# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1349126329 14400
#      Mon Oct 01 17:18:49 2012 -0400
# Branch stable
# Node ID d174210ce1ec47ce6eb4ecb3c723aa26b62a338e
# Parent  c9954a15bc030932c945e8ad4fc52fb9eebd1e84
use ' instead of ` in error messages, warnings and most comments

* intro.txi, io.txi, munge-texi.cc, octave.texi, cmd-edit.cc,
data-conv.cc, file-ops.cc, glob-match.h, kpse.cc, oct-env.cc,
oct-locbuf.h, oct-md5.cc, oct-rand.cc, general/interp2.m, doc.m,
get_first_help_sentence.m, help.m, print_usage.m,
__additional_help_message__.m, type.m, unimplemented.m, which.m,
cast.m, dir.m, license.m, mkoctfile.m, recycle.m, tempdir.m,
optimset.m, pkg/pkg.m, closereq.m, colstyle.m, __fltk_print__.m,
__gnuplot_print__.m, __go_draw_figure__.m, __pie__.m, __pltopt__.m,
__print_parse_opts__.m, uigetdir.m, uigetfile.m, uiputfile.m, stft.m,
mean.m, anova.m, cor_test.m, t_test_regression.m, __magick_read__.cc,
dlmread.cc, schur.cc, data.cc, debug.cc, defun-dld.h, defun.cc,
defun.h, dynamic-ld.cc, error.cc, error.h, gl-render.cc, graphics.cc,
gripes.cc, input.cc, lex.ll, load-path.cc, load-save.cc, ls-hdf5.cc,
ls-mat-ascii.cc, ls-mat4.cc, ls-mat5.cc, ls-oct-ascii.cc,
ls-oct-binary.cc, oct-hist.cc, oct-parse.yy, oct-stream.cc,
oct-stream.h, octave.cc, ov-base-diag.cc, ov-base.cc, ov-class.cc,
ov-colon.h, ov-struct.cc, ov-typeinfo.cc, ov.cc, pager.cc,
pr-output.cc, pt-binop.cc, pt-eval.cc, pt-id.cc, pt-idx.cc,
pt-misc.cc, pt-unop.cc, symtab.cc, symtab.h, toplev.cc, txt-eng-ft.cc,
utils.cc, variables.cc, test_eval-catch.m, test_try.m:
Use ' instead of ` in error messages, warnings, and most comments.

diff --git a/doc/interpreter/intro.txi b/doc/interpreter/intro.txi
--- a/doc/interpreter/intro.txi
+++ b/doc/interpreter/intro.txi
@@ -519,17 +519,17 @@ printf ("foo %s\n", "bar")
 
 Some examples signal errors.  This normally displays an error message
 on your terminal.  Error messages are shown on a line beginning with
 @code{error:}.
 
 @example
 @group
 fieldnames ([1, 2; 3, 4])
-error: fieldnames: wrong type argument `matrix'
+error: fieldnames: wrong type argument 'matrix'
 @end group
 @end example
 
 @node Format of Descriptions
 @subsection Format of Descriptions
 @cindex description format
 
 Functions, commands, and variables are described in this manual in a 
diff --git a/doc/interpreter/io.txi b/doc/interpreter/io.txi
--- a/doc/interpreter/io.txi
+++ b/doc/interpreter/io.txi
@@ -403,27 +403,27 @@ output stream as-is, while @dfn{conversi
 a @samp{%} character in the template cause subsequent arguments to be
 formatted and written to the output stream.  For example,
 @cindex conversion specifications (@code{printf})
 
 @example
 @group
 pct = 37;
 filename = "foo.txt";
-printf ("Processed %d%% of `%s'.\nPlease be patient.\n",
+printf ("Processed %d%% of '%s'.\nPlease be patient.\n",
         pct, filename);
 @end group
 @end example
 
 @noindent
 produces output like
 
 @example
 @group
-Processed 37% of `foo.txt'.
+Processed 37% of 'foo.txt'.
 Please be patient.
 @end group
 @end example
 
 This example shows the use of the @samp{%d} conversion to specify that a
 scalar argument should be printed in decimal notation, the @samp{%s}
 conversion to specify printing of a string argument, and the @samp{%%}
 conversion to print a literal @samp{%} character.
@@ -693,17 +693,17 @@ The @samp{%g} and @samp{%G} conversions 
 of @samp{%e} or @samp{%E} (respectively) if the exponent would be less
 than -4 or greater than or equal to the precision; otherwise they use the
 @samp{%f} style.  Trailing zeros are removed from the fractional portion
 of the result and a decimal-point character appears only if it is
 followed by a digit.
 
 The following flags can be used to modify the behavior:
 
-@c Not @samp so we can have ` ' as an item.
+@c Not @samp so we can have ' ' as an item.
 @table @asis
 @item @samp{-}
 Left-justify the result in the field.  Normally the result is
 right-justified.
 
 @item @samp{+}
 Always include a plus or minus sign in the result.
 
diff --git a/doc/interpreter/munge-texi.cc b/doc/interpreter/munge-texi.cc
--- a/doc/interpreter/munge-texi.cc
+++ b/doc/interpreter/munge-texi.cc
@@ -312,17 +312,17 @@ process_texi_input_file (std::istream& i
 
                           if (doc_string.substr (j, 15) == "-*- texinfo -*-")
                             {
                               j += 15;
 
                               while (isspace (doc_string[j]))
                                 j++;
 
-                              // Make `see also' references in functions
+                              // Make 'see also' references in functions
                               // possible using @anchor{TAG} (new with
                               // Texinfo 4.0).
 
                               if (symbol_name[0] == '@')
                                 symbol_name = "@" + symbol_name;
 
                               os << "@anchor{doc-" << symbol_name << "}\n";
 
diff --git a/doc/interpreter/octave.texi b/doc/interpreter/octave.texi
--- a/doc/interpreter/octave.texi
+++ b/doc/interpreter/octave.texi
@@ -15,17 +15,17 @@
 % You should have received a copy of the GNU General Public License
 % along with Octave; see the file COPYING.  If not, see
 % <http://www.gnu.org/licenses/>.
 
 \input texinfo
 @setfilename octave.info
 
 @c The following macro is used for the on-line help system, but we don't
-@c want lots of `See also: foo, bar, and baz' strings cluttering the
+@c want lots of 'See also: foo, bar, and baz' strings cluttering the
 @c printed manual (that information should be in the supporting text for
 @c each group of functions and variables).
 
 @macro seealso {args}
 @iftex
 @vskip 2pt
 @end iftex
 @ifnottex
@@ -42,17 +42,17 @@
 @c spellchecking.  Within Texinfo it has no effect as it merely replaces
 @c the macro call with the argument itself.
 
 @macro nospell {arg}
 \arg\
 @end macro
 
 @c The following macro works around a situation where the Info/plain text
-@c expansion of the @code{XXX} macro is `XXX'.  The use of the apostrophe
+@c expansion of the @code{XXX} macro is 'XXX'.  The use of the apostrophe
 @c can be confusing if the code segment itself ends with a transpose operator.
 @ifinfo
 @macro xcode{arg}
 \arg\
 @end macro
 @end ifinfo
 @ifnotinfo
 @macro xcode{arg}
diff --git a/liboctave/cmd-edit.cc b/liboctave/cmd-edit.cc
--- a/liboctave/cmd-edit.cc
+++ b/liboctave/cmd-edit.cc
@@ -1271,17 +1271,17 @@ command_editor::filename_quoting_desired
 }
 
 // Return a string which will be printed as a prompt.  The string may
 // contain special characters which are decoded as follows:
 //
 //      \a      bell (ascii 07)
 //      \d      the date
 //      \e      escape (ascii 033)
-//      \h      the hostname up to the first `.'
+//      \h      the hostname up to the first '.'
 //      \H      the hostname
 //      \n      CRLF
 //      \r      CR
 //      \s      the name of the shell (program)
 //      \t      the time
 //      \T      the time in 12-hour hh:mm:ss format
 //      \@      the time in 12-hour hh:mm am/pm format
 //      \A      the time in 24-hour hh:mm format
diff --git a/liboctave/data-conv.cc b/liboctave/data-conv.cc
--- a/liboctave/data-conv.cc
+++ b/liboctave/data-conv.cc
@@ -285,17 +285,17 @@ oct_data_conv::string_to_data_type
           if (s[pos] == '*')
             {
               block_size = atoi (s.c_str ());
               s = s.substr (pos+1);
             }
           else
             {
               (*current_liboctave_error_handler)
-                ("invalid repeat count in `%s'", str.c_str ());
+                ("invalid repeat count in '%s'", str.c_str ());
 
               return;
             }
         }
     }
 
   pos = s.find ('=');
 
@@ -358,17 +358,17 @@ oct_data_conv::string_to_data_type
       if (s[pos] == '*')
         {
           block_size = atoi (s.c_str ());
           s = s.substr (pos+1);
         }
       else
         {
           (*current_liboctave_error_handler)
-            ("invalid repeat count in `%s'", str.c_str ());
+            ("invalid repeat count in '%s'", str.c_str ());
 
           return;
         }
     }
 
   output_type = string_to_data_type (s);
 }
 
@@ -846,17 +846,17 @@ do_double_format_conversion (void *data,
         default:
           gripe_unrecognized_float_fmt ();
           break;
         }
       break;
 
     default:
       (*current_liboctave_error_handler)
-        ("impossible state reached in file `%s' at line %d",
+        ("impossible state reached in file '%s' at line %d",
          __FILE__, __LINE__);
       break;
     }
 }
 
 void
 do_float_format_conversion (void *data, octave_idx_type len,
                             oct_mach_info::float_format from_fmt,
@@ -973,17 +973,17 @@ do_float_format_conversion (void *data, 
         default:
           gripe_unrecognized_float_fmt ();
           break;
         }
       break;
 
     default:
       (*current_liboctave_error_handler)
-        ("impossible state reached in file `%s' at line %d",
+        ("impossible state reached in file '%s' at line %d",
          __FILE__, __LINE__);
       break;
     }
 }
 
 void
 do_float_format_conversion (void *data, size_t sz, octave_idx_type len,
                             oct_mach_info::float_format from_fmt,
@@ -996,17 +996,17 @@ do_float_format_conversion (void *data, 
       break;
 
     case sizeof (double):
       do_double_format_conversion (data, len, from_fmt, to_fmt);
       break;
 
     default:
       (*current_liboctave_error_handler)
-        ("impossible state reached in file `%s' at line %d",
+        ("impossible state reached in file '%s' at line %d",
          __FILE__, __LINE__);
       break;
     }
 }
 
 
 void
 read_doubles (std::istream& is, double *data, save_type type,
diff --git a/liboctave/file-ops.cc b/liboctave/file-ops.cc
--- a/liboctave/file-ops.cc
+++ b/liboctave/file-ops.cc
@@ -112,23 +112,23 @@ file_ops::tilde_expansion_hook file_ops:
 // If non-null, this contains the address of a function to call if the
 // standard meaning for expanding a tilde fails.  The function is
 // called with the text (sans tilde, as in "foo"), and returns a
 // malloc()'ed string which is the expansion, or a NULL pointer if
 // there is no expansion.
 file_ops::tilde_expansion_hook file_ops::tilde_expansion_failure_hook = 0;
 
 // When non-null, this is a NULL terminated array of strings which are
-// duplicates for a tilde prefix.  Bash uses this to expand `=~' and
-// `:~'.
+// duplicates for a tilde prefix.  Bash uses this to expand '=~' and
+// ':~'.
 string_vector file_ops::tilde_additional_prefixes = default_prefixes;
 
 // When non-null, this is a NULL terminated array of strings which
 // match the end of a username, instead of just "/".  Bash sets this
-// to `:' and `=~'.
+// to ':' and '=~'.
 string_vector file_ops::tilde_additional_suffixes = default_suffixes;
 
 // Find the start of a tilde expansion in S, and return the index
 // of the tilde which starts the expansion.  Place the length of the
 // text which identified this tilde starter in LEN, excluding the
 // tilde itself.
 
 static size_t
@@ -216,17 +216,17 @@ isolate_tilde_prefix (const std::string&
 static std::string
 tilde_expand_word (const std::string& filename)
 {
   size_t f_len = filename.length ();
 
   if (f_len == 0 || filename[0] != '~')
     return filename;
 
-  // A leading `~/' or a bare `~' is *always* translated to the value
+  // A leading '~/' or a bare '~' is *always* translated to the value
   // of $HOME or the home directory of the current user, regardless of
   // any preexpansion hook.
 
   if (f_len == 1 || file_ops::is_dir_sep (filename[1]))
     return octave_env::get_home_directory () + filename.substr (1);
 
   std::string username = isolate_tilde_prefix (filename);
 
diff --git a/liboctave/glob-match.h b/liboctave/glob-match.h
--- a/liboctave/glob-match.h
+++ b/liboctave/glob-match.h
@@ -31,19 +31,19 @@ along with Octave; see the file COPYING.
 class
 OCTAVE_API
 glob_match
 {
 public:
 
   enum opts
   {
-    pathname = 1,  // No wildcard can ever match `/'.
+    pathname = 1,  // No wildcard can ever match '/'.
     noescape = 2,  // Backslashes don't quote special chars.
-    period = 4     // Leading `.' is matched only explicitly.
+    period = 4     // Leading '.' is matched only explicitly.
   };
 
   glob_match (const std::string& p,
               unsigned int xopts = pathname|noescape|period)
     : pat (p), fnmatch_flags (opts_to_fnmatch_flags (xopts)) { }
 
   glob_match (const string_vector& p = string_vector (),
               unsigned int xopts = pathname|noescape|period)
diff --git a/liboctave/kpse.cc b/liboctave/kpse.cc
--- a/liboctave/kpse.cc
+++ b/liboctave/kpse.cc
@@ -52,27 +52,27 @@ extern "C" {
 #ifndef _MSC_VER
 #define __STDC__ 1
 #include "win32lib.h"
 #endif
 #endif /* not WIN32 */
 
 #ifdef __DJGPP__
 #include <fcntl.h>      /* for long filenames' stuff */
-#include <dir.h>        /* for `getdisk' */
-#include <io.h>         /* for `setmode' */
+#include <dir.h>        /* for 'getdisk' */
+#include <io.h>         /* for 'setmode' */
 #endif
 }
 
 /* Some drivers have partially integrated kpathsea changes.  */
 #ifndef KPATHSEA
 #define KPATHSEA 32
 #endif
 
-/* System dependencies that are figured out by `configure'.  If we are
+/* System dependencies that are figured out by 'configure'.  If we are
    compiling standalone, we get our c-auto.h.  Otherwise, the package
    containing us must provide this (unless it can somehow generate ours
    from c-auto.in).  We use <...> instead of "..." so that the current
    cpp directory (i.e., kpathsea/) won't be searched. */
 
 /* If you want to find subdirectories in a directory with non-Unix
    semantics (specifically, if a directory with no subdirectories does
    not have exactly two links), define this.  */
@@ -106,17 +106,17 @@ extern "C" {
 #define DIR_SEP '/'
 #define DIR_SEP_STRING "/"
 #endif /* not DOSISH */
 #endif /* not DIR_SEP */
 
 #ifndef IS_DIR_SEP
 #define IS_DIR_SEP(ch) ((ch) == DIR_SEP)
 #endif
-#ifndef IS_DEVICE_SEP /* No `devices' on, e.g., Unix.  */
+#ifndef IS_DEVICE_SEP /* No 'devices' on, e.g., Unix.  */
 #define IS_DEVICE_SEP(ch) 0
 #endif
 #ifndef NAME_BEGINS_WITH_DEVICE
 #define NAME_BEGINS_WITH_DEVICE(name) 0
 #endif
 
 #include "lo-error.h"
 #include "oct-env.h"
@@ -272,17 +272,17 @@ static unsigned int kpathsea_debug = 0;
 
 /* ============================================================ */
 
 #endif /* WIN32 */
 
 /* Define common sorts of messages.  */
 
 /* This should be called only after a system call fails.  Don't exit
-   with status `errno', because that might be 256, which would mean
+   with status 'errno', because that might be 256, which would mean
    success (exit statuses are truncated to eight bits).  */
 #define FATAL_PERROR(str) \
   do \
     { \
       gnulib::fputs ("pathsearch: ", stderr); \
       perror (str); exit (EXIT_FAILURE); \
     } \
   while (0)
@@ -335,17 +335,17 @@ static str_llist_type *kpse_element_dirs
 static std::string kpse_expand (const std::string& s);
 
 static std::string kpse_expand_default (const std::string& path,
                                         const std::string& dflt);
 
 static string_vector kpse_db_search (const std::string& name,
                                      const std::string& path_elt, bool all);
 
-#include <ctime> /* for `time' */
+#include <ctime> /* for 'time' */
 
 static bool
 kpse_is_env_sep (char c)
 {
   return IS_ENV_SEP (c);
 }
 
 /* These routines just check the return status from standard library
@@ -707,17 +707,17 @@ log_search (const string_vector& filenam
 
           /* Only record absolute filenames, for privacy.  */
           if (log_file && kpse_absolute_p (filename.c_str (), false))
             gnulib::fprintf (log_file, "%lu %s\n",
                      static_cast<unsigned long> (time (0)),
                      filename.c_str ());
 
           /* And show them online, if debugging.  We've already started
-             the debugging line in `search', where this is called, so
+             the debugging line in 'search', where this is called, so
              just print the filename here, don't use DEBUGF.  */
           if (KPSE_DEBUG_P (KPSE_DEBUG_SEARCH))
             gnulib::fputs (filename.c_str (), stderr);
         }
     }
 }
 
 /* Concatenate each element in DIRS with NAME (assume each ends with a
@@ -764,17 +764,17 @@ dir_list_search (str_llist_type *dirs, c
    readable, return (a list containing) it; otherwise, return NULL.  */
 
 static string_vector
 absolute_search (const std::string& name)
 {
   string_vector ret_list;
   std::string found = kpse_readable_file (name);
 
-  /* Add `found' to the return list even if it's null; that tells
+  /* Add 'found' to the return list even if it's null; that tells
      the caller we didn't find anything.  */
   ret_list.append (found);
 
   return ret_list;
 }
 
 /* This is the hard case -- look for NAME in PATH.  If ALL is false,
    return the first file found.  Otherwise, search all elements of PATH.  */
@@ -826,18 +826,18 @@ path_search (const std::string& path, co
       found = first_search
         ? string_vector () : kpse_db_search (name, elt, all);
 
       /* Search the filesystem if (1) the path spec allows it, and either
          (2a) we are searching for texmf.cnf ; or
          (2b) no db exists; or
          (2c) no db's are relevant to this elt; or
          (3) MUST_EXIST && NAME was not in the db.
-         In (2*), `found' will be NULL.
-         In (3),  `found' will be an empty list. */
+         In (2*), 'found' will be NULL.
+         In (3),  'found' will be an empty list. */
 
       if (allow_disk_search && found.empty ())
         {
           str_llist_type *dirs = kpse_element_dirs (elt);
 
           if (dirs && *dirs)
             found = dir_list_search (dirs, name, all);
         }
@@ -908,17 +908,17 @@ search (const std::string& path, const s
         gnulib::putc ('\n', stderr);
     }
 
   return ret_list;
 }
 
 /* Search PATH for the first NAME.  */
 
-/* Call `kpse_expand' on NAME.  If the result is an absolute or
+/* Call 'kpse_expand' on NAME.  If the result is an absolute or
    explicitly relative filename, check whether it is a readable
    (regular) file.
 
    Otherwise, look in each of the directories specified in PATH (also do
    tilde and variable expansion on elements in PATH), using a prebuilt
    db (see db.h) if it's relevant for a given path element.
 
    If the prebuilt db doesn't exist, or if MUST_EXIST is true and NAME
@@ -936,19 +936,19 @@ kpse_path_search (const std::string& pat
                   bool must_exist)
 {
   string_vector ret_list = search (path, name, must_exist, false);
 
   return ret_list.empty () ? std::string () : ret_list[0];
 }
 
 /* Search all elements of PATH for files named NAME.  Not sure if it's
-   right to assert `must_exist' here, but it suffices now.  */
-
-/* Like `kpse_path_search' with MUST_EXIST true, but return a list of
+   right to assert 'must_exist' here, but it suffices now.  */
+
+/* Like 'kpse_path_search' with MUST_EXIST true, but return a list of
    all the filenames (or NULL if none), instead of taking the first.  */
 
 static string_vector
 kpse_all_path_search (const std::string& path, const std::string& name)
 {
   return search (path, name, true, true);
 }
 
@@ -1022,18 +1022,18 @@ path_find_first_of (const std::string& p
               /* Search the filesystem if (1) the path spec allows it,
                  and either
 
                    (2a) we are searching for texmf.cnf ; or
                    (2b) no db exists; or
                    (2c) no db's are relevant to this elt; or
                    (3) MUST_EXIST && NAME was not in the db.
 
-                 In (2*), `found' will be NULL.
-                 In (3),  `found' will be an empty list. */
+                 In (2*), 'found' will be NULL.
+                 In (3),  'found' will be an empty list. */
 
               if (allow_disk_search && found.empty ())
                 {
                   static str_llist_type *tmp = 0;
 
                   if (! tmp)
                     {
                       tmp = new str_llist_type;
@@ -1158,17 +1158,17 @@ kpse_path_find_first_of (const std::stri
   string_vector ret_list = find_first_of (path, names, must_exist, false);
 
   return ret_list.empty () ? std::string () : ret_list[0];
 }
 
 /* Search each element of PATH for each element of NAMES and return a
    list containing everything found, in the order found.  */
 
-/* Like `kpse_path_find_first_of' with MUST_EXIST true, but return a
+/* Like 'kpse_path_find_first_of' with MUST_EXIST true, but return a
    list of all the filenames (or NULL if none), instead of taking the
    first.  */
 
 static string_vector
 kpse_all_path_find_first_of (const std::string& path,
                              const string_vector& names)
 {
   return find_first_of (path, names, true, true);
@@ -1188,28 +1188,28 @@ kpse_tilde_expand (const std::string& na
 {
   std::string expansion;
 
   /* If no leading tilde, do nothing.  */
   if (name.empty () || name[0] != '~')
     {
       expansion = name;
 
-      /* If a bare tilde, return the home directory or `.'.  (Very
+      /* If a bare tilde, return the home directory or '.'.  (Very
          unlikely that the directory name will do anyone any good, but
          ...  */
     }
   else if (name.length () == 1)
     {
       expansion = octave_env::getenv ("HOME");
 
       if (expansion.empty ())
         expansion = ".";
 
-      /* If `~/', remove any trailing / or replace leading // in $HOME.
+      /* If '~/', remove any trailing / or replace leading // in $HOME.
          Should really check for doubled intermediate slashes, too.  */
     }
   else if (IS_DIR_SEP (name[1]))
     {
       unsigned c = 1;
       std::string home = octave_env::getenv ("HOME");
 
       if (home.empty ())
@@ -1222,35 +1222,35 @@ kpse_tilde_expand (const std::string& na
         home = home.substr (1);
 
       /* omit / after ~ */
       if (IS_DIR_SEP (home[home_len - 1]))
         c++;
 
       expansion = home + name.substr (c);
 
-      /* If `~user' or `~user/', look up user in the passwd database (but
+      /* If '~user' or '~user/', look up user in the passwd database (but
          OS/2 doesn't have this concept.  */
     }
   else
 #ifdef HAVE_PWD_H
     {
       unsigned c = 2;
 
       /* find user name */
       while (name.length () > c && ! IS_DIR_SEP (name[c]))
         c++;
 
       std::string user = name.substr (1, c-1);
 
       /* We only need the cast here for (deficient) systems
-         which do not declare `getpwnam' in <pwd.h>.  */
+         which do not declare 'getpwnam' in <pwd.h>.  */
       octave_passwd p = octave_passwd::getpwnam (user);
 
-      /* If no such user, just use `.'.  */
+      /* If no such user, just use '.'.  */
       std::string home = p ? p.dir () : std::string (".");
 
       if (home.empty ())
         home = ".";
 
       /* handle leading // */
       if (home.length () > 1 && IS_DIR_SEP (home[0]) && IS_DIR_SEP (home[1]))
         home = home.substr (1);
@@ -1352,21 +1352,21 @@ kpse_brace_expand_element (const std::st
       ret += x + ENV_SEP_STRING;
     }
 
   ret.resize (ret.length () - 1);
 
   return ret;
 }
 
-/* Do brace expansion and call `kpse_expand' on each element of the
+/* Do brace expansion and call 'kpse_expand' on each element of the
    result; return the final expansion (always in fresh memory, even if
-   no expansions were done).  We don't call `kpse_expand_default'
+   no expansions were done).  We don't call 'kpse_expand_default'
    because there is a whole sequence of defaults to run through; see
-   `kpse_init_format'.  */
+   'kpse_init_format'.  */
 
 static std::string
 kpse_brace_expand (const std::string& path)
 {
   /* Must do variable expansion first because if we have
        foo = .:~
        TEXINPUTS = $foo
      we want to end up with TEXINPUTS = .:/home/karl.
@@ -1390,18 +1390,18 @@ kpse_brace_expand (const std::string& pa
     ret.resize (len-1);
 
   return kpse_expand_kpse_dot (ret);
 }
 
 /* Expand all special constructs in a path, and include only the actually
    existing directories in the result. */
 
-/* Do brace expansion and call `kpse_expand' on each argument of the
-   result, then expand any `//' constructs.  The final expansion (always
+/* Do brace expansion and call 'kpse_expand' on each argument of the
+   result, then expand any '//' constructs.  The final expansion (always
    in fresh memory) is a path of all the existing directories that match
    the pattern. */
 
 static std::string
 kpse_path_expand (const std::string& path)
 {
   std::string ret;
   unsigned len;
@@ -1667,18 +1667,18 @@ brace_gobbler (const std::string& text, 
           /* We ignore an open brace surrounded by whitespace, and also
              an open brace followed immediately by a close brace, that
              was preceded with whitespace.  */
           if (c == '{' &&
               ((i == 0 || brace_whitespace (text[i-1])) &&
                (i+1 < text_len &&
                 (brace_whitespace (text[i+1]) || text[i+1] == '}'))))
             continue;
-          /* If this is being compiled as part of bash, ignore the `{'
-             in a `${}' construct */
+          /* If this is being compiled as part of bash, ignore the '{'
+             in a '${}' construct */
           if ((c != '{') || i == 0 || (text[i-1] != '$'))
             break;
         }
 
       if (c == '{')
         level++;
       else if (c == '}' && level)
         level--;
@@ -1710,18 +1710,18 @@ struct kpse_format_info_type
   std::string path_source;   /* Where the path started from.  */
   std::string override_path; /* From client environment variable.  */
   std::string client_path;   /* E.g., from dvips's config.ps.  */
   std::string cnf_path;      /* From texmf.cnf.  */
   std::string default_path;  /* If all else fails.  */
   string_vector suffix;      /* For kpse_find_file to check for/append.  */
 };
 
-/* The sole variable of that type, indexed by `kpse_file_format_type'.
-   Initialized by calls to `kpse_find_file' for `kpse_init_format'.  */
+/* The sole variable of that type, indexed by 'kpse_file_format_type'.
+   Initialized by calls to 'kpse_find_file' for 'kpse_init_format'.  */
 static kpse_format_info_type kpse_format_info;
 
 /* And EXPAND_DEFAULT calls kpse_expand_default on try_path and the
    present info->path.  */
 #define EXPAND_DEFAULT(try_path, source_string) \
   do \
     { \
       if (! try_path.empty ()) \
@@ -1789,21 +1789,21 @@ match (const std::string& filename_arg, 
         /* normal character nonmatch, quit */
         break;
     }
 
   /* If we've reached the end of PATH_ELT, check that we're at the last
      component of FILENAME, we've matched.  */
   if (! matched && *path_elt == 0)
     {
-      /* Probably PATH_ELT ended with `vf' or some such, and FILENAME
-         ends with `vf/ptmr.vf'.  In that case, we'll be at a
+      /* Probably PATH_ELT ended with 'vf' or some such, and FILENAME
+         ends with 'vf/ptmr.vf'.  In that case, we'll be at a
          directory separator.  On the other hand, if PATH_ELT ended
-         with a / (as in `vf/'), FILENAME being the same `vf/ptmr.vf',
-         we'll be at the `p'.  Upshot: if we're at a dir separator in
+         with a / (as in 'vf/'), FILENAME being the same 'vf/ptmr.vf',
+         we'll be at the 'p'.  Upshot: if we're at a dir separator in
          FILENAME, skip it.  But if not, that's ok, as long as there
          are no more dir separators.  */
 
       if (IS_DIR_SEP (*filename))
         filename++;
 
       while (*filename && !IS_DIR_SEP (*filename))
         filename++;
@@ -1870,32 +1870,32 @@ kpse_db_search (const std::string& name_
   std::string name = name_arg;
 
   /* If we failed to build the database (or if this is the recursive
      call to build the db path), quit.  */
   if (! db.buckets)
     return ret;
 
   /* When tex-glyph.c calls us looking for, e.g., dpi600/cmr10.pk, we
-     won't find it unless we change NAME to just `cmr10.pk' and append
-     `/dpi600' to PATH_ELT.  We are justified in using a literal `/'
+     won't find it unless we change NAME to just 'cmr10.pk' and append
+     '/dpi600' to PATH_ELT.  We are justified in using a literal '/'
      here, since that's what tex-glyph.c unconditionally uses in
      DPI_BITMAP_SPEC.  But don't do anything if the / begins NAME; that
      should never happen.  */
   std::string path_elt;
   size_t last_slash = name.rfind ('/');
   if (last_slash != std::string::npos && last_slash != 0)
     {
       std::string dir_part = name.substr (0, last_slash);
       name = name.substr (last_slash + 1);
     }
   else
     path_elt = orig_path_elt;
 
-  /* Don't bother doing any lookups if this `path_elt' isn't covered by
+  /* Don't bother doing any lookups if this 'path_elt' isn't covered by
      any of database directories.  We do this not so much because the
      extra couple of hash lookups matter -- they don't -- but rather
      because we want to return NULL in this case, so path_search can
      know to do a disk search.  */
   for (int e = 0; ! relevant && e < db_dir_list.length (); e++)
     relevant = elt_in_db (db_dir_list[e], path_elt);
 
   if (! relevant)
@@ -1913,17 +1913,17 @@ kpse_db_search (const std::string& name_
   aliases[0] = name;
 
   done = false;
   len = aliases.length ();
   for (int i = 0; i < len && !done; i++)
     {
       std::string atry = aliases[i];
 
-      /* We have an ls-R db.  Look up `atry'.  */
+      /* We have an ls-R db.  Look up 'atry'.  */
       string_vector db_dirs = hash_lookup (db, atry);
 
       /* For each filename found, see if it matches the path element.  For
          example, if we have .../cx/cmr10.300pk and .../ricoh/cmr10.300pk,
          and the path looks like .../cx, we don't want the ricoh file.  */
 
       int db_dirs_len = db_dirs.length ();
       for (int j = 0; j < db_dirs_len && !done; j++)
@@ -1943,18 +1943,18 @@ kpse_db_search (const std::string& name_
               std::string found;
               std::string tmp = kpse_readable_file (db_file);
               if (! tmp.empty ())
                 found = db_file;
               else
                 {
                   /* The hit in the DB doesn't exist in disk.  Now try
                      all its aliases.  For example, suppose we have a
-                     hierarchy on CD, thus `mf.bas', but ls-R contains
-                     `mf.base'.  Find it anyway.  Could probably work
+                     hierarchy on CD, thus 'mf.bas', but ls-R contains
+                     'mf.base'.  Find it anyway.  Could probably work
                      around this with aliases, but this is pretty easy
                      and shouldn't hurt.  The upshot is that if one of
                      the aliases actually exists, we use that.  */
 
                   int aliases_len = aliases.length ();
 
                   for (int k = 1; k < aliases_len && found.empty (); k++)
                     {
@@ -2224,18 +2224,18 @@ do_subdir (str_llist_type *str_list_ptr,
     return;
 
   /* Include top level before subdirectories, if nothing to match.  */
   if (post.empty ())
     dir_list_add (str_list_ptr, name);
   else
     {
       /* If we do have something to match, see if it exists.  For
-         example, POST might be `pk/ljfour', and they might have a
-         directory `$TEXMF/fonts/pk/ljfour' that we should find.  */
+         example, POST might be 'pk/ljfour', and they might have a
+         directory '$TEXMF/fonts/pk/ljfour' that we should find.  */
       name += post;
       expand_elt (str_list_ptr, name, elt_length);
       name.resize (elt_length);
     }
 
   proceed = 1;
 
   while (proceed)
@@ -2270,26 +2270,26 @@ do_subdir (str_llist_type *str_list_ptr,
     return;
 
   /* Include top level before subdirectories, if nothing to match.  */
   if (post.empty ())
     dir_list_add (str_list_ptr, name);
   else
     {
       /* If we do have something to match, see if it exists.  For
-         example, POST might be `pk/ljfour', and they might have a
-         directory `$TEXMF/fonts/pk/ljfour' that we should find.  */
+         example, POST might be 'pk/ljfour', and they might have a
+         directory '$TEXMF/fonts/pk/ljfour' that we should find.  */
       name += post;
       expand_elt (str_list_ptr, name, elt_length);
       name.resize (elt_length);
     }
 
   while ((e = gnulib::readdir (dir)))
     {
-      /* If it begins with a `.', never mind.  (This allows ``hidden''
+      /* If it begins with a '.', never mind.  (This allows "hidden"
          directories that the algorithm won't find.)  */
 
       if (e->d_name[0] != '.')
         {
           int links;
 
           /* Construct the potential subdirectory name.  */
           name += e->d_name;
@@ -2322,17 +2322,17 @@ do_subdir (str_llist_type *str_list_ptr,
 #ifdef ST_NLINK_TRICK
               else if (post.empty ())
                 /* Nothing to match, no recursive subdirectories to
                    look for: we're done with this branch.  Add it.  */
                 dir_list_add (str_list_ptr, name);
 #endif
             }
 
-          /* Remove the directory entry we just checked from `name'.  */
+          /* Remove the directory entry we just checked from 'name'.  */
           name.resize (elt_length);
         }
     }
 
   xclosedir (dir);
 #endif /* not WIN32 */
 }
 
@@ -2384,17 +2384,17 @@ expand_elt (str_llist_type *str_list_ptr
 /* Here is the entry point.  Returns directory list for ELT.  */
 
 /* Given a path element ELT, return a pointer to a NULL-terminated list
    of the corresponding (existing) directory or directories, with
    trailing slashes, or NULL.  If ELT is the empty string, check the
    current working directory.
 
    It's up to the caller to expand ELT.  This is because this routine is
-   most likely only useful to be called from `kpse_path_search', which
+   most likely only useful to be called from 'kpse_path_search', which
    has already assumed expansion has been done.  */
 
 static str_llist_type *
 kpse_element_dirs (const std::string& elt)
 {
   str_llist_type *ret;
 
   /* If given nothing, return nothing.  */
@@ -2489,30 +2489,30 @@ str_llist_float (str_llist_type *l, str_
      guaranteed this will terminate, since MOVER itself is currently
      unmoved, and it must be in L (by hypothesis).  */
   for (last_moved = 0, unmoved = *l; STR_LLIST_MOVED (*unmoved);
        last_moved = unmoved, unmoved = STR_LLIST_NEXT (*unmoved))
     ;
 
   /* If we are the first unmoved element, nothing to relink.  */
   if (unmoved != mover)
-    { /* Remember `mover's current successor, so we can relink `mover's
+    { /* Remember 'mover's current successor, so we can relink 'mover's
          predecessor to it.  */
       str_llist_elt_type *before_mover;
       str_llist_elt_type *after_mover = STR_LLIST_NEXT (*mover);
 
-      /* Find `mover's predecessor.  */
+      /* Find 'mover's predecessor.  */
       for (before_mover = unmoved; STR_LLIST_NEXT (*before_mover) != mover;
            before_mover = STR_LLIST_NEXT (*before_mover))
         ;
 
-      /* `before_mover' now links to `after_mover'.  */
+      /* 'before_mover' now links to 'after_mover'.  */
       STR_LLIST_NEXT (*before_mover) = after_mover;
 
-      /* Insert `mover' before `unmoved' and after `last_moved' (or at
+      /* Insert 'mover' before 'unmoved' and after 'last_moved' (or at
          the head of the list).  */
       STR_LLIST_NEXT (*mover) = unmoved;
       if (! last_moved)
         *l = mover;
       else
         STR_LLIST_NEXT (*last_moved) = mover;
     }
 
@@ -2540,27 +2540,27 @@ expanding (const std::string& var, bool 
 
 static bool
 expanding_p (const std::string& var)
 {
   return (expansions.find (var) != expansions.end ())
     ? expansions[var] : false;
 }
 
-/* Append the result of value of `var' to EXPANSION, where `var' begins
-   at START and ends at END.  If `var' is not set, do not complain.
+/* Append the result of value of 'var' to EXPANSION, where 'var' begins
+   at START and ends at END.  If 'var' is not set, do not complain.
    This is a subroutine for the more complicated expansion function.  */
 
 static void
 expand (std::string &expansion, const std::string& var)
 {
   if (expanding_p (var))
     {
       (*current_liboctave_warning_handler)
-        ("kpathsea: variable `%s' references itself (eventually)",
+        ("kpathsea: variable '%s' references itself (eventually)",
          var.c_str ());
     }
   else
     {
       /* Check for an environment variable.  */
       std::string value = octave_env::getenv (var);
 
       if (! value.empty ())
@@ -2600,17 +2600,17 @@ kpse_var_expand (const std::string& src)
 
   /* Copy everything but variable constructs.  */
   for (size_t i = 0; i < src_len; i++)
     {
       if (IS_VAR_START (src[i]))
         {
           i++;
 
-          /* Three cases: `$VAR', `${VAR}', `$<anything-else>'.  */
+          /* Three cases: '$VAR', '${VAR}', '$<anything-else>'.  */
           if (IS_VAR_CHAR (src[i]))
             {
               /* $V: collect name constituents, then expand.  */
               size_t var_end = i;
 
               do
                 {
                   var_end++;
@@ -2641,17 +2641,17 @@ kpse_var_expand (const std::string& src)
                   expand (expansion, src.substr (i, var_end - i));
                   i = var_end; /* will incr past } at top of loop*/
                 }
             }
           else
             {
               /* $<something-else>: error.  */
               (*current_liboctave_warning_handler)
-                ("%s: Unrecognized variable construct `$%c'",
+                ("%s: Unrecognized variable construct '$%c'",
                  src.c_str (), src[i]);
 
               /* Just ignore those chars and keep going.  */
             }
         }
       else
         expansion += src[i];
     }
diff --git a/liboctave/oct-env.cc b/liboctave/oct-env.cc
--- a/liboctave/oct-env.cc
+++ b/liboctave/oct-env.cc
@@ -229,17 +229,17 @@ octave_env::do_set_program_name (const s
     = prog_invocation_name.find_last_of (file_ops::dir_sep_chars ());
 
   // Also keep a shortened version of the program name.
   prog_name = (pos == std::string::npos)
     ? prog_invocation_name : prog_invocation_name.substr (pos+1);
 }
 
 // Return a pretty pathname.  If the first part of the pathname is the
-// same as $HOME, then replace that with `~'.
+// same as $HOME, then replace that with '~'.
 
 std::string
 octave_env::do_polite_directory_format (const std::string& name) const
 {
   std::string retval;
 
   std::string home_dir = do_get_home_directory ();
 
@@ -296,17 +296,17 @@ octave_env::do_rooted_relative_pathname 
     return true;
 
   if (len > 2 && s[0] == '.' && s[1] == '.' && file_ops::is_dir_sep (s[2]))
     return true;
 
   return false;
 }
 
-// Return the `basename' of the pathname in STRING (the stuff after
+// Return the 'basename' of the pathname in STRING (the stuff after
 // the last directory separator).  If STRING is not a full pathname,
 // simply return it.
 
 std::string
 octave_env::do_base_pathname (const std::string& s) const
 {
   if (! (do_absolute_pathname (s) || do_rooted_relative_pathname (s)))
     return s;
diff --git a/liboctave/oct-locbuf.h b/liboctave/oct-locbuf.h
--- a/liboctave/oct-locbuf.h
+++ b/liboctave/oct-locbuf.h
@@ -169,17 +169,17 @@ public:
 
 #if 0 // defined (HAVE_DYNAMIC_AUTO_ARRAYS)
 
 // Maximum buffer size (in bytes) to be placed on the stack.
 
 #define OCTAVE_LOCAL_BUFFER_MAX_STACK_SIZE 8192
 
 // If we have automatic arrays, we use an automatic array if the size
-// is small enough.  To avoid possibly evaluating `size' multiple
+// is small enough.  To avoid possibly evaluating 'size' multiple
 // times, we first cache it.  Note that we always construct both the
 // stack array and the octave_local_buffer object, but only one of
 // them will be nonempty.
 
 #define OCTAVE_LOCAL_BUFFER(T, buf, size) \
   const size_t _bufsize_ ## buf = size; \
   const bool _lbufaut_ ## buf = _bufsize_ ## buf * sizeof (T) \
      <= OCTAVE_LOCAL_BUFFER_MAX_STACK_SIZE; \
diff --git a/liboctave/oct-md5.cc b/liboctave/oct-md5.cc
--- a/liboctave/oct-md5.cc
+++ b/liboctave/oct-md5.cc
@@ -73,13 +73,13 @@ oct_md5_file (const std::string file)
       gnulib::fclose (ifile);
 
       if (! errflag)
         retval = oct_md5_result_to_str (buf);
       else
         (*current_liboctave_error_handler) ("internal error in md5_stream");
     }
   else
-    (*current_liboctave_error_handler) ("unable to open file `%s' for reading",
+    (*current_liboctave_error_handler) ("unable to open file '%s' for reading",
                                         file.c_str());
 
   return retval;
 }
diff --git a/liboctave/oct-rand.cc b/liboctave/oct-rand.cc
--- a/liboctave/oct-rand.cc
+++ b/liboctave/oct-rand.cc
@@ -554,17 +554,17 @@ octave_rand::get_dist_id (const std::str
   else if (d == "exponential" || d == "rande")
     retval = expon_dist;
   else if (d == "poisson" || d == "randp")
     retval = poisson_dist;
   else if (d == "gamma" || d == "randg")
     retval = gamma_dist;
   else
     (*current_liboctave_error_handler)
-      ("rand: invalid distribution `%s'", d.c_str ());
+      ("rand: invalid distribution '%s'", d.c_str ());
 
   return retval;
 }
 
 void
 octave_rand::set_internal_state (const ColumnVector& s)
 {
   octave_idx_type len = s.length ();
diff --git a/scripts/general/interp2.m b/scripts/general/interp2.m
--- a/scripts/general/interp2.m
+++ b/scripts/general/interp2.m
@@ -392,25 +392,25 @@ function ZI = interp2 (varargin)
            + AY0  .* AX1  .* Z (sym_sub2ind (sz, L,   K-1)) ...
            + AY1  .* AX_2 .* Z (sym_sub2ind (sz, L-1, K+2)) ...
            + AY1  .* AX_1 .* Z (sym_sub2ind (sz, L-1, K+1)) ...
            + AY1  .* AX0  .* Z (sym_sub2ind (sz, L-1, K))   ...
            + AY1  .* AX1  .* Z (sym_sub2ind (sz, L-1, K-1));
         ZI (!inside) = extrapval;
 
       else
-        error ("interp2: input data must have `meshgrid' format");
+        error ("interp2: input data must have 'meshgrid' format");
       endif
 
     elseif (strcmp (method, "spline"))
       if (isgriddata (XI) && isgriddata (YI'))
         ZI = __splinen__ ({Y(:,1).', X(1,:)}, Z, {YI(:,1), XI(1,:)}, extrapval,
                         "spline");
       else
-        error ("interp2: input data must have `meshgrid' format");
+        error ("interp2: input data must have 'meshgrid' format");
       endif
     else
       error ("interp2: interpolation METHOD not recognized");
     endif
 
   endif
 endfunction
 
diff --git a/scripts/help/doc.m b/scripts/help/doc.m
--- a/scripts/help/doc.m
+++ b/scripts/help/doc.m
@@ -87,17 +87,17 @@ function retval = doc (fname)
 
     if (have_fname)
       status = system (sprintf ("%s --index-search %s", cmd, fname));
     endif
 
     if (! (have_fname && status == 0))
       status = system (cmd);
       if (status == 127)
-        warning ("unable to find info program `%s'", info_program ());
+        warning ("unable to find info program '%s'", info_program ());
       endif
     endif
 
     if (nargout > 0)
       retval = status;
     endif
 
   else
diff --git a/scripts/help/get_first_help_sentence.m b/scripts/help/get_first_help_sentence.m
--- a/scripts/help/get_first_help_sentence.m
+++ b/scripts/help/get_first_help_sentence.m
@@ -61,19 +61,19 @@ function [text, status] = get_first_help
   switch (lower (format))
     case "plain text"
       [text, status] = first_sentence_plain_text (help_text, max_len);
     case "texinfo"
       [text, status] = first_sentence_texinfo (help_text, max_len);
     case "html"
       [text, status] = first_sentence_html (help_text, max_len);
     case "not documented"
-      error ("get_first_help_sentence: `%s' is not documented\n", name);
+      error ("get_first_help_sentence: '%s' is not documented\n", name);
     case "not found"
-      error ("get_first_help_sentence: `%s' not found\n", name);
+      error ("get_first_help_sentence: '%s' not found\n", name);
     otherwise
       error ("get_first_help_sentence: internal error: unsupported help text format: '%s'\n", format);
   endswitch
 
   if (nargout <= 1 && status != 0)
     warning ("get_first_help_sentence: couldn't run makeinfo on '%s'", name);
   endif
 endfunction
diff --git a/scripts/help/help.m b/scripts/help/help.m
--- a/scripts/help/help.m
+++ b/scripts/help/help.m
@@ -75,17 +75,17 @@ function retval = help (name)
     switch (lower (format))
       case "plain text"
         status = 0;
       case "texinfo"
         [text, status] = __makeinfo__ (text, "plain text");
       case "html"
         [text, status] = strip_html_tags (text);
       case "not documented"
-        error ("help: `%s' is not documented\n", name);
+        error ("help: '%s' is not documented\n", name);
       case "not found"
         do_contents (name);
         return;
       otherwise
         error ("help: internal error: unsupported help text format: '%s'\n", format);
     endswitch
 
     ## Print text
@@ -167,17 +167,17 @@ function do_contents (name)
   endfor
 
   if (found)
     puts (__additional_help_message__ ());
   else
     msg = feval (missing_function_hook, name);
 
     if (isempty (msg))
-      msg = sprintf ("`%s' not found", name);
+      msg = sprintf ("'%s' not found", name);
     endif
 
     error ("help: %s\n", msg);
   endif
 
 endfunction
 
 
diff --git a/scripts/help/print_usage.m b/scripts/help/print_usage.m
--- a/scripts/help/print_usage.m
+++ b/scripts/help/print_usage.m
@@ -54,19 +54,19 @@ function print_usage (name)
   switch (lower (format))
     case "plain text"
       [usage_string, status] = get_usage_plain_text (text, max_len);
     case "texinfo"
       [usage_string, status] = get_usage_texinfo (text, max_len);
     case "html"
       [usage_string, status] = get_usage_html (text, max_len);
     case "not documented"
-      error ("print_usage: `%s' is not documented\n", name);
+      error ("print_usage: '%s' is not documented\n", name);
     case "not found"
-      error ("print_usage: `%s' not found\n", name);
+      error ("print_usage: '%s' not found\n", name);
     otherwise
       error ("print_usage: internal error: unsupported help text format: '%s'\n", format);
   endswitch
 
   ## Raise the final error
   if (status != 0)
     warning ("print_usage: Texinfo formatting filter exited abnormally");
     warning ("print_usage: raw Texinfo source of help text follows...\n");
diff --git a/scripts/help/private/__additional_help_message__.m b/scripts/help/private/__additional_help_message__.m
--- a/scripts/help/private/__additional_help_message__.m
+++ b/scripts/help/private/__additional_help_message__.m
@@ -24,16 +24,16 @@
 function msg = __additional_help_message__ ()
 
   if (suppress_verbose_help_message ())
     msg = "";
   else
     msg = "\
 Additional help for built-in functions and operators is\n\
 available in the on-line version of the manual.  Use the command\n\
-`doc <topic>' to search the manual index.\n\
+'doc <topic>' to search the manual index.\n\
 \n\
 Help and information about Octave is also available on the WWW\n\
 at http://www.octave.org and via the help@octave.org\n\
 mailing list.\n";
   endif
 
 endfunction
diff --git a/scripts/help/type.m b/scripts/help/type.m
--- a/scripts/help/type.m
+++ b/scripts/help/type.m
@@ -68,23 +68,23 @@ function retval = type (varargin)
         text = sprintf ("%s is a variable\n%s", name, desc);
       endif
     elseif (e == 2)
       ## m-file or ordinary file
       file = which (name);
       if (isempty (file))
         ## 'name' is an ordinary file, and not a function name.
         ## FIXME: Should we just print it anyway?
-        error ("type: `%s' undefined\n", name);
+        error ("type: '%s' undefined\n", name);
       endif
 
       ## Read the file
       fid = fopen (file, "r");
       if (fid < 0)
-        error ("type: couldn't open `%s' for reading", file);
+        error ("type: couldn't open '%s' for reading", file);
       endif
       contents = char (fread (fid).');
       fclose (fid);
 
       if (quiet)
         text = contents;
       else
         text = sprintf ("%s is the user-defined function defined from: %s\n\n%s",
@@ -94,17 +94,17 @@ function retval = type (varargin)
       text = sprintf ("%s is a dynamically-linked function", name);
     elseif (e == 5)
       text = sprintf ("%s is a built-in function", name);
     elseif (any (strcmp (__operators__ (), name)))
       text = sprintf ("%s is an operator", name);
     elseif (any (strcmp (__keywords__ (), name)))
       text = sprintf ("%s is a keyword", name);
     else
-      error ("type: `%s' undefined\n", name);
+      error ("type: '%s' undefined\n", name);
     endif
 
     ## Should we return the text or print if
     if (nargout == 0)
       disp (text);
     else
       retval {n} = text;
     endif
diff --git a/scripts/help/unimplemented.m b/scripts/help/unimplemented.m
--- a/scripts/help/unimplemented.m
+++ b/scripts/help/unimplemented.m
@@ -49,17 +49,17 @@ function txt = unimplemented (fcn)
   case {"ode113", "ode15i", "ode15s", "ode23", "ode23s", "ode23t", "ode45", "odeget", "odeset"}
     txt = ["Octave provides lsode for solving differential equations.  ",...
     "For more information try @code{help lsode}.  ",...
     "Matlab-compatible ODE functions are provided by the odepkg package.  ",...
     "See @url{http://octave.sf.net/odepkg/}."];
 
   otherwise
     if (ismember (fcn, missing_functions ()))
-      txt = sprintf ("the `%s' function is not yet implemented in Octave", fcn);
+      txt = sprintf ("the '%s' function is not yet implemented in Octave", fcn);
     else
       is_matlab_function = false;
       txt = "";
     endif
   endswitch
 
   if (is_matlab_function)
     txt = [txt, "\n\n@noindent\nPlease read ",...
@@ -425,11 +425,11 @@ endfunction
 
 
 %!test
 %! str = unimplemented ("no_name_function");
 %! assert (isempty (str));
 %! str = unimplemented ("quad2d");
 %! assert (str(1:51), "quad2d is not implemented.  Consider using dblquad.");
 %! str = unimplemented ("MException");
-%! assert (str(1:58), "the `MException' function is not yet implemented in Octave");
+%! assert (str(1:58), "the 'MException' function is not yet implemented in Octave");
 
 
diff --git a/scripts/help/which.m b/scripts/help/which.m
--- a/scripts/help/which.m
+++ b/scripts/help/which.m
@@ -27,25 +27,25 @@ function varargout = which (varargin)
 
   if (nargin > 0 && iscellstr (varargin))
     m = __which__ (varargin{:});
 
     if (nargout == 0)
       for i = 1:nargin
         if (isempty (m(i).file))
           if (! isempty (m(i).type))
-            printf ("`%s' is a %s\n",
+            printf ("'%s' is a %s\n",
                     m(i).name, m(i).type);
           endif
         else
           if (isempty (m(i).type))
-            printf ("`%s' is the file %s\n",
+            printf ("'%s' is the file %s\n",
                     m(i).name, m(i).file);
           else
-            printf ("`%s' is a %s from the file %s\n",
+            printf ("'%s' is a %s from the file %s\n",
                     m(i).name, m(i).type, m(i).file);
           endif
         endif
       endfor
     else
       varargout = {m.file};
     endif
   else
diff --git a/scripts/miscellaneous/cast.m b/scripts/miscellaneous/cast.m
--- a/scripts/miscellaneous/cast.m
+++ b/scripts/miscellaneous/cast.m
@@ -28,17 +28,17 @@ function retval = cast (val, typ)
 
   if (nargin == 2)
     if (ischar (typ))
       if (any (strcmp (typ, {"int8"; "uint8"; "int16"; "uint16";
                              "int32"; "uint32"; "int64"; "uint64";
                              "double"; "single"; "logical"; "char"})))
         retval = feval (typ, val);
       else
-        error ("cast: type name `%s' is not a built-in type", typ);
+        error ("cast: type name '%s' is not a built-in type", typ);
       endif
     else
       error ("cast: expecting TYPE name as second argument");
     endif
   else
     print_usage ();
   endif
 
diff --git a/scripts/miscellaneous/dir.m b/scripts/miscellaneous/dir.m
--- a/scripts/miscellaneous/dir.m
+++ b/scripts/miscellaneous/dir.m
@@ -77,34 +77,34 @@ function retval = dir (directory)
     endif
 
     ## Determine the file list for the case where a single directory is
     ## specified.
     if (nf == 1)
       fn = flst{1};
       [st, err, msg] = stat (fn);
       if (err < 0)
-        warning ("dir: `stat (%s)' failed: %s", fn, msg);
+        warning ("dir: 'stat (%s)' failed: %s", fn, msg);
         nf = 0;
       elseif (S_ISDIR (st.mode))
         flst = readdir (flst{1});
         nf = length (flst);
         for i = 1:nf
           flst{i} = fullfile (fn, flst{i});
         endfor
       endif
     endif
 
     if (length (flst) > 0)
       ## Collect results.
       for i = nf:-1:1
         fn = flst{i};
         [st, err, msg] = lstat (fn);
         if (err < 0)
-          warning ("dir: `lstat (%s)' failed: %s", fn, msg);
+          warning ("dir: 'lstat (%s)' failed: %s", fn, msg);
         else
           ## If we are looking at a link that points to something,
           ## return info about the target of the link, otherwise, return
           ## info about the link itself.
           if (S_ISLNK (st.mode))
             [xst, err, msg] = stat (fn);
             if (! err)
               st = xst;
@@ -131,12 +131,12 @@ function retval = dir (directory)
   ## Return the output arguments.
   if (nargout > 0)
     ## Return the requested structure.
     retval = info;
   elseif (length (info) > 0)
     ## Print the structure to the screen.
     printf ("%s", list_in_columns ({info.name}));
   else
-    warning ("dir: nonexistent directory `%s'", directory);
+    warning ("dir: nonexistent directory '%s'", directory);
   endif
 
 endfunction
diff --git a/scripts/miscellaneous/license.m b/scripts/miscellaneous/license.m
--- a/scripts/miscellaneous/license.m
+++ b/scripts/miscellaneous/license.m
@@ -133,20 +133,20 @@ function retval = license (varargin)
         retval = ! isempty (found) && __octave_licenses__{found,3};
       else
         if (! isempty (found))
           if (strcmp (varargin{3}, "enable"))
             __octave_licenses__{found,3} = true;
           elseif (strcmp (varargin{3}, "disable"))
             __octave_licenses__{found,3} = false;
           else
-            error ("license: TOGGLE must be either `enable' or `disable'");
+            error ("license: TOGGLE must be either 'enable' or 'disable'");
           endif
         else
-          error ("license: FEATURE `%s' not found", feature);
+          error ("license: FEATURE '%s' not found", feature);
         endif
       endif
 
     elseif (strcmp (varargin{1}, "checkout"))
 
       if (nin != 2)
         usage ('retval = license ("checkout", feature)');
       endif
@@ -177,11 +177,11 @@ endfunction
 %!   license ("test", "Octave", "disable");
 %! endif
 
 %!assert (license ("checkout", "Octave"), true)
 
 %% Test input validation
 %!error license ("not_inuse")
 %!error <TOGGLE must be either> license ("test", "Octave", "not_enable")
-%!error <FEATURE `INVALID' not found> license ("test", "INVALID", "enable")
+%!error <FEATURE 'INVALID' not found> license ("test", "INVALID", "enable")
 %!error license ("not_test", "Octave", "enable")
 
diff --git a/scripts/miscellaneous/mkoctfile.m b/scripts/miscellaneous/mkoctfile.m
--- a/scripts/miscellaneous/mkoctfile.m
+++ b/scripts/miscellaneous/mkoctfile.m
@@ -155,15 +155,15 @@ function [output, status] = mkoctfile (v
 
   if (nargout > 0)
     [output, status] = deal (out, sys);
   else
     printf ("%s", out);
   endif
 
   if (sys == 127)
-    warning ("unable to find mkoctfile in expected location: `%s'",
+    warning ("unable to find mkoctfile in expected location: '%s'",
              shell_script);
 
     warning ("mkoctfile exited with failure status");
   endif
 
 endfunction
diff --git a/scripts/miscellaneous/recycle.m b/scripts/miscellaneous/recycle.m
--- a/scripts/miscellaneous/recycle.m
+++ b/scripts/miscellaneous/recycle.m
@@ -43,17 +43,17 @@ function retval = recycle (state)
 
   if (nargin == 1)
     if (ischar (state))
       if (strcmpi (state, "on"))
         error ("recycle: recycling files is not implemented");
       elseif (strcmpi (state, "off"))
         current_state = "off";
       else
-        error ("recycle: invalid value of STATE = `%s'", state);
+        error ("recycle: invalid value of STATE = '%s'", state);
       endif
     else
       error ("recycle: expecting STATE to be a character string");
     endif
   endif
 
 endfunction
 
diff --git a/scripts/miscellaneous/tempdir.m b/scripts/miscellaneous/tempdir.m
--- a/scripts/miscellaneous/tempdir.m
+++ b/scripts/miscellaneous/tempdir.m
@@ -28,17 +28,17 @@ function dirname = tempdir ()
     dirname = P_tmpdir;
   endif
 
   if (! strcmp (dirname(end), filesep))
     dirname = cstrcat (dirname, filesep);
   endif
 
   if (! isdir (dirname))
-    warning ("tempdir: `%s' does not exist or is not a directory", dirname);
+    warning ("tempdir: '%s' does not exist or is not a directory", dirname);
   endif
 
 endfunction
 
 
 %!assert (ischar (tempdir ()))
 
 %!test
diff --git a/scripts/optimization/optimset.m b/scripts/optimization/optimset.m
--- a/scripts/optimization/optimset.m
+++ b/scripts/optimization/optimset.m
@@ -94,17 +94,17 @@ function retval = optimset (varargin)
       retval = cell2struct (repmat ({[]}, size (opts)), opts, 2);
     endif
   elseif (nargs == 1 && ischar (varargin{1}))
     ## Return defaults for named function.
     fcn = varargin{1};
     try
       retval = feval (fcn, "defaults");
     catch
-      error ("optimset: no defaults for function `%s'", fcn);
+      error ("optimset: no defaults for function '%s'", fcn);
     end_try_catch
   elseif (nargs == 2 && isstruct (varargin{1}) && isstruct (varargin{2}))
     ## Set slots in old from nonempties in new.  Should we be checking
     ## to ensure that the field names are expected?
     old = varargin{1};
     new = varargin{2};
     fnames = fieldnames (old);
     ## skip validation if we're in the internal query
diff --git a/scripts/pkg/pkg.m b/scripts/pkg/pkg.m
--- a/scripts/pkg/pkg.m
+++ b/scripts/pkg/pkg.m
@@ -1746,17 +1746,17 @@ function desc = get_description (filenam
       if (length (colon) == 0)
         disp ("skipping line");
       else
         colon = colon(1);
         keyword = tolower (strip (line(1:colon-1)));
         value = strip (line (colon+1:end));
         if (length (value) == 0)
             fclose (fid);
-            error ("The keyword `%s' of the package `%s' has an empty value",
+            error ("The keyword '%s' of the package '%s' has an empty value",
                     keyword, desc.name);
         endif
         desc.(keyword) = value;
       endif
     endif
     line = fgetl (fid);
   endwhile
   fclose (fid);
@@ -1815,17 +1815,17 @@ function deps_cell = fix_depends (depend
     rpar = find (dep == ")");
     ## Does the dependency specify a version
     ## Example: package(>= version).
     if (length (lpar) == 1 && length (rpar) == 1)
       package = tolower (strip (dep(1:lpar-1)));
       sub = dep(lpar(1)+1:rpar(1)-1);
       parts = strsplit (sub, " ", true);
       if (length (parts) != 2)
-        error ("incorrect syntax for dependency `%s' in the DESCRIPTION file\n",
+        error ("incorrect syntax for dependency '%s' in the DESCRIPTION file\n",
                dep);
       endif
       operator = parts{1};
       if (! any (strcmp (operator, {">", ">=", "<=", "<", "=="})))
         error ("unsupported operator: %s", operator);
       endif
       version  = fix_version (parts{2});
 
diff --git a/scripts/plot/closereq.m b/scripts/plot/closereq.m
--- a/scripts/plot/closereq.m
+++ b/scripts/plot/closereq.m
@@ -25,17 +25,17 @@
 
 ## Author: jwe
 
 function closereq ()
 
   if (nargin == 0)
     cf = gcbf ();
     if (isempty (cf))
-      warning ("closereq: calling closereq from octave prompt is not supported, use `close' instead");
+      warning ("closereq: calling closereq from octave prompt is not supported, use 'close' instead");
       cf = get (0, "currentfigure");
     endif
     if (! isempty (cf) && isfigure (cf))
       delete (cf);
     endif
   else
     print_usage ();
   endif
diff --git a/scripts/plot/colstyle.m b/scripts/plot/colstyle.m
--- a/scripts/plot/colstyle.m
+++ b/scripts/plot/colstyle.m
@@ -75,15 +75,15 @@ endfunction
 %! [l, c, m, msg] = colstyle (".");
 %! assert (isempty (msg));
 %! assert (l, "none");
 %! assert (c, []);
 %! assert (m, ".");
 
 %!test
 %! [l, c, m, msg] = colstyle ("~");
-%! assert (msg, "colstyle: unrecognized format character: `~'");
+%! assert (msg, "colstyle: unrecognized format character: '~'");
 
 %% Test input validation
 %!error colstyle ()
 %!error colstyle (1, 2)
 %!error colstyle (1.5)
 
diff --git a/scripts/plot/private/__fltk_print__.m b/scripts/plot/private/__fltk_print__.m
--- a/scripts/plot/private/__fltk_print__.m
+++ b/scripts/plot/private/__fltk_print__.m
@@ -56,17 +56,17 @@ function opts = __fltk_print__ (opts)
       name = opts.name(1:dot-1);
       if (dot < numel (opts.name)
           && any (strcmpi (opts.name(dot+1:end), {"eps", "ps", "pdf"})))
         ## If user provides eps/ps/pdf suffix, use it.
         suffix = opts.name(dot+1:end);
       endif
     else
       error ("print:invalid-suffix", 
-             "invalid suffix `%s' for device `%s'.",
+             "invalid suffix '%s' for device '%s'.",
              opts.name(dot:end), lower (opts.devopt));
     endif
     gl2ps_device = {sprintf("%snotxt", lower (suffix))};
     gl2ps_device{2} = "tex";
     if (dos_shell)
       ## FIXME - this will only work on MinGW with the MSYS shell
       pipeline = {sprintf("cat > %s-inc.%s", name, suffix)};
       pipeline{2} = sprintf ("cat > %s.tex", name);
diff --git a/scripts/plot/private/__gnuplot_print__.m b/scripts/plot/private/__gnuplot_print__.m
--- a/scripts/plot/private/__gnuplot_print__.m
+++ b/scripts/plot/private/__gnuplot_print__.m
@@ -71,17 +71,17 @@ function opts = __gnuplot_print__ (opts)
     dot = find (opts.name == ".", 1, "last");
     n = find (opts.devopt == "l", 1);
     suffix = opts.devopt(1:n-1);
     if (! isempty (dot))
       if (any (strcmpi (opts.name(dot:end), {strcat(".", suffix), ".tex", "."})))
         name = opts.name(1:dot-1);
       else
         error ("print:invalid-suffix", 
-               "invalid suffix `%s' for device `%s'.",
+               "invalid suffix '%s' for device '%s'.",
                opts.name(dot:end), lower (opts.devopt));
       endif
     endif
     if (strfind (opts.devopt, "standalone"))
       term = sprintf ("%s ",
                       strrep (opts.devopt, "standalone", " standalone"));
     else
       term = sprintf ("%s ", opts.devopt);
diff --git a/scripts/plot/private/__go_draw_figure__.m b/scripts/plot/private/__go_draw_figure__.m
--- a/scripts/plot/private/__go_draw_figure__.m
+++ b/scripts/plot/private/__go_draw_figure__.m
@@ -182,17 +182,17 @@ function __go_draw_figure__ (h, plot_str
           endswitch
         endfor
         fputs (plot_stream, "\nunset multiplot;\n");
       else
         fputs (plot_stream, "\nreset; clear;\n");
         fflush (plot_stream);
       endif
     else
-      error ("__go_draw_figure__: expecting figure object, found `%s'",
+      error ("__go_draw_figure__: expecting figure object, found '%s'",
              htype);
     endif
   else
     print_usage ();
   endif
 
 endfunction
 
diff --git a/scripts/plot/private/__pie__.m b/scripts/plot/private/__pie__.m
--- a/scripts/plot/private/__pie__.m
+++ b/scripts/plot/private/__pie__.m
@@ -134,17 +134,17 @@ function hlist = __pie__ (caller, vararg
       else
         align = "right";
       endif
 
       hlist = [hlist; patch(xoff + [0, - sind(xn)], yoff + [0, cosd(xn)], i);
                text(xt, yt, labels{i}, "horizontalalignment", align)];
 
     else
-      error ("__pie__: unknown caller `%s'", caller);
+      error ("__pie__: unknown caller '%s'", caller);
     endif
   endfor
 
   addlistener(gca, "view", {@update_text_pos, hlist});
 
   if (strncmp (caller, "pie3", 4))
     axis ([-1.25, 1.25, -1.25, 1.25, -0.05, 0.4], "equal", "off");
     view (-37.5, 30);
diff --git a/scripts/plot/private/__pltopt__.m b/scripts/plot/private/__pltopt__.m
--- a/scripts/plot/private/__pltopt__.m
+++ b/scripts/plot/private/__pltopt__.m
@@ -214,17 +214,17 @@ function [options, valid] = __pltopt1__ 
           else
             valid = false;
             options = __default_plot_options__ ();
             return;
           endif
         endif
       else
         if (err_on_invalid)
-          error ("%s: unrecognized format character: `%s'", caller, topt);
+          error ("%s: unrecognized format character: '%s'", caller, topt);
         else
           valid = false;
           options = __default_plot_options__ ();
           return;
         endif
       endif
     endif
     opt(1:n) = [];
diff --git a/scripts/plot/private/__print_parse_opts__.m b/scripts/plot/private/__print_parse_opts__.m
--- a/scripts/plot/private/__print_parse_opts__.m
+++ b/scripts/plot/private/__print_parse_opts__.m
@@ -135,17 +135,17 @@ function arg_st = __print_parse_opts__ (
         endif
       elseif (length (arg) > 2 && arg(1:2) == "-S")
         arg_st.canvas_size = str2num (arg(3:end));
       elseif (length (arg) > 2 && arg(1:2) == "-r")
         arg_st.ghostscript.resolution = str2double (arg(3:end));
       elseif (length (arg) > 2 && arg(1:2) == "-f")
         arg_st.figure = str2num (arg(3:end));
       elseif (length (arg) >= 1 && arg(1) == "-")
-        error ("print: unknown option `%s'", arg);
+        error ("print: unknown option '%s'", arg);
       elseif (length (arg) > 0)
         arg_st.name = arg;
       endif
     elseif (isfigure (arg))
       arg_st.figure = arg;
     else
       error ("print: expecting inputs to be character string options or a figure handle");
     endif
@@ -465,17 +465,17 @@ function gs = __ghostscript_binary__ ()
 
 endfunction
 
 function bin = __find_binary__ (binary)
 
   persistent data = struct ()
 
   if (! isfield (data, binary))
-    ## Reinitialize when `user_binaries' is present.
+    ## Reinitialize when 'user_binaries' is present.
     data.(binary).bin = "";
     data.(binary).warn_on_absence = false;
   endif
 
   if (isempty (data.(binary).bin))
     if (isunix ())
       ## Unix - Includes Mac OSX and Cygwin.
       binaries = strcat (binary, {"", ".exe"});
diff --git a/scripts/plot/uigetdir.m b/scripts/plot/uigetdir.m
--- a/scripts/plot/uigetdir.m
+++ b/scripts/plot/uigetdir.m
@@ -33,17 +33,17 @@ function dirname = uigetdir (init_path =
   defaulttoolkit = get (0, "defaultfigure__graphics_toolkit__");
   funcname = ["__uigetdir_", defaulttoolkit, "__"];
   functype = exist (funcname);
   if (! __is_function__ (funcname))
     funcname = "__uigetdir_fltk__";
     if (! __is_function__ (funcname))
       error ("uigetdir: fltk graphics toolkit required");
     elseif (! strcmp (defaulttoolkit, "gnuplot"))
-      warning ("uigetdir: no implementation for toolkit `%s', using `fltk' instead",
+      warning ("uigetdir: no implementation for toolkit '%s', using 'fltk' instead",
                defaulttoolkit);
     endif
   endif
 
   if (nargin > 2)
     print_usage ();
   endif
 
diff --git a/scripts/plot/uigetfile.m b/scripts/plot/uigetfile.m
--- a/scripts/plot/uigetfile.m
+++ b/scripts/plot/uigetfile.m
@@ -67,17 +67,17 @@ function [retfile, retpath, retindex] = 
   defaulttoolkit = get (0, "defaultfigure__graphics_toolkit__");
   funcname = ["__uigetfile_", defaulttoolkit, "__"];
   functype = exist (funcname);
   if (! __is_function__ (funcname))
     funcname = "__uigetfile_fltk__";
     if (! __is_function__ (funcname))
       error ("uigetfile: fltk graphics toolkit required");
     elseif (! strcmp (defaulttoolkit, "gnuplot"))
-      warning ("uigetfile: no implementation for toolkit `%s', using `fltk' instead",
+      warning ("uigetfile: no implementation for toolkit '%s', using 'fltk' instead",
                defaulttoolkit);
     endif
   endif
 
   if (nargin > 7)
     error ("uigetfile: number of input arguments must be less than eight");
   endif
 
diff --git a/scripts/plot/uiputfile.m b/scripts/plot/uiputfile.m
--- a/scripts/plot/uiputfile.m
+++ b/scripts/plot/uiputfile.m
@@ -58,17 +58,17 @@ function [retfile, retpath, retindex] = 
   defaulttoolkit = get (0, "defaultfigure__graphics_toolkit__");
   funcname = ["__uiputfile_", defaulttoolkit, "__"];
   functype = exist (funcname);
   if (! __is_function__ (funcname))
     funcname = "__uiputfile_fltk__";
     if (! __is_function__ (funcname))
       error ("uiputfile: fltk graphics toolkit required");
     elseif (! strcmp (defaulttoolkit, "gnuplot"))
-      warning ("uiputfile: no implementation for toolkit `%s', using `fltk' instead",
+      warning ("uiputfile: no implementation for toolkit '%s', using 'fltk' instead",
                defaulttoolkit);
     endif
   endif
 
   if (nargin > 3)
     print_usage ();
   endif
 
diff --git a/scripts/signal/stft.m b/scripts/signal/stft.m
--- a/scripts/signal/stft.m
+++ b/scripts/signal/stft.m
@@ -73,17 +73,17 @@ function [y, c] = stft(x, win_size, inc,
     if (ischar (win_type))
       if (strcmp (win_type, "hanning"))
         win_type = 1;
       elseif (strcmp (win_type, "hamming"))
         win_type = 2;
       elseif (strcmp (win_type, "rectangle"))
         win_type = 3;
       else
-        error ("stft: unknown window type `%s'", win_type);
+        error ("stft: unknown window type '%s'", win_type);
       endif
     endif
   else
     print_usage ();
   endif
 
   ## Check whether X is a vector.
   [nr, nc] = size (x);
diff --git a/scripts/statistics/base/mean.m b/scripts/statistics/base/mean.m
--- a/scripts/statistics/base/mean.m
+++ b/scripts/statistics/base/mean.m
@@ -112,17 +112,17 @@ function y = mean (x, opt1, opt2)
 
   if (strcmp (opt, "a"))
     y = sum (x, dim) / n;
   elseif (strcmp (opt, "g"))
     y = prod (x, dim) .^ (1/n);
   elseif (strcmp (opt, "h"))
     y = n ./ sum (1 ./ x, dim);
   else
-    error ("mean: option `%s' not recognized", opt);
+    error ("mean: option '%s' not recognized", opt);
   endif
 
 endfunction
 
 
 %!test
 %! x = -10:10;
 %! y = x';
diff --git a/scripts/statistics/tests/anova.m b/scripts/statistics/tests/anova.m
--- a/scripts/statistics/tests/anova.m
+++ b/scripts/statistics/tests/anova.m
@@ -45,24 +45,24 @@
 ## Description: One-way analysis of variance (ANOVA)
 
 function [pval, f, df_b, df_w] = anova (y, g)
 
   if ((nargin < 1) || (nargin > 2))
     print_usage ();
   elseif (nargin == 1)
     if (isvector (y))
-      error ("anova: for `anova (Y)', Y must not be a vector");
+      error ("anova: for 'anova (Y)', Y must not be a vector");
     endif
     [group_count, k] = size (y);
     n = group_count * k;
     group_mean = mean (y);
   else
     if (! isvector (y))
-      error ("anova: for `anova (Y, G)', Y must be a vector");
+      error ("anova: for 'anova (Y, G)', Y must be a vector");
     endif
     n = length (y);
     if (! isvector (g) || (length (g) != n))
       error ("anova: G must be a vector of the same length as Y");
     endif
     s = sort (g);
     i = find (s (2 : n) > s(1 : (n-1)));
     k = length (i) + 1;
diff --git a/scripts/statistics/tests/cor_test.m b/scripts/statistics/tests/cor_test.m
--- a/scripts/statistics/tests/cor_test.m
+++ b/scripts/statistics/tests/cor_test.m
@@ -108,27 +108,27 @@ function t = cor_test (x, y, alt, method
   elseif (m == "s")
     rho = spearman (x, y);
     t.method = "Spearman's rank correlation rho";
     t.params = [];
     t.stat = sqrt (n-1) * (rho - 6/(n^3-n));
     t.dist = "stdnormal";
     cdf = stdnormal_cdf (t.stat);
   else
-    error ("cor_test: METHOD `%s' not recognized", method);
+    error ("cor_test: METHOD '%s' not recognized", method);
   endif
 
   if (strcmp (alt, "!=") || strcmp (alt, "<>"))
     t.pval = 2 * min (cdf, 1 - cdf);
   elseif (strcmp (alt, ">"))
     t.pval = 1 - cdf;
   elseif (strcmp (alt, "<"))
     t.pval = cdf;
   else
-    error ("cor_test: alternative `%s' not recognized", alt);
+    error ("cor_test: alternative '%s' not recognized", alt);
   endif
 
   t.alternative = alt;
 
   if (nargout == 0)
     printf ("pval: %g\n", t.pval);
   endif
 
diff --git a/scripts/statistics/tests/t_test_regression.m b/scripts/statistics/tests/t_test_regression.m
--- a/scripts/statistics/tests/t_test_regression.m
+++ b/scripts/statistics/tests/t_test_regression.m
@@ -81,16 +81,16 @@ function [pval, t, df] = t_test_regressi
 
   if (strcmp (alt, "!=") || strcmp (alt, "<>"))
     pval = 2 * min (cdf, 1 - cdf);
   elseif strcmp (alt, ">")
     pval = 1 - cdf;
   elseif strcmp (alt, "<")
     pval = cdf;
   else
-    error ("t_test_regression: the value `%s' for alt is not possible", alt);
+    error ("t_test_regression: the value '%s' for alt is not possible", alt);
   endif
 
   if (nargout == 0)
     printf ("pval: %g\n", pval);
   endif
 
 endfunction
diff --git a/src/DLD-FUNCTIONS/__magick_read__.cc b/src/DLD-FUNCTIONS/__magick_read__.cc
--- a/src/DLD-FUNCTIONS/__magick_read__.cc
+++ b/src/DLD-FUNCTIONS/__magick_read__.cc
@@ -1079,17 +1079,17 @@ not be using this function.  Instead use
           octave_localtime mtime = fs.mtime ();
 
           filetime = mtime.strftime ("%e-%b-%Y %H:%M:%S");
         }
       else
         {
           std::string msg = fs.error ();
 
-          error ("imfinfo: error reading `%s': %s",
+          error ("imfinfo: error reading '%s': %s",
                  filename.c_str (), msg.c_str ());
 
           return retval;
         }
 
       // For each frame in the image (some images contain multiple
       // layers, each to be treated like a separate image).
       for (int frame = 0; frame < nframes; frame++)
diff --git a/src/DLD-FUNCTIONS/dlmread.cc b/src/DLD-FUNCTIONS/dlmread.cc
--- a/src/DLD-FUNCTIONS/dlmread.cc
+++ b/src/DLD-FUNCTIONS/dlmread.cc
@@ -216,17 +216,17 @@ fields.  The default is zero.\n\
          return retval;
 
       std::string tname = file_ops::tilde_expand (fname);
 
       input_file.open (tname.c_str (), std::ios::in);
 
       if (! input_file)
         {
-          error ("dlmread: unable to open file `%s'", fname.c_str ());
+          error ("dlmread: unable to open file '%s'", fname.c_str ());
           return retval;
         }
       else
         input = &input_file;
     }
   else if (args(0).is_scalar_type ())
     {
       octave_stream is = octave_stream_list::lookup (args(0), "dlmread");
diff --git a/src/DLD-FUNCTIONS/schur.cc b/src/DLD-FUNCTIONS/schur.cc
--- a/src/DLD-FUNCTIONS/schur.cc
+++ b/src/DLD-FUNCTIONS/schur.cc
@@ -164,17 +164,17 @@ Riccati equations in control (see @code{
     }
   else
     {
       char ord_char = ord.empty () ? 'U' : ord[0];
 
       if (ord_char != 'U' && ord_char != 'A' && ord_char != 'D'
           && ord_char != 'u' && ord_char != 'a' && ord_char != 'd')
         {
-          warning ("schur: incorrect ordered schur argument `%c'",
+          warning ("schur: incorrect ordered schur argument '%c'",
                    ord.c_str ());
           return retval;
         }
     }
 
   octave_idx_type nr = arg.rows ();
   octave_idx_type nc = arg.columns ();
 
diff --git a/src/data.cc b/src/data.cc
--- a/src/data.cc
+++ b/src/data.cc
@@ -6200,17 +6200,17 @@ ordered lists.\n\
 %! assert (i, [1, 4, 2, 5, 3])
 
 %!error <Invalid call to sort> sort ();
 %!error <Invalid call to sort> sort (1, 2, 3, 4);
 
 */
 
 // Sort the rows of the matrix @var{a} according to the order
-// specified by @var{mode}, which can either be `ascend' or `descend'
+// specified by @var{mode}, which can either be 'ascend' or 'descend'
 // and return the index vector corresponding to the sort order.
 //
 // This function does not yet support sparse matrices.
 
 DEFUN (__sort_rows_idx__, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} __sort_rows_idx__ (@var{a}, @var{mode})\n\
 Undocumented internal function.\n\
diff --git a/src/debug.cc b/src/debug.cc
--- a/src/debug.cc
+++ b/src/debug.cc
@@ -775,17 +775,17 @@ do_dbtype (std::ostream& os, const std::
                 {
                   line++;
                   if (line >= start && line <= end)
                     os << line << "\t";
                 }
             }
         }
       else
-        os << "dbtype: unable to open `" << ff << "' for reading!\n";
+        os << "dbtype: unable to open '" << ff << "' for reading!\n";
     }
   else
     os << "dbtype: unknown function " << name << "\n";
 
   os.flush ();
 }
 
 DEFUN (dbtype, args, ,
@@ -849,17 +849,17 @@ with line numbers.\n\
                         error ("dbtype: start and end lines must be >= 1\n");
 
                       if (start <= end)
                         do_dbtype (octave_stdout, dbg_fcn->name (), start, end);
                       else
                         error ("dbtype: start line must be less than end line\n");
                     }
                   else
-                    error ("dbtype: line specification must be `start:end'");
+                    error ("dbtype: line specification must be 'start:end'");
                 }
             }
           break;
 
         case 2: // (dbtype func start:end) , (dbtype func start)
           dbg_fcn = get_user_code (argv[1]);
 
           if (dbg_fcn)
diff --git a/src/defun-dld.h b/src/defun-dld.h
--- a/src/defun-dld.h
+++ b/src/defun-dld.h
@@ -39,17 +39,17 @@ along with Octave; see the file COPYING.
 // The first DECLARE_FUN is for the benefit of the installer function
 // and the second is for the definition of the function.
 
 #if defined (MAKE_BUILTINS)
 
 #define DEFUN_DLD(name, args_name, nargout_name, doc) \
   DEFUN_DLD_INTERNAL (name, args_name, nargout_name, doc)
 
-// This one can be used when `name' cannot be used directly (if it is
+// This one can be used when 'name' cannot be used directly (if it is
 // already defined as a macro).  In that case, name is already a
 // quoted string, and the internal name of the function must be passed
 // too (the convention is to use a prefix of "F", so "foo" becomes
 // "Ffoo") as well as the name of the generated installer function
 // (the convention is to use a prefix of "G", so "foo" becomes "Gfoo").
 
 #define DEFUNX_DLD(name, fname, gname, args_name, nargout_name, doc) \
   DEFUNX_DLD_INTERNAL (name, fname, args_name, nargout_name, doc)
diff --git a/src/defun.cc b/src/defun.cc
--- a/src/defun.cc
+++ b/src/defun.cc
@@ -63,17 +63,17 @@ print_usage (const std::string& name)
   feval ("print_usage", octave_value (name), 0);
 }
 
 void
 check_version (const std::string& version, const std::string& fcn)
 {
   if (version != OCTAVE_API_VERSION)
     {
-      error ("API version %s found in .oct file function `%s'\n"
+      error ("API version %s found in .oct file function '%s'\n"
              "       does not match the running Octave (API version %s)\n"
              "       this can lead to incorrect results or other failures\n"
              "       you can fix this problem by recompiling this .oct file",
              version.c_str (), fcn.c_str (), OCTAVE_API_VERSION);
     }
 }
 
 // Install variables and functions in the symbol tables.
diff --git a/src/defun.h b/src/defun.h
--- a/src/defun.h
+++ b/src/defun.h
@@ -39,17 +39,17 @@ along with Octave; see the file COPYING.
 //   nargout_name is the name of the int variable used to pass the
 //     number of output arguments this function is expected to produce.
 //
 //   doc is the simple help text for the function.
 
 #define DEFUN(name, args_name, nargout_name, doc) \
   DEFUN_INTERNAL (name, args_name, nargout_name, doc)
 
-// This one can be used when `name' cannot be used directly (if it is
+// This one can be used when 'name' cannot be used directly (if it is
 // already defined as a macro).  In that case, name is already a
 // quoted string, and the internal name of the function must be passed
 // too (the convention is to use a prefix of "F", so "foo" becomes "Ffoo").
 
 #define DEFUNX(name, fname, args_name, nargout_name, doc) \
   DEFUNX_INTERNAL (name, fname, args_name, nargout_name, doc)
 
 // This is a function with a name that can't be hidden by a variable.
diff --git a/src/dynamic-ld.cc b/src/dynamic-ld.cc
--- a/src/dynamic-ld.cc
+++ b/src/dynamic-ld.cc
@@ -393,17 +393,17 @@ octave_dynamic_loader::do_load_oct (cons
           if (function)
             {
               octave_dld_fcn_getter f
                 = FCN_PTR_CAST (octave_dld_fcn_getter, function);
 
               retval = f (oct_file, relative);
 
               if (! retval)
-                ::error ("failed to install .oct file function `%s'",
+                ::error ("failed to install .oct file function '%s'",
                          fcn_name.c_str ());
             }
         }
       else
         ::error ("%s is not a valid shared library",
                  file_name.c_str ());
     }
 
@@ -463,17 +463,17 @@ octave_dynamic_loader::do_load_mex (cons
                     have_fmex = true;
                 }
             }
 
           if (function)
             retval = new octave_mex_function (function, have_fmex,
                                               mex_file, fcn_name);
           else
-            ::error ("failed to install .mex file function `%s'",
+            ::error ("failed to install .mex file function '%s'",
                      fcn_name.c_str ());
         }
       else
         ::error ("%s is not a valid shared library",
                  file_name.c_str ());
     }
 
   return retval;
diff --git a/src/error.cc b/src/error.cc
--- a/src/error.cc
+++ b/src/error.cc
@@ -105,17 +105,17 @@ int error_state = 0;
 //
 //    0: no warning
 //    1: a warning has occurred
 //
 int warning_state = 0;
 
 // Tell the error handler whether to print messages, or just store
 // them for later.  Used for handling errors in eval() and
-// the `unwind_protect' statement.
+// the 'unwind_protect' statement.
 int buffer_error_messages = 0;
 
 // TRUE means error messages are turned off.
 bool discard_error_messages = false;
 
 // TRUE means warning messages are turned off.
 bool discard_warning_messages = false;
 
@@ -916,20 +916,20 @@ location of the error.  Typically @var{e
                                 pr_where_1 ("error: near line %d", l);
                             }
                         }
                       else
                         {
                           if (l > 0)
                             {
                               if (c > 0)
-                                pr_where_1 ("error: called from `%s' near line %d, column %d",
+                                pr_where_1 ("error: called from '%s' near line %d, column %d",
                                             nm.c_str (), l, c);
                               else
-                                pr_where_1 ("error: called from `%d' near line %d", nm.c_str (), l);
+                                pr_where_1 ("error: called from '%d' near line %d", nm.c_str (), l);
                             }
                         }
                     }
                   else
                     {
                       if (nm.empty ())
                         {
                           if (l > 0)
@@ -941,20 +941,20 @@ location of the error.  Typically @var{e
                                 pr_where_1 ("error: in file %s near line %d", file.c_str (), l);
                             }
                         }
                       else
                         {
                           if (l > 0)
                             {
                               if (c > 0)
-                                pr_where_1 ("error: called from `%s' in file %s near line %d, column %d",
+                                pr_where_1 ("error: called from '%s' in file %s near line %d, column %d",
                                             nm.c_str (), file.c_str (), l, c);
                               else
-                                pr_where_1 ("error: called from `%d' in file %s near line %d", nm.c_str (), file.c_str (), l);
+                                pr_where_1 ("error: called from '%d' in file %s near line %d", nm.c_str (), file.c_str (), l);
                             }
                         }
                     }
                 }
             }
           else
             error ("rethrow: ERR structure must contain the fields 'message and 'identifier'");
         }
@@ -1379,17 +1379,17 @@ warning (\"error\");\n\
 
       if (arg.is_map ())
         {
           octave_map m = arg.map_value ();
 
           if (m.contains ("identifier") && m.contains ("state"))
             warning_options = m;
           else
-            error ("warning: expecting structure with fields `identifier' and `state'");
+            error ("warning: expecting structure with fields 'identifier' and 'state'");
 
           done = true;
 
           if (nargout > 0)
             retval = old_warning_options;
         }
     }
 
diff --git a/src/error.h b/src/error.h
--- a/src/error.h
+++ b/src/error.h
@@ -25,17 +25,17 @@ along with Octave; see the file COPYING.
 
 #include <cstdarg>
 #include <string>
 
 class octave_value_list;
 class unwind_protect;
 
 #define panic_impossible() \
-  panic ("impossible state reached in file `%s' at line %d", \
+  panic ("impossible state reached in file '%s' at line %d", \
          __FILE__, __LINE__)
 
 extern OCTINTERP_API void reset_error_handler (void);
 
 extern OCTINTERP_API int warning_enabled (const std::string& id);
 
 extern OCTINTERP_API void vmessage (const char *name, const char *fmt, va_list args);
 extern OCTINTERP_API void message (const char *name, const char *fmt, ...);
@@ -117,17 +117,17 @@ extern OCTINTERP_API bool Vdebug_on_warn
 // Current error state.
 extern OCTINTERP_API int error_state;
 
 // Current warning state.
 extern OCTINTERP_API int warning_state;
 
 // Tell the error handler whether to print messages, or just store
 // them for later.  Used for handling errors in eval() and
-// the `unwind_protect' statement.
+// the 'unwind_protect' statement.
 extern OCTINTERP_API int buffer_error_messages;
 
 // TRUE means error messages are turned off.
 extern OCTINTERP_API bool discard_error_messages;
 
 // TRUE means warning messages are turned off.
 extern OCTINTERP_API bool discard_warning_messages;
 
diff --git a/src/gl-render.cc b/src/gl-render.cc
--- a/src/gl-render.cc
+++ b/src/gl-render.cc
@@ -574,17 +574,17 @@ opengl_renderer::draw (const graphics_ob
     /* SKIP */;
   else if (go.isa ("uipanel"))
     {
       if (toplevel)
         draw_uipanel (dynamic_cast<const uipanel::properties&> (props), go);
     }
   else
     {
-      warning ("opengl_renderer: cannot render object of type `%s'",
+      warning ("opengl_renderer: cannot render object of type '%s'",
                props.graphics_object_name ().c_str ());
     }
 }
 
 void
 opengl_renderer::draw_figure (const figure::properties& props)
 {
   toolkit = props.get_toolkit ();
@@ -2974,17 +2974,17 @@ opengl_renderer::make_marker_list (const
             ang = (0.5 + double(i+1)/6.0) * M_PI;
             r = 1.0 - (dr * fmod(double(i+1), 2.0));
             glVertex2d (sz*r*cos(ang)/2, sz*r*sin(ang)/2);
           }
         glEnd ();
       }
       break;
     default:
-      warning ("opengl_renderer: unsupported marker `%s'",
+      warning ("opengl_renderer: unsupported marker '%s'",
                marker.c_str ());
       break;
     }
 
   glEndList ();
 
   return ID;
 }
diff --git a/src/graphics.cc b/src/graphics.cc
--- a/src/graphics.cc
+++ b/src/graphics.cc
@@ -1793,17 +1793,17 @@ property_list::set (const caseless_str& 
 
                   if (p != pval_map.end ())
                     pval_map.erase (p);
                 }
               else
                 pval_map[pname] = val;
             }
           else
-            error ("invalid %s property `%s'", pfx.c_str (), pname.c_str ());
+            error ("invalid %s property '%s'", pfx.c_str (), pname.c_str ());
         }
     }
 
   if (! error_state && offset == 0)
     error ("invalid default property specification");
 }
 
 octave_value
@@ -7470,17 +7470,17 @@ gh_manager::do_make_graphics_handle (con
       if (do_createfcn)
         go->get_properties ().execute_createfcn ();
 
       // Notify graphics toolkit.
       if (do_notify_toolkit)
         obj.initialize ();
     }
   else
-    error ("gh_manager::do_make_graphics_handle: invalid object type `%s'",
+    error ("gh_manager::do_make_graphics_handle: invalid object type '%s'",
            go_name.c_str ());
 
   return h;
 }
 
 graphics_handle
 gh_manager::do_make_figure_handle (double val, bool do_notify_toolkit)
 {
@@ -9040,17 +9040,17 @@ gtk_manager::do_get_toolkit (void) const
             pl = loaded_toolkits.find (dtk);
 
           if (error_state || pl == loaded_toolkits.end ())
             error ("failed to load %s graphics toolkit", dtk.c_str ());
           else
             retval = pl->second;
         }
       else
-        error ("default graphics toolkit `%s' is not available!",
+        error ("default graphics toolkit '%s' is not available!",
                dtk.c_str ());
     }
   else
     retval = pl->second;
 
   return retval;
 }
 
@@ -9164,17 +9164,17 @@ undocumented.\n\
           if (args.length () == 1)
             {
               caseless_str val (args(0).string_value ());
 
               if (! error_state && val.compare ("expose"))
                 do_events = false;
               else
                 {
-                  error ("drawnow: invalid argument, expected `expose' as argument");
+                  error ("drawnow: invalid argument, expected 'expose' as argument");
                   return retval;
                 }
             }
 
           if (do_events)
             {
               gh_manager::unlock ();
 
@@ -9206,17 +9206,17 @@ undocumented.\n\
                       if (pos != std::string::npos)
                         {
                           std::string dirname = file.substr (0, pos+1);
 
                           file_stat fs (dirname);
 
                           if (! (fs && fs.is_dir ()))
                             {
-                              error ("drawnow: nonexistent directory `%s'",
+                              error ("drawnow: nonexistent directory '%s'",
                                      dirname.c_str ());
 
                               return retval;
                             }
                         }
                     }
 
                   mono = (args.length () >= 3 ? args(2).bool_value () : false);
@@ -9518,17 +9518,17 @@ addproperty (\"my_style\", gcf, \"lineli
                         {
                           property p = property::create (name, gh, type,
                                                          args.splice (0, 3));
 
                           if (! error_state)
                             go.get_properties ().insert_property (name, p);
                         }
                       else
-                        error ("addproperty: a `%s' property already exists in the graphics object",
+                        error ("addproperty: a '%s' property already exists in the graphics object",
                                name.c_str ());
                     }
                   else
                     error ("addproperty: invalid property TYPE, expected a string value");
                 }
               else
                 error ("addproperty: invalid graphics object (= %g)", h);
             }
@@ -9880,20 +9880,20 @@ In all cases, typing CTRL-C stops progra
             {
               caseless_str s = args(max_arg_index + 1).string_value ();
 
               if (! error_state)
                 {
                   if (s.compare ("timeout"))
                     timeout_index = max_arg_index + 1;
                   else
-                    error ("waitfor: invalid parameter `%s'", s.c_str ());
+                    error ("waitfor: invalid parameter '%s'", s.c_str ());
                 }
               else
-                error ("waitfor: invalid parameter, expected `timeout'");
+                error ("waitfor: invalid parameter, expected 'timeout'");
             }
 
           if (! error_state && timeout_index >= 0)
             {
               if (args.length () > (timeout_index + 1))
                 {
                   timeout = static_cast<int>
                     (args(timeout_index + 1).scalar_value ());
diff --git a/src/gripes.cc b/src/gripes.cc
--- a/src/gripes.cc
+++ b/src/gripes.cc
@@ -98,17 +98,17 @@ void
 gripe_invalid_conversion (const std::string& from, const std::string& to)
 {
   error ("invalid conversion from %s to %s", from.c_str (), to.c_str ());
 }
 
 void
 gripe_invalid_value_specified (const char *name)
 {
-  warning ("invalid value specified for `%s'", name);
+  warning ("invalid value specified for '%s'", name);
 }
 
 void
 gripe_2_or_3_dim_plot (void)
 {
   error ("plot: can only plot in 2 or 3 dimensions");
 }
 
@@ -129,19 +129,19 @@ gripe_data_conversion (const char *from,
 {
   error ("unable to convert from %s to %s format", from, to);
 }
 
 void
 gripe_wrong_type_arg (const char *name, const char *s, bool is_error)
 {
   if (is_error)
-    error ("%s: wrong type argument `%s'", name, s);
+    error ("%s: wrong type argument '%s'", name, s);
   else
-    warning ("%s: wrong type argument `%s'", name, s);
+    warning ("%s: wrong type argument '%s'", name, s);
 }
 
 void
 gripe_wrong_type_arg (const char *name, const std::string& s, bool is_error)
 {
   gripe_wrong_type_arg (name, s.c_str (), is_error);
 }
 
@@ -160,24 +160,24 @@ gripe_wrong_type_arg (const std::string&
 {
   gripe_wrong_type_arg (name.c_str (), tc, is_error);
 }
 
 void
 gripe_wrong_type_arg_for_unary_op (const octave_value& op)
 {
   std::string type = op.type_name ();
-  error ("invalid operand `%s' for unary operator", type.c_str ());
+  error ("invalid operand '%s' for unary operator", type.c_str ());
 }
 
 void
 gripe_wrong_type_arg_for_binary_op (const octave_value& op)
 {
   std::string type = op.type_name ();
-  error ("invalid operand `%s' for binary operator", type.c_str ());
+  error ("invalid operand '%s' for binary operator", type.c_str ());
 }
 
 void
 gripe_implicit_conversion (const char *id, const char *from, const char *to)
 {
   warning_with_id (id, "implicit conversion from %s to %s", from, to);
 }
 
diff --git a/src/input.cc b/src/input.cc
--- a/src/input.cc
+++ b/src/input.cc
@@ -417,17 +417,17 @@ octave_read (char *buf, unsigned max_siz
       status = 0;
     }
   else
     status = -1;
 
   return status;
 }
 
-// Fix things up so that input can come from file `name', printing a
+// Fix things up so that input can come from file 'name', printing a
 // warning if the file doesn't exist.
 
 FILE *
 get_input_from_file (const std::string& name, int warn)
 {
   FILE *instream = 0;
 
   if (name.length () > 0)
diff --git a/src/lex.ll b/src/lex.ll
--- a/src/lex.ll
+++ b/src/lex.ll
@@ -102,17 +102,17 @@ along with Octave; see the file COPYING.
 #undef YY_INPUT
 #endif
 #define YY_INPUT(buf, result, max_size) \
   if ((result = octave_read (buf, max_size)) < 0) \
     YY_FATAL_ERROR ("octave_read () in flex scanner failed");
 
 // Try to avoid crashing out completely on fatal scanner errors.
 // The call to yy_fatal_error should never happen, but it avoids a
-// `static function defined but not used' warning from gcc.
+// 'static function defined but not used' warning from gcc.
 
 #ifdef YY_FATAL_ERROR
 #undef YY_FATAL_ERROR
 #endif
 #define YY_FATAL_ERROR(msg) \
   do \
     { \
       error (msg); \
@@ -424,17 +424,17 @@ NUMBER  (({D}+\.?{D}*{EXPON}?)|(\.{D}+{E
     lexer_flags.looking_for_object_index = false;
     lexer_flags.at_beginning_of_statement = false;
 
     TOK_PUSH_AND_RETURN (tok, SQ_STRING);
   }
 
 %{
 // For this and the next two rules, we're looking at ']', and we
-// need to know if the next token is `=' or `=='.
+// need to know if the next token is '=' or '=='.
 //
 // It would have been so much easier if the delimiters were simply
 // different for the expression on the left hand side of the equals
 // operator.
 //
 // It's also a pain in the ass to decide whether to insert a comma
 // after seeing a ']' character...
 
@@ -666,17 +666,17 @@ NUMBER  (({D}+\.?{D}*{EXPON}?)|(\.{D}+{E
 {NUMBER}{Im} {
     LEXER_DEBUG ("{NUMBER}{Im}");
 
     handle_number ();
     COUNT_TOK_AND_RETURN (IMAG_NUM);
   }
 
 %{
-// Real numbers.  Don't grab the `.' part of a dot operator as part of
+// Real numbers.  Don't grab the '.' part of a dot operator as part of
 // the constant.
 %}
 
 {D}+/\.[\*/\\^\'] |
 {NUMBER} {
     LEXER_DEBUG ("{D}+/\\.[\\*/\\^\\']|{NUMBER}");
     handle_number ();
     COUNT_TOK_AND_RETURN (NUM);
@@ -715,17 +715,17 @@ NUMBER  (({D}+\.?{D}*{EXPON}?)|(\.{D}+{E
     LEXER_DEBUG ("<<EOF>>");
 
     if (block_comment_nesting_level != 0)
       {
         warning ("block comment open at end of input");
 
         if ((reading_fcn_file || reading_script_file || reading_classdef_file)
             && ! curr_fcn_file_name.empty ())
-          warning ("near line %d of file `%s.m'",
+          warning ("near line %d of file '%s.m'",
                    input_line_number, curr_fcn_file_name.c_str ());
       }
 
     TOK_RETURN (END_OF_INPUT);
   }
 
 %{
 // Identifiers.  Truncate the token at the first space or tab but
@@ -1063,17 +1063,17 @@ NUMBER  (({D}+\.?{D}*{EXPON}?)|(\.{D}+{E
     xunput (yytext[0], yytext);
 
     int c = text_yyinput ();
 
     if (c != EOF)
       {
         current_input_column++;
 
-        error ("invalid character `%s' (ASCII %d) near line %d, column %d",
+        error ("invalid character '%s' (ASCII %d) near line %d, column %d",
                undo_string_escape (static_cast<char> (c)), c,
                input_line_number, current_input_column);
 
         return LEXICAL_ERROR;
       }
     else
       TOK_RETURN (END_OF_INPUT);
   }
@@ -2523,17 +2523,17 @@ cleanup:
 
   int len = s.length ();
   while (len--)
     xunput (s[len], yytext);
 
   return false;
 }
 
-// We have seen a `.' and need to see if it is the start of a
+// We have seen a '.' and need to see if it is the start of a
 // continuation.  If so, this eats it, up to and including the new
 // line character.
 
 static bool
 have_ellipsis_continuation (bool trailing_comments_ok)
 {
   char c1 = text_yyinput ();
   if (c1 == '.')
@@ -3314,17 +3314,17 @@ handle_identifier (void)
 
   xunput (c1, yytext);
 
   // Kluge alert.
   //
   // If we are looking at a text style function, set up to gobble its
   // arguments.
   //
-  // If the following token is `=', or if we are parsing a function
+  // If the following token is '=', or if we are parsing a function
   // return list or function parameter list, or if we are looking at
   // something like [ab,cd] = foo (), force the symbol to be inserted
   // as a variable in the current symbol table.
 
   if (! is_variable (tok))
     {
       if (at_bos && spc_gobbled && can_be_command (tok)
           && looks_like_command_arg ())
@@ -3513,21 +3513,21 @@ prep_lexer_for_function_file (void)
 
 static void
 maybe_warn_separator_insert (char sep)
 {
   std::string nm = curr_fcn_file_full_name;
 
   if (nm.empty ())
     warning_with_id ("Octave:separator-insert",
-                     "potential auto-insertion of `%c' near line %d",
+                     "potential auto-insertion of '%c' near line %d",
                      sep, input_line_number);
   else
     warning_with_id ("Octave:separator-insert",
-                     "potential auto-insertion of `%c' near line %d of file %s",
+                     "potential auto-insertion of '%c' near line %d of file %s",
                      sep, input_line_number, nm.c_str ());
 }
 
 static void
 gripe_single_quote_string (void)
 {
   std::string nm = curr_fcn_file_full_name;
 
diff --git a/src/load-path.cc b/src/load-path.cc
--- a/src/load-path.cc
+++ b/src/load-path.cc
@@ -632,17 +632,17 @@ strip_trailing_separators (const std::st
 
 void
 load_path::do_add (const std::string& dir_arg, bool at_end, bool warn)
 {
   size_t len = dir_arg.length ();
 
   if (len > 1 && dir_arg.substr (len-2) == "//")
     warning_with_id ("Octave:recursive-path-search",
-                     "trailing `//' is no longer special in search path elements");
+                     "trailing '//' is no longer special in search path elements");
 
   std::string dir = file_ops::tilde_expand (dir_arg);
 
   dir = strip_trailing_separators (dir);
 
   dir_info_list_iterator i = find_dir_info (dir);
 
   if (i != dir_info_list.end ())
diff --git a/src/load-save.cc b/src/load-save.cc
--- a/src/load-save.cc
+++ b/src/load-save.cc
@@ -116,29 +116,29 @@ default_save_header_format (void)
                  ", %a %b %d %H:%M:%S %Y %Z <")
     + octave_env::get_user_name ()
     + std::string ("@")
     + octave_env::get_host_name ()
     + std::string (">");
 }
 
 // The format string for the comment line at the top of text-format
-// save files.  Passed to strftime.  Should begin with `#' and contain
+// save files.  Passed to strftime.  Should begin with '#' and contain
 // no newline characters.
 static std::string Vsave_header_format_string = default_save_header_format ();
 
 static void
 gripe_file_open (const std::string& fcn, const std::string& file)
 {
   if (fcn == "load")
-    error ("%s: unable to open input file `%s'", fcn.c_str (), file.c_str ());
+    error ("%s: unable to open input file '%s'", fcn.c_str (), file.c_str ());
   else if (fcn == "save")
-    error ("%s: unable to open output file `%s'", fcn.c_str (), file.c_str ());
+    error ("%s: unable to open output file '%s'", fcn.c_str (), file.c_str ());
   else
-    error ("%s: unable to open file `%s'", fcn.c_str (), file.c_str ());
+    error ("%s: unable to open file '%s'", fcn.c_str (), file.c_str ());
 }
 
 // Install a variable with name NAME and the value VAL in the
 // symbol table.  If GLOBAL is TRUE, make the variable global.
 
 static void
 install_loaded_variable (const std::string& name,
                          const octave_value& val,
@@ -389,17 +389,17 @@ do_load (std::istream& stream, const std
 
       if (error_state || stream.eof () || name.empty ())
         break;
       else if (! error_state && ! name.empty ())
         {
           if (tc.is_defined ())
             {
               if (format == LS_MAT_ASCII && argv_idx < argc)
-                warning ("load: loaded ASCII file `%s' -- ignoring extra args",
+                warning ("load: loaded ASCII file '%s' -- ignoring extra args",
                          orig_fname.c_str ());
 
               if (format == LS_MAT_ASCII
                   || argv_idx == argc
                   || matches_patterns (argv, argv_idx, argc, name))
                 {
                   count++;
                   if (list_only)
@@ -437,22 +437,22 @@ do_load (std::istream& stream, const std
                 }
 
               // Only attempt to read one item from a headless text file.
 
               if (format == LS_MAT_ASCII)
                 break;
             }
           else
-            error ("load: unable to load variable `%s'", name.c_str ());
+            error ("load: unable to load variable '%s'", name.c_str ());
         }
       else
         {
           if (count == 0)
-            error ("load: are you sure `%s' is an Octave data file?",
+            error ("load: are you sure '%s' is an Octave data file?",
                    orig_fname.c_str ());
 
           break;
         }
     }
 
   if (list_only && count)
     {
@@ -868,17 +868,17 @@ Force Octave to assume the file is in Oc
 
                   retval = do_load (file, orig_fname, format,
                                     flt_fmt, list_only, swap, verbose,
                                     argv, i, argc, nargout);
 
                   file.close ();
                 }
               else
-                error ("load: unable to open input file `%s'",
+                error ("load: unable to open input file '%s'",
                        orig_fname.c_str ());
             }
         }
     }
 
   return retval;
 }
 
@@ -1264,53 +1264,53 @@ save_vars (const string_vector& argv, in
           error ("save: missing struct name");
           return;
         }
 
       std::string struct_name = argv[argv_idx];
 
       if (! symbol_table::is_variable (struct_name))
         {
-          error ("save: no such variable: `%s'", struct_name.c_str ());
+          error ("save: no such variable: '%s'", struct_name.c_str ());
           return;
         }
 
       octave_value struct_var = symbol_table::varref (struct_name);
 
       if (! struct_var.is_map () || struct_var.numel () != 1)
         {
-          error ("save: `%s' is not a scalar structure",
+          error ("save: '%s' is not a scalar structure",
                  struct_name.c_str ());
           return;
         }
       octave_scalar_map struct_var_map = struct_var.scalar_map_value ();
 
       ++argv_idx;
 
       if (argv_idx < argc)
         {
           for (int i = argv_idx; i < argc; i++)
             {
               if (! save_fields (os, struct_var_map, argv[i], fmt,
                                  save_as_floats))
                 {
-                  warning ("save: no such field `%s.%s'",
+                  warning ("save: no such field '%s.%s'",
                            struct_name.c_str (), argv[i].c_str ());
                 }
             }
         }
       else
         save_fields (os, struct_var_map, "*", fmt, save_as_floats);
     }
   else
     {
       for (int i = argv_idx; i < argc; i++)
         {
           if (! save_vars (os, argv[i], fmt, save_as_floats))
-            warning ("save: no such variable `%s'", argv[i].c_str ());
+            warning ("save: no such variable '%s'", argv[i].c_str ());
         }
     }
 }
 
 static void
 dump_octave_core (std::ostream& os, const char *fname, load_save_format fmt,
                   bool save_as_floats)
 {
@@ -1345,29 +1345,29 @@ dump_octave_core (std::ostream& os, cons
               do_save (os, val, name, help, global, fmt, save_as_floats);
 
               if (error_state)
                 break;
             }
         }
     }
 
-  message (0, "save to `%s' complete", fname);
+  message (0, "save to '%s' complete", fname);
 }
 
 void
 dump_octave_core (void)
 {
   if (Vcrash_dumps_octave_core)
     {
       // FIXME -- should choose better file name?
 
       const char *fname = Voctave_core_file_name.c_str ();
 
-      message (0, "attempting to save variables to `%s'...", fname);
+      message (0, "attempting to save variables to '%s'...", fname);
 
       load_save_format format = LS_BINARY;
 
       bool save_as_floats = false;
 
       bool append = false;
 
       bool use_zlib = false;
@@ -1399,17 +1399,17 @@ dump_octave_core (void)
 
           if (file.file_id >= 0)
             {
               dump_octave_core (file, fname, format, save_as_floats);
 
               file.close ();
             }
           else
-            warning ("unable to open `%s' for writing...", fname);
+            warning ("unable to open '%s' for writing...", fname);
         }
       else
 #endif /* HAVE_HDF5 */
         // don't insert any commands here!  The open brace below must
         // go with the else above!
         {
 #ifdef HAVE_ZLIB
           if (use_zlib)
@@ -1418,31 +1418,31 @@ dump_octave_core (void)
 
               if (file)
                 {
                   dump_octave_core (file, fname, format, save_as_floats);
 
                   file.close ();
                 }
               else
-                warning ("unable to open `%s' for writing...", fname);
+                warning ("unable to open '%s' for writing...", fname);
             }
           else
 #endif
             {
               std::ofstream file (fname, mode);
 
               if (file)
                 {
                   dump_octave_core (file, fname, format, save_as_floats);
 
                   file.close ();
                 }
               else
-                warning ("unable to open `%s' for writing...", fname);
+                warning ("unable to open '%s' for writing...", fname);
             }
         }
     }
 }
 
 
 DEFUN (save, args, ,
   "-*- texinfo -*-\n\
@@ -1631,17 +1631,17 @@ the file @file{data} in Octave's binary 
           // FIXME -- should things intended for the screen end up
           // in a octave_value (string)?
 
           save_vars (argv, i, argc, octave_stdout, format,
                      save_as_floats, true);
         }
     }
 
-  // Guard against things like `save a*', which are probably mistakes...
+  // Guard against things like 'save a*', which are probably mistakes...
 
   else if (i == argc - 1 && glob_pattern_p (argv[i]))
     {
       print_usage ();
       return retval;
     }
   else
     {
diff --git a/src/ls-hdf5.cc b/src/ls-hdf5.cc
--- a/src/ls-hdf5.cc
+++ b/src/ls-hdf5.cc
@@ -433,26 +433,26 @@ hdf5_read_next_data (hid_t group_id, con
             case H5T_NATIVE_ULLONG:
               int_typ = "uint64 ";
               break;
             }
 #else
           hid_t int_sign = H5Tget_sign (type_id);
 
           if (int_sign == H5T_SGN_ERROR)
-            warning ("load: can't read `%s' (unknown datatype)", name);
+            warning ("load: can't read '%s' (unknown datatype)", name);
           else
             {
               if (int_sign == H5T_SGN_NONE)
                 int_typ.append ("u");
               int_typ.append ("int");
 
               int slen = H5Tget_size (type_id);
               if (slen < 0)
-                warning ("load: can't read `%s' (unknown datatype)", name);
+                warning ("load: can't read '%s' (unknown datatype)", name);
               else
                 {
                   switch (slen)
                     {
                     case 1:
                       int_typ.append ("8 ");
                       break;
 
@@ -464,26 +464,26 @@ hdf5_read_next_data (hid_t group_id, con
                       int_typ.append ("32 ");
                       break;
 
                     case 8:
                       int_typ.append ("64 ");
                       break;
 
                     default:
-                      warning ("load: can't read `%s' (unknown datatype)",
+                      warning ("load: can't read '%s' (unknown datatype)",
                                name);
                       int_typ = "";
                       break;
                     }
                 }
             }
 #endif
           if (int_typ == "")
-            warning ("load: can't read `%s' (unknown datatype)", name);
+            warning ("load: can't read '%s' (unknown datatype)", name);
           else
             {
               // Matrix or scalar?
               space_id = H5Dget_space (data_id);
 
               hsize_t rank = H5Sget_simple_extent_ndims (space_id);
 
               if (rank == 0)
@@ -518,34 +518,34 @@ hdf5_read_next_data (hid_t group_id, con
             // Assume that if its not complex its a range. If its not
             // it'll be rejected later in the range code
             d->tc = octave_value_typeinfo::lookup_type ("range");
 
           H5Tclose (complex_type);
         }
       else
         {
-          warning ("load: can't read `%s' (unknown datatype)", name);
+          warning ("load: can't read '%s' (unknown datatype)", name);
           retval = 0; // unknown datatype; skip
         }
 
       // check for OCTAVE_GLOBAL attribute:
       d->global = hdf5_check_attr (data_id, "OCTAVE_GLOBAL");
 
       H5Tclose (type_id);
       H5Dclose (data_id);
 
       retval = (d->tc.load_hdf5 (group_id, name) ? 1 : -1);
     }
 
   if (!ident_valid)
     {
       // should we attempt to handle invalid identifiers by converting
       // bad characters to '_', say?
-      warning ("load: skipping invalid identifier `%s' in hdf5 file",
+      warning ("load: skipping invalid identifier '%s' in hdf5 file",
                name);
     }
 
  done:
   if (retval < 0)
     error ("load: error while reading hdf5 item %s", name);
 
   if (retval > 0)
@@ -894,17 +894,17 @@ add_hdf5_data (hid_t loc_id, const octav
 
   if (space_id >= 0)
     H5Sclose (space_id);
 
   if (data_id >= 0)
     H5Gclose (data_id);
 
   if (! retval)
-    error ("save: error while writing `%s' to hdf5 file", name.c_str ());
+    error ("save: error while writing '%s' to hdf5 file", name.c_str ());
 
   return retval;
 }
 
 // Write data from TC in HDF5 (binary) format to the stream OS,
 // which must be an hdf5_ofstream, returning true on success.
 
 bool
diff --git a/src/ls-mat-ascii.cc b/src/ls-mat-ascii.cc
--- a/src/ls-mat-ascii.cc
+++ b/src/ls-mat-ascii.cc
@@ -173,17 +173,17 @@ get_lines_and_columns (std::istream& is,
             nr++;
           else
             error ("load: %s: inconsistent number of columns near line %d",
                    filename.c_str (), file_line_number);
         }
     }
 
   if (nr == 0 || nc == 0)
-    error ("load: file `%s' seems to be empty!", filename.c_str ());
+    error ("load: file '%s' seems to be empty!", filename.c_str ());
 
   is.clear ();
   is.seekg (pos);
 }
 
 // Extract a matrix from a file of numbers only.
 //
 // Comments are not allowed.  The file should only have numeric values.
@@ -279,17 +279,17 @@ read_mat_ascii_data (std::istream& is, c
                                 }
                             }
 
                           if (tmp_stream.eof ())
                             break;
                         }
                       else
                         {
-                          error ("load: failed to read matrix from file `%s'",
+                          error ("load: failed to read matrix from file '%s'",
                                  filename.c_str ());
 
                           return retval;
                         }
 
                     }
                 }
             }
@@ -308,25 +308,25 @@ read_mat_ascii_data (std::istream& is, c
                   tc = tmp;
                   retval = varname;
                 }
               else
                 error ("load: expected %d elements, found %d",
                        expected, total_count);
             }
           else
-            error ("load: failed to read matrix from file `%s'",
+            error ("load: failed to read matrix from file '%s'",
                    filename.c_str ());
         }
       else
-        error ("load: unable to extract matrix size from file `%s'",
+        error ("load: unable to extract matrix size from file '%s'",
                filename.c_str ());
     }
   else
-    error ("load: unable to convert filename `%s' to valid identifier",
+    error ("load: unable to convert filename '%s' to valid identifier",
            filename.c_str ());
 
   return retval;
 }
 
 bool
 save_mat_ascii_data (std::ostream& os, const octave_value& val,
                      int precision, bool tabs)
diff --git a/src/ls-mat4.cc b/src/ls-mat4.cc
--- a/src/ls-mat4.cc
+++ b/src/ls-mat4.cc
@@ -390,30 +390,30 @@ read_mat_binary_data (std::istream& is, 
     else
       {
         re.resize (nr, nc);
 
         read_mat_binary_data (is, re.fortran_vec (), prec, dlen, swap, flt_fmt);
 
         if (! is || error_state)
           {
-            error ("load: reading matrix data for `%s'", name);
+            error ("load: reading matrix data for '%s'", name);
             goto data_read_error;
           }
 
         if (imag)
           {
             Matrix im (nr, nc);
 
             read_mat_binary_data (is, im.fortran_vec (), prec, dlen, swap,
                                   flt_fmt);
 
             if (! is || error_state)
               {
-                error ("load: reading imaginary matrix data for `%s'", name);
+                error ("load: reading imaginary matrix data for '%s'", name);
                 goto data_read_error;
               }
 
             ComplexMatrix ctmp (nr, nc);
 
             for (octave_idx_type j = 0; j < nc; j++)
               for (octave_idx_type i = 0; i < nr; i++)
                 ctmp (i, j) = Complex (re (i, j), im (i, j));
@@ -426,17 +426,17 @@ read_mat_binary_data (std::istream& is, 
         if (type == 1)
           tc = tc.convert_to_str (false, true, '\'');
       }
 
       return retval;
     }
 
  data_read_error:
-  error ("load: trouble reading binary file `%s'", filename.c_str ());
+  error ("load: trouble reading binary file '%s'", filename.c_str ());
   return retval;
 }
 
 // Save the data from TC along with the corresponding NAME on stream OS
 // in the MatLab version 4 binary format.
 
 bool
 save_mat_binary_data (std::ostream& os, const octave_value& tc,
diff --git a/src/ls-mat5.cc b/src/ls-mat5.cc
--- a/src/ls-mat5.cc
+++ b/src/ls-mat5.cc
@@ -369,52 +369,52 @@ read_mat5_integer_data (std::istream& is
 #define OCTAVE_MAT5_INTEGER_READ(TYP) \
   { \
         TYP re (dims); \
   \
         std::streampos tmp_pos; \
   \
         if (read_mat5_tag (is, swap, type, len)) \
           { \
-            error ("load: reading matrix data for `%s'", retval.c_str ()); \
+            error ("load: reading matrix data for '%s'", retval.c_str ()); \
             goto data_read_error; \
           } \
   \
         octave_idx_type n = re.numel (); \
         tmp_pos = is.tellg (); \
         read_mat5_integer_data (is, re.fortran_vec (), n, swap, \
                                 static_cast<enum mat5_data_type> (type)); \
   \
         if (! is || error_state) \
           { \
-            error ("load: reading matrix data for `%s'", retval.c_str ()); \
+            error ("load: reading matrix data for '%s'", retval.c_str ()); \
             goto data_read_error; \
           } \
   \
         is.seekg (tmp_pos + static_cast<std::streamoff> (PAD (len))); \
   \
         if (imag) \
           { \
             /* We don't handle imag integer types, convert to an array */ \
             NDArray im (dims); \
   \
             if (read_mat5_tag (is, swap, type, len)) \
               { \
-                error ("load: reading matrix data for `%s'", \
+                error ("load: reading matrix data for '%s'", \
                        retval.c_str ()); \
                 goto data_read_error; \
               } \
   \
             n = im.numel (); \
             read_mat5_binary_data (is, im.fortran_vec (), n, swap, \
                                    static_cast<enum mat5_data_type> (type), flt_fmt); \
   \
             if (! is || error_state) \
               { \
-                error ("load: reading imaginary matrix data for `%s'", \
+                error ("load: reading imaginary matrix data for '%s'", \
                        retval.c_str ()); \
                 goto data_read_error; \
               } \
   \
             ComplexNDArray ctmp (dims); \
   \
             for (octave_idx_type i = 0; i < n; i++) \
               ctmp(i) = Complex (re(i).double_value (), im(i)); \
@@ -709,17 +709,17 @@ read_mat5_binary_element (std::istream& 
           {
             octave_value tc2;
 
             std::string nm
               = read_mat5_binary_element (is, filename, swap, global, tc2);
 
             if (! is || error_state)
               {
-                error ("load: reading cell data for `%s'", nm.c_str ());
+                error ("load: reading cell data for '%s'", nm.c_str ());
                 goto data_read_error;
               }
 
             cell_array(i) = tc2;
           }
 
         tc = cell_array;
       }
@@ -751,57 +751,57 @@ read_mat5_binary_element (std::istream& 
             data = sm.data ();
           }
 
         // row indices
         std::streampos tmp_pos;
 
         if (read_mat5_tag (is, swap, type, len))
           {
-            error ("load: reading sparse row data for `%s'", retval.c_str ());
+            error ("load: reading sparse row data for '%s'", retval.c_str ());
             goto data_read_error;
           }
 
         tmp_pos = is.tellg ();
 
         read_mat5_integer_data (is, ridx, nzmax, swap,
                                 static_cast<enum mat5_data_type> (type));
 
         if (! is || error_state)
           {
-            error ("load: reading sparse row data for `%s'", retval.c_str ());
+            error ("load: reading sparse row data for '%s'", retval.c_str ());
             goto data_read_error;
           }
 
         is.seekg (tmp_pos + static_cast<std::streamoff> (PAD (len)));
 
         // col indices
         if (read_mat5_tag (is, swap, type, len))
           {
-            error ("load: reading sparse column data for `%s'", retval.c_str ());
+            error ("load: reading sparse column data for '%s'", retval.c_str ());
             goto data_read_error;
           }
 
         tmp_pos = is.tellg ();
 
         read_mat5_integer_data (is, cidx, nc + 1, swap,
                                 static_cast<enum mat5_data_type> (type));
 
         if (! is || error_state)
           {
-            error ("load: reading sparse column data for `%s'", retval.c_str ());
+            error ("load: reading sparse column data for '%s'", retval.c_str ());
             goto data_read_error;
           }
 
         is.seekg (tmp_pos + static_cast<std::streamoff> (PAD (len)));
 
         // real data subelement
         if (read_mat5_tag (is, swap, type, len))
           {
-            error ("load: reading sparse matrix data for `%s'", retval.c_str ());
+            error ("load: reading sparse matrix data for '%s'", retval.c_str ());
             goto data_read_error;
           }
 
         octave_idx_type nnz = cidx[nc];
         NDArray re;
         if (imag)
           {
             re = NDArray (dim_vector (nnz, 1));
@@ -809,39 +809,39 @@ read_mat5_binary_element (std::istream& 
           }
 
         tmp_pos = is.tellg ();
         read_mat5_binary_data (is, data, nnz, swap,
                                static_cast<enum mat5_data_type> (type), flt_fmt);
 
         if (! is || error_state)
           {
-            error ("load: reading sparse matrix data for `%s'", retval.c_str ());
+            error ("load: reading sparse matrix data for '%s'", retval.c_str ());
             goto data_read_error;
           }
 
         is.seekg (tmp_pos + static_cast<std::streamoff> (PAD (len)));
 
         // imaginary data subelement
         if (imag)
           {
             NDArray im (dim_vector (static_cast<int> (nnz), 1));
 
             if (read_mat5_tag (is, swap, type, len))
               {
-                error ("load: reading sparse matrix data for `%s'", retval.c_str ());
+                error ("load: reading sparse matrix data for '%s'", retval.c_str ());
                 goto data_read_error;
               }
 
             read_mat5_binary_data (is, im.fortran_vec (), nnz, swap,
                                    static_cast<enum mat5_data_type> (type), flt_fmt);
 
             if (! is || error_state)
               {
-                error ("load: reading imaginary sparse matrix data for `%s'",
+                error ("load: reading imaginary sparse matrix data for '%s'",
                        retval.c_str ());
                 goto data_read_error;
               }
 
             for (octave_idx_type i = 0; i < nnz; i++)
               scm.xdata (i) = Complex (re (i), im (i));
 
             tc = scm;
@@ -1314,52 +1314,52 @@ read_mat5_binary_element (std::istream& 
         FloatNDArray re (dims);
 
         // real data subelement
 
         std::streampos tmp_pos;
 
         if (read_mat5_tag (is, swap, type, len))
           {
-            error ("load: reading matrix data for `%s'", retval.c_str ());
+            error ("load: reading matrix data for '%s'", retval.c_str ());
             goto data_read_error;
           }
 
         octave_idx_type n = re.numel ();
         tmp_pos = is.tellg ();
         read_mat5_binary_data (is, re.fortran_vec (), n, swap,
                                static_cast<enum mat5_data_type> (type), flt_fmt);
 
         if (! is || error_state)
           {
-            error ("load: reading matrix data for `%s'", retval.c_str ());
+            error ("load: reading matrix data for '%s'", retval.c_str ());
             goto data_read_error;
           }
 
         is.seekg (tmp_pos + static_cast<std::streamoff> (PAD (len)));
 
         if (imag)
           {
             // imaginary data subelement
 
             FloatNDArray im (dims);
 
             if (read_mat5_tag (is, swap, type, len))
               {
-                error ("load: reading matrix data for `%s'", retval.c_str ());
+                error ("load: reading matrix data for '%s'", retval.c_str ());
                 goto data_read_error;
               }
 
             n = im.numel ();
             read_mat5_binary_data (is, im.fortran_vec (), n, swap,
                                    static_cast<enum mat5_data_type> (type), flt_fmt);
 
             if (! is || error_state)
               {
-                error ("load: reading imaginary matrix data for `%s'",
+                error ("load: reading imaginary matrix data for '%s'",
                        retval.c_str ());
                 goto data_read_error;
               }
 
             FloatComplexNDArray ctmp (dims);
 
             for (octave_idx_type i = 0; i < n; i++)
               ctmp(i) = FloatComplex (re(i), im(i));
@@ -1380,28 +1380,28 @@ read_mat5_binary_element (std::istream& 
         NDArray re (dims);
 
         // real data subelement
 
         std::streampos tmp_pos;
 
         if (read_mat5_tag (is, swap, type, len))
           {
-            error ("load: reading matrix data for `%s'", retval.c_str ());
+            error ("load: reading matrix data for '%s'", retval.c_str ());
             goto data_read_error;
           }
 
         octave_idx_type n = re.numel ();
         tmp_pos = is.tellg ();
         read_mat5_binary_data (is, re.fortran_vec (), n, swap,
                                static_cast<enum mat5_data_type> (type), flt_fmt);
 
         if (! is || error_state)
           {
-            error ("load: reading matrix data for `%s'", retval.c_str ());
+            error ("load: reading matrix data for '%s'", retval.c_str ());
             goto data_read_error;
           }
 
         is.seekg (tmp_pos + static_cast<std::streamoff> (PAD (len)));
 
         if (logicalvar)
           {
             // Logical variables can either be MAT_FILE_UINT8_CLASS or
@@ -1418,27 +1418,27 @@ read_mat5_binary_element (std::istream& 
         else if (imag)
           {
             // imaginary data subelement
 
             NDArray im (dims);
 
             if (read_mat5_tag (is, swap, type, len))
               {
-                error ("load: reading matrix data for `%s'", retval.c_str ());
+                error ("load: reading matrix data for '%s'", retval.c_str ());
                 goto data_read_error;
               }
 
             n = im.numel ();
             read_mat5_binary_data (is, im.fortran_vec (), n, swap,
                                    static_cast<enum mat5_data_type> (type), flt_fmt);
 
             if (! is || error_state)
               {
-                error ("load: reading imaginary matrix data for `%s'",
+                error ("load: reading imaginary matrix data for '%s'",
                        retval.c_str ());
                 goto data_read_error;
               }
 
             ComplexNDArray ctmp (dims);
 
             for (octave_idx_type i = 0; i < n; i++)
               ctmp(i) = Complex (re(i), im(i));
@@ -1500,21 +1500,21 @@ read_mat5_binary_element (std::istream& 
 
   if (is.eof ())
     is.clear ();
 
   return retval;
 
  data_read_error:
  early_read_error:
-  error ("load: trouble reading binary file `%s'", filename.c_str ());
+  error ("load: trouble reading binary file '%s'", filename.c_str ());
   return std::string ();
 
  skip_ahead:
-  warning ("skipping over `%s'", retval.c_str ());
+  warning ("skipping over '%s'", retval.c_str ());
   is.seekg (pos + static_cast<std::streamoff> (element_length));
   return read_mat5_binary_element (is, filename, swap, global, tc);
 }
 
 int
 read_mat5_binary_file_header (std::istream& is, bool& swap, bool quiet,
                               const std::string& filename)
 {
@@ -2708,12 +2708,12 @@ save_mat5_binary_element (std::ostream& 
     }
   else
     gripe_wrong_type_arg ("save", tc, false);
 
  skip_to_next:
   return true;
 
  error_cleanup:
-  error ("save: error while writing `%s' to MAT file", name.c_str ());
+  error ("save: error while writing '%s' to MAT file", name.c_str ());
 
   return false;
 }
diff --git a/src/ls-oct-ascii.cc b/src/ls-oct-ascii.cc
--- a/src/ls-oct-ascii.cc
+++ b/src/ls-oct-ascii.cc
@@ -150,17 +150,17 @@ extract_keyword (std::istream& is, const
 // function is extensible.
 //
 // FILENAME is used for error messages.
 //
 // The data is expected to be in the following format:
 //
 // The input file must have a header followed by some data.
 //
-// All lines in the header must begin with a `#' character.
+// All lines in the header must begin with a '#' character.
 //
 // The header must contain a list of keyword and value pairs with the
 // keyword and value separated by a colon.
 //
 // Keywords must appear in the following order:
 //
 // # name: <name>
 // # type: <type>
@@ -239,26 +239,26 @@ read_ascii_data (std::istream& is, const
 {
   // Read name for this entry or break on EOF.
 
   std::string name = extract_keyword (is, "name");
 
   if (name.empty ())
     {
       if (count == 0)
-        error ("load: empty name keyword or no data found in file `%s'",
+        error ("load: empty name keyword or no data found in file '%s'",
                filename.c_str ());
 
       return std::string ();
     }
 
   if (! (name == ".nargin." || name == ".nargout."
          || name == CELL_ELT_TAG || valid_identifier (name)))
     {
-      error ("load: bogus identifier `%s' found in file `%s'",
+      error ("load: bogus identifier '%s' found in file '%s'",
              name.c_str (), filename.c_str ());
       return std::string ();
     }
 
   // Look for type keyword.
 
   std::string tag = extract_keyword (is, "type");
 
@@ -278,17 +278,17 @@ read_ascii_data (std::istream& is, const
 
       // Special case for backward compatiablity. A small bit of cruft
       if (SUBSTRING_COMPARE_EQ (typ, 0, 12, "string array"))
         tc = charMatrix ();
       else
         tc = octave_value_typeinfo::lookup_type (typ);
 
       if (! tc.load_ascii (is))
-        error ("load: trouble reading ascii file `%s'", filename.c_str ());
+        error ("load: trouble reading ascii file '%s'", filename.c_str ());
     }
   else
     error ("load: failed to extract keyword specifying value type");
 
   if (error_state)
     {
       error ("load: reading file %s", filename.c_str ());
       return std::string ();
diff --git a/src/ls-oct-binary.cc b/src/ls-oct-binary.cc
--- a/src/ls-oct-binary.cc
+++ b/src/ls-oct-binary.cc
@@ -251,17 +251,17 @@ read_binary_data (std::istream& is, bool
     default:
       goto data_read_error;
       break;
     }
 
   if (!tc.load_binary (is, swap, fmt))
     {
     data_read_error:
-      error ("load: trouble reading binary file `%s'", filename.c_str ());
+      error ("load: trouble reading binary file '%s'", filename.c_str ());
     }
 
   return retval;
 }
 
 // Save the data from TC along with the corresponding NAME, help
 // string DOC, and global flag MARK_AS_GLOBAL on stream OS in the
 // binary format described above for read_binary_data.
diff --git a/src/oct-hist.cc b/src/oct-hist.cc
--- a/src/oct-hist.cc
+++ b/src/oct-hist.cc
@@ -144,29 +144,29 @@ do_history (int argc, const string_vecto
 
       if (option == "-r" || option == "-w" || option == "-a"
           || option == "-n")
         {
           if (i < argc - 1)
             command_history::set_file (argv[i+1]);
 
           if (option == "-a")
-            // Append `new' lines to file.
+            // Append 'new' lines to file.
             command_history::append ();
 
           else if (option == "-w")
             // Write entire history.
             command_history::write ();
 
           else if (option == "-r")
             // Read entire file.
             command_history::read ();
 
           else if (option == "-n")
-            // Read `new' history from file.
+            // Read 'new' history from file.
             command_history::read_range ();
 
           else
             panic_impossible ();
 
           return;
         }
       else if (argv[i] == "-q")
@@ -182,19 +182,19 @@ do_history (int argc, const string_vecto
 
   int limit = -1;
 
   if (i < argc)
     {
       if (sscanf (argv[i].c_str (), "%d", &limit) != 1)
         {
           if (argv[i][0] == '-')
-            error ("history: unrecognized option `%s'", argv[i].c_str ());
+            error ("history: unrecognized option '%s'", argv[i].c_str ());
           else
-            error ("history: bad non-numeric arg `%s'", argv[i].c_str ());
+            error ("history: bad non-numeric arg '%s'", argv[i].c_str ());
 
           return;
         }
 
       if (limit < 0)
         limit = -limit;
     }
 
@@ -255,20 +255,20 @@ edit_history_readline (std::fstream& str
 
   // Finish with newline if none in file.
 
   line[lindex++] = '\n';
   line[lindex++] = '\0';
   return line;
 }
 
-// Use `command' to replace the last entry in the history list, which,
-// by this time, is `run_history blah...'.  The intent is that the
-// new command becomes the history entry, and that `fc' should never
-// appear in the history list.  This way you can do `run_history' to
+// Use 'command' to replace the last entry in the history list, which,
+// by this time, is 'run_history blah...'.  The intent is that the
+// new command becomes the history entry, and that 'fc' should never
+// appear in the history list.  This way you can do 'run_history' to
 // your heart's content.
 
 static void
 edit_history_repl_hist (const std::string& command)
 {
   if (! command.empty ())
     {
       string_vector hlist = command_history::list ();
@@ -388,17 +388,17 @@ mk_tmp_hist_file (int argc, const string
     }
 
   std::string name = octave_tempnam ("", "oct-");
 
   std::fstream file (name.c_str (), std::ios::out);
 
   if (! file)
     {
-      error ("%s: couldn't open temporary file `%s'", warn_for,
+      error ("%s: couldn't open temporary file '%s'", warn_for,
              name.c_str ());
       return retval;
     }
 
   if (reverse)
     {
       for (int i = hist_end; i >= hist_beg; i--)
         file << hlist[i] << "\n";
diff --git a/src/oct-parse.yy b/src/oct-parse.yy
--- a/src/oct-parse.yy
+++ b/src/oct-parse.yy
@@ -895,17 +895,17 @@ simple_expr     : colon_expr
                 | simple_expr EXPR_OR simple_expr
                   { $$ = make_binary_op (EXPR_OR, $1, $2, $3); }
                 | simple_expr EXPR_AND_AND simple_expr
                   { $$ = make_boolean_op (EXPR_AND_AND, $1, $2, $3); }
                 | simple_expr EXPR_OR_OR simple_expr
                   { $$ = make_boolean_op (EXPR_OR_OR, $1, $2, $3); }
                 ;
 
-// Arrange for the lexer to return CLOSE_BRACE for `]' by looking ahead
+// Arrange for the lexer to return CLOSE_BRACE for ']' by looking ahead
 // one token for an assignment op.
 
 assign_lhs      : simple_expr
                   {
                     $$ = new tree_argument_list ($1);
                     $$->mark_as_simple_assign_lhs ();
                   }
                 | '[' arg_list CLOSE_BRACE
@@ -1209,17 +1209,17 @@ except_command  : UNWIND stash_comment o
                 | TRY stash_comment opt_sep opt_list END
                   {
                     if (! ($$ = make_try_command ($1, $4, 0, $5, $2, 0)))
                       ABORT_PARSE;
                   }
                 ;
 
 // ===========================================
-// Some `subroutines' for function definitions
+// Some 'subroutines' for function definitions
 // ===========================================
 
 push_fcn_symtab : // empty
                   {
                     current_function_depth++;
 
                     if (max_function_depth < current_function_depth)
                       max_function_depth = current_function_depth;
@@ -1721,17 +1721,17 @@ yyerror (const char *s)
 }
 
 // Error mesages for mismatched end tokens.
 
 static void
 end_error (const char *type, token::end_tok_type ettype, int l, int c)
 {
   static const char *fmt
-    = "`%s' command matched by `%s' near line %d column %d";
+    = "'%s' command matched by '%s' near line %d column %d";
 
   switch (ettype)
     {
     case token::simple_end:
       error (fmt, type, "end", l, c);
       break;
 
     case token::for_end:
@@ -1852,17 +1852,17 @@ maybe_warn_assign_as_truth_value (tree_e
     {
       if (curr_fcn_file_full_name.empty ())
         warning_with_id
           ("Octave:assign-as-truth-value",
            "suggest parenthesis around assignment used as truth value");
       else
         warning_with_id
           ("Octave:assign-as-truth-value",
-           "suggest parenthesis around assignment used as truth value near line %d, column %d in file `%s'",
+           "suggest parenthesis around assignment used as truth value near line %d, column %d in file '%s'",
            expr->line (), expr->column (), curr_fcn_file_full_name.c_str ());
     }
 }
 
 // Maybe print a warning about switch labels that aren't constants.
 
 static void
 maybe_warn_variable_switch_label (tree_expression *expr)
@@ -1870,17 +1870,17 @@ maybe_warn_variable_switch_label (tree_e
   if (! expr->is_constant ())
     {
       if (curr_fcn_file_full_name.empty ())
         warning_with_id ("Octave:variable-switch-label",
                          "variable switch label");
       else
         warning_with_id
           ("Octave:variable-switch-label",
-           "variable switch label near line %d, column %d in file `%s'",
+           "variable switch label near line %d, column %d in file '%s'",
            expr->line (), expr->column (), curr_fcn_file_full_name.c_str ());
     }
 }
 
 static tree_expression *
 fold (tree_binary_expression *e)
 {
   tree_expression *retval = e;
@@ -2837,17 +2837,17 @@ frob_function (const std::string& fname,
 
     if (pos != std::string::npos)
       nm = curr_fcn_file_name.substr (pos+1);
 
     if (nm != id_name)
       {
         warning_with_id
           ("Octave:function-name-clash",
-           "function name `%s' does not agree with function file name `%s'",
+           "function name '%s' does not agree with function file name '%s'",
            id_name.c_str (), curr_fcn_file_full_name.c_str ());
 
         id_name = nm;
       }
   }
 
   if (reading_fcn_file || reading_classdef_file || autoloading)
     {
@@ -2877,23 +2877,23 @@ frob_function (const std::string& fname,
         }
 
       std::string nm = fcn->fcn_file_name ();
 
       file_stat fs (nm);
 
       if (fs && fs.is_newer (now))
         warning_with_id ("Octave:future-time-stamp",
-                         "time stamp for `%s' is in the future", nm.c_str ());
+                         "time stamp for '%s' is in the future", nm.c_str ());
     }
   else if (! (input_from_tmp_history_file || input_from_startup_file)
            && reading_script_file
            && curr_fcn_file_name == id_name)
     {
-      warning ("function `%s' defined within script file `%s'",
+      warning ("function '%s' defined within script file '%s'",
                id_name.c_str (), curr_fcn_file_full_name.c_str ());
     }
 
   fcn->stash_function_name (id_name);
   fcn->stash_fcn_location (input_line_number, current_input_column);
 
   if (! help_buf.empty () && current_function_depth == 1
       && ! parsing_subfunctions)
@@ -3090,17 +3090,17 @@ make_decl_command (int tok, token *tok_v
       break;
 
     case STATIC:
       if (current_function_depth > 0)
         retval = new tree_static_command (lst, l, c);
       else
         {
           if (reading_script_file)
-            warning ("ignoring persistent declaration near line %d of file `%s'",
+            warning ("ignoring persistent declaration near line %d of file '%s'",
                      l, curr_fcn_file_full_name.c_str ());
           else
             warning ("ignoring persistent declaration near line %d", l);
         }
       break;
 
     default:
       panic_impossible ();
@@ -3175,17 +3175,17 @@ maybe_warn_missing_semi (tree_statement_
 {
   if (current_function_depth > 0)
     {
       tree_statement *tmp = t->back();
 
       if (tmp->is_expression ())
         warning_with_id
           ("Octave:missing-semicolon",
-           "missing semicolon near line %d, column %d in file `%s'",
+           "missing semicolon near line %d, column %d in file '%s'",
             tmp->line (), tmp->column (), curr_fcn_file_full_name.c_str ());
     }
 }
 
 static tree_statement_list *
 set_stmt_print_flag (tree_statement_list *list, char sep,
                      bool warn_missing_semi)
 {
@@ -3586,19 +3586,19 @@ parse_fcn_file (const std::string& ff, c
             = make_end ("endscript", input_line_number, current_input_column);
 
           make_script (0, end_of_script);
 
           fcn_ptr = primary_fcn_ptr;
         }
     }
   else if (require_file)
-    error ("no such file, `%s'", ff.c_str ());
+    error ("no such file, '%s'", ff.c_str ());
   else if (! warn_for.empty ())
-    error ("%s: unable to open file `%s'", warn_for.c_str (), ff.c_str ());
+    error ("%s: unable to open file '%s'", warn_for.c_str (), ff.c_str ());
 
   return fcn_ptr;
 }
 
 std::string
 get_help_from_file (const std::string& nm, bool& symbol_found,
                     std::string& file)
 {
@@ -3874,17 +3874,17 @@ With no arguments, return a structure co
                         {
                           nm = fname + nm;
                           found = true;
                         }
                     }
                 }
               if (! found)
                 warning_with_id ("Octave:autoload-relative-file-name",
-                                 "autoload: `%s' is not an absolute file name",
+                                 "autoload: '%s' is not an absolute file name",
                                  nm.c_str ());
             }
           autoload_map[argv[1]] = nm;
         }
     }
   else
     print_usage ();
 
@@ -3990,17 +3990,17 @@ source_file (const std::string& file_nam
 
               if (verbose)
                 std::cout << "done." << std::endl;
 
               delete fcn;
             }
         }
       else
-        error ("source: error sourcing file `%s'",
+        error ("source: error sourcing file '%s'",
                file_full_name.c_str ());
     }
 }
 
 DEFUN (mfilename, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} mfilename ()\n\
 @deftypefnx {Built-in Function} {} mfilename (\"fullpath\")\n\
@@ -4119,17 +4119,17 @@ feval (const std::string& name, const oc
   octave_value fcn = symbol_table::find_function (name, args);
 
   if (fcn.is_defined ())
     retval = fcn.do_multi_index_op (nargout, args);
   else
     {
       maybe_missing_function_hook (name);
       if (! error_state)
-        error ("feval: function `%s' not found", name.c_str ());
+        error ("feval: function '%s' not found", name.c_str ());
     }
 
   return retval;
 }
 
 octave_value_list
 feval (octave_function *fcn, const octave_value_list& args, int nargout)
 {
@@ -4259,17 +4259,17 @@ another function for the given type sign
       if (! error_state)
         {
           octave_value fcn = symbol_table::builtin_find (name);
 
           if (fcn.is_defined ())
             retval = feval (fcn.function_value (), args.splice (0, 1),
                             nargout);
           else
-            error ("builtin: lookup for symbol `%s' failed", name.c_str ());
+            error ("builtin: lookup for symbol '%s' failed", name.c_str ());
         }
       else
         error ("builtin: function name (F) must be a string");
     }
   else
     print_usage ();
 
   return retval;
diff --git a/src/oct-stream.cc b/src/oct-stream.cc
--- a/src/oct-stream.cc
+++ b/src/oct-stream.cc
@@ -503,18 +503,18 @@ scanf_format_list::printme (void) const
         std::cerr << "literal text\n";
       else if (elt->type == scanf_format_elt::whitespace_conversion)
         std::cerr << "whitespace\n";
       else
         std::cerr << elt->type << "\n";
 
       std::cerr
         << "modifier:   " << elt->modifier << "\n"
-        << "char_class: `" << undo_string_escapes (elt->char_class) << "'\n"
-        << "text:       `" << undo_string_escapes (elt->text) << "'\n\n";
+        << "char_class: '" << undo_string_escapes (elt->char_class) << "'\n"
+        << "text:       '" << undo_string_escapes (elt->text) << "'\n\n";
     }
 }
 
 bool
 scanf_format_list::all_character_conversions (void)
 {
   octave_idx_type n = list.length ();
 
@@ -862,22 +862,22 @@ printf_format_list::printme (void) const
   int n = list.length ();
 
   for (int i = 0; i < n; i++)
     {
       printf_format_elt *elt = list(i);
 
       std::cerr
         << "args:     " << elt->args << "\n"
-        << "flags:    `" << elt->flags << "'\n"
+        << "flags:    '" << elt->flags << "'\n"
         << "width:    " << elt->fw << "\n"
         << "prec:     " << elt->prec << "\n"
-        << "type:     `" << elt->type << "'\n"
-        << "modifier: `" << elt->modifier << "'\n"
-        << "text:     `" << undo_string_escapes (elt->text) << "'\n\n";
+        << "type:     '" << elt->type << "'\n"
+        << "modifier: '" << elt->modifier << "'\n"
+        << "text:     '" << undo_string_escapes (elt->text) << "'\n\n";
     }
 }
 
 void
 octave_base_stream::error (const std::string& msg)
 {
   fail = true;
   errmsg = msg;
@@ -1379,17 +1379,17 @@ do_scanf_conv (std::istream&, const scan
   while (is && n < width && (c = is.get ()) != EOF) \
     tmp[n++] = static_cast<char> (c); \
  \
   if (n > 0 && c == EOF) \
     is.clear (); \
  \
   tmp.resize (n)
 
-// For a `%s' format, skip initial whitespace and then read until the
+// For a '%s' format, skip initial whitespace and then read until the
 // next whitespace character or until WIDTH characters have been read.
 #define BEGIN_S_CONVERSION() \
   int width = elt->width; \
  \
   std::string tmp; \
  \
   do \
     { \
@@ -2468,17 +2468,17 @@ octave_base_stream::do_printf (printf_fo
         return retval;
 
       for (;;)
         {
           octave_quit ();
 
           if (elt)
             {
-              // NSA is the number of `star' args to convert.
+              // NSA is the number of 'star' args to convert.
 
               int nsa = (elt->fw < 0) + (elt->prec < 0);
 
               int sa_1 = 0;
               int sa_2 = 0;
 
               if (nsa > 0)
                 {
diff --git a/src/oct-stream.h b/src/oct-stream.h
--- a/src/oct-stream.h
+++ b/src/oct-stream.h
@@ -82,24 +82,24 @@ public:
   const char *text;
 
   // The maximum field width.
   int width;
 
   // TRUE if we are not storing the result of this conversion.
   bool discard;
 
-  // Type of conversion -- `d', `i', `o', `u', `x', `e', `f', `g',
-  // `c', `s', `p', `%', or `['.
+  // Type of conversion -- 'd', 'i', 'o', 'u', 'x', 'e', 'f', 'g',
+  // 'c', 's', 'p', '%', or '['.
   char type;
 
-  // A length modifier -- `h', `l', or `L'.
+  // A length modifier -- 'h', 'l', or 'L'.
   char modifier;
 
-  // The class of characters in a `[' format.
+  // The class of characters in a '[' format.
   std::string char_class;
 };
 
 class
 OCTINTERP_API
 scanf_format_list
 {
 public:
@@ -224,24 +224,24 @@ public:
   int args;
 
   // Field width.
   int fw;
 
   // Precision.
   int prec;
 
-  // Flags -- `-', `+', ` ', `0', or `#'.
+  // Flags -- '-', '+', ' ', '0', or '#'.
   std::string flags;
 
-  // Type of conversion -- `d', `i', `o', `x', `X', `u', `c', `s',
-  // `f', `e', `E', `g', `G', `p', or `%'
+  // Type of conversion -- 'd', 'i', 'o', 'x', 'X', 'u', 'c', 's',
+  // 'f', 'e', 'E', 'g', 'G', 'p', or '%'
   char type;
 
-  // A length modifier -- `h', `l', or `L'.
+  // A length modifier -- 'h', 'l', or 'L'.
   char modifier;
 };
 
 class
 OCTINTERP_API
 printf_format_list
 {
 public:
diff --git a/src/octave.cc b/src/octave.cc
--- a/src/octave.cc
+++ b/src/octave.cc
@@ -120,17 +120,17 @@ static const char *usage_string =
   "octave [-HVdfhiqvx] [--debug] [--echo-commands] [--eval CODE]\n\
        [--exec-path path] [--help] [--image-path path] [--info-file file]\n\
        [--info-program prog] [--interactive] [--line-editing]\n\
        [--no-history] [--no-init-file] [--no-init-path] [--no-line-editing]\n\
        [--no-site-file] [--no-window-system] [-p path] [--path path]\n\
        [--silent] [--traditional] [--verbose] [--version] [file]";
 
 // This is here so that it's more likely that the usage message and
-// the real set of options will agree.  Note: the `+' must come first
+// the real set of options will agree.  Note: the '+' must come first
 // to prevent getopt from permuting arguments!
 static const char *short_opts = "+HVdfhip:qvx";
 
 // The code to evaluate at startup (--eval CODE)
 static std::string code_to_eval;
 
 // If TRUE, don't exit after evaluating code given by --eval option.
 static bool persist = false;
diff --git a/src/ov-base-diag.cc b/src/ov-base-diag.cc
--- a/src/ov-base-diag.cc
+++ b/src/ov-base-diag.cc
@@ -142,17 +142,17 @@ octave_base_diag<DMT, MT>::subsasgn (con
   switch (type[0])
     {
     case '(':
       {
         if (type.length () == 1)
           {
             octave_value_list jdx = idx.front ();
             // Check for a simple element assignment. That means, if D is a diagonal matrix,
-            // `D(i,i) = x' will not destroy its diagonality (provided i is a valid index).
+            // 'D(i,i) = x' will not destroy its diagonality (provided i is a valid index).
             if (jdx.length () == 2 && jdx(0).is_scalar_type () && jdx(1).is_scalar_type ())
               {
                 typename DMT::element_type val;
                 idx_vector i0 = jdx(0).index_vector (), i1 = jdx(1).index_vector ();
                 if (! error_state  && i0(0) == i1(0)
                     && i0(0) < matrix.rows () && i1(0) < matrix.cols ()
                     && chk_valid_scalar (rhs, val))
                   {
diff --git a/src/ov-base.cc b/src/ov-base.cc
--- a/src/ov-base.cc
+++ b/src/ov-base.cc
@@ -1258,33 +1258,33 @@ octave_base_value::dump (std::ostream& o
   os << "class: " << this->class_name ()
      << " type: " << this->type_name ()
      << " dims: " << dv.str ();
 }
 
 static void
 gripe_indexed_assignment (const std::string& tn1, const std::string& tn2)
 {
-  error ("assignment of `%s' to indexed `%s' not implemented",
+  error ("assignment of '%s' to indexed '%s' not implemented",
          tn2.c_str (), tn1.c_str ());
 }
 
 static void
 gripe_assign_conversion_failed (const std::string& tn1,
                                 const std::string& tn2)
 {
-  error ("type conversion for assignment of `%s' to indexed `%s' failed",
+  error ("type conversion for assignment of '%s' to indexed '%s' failed",
          tn2.c_str (), tn1.c_str ());
 }
 
 static void
 gripe_no_conversion (const std::string& on, const std::string& tn1,
                      const std::string& tn2)
 {
-  error ("operator %s: no conversion for assignment of `%s' to indexed `%s'",
+  error ("operator %s: no conversion for assignment of '%s' to indexed '%s'",
          on.c_str (), tn2.c_str (), tn1.c_str ());
 }
 
 octave_value
 octave_base_value::numeric_assign (const std::string& type,
                                    const std::list<octave_value_list>& idx,
                                    const octave_value& rhs)
 {
diff --git a/src/ov-class.cc b/src/ov-class.cc
--- a/src/ov-class.cc
+++ b/src/ov-class.cc
@@ -318,23 +318,23 @@ make_idx_args (const std::string& type,
                 if (vlist.length () == 1)
                   {
                     octave_value val = vlist(0);
 
                     if (val.is_string ())
                       subs_field(i) = val;
                     else
                       {
-                        error ("expecting character string argument for `.' index");
+                        error ("expecting character string argument for '.' index");
                         return retval;
                       }
                   }
                 else
                   {
-                    error ("expecting single argument for `.' index");
+                    error ("expecting single argument for '.' index");
                     return retval;
                   }
               }
               break;
 
             default:
               panic_impossible ();
               break;
@@ -380,17 +380,17 @@ octave_class::dotref (const octave_value
 
   if (! error_state)
     {
       octave_map::const_iterator p = my_map.seek (nm);
 
       if (p != my_map.end ())
         retval = my_map.contents (p);
       else
-        error ("class has no member `%s'", nm.c_str ());
+        error ("class has no member '%s'", nm.c_str ());
     }
   else
     gripe_invalid_index1 ();
 
   return retval;
 }
 
 static bool
@@ -1969,25 +1969,25 @@ derived.\n\
                         {
                           octave_class::exemplar_const_iterator it
                             = octave_class::exemplar_map.find (id);
 
                           if (it == octave_class::exemplar_map.end ())
                             octave_class::exemplar_map[id]
                               = octave_class::exemplar_info (retval);
                           else if (! it->second.compare (retval))
-                            error ("class: object of class `%s' does not match previously constructed objects",
+                            error ("class: object of class '%s' does not match previously constructed objects",
                                    id.c_str ());
                         }
                     }
                   else
                     error ("class: expecting structure S as first argument");
                 }
               else
-                error ("class: `%s' is invalid as a class name in this context",
+                error ("class: '%s' is invalid as a class name in this context",
                        id.c_str ());
             }
           else
             error ("class: invalid call from outside class constructor or method");
         }
       else
         error ("class: ID (class name) must be a character string");
     }
diff --git a/src/ov-colon.h b/src/ov-colon.h
--- a/src/ov-colon.h
+++ b/src/ov-colon.h
@@ -34,17 +34,17 @@ along with Octave; see the file COPYING.
 #include "error.h"
 #include "ov-base.h"
 #include "ov-typeinfo.h"
 
 class octave_value_list;
 
 class tree_walker;
 
-// A type to represent `:' as used for indexing.
+// A type to represent ':' as used for indexing.
 
 class
 octave_magic_colon : public octave_base_value
 {
 public:
 
   octave_magic_colon (void)
     : octave_base_value () { }
diff --git a/src/ov-struct.cc b/src/ov-struct.cc
--- a/src/ov-struct.cc
+++ b/src/ov-struct.cc
@@ -79,17 +79,17 @@ octave_struct::dotref (const octave_valu
 
   octave_map::const_iterator p = map.seek (nm);
 
   if (p != map.end ())
     retval = map.contents (p);
   else if (auto_add)
     retval = (numel () == 0) ? Cell (dim_vector (1, 1)) : Cell (dims ());
   else
-    error ("structure has no member `%s'", nm.c_str ());
+    error ("structure has no member '%s'", nm.c_str ());
 
   return retval;
 }
 
 #if 0
 static void
 gripe_invalid_index1 (void)
 {
@@ -1112,17 +1112,17 @@ octave_scalar_struct::dotref (const octa
 {
   assert (idx.length () == 1);
 
   std::string nm = idx(0).string_value ();
 
   octave_value retval = map.getfield (nm);
 
   if (! auto_add && retval.is_undefined ())
-    error ("structure has no member `%s'", nm.c_str ());
+    error ("structure has no member '%s'", nm.c_str ());
 
   return retval;
 }
 
 octave_value
 octave_scalar_struct::subsref (const std::string& type,
                                const std::list<octave_value_list>& idx)
 {
@@ -1837,17 +1837,17 @@ If the argument is an object, return the
 
       std::string key (args(i).string_value ());
 
       if (error_state)
         return retval;
 
       if (! valid_identifier (key))
         {
-          error ("struct: invalid structure field name `%s'", key.c_str ());
+          error ("struct: invalid structure field name '%s'", key.c_str ());
           return retval;
         }
 
       // Value may be v, { v }, or { v1, v2, ... }
       // In the first two cases, we need to create a cell array of
       // the appropriate dimensions filled with v.  In the last case,
       // the cell array has already been determined to be of the
       // correct dimensions.
diff --git a/src/ov-typeinfo.cc b/src/ov-typeinfo.cc
--- a/src/ov-typeinfo.cc
+++ b/src/ov-typeinfo.cc
@@ -238,17 +238,17 @@ octave_value_typeinfo::do_register_type 
 bool
 octave_value_typeinfo::do_register_unary_class_op (octave_value::unary_op op,
                                                    octave_value_typeinfo::unary_class_op_fcn f)
 {
   if (lookup_unary_class_op (op))
     {
       std::string op_name = octave_value::unary_op_as_string (op);
 
-      warning ("duplicate unary operator `%s' for class dispatch",
+      warning ("duplicate unary operator '%s' for class dispatch",
                op_name.c_str ());
     }
 
   unary_class_ops.checkelem (static_cast<int> (op)) = reinterpret_cast<void *> (f);
 
   return false;
 }
 
@@ -256,17 +256,17 @@ bool
 octave_value_typeinfo::do_register_unary_op (octave_value::unary_op op,
                                              int t, octave_value_typeinfo::unary_op_fcn f)
 {
   if (lookup_unary_op (op, t))
     {
       std::string op_name = octave_value::unary_op_as_string (op);
       std::string type_name = types(t);
 
-      warning ("duplicate unary operator `%s' for type `%s'",
+      warning ("duplicate unary operator '%s' for type '%s'",
                op_name.c_str (), type_name.c_str ());
     }
 
   unary_ops.checkelem (static_cast<int> (op), t) = reinterpret_cast<void *> (f);
 
   return false;
 }
 
@@ -274,34 +274,34 @@ bool
 octave_value_typeinfo::do_register_non_const_unary_op
   (octave_value::unary_op op, int t, octave_value_typeinfo::non_const_unary_op_fcn f)
 {
   if (lookup_non_const_unary_op (op, t))
     {
       std::string op_name = octave_value::unary_op_as_string (op);
       std::string type_name = types(t);
 
-      warning ("duplicate unary operator `%s' for type `%s'",
+      warning ("duplicate unary operator '%s' for type '%s'",
                op_name.c_str (), type_name.c_str ());
     }
 
   non_const_unary_ops.checkelem (static_cast<int> (op), t) = reinterpret_cast<void *> (f);
 
   return false;
 }
 
 bool
 octave_value_typeinfo::do_register_binary_class_op (octave_value::binary_op op,
                                                     octave_value_typeinfo::binary_class_op_fcn f)
 {
   if (lookup_binary_class_op (op))
     {
       std::string op_name = octave_value::binary_op_as_string (op);
 
-      warning ("duplicate binary operator `%s' for class dispatch",
+      warning ("duplicate binary operator '%s' for class dispatch",
                op_name.c_str ());
     }
 
   binary_class_ops.checkelem (static_cast<int> (op)) = reinterpret_cast<void *> (f);
 
   return false;
 }
 
@@ -311,34 +311,34 @@ octave_value_typeinfo::do_register_binar
                                               octave_value_typeinfo::binary_op_fcn f)
 {
   if (lookup_binary_op (op, t1, t2))
     {
       std::string op_name = octave_value::binary_op_as_string (op);
       std::string t1_name = types(t1);
       std::string t2_name = types(t2);
 
-      warning ("duplicate binary operator `%s' for types `%s' and `%s'",
+      warning ("duplicate binary operator '%s' for types '%s' and '%s'",
                op_name.c_str (), t1_name.c_str (), t1_name.c_str ());
     }
 
   binary_ops.checkelem (static_cast<int> (op), t1, t2) = reinterpret_cast<void *> (f);
 
   return false;
 }
 
 bool
 octave_value_typeinfo::do_register_binary_class_op (octave_value::compound_binary_op op,
                                                     octave_value_typeinfo::binary_class_op_fcn f)
 {
   if (lookup_binary_class_op (op))
     {
       std::string op_name = octave_value::binary_op_fcn_name (op);
 
-      warning ("duplicate compound binary operator `%s' for class dispatch",
+      warning ("duplicate compound binary operator '%s' for class dispatch",
                op_name.c_str ());
     }
 
   compound_binary_class_ops.checkelem (static_cast<int> (op)) = reinterpret_cast<void *> (f);
 
   return false;
 }
 
@@ -348,34 +348,34 @@ octave_value_typeinfo::do_register_binar
                                               octave_value_typeinfo::binary_op_fcn f)
 {
   if (lookup_binary_op (op, t1, t2))
     {
       std::string op_name = octave_value::binary_op_fcn_name (op);
       std::string t1_name = types(t1);
       std::string t2_name = types(t2);
 
-      warning ("duplicate compound binary operator `%s' for types `%s' and `%s'",
+      warning ("duplicate compound binary operator '%s' for types '%s' and '%s'",
                op_name.c_str (), t1_name.c_str (), t1_name.c_str ());
     }
 
   compound_binary_ops.checkelem (static_cast<int> (op), t1, t2) = reinterpret_cast<void *> (f);
 
   return false;
 }
 
 bool
 octave_value_typeinfo::do_register_cat_op (int t1, int t2, octave_value_typeinfo::cat_op_fcn f)
 {
   if (lookup_cat_op (t1, t2))
     {
       std::string t1_name = types(t1);
       std::string t2_name = types(t2);
 
-      warning ("duplicate concatenation operator for types `%s' and `%s'",
+      warning ("duplicate concatenation operator for types '%s' and '%s'",
                t1_name.c_str (), t1_name.c_str ());
     }
 
   cat_ops.checkelem (t1, t2) = reinterpret_cast<void *> (f);
 
   return false;
 }
 
@@ -385,17 +385,17 @@ octave_value_typeinfo::do_register_assig
                                               octave_value_typeinfo::assign_op_fcn f)
 {
   if (lookup_assign_op (op, t_lhs, t_rhs))
     {
       std::string op_name = octave_value::assign_op_as_string (op);
       std::string t_lhs_name = types(t_lhs);
       std::string t_rhs_name = types(t_rhs);
 
-      warning ("duplicate assignment operator `%s' for types `%s' and `%s'",
+      warning ("duplicate assignment operator '%s' for types '%s' and '%s'",
                op_name.c_str (), t_lhs_name.c_str (), t_rhs_name.c_str ());
     }
 
   assign_ops.checkelem (static_cast<int> (op), t_lhs, t_rhs) = reinterpret_cast<void *> (f);
 
   return false;
 }
 
@@ -403,17 +403,17 @@ bool
 octave_value_typeinfo::do_register_assignany_op (octave_value::assign_op op,
                                                  int t_lhs, octave_value_typeinfo::assignany_op_fcn f)
 {
   if (lookup_assignany_op (op, t_lhs))
     {
       std::string op_name = octave_value::assign_op_as_string (op);
       std::string t_lhs_name = types(t_lhs);
 
-      warning ("duplicate assignment operator `%s' for types `%s'",
+      warning ("duplicate assignment operator '%s' for types '%s'",
                op_name.c_str (), t_lhs_name.c_str ());
     }
 
   assignany_ops.checkelem (static_cast<int> (op), t_lhs) = reinterpret_cast<void *> (f);
 
   return false;
 }
 
@@ -421,17 +421,17 @@ bool
 octave_value_typeinfo::do_register_pref_assign_conv (int t_lhs, int t_rhs,
                                                      int t_result)
 {
   if (lookup_pref_assign_conv (t_lhs, t_rhs) >= 0)
     {
       std::string t_lhs_name = types(t_lhs);
       std::string t_rhs_name = types(t_rhs);
 
-      warning ("overriding assignment conversion for types `%s' and `%s'",
+      warning ("overriding assignment conversion for types '%s' and '%s'",
                t_lhs_name.c_str (), t_rhs_name.c_str ());
     }
 
   pref_assign_conv.checkelem (t_lhs, t_rhs) = t_result;
 
   return false;
 }
 
@@ -439,17 +439,17 @@ bool
 octave_value_typeinfo::do_register_type_conv_op
   (int t, int t_result, octave_base_value::type_conv_fcn f)
 {
   if (lookup_type_conv_op (t, t_result))
     {
       std::string t_name = types(t);
       std::string t_result_name = types(t_result);
 
-      warning ("overriding type conversion op for `%s' to `%s'",
+      warning ("overriding type conversion op for '%s' to '%s'",
                t_name.c_str (), t_result_name.c_str ());
     }
 
   type_conv_ops.checkelem (t, t_result) = reinterpret_cast<void *> (f);
 
   return false;
 }
 
@@ -457,17 +457,17 @@ bool
 octave_value_typeinfo::do_register_widening_op
   (int t, int t_result, octave_base_value::type_conv_fcn f)
 {
   if (lookup_widening_op (t, t_result))
     {
       std::string t_name = types(t);
       std::string t_result_name = types(t_result);
 
-      warning ("overriding widening op for `%s' to `%s'",
+      warning ("overriding widening op for '%s' to '%s'",
                t_name.c_str (), t_result_name.c_str ());
     }
 
   widening_ops.checkelem (t, t_result) = reinterpret_cast<void *> (f);
 
   return false;
 }
 
diff --git a/src/ov.cc b/src/ov.cc
--- a/src/ov.cc
+++ b/src/ov.cc
@@ -1299,27 +1299,27 @@ octave_value::do_multi_index_op (int nar
   return rep->do_multi_index_op (nargout, idx, lvalue_list);
 }
 
 #if 0
 static void
 gripe_assign_failed (const std::string& on, const std::string& tn1,
                      const std::string& tn2)
 {
-  error ("assignment failed for `%s %s %s'",
+  error ("assignment failed for '%s %s %s'",
          tn1.c_str (), on.c_str (), tn2.c_str ());
 }
 #endif
 
 static void
 gripe_assign_failed_or_no_method (const std::string& on,
                                   const std::string& tn1,
                                   const std::string& tn2)
 {
-  error ("assignment failed, or no method for `%s %s %s'",
+  error ("assignment failed, or no method for '%s %s %s'",
          tn1.c_str (), on.c_str (), tn2.c_str ());
 }
 
 octave_value
 octave_value::subsasgn (const std::string& type,
                         const std::list<octave_value_list>& idx,
                         const octave_value& rhs)
 {
@@ -1867,24 +1867,24 @@ octave_value::write (octave_stream& os, 
 {
   return rep->write (os, block_size, output_type, skip, flt_fmt);
 }
 
 static void
 gripe_binary_op (const std::string& on, const std::string& tn1,
                  const std::string& tn2)
 {
-  error ("binary operator `%s' not implemented for `%s' by `%s' operations",
+  error ("binary operator '%s' not implemented for '%s' by '%s' operations",
          on.c_str (), tn1.c_str (), tn2.c_str ());
 }
 
 static void
 gripe_binary_op_conv (const std::string& on)
 {
-  error ("type conversion failed for binary operator `%s'", on.c_str ());
+  error ("type conversion failed for binary operator '%s'", on.c_str ());
 }
 
 octave_value
 do_binary_op (octave_value::binary_op op,
               const octave_value& v1, const octave_value& v2)
 {
   octave_value retval;
 
@@ -2179,17 +2179,17 @@ do_binary_op (octave_value::compound_bin
     }
 
   return retval;
 }
 
 static void
 gripe_cat_op (const std::string& tn1, const std::string& tn2)
 {
-  error ("concatenation operator not implemented for `%s' by `%s' operations",
+  error ("concatenation operator not implemented for '%s' by '%s' operations",
          tn1.c_str (), tn2.c_str ());
 }
 
 static void
 gripe_cat_op_conv (void)
 {
   error ("type conversion failed for concatenation operator");
 }
@@ -2291,24 +2291,24 @@ octave_value::print_info (std::ostream& 
      << prefix << "rep info:  ";
 
   rep->print_info (os, prefix + " ");
 }
 
 static void
 gripe_unary_op (const std::string& on, const std::string& tn)
 {
-  error ("unary operator `%s' not implemented for `%s' operands",
+  error ("unary operator '%s' not implemented for '%s' operands",
          on.c_str (), tn.c_str ());
 }
 
 static void
 gripe_unary_op_conv (const std::string& on)
 {
-  error ("type conversion failed for unary operator `%s'", on.c_str ());
+  error ("type conversion failed for unary operator '%s'", on.c_str ());
 }
 
 octave_value
 do_unary_op (octave_value::unary_op op, const octave_value& v)
 {
   octave_value retval;
 
   int t = v.type_id ();
@@ -2378,17 +2378,17 @@ do_unary_op (octave_value::unary_op op, 
 
   return retval;
 }
 
 static void
 gripe_unary_op_conversion_failed (const std::string& op,
                                   const std::string& tn)
 {
-  error ("operator %s: type conversion for `%s' failed",
+  error ("operator %s: type conversion for '%s' failed",
          op.c_str (), tn.c_str ());
 }
 
 octave_value&
 octave_value::do_non_const_unary_op (unary_op op)
 {
   if (op == op_incr || op == op_decr)
     {
@@ -2770,17 +2770,17 @@ decode_subscripts (const char* name, con
               if (item == "{}")
                 type_string[k] = '{';
               else if (item == "()")
                 type_string[k] = '(';
               else if (item == ".")
                 type_string[k] = '.';
               else
                 {
-                  error("%s: invalid indexing type `%s'", name, item.c_str ());
+                  error("%s: invalid indexing type '%s'", name, item.c_str ());
                   return;
                 }
             }
           else
             {
               error ("%s: expecting type(%d) to be a character string",
                      name, k+1);
               return;
@@ -2809,17 +2809,17 @@ decode_subscripts (const char* name, con
                      name, k+1);
               return;
             }
 
           idx.push_back (idx_item);
         }
     }
   else
-    error ("%s: second argument must be a structure with fields `type' and `subs'", name);
+    error ("%s: second argument must be a structure with fields 'type' and 'subs'", name);
 }
 
 DEFUN (subsref, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} subsref (@var{val}, @var{idx})\n\
 Perform the subscripted element selection operation according to\n\
 the subscript specified by @var{idx}.\n\
 \n\
diff --git a/src/pager.cc b/src/pager.cc
--- a/src/pager.cc
+++ b/src/pager.cc
@@ -504,17 +504,17 @@ open_diary_file (void)
   // If there is pending output in the pager buf, it should not go
   // into the diary file.
 
   octave_pager_stream::set_diary_skip ();
 
   external_diary_file.open (diary_file.c_str (), std::ios::app);
 
   if (! external_diary_file)
-    error ("diary: can't open diary file `%s'", diary_file.c_str ());
+    error ("diary: can't open diary file '%s'", diary_file.c_str ());
 }
 
 DEFUN (diary, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Command} {} diary options\n\
 Record a list of all commands @emph{and} the output they produce, mixed\n\
 together just as you see them on your terminal.  Valid options are:\n\
 \n\
@@ -606,17 +606,17 @@ The current state can be determined via 
     {
       std::string arg = argv[1];
 
       if (arg == "on")
         Vpage_screen_output = true;
       else if (arg == "off")
         Vpage_screen_output = false;
       else
-        error ("more: unrecognized argument `%s'", arg.c_str ());
+        error ("more: unrecognized argument '%s'", arg.c_str ());
     }
   else if (argc == 1)
     Vpage_screen_output = ! Vpage_screen_output;
   else
     print_usage ();
 
   return retval;
 }
diff --git a/src/pr-output.cc b/src/pr-output.cc
--- a/src/pr-output.cc
+++ b/src/pr-output.cc
@@ -53,18 +53,18 @@ along with Octave; see the file COPYING.
 #include "oct-stream.h"
 #include "pager.h"
 #include "pr-output.h"
 #include "sysdep.h"
 #include "unwind-prot.h"
 #include "utils.h"
 #include "variables.h"
 
-// TRUE means use a scaled fixed point format for `format long' and
-// `format short'.
+// TRUE means use a scaled fixed point format for 'format long' and
+// 'format short'.
 static bool Vfixed_point_format = false;
 
 // The maximum field width for a number printed by the default output
 // routines.
 static int Voutput_max_field_width = 10;
 
 // The precision of the numbers printed by the default output
 // routines.
@@ -3626,17 +3626,17 @@ set_format_style (int argc, const string
                 }
               else if (arg == "eng")
                 {
                   init_format_state ();
                   print_eng = true;
                 }
               else
                 {
-                  error ("format: unrecognized option `short %s'",
+                  error ("format: unrecognized option 'short %s'",
                          arg.c_str ());
                   return;
                 }
             }
           else
             init_format_state ();
 
           set_output_prec_and_fw (5, 10);
@@ -3671,17 +3671,17 @@ set_format_style (int argc, const string
                 }
               else if (arg == "eng")
                 {
                   init_format_state ();
                   print_eng = true;
                 }
               else
                 {
-                  error ("format: unrecognized option `long %s'",
+                  error ("format: unrecognized option 'long %s'",
                          arg.c_str ());
                   return;
                 }
             }
           else
             init_format_state ();
 
           set_output_prec_and_fw (15, 20);
@@ -3750,17 +3750,17 @@ set_format_style (int argc, const string
         {
           Vcompact_format = true;
         }
       else if (arg == "loose")
         {
           Vcompact_format = false;
         }
       else
-        error ("format: unrecognized format state `%s'", arg.c_str ());
+        error ("format: unrecognized format state '%s'", arg.c_str ());
     }
   else
     {
       init_format_state ();
       set_output_prec_and_fw (5, 10);
     }
 }
 
diff --git a/src/pt-binop.cc b/src/pt-binop.cc
--- a/src/pt-binop.cc
+++ b/src/pt-binop.cc
@@ -41,17 +41,17 @@ static bool Vdo_braindead_shortcircuit_e
 // Binary expressions.
 
 octave_value_list
 tree_binary_expression::rvalue (int nargout)
 {
   octave_value_list retval;
 
   if (nargout > 1)
-    error ("binary operator `%s': invalid number of output arguments",
+    error ("binary operator '%s': invalid number of output arguments",
            oper () . c_str ());
   else
     retval = rvalue1 (nargout);
 
   return retval;
 }
 
 octave_value
@@ -171,17 +171,17 @@ tree_binary_expression::accept (tree_wal
 // Boolean expressions.
 
 octave_value_list
 tree_boolean_expression::rvalue (int nargout)
 {
   octave_value_list retval;
 
   if (nargout > 1)
-    error ("binary operator `%s': invalid number of output arguments",
+    error ("binary operator '%s': invalid number of output arguments",
            oper () . c_str ());
   else
     retval = rvalue1 (nargout);
 
   return retval;
 }
 
 octave_value
diff --git a/src/pt-eval.cc b/src/pt-eval.cc
--- a/src/pt-eval.cc
+++ b/src/pt-eval.cc
@@ -260,17 +260,17 @@ tree_evaluator::visit_decl_init_list (tr
 }
 
 // Decide if it's time to quit a for or while loop.
 static inline bool
 quit_loop_now (void)
 {
   octave_quit ();
 
-  // Maybe handle `continue N' someday...
+  // Maybe handle 'continue N' someday...
 
   if (tree_continue_command::continuing)
     tree_continue_command::continuing--;
 
   bool quit = (error_state
                || tree_return_command::returning
                || tree_break_command::breaking
                || tree_continue_command::continuing);
@@ -475,17 +475,17 @@ tree_evaluator::visit_complex_for_comman
           if (! error_state && loop_body)
             loop_body->accept (*this);
 
           if (quit_loop_now ())
             break;
         }
     }
   else
-    error ("in statement `for [X, Y] = VAL', VAL must be a structure");
+    error ("in statement 'for [X, Y] = VAL', VAL must be a structure");
 }
 
 void
 tree_evaluator::visit_octave_user_script (octave_user_script&)
 {
   panic_impossible ();
 }
 
diff --git a/src/pt-id.cc b/src/pt-id.cc
--- a/src/pt-id.cc
+++ b/src/pt-id.cc
@@ -44,19 +44,19 @@ tree_identifier::eval_undefined_error (v
   int l = line ();
   int c = column ();
 
   maybe_missing_function_hook (name ());
   if (error_state)
     return;
 
   if (l == -1 && c == -1)
-    ::error ("`%s' undefined", name ().c_str ());
+    ::error ("'%s' undefined", name ().c_str ());
   else
-    ::error ("`%s' undefined near line %d column %d",
+    ::error ("'%s' undefined near line %d column %d",
              name ().c_str (), l, c);
 }
 
 octave_value_list
 tree_identifier::rvalue (int nargout)
 {
   octave_value_list retval;
 
@@ -67,17 +67,17 @@ tree_identifier::rvalue (int nargout)
 
   if (val.is_defined ())
     {
       // GAGME -- this would be cleaner if we required
       // parens to indicate function calls.
       //
       // If this identifier refers to a function, we need to know
       // whether it is indexed so that we can do the same thing
-      // for `f' and `f()'.  If the index is present, return the
+      // for 'f' and 'f()'.  If the index is present, return the
       // function object and let tree_index_expression::rvalue
       // handle indexing.  Otherwise, arrange to call the function
       // here, so that we don't return the function definition as
       // a value.
 
       if (val.is_function () && ! is_postfix_indexed ())
         {
           octave_value_list tmp_args;
diff --git a/src/pt-idx.cc b/src/pt-idx.cc
--- a/src/pt-idx.cc
+++ b/src/pt-idx.cc
@@ -215,17 +215,17 @@ tree_index_expression::get_struct_index
         {
           octave_value t = df->rvalue1 ();
 
           if (! error_state)
             {
               fn = t.string_value ();
 
               if (! valid_identifier (fn))
-                ::error ("invalid structure field name `%s'", fn.c_str ());
+                ::error ("invalid structure field name '%s'", fn.c_str ());
             }
         }
       else
         panic_impossible ();
     }
 
   return fn;
 }
diff --git a/src/pt-misc.cc b/src/pt-misc.cc
--- a/src/pt-misc.cc
+++ b/src/pt-misc.cc
@@ -78,17 +78,17 @@ tree_parameter_list::validate (in_or_out
           if (id->is_black_hole ())
             {
               if (type != in)
                 error ("invalid use of ~ in output list");
             }
           else if (dict.find (name) != dict.end ())
             {
               retval = false;
-              error ("`%s' appears more than once in parameter list",
+              error ("'%s' appears more than once in parameter list",
                      name.c_str ());
               break;
             }
           else
             dict.insert (name);
         }
     }
 
diff --git a/src/pt-unop.cc b/src/pt-unop.cc
--- a/src/pt-unop.cc
+++ b/src/pt-unop.cc
@@ -44,17 +44,17 @@ tree_unary_expression::oper (void) const
 // Prefix expressions.
 
 octave_value_list
 tree_prefix_expression::rvalue (int nargout)
 {
   octave_value_list retval;
 
   if (nargout > 1)
-    error ("prefix operator `%s': invalid number of output arguments",
+    error ("prefix operator '%s': invalid number of output arguments",
            oper () . c_str ());
   else
     retval = rvalue1 (nargout);
 
   return retval;
 }
 
 octave_value
@@ -131,17 +131,17 @@ tree_prefix_expression::accept (tree_wal
 // Postfix expressions.
 
 octave_value_list
 tree_postfix_expression::rvalue (int nargout)
 {
   octave_value_list retval;
 
   if (nargout > 1)
-    error ("postfix operator `%s': invalid number of output arguments",
+    error ("postfix operator '%s': invalid number of output arguments",
            oper () . c_str ());
   else
     retval = rvalue1 (nargout);
 
   return retval;
 }
 
 octave_value
diff --git a/src/symtab.cc b/src/symtab.cc
--- a/src/symtab.cc
+++ b/src/symtab.cc
@@ -1653,17 +1653,17 @@ DEFUN (variable_value, args, , "VALUE = 
     {
       std::string name = args(0).string_value ();
 
       if (! error_state)
         {
           retval = symbol_table::varval (name);
 
           if (retval.is_undefined ())
-            error ("variable_value: `%s' is not a variable in the current scope",
+            error ("variable_value: '%s' is not a variable in the current scope",
                    name.c_str ());
         }
       else
         error ("variable_value: expecting variable name as first argument");
     }
   else
     print_usage ();
 
diff --git a/src/symtab.h b/src/symtab.h
--- a/src/symtab.h
+++ b/src/symtab.h
@@ -1434,17 +1434,17 @@ public:
     if (p != fcn_table.end ())
       {
         fcn_info& finfo = p->second;
 
         finfo.clear_user_function ();
       }
     // FIXME -- is this necessary, or even useful?
     // else
-    //   error ("clear: no such function `%s'", name.c_str ());
+    //   error ("clear: no such function '%s'", name.c_str ());
   }
 
   // This clears oct and mex files, incl. autoloads.
   static void clear_dld_function (const std::string& name)
   {
     fcn_table_iterator p = fcn_table.find (name);
 
     if (p != fcn_table.end ())
@@ -1480,17 +1480,17 @@ public:
       {
         fcn_info finfo (alias);
 
         finfo.install_built_in_function (fcn);
 
         fcn_table[alias] = finfo;
       }
     else
-      panic ("alias: `%s' is undefined", name.c_str ());
+      panic ("alias: '%s' is undefined", name.c_str ());
   }
 
   static void add_dispatch (const std::string& name, const std::string& type,
                             const std::string& fname)
   {
     fcn_table_iterator p = fcn_table.find (name);
 
     if (p != fcn_table.end ())
diff --git a/src/toplev.cc b/src/toplev.cc
--- a/src/toplev.cc
+++ b/src/toplev.cc
@@ -812,17 +812,17 @@ run_command_and_return_output (const std
         cmd_status = WEXITSTATUS (cmd_status);
       else
         cmd_status = 127;
 
       retval(1) = output_buf.str ();
       retval(0) = cmd_status;
     }
   else
-    error ("unable to start subprocess for `%s'", cmd_str.c_str ());
+    error ("unable to start subprocess for '%s'", cmd_str.c_str ());
 
   return retval;
 }
 
 enum system_exec_type { et_sync, et_async };
 
 DEFUN (system, args, nargout,
   "-*- texinfo -*-\n\
@@ -1465,17 +1465,17 @@ specified option.\n\
     {
       std::string arg = args(0).string_value ();
 
       if (! error_state)
         {
           Cell c = m.contents (arg.c_str ());
 
           if (c.is_empty ())
-            error ("octave_config_info: no info for `%s'", arg.c_str ());
+            error ("octave_config_info: no info for '%s'", arg.c_str ());
           else
             retval = c(0);
         }
     }
   else if (nargin == 0)
     retval = m;
   else
     print_usage ();
diff --git a/src/txt-eng-ft.cc b/src/txt-eng-ft.cc
--- a/src/txt-eng-ft.cc
+++ b/src/txt-eng-ft.cc
@@ -40,25 +40,25 @@ along with Octave; see the file COPYING.
 
 // FIXME -- maybe issue at most one warning per glyph/font/size/weight
 // combination.
 
 static void
 gripe_missing_glyph (char c)
 {
   warning_with_id ("Octave:missing-glyph",
-                   "ft_render: skipping missing glyph for character `%c'",
+                   "ft_render: skipping missing glyph for character '%c'",
                    c);
 }
 
 static void
 gripe_glyph_render (char c)
 {
   warning_with_id ("Octave:glyph-render",
-                   "ft_render: unable to render glyph for character `%c'",
+                   "ft_render: unable to render glyph for character '%c'",
                    c);
 }
 
 #ifdef _MSC_VER
 // This is just a trick to avoid multiply symbols definition.
 // PermMatrix.h contains a dllexport'ed Array<octave_idx_type>
 // that will make MSVC not to generate new instantiation and
 // use the imported one.
@@ -131,17 +131,17 @@ private:
     {
       if (freetype_initialized)
         FT_Done_FreeType (library);
 
 #if defined (HAVE_FONTCONFIG)
       // FIXME -- Skip the call to FcFini because it can trigger the
       // assertion
       //
-      //   octave: fccache.c:507: FcCacheFini: Assertion `fcCacheChains[i] == ((void *)0)' failed.
+      //   octave: fccache.c:507: FcCacheFini: Assertion 'fcCacheChains[i] == ((void *)0)' failed.
       //
       // if (fontconfig_initialized)
       //   FcFini ();
 #endif
     }
 
 
   FT_Face do_get_font (const std::string& name, const std::string& weight,
@@ -293,17 +293,17 @@ ft_render::set_mode (int m)
         {
           pixels = uint8NDArray (dim_vector (4, bbox(2), bbox(3)),
                                  static_cast<uint8_t> (0));
           xoffset = 0;
           yoffset = -bbox(1)-1;
         }
       break;
     default:
-      ::error ("ft_render: invalid mode `%d'", mode);
+      ::error ("ft_render: invalid mode '%d'", mode);
       break;
     }
 }
 
 void
 ft_render::visit (text_element_string& e)
 {
   if (face)
diff --git a/src/utils.cc b/src/utils.cc
--- a/src/utils.cc
+++ b/src/utils.cc
@@ -625,18 +625,18 @@ do_string_escapes (const std::string& s)
               retval[i] = '\'';
               break;
 
             case '"': // double quote
               retval[i] = '"';
               break;
 
             default:
-              warning ("unrecognized escape sequence `\\%c' --\
- converting to `%c'", s[j], s[j]);
+              warning ("unrecognized escape sequence '\\%c' --\
+ converting to '%c'", s[j], s[j]);
               retval[i] = s[j];
               break;
             }
         }
       else
         {
           retval[i] = s[j];
         }
diff --git a/src/variables.cc b/src/variables.cc
--- a/src/variables.cc
+++ b/src/variables.cc
@@ -104,17 +104,17 @@ is_valid_function (const std::string& fc
     {
       octave_value val = symbol_table::find_function (fcn_name);
 
       if (val.is_defined ())
         ans = val.function_value (true);
     }
 
   if (! ans && warn)
-    error ("%s: the symbol `%s' is not valid as a function",
+    error ("%s: the symbol '%s' is not valid as a function",
            warn_for.c_str (), fcn_name.c_str ());
 
   return ans;
 }
 
 octave_function *
 is_valid_function (const octave_value& arg,
                    const std::string& warn_for, bool warn)
@@ -162,26 +162,26 @@ extract_function (const octave_value& ar
           eval_string (cmd, true, parse_status, 0);
 
           if (parse_status == 0)
             {
               retval = is_valid_function (fname, warn_for, 0);
 
               if (! retval)
                 {
-                  error ("%s: `%s' is not valid as a function",
+                  error ("%s: '%s' is not valid as a function",
                          warn_for.c_str (), fname.c_str ());
                   return retval;
                 }
 
               warning ("%s: passing function body as a string is obsolete; please use anonymous functions",
                        warn_for.c_str ());
             }
           else
-            error ("%s: `%s' is not valid as a function",
+            error ("%s: '%s' is not valid as a function",
                    warn_for.c_str (), fname.c_str ());
         }
       else
         error ("%s: expecting first argument to be a string",
                warn_for.c_str ());
     }
 
   return retval;
@@ -602,34 +602,34 @@ lookup_function_handle (const std::strin
 }
 
 octave_value
 get_global_value (const std::string& nm, bool silent)
 {
   octave_value val = symbol_table::global_varval (nm);
 
   if (val.is_undefined () && ! silent)
-    error ("get_global_value: undefined symbol `%s'", nm.c_str ());
+    error ("get_global_value: undefined symbol '%s'", nm.c_str ());
 
   return val;
 }
 
 void
 set_global_value (const std::string& nm, const octave_value& val)
 {
   symbol_table::global_varref (nm) = val;
 }
 
 octave_value
 get_top_level_value (const std::string& nm, bool silent)
 {
   octave_value val = symbol_table::top_level_varval (nm);
 
   if (val.is_undefined () && ! silent)
-    error ("get_top_level_value: undefined symbol `%s'", nm.c_str ());
+    error ("get_top_level_value: undefined symbol '%s'", nm.c_str ());
 
   return val;
 }
 
 void
 set_top_level_value (const std::string& nm, const octave_value& val)
 {
   symbol_table::top_level_varref (nm) = val;
@@ -1104,17 +1104,17 @@ private:
                   else
                     {
                       os << std::setiosflags (std::ios::left)
                          << std::setw (param.parameter_length);
                     }
                   break;
 
                 default:
-                  error ("whos_line_format: modifier `%c' unknown",
+                  error ("whos_line_format: modifier '%c' unknown",
                          param.modifier);
 
                   os << std::setiosflags (std::ios::right)
                      << std::setw (param.parameter_length);
                 }
 
               switch (param.command)
                 {
@@ -1154,17 +1154,17 @@ private:
                     os << dims_str;
                   break;
 
                 case 't':
                   os << varval.type_name ();
                   break;
 
                 default:
-                  error ("whos_line_format: command `%c' unknown",
+                  error ("whos_line_format: command '%c' unknown",
                          param.command);
                 }
 
               os << std::resetiosflags (std::ios::left)
                  << std::resetiosflags (std::ios::right);
               i++;
             }
           else
@@ -1587,17 +1587,17 @@ do_who (int argc, const string_vector& a
 
           return retval;
         }
       else if (argv[i] == "-regexp")
         have_regexp = true;
       else if (argv[i] == "global")
         global_only = true;
       else if (argv[i][0] == '-')
-        warning ("%s: unrecognized option `%s'", my_name.c_str (),
+        warning ("%s: unrecognized option '%s'", my_name.c_str (),
                  argv[i].c_str ());
       else
         break;
     }
 
   int npats = argc - i;
   string_vector pats;
   if (npats > 0)
diff --git a/test/test_eval-catch.m b/test/test_eval-catch.m
--- a/test/test_eval-catch.m
+++ b/test/test_eval-catch.m
@@ -27,47 +27,47 @@
 %% test/octave.test/eval-catch/eval-catch-3.m
 %!test
 %! eval ("clear a; a; x = 0;", "x = 1;");
 %! assert (x, 1);
 
 %% test/octave.test/eval-catch/eval-catch-5.m
 %!test
 %! eval ("clear a; a; str = '';", "str=lasterr;");
-%! assert (lasterr()(1:13), "`a' undefined");
-%! assert (str(1:13), "`a' undefined");
+%! assert (lasterr()(1:13), "'a' undefined");
+%! assert (str(1:13), "'a' undefined");
 
 %% test/octave.test/eval-catch/eval-catch-6.m
 %!test
 %! eval ("error ('user-defined error'); str = '';", "str = lasterr;");
 %! assert (lasterr()(1:18), "user-defined error");
 %! assert (str(1:18), "user-defined error");
 
 %% test/octave.test/eval-catch/eval-catch-7.m
 %!function ms = mangle (s)
 %!  ## Wrap angle brackets around S.
 %!  ms = cstrcat ("<", s, ">");
 %!endfunction
 %!test
 %! eval ("clear a; a; str='';", "str = mangle (lasterr);");
-%! assert (mangle(lasterr)(1:14), "<`a' undefined");
-%! assert (str(1:14), "<`a' undefined");
+%! assert (mangle(lasterr)(1:14), "<'a' undefined");
+%! assert (str(1:14), "<'a' undefined");
 
 %% test/octave.test/eval-catch/eval-catch-8.m
 %!test
 %! eval ("eval (\"clear a; a;str1='';\", \"str1=lasterr;\"); clear b; b; str2='';",
 %! "str2 = lasterr;");
-%! assert (str1(1:13), "`a' undefined");
-%! assert (str2(1:13), "`b' undefined");
+%! assert (str1(1:13), "'a' undefined");
+%! assert (str2(1:13), "'b' undefined");
 
 %% test/octave.test/eval-catch/eval-catch-9.m
 %!test
 %! eval ("clear a; a; str1='';",
 %! "eval (\"clear b; b; str2='';\", \"str2=lasterr;\"); str1=lasterr;");
-%! assert (str1(1:13), "`b' undefined");
-%! assert (str2(1:13), "`b' undefined");
+%! assert (str1(1:13), "'b' undefined");
+%! assert (str2(1:13), "'b' undefined");
 
 %% test/octave.test/eval-catch/eval-catch-10.m
 %!test
 %! eval ("eval (\"clear a; a; str='';\",\"error (cstrcat (\\\"rethrow: \\\", lasterr));str='';\");",
 %! "str=lasterr;");
-%! assert (str(1:22), "rethrow: `a' undefined");
+%! assert (str(1:22), "rethrow: 'a' undefined");
 
diff --git a/test/test_try.m b/test/test_try.m
--- a/test/test_try.m
+++ b/test/test_try.m
@@ -58,19 +58,19 @@
 
 %% test/octave.test/try/try-5.m
 %!test
 %! try
 %!   clear a;
 %!   a;
 %!   error ("Shoudn't get here");
 %! catch
-%!   assert (lasterr()(1:13), "`a' undefined");
+%!   assert (lasterr()(1:13), "'a' undefined");
 %! end_try_catch
-%! assert (lasterr()(1:13), "`a' undefined");
+%! assert (lasterr()(1:13), "'a' undefined");
 
 %% test/octave.test/try/try-6.m
 %!test 
 %! try
 %!   error ("user-defined error");
 %! catch
 %!   assert (lasterr, "user-defined error");
 %! end_try_catch
@@ -81,59 +81,59 @@
 %!  ms = cstrcat ("<", s, ">");
 %!endfunction
 %!test
 %! try
 %!   clear a;
 %!   a;
 %!   error ("Shoudn't get here");
 %! catch
-%!   assert (mangle (lasterr)(1:14), "<`a' undefined");
+%!   assert (mangle (lasterr)(1:14), "<'a' undefined");
 %! end_try_catch
 
 %% test/octave.test/try/try-8.m
 %!test
 %! try
 %!   try
 %!     clear a;
 %!     a;
 %!     error ("Shoudn't get here");
 %!   catch
-%!     assert (lasterr()(1:13), "`a' undefined");
+%!     assert (lasterr()(1:13), "'a' undefined");
 %!   end_try_catch
 %!   clear b;
 %!   b;
 %!   error ("Shoudn't get here");
 %! catch
-%!   assert (lasterr()(1:13), "`b' undefined");
+%!   assert (lasterr()(1:13), "'b' undefined");
 %! end_try_catch
 
 %% test/octave.test/try/try-9.m
 %!test
 %! try
 %!   clear a;
 %!   a;
 %!   error ("Shoudn't get here");
 %! catch
 %!   try
-%!     assert (lasterr()(1:13), "`a' undefined");
+%!     assert (lasterr()(1:13), "'a' undefined");
 %!     clear b;
 %!     b;
 %!     error ("Shoudn't get here");
 %!   catch
-%!     assert (lasterr()(1:13), "`b' undefined");
+%!     assert (lasterr()(1:13), "'b' undefined");
 %!   end_try_catch
 %! end_try_catch
 
 %% test/octave.test/try/try-10.m
 %!test
 %! try
 %!   try
 %!     clear a;
 %!     a;
 %!     error ("Shoudn't get here");
 %!   catch
 %!     error (cstrcat ("rethrow: ", lasterr));
 %!   end_try_catch
 %! catch
-%!   assert (lasterr()(1:22), "rethrow: `a' undefined");
+%!   assert (lasterr()(1:22), "rethrow: 'a' undefined");
 %! end_try_catch
 
