# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1444087776 14400
#      Mon Oct 05 19:29:36 2015 -0400
# Node ID f90c8372b7bab3bff3a6908cf43976eefdbf93cb
# Parent  b7ac1e94266ecc1902f072c09e18846b06e557e5
eliminate many more simple uses of error_state

* Cell.cc, __ichol__.cc, __ilu__.cc, balance.cc, bsxfun.cc, colloc.cc,
det.cc, dlmread.cc, dynamic-ld.cc, eig.cc, fft.cc, fft2.cc, fftn.cc,
gcd.cc, getgrent.cc, getpwent.cc, givens.cc, hess.cc, input.cc,
levenshtein.cc, load-path.cc, lookup.cc, ls-mat-ascii.cc, ls-mat4.cc,
lsode.cc, lu.cc, max.cc, md5sum.cc, mex.cc, pager.cc, pinv.cc,
pr-output.cc, qz.cc, schur.cc, sparse.cc, sqrtm.cc, str2double.cc,
strfns.cc, sub2ind.cc, sysdep.cc, time.cc, toplev.cc, tril.cc,
tsearch.cc, typecast.cc, __init_gnuplot__.cc, __magick_read__.cc,
__osmesa_print__.cc, amd.cc, audiodevinfo.cc, dmperm.cc, fftw.cc,
symrcm.cc, ov-base-diag.cc, ov-base-sparse.cc, ov-base.cc,
ov-bool-sparse.cc, ov-builtin.cc, ov-complex.cc, ov-cx-diag.cc,
ov-cx-mat.cc, ov-cx-sparse.cc, ov-fcn-handle.cc, ov-fcn-inline.cc,
ov-float.cc, ov-flt-complex.cc, ov-flt-cx-diag.cc, ov-flt-cx-mat.cc,
ov-flt-re-diag.cc, ov-flt-re-mat.cc, ov-lazy-idx.cc, ov-mex-fcn.cc,
ov-perm.cc, ov-range.cc, ov-re-diag.cc, ov-re-mat.cc, ov-re-sparse.cc,
ov-scalar.cc, ov-str-mat.cc, op-bm-b.cc, op-bm-bm.cc, op-sbm-b.cc,
op-sbm-bm.cc, op-str-m.cc, op-str-s.cc, oct-parse.in.yy, pt-cbinop.cc,
pt-colon.cc, pt-decl.cc, pt-exp.cc, pt-id.cc, pt-misc.cc,
pt-select.cc, pt-unop.cc: Eliminate simple uses of error_state.

diff --git a/libinterp/corefcn/Cell.cc b/libinterp/corefcn/Cell.cc
--- a/libinterp/corefcn/Cell.cc
+++ b/libinterp/corefcn/Cell.cc
@@ -175,49 +175,40 @@ Cell::index (const octave_value_list& id
         case 0:
           retval = *this;
           break;
 
         case 1:
           {
             idx_vector i = idx_arg(0).index_vector ();
 
-            if (! error_state)
-              retval = Array<octave_value>::index (i, resize_ok, Matrix ());
+            retval = Array<octave_value>::index (i, resize_ok, Matrix ());
           }
           break;
 
         case 2:
           {
             idx_vector i = idx_arg(0).index_vector ();
 
+            k = 1;
+            idx_vector j = idx_arg(1).index_vector ();
+
             if (! error_state)
-              {
-                k = 1;
-                idx_vector j = idx_arg(1).index_vector ();
-
-                if (! error_state)
-                  retval = Array<octave_value>::index (i, j, resize_ok, Matrix ());
-              }
+              retval = Array<octave_value>::index (i, j, resize_ok, Matrix ());
           }
           break;
 
         default:
           {
             Array<idx_vector> iv (dim_vector (n, 1));
 
             for (k = 0; k < n; k++)
-              {
-                iv(k) = idx_arg(k).index_vector ();
+              iv(k) = idx_arg(k).index_vector ();
 
-                if (error_state)
-                  break;
-              }
-            if (!error_state)
-              retval = Array<octave_value>::index (iv, resize_ok, Matrix ());
+            retval = Array<octave_value>::index (iv, resize_ok, Matrix ());
           }
           break;
         }
     }
   catch (index_exception& e)
     {
       // Rethrow to allow more info to be reported later.
       e.set_pos_if_unset (n, k+1);
diff --git a/libinterp/corefcn/__ichol__.cc b/libinterp/corefcn/__ichol__.cc
--- a/libinterp/corefcn/__ichol__.cc
+++ b/libinterp/corefcn/__ichol__.cc
@@ -216,28 +216,28 @@ Undocumented internal function.\n\
   octave_value_list param_list;
   if (!args(0).is_complex_type ())
     {
       SparseMatrix sm = args(0).sparse_matrix_value ();
       param_list.append (sm);
       sm = feval ("tril", param_list)(0).sparse_matrix_value ();
       ichol_0 <SparseMatrix, double, ichol_mult_real,
                ichol_checkpivot_real> (sm, michol);
-      if (! error_state)
-        retval(0) = sm;
+
+      retval(0) = sm;
     }
   else
     {
       SparseComplexMatrix sm = args(0).sparse_complex_matrix_value ();
       param_list.append (sm);
       sm = feval ("tril", param_list)(0).sparse_complex_matrix_value ();
       ichol_0 <SparseComplexMatrix, Complex, ichol_mult_complex,
                ichol_checkpivot_complex> (sm, michol);
-      if (! error_state)
-        retval(0) = sm;
+
+      retval(0) = sm;
     }
 
   return retval;
 }
 
 template <typename octave_matrix_t, typename T,  T (*ichol_mult) (T, T),
           bool (*ichol_checkpivot) (T)>
 void ichol_t (const octave_matrix_t& sm, octave_matrix_t& L, const T* cols_norm,
@@ -423,27 +423,26 @@ void ichol_t (const octave_matrix_t& sm,
               Lfirst[k]++;
               jjrow = ridx_l[Lfirst[k]];
               Llist[k] = Llist[jjrow];
               Llist[jjrow] = k;
             }
         }
     }
 
-  if (! error_state)
+  // Build the output matrices
+  L = octave_matrix_t (n, n, total_len);
+
+  for (i = 0; i <= n; i++)
+    L.cidx (i) = cidx_l[i];
+
+  for (i = 0; i < total_len; i++)
     {
-      // Build the output matrices
-      L = octave_matrix_t (n, n, total_len);
-      for (i = 0; i <= n; i++)
-        L.cidx (i) = cidx_l[i];
-      for (i = 0; i < total_len; i++)
-        {
-          L.ridx (i) = ridx_l[i];
-          L.data (i) = data_l[i];
-        }
+      L.ridx (i) = ridx_l[i];
+      L.data (i) = data_l[i];
     }
 }
 
 DEFUN (__icholt__, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{L} =} __icholt__ (@var{A})\n\
 @deftypefnx {Built-in Function} {@var{L} =} __icholt__ (@var{A}, @var{droptol})\n\
 @deftypefnx {Built-in Function} {@var{L} =} __icholt__ (@var{A}, @var{droptol}, @var{michol})\n\
@@ -481,18 +480,18 @@ Undocumented internal function.\n\
       param_list(0) = sm_l;
       param_list(1) = 1;
       param_list(2) = "cols";
       cols_norm = feval ("norm", param_list)(0).vector_value ();
       param_list.clear ();
       ichol_t <SparseMatrix,
                double, ichol_mult_real, ichol_checkpivot_real>
                (sm_l, L, cols_norm.fortran_vec (), droptol, michol);
-      if (! error_state)
-        retval(0) = L;
+
+      retval(0) = L;
     }
   else
     {
       Array <Complex> cols_norm;
       SparseComplexMatrix L;
       param_list.append (args(0).sparse_complex_matrix_value ());
       SparseComplexMatrix sm_l =
         feval ("tril", param_list)(0).sparse_complex_matrix_value ();
@@ -500,18 +499,18 @@ Undocumented internal function.\n\
       param_list(1) = 1;
       param_list(2) = "cols";
       cols_norm = feval ("norm", param_list)(0).complex_vector_value ();
       param_list.clear ();
       ichol_t <SparseComplexMatrix,
                Complex, ichol_mult_complex, ichol_checkpivot_complex>
                (sm_l, L, cols_norm.fortran_vec (),
                 Complex (droptol), michol);
-      if (! error_state)
-        retval(0) = L;
+
+      retval(0) = L;
     }
 
   return retval;
 }
 
 /*
 ## No test needed for internal helper function.
 %!assert (1)
diff --git a/libinterp/corefcn/__ilu__.cc b/libinterp/corefcn/__ilu__.cc
--- a/libinterp/corefcn/__ilu__.cc
+++ b/libinterp/corefcn/__ilu__.cc
@@ -148,44 +148,38 @@ Undocumented internal function.\n\
   // In ILU0 algorithm the zero-pattern of the input matrix is preserved so
   // it's structure does not change during the algorithm.  The same input
   // matrix is used to build the output matrix due to that fact.
   octave_value_list param_list;
   if (! args(0).is_complex_type ())
     {
       SparseMatrix sm = args(0).sparse_matrix_value ();
       ilu_0 <SparseMatrix, double> (sm, milu);
-      if (!error_state)
-        {
-          param_list.append (sm);
-          retval(1) = feval ("triu", param_list)(0).sparse_matrix_value ();
-          SparseMatrix eye =
-            feval ("speye", octave_value_list (
-                     octave_value (sm.cols ())))(0).sparse_matrix_value ();
-          param_list.append (-1);
-          retval(0) = eye +
-                      feval ("tril", param_list)(0).sparse_matrix_value ();
-        }
+
+      param_list.append (sm);
+      retval(1) = feval ("triu", param_list)(0).sparse_matrix_value ();
+      SparseMatrix eye =
+        feval ("speye", octave_value_list (octave_value (sm.cols ())))(0).sparse_matrix_value ();
+      param_list.append (-1);
+      retval(0) = eye +
+        feval ("tril", param_list)(0).sparse_matrix_value ();
     }
   else
     {
       SparseComplexMatrix sm = args(0).sparse_complex_matrix_value ();
       ilu_0 <SparseComplexMatrix, Complex> (sm, milu);
-      if (! error_state)
-        {
-          param_list.append (sm);
-          retval(1) =
-            feval ("triu", param_list)(0).sparse_complex_matrix_value ();
-          SparseComplexMatrix eye =
-            feval ("speye", octave_value_list (
-                     octave_value (sm.cols ())))(0).sparse_complex_matrix_value ();
-          param_list.append (-1);
-          retval(0) =
-            eye + feval ("tril", param_list)(0).sparse_complex_matrix_value ();
-        }
+
+      param_list.append (sm);
+      retval(1) =
+        feval ("triu", param_list)(0).sparse_complex_matrix_value ();
+      SparseComplexMatrix eye =
+        feval ("speye", octave_value_list (octave_value (sm.cols ())))(0).sparse_complex_matrix_value ();
+      param_list.append (-1);
+      retval(0) =
+        eye + feval ("tril", param_list)(0).sparse_complex_matrix_value ();
     }
 
   return retval;
 }
 
 template <typename octave_matrix_t, typename T>
 void ilu_crout (octave_matrix_t& sm_l, octave_matrix_t& sm_u,
                 octave_matrix_t& L, octave_matrix_t& U, T* cols_norm,
@@ -441,37 +435,39 @@ void ilu_crout (octave_matrix_t& sm_l, o
                       rows_list[rows_list_len] = i;
                       rows_list_len++;
                     }
                 }
             }
         }
     }
 
-  if (! error_state)
+  // Build the output matrices
+  L = octave_matrix_t (n, n, total_len_l);
+  U = octave_matrix_t (n, n, total_len_u);
+
+  for (i = 0; i <= n; i++)
+    L.cidx (i) = cidx_l[i];
+
+  for (i = 0; i < total_len_l; i++)
     {
-      // Build the output matrices
-      L = octave_matrix_t (n, n, total_len_l);
-      U = octave_matrix_t (n, n, total_len_u);
-      for (i = 0; i <= n; i++)
-        L.cidx (i) = cidx_l[i];
-      for (i = 0; i < total_len_l; i++)
-        {
-          L.ridx (i) = ridx_l[i];
-          L.data (i) = data_l[i];
-        }
-      for (i = 0; i <= n; i++)
-        U.cidx (i) = cidx_u[i];
-      for (i = 0; i < total_len_u; i++)
-        {
-          U.ridx (i) = ridx_u[i];
-          U.data (i) = data_u[i];
-        }
-      U = U.transpose ();
+      L.ridx (i) = ridx_l[i];
+      L.data (i) = data_l[i];
     }
+
+  for (i = 0; i <= n; i++)
+    U.cidx (i) = cidx_u[i];
+
+  for (i = 0; i < total_len_u; i++)
+    {
+      U.ridx (i) = ridx_u[i];
+      U.data (i) = data_u[i];
+    }
+
+  U = U.transpose ();
 }
 
 DEFUN (__iluc__, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {[@var{L}, @var{U}] =} __iluc__ (@var{A})\n\
 @deftypefnx {Built-in Function} {[@var{L}, @var{U}] =} __iluc__ (@var{A}, @var{droptol})\n\
 @deftypefnx {Built-in Function} {[@var{L}, @var{U}] =} __iluc__ (@var{A}, @var{droptol}, @var{milu})\n\
 @deftypefnx {Built-in Function} {[@var{L}, @var{U}, @var{P}] =} __iluc__ (@var{A}, @dots{})\n\
@@ -510,24 +506,21 @@ Undocumented internal function.\n\
       cols_norm = feval ("norm", param_list)(0).vector_value ();
       param_list.clear ();
       SparseMatrix U;
       SparseMatrix L;
       ilu_crout <SparseMatrix, double> (sm_l, sm_u, L, U,
                                         cols_norm.fortran_vec (),
                                         rows_norm.fortran_vec (),
                                         droptol, milu);
-      if (! error_state)
-        {
-          param_list.append (octave_value (L.cols ()));
-          SparseMatrix eye =
-            feval ("speye", param_list)(0).sparse_matrix_value ();
-          retval(1) = U;
-          retval(0) = L + eye;
-        }
+      param_list.append (octave_value (L.cols ()));
+      SparseMatrix eye =
+        feval ("speye", param_list)(0).sparse_matrix_value ();
+      retval(1) = U;
+      retval(0) = L + eye;
     }
   else
     {
       Array<Complex> cols_norm, rows_norm;
       param_list.append (args(0).sparse_complex_matrix_value ());
       SparseComplexMatrix sm_u =
         feval ("triu", param_list)(0).sparse_complex_matrix_value ();
       param_list.append (-1);
@@ -538,24 +531,22 @@ Undocumented internal function.\n\
       param_list(1) = "cols";
       cols_norm = feval ("norm", param_list)(0).complex_vector_value ();
       param_list.clear ();
       SparseComplexMatrix U;
       SparseComplexMatrix L;
       ilu_crout < SparseComplexMatrix, Complex >
                 (sm_l, sm_u, L, U, cols_norm.fortran_vec () ,
                  rows_norm.fortran_vec (), Complex (droptol), milu);
-      if (! error_state)
-        {
-          param_list.append (octave_value (L.cols ()));
-          SparseComplexMatrix eye =
-            feval ("speye", param_list)(0).sparse_complex_matrix_value ();
-          retval(1) = U;
-          retval(0) = L + eye;
-        }
+
+      param_list.append (octave_value (L.cols ()));
+      SparseComplexMatrix eye =
+        feval ("speye", param_list)(0).sparse_complex_matrix_value ();
+      retval(1) = U;
+      retval(0) = L + eye;
     }
 
   return retval;
 }
 
 // That function implements the IKJ and JKI variants of gaussian elimination
 // to perform the ILUTP decomposition.  The behaviour is controlled by milu
 // parameter.  If milu = ['off'|'col'] the JKI version is performed taking
@@ -868,91 +859,88 @@ void ilu_tp (octave_matrix_t& sm, octave
         uptr[k] = total_len_u - 1;
       cidx_u[k+1] = cidx_u[k] - cidx_u[0] + w_len_u;
       cidx_l[k+1] = cidx_l[k] - cidx_l[0] + w_len_l;
 
       iw_l.clear ();
       iw_u.clear ();
     }
 
-  if (! error_state)
+  octave_matrix_t *L_ptr;
+  octave_matrix_t *U_ptr;
+  octave_matrix_t diag (n, n, n);
+
+  // L and U are interchanged if milu = 'row'.  It is a matter
+  // of nomenclature to re-use code with both IKJ and JKI
+  // versions of the algorithm.
+  if (opt == ROW)
     {
-      octave_matrix_t *L_ptr;
-      octave_matrix_t *U_ptr;
-      octave_matrix_t diag (n, n, n);
+      L_ptr = &U;
+      U_ptr = &L;
+      L = octave_matrix_t (n, n, total_len_u - n);
+      U = octave_matrix_t (n, n, total_len_l);
+    }
+  else
+    {
+      L_ptr = &L;
+      U_ptr = &U;
+      L = octave_matrix_t (n, n, total_len_l);
+      U = octave_matrix_t (n, n, total_len_u);
+    }
 
-      // L and U are interchanged if milu = 'row'.  It is a matter
-      // of nomenclature to re-use code with both IKJ and JKI
-      // versions of the algorithm.
+  for (i = 0; i <= n; i++)
+    {
+      L_ptr->cidx (i) = cidx_l[i];
+      U_ptr->cidx (i) = cidx_u[i];
       if (opt == ROW)
-        {
-          L_ptr = &U;
-          U_ptr = &L;
-          L = octave_matrix_t (n, n, total_len_u - n);
-          U = octave_matrix_t (n, n, total_len_l);
-        }
-      else
-        {
-          L_ptr = &L;
-          U_ptr = &U;
-          L = octave_matrix_t (n, n, total_len_l);
-          U = octave_matrix_t (n, n, total_len_u);
-        }
+        U_ptr->cidx (i) -= i;
+    }
 
-      for (i = 0; i <= n; i++)
-        {
-          L_ptr->cidx (i) = cidx_l[i];
-          U_ptr->cidx (i) = cidx_u[i];
-          if (opt == ROW)
-            U_ptr->cidx (i) -= i;
-        }
-
-      for (i = 0; i < n; i++)
-        {
-          if (opt == ROW)
-            diag.elem (i,i) = data_u[uptr[i]];
-          j = cidx_l[i];
+  for (i = 0; i < n; i++)
+    {
+      if (opt == ROW)
+        diag.elem (i,i) = data_u[uptr[i]];
+      j = cidx_l[i];
 
-          while (j < cidx_l[i+1])
+      while (j < cidx_l[i+1])
+        {
+          L_ptr->ridx (j) = ridx_l[j];
+          L_ptr->data (j) = data_l[j];
+          j++;
+        }
+      j = cidx_u[i];
+
+      while (j < cidx_u[i+1])
+        {
+          c = j;
+          if (opt == ROW)
             {
-              L_ptr->ridx (j) = ridx_l[j];
-              L_ptr->data (j) = data_l[j];
-              j++;
-            }
-          j = cidx_u[i];
-
-          while (j < cidx_u[i+1])
-            {
-              c = j;
-              if (opt == ROW)
+              // The diagonal is removed from L if milu = 'row'.
+              // That is because is convenient to have it inside
+              // the L part to carry out the process.
+              if (ridx_u[j] == i)
                 {
-                  // The diagonal is removed from L if milu = 'row'.
-                  // That is because is convenient to have it inside
-                  // the L part to carry out the process.
-                  if (ridx_u[j] == i)
-                    {
-                      j++;
-                      continue;
-                    }
-                  else
-                    c -= i;
+                  j++;
+                  continue;
                 }
-              U_ptr->data (c) = data_u[j];
-              U_ptr->ridx (c) = ridx_u[j];
-              j++;
+              else
+                c -= i;
             }
+          U_ptr->data (c) = data_u[j];
+          U_ptr->ridx (c) = ridx_u[j];
+          j++;
         }
+    }
 
-      if (opt == ROW)
-        {
-          U = U.transpose ();
-          // The diagonal, conveniently permuted is added to U
-          U += diag.index (idx_vector::colon, perm_vec);
-          L = L.transpose ();
-        }
+  if (opt == ROW)
+    {
+      U = U.transpose ();
+      // The diagonal, conveniently permuted is added to U
+      U += diag.index (idx_vector::colon, perm_vec);
+      L = L.transpose ();
     }
 }
 
 DEFUN (__ilutp__, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {[@var{L}, @var{U}] =} __ilutp__ (@var{A})\n\
 @deftypefnx {Built-in Function} {[@var{L}, @var{U}] =} __ilutp__ (@var{A}, @var{droptol})\n\
 @deftypefnx {Built-in Function} {[@var{L}, @var{U}] =} __ilutp__ (@var{A}, @var{droptol}, @var{thresh})\n\
@@ -1005,45 +993,42 @@ Undocumented internal function.\n\
       rc_norm = feval ("norm", param_list)(0).vector_value ();
       param_list.clear ();
       Array <octave_idx_type> perm (dim_vector (sm.cols (), 1));
       SparseMatrix U;
       SparseMatrix L;
       ilu_tp <SparseMatrix, double> (sm, L, U, nnz_u, nnz_l,
                                      rc_norm.fortran_vec (),
                                      perm, droptol, thresh, milu, udiag);
-      if (! error_state)
+      param_list.append (octave_value (L.cols ()));
+      SparseMatrix eye =
+        feval ("speye", param_list)(0).sparse_matrix_value ();
+      if (milu == "row")
         {
-          param_list.append (octave_value (L.cols ()));
-          SparseMatrix eye =
-            feval ("speye", param_list)(0).sparse_matrix_value ();
-          if (milu == "row")
+          if (nargout == 3)
             {
-              if (nargout == 3)
-                {
-                  retval(2) = eye.index (idx_vector::colon, perm);
-                  retval(1) = U.index (idx_vector::colon, perm);
-                }
-              else if (nargout == 2)
-                retval(1) = U;
-              retval(0) = L + eye;
+              retval(2) = eye.index (idx_vector::colon, perm);
+              retval(1) = U.index (idx_vector::colon, perm);
+            }
+          else if (nargout == 2)
+            retval(1) = U;
+          retval(0) = L + eye;
+        }
+      else
+        {
+          if (nargout == 3)
+            {
+              retval(2) = eye.index (perm, idx_vector::colon);
+              retval(1) = U;
+              retval(0) = L.index (perm, idx_vector::colon) + eye;
             }
           else
             {
-              if (nargout == 3)
-                {
-                  retval(2) = eye.index (perm, idx_vector::colon);
-                  retval(1) = U;
-                  retval(0) = L.index (perm, idx_vector::colon) + eye;
-                }
-              else
-                {
-                  retval(1) = U;
-                  retval(0) = L + eye.index (perm, idx_vector::colon);
-                }
+              retval(1) = U;
+              retval(0) = L + eye.index (perm, idx_vector::colon);
             }
         }
     }
   else
     {
       Array <Complex> rc_norm;
       SparseComplexMatrix sm = args(0).sparse_complex_matrix_value ();
       param_list.append (sm);
@@ -1060,45 +1045,42 @@ Undocumented internal function.\n\
       Array <octave_idx_type> perm (dim_vector (sm.cols (), 1));
       param_list.clear ();
       SparseComplexMatrix U;
       SparseComplexMatrix L;
       ilu_tp < SparseComplexMatrix, Complex>
               (sm, L, U, nnz_u, nnz_l, rc_norm.fortran_vec (), perm,
                Complex (droptol), Complex (thresh), milu, udiag);
 
-      if (! error_state)
+      param_list.append (octave_value (L.cols ()));
+      SparseComplexMatrix eye =
+        feval ("speye", param_list)(0).sparse_complex_matrix_value ();
+      if (milu == "row")
         {
-          param_list.append (octave_value (L.cols ()));
-          SparseComplexMatrix eye =
-            feval ("speye", param_list)(0).sparse_complex_matrix_value ();
-          if (milu == "row")
+          if (nargout == 3)
             {
-              if (nargout == 3)
-                {
-                  retval(2) = eye.index (idx_vector::colon, perm);
-                  retval(1) = U.index (idx_vector::colon, perm);
-                }
-              else if (nargout == 2)
-                retval(1) = U;
-              retval(0) = L + eye;
+              retval(2) = eye.index (idx_vector::colon, perm);
+              retval(1) = U.index (idx_vector::colon, perm);
+            }
+          else if (nargout == 2)
+            retval(1) = U;
+          retval(0) = L + eye;
+        }
+      else
+        {
+          if (nargout == 3)
+            {
+              retval(2) = eye.index (perm, idx_vector::colon);
+              retval(1) = U;
+              retval(0) = L.index (perm, idx_vector::colon) + eye;
             }
           else
             {
-              if (nargout == 3)
-                {
-                  retval(2) = eye.index (perm, idx_vector::colon);
-                  retval(1) = U;
-                  retval(0) = L.index (perm, idx_vector::colon) + eye;
-                }
-              else
-                {
-                  retval(1) = U;
-                  retval(0) = L + eye.index (perm, idx_vector::colon);
-                }
+              retval(1) = U;
+              retval(0) = L + eye.index (perm, idx_vector::colon);
             }
         }
     }
 
   return retval;
 }
 
 /*
diff --git a/libinterp/corefcn/balance.cc b/libinterp/corefcn/balance.cc
--- a/libinterp/corefcn/balance.cc
+++ b/libinterp/corefcn/balance.cc
@@ -135,19 +135,16 @@ Generalized eigenvalue problem balancing
   else
     {
       if (complex_case)
         caa = args(0).complex_matrix_value ();
       else
         aa = args(0).matrix_value ();
     }
 
-  if (error_state)
-    return retval;
-
   // Treat AEP/GEP cases.
   if (AEPcase)
     {
       // Algebraic eigenvalue problem.
       bool noperm = false;
       bool noscal = false;
       if (nargin > 1)
         {
diff --git a/libinterp/corefcn/bsxfun.cc b/libinterp/corefcn/bsxfun.cc
--- a/libinterp/corefcn/bsxfun.cc
+++ b/libinterp/corefcn/bsxfun.cc
@@ -369,17 +369,17 @@ dimensionality as the other array.\n\
             {
               octave_value tmp = maybe_optimized_builtin (fcn_val->name (),
                                                           A, B);
               if (tmp.is_defined ())
                 retval(0) = tmp;
             }
         }
 
-      if (! error_state && retval.empty ())
+      if (retval.empty ())
         {
           dim_vector dva = A.dims ();
           octave_idx_type nda = dva.length ();
           dim_vector dvb = B.dims ();
           octave_idx_type ndb = dvb.length ();
           octave_idx_type nd = nda;
 
           if (nda > ndb)
@@ -392,281 +392,272 @@ dimensionality as the other array.\n\
 
           for (octave_idx_type i = 0; i < nd; i++)
             if (dva(i) != dvb(i) && dva(i) != 1 && dvb(i) != 1)
               {
                 error ("bsxfun: dimensions of A and B must match");
                 break;
               }
 
-          if (!error_state)
-            {
-              // Find the size of the output
-              dim_vector dvc;
-              dvc.resize (nd);
+          // Find the size of the output
+          dim_vector dvc;
+          dvc.resize (nd);
 
-              for (octave_idx_type i = 0; i < nd; i++)
-                dvc(i) = (dva(i) < 1 ? dva(i)
-                                     : (dvb(i) < 1 ? dvb(i)
-                                                   : (dva(i) > dvb(i)
-                                                       ? dva(i) : dvb(i))));
+          for (octave_idx_type i = 0; i < nd; i++)
+            dvc(i) = (dva(i) < 1 ? dva(i)
+                                 : (dvb(i) < 1 ? dvb(i)
+                                               : (dva(i) > dvb(i)
+                                                   ? dva(i) : dvb(i))));
 
-              if (dva == dvb || dva.numel () == 1 || dvb.numel () == 1)
-                {
-                  octave_value_list inputs;
-                  inputs (0) = A;
-                  inputs (1) = B;
-                  retval = func.do_multi_index_op (1, inputs);
-                }
-              else if (dvc.numel () < 1)
-                {
-                  octave_value_list inputs;
-                  inputs (0) = A.resize (dvc);
-                  inputs (1) = B.resize (dvc);
-                  retval = func.do_multi_index_op (1, inputs);
-                }
-              else
-                {
-                  octave_idx_type ncount = 1;
-                  for (octave_idx_type i = 1; i < nd; i++)
-                    ncount *= dvc(i);
+          if (dva == dvb || dva.numel () == 1 || dvb.numel () == 1)
+            {
+              octave_value_list inputs;
+              inputs (0) = A;
+              inputs (1) = B;
+              retval = func.do_multi_index_op (1, inputs);
+            }
+          else if (dvc.numel () < 1)
+            {
+              octave_value_list inputs;
+              inputs (0) = A.resize (dvc);
+              inputs (1) = B.resize (dvc);
+              retval = func.do_multi_index_op (1, inputs);
+            }
+          else
+            {
+              octave_idx_type ncount = 1;
+              for (octave_idx_type i = 1; i < nd; i++)
+                ncount *= dvc(i);
 
 #define BSXDEF(T) \
-                  T result_ ## T; \
-                  bool have_ ## T = false;
+              T result_ ## T; \
+              bool have_ ## T = false;
 
-                  BSXDEF(NDArray);
-                  BSXDEF(ComplexNDArray);
-                  BSXDEF(FloatNDArray);
-                  BSXDEF(FloatComplexNDArray);
-                  BSXDEF(boolNDArray);
-                  BSXDEF(int8NDArray);
-                  BSXDEF(int16NDArray);
-                  BSXDEF(int32NDArray);
-                  BSXDEF(int64NDArray);
-                  BSXDEF(uint8NDArray);
-                  BSXDEF(uint16NDArray);
-                  BSXDEF(uint32NDArray);
-                  BSXDEF(uint64NDArray);
+              BSXDEF(NDArray);
+              BSXDEF(ComplexNDArray);
+              BSXDEF(FloatNDArray);
+              BSXDEF(FloatComplexNDArray);
+              BSXDEF(boolNDArray);
+              BSXDEF(int8NDArray);
+              BSXDEF(int16NDArray);
+              BSXDEF(int32NDArray);
+              BSXDEF(int64NDArray);
+              BSXDEF(uint8NDArray);
+              BSXDEF(uint16NDArray);
+              BSXDEF(uint32NDArray);
+              BSXDEF(uint64NDArray);
 
-                  octave_value Ac ;
-                  octave_value_list idxA;
-                  octave_value Bc;
-                  octave_value_list idxB;
-                  octave_value C;
-                  octave_value_list inputs;
-                  Array<int> ra_idx (dim_vector (dvc.length (), 1), 0);
+              octave_value Ac ;
+              octave_value_list idxA;
+              octave_value Bc;
+              octave_value_list idxB;
+              octave_value C;
+              octave_value_list inputs;
+              Array<int> ra_idx (dim_vector (dvc.length (), 1), 0);
 
 
-                  for (octave_idx_type i = 0; i < ncount; i++)
-                    {
-                      if (maybe_update_column (Ac, A, dva, dvc, i, idxA))
-                        inputs (0) = Ac;
+              for (octave_idx_type i = 0; i < ncount; i++)
+                {
+                  if (maybe_update_column (Ac, A, dva, dvc, i, idxA))
+                    inputs (0) = Ac;
 
-                      if (maybe_update_column (Bc, B, dvb, dvc, i, idxB))
-                        inputs (1) = Bc;
+                  if (maybe_update_column (Bc, B, dvb, dvc, i, idxB))
+                    inputs (1) = Bc;
 
-                      octave_value_list tmp = func.do_multi_index_op (1,
-                                                                      inputs);
-
-                      if (error_state)
-                        break;
+                  octave_value_list tmp = func.do_multi_index_op (1,
+                                                                  inputs);
 
 #define BSXINIT(T, CLS, EXTRACTOR) \
-                      (result_type == CLS) \
-                        { \
-                            have_ ## T = true; \
-                            result_ ## T = \
-                                tmp (0). EXTRACTOR ## _array_value (); \
-                            result_ ## T .resize (dvc); \
-                        }
+  (result_type == CLS) \
+    { \
+      have_ ## T = true; \
+      result_ ## T = tmp (0). EXTRACTOR ## _array_value (); \
+      result_ ## T .resize (dvc); \
+    }
 
-                      if (i == 0)
+                  if (i == 0)
+                    {
+                      if (! tmp(0).is_sparse_type ())
                         {
-                          if (! tmp(0).is_sparse_type ())
+                          std::string result_type = tmp(0).class_name ();
+                          if (result_type == "double")
                             {
-                              std::string result_type = tmp(0).class_name ();
-                              if (result_type == "double")
+                              if (tmp(0).is_real_type ())
                                 {
-                                  if (tmp(0).is_real_type ())
-                                    {
-                                      have_NDArray = true;
-                                      result_NDArray = tmp(0).array_value ();
-                                      result_NDArray.resize (dvc);
-                                    }
-                                  else
-                                    {
-                                      have_ComplexNDArray = true;
-                                      result_ComplexNDArray =
-                                        tmp(0).complex_array_value ();
-                                      result_ComplexNDArray.resize (dvc);
-                                    }
+                                  have_NDArray = true;
+                                  result_NDArray = tmp(0).array_value ();
+                                  result_NDArray.resize (dvc);
                                 }
-                              else if (result_type == "single")
+                              else
                                 {
-                                  if (tmp(0).is_real_type ())
-                                    {
-                                      have_FloatNDArray = true;
-                                      result_FloatNDArray
-                                        = tmp(0).float_array_value ();
-                                      result_FloatNDArray.resize (dvc);
-                                    }
-                                  else
-                                    {
-                                      have_ComplexNDArray = true;
-                                      result_ComplexNDArray =
-                                        tmp(0).complex_array_value ();
-                                      result_ComplexNDArray.resize (dvc);
-                                    }
+                                  have_ComplexNDArray = true;
+                                  result_ComplexNDArray =
+                                    tmp(0).complex_array_value ();
+                                  result_ComplexNDArray.resize (dvc);
                                 }
-                              else if BSXINIT(boolNDArray, "logical", bool)
-                              else if BSXINIT(int8NDArray, "int8", int8)
-                              else if BSXINIT(int16NDArray, "int16", int16)
-                              else if BSXINIT(int32NDArray, "int32", int32)
-                              else if BSXINIT(int64NDArray, "int64", int64)
-                              else if BSXINIT(uint8NDArray, "uint8", uint8)
-                              else if BSXINIT(uint16NDArray, "uint16", uint16)
-                              else if BSXINIT(uint32NDArray, "uint32", uint32)
-                              else if BSXINIT(uint64NDArray, "uint64", uint64)
+                            }
+                          else if (result_type == "single")
+                            {
+                              if (tmp(0).is_real_type ())
+                                {
+                                  have_FloatNDArray = true;
+                                  result_FloatNDArray
+                                    = tmp(0).float_array_value ();
+                                  result_FloatNDArray.resize (dvc);
+                                }
                               else
                                 {
-                                  C = tmp (0);
-                                  C = C.resize (dvc);
+                                  have_ComplexNDArray = true;
+                                  result_ComplexNDArray =
+                                    tmp(0).complex_array_value ();
+                                  result_ComplexNDArray.resize (dvc);
                                 }
                             }
+                          else if BSXINIT(boolNDArray, "logical", bool)
+                          else if BSXINIT(int8NDArray, "int8", int8)
+                          else if BSXINIT(int16NDArray, "int16", int16)
+                          else if BSXINIT(int32NDArray, "int32", int32)
+                          else if BSXINIT(int64NDArray, "int64", int64)
+                          else if BSXINIT(uint8NDArray, "uint8", uint8)
+                          else if BSXINIT(uint16NDArray, "uint16", uint16)
+                          else if BSXINIT(uint32NDArray, "uint32", uint32)
+                          else if BSXINIT(uint64NDArray, "uint64", uint64)
+                          else
+                            {
+                              C = tmp (0);
+                              C = C.resize (dvc);
+                            }
                         }
-                      else
+                    }
+                  else
+                    {
+                      update_index (ra_idx, dvc, i);
+
+                      if (have_FloatNDArray
+                          || have_FloatComplexNDArray)
                         {
-                          update_index (ra_idx, dvc, i);
-
-                          if (have_FloatNDArray
-                              || have_FloatComplexNDArray)
+                          if (! tmp(0).is_float_type ())
                             {
-                              if (! tmp(0).is_float_type ())
-                                {
-                                  if (have_FloatNDArray)
-                                    {
-                                      have_FloatNDArray = false;
-                                      C = result_FloatNDArray;
-                                    }
-                                  else
-                                    {
-                                      have_FloatComplexNDArray = false;
-                                      C = result_FloatComplexNDArray;
-                                    }
-                                  C = do_cat_op (C, tmp(0), ra_idx);
-                                }
-                              else if (tmp(0).is_double_type ())
+                              if (have_FloatNDArray)
                                 {
-                                  if (tmp(0).is_complex_type ()
-                                      && have_FloatNDArray)
-                                    {
-                                      result_ComplexNDArray =
-                                        ComplexNDArray (result_FloatNDArray);
-                                      result_ComplexNDArray.insert
-                                        (tmp(0).complex_array_value (), ra_idx);
-                                      have_FloatComplexNDArray = false;
-                                      have_ComplexNDArray = true;
-                                    }
-                                  else
-                                    {
-                                      result_NDArray =
-                                        NDArray (result_FloatNDArray);
-                                      result_NDArray.insert
-                                        (tmp(0).array_value (), ra_idx);
-                                      have_FloatNDArray = false;
-                                      have_NDArray = true;
-                                    }
+                                  have_FloatNDArray = false;
+                                  C = result_FloatNDArray;
                                 }
-                              else if (tmp(0).is_real_type ())
-                                result_FloatNDArray.insert
-                                  (tmp(0).float_array_value (), ra_idx);
                               else
                                 {
-                                  result_FloatComplexNDArray =
-                                    FloatComplexNDArray (result_FloatNDArray);
-                                  result_FloatComplexNDArray.insert
-                                    (tmp(0).float_complex_array_value (),
-                                     ra_idx);
+                                  have_FloatComplexNDArray = false;
+                                  C = result_FloatComplexNDArray;
+                                }
+                              C = do_cat_op (C, tmp(0), ra_idx);
+                            }
+                          else if (tmp(0).is_double_type ())
+                            {
+                              if (tmp(0).is_complex_type ()
+                                  && have_FloatNDArray)
+                                {
+                                  result_ComplexNDArray =
+                                    ComplexNDArray (result_FloatNDArray);
+                                  result_ComplexNDArray.insert
+                                    (tmp(0).complex_array_value (), ra_idx);
+                                  have_FloatComplexNDArray = false;
+                                  have_ComplexNDArray = true;
+                                }
+                              else
+                                {
+                                  result_NDArray =
+                                    NDArray (result_FloatNDArray);
+                                  result_NDArray.insert
+                                    (tmp(0).array_value (), ra_idx);
                                   have_FloatNDArray = false;
-                                  have_FloatComplexNDArray = true;
+                                  have_NDArray = true;
                                 }
                             }
-                          else if (have_NDArray)
+                          else if (tmp(0).is_real_type ())
+                            result_FloatNDArray.insert
+                              (tmp(0).float_array_value (), ra_idx);
+                          else
+                            {
+                              result_FloatComplexNDArray =
+                                FloatComplexNDArray (result_FloatNDArray);
+                              result_FloatComplexNDArray.insert
+                                (tmp(0).float_complex_array_value (),
+                                 ra_idx);
+                              have_FloatNDArray = false;
+                              have_FloatComplexNDArray = true;
+                            }
+                        }
+                      else if (have_NDArray)
+                        {
+                          if (! tmp(0).is_float_type ())
                             {
-                              if (! tmp(0).is_float_type ())
-                                {
-                                  have_NDArray = false;
-                                  C = result_NDArray;
-                                  C = do_cat_op (C, tmp(0), ra_idx);
-                                }
-                              else if (tmp(0).is_real_type ())
-                                result_NDArray.insert (tmp(0).array_value (),
-                                                       ra_idx);
-                              else
-                                {
-                                  result_ComplexNDArray =
-                                    ComplexNDArray (result_NDArray);
-                                  result_ComplexNDArray.insert
-                                    (tmp(0).complex_array_value (), ra_idx);
-                                  have_NDArray = false;
-                                  have_ComplexNDArray = true;
-                                }
+                              have_NDArray = false;
+                              C = result_NDArray;
+                              C = do_cat_op (C, tmp(0), ra_idx);
                             }
+                          else if (tmp(0).is_real_type ())
+                            result_NDArray.insert (tmp(0).array_value (),
+                                                   ra_idx);
+                          else
+                            {
+                              result_ComplexNDArray =
+                                ComplexNDArray (result_NDArray);
+                              result_ComplexNDArray.insert
+                                (tmp(0).complex_array_value (), ra_idx);
+                              have_NDArray = false;
+                              have_ComplexNDArray = true;
+                            }
+                        }
 
 #define BSXLOOP(T, CLS, EXTRACTOR) \
-                        (have_ ## T) \
-                          { \
-                            if (tmp (0).class_name () != CLS) \
-                              { \
-                                have_ ## T = false; \
-                                C = result_ ## T; \
-                                C = do_cat_op (C, tmp (0), ra_idx); \
-                              } \
-                            else \
-                              result_ ## T .insert \
-                                (tmp(0). EXTRACTOR ## _array_value (), \
-                                ra_idx); \
-                          }
+  (have_ ## T) \
+    { \
+      if (tmp (0).class_name () != CLS) \
+        { \
+          have_ ## T = false; \
+          C = result_ ## T; \
+          C = do_cat_op (C, tmp (0), ra_idx); \
+        } \
+      else \
+        result_ ## T .insert (tmp(0). EXTRACTOR ## _array_value (), ra_idx); \
+    }
 
-                          else if BSXLOOP(ComplexNDArray, "double", complex)
-                          else if BSXLOOP(boolNDArray, "logical", bool)
-                          else if BSXLOOP(int8NDArray, "int8", int8)
-                          else if BSXLOOP(int16NDArray, "int16", int16)
-                          else if BSXLOOP(int32NDArray, "int32", int32)
-                          else if BSXLOOP(int64NDArray, "int64", int64)
-                          else if BSXLOOP(uint8NDArray, "uint8", uint8)
-                          else if BSXLOOP(uint16NDArray, "uint16", uint16)
-                          else if BSXLOOP(uint32NDArray, "uint32", uint32)
-                          else if BSXLOOP(uint64NDArray, "uint64", uint64)
-                          else
-                            C = do_cat_op (C, tmp(0), ra_idx);
-                        }
+                      else if BSXLOOP(ComplexNDArray, "double", complex)
+                      else if BSXLOOP(boolNDArray, "logical", bool)
+                      else if BSXLOOP(int8NDArray, "int8", int8)
+                      else if BSXLOOP(int16NDArray, "int16", int16)
+                      else if BSXLOOP(int32NDArray, "int32", int32)
+                      else if BSXLOOP(int64NDArray, "int64", int64)
+                      else if BSXLOOP(uint8NDArray, "uint8", uint8)
+                      else if BSXLOOP(uint16NDArray, "uint16", uint16)
+                      else if BSXLOOP(uint32NDArray, "uint32", uint32)
+                      else if BSXLOOP(uint64NDArray, "uint64", uint64)
+                      else
+                        C = do_cat_op (C, tmp(0), ra_idx);
                     }
+                }
 
 #define BSXEND(T) \
-                  (have_ ## T) \
-                    retval(0) = result_ ## T;
+  (have_ ## T) \
+    retval(0) = result_ ## T;
 
-                  if BSXEND(NDArray)
-                  else if BSXEND(ComplexNDArray)
-                  else if BSXEND(FloatNDArray)
-                  else if BSXEND(FloatComplexNDArray)
-                  else if BSXEND(boolNDArray)
-                  else if BSXEND(int8NDArray)
-                  else if BSXEND(int16NDArray)
-                  else if BSXEND(int32NDArray)
-                  else if BSXEND(int64NDArray)
-                  else if BSXEND(uint8NDArray)
-                  else if BSXEND(uint16NDArray)
-                  else if BSXEND(uint32NDArray)
-                  else if BSXEND(uint64NDArray)
-                  else
-                    retval(0) = C;
-                }
+              if BSXEND(NDArray)
+              else if BSXEND(ComplexNDArray)
+              else if BSXEND(FloatNDArray)
+              else if BSXEND(FloatComplexNDArray)
+              else if BSXEND(boolNDArray)
+              else if BSXEND(int8NDArray)
+              else if BSXEND(int16NDArray)
+              else if BSXEND(int32NDArray)
+              else if BSXEND(int64NDArray)
+              else if BSXEND(uint8NDArray)
+              else if BSXEND(uint16NDArray)
+              else if BSXEND(uint32NDArray)
+              else if BSXEND(uint64NDArray)
+              else
+                retval(0) = C;
             }
         }
     }
 
   return retval;
 }
 
 /*
diff --git a/libinterp/corefcn/colloc.cc b/libinterp/corefcn/colloc.cc
--- a/libinterp/corefcn/colloc.cc
+++ b/libinterp/corefcn/colloc.cc
@@ -56,19 +56,16 @@ Reference: @nospell{J. Villadsen}, @nosp
   if (! args(0).is_scalar_type ())
     {
       error ("colloc: N must be a scalar");
       return retval;
     }
 
   double tmp = args(0).double_value ();
 
-  if (error_state)
-    return retval;
-
   if (xisnan (tmp))
     {
       error ("colloc: N cannot be NaN");
       return retval;
     }
 
   octave_idx_type ncol = NINTbig (tmp);
   if (ncol < 0)
diff --git a/libinterp/corefcn/det.cc b/libinterp/corefcn/det.cc
--- a/libinterp/corefcn/det.cc
+++ b/libinterp/corefcn/det.cc
@@ -146,106 +146,98 @@ For that, use any of the condition numbe
     {
       if (arg.is_real_type ())
         {
           octave_idx_type info;
           float rcond = 0.0;
           // Always compute rcond, so we can detect numerically
           // singular matrices.
           FloatMatrix m = arg.float_matrix_value ();
-          if (! error_state)
-            {
-              MAYBE_CAST (rep, octave_float_matrix);
-              MatrixType mtype = rep ? rep -> matrix_type () : MatrixType ();
-              FloatDET det = m.determinant (mtype, info, rcond);
-              retval(1) = rcond;
-              retval(0) = info == -1 ? 0.0f : det.value ();
-              if (rep) rep->matrix_type (mtype);
-            }
+
+          MAYBE_CAST (rep, octave_float_matrix);
+          MatrixType mtype = rep ? rep -> matrix_type () : MatrixType ();
+          FloatDET det = m.determinant (mtype, info, rcond);
+          retval(1) = rcond;
+          retval(0) = info == -1 ? 0.0f : det.value ();
+          if (rep)
+            rep->matrix_type (mtype);
         }
       else if (arg.is_complex_type ())
         {
           octave_idx_type info;
           float rcond = 0.0;
           // Always compute rcond, so we can detect numerically
           // singular matrices.
           FloatComplexMatrix m = arg.float_complex_matrix_value ();
-          if (! error_state)
-            {
-              MAYBE_CAST (rep, octave_float_complex_matrix);
-              MatrixType mtype = rep ? rep -> matrix_type () : MatrixType ();
-              FloatComplexDET det = m.determinant (mtype, info, rcond);
-              retval(1) = rcond;
-              retval(0) = info == -1 ? FloatComplex (0.0) : det.value ();
-              if (rep) rep->matrix_type (mtype);
-            }
+
+          MAYBE_CAST (rep, octave_float_complex_matrix);
+          MatrixType mtype = rep ? rep -> matrix_type () : MatrixType ();
+          FloatComplexDET det = m.determinant (mtype, info, rcond);
+          retval(1) = rcond;
+          retval(0) = info == -1 ? FloatComplex (0.0) : det.value ();
+          if (rep)
+            rep->matrix_type (mtype);
         }
     }
   else
     {
       if (arg.is_real_type ())
         {
           octave_idx_type info;
           double rcond = 0.0;
           // Always compute rcond, so we can detect numerically
           // singular matrices.
           if (arg.is_sparse_type ())
             {
               SparseMatrix m = arg.sparse_matrix_value ();
-              if (! error_state)
-                {
-                  DET det = m.determinant (info, rcond);
-                  retval(1) = rcond;
-                  retval(0) = info == -1 ? 0.0 : det.value ();
-                }
+
+              DET det = m.determinant (info, rcond);
+              retval(1) = rcond;
+              retval(0) = info == -1 ? 0.0 : det.value ();
             }
           else
             {
               Matrix m = arg.matrix_value ();
-              if (! error_state)
-                {
-                  MAYBE_CAST (rep, octave_matrix);
-                  MatrixType mtype = rep ? rep -> matrix_type ()
-                                         : MatrixType ();
-                  DET det = m.determinant (mtype, info, rcond);
-                  retval(1) = rcond;
-                  retval(0) = info == -1 ? 0.0 : det.value ();
-                  if (rep) rep->matrix_type (mtype);
-                }
+
+              MAYBE_CAST (rep, octave_matrix);
+              MatrixType mtype = rep ? rep -> matrix_type ()
+                : MatrixType ();
+              DET det = m.determinant (mtype, info, rcond);
+              retval(1) = rcond;
+              retval(0) = info == -1 ? 0.0 : det.value ();
+              if (rep)
+                rep->matrix_type (mtype);
             }
         }
       else if (arg.is_complex_type ())
         {
           octave_idx_type info;
           double rcond = 0.0;
           // Always compute rcond, so we can detect numerically
           // singular matrices.
           if (arg.is_sparse_type ())
             {
               SparseComplexMatrix m = arg.sparse_complex_matrix_value ();
-              if (! error_state)
-                {
-                  ComplexDET det = m.determinant (info, rcond);
-                  retval(1) = rcond;
-                  retval(0) = info == -1 ? Complex (0.0) : det.value ();
-                }
+
+              ComplexDET det = m.determinant (info, rcond);
+              retval(1) = rcond;
+              retval(0) = info == -1 ? Complex (0.0) : det.value ();
             }
           else
             {
               ComplexMatrix m = arg.complex_matrix_value ();
-              if (! error_state)
-                {
-                  MAYBE_CAST (rep, octave_complex_matrix);
-                  MatrixType mtype = rep ? rep -> matrix_type ()
-                                         : MatrixType ();
-                  ComplexDET det = m.determinant (mtype, info, rcond);
-                  retval(1) = rcond;
-                  retval(0) = info == -1 ? Complex (0.0) : det.value ();
-                  if (rep) rep->matrix_type (mtype);
-                }
+
+              MAYBE_CAST (rep, octave_complex_matrix);
+              MatrixType mtype = rep ? rep -> matrix_type ()
+                : MatrixType ();
+              ComplexDET det = m.determinant (mtype, info, rcond);
+              retval(1) = rcond;
+              retval(0) = info == -1 ? Complex (0.0) : det.value ();
+              if (rep)
+                rep->matrix_type (mtype);
             }
         }
       else
         gripe_wrong_type_arg ("det", arg);
     }
   return retval;
 }
 
diff --git a/libinterp/corefcn/dlmread.cc b/libinterp/corefcn/dlmread.cc
--- a/libinterp/corefcn/dlmread.cc
+++ b/libinterp/corefcn/dlmread.cc
@@ -193,18 +193,17 @@ fill empty fields.  The default is zero.
   int nargin = args.length ();
 
   double empty_value = 0.0;
 
   if (nargin > 2 && args(nargin-2).is_string ()
       && args(nargin-2).string_value () == "emptyvalue")
     {
       empty_value = args(nargin-1).double_value ();
-      if (error_state)
-        return retval;
+
       nargin -= 2;
     }
 
   if (nargin < 1 || nargin > 4)
     {
       print_usage ();
       return retval;
     }
@@ -228,19 +227,16 @@ fill empty fields.  The default is zero.
         }
       else
         input = &input_file;
     }
   else if (args(0).is_scalar_type ())
     {
       octave_stream is = octave_stream_list::lookup (args(0), "dlmread");
 
-      if (error_state)
-        return retval;
-
       input = is.input_stream ();
 
       if (! input)
         {
           error ("dlmread: stream FILE not open for input");
           return retval;
         }
     }
@@ -253,19 +249,16 @@ fill empty fields.  The default is zero.
   // Set default separator.
   std::string sep;
   if (nargin > 1)
     {
       if (args(1).is_sq_string ())
         sep = do_string_escapes (args(1).string_value ());
       else
         sep = args(1).string_value ();
-
-      if (error_state)
-        return retval;
     }
 
   // Take a subset if a range was given.
   octave_idx_type r0 = 0;
   octave_idx_type c0 = 0;
   octave_idx_type r1 = idx_max-1;
   octave_idx_type c1 = idx_max-1;
   if (nargin > 2)
@@ -274,226 +267,220 @@ fill empty fields.  The default is zero.
         {
           if (!parse_range_spec (args(2), r0, c0, r1, c1))
             error ("dlmread: error parsing RANGE");
         }
       else if (nargin == 4)
         {
           r0 = args(2).idx_type_value ();
           c0 = args(3).idx_type_value ();
-
-          if (error_state)
-            return retval;
         }
 
       if (r0 < 0 || c0 < 0)
         error ("dlmread: left & top must be positive");
     }
 
-  if (!error_state)
-    {
-      octave_idx_type i = 0;
-      octave_idx_type j = 0;
-      octave_idx_type r = 1;
-      octave_idx_type c = 1;
-      octave_idx_type rmax = 0;
-      octave_idx_type cmax = 0;
+  octave_idx_type i = 0;
+  octave_idx_type j = 0;
+  octave_idx_type r = 1;
+  octave_idx_type c = 1;
+  octave_idx_type rmax = 0;
+  octave_idx_type cmax = 0;
 
-      Matrix rdata;
-      ComplexMatrix cdata;
+  Matrix rdata;
+  ComplexMatrix cdata;
+
+  bool iscmplx = false;
+  bool sepflag = false;
+
+  std::string line;
 
-      bool iscmplx = false;
-      bool sepflag = false;
+  // Skip the r0 leading lines as these might be a header.
+  for (octave_idx_type m = 0; m < r0; m++)
+    getline (*input, line);
+  r1 -= r0;
 
-      std::string line;
+  std::istringstream tmp_stream;
 
-      // Skip the r0 leading lines as these might be a header.
-      for (octave_idx_type m = 0; m < r0; m++)
-        getline (*input, line);
-      r1 -= r0;
+  // Read in the data one field at a time, growing the data matrix
+  // as needed.
+  while (getline (*input, line))
+    {
+      // Skip blank lines for compatibility.
+      if (line.find_first_not_of (" \t") == std::string::npos)
+        continue;
 
-      std::istringstream tmp_stream;
-
-      // Read in the data one field at a time, growing the data matrix
-      // as needed.
-      while (getline (*input, line))
+      // To be compatible with matlab, blank separator should
+      // correspond to whitespace as delimter.
+      if (!sep.length ())
         {
-          // Skip blank lines for compatibility.
-          if (line.find_first_not_of (" \t") == std::string::npos)
-            continue;
+          size_t n = line.find_first_of (",:; \t",
+                                         line.find_first_of ("0123456789"));
+          if (n == std::string::npos)
+            {
+              sep = " \t";
+              sepflag = true;
+            }
+          else
+            {
+              char ch = line.at (n);
 
-          // To be compatible with matlab, blank separator should
-          // correspond to whitespace as delimter.
-          if (!sep.length ())
-            {
-              size_t n = line.find_first_of (",:; \t",
-                                             line.find_first_of ("0123456789"));
-              if (n == std::string::npos)
+              switch (line.at (n))
                 {
-                  sep = " \t";
+                case ' ':
+                case '\t':
                   sepflag = true;
-                }
-              else
-                {
-                  char ch = line.at (n);
+                  sep = " \t";
+                  break;
 
-                  switch (line.at (n))
-                    {
-                    case ' ':
-                    case '\t':
-                      sepflag = true;
-                      sep = " \t";
-                      break;
-
-                    default:
-                      sep = ch;
-                      break;
-                    }
+                default:
+                  sep = ch;
+                  break;
                 }
             }
-
-          if (cmax == 0)
-            {
-              // Try to estimate the number of columns.  Skip leading
-              // whitespace.
-              size_t pos1 = line.find_first_not_of (" \t");
-              do
-                {
-                  size_t pos2 = line.find_first_of (sep, pos1);
-
-                  if (sepflag && pos2 != std::string::npos)
-                    // Treat consecutive separators as one.
-                    {
-                      pos2 = line.find_first_not_of (sep, pos2);
-                      if (pos2 != std::string::npos)
-                        pos2 -= 1;
-                      else
-                        pos2 = line.length () - 1;
-                    }
+        }
 
-                  cmax++;
-
-                  if (pos2 != std::string::npos)
-                    pos1 = pos2 + 1;
-                  else
-                    pos1 = std::string::npos;
-
-                }
-              while (pos1 != std::string::npos);
-
-              if (iscmplx)
-                cdata.resize (rmax, cmax);
-              else
-                rdata.resize (rmax, cmax);
-            }
-
-          r = (r > i + 1 ? r : i + 1);
-          j = 0;
-          // Skip leading whitespace.
+      if (cmax == 0)
+        {
+          // Try to estimate the number of columns.  Skip leading
+          // whitespace.
           size_t pos1 = line.find_first_not_of (" \t");
           do
             {
-              octave_quit ();
-
               size_t pos2 = line.find_first_of (sep, pos1);
-              std::string str = line.substr (pos1, pos2 - pos1);
 
               if (sepflag && pos2 != std::string::npos)
                 // Treat consecutive separators as one.
-                pos2 = line.find_first_not_of (sep, pos2) - 1;
-
-              c = (c > j + 1 ? c : j + 1);
-              if (r > rmax || c > cmax)
                 {
-                  // Use resize_and_fill for the case of not-equal
-                  // length rows.
-                  rmax = 2*r;
-                  cmax = c;
-                  if (iscmplx)
-                    cdata.resize (rmax, cmax);
+                  pos2 = line.find_first_not_of (sep, pos2);
+                  if (pos2 != std::string::npos)
+                    pos2 -= 1;
                   else
-                    rdata.resize (rmax, cmax);
+                    pos2 = line.length () - 1;
                 }
 
-              tmp_stream.str (str);
-              tmp_stream.clear ();
-
-              double x = octave_read_double (tmp_stream);
-              if (tmp_stream)
-                {
-                  if (tmp_stream.eof ())
-                    {
-                      if (iscmplx)
-                        cdata(i,j++) = x;
-                      else
-                        rdata(i,j++) = x;
-                    }
-                  else if (std::toupper (tmp_stream.peek ()) == 'I')
-                    {
-                      // This is to allow pure imaginary numbers.
-                      if (iscmplx)
-                        cdata(i,j++) = x;
-                      else
-                        rdata(i,j++) = x;
-                    }
-                  else
-                    {
-                      double y = octave_read_double (tmp_stream);
-
-                      if (!iscmplx && y != 0.)
-                        {
-                          iscmplx = true;
-                          cdata = ComplexMatrix (rdata);
-                        }
-
-                      if (iscmplx)
-                        cdata(i,j++) = Complex (x, y);
-                      else
-                        rdata(i,j++) = x;
-                    }
-                }
-              else if (iscmplx)
-                cdata(i,j++) = empty_value;
-              else
-                rdata(i,j++) = empty_value;
+              cmax++;
 
               if (pos2 != std::string::npos)
                 pos1 = pos2 + 1;
               else
                 pos1 = std::string::npos;
 
             }
           while (pos1 != std::string::npos);
 
-          if (i == r1)
-            break;
-
-          i++;
+          if (iscmplx)
+            cdata.resize (rmax, cmax);
+          else
+            rdata.resize (rmax, cmax);
         }
 
-      if (r1 >= r)
-        r1 = r - 1;
-      if (c1 >= c)
-        c1 = c - 1;
-
-      // Now take the subset of the matrix if there are any values.
-      if (i > 0 || j > 0)
+      r = (r > i + 1 ? r : i + 1);
+      j = 0;
+      // Skip leading whitespace.
+      size_t pos1 = line.find_first_not_of (" \t");
+      do
         {
-          if (iscmplx)
-            cdata = cdata.extract (0, c0, r1, c1);
-          else
-            rdata = rdata.extract (0, c0, r1, c1);
-        }
+          octave_quit ();
+
+          size_t pos2 = line.find_first_of (sep, pos1);
+          std::string str = line.substr (pos1, pos2 - pos1);
+
+          if (sepflag && pos2 != std::string::npos)
+            // Treat consecutive separators as one.
+            pos2 = line.find_first_not_of (sep, pos2) - 1;
+
+          c = (c > j + 1 ? c : j + 1);
+          if (r > rmax || c > cmax)
+            {
+              // Use resize_and_fill for the case of not-equal
+              // length rows.
+              rmax = 2*r;
+              cmax = c;
+              if (iscmplx)
+                cdata.resize (rmax, cmax);
+              else
+                rdata.resize (rmax, cmax);
+            }
+
+          tmp_stream.str (str);
+          tmp_stream.clear ();
+
+          double x = octave_read_double (tmp_stream);
+          if (tmp_stream)
+            {
+              if (tmp_stream.eof ())
+                {
+                  if (iscmplx)
+                    cdata(i,j++) = x;
+                  else
+                    rdata(i,j++) = x;
+                }
+              else if (std::toupper (tmp_stream.peek ()) == 'I')
+                {
+                  // This is to allow pure imaginary numbers.
+                  if (iscmplx)
+                    cdata(i,j++) = x;
+                  else
+                    rdata(i,j++) = x;
+                }
+              else
+                {
+                  double y = octave_read_double (tmp_stream);
 
+                  if (!iscmplx && y != 0.)
+                    {
+                      iscmplx = true;
+                      cdata = ComplexMatrix (rdata);
+                    }
+
+                  if (iscmplx)
+                    cdata(i,j++) = Complex (x, y);
+                  else
+                    rdata(i,j++) = x;
+                }
+            }
+          else if (iscmplx)
+            cdata(i,j++) = empty_value;
+          else
+            rdata(i,j++) = empty_value;
+
+          if (pos2 != std::string::npos)
+            pos1 = pos2 + 1;
+          else
+            pos1 = std::string::npos;
+
+        }
+      while (pos1 != std::string::npos);
+
+      if (i == r1)
+        break;
+
+      i++;
+    }
+
+  if (r1 >= r)
+    r1 = r - 1;
+  if (c1 >= c)
+    c1 = c - 1;
+
+  // Now take the subset of the matrix if there are any values.
+  if (i > 0 || j > 0)
+    {
       if (iscmplx)
-        retval(0) = cdata;
+        cdata = cdata.extract (0, c0, r1, c1);
       else
-        retval(0) = rdata;
+        rdata = rdata.extract (0, c0, r1, c1);
     }
 
+  if (iscmplx)
+    retval(0) = cdata;
+  else
+    retval(0) = rdata;
+
   return retval;
 }
 
 /*
 %!shared file
 %! file = tempname ();
 %! fid = fopen (file, "wt");
 %! fwrite (fid, "1, 2, 3\n4, 5, 6\n7, 8, 9\n10, 11, 12");
diff --git a/libinterp/corefcn/dynamic-ld.cc b/libinterp/corefcn/dynamic-ld.cc
--- a/libinterp/corefcn/dynamic-ld.cc
+++ b/libinterp/corefcn/dynamic-ld.cc
@@ -264,49 +264,46 @@ octave_dynamic_loader::do_load_oct (cons
 
   if (oct_file && oct_file.is_out_of_date ())
     clear (oct_file);
 
   if (! oct_file)
     {
       oct_file.open (file_name);
 
-      if (! error_state && oct_file)
+      if (oct_file)
         octave_shlib_list::append (oct_file);
     }
 
-  if (! error_state)
+  if (oct_file)
     {
-      if (oct_file)
-        {
-          void *function = oct_file.search (fcn_name, name_mangler);
+      void *function = oct_file.search (fcn_name, name_mangler);
 
-          if (! function)
-            {
-              // FIXME: can we determine this C mangling scheme
-              // automatically at run time or configure time?
+      if (! function)
+        {
+          // FIXME: can we determine this C mangling scheme
+          // automatically at run time or configure time?
 
-              function = oct_file.search (fcn_name, name_uscore_mangler);
-            }
+          function = oct_file.search (fcn_name, name_uscore_mangler);
+        }
 
-          if (function)
-            {
-              octave_dld_fcn_getter f
-                = FCN_PTR_CAST (octave_dld_fcn_getter, function);
+      if (function)
+        {
+          octave_dld_fcn_getter f
+            = FCN_PTR_CAST (octave_dld_fcn_getter, function);
 
-              retval = f (oct_file, relative);
+          retval = f (oct_file, relative);
 
-              if (! retval)
-                error ("failed to install .oct file function '%s'",
-                       fcn_name.c_str ());
-            }
+          if (! retval)
+            error ("failed to install .oct file function '%s'",
+                   fcn_name.c_str ());
         }
-      else
-        error ("%s is not a valid shared library", file_name.c_str ());
     }
+  else
+    error ("%s is not a valid shared library", file_name.c_str ());
 
   return retval;
 }
 
 octave_function *
 octave_dynamic_loader::do_load_mex (const std::string& fcn_name,
                                     const std::string& file_name,
                                     bool /*relative*/)
@@ -323,56 +320,53 @@ octave_dynamic_loader::do_load_mex (cons
 
   if (mex_file && mex_file.is_out_of_date ())
     clear (mex_file);
 
   if (! mex_file)
     {
       mex_file.open (file_name);
 
-      if (! error_state && mex_file)
+      if (mex_file)
         octave_shlib_list::append (mex_file);
     }
 
-  if (! error_state)
+  if (mex_file)
     {
-      if (mex_file)
+      void *function = 0;
+
+      bool have_fmex = false;
+
+      function = mex_file.search (fcn_name, mex_mangler);
+
+      if (! function)
         {
-          void *function = 0;
+          // FIXME: can we determine this C mangling scheme
+          // automatically at run time or configure time?
 
-          bool have_fmex = false;
-
-          function = mex_file.search (fcn_name, mex_mangler);
+          function = mex_file.search (fcn_name, mex_uscore_mangler);
 
           if (! function)
             {
-              // FIXME: can we determine this C mangling scheme
-              // automatically at run time or configure time?
+              function = mex_file.search (fcn_name, mex_f77_mangler);
 
-              function = mex_file.search (fcn_name, mex_uscore_mangler);
-
-              if (! function)
-                {
-                  function = mex_file.search (fcn_name, mex_f77_mangler);
+              if (function)
+                have_fmex = true;
+            }
+        }
 
-                  if (function)
-                    have_fmex = true;
-                }
-            }
-
-          if (function)
-            retval = new octave_mex_function (function, have_fmex,
-                                              mex_file, fcn_name);
-          else
-            error ("failed to install .mex file function '%s'",
-                   fcn_name.c_str ());
-        }
+      if (function)
+        retval = new octave_mex_function (function, have_fmex,
+                                          mex_file, fcn_name);
       else
-        error ("%s is not a valid shared library", file_name.c_str ());
+        error ("failed to install .mex file function '%s'",
+               fcn_name.c_str ());
     }
+  else
+    error ("%s is not a valid shared library", file_name.c_str ());
 
   return retval;
 }
 
 bool
 octave_dynamic_loader::do_remove_oct (const std::string& fcn_name,
                                       octave_shlib& shl)
 {
diff --git a/libinterp/corefcn/eig.cc b/libinterp/corefcn/eig.cc
--- a/libinterp/corefcn/eig.cc
+++ b/libinterp/corefcn/eig.cc
@@ -122,136 +122,106 @@ The eigenvalues returned by @code{eig} a
       FloatEIG result;
 
       if (nargin == 1)
         {
           if (arg_a.is_real_type ())
             {
               ftmp_a = arg_a.float_matrix_value ();
 
-              if (error_state)
-                return retval;
-              else
-                result = FloatEIG (ftmp_a, nargout > 1);
+              result = FloatEIG (ftmp_a, nargout > 1);
             }
           else
             {
               fctmp_a = arg_a.float_complex_matrix_value ();
 
-              if (error_state)
-                return retval;
-              else
-                result = FloatEIG (fctmp_a, nargout > 1);
+              result = FloatEIG (fctmp_a, nargout > 1);
             }
         }
       else if (nargin == 2)
         {
           if (arg_a.is_real_type () && arg_b.is_real_type ())
             {
               ftmp_a = arg_a.float_matrix_value ();
               ftmp_b = arg_b.float_matrix_value ();
 
-              if (error_state)
-                return retval;
-              else
-                result = FloatEIG (ftmp_a, ftmp_b, nargout > 1);
+              result = FloatEIG (ftmp_a, ftmp_b, nargout > 1);
             }
           else
             {
               fctmp_a = arg_a.float_complex_matrix_value ();
               fctmp_b = arg_b.float_complex_matrix_value ();
 
-              if (error_state)
-                return retval;
-              else
-                result = FloatEIG (fctmp_a, fctmp_b, nargout > 1);
+              result = FloatEIG (fctmp_a, fctmp_b, nargout > 1);
             }
         }
 
-      if (! error_state)
+      if (nargout == 0 || nargout == 1)
+        {
+          retval(0) = result.eigenvalues ();
+        }
+      else
         {
-          if (nargout == 0 || nargout == 1)
-            {
-              retval(0) = result.eigenvalues ();
-            }
-          else
-            {
-              // Blame it on Matlab.
+          // Blame it on Matlab.
 
-              FloatComplexDiagMatrix d (result.eigenvalues ());
+          FloatComplexDiagMatrix d (result.eigenvalues ());
 
-              retval(1) = d;
-              retval(0) = result.eigenvectors ();
-            }
+          retval(1) = d;
+          retval(0) = result.eigenvectors ();
         }
     }
   else
     {
       EIG result;
 
       if (nargin == 1)
         {
           if (arg_a.is_real_type ())
             {
               tmp_a = arg_a.matrix_value ();
 
-              if (error_state)
-                return retval;
-              else
-                result = EIG (tmp_a, nargout > 1);
+              result = EIG (tmp_a, nargout > 1);
             }
           else
             {
               ctmp_a = arg_a.complex_matrix_value ();
 
-              if (error_state)
-                return retval;
-              else
-                result = EIG (ctmp_a, nargout > 1);
+              result = EIG (ctmp_a, nargout > 1);
             }
         }
       else if (nargin == 2)
         {
           if (arg_a.is_real_type () && arg_b.is_real_type ())
             {
               tmp_a = arg_a.matrix_value ();
               tmp_b = arg_b.matrix_value ();
 
-              if (error_state)
-                return retval;
-              else
-                result = EIG (tmp_a, tmp_b, nargout > 1);
+              result = EIG (tmp_a, tmp_b, nargout > 1);
             }
           else
             {
               ctmp_a = arg_a.complex_matrix_value ();
               ctmp_b = arg_b.complex_matrix_value ();
 
-              if (error_state)
-                return retval;
-              else
-                result = EIG (ctmp_a, ctmp_b, nargout > 1);
+              result = EIG (ctmp_a, ctmp_b, nargout > 1);
             }
         }
 
-      if (! error_state)
+      if (nargout == 0 || nargout == 1)
+        {
+          retval(0) = result.eigenvalues ();
+        }
+      else
         {
-          if (nargout == 0 || nargout == 1)
-            {
-              retval(0) = result.eigenvalues ();
-            }
-          else
-            {
-              // Blame it on Matlab.
+          // Blame it on Matlab.
 
-              ComplexDiagMatrix d (result.eigenvalues ());
+          ComplexDiagMatrix d (result.eigenvalues ());
 
-              retval(1) = d;
-              retval(0) = result.eigenvectors ();
-            }
+          retval(1) = d;
+          retval(0) = result.eigenvectors ();
         }
     }
 
   return retval;
 }
 
 /*
 %!assert (eig ([1, 2; 2, 1]), [-1; 3], sqrt (eps))
diff --git a/libinterp/corefcn/fft.cc b/libinterp/corefcn/fft.cc
--- a/libinterp/corefcn/fft.cc
+++ b/libinterp/corefcn/fft.cc
@@ -69,35 +69,29 @@ do_fft (const octave_value_list &args, c
               n_points = NINTbig (dval);
               if (n_points < 0)
                 error ("%s: number of points (N) must be greater than zero",
                        fcn);
             }
         }
     }
 
-  if (error_state)
-    return retval;
-
   if (nargin > 2)
     {
       double dval = args(2).double_value ();
       if (xisnan (dval))
         error ("%s: DIM cannot be NaN", fcn);
       else if (dval < 1 || dval > dims.length ())
         error ("%s: DIM must be a valid dimension along which to perform FFT",
                fcn);
       else
         // to be safe, cast it back to int since dim is an int
         dim = NINT (dval) - 1;
     }
 
-  if (error_state)
-    return retval;
-
   for (octave_idx_type i = 0; i < dims.length (); i++)
     if (dims(i) < 0)
       return retval;
 
   if (dim < 0)
     {
       for (octave_idx_type i = 0; i < dims.length (); i++)
         if (dims(i) > 1)
@@ -125,59 +119,45 @@ do_fft (const octave_value_list &args, c
     }
 
   if (arg.is_single_type ())
     {
       if (arg.is_real_type ())
         {
           FloatNDArray nda = arg.float_array_value ();
 
-          if (! error_state)
-            {
-              nda.resize (dims, 0.0);
-              retval = (type != 0 ? nda.ifourier (dim) : nda.fourier (dim));
-            }
+          nda.resize (dims, 0.0);
+          retval = (type != 0 ? nda.ifourier (dim) : nda.fourier (dim));
         }
       else
         {
           FloatComplexNDArray cnda = arg.float_complex_array_value ();
 
-          if (! error_state)
-            {
-              cnda.resize (dims, 0.0);
-              retval = (type != 0 ? cnda.ifourier (dim) : cnda.fourier (dim));
-            }
+          cnda.resize (dims, 0.0);
+          retval = (type != 0 ? cnda.ifourier (dim) : cnda.fourier (dim));
         }
     }
   else
     {
       if (arg.is_real_type ())
         {
           NDArray nda = arg.array_value ();
 
-          if (! error_state)
-            {
-              nda.resize (dims, 0.0);
-              retval = (type != 0 ? nda.ifourier (dim) : nda.fourier (dim));
-            }
+          nda.resize (dims, 0.0);
+          retval = (type != 0 ? nda.ifourier (dim) : nda.fourier (dim));
         }
       else if (arg.is_complex_type ())
         {
           ComplexNDArray cnda = arg.complex_array_value ();
 
-          if (! error_state)
-            {
-              cnda.resize (dims, 0.0);
-              retval = (type != 0 ? cnda.ifourier (dim) : cnda.fourier (dim));
-            }
+          cnda.resize (dims, 0.0);
+          retval = (type != 0 ? cnda.ifourier (dim) : cnda.fourier (dim));
         }
       else
-        {
-          gripe_wrong_type_arg (fcn, arg);
-        }
+        gripe_wrong_type_arg (fcn, arg);
     }
 
   return retval;
 }
 
 /*
 %!assert (fft ([]), [])
 %!assert (fft (zeros (10,0)), zeros (10,0))
diff --git a/libinterp/corefcn/fft2.cc b/libinterp/corefcn/fft2.cc
--- a/libinterp/corefcn/fft2.cc
+++ b/libinterp/corefcn/fft2.cc
@@ -66,36 +66,30 @@ do_fft2 (const octave_value_list &args, 
       else
         {
           n_rows = NINTbig (dval);
           if (n_rows < 0)
             error ("%s: number of rows (N) must be greater than zero", fcn);
         }
     }
 
-  if (error_state)
-    return retval;
-
   octave_idx_type n_cols = -1;
   if (nargin > 2)
     {
       double dval = args(2).double_value ();
       if (xisnan (dval))
         error ("%s: number of columns (M) cannot be NaN", fcn);
       else
         {
           n_cols = NINTbig (dval);
           if (n_cols < 0)
             error ("%s: number of columns (M) must be greater than zero", fcn);
         }
     }
 
-  if (error_state)
-    return retval;
-
   for (int i = 0; i < dims.length (); i++)
     if (dims(i) < 0)
       return retval;
 
   if (n_rows < 0)
     n_rows = dims(0);
   else
     dims(0) = n_rows;
@@ -114,59 +108,45 @@ do_fft2 (const octave_value_list &args, 
     }
 
   if (arg.is_single_type ())
     {
       if (arg.is_real_type ())
         {
           FloatNDArray nda = arg.float_array_value ();
 
-          if (! error_state)
-            {
-              nda.resize (dims, 0.0);
-              retval = (type != 0 ? nda.ifourier2d () : nda.fourier2d ());
-            }
+          nda.resize (dims, 0.0);
+          retval = (type != 0 ? nda.ifourier2d () : nda.fourier2d ());
         }
       else
         {
           FloatComplexNDArray cnda = arg.float_complex_array_value ();
 
-          if (! error_state)
-            {
-              cnda.resize (dims, 0.0);
-              retval = (type != 0 ? cnda.ifourier2d () : cnda.fourier2d ());
-            }
+          cnda.resize (dims, 0.0);
+          retval = (type != 0 ? cnda.ifourier2d () : cnda.fourier2d ());
         }
     }
   else
     {
       if (arg.is_real_type ())
         {
           NDArray nda = arg.array_value ();
 
-          if (! error_state)
-            {
-              nda.resize (dims, 0.0);
-              retval = (type != 0 ? nda.ifourier2d () : nda.fourier2d ());
-            }
+          nda.resize (dims, 0.0);
+          retval = (type != 0 ? nda.ifourier2d () : nda.fourier2d ());
         }
       else if (arg.is_complex_type ())
         {
           ComplexNDArray cnda = arg.complex_array_value ();
 
-          if (! error_state)
-            {
-              cnda.resize (dims, 0.0);
-              retval = (type != 0 ? cnda.ifourier2d () : cnda.fourier2d ());
-            }
+          cnda.resize (dims, 0.0);
+          retval = (type != 0 ? cnda.ifourier2d () : cnda.fourier2d ());
         }
       else
-        {
-          gripe_wrong_type_arg (fcn, arg);
-        }
+        gripe_wrong_type_arg (fcn, arg);
     }
 
   return retval;
 }
 
 DEFUN (fft2, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} fft2 (@var{A})\n\
diff --git a/libinterp/corefcn/fftn.cc b/libinterp/corefcn/fftn.cc
--- a/libinterp/corefcn/fftn.cc
+++ b/libinterp/corefcn/fftn.cc
@@ -80,76 +80,59 @@ do_fftn (const octave_value_list &args, 
               else
                 {
                   dims(i) = NINTbig(val(i,0));
                 }
             }
         }
     }
 
-  if (error_state)
-    return retval;
-
   if (dims.all_zero ())
     {
       if (arg.is_single_type ())
         return octave_value (FloatMatrix ());
       else
         return octave_value (Matrix ());
     }
 
   if (arg.is_single_type ())
     {
       if (arg.is_real_type ())
         {
           FloatNDArray nda = arg.float_array_value ();
 
-          if (! error_state)
-            {
-              nda.resize (dims, 0.0);
-              retval = (type != 0 ? nda.ifourierNd () : nda.fourierNd ());
-            }
+          nda.resize (dims, 0.0);
+          retval = (type != 0 ? nda.ifourierNd () : nda.fourierNd ());
         }
       else
         {
           FloatComplexNDArray cnda = arg.float_complex_array_value ();
 
-          if (! error_state)
-            {
-              cnda.resize (dims, 0.0);
-              retval = (type != 0 ? cnda.ifourierNd () : cnda.fourierNd ());
-            }
+          cnda.resize (dims, 0.0);
+          retval = (type != 0 ? cnda.ifourierNd () : cnda.fourierNd ());
         }
     }
   else
     {
       if (arg.is_real_type ())
         {
           NDArray nda = arg.array_value ();
 
-          if (! error_state)
-            {
-              nda.resize (dims, 0.0);
-              retval = (type != 0 ? nda.ifourierNd () : nda.fourierNd ());
-            }
+          nda.resize (dims, 0.0);
+          retval = (type != 0 ? nda.ifourierNd () : nda.fourierNd ());
         }
       else if (arg.is_complex_type ())
         {
           ComplexNDArray cnda = arg.complex_array_value ();
 
-          if (! error_state)
-            {
-              cnda.resize (dims, 0.0);
-              retval = (type != 0 ? cnda.ifourierNd () : cnda.fourierNd ());
-            }
+          cnda.resize (dims, 0.0);
+          retval = (type != 0 ? cnda.ifourierNd () : cnda.fourierNd ());
         }
       else
-        {
-          gripe_wrong_type_arg (fcn, arg);
-        }
+        gripe_wrong_type_arg (fcn, arg);
     }
 
   return retval;
 }
 
 DEFUN (fftn, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} fftn (@var{A})\n\
diff --git a/libinterp/corefcn/gcd.cc b/libinterp/corefcn/gcd.cc
--- a/libinterp/corefcn/gcd.cc
+++ b/libinterp/corefcn/gcd.cc
@@ -415,17 +415,17 @@ do_extended_gcd (const octave_value& a, 
       break;
 
     default:
       error ("gcd: invalid class combination for gcd: %s and %s\n",
              a.class_name ().c_str (), b.class_name ().c_str ());
     }
 
   // For consistency.
-  if (! error_state && a.is_sparse_type () && b.is_sparse_type ())
+  if (a.is_sparse_type () && b.is_sparse_type ())
     {
       retval = retval.sparse_matrix_value ();
       x = x.sparse_matrix_value ();
       y = y.sparse_matrix_value ();
     }
 
   if (btyp == btyp_float)
     {
@@ -490,32 +490,24 @@ gcd ([15, 9], [20, 18])\n\
 
           for (int j = 2; j < nargin; j++)
             {
               octave_value x;
               retval(0) = do_extended_gcd (retval(0), args(j),
                                            x, retval(j+1));
               for (int i = 0; i < j; i++)
                 retval(i+1).assign (octave_value::op_el_mul_eq, x);
-
-              if (error_state)
-                break;
             }
         }
       else
         {
           retval(0) = do_simple_gcd (args(0), args(1));
 
           for (int j = 2; j < nargin; j++)
-            {
-              retval(0) = do_simple_gcd (retval(0), args(j));
-
-              if (error_state)
-                break;
-            }
+            retval(0) = do_simple_gcd (retval(0), args(j));
         }
     }
   else
     print_usage ();
 
   return retval;
 }
 
diff --git a/libinterp/corefcn/getgrent.cc b/libinterp/corefcn/getgrent.cc
--- a/libinterp/corefcn/getgrent.cc
+++ b/libinterp/corefcn/getgrent.cc
@@ -107,30 +107,27 @@ If the group ID does not exist in the da
   retval(0) = 0;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
       double dval = args(0).double_value ();
 
-      if (! error_state)
+      if (D_NINT (dval) == dval)
         {
-          if (D_NINT (dval) == dval)
-            {
-              gid_t gid = static_cast<gid_t> (dval);
+          gid_t gid = static_cast<gid_t> (dval);
+
+          std::string msg;
 
-              std::string msg;
-
-              retval(1) = msg;
-              retval(0) = mk_gr_map (octave_group::getgrgid (gid, msg));
-            }
-          else
-            error ("getgrgid: GID must be an integer");
+          retval(1) = msg;
+          retval(0) = mk_gr_map (octave_group::getgrgid (gid, msg));
         }
+      else
+        error ("getgrgid: GID must be an integer");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (getgrnam, args, ,
@@ -149,23 +146,20 @@ If the group name does not exist in the 
   retval(0) = 0;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
       std::string s = args(0).string_value ();
 
-      if (! error_state)
-        {
-          std::string msg;
+      std::string msg;
 
-          retval(1) = msg;
-          retval(0) = mk_gr_map (octave_group::getgrnam (s.c_str (), msg));
-        }
+      retval(1) = msg;
+      retval(0) = mk_gr_map (octave_group::getgrnam (s.c_str (), msg));
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (setgrent, args, ,
diff --git a/libinterp/corefcn/getpwent.cc b/libinterp/corefcn/getpwent.cc
--- a/libinterp/corefcn/getpwent.cc
+++ b/libinterp/corefcn/getpwent.cc
@@ -111,30 +111,27 @@ If the user ID does not exist in the dat
   retval(0) = 0;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
       double dval = args(0).double_value ();
 
-      if (! error_state)
+      if (D_NINT (dval) == dval)
         {
-          if (D_NINT (dval) == dval)
-            {
-              uid_t uid = static_cast<uid_t> (dval);
+          uid_t uid = static_cast<uid_t> (dval);
+
+          std::string msg;
 
-              std::string msg;
-
-              retval(1) = msg;
-              retval(0) = mk_pw_map (octave_passwd::getpwuid (uid, msg));
-            }
-          else
-            error ("getpwuid: UID must be an integer");
+          retval(1) = msg;
+          retval(0) = mk_pw_map (octave_passwd::getpwuid (uid, msg));
         }
+      else
+        error ("getpwuid: UID must be an integer");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (getpwnam, args, ,
@@ -153,23 +150,20 @@ If the user name does not exist in the d
   retval(0) = 0.0;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
       std::string s = args(0).string_value ();
 
-      if (! error_state)
-        {
-          std::string msg;
+      std::string msg;
 
-          retval(1) = msg;
-          retval(0) = mk_pw_map (octave_passwd::getpwnam (s, msg));
-        }
+      retval(1) = msg;
+      retval(0) = mk_pw_map (octave_passwd::getpwnam (s, msg));
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (setpwent, args, ,
diff --git a/libinterp/corefcn/givens.cc b/libinterp/corefcn/givens.cc
--- a/libinterp/corefcn/givens.cc
+++ b/libinterp/corefcn/givens.cc
@@ -87,116 +87,92 @@ givens (1, 1)\n\
     {
       if (args(0).is_single_type () || args(1).is_single_type ())
         {
           if (args(0).is_complex_type () || args(1).is_complex_type ())
             {
               FloatComplex cx = args(0).float_complex_value ();
               FloatComplex cy = args(1).float_complex_value ();
 
-              if (! error_state)
-                {
-                  FloatComplexMatrix result = Givens (cx, cy);
+              FloatComplexMatrix result = Givens (cx, cy);
 
-                  if (! error_state)
-                    {
-                      switch (nargout)
-                        {
-                        case 0:
-                        case 1:
-                          retval(0) = result;
-                          break;
+              switch (nargout)
+                {
+                case 0:
+                case 1:
+                  retval(0) = result;
+                  break;
 
-                        case 2:
-                          retval(1) = result (0, 1);
-                          retval(0) = result (0, 0);
-                          break;
-                        }
-                    }
+                case 2:
+                  retval(1) = result (0, 1);
+                  retval(0) = result (0, 0);
+                  break;
                 }
             }
           else
             {
               float x = args(0).float_value ();
               float y = args(1).float_value ();
 
-              if (! error_state)
-                {
-                  FloatMatrix result = Givens (x, y);
+              FloatMatrix result = Givens (x, y);
 
-                  if (! error_state)
-                    {
-                      switch (nargout)
-                        {
-                        case 0:
-                        case 1:
-                          retval(0) = result;
-                          break;
+              switch (nargout)
+                {
+                case 0:
+                case 1:
+                  retval(0) = result;
+                  break;
 
-                        case 2:
-                          retval(1) = result (0, 1);
-                          retval(0) = result (0, 0);
-                          break;
-                        }
-                    }
+                case 2:
+                  retval(1) = result (0, 1);
+                  retval(0) = result (0, 0);
+                  break;
                 }
             }
         }
       else
         {
           if (args(0).is_complex_type () || args(1).is_complex_type ())
             {
               Complex cx = args(0).complex_value ();
               Complex cy = args(1).complex_value ();
 
-              if (! error_state)
-                {
-                  ComplexMatrix result = Givens (cx, cy);
+              ComplexMatrix result = Givens (cx, cy);
 
-                  if (! error_state)
-                    {
-                      switch (nargout)
-                        {
-                        case 0:
-                        case 1:
-                          retval(0) = result;
-                          break;
+              switch (nargout)
+                {
+                case 0:
+                case 1:
+                  retval(0) = result;
+                  break;
 
-                        case 2:
-                          retval(1) = result (0, 1);
-                          retval(0) = result (0, 0);
-                          break;
-                        }
-                    }
+                case 2:
+                  retval(1) = result (0, 1);
+                  retval(0) = result (0, 0);
+                  break;
                 }
             }
           else
             {
               double x = args(0).double_value ();
               double y = args(1).double_value ();
 
-              if (! error_state)
-                {
-                  Matrix result = Givens (x, y);
+              Matrix result = Givens (x, y);
 
-                  if (! error_state)
-                    {
-                      switch (nargout)
-                        {
-                        case 0:
-                        case 1:
-                          retval(0) = result;
-                          break;
+              switch (nargout)
+                {
+                case 0:
+                case 1:
+                  retval(0) = result;
+                  break;
 
-                        case 2:
-                          retval(1) = result (0, 1);
-                          retval(0) = result (0, 0);
-                          break;
-                        }
-                    }
+                case 2:
+                  retval(1) = result (0, 1);
+                  retval(0) = result (0, 0);
+                  break;
                 }
             }
         }
     }
 
   return retval;
 }
 
diff --git a/libinterp/corefcn/hess.cc b/libinterp/corefcn/hess.cc
--- a/libinterp/corefcn/hess.cc
+++ b/libinterp/corefcn/hess.cc
@@ -93,81 +93,69 @@ IEEE Transactions on Automatic Control, 
     }
 
   if (arg.is_single_type ())
     {
       if (arg.is_real_type ())
         {
           FloatMatrix tmp = arg.float_matrix_value ();
 
-          if (! error_state)
-            {
-              FloatHESS result (tmp);
+          FloatHESS result (tmp);
 
-              if (nargout <= 1)
-                retval(0) = result.hess_matrix ();
-              else
-                {
-                  retval(1) = result.hess_matrix ();
-                  retval(0) = result.unitary_hess_matrix ();
-                }
+          if (nargout <= 1)
+            retval(0) = result.hess_matrix ();
+          else
+            {
+              retval(1) = result.hess_matrix ();
+              retval(0) = result.unitary_hess_matrix ();
             }
         }
       else if (arg.is_complex_type ())
         {
           FloatComplexMatrix ctmp = arg.float_complex_matrix_value ();
 
-          if (! error_state)
-            {
-              FloatComplexHESS result (ctmp);
+          FloatComplexHESS result (ctmp);
 
-              if (nargout <= 1)
-                retval(0) = result.hess_matrix ();
-              else
-                {
-                  retval(1) = result.hess_matrix ();
-                  retval(0) = result.unitary_hess_matrix ();
-                }
+          if (nargout <= 1)
+            retval(0) = result.hess_matrix ();
+          else
+            {
+              retval(1) = result.hess_matrix ();
+              retval(0) = result.unitary_hess_matrix ();
             }
         }
     }
   else
     {
       if (arg.is_real_type ())
         {
           Matrix tmp = arg.matrix_value ();
 
-          if (! error_state)
-            {
-              HESS result (tmp);
+          HESS result (tmp);
 
-              if (nargout <= 1)
-                retval(0) = result.hess_matrix ();
-              else
-                {
-                  retval(1) = result.hess_matrix ();
-                  retval(0) = result.unitary_hess_matrix ();
-                }
+          if (nargout <= 1)
+            retval(0) = result.hess_matrix ();
+          else
+            {
+              retval(1) = result.hess_matrix ();
+              retval(0) = result.unitary_hess_matrix ();
             }
         }
       else if (arg.is_complex_type ())
         {
           ComplexMatrix ctmp = arg.complex_matrix_value ();
 
-          if (! error_state)
-            {
-              ComplexHESS result (ctmp);
+          ComplexHESS result (ctmp);
 
-              if (nargout <= 1)
-                retval(0) = result.hess_matrix ();
-              else
-                {
-                  retval(1) = result.hess_matrix ();
-                  retval(0) = result.unitary_hess_matrix ();
-                }
+          if (nargout <= 1)
+            retval(0) = result.hess_matrix ();
+          else
+            {
+              retval(1) = result.hess_matrix ();
+              retval(0) = result.unitary_hess_matrix ();
             }
         }
       else
         {
           gripe_wrong_type_arg ("hess", arg);
         }
     }
 
diff --git a/libinterp/corefcn/input.cc b/libinterp/corefcn/input.cc
--- a/libinterp/corefcn/input.cc
+++ b/libinterp/corefcn/input.cc
@@ -702,17 +702,17 @@ get_user_input (const octave_value_list&
   octave_diary_stream::reset ();
 
   octave_diary << prompt;
 
   bool eof = false;
 
   std::string input_buf = interactive_input (prompt.c_str (), eof);
 
-  if (! (error_state || input_buf.empty ()))
+  if (! input_buf.empty ())
     {
       size_t len = input_buf.length ();
 
       octave_diary << input_buf;
 
       if (input_buf[len - 1] != '\n')
         octave_diary << "\n";
 
@@ -883,18 +883,17 @@ do_keyboard (const octave_value_list& ar
   // stmt.accept (tpc);
 
   Vdebugging = true;
 
   std::string prompt = "debug> ";
   if (nargin > 0)
     prompt = args(0).string_value ();
 
-  if (! error_state)
-    get_debug_input (prompt);
+  get_debug_input (prompt);
 
   return retval;
 }
 
 DEFUN (keyboard, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} keyboard ()\n\
 @deftypefnx {Built-in Function} {} keyboard (\"@var{prompt}\")\n\
@@ -971,19 +970,16 @@ With no arguments, @code{echo} toggles t
 @end deftypefn")
 {
   octave_value_list retval;
 
   int argc = args.length () + 1;
 
   string_vector argv = args.make_argv ("echo");
 
-  if (error_state)
-    return retval;
-
   switch (argc)
     {
     case 1:
       {
         if ((Vecho_executing_commands & ECHO_SCRIPTS)
             || (Vecho_executing_commands & ECHO_FUNCTIONS))
           Vecho_executing_commands = ECHO_OFF;
         else
@@ -1098,66 +1094,63 @@ a feature, not a bug.\n\
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
       std::string hint = args(0).string_value ();
 
-      if (! error_state)
-        {
-          int n = 32;
+      int n = 32;
 
-          string_vector list (n);
+      string_vector list (n);
+
+      int k = 0;
 
-          int k = 0;
+      for (;;)
+        {
+          std::string cmd = generate_completion (hint, k);
 
-          for (;;)
+          if (! cmd.empty ())
             {
-              std::string cmd = generate_completion (hint, k);
-
-              if (! cmd.empty ())
+              if (k == n)
                 {
-                  if (k == n)
-                    {
-                      n *= 2;
-                      list.resize (n);
-                    }
-
-                  list[k++] = cmd;
+                  n *= 2;
+                  list.resize (n);
                 }
-              else
-                {
-                  list.resize (k);
-                  break;
-                }
-            }
 
-          if (nargout > 0)
-            {
-              if (! list.empty ())
-                retval = list;
-              else
-                retval = "";
+              list[k++] = cmd;
             }
           else
             {
-              // We don't use string_vector::list_in_columns here
-              // because it will be easier for Emacs if the names
-              // appear in a single column.
-
-              int len = list.numel ();
+              list.resize (k);
+              break;
+            }
+        }
 
-              for (int i = 0; i < len; i++)
-                octave_stdout << list[i] << "\n";
-            }
+      if (nargout > 0)
+        {
+          if (! list.empty ())
+            retval = list;
+          else
+            retval = "";
+        }
+      else
+        {
+          // We don't use string_vector::list_in_columns here
+          // because it will be easier for Emacs if the names
+          // appear in a single column.
 
-          octave_completion_matches_called = true;
+          int len = list.numel ();
+
+          for (int i = 0; i < len; i++)
+            octave_stdout << list[i] << "\n";
         }
+
+      octave_completion_matches_called = true;
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
@@ -1193,18 +1186,17 @@ for details.\n\
   int nargin = args.length ();
 
   if (nargin == 0)
     command_editor::read_init_file ();
   else if (nargin == 1)
     {
       std::string file = args(0).string_value ();
 
-      if (! error_state)
-        command_editor::read_init_file (file);
+      command_editor::read_init_file (file);
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (readline_re_read_init_file, args, ,
@@ -1544,16 +1536,16 @@ When called from inside a function with 
 variable is changed locally for the function and any subroutines it calls.\n\
 The original variable value is restored when exiting the function.\n\
 @end deftypefn")
 {
   char tmp = Vfilemarker;
   octave_value retval = SET_INTERNAL_VARIABLE (filemarker);
 
   // The character passed must not be a legal character for a function name
-  if (! error_state && (::isalnum (Vfilemarker) || Vfilemarker == '_'))
+  if (::isalnum (Vfilemarker) || Vfilemarker == '_')
     {
       Vfilemarker = tmp;
       error ("filemarker: character can not be a valid character for a function name");
     }
 
   return retval;
 }
diff --git a/libinterp/corefcn/levenshtein.cc b/libinterp/corefcn/levenshtein.cc
--- a/libinterp/corefcn/levenshtein.cc
+++ b/libinterp/corefcn/levenshtein.cc
@@ -66,44 +66,44 @@ The third argument @var{u_bound} is opti
   Array<char> s2 (args(1).char_array_value ());
   char *s2_p = s2.fortran_vec ();
 
   octave_idx_type
     s1len = s1.numel (),
     s2len = s2.numel (),
     ii, jj;
 
-  if (! error_state)
+  Array<octave_idx_type>
+    dist (dim_vector (s1len + 1, s2len + 1), 0);
+
+  for (ii = 1; ii <= s1len; ii++)
+    dist.xelem (ii, 0) = ii;
+
+  for (jj = 1; jj <= s2len; jj++)
+    dist.xelem (0, jj) = jj;
+
+  for (jj = 1; jj <= s2len; jj++)
     {
-      Array<octave_idx_type>
-        dist (dim_vector (s1len + 1, s2len + 1), 0);
-
       for (ii = 1; ii <= s1len; ii++)
-        dist.xelem (ii, 0) = ii;
+        if (s1_p[ii-1] == s2_p[jj-1])
+          dist.xelem (ii, jj) = dist.xelem (ii-1, jj-1);
+        else
+          dist.xelem (ii, jj) =
+            MIN3(dist.xelem (ii-1, jj) + 1,
+                 dist.xelem (ii, jj-1) + 1,
+                 dist.xelem (ii-1, jj-1) + 1);
 
-      for (jj = 1; jj <= s2len; jj++)
-        dist.xelem (0, jj) = jj;
-
-      for (jj = 1; jj <= s2len; jj++)
+      if (dist(MIN2(jj, s1len), jj) > ub)
         {
-          for (ii = 1; ii <= s1len; ii++)
-            if (s1_p[ii-1] == s2_p[jj-1])
-              dist.xelem (ii, jj) = dist.xelem (ii-1, jj-1);
-            else
-              dist.xelem (ii, jj) =
-                MIN3(dist.xelem (ii-1, jj) + 1,
-                     dist.xelem (ii, jj-1) + 1,
-                     dist.xelem (ii-1, jj-1) + 1);
+          retval(0) = std::numeric_limits<int32_t>::max ();
+          if (nargout == 2)
+            retval(1) = Matrix ();
+          return retval;
+        }
+    }
 
-          if (dist(MIN2(jj, s1len), jj) > ub)
-            {
-              retval(0) = std::numeric_limits<int32_t>::max ();
-              if (nargout == 2)
-                retval(1) = Matrix ();
-              return retval;
-            }
-        }
-      retval(0) = dist.xelem (s1len, s2len);
-      if (nargout == 2)
-        retval(1) = dist;
-    }
+  retval(0) = dist.xelem (s1len, s2len);
+
+  if (nargout == 2)
+    retval(1) = dist;
+
   return retval;
 }
diff --git a/libinterp/corefcn/load-path.cc b/libinterp/corefcn/load-path.cc
--- a/libinterp/corefcn/load-path.cc
+++ b/libinterp/corefcn/load-path.cc
@@ -761,28 +761,25 @@ load_path::do_add (const std::string& di
       file_stat fs (dir);
 
       if (fs)
         {
           if (fs.is_dir ())
             {
               dir_info di (dir);
 
-              if (! error_state)
-                {
-                  if (at_end)
-                    dir_info_list.push_back (di);
-                  else
-                    dir_info_list.push_front (di);
-
-                  add (di, at_end);
-
-                  if (add_hook)
-                    add_hook (dir);
-                }
+              if (at_end)
+                dir_info_list.push_back (di);
+              else
+                dir_info_list.push_front (di);
+
+              add (di, at_end);
+
+              if (add_hook)
+                add_hook (dir);
             }
           else if (warn)
             warning ("addpath: %s: not a directory", dir_arg.c_str ());
         }
       else if (warn)
         {
           std::string msg = fs.error ();
           warning ("addpath: %s: %s", dir_arg.c_str (), msg.c_str ());
@@ -2251,22 +2248,17 @@ directories with those names.\n\
     }
   else if (nargin > 1)
     {
       std::string dirname = args(0).string_value ();
 
       string_vector skip (nargin - 1);
 
       for (octave_idx_type i = 1; i < nargin; i++)
-        {
-          skip[i-1] = args(i).string_value ();
-
-          if (error_state)
-            break;
-        }
+        skip[i-1] = args(i).string_value ();
 
       if (! error_state)
         retval = genpath (dirname, skip);
       else
         error ("genpath: all arguments must be strings");
     }
   else
     print_usage ();
@@ -2357,43 +2349,40 @@ No checks are made for duplicate element
 @end deftypefn")
 {
   octave_value retval;
 
   int argc = args.length () + 1;
 
   string_vector argv = args.make_argv ("path");
 
-  if (! error_state)
+  if (argc > 1)
     {
-      if (argc > 1)
-        {
-          std::string path = argv[1];
-
-          for (int i = 2; i < argc; i++)
-            path += dir_path::path_sep_str () + argv[i];
-
-          load_path::set (path, true);
-
-          rehash_internal ();
-        }
-
-      if (nargout > 0)
-        retval = load_path::path ();
-      else if (argc == 1 && nargout == 0)
-        {
-          octave_stdout <<
-                        "\nOctave's search path contains the following directories:\n\n";
-
-          string_vector dirs = load_path::dirs ();
-
-          dirs.list_in_columns (octave_stdout);
-
-          octave_stdout << "\n";
-        }
+      std::string path = argv[1];
+
+      for (int i = 2; i < argc; i++)
+        path += dir_path::path_sep_str () + argv[i];
+
+      load_path::set (path, true);
+
+      rehash_internal ();
+    }
+
+  if (nargout > 0)
+    retval = load_path::path ();
+  else if (argc == 1 && nargout == 0)
+    {
+      octave_stdout <<
+        "\nOctave's search path contains the following directories:\n\n";
+
+      string_vector dirs = load_path::dirs ();
+
+      dirs.list_in_columns (octave_stdout);
+
+      octave_stdout << "\n";
     }
 
   return retval;
 }
 
 DEFUN (addpath, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} addpath (@var{dir1}, @dots{})\n\
diff --git a/libinterp/corefcn/lookup.cc b/libinterp/corefcn/lookup.cc
--- a/libinterp/corefcn/lookup.cc
+++ b/libinterp/corefcn/lookup.cc
@@ -278,19 +278,16 @@ at most n-1).\n\
 
   if ((match_idx || match_bool) && (left_inf || right_inf))
     error ("lookup: m, b cannot be specified with l or r");
   else if (match_idx && match_bool)
     error ("lookup: only one of m or b can be specified");
   else if (str_case && (left_inf || right_inf))
     error ("lookup: l, r are not recognized for string lookups");
 
-  if (error_state)
-    return retval;
-
   if (num_case)
     {
 
       // In the case of a complex array, absolute values will be used for
       // compatibility (though it's not too meaningful).
 
       if (table.is_complex_type ())
         table = table.abs ();
diff --git a/libinterp/corefcn/ls-mat-ascii.cc b/libinterp/corefcn/ls-mat-ascii.cc
--- a/libinterp/corefcn/ls-mat-ascii.cc
+++ b/libinterp/corefcn/ls-mat-ascii.cc
@@ -114,17 +114,17 @@ get_lines_and_columns (std::istream& is,
 {
   std::streampos pos = is.tellg ();
 
   int file_line_number = 0;
 
   nr = 0;
   nc = 0;
 
-  while (is && ! error_state)
+  while (is)
     {
       octave_quit ();
 
       std::string buf = get_mat_data_input_line (is);
 
       file_line_number++;
 
       size_t beg = buf.find_first_not_of (", \t");
@@ -265,17 +265,17 @@ read_mat_ascii_data (std::istream& is, c
       octave_idx_type nc = 0;
 
       int total_count = 0;
 
       get_lines_and_columns (is, nr, nc, filename);
 
       octave_quit ();
 
-      if (! error_state && nr > 0 && nc > 0)
+      if (nr > 0 && nc > 0)
         {
           Matrix tmp (nr, nc);
 
           if (nr < 1 || nc < 1)
             is.clear (std::ios::badbit);
           else
             {
               double d;
diff --git a/libinterp/corefcn/ls-mat4.cc b/libinterp/corefcn/ls-mat4.cc
--- a/libinterp/corefcn/ls-mat4.cc
+++ b/libinterp/corefcn/ls-mat4.cc
@@ -368,30 +368,30 @@ read_mat_binary_data (std::istream& is, 
           }
       }
     else
       {
         re.resize (nr, nc);
 
         read_mat_binary_data (is, re.fortran_vec (), prec, dlen, swap, flt_fmt);
 
-        if (! is || error_state)
+        if (! is)
           {
             error ("load: reading matrix data for '%s'", name);
             goto data_read_error;
           }
 
         if (imag)
           {
             Matrix im (nr, nc);
 
             read_mat_binary_data (is, im.fortran_vec (), prec, dlen, swap,
                                   flt_fmt);
 
-            if (! is || error_state)
+            if (! is)
               {
                 error ("load: reading imaginary matrix data for '%s'", name);
                 goto data_read_error;
               }
 
             ComplexMatrix ctmp (nr, nc);
 
             for (octave_idx_type j = 0; j < nc; j++)
diff --git a/libinterp/corefcn/lsode.cc b/libinterp/corefcn/lsode.cc
--- a/libinterp/corefcn/lsode.cc
+++ b/libinterp/corefcn/lsode.cc
@@ -362,41 +362,38 @@ parameters for @code{lsode}.\n\
                     }
                   while (0);
                   break;
 
                 case 2:
                   {
                     string_vector tmp = f_arg.all_strings ();
 
-                    if (! error_state)
+                    fcn_name = unique_symbol_name ("__lsode_fcn__");
+                    fname = "function y = ";
+                    fname.append (fcn_name);
+                    fname.append (" (x, t) y = ");
+                    lsode_fcn = extract_function (tmp(0), "lsode", fcn_name,
+                                                  fname, "; endfunction");
+
+                    if (lsode_fcn)
                       {
-                        fcn_name = unique_symbol_name ("__lsode_fcn__");
-                        fname = "function y = ";
-                        fname.append (fcn_name);
-                        fname.append (" (x, t) y = ");
-                        lsode_fcn = extract_function (tmp(0), "lsode", fcn_name,
-                                                      fname, "; endfunction");
+                        jac_name = unique_symbol_name ("__lsode_jac__");
+                        jname = "function jac = ";
+                        jname.append (jac_name);
+                        jname.append (" (x, t) jac = ");
+                        lsode_jac = extract_function (tmp(1), "lsode",
+                                                      jac_name, jname,
+                                                      "; endfunction");
 
-                        if (lsode_fcn)
+                        if (!lsode_jac)
                           {
-                            jac_name = unique_symbol_name ("__lsode_jac__");
-                            jname = "function jac = ";
-                            jname.append (jac_name);
-                            jname.append (" (x, t) jac = ");
-                            lsode_jac = extract_function (tmp(1), "lsode",
-                                                          jac_name, jname,
-                                                          "; endfunction");
-
-                            if (!lsode_jac)
-                              {
-                                if (fcn_name.length ())
-                                  clear_function (fcn_name);
-                                lsode_fcn = 0;
-                              }
+                            if (fcn_name.length ())
+                              clear_function (fcn_name);
+                            lsode_fcn = 0;
                           }
                       }
                   }
                   break;
 
                 default:
                   LSODE_ABORT1
                   ("first arg should be a string or 2-element string array");
@@ -446,32 +443,29 @@ parameters for @code{lsode}.\n\
       else
         output = ode.integrate (out_times);
 
       if (fcn_name.length ())
         clear_function (fcn_name);
       if (jac_name.length ())
         clear_function (jac_name);
 
-      if (! error_state)
-        {
-          std::string msg = ode.error_message ();
+      std::string msg = ode.error_message ();
 
-          retval(2) = msg;
-          retval(1) = static_cast<double> (ode.integration_state ());
+      retval(2) = msg;
+      retval(1) = static_cast<double> (ode.integration_state ());
 
-          if (ode.integration_ok ())
-            retval(0) = output;
-          else
-            {
-              retval(0) = Matrix ();
+      if (ode.integration_ok ())
+        retval(0) = output;
+      else
+        {
+          retval(0) = Matrix ();
 
-              if (nargout < 2)
-                error ("lsode: %s", msg.c_str ());
-            }
+          if (nargout < 2)
+            error ("lsode: %s", msg.c_str ());
         }
     }
   else
     print_usage ();
 
   return retval;
 }
 
diff --git a/libinterp/corefcn/lu.cc b/libinterp/corefcn/lu.cc
--- a/libinterp/corefcn/lu.cc
+++ b/libinterp/corefcn/lu.cc
@@ -153,46 +153,43 @@ information.\n\
       print_usage ();
       return retval;
     }
 
   bool vecout = false;
   Matrix thres;
 
   int n = 1;
-  while (n < nargin && ! error_state)
+  while (n < nargin)
     {
       if (args(n).is_string ())
         {
           std::string tmp = args(n++).string_value ();
 
           if (tmp.compare ("vector") == 0)
             vecout = true;
           else
             error ("lu: unrecognized string argument");
         }
       else
         {
           Matrix tmp = args(n++).matrix_value ();
 
-          if (! error_state)
+          if (!issparse)
+            error ("lu: can not define pivoting threshold THRES for full matrices");
+          else if (tmp.numel () == 1)
             {
-              if (!issparse)
-                error ("lu: can not define pivoting threshold THRES for full matrices");
-              else if (tmp.numel () == 1)
-                {
-                  thres.resize (1,2);
-                  thres(0) = tmp(0);
-                  thres(1) = tmp(0);
-                }
-              else if (tmp.numel () == 2)
-                thres = tmp;
-              else
-                error ("lu: expecting 2-element vector for THRES");
+              thres.resize (1,2);
+              thres(0) = tmp(0);
+              thres(1) = tmp(0);
             }
+          else if (tmp.numel () == 2)
+            thres = tmp;
+          else
+            error ("lu: expecting 2-element vector for THRES");
         }
     }
 
   octave_value arg = args(0);
 
   octave_idx_type nr = arg.rows ();
   octave_idx_type nc = arg.columns ();
 
@@ -355,165 +352,153 @@ information.\n\
         return octave_value_list (3, Matrix ());
 
       if (arg.is_real_type ())
         {
           if (arg.is_single_type ())
             {
               FloatMatrix m = arg.float_matrix_value ();
 
-              if (! error_state)
-                {
-                  FloatLU fact (m);
+              FloatLU fact (m);
 
-                  switch (nargout)
-                    {
-                    case 0:
-                    case 1:
-                      retval(0) = fact.Y ();
-                      break;
+              switch (nargout)
+                {
+                case 0:
+                case 1:
+                  retval(0) = fact.Y ();
+                  break;
 
-                    case 2:
-                      {
-                        PermMatrix P = fact.P ();
-                        FloatMatrix L = P.transpose () * fact.L ();
-                        retval(1) = get_lu_u (fact);
-                        retval(0) = L;
-                      }
-                      break;
+                case 2:
+                  {
+                    PermMatrix P = fact.P ();
+                    FloatMatrix L = P.transpose () * fact.L ();
+                    retval(1) = get_lu_u (fact);
+                    retval(0) = L;
+                  }
+                  break;
 
-                    case 3:
-                    default:
-                      {
-                        if (vecout)
-                          retval(2) = fact.P_vec ();
-                        else
-                          retval(2) = fact.P ();
-                        retval(1) = get_lu_u (fact);
-                        retval(0) = get_lu_l (fact);
-                      }
-                      break;
-                    }
+                case 3:
+                default:
+                  {
+                    if (vecout)
+                      retval(2) = fact.P_vec ();
+                    else
+                      retval(2) = fact.P ();
+                    retval(1) = get_lu_u (fact);
+                    retval(0) = get_lu_l (fact);
+                  }
+                  break;
                 }
             }
           else
             {
               Matrix m = arg.matrix_value ();
 
-              if (! error_state)
-                {
-                  LU fact (m);
+              LU fact (m);
 
-                  switch (nargout)
-                    {
-                    case 0:
-                    case 1:
-                      retval(0) = fact.Y ();
-                      break;
+              switch (nargout)
+                {
+                case 0:
+                case 1:
+                  retval(0) = fact.Y ();
+                  break;
 
-                    case 2:
-                      {
-                        PermMatrix P = fact.P ();
-                        Matrix L = P.transpose () * fact.L ();
-                        retval(1) = get_lu_u (fact);
-                        retval(0) = L;
-                      }
-                      break;
+                case 2:
+                  {
+                    PermMatrix P = fact.P ();
+                    Matrix L = P.transpose () * fact.L ();
+                    retval(1) = get_lu_u (fact);
+                    retval(0) = L;
+                  }
+                  break;
 
-                    case 3:
-                    default:
-                      {
-                        if (vecout)
-                          retval(2) = fact.P_vec ();
-                        else
-                          retval(2) = fact.P ();
-                        retval(1) = get_lu_u (fact);
-                        retval(0) = get_lu_l (fact);
-                      }
-                      break;
-                    }
+                case 3:
+                default:
+                  {
+                    if (vecout)
+                      retval(2) = fact.P_vec ();
+                    else
+                      retval(2) = fact.P ();
+                    retval(1) = get_lu_u (fact);
+                    retval(0) = get_lu_l (fact);
+                  }
+                  break;
                 }
             }
         }
       else if (arg.is_complex_type ())
         {
           if (arg.is_single_type ())
             {
               FloatComplexMatrix m = arg.float_complex_matrix_value ();
 
-              if (! error_state)
-                {
-                  FloatComplexLU fact (m);
+              FloatComplexLU fact (m);
 
-                  switch (nargout)
-                    {
-                    case 0:
-                    case 1:
-                      retval(0) = fact.Y ();
-                      break;
+              switch (nargout)
+                {
+                case 0:
+                case 1:
+                  retval(0) = fact.Y ();
+                  break;
 
-                    case 2:
-                      {
-                        PermMatrix P = fact.P ();
-                        FloatComplexMatrix L = P.transpose () * fact.L ();
-                        retval(1) = get_lu_u (fact);
-                        retval(0) = L;
-                      }
-                      break;
+                case 2:
+                  {
+                    PermMatrix P = fact.P ();
+                    FloatComplexMatrix L = P.transpose () * fact.L ();
+                    retval(1) = get_lu_u (fact);
+                    retval(0) = L;
+                  }
+                  break;
 
-                    case 3:
-                    default:
-                      {
-                        if (vecout)
-                          retval(2) = fact.P_vec ();
-                        else
-                          retval(2) = fact.P ();
-                        retval(1) = get_lu_u (fact);
-                        retval(0) = get_lu_l (fact);
-                      }
-                      break;
-                    }
+                case 3:
+                default:
+                  {
+                    if (vecout)
+                      retval(2) = fact.P_vec ();
+                    else
+                      retval(2) = fact.P ();
+                    retval(1) = get_lu_u (fact);
+                    retval(0) = get_lu_l (fact);
+                  }
+                  break;
                 }
             }
           else
             {
               ComplexMatrix m = arg.complex_matrix_value ();
 
-              if (! error_state)
-                {
-                  ComplexLU fact (m);
+              ComplexLU fact (m);
 
-                  switch (nargout)
-                    {
-                    case 0:
-                    case 1:
-                      retval(0) = fact.Y ();
-                      break;
+              switch (nargout)
+                {
+                case 0:
+                case 1:
+                  retval(0) = fact.Y ();
+                  break;
 
-                    case 2:
-                      {
-                        PermMatrix P = fact.P ();
-                        ComplexMatrix L = P.transpose () * fact.L ();
-                        retval(1) = get_lu_u (fact);
-                        retval(0) = L;
-                      }
-                      break;
+                case 2:
+                  {
+                    PermMatrix P = fact.P ();
+                    ComplexMatrix L = P.transpose () * fact.L ();
+                    retval(1) = get_lu_u (fact);
+                    retval(0) = L;
+                  }
+                  break;
 
-                    case 3:
-                    default:
-                      {
-                        if (vecout)
-                          retval(2) = fact.P_vec ();
-                        else
-                          retval(2) = fact.P ();
-                        retval(1) = get_lu_u (fact);
-                        retval(0) = get_lu_l (fact);
-                      }
-                      break;
-                    }
+                case 3:
+                default:
+                  {
+                    if (vecout)
+                      retval(2) = fact.P_vec ();
+                    else
+                      retval(2) = fact.P ();
+                    retval(1) = get_lu_u (fact);
+                    retval(0) = get_lu_l (fact);
+                  }
+                  break;
                 }
             }
         }
       else
         gripe_wrong_type_arg ("lu", arg);
     }
 
   return retval;
diff --git a/libinterp/corefcn/max.cc b/libinterp/corefcn/max.cc
--- a/libinterp/corefcn/max.cc
+++ b/libinterp/corefcn/max.cc
@@ -44,19 +44,16 @@ along with Octave; see the file COPYING.
 template <class ArrayType>
 static octave_value_list
 do_minmax_red_op (const octave_value& arg,
                   int nargout, int dim, bool ismin)
 {
   octave_value_list retval;
   ArrayType array = octave_value_extract<ArrayType> (arg);
 
-  if (error_state)
-    return retval;
-
   if (nargout == 2)
     {
       retval.resize (2);
       Array<octave_idx_type> idx;
       if (ismin)
         retval(0) = array.min (idx, dim);
       else
         retval(0) = array.max (idx, dim);
@@ -85,19 +82,16 @@ do_minmax_red_op (const octave_value& ar
 template <>
 octave_value_list
 do_minmax_red_op<charNDArray> (const octave_value& arg,
                                int nargout, int dim, bool ismin)
 {
   octave_value_list retval;
   charNDArray array = octave_value_extract<charNDArray> (arg);
 
-  if (error_state)
-    return retval;
-
   if (nargout == 2)
     {
       retval.resize (2);
       Array<octave_idx_type> idx;
       if (ismin)
         retval(0) = NDArray (array.min (idx, dim));
       else
         retval(0) = NDArray (array.max (idx, dim));
@@ -134,18 +128,18 @@ do_minmax_red_op<boolNDArray> (const oct
         retval(0) = array.all (dim);
       else
         retval(0) = array.any (dim);
     }
   else
     {
       // any/all don't have indexed versions, so do it via a conversion.
       retval = do_minmax_red_op<int8NDArray> (arg, nargout, dim, ismin);
-      if (! error_state)
-        retval(0) = retval(0).bool_array_value ();
+
+      retval(0) = retval(0).bool_array_value ();
     }
 
   return retval;
 }
 
 template <class ArrayType>
 static octave_value
 do_minmax_bin_op (const octave_value& argx, const octave_value& argy,
@@ -155,43 +149,37 @@ do_minmax_bin_op (const octave_value& ar
 
   octave_value retval;
 
   if (argx.is_scalar_type ())
     {
       ScalarType x = octave_value_extract<ScalarType> (argx);
       ArrayType y = octave_value_extract<ArrayType> (argy);
 
-      if (error_state)
-        ;
-      else if (ismin)
+      if (ismin)
         retval = min (x, y);
       else
         retval = max (x, y);
     }
   else if (argy.is_scalar_type ())
     {
       ArrayType x = octave_value_extract<ArrayType> (argx);
       ScalarType y = octave_value_extract<ScalarType> (argy);
 
-      if (error_state)
-        ;
-      else if (ismin)
+      if (ismin)
         retval = min (x, y);
       else
         retval = max (x, y);
     }
   else
     {
       ArrayType x = octave_value_extract<ArrayType> (argx);
       ArrayType y = octave_value_extract<ArrayType> (argy);
 
-      if (error_state)
-        ;
-      else if (ismin)
+      if (ismin)
         retval = min (x, y);
       else
         retval = max (x, y);
     }
 
   return retval;
 }
 
@@ -208,19 +196,17 @@ octave_value
 do_minmax_bin_op<charNDArray> (const octave_value& argx,
                                const octave_value& argy, bool ismin)
 {
   octave_value retval;
 
   charNDArray x = octave_value_extract<charNDArray> (argx);
   charNDArray y = octave_value_extract<charNDArray> (argy);
 
-  if (error_state)
-    ;
-  else if (ismin)
+  if (ismin)
     {
       if (x.numel () == 1)
         retval = NDArray (min (x(0), y));
       else if (y.numel () == 1)
         retval = NDArray (min (x, y(0)));
       else
         retval = NDArray (min (x, y));
     }
@@ -871,19 +857,16 @@ the first index of the maximum value(s).
 template <class ArrayType>
 static octave_value_list
 do_cumminmax_red_op (const octave_value& arg,
                      int nargout, int dim, bool ismin)
 {
   octave_value_list retval;
   ArrayType array = octave_value_extract<ArrayType> (arg);
 
-  if (error_state)
-    return retval;
-
   if (nargout == 2)
     {
       retval.resize (2);
       Array<octave_idx_type> idx;
       if (ismin)
         retval(0) = array.cummin (idx, dim);
       else
         retval(0) = array.cummax (idx, dim);
diff --git a/libinterp/corefcn/md5sum.cc b/libinterp/corefcn/md5sum.cc
--- a/libinterp/corefcn/md5sum.cc
+++ b/libinterp/corefcn/md5sum.cc
@@ -54,28 +54,25 @@ sum of the string @var{str}.\n\
   else
     {
       bool have_str = false;
       std::string str = args(0).string_value ();
 
       if (nargin == 2)
         have_str = args(1).bool_value ();
 
-      if (!error_state)
+      if (have_str)
+        retval = oct_md5 (str);
+      else
         {
-          if (have_str)
-            retval = oct_md5 (str);
-          else
-            {
-              std::string fname = file_ops::tilde_expand (str);
+          std::string fname = file_ops::tilde_expand (str);
 
-              fname = find_data_file_in_load_path ("md5sum", fname);
+          fname = find_data_file_in_load_path ("md5sum", fname);
 
-              retval = oct_md5_file (fname);
-            }
+          retval = oct_md5_file (fname);
         }
     }
 
   return retval;
 }
 
 /*
 %!assert (md5sum ("abc\0", true), "147a664a2ca9410911e61986d3f0d52a");
diff --git a/libinterp/corefcn/mex.cc b/libinterp/corefcn/mex.cc
--- a/libinterp/corefcn/mex.cc
+++ b/libinterp/corefcn/mex.cc
@@ -3055,30 +3055,27 @@ call_mex (bool have_fmex, void *f, const
           fcn (nargout, argout, nargin, argin);
         }
     }
 
   // Convert returned array entries back into octave values.
 
   octave_value_list retval;
 
-  if (! error_state)
+  if (nargout == 0 && argout[0])
     {
-      if (nargout == 0 && argout[0])
-        {
-          // We have something for ans.
-          nargout = 1;
-        }
-
-      retval.resize (nargout);
-
-      for (int i = 0; i < nargout; i++)
-        retval(i) = mxArray::as_octave_value (argout[i]);
+      // We have something for ans.
+      nargout = 1;
     }
 
+  retval.resize (nargout);
+
+  for (int i = 0; i < nargout; i++)
+    retval(i) = mxArray::as_octave_value (argout[i]);
+
   // Clean up mex resources.
   frame.run ();
 
   return retval;
 }
 
 // C interface to mex functions:
 
@@ -3282,19 +3279,16 @@ mexGetVariable (const char *space, const
         {
           // MEX files don't create a separate frame in the call stack,
           // so we are already in the "caller" frame.
 
           if (base)
             {
               octave_call_stack::goto_base_frame ();
 
-              if (error_state)
-                return retval;
-
               frame.add_fcn (octave_call_stack::pop);
             }
 
           val = symbol_table::varval (name);
         }
       else
         mexErrMsgTxt ("mexGetVariable: symbol table does not exist");
     }
@@ -3345,19 +3339,16 @@ mexPutVariable (const char *space, const
         {
           // MEX files don't create a separate frame in the call stack,
           // so we are already in the "caller" frame.
 
           if (base)
             {
               octave_call_stack::goto_base_frame ();
 
-              if (error_state)
-                return 1;
-
               frame.add_fcn (octave_call_stack::pop);
             }
 
           symbol_table::assign (name, mxArray::as_octave_value (ptr));
         }
       else
         mexErrMsgTxt ("mexPutVariable: symbol table does not exist");
     }
@@ -3391,20 +3382,22 @@ mexAtExit (void (*f) (void))
 
   return 0;
 }
 
 const mxArray *
 mexGet (double handle, const char *property)
 {
   mxArray *m = 0;
+
   octave_value ret = get_property_from_handle (handle, property, "mexGet");
 
-  if (!error_state && ret.is_defined ())
+  if (ret.is_defined ())
     m = ret.as_mxArray ();
+
   return m;
 }
 
 int
 mexIsGlobal (const mxArray *ptr)
 {
   return mxIsFromGlobalWS (ptr);
 }
diff --git a/libinterp/corefcn/pager.cc b/libinterp/corefcn/pager.cc
--- a/libinterp/corefcn/pager.cc
+++ b/libinterp/corefcn/pager.cc
@@ -540,19 +540,16 @@ With no arguments, @code{diary} toggles 
 @end deftypefn")
 {
   octave_value_list retval;
 
   int argc = args.length () + 1;
 
   string_vector argv = args.make_argv ("diary");
 
-  if (error_state)
-    return retval;
-
   if (diary_file.empty ())
     diary_file = "diary";
 
   switch (argc)
     {
     case 1:
       write_to_diary_file = ! write_to_diary_file;
       open_diary_file ();
@@ -621,19 +618,16 @@ The current state can be determined via 
 @end deftypefn")
 {
   octave_value_list retval;
 
   int argc = args.length () + 1;
 
   string_vector argv = args.make_argv ("more");
 
-  if (error_state)
-    return retval;
-
   if (argc == 2)
     {
       std::string arg = argv[1];
 
       if (arg == "on")
         Vpage_screen_output = true;
       else if (arg == "off")
         Vpage_screen_output = false;
diff --git a/libinterp/corefcn/pinv.cc b/libinterp/corefcn/pinv.cc
--- a/libinterp/corefcn/pinv.cc
+++ b/libinterp/corefcn/pinv.cc
@@ -78,19 +78,16 @@ where @code{sigma_max (@var{x})} is the 
   if (arg.is_diag_matrix ())
     {
       if (isfloat)
         {
           float tol = 0.0;
           if (nargin == 2)
             tol = args(1).float_value ();
 
-          if (error_state)
-            return retval;
-
           if (tol < 0.0)
             {
               error ("pinv: TOL must be greater than zero");
               return retval;
             }
 
           if (arg.is_real_type ())
             retval = arg.float_diag_matrix_value ().pseudo_inverse (tol);
@@ -98,19 +95,16 @@ where @code{sigma_max (@var{x})} is the 
             retval = arg.float_complex_diag_matrix_value ().pseudo_inverse (tol);
         }
       else
         {
           double tol = 0.0;
           if (nargin == 2)
             tol = args(1).double_value ();
 
-          if (error_state)
-            return retval;
-
           if (tol < 0.0)
             {
               error ("pinv: TOL must be greater than zero");
               return retval;
             }
 
           if (arg.is_real_type ())
             retval = arg.diag_matrix_value ().pseudo_inverse (tol);
@@ -123,77 +117,63 @@ where @code{sigma_max (@var{x})} is the 
       retval = arg.perm_matrix_value ().inverse ();
     }
   else if (isfloat)
     {
       float tol = 0.0;
       if (nargin == 2)
         tol = args(1).float_value ();
 
-      if (error_state)
-        return retval;
-
       if (tol < 0.0)
         {
           error ("pinv: TOL must be greater than zero");
           return retval;
         }
 
       if (arg.is_real_type ())
         {
           FloatMatrix m = arg.float_matrix_value ();
 
-          if (! error_state)
-            retval = m.pseudo_inverse (tol);
+          retval = m.pseudo_inverse (tol);
         }
       else if (arg.is_complex_type ())
         {
           FloatComplexMatrix m = arg.float_complex_matrix_value ();
 
-          if (! error_state)
-            retval = m.pseudo_inverse (tol);
+          retval = m.pseudo_inverse (tol);
         }
       else
-        {
-          gripe_wrong_type_arg ("pinv", arg);
-        }
+        gripe_wrong_type_arg ("pinv", arg);
     }
   else
     {
       double tol = 0.0;
       if (nargin == 2)
         tol = args(1).double_value ();
 
-      if (error_state)
-        return retval;
-
       if (tol < 0.0)
         {
           error ("pinv: TOL must be greater than zero");
           return retval;
         }
 
       if (arg.is_real_type ())
         {
           Matrix m = arg.matrix_value ();
 
-          if (! error_state)
-            retval = m.pseudo_inverse (tol);
+          retval = m.pseudo_inverse (tol);
         }
       else if (arg.is_complex_type ())
         {
           ComplexMatrix m = arg.complex_matrix_value ();
 
-          if (! error_state)
-            retval = m.pseudo_inverse (tol);
+          retval = m.pseudo_inverse (tol);
         }
       else
-        {
-          gripe_wrong_type_arg ("pinv", arg);
-        }
+        gripe_wrong_type_arg ("pinv", arg);
     }
 
   return retval;
 }
 
 /*
 %!shared a, b, tol, hitol, d, u, x, y
 %! a = reshape (rand*[1:16], 4, 4);  # Rank 2 matrix
diff --git a/libinterp/corefcn/pr-output.cc b/libinterp/corefcn/pr-output.cc
--- a/libinterp/corefcn/pr-output.cc
+++ b/libinterp/corefcn/pr-output.cc
@@ -3437,56 +3437,53 @@ If the length of the smallest possible r
 
       frame.protect_var (rat_string_len);
 
       rat_string_len = 9;
 
       if (nargin == 2)
         rat_string_len = args(1).nint_value ();
 
-      if (! error_state)
+      octave_value arg = args(0);
+
+      if (arg.is_numeric_type ())
         {
-          octave_value arg = args(0);
-
-          if (arg.is_numeric_type ())
+          frame.protect_var (rat_format);
+
+          rat_format = true;
+
+          std::ostringstream buf;
+          arg.print (buf);
+          std::string s = buf.str ();
+
+          std::list<std::string> lst;
+
+          size_t n = 0;
+          size_t s_len = s.length ();
+
+          while (n < s_len)
             {
-              frame.protect_var (rat_format);
-
-              rat_format = true;
-
-              std::ostringstream buf;
-              arg.print (buf);
-              std::string s = buf.str ();
-
-              std::list<std::string> lst;
-
-              size_t n = 0;
-              size_t s_len = s.length ();
-
-              while (n < s_len)
+              size_t m = s.find ('\n',  n);
+
+              if (m == std::string::npos)
+                {
+                  lst.push_back (s.substr (n));
+                  break;
+                }
+              else
                 {
-                  size_t m = s.find ('\n',  n);
-
-                  if (m == std::string::npos)
-                    {
-                      lst.push_back (s.substr (n));
-                      break;
-                    }
-                  else
-                    {
-                      lst.push_back (s.substr (n, m - n));
-                      n = m + 1;
-                    }
+                  lst.push_back (s.substr (n, m - n));
+                  n = m + 1;
                 }
-
-              retval = string_vector (lst);
             }
-          else
-            error ("rats: X must be numeric");
+
+          retval = string_vector (lst);
         }
+      else
+        error ("rats: X must be numeric");
     }
 
   return retval;
 }
 
 DEFUN (disp, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} disp (@var{x})\n\
@@ -3560,27 +3557,24 @@ Note that the output from @code{fdisp} a
   int nargin = args.length ();
 
   if (nargin == 2)
     {
       int fid = octave_stream_list::get_file_number (args(0));
 
       octave_stream os = octave_stream_list::lookup (fid, "fdisp");
 
-      if (! error_state)
-        {
-          std::ostream *osp = os.output_stream ();
-
-          octave_value arg = args(1);
-
-          if (osp)
-            arg.print (*osp);
-          else
-            error ("fdisp: stream FID not open for writing");
-        }
+      std::ostream *osp = os.output_stream ();
+
+      octave_value arg = args(1);
+
+      if (osp)
+        arg.print (*osp);
+      else
+        error ("fdisp: stream FID not open for writing");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
@@ -4064,19 +4058,16 @@ to produce a more readable output with l
 @end deftypefn")
 {
   octave_value_list retval;
 
   int argc = args.length () + 1;
 
   string_vector argv = args.make_argv ("format");
 
-  if (error_state)
-    return retval;
-
   set_format_style (argc, argv);
 
   return retval;
 }
 
 DEFUN (__compactformat__, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} __compactformat__ ()\n\
diff --git a/libinterp/corefcn/qz.cc b/libinterp/corefcn/qz.cc
--- a/libinterp/corefcn/qz.cc
+++ b/libinterp/corefcn/qz.cc
@@ -490,19 +490,16 @@ compatibility with @sc{matlab}.\n\
   Matrix aa;
   ComplexMatrix caa;
 
   if (args(0).is_complex_type ())
     caa = args(0).complex_matrix_value ();
   else
     aa = args(0).matrix_value ();
 
-  if (error_state)
-    return retval;
-
 #ifdef DEBUG
   std::cout << "qz: check argument 2" << std::endl;
 #endif
 
   // Extract argument 2 (bb, or cbb if complex).
   if ((nn != args(1).columns ()) || (nn != args(1).rows ()))
     {
       gripe_nonconformant ();
@@ -512,19 +509,16 @@ compatibility with @sc{matlab}.\n\
   Matrix bb;
   ComplexMatrix cbb;
 
   if (args(1).is_complex_type ())
     cbb = args(1).complex_matrix_value ();
   else
     bb = args(1).matrix_value ();
 
-  if (error_state)
-    return retval;
-
   // Both matrices loaded, now let's check what kind of arithmetic:
   // declared volatile to avoid compiler warnings about long jumps,
   // vforks.
 
   volatile int complex_case
     = (args(0).is_complex_type () || args(1).is_complex_type ());
 
   if (nargin == 3 && complex_case)
diff --git a/libinterp/corefcn/schur.cc b/libinterp/corefcn/schur.cc
--- a/libinterp/corefcn/schur.cc
+++ b/libinterp/corefcn/schur.cc
@@ -189,91 +189,77 @@ in control (see @code{are} and @code{dar
   if (! arg.is_numeric_type ())
     gripe_wrong_type_arg ("schur", arg);
   else if (arg.is_single_type ())
     {
       if (! force_complex && arg.is_real_type ())
         {
           FloatMatrix tmp = arg.float_matrix_value ();
 
-          if (! error_state)
+          if (nargout == 0 || nargout == 1)
             {
-              if (nargout == 0 || nargout == 1)
-                {
-                  FloatSCHUR result (tmp, ord, false);
-                  retval(0) = result.schur_matrix ();
-                }
-              else
-                {
-                  FloatSCHUR result (tmp, ord, true);
-                  retval(1) = result.schur_matrix ();
-                  retval(0) = result.unitary_matrix ();
-                }
+              FloatSCHUR result (tmp, ord, false);
+              retval(0) = result.schur_matrix ();
+            }
+          else
+            {
+              FloatSCHUR result (tmp, ord, true);
+              retval(1) = result.schur_matrix ();
+              retval(0) = result.unitary_matrix ();
             }
         }
       else
         {
           FloatComplexMatrix ctmp = arg.float_complex_matrix_value ();
 
-          if (! error_state)
+          if (nargout == 0 || nargout == 1)
             {
-
-              if (nargout == 0 || nargout == 1)
-                {
-                  FloatComplexSCHUR result (ctmp, ord, false);
-                  retval(0) = mark_upper_triangular (result.schur_matrix ());
-                }
-              else
-                {
-                  FloatComplexSCHUR result (ctmp, ord, true);
-                  retval(1) = mark_upper_triangular (result.schur_matrix ());
-                  retval(0) = result.unitary_matrix ();
-                }
+              FloatComplexSCHUR result (ctmp, ord, false);
+              retval(0) = mark_upper_triangular (result.schur_matrix ());
+            }
+          else
+            {
+              FloatComplexSCHUR result (ctmp, ord, true);
+              retval(1) = mark_upper_triangular (result.schur_matrix ());
+              retval(0) = result.unitary_matrix ();
             }
         }
     }
   else
     {
       if (! force_complex && arg.is_real_type ())
         {
           Matrix tmp = arg.matrix_value ();
 
-          if (! error_state)
+          if (nargout == 0 || nargout == 1)
             {
-              if (nargout == 0 || nargout == 1)
-                {
-                  SCHUR result (tmp, ord, false);
-                  retval(0) = result.schur_matrix ();
-                }
-              else
-                {
-                  SCHUR result (tmp, ord, true);
-                  retval(1) = result.schur_matrix ();
-                  retval(0) = result.unitary_matrix ();
-                }
+              SCHUR result (tmp, ord, false);
+              retval(0) = result.schur_matrix ();
+            }
+          else
+            {
+              SCHUR result (tmp, ord, true);
+              retval(1) = result.schur_matrix ();
+              retval(0) = result.unitary_matrix ();
             }
         }
       else
         {
           ComplexMatrix ctmp = arg.complex_matrix_value ();
 
-          if (! error_state)
+          if (nargout == 0 || nargout == 1)
             {
-
-              if (nargout == 0 || nargout == 1)
-                {
-                  ComplexSCHUR result (ctmp, ord, false);
-                  retval(0) = mark_upper_triangular (result.schur_matrix ());
-                }
-              else
-                {
-                  ComplexSCHUR result (ctmp, ord, true);
-                  retval(1) = mark_upper_triangular (result.schur_matrix ());
-                  retval(0) = result.unitary_matrix ();
-                }
+              ComplexSCHUR result (ctmp, ord, false);
+              retval(0) = mark_upper_triangular (result.schur_matrix ());
+            }
+          else
+            {
+              ComplexSCHUR result (ctmp, ord, true);
+              retval(1) = mark_upper_triangular (result.schur_matrix ());
+              retval(0) = result.unitary_matrix ();
             }
         }
     }
 
   return retval;
 }
 
 /*
@@ -329,35 +315,31 @@ Note also that @var{U} and @var{T} are n
         error ("rsf2csf: UR and TR must be real matrices");
       else
         {
 
           if (args(0).is_single_type () || args(1).is_single_type ())
             {
               FloatMatrix u = args(0).float_matrix_value ();
               FloatMatrix t = args(1).float_matrix_value ();
-              if (! error_state)
-                {
-                  FloatComplexSCHUR cs (FloatSCHUR (t, u));
+
+              FloatComplexSCHUR cs (FloatSCHUR (t, u));
 
-                  retval(1) = cs.schur_matrix ();
-                  retval(0) = cs.unitary_matrix ();
-                }
+              retval(1) = cs.schur_matrix ();
+              retval(0) = cs.unitary_matrix ();
             }
           else
             {
               Matrix u = args(0).matrix_value ();
               Matrix t = args(1).matrix_value ();
-              if (! error_state)
-                {
-                  ComplexSCHUR cs (SCHUR (t, u));
+
+              ComplexSCHUR cs (SCHUR (t, u));
 
-                  retval(1) = cs.schur_matrix ();
-                  retval(0) = cs.unitary_matrix ();
-                }
+              retval(1) = cs.schur_matrix ();
+              retval(0) = cs.unitary_matrix ();
             }
         }
     }
   else
     print_usage ();
 
   return retval;
 }
diff --git a/libinterp/corefcn/sparse.cc b/libinterp/corefcn/sparse.cc
--- a/libinterp/corefcn/sparse.cc
+++ b/libinterp/corefcn/sparse.cc
@@ -147,23 +147,20 @@ Compressed Column Sparse (rows = 3, cols
     }
   else if (nargin == 2)
     {
       octave_idx_type m = 0;
       octave_idx_type n = 0;
 
       get_dimensions (args(0), args(1), "sparse", m, n);
 
-      if (! error_state)
-        {
-          if (m >= 0 && n >= 0)
-            retval = SparseMatrix (m, n);
-          else
-            error ("sparse: dimensions must be non-negative");
-        }
+      if (m >= 0 && n >= 0)
+        retval = SparseMatrix (m, n);
+      else
+        error ("sparse: dimensions must be non-negative");
     }
   else if (nargin >= 3)
     {
       bool summation = true;
       if (nargin > 3 && args(nargin-1).is_string ())
         {
           std::string opt = args(nargin-1).string_value ();
           if (opt == "unique")
@@ -171,65 +168,58 @@ Compressed Column Sparse (rows = 3, cols
           else if (opt == "sum" || opt == "summation")
             summation = true;
           else
             error ("sparse: invalid option: %s", opt.c_str ());
 
           nargin -= 1;
         }
 
-      if (! error_state)
+      octave_idx_type m, n, nzmax;
+      m = n = nzmax = -1;
+      if (nargin == 6)
         {
-          octave_idx_type m, n, nzmax;
-          m = n = nzmax = -1;
-          if (nargin == 6)
-            {
-              nzmax = args(5).idx_type_value ();
-              nargin --;
-            }
+          nzmax = args(5).idx_type_value ();
+          nargin --;
+        }
 
-          if (nargin == 5)
-            {
-              get_dimensions (args(3), args(4), "sparse", m, n);
+      if (nargin == 5)
+        {
+          get_dimensions (args(3), args(4), "sparse", m, n);
 
-              if (! error_state && (m < 0 || n < 0))
-                error ("sparse: dimensions must be non-negative");
-            }
-          else if (nargin != 3)
-            print_usage ();
+          if (! error_state && (m < 0 || n < 0))
+            error ("sparse: dimensions must be non-negative");
+        }
+      else if (nargin != 3)
+        print_usage ();
 
-          if (! error_state)
-            {
-              int k = 0;    // index we're checking when index_vector throws
-              try
-                {
-                  idx_vector i = args(0).index_vector ();
-                  k = 1;
-                  idx_vector j = args(1).index_vector ();
+      int k = 0;    // index we're checking when index_vector throws
+      try
+        {
+          idx_vector i = args(0).index_vector ();
+          k = 1;
+          idx_vector j = args(1).index_vector ();
 
-                  if (args(2).is_bool_type ())
-                    retval = SparseBoolMatrix (args(2).bool_array_value (), i,j,
-                                               m, n, summation, nzmax);
-                  else if (args(2).is_complex_type ())
-                    retval = SparseComplexMatrix (args(2).complex_array_value(),
-                                                  i, j, m, n, summation, nzmax);
-                  else if (args(2).is_numeric_type ())
-                    retval = SparseMatrix (args(2).array_value (), i, j,
-                                           m, n, summation, nzmax);
-                  else
-                    gripe_wrong_type_arg ("sparse", args(2));
-                }
-              catch (index_exception& e)
-                {
-                  // Rethrow to allow more info to be reported later.
-                  e.set_pos_if_unset (2, k+1);
-                  throw;
-                }
-            }
-
+          if (args(2).is_bool_type ())
+            retval = SparseBoolMatrix (args(2).bool_array_value (), i,j,
+                                       m, n, summation, nzmax);
+          else if (args(2).is_complex_type ())
+            retval = SparseComplexMatrix (args(2).complex_array_value(),
+                                          i, j, m, n, summation, nzmax);
+          else if (args(2).is_numeric_type ())
+            retval = SparseMatrix (args(2).array_value (), i, j,
+                                   m, n, summation, nzmax);
+          else
+            gripe_wrong_type_arg ("sparse", args(2));
+        }
+      catch (index_exception& e)
+        {
+          // Rethrow to allow more info to be reported later.
+          e.set_pos_if_unset (2, k+1);
+          throw;
         }
     }
 
   return retval;
 }
 
 DEFUN (spalloc, args, ,
        "-*- texinfo -*-\n\
@@ -272,21 +262,21 @@ the function @code{nzmax}.\n\
   octave_value retval;
   int nargin = args.length ();
 
   if (nargin == 2 || nargin == 3)
     {
       octave_idx_type m = args(0).idx_type_value ();
       octave_idx_type n = args(1).idx_type_value ();
       octave_idx_type nz = 0;
+
       if (nargin == 3)
         nz = args(2).idx_type_value ();
-      if (error_state)
-        ;
-      else if (m >= 0 && n >= 0 && nz >= 0)
+
+      if (m >= 0 && n >= 0 && nz >= 0)
         retval = SparseMatrix (dim_vector (m, n), nz);
       else
         error ("spalloc: M,N,NZ must be non-negative");
     }
   else
     print_usage ();
 
   return retval;
diff --git a/libinterp/corefcn/sqrtm.cc b/libinterp/corefcn/sqrtm.cc
--- a/libinterp/corefcn/sqrtm.cc
+++ b/libinterp/corefcn/sqrtm.cc
@@ -243,17 +243,17 @@ Mathematics, Manchester, England, Januar
     // sqrtm of a diagonal matrix is just sqrt.
     retval(0) = arg.sqrt ();
   else if (arg.is_single_type ())
     retval(0) = do_sqrtm<FloatMatrix, FloatComplexMatrix, FloatComplexSCHUR>
                  (arg);
   else if (arg.is_numeric_type ())
     retval(0) = do_sqrtm<Matrix, ComplexMatrix, ComplexSCHUR> (arg);
 
-  if (nargout > 1 && ! error_state)
+  if (nargout > 1)
     {
       // This corresponds to generic code
       //
       //   norm (s*s - x, "fro") / norm (x, "fro");
 
       octave_value s = retval(0);
       retval(1) = xfrobnorm (s*s - arg) / xfrobnorm (arg);
     }
diff --git a/libinterp/corefcn/str2double.cc b/libinterp/corefcn/str2double.cc
--- a/libinterp/corefcn/str2double.cc
+++ b/libinterp/corefcn/str2double.cc
@@ -353,34 +353,31 @@ risk of using @code{eval} on unknown dat
         }
       else if (args(0).rows () == 1 && args(0).ndims () == 2)
         {
           retval = str2double1 (args(0).string_value ());
         }
       else
         {
           const string_vector sv = args(0).all_strings ();
-          if (! error_state)
-            retval = sv.map<Complex> (str2double1);
+
+          retval = sv.map<Complex> (str2double1);
         }
     }
   else if (args(0).is_cell ())
     {
       const Cell cell = args(0).cell_value ();
 
-      if (! error_state)
+      ComplexNDArray output (cell.dims (), octave_NaN);
+      for (octave_idx_type i = 0; i < cell.numel (); i++)
         {
-          ComplexNDArray output (cell.dims (), octave_NaN);
-          for (octave_idx_type i = 0; i < cell.numel (); i++)
-            {
-              if (cell(i).is_string ())
-                output(i) = str2double1 (cell(i).string_value ());
-            }
-          retval = output;
+          if (cell(i).is_string ())
+            output(i) = str2double1 (cell(i).string_value ());
         }
+      retval = output;
     }
   else
     retval = Matrix (1, 1, octave_NaN);
 
 
   return retval;
 }
 
diff --git a/libinterp/corefcn/strfns.cc b/libinterp/corefcn/strfns.cc
--- a/libinterp/corefcn/strfns.cc
+++ b/libinterp/corefcn/strfns.cc
@@ -690,26 +690,23 @@ This is just the opposite of the corresp
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 3)
     {
       octave_idx_type n = args(2).idx_type_value ();
 
-      if (! error_state)
+      if (n > 0)
         {
-          if (n > 0)
-            {
-              retval = do_strcmp_fun (args(0), args(1), n, "strncmp",
-                                      strncmp_array_op, strncmp_str_op);
-            }
-          else
-            error ("strncmp: N must be greater than 0");
+          retval = do_strcmp_fun (args(0), args(1), n, "strncmp",
+                                  strncmp_array_op, strncmp_str_op);
         }
+      else
+        error ("strncmp: N must be greater than 0");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
@@ -833,26 +830,23 @@ This is just the opposite of the corresp
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 3)
     {
       octave_idx_type n = args(2).idx_type_value ();
 
-      if (! error_state)
+      if (n > 0)
         {
-          if (n > 0)
-            {
-              retval = do_strcmp_fun (args(0), args(1), n, "strncmpi",
-                                      strncmpi_array_op, strncmpi_str_op);
-            }
-          else
-            error ("strncmpi: N must be greater than 0");
+          retval = do_strcmp_fun (args(0), args(1), n, "strncmpi",
+                                  strncmpi_array_op, strncmpi_str_op);
         }
+      else
+        error ("strncmpi: N must be greater than 0");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
diff --git a/libinterp/corefcn/sub2ind.cc b/libinterp/corefcn/sub2ind.cc
--- a/libinterp/corefcn/sub2ind.cc
+++ b/libinterp/corefcn/sub2ind.cc
@@ -87,52 +87,41 @@ linear_index = sub2ind ([3, 3], 2, 3)\n\
 
   if (nargin < 2)
     print_usage ();
   else
     {
       dim_vector dv = get_dim_vector (args(0), "sub2ind");
       Array<idx_vector> idxa (dim_vector (nargin-1, 1));
 
-      if (! error_state)
+      dv = dv.redim (nargin - 1);
+      for (int j = 0; j < nargin - 1; j++)
         {
-          dv = dv.redim (nargin - 1);
-          for (int j = 0; j < nargin - 1; j++)
+          if (args(j+1).is_numeric_type ())
             {
-              if (args(j+1).is_numeric_type ())
+              try
                 {
-                  try
-                    {
-                      idxa(j) = args(j+1).index_vector ();
-                      if (error_state)
-                        break;
-                      else if (j > 0 && args(j+1).dims () != args(1).dims ())
-                        error ("sub2ind: all subscripts must be of the same size");
-                    }
-                  catch (index_exception& e)
-                    {
-                      e.set_pos_if_unset (nargin-1, j+1);
-                      e.set_var ("");     // no particular variable
-                      (*current_liboctave_error_with_id_handler)
-                                                        (e.id(), e.err());
-                    }
+                  idxa(j) = args(j+1).index_vector ();
+
+                  if (j > 0 && args(j+1).dims () != args(1).dims ())
+                    error ("sub2ind: all subscripts must be of the same size");
                 }
-              else
-                error ("sub2ind: subscripts must be numeric");
-
-              if (error_state)
-                break;
+              catch (index_exception& e)
+                {
+                  e.set_pos_if_unset (nargin-1, j+1);
+                  e.set_var ("");     // no particular variable
+                  (*current_liboctave_error_with_id_handler)
+                    (e.id(), e.err());
+                }
             }
+          else
+            error ("sub2ind: subscripts must be numeric");
         }
 
-      if (! error_state)
-        {
-          idx_vector idx = sub2ind (dv, idxa);
-          retval = idx;
-        }
+      retval = sub2ind (dv, idxa);
     }
 
   return retval;
 }
 
 /*
 ## Test evaluation
 %!test
@@ -200,27 +189,25 @@ moving from one column to next, filling 
   int nargin = args.length ();
   octave_value_list retval;
 
   if (nargin != 2)
     print_usage ();
   else
     {
       dim_vector dv = get_dim_vector (args(0), "ind2sub");
+
       try
         {
           idx_vector idx = args(1).index_vector ();
-          if (! error_state)
-            {
-              if (nargout > dv.length ())
-                dv = dv.redim (nargout);
 
-              Array<idx_vector> idxa = ind2sub (dv, idx);
-              retval = Array<octave_value> (idxa);
-            }
+          if (nargout > dv.length ())
+            dv = dv.redim (nargout);
+          
+          retval = Array<octave_value> (ind2sub (dv, idx));
         }
       catch (index_exception& e)
         {
           error ("ind2sub: Invalid index %s. %s", e.idx (), e.explain ());
         }
     }
 
   return retval;
diff --git a/libinterp/corefcn/sysdep.cc b/libinterp/corefcn/sysdep.cc
--- a/libinterp/corefcn/sysdep.cc
+++ b/libinterp/corefcn/sysdep.cc
@@ -615,18 +615,17 @@ returns a string containing the value of
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
       std::string name = args(0).string_value ();
 
-      if (! error_state)
-        retval = octave_env::getenv (name);
+      retval = octave_env::getenv (name);
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
@@ -695,21 +694,17 @@ occurred.\n\
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
       std::string tmp = args(0).string_value ();
 
-      if (! error_state)
-        {
-          int status = gnulib::unsetenv (tmp.c_str ());
-          retval = status;
-        }
+      retval = gnulib::unsetenv (tmp.c_str ());
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
@@ -800,33 +795,30 @@ clc;\n\
       print_usage ();
       return retval;
     }
 
   if (nargin == 1)
     {
       double dval = args(0).double_value ();
 
-      if (! error_state)
+      if (! xisnan (dval))
         {
-          if (! xisnan (dval))
-            {
-              Fdrawnow ();
+          Fdrawnow ();
 
-              if (xisinf (dval))
-                {
-                  flush_octave_stdout ();
-                  octave_kbhit ();
-                }
-              else
-                octave_sleep (dval);
+          if (xisinf (dval))
+            {
+              flush_octave_stdout ();
+              octave_kbhit ();
             }
           else
-            warning ("pause: NaN is an invalid delay");
+            octave_sleep (dval);
         }
+      else
+        warning ("pause: NaN is an invalid delay");
     }
   else
     {
       Fdrawnow ();
       flush_octave_stdout ();
       octave_kbhit ();
     }
 
@@ -848,25 +840,22 @@ Suspend the execution of the program for
 @end deftypefn")
 {
   octave_value_list retval;
 
   if (args.length () == 1)
     {
       double dval = args(0).double_value ();
 
-      if (! error_state)
+      if (xisnan (dval))
+        warning ("sleep: NaN is an invalid delay");
+      else
         {
-          if (xisnan (dval))
-            warning ("sleep: NaN is an invalid delay");
-          else
-            {
-              Fdrawnow ();
-              octave_sleep (dval);
-            }
+          Fdrawnow ();
+          octave_sleep (dval);
         }
     }
   else
     print_usage ();
 
   return retval;
 }
 
@@ -891,29 +880,26 @@ one second, @code{usleep} will pause the
 @end deftypefn")
 {
   octave_value_list retval;
 
   if (args.length () == 1)
     {
       double dval = args(0).double_value ();
 
-      if (! error_state)
+      if (xisnan (dval))
+        warning ("usleep: NaN is an invalid delay");
+      else
         {
-          if (xisnan (dval))
-            warning ("usleep: NaN is an invalid delay");
-          else
-            {
-              Fdrawnow ();
+          Fdrawnow ();
 
-              int delay = NINT (dval);
+          int delay = NINT (dval);
 
-              if (delay > 0)
-                octave_usleep (delay);
-            }
+          if (delay > 0)
+            octave_usleep (delay);
         }
     }
   else
     print_usage ();
 
   return retval;
 }
 
diff --git a/libinterp/corefcn/time.cc b/libinterp/corefcn/time.cc
--- a/libinterp/corefcn/time.cc
+++ b/libinterp/corefcn/time.cc
@@ -161,18 +161,17 @@ gmtime (time ())\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1)
     {
       double tmp = args(0).double_value ();
 
-      if (! error_state)
-        retval = octave_value (mk_tm_map (octave_gmtime (tmp)));
+      retval = octave_value (mk_tm_map (octave_gmtime (tmp)));
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
@@ -223,18 +222,17 @@ localtime (time ())\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1)
     {
       double tmp = args(0).double_value ();
 
-      if (! error_state)
-        retval = octave_value (mk_tm_map (octave_localtime (tmp)));
+      retval = octave_value (mk_tm_map (octave_localtime (tmp)));
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
diff --git a/libinterp/corefcn/toplev.cc b/libinterp/corefcn/toplev.cc
--- a/libinterp/corefcn/toplev.cc
+++ b/libinterp/corefcn/toplev.cc
@@ -1244,27 +1244,24 @@ from the list, so if a function was plac
           if (nargin == 2)
             {
               add_mode = args(1).bool_value ();
 
               if (error_state)
                 error ("atexit: FLAG argument must be a logical value");
             }
 
-          if (! error_state)
+          if (add_mode)
+            octave_add_atexit_function (arg);
+          else
             {
-              if (add_mode)
-                octave_add_atexit_function (arg);
-              else
-                {
-                  bool found = octave_remove_atexit_function (arg);
+              bool found = octave_remove_atexit_function (arg);
 
-                  if (nargout > 0)
-                    retval(0) = found;
-                }
+              if (nargout > 0)
+                retval(0) = found;
             }
         }
       else
         error ("atexit: FCN argument must be a string");
     }
   else
     print_usage ();
 
@@ -1545,30 +1542,27 @@ specified option.\n\
     }
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
       std::string arg = args(0).string_value ();
 
-      if (! error_state)
+      if (m.isfield (arg))
         {
-          if (m.isfield (arg))
-            {
-              Cell c = m.contents (arg);
+          Cell c = m.contents (arg);
 
-              if (c.is_empty ())
-                error ("octave_config_info: no info for '%s'", arg.c_str ());
-              else
-                retval = c(0);
-            }
+          if (c.is_empty ())
+            error ("octave_config_info: no info for '%s'", arg.c_str ());
           else
-            error ("octave_config_info: invalid parameter '%s'", arg.c_str ());
+            retval = c(0);
         }
+      else
+        error ("octave_config_info: invalid parameter '%s'", arg.c_str ());
     }
   else if (nargin == 0)
     retval = m;
   else
     print_usage ();
 
   return retval;
 }
diff --git a/libinterp/corefcn/tril.cc b/libinterp/corefcn/tril.cc
--- a/libinterp/corefcn/tril.cc
+++ b/libinterp/corefcn/tril.cc
@@ -197,22 +197,17 @@ do_trilu (const std::string& name,
   bool pack = false;
   if (nargin >= 2 && args(nargin-1).is_string ())
     {
       pack = args(nargin-1).string_value () == "pack";
       nargin--;
     }
 
   if (nargin == 2)
-    {
-      k = args(1).int_value (true);
-
-      if (error_state)
-        return retval;
-    }
+    k = args(1).int_value (true);
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
   else
     {
       octave_value arg = args(0);
 
       dim_vector dims = arg.dims ();
@@ -307,37 +302,31 @@ do_trilu (const std::string& name,
                       {
                         octave_idx_type nr_limit = 1 > j - k ? 1 : j - k;
                         ov_idx(1) = static_cast<double> (j);
                         ov_idx(0) = Range (nr_limit, nr);
                         std::list<octave_value_list> idx;
                         idx.push_back (ov_idx);
 
                         tmp = tmp.subsasgn ("(", idx, arg.do_index_op (ov_idx));
-
-                        if (error_state)
-                          return retval;
                       }
                   }
                 else
                   {
                     octave_idx_type st = k + 1 > 1 ? k + 1 : 1;
 
                     for (octave_idx_type j = st; j <= nc; j++)
                       {
                         octave_idx_type nr_limit = nr < j - k ? nr : j - k;
                         ov_idx(1) = static_cast<double> (j);
                         ov_idx(0) = Range (1, nr_limit);
                         std::list<octave_value_list> idx;
                         idx.push_back (ov_idx);
 
                         tmp = tmp.subsasgn ("(", idx, arg.do_index_op (ov_idx));
-
-                        if (error_state)
-                          return retval;
                       }
                   }
 
                 retval = tmp;
               }
             }
         }
     }
diff --git a/libinterp/corefcn/tsearch.cc b/libinterp/corefcn/tsearch.cc
--- a/libinterp/corefcn/tsearch.cc
+++ b/libinterp/corefcn/tsearch.cc
@@ -81,19 +81,16 @@ convex hull, @var{idx} is NaN.\n\
     }
 
   const ColumnVector x (args(0).vector_value ());
   const ColumnVector y (args(1).vector_value ());
   const Matrix elem (args(2).matrix_value ());
   const ColumnVector xi (args(3).vector_value ());
   const ColumnVector yi (args(4).vector_value ());
 
-  if (error_state)
-    return retval;
-
   const octave_idx_type nelem = elem.rows ();
 
   ColumnVector minx (nelem);
   ColumnVector maxx (nelem);
   ColumnVector miny (nelem);
   ColumnVector maxy (nelem);
   for (octave_idx_type k = 0; k < nelem; k++)
     {
diff --git a/libinterp/corefcn/typecast.cc b/libinterp/corefcn/typecast.cc
--- a/libinterp/corefcn/typecast.cc
+++ b/libinterp/corefcn/typecast.cc
@@ -207,17 +207,17 @@ typecast (@var{x}, \"uint8\")\n\
             get_data_and_bytesize (array.array_value (), data, byte_size,
                                    old_dims, frame); }
       else
         error ("typecast: invalid input class: %s",
                                                 array.class_name ().c_str ());
 
       std::string numclass = args(1).string_value ();
 
-      if (error_state || numclass.size () == 0)
+      if (numclass.size () == 0)
         ;
       else if (numclass == "char")
         retval = octave_value (reinterpret_copy<charNDArray>
                    (data, byte_size, old_dims), array.is_dq_string () ? '"'
                                                                       : '\'');
       else if (numclass[0] == 'i')
         {
           if (numclass == "int8")
@@ -248,17 +248,17 @@ typecast (@var{x}, \"uint8\")\n\
       else if (numclass == "double")
         retval = reinterpret_copy<NDArray> (data, byte_size, old_dims);
       else if (numclass == "single complex")
         retval = reinterpret_copy<FloatComplexNDArray> (data, byte_size,
                                                         old_dims);
       else if (numclass == "double complex")
         retval = reinterpret_copy<ComplexNDArray> (data, byte_size, old_dims);
 
-      if (! error_state && retval.is_undefined ())
+      if (retval.is_undefined ())
         error ("typecast: cannot convert to %s class", numclass.c_str ());
     }
   else
     print_usage ();
 
   return retval;
 }
 
@@ -342,17 +342,17 @@ column vector.\n\
   else if (! args(0).is_bool_type ())
     error ("bitpack: X must be a logical array");
   else
     {
       boolNDArray bitp = args(0).bool_array_value ();
 
       std::string numclass = args(1).string_value ();
 
-      if (error_state || numclass.size () == 0)
+      if (numclass.size () == 0)
         ;
       else if (numclass == "char")
         retval = octave_value (do_bitpack<charNDArray> (bitp), '\'');
       else if (numclass[0] == 'i')
         {
           if (numclass == "int8")
             retval = do_bitpack<int8NDArray> (bitp);
           else if (numclass == "int16")
@@ -377,17 +377,17 @@ column vector.\n\
         retval = do_bitpack<FloatNDArray> (bitp);
       else if (numclass == "double")
         retval = do_bitpack<NDArray> (bitp);
       else if (numclass == "single complex")
         retval = do_bitpack<FloatComplexNDArray> (bitp);
       else if (numclass == "double complex")
         retval = do_bitpack<ComplexNDArray> (bitp);
 
-      if (! error_state && retval.is_undefined ())
+      if (retval.is_undefined ())
         error ("bitpack: cannot pack to %s class", numclass.c_str ());
     }
 
   return retval;
 }
 
 template <class ArrayType>
 boolNDArray
diff --git a/libinterp/dldfcn/__init_gnuplot__.cc b/libinterp/dldfcn/__init_gnuplot__.cc
--- a/libinterp/dldfcn/__init_gnuplot__.cc
+++ b/libinterp/dldfcn/__init_gnuplot__.cc
@@ -146,30 +146,27 @@ private:
 
   void send_quit (const octave_value& pstream) const
   {
     if (! pstream.is_empty ())
       {
         octave_value_list args;
         Matrix fids = pstream.matrix_value ();
 
-        if (! error_state)
-          {
-            Ffputs (ovl (fids(0), "\nquit;\n"));
+        Ffputs (ovl (fids(0), "\nquit;\n"));
 
-            Ffflush (ovl (fids(0)));
-            Fpclose (ovl (fids(0)));
+        Ffflush (ovl (fids(0)));
+        Fpclose (ovl (fids(0)));
 
-            if (fids.numel () > 1)
-              {
-                Fpclose (ovl (fids(1)));
+        if (fids.numel () > 1)
+          {
+            Fpclose (ovl (fids(1)));
 
-                if (fids.numel () > 2)
-                  Fwaitpid (ovl (fids(2)));
-              }
+            if (fids.numel () > 2)
+              Fwaitpid (ovl (fids(2)));
           }
       }
   }
 };
 
 static bool
 have_gnuplot_binary (void)
 {
diff --git a/libinterp/dldfcn/__magick_read__.cc b/libinterp/dldfcn/__magick_read__.cc
--- a/libinterp/dldfcn/__magick_read__.cc
+++ b/libinterp/dldfcn/__magick_read__.cc
@@ -752,18 +752,16 @@ Use @code{imread} instead.\n\
   if (error_state)
     {
       error ("__magick_read__: OPTIONS must be a struct");
       return output;
     }
 
   std::vector<Magick::Image> imvec;
   read_file (args(0).string_value (), imvec);
-  if (error_state)
-    return output;
 
   // Prepare an Array with the indexes for the requested frames.
   const octave_idx_type nFrames = imvec.size ();
   Array<octave_idx_type> frameidx;
   const octave_value indexes = options.getfield ("index");
   if (indexes.is_string () && indexes.string_value () == "all")
     {
       frameidx.resize (dim_vector (1, nFrames));
@@ -1509,18 +1507,17 @@ Use @code{imwrite} instead.\n\
 
   // If writemode is set to append, read the image and append to it. Even
   // if set to append, make sure that something was read at all.
   const std::string writemode = options.getfield ("writemode").string_value ();
   if (writemode == "append" && file_stat (filename).exists ())
     {
       std::vector<Magick::Image> ini_imvec;
       read_file (filename, ini_imvec);
-      if (error_state)
-        return retval;
+
       if (ini_imvec.size () > 0)
         {
           ini_imvec.insert (ini_imvec.end (), imvec.begin (), imvec.end ());
           ini_imvec.swap (imvec);
         }
     }
 
   // FIXME: LoopCount or animationIterations
@@ -1562,18 +1559,16 @@ Use @code{imwrite} instead.\n\
   else COMPRESS_MAGICK_IMAGE_VECTOR("jpeg", Magick::JPEGCompression)
   else COMPRESS_MAGICK_IMAGE_VECTOR("lzw", Magick::LZWCompression)
   else COMPRESS_MAGICK_IMAGE_VECTOR("rle", Magick::RLECompression)
   else COMPRESS_MAGICK_IMAGE_VECTOR("deflate", Magick::ZipCompression)
 
 #undef COMPRESS_MAGICK_IMAGE_VECTOR
 
   write_file (filename, ext, imvec);
-  if (error_state)
-    return retval;
 
 #endif
   return retval;
 }
 
 /*
 ## No test needed for internal helper function.
 %!assert (1)
@@ -1826,18 +1821,17 @@ Use @code{imfinfo} instead.\n\
     {
       print_usage ();
       return retval;
     }
   const std::string filename = args(0).string_value ();
 
   std::vector<Magick::Image> imvec;
   read_file (filename, imvec);
-  if (error_state)
-    return retval;
+
   const octave_idx_type nFrames = imvec.size ();
   const std::string format = imvec[0].magick ();
 
   // Here's how this function works. We need to return a struct array, one
   // struct for each image in the file (remember, there are image
   // that allow for multiple images in the same file). Now, Matlab seems
   // to have format specific code so the fields on the struct are different
   // for each format. It only has a small subset that is common to all
diff --git a/libinterp/dldfcn/__osmesa_print__.cc b/libinterp/dldfcn/__osmesa_print__.cc
--- a/libinterp/dldfcn/__osmesa_print__.cc
+++ b/libinterp/dldfcn/__osmesa_print__.cc
@@ -177,51 +177,48 @@ instead.\n\
     {
       // use gl2ps
 #ifndef HAVE_GL2PS_H
       gripe_disabled_feature ("__osmesa_print__", "gl2ps");
 #else
       std::string file = args(1).string_value ();
       std::string term = args(2).string_value ();
 
-      if (! error_state)
-        {
-          size_t pos_p = file.find_first_of ("|");
-          size_t pos_c = file.find_first_not_of ("| ");
+      size_t pos_p = file.find_first_of ("|");
+      size_t pos_c = file.find_first_not_of ("| ");
 
-          if (pos_p == std::string::npos && pos_c == std::string::npos)
-            error ("__osmesa_print__: empty output ''");
-          else if (pos_c == std::string::npos)
-            error ("__osmesa_print__: empty pipe '|'");
-          else if (pos_p != std::string::npos && pos_p < pos_c)
+      if (pos_p == std::string::npos && pos_c == std::string::npos)
+        error ("__osmesa_print__: empty output ''");
+      else if (pos_c == std::string::npos)
+        error ("__osmesa_print__: empty pipe '|'");
+      else if (pos_p != std::string::npos && pos_p < pos_c)
+        {
+          // create process and pipe gl2ps output to it
+          std::string cmd = file.substr (pos_c);
+          gl2ps_print (fobj, cmd, term);
+        }
+      else
+        {
+          // write gl2ps output directly to file
+          FILE *filep = gnulib::fopen (file.substr (pos_c).c_str (), "w");
+
+          if (filep)
             {
-              // create process and pipe gl2ps output to it
-              std::string cmd = file.substr (pos_c);
-              gl2ps_print (fobj, cmd, term);
+              unwind_protect frame;
+
+              frame.add_fcn (close_fcn, filep);
+
+              glps_renderer rend (filep, term);
+              rend.draw (fobj, "");
+
+              // Make sure buffered commands are finished!!!
+              glFinish ();
             }
           else
-            {
-              // write gl2ps output directly to file
-              FILE *filep = gnulib::fopen (file.substr (pos_c).c_str (), "w");
-
-              if (filep)
-                {
-                  unwind_protect frame;
-
-                  frame.add_fcn (close_fcn, filep);
-
-                  glps_renderer rend (filep, term);
-                  rend.draw (fobj, "");
-
-                  // Make sure buffered commands are finished!!!
-                  glFinish ();
-                }
-              else
-                error ("__osmesa_print__: Couldn't create file \"%s\"", file.c_str ());
-            }
+            error ("__osmesa_print__: Couldn't create file \"%s\"", file.c_str ());
         }
 #endif
     }
   else
     {
       // return RGB image
       opengl_renderer rend;
       rend.draw (fobj);
diff --git a/libinterp/dldfcn/amd.cc b/libinterp/dldfcn/amd.cc
--- a/libinterp/dldfcn/amd.cc
+++ b/libinterp/dldfcn/amd.cc
@@ -128,77 +128,76 @@ The author of the code itself is Timothy
           n_col = sm.cols ();
           ridx = sm.xridx ();
           cidx = sm.xcidx ();
         }
 
       if (!error_state && n_row != n_col)
         error ("amd: matrix S must be square");
 
-      if (!error_state)
+      OCTAVE_LOCAL_BUFFER (double, Control, AMD_CONTROL);
+      AMD_NAME (_defaults) (Control) ;
+      if (nargin > 1)
         {
-          OCTAVE_LOCAL_BUFFER (double, Control, AMD_CONTROL);
-          AMD_NAME (_defaults) (Control) ;
-          if (nargin > 1)
-            {
-              octave_scalar_map arg1 = args(1).scalar_map_value ();
-
-              if (!error_state)
-                {
-                  octave_value tmp;
-
-                  tmp = arg1.getfield ("dense");
-                  if (tmp.is_defined ())
-                    Control[AMD_DENSE] = tmp.double_value ();
-
-                  tmp = arg1.getfield ("aggressive");
-                  if (tmp.is_defined ())
-                    Control[AMD_AGGRESSIVE] = tmp.double_value ();
-                }
-              else
-                error ("amd: OPTS argument must be a scalar structure");
-            }
+          octave_scalar_map arg1 = args(1).scalar_map_value ();
 
           if (!error_state)
             {
-              OCTAVE_LOCAL_BUFFER (octave_idx_type, P, n_col);
-              Matrix xinfo (AMD_INFO, 1);
-              double *Info = xinfo.fortran_vec ();
+              octave_value tmp;
+
+              tmp = arg1.getfield ("dense");
+              if (tmp.is_defined ())
+                Control[AMD_DENSE] = tmp.double_value ();
 
-              // FIXME: how can we manage the memory allocation of amd
-              //        in a cleaner manner?
-              SUITESPARSE_ASSIGN_FPTR (malloc_func, amd_malloc, malloc);
-              SUITESPARSE_ASSIGN_FPTR (free_func, amd_free, free);
-              SUITESPARSE_ASSIGN_FPTR (calloc_func, amd_calloc, calloc);
-              SUITESPARSE_ASSIGN_FPTR (realloc_func, amd_realloc, realloc);
-              SUITESPARSE_ASSIGN_FPTR (printf_func, amd_printf, printf);
+              tmp = arg1.getfield ("aggressive");
+              if (tmp.is_defined ())
+                Control[AMD_AGGRESSIVE] = tmp.double_value ();
+            }
+          else
+            error ("amd: OPTS argument must be a scalar structure");
+        }
 
-              octave_idx_type result = AMD_NAME (_order) (n_col, cidx, ridx, P,
-                                                          Control, Info);
+      if (!error_state)
+        {
+          OCTAVE_LOCAL_BUFFER (octave_idx_type, P, n_col);
+          Matrix xinfo (AMD_INFO, 1);
+          double *Info = xinfo.fortran_vec ();
 
-              switch (result)
-                {
-                case AMD_OUT_OF_MEMORY:
-                  error ("amd: out of memory");
-                  break;
-                case AMD_INVALID:
-                  error ("amd: matrix S is corrupted");
-                  break;
-                default:
-                  {
-                    if (nargout > 1)
-                      retval(1) = xinfo;
+          // FIXME: how can we manage the memory allocation of amd
+          //        in a cleaner manner?
+          SUITESPARSE_ASSIGN_FPTR (malloc_func, amd_malloc, malloc);
+          SUITESPARSE_ASSIGN_FPTR (free_func, amd_free, free);
+          SUITESPARSE_ASSIGN_FPTR (calloc_func, amd_calloc, calloc);
+          SUITESPARSE_ASSIGN_FPTR (realloc_func, amd_realloc, realloc);
+          SUITESPARSE_ASSIGN_FPTR (printf_func, amd_printf, printf);
+
+          octave_idx_type result = AMD_NAME (_order) (n_col, cidx, ridx, P,
+                                                      Control, Info);
 
-                    Matrix Pout (1, n_col);
-                    for (octave_idx_type i = 0; i < n_col; i++)
-                      Pout.xelem (i) = P[i] + 1;
+          switch (result)
+            {
+            case AMD_OUT_OF_MEMORY:
+              error ("amd: out of memory");
+              break;
+
+            case AMD_INVALID:
+              error ("amd: matrix S is corrupted");
+              break;
 
-                    retval(0) = Pout;
-                  }
-                }
+            default:
+              {
+                if (nargout > 1)
+                  retval(1) = xinfo;
+
+                Matrix Pout (1, n_col);
+                for (octave_idx_type i = 0; i < n_col; i++)
+                  Pout.xelem (i) = P[i] + 1;
+
+                retval(0) = Pout;
+              }
             }
         }
     }
 #else
 
   error ("amd: not available in this version of Octave");
 
 #endif
diff --git a/libinterp/dldfcn/audiodevinfo.cc b/libinterp/dldfcn/audiodevinfo.cc
--- a/libinterp/dldfcn/audiodevinfo.cc
+++ b/libinterp/dldfcn/audiodevinfo.cc
@@ -565,27 +565,27 @@ octave_play_callback (const void *, void
     {
       error ("audio player callback function called without player");
       return paAbort;
     }
 
   octave_value_list retval = feval (player->octave_callback_function,
                                     ovl (static_cast<double> (frames)), 1);
 
-  if (error_state || retval.length () < 2)
+  if (retval.length () < 2)
     {
       error ("audio player callback function failed");
       return paAbort;
     }
 
   const Matrix sound = retval(0).matrix_value ();
   int return_status = retval(1).int_value ();
 
-  if (error_state || (frames - sound.rows () != 0)
-      || sound.columns () < 1 || sound.columns () > 2)
+  if (frames - sound.rows () != 0 || sound.columns () < 1
+      || sound.columns () > 2)
     {
       error ("audio player callback function failed");
       return paAbort;
     }
 
   // Don't multiply the audio data by scale_factor here.  Although it
   // does move the operation outside of the loops below, it also causes
   // a second copy of the data array to be made.
diff --git a/libinterp/dldfcn/dmperm.cc b/libinterp/dldfcn/dmperm.cc
--- a/libinterp/dldfcn/dmperm.cc
+++ b/libinterp/dldfcn/dmperm.cc
@@ -77,61 +77,59 @@ dmperm_internal (bool rank, const octave
   else
     {
       cm = arg.sparse_complex_matrix_value ();
       csm.nzmax = cm.nnz ();
       csm.p = cm.xcidx ();
       csm.i = cm.xridx ();
     }
 
-  if (!error_state)
+  if (nargout <= 1 || rank)
     {
-      if (nargout <= 1 || rank)
-        {
 #if defined(CS_VER) && (CS_VER >= 2)
-          octave_idx_type *jmatch = CXSPARSE_NAME (_maxtrans) (&csm, 0);
+      octave_idx_type *jmatch = CXSPARSE_NAME (_maxtrans) (&csm, 0);
 #else
-          octave_idx_type *jmatch = CXSPARSE_NAME (_maxtrans) (&csm);
+      octave_idx_type *jmatch = CXSPARSE_NAME (_maxtrans) (&csm);
 #endif
-          if (rank)
-            {
-              octave_idx_type r = 0;
-              for (octave_idx_type i = 0; i < nc; i++)
-                if (jmatch[nr+i] >= 0)
-                  r++;
-              retval(0) = static_cast<double>(r);
-            }
-          else
-            retval(0) = put_int (jmatch + nr, nc);
-          CXSPARSE_NAME (_free) (jmatch);
+      if (rank)
+        {
+          octave_idx_type r = 0;
+          for (octave_idx_type i = 0; i < nc; i++)
+            if (jmatch[nr+i] >= 0)
+              r++;
+          retval(0) = static_cast<double>(r);
         }
       else
-        {
+        retval(0) = put_int (jmatch + nr, nc);
+      CXSPARSE_NAME (_free) (jmatch);
+    }
+  else
+    {
 #if defined(CS_VER) && (CS_VER >= 2)
-          CXSPARSE_NAME (d) *dm = CXSPARSE_NAME(_dmperm) (&csm, 0);
+      CXSPARSE_NAME (d) *dm = CXSPARSE_NAME(_dmperm) (&csm, 0);
 #else
-          CXSPARSE_NAME (d) *dm = CXSPARSE_NAME(_dmperm) (&csm);
+      CXSPARSE_NAME (d) *dm = CXSPARSE_NAME(_dmperm) (&csm);
 #endif
 
-          //retval(5) = put_int (dm->rr, 5);
-          //retval(4) = put_int (dm->cc, 5);
+      //retval(5) = put_int (dm->rr, 5);
+      //retval(4) = put_int (dm->cc, 5);
 #if defined(CS_VER) && (CS_VER >= 2)
-          retval(3) = put_int (dm->s, dm->nb+1);
-          retval(2) = put_int (dm->r, dm->nb+1);
-          retval(1) = put_int (dm->q, nc);
-          retval(0) = put_int (dm->p, nr);
+      retval(3) = put_int (dm->s, dm->nb+1);
+      retval(2) = put_int (dm->r, dm->nb+1);
+      retval(1) = put_int (dm->q, nc);
+      retval(0) = put_int (dm->p, nr);
 #else
-          retval(3) = put_int (dm->S, dm->nb+1);
-          retval(2) = put_int (dm->R, dm->nb+1);
-          retval(1) = put_int (dm->Q, nc);
-          retval(0) = put_int (dm->P, nr);
+      retval(3) = put_int (dm->S, dm->nb+1);
+      retval(2) = put_int (dm->R, dm->nb+1);
+      retval(1) = put_int (dm->Q, nc);
+      retval(0) = put_int (dm->P, nr);
 #endif
-          CXSPARSE_NAME (_dfree) (dm);
-        }
+      CXSPARSE_NAME (_dfree) (dm);
     }
+
   return retval;
 }
 #endif
 
 DEFUN_DLD (dmperm, args, nargout,
            "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {@var{p} =} dmperm (@var{S})\n\
 @deftypefnx {Loadable Function} {[@var{p}, @var{q}, @var{r}, @var{S}] =} dmperm (@var{S})\n\
diff --git a/libinterp/dldfcn/fftw.cc b/libinterp/dldfcn/fftw.cc
--- a/libinterp/dldfcn/fftw.cc
+++ b/libinterp/dldfcn/fftw.cc
@@ -152,70 +152,65 @@ used per default.\n\
           if (nargin == 2)  //planner setter
             {
               if (args(1).is_string ())
                 {
                   // Use STL function to convert to lower case
                   std::transform (arg0.begin (), arg0.end (), arg0.begin (),
                                   tolower);
                   std::string arg1 = args(1).string_value ();
-                  if (!error_state)
-                    {
-                      std::transform (arg1.begin (), arg1.end (),
-                                      arg1.begin (), tolower);
-                      octave_fftw_planner::FftwMethod meth
-                        = octave_fftw_planner::UNKNOWN;
-                      octave_float_fftw_planner::FftwMethod methf
-                        = octave_float_fftw_planner::UNKNOWN;
+
+                  std::transform (arg1.begin (), arg1.end (),
+                                  arg1.begin (), tolower);
+                  octave_fftw_planner::FftwMethod meth
+                    = octave_fftw_planner::UNKNOWN;
+                  octave_float_fftw_planner::FftwMethod methf
+                    = octave_float_fftw_planner::UNKNOWN;
 
-                      if (arg1 == "estimate")
-                        {
-                          meth = octave_fftw_planner::ESTIMATE;
-                          methf = octave_float_fftw_planner::ESTIMATE;
-                        }
-                      else if (arg1 == "measure")
-                        {
-                          meth = octave_fftw_planner::MEASURE;
-                          methf = octave_float_fftw_planner::MEASURE;
-                        }
-                      else if (arg1 == "patient")
-                        {
-                          meth = octave_fftw_planner::PATIENT;
-                          methf = octave_float_fftw_planner::PATIENT;
-                        }
-                      else if (arg1 == "exhaustive")
-                        {
-                          meth = octave_fftw_planner::EXHAUSTIVE;
-                          methf = octave_float_fftw_planner::EXHAUSTIVE;
-                        }
-                      else if (arg1 == "hybrid")
-                        {
-                          meth = octave_fftw_planner::HYBRID;
-                          methf = octave_float_fftw_planner::HYBRID;
-                        }
-                      else
-                        error ("fftw: unrecognized planner METHOD");
+                  if (arg1 == "estimate")
+                    {
+                      meth = octave_fftw_planner::ESTIMATE;
+                      methf = octave_float_fftw_planner::ESTIMATE;
+                    }
+                  else if (arg1 == "measure")
+                    {
+                      meth = octave_fftw_planner::MEASURE;
+                      methf = octave_float_fftw_planner::MEASURE;
+                    }
+                  else if (arg1 == "patient")
+                    {
+                      meth = octave_fftw_planner::PATIENT;
+                      methf = octave_float_fftw_planner::PATIENT;
+                    }
+                  else if (arg1 == "exhaustive")
+                    {
+                      meth = octave_fftw_planner::EXHAUSTIVE;
+                      methf = octave_float_fftw_planner::EXHAUSTIVE;
+                    }
+                  else if (arg1 == "hybrid")
+                    {
+                      meth = octave_fftw_planner::HYBRID;
+                      methf = octave_float_fftw_planner::HYBRID;
+                    }
+                  else
+                    error ("fftw: unrecognized planner METHOD");
 
-                      if (!error_state)
-                        {
-                          meth = octave_fftw_planner::method (meth);
-                          octave_float_fftw_planner::method (methf);
+                  meth = octave_fftw_planner::method (meth);
+                  octave_float_fftw_planner::method (methf);
 
-                          if (meth == octave_fftw_planner::MEASURE)
-                            retval = octave_value ("measure");
-                          else if (meth == octave_fftw_planner::PATIENT)
-                            retval = octave_value ("patient");
-                          else if (meth == octave_fftw_planner::EXHAUSTIVE)
-                            retval = octave_value ("exhaustive");
-                          else if (meth == octave_fftw_planner::HYBRID)
-                            retval = octave_value ("hybrid");
-                          else
-                            retval = octave_value ("estimate");
-                        }
-                    }
+                  if (meth == octave_fftw_planner::MEASURE)
+                    retval = octave_value ("measure");
+                  else if (meth == octave_fftw_planner::PATIENT)
+                    retval = octave_value ("patient");
+                  else if (meth == octave_fftw_planner::EXHAUSTIVE)
+                    retval = octave_value ("exhaustive");
+                  else if (meth == octave_fftw_planner::HYBRID)
+                    retval = octave_value ("hybrid");
+                  else
+                    retval = octave_value ("estimate");
                 }
               else
                 error ("fftw: planner expects a string value as METHOD");
             }
           else //planner getter
             {
               octave_fftw_planner::FftwMethod meth =
                 octave_fftw_planner::method ();
@@ -237,70 +232,74 @@ used per default.\n\
           if (nargin == 2)  //dwisdom setter
             {
               if (args(1).is_string ())
                 {
                   // Use STL function to convert to lower case
                   std::transform (arg0.begin (), arg0.end (), arg0.begin (),
                                   tolower);
                   std::string arg1 = args(1).string_value ();
-                  if (!error_state)
-                    {
-                      char *str = fftw_export_wisdom_to_string ();
+
+                  char *str = fftw_export_wisdom_to_string ();
 
-                      if (arg1.length () < 1)
-                        fftw_forget_wisdom ();
-                      else if (! fftw_import_wisdom_from_string (arg1.c_str ()))
-                        error ("fftw: could not import supplied WISDOM");
+                  if (arg1.length () < 1)
+                    fftw_forget_wisdom ();
+                  else if (! fftw_import_wisdom_from_string (arg1.c_str ()))
+                    error ("fftw: could not import supplied WISDOM");
 
-                      if (!error_state)
-                        retval = octave_value (std::string (str));
+                  retval = octave_value (std::string (str));
 
-                      free (str);
-                    }
+                  // FIXME: need to free string even if there is an
+                  // exception.
+                  free (str);
                 }
             }
           else //dwisdom getter
             {
               char *str = fftw_export_wisdom_to_string ();
               retval = octave_value (std::string (str));
+
+              // FIXME: need to free string even if there is an
+              // exception.
               free (str);
             }
         }
       else if (arg0 == "swisdom")
         {
           //swisdom uses fftwf_ functions (float), dwisdom fftw_ (real)
           if (nargin == 2)  //swisdom setter
             {
               if (args(1).is_string ())
                 {
                   // Use STL function to convert to lower case
                   std::transform (arg0.begin (), arg0.end (), arg0.begin (),
                                   tolower);
                   std::string arg1 = args(1).string_value ();
-                  if (!error_state)
-                    {
-                      char *str = fftwf_export_wisdom_to_string ();
+
+                  char *str = fftwf_export_wisdom_to_string ();
 
-                      if (arg1.length () < 1)
-                        fftwf_forget_wisdom ();
-                      else if (! fftwf_import_wisdom_from_string (arg1.c_str ()))
-                        error ("fftw: could not import supplied WISDOM");
+                  if (arg1.length () < 1)
+                    fftwf_forget_wisdom ();
+                  else if (! fftwf_import_wisdom_from_string (arg1.c_str ()))
+                    error ("fftw: could not import supplied WISDOM");
 
-                      if (!error_state)
-                        retval = octave_value (std::string (str));
+                  retval = octave_value (std::string (str));
 
-                      free (str);
-                    }
+                  // FIXME: need to free string even if there is an
+                  // exception.
+                  free (str);
                 }
             }
           else //swisdom getter
             {
               char *str = fftwf_export_wisdom_to_string ();
               retval = octave_value (std::string (str));
+
+              // FIXME: need to free string even if there is an
+              // exception.
               free (str);
             }
         }
       else if (arg0 == "threads")
         {
           if (nargin == 2)  //threads setter
             {
               if (args(1).is_real_scalar ())
diff --git a/libinterp/dldfcn/symrcm.cc b/libinterp/dldfcn/symrcm.cc
--- a/libinterp/dldfcn/symrcm.cc
+++ b/libinterp/dldfcn/symrcm.cc
@@ -464,19 +464,16 @@ Mathematics, ISBN 0-13-165274-5, 1981.\n
     }
   else
     {
       Ac = arg.sparse_complex_matrix_value ();
       cidx = Ac.xcidx ();
       ridx = Ac.xridx ();
     }
 
-  if (error_state)
-    return retval;
-
   octave_idx_type nr = arg.rows ();
   octave_idx_type nc = arg.columns ();
 
   if (nr != nc)
     {
       gripe_square_matrix_required ("symrcm");
       return retval;
     }
diff --git a/libinterp/octave-value/ov-base-diag.cc b/libinterp/octave-value/ov-base-diag.cc
--- a/libinterp/octave-value/ov-base-diag.cc
+++ b/libinterp/octave-value/ov-base-diag.cc
@@ -166,17 +166,17 @@ octave_base_diag<DMT, MT>::subsasgn (con
               {
                 typename DMT::element_type val;
                 int k = 0;
                 try
                   {
                     idx_vector i0 = jdx(0).index_vector ();
                     k = 1;
                     idx_vector i1 = jdx(1).index_vector ();
-                    if (! error_state  && i0(0) == i1(0)
+                    if (i0(0) == i1(0)
                         && i0(0) < matrix.rows () && i1(0) < matrix.cols ()
                         && chk_valid_scalar (rhs, val))
                       {
                         matrix.dgelem (i0(0)) = val;
                         retval = this;
                         this->count++;
                         // invalidate cache
                         dense_cache = octave_value ();
@@ -185,17 +185,17 @@ octave_base_diag<DMT, MT>::subsasgn (con
                 catch (index_exception& e)
                   {
                     // Rethrow to allow more info to be reported later.
                     e.set_pos_if_unset (2, k+1);
                     throw;
                   }
               }
 
-            if (! error_state && ! retval.is_defined ())
+            if (! retval.is_defined ())
               retval = numeric_assign (type, idx, rhs);
           }
         else
           {
             std::string nm = type_name ();
             error ("in indexed assignment of %s, last lhs index must be ()",
                    nm.c_str ());
           }
diff --git a/libinterp/octave-value/ov-base-sparse.cc b/libinterp/octave-value/ov-base-sparse.cc
--- a/libinterp/octave-value/ov-base-sparse.cc
+++ b/libinterp/octave-value/ov-base-sparse.cc
@@ -68,33 +68,28 @@ octave_base_sparse<T>::do_index_op (cons
         case 0:
           retval = matrix;
           break;
 
         case 1:
           {
             idx_vector i = idx (0).index_vector ();
 
-            if (! error_state)
-              retval = octave_value (matrix.index (i, resize_ok));
+            retval = octave_value (matrix.index (i, resize_ok));
           }
           break;
 
         case 2:
           {
             idx_vector i = idx (0).index_vector ();
 
-            if (! error_state)
-              {
-                k = 1;
-                idx_vector j = idx (1).index_vector ();
+            k = 1;
+            idx_vector j = idx (1).index_vector ();
 
-                if (! error_state)
-                  retval = octave_value (matrix.index (i, j, resize_ok));
-              }
+            retval = octave_value (matrix.index (i, j, resize_ok));
           }
           break;
         default:
           error ("sparse indexing needs 1 or 2 indices");
         }
     }
   catch (index_exception& e)
     {
@@ -197,34 +192,30 @@ octave_base_sparse<T>::assign (const oct
   try
     {
       switch (len)
         {
         case 1:
           {
             idx_vector i = idx (0).index_vector ();
 
-            if (! error_state)
-              matrix.assign (i, rhs);
+            matrix.assign (i, rhs);
 
             break;
           }
 
         case 2:
           {
             idx_vector i = idx (0).index_vector ();
 
-            if (! error_state)
-              {
-                k = 1;
-                idx_vector j = idx (1).index_vector ();
+            k = 1;
+            idx_vector j = idx (1).index_vector ();
 
-                if (! error_state)
-                  matrix.assign (i, j, rhs);
-              }
+            matrix.assign (i, j, rhs);
+
             break;
           }
 
         default:
           error ("sparse indexing needs 1 or 2 indices");
         }
     }
   catch (index_exception& e)
@@ -254,34 +245,29 @@ octave_base_sparse<MT>::delete_elements 
   try
     {
       switch (len)
         {
         case 1:
           {
             idx_vector i = idx (0).index_vector ();
 
-            if (! error_state)
-              matrix.delete_elements (i);
+            matrix.delete_elements (i);
 
             break;
           }
 
         case 2:
           {
             idx_vector i = idx (0).index_vector ();
 
-            if (! error_state)
-              {
-                k = 1;
-                idx_vector j = idx (1).index_vector ();
+            k = 1;
+            idx_vector j = idx (1).index_vector ();
 
-                if (! error_state)
-                  matrix.delete_elements (i, j);
-              }
+            matrix.delete_elements (i, j);
 
             break;
           }
 
         default:
           error ("sparse indexing needs 1 or 2 indices");
         }
     }
diff --git a/libinterp/octave-value/ov-base.cc b/libinterp/octave-value/ov-base.cc
--- a/libinterp/octave-value/ov-base.cc
+++ b/libinterp/octave-value/ov-base.cc
@@ -653,18 +653,17 @@ octave_base_value::bool_array_value (boo
 
 charMatrix
 octave_base_value::char_matrix_value (bool force) const
 {
   charMatrix retval;
 
   octave_value tmp = convert_to_str (false, force);
 
-  if (! error_state)
-    retval = tmp.char_matrix_value ();
+  retval = tmp.char_matrix_value ();
 
   return retval;
 }
 
 charNDArray
 octave_base_value::char_array_value (bool) const
 {
   charNDArray retval;
@@ -889,31 +888,29 @@ octave_base_value::uint64_array_value (v
 
 string_vector
 octave_base_value::all_strings (bool pad) const
 {
   string_vector retval;
 
   octave_value tmp = convert_to_str (pad, true);
 
-  if (! error_state)
-    retval = tmp.all_strings ();
+  retval = tmp.all_strings ();
 
   return retval;
 }
 
 std::string
 octave_base_value::string_value (bool force) const
 {
   std::string retval;
 
   octave_value tmp = convert_to_str (force);
 
-  if (! error_state)
-    retval = tmp.string_value ();
+  retval = tmp.string_value ();
 
   return retval;
 }
 
 Array<std::string>
 octave_base_value::cellstr_value (void) const
 {
   Array<std::string> retval;
@@ -1345,17 +1342,17 @@ octave_base_value::numeric_assign (const
                                                t_lhs, t_rhs);
 
   bool done = false;
 
   if (f)
     {
       f (*this, idx.front (), rhs.get_rep ());
 
-      done = (! error_state);
+      done = true;
     }
 
   if (done)
     {
       count++;
       retval = octave_value (this);
     }
   else
@@ -1373,27 +1370,27 @@ octave_base_value::numeric_assign (const
               octave_base_value *tmp = cf (*this);
 
               if (tmp)
                 {
                   octave_value val (tmp);
 
                   retval = val.subsasgn (type, idx, rhs);
 
-                  done = (! error_state);
+                  done = true;
                 }
               else
                 gripe_assign_conversion_failed (type_name (),
                                                 rhs.type_name ());
             }
           else
             gripe_indexed_assignment (type_name (), rhs.type_name ());
         }
 
-      if (! (done || error_state))
+      if (! done)
         {
           octave_value tmp_rhs;
 
           octave_base_value::type_conv_info cf_rhs
             = rhs.numeric_conversion_function ();
 
           octave_base_value::type_conv_info cf_this
             = numeric_conversion_function ();
@@ -1445,17 +1442,17 @@ octave_base_value::numeric_assign (const
                   return octave_value ();
                 }
             }
 
           if (cf_this || cf_rhs)
             {
               retval = tmp_lhs.subsasgn (type, idx, tmp_rhs);
 
-              done = (! error_state);
+              done = true;
             }
           else
             gripe_no_conversion (octave_value::assign_op_as_string
                                    (octave_value::op_asn_eq),
                                  type_name (), rhs.type_name ());
         }
     }
 
diff --git a/libinterp/octave-value/ov-bool-sparse.cc b/libinterp/octave-value/ov-bool-sparse.cc
--- a/libinterp/octave-value/ov-bool-sparse.cc
+++ b/libinterp/octave-value/ov-bool-sparse.cc
@@ -314,17 +314,17 @@ octave_sparse_bool_matrix::load_binary (
       octave_quit ();
       if (! is.read (reinterpret_cast<char *> (&tmp), 4))
         return false;
       if (swap)
         swap_bytes<4> (&tmp);
       m.ridx (i) = tmp;
     }
 
-  if (error_state || ! is)
+  if (! is)
     return false;
 
   OCTAVE_LOCAL_BUFFER (char, htmp, nz);
 
   if (! is.read (htmp, nz))
     return false;
 
   for (int i = 0; i < nz; i++)
diff --git a/libinterp/octave-value/ov-builtin.cc b/libinterp/octave-value/ov-builtin.cc
--- a/libinterp/octave-value/ov-builtin.cc
+++ b/libinterp/octave-value/ov-builtin.cc
@@ -100,19 +100,16 @@ octave_builtin::do_multi_index_op (int n
 }
 
 octave_value_list
 octave_builtin::do_multi_index_op (int nargout, const octave_value_list& args,
                                    const std::list<octave_lvalue> *lvalue_list)
 {
   octave_value_list retval;
 
-  if (error_state)
-    return retval;
-
   if (args.has_magic_colon ())
     error ("invalid use of colon in function argument list");
   else
     {
       unwind_protect frame;
 
       octave_call_stack::push (this);
 
diff --git a/libinterp/octave-value/ov-complex.cc b/libinterp/octave-value/ov-complex.cc
--- a/libinterp/octave-value/ov-complex.cc
+++ b/libinterp/octave-value/ov-complex.cc
@@ -296,17 +296,18 @@ octave_complex::load_binary (std::istrea
 {
   char tmp;
   if (! is.read (reinterpret_cast<char *> (&tmp), 1))
     return false;
 
   Complex ctmp;
   read_doubles (is, reinterpret_cast<double *> (&ctmp),
                 static_cast<save_type> (tmp), 2, swap, fmt);
-  if (error_state || ! is)
+
+  if (! is)
     return false;
 
   scalar = ctmp;
   return true;
 }
 
 bool
 octave_complex::save_hdf5 (octave_hdf5_id loc_id, const char *name,
diff --git a/libinterp/octave-value/ov-cx-diag.cc b/libinterp/octave-value/ov-cx-diag.cc
--- a/libinterp/octave-value/ov-cx-diag.cc
+++ b/libinterp/octave-value/ov-cx-diag.cc
@@ -213,18 +213,20 @@ octave_complex_diag_matrix::load_binary 
       swap_bytes<4> (&c);
     }
 
   ComplexDiagMatrix m (r, c);
   Complex *im = m.fortran_vec ();
   octave_idx_type len = m.length ();
   read_doubles (is, reinterpret_cast<double *> (im),
                 static_cast<save_type> (tmp), 2 * len, swap, fmt);
-  if (error_state || ! is)
+
+  if (! is)
     return false;
+
   matrix = m;
 
   return true;
 }
 
 bool
 octave_complex_diag_matrix::chk_valid_scalar (const octave_value& val,
                                               Complex& x) const
diff --git a/libinterp/octave-value/ov-cx-mat.cc b/libinterp/octave-value/ov-cx-mat.cc
--- a/libinterp/octave-value/ov-cx-mat.cc
+++ b/libinterp/octave-value/ov-cx-mat.cc
@@ -532,18 +532,20 @@ octave_complex_matrix::load_binary (std:
 
       if (! is.read (reinterpret_cast<char *> (&tmp), 1))
         return false;
 
       ComplexNDArray m(dv);
       Complex *im = m.fortran_vec ();
       read_doubles (is, reinterpret_cast<double *> (im),
                     static_cast<save_type> (tmp), 2 * dv.numel (), swap, fmt);
-      if (error_state || ! is)
+
+      if (! is)
         return false;
+
       matrix = m;
     }
   else
     {
       int32_t nr, nc;
       nr = mdims;
       if (! is.read (reinterpret_cast<char *> (&nc), 4))
         return false;
@@ -551,18 +553,20 @@ octave_complex_matrix::load_binary (std:
         swap_bytes<4> (&nc);
       if (! is.read (reinterpret_cast<char *> (&tmp), 1))
         return false;
       ComplexMatrix m (nr, nc);
       Complex *im = m.fortran_vec ();
       octave_idx_type len = nr * nc;
       read_doubles (is, reinterpret_cast<double *> (im),
                     static_cast<save_type> (tmp), 2*len, swap, fmt);
-      if (error_state || ! is)
+
+      if (! is)
         return false;
+
       matrix = m;
     }
   return true;
 }
 
 bool
 octave_complex_matrix::save_hdf5 (octave_hdf5_id loc_id, const char *name,
                                   bool save_as_floats)
diff --git a/libinterp/octave-value/ov-cx-sparse.cc b/libinterp/octave-value/ov-cx-sparse.cc
--- a/libinterp/octave-value/ov-cx-sparse.cc
+++ b/libinterp/octave-value/ov-cx-sparse.cc
@@ -352,17 +352,17 @@ octave_sparse_complex_matrix::load_binar
     }
 
   if (! is.read (reinterpret_cast<char *> (&ctmp), 1))
     return false;
 
   read_doubles (is, reinterpret_cast<double *> (m.data ()),
                 static_cast<save_type> (ctmp), 2 * nz, swap, fmt);
 
-  if (error_state || ! is)
+  if (! is)
     return false;
 
   if (! m.indices_ok ())
     return false;
 
   matrix = m;
 
   return true;
diff --git a/libinterp/octave-value/ov-fcn-handle.cc b/libinterp/octave-value/ov-fcn-handle.cc
--- a/libinterp/octave-value/ov-fcn-handle.cc
+++ b/libinterp/octave-value/ov-fcn-handle.cc
@@ -1154,32 +1154,29 @@ octave_fcn_handle::load_hdf5 (octave_hdf
           H5Gclose (data_hid);
 
           if (num_obj != static_cast<hsize_t>(len))
             {
               error ("load: failed to load anonymous function handle");
               success = false;
             }
 
-          if (! error_state)
+          hdf5_callback_data dsub;
+          int current_item = 0;
+          for (octave_idx_type i = 0; i < len; i++)
             {
-              hdf5_callback_data dsub;
-              int current_item = 0;
-              for (octave_idx_type i = 0; i < len; i++)
+              if (H5Giterate (group_hid, "symbol table", &current_item,
+                              hdf5_read_next_data, &dsub) <= 0)
                 {
-                  if (H5Giterate (group_hid, "symbol table", &current_item,
-                                  hdf5_read_next_data, &dsub) <= 0)
-                    {
-                      error ("load: failed to load anonymous function handle");
-                      success = false;
-                      break;
-                    }
+                  error ("load: failed to load anonymous function handle");
+                  success = false;
+                  break;
+                }
 
-                  symbol_table::assign (dsub.name, dsub.tc, local_scope);
-                }
+              symbol_table::assign (dsub.name, dsub.tc, local_scope);
             }
         }
 
       if (success)
         {
           int parse_status;
           octave_value anon_fcn_handle =
             eval_string (fcn_tmp, true, parse_status);
diff --git a/libinterp/octave-value/ov-fcn-inline.cc b/libinterp/octave-value/ov-fcn-inline.cc
--- a/libinterp/octave-value/ov-fcn-inline.cc
+++ b/libinterp/octave-value/ov-fcn-inline.cc
@@ -985,48 +985,45 @@ quadv (fcn, 0, 3)\n\
           func_is_string = false;
 
           if (old)
             old_func = old->fcn_text ();
           else
             error ("vectorize: FUN must be a string or inline function");
         }
 
-      if (! error_state)
+      std::string new_func;
+      size_t i = 0;
+
+      while (i < old_func.length ())
         {
-          std::string new_func;
-          size_t i = 0;
+          std::string t1 = old_func.substr (i, 1);
 
-          while (i < old_func.length ())
+          if (t1 == "*" || t1 == "/" || t1 == "\\" || t1 == "^")
             {
-              std::string t1 = old_func.substr (i, 1);
-
-              if (t1 == "*" || t1 == "/" || t1 == "\\" || t1 == "^")
-                {
-                  if (i && old_func.substr (i-1, 1) != ".")
-                    new_func.append (".");
+              if (i && old_func.substr (i-1, 1) != ".")
+                new_func.append (".");
 
-                  // Special case for ** operator.
-                  if (t1 == "*" && i < (old_func.length () - 1)
-                      && old_func.substr (i+1, 1) == "*")
-                    {
-                      new_func.append ("*");
-                      i++;
-                    }
+              // Special case for ** operator.
+              if (t1 == "*" && i < (old_func.length () - 1)
+                  && old_func.substr (i+1, 1) == "*")
+                {
+                  new_func.append ("*");
+                  i++;
                 }
-              new_func.append (t1);
-              i++;
             }
+          new_func.append (t1);
+          i++;
+        }
 
-          if (func_is_string)
-            retval = octave_value (new_func);
-          else
-            retval = octave_value (new octave_fcn_inline
-                                   (new_func, old->fcn_arg_names ()));
-        }
+      if (func_is_string)
+        retval = octave_value (new_func);
+      else
+        retval = octave_value (new octave_fcn_inline
+                               (new_func, old->fcn_arg_names ()));
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
diff --git a/libinterp/octave-value/ov-float.cc b/libinterp/octave-value/ov-float.cc
--- a/libinterp/octave-value/ov-float.cc
+++ b/libinterp/octave-value/ov-float.cc
@@ -172,17 +172,18 @@ octave_float_scalar::load_binary (std::i
                                   oct_mach_info::float_format fmt)
 {
   char tmp;
   if (! is.read (reinterpret_cast<char *> (&tmp), 1))
     return false;
 
   float dtmp;
   read_floats (is, &dtmp, static_cast<save_type> (tmp), 1, swap, fmt);
-  if (error_state || ! is)
+
+  if (! is)
     return false;
 
   scalar = dtmp;
   return true;
 }
 
 bool
 octave_float_scalar::save_hdf5 (octave_hdf5_id loc_id, const char *name,
@@ -352,17 +353,17 @@ octave_float_scalar::map (unary_mapper_t
     case umap_xisprint:
     case umap_xispunct:
     case umap_xisspace:
     case umap_xisupper:
     case umap_xisxdigit:
     case umap_xtoascii:
       {
         octave_value str_conv = convert_to_str (true, true);
-        return error_state ? octave_value () : str_conv.map (umap);
+        return str_conv.map (umap);
       }
 
     default:
       return octave_base_value::map (umap);
     }
 }
 
 bool
diff --git a/libinterp/octave-value/ov-flt-complex.cc b/libinterp/octave-value/ov-flt-complex.cc
--- a/libinterp/octave-value/ov-flt-complex.cc
+++ b/libinterp/octave-value/ov-flt-complex.cc
@@ -282,17 +282,18 @@ octave_float_complex::load_binary (std::
 {
   char tmp;
   if (! is.read (reinterpret_cast<char *> (&tmp), 1))
     return false;
 
   FloatComplex ctmp;
   read_floats (is, reinterpret_cast<float *> (&ctmp),
                static_cast<save_type> (tmp), 2, swap, fmt);
-  if (error_state || ! is)
+
+  if (! is)
     return false;
 
   scalar = ctmp;
   return true;
 }
 
 bool
 octave_float_complex::save_hdf5 (octave_hdf5_id loc_id, const char *name,
diff --git a/libinterp/octave-value/ov-flt-cx-diag.cc b/libinterp/octave-value/ov-flt-cx-diag.cc
--- a/libinterp/octave-value/ov-flt-cx-diag.cc
+++ b/libinterp/octave-value/ov-flt-cx-diag.cc
@@ -185,18 +185,20 @@ octave_float_complex_diag_matrix::load_b
       swap_bytes<4> (&c);
     }
 
   FloatComplexDiagMatrix m (r, c);
   FloatComplex *re = m.fortran_vec ();
   octave_idx_type len = m.length ();
   read_floats (is, reinterpret_cast<float *> (re),
                static_cast<save_type> (tmp), 2 * len, swap, fmt);
-  if (error_state || ! is)
+
+  if (! is)
     return false;
+
   matrix = m;
 
   return true;
 }
 
 bool
 octave_float_complex_diag_matrix::chk_valid_scalar (const octave_value& val,
                                                     FloatComplex& x) const
diff --git a/libinterp/octave-value/ov-flt-cx-mat.cc b/libinterp/octave-value/ov-flt-cx-mat.cc
--- a/libinterp/octave-value/ov-flt-cx-mat.cc
+++ b/libinterp/octave-value/ov-flt-cx-mat.cc
@@ -494,18 +494,20 @@ octave_float_complex_matrix::load_binary
 
       if (! is.read (reinterpret_cast<char *> (&tmp), 1))
         return false;
 
       FloatComplexNDArray m(dv);
       FloatComplex *im = m.fortran_vec ();
       read_floats (is, reinterpret_cast<float *> (im),
                    static_cast<save_type> (tmp), 2 * dv.numel (), swap, fmt);
-      if (error_state || ! is)
+
+      if (! is)
         return false;
+
       matrix = m;
     }
   else
     {
       int32_t nr, nc;
       nr = mdims;
       if (! is.read (reinterpret_cast<char *> (&nc), 4))
         return false;
@@ -513,18 +515,20 @@ octave_float_complex_matrix::load_binary
         swap_bytes<4> (&nc);
       if (! is.read (reinterpret_cast<char *> (&tmp), 1))
         return false;
       FloatComplexMatrix m (nr, nc);
       FloatComplex *im = m.fortran_vec ();
       octave_idx_type len = nr * nc;
       read_floats (is, reinterpret_cast<float *> (im),
                    static_cast<save_type> (tmp), 2*len, swap, fmt);
-      if (error_state || ! is)
+
+      if (! is)
         return false;
+
       matrix = m;
     }
   return true;
 }
 
 bool
 octave_float_complex_matrix::save_hdf5 (octave_hdf5_id loc_id, const char *name, bool)
 {
diff --git a/libinterp/octave-value/ov-flt-re-diag.cc b/libinterp/octave-value/ov-flt-re-diag.cc
--- a/libinterp/octave-value/ov-flt-re-diag.cc
+++ b/libinterp/octave-value/ov-flt-re-diag.cc
@@ -153,18 +153,20 @@ octave_float_diag_matrix::load_binary (s
       swap_bytes<4> (&r);
       swap_bytes<4> (&c);
     }
 
   FloatDiagMatrix m (r, c);
   float *re = m.fortran_vec ();
   octave_idx_type len = m.length ();
   read_floats (is, re, static_cast<save_type> (tmp), len, swap, fmt);
-  if (error_state || ! is)
+
+  if (! is)
     return false;
+
   matrix = m;
 
   return true;
 }
 
 bool
 octave_float_diag_matrix::chk_valid_scalar (const octave_value& val,
                                             float& x) const
diff --git a/libinterp/octave-value/ov-flt-re-mat.cc b/libinterp/octave-value/ov-flt-re-mat.cc
--- a/libinterp/octave-value/ov-flt-re-mat.cc
+++ b/libinterp/octave-value/ov-flt-re-mat.cc
@@ -522,36 +522,40 @@ octave_float_matrix::load_binary (std::i
 
       if (! is.read (reinterpret_cast<char *> (&tmp), 1))
         return false;
 
       FloatNDArray m(dv);
       float *re = m.fortran_vec ();
       read_floats (is, re, static_cast<save_type> (tmp), dv.numel (),
                    swap, fmt);
-      if (error_state || ! is)
+
+      if (! is)
         return false;
+
       matrix = m;
     }
   else
     {
       int32_t nr, nc;
       nr = mdims;
       if (! is.read (reinterpret_cast<char *> (&nc), 4))
         return false;
       if (swap)
         swap_bytes<4> (&nc);
       if (! is.read (reinterpret_cast<char *> (&tmp), 1))
         return false;
       FloatMatrix m (nr, nc);
       float *re = m.fortran_vec ();
       octave_idx_type len = nr * nc;
       read_floats (is, re, static_cast<save_type> (tmp), len, swap, fmt);
-      if (error_state || ! is)
+
+      if (! is)
         return false;
+
       matrix = m;
     }
   return true;
 }
 
 bool
 octave_float_matrix::save_hdf5 (octave_hdf5_id loc_id, const char *name, bool)
 {
@@ -836,17 +840,17 @@ octave_float_matrix::map (unary_mapper_t
     case umap_xisprint:
     case umap_xispunct:
     case umap_xisspace:
     case umap_xisupper:
     case umap_xisxdigit:
     case umap_xtoascii:
       {
         octave_value str_conv = convert_to_str (true, true);
-        return error_state ? octave_value () : str_conv.map (umap);
+        return str_conv.map (umap);
       }
 
     default:
       return octave_base_value::map (umap);
     }
 }
 
 DEFUN (single, args, ,
diff --git a/libinterp/octave-value/ov-lazy-idx.cc b/libinterp/octave-value/ov-lazy-idx.cc
--- a/libinterp/octave-value/ov-lazy-idx.cc
+++ b/libinterp/octave-value/ov-lazy-idx.cc
@@ -170,17 +170,17 @@ bool octave_lazy_index::load_ascii (std:
 
   std::string nm = read_text_data (is, std::string (), dummy, value, 0);
 
   if (nm != value_save_tag)
     error ("lazy_index: corrupted data on load");
   else
     index = value.index_vector ();
 
-  return ! error_state;
+  return true;
 }
 
 
 bool octave_lazy_index::save_binary (std::ostream& os, bool& save_as_floats)
 {
   return save_binary_data (os, make_value (), value_save_tag,
                            std::string (), false, save_as_floats);
 }
@@ -194,10 +194,10 @@ bool octave_lazy_index::load_binary (std
   std::string nm = read_binary_data (is, swap, fmt, std::string (),
                                      dummy, value, doc);
 
   if (nm != value_save_tag)
     error ("lazy_index: corrupted data on load");
   else
     index = value.index_vector ();
 
-  return ! error_state;
+  return true;
 }
diff --git a/libinterp/octave-value/ov-mex-fcn.cc b/libinterp/octave-value/ov-mex-fcn.cc
--- a/libinterp/octave-value/ov-mex-fcn.cc
+++ b/libinterp/octave-value/ov-mex-fcn.cc
@@ -127,19 +127,16 @@ call_mex (bool have_fmex, void *f, const
           int nargout, octave_mex_function *curr_mex_fcn);
 
 octave_value_list
 octave_mex_function::do_multi_index_op (int nargout,
                                         const octave_value_list& args)
 {
   octave_value_list retval;
 
-  if (error_state)
-    return retval;
-
   if (args.has_magic_colon ())
     error ("invalid use of colon in function argument list");
   else
     {
       unwind_protect frame;
 
       octave_call_stack::push (this);
 
diff --git a/libinterp/octave-value/ov-perm.cc b/libinterp/octave-value/ov-perm.cc
--- a/libinterp/octave-value/ov-perm.cc
+++ b/libinterp/octave-value/ov-perm.cc
@@ -89,17 +89,17 @@ octave_perm_matrix::do_index_op (const o
         }
     }
 
   // This hack is to allow constructing permutation matrices using
   // eye(n)(p,:), eye(n)(:,q) && eye(n)(p,q) where p & q are permutation
   // vectors.
   // Note that, for better consistency, eye(n)(:,:) still converts to a full
   // matrix.
-  if (! error_state && nidx == 2)
+  if (nidx == 2)
     {
       bool left = idx0.is_permutation (matrix.rows ());
       bool right = idx1.is_permutation (matrix.cols ());
 
       if (left && right)
         {
           if (idx0.is_colon ()) left = false;
           if (idx1.is_colon ()) right = false;
@@ -115,18 +115,17 @@ octave_perm_matrix::do_index_op (const o
           else
             {
               retval = this;
               this->count++;
             }
         }
     }
 
-  // if error_state is set, we've already griped.
-  if (! error_state && ! retval.is_defined ())
+  if (! retval.is_defined ())
     {
       if (nidx == 2 && ! resize_ok && idx0.is_scalar () && idx1.is_scalar ())
         retval = matrix.checkelem (idx0(0), idx1(0));
       else
         retval = to_dense ().do_index_op (idx, resize_ok);
     }
 
   return retval;
diff --git a/libinterp/octave-value/ov-range.cc b/libinterp/octave-value/ov-range.cc
--- a/libinterp/octave-value/ov-range.cc
+++ b/libinterp/octave-value/ov-range.cc
@@ -128,23 +128,20 @@ octave_range::do_index_op (const octave_
       octave_value retval;
 
       // The range can handle a single subscript.
 
       try
         {
           idx_vector i = idx(0).index_vector ();
 
-          if (! error_state)
-            {
-              if (i.is_scalar () && i(0) < range.numel ())
-                retval = range.elem (i(0));
-              else
-                retval = range.index (i);
-            }
+          if (i.is_scalar () && i(0) < range.numel ())
+            retval = range.elem (i(0));
+          else
+            retval = range.index (i);
         }
       catch (index_exception& e)
         {
           // More info may be added later before displaying error.
 
           e.set_pos_if_unset (1, 1);
           throw;
         }
diff --git a/libinterp/octave-value/ov-re-diag.cc b/libinterp/octave-value/ov-re-diag.cc
--- a/libinterp/octave-value/ov-re-diag.cc
+++ b/libinterp/octave-value/ov-re-diag.cc
@@ -94,49 +94,45 @@ octave_diag_matrix::do_index_op (const o
     {
       int k = 0;        // index we're accesing when index_vector throws
       try
         {
           idx_vector idx0 = idx(0).index_vector ();
           k = 1;
           idx_vector idx1 = idx(1).index_vector ();
 
-          if (! error_state)
+          bool left = idx0.is_permutation (matrix.rows ());
+          bool right = idx1.is_permutation (matrix.cols ());
+
+          if (left && right)
             {
-              bool left = idx0.is_permutation (matrix.rows ());
-              bool right = idx1.is_permutation (matrix.cols ());
-
+              if (idx0.is_colon ()) left = false;
+              if (idx1.is_colon ()) right = false;
               if (left && right)
+                retval = PermMatrix (idx0, false) * PermMatrix (idx1, true);
+              else if (left)
+                retval = PermMatrix (idx0, false);
+              else if (right)
+                retval = PermMatrix (idx1, true);
+              else
                 {
-                  if (idx0.is_colon ()) left = false;
-                  if (idx1.is_colon ()) right = false;
-                  if (left && right)
-                    retval = PermMatrix (idx0, false) * PermMatrix (idx1, true);
-                  else if (left)
-                    retval = PermMatrix (idx0, false);
-                  else if (right)
-                    retval = PermMatrix (idx1, true);
-                  else
-                    {
-                      retval = this;
-                      this->count++;
-                    }
+                  retval = this;
+                  this->count++;
                 }
             }
         }
       catch (index_exception& e)
         {
           // Rethrow to allow more info to be reported later.
           e.set_pos_if_unset (2, k+1);
           throw;
         }
     }
 
-  // if error_state is set, we've already griped.
-  if (! error_state && retval.is_undefined ())
+  if (retval.is_undefined ())
     retval = octave_base_diag<DiagMatrix, Matrix>::do_index_op (idx, resize_ok);
 
   return retval;
 }
 
 DiagMatrix
 octave_diag_matrix::diag_matrix_value (bool) const
 {
@@ -234,18 +230,20 @@ octave_diag_matrix::load_binary (std::is
       swap_bytes<4> (&r);
       swap_bytes<4> (&c);
     }
 
   DiagMatrix m (r, c);
   double *re = m.fortran_vec ();
   octave_idx_type len = m.length ();
   read_doubles (is, re, static_cast<save_type> (tmp), len, swap, fmt);
-  if (error_state || ! is)
+
+  if (! is)
     return false;
+
   matrix = m;
 
   return true;
 }
 
 bool
 octave_diag_matrix::chk_valid_scalar (const octave_value& val,
                                       double& x) const
diff --git a/libinterp/octave-value/ov-re-mat.cc b/libinterp/octave-value/ov-re-mat.cc
--- a/libinterp/octave-value/ov-re-mat.cc
+++ b/libinterp/octave-value/ov-re-mat.cc
@@ -634,36 +634,40 @@ octave_matrix::load_binary (std::istream
 
       if (! is.read (reinterpret_cast<char *> (&tmp), 1))
         return false;
 
       NDArray m(dv);
       double *re = m.fortran_vec ();
       read_doubles (is, re, static_cast<save_type> (tmp), dv.numel (),
                     swap, fmt);
-      if (error_state || ! is)
+
+      if (! is)
         return false;
+
       matrix = m;
     }
   else
     {
       int32_t nr, nc;
       nr = mdims;
       if (! is.read (reinterpret_cast<char *> (&nc), 4))
         return false;
       if (swap)
         swap_bytes<4> (&nc);
       if (! is.read (reinterpret_cast<char *> (&tmp), 1))
         return false;
       Matrix m (nr, nc);
       double *re = m.fortran_vec ();
       octave_idx_type len = nr * nc;
       read_doubles (is, re, static_cast<save_type> (tmp), len, swap, fmt);
-      if (error_state || ! is)
+
+      if (! is)
         return false;
+
       matrix = m;
     }
   return true;
 }
 
 bool
 octave_matrix::save_hdf5 (octave_hdf5_id loc_id, const char *name, bool save_as_floats)
 {
@@ -959,17 +963,17 @@ octave_matrix::map (unary_mapper_t umap)
     case umap_xisprint:
     case umap_xispunct:
     case umap_xisspace:
     case umap_xisupper:
     case umap_xisxdigit:
     case umap_xtoascii:
       {
         octave_value str_conv = convert_to_str (true, true);
-        return error_state ? octave_value () : str_conv.map (umap);
+        return str_conv.map (umap);
       }
 
     default:
       return octave_base_value::map (umap);
     }
 }
 
 DEFUN (double, args, ,
diff --git a/libinterp/octave-value/ov-re-sparse.cc b/libinterp/octave-value/ov-re-sparse.cc
--- a/libinterp/octave-value/ov-re-sparse.cc
+++ b/libinterp/octave-value/ov-re-sparse.cc
@@ -382,17 +382,17 @@ octave_sparse_matrix::load_binary (std::
       m.xridx (i) = tmp;
     }
 
   if (! is.read (reinterpret_cast<char *> (&ctmp), 1))
     return false;
 
   read_doubles (is, m.xdata (), static_cast<save_type> (ctmp), nz, swap, fmt);
 
-  if (error_state || ! is)
+  if (! is)
     return false;
 
   if (! m.indices_ok ())
     return false;
 
   matrix = m;
 
   return true;
diff --git a/libinterp/octave-value/ov-scalar.cc b/libinterp/octave-value/ov-scalar.cc
--- a/libinterp/octave-value/ov-scalar.cc
+++ b/libinterp/octave-value/ov-scalar.cc
@@ -187,17 +187,18 @@ octave_scalar::load_binary (std::istream
                             oct_mach_info::float_format fmt)
 {
   char tmp;
   if (! is.read (reinterpret_cast<char *> (&tmp), 1))
     return false;
 
   double dtmp;
   read_doubles (is, &dtmp, static_cast<save_type> (tmp), 1, swap, fmt);
-  if (error_state || ! is)
+
+  if (! is)
     return false;
 
   scalar = dtmp;
   return true;
 }
 
 bool
 octave_scalar::save_hdf5 (octave_hdf5_id loc_id, const char *name,
@@ -368,17 +369,17 @@ octave_scalar::map (unary_mapper_t umap)
     case umap_xisprint:
     case umap_xispunct:
     case umap_xisspace:
     case umap_xisupper:
     case umap_xisxdigit:
     case umap_xtoascii:
       {
         octave_value str_conv = convert_to_str (true, true);
-        return error_state ? octave_value () : str_conv.map (umap);
+        return str_conv.map (umap);
       }
 
     default:
       return octave_base_value::map (umap);
     }
 }
 
 bool
diff --git a/libinterp/octave-value/ov-str-mat.cc b/libinterp/octave-value/ov-str-mat.cc
--- a/libinterp/octave-value/ov-str-mat.cc
+++ b/libinterp/octave-value/ov-str-mat.cc
@@ -63,23 +63,20 @@ static octave_base_value *
 default_numeric_conversion_function (const octave_base_value& a)
 {
   octave_base_value *retval = 0;
 
   CAST_CONV_ARG (const octave_char_matrix_str&);
 
   NDArray nda = v.array_value (true);
 
-  if (! error_state)
-    {
-      if (nda.numel () == 1)
-        retval = new octave_scalar (nda(0));
-      else
-        retval = new octave_matrix (nda);
-    }
+  if (nda.numel () == 1)
+    retval = new octave_scalar (nda(0));
+  else
+    retval = new octave_matrix (nda);
 
   return retval;
 }
 
 octave_base_value::type_conv_info
 octave_char_matrix_str::numeric_conversion_function (void) const
 {
   return octave_base_value::type_conv_info (default_numeric_conversion_function,
@@ -107,45 +104,42 @@ octave_char_matrix_str::do_index_op_inte
         case 0:
           retval = octave_value (matrix, type);
           break;
 
         case 1:
           {
             idx_vector i = idx (0).index_vector ();
 
-            if (! error_state)
-              retval = octave_value (charNDArray (matrix.index (i, resize_ok)),
-                                     type);
+            retval = octave_value (charNDArray (matrix.index (i, resize_ok)),
+                                   type);
           }
           break;
 
         case 2:
           {
             idx_vector i = idx (0).index_vector ();
             k = 1;
             idx_vector j = idx (1).index_vector ();
 
-            if (! error_state)
-              retval = octave_value (charNDArray (matrix.index (i, j, resize_ok)),
-                                     type);
+            retval = octave_value (charNDArray (matrix.index (i, j, resize_ok)),
+                                   type);
           }
           break;
 
         default:
           {
             Array<idx_vector> idx_vec (dim_vector (len, 1));
 
             for (k = 0; k < len; k++)
               idx_vec(k) = idx(k).index_vector ();
 
-            if (! error_state)
-              retval =
-                octave_value (charNDArray (matrix.index (idx_vec, resize_ok)),
-                              type);
+            retval =
+              octave_value (charNDArray (matrix.index (idx_vec, resize_ok)),
+                            type);
           }
           break;
         }
     }
   catch (index_exception& e)
     {
       // Rethrow to allow more info to be reported later.
       e.set_pos_if_unset (len, k+1);
@@ -438,18 +432,17 @@ octave_char_matrix_str::load_ascii (std:
                   else
                     {
                       error ("load: failed to extract string length for element %d",
                              i+1);
                       success = false;
                     }
                 }
 
-              if (! error_state)
-                matrix = chm;
+              matrix = chm;
             }
           else
             {
               error ("load: failed to extract number of string elements");
               success = false;
             }
         }
       else if (kw == "length")
@@ -550,18 +543,19 @@ octave_char_matrix_str::load_binary (std
           dv(1) = dv(0);
           dv(0) = 1;
         }
 
       charNDArray m(dv);
       char *tmp = m.fortran_vec ();
       is.read (tmp, dv.numel ());
 
-      if (error_state || ! is)
+      if (! is)
         return false;
+
       matrix = m;
     }
   else
     {
       charMatrix chm (elements, 0);
       int max_len = 0;
       for (int i = 0; i < elements; i++)
         {
diff --git a/libinterp/operators/op-bm-b.cc b/libinterp/operators/op-bm-b.cc
--- a/libinterp/operators/op-bm-b.cc
+++ b/libinterp/operators/op-bm-b.cc
@@ -71,18 +71,17 @@ oct_assignop_conv_and_assign (octave_bas
 {
   octave_bool_matrix& v1 = dynamic_cast<octave_bool_matrix&> (a1);
 
   // FIXME: perhaps add a warning for this conversion
   //        if the values are not all 0 or 1?
 
   boolNDArray v2 = a2.bool_array_value (true);
 
-  if (! error_state)
-    v1.assign (idx, v2);
+  v1.assign (idx, v2);
 
   return octave_value ();
 }
 
 void
 install_bm_b_ops (void)
 {
   INSTALL_BINOP (op_el_and, octave_bool_matrix, octave_bool, el_and);
diff --git a/libinterp/operators/op-bm-bm.cc b/libinterp/operators/op-bm-bm.cc
--- a/libinterp/operators/op-bm-bm.cc
+++ b/libinterp/operators/op-bm-bm.cc
@@ -115,18 +115,17 @@ oct_assignop_conv_and_assign (octave_bas
 {
   octave_bool_matrix& v1 = dynamic_cast<octave_bool_matrix&> (a1);
 
   // FIXME: perhaps add a warning for this conversion
   //        if the values are not all 0 or 1?
 
   boolNDArray v2 = a2.bool_array_value (true);
 
-  if (! error_state)
-    v1.assign (idx, v2);
+  v1.assign (idx, v2);
 
   return octave_value ();
 }
 
 DEFCONVFN (matrix_to_bool_matrix, matrix, bool)
 DEFCONVFN (scalar_to_bool_matrix, scalar, bool)
 
 void
diff --git a/libinterp/operators/op-sbm-b.cc b/libinterp/operators/op-sbm-b.cc
--- a/libinterp/operators/op-sbm-b.cc
+++ b/libinterp/operators/op-sbm-b.cc
@@ -92,18 +92,17 @@ oct_assignop_conv_and_assign (octave_bas
 {
   octave_sparse_bool_matrix& v1 = dynamic_cast<octave_sparse_bool_matrix&> (a1);
 
   // FIXME: perhaps add a warning for this conversion if the values
   // are not all 0 or 1?
 
   SparseBoolMatrix v2 (1, 1, a2.bool_value ());
 
-  if (! error_state)
-    v1.assign (idx, v2);
+  v1.assign (idx, v2);
 
   return octave_value ();
 }
 
 void
 install_sbm_b_ops (void)
 {
   INSTALL_BINOP (op_eq, octave_sparse_bool_matrix, octave_bool, eq);
diff --git a/libinterp/operators/op-sbm-bm.cc b/libinterp/operators/op-sbm-bm.cc
--- a/libinterp/operators/op-sbm-bm.cc
+++ b/libinterp/operators/op-sbm-bm.cc
@@ -98,18 +98,17 @@ oct_assignop_conv_and_assign (octave_bas
 {
   octave_sparse_bool_matrix& v1 = dynamic_cast<octave_sparse_bool_matrix&> (a1);
 
   // FIXME: perhaps add a warning for this conversion if the values
   // are not all 0 or 1?
 
   SparseBoolMatrix v2 (a2.bool_array_value ());
 
-  if (! error_state)
-    v1.assign (idx, v2);
+  v1.assign (idx, v2);
 
   return octave_value ();
 }
 
 void
 install_sbm_bm_ops (void)
 {
   INSTALL_BINOP (op_eq, octave_sparse_bool_matrix, octave_bool_matrix, eq);
diff --git a/libinterp/operators/op-str-m.cc b/libinterp/operators/op-str-m.cc
--- a/libinterp/operators/op-str-m.cc
+++ b/libinterp/operators/op-str-m.cc
@@ -35,18 +35,17 @@ along with Octave; see the file COPYING.
 DEFASSIGNOP (assign, char_matrix_str, octave_matrix)
 {
   CAST_BINOP_ARGS (octave_char_matrix_str&, const octave_matrix&);
 
   octave_value tmp
     = v2.convert_to_str_internal (false, false,
                                   a1.is_sq_string () ? '\'' : '"');
 
-  if (! error_state)
-    v1.assign (idx, tmp.char_array_value ());
+  v1.assign (idx, tmp.char_array_value ());
 
   return octave_value ();
 }
 
 DEFNDCHARCATOP_FN (str_m, char_matrix_str, matrix, concat)
 
 DEFNDCHARCATOP_FN (m_str, matrix, char_matrix_str, concat)
 
diff --git a/libinterp/operators/op-str-s.cc b/libinterp/operators/op-str-s.cc
--- a/libinterp/operators/op-str-s.cc
+++ b/libinterp/operators/op-str-s.cc
@@ -35,18 +35,17 @@ along with Octave; see the file COPYING.
 DEFASSIGNOP (assign, char_matrix_str, octave_scalar)
 {
   CAST_BINOP_ARGS (octave_char_matrix_str&, const octave_scalar&);
 
   octave_value tmp
     = v2.convert_to_str_internal (false, false,
                                   a1.is_sq_string () ? '\'' : '"');
 
-  if (! error_state)
-    v1.assign (idx, tmp.char_array_value ());
+  v1.assign (idx, tmp.char_array_value ());
 
   return octave_value ();
 }
 
 DEFNDCHARCATOP_FN (str_s, char_matrix_str, scalar, concat)
 
 DEFNDCHARCATOP_FN (s_str, scalar, char_matrix_str, concat)
 
diff --git a/libinterp/parse-tree/oct-parse.in.yy b/libinterp/parse-tree/oct-parse.in.yy
--- a/libinterp/parse-tree/oct-parse.in.yy
+++ b/libinterp/parse-tree/oct-parse.in.yy
@@ -4482,22 +4482,22 @@ source_file (const std::string& file_nam
       else if (context == "base")
         octave_call_stack::goto_base_frame ();
       else
         error ("source: context must be \"caller\" or \"base\"");
 
       frame.add_fcn (octave_call_stack::pop);
     }
 
-  octave_function *fcn;
+  octave_function *fcn = 0;
+
   try
     {
-      fcn = parse_fcn_file (file_full_name, file_name,
-                            "", "", require_file, true,
-                            false, false, warn_for);
+      fcn = parse_fcn_file (file_full_name, file_name, "", "",
+                            require_file, true, false, false, warn_for);
     }
   catch (const octave_execution_exception&)
     {
       error ("source: error sourcing file '%s'", file_full_name.c_str ());
     }
 
   if (fcn && fcn->is_user_script ())
     {
@@ -5085,32 +5085,29 @@ may be either @qcode{\"base\"} or @qcode
 
           if (context == "caller")
             octave_call_stack::goto_caller_frame ();
           else if (context == "base")
             octave_call_stack::goto_base_frame ();
           else
             error ("assignin: CONTEXT must be \"caller\" or \"base\"");
 
+          frame.add_fcn (octave_call_stack::pop);
+
+          std::string nm = args(1).string_value ();
+
           if (! error_state)
             {
-              frame.add_fcn (octave_call_stack::pop);
-
-              std::string nm = args(1).string_value ();
-
-              if (! error_state)
-                {
-                  if (valid_identifier (nm))
-                    symbol_table::assign (nm, args(2));
-                  else
-                    error ("assignin: invalid variable name in argument VARNAME");
-                }
+              if (valid_identifier (nm))
+                symbol_table::assign (nm, args(2));
               else
-                error ("assignin: VARNAME must be a string");
+                error ("assignin: invalid variable name in argument VARNAME");
             }
+          else
+            error ("assignin: VARNAME must be a string");
         }
       else
         error ("assignin: CONTEXT must be a string");
     }
   else
     print_usage ();
 
   return retval;
diff --git a/libinterp/parse-tree/pt-cbinop.cc b/libinterp/parse-tree/pt-cbinop.cc
--- a/libinterp/parse-tree/pt-cbinop.cc
+++ b/libinterp/parse-tree/pt-cbinop.cc
@@ -46,34 +46,26 @@ tree_compound_binary_expression::rvalue 
   return retval;
 }
 
 octave_value
 tree_compound_binary_expression::rvalue1 (int)
 {
   octave_value retval;
 
-  if (error_state)
-    return retval;
-
   if (op_lhs)
     {
       octave_value a = op_lhs->rvalue1 ();
 
-      if (! error_state && a.is_defined () && op_rhs)
+      if (a.is_defined () && op_rhs)
         {
           octave_value b = op_rhs->rvalue1 ();
 
-          if (! error_state && b.is_defined ())
-            {
-              retval = ::do_binary_op (etype, a, b);
-
-              if (error_state)
-                retval = octave_value ();
-            }
+          if (b.is_defined ())
+            retval = ::do_binary_op (etype, a, b);
         }
     }
 
   return retval;
 }
 
 // If a tree expression is a transpose or hermitian transpose, return
 // the argument and corresponding operator.
diff --git a/libinterp/parse-tree/pt-colon.cc b/libinterp/parse-tree/pt-colon.cc
--- a/libinterp/parse-tree/pt-colon.cc
+++ b/libinterp/parse-tree/pt-colon.cc
@@ -80,17 +80,17 @@ tree_colon_expression::rvalue (int nargo
   return retval;
 }
 
 octave_value
 tree_colon_expression::rvalue1 (int)
 {
   octave_value retval;
 
-  if (error_state || ! op_base || ! op_limit)
+  if (! op_base || ! op_limit)
     return retval;
 
   octave_value ov_base = op_base->rvalue1 ();
 
   if (error_state || ov_base.is_undefined ())
     eval_error ("invalid base value in colon expression");
   else
     {
@@ -116,46 +116,42 @@ tree_colon_expression::rvalue1 (int)
                 }
             }
           else
             {
               tmp1(1) = ov_limit;
               tmp1(0) = ov_base;
             }
 
-          if (!error_state)
+          octave_value fcn = symbol_table::find_function ("colon", tmp1);
+
+          if (fcn.is_defined ())
             {
-              octave_value fcn = symbol_table::find_function ("colon", tmp1);
+              octave_value_list tmp2 = fcn.do_multi_index_op (1, tmp1);
 
-              if (fcn.is_defined ())
-                {
-                  octave_value_list tmp2 = fcn.do_multi_index_op (1, tmp1);
-
-                  if (! error_state)
-                    retval = tmp2 (0);
-                }
-              else
-                error ("can not find overloaded colon function");
+              if (! error_state)
+                retval = tmp2 (0);
             }
+          else
+            error ("can not find overloaded colon function");
         }
       else
         {
           octave_value ov_increment = 1.0;
 
           if (op_increment)
             {
               ov_increment = op_increment->rvalue1 ();
 
               if (error_state || ov_increment.is_undefined ())
                 eval_error ("invalid increment value in colon expression");
             }
 
-          if (! error_state)
-            retval = do_colon_op (ov_base, ov_increment, ov_limit,
-                                  is_for_cmd_expr ());
+          retval = do_colon_op (ov_base, ov_increment, ov_limit,
+                                is_for_cmd_expr ());
         }
     }
 
   return retval;
 }
 
 void
 tree_colon_expression::eval_error (const std::string& s) const
diff --git a/libinterp/parse-tree/pt-decl.cc b/libinterp/parse-tree/pt-decl.cc
--- a/libinterp/parse-tree/pt-decl.cc
+++ b/libinterp/parse-tree/pt-decl.cc
@@ -51,22 +51,19 @@ tree_decl_elt::eval (void)
   bool retval = false;
 
   if (id && expr)
     {
       octave_lvalue ult = id->lvalue ();
 
       octave_value init_val = expr->rvalue1 ();
 
-      if (! error_state)
-        {
-          ult.assign (octave_value::op_asn_eq, init_val);
+      ult.assign (octave_value::op_asn_eq, init_val);
 
-          retval = true;
-        }
+      retval = true;
     }
 
   return retval;
 }
 
 tree_decl_elt *
 tree_decl_elt::dup (symbol_table::scope_id scope,
                     symbol_table::context_id context) const
diff --git a/libinterp/parse-tree/pt-exp.cc b/libinterp/parse-tree/pt-exp.cc
--- a/libinterp/parse-tree/pt-exp.cc
+++ b/libinterp/parse-tree/pt-exp.cc
@@ -37,24 +37,21 @@ along with Octave; see the file COPYING.
 
 bool
 tree_expression::is_logically_true (const char *warn_for)
 {
   bool expr_value = false;
 
   octave_value t1 = rvalue1 ();
 
-  if (! error_state)
-    {
-      if (t1.is_defined ())
-        return t1.is_true ();
-      else
-        error ("%s: undefined value used in conditional expression",
-               warn_for);
-    }
+  if (t1.is_defined ())
+    return t1.is_true ();
+  else
+    error ("%s: undefined value used in conditional expression",
+           warn_for);
 
   return expr_value;
 }
 
 octave_value
 tree_expression::rvalue1 (int)
 {
   error ("invalid rvalue function called in expression");
diff --git a/libinterp/parse-tree/pt-id.cc b/libinterp/parse-tree/pt-id.cc
--- a/libinterp/parse-tree/pt-id.cc
+++ b/libinterp/parse-tree/pt-id.cc
@@ -41,37 +41,32 @@ along with Octave; see the file COPYING.
 
 void
 tree_identifier::eval_undefined_error (void)
 {
   int l = line ();
   int c = column ();
 
   maybe_missing_function_hook (name ());
-  if (error_state)
-    return;
 
   if (l == -1 && c == -1)
     error_with_id ("Octave:undefined-function",
                    "'%s' undefined", name ().c_str ());
   else
     error_with_id ("Octave:undefined-function",
                    "'%s' undefined near line %d column %d",
                    name ().c_str (), l, c);
 }
 
 octave_value_list
 tree_identifier::rvalue (int nargout,
                          const std::list<octave_lvalue> *lvalue_list)
 {
   octave_value_list retval;
 
-  if (error_state)
-    return retval;
-
   octave_value val = sym->find ();
 
   if (val.is_defined ())
     {
       // GAGME -- this would be cleaner if we required
       // parens to indicate function calls.
       //
       // If this identifier refers to a function, we need to know
diff --git a/libinterp/parse-tree/pt-misc.cc b/libinterp/parse-tree/pt-misc.cc
--- a/libinterp/parse-tree/pt-misc.cc
+++ b/libinterp/parse-tree/pt-misc.cc
@@ -87,40 +87,37 @@ tree_parameter_list::validate (in_or_out
                      name.c_str ());
               break;
             }
           else
             dict.insert (name);
         }
     }
 
-  if (! error_state)
-    {
-      std::string va_type = (type == in ? "varargin" : "varargout");
+  std::string va_type = (type == in ? "varargin" : "varargout");
 
-      size_t len = length ();
+  size_t len = length ();
 
-      if (len > 0)
-        {
-          tree_decl_elt *elt = back ();
+  if (len > 0)
+    {
+      tree_decl_elt *elt = back ();
 
-          tree_identifier *id = elt->ident ();
+      tree_identifier *id = elt->ident ();
 
-          if (id && id->name () == va_type)
-            {
-              if (len == 1)
-                mark_varargs_only ();
-              else
-                mark_varargs ();
+      if (id && id->name () == va_type)
+        {
+          if (len == 1)
+            mark_varargs_only ();
+          else
+            mark_varargs ();
 
-              iterator p = end ();
-              --p;
-              delete *p;
-              erase (p);
-            }
+          iterator p = end ();
+          --p;
+          delete *p;
+          erase (p);
         }
     }
 
   return retval;
 }
 
 void
 tree_parameter_list::initialize_undefined_elements (const std::string& warnfor,
diff --git a/libinterp/parse-tree/pt-select.cc b/libinterp/parse-tree/pt-select.cc
--- a/libinterp/parse-tree/pt-select.cc
+++ b/libinterp/parse-tree/pt-select.cc
@@ -118,44 +118,35 @@ tree_switch_case::~tree_switch_case (voi
 }
 
 
 bool
 tree_switch_case::label_matches (const octave_value& val)
 {
   octave_value label_value = label->rvalue1 ();
 
-  if (! error_state && label_value.is_defined ())
+  if (label_value.is_defined ())
     {
       if (label_value.is_cell ())
         {
           Cell cell (label_value.cell_value ());
 
           for (octave_idx_type i = 0; i < cell.rows (); i++)
             {
               for (octave_idx_type j = 0; j < cell.columns (); j++)
                 {
                   bool match = val.is_equal (cell(i,j));
 
-                  if (error_state)
-                    return false;
-                  else if (match)
+                  if (match)
                     return true;
                 }
             }
         }
       else
-        {
-          bool match = val.is_equal (label_value);
-
-          if (error_state)
-            return false;
-          else
-            return match;
-        }
+        return val.is_equal (label_value);
     }
 
   return false;
 }
 
 tree_switch_case *
 tree_switch_case::dup (symbol_table::scope_id scope,
                        symbol_table::context_id context) const
diff --git a/libinterp/parse-tree/pt-unop.cc b/libinterp/parse-tree/pt-unop.cc
--- a/libinterp/parse-tree/pt-unop.cc
+++ b/libinterp/parse-tree/pt-unop.cc
@@ -57,55 +57,45 @@ tree_prefix_expression::rvalue (int narg
   return retval;
 }
 
 octave_value
 tree_prefix_expression::rvalue1 (int)
 {
   octave_value retval;
 
-  if (error_state)
-    return retval;
-
   if (op)
     {
       if (etype == octave_value::op_incr || etype == octave_value::op_decr)
         {
           octave_lvalue ref = op->lvalue ();
 
-          if (! error_state)
-            {
-              BEGIN_PROFILER_BLOCK (tree_prefix_expression)
+          BEGIN_PROFILER_BLOCK (tree_prefix_expression)
 
-              ref.do_unary_op (etype);
+          ref.do_unary_op (etype);
 
-              if (! error_state)
-                retval = ref.value ();
+          retval = ref.value ();
 
-              END_PROFILER_BLOCK
-            }
+          END_PROFILER_BLOCK
         }
       else
         {
           octave_value val = op->rvalue1 ();
 
-          if (! error_state && val.is_defined ())
+          if (val.is_defined ())
             {
-              BEGIN_PROFILER_BLOCK (tree_prefix_expression)
+               BEGIN_PROFILER_BLOCK (tree_prefix_expression)
 
               // Attempt to do the operation in-place if it is unshared
               // (a temporary expression).
               if (val.get_count () == 1)
                 retval = val.do_non_const_unary_op (etype);
               else
                 retval = ::do_unary_op (etype, val);
 
-              if (error_state)
-                retval = octave_value ();
-
               END_PROFILER_BLOCK
             }
         }
     }
 
   return retval;
 }
 
@@ -144,49 +134,40 @@ tree_postfix_expression::rvalue (int nar
   return retval;
 }
 
 octave_value
 tree_postfix_expression::rvalue1 (int)
 {
   octave_value retval;
 
-  if (error_state)
-    return retval;
-
   if (op)
     {
       if (etype == octave_value::op_incr || etype == octave_value::op_decr)
         {
           octave_lvalue ref = op->lvalue ();
 
-          if (! error_state)
-            {
-              retval = ref.value ();
+          retval = ref.value ();
+
+          BEGIN_PROFILER_BLOCK (tree_postfix_expression)
 
-              BEGIN_PROFILER_BLOCK (tree_postfix_expression)
+          ref.do_unary_op (etype);
 
-              ref.do_unary_op (etype);
-
-              END_PROFILER_BLOCK
-            }
+          END_PROFILER_BLOCK
         }
       else
         {
           octave_value val = op->rvalue1 ();
 
-          if (! error_state && val.is_defined ())
+          if (val.is_defined ())
             {
               BEGIN_PROFILER_BLOCK (tree_postfix_expression)
 
               retval = ::do_unary_op (etype, val);
 
-              if (error_state)
-                retval = octave_value ();
-
               END_PROFILER_BLOCK
             }
         }
     }
 
   return retval;
 }
 
