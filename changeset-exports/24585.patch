# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1513117850 18000
#      Tue Dec 12 17:30:50 2017 -0500
# Node ID 8a4aedbb3e5a06a4b5595dccdb58ab5c5cee6f87
# Parent  7a18e02a516e162022da2a1d6351bcbe082d326e
style fixes for variable editor

* variable-editor-model.h, variable-editor-model.cc,
variable-editor.h, variable-editor.cc: Style fixes.

diff --git a/libgui/src/variable-editor-model.cc b/libgui/src/variable-editor-model.cc
--- a/libgui/src/variable-editor-model.cc
+++ b/libgui/src/variable-editor-model.cc
@@ -1,13 +1,13 @@
 /*
 
+Copyright (C) 2013-2017 John W. Eaton
 Copyright (C) 2015 Michael Barnes
 Copyright (C) 2013 Rüdiger Sonderfeld
-Copyright (C) 2013 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software: you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation, either version 3 of the License, or (at your
 option) any later version.
 
@@ -36,48 +36,54 @@ along with Octave; see the file COPYING.
 
 #include "octave-qt-link.h"
 #include "variable-editor-model.h"
 
 #include "ov.h"
 #include "parse.h"
 #include "variables.h"
 
-/// Pimpl/Dpointer for variable_editor_model.
+// Pimpl/Dpointer for variable_editor_model.
+
 struct variable_editor_model::impl
 {
   struct cell
   {
     enum state_t
       {
         avail,
         notavail,
         pending,
         unset
       };
 
-    cell ()
+    cell (void)
       : m_state (unset)
     { }
 
     cell (state_t s)
       : m_state (s)
     { }
 
     cell (const QString& d, const QString& s, const QString& t,
           bool rse, sub_editor_types edtype)
       : m_state (avail), m_data (d), m_status_tip (s), m_tool_tip (t),
         m_requires_sub_editor (rse), m_editor_type (edtype)
     { }
 
     state_t m_state;
+
     QVariant m_data;
+
     QVariant m_status_tip;
+
     QVariant m_tool_tip;
+
     QVariant m_background;
+
     bool m_requires_sub_editor;
 
     sub_editor_types m_editor_type;
 
     // FIXME: Other variables needed?
   };
 
   void set (const QModelIndex& idx, const cell& dat)
@@ -89,53 +95,54 @@ struct variable_editor_model::impl
   void set (int r, int c, const cell& dat)
   {
     if (0 <= r && r < m_rows && 0 <= c && c <= columns ())
       m_table[c * m_rows + r] = dat;
   }
 
   bool is_set (const QModelIndex& idx) const
   {
-    return idx.isValid ()
-           && m_table[model_to_index (idx)].m_state == cell::avail;
+    return (idx.isValid ()
+            && m_table[model_to_index (idx)].m_state == cell::avail);
   }
 
   bool is_notavail (const QModelIndex& idx) const
   {
-    return idx.isValid ()
-           && m_table[model_to_index (idx)].m_state == cell::notavail;
+    return (idx.isValid ()
+            && m_table[model_to_index (idx)].m_state == cell::notavail);
   }
 
   bool is_pending (const QModelIndex& idx) const
   {
-    return idx.isValid ()
-           && m_table[model_to_index (idx)].m_state == cell::pending;
+    return (idx.isValid ()
+            && m_table[model_to_index (idx)].m_state == cell::pending);
   }
 
   void pending (const QModelIndex& idx)
   {
     if (idx.isValid ())
       m_table[model_to_index (idx)].m_state = cell::pending;
   }
 
   void notavail (int r, int c)
   {
     if (0 <= r && r < m_rows && 0 <= c && c <= columns ())
       m_table[c * m_rows + r].m_state = cell::notavail;
   }
 
   bool requires_sub_editor (const QModelIndex& idx)
   {
-    return idx.isValid ()
-           && m_table[model_to_index (idx)].m_requires_sub_editor;
+    return (idx.isValid ()
+            && m_table[model_to_index (idx)].m_requires_sub_editor);
   }
 
   sub_editor_types sub_editor_type (const QModelIndex& idx)
   {
-    return idx.isValid () ? m_table[model_to_index (idx)].m_editor_type : sub_none;
+    return (idx.isValid ()
+            ? m_table[model_to_index (idx)].m_editor_type : sub_none);
   }
 
   void unset (int r, int c)
   {
     if (0 <= r && r < m_rows && 0 <= c && c <= columns ())
       m_table[c * m_rows + r].m_state = cell::unset;
   }
 
@@ -145,29 +152,34 @@ struct variable_editor_model::impl
       m_table[i].m_state = cell::unset;
   }
 
   QVariant data (const QModelIndex& idx, int role) const
   {
     if (idx.isValid ())
       {
         const int i = model_to_index (idx);
+
         switch (role)
           {
           case Qt::DisplayRole:
           case Qt::EditRole:
             return m_table[i].m_data;
+
           case Qt::StatusTipRole:
             return m_table[i].m_status_tip;
+
           case Qt::ToolTipRole:
             return m_table[i].m_tool_tip;
+
           case Qt::BackgroundRole:
             return m_table[i].m_background;
           }
       }
+
     return QVariant ();
   }
 
   octave_idx_type rows (void) const { return m_rows; }
 
   octave_idx_type columns (void) const { return m_cols; }
 
   int model_to_index (const QModelIndex& idx) const
@@ -177,42 +189,53 @@ struct variable_editor_model::impl
 
   impl (const QString& n, QLabel *l)
     : m_name (n.toStdString ()), m_type (),
       m_rows (0), m_cols (0), m_table (), m_label (l),
       m_validity (true), m_validtext ()
   { }
 
   const std::string m_name;
+
   std::string m_type;
+
   octave_idx_type m_rows;
+
   octave_idx_type m_cols;
+
   QVector<cell> m_table;
+
   QLabel *m_label;
+
   bool m_validity;
+
   QString m_validtext;
 };
 
 variable_editor_model::variable_editor_model (const QString& expr,
                                               QLabel *label,
                                               QObject *parent)
   : QAbstractTableModel (parent), m_p (parent), m_d (new impl (expr, label))
 {
   connect (this, SIGNAL (data_ready (int, int, const QString&,
                                      const QString&,
                                      int, int)),
            this, SLOT (received_data (int, int, const QString&,
                                       const QString&,
                                       int, int)));
+
   connect (this, SIGNAL (no_data (int, int)),
            this, SLOT (received_no_data (int, int)));
+
   connect (this, SIGNAL (unset_data (int, int)),
            this, SLOT (received_unset_data (int, int)));
+
   connect (this, SIGNAL (user_error (const QString&, const QString&)),
            this, SLOT (received_user_error (const QString&, const QString&)));
+
   connect (this, SIGNAL (initialize_data (const QString&, const QString&,
                                           int, int)),
            this, SLOT (received_initialize_data (const QString&,
                                                  const QString&,
                                                  int, int)));
 
   clear_data_cache ();  // initializes everything
 }
@@ -248,95 +271,92 @@ bool variable_editor_model::editor_type_
 sub_editor_types variable_editor_model::editor_type (const QModelIndex& idx) const
 {
   return m_d->sub_editor_type (idx);
 }
 
 QString
 variable_editor_model::parens (void) const
 {
-  if (m_d->m_type == "{")
-    return "{%1, %2}";
-  else
-    return "(%1, %2)";
+  return m_d->m_type == "{" ? "{%1, %2}" : "(%1, %2)";
 }
 
 int
 variable_editor_model::rowCount (const QModelIndex&) const
 {
-  if (m_d->m_validity)
-    return m_d->rows ();
-
-  return 1;
+  return m_d->m_validity ? m_d->rows () : 1;
 }
 
 int
 variable_editor_model::columnCount (const QModelIndex&) const
 {
-  if (m_d->m_validity)
-    return m_d->columns ();
-
-  return 1;
+  return m_d->m_validity ? m_d->columns () : 1;
 }
 
 QVariant
 variable_editor_model::data (const QModelIndex& idx, int role) const
 {
   if (! m_d->m_validity)
     {
       if (idx.isValid ())
         {
           if (role == Qt::DisplayRole)
             return QVariant (QString ("Variable %d not found")
                              .arg (QString::fromStdString (m_d->m_name)));
         }
+
       return QVariant (QString ("x"));
     }
 
   if (idx.isValid ())
     {
       if (m_d->is_set (idx))
         return m_d->data (idx, role);
       else
         {
           if (! m_d->is_pending (idx))
             {
               octave_link::post_event<variable_editor_model,
                                       int, int, std::string>
                 (const_cast<variable_editor_model *> (this),
                  &variable_editor_model::get_data_oct,
                  idx.row (), idx.column (), m_d->m_name);
+
               m_d->pending (idx);
             }
+
           if (role == Qt::DisplayRole)
             return QVariant (QString (m_d->is_notavail (idx) ? "⌛" : "✗"));
           else
             return QVariant ();
         }
     }
 
-  return QVariant (); // invalid
+  // Invalid.
+  return QVariant ();
 }
 
 bool
 variable_editor_model::setData (const QModelIndex& idx, const QVariant& v,
                                 int role)
 {
   if (idx.isValid () && role == Qt::EditRole)
     {
       if (v.type () != QVariant::String)
         {
           qDebug () << v.typeName () << " Expected String!";
           return false;
         }
+
       octave_link::post_event<variable_editor_model,
                               std::string, int, int, std::string>
         (this, &variable_editor_model::set_data_oct,
          m_d->m_name, idx.row (), idx.column (),
          v.toString ().toStdString ());
+
       return true;
     }
   else
     return false;
 }
 
 bool
 variable_editor_model::insertRows (int row, int count, const QModelIndex&)
@@ -414,56 +434,61 @@ variable_editor_model::flags (const QMod
 {
   if (m_d->m_validity)
     {
       if (requires_sub_editor (idx))
         {
           if (editor_type (idx) != sub_string)
             return QAbstractTableModel::flags (idx);
         }
+
       return QAbstractTableModel::flags (idx) | Qt::ItemIsEditable;
-      //return requires_sub_editor(idx) ?  QAbstractTableModel::flags (idx) : QAbstractTableModel::flags (idx) | Qt::ItemIsEditable;
+
+      // FIXME: ???
+      // return requires_sub_editor(idx) ?  QAbstractTableModel::flags (idx) : QAbstractTableModel::flags (idx) | Qt::ItemIsEditable;
     }
 
   return Qt::NoItemFlags;
 }
 
-// private slots
+// Private slots.
 
 void
 variable_editor_model::received_data (int r, int c,
                                       const QString& dat,
                                       const QString& class_info,
                                       int rows, int cols)
 {
-  // trim data
+  // Trim data.
+
   const QString status_tip;
-  const QString tool_tip = class_info +
-                           QString (": %1x%2").arg (rows).arg (cols);
+
+  const QString tool_tip
+    = class_info + QString (": %1x%2").arg (rows).arg (cols);
 
   bool subedit = rows != 1 || cols != 1 || class_info == QString ("struct");
 
   sub_editor_types edittype;
-  if (!subedit)
+
+  if (! subedit)
     edittype = sub_none;
   else
     {
       if (class_info == QString ("char") && rows == 1)
         edittype = sub_string;
       else
         edittype = sub_matrix;
     }
+
   if (class_info == QString ("struct"))
     edittype = sub_struct;
 
-
-
   m_d->set (r, c, impl::cell (dat, status_tip, tool_tip,
-                              rows > 1 || cols > 1
-                              || class_info == QString ("struct"),
+                              (rows > 1 || cols > 1
+                               || class_info == QString ("struct")),
                               edittype));
 
   QModelIndex idx = QAbstractTableModel::index (r, c);
 
   emit dataChanged (idx, idx);
 }
 
 void
@@ -477,28 +502,27 @@ variable_editor_model::received_unset_da
 {
   m_d->unset (r, c);
 }
 
 void
 variable_editor_model::received_user_error (const QString& title,
                                             const QString& msg)
 {
-  QMessageBox::critical (0x0, title, msg);
+  QMessageBox::critical (nullptr, title, msg);
 }
 
 void
 variable_editor_model::received_initialize_data (const QString& class_name,
                                                  const QString& paren,
                                                  int rows, int cols)
 {
-  if (!(m_d->m_validity))
-  {
+  if (! (m_d->m_validity))
     return;
-  }
+
   m_d->m_type = paren.toStdString ();
 
   const int r = m_d->m_rows - rows;
   if (r > 0)
     emit beginRemoveRows (QModelIndex (), rows, m_d->m_rows - 1);
   else if (r < 0)
     emit beginInsertRows (QModelIndex (), m_d->m_rows, rows - 1);
 
@@ -519,39 +543,46 @@ variable_editor_model::received_initiali
     emit endInsertColumns ();
 
   if (r > 0)
     emit endRemoveRows ();
   else if (r < 0)
     emit endInsertRows ();
 
   emit dataChanged (QAbstractTableModel::index (0, 0),
-                    QAbstractTableModel::index (m_d->m_rows - 1, m_d->m_cols - 1));
+                    QAbstractTableModel::index (m_d->m_rows - 1,
+                                                m_d->m_cols - 1));
 
   m_d->m_label->setTextFormat (Qt::PlainText);
-  QString description = QString ("%1: %2 %3x%4")
-                        .arg (QString::fromStdString (m_d->m_name))
-                        .arg (class_name)
-                        .arg (rows)
-                        .arg (cols);
+
+  QString description
+    = (QString ("%1: %2 %3x%4")
+       .arg (QString::fromStdString (m_d->m_name))
+       .arg (class_name)
+       .arg (rows)
+       .arg (cols));
+
   m_d->m_label->setText (description);
+
   m_d->m_validtext = description;
 }
 
-// private
+// Private.
 
 void
 variable_editor_model::get_data_oct (const int& row, const int& col,
                                      const std::string& x)
 {
   int parse_status = 0;
 
   octave_value v = retrieve_variable (x, parse_status);
-  //eval_string (x, true, parse_status);//retrieve_variable(x, parse_status);
-  //symbol_exist(x,"var") > 0 ? eval_string (x, true, parse_status) : octave_value();
+
+  // FIXME: ???
+  // eval_string (x, true, parse_status);//retrieve_variable(x, parse_status);
+  // symbol_exist(x,"var") > 0 ? eval_string (x, true, parse_status) : octave_value();
 
   if (parse_status != 0 || ! v.is_defined ())
     {
       emit no_data (row, col);
       m_d->m_validity = false;
       return;
     }
   octave_value_list ovlidx = ovl (row + 1, col + 1);
@@ -572,59 +603,71 @@ variable_editor_model::get_data_oct (con
 
       emit data_ready (row, col, dat, cname, elem.rows (), elem.columns ());
     }
   else
     emit no_data (row, col);
 }
 
 // val has to be copied!
+
 void
 variable_editor_model::set_data_oct (const std::string& x,
                                      const int& row, const int& col,
                                      const std::string& val)
 {
   m_d->m_validity = true;
-  int parse_status = 0;
+
   // Accessing directly since
   // 1) retrieve_variable does not support writeback, and
   // 2) we can be reasonably sure that this variable exists.
+
+  int parse_status = 0;
+
   octave_value ret = octave::eval_string (val, true, parse_status);
-  //retrieve_variable(x, parse_status);//eval_string (val, true, parse_status);
+
+  // FIXME: ???
+  // retrieve_variable(x, parse_status);//eval_string (val, true, parse_status);
+
   if (parse_status != 0 || ret.is_undefined ())
     {
       emit user_error ("Invalid expression",
                        QString ("Expression `%1' invalid")
                        .arg (QString::fromStdString (val)));
       return;
     }
 
   parse_status = 0;
+
   octave_value v = retrieve_variable (x, parse_status);
-  //eval_string (x, true, parse_status);
+
+  // FIXME: ???
+  // eval_string (x, true, parse_status);
+
   if (parse_status != 0 || ! v.is_defined ())
     {
       m_d->m_validity = false;
       emit user_error ("Table invalid",
                        QString ("Table expression `%1' invalid")
                        .arg (QString::fromStdString (x)));
       return;
     }
 
   octave_value_list ovlidx = ovl (row + 1, col + 1);
   std::list<octave_value_list> idxl;
   idxl.push_back (ovlidx);
   v.subsasgn (m_d->m_type, idxl, ret);
   emit unset_data (row, col);
   QModelIndex idx = QAbstractTableModel::index (row, col);
+
   emit dataChanged (idx, idx);
 }
 
-// If the variable exists, load it into the data model.  If it doesn't exist,
-// flag the data model as referring to a nonexistent variable.
+// If the variable exists, load it into the data model.  If it doesn't
+// exist, flag the data model as referring to a nonexistent variable.
 // This allows the variable to be opened before it is created.
 octave_value
 variable_editor_model::retrieve_variable (const std::string& x,
                                           int& parse_status)
 {
   std::string name = x;
 
   if (x.back () == ')' || x.back () == '}')
@@ -638,55 +681,71 @@ variable_editor_model::retrieve_variable
   return octave_value ();
 }
 
 
 void
 variable_editor_model::init_from_oct (const std::string& x)
 {
   int parse_status = 0;
-  const octave_value ov = retrieve_variable (x, parse_status);//eval_string (x, true, parse_status);
+
+  const octave_value ov = retrieve_variable (x, parse_status);
+
+  // FIXME: ???
+  // eval_string (x, true, parse_status);
+
   m_d->m_validity = true;
+
   if (parse_status != 0 || ! ov.is_defined ())
     {
       m_d->m_validity = false;
       display_invalid ();
       return;
     }
+
   const QString class_name = QString::fromStdString (ov.class_name ());
   const QString paren = ov.iscell () ? "{" : "("; // FIXME: cells?
   const octave_idx_type rows = ov.rows ();
   const octave_idx_type cols = ov.columns ();
 
   display_valid ();
+
   emit initialize_data (class_name, paren, rows, cols);
 }
 
 void
 variable_editor_model::eval_oct (const std::string& name, const std::string& x)
 {
   int parse_status = 0;
+
   octave::eval_string (x, true, parse_status);
+
   if (parse_status != 0)
     emit user_error ("Evaluation failed",
                      QString ("Evaluation of `%s' failed")
                      .arg (QString::fromStdString (x)));
+
   init_from_oct (name);
 }
 
 void
 variable_editor_model::display_invalid (void)
 {
   m_d->m_label->setTextFormat (Qt::PlainText);
+
   QString description = QString ("%1: [not found or out-of-scope]")
                         .arg (QString::fromStdString (m_d->m_name));
+
   m_d->m_label->setText (description);
+
   dynamic_cast<QWidget *> (m_p)->setVisible (false);
 }
 
 void
 variable_editor_model::display_valid (void)
 {
   m_d->m_label->setTextFormat (Qt::PlainText);
+
   m_d->m_label->setText (m_d->m_validtext);
+
   dynamic_cast<QWidget *> (m_p)->setVisible (true);
 }
 
diff --git a/libgui/src/variable-editor-model.h b/libgui/src/variable-editor-model.h
--- a/libgui/src/variable-editor-model.h
+++ b/libgui/src/variable-editor-model.h
@@ -1,13 +1,13 @@
 /*
 
+Copyright (C) 2013-2017 John W. Eaton
 Copyright (C) 2015 Michael Barnes
 Copyright (C) 2013 Rüdiger Sonderfeld
-Copyright (C) 2013 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software: you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation, either version 3 of the License, or (at your
 option) any later version.
 
@@ -76,16 +76,17 @@ public:
 
   void clear_data_cache (void);
 
   // Is cell at idx complex enough to require a sub editor?
   bool requires_sub_editor (const QModelIndex& idx) const;
 
   // If a sub editor is required, is it a standard type?
   bool editor_type_matrix (const QModelIndex& idx) const;
+
   bool editor_type_string (const QModelIndex& idx) const;
 
   // Return the proper parens to access the data structure.
   // {%1,%2} for cell and (%1,%2) for matrices.
   QString parens (void) const;
 
 signals: // private
 
@@ -115,17 +116,18 @@ private slots:
   void received_user_error (const QString& title, const QString& msg);
 
   void received_initialize_data (const QString& class_name,
                                  const QString& paren, int rows, int cols);
 
 private:
 
   // Get data for ov(row, col).  This must be executed in the octave thread!
-  void get_data_oct (const int& row, const int& col, const std::string& v) /*const*/;
+  void get_data_oct (const int& row, const int& col,
+                     const std::string& v) /*const*/;
 
   void set_data_oct (const std::string& v, const int& row, const int& col,
                      const std::string& val);
 
   void init_from_oct (const std::string& x);
 
   void eval_oct (const std::string& name, const std::string& expr);
 
@@ -137,13 +139,15 @@ private:
 
   // Change the display if the variable does not exist (Yet)
   void display_invalid (void);
 
   // Change the display now that the variable exists
   void display_valid (void);
 
   QObject *m_p;
+
   struct impl;
+
   impl *m_d;
 };
 
 #endif
diff --git a/libgui/src/variable-editor.cc b/libgui/src/variable-editor.cc
--- a/libgui/src/variable-editor.cc
+++ b/libgui/src/variable-editor.cc
@@ -1,13 +1,13 @@
 /*
 
+Copyright (C) 2013-2017 John W. Eaton
 Copyright (C) 2015 Michael Barnes
 Copyright (C) 2013 Rüdiger Sonderfeld
-Copyright (C) 2013 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software: you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation, either version 3 of the License, or (at your
 option) any later version.
 
@@ -73,73 +73,70 @@ namespace
   table_data get_table_data (QTabWidget *w)
   {
     return get_table_data (w, w->currentIndex ());
   }
 }
 
 Q_DECLARE_METATYPE (table_data)
 
-static
-QString idx_to_expr (int32_t from, int32_t to)
+static QString
+idx_to_expr (int32_t from, int32_t to)
 {
-  if (from == to)
-    return QString ("%1").arg (from + 1);
-  else
-    return QString ("%1:%2").arg (from + 1).arg (to + 1);
+  return (from == to
+          ? QString ("%1").arg (from + 1)
+          : QString ("%1:%2").arg (from + 1).arg (to + 1));
 }
 
 variable_editor::variable_editor (QWidget *p)
-  : octave_dock_widget (p),
-    m_main (new QMainWindow ()),
+  : octave_dock_widget (p), m_main (new QMainWindow ()),
     m_tool_bar (new QToolBar (m_main)),
     m_tab_widget (new QTabWidget (m_main)),
-    m_default_width (20), m_default_height (100),
-    m_add_font_height (0),
-    m_autofit (false), m_autofit_max (false),
-    m_use_terminal_font (true), m_alternate_rows (true),
-    m_stylesheet (""), m_font (), m_sel_font (),
+    m_default_width (20), m_default_height (100), m_add_font_height (0),
+    m_autofit (false), m_autofit_max (false), m_use_terminal_font (true),
+    m_alternate_rows (true), m_stylesheet (""), m_font (), m_sel_font (),
     m_table_colors ()
 {
-  // Use a MainWindow
+  // Use a MainWindow.
   setObjectName ("variable_editor");
   set_title (tr ("Variable Editor"));
   setStatusTip (tr ("Edit variables."));
   setWindowIcon (QIcon (":/actions/icons/logo.png"));
 
-  // Tool Bar
+  // Tool Bar.
   construct_tool_bar ();
   m_main->addToolBar (m_tool_bar);
 
   for (int i = 0; i < resource_manager::varedit_color_chars ().length (); i++)
     m_table_colors.append (QColor (Qt::white));
 
-  // Tab Widget
+  // Tab Widget.
   m_tab_widget->setTabsClosable (true);
   m_tab_widget->setMovable (true);
   connect (m_tab_widget, SIGNAL (tabCloseRequested (int)),
            this, SLOT (closeTab (int)));
   m_main->setCentralWidget (m_tab_widget);
 
-  // Main
+  // Main.
   m_main->setParent (this);
   setWidget (m_main);
 
   connect (this, SIGNAL (command_requested (const QString&)),
            p, SLOT (execute_command_in_terminal (const QString&)));
 }
 
 variable_editor::~variable_editor (void)
 {
-  // m_tool_bar and m_tab_widget are contained within m_main
+  // m_tool_bar and m_tab_widget are contained within m_main.
   delete m_main;
 }
 
-// Returns the real variable name from the tab addressed by 'index',
+// Return the real variable name from the tab addressed by 'index',
 // cleaned of any '&' possibly inserted by KDE.
+
 QString
 variable_editor::real_var_name (int index)
 {
   QString var_name = m_tab_widget->tabText (index);
   var_name.remove (QChar ('&'));
   return var_name;
 }
 
@@ -149,21 +146,23 @@ variable_editor::edit_variable (const QS
   if (m_stylesheet.isEmpty ())
     {
       QSettings *settings = resource_manager::get_settings ();
       notice_settings (settings);
     }
 
   const int tab_count = m_tab_widget->count ();
   for (int i = 0; i < tab_count; ++i)
-    if (real_var_name (i) == name)
-      {
-        m_tab_widget->setCurrentIndex (i);
-        return;  // already open
-      }
+    {
+      if (real_var_name (i) == name)
+        {
+          m_tab_widget->setCurrentIndex (i);
+          return;  // Already open.
+        }
+    }
 
   QWidget *page = new QWidget;  // Do not set parent.
 
   QVBoxLayout *vbox = new QVBoxLayout (page);
   page->setLayout (vbox);
 
   QLabel *label = new QLabel (page);
   label->setTextFormat (Qt::PlainText);
@@ -181,113 +180,121 @@ variable_editor::edit_variable (const QS
 
 
   table->horizontalHeader ()->setContextMenuPolicy (Qt::CustomContextMenu);
   table->verticalHeader ()->setContextMenuPolicy (Qt::CustomContextMenu);
 
   connect (table->horizontalHeader (),
            SIGNAL (customContextMenuRequested (const QPoint&)),
            this, SLOT (columnmenu_requested (const QPoint&)));
+
   connect (table->verticalHeader (),
            SIGNAL (customContextMenuRequested (const QPoint&)),
            this, SLOT (rowmenu_requested (const QPoint&)));
+
   connect (table, SIGNAL (customContextMenuRequested (const QPoint&)),
            this, SLOT (contextmenu_requested (const QPoint&)));
+
   connect (table, SIGNAL (doubleClicked (const QModelIndex&)),
            this, SLOT (double_click (const QModelIndex&)));
+
   connect (model, SIGNAL (dataChanged (const QModelIndex&, const QModelIndex&)),
            this, SLOT (callUpdate (const QModelIndex&, const QModelIndex&)));
 
   vbox->addWidget (table);
 
   page->setProperty ("data", QVariant::fromValue (table_data (table)));
   int tab_idx = m_tab_widget->addTab (page, name);
   m_tab_widget->setCurrentIndex (tab_idx);
 
   if (m_tab_widget->count () == 1)
-    m_tool_bar->setEnabled (true);  // This is the first tab -> enable tool bar
+    m_tool_bar->setEnabled (true);  // This is the first tab -> enable tool bar.
 
   if (m_autofit)
     {
       table->resizeColumnsToContents ();
+
       if (m_autofit_max)
         {
           int mx = 0;
+
           for (int i = 0; i < table->model ()->columnCount (); i++)
             {
               if (table->columnWidth (i) > mx)
                 mx = table->columnWidth (i);
             }
+
           table->horizontalHeader ()->setDefaultSectionSize (mx);
         }
     }
   else
-    {
-      table->horizontalHeader ()->setDefaultSectionSize (m_default_width);
-    }
+    table->horizontalHeader ()->setDefaultSectionSize (m_default_width);
+
   table->setFont (m_font);
   table->setStyleSheet (m_stylesheet);
   table->setAlternatingRowColors (m_alternate_rows);
 #if defined (HAVE_QT4)
   table->verticalHeader ()->setResizeMode (QHeaderView::Interactive);
 #else
   table->verticalHeader ()->setSectionResizeMode (QHeaderView::Interactive);
 #endif
   table->verticalHeader ()->setDefaultSectionSize (m_default_height
                                                    + m_add_font_height);
 }
 
-void variable_editor::clear_data_cache (void)
+void
+variable_editor::clear_data_cache (void)
 {
   for (int i = 0; i < m_tab_widget->count (); ++i)
     {
       QTableView *const table = get_table_data (m_tab_widget, i).m_table;
       QAbstractItemModel *const model = table->model ();
       qobject_cast<variable_editor_model *> (model)->clear_data_cache ();
     }
 }
 
 bool
 variable_editor::has_focus (void)
 {
   // FIXME: This only generates exceptions in certain circumstances.
   //        Get a definitive list and eliminate the need to handle exceptions.
+
   if (m_tab_widget->currentIndex () == -1)
-    return false;  // No tabs
+    return false;  // No tabs.
 
   try
     {
       QTableView *view = get_table_data (m_tab_widget).m_table;
-      if (view)
-        return view->hasFocus ();
 
-      return false;
+      return view ? view->hasFocus () : false;
     }
   catch (...)
     {
       return false;
     }
 
   return false;
 }
 
-QList<QColor> variable_editor::default_colors (void)
+QList<QColor>
+variable_editor::default_colors (void)
 {
   QList<QColor> colorlist;
 
   colorlist << qApp->palette ().color (QPalette::WindowText);
   colorlist << qApp->palette ().color (QPalette::Base);
   colorlist << qApp->palette ().color (QPalette::HighlightedText);
   colorlist << qApp->palette ().color (QPalette::Highlight);
   colorlist << qApp->palette ().color (QPalette::AlternateBase);
 
   return colorlist;
 }
 
-QStringList variable_editor::color_names (void)
+QStringList
+variable_editor::color_names (void)
 {
   QStringList output;
 
   output << "Foreground";
   output << "Background";
   output << "Selected Foreground";
   output << "Selected Background";
   output << "Alternate Background";
@@ -296,53 +303,61 @@ QStringList variable_editor::color_names
 }
 
 void
 variable_editor::callUpdate (const QModelIndex&, const QModelIndex&)
 {
   if (m_autofit)
     {
       QTableView *view = get_table_data (m_tab_widget).m_table;
+
       view->resizeColumnsToContents ();
+
       if (m_autofit_max)
         {
           int mx = 0;
+
           for (int i = 0; i < view->model ()->columnCount (); i++)
             {
               if (view->columnWidth (i) > mx)
                 mx = view->columnWidth (i);
             }
+
           view->horizontalHeader ()->setDefaultSectionSize (mx);
         }
-
     }
 
   emit updated ();
 }
 
-void variable_editor::notice_settings (const QSettings *settings)
+void
+variable_editor::notice_settings (const QSettings *settings)
 {
   // FIXME: Why use object->tostring->toint?  Why not just 100?
   m_default_width = settings->value ("variable_editor/column_width",
                                      QVariant ("100")).toString ().toInt ();
+
   m_autofit = settings->value ("variable_editor/autofit_column_width",
                                QVariant (false)).toBool ();
+
   // FIXME: Magic Number 1 here, why not use enum?
   if (m_autofit)
     {
       if (settings->value ("variable_editor/autofit_type", 0).toInt () == 1)
         m_autofit_max = true;
     }
 
   m_default_height = settings->value ("variable_editor/row_height",
-                                    QVariant ("10")).toString ().toInt ();
+                                      QVariant ("10")).toString ().toInt ();
+
   m_alternate_rows = settings->value ("variable_editor/alternate_rows",
-                                    QVariant (false)).toBool ();
+                                      QVariant (false)).toBool ();
 
   QList<QColor> _default_colors = resource_manager::varedit_default_colors ();
+
   QString class_chars = resource_manager::varedit_color_chars ();
 
   m_use_terminal_font = settings->value ("variable_editor/use_terminal_font",
                                          true).toBool ();
 
   QString font_name;
   int font_size;
 
@@ -351,37 +366,41 @@ void variable_editor::notice_settings (c
       font_name = settings->value ("terminal/fontName", "Courier New").toString ();
       font_size = settings->value ("terminal/fontSize", 10).toInt ();
     }
   else
     {
       font_name = settings->value ("variable_editor/font_name", settings->value ("terminal/fontName", "Courier New")).toString ();
       font_size = settings->value ("variable_editor/font_size", 10).toInt ();
     }
+
   m_font = QFont (font_name, font_size);
 
   if (settings->value ("variable_editor/autofit_row_height", true).toBool ())
     {
       QFontMetrics fm (m_font);
+
       m_add_font_height = fm.height ();
     }
   else
     m_add_font_height = 0;
 
   for (int i = 0; i < class_chars.length (); i++)
     {
       QVariant default_var = _default_colors.at (i);
       QColor setting_color = settings->value ("variable_editor/color_"
                                               + class_chars.mid (i, 1),
                                               default_var).value<QColor> ();
+
       m_table_colors.replace (i, setting_color);
     }
+
   update_colors ();
 
-  // Icon size in the toolbar
+  // Icon size in the toolbar.
   int icon_size_settings = settings->value ("toolbar_icon_size", 0).toInt ();
   QStyle *st = style ();
   int icon_size = st->pixelMetric (QStyle::PM_ToolBarIconSize);
 
   // FIXME: Magic numbers.  Use enum?
   if (icon_size_settings == 1)
     icon_size = st->pixelMetric (QStyle::PM_LargeIconSize);
   else if (icon_size_settings == -1)
@@ -389,16 +408,17 @@ void variable_editor::notice_settings (c
 
   m_tool_bar->setIconSize (QSize (icon_size, icon_size));
 }
 
 void
 variable_editor::closeEvent (QCloseEvent *e)
 {
   emit finished ();
+
   octave_dock_widget::closeEvent (e);
 }
 
 void
 variable_editor::closeTab (int idx)
 {
   if (idx < 0 || idx > m_tab_widget->count ())
     return;
@@ -415,359 +435,386 @@ void
 variable_editor::contextmenu_requested (const QPoint& qpos)
 {
   QTableView *view = get_table_data (m_tab_widget).m_table;
   QModelIndex index = view->indexAt (qpos);
 
   if (index.isValid ())
     {
       QMenu *menu = new QMenu (this);
-      menu->addAction (resource_manager::icon ("edit-cut"), tr ("Cut"),
-                       this, SLOT (cutClipboard ()));
-      menu->addAction (resource_manager::icon ("edit-copy"), tr ("Copy"),
-                       this, SLOT (copyClipboard ()));
-      menu->addAction (resource_manager::icon ("edit-paste"), tr ("Paste"),
-                       this, SLOT (pasteClipboard ()));
+
+      menu->addAction (resource_manager::icon ("edit-cut"),
+                       tr ("Cut"), this, SLOT (cutClipboard ()));
+
+      menu->addAction (resource_manager::icon ("edit-copy"),
+                       tr ("Copy"), this, SLOT (copyClipboard ()));
+
+      menu->addAction (resource_manager::icon ("edit-paste"),
+                       tr ("Paste"), this, SLOT (pasteClipboard ()));
+
       // FIXME: need different icon for paste table separate from paste?
-      menu->addAction (resource_manager::icon ("edit-paste"), tr ("Paste Table"),
-                       this, SLOT (pasteTableClipboard ()));
+      menu->addAction (resource_manager::icon ("edit-paste"),
+                       tr ("Paste Table"), this,
+                       SLOT (pasteTableClipboard ()));
 
       menu->addSeparator ();
 
-      menu->addAction (resource_manager::icon ("edit-delete"), tr ("Clear"),
-                       this, SLOT (clearContent ()));
+      menu->addAction (resource_manager::icon ("edit-delete"),
+                       tr ("Clear"), this, SLOT (clearContent ()));
+
       menu->addAction (resource_manager::icon ("document-new"),
-                       tr ("Variable from Selection"),
-                       this, SLOT (createVariable ()));
+                       tr ("Variable from Selection"), this,
+                       SLOT (createVariable ()));
+
       // FIXME: addAction for sort?
       menu->addAction ( //QIcon (), FIXME: Add icon for transpose
-                       tr ("Transpose"),
-                       this, SLOT (transposeContent ()));
+                       tr ("Transpose"), this,
+                       SLOT (transposeContent ()));
 
       QItemSelectionModel *sel = view->selectionModel ();
+
       QList<QModelIndex> indices = sel->selectedIndexes ();
+
       if (! indices.isEmpty ())
         {
           menu->addSeparator ();
+
           QSignalMapper *plot_mapper = new QSignalMapper (menu);
-          plot_mapper->setMapping (menu->addAction ("plot",
-                                                    plot_mapper,
-                                                    SLOT (map ())),
-                                   "figure (); plot (%1);");
-          plot_mapper->setMapping (menu->addAction ("bar",
-                                                    plot_mapper,
-                                                    SLOT (map ())),
-                                   "figure (); bar (%1);");
-          plot_mapper->setMapping (menu->addAction ("stem",
-                                                    plot_mapper,
-                                                    SLOT (map ())),
-                                   "figure (); stem (%1);");
-          plot_mapper->setMapping (menu->addAction ("stairs",
-                                                    plot_mapper,
-                                                    SLOT (map ())),
-                                   "figure (); stairs (%1);");
-          plot_mapper->setMapping (menu->addAction ("area",
-                                                    plot_mapper,
-                                                    SLOT (map ())),
-                                   "figure (); area (%1);");
-          plot_mapper->setMapping (menu->addAction ("pie",
-                                                    plot_mapper,
-                                                    SLOT (map ())),
-                                   "figure (); pie (%1);");
-          plot_mapper->setMapping (menu->addAction ("hist",
-                                                    plot_mapper,
-                                                    SLOT (map ())),
-                                   "figure (); hist (%1);");
+
+          plot_mapper->setMapping
+            (menu->addAction ("plot", plot_mapper, SLOT (map ())),
+             "figure (); plot (%1);");
+
+          plot_mapper->setMapping
+            (menu->addAction ("bar", plot_mapper, SLOT (map ())),
+             "figure (); bar (%1);");
+
+          plot_mapper->setMapping
+            (menu->addAction ("stem", plot_mapper, SLOT (map ())),
+             "figure (); stem (%1);");
+
+          plot_mapper->setMapping
+            (menu->addAction ("stairs", plot_mapper, SLOT (map ())),
+             "figure (); stairs (%1);");
+
+          plot_mapper->setMapping
+            (menu->addAction ("area", plot_mapper, SLOT (map ())),
+             "figure (); area (%1);");
+
+          plot_mapper->setMapping
+            (menu->addAction ("pie", plot_mapper, SLOT (map ())),
+             "figure (); pie (%1);");
+
+          plot_mapper->setMapping
+            (menu->addAction ("hist", plot_mapper, SLOT (map ())),
+             "figure (); hist (%1);");
+
           connect (plot_mapper, SIGNAL (mapped (const QString&)),
                    this, SLOT (relay_command (const QString&)));
         }
 
       menu->exec (view->mapToGlobal (qpos));
     }
 }
 
 void
 variable_editor::columnmenu_requested (const QPoint& pt)
 {
   QTableView *view = get_table_data (m_tab_widget).m_table;
 
   int index = view->horizontalHeader ()->logicalIndexAt (pt);
 
-  //emit command_requested (QString ("disp ('") + QString::number (index) + "');");
+  // FIXME: what was the intent here?
+  // emit command_requested (QString ("disp ('") + QString::number (index) + "');");
 
   if (index < 0 || index > view->model ()->columnCount ())
     return;
 
   QString selection = selected_to_octave ();
+
   QList<int> coords = octave_to_coords (selection);
 
-  bool nothingSelected = false;
-  if (coords.isEmpty ())
-    nothingSelected = true;
+  bool nothingSelected = coords.isEmpty ();
 
-  bool whole_columns_selected =
-    nothingSelected ? false
-    : (coords[0] == 1
-       && coords[1] == view->model ()->rowCount ());
+  bool whole_columns_selected
+    =  (nothingSelected
+        ? false
+        : (coords[0] == 1 && coords[1] == view->model ()->rowCount ()));
 
-  bool current_column_selected =
-    nothingSelected ? false : (coords[2] <= index+1 && coords[3] > index);
+  bool current_column_selected
+    = nothingSelected ? false : (coords[2] <= index+1 && coords[3] > index);
 
-  int column_selection_count =
-    nothingSelected ? 0 : (coords[3] - coords[2] + 1);
+  int column_selection_count
+    = nothingSelected ? 0 : (coords[3] - coords[2] + 1);
 
   if (! whole_columns_selected || ! current_column_selected)
     {
       view->selectColumn (index);
       column_selection_count = 1;
       current_column_selected = true;
       whole_columns_selected = true;
     }
 
-  QString column_string = tr (column_selection_count > 1 ? " columns"
-                                                         : " column");
+  QString column_string
+    = tr (column_selection_count > 1 ? " columns" : " column");
 
   QMenu *menu = new QMenu (this);
+
   menu->addAction (resource_manager::icon ("edit-cut"),
                    tr ("Cut") + column_string,
                    this, SLOT (cutClipboard ()));
+
   menu->addAction (resource_manager::icon ("edit-copy"),
                    tr ("Copy") + column_string,
                    this, SLOT (copyClipboard ()));
+
   menu->addAction (resource_manager::icon ("edit-paste"),
                    tr ("Paste"),
                    this, SLOT (pasteClipboard ()));
+
   // FIXME: different icon for Paste Table?
   menu->addAction (resource_manager::icon ("edit-paste"),
                    tr ("Paste Table"),
                    this, SLOT (pasteTableClipboard ()));
 
   menu->addSeparator ();
 
   menu->addAction (resource_manager::icon ("edit-delete"),
                    tr ("Clear") + column_string,
                    this, SLOT (clearContent ()));
+
   menu->addAction (resource_manager::icon ("edit-delete"),
                    tr ("Delete") + column_string,
                    this, SLOT (delete_selected ()));
+
   menu->addAction (resource_manager::icon ("document-new"),
                    tr ("Variable from Selection"),
                    this, SLOT (createVariable ()));
 
   menu->addSeparator ();
 
   QSignalMapper *plot_mapper = new QSignalMapper (menu);
-  plot_mapper->setMapping (menu->addAction ("plot",
-                                            plot_mapper,
-                                            SLOT (map ())),
-                           "figure (); plot (%1);");
-  plot_mapper->setMapping (menu->addAction ("bar",
-                                            plot_mapper,
-                                            SLOT (map ())),
-                           "figure (); bar (%1);");
-  plot_mapper->setMapping (menu->addAction ("stem",
-                                            plot_mapper,
-                                            SLOT (map ())),
-                           "figure (); stem (%1);");
-  plot_mapper->setMapping (menu->addAction ("stairs",
-                                            plot_mapper,
-                                            SLOT (map ())),
-                           "figure (); stairs (%1);");
-  plot_mapper->setMapping (menu->addAction ("area",
-                                            plot_mapper,
-                                            SLOT (map ())),
-                           "figure (); area (%1);");
-  plot_mapper->setMapping (menu->addAction ("pie",
-                                            plot_mapper,
-                                            SLOT (map ())),
-                           "figure (); pie (%1);");
-  plot_mapper->setMapping (menu->addAction ("hist",
-                                            plot_mapper,
-                                            SLOT (map ())),
-                           "figure (); hist (%1);");
+
+  plot_mapper->setMapping
+    (menu->addAction ("plot", plot_mapper, SLOT (map ())),
+     "figure (); plot (%1);");
+
+  plot_mapper->setMapping
+    (menu->addAction ("bar", plot_mapper, SLOT (map ())),
+     "figure (); bar (%1);");
+
+  plot_mapper->setMapping
+    (menu->addAction ("stem", plot_mapper, SLOT (map ())),
+     "figure (); stem (%1);");
+
+  plot_mapper->setMapping
+    (menu->addAction ("stairs", plot_mapper, SLOT (map ())),
+     "figure (); stairs (%1);");
+
+  plot_mapper->setMapping
+    (menu->addAction ("area", plot_mapper, SLOT (map ())),
+     "figure (); area (%1);");
+
+  plot_mapper->setMapping
+    (menu->addAction ("pie", plot_mapper, SLOT (map ())),
+     "figure (); pie (%1);");
+
+  plot_mapper->setMapping
+    (menu->addAction ("hist", plot_mapper, SLOT (map ())),
+     "figure (); hist (%1);");
+
   connect (plot_mapper, SIGNAL (mapped (const QString&)),
            this, SLOT (relay_command (const QString&)));
 
   QPoint menupos = pt;
   menupos.setY (view->horizontalHeader ()->height ());
 
   menu->exec (view->mapToGlobal (menupos));
 }
 
 void
 variable_editor::rowmenu_requested (const QPoint& pt)
 {
   QTableView *view = get_table_data (m_tab_widget).m_table;
 
   int index = view->verticalHeader ()->logicalIndexAt (pt);
 
+  // FIXME: what was the intent here?
   //emit command_requested (QString ("disp ('") + QString::number (index) + "');");
 
   if (index < 0 || index > view->model ()->columnCount ())
     return;
 
   QString selection = selected_to_octave ();
+
   QList<int> coords = octave_to_coords (selection);
 
-  bool nothingSelected;
-  if (coords.isEmpty ())
-    nothingSelected = true;
-  else
-    nothingSelected = false;
+  bool nothingSelected = coords.isEmpty ();
 
-  bool whole_rows_selected =
-    nothingSelected ? false
-    : (coords[2] == 1
-       && coords[3] == view->model ()->columnCount ());
+  bool whole_rows_selected
+    = (nothingSelected
+       ? false
+       : (coords[2] == 1 && coords[3] == view->model ()->columnCount ()));
 
-  bool current_row_selected =
-    nothingSelected ? false
-    : (coords[0] <= index+1 && coords[1] > index);
+  bool current_row_selected
+    = (nothingSelected ? false : (coords[0] <= index+1 && coords[1] > index));
 
   int rowselection_count = nothingSelected ? 0 : (coords[3] - coords[2] + 1);
 
   if (! whole_rows_selected || ! current_row_selected)
     {
       view->selectRow (index);
       rowselection_count = 1;
       current_row_selected = true;
       whole_rows_selected = true;
     }
 
   QString row_string = tr (rowselection_count > 1 ? " rows" : " row");
 
   QMenu *menu = new QMenu (this);
+
   menu->addAction (resource_manager::icon ("edit-cut"),
                    tr ("Cut") + row_string,
                    this, SLOT (cutClipboard ()));
+
   menu->addAction (resource_manager::icon ("edit-copy"),
                    tr ("Copy") + row_string,
                    this, SLOT (copyClipboard ()));
+
   menu->addAction (resource_manager::icon ("edit-paste"),
                    tr ("Paste"),
                    this, SLOT (pasteClipboard ()));
+
   // FIXME: better icon for Paste Table?
   menu->addAction (resource_manager::icon ("edit-paste"),
                    tr ("Paste Table"),
                    this, SLOT (pasteTableClipboard ()));
 
   menu->addSeparator ();
 
   menu->addAction (resource_manager::icon ("edit-delete"),
                    tr ("Clear") + row_string,
                    this, SLOT (clearContent ()));
+
   menu->addAction (resource_manager::icon ("edit-delete"),
                    tr ("Delete") + row_string,
                    this, SLOT (delete_selected ()));
+
   menu->addAction (resource_manager::icon ("document-new"),
                    tr ("Variable from Selection"),
                    this, SLOT (createVariable ()));
 
   menu->addSeparator ();
 
   QSignalMapper *plot_mapper = new QSignalMapper (menu);
-  plot_mapper->setMapping (menu->addAction ("plot",
-                                            plot_mapper,
-                                            SLOT (map ())),
-                           "figure (); plot (%1);");
-  plot_mapper->setMapping (menu->addAction ("bar",
-                                            plot_mapper,
-                                            SLOT (map ())),
-                           "figure (); bar (%1);");
-  plot_mapper->setMapping (menu->addAction ("stem",
-                                            plot_mapper,
-                                            SLOT (map ())),
-                           "figure (); stem (%1);");
-  plot_mapper->setMapping (menu->addAction ("stairs",
-                                            plot_mapper,
-                                            SLOT (map ())),
-                           "figure (); stairs (%1);");
-  plot_mapper->setMapping (menu->addAction ("area",
-                                            plot_mapper,
-                                            SLOT (map ())),
-                           "figure (); area (%1);");
-  plot_mapper->setMapping (menu->addAction ("pie",
-                                            plot_mapper,
-                                            SLOT (map ())),
-                           "figure (); pie (%1);");
-  plot_mapper->setMapping (menu->addAction ("hist",
-                                            plot_mapper,
-                                            SLOT (map ())),
-                           "figure (); hist (%1);");
+
+  plot_mapper->setMapping
+    (menu->addAction ("plot", plot_mapper, SLOT (map ())),
+     "figure (); plot (%1);");
+
+  plot_mapper->setMapping
+    (menu->addAction ("bar", plot_mapper, SLOT (map ())),
+     "figure (); bar (%1);");
+
+  plot_mapper->setMapping
+    (menu->addAction ("stem", plot_mapper, SLOT (map ())),
+     "figure (); stem (%1);");
+
+  plot_mapper->setMapping
+    (menu->addAction ("stairs", plot_mapper, SLOT (map ())),
+     "figure (); stairs (%1);");
+
+  plot_mapper->setMapping
+    (menu->addAction ("area", plot_mapper, SLOT (map ())),
+     "figure (); area (%1);");
+
+  plot_mapper->setMapping
+    (menu->addAction ("pie", plot_mapper, SLOT (map ())),
+     "figure (); pie (%1);");
+
+  plot_mapper->setMapping
+    (menu->addAction ("hist", plot_mapper, SLOT (map ())),
+     "figure (); hist (%1);");
+
   connect (plot_mapper, SIGNAL (mapped (const QString&)),
            this, SLOT (relay_command (const QString&)));
 
   QPoint menupos = pt;
   menupos.setX (view->verticalHeader ()->width ());
   //setY (view->verticalHeader ()->sectionPosition (index+1) +
   //             view->verticalHeader ()->sectionSize (index));
 
   menu->exec (view->mapToGlobal (menupos));
 }
 
 void
 variable_editor::double_click (const QModelIndex& idx)
 {
   QString name = real_var_name (m_tab_widget->currentIndex ());
+
   QTableView *const table = get_table_data (m_tab_widget).m_table;
-  variable_editor_model *const model =
-    qobject_cast<variable_editor_model *> (table->model ());
+
+  variable_editor_model *const model
+    = qobject_cast<variable_editor_model *> (table->model ());
+
   if (model->requires_sub_editor (idx))
     {
       if (model ->editor_type_matrix (idx))
-        edit_variable (name +
-                       model->parens ()
-                       .arg (idx.row () + 1)
+        edit_variable (name + model->parens () .arg (idx.row () + 1)
                        .arg (idx.column () + 1));
+
       /*        emit command_requested ("openvar ('" + name +
                 model->parens ()
                 .arg (idx.row () + 1)
                 .arg (idx.column () + 1)
                 + "');");
       */
 
     }
 }
 
 void
 variable_editor::save (void)
 {
   QString name = real_var_name (m_tab_widget->currentIndex ());
-  QString file =
-    QFileDialog::getSaveFileName (this,
-                                  tr ("Save Variable %1 As").arg (name),
-                                  ".", 0, 0,
-                                  QFileDialog::DontUseNativeDialog);
+  QString file
+    = QFileDialog::getSaveFileName (this,
+                                    tr ("Save Variable %1 As").arg (name),
+                                    ".", 0, 0,
+                                    QFileDialog::DontUseNativeDialog);
+
   // FIXME: Type? binary, float-binary, ascii, text, hdf5, matlab format?
   if (! file.isEmpty ())
     // FIXME: Call octave_value::save_* directly?
     emit command_requested (QString ("save (\"%1\", \"%2\");")
                             .arg (file)
                             .arg (name));
 }
 
 void
 variable_editor::clearContent (void)
 {
   // FIXME: shift?
   QTableView *view = get_table_data (m_tab_widget).m_table;
   QAbstractItemModel *model = view->model ();
   QItemSelectionModel *sel = view->selectionModel ();
   QList<QModelIndex> indices = sel->selectedIndexes ();
+
   for (const auto& idx : indices)
     model->setData (idx, QVariant ("0"));  // FIXME: Use [] for empty cells
 }
 
 void
 variable_editor::cutClipboard (void)
 {
   if (! has_focus ())
     return;
 
   copyClipboard ();
+
   clearContent ();
 }
 
 void
 variable_editor::copyClipboard (void)
 {
   if (! has_focus ())
     return;
@@ -811,19 +858,17 @@ variable_editor::pasteClipboard (void)
   QList<QModelIndex> indices = sel->selectedIndexes ();
 
   variable_editor_model *model
     = static_cast<variable_editor_model *> (view->model ());
 
   if (indices.isEmpty ())
     {
       if (view->size () == QSize (1,1))
-        {
-          model->setData (view->model ()->index (0,0), text.toDouble ());
-        }
+        model->setData (view->model ()->index (0,0), text.toDouble ());
       else if (view->size () == QSize (0,0))
         {
           model->insertColumn (0);
           model->insertRow (0);
           model->setData (view->model ()->index (0,0), text.toDouble ());
         }
     }
   else
@@ -842,18 +887,18 @@ void variable_editor::pasteTableClipboar
 
   QClipboard *clipboard = QApplication::clipboard ();
   QString text = clipboard->text ();
 
   QTableView *view = get_table_data (m_tab_widget).m_table;
   QItemSelectionModel *sel = view->selectionModel ();
   QList<QModelIndex> indices = sel->selectedIndexes ();
 
-  variable_editor_model *model =
-    static_cast<variable_editor_model *> (view->model ());
+  variable_editor_model *model
+    = static_cast<variable_editor_model *> (view->model ());
 
   QPoint start, end;
 
   QPoint tabsize = QPoint (model->rowCount (), model->columnCount ());
 
   if (indices.isEmpty ())
     {
       start = QPoint (0,0);
@@ -877,17 +922,16 @@ void variable_editor::pasteTableClipboar
           if (indices[i].column () > end.y ())
             end.setY (indices[i].column ());
 
           if (indices[i].row () < start.x ())
             start.setX (indices[i].column ());
 
           if (indices[i].row () > end.x ())
             end.setX (indices[i].column ());
-
         }
     }
 
   int rownum = 0;
   int colnum = 0;
 
   QStringList rows = text.split ('\n');
   for (const auto& row : rows)
@@ -905,19 +949,20 @@ void variable_editor::pasteTableClipboar
             continue;
           if (colnum > end.y () - start.y () )
             continue;
 
           model->setData (model->index (rownum + start.x (),
                                         colnum + start.y ()),
                           QVariant (col));
 
-          //          relay_command ("disp ('" + QString::number (colnum+start.y ()) + "," + QString::number (rownum+start.x ()) +"');");
+          // relay_command ("disp ('" + QString::number (colnum+start.y ()) + "," + QString::number (rownum+start.x ()) +"');");
           colnum++;
         }
+
       colnum = 0;
       rownum++;
     }
 
   emit updated ();
 }
 
 void
@@ -926,24 +971,27 @@ variable_editor::createVariable (void)
   // FIXME: Create unnamed1..n if exist ('unnamed', 'var') is true.
   relay_command ("unnamed = %1");
 }
 
 void
 variable_editor::transposeContent (void)
 {
   QString name = real_var_name (m_tab_widget->currentIndex ());
+
   emit command_requested (QString ("%1 = %1';").arg (name));
+
   emit updated ();
 }
 
 void
 variable_editor::up (void)
 {
   QString name = real_var_name (m_tab_widget->currentIndex ());
+
   // FIXME: is there a better way?
   if (name.endsWith (')') || name.endsWith ('}'))
     {
       qDebug () << "up";
       name.remove (QRegExp ("(\\(|\\{)[^({]*(\\)|\\})$"));
       edit_variable (name);
       //emit command_requested (QString ("openvar ('%1');").arg (name));
     }
@@ -954,29 +1002,30 @@ variable_editor::delete_selected (void)
 {
   QTableView *view = get_table_data (m_tab_widget).m_table;
   QString selection = selected_to_octave ();
   QList<int> coords = octave_to_coords (selection);
 
   if (coords.isEmpty ())
     return;
 
-  bool whole_columns_selected = coords[0] == 1
-                                && coords[1] == view->model ()->rowCount ();
-  bool whole_rows_selected = coords[2] == 1
-                             && coords[3] == view->model ()->columnCount ();
+  bool whole_columns_selected
+    = coords[0] == 1 && coords[1] == view->model ()->rowCount ();
+
+  bool whole_rows_selected
+    = coords[2] == 1 && coords[3] == view->model ()->columnCount ();
 
   emit command_requested (QString ("disp ('")
                           + QString::number (coords[0]) + ","
                           + QString::number (coords[1]) + ","
                           + QString::number (coords[2]) + ","
                           + QString::number (coords[3]) + "');");
 
   // Must be deleting whole columns or whole rows, and not the whole thing.
-  if (whole_columns_selected == whole_rows_selected)  // all or nothing
+  if (whole_columns_selected == whole_rows_selected)
     return;
 
   if (whole_rows_selected)
     view->model ()->removeRows (coords[0], coords[1] - coords[0]);
 
   if (whole_columns_selected)
     view->model ()->removeColumns (coords[2], coords[3] - coords[2]);
 
@@ -990,32 +1039,34 @@ variable_editor::relay_command (const QS
 }
 
 QList<int>
 variable_editor::octave_to_coords (QString& selection)
 {
   // FIXME: Is this necessary or would it be quicker to clone the function
   //        that gives us the QString?
 
-  // sanity check
+  // Sanity check.
   if (selection.count (",") != 1)
     return QList<int> ();
 
   QList<int> output;
   output.clear ();  // FIXME: Why clear if object has just been created?
-  // remove braces
+
+  // Remove braces.
   int firstbracket = std::max (selection.indexOf ("("),
                                selection.indexOf ("{"));
+
   selection = selection.mid (firstbracket + 1,
                              selection.length () - (firstbracket + 2));
 
   QString rows = selection.left (selection.indexOf (","));
   if (! rows.contains (":"))
     {
-      // Only one row
+      // Only one row.
       output.push_back (rows.toInt ());
       output.push_back (output.last ());
     }
   else
     {
       output.push_back (rows.left (rows.indexOf (":")).toInt ());
       output.push_back (rows.right (rows.length () - (rows.indexOf (":") + 1))
                         .toInt ());
@@ -1023,17 +1074,17 @@ variable_editor::octave_to_coords (QStri
 
   QString cols;
   cols = selection.right (selection.length () - (selection.indexOf (",") + 1));
   if (cols.left (1) == " ")
     cols = cols.right (cols.length () - 1);
 
   if (! cols.contains (":"))
     {
-      // Only one row
+      // Only one row.
       output.push_back (cols.toInt ());
       output.push_back (output.last ());
     }
   else
     {
       output.push_back (cols.left (cols.indexOf (":")).toInt ());
       output.push_back (cols.right (cols.length () - (cols.indexOf (":") + 1))
                         .toInt ());
@@ -1047,17 +1098,17 @@ variable_editor::selected_to_octave (voi
 {
   QString name = real_var_name (m_tab_widget->currentIndex ());
   QTableView *view = get_table_data (m_tab_widget).m_table;
   QItemSelectionModel *sel = view->selectionModel ();
 
   if (! sel->hasSelection ())
     return name;  // Nothing selected
 
-  QList<QModelIndex> indices = sel->selectedIndexes ();  // it's indices!
+  QList<QModelIndex> indices = sel->selectedIndexes ();
 
   // FIXME: Shouldn't this be keyed to octave_idx_type?
   // If octave_idx_type is 64-bit then one could have 2^64,1 vector which
   // overflows int32_t type.
   int32_t from_row = std::numeric_limits<int32_t>::max ();
   int32_t to_row = 0;
   int32_t from_col = std::numeric_limits<int32_t>::max ();
   int32_t to_col = 0;
@@ -1068,38 +1119,46 @@ variable_editor::selected_to_octave (voi
       to_row = std::max (to_row, idx.row ());
       from_col = std::min (from_col, idx.column ());
       to_col = std::max (to_col, idx.column ());
     }
 
   QString rows = idx_to_expr (from_row, to_row);
   QString cols = idx_to_expr (from_col, to_col);
 
-  // FIXME: Do cell needs separate handling?  Maybe use '{.,.}'?
+  // FIXME: Does cell need separate handling?  Maybe use '{.,.}'?
   return QString ("%1(%2, %3)").arg (name).arg (rows).arg (cols);
 }
 
-/// Also updates the font
+/// Also updates the font.
 void variable_editor::update_colors (void)
 {
   m_stylesheet = "";
+
   m_stylesheet += "QTableView::item{ foreground-color: "
-                  + m_table_colors[0].name () +" }";
+    + m_table_colors[0].name () +" }";
+
   m_stylesheet += "QTableView::item{ background-color: "
-                  + m_table_colors[1].name () +" }";
+    + m_table_colors[1].name () +" }";
+
   m_stylesheet += "QTableView::item{ selection-color: "
-                  + m_table_colors[2].name () +" }";
+    + m_table_colors[2].name () +" }";
+
   m_stylesheet += "QTableView::item:selected{ background-color: "
-                  + m_table_colors[3].name () +" }";
+    + m_table_colors[3].name () +" }";
+
   if (m_table_colors.length () > 4 && m_alternate_rows)
     {
-      m_stylesheet += "QTableView::item:alternate{ background-color: "
-                      + m_table_colors[4].name () +" }";
-      m_stylesheet += "QTableView::item:alternate:selected{ background-color: "
-                      + m_table_colors[3].name () +" }";
+      m_stylesheet
+        += "QTableView::item:alternate{ background-color: "
+        + m_table_colors[4].name () +" }";
+
+      m_stylesheet
+        += "QTableView::item:alternate:selected{ background-color: "
+        + m_table_colors[3].name () +" }";
     }
 
   if (m_tab_widget->count () < 1)
     return;
 
   for (int i = 0; i < m_tab_widget->count (); i++)
     {
       QTableView *view = get_table_data (m_tab_widget).m_table;
@@ -1109,80 +1168,91 @@ void variable_editor::update_colors (voi
     }
 
 }
 
 void
 variable_editor::construct_tool_bar (void)
 {
   m_tool_bar->setObjectName ("VariableEditorToolBar");
+
   m_tool_bar->setWindowTitle (tr ("Variable Editor Toolbar"));
 
-  m_tool_bar->addAction (resource_manager::icon ("document-save"), tr ("Save"),
-                         this, SLOT (save ()));
+  m_tool_bar->addAction (resource_manager::icon ("document-save"),
+                         tr ("Save"), this, SLOT (save ()));
 
   m_tool_bar->addSeparator ();
 
-  m_tool_bar->addAction (resource_manager::icon ("edit-cut"), tr ("Cut"),
-                         this, SLOT (cutClipboard ()));
-  m_tool_bar->addAction (resource_manager::icon ("edit-copy"), tr ("Copy"),
-                         this, SLOT (copyClipboard ()));
-  m_tool_bar->addAction (resource_manager::icon ("edit-paste"), tr ("Paste"),
-                         this, SLOT (pasteClipboard ()));
+  m_tool_bar->addAction (resource_manager::icon ("edit-cut"),
+                         tr ("Cut"), this, SLOT (cutClipboard ()));
+
+  m_tool_bar->addAction (resource_manager::icon ("edit-copy"),
+                         tr ("Copy"), this, SLOT (copyClipboard ()));
+
+  m_tool_bar->addAction (resource_manager::icon ("edit-paste"),
+                         tr ("Paste"), this, SLOT (pasteClipboard ()));
+
   // FIXME: Different icon for Paste Table?
-  m_tool_bar->addAction (resource_manager::icon ("edit-paste"), tr ("Paste Table"),
+  m_tool_bar->addAction (resource_manager::icon ("edit-paste"),
+                         tr ("Paste Table"),
                          this, SLOT (pasteTableClipboard ()));
 
   m_tool_bar->addSeparator ();
 
   // FIXME: Add a print item?
   //QAction *print_action; /icons/fileprint.png
   //m_tool_bar->addSeparator ();
 
   QToolButton *plot_tool_button = new QToolButton (m_tool_bar);
   plot_tool_button->setText (tr ("Plot"));
   plot_tool_button->setIcon (resource_manager::icon ("plot-xy-curve"));
 
   plot_tool_button->setPopupMode (QToolButton::InstantPopup);
 
   QMenu *plot_menu = new QMenu (tr ("Plot"), plot_tool_button);
+
   plot_menu->setSeparatorsCollapsible (false);
+
   QSignalMapper *plot_mapper = new QSignalMapper (plot_menu);
-  plot_mapper->setMapping (plot_menu->addAction ("plot",
-                                                 plot_mapper,
-                                                 SLOT (map ())),
-                           "figure (); plot (%1);");
-  plot_mapper->setMapping (plot_menu->addAction ("bar",
-                                                 plot_mapper,
-                                                 SLOT (map ())),
-                           "figure (); bar (%1);");
-  plot_mapper->setMapping (plot_menu->addAction ("stem",
-                                                 plot_mapper,
-                                                 SLOT (map ())),
-                           "figure (); stem (%1);");
-  plot_mapper->setMapping (plot_menu->addAction ("stairs",
-                                                 plot_mapper,
-                                                 SLOT (map ())),
-                           "figure (); stairs (%1);");
-  plot_mapper->setMapping (plot_menu->addAction ("area",
-                                                 plot_mapper,
-                                                 SLOT (map ())),
-                           "figure (); area (%1);");
-  plot_mapper->setMapping (plot_menu->addAction ("pie",
-                                                 plot_mapper,
-                                                 SLOT (map ())),
-                           "figure (); pie (%1);");
-  plot_mapper->setMapping (plot_menu->addAction ("hist",
-                                                 plot_mapper,
-                                                 SLOT (map ())),
-                           "figure (); hist (%1);");
+
+  plot_mapper->setMapping
+    (plot_menu->addAction ("plot", plot_mapper, SLOT (map ())),
+     "figure (); plot (%1);");
+
+  plot_mapper->setMapping
+    (plot_menu->addAction ("bar", plot_mapper, SLOT (map ())),
+     "figure (); bar (%1);");
+
+  plot_mapper->setMapping
+    (plot_menu->addAction ("stem", plot_mapper, SLOT (map ())),
+     "figure (); stem (%1);");
+
+  plot_mapper->setMapping
+    (plot_menu->addAction ("stairs", plot_mapper, SLOT (map ())),
+     "figure (); stairs (%1);");
+
+  plot_mapper->setMapping
+    (plot_menu->addAction ("area", plot_mapper, SLOT (map ())),
+     "figure (); area (%1);");
+
+  plot_mapper->setMapping
+    (plot_menu->addAction ("pie", plot_mapper, SLOT (map ())),
+     "figure (); pie (%1);");
+
+  plot_mapper->setMapping
+    (plot_menu->addAction ("hist", plot_mapper, SLOT (map ())),
+     "figure (); hist (%1);");
+
   connect (plot_mapper, SIGNAL (mapped (const QString&)),
            this, SLOT (relay_command (const QString&)));
 
   plot_tool_button->setMenu (plot_menu);
+
   m_tool_bar->addWidget (plot_tool_button);
 
   m_tool_bar->addSeparator ();
+
   m_tool_bar->addAction (QIcon (resource_manager::icon ("go-up")), tr ("Up"),
                          this, SLOT (up ()));
 
-  m_tool_bar->setEnabled (false);  // Disabled when no tab is present
+  // Disabled when no tab is present.
+  m_tool_bar->setEnabled (false);
 }
diff --git a/libgui/src/variable-editor.h b/libgui/src/variable-editor.h
--- a/libgui/src/variable-editor.h
+++ b/libgui/src/variable-editor.h
@@ -1,13 +1,13 @@
 /*
 
+Copyright (C) 2013-2017 John W. Eaton
 Copyright (C) 2015 Michael Barnes
 Copyright (C) 2013 Rüdiger Sonderfeld
-Copyright (C) 2013 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software: you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation, either version 3 of the License, or (at your
 option) any later version.
 
@@ -43,86 +43,107 @@ class variable_editor : public octave_do
 public:
 
   variable_editor (QWidget *parent = nullptr);
 
   ~variable_editor (void);
 
   void edit_variable (const QString& name);
 
-  /// Clear all the models' data cache
+  // Clear all the models' data cache.
   void clear_data_cache (void);
 
   bool has_focus (void);
 
   static QList<QColor> default_colors (void);
+
   static QStringList color_names (void);
 
 public slots:
 
   void callUpdate (const QModelIndex&,const QModelIndex&);
 
   void notice_settings (const QSettings *);
 
 protected slots:
 
   void closeEvent (QCloseEvent *);
 
   void closeTab (int idx);
 
   void contextmenu_requested (const QPoint& pt);
+
   void columnmenu_requested (const QPoint& pt);
+
   void rowmenu_requested (const QPoint& pt);
 
   void double_click (const QModelIndex& idx);
 
   void save (void);
+
   void clearContent (void);
+
   void cutClipboard (void);
+
   void copyClipboard (void);
+
   void pasteClipboard (void);
+
   void pasteTableClipboard (void);
+
   void createVariable (void);
+
   void transposeContent (void);
+
   void up (void);
 
   void delete_selected (void);
 
   // Send command to Octave interpreter.
   // %1 in CMD is replaced with the value of selected_to_octave.
   void relay_command (const QString& cmd);
 
 signals:
 
   void updated (void);
+
   void finished (void);
+
   void command_requested (const QString& cmd);
 
 private:
 
   QMainWindow *m_main;
+
   QToolBar *m_tool_bar;
+
   QTabWidget *m_tab_widget;
 
   int m_default_width;
+
   int m_default_height;
+
   int m_add_font_height;
 
   bool m_autofit;
+
   bool m_autofit_max;
+
   bool m_use_terminal_font;
+
   bool m_alternate_rows;
 
   QString m_stylesheet;
 
   QFont m_font;
 
   // If use_terminal_font is true then this will be different since
   // "font" will contain the terminal font.
   QFont m_sel_font;
+
   QList<QColor> m_table_colors;
 
   QList<int> octave_to_coords (QString&);
 
   // Get the real variable name from the tab text
   QString real_var_name (int index);
 
   // Convert selection to an Octave expression.
