# HG changeset patch
# User Pantxo Diribarne <pantxo.diribarne@gmail.com>
# Date 1510913010 -3600
#      Fri Nov 17 11:03:30 2017 +0100
# Node ID 98d7a111786a1cc1e716563b6bcd19ca37a1d40b
# Parent  511295347a27f1964a0207c46f6ff100726bcca8
Add SVG convertion option for printing to PDF and raster outputs (bug #52193)

* print.m (docstring): Mark Gnuplot only devices with "*". For ps formats
  document the limited text support. Add "pdfcrop" device (no surrounding page)
  and remove "pdfwrite" from the examples of ghostscript devices.
  (print): in warnings, replace "print:" namespace by "octave:print:".
  Only change grid lines transparency for "ps2write" device. Add svgconvert_cmd
  field to opt structure
  (svgconvert): new function to build the svg convertion command

* __print_parse_opts__.m: In warnings, replace "print:" namespace by
  "octave:print:". Add svgconvert_binary to arg_st structure.
  (__svgconv_binary__): New function to locate the svg conversion binary either
  using OCTAVE_ARCHLIBDIR environment variable or in Octave's archlibdir.

* __opengl_print__.m: For other ghostscript devices than ps2write, first convert
 SVG to PDF and pass the PDF to ghostscript instead of an EPS.

* src/octave-svgconvert.cc: New file with the command line converter code.

* src/module.mk: Build converter based AMCOND_BUILD_QT_GUI condition. Setup
  related SOURCE, CPPFLAGS, LDADD, LDFLAGS variables with Qt headers and
  libraries.

* m4/acinclude.m4: Add QtXml to necessary Qt modules.

diff --git a/m4/acinclude.m4 b/m4/acinclude.m4
--- a/m4/acinclude.m4
+++ b/m4/acinclude.m4
@@ -1970,21 +1970,21 @@ AC_DEFUN([OCTAVE_CHECK_QT_VERSION], [AC_
   warn_qt_lib_fcns=""
   warn_qt_abstract_item_model=""
   warn_qt_opengl=""
 
   ## Check for Qt libraries
   case "$qt_version" in
     4)
       QT_OPENGL_MODULE="QtOpenGL"
-      QT_MODULES="QtCore QtGui QtNetwork QtHelp"
+      QT_MODULES="QtCore QtGui QtNetwork QtHelp QtXml"
     ;;
     5)
       QT_OPENGL_MODULE="Qt5OpenGL"
-      QT_MODULES="Qt5Core Qt5Gui Qt5Network Qt5PrintSupport Qt5Help"
+      QT_MODULES="Qt5Core Qt5Gui Qt5Network Qt5PrintSupport Qt5Help Qt5Xml"
     ;;
     *)
       AC_MSG_ERROR([Unrecognized Qt version $qt_version])
     ;;
   esac
 
   ## Use this check to get info in the log file.
   PKG_CHECK_MODULES(QT, [$QT_MODULES],
diff --git a/scripts/plot/util/print.m b/scripts/plot/util/print.m
--- a/scripts/plot/util/print.m
+++ b/scripts/plot/util/print.m
@@ -17,17 +17,17 @@
 ## <https://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {} {} print ()
 ## @deftypefnx {} {} print (@var{options})
 ## @deftypefnx {} {} print (@var{filename}, @var{options})
 ## @deftypefnx {} {} print (@var{h}, @var{filename}, @var{options})
 ## @deftypefnx {} {@var{rgb} = } print (@var{-RGBImage}, @dots{})
-## Format a figure and send it to a printer, save it to a file or
+## Format a figure for printing and send it to a printer, save it to a file or
 ## return an RGB image.
 ##
 ## @var{filename} defines the name of the output file.  If the filename has
 ## no suffix, one is inferred from the specified device and appended to the
 ## filename.  In absence of a filename or "-RGBImage" option, the output is
 ## sent to the printer.
 ## The filename and options can be given in any order.
 ##
@@ -178,32 +178,38 @@
 ##   Color or monochrome output.
 ##
 ## @item  -solid
 ## @itemx -dashed
 ##   Force all lines to be solid or dashed, respectively.
 ##
 ## @item -d@var{device}
 ##   The available output format is specified by the option @var{device}, and
-## is one of:
+## is one of (devices marked with a "*" are available only with Gnuplot
+## toolkit):
 ##
 ##   @table @code
 ##   @item  ps
 ##   @itemx ps2
 ##   @itemx psc
 ##   @itemx psc2
 ##     PostScript (level 1 and 2, mono and color).  The OpenGL-based toolkits
-## always generate PostScript level 3.0.
+## always generate PostScript level 3.0 and have a limited support for
+## text.
 ##
 ##   @item  eps
 ##   @itemx eps2
 ##   @itemx epsc
 ##   @itemx epsc2
 ##     Encapsulated PostScript (level 1 and 2, mono and color).  The
-## OpenGL-based toolkits always generate PostScript level 3.0.
+## OpenGL-based toolkits always generate PostScript level 3.0 and have a
+## limited support for text.  Only the set of ASCII characters may be
+## used and the only supported fonts are the base postscript fonts:
+## Helvetica (the default), Times, Courier and their variants (bold or
+## italic).  Any other font will be replaced by Helvetica.
 ##
 ##   @item  pslatex
 ##   @itemx epslatex
 ##   @itemx pdflatex
 ##   @itemx pslatexstandalone
 ##   @itemx epslatexstandalone
 ##   @itemx pdflatexstandalone
 ##     Generate a @LaTeX{} file @file{@var{filename}.tex} for the text
@@ -219,41 +225,40 @@
 ## @strong{exactly} as they were specified in the plot.  If any special
 ## characters of the @TeX{} mode interpreter were used, the file must be
 ## edited before @LaTeX{} processing.  Specifically, the special characters
 ## must be enclosed with dollar signs (@code{$ @dots{} $}), and other
 ## characters that are recognized by @LaTeX{} may also need editing (.e.g.,
 ## braces).  The @samp{pdflatex} device, and any of the @samp{standalone}
 ## formats, are not available with the Gnuplot toolkit.
 ##
-##   @item  epscairo
-##   @itemx pdfcairo
-##   @itemx epscairolatex
-##   @itemx pdfcairolatex
-##   @itemx epscairolatexstandalone
-##   @itemx pdfcairolatexstandalone
-##     Generate Cairo-based output when using the Gnuplot graphics toolkit.
-## The @samp{epscairo} and @samp{pdfcairo} devices are synonymous with
-## the @samp{epsc} device.  The @LaTeX{} variants generate a @LaTeX{} file,
-## @file{@var{filename}.tex}, for the text portions of a plot, and an image
-## file, @file{@var{filename}.(eps|pdf)}, for the graph portion of the plot.
-## The @samp{standalone} variants behave as described for
+##   @item  epscairo*
+##   @itemx pdfcairo*
+##   @itemx epscairolatex*
+##   @itemx pdfcairolatex*
+##   @itemx epscairolatexstandalone*
+##   @itemx pdfcairolatexstandalone*
+##     Generate Cairo based output.  The @samp{epscairo} and
+## @samp{pdfcairo} devices are synonymous with the @samp{epsc} device.
+## The @LaTeX{} variants generate a @LaTeX{} file,
+## @file{@var{filename}.tex}, for the text portions of a plot, and an
+## image file, @file{@var{filename}.(eps|pdf)}, for the graph portion of
+## the plot.  The @samp{standalone} variants behave as described for
 ## @samp{epslatexstandalone} above.
 ##
 ##   @item  ill
 ##   @itemx @nospell{aifm}
 ##     Adobe Illustrator (obsolete for Gnuplot versions > 4.2)
 ##
-##   @item canvas
-##     Javascript-based drawing on HTML5 canvas viewable in a web browser
-## (only available for the Gnuplot graphics toolkit).
+##   @item canvas*
+##     Javascript-based drawing on HTML5 canvas viewable in a web browser.
 ##
-##   @item  cdr
-##   @itemx @nospell{corel}
-##     @nospell{CorelDraw}
+##   @item  cdr*
+##   @itemx @nospell{corel*}
+##     CorelDraw.
 ##
 ##   @item cgm
 ##     Computer Graphics Metafile, Version 1, ANSI X3.122-1986
 ## (only available for the Gnuplot graphics toolkit).
 ##
 ##   @item dxf
 ##     AutoCAD
 ##
@@ -262,71 +267,72 @@
 ##     Microsoft Enhanced Metafile
 ##
 ##   @item fig
 ##     XFig.  For the Gnuplot graphics toolkit, the additional options
 ## @option{-textspecial} or @option{-textnormal} can be used to control
 ## whether the special flag should be set for the text in the figure.
 ## (default is @option{-textnormal})
 ##
-##   @item gif
-##     GIF image
-## (only available for the Gnuplot graphics toolkit).
+##   @item gif*
+##     GIF image.
 ##
 ##   @item hpgl
 ##     HP plotter language
 ##
 ##   @item  jpg
 ##   @itemx jpeg
 ##     JPEG image
 ##
-##   @item latex
-##   @itemx eepic
-##     @LaTeX{} picture environment and extended picture environment
-## (only available for the Gnuplot graphics toolkit).
+##   @item latex*
+##   @itemx eepic*
+##     @LaTeX{} picture environment and extended picture environment.
 ##
 ##   @item mf
 ##     Metafont
 ##
 ##   @item png
 ##     Portable Network Graphics
 ##
 ##   @item pbm
 ##     PBMplus
 ##
 ##   @item pdf
-##     Portable Document Format
+##   @itemx pdfcrop
+##     Portable Document Format. The @code{pdfcrop} device removes the default
+## surrounding page.
+##
+## By default PDF output has limited support for text and doesn't
+## support transparency at all.  For complete text support and basic
+## transparency, use the @code{-svgconvert} option.
 ##
 ##   @item svg
 ##     Scalable Vector Graphics
 ##
 ##   @item  tif
 ##   @itemx tiff
-##     TIFF image, compressed
+##   @itemx tiffn
+##     TIFF image with lzm compression (tif, tiff) or uncompressed (tiffn).
 ##
 ##   @item  tikz
-##   @itemx tikzstandalone
+##   @itemx tikzstandalone*
 ##     Generate a @LaTeX{} file using PGF/TikZ format.  The OpenGL-based
 ## toolkits create a PGF file while Gnuplot creates a TikZ file.  The
 ## @samp{tikzstandalone} device produces a @LaTeX{} document which includes the
-## TikZ file (@samp{tikzstandalone} and is only available for the Gnuplot
-## graphics toolkit).
+## TikZ file.
 ##   @end table
 ##
 ##   If the device is omitted, it is inferred from the file extension,
 ## or if there is no filename it is sent to the printer as PostScript.
 ##
 ## @item -d@var{ghostscript_device}
 ##   Additional devices are supported by Ghostscript.
 ## Some examples are;
 ##
 ##   @table @code
-##   @item pdfwrite
-##     Produces pdf output from eps
-##
 ##   @item ljet2p
 ##     HP LaserJet @nospell{IIP}
 ##
 ##   @item pcx24b
 ##     24-bit color PCX file format
 ##
 ##   @item ppm
 ##     Portable Pixel Map file format
@@ -339,16 +345,29 @@
 ## the figure's @qcode{"papersize"} property.  When the output is sent to a
 ## file the size is determined by the plot box defined by the figure's
 ## @qcode{"paperposition"} property.
 ##
 ## @item -G@var{ghostscript_command}
 ##   Specify the command for calling Ghostscript.  For Unix and Windows the
 ## defaults are @qcode{"gs"} and @qcode{"gswin32c"}, respectively.
 ##
+## @item -svgconvert
+##   For OpenGL based toolkits, this option adds support for printing
+## arbitrary characters and fonts in PDF outputs.  It also avoids some
+## antialiasing artifacts in patch and surface objects rendering.
+## Finally it adds support for printing transparent line, patch and surface 
+## objects.
+##
+## This option only affects PDF outputs, unless it is combined with
+## @code{-painters} option, in which case raster outputs are also affected.
+##
+## Caution: @code{-svgconvert} may lead to innacurate rendering of
+## image objects.
+##
 ## @item  -TextAlphaBits=@var{n}
 ## @itemx -GraphicsAlphaBits=@var{n}
 ##   Octave is able to produce output for various printers, bitmaps, and
 ## vector formats by using Ghostscript.  For bitmap and printer output
 ## anti-aliasing is applied using Ghostscript's TextAlphaBits and
 ## GraphicsAlphaBits options.  The default number of bits are 4 and 1
 ## respectively.  Allowed values for @var{N} are 1, 2, or 4.
 ## @end table
@@ -378,16 +397,17 @@ function rgbout = print (varargin)
     endif
   endif
 
   opts.pstoedit_cmd = @pstoedit;
   opts.fig2dev_cmd = @fig2dev;
   opts.latex_standalone = @latex_standalone;
   opts.lpr_cmd = @lpr;
   opts.epstool_cmd = @epstool;
+  opts.svgconvert_cmd = @svgconvert;
 
   if (isempty (opts.figure) || ! isfigure (opts.figure))
     error ("print: no figure to print");
   endif
 
   if (isempty (findall (opts.figure, "-depth", 1, "type", "axes")))
     error ("print: no axes object in figure to print");
   endif
@@ -448,22 +468,24 @@ function rgbout = print (varargin)
     for n = 1:numel (hax)
       props(end+1).h = hax(n);
       props(end).name = "units";
       props(end).value = {get(hax(n), "units")};
       set (hax(n), "units", "normalized");
       nfig += 1;
     endfor
 
-    ## FIXME: line transparency is only handled for svg output when
-    ## using gl2ps. For other formats, switch grid lines to light gray
-    ## so that the image output approximately matches on-screen experience.
+    ## With the -painters (gl2ps) renderer, line transparency is only
+    ## handled for svg and pdf outputs using svgconvert.
+    ## Otherwise, switch grid lines color to light gray so that the image 
+    ## output approximately matches on-screen experience.
     hax = findall (opts.figure, "type", "axes");
-    if (! strcmp (tk, "gnuplot") && ! strcmp (opts.devopt, "svg")
-        && ! strcmp (opts.renderer, "opengl"))
+    if (! strcmp (tk, "gnuplot") && ! strcmp (opts.renderer, "opengl")
+        && ! (opts.svgconvert && strcmp (opts.devopt, "pdfwrite"))
+        && ! strcmp (opts.devopt, "svg"))
       for n = 1:numel (hax)
         if (strcmp (get (hax(n), "gridcolormode"), "auto"))
           props(end+1).h = hax(n);
           props(end).name = "gridcolormode";
           props(end).value = {"auto"};
           props(end+1).h = hax(n);
           props(end).name = "gridcolor";
           props(end).value = {get(hax(n), "gridcolor")};
@@ -654,17 +676,18 @@ function rgbout = print (varargin)
         endif
       endfor
     endif
 
     ## Unlink temporary files
     for n = 1:numel (opts.unlink)
       [status, output] = unlink (opts.unlink{n});
       if (status != 0)
-        warning ("print.m: %s, '%s'", output, opts.unlink{n});
+        warning ("octave:print:unlinkerror", ...
+                 "print.m: %s, '%s'", output, opts.unlink{n});
       endif
     endfor
   end_unwind_protect
 
   if (isfigure (orig_figure))
     set (0, "currentfigure", orig_figure);
   endif
 
@@ -722,17 +745,17 @@ function cmd = epstool (opts, filein, fi
       cleanup = [cleanup, sprintf("; rm %s ", fileout)];
     endif
   else
     pipeout = false;
     fileout = ["'" strtrim(fileout) "'"];
   endif
 
   if (! isempty (opts.preview) && opts.tight_flag)
-    warning ("print:previewandtight",
+    warning ("octave:print:previewandtight",
              "print.m: eps preview may not be combined with -tight");
   endif
   if (! isempty (opts.preview) || opts.tight_flag)
 
     if (isempty (opts.epstool_binary))
       error ("print:noepstool", "print.m: 'epstool' is required for specified output format, but binary is not available in PATH");
     endif
 
@@ -959,8 +982,33 @@ function cmd = pstoedit (opts, devopt)
     cmd = sprintf ("%s -f %s 2> /dev/null", opts.pstoedit_binary, devopt);
   endif
 
   if (opts.debug)
     fprintf ("pstoedit command: '%s'\n", cmd);
   endif
 
 endfunction
+
+function cmd = svgconvert (opts, devopt)
+
+  cmd = "";
+
+  if (nargin < 2)
+    devopt = opts.devopt;
+  endif
+
+  if (isempty (opts.svgconvert_binary))
+    warning ("octave:print:nosvgconvert", ...
+             ["print.m: unale to find octave-svgconvert, ", ...
+              "falling back to eps convertion"]);
+  else
+    def_font = fullfile (__octave_config_info__ ("datadir"), "font", ...
+                         "FreeSans.otf");
+    cmd = sprintf ("%s - %%s %3.2f %s %d %%s", opts.svgconvert_binary, ...
+                   get (0, "screenpixelsperinch"), def_font, 1);
+
+    if (opts.debug)
+      fprintf ("svgconvert command: '%s'\n", cmd);
+    endif
+  endif
+
+endfunction
diff --git a/scripts/plot/util/private/__opengl_print__.m b/scripts/plot/util/private/__opengl_print__.m
--- a/scripts/plot/util/private/__opengl_print__.m
+++ b/scripts/plot/util/private/__opengl_print__.m
@@ -73,17 +73,25 @@ function opts = __opengl_print__ (opts)
       endif
     case "tikz"
       ## format GL2PS_PGF
       gl2ps_device = {"pgf"};
       pipeline = {sprintf("cat > %s", opts.name)};
     case "svg"
       ## format GL2PS_SVG
       gl2ps_device = {"svg"};
-      pipeline = {sprintf("cat > %s", opts.name)};
+      svgcmd = "";
+      if (opts.svgconvert)
+        svgcmd = opts.svgconvert_cmd (opts, opts.ghostscript.device);
+      endif
+      if (! isempty (svgcmd))
+        pipeline = {sprintf(svgcmd, "svg", opts.name)};
+      else
+        pipeline = {sprintf("cat > %s", opts.name)};
+      endif
     case fig2dev_devices
       cmd_pstoedit = opts.pstoedit_cmd (opts, "fig");
       cmd_fig2dev = opts.fig2dev_cmd (opts, opts.devopt);
       if (strcmp (opts.devopt, "pstex"))
         [~, ~, ext] = fileparts (opts.name);
         if (any (strcmpi (ext, {".ps", ".tex", "."})))
           opts.name = opts.name(1:end-numel(ext));
         endif
@@ -105,46 +113,73 @@ function opts = __opengl_print__ (opts)
       gl2ps_device = {"eps"};
       pipeline = {sprintf("%s > %s", cmd, opts.name)};
     case {"dxf", "emf", "fig", "hpgl"}
       cmd = opts.pstoedit_cmd (opts);
       gl2ps_device = {"eps"};
       pipeline = {sprintf("%s > %s", cmd, opts.name)};
     case {"corel", "gif"}
       error ("print:unsupporteddevice",
-             "print.m: %s output is not available for the FLTK graphics toolkit",
+             "print.m: %s output is not available for OpenGL graphics toolkits",
              upper (opts.devopt));
     case opts.ghostscript.device
-      opts.ghostscript.source = "-";
+      ## Except for postscript, use svg format and first convert to pdf
+      ## before going through ghostscript for final adjusments
+      svgcmd = "";
+      if (opts.svgconvert)
+        svgcmd = opts.svgconvert_cmd (opts, opts.ghostscript.device);
+      endif
+      dosvg = ! (strcmp (opts.devopt, "ps2write") || isempty (svgcmd));
+      if (! dosvg)
+        opts.ghostscript.source = "-";
+      else
+        tmp = tempname ();
+        opts.ghostscript.source = tmp;
+        opts.unlink = [opts.unlink tmp];
+        svgcmd = sprintf (svgcmd, "pdf", tmp);
+      endif
+
       opts.ghostscript.output = opts.name;
       if (opts.send_to_printer)
         opts.unlink(strcmp (opts.unlink, opts.ghostscript.output)) = [];
         opts.ghostscript.output = "-";
       endif
+
       [cmd_gs, cmd_cleanup] = __ghostscript__ (opts.ghostscript);
       if (opts.send_to_printer || isempty (opts.name))
         cmd_lpr = opts.lpr_cmd (opts);
         cmd = sprintf ("%s | %s", cmd_gs, cmd_lpr);
+      elseif (dosvg)
+        if (dos_shell)
+          cmd = sprintf ("%s & %s", svgcmd, cmd_gs);
+        else
+          cmd = sprintf ("%s ; %s", svgcmd, cmd_gs);
+        endif
       else
         cmd = sprintf ("%s", cmd_gs);
       endif
+
+      if (dosvg)
+        gl2ps_device = {"svg"};
+      else
+        gl2ps_device = {"eps"};
+      endif
+
       if (! isempty (cmd_cleanup))
-        gl2ps_device = {"eps"};
         if (dos_shell)
           pipeline = {sprintf("%s & %s", cmd, cmd_cleanup)};
         else
           pipeline = {sprintf("%s ; %s", cmd, cmd_cleanup)};
         endif
       else
-        gl2ps_device = {"eps"};
         pipeline = {cmd};
       endif
     otherwise
       error (sprintf ("print:no%soutput", opts.devopt),
-             "print.m: %s output is not available for GL2PS output",
+             "print.m: %s output is not available for OpenGL toolkits",
              upper (opts.devopt));
   endswitch
 
   opts.pipeline = pipeline;
 
   for n = 1:numel (pipeline)
     if (opts.debug)
       fprintf ("opengl-pipeline: '%s'\n", pipeline{n});
diff --git a/scripts/plot/util/private/__print_parse_opts__.m b/scripts/plot/util/private/__print_parse_opts__.m
--- a/scripts/plot/util/private/__print_parse_opts__.m
+++ b/scripts/plot/util/private/__print_parse_opts__.m
@@ -57,16 +57,18 @@ function arg_st = __print_parse_opts__ (
   arg_st.orientation = "";
   arg_st.pstoedit_binary = __quote_path__ (__find_binary__ ("pstoedit"));
   arg_st.preview = "";
   arg_st.printer = "";
   arg_st.renderer = "auto";
   arg_st.rgb_output = false;
   arg_st.send_to_printer = false;
   arg_st.special_flag = "textnormal";
+  arg_st.svgconvert = false;
+  arg_st.svgconvert_binary = __quote_path__ (__svgconv_binary__ ());
   arg_st.tight_flag = false;
   arg_st.use_color = 0; # 0=default, -1=mono, +1=color
 
   if (isunix ())
     arg_st.lpr_options = "-l";
   elseif (ispc ())
     arg_st.lpr_options = "-o l";
   else
@@ -102,16 +104,18 @@ function arg_st = __print_parse_opts__ (
       elseif (strncmp (arg, "-landscape", length (arg)))
         arg_st.orientation = "landscape";
       elseif (strcmp (arg, "-loose"))
         arg_st.loose = true;
         arg_st.tight_flag = false;
       elseif (strcmp (arg, "-tight"))
         arg_st.loose = false;
         arg_st.tight_flag = true;
+      elseif (strcmp (arg, "-svgconvert"))
+        arg_st.svgconvert = true;
       elseif (strcmp (arg, "-textspecial"))
         arg_st.special_flag = "textspecial";
       elseif (any (strcmp (arg,
                            {"-interchange", "-metafile", "-pict", "-tiff"})))
         arg_st.preview = arg(2:end);
       elseif (strncmp (arg, "-debug", 6))
         arg_st.debug = true;
         arg_st.ghostscript.debug = true;
@@ -157,59 +161,69 @@ function arg_st = __print_parse_opts__ (
         endif
       elseif (length (arg) > 2 && arg(1:2) == "-S")
         arg_st.canvas_size = str2double (strsplit (arg(3:end), ","));
       elseif (length (arg) > 2 && arg(1:2) == "-r")
         arg_st.ghostscript.resolution = str2double (arg(3:end));
       elseif (length (arg) > 2 && arg(1:2) == "-f")
         arg_st.figure = str2double (arg(3:end));
       elseif (strcmp (arg, "-noui"))
-        warning ("print: option '-noui' not yet implemented");
+        warning ("octave:ignoredargument", ...
+                 ["print: '%s' accepted for Matlab compatibility, ", ...
+                  "but is ignored."], arg);
       elseif (length (arg) >= 1 && arg(1) == "-")
         error ("print: unknown option '%s'", arg);
       elseif (length (arg) > 0)
         arg_st.name = tilde_expand (arg);
       endif
     elseif (isfigure (arg))
       arg_st.figure = arg;
     else
       error ("print: first argument must be string or figure handle");
     endif
   endfor
 
+  ## Resolution
   if (arg_st.ghostscript.resolution == 0)
     ## Do as Matlab does.
     arg_st.ghostscript.resolution = get (0, "screenpixelsperinch");
   endif
 
+  ## Orientation
   if (isempty (arg_st.orientation))
     if (isfigure (arg_st.figure))
       arg_st.orientation = get (arg_st.figure, "paperorientation");
     else
       ## Allows tests to be run without error.
       arg_st.orientation = "portrait";
     endif
   endif
 
+  ## The device is infered from extension if not provided
   dot = rindex (arg_st.name, ".");
   if (isempty (arg_st.devopt))
     if (arg_st.rgb_output)
       arg_st.devopt = "png";
     elseif (dot == 0)
       arg_st.devopt = "psc";
     else
       arg_st.devopt = tolower (arg_st.name(dot+1:end));
     endif
   endif
 
-  ## The opengl renderer is only available for raster outputs
+  ## By default, postprocess svg files using svgconvert.
+  if (strcmp (arg_st.devopt, "svg"))
+    arg_st.svgconvert = true;
+  endif
+
+  ## By default, use the "opengl" renderer for all raster outputs
+  ## supported by "imwrite".
   fmts = imformats ();
   persistent gl_devlist = [fmts(! cellfun (@isempty, {fmts.write})).ext, ...
                            "tiffn"];
-
   opengl_ok = any (strcmp (gl_devlist, arg_st.devopt));
 
   if (strcmp (arg_st.renderer, "auto")
       && strcmp (get (arg_st.figure, "renderermode"), "manual"))
     arg_st.renderer = get (arg_st.figure, "renderer");
   endif
 
   if (strcmp (arg_st.renderer, "auto"))
@@ -219,16 +233,17 @@ function arg_st = __print_parse_opts__ (
       arg_st.renderer = "painters";
     endif
   elseif (strcmp (arg_st.renderer, "opengl") && ! opengl_ok)
     arg_st.renderer = "painters";
     warning (["print: unsupported output format \"%s\" for renderer ", ...
               "\"opengl\"."], arg_st.devopt);
   endif
 
+  
   if (arg_st.use_color == 0)
     if (any (strcmp ({"ps", "ps2", "eps", "eps2"}, arg_st.devopt)))
       arg_st.use_color = -1;
     else
       arg_st.use_color = 1;
     endif
   endif
 
@@ -239,40 +254,42 @@ function arg_st = __print_parse_opts__ (
   elseif (strcmp (arg_st.devopt, "cdr"))
     arg_st.devopt = "corel";
   elseif (strcmp (arg_st.devopt, "meta"))
     arg_st.devopt = "emf";
   elseif (strcmp (arg_st.devopt, "jpg"))
     arg_st.devopt = "jpeg";
   elseif (strcmp (arg_st.devopt, "tif"))
     arg_st.devopt = "tiff";
+  elseif (strcmp (arg_st.devopt, "pdfcrop"))
+    arg_st.devopt = "pdfwrite";
   endif
 
   persistent dev_list = [{"aifm", "corel", "fig", "png", "jpeg", ...
               "gif", "pbm", "pbmraw", "dxf", "mf", ...
               "svg", "hpgl", "ps", "ps2", "psc", ...
               "psc2", "eps", "eps2", "epsc", "epsc2", ...
               "emf", "pdf", "pslatex", "epslatex", "epslatexstandalone", ...
               "pslatexstandalone", "pdflatexstandalone", ...
-              "pstex", "tiff", "tiffn" "tikz", "pcxmono", ...
+              "pstex", "tiff", "tiffn", "tikz", "tikzstandalone", "pcxmono", ...
               "pcx24b", "pcx256", "pcx16", "pgm", "pgmraw", ...
               "ppm", "ppmraw", "pdflatex", "texdraw", ...
               "epscairo", "pdfcairo", "pngcairo", "cairolatex", ...
               "pdfcairolatex", "pdfcairolatexstandalone", ...
               "epscairolatex", "epscairolatexstandalone", "pstricks", ...
               "epswrite", "eps2write", "pswrite", "ps2write", "pdfwrite", ...
               "canvas", "cgm", "latex", "eepic"}, gl_devlist];
 
   persistent suffixes = [{"ai", "cdr", "fig", "png", "jpg", ...
               "gif", "pbm", "pbm", "dxf", "mf", ...
               "svg", "hpgl", "ps", "ps", "ps", ...
               "ps", "eps", "eps", "eps", "eps", ...
               "emf", "pdf", "tex", "tex", "tex", ...
               "tex", "tex", ...
-              "ps", "tiff", "tiff", "tikz", "pcx", ...
+              "ps", "tiff", "tiff", "tikz", "tikz", "pcx", ...
               "pcx", "pcx", "pcx", "pgm", "pgm", ...
               "ppm", "ppm", "tex", "tex", ...
               "eps", "pdf", "png", "tex", ...
               "tex", "tex", ...
               "tex", "tex", "tex", ...
               "eps", "eps", "ps", "ps", "pdf", ...
               "js", "cgm", "tex", "tex"}, gl_devlist];
 
@@ -418,17 +435,18 @@ function arg_st = __print_parse_opts__ (
   else
     arg_st.ghostscript.papersize = "";
     arg_st.ghostscript.pageoffset = [0, 0];
   endif
 
   if (warn_on_missing_ghostscript)
     if (isempty (arg_st.ghostscript.binary))
       warning ("octave:print:missing_gs", ...
-               "print.m: Ghostscript binary is not available.  Only eps output is possible");
+               ["print.m: Ghostscript binary is not available.  ", ...
+                "Only eps output is possible"]);
     endif
     warn_on_missing_ghostscript = false;
   endif
 
 endfunction
 
 
 ## Test blocks are not allowed (and not needed) for private functions
@@ -501,29 +519,28 @@ function cmd = __quote_path__ (cmd)
       if (any (cmd == " "))
         cmd = ['"' strrep(cmd, '"', '""') '"'];
       endif
     endif
   endif
 
 endfunction
 
-
 function gs = __ghostscript_binary__ ()
 
   persistent ghostscript_binary = "";
   persistent warn_on_bad_gsc = true;
 
   if (isempty (ghostscript_binary))
     GSC = getenv ("GSC");
     if (exist (GSC, "file")
         || (! isempty (GSC) && file_in_path (getenv ("PATH"), GSC)))
       gs_binaries = {GSC};
     elseif (! isempty (GSC) && warn_on_bad_gsc)
-      warning ("print:badgscenv",
+      warning ("octave:print:badgscenv",
                "print.m: GSC environment variable not set properly");
       warn_on_bad_gsc = false;
       gs_binaries = {};
     else
       gs_binaries = {};
     endif
 
     if (isunix ())
@@ -539,16 +556,42 @@ function gs = __ghostscript_binary__ ()
       ghostscript_binary = file_in_path (getenv ("PATH"), gs_binaries{++n});
     endwhile
   endif
 
   gs = ghostscript_binary;
 
 endfunction
 
+function bin = __svgconv_binary__ ()
+
+  persistent binary = "";
+
+  if (isempty (binary))
+    bindir = getenv ("OCTAVE_ARCHLIBDIR");
+    if (isempty (bindir))
+      bindir = __octave_config_info__ ("archlibdir");
+    endif
+    
+    binary = fullfile (bindir, "octave-svgconvert");
+
+    if (! exist (binary, "file"))
+      if (! isunix () && exist ([binary, ".exe"], "file"))
+        ## Unix - Includes Mac OSX and Cygwin.
+        binary = [binary, ".exe"];
+      else
+        binary = "";
+      endif
+    endif
+  endif
+
+  bin = binary;
+
+endfunction
+
 function bin = __find_binary__ (binary)
 
   persistent data = struct ();
 
   if (! isfield (data, binary))
     data.(binary).bin = "";
   endif
 
diff --git a/src/module.mk b/src/module.mk
--- a/src/module.mk
+++ b/src/module.mk
@@ -44,16 +44,21 @@ OCTAVE_VERSION_LINKS += %reldir%/octave-
 
 if AMCOND_BUILD_QT_GUI
   archlib_PROGRAMS += %reldir%/octave-gui
   OCTAVE_VERSION_LINKS += %reldir%/octave-gui-$(version)$(EXEEXT)
 
   OCTAVE_INTERPRETER_TARGETS += %reldir%/octave-gui$(EXEEXT)
 endif
 
+if AMCOND_BUILD_QT_GUI
+  archlib_PROGRAMS += %reldir%/octave-svgconvert
+  OCTAVE_INTERPRETER_TARGETS += %reldir%/octave-svgconvert$(EXEEXT)
+endif
+
 OCTAVE_CORE_LIBS = \
   libinterp/liboctinterp.la \
   liboctave/liboctave.la \
   libgnu/libgnu.la
 
 nodist_%canon_reldir%_octave_SOURCES = %reldir%/main.cc
 
 %canon_reldir%_octave_SOURCES = %reldir%/display-available.c
@@ -110,16 +115,24 @@ endif
   $(OCTAVE_CORE_LIBS) \
   $(OCTAVE_GUI_LINK_DEPS)
 
 %canon_reldir%_octave_gui_LDFLAGS = \
   $(NO_UNDEFINED_LDFLAG) \
   $(OCTAVE_GUI_LINK_OPTS) \
   $(WARN_LDFLAGS)
 
+%canon_reldir%_octave_svgconvert_SOURCES = %reldir%/octave-svgconvert.cc
+
+%canon_reldir%_octave_svgconvert_CPPFLAGS = $(QT_CPPFLAGS)
+
+%canon_reldir%_octave_svgconvert_LDADD = $(QT_LIBS)
+
+%canon_reldir%_octave_svgconvert_LDFLAGS = $(QT_LDFLAGS)
+
 %canon_reldir%_mkoctfile_SOURCES =
 
 nodist_%canon_reldir%_mkoctfile_SOURCES = %reldir%/mkoctfile.cc
 
 %canon_reldir%_mkoctfile_LDADD = \
   liboctave/wrappers/libwrappers.la \
   libgnu/libgnu.la $(LIBS)
 
diff --git a/src/octave-svgconvert.cc b/src/octave-svgconvert.cc
new file mode 100644
--- /dev/null
+++ b/src/octave-svgconvert.cc
@@ -0,0 +1,851 @@
+/*
+Copyright (C) 2017 Pantxo Diribarne
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3 of the License, or
+(at your option) any later version.
+
+Octave is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, see
+<http://www.gnu.org/licenses/>.
+
+*/
+
+#include <iostream>
+
+#include <QtCore>
+#include <QtMath>
+#include <QtXml>
+
+#include <QApplication>
+#include <QFontDatabase>
+#include <QImage>
+#include <QPainter>
+#include <QPrinter>
+#include <QRegExp>
+
+class pdfpainter : public QPainter
+{
+public:
+  pdfpainter (QString fname, QRectF sizepix, double dpi)
+    : m_fname (fname), m_sizef (sizepix), m_dpi (dpi), m_printer ()
+  {
+    double scl = get_scale ();
+    m_sizef.setWidth (m_sizef.width () * scl);
+    m_sizef.setHeight (m_sizef.height () * scl);
+
+    // Printer settings
+    m_printer.setOutputFormat (QPrinter::PdfFormat);
+    m_printer.setFontEmbeddingEnabled (true);
+    m_printer.setOutputFileName (get_fname ());
+    m_printer.setFullPage (true);
+    m_printer.setPaperSize (get_rectf ().size (), QPrinter::DevicePixel);
+
+    // Painter settings
+    begin (&m_printer);
+    setViewport (get_rect ());
+    scale (get_scale (), get_scale ());
+  }
+
+  ~pdfpainter (void) { }
+
+  QString get_fname (void) const { return m_fname; }
+
+  QRectF get_rectf (void) const { return m_sizef; }
+
+  QRect get_rect (void) const { return m_sizef.toRect (); }
+
+  double get_scale (void) const { return m_dpi / 72.0; }
+
+  void finish (void) { end (); }
+
+private:
+  QString m_fname;
+  QRectF m_sizef;
+  double m_dpi;
+  QPrinter m_printer;
+};
+
+// String conversion functions
+QVector<double> qstr2vectorf (QString str)
+{
+  QVector<double> pts;
+  QStringList coords = str.split (",");
+  for (QStringList::iterator p = coords.begin (); p != coords.end (); p += 1)
+    {
+      double pt = (*p).toDouble ();
+      pts.append (pt);
+    }
+  return pts;
+}
+
+QVector<double> qstr2vectord (QString str)
+{
+  QVector<double> pts;
+  QStringList coords = str.split (",");
+  for (QStringList::iterator p = coords.begin (); p != coords.end (); p += 1)
+    {
+      double pt = (*p).toDouble ();
+      pts.append (pt);
+    }
+
+  return pts;
+}
+
+QVector<QPointF> qstr2ptsvector (QString str)
+{
+  QVector<QPointF> pts;
+  str = str.trimmed ();
+  str.replace (" ", ",");
+  QStringList coords = str.split (",");
+  for (QStringList::iterator p = coords.begin (); p != coords.end (); p += 2)
+    {
+      QPointF pt ((*p).toDouble (), (*(p+1)).toDouble ());
+      pts.append (pt);
+    }
+  return pts;
+}
+
+QVector<QPoint> qstr2ptsvectord (QString str)
+{
+  QVector<QPoint> pts;
+  str = str.trimmed ();
+  str.replace (" ", ",");
+  QStringList coords = str.split (",");
+  for (QStringList::iterator p = coords.begin (); p != coords.end (); p += 2)
+    {
+      QPoint pt ((*p).toDouble (), (*(p+1)).toDouble ());
+      pts.append (pt);
+    }
+  return pts;
+}
+
+// Extract field arguments in a style-like string, e.g. "bla field(1,34,56) bla"
+QString get_field (QString str, QString field)
+{
+  QString retval;
+  QRegExp rx (field + "\\(([^\\)]*)\\)");
+  int pos = 0;
+  pos = rx.indexIn (str, pos);
+  if (pos > -1)
+    retval = rx.cap (1);
+
+  return retval;
+}
+
+// Polygon reconstruction class
+class octave_polygon
+{
+public:
+  octave_polygon (void)
+  { }
+
+  octave_polygon (QPolygonF p)
+  { m_polygons.push_back (p); }
+
+  ~octave_polygon (void) { }
+
+  int count (void) const
+  { return m_polygons.count (); }
+
+  void reset (void)
+  { m_polygons.clear (); }
+
+  QList<QPolygonF> reconstruct (void)
+  {
+    if (m_polygons.isEmpty ())
+      return QList<QPolygonF> ();
+
+    // Once a polygon has been merged to another, it is marked unsuded
+    QVector<bool> unused;
+    for (auto it = m_polygons.begin (); it != m_polygons.end (); it++)
+      unused.push_back (false);
+
+    bool tryagain = (m_polygons.count () > 1);
+
+    while (tryagain)
+      {
+        tryagain = false;
+        for (auto ii = 0; ii < m_polygons.count (); ii++)
+          {
+            if (! unused[ii])
+              {
+                QPolygonF polygon = m_polygons[ii];
+                for (auto jj = ii+1; jj < m_polygons.count (); jj++)
+                  {
+                    if (! unused[jj])
+                      {
+                        QPolygonF newpoly = mergepoly (polygon, m_polygons[jj]);
+                        if (newpoly.count ())
+                          {
+                            polygon = newpoly;
+                            m_polygons[ii] = newpoly;
+                            unused[jj] = true;
+                            tryagain = true;
+                          }
+                      }
+                  }
+              }
+          }
+      }
+
+    // Try to remove cracks in polygons
+    for (auto ii = 0; ii < m_polygons.count (); ii++)
+      {
+        QPolygonF polygon = m_polygons[ii];
+        tryagain = ! unused[ii];
+
+        while (tryagain && polygon.count () > 4)
+          {
+            tryagain = false;
+            QVector<int> del;
+
+            for (auto jj = 1; jj < (polygon.count () - 1); jj++)
+              if (polygon[jj-1] == polygon[jj+1])
+                {
+                  if (! del.contains (jj))
+                    del.push_front (jj);
+
+                  del.push_front (jj+1);
+                }
+
+            for (auto idx : del)
+              polygon.remove (idx);
+
+            if (del.count ())
+              tryagain = true;
+          }
+        m_polygons[ii] = polygon;
+      }
+
+    // FIXME: There may still be residual cracks, we should do something like
+    //   resetloop = 2;
+    //   while (resetloop)
+    //     currface = shift (currface, 1);
+    //     if (currface(1) == currface(3))
+    //       currface([2 3]) = [];
+    //       resetloop = 2;
+    //     else
+    //       resetloop--;
+    //     endif
+    //   endwhile
+
+    QList<QPolygonF> retval;
+    for (int ii = 0; ii < m_polygons.count (); ii++)
+      {
+        QPolygonF polygon = m_polygons[ii];
+        if (! unused[ii] && polygon.count () > 2)
+          retval.push_back (polygon);
+      }
+
+    return retval;
+  }
+
+  static inline
+  bool eq (QPointF p1, QPointF p2)
+  {
+    return ((qAbs (p1.x () - p2.x ()) <=
+             0.00001 * qMin (qAbs (p1.x ()), qAbs (p2.x ())))
+            && (qAbs (p1.y () - p2.y ()) <=
+                0.00001 * qMin (qAbs (p1.y ()), qAbs (p2.y ()))));
+  }
+
+  static
+  QPolygonF mergepoly (QPolygonF poly1, QPolygonF poly2)
+  {
+    // Close polygon contour
+    poly1.push_back (poly1[0]);
+    poly2.push_back (poly2[0]);
+
+    for (int ii = 0; ii < (poly1.size () - 1); ii++)
+      {
+        for (int jj = 0; jj < (poly2.size () - 1); jj++)
+          {
+            bool forward = (eq (poly1[ii], poly2[jj])
+                            && eq (poly1[ii+1], poly2[jj+1]));
+            bool backward = ! forward && (eq (poly1[ii], poly2[jj+1])
+                                          && eq (poly1[ii+1], poly2[jj]));
+
+            if (forward || backward)
+              {
+                // Unclose contour
+                poly1.pop_back ();
+                poly2.pop_back ();
+
+                QPolygonF merged;
+                for (int kk = 0; kk < (ii+1); kk++)
+                  merged.push_back (poly1[kk]);
+
+                // Shift vertices and eliminate the common edge
+                std::rotate (poly2.begin (), poly2.begin () + jj, poly2.end ());
+                poly2.erase (poly2.begin ());
+                poly2.erase (poly2.begin ());
+
+                if (forward)
+                  for (int kk = poly2.size (); kk > 0; kk--)
+                    merged.push_back (poly2[kk-1]);
+                else
+                  for (int kk = 0; kk < poly2.size (); kk++)
+                    merged.push_back (poly2[kk]);
+
+                for (int kk = ii+1; kk < poly1.size (); kk++)
+                  merged.push_back (poly1[kk]);
+
+                // Return row vector
+                QPolygonF out (merged.size ());
+                for (int kk = 0; kk < merged.size (); kk++)
+                  out[kk] = merged[kk];
+
+                return out;
+              }
+          }
+      }
+    return QPolygonF ();
+  }
+
+  void add (QPolygonF p)
+  {
+    if (m_polygons.count () == 0)
+        m_polygons.push_back (p);
+    else
+      {
+        QPolygonF tmp = mergepoly (m_polygons.back (), p);
+        if (tmp.count ())
+          m_polygons.back () = tmp;
+        else
+          m_polygons.push_back (p);
+      }
+  }
+
+private:
+  QList<QPolygonF> m_polygons;
+};
+
+void draw (QDomElement& parent_elt, pdfpainter& painter)
+{
+  QDomNodeList nodes = parent_elt.childNodes ();
+
+  static QString clippath_id;
+  static QMap< QString, QVector<QPoint> > clippath;
+
+  // tspan elements must have access to the font and position extracted from
+  // their parent text element
+  static QFont font;
+  static double dx = 0, dy = 0;
+
+  for (int i = 0; i < nodes.count (); i++)
+    {
+      QDomNode node = nodes.at (i);
+      if (! node.isElement ())
+        continue;
+
+      QDomElement elt = node.toElement ();
+
+      if (elt.tagName () == "clipPath")
+        {
+          clippath_id = "#" + elt.attribute ("id");
+          draw (elt, painter);
+          clippath_id = QString ();
+        }
+      else if (elt.tagName () == "g")
+        {
+          bool current_clipstate = painter.hasClipping ();
+          QRegion current_clippath = painter.clipRegion ();
+
+          QString str = elt.attribute ("clip-path");
+          if (! str.isEmpty ())
+            {
+              QVector<QPoint> pts = clippath[get_field (str, "url")];
+              if (! pts.isEmpty ())
+                {
+                  painter.setClipRegion (QRegion (QPolygon (pts)));
+                  painter.setClipping (true);
+                }
+            }
+
+          draw (elt, painter);
+
+          // Restore previous clipping settings
+          painter.setClipRegion (current_clippath);
+          painter.setClipping (current_clipstate);
+        }
+      else if (elt.tagName () == "text")
+        {
+          // Font
+          font = QFont ();
+          QString str = elt.attribute ("font-family");
+          if (! str.isEmpty ())
+            font.setFamily (elt.attribute ("font-family"));
+
+          str = elt.attribute ("font-weight");
+          if (! str.isEmpty () && str != "normal")
+            font.setWeight (QFont::Bold);
+
+          str = elt.attribute ("font-style");
+          if (! str.isEmpty () && str != "normal")
+            font.setStyle (QFont::StyleItalic);
+
+          int sz = elt.attribute ("font-size").toInt ();
+          if (sz > 0)
+            font.setPixelSize (sz);
+
+          painter.setFont (font);
+
+          // Translation and rotation
+          painter.save ();
+          str = get_field (elt.attribute ("transform"), "translate");
+          if (! str.isEmpty ())
+            {
+              QStringList trans = str.split (",");
+              dx = trans[0].toDouble ();
+              dy = trans[1].toDouble ();
+
+              str = get_field (elt.attribute ("transform"), "rotate");
+              if (! str.isEmpty ())
+                {
+                  QStringList rot = str.split (",");
+                  painter.translate (dx+rot[1].toDouble (),
+                                     dy+rot[2].toDouble ());
+                  painter.rotate (rot[0].toDouble ());
+                  dx = rot[1].toDouble ();
+                  dy = rot[2].toDouble ();
+                }
+              else
+                {
+                  painter.translate (dx, dy);
+                  dx = 0;
+                  dy = 0;
+                }
+            }
+
+          draw (elt, painter);
+          painter.restore ();
+        }
+      else if (elt.tagName () == "tspan")
+        {
+          // Font
+          QFont saved_font(font);
+
+          QString str = elt.attribute ("font-family");
+          if (! str.isEmpty ())
+            font.setFamily (elt.attribute ("font-family"));
+
+          str = elt.attribute ("font-weight");
+          if (! str.isEmpty ())
+            {
+              if (str != "normal")
+                font.setWeight (QFont::Bold);
+              else
+                font.setWeight (QFont::Normal);
+            }
+
+          int sz = elt.attribute ("font-size").toInt ();
+          if (sz > 0)
+            font.setPixelSize (sz);
+
+          painter.setFont (font);
+
+          // Color is specified in rgb
+          str = get_field (elt.attribute ("fill"), "rgb");
+          if (! str.isEmpty ())
+            {
+              QStringList clist = str.split (",");
+              painter.setPen (QColor (clist[0].toInt (), clist[1].toInt (),
+                                      clist[2].toInt ()));
+            }
+
+          QStringList xx = elt.attribute ("x").split (" ");
+          int y = elt.attribute ("y").toInt ();
+          str = elt.text ();
+          if (! str.isEmpty ())
+            {
+              int ii = 0;
+              foreach (QString s,  xx)
+                if (ii < str.size ())
+                  painter.drawText (s.toInt ()-dx, y-dy, str.at (ii++));
+            }
+
+          draw (elt, painter);
+          font = saved_font;
+        }
+      else if (elt.tagName () == "polyline")
+        {
+          // Color
+          QColor c (elt.attribute ("stroke"));
+          QString str = elt.attribute ("stroke-opacity");
+          if (! str.isEmpty () && str.toDouble () != 1.0
+              && str.toDouble () >= 0.0)
+            c.setAlphaF (str.toDouble ());
+
+          QPen pen;
+          pen.setColor (c);
+
+          // Line properies
+          str = elt.attribute ("stroke-width");
+          if (! str.isEmpty ())
+            {
+              double w = str.toDouble () * painter.get_scale ();
+              if (w > 0)
+                pen.setWidthF (w / painter.get_scale ());
+            }
+
+          str = elt.attribute ("stroke-linecap");
+          pen.setCapStyle (Qt::SquareCap);
+          if (str == "round")
+            pen.setCapStyle (Qt::RoundCap);
+          else if (str == "butt")
+            pen.setCapStyle (Qt::FlatCap);
+
+          str = elt.attribute ("stroke-linejoin");
+          pen.setJoinStyle (Qt::MiterJoin);
+          if (str == "round")
+            pen.setJoinStyle (Qt::RoundJoin);
+          else if (str == "bevel")
+            pen.setJoinStyle (Qt::BevelJoin);
+
+          str = elt.attribute ("stroke-dasharray");
+          pen.setStyle (Qt::SolidLine);
+          if (! str.isEmpty ())
+            {
+              QVector<double> pat = qstr2vectord (str);
+              if (pat.count () != 2 || pat[1] != 0)
+                {
+                  // Express pattern in linewidth units
+                  for (auto& p : pat)
+                    p /= pen.widthF ();
+
+                  pen.setDashPattern (pat);
+                }
+            }
+
+          painter.setPen (pen);
+          painter.drawPolyline (qstr2ptsvector (elt.attribute ("points")));
+        }
+      else if (elt.tagName () == "image")
+        {
+          // Images are represented as a base64 stream of png formated data
+          QString href_att = elt.attribute ("xlink:href");
+          QString prefix ("data:image/png;base64,");
+          QByteArray data =
+            QByteArray::fromBase64(href_att.mid (prefix.length ())
+                                   .toLatin1 ());
+          QImage img;
+          if (img.loadFromData (data, "PNG"))
+            {
+              QRect pos(elt.attribute ("x").toInt (),
+                        elt.attribute ("y").toInt (),
+                        elt.attribute ("width").toInt (),
+                        elt.attribute ("height").toInt ());
+
+              // Translate
+              painter.save ();
+              QString str = get_field (elt.attribute ("transform"), "matrix");
+              if (! str.isEmpty ())
+                {
+                  QVector<double> m = qstr2vectorf (str);
+                  double scl = painter.get_scale ();
+                  QTransform tform(m[0]*scl, m[1]*scl, m[2]*scl,
+                                   m[3]*scl, m[4]*scl, m[5]*scl);
+                  painter.setTransform (tform);
+                }
+
+              painter.setRenderHint (QPainter::Antialiasing, false);
+              painter.drawImage (pos, img);
+              painter.setRenderHint (QPainter::Antialiasing, true);
+              painter.restore  ();
+            }
+        }
+      else if (elt.tagName () == "polygon")
+        {
+          if (! clippath_id.isEmpty ())
+            clippath[clippath_id] = qstr2ptsvectord (elt.attribute ("points"));
+          else
+            {
+              QString str = elt.attribute ("fill");
+              if (! str.isEmpty ())
+                {
+                  QColor color (str);
+
+                  str = elt.attribute ("fill-opacity");
+                  if (! str.isEmpty () && str.toDouble () != 1.0
+                      && str.toDouble () >= 0.0)
+                    color.setAlphaF (str.toDouble ());
+
+                  QPolygonF p (qstr2ptsvector (elt.attribute ("points")));
+
+                  if (p.count () > 2)
+                    {
+                      painter.setBrush (color);
+                      painter.setPen (Qt::NoPen);
+
+                      painter.setRenderHint (QPainter::Antialiasing, false);
+                      painter.drawPolygon (p);
+                      painter.setRenderHint (QPainter::Antialiasing, true);
+                    }
+                }
+            }
+        }
+    }
+}
+
+// Append a list of reconstructed child polygons to a QDomElement and remove
+// the original nodes
+
+void replace_polygons (QDomElement& parent_elt, QList<QDomNode> orig,
+                       QList<QPolygonF> polygons)
+{
+  if (! orig.count () || (orig.count () == polygons.count ()))
+    return;
+
+  QDomNode last = orig.last ();
+  for (int ii = 0; ii < polygons.count (); ii++)
+    {
+      QPolygonF polygon = polygons[ii];
+
+      QDomNode node = last.cloneNode ();
+
+      QString pts;
+
+      for (int jj = 0; jj < polygon.count (); jj++)
+        {
+          pts += QString ("%1,%2 ").arg (polygon[jj].x ())
+            .arg (polygon[jj].y ());
+        }
+
+      node.toElement ().setAttribute ("points", pts.trimmed ());
+
+      if (! last.isNull ())
+        last = parent_elt.insertAfter (node, last);
+    }
+
+  for (int ii = 0; ii < orig.count (); ii++)
+    parent_elt.removeChild (orig.at (ii));
+}
+
+void reconstruct_polygons (QDomElement& parent_elt)
+{
+  QDomNodeList nodes = parent_elt.childNodes ();
+  QColor current_color;
+  QList<QDomNode> replaced_nodes;
+  octave_polygon current_polygon;
+
+  // Collection of child nodes to be removed and polygons to be added
+  QList< QPair<QList<QDomNode>,QList<QPolygonF> > > collection;
+
+  for (int ii = 0; ii < nodes.count (); ii++)
+    {
+      QDomNode node = nodes.at (ii);
+      if (! node.isElement ())
+        continue;
+
+      QDomElement elt = node.toElement ();
+
+      if (elt.tagName () == "polygon")
+        {
+          QString str = elt.attribute ("fill");
+          if (! str.isEmpty ())
+            {
+              QColor color (str);
+              str = elt.attribute ("fill-opacity");
+              if (! str.isEmpty ())
+                {
+                  double alpha = str.toDouble ();
+                  if (alpha != 1.0 && str.toDouble () >= 0.0)
+                    color.setAlphaF (alpha);
+                }
+
+              if (! current_polygon.count ())
+                current_color = color;
+
+              if (color != current_color)
+                {
+                  // Reconstruct the previous series of triangle
+                  QList<QPolygonF> polygons = current_polygon.reconstruct ();
+                  collection.push_back (QPair<QList<QDomNode>,QList<QPolygonF> >
+                                        (replaced_nodes, polygons));
+
+                  replaced_nodes.clear ();
+                  current_polygon.reset ();
+
+                  current_color = color;
+                }
+
+              QPolygonF p (qstr2ptsvector (elt.attribute ("points")));
+              current_polygon.add (p);
+              replaced_nodes.push_back (node);
+            }
+        }
+      else
+        {
+          if (current_polygon.count ())
+            {
+              QList<QPolygonF> polygons = current_polygon.reconstruct ();
+              collection.push_back (QPair<QList<QDomNode>,QList<QPolygonF> >
+                                    (replaced_nodes, polygons));
+              replaced_nodes.clear ();
+              current_polygon.reset ();
+            }
+          reconstruct_polygons (elt);
+        }
+    }
+
+  // Finish
+  collection.push_back (QPair<QList<QDomNode>,QList<QPolygonF> >
+                        (replaced_nodes, current_polygon.reconstruct ()));
+
+  for (int ii = 0; ii < collection.count (); ii++)
+    replace_polygons (parent_elt, collection[ii].first, collection[ii].second);
+}
+
+int main(int argc, char *argv[])
+{
+  const char *doc = "See \"octave-svgconvert -h\"";
+  const char *help =
+"Usage:\n\
+octave-svgconvert infile fmt dpi font reconstruct outfile\n\n\
+Convert svg file to pdf, or svg. All arguments are mandatory:\n\
+* infile: input svg file or \"-\" to indicate that the input svg file should be \
+read from stdin\n\
+* fmt: format of the output file. May be one of pdf or svg\n\
+* dpi: device dependent resolution in screen pixel per inch\n\
+* font: specify a file name for the default FreeSans font\n\
+* reconstruct: specify wether to reconstruct triangle to polygons (0 or 1)\n\
+* outfile: output file name\n";
+  
+  if (strcmp (argv[1], "-h") == 0)
+    {
+      std::cout << help;
+      return 0;
+    }
+  else if (argc != 7)
+    {
+      std::cerr << help;
+      return -1;
+    }
+
+  // Open svg file
+  QFile file;
+  if (strcmp (argv[1], "-") != 0)
+    {
+      // Read from file
+      file.setFileName (argv[1]);
+      if (! file.open (QIODevice::ReadOnly | QIODevice::Text))
+        {
+          std::cerr << "Unable to open file " << argv[1] << "\n";
+          std::cerr << help;
+          return -1;
+        }
+    }
+  else
+    {
+      // Read from stdin
+      if (! file.open (stdin, QIODevice::ReadOnly | QIODevice::Text))
+        {
+          std::cerr << "Unable read from stdin\n";
+          std::cerr << doc;
+          return -1;
+        }
+    }
+
+  // Create a DOM document and load the svg file
+  QDomDocument document;
+  QString msg;
+  if(! document.setContent (&file, false, &msg))
+    {
+      std::cerr << "Failed to parse XML contents" << std::endl
+                << msg.toStdString ();
+      std::cerr << doc;
+      file.close();
+      return -1;
+    }
+
+  // Format
+  if (strcmp (argv[2], "pdf") != 0 && strcmp (argv[2], "svg") != 0)
+    {
+      std::cerr << "Unhandled output file format " << argv[2] << "\n";
+      std::cerr << doc;
+      return -1;
+    }
+
+  // Resolution
+  double dpi = QString (argv[3]).toDouble ();
+  if (dpi <= 0.0)
+    {
+      std::cerr << "DPI must be positive\n";
+      return -1;
+    }
+
+
+  // Get the viewport from the root element
+  QDomElement root = document.firstChildElement();
+  double x0, y0, dx, dy;
+  QString s = root.attribute ("viewBox");
+  QTextStream (&s) >> x0 >> y0 >> dx >> dy;
+  QRectF vp (x0, y0, dx, dy);
+
+  // Setup application and add default FreeSans font if needed
+  QApplication a (argc, argv);
+
+  QFont font ("FreeSans");
+  int id = 0;
+  if (! font.exactMatch ())
+    {
+      QString fontname (argv[4]);
+      if (! fontname.isEmpty ())
+        {
+          id = QFontDatabase::addApplicationFont (fontname);
+          if (id < 0)
+            std::cerr << "Unable to add default font to database\n";
+        }
+      else
+        std::cerr << "FreeSans font not found\n";
+    }
+
+  // First render in a temporary file
+  QTemporaryFile fout;
+  if (! fout.open ())
+    {
+      std::cerr << "Could not open temporary file\n";
+      return -1;
+    }
+
+  // Do basic polygons reconstruction
+  if (QString (argv[5]).toInt ())
+    reconstruct_polygons (root);
+
+  // Draw
+  if (! strcmp (argv[2], "pdf"))
+    {
+      // PDF painter
+      pdfpainter painter (fout.fileName (), vp, dpi);
+
+      draw (root, painter);
+      painter.finish ();
+    }
+  else
+    {
+      // Return modified svg document
+      QTextStream out (&fout);
+      out << document.toString ();
+    }
+
+  // Delete output file before writing with new data
+  if (QFile::exists (argv[6]))
+    if (! QFile::remove (argv[6]))
+      {
+        std::cerr << "Unable to replace existing file " << argv[6] << "\n";
+        return -1;
+      }
+
+  fout.copy (argv[6]);
+
+  return 0;
+}
