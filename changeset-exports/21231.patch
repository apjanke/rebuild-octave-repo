# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1455009350 18000
#      Tue Feb 09 04:15:50 2016 -0500
# Node ID 5f318c8ec6345f4d9478656db00395661ce9b023
# Parent  721539013db4f9a09b9589412e935a4bd7d3358f
eliminate feature tests from lo-specfun.h

* lo-specfun.h, lo-specfun.cc (xacosh, xasinh, xatanh, xerf, xerfc
xexpm1, xlog1p, xcbrt): Rename to have 'x' prefix.  Conditionally
define in .cc file.  Change all uses  Move complex versions of acosh,
asinh, and atanh functions here.

diff --git a/libinterp/octave-value/ov-complex.cc b/libinterp/octave-value/ov-complex.cc
--- a/libinterp/octave-value/ov-complex.cc
+++ b/libinterp/octave-value/ov-complex.cc
@@ -465,41 +465,41 @@ octave_complex::map (unary_mapper_t umap
   switch (umap)
     {
 #define SCALAR_MAPPER(UMAP, FCN) \
     case umap_ ## UMAP: \
       return octave_value (FCN (scalar))
 
       SCALAR_MAPPER (abs, std::abs);
       SCALAR_MAPPER (acos, ::acos);
-      SCALAR_MAPPER (acosh, ::acosh);
+      SCALAR_MAPPER (acosh, xacosh);
       SCALAR_MAPPER (angle, std::arg);
       SCALAR_MAPPER (arg, std::arg);
       SCALAR_MAPPER (asin, ::asin);
-      SCALAR_MAPPER (asinh, ::asinh);
+      SCALAR_MAPPER (asinh, xasinh);
       SCALAR_MAPPER (atan, ::atan);
-      SCALAR_MAPPER (atanh, ::atanh);
-      SCALAR_MAPPER (erf, ::erf);
-      SCALAR_MAPPER (erfc, ::erfc);
+      SCALAR_MAPPER (atanh, xatanh);
+      SCALAR_MAPPER (erf, xerf);
+      SCALAR_MAPPER (erfc, xerfc);
       SCALAR_MAPPER (erfcx, ::erfcx);
       SCALAR_MAPPER (erfi, ::erfi);
       SCALAR_MAPPER (dawson, ::dawson);
       SCALAR_MAPPER (ceil, ::ceil);
       SCALAR_MAPPER (conj, std::conj);
       SCALAR_MAPPER (cos, std::cos);
       SCALAR_MAPPER (cosh, std::cosh);
       SCALAR_MAPPER (exp, std::exp);
-      SCALAR_MAPPER (expm1, ::expm1);
+      SCALAR_MAPPER (expm1, xexpm1);
       SCALAR_MAPPER (fix, ::fix);
       SCALAR_MAPPER (floor, ::floor);
       SCALAR_MAPPER (imag, std::imag);
       SCALAR_MAPPER (log, std::log);
       SCALAR_MAPPER (log2, xlog2);
       SCALAR_MAPPER (log10, std::log10);
-      SCALAR_MAPPER (log1p, ::log1p);
+      SCALAR_MAPPER (log1p, xlog1p);
       SCALAR_MAPPER (real, std::real);
       SCALAR_MAPPER (round, xround);
       SCALAR_MAPPER (roundb, xroundb);
       SCALAR_MAPPER (signum, ::signum);
       SCALAR_MAPPER (sin, std::sin);
       SCALAR_MAPPER (sinh, std::sinh);
       SCALAR_MAPPER (sqrt, std::sqrt);
       SCALAR_MAPPER (tan, std::tan);
diff --git a/libinterp/octave-value/ov-cx-mat.cc b/libinterp/octave-value/ov-cx-mat.cc
--- a/libinterp/octave-value/ov-cx-mat.cc
+++ b/libinterp/octave-value/ov-cx-mat.cc
@@ -753,39 +753,39 @@ octave_complex_matrix::map (unary_mapper
       ARRAY_METHOD_MAPPER (isinf, isinf);
       ARRAY_METHOD_MAPPER (isfinite, isfinite);
 
 #define ARRAY_MAPPER(UMAP, TYPE, FCN) \
     case umap_ ## UMAP: \
       return octave_value (matrix.map<TYPE> (FCN))
 
       ARRAY_MAPPER (acos, Complex, ::acos);
-      ARRAY_MAPPER (acosh, Complex, ::acosh);
+      ARRAY_MAPPER (acosh, Complex, xacosh);
       ARRAY_MAPPER (angle, double, std::arg);
       ARRAY_MAPPER (arg, double, std::arg);
       ARRAY_MAPPER (asin, Complex, ::asin);
-      ARRAY_MAPPER (asinh, Complex, ::asinh);
+      ARRAY_MAPPER (asinh, Complex, xasinh);
       ARRAY_MAPPER (atan, Complex, ::atan);
-      ARRAY_MAPPER (atanh, Complex, ::atanh);
-      ARRAY_MAPPER (erf, Complex, ::erf);
-      ARRAY_MAPPER (erfc, Complex, ::erfc);
+      ARRAY_MAPPER (atanh, Complex, xatanh);
+      ARRAY_MAPPER (erf, Complex, xerf);
+      ARRAY_MAPPER (erfc, Complex, xerfc);
       ARRAY_MAPPER (erfcx, Complex, ::erfcx);
       ARRAY_MAPPER (erfi, Complex, ::erfi);
       ARRAY_MAPPER (dawson, Complex, ::dawson);
       ARRAY_MAPPER (ceil, Complex, ::ceil);
       ARRAY_MAPPER (cos, Complex, std::cos);
       ARRAY_MAPPER (cosh, Complex, std::cosh);
       ARRAY_MAPPER (exp, Complex, std::exp);
-      ARRAY_MAPPER (expm1, Complex, ::expm1);
+      ARRAY_MAPPER (expm1, Complex, xexpm1);
       ARRAY_MAPPER (fix, Complex, ::fix);
       ARRAY_MAPPER (floor, Complex, ::floor);
       ARRAY_MAPPER (log, Complex, std::log);
       ARRAY_MAPPER (log2, Complex, xlog2);
       ARRAY_MAPPER (log10, Complex, std::log10);
-      ARRAY_MAPPER (log1p, Complex, ::log1p);
+      ARRAY_MAPPER (log1p, Complex, xlog1p);
       ARRAY_MAPPER (round, Complex, xround);
       ARRAY_MAPPER (roundb, Complex, xroundb);
       ARRAY_MAPPER (signum, Complex, ::signum);
       ARRAY_MAPPER (sin, Complex, std::sin);
       ARRAY_MAPPER (sinh, Complex, std::sinh);
       ARRAY_MAPPER (sqrt, Complex, std::sqrt);
       ARRAY_MAPPER (tan, Complex, std::tan);
       ARRAY_MAPPER (tanh, Complex, std::tanh);
diff --git a/libinterp/octave-value/ov-cx-sparse.cc b/libinterp/octave-value/ov-cx-sparse.cc
--- a/libinterp/octave-value/ov-cx-sparse.cc
+++ b/libinterp/octave-value/ov-cx-sparse.cc
@@ -907,40 +907,40 @@ octave_sparse_complex_matrix::map (unary
 
       ARRAY_METHOD_MAPPER (abs, abs);
 
 #define ARRAY_MAPPER(UMAP, TYPE, FCN) \
     case umap_ ## UMAP: \
       return octave_value (matrix.map<TYPE> (FCN))
 
       ARRAY_MAPPER (acos, Complex, ::acos);
-      ARRAY_MAPPER (acosh, Complex, ::acosh);
+      ARRAY_MAPPER (acosh, Complex, xacosh);
       ARRAY_MAPPER (angle, double, std::arg);
       ARRAY_MAPPER (arg, double, std::arg);
       ARRAY_MAPPER (asin, Complex, ::asin);
-      ARRAY_MAPPER (asinh, Complex, ::asinh);
+      ARRAY_MAPPER (asinh, Complex, xasinh);
       ARRAY_MAPPER (atan, Complex, ::atan);
-      ARRAY_MAPPER (atanh, Complex, ::atanh);
-      ARRAY_MAPPER (erf, Complex, ::erf);
-      ARRAY_MAPPER (erfc, Complex, ::erfc);
+      ARRAY_MAPPER (atanh, Complex, xatanh);
+      ARRAY_MAPPER (erf, Complex, xerf);
+      ARRAY_MAPPER (erfc, Complex, xerfc);
       ARRAY_MAPPER (erfcx, Complex, ::erfcx);
       ARRAY_MAPPER (erfi, Complex, ::erfi);
       ARRAY_MAPPER (dawson, Complex, ::dawson);
       ARRAY_MAPPER (ceil, Complex, ::ceil);
       ARRAY_MAPPER (conj, Complex, std::conj<double>);
       ARRAY_MAPPER (cos, Complex, std::cos);
       ARRAY_MAPPER (cosh, Complex, std::cosh);
       ARRAY_MAPPER (exp, Complex, std::exp);
-      ARRAY_MAPPER (expm1, Complex, ::expm1);
+      ARRAY_MAPPER (expm1, Complex, xexpm1);
       ARRAY_MAPPER (fix, Complex, ::fix);
       ARRAY_MAPPER (floor, Complex, ::floor);
       ARRAY_MAPPER (log, Complex, std::log);
       ARRAY_MAPPER (log2, Complex, xlog2);
       ARRAY_MAPPER (log10, Complex, std::log10);
-      ARRAY_MAPPER (log1p, Complex, ::log1p);
+      ARRAY_MAPPER (log1p, Complex, xlog1p);
       ARRAY_MAPPER (round, Complex, xround);
       ARRAY_MAPPER (roundb, Complex, xroundb);
       ARRAY_MAPPER (signum, Complex, ::signum);
       ARRAY_MAPPER (sin, Complex, std::sin);
       ARRAY_MAPPER (sinh, Complex, std::sinh);
       ARRAY_MAPPER (sqrt, Complex, std::sqrt);
       ARRAY_MAPPER (tan, Complex, std::tan);
       ARRAY_MAPPER (tanh, Complex, std::tanh);
diff --git a/libinterp/octave-value/ov-float.cc b/libinterp/octave-value/ov-float.cc
--- a/libinterp/octave-value/ov-float.cc
+++ b/libinterp/octave-value/ov-float.cc
@@ -290,34 +290,34 @@ octave_float_scalar::map (unary_mapper_t
       return octave_value (FCN (scalar))
 
       SCALAR_MAPPER (abs, ::fabsf);
       SCALAR_MAPPER (acos, rc_acos);
       SCALAR_MAPPER (acosh, rc_acosh);
       SCALAR_MAPPER (angle, ::arg);
       SCALAR_MAPPER (arg, ::arg);
       SCALAR_MAPPER (asin, rc_asin);
-      SCALAR_MAPPER (asinh, ::asinhf);
+      SCALAR_MAPPER (asinh, xasinh);
       SCALAR_MAPPER (atan, ::atanf);
       SCALAR_MAPPER (atanh, rc_atanh);
-      SCALAR_MAPPER (erf, ::erff);
+      SCALAR_MAPPER (erf, xerf);
       SCALAR_MAPPER (erfinv, ::erfinv);
       SCALAR_MAPPER (erfcinv, ::erfcinv);
-      SCALAR_MAPPER (erfc, ::erfcf);
+      SCALAR_MAPPER (erfc, xerfc);
       SCALAR_MAPPER (erfcx, ::erfcx);
       SCALAR_MAPPER (erfi, ::erfi);
       SCALAR_MAPPER (dawson, ::dawson);
       SCALAR_MAPPER (gamma, xgamma);
       SCALAR_MAPPER (lgamma, rc_lgamma);
-      SCALAR_MAPPER (cbrt, ::cbrtf);
+      SCALAR_MAPPER (cbrt, xcbrt);
       SCALAR_MAPPER (ceil, ::ceilf);
       SCALAR_MAPPER (cos, ::cosf);
       SCALAR_MAPPER (cosh, ::coshf);
       SCALAR_MAPPER (exp, ::expf);
-      SCALAR_MAPPER (expm1, ::expm1f);
+      SCALAR_MAPPER (expm1, xexpm1);
       SCALAR_MAPPER (fix, ::fix);
       SCALAR_MAPPER (floor, gnulib::floorf);
       SCALAR_MAPPER (log, rc_log);
       SCALAR_MAPPER (log2, rc_log2);
       SCALAR_MAPPER (log10, rc_log10);
       SCALAR_MAPPER (log1p, rc_log1p);
       SCALAR_MAPPER (round, xround);
       SCALAR_MAPPER (roundb, xroundb);
diff --git a/libinterp/octave-value/ov-flt-complex.cc b/libinterp/octave-value/ov-flt-complex.cc
--- a/libinterp/octave-value/ov-flt-complex.cc
+++ b/libinterp/octave-value/ov-flt-complex.cc
@@ -416,41 +416,41 @@ octave_float_complex::map (unary_mapper_
   switch (umap)
     {
 #define SCALAR_MAPPER(UMAP, FCN) \
     case umap_ ## UMAP: \
       return octave_value (FCN (scalar))
 
       SCALAR_MAPPER (abs, std::abs);
       SCALAR_MAPPER (acos, ::acos);
-      SCALAR_MAPPER (acosh, ::acosh);
+      SCALAR_MAPPER (acosh, xacosh);
       SCALAR_MAPPER (angle, std::arg);
       SCALAR_MAPPER (arg, std::arg);
       SCALAR_MAPPER (asin, ::asin);
-      SCALAR_MAPPER (asinh, ::asinh);
+      SCALAR_MAPPER (asinh, xasinh);
       SCALAR_MAPPER (atan, ::atan);
-      SCALAR_MAPPER (atanh, ::atanh);
-      SCALAR_MAPPER (erf, ::erf);
-      SCALAR_MAPPER (erfc, ::erfc);
+      SCALAR_MAPPER (atanh, xatanh);
+      SCALAR_MAPPER (erf, xerf);
+      SCALAR_MAPPER (erfc, xerfc);
       SCALAR_MAPPER (erfcx, ::erfcx);
       SCALAR_MAPPER (erfi, ::erfi);
       SCALAR_MAPPER (dawson, ::dawson);
       SCALAR_MAPPER (ceil, ::ceil);
       SCALAR_MAPPER (conj, std::conj);
       SCALAR_MAPPER (cos, std::cos);
       SCALAR_MAPPER (cosh, std::cosh);
       SCALAR_MAPPER (exp, std::exp);
-      SCALAR_MAPPER (expm1, ::expm1);
+      SCALAR_MAPPER (expm1, xexpm1);
       SCALAR_MAPPER (fix, ::fix);
       SCALAR_MAPPER (floor, ::floor);
       SCALAR_MAPPER (imag, std::imag);
       SCALAR_MAPPER (log, std::log);
       SCALAR_MAPPER (log2, xlog2);
       SCALAR_MAPPER (log10, std::log10);
-      SCALAR_MAPPER (log1p, ::log1p);
+      SCALAR_MAPPER (log1p, xlog1p);
       SCALAR_MAPPER (real, std::real);
       SCALAR_MAPPER (round, xround);
       SCALAR_MAPPER (roundb, xroundb);
       SCALAR_MAPPER (signum, ::signum);
       SCALAR_MAPPER (sin, std::sin);
       SCALAR_MAPPER (sinh, std::sinh);
       SCALAR_MAPPER (sqrt, std::sqrt);
       SCALAR_MAPPER (tan, std::tan);
diff --git a/libinterp/octave-value/ov-flt-cx-mat.cc b/libinterp/octave-value/ov-flt-cx-mat.cc
--- a/libinterp/octave-value/ov-flt-cx-mat.cc
+++ b/libinterp/octave-value/ov-flt-cx-mat.cc
@@ -704,39 +704,39 @@ octave_float_complex_matrix::map (unary_
       ARRAY_METHOD_MAPPER (isinf, isinf);
       ARRAY_METHOD_MAPPER (isfinite, isfinite);
 
 #define ARRAY_MAPPER(UMAP, TYPE, FCN) \
     case umap_ ## UMAP: \
       return octave_value (matrix.map<TYPE> (FCN))
 
       ARRAY_MAPPER (acos, FloatComplex, ::acos);
-      ARRAY_MAPPER (acosh, FloatComplex, ::acosh);
+      ARRAY_MAPPER (acosh, FloatComplex, xacosh);
       ARRAY_MAPPER (angle, float, std::arg);
       ARRAY_MAPPER (arg, float, std::arg);
       ARRAY_MAPPER (asin, FloatComplex, ::asin);
-      ARRAY_MAPPER (asinh, FloatComplex, ::asinh);
+      ARRAY_MAPPER (asinh, FloatComplex, xasinh);
       ARRAY_MAPPER (atan, FloatComplex, ::atan);
-      ARRAY_MAPPER (atanh, FloatComplex, ::atanh);
-      ARRAY_MAPPER (erf, FloatComplex, ::erf);
-      ARRAY_MAPPER (erfc, FloatComplex, ::erfc);
+      ARRAY_MAPPER (atanh, FloatComplex, xatanh);
+      ARRAY_MAPPER (erf, FloatComplex, xerf);
+      ARRAY_MAPPER (erfc, FloatComplex, xerfc);
       ARRAY_MAPPER (erfcx, FloatComplex, ::erfcx);
       ARRAY_MAPPER (erfi, FloatComplex, ::erfi);
       ARRAY_MAPPER (dawson, FloatComplex, ::dawson);
       ARRAY_MAPPER (ceil, FloatComplex, ::ceil);
       ARRAY_MAPPER (cos, FloatComplex, std::cos);
       ARRAY_MAPPER (cosh, FloatComplex, std::cosh);
       ARRAY_MAPPER (exp, FloatComplex, std::exp);
-      ARRAY_MAPPER (expm1, FloatComplex, ::expm1);
+      ARRAY_MAPPER (expm1, FloatComplex, xexpm1);
       ARRAY_MAPPER (fix, FloatComplex, ::fix);
       ARRAY_MAPPER (floor, FloatComplex, ::floor);
       ARRAY_MAPPER (log, FloatComplex, std::log);
       ARRAY_MAPPER (log2, FloatComplex, xlog2);
       ARRAY_MAPPER (log10, FloatComplex, std::log10);
-      ARRAY_MAPPER (log1p, FloatComplex, ::log1p);
+      ARRAY_MAPPER (log1p, FloatComplex, xlog1p);
       ARRAY_MAPPER (round, FloatComplex, xround);
       ARRAY_MAPPER (roundb, FloatComplex, xroundb);
       ARRAY_MAPPER (signum, FloatComplex, ::signum);
       ARRAY_MAPPER (sin, FloatComplex, std::sin);
       ARRAY_MAPPER (sinh, FloatComplex, std::sinh);
       ARRAY_MAPPER (sqrt, FloatComplex, std::sqrt);
       ARRAY_MAPPER (tan, FloatComplex, std::tan);
       ARRAY_MAPPER (tanh, FloatComplex, std::tanh);
diff --git a/libinterp/octave-value/ov-flt-re-mat.cc b/libinterp/octave-value/ov-flt-re-mat.cc
--- a/libinterp/octave-value/ov-flt-re-mat.cc
+++ b/libinterp/octave-value/ov-flt-re-mat.cc
@@ -738,34 +738,34 @@ octave_float_matrix::map (unary_mapper_t
     case umap_ ## UMAP: \
       return do_rc_map (matrix, FCN)
 
       RC_ARRAY_MAPPER (acos, FloatComplex, rc_acos);
       RC_ARRAY_MAPPER (acosh, FloatComplex, rc_acosh);
       ARRAY_MAPPER (angle, float, ::arg);
       ARRAY_MAPPER (arg, float, ::arg);
       RC_ARRAY_MAPPER (asin, FloatComplex, rc_asin);
-      ARRAY_MAPPER (asinh, float, ::asinhf);
+      ARRAY_MAPPER (asinh, float, xasinh);
       ARRAY_MAPPER (atan, float, ::atanf);
       RC_ARRAY_MAPPER (atanh, FloatComplex, rc_atanh);
-      ARRAY_MAPPER (erf, float, ::erff);
+      ARRAY_MAPPER (erf, float, xerf);
       ARRAY_MAPPER (erfinv, float, ::erfinv);
       ARRAY_MAPPER (erfcinv, float, ::erfcinv);
-      ARRAY_MAPPER (erfc, float, ::erfcf);
+      ARRAY_MAPPER (erfc, float, xerfc);
       ARRAY_MAPPER (erfcx, float, ::erfcx);
       ARRAY_MAPPER (erfi, float, ::erfi);
       ARRAY_MAPPER (dawson, float, ::dawson);
       ARRAY_MAPPER (gamma, float, xgamma);
       RC_ARRAY_MAPPER (lgamma, FloatComplex, rc_lgamma);
-      ARRAY_MAPPER (cbrt, float, ::cbrtf);
+      ARRAY_MAPPER (cbrt, float, xcbrt);
       ARRAY_MAPPER (ceil, float, ::ceilf);
       ARRAY_MAPPER (cos, float, ::cosf);
       ARRAY_MAPPER (cosh, float, ::coshf);
       ARRAY_MAPPER (exp, float, ::expf);
-      ARRAY_MAPPER (expm1, float, ::expm1f);
+      ARRAY_MAPPER (expm1, float, xexpm1);
       ARRAY_MAPPER (fix, float, ::fix);
       ARRAY_MAPPER (floor, float, ::floorf);
       RC_ARRAY_MAPPER (log, FloatComplex, rc_log);
       RC_ARRAY_MAPPER (log2, FloatComplex, rc_log2);
       RC_ARRAY_MAPPER (log10, FloatComplex, rc_log10);
       RC_ARRAY_MAPPER (log1p, FloatComplex, rc_log1p);
       ARRAY_MAPPER (round, float, xround);
       ARRAY_MAPPER (roundb, float, xroundb);
diff --git a/libinterp/octave-value/ov-re-mat.cc b/libinterp/octave-value/ov-re-mat.cc
--- a/libinterp/octave-value/ov-re-mat.cc
+++ b/libinterp/octave-value/ov-re-mat.cc
@@ -861,34 +861,34 @@ octave_matrix::map (unary_mapper_t umap)
     case umap_ ## UMAP: \
       return do_rc_map (matrix, FCN)
 
       RC_ARRAY_MAPPER (acos, Complex, rc_acos);
       RC_ARRAY_MAPPER (acosh, Complex, rc_acosh);
       ARRAY_MAPPER (angle, double, ::arg);
       ARRAY_MAPPER (arg, double, ::arg);
       RC_ARRAY_MAPPER (asin, Complex, rc_asin);
-      ARRAY_MAPPER (asinh, double, ::asinh);
+      ARRAY_MAPPER (asinh, double, xasinh);
       ARRAY_MAPPER (atan, double, ::atan);
       RC_ARRAY_MAPPER (atanh, Complex, rc_atanh);
-      ARRAY_MAPPER (erf, double, ::erf);
+      ARRAY_MAPPER (erf, double, xerf);
       ARRAY_MAPPER (erfinv, double, ::erfinv);
       ARRAY_MAPPER (erfcinv, double, ::erfcinv);
-      ARRAY_MAPPER (erfc, double, ::erfc);
+      ARRAY_MAPPER (erfc, double, xerfc);
       ARRAY_MAPPER (erfcx, double, ::erfcx);
       ARRAY_MAPPER (erfi, double, ::erfi);
       ARRAY_MAPPER (dawson, double, ::dawson);
       ARRAY_MAPPER (gamma, double, xgamma);
       RC_ARRAY_MAPPER (lgamma, Complex, rc_lgamma);
-      ARRAY_MAPPER (cbrt, double, ::cbrt);
+      ARRAY_MAPPER (cbrt, double, xcbrt);
       ARRAY_MAPPER (ceil, double, ::ceil);
       ARRAY_MAPPER (cos, double, ::cos);
       ARRAY_MAPPER (cosh, double, ::cosh);
       ARRAY_MAPPER (exp, double, ::exp);
-      ARRAY_MAPPER (expm1, double, ::expm1);
+      ARRAY_MAPPER (expm1, double, xexpm1);
       ARRAY_MAPPER (fix, double, ::fix);
       ARRAY_MAPPER (floor, double, ::floor);
       RC_ARRAY_MAPPER (log, Complex, rc_log);
       RC_ARRAY_MAPPER (log2, Complex, rc_log2);
       RC_ARRAY_MAPPER (log10, Complex, rc_log10);
       RC_ARRAY_MAPPER (log1p, Complex, rc_log1p);
       ARRAY_MAPPER (round, double, xround);
       ARRAY_MAPPER (roundb, double, xroundb);
diff --git a/libinterp/octave-value/ov-re-sparse.cc b/libinterp/octave-value/ov-re-sparse.cc
--- a/libinterp/octave-value/ov-re-sparse.cc
+++ b/libinterp/octave-value/ov-re-sparse.cc
@@ -900,34 +900,34 @@ octave_sparse_matrix::map (unary_mapper_
     case umap_ ## UMAP: \
       return octave_value (matrix.map<TYPE> (FCN))
 
       ARRAY_MAPPER (acos, Complex, rc_acos);
       ARRAY_MAPPER (acosh, Complex, rc_acosh);
       ARRAY_MAPPER (angle, double, ::arg);
       ARRAY_MAPPER (arg, double, ::arg);
       ARRAY_MAPPER (asin, Complex, rc_asin);
-      ARRAY_MAPPER (asinh, double, ::asinh);
+      ARRAY_MAPPER (asinh, double, xasinh);
       ARRAY_MAPPER (atan, double, ::atan);
       ARRAY_MAPPER (atanh, Complex, rc_atanh);
-      ARRAY_MAPPER (erf, double, ::erf);
+      ARRAY_MAPPER (erf, double, xerf);
       ARRAY_MAPPER (erfinv, double, ::erfinv);
       ARRAY_MAPPER (erfcinv, double, ::erfcinv);
-      ARRAY_MAPPER (erfc, double, ::erfc);
+      ARRAY_MAPPER (erfc, double, xerfc);
       ARRAY_MAPPER (erfcx, double, ::erfcx);
       ARRAY_MAPPER (erfi, double, ::erfi);
       ARRAY_MAPPER (dawson, double, ::dawson);
       ARRAY_MAPPER (gamma, double, xgamma);
       ARRAY_MAPPER (lgamma, Complex, rc_lgamma);
-      ARRAY_MAPPER (cbrt, double, ::cbrt);
+      ARRAY_MAPPER (cbrt, double, xcbrt);
       ARRAY_MAPPER (ceil, double, ::ceil);
       ARRAY_MAPPER (cos, double, ::cos);
       ARRAY_MAPPER (cosh, double, ::cosh);
       ARRAY_MAPPER (exp, double, ::exp);
-      ARRAY_MAPPER (expm1, double, ::expm1);
+      ARRAY_MAPPER (expm1, double, xexpm1);
       ARRAY_MAPPER (fix, double, ::fix);
       ARRAY_MAPPER (floor, double, ::floor);
       ARRAY_MAPPER (log, Complex, rc_log);
       ARRAY_MAPPER (log2, Complex, rc_log2);
       ARRAY_MAPPER (log10, Complex, rc_log10);
       ARRAY_MAPPER (log1p, Complex, rc_log1p);
       ARRAY_MAPPER (round, double, xround);
       ARRAY_MAPPER (roundb, double, xroundb);
diff --git a/libinterp/octave-value/ov-scalar.cc b/libinterp/octave-value/ov-scalar.cc
--- a/libinterp/octave-value/ov-scalar.cc
+++ b/libinterp/octave-value/ov-scalar.cc
@@ -307,34 +307,34 @@ octave_scalar::map (unary_mapper_t umap)
       return octave_value (FCN (scalar))
 
       SCALAR_MAPPER (abs, ::fabs);
       SCALAR_MAPPER (acos, rc_acos);
       SCALAR_MAPPER (acosh, rc_acosh);
       SCALAR_MAPPER (angle, ::arg);
       SCALAR_MAPPER (arg, ::arg);
       SCALAR_MAPPER (asin, rc_asin);
-      SCALAR_MAPPER (asinh, ::asinh);
+      SCALAR_MAPPER (asinh, xasinh);
       SCALAR_MAPPER (atan, ::atan);
       SCALAR_MAPPER (atanh, rc_atanh);
-      SCALAR_MAPPER (erf, ::erf);
+      SCALAR_MAPPER (erf, xerf);
       SCALAR_MAPPER (erfinv, ::erfinv);
       SCALAR_MAPPER (erfcinv, ::erfcinv);
-      SCALAR_MAPPER (erfc, ::erfc);
+      SCALAR_MAPPER (erfc, xerfc);
       SCALAR_MAPPER (erfcx, ::erfcx);
       SCALAR_MAPPER (erfi, ::erfi);
       SCALAR_MAPPER (dawson, ::dawson);
       SCALAR_MAPPER (gamma, xgamma);
       SCALAR_MAPPER (lgamma, rc_lgamma);
-      SCALAR_MAPPER (cbrt, ::cbrt);
+      SCALAR_MAPPER (cbrt, xcbrt);
       SCALAR_MAPPER (ceil, ::ceil);
       SCALAR_MAPPER (cos, ::cos);
       SCALAR_MAPPER (cosh, ::cosh);
       SCALAR_MAPPER (exp, ::exp);
-      SCALAR_MAPPER (expm1, ::expm1);
+      SCALAR_MAPPER (expm1, xexpm1);
       SCALAR_MAPPER (fix, ::fix);
       SCALAR_MAPPER (floor, gnulib::floor);
       SCALAR_MAPPER (log, rc_log);
       SCALAR_MAPPER (log2, rc_log2);
       SCALAR_MAPPER (log10, rc_log10);
       SCALAR_MAPPER (log1p, rc_log1p);
       SCALAR_MAPPER (round, xround);
       SCALAR_MAPPER (roundb, xroundb);
diff --git a/liboctave/numeric/lo-mappers.cc b/liboctave/numeric/lo-mappers.cc
--- a/liboctave/numeric/lo-mappers.cc
+++ b/liboctave/numeric/lo-mappers.cc
@@ -190,22 +190,16 @@ acos (const Complex& x)
     }
   else
     tmp = 1.0 - x*x;
 
   return -i * log (x + i * sqrt (tmp));
 }
 
 Complex
-acosh (const Complex& x)
-{
-  return log (x + sqrt (x + 1.0) * sqrt (x - 1.0));
-}
-
-Complex
 asin (const Complex& x)
 {
   static Complex i (0, 1);
 
   Complex tmp;
 
   if (imag (x) == 0.0)
     {
@@ -217,35 +211,23 @@ asin (const Complex& x)
     }
   else
     tmp = 1.0 - x*x;
 
   return -i * log (i*x + sqrt (tmp));
 }
 
 Complex
-asinh (const Complex& x)
-{
-  return log (x + sqrt (x*x + 1.0));
-}
-
-Complex
 atan (const Complex& x)
 {
   static Complex i (0, 1);
 
   return i * log ((i + x) / (i - x)) / 2.0;
 }
 
-Complex
-atanh (const Complex& x)
-{
-  return log ((1.0 + x) / (1.0 - x)) / 2.0;
-}
-
 // complex -> bool mappers.
 
 bool
 octave_is_NA (const Complex& x)
 {
   return (octave_is_NA (real (x)) || octave_is_NA (imag (x)));
 }
 
@@ -427,22 +409,16 @@ acos (const FloatComplex& x)
     }
   else
     tmp = 1.0f - x*x;
 
   return -i * log (x + i * sqrt (tmp));
 }
 
 FloatComplex
-acosh (const FloatComplex& x)
-{
-  return log (x + sqrt (x + 1.0f) * sqrt (x - 1.0f));
-}
-
-FloatComplex
 asin (const FloatComplex& x)
 {
   static FloatComplex i (0, 1);
 
   FloatComplex tmp;
 
   if (imag (x) == 0.0f)
     {
@@ -454,35 +430,23 @@ asin (const FloatComplex& x)
     }
   else
     tmp = 1.0f - x*x;
 
   return -i * log (i*x + sqrt (tmp));
 }
 
 FloatComplex
-asinh (const FloatComplex& x)
-{
-  return log (x + sqrt (x*x + 1.0f));
-}
-
-FloatComplex
 atan (const FloatComplex& x)
 {
   static FloatComplex i (0, 1);
 
   return i * log ((i + x) / (i - x)) / 2.0f;
 }
 
-FloatComplex
-atanh (const FloatComplex& x)
-{
-  return log ((1.0f + x) / (1.0f - x)) / 2.0f;
-}
-
 // complex -> bool mappers.
 
 bool
 octave_is_NA (const FloatComplex& x)
 {
   return (octave_is_NA (real (x)) || octave_is_NA (imag (x)));
 }
 
@@ -518,23 +482,23 @@ FloatComplex
 rc_acos (float x)
 {
   return fabsf (x) > 1.0f ? acos (FloatComplex (x)) : FloatComplex (acosf (x));
 }
 
 Complex
 rc_acosh (double x)
 {
-  return x < 1.0 ? acosh (Complex (x)) : Complex (acosh (x));
+  return x < 1.0 ? xacosh (Complex (x)) : Complex (xacosh (x));
 }
 
 FloatComplex
 rc_acosh (float x)
 {
-  return x < 1.0f ? acosh (FloatComplex (x)) : FloatComplex (acoshf (x));
+  return x < 1.0f ? xacosh (FloatComplex (x)) : FloatComplex (xacosh (x));
 }
 
 Complex
 rc_asin (double x)
 {
   return fabs (x) > 1.0 ? asin (Complex (x)) : Complex (asin (x));
 }
 
@@ -542,24 +506,24 @@ FloatComplex
 rc_asin (float x)
 {
   return fabsf (x) > 1.0f ? asin (FloatComplex (x)) : FloatComplex (asinf (x));
 }
 
 Complex
 rc_atanh (double x)
 {
-  return fabs (x) > 1.0 ? atanh (Complex (x)) : Complex (atanh (x));
+  return fabs (x) > 1.0 ? xatanh (Complex (x)) : Complex (xatanh (x));
 }
 
 FloatComplex
 rc_atanh (float x)
 {
-  return fabsf (x) > 1.0f ? atanh (FloatComplex (x))
-                          : FloatComplex (atanhf (x));
+  return fabsf (x) > 1.0f ? xatanh (FloatComplex (x))
+                          : FloatComplex (xatanh (x));
 }
 
 Complex
 rc_log (double x)
 {
   const double pi = 3.14159265358979323846;
   return x < 0.0 ? Complex (gnulib::log (-x), pi) : Complex (gnulib::log (x));
 }
diff --git a/liboctave/numeric/lo-mappers.h b/liboctave/numeric/lo-mappers.h
--- a/liboctave/numeric/lo-mappers.h
+++ b/liboctave/numeric/lo-mappers.h
@@ -98,21 +98,18 @@ xmin (double x, double y)
 
 inline double
 xmax (double x, double y)
 {
   return xisnan (y) ? x : (x >= y ? x : y);
 }
 
 extern OCTAVE_API Complex acos (const Complex& x);
-extern OCTAVE_API Complex acosh (const Complex& x);
 extern OCTAVE_API Complex asin (const Complex& x);
-extern OCTAVE_API Complex asinh (const Complex& x);
 extern OCTAVE_API Complex atan (const Complex& x);
-extern OCTAVE_API Complex atanh (const Complex& x);
 
 extern OCTAVE_API bool octave_is_NA (const Complex& x);
 extern OCTAVE_API bool octave_is_NaN_or_NA (const Complex& x);
 
 extern OCTAVE_API Complex xmin (const Complex& x, const Complex& y);
 extern OCTAVE_API Complex xmax (const Complex& x, const Complex& y);
 
 // Single Precision
@@ -163,21 +160,18 @@ xmin (float x, float y)
 
 inline float
 xmax (float x, float y)
 {
   return xisnan (y) ? x : (x >= y ? x : y);
 }
 
 extern OCTAVE_API FloatComplex acos (const FloatComplex& x);
-extern OCTAVE_API FloatComplex acosh (const FloatComplex& x);
 extern OCTAVE_API FloatComplex asin (const FloatComplex& x);
-extern OCTAVE_API FloatComplex asinh (const FloatComplex& x);
 extern OCTAVE_API FloatComplex atan (const FloatComplex& x);
-extern OCTAVE_API FloatComplex atanh (const FloatComplex& x);
 
 extern OCTAVE_API bool octave_is_NA (const FloatComplex& x);
 extern OCTAVE_API bool octave_is_NaN_or_NA (const FloatComplex& x);
 
 extern OCTAVE_API FloatComplex xmin (const FloatComplex& x,
                                      const FloatComplex& y);
 extern OCTAVE_API FloatComplex xmax (const FloatComplex& x,
                                      const FloatComplex& y);
diff --git a/liboctave/numeric/lo-specfun.cc b/liboctave/numeric/lo-specfun.cc
--- a/liboctave/numeric/lo-specfun.cc
+++ b/liboctave/numeric/lo-specfun.cc
@@ -193,138 +193,196 @@ extern "C"
                            float*, octave_idx_type*, octave_idx_type*);
 
   F77_RET_T
   F77_FUNC (dpsifn, DPSIFN) (const double*, const octave_idx_type&,
                              const octave_idx_type&, const octave_idx_type&,
                              double*, octave_idx_type*, octave_idx_type*);
 }
 
-#if ! defined (HAVE_ACOSH)
 double
-acosh (double x)
+xacosh (double x)
 {
+#if defined (HAVE_ACOSH)
+  return acosh (x);
+#else
   double retval;
   F77_XFCN (xdacosh, XDACOSH, (x, retval));
   return retval;
+#endif
 }
-#endif
-
-#if ! defined (HAVE_ACOSHF)
+
 float
-acoshf (float x)
+xacosh (float x)
 {
+#if defined (HAVE_ACOSHF)
+  return acoshf (x);
+#else
   float retval;
   F77_XFCN (xacosh, XACOSH, (x, retval));
   return retval;
+#endif
 }
-#endif
-
-#if ! defined (HAVE_ASINH)
+
+Complex
+xacosh (const Complex& x)
+{
+  return log (x + sqrt (x + 1.0) * sqrt (x - 1.0));
+}
+
+FloatComplex
+xacosh (const FloatComplex& x)
+{
+  return log (x + sqrt (x + 1.0f) * sqrt (x - 1.0f));
+}
+
 double
-asinh (double x)
+xasinh (double x)
 {
+#if defined (HAVE_ASINH)
+  return asinh (x);
+#else
   double retval;
   F77_XFCN (xdasinh, XDASINH, (x, retval));
   return retval;
+#endif
 }
-#endif
-
-#if ! defined (HAVE_ASINHF)
+
 float
-asinhf (float x)
+xasinh (float x)
 {
+#if defined (HAVE_ASINHF)
+  return asinhf (x);
+#else
   float retval;
   F77_XFCN (xasinh, XASINH, (x, retval));
   return retval;
+#endif
 }
-#endif
-
-#if ! defined (HAVE_ATANH)
+
+Complex
+xasinh (const Complex& x)
+{
+  return log (x + sqrt (x*x + 1.0));
+}
+
+FloatComplex
+xasinh (const FloatComplex& x)
+{
+  return log (x + sqrt (x*x + 1.0f));
+}
+
 double
-atanh (double x)
+xatanh (double x)
 {
+#if defined (HAVE_ATANH)
+  return atanh (x);
+#else
   double retval;
   F77_XFCN (xdatanh, XDATANH, (x, retval));
   return retval;
+#endif
 }
-#endif
-
-#if ! defined (HAVE_ATANHF)
+
 float
-atanhf (float x)
+xatanh (float x)
 {
+#if defined (HAVE_ATANHF)
+  return atanhf (x);
+#else
   float retval;
   F77_XFCN (xatanh, XATANH, (x, retval));
   return retval;
+#endif
 }
-#endif
-
-#if ! defined (HAVE_ERF)
+
+Complex
+xatanh (const Complex& x)
+{
+  return log ((1.0 + x) / (1.0 - x)) / 2.0;
+}
+
+FloatComplex
+xatanh (const FloatComplex& x)
+{
+  return log ((1.0f + x) / (1.0f - x)) / 2.0f;
+}
+
 double
-erf (double x)
+xerf (double x)
 {
+#if defined (HAVE_ERF)
+  return erf (x);
+#else
   double retval;
   F77_XFCN (xderf, XDERF, (x, retval));
   return retval;
+#endif
 }
-#endif
-
-#if ! defined (HAVE_ERFF)
+
 float
-erff (float x)
+xerf (float x)
 {
+#if defined (HAVE_ERFF)
+  return erff (x);
+#else
   float retval;
   F77_XFCN (xerf, XERF, (x, retval));
   return retval;
-}
 #endif
-
-#if ! defined (HAVE_ERFC)
-double
-erfc (double x)
-{
-  double retval;
-  F77_XFCN (xderfc, XDERFC, (x, retval));
-  return retval;
 }
-#endif
-
-#if ! defined (HAVE_ERFCF)
-float
-erfcf (float x)
-{
-  float retval;
-  F77_XFCN (xerfc, XERFC, (x, retval));
-  return retval;
-}
-#endif
 
 // Complex error function from the Faddeeva package
 Complex
-erf (const Complex& x)
+xerf (const Complex& x)
 {
   return Faddeeva::erf (x);
 }
+
 FloatComplex
-erf (const FloatComplex& x)
+xerf (const FloatComplex& x)
 {
   Complex xd (real (x), imag (x));
   Complex ret = Faddeeva::erf (xd, std::numeric_limits<float>::epsilon ());
   return FloatComplex (real (ret), imag (ret));
 }
 
+double
+xerfc (double x)
+{
+#if defined (HAVE_ERFC)
+  return erfc (x);
+#else
+  double retval;
+  F77_XFCN (xderfc, XDERFC, (x, retval));
+  return retval;
+#endif
+}
+
+float
+xerfc (float x)
+{
+#if defined (HAVE_ERFCF)
+  return erfcf (x);
+#else
+  float retval;
+  F77_XFCN (xerfc, XERFC, (x, retval));
+  return retval;
+#endif
+}
+
 // Complex complementary error function from the Faddeeva package
 Complex
-erfc (const Complex& x)
+xerfc (const Complex& x)
 {
   return Faddeeva::erfc (x);
 }
+
 FloatComplex
-erfc (const FloatComplex& x)
+xerfc (const FloatComplex& x)
 {
   Complex xd (real (x), imag (x));
   Complex ret = Faddeeva::erfc (xd, std::numeric_limits<float>::epsilon ());
   return FloatComplex (real (ret), imag (ret));
 }
 
 // Real and complex scaled complementary error function from Faddeeva package
 float erfcx (float x) { return Faddeeva::erfcx(x); }
@@ -513,20 +571,22 @@ rc_lgamma (float x)
 #endif
 
   if (sgngam < 0)
     return result + FloatComplex (0., M_PI);
   else
     return result;
 }
 
-#if ! defined (HAVE_EXPM1)
 double
-expm1 (double x)
+xexpm1 (double x)
 {
+#if defined (HAVE_EXPM1)
+  return expm1 (x);
+#else
   double retval;
 
   double ax = fabs (x);
 
   if (ax < 0.1)
     {
       ax /= 16;
 
@@ -546,42 +606,44 @@ expm1 (double x)
         }
 
       retval = (x > 0) ? s : -s / (1+s);
     }
   else
     retval = exp (x) - 1;
 
   return retval;
+#endif
 }
-#endif
 
 Complex
-expm1 (const Complex& x)
+xexpm1 (const Complex& x)
 {
   Complex retval;
 
   if (std:: abs (x) < 1)
     {
       double im = x.imag ();
-      double u = expm1 (x.real ());
+      double u = xexpm1 (x.real ());
       double v = sin (im/2);
       v = -2*v*v;
       retval = Complex (u*v + u + v, (u+1) * sin (im));
     }
   else
     retval = std::exp (x) - Complex (1);
 
   return retval;
 }
 
-#if ! defined (HAVE_EXPM1F)
 float
-expm1f (float x)
+xexpm1 (float x)
 {
+#if defined (HAVE_EXPM1F)
+  return expm1f (x);
+#else
   float retval;
 
   float ax = fabs (x);
 
   if (ax < 0.1)
     {
       ax /= 16;
 
@@ -601,42 +663,44 @@ expm1f (float x)
         }
 
       retval = (x > 0) ? s : -s / (1+s);
     }
   else
     retval = exp (x) - 1;
 
   return retval;
+#endif
 }
-#endif
 
 FloatComplex
-expm1 (const FloatComplex& x)
+xexpm1 (const FloatComplex& x)
 {
   FloatComplex retval;
 
   if (std:: abs (x) < 1)
     {
       float im = x.imag ();
-      float u = expm1 (x.real ());
+      float u = xexpm1 (x.real ());
       float v = sin (im/2);
       v = -2*v*v;
       retval = FloatComplex (u*v + u + v, (u+1) * sin (im));
     }
   else
     retval = std::exp (x) - FloatComplex (1);
 
   return retval;
 }
 
-#if ! defined (HAVE_LOG1P)
 double
-log1p (double x)
+xlog1p (double x)
 {
+#if defined (HAVE_LOG1P)
+  return log1p (x);
+#else
   double retval;
 
   double ax = fabs (x);
 
   if (ax < 0.2)
     {
       // approximation log (1+x) ~ 2*sum ((x/(2+x)).^ii ./ ii), ii = 1:2:2n+1
       double u = x / (2 + x), t = 1, s = 0;
@@ -644,58 +708,70 @@ log1p (double x)
         s += (t *= u*u) / (i+1);
 
       retval = 2 * (s + 1) * u;
     }
   else
     retval = gnulib::log (1 + x);
 
   return retval;
+#endif
 }
-#endif
 
 Complex
-log1p (const Complex& x)
+xlog1p (const Complex& x)
 {
   Complex retval;
 
   double r = x.real (), i = x.imag ();
 
   if (fabs (r) < 0.5 && fabs (i) < 0.5)
     {
       double u = 2*r + r*r + i*i;
-      retval = Complex (log1p (u / (1+sqrt (u+1))),
+      retval = Complex (xlog1p (u / (1+sqrt (u+1))),
                         atan2 (1 + r, i));
     }
   else
     retval = std::log (Complex (1) + x);
 
   return retval;
 }
 
-#if ! defined (HAVE_CBRT)
-double cbrt (double x)
+template <typename T>
+T
+xxcbrt (T x)
 {
-  static const double one_third = 0.3333333333333333333;
+  static const T one_third = 0.3333333333333333333f;
   if (xfinite (x))
     {
       // Use pow.
-      double y = std::pow (std::abs (x), one_third) * signum (x);
+      T y = std::pow (std::abs (x), one_third) * signum (x);
       // Correct for better accuracy.
       return (x / (y*y) + y + y) / 3;
     }
   else
     return x;
 }
+
+double
+xcbrt (double x)
+{
+#if defined (HAVE_CBRT)
+  return cbrt (x);
+#else
+  return xxcbrt (x);
 #endif
-
-#if ! defined (HAVE_LOG1PF)
+}
+
 float
-log1pf (float x)
+xlog1p (float x)
 {
+#if defined (HAVE_LOG1PF)
+  return log1pf (x);
+#else
   float retval;
 
   float ax = fabs (x);
 
   if (ax < 0.2)
     {
       // approximation log (1+x) ~ 2*sum ((x/(2+x)).^ii ./ ii), ii = 1:2:2n+1
       float u = x / (2 + x), t = 1.0f, s = 0;
@@ -703,53 +779,47 @@ log1pf (float x)
         s += (t *= u*u) / (i+1);
 
       retval = 2 * (s + 1.0f) * u;
     }
   else
     retval = gnulib::logf (1.0f + x);
 
   return retval;
+#endif
 }
-#endif
 
 FloatComplex
-log1p (const FloatComplex& x)
+xlog1p (const FloatComplex& x)
 {
   FloatComplex retval;
 
   float r = x.real (), i = x.imag ();
 
   if (fabs (r) < 0.5 && fabs (i) < 0.5)
     {
       float u = 2*r + r*r + i*i;
-      retval = FloatComplex (log1p (u / (1+sqrt (u+1))),
+      retval = FloatComplex (xlog1p (u / (1+sqrt (u+1))),
                              atan2 (1 + r, i));
     }
   else
     retval = std::log (FloatComplex (1) + x);
 
   return retval;
 }
 
-#if ! defined (HAVE_CBRTF)
-float cbrtf (float x)
+float
+xcbrt (float x)
 {
-  static const float one_third = 0.3333333333333333333f;
-  if (xfinite (x))
-    {
-      // Use pow.
-      float y = std::pow (std::abs (x), one_third) * signum (x);
-      // Correct for better accuracy.
-      return (x / (y*y) + y + y) / 3;
-    }
-  else
-    return x;
+#if defined (HAVE_CBRTF)
+  return cbrtf (x);
+#else
+  return xxcbrt (x);
+#endif
 }
-#endif
 
 static inline Complex
 zbesj (const Complex& z, double alpha, int kode, octave_idx_type& ierr);
 
 static inline Complex
 zbesy (const Complex& z, double alpha, int kode, octave_idx_type& ierr);
 
 static inline Complex
@@ -2887,25 +2957,25 @@ gammainc (const FloatNDArray& x, const F
 }
 
 
 Complex rc_log1p (double x)
 {
   const double pi = 3.14159265358979323846;
   return (x < -1.0
           ? Complex (gnulib::log (-(1.0 + x)), pi)
-          : Complex (log1p (x)));
+          : Complex (xlog1p (x)));
 }
 
 FloatComplex rc_log1p (float x)
 {
   const float pi = 3.14159265358979323846f;
   return (x < -1.0f
           ? FloatComplex (gnulib::logf (-(1.0f + x)), pi)
-          : FloatComplex (log1pf (x)));
+          : FloatComplex (xlog1p (x)));
 }
 
 // This algorithm is due to P. J. Acklam.
 //
 // See http://home.online.no/~pjacklam/notes/invnorm/
 //
 // The rational approximation has relative accuracy 1.15e-9 in the whole
 // region.  For doubles, it is refined by a single step of Halley's 3rd
diff --git a/liboctave/numeric/lo-specfun.h b/liboctave/numeric/lo-specfun.h
--- a/liboctave/numeric/lo-specfun.h
+++ b/liboctave/numeric/lo-specfun.h
@@ -36,87 +36,55 @@ class ComplexColumnVector;
 class FloatMatrix;
 class FloatComplexMatrix;
 class FloatNDArray;
 class FloatComplexNDArray;
 class FloatRowVector;
 class FloatComplexColumnVector;
 class Range;
 
-#if ! defined (HAVE_ACOSH)
-extern OCTAVE_API double acosh (double);
-#endif
-
-#if ! defined (HAVE_ASINH)
-extern OCTAVE_API double asinh (double);
-#endif
+extern OCTAVE_API double xacosh (double);
+extern OCTAVE_API float xacosh (float);
+extern OCTAVE_API Complex xacosh (const Complex& x);
+extern OCTAVE_API FloatComplex xacosh (const FloatComplex& x);
 
-#if ! defined (HAVE_ATANH)
-extern OCTAVE_API double atanh (double);
-#endif
-
-#if ! defined (HAVE_ERF)
-extern OCTAVE_API double erf (double);
-#endif
-extern OCTAVE_API Complex erf (const Complex& x);
-extern OCTAVE_API FloatComplex erf (const FloatComplex& x);
+extern OCTAVE_API double xasinh (double);
+extern OCTAVE_API float xasinh (float);
+extern OCTAVE_API Complex xasinh (const Complex& x);
+extern OCTAVE_API FloatComplex xasinh (const FloatComplex& x);
 
-#if ! defined (HAVE_ERFC)
-extern OCTAVE_API double erfc (double);
-#endif
-extern OCTAVE_API Complex erfc (const Complex& x);
-extern OCTAVE_API FloatComplex erfc (const FloatComplex& x);
+extern OCTAVE_API double xatanh (double);
+extern OCTAVE_API float xatanh (float);
+extern OCTAVE_API Complex xatanh (const Complex& x);
+extern OCTAVE_API FloatComplex xatanh (const FloatComplex& x);
 
-#if ! defined (HAVE_ACOSHF)
-extern OCTAVE_API float acoshf (float);
-#endif
-
-#if ! defined (HAVE_ASINHF)
-extern OCTAVE_API float asinhf (float);
-#endif
-
-#if ! defined (HAVE_ATANHF)
-extern OCTAVE_API float atanhf (float);
-#endif
+extern OCTAVE_API double xerf (double);
+extern OCTAVE_API float xerf (float);
+extern OCTAVE_API Complex xerf (const Complex& x);
+extern OCTAVE_API FloatComplex xerf (const FloatComplex& x);
 
-#if ! defined (HAVE_ERFF)
-extern OCTAVE_API float erff (float);
-#endif
-
-#if ! defined (HAVE_ERFCF)
-extern OCTAVE_API float erfcf (float);
-#endif
+extern OCTAVE_API double xerfc (double);
+extern OCTAVE_API float xerfc (float);
+extern OCTAVE_API Complex xerfc (const Complex& x);
+extern OCTAVE_API FloatComplex xerfc (const FloatComplex& x);
 
-#if ! defined (HAVE_EXPM1)
-extern OCTAVE_API double expm1 (double x);
-#endif
-extern OCTAVE_API Complex expm1 (const Complex& x);
-
-#if ! defined (HAVE_EXPM1F)
-extern OCTAVE_API float expm1f (float x);
-#endif
-extern OCTAVE_API FloatComplex expm1 (const FloatComplex& x);
+extern OCTAVE_API double xexpm1 (double x);
+extern OCTAVE_API Complex xexpm1 (const Complex& x);
 
-#if ! defined (HAVE_LOG1P)
-extern OCTAVE_API double log1p (double x);
-#endif
-extern OCTAVE_API Complex log1p (const Complex& x);
+extern OCTAVE_API float xexpm1 (float x);
+extern OCTAVE_API FloatComplex xexpm1 (const FloatComplex& x);
+
+extern OCTAVE_API double xlog1p (double x);
+extern OCTAVE_API Complex xlog1p (const Complex& x);
 
-#if ! defined (HAVE_LOG1PF)
-extern OCTAVE_API float log1pf (float x);
-#endif
-extern OCTAVE_API FloatComplex log1p (const FloatComplex& x);
+extern OCTAVE_API float xlog1p (float x);
+extern OCTAVE_API FloatComplex xlog1p (const FloatComplex& x);
 
-#if ! defined (HAVE_CBRT)
-extern OCTAVE_API double cbrt (double x);
-#endif
-
-#if ! defined (HAVE_CBRTF)
-extern OCTAVE_API float cbrtf (float x);
-#endif
+extern OCTAVE_API double xcbrt (double x);
+extern OCTAVE_API float xcbrt (float x);
 
 extern OCTAVE_API double xgamma (double x);
 extern OCTAVE_API double xlgamma (double x);
 extern OCTAVE_API Complex rc_lgamma (double x);
 
 extern OCTAVE_API float xgamma (float x);
 extern OCTAVE_API float xlgamma (float x);
 extern OCTAVE_API FloatComplex rc_lgamma (float x);
