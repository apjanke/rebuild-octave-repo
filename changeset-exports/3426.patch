# HG changeset patch
# User jwe
# Date 947752853 0
#      Thu Jan 13 08:40:53 2000 +0000
# Node ID f8dde1807dee9796b72785c6cdbad93b020d2b43
# Parent  8625164a0a398808ce4851289f21313122ce1861
[project @ 2000-01-13 08:40:00 by jwe]

diff --git a/scripts/audio/loadaudio.m b/scripts/audio/loadaudio.m
--- a/scripts/audio/loadaudio.m
+++ b/scripts/audio/loadaudio.m
@@ -15,23 +15,23 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} loadaudio (@var{name}, @var{ext}, @var{bps})
 ## Loads audio data from the file @file{@var{name}.@var{ext}} into the
-## vector @var{x}.  
+## vector @var{x}.
 ##
 ## The extension @var{ext} determines how the data in the audio file is
 ## interpreted;  the extensions @file{lin} (default) and @file{raw}
 ## correspond to linear, the extensions @file{au}, @file{mu}, or @file{snd}
 ## to mu-law encoding.
-## 
+##
 ## The argument @var{bps} can be either 8 (default) or 16, and specifies
 ## the number of bits per sample used in the audio file.
 ## @end deftypefn
 ## @seealso{lin2mu, mu2lin, saveaudio, playaudio, setaudio, and record}
 
 ## Author: AW <Andreas.Weingessel@ci.tuwien.ac.at>
 ## Created: 10 April 1994
 ## Adapted-By: jwe
diff --git a/scripts/audio/playaudio.m b/scripts/audio/playaudio.m
--- a/scripts/audio/playaudio.m
+++ b/scripts/audio/playaudio.m
@@ -33,20 +33,20 @@ function playaudio (name, ext)
 
   usage_msg = "playaudio (name [, ext])  or  playaudio (X)";
 
   if (nargin == 1 && is_vector (name) && ! isstr (name))
     ## play a vector
     [nr, nc] = size (name);
     if (nc != 1)
       if (nr == 1)
-	name = name';
-	nr = nc;
+        name = name';
+        nr = nc;
       else
-	error ("playaudio: X must be a vector");
+        error ("playaudio: X must be a vector");
       endif
     endif
     X = name + 127;
     unwind_protect
       file = tmpnam ();
       num = fopen (file, "wb");
       c = fwrite (num, X, "uchar");
       fclose (num);
diff --git a/scripts/audio/saveaudio.m b/scripts/audio/saveaudio.m
--- a/scripts/audio/saveaudio.m
+++ b/scripts/audio/saveaudio.m
@@ -12,17 +12,17 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
-## -*- texinfo -*- 
+## -*- texinfo -*-
 ## @deftypefn {Function File} {} saveaudio (@var{name}, @var{x}, @var{ext}, @var{bps})
 ## Saves a vector @var{x} of audio data to the file
 ## @file{@var{name}.@var{ext}}.  The optional parameters @var{ext} and
 ## @var{bps} determine the encoding and the number of bits per sample used
 ## in the audio file (see @code{loadaudio});  defaults are @file{lin} and
 ## 8, respectively.
 ## @end deftypefn
 ## @seealso{lin2mu, mu2lin, loadaudio, playaudio, setaudio, and record}
@@ -58,22 +58,22 @@ function saveaudio (name, X, ext, bit)
   endif
 
   num = fopen ([name, ".", ext], "wb");
 
   if (strcmp (ext, "lin") || strcmp (ext, "raw"))
     if (bit == 8)
       ld = max (abs (X));
       if (ld > 127)   # convert 16 to 8 bit
-	if (ld < 16384)
-	  sc = 64 / ld;
-	else
-	  sc = 1 / 256;
-	endif
-	X = fix (X * sc);
+        if (ld < 16384)
+          sc = 64 / ld;
+        else
+          sc = 1 / 256;
+        endif
+        X = fix (X * sc);
       endif
       X = X + 127;
       c = fwrite (num, X, "uchar");
     else
       c = fwrite (num, X, "short");
     endif
   elseif (strcmp (ext, "mu") || strcmp (ext, "au") || strcmp (ext, "snd"))
     Y = lin2mu (X);
diff --git a/scripts/control/obsolete/dlqg.m b/scripts/control/obsolete/dlqg.m
--- a/scripts/control/obsolete/dlqg.m
+++ b/scripts/control/obsolete/dlqg.m
@@ -1,50 +1,50 @@
 ## Copyright (C) 1996 Auburn University.  All rights reserved.
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ##  O B S O L E T E * * * D O   N O T   U S E!
 ##
 ##  Use lqg instead.
 ##
 ## function [K,Q,P,Ee,Er] = dlqg(A,B,C,G,Sigw,Sigv,Q,R)
 ## function [K,Q,P,Ee,Er] = dlqg(Sys,Sigw,Sigv,Q,R)
-## 
+##
 ## design a discrete-time linear quadratic gaussian optimal controller
 ## for the system
 ##
 ##  x(k+1) = A x(k) + B u(k) + G w(k)       [w]=N(0,[Sigw 0    ])
 ##    y(k) = C x(k) + v(k)                  [v]  (    0   Sigv ])
 ##
 ## Outputs:
 ##    K: system data structure format LQG optimal controller
 ##    P: Solution of control (state feedback) algebraic Riccati equation
 ##    Q: Solution of estimation algebraic Riccati equation
 ##    Ee: estimator poles
 ##    Es: controller poles
 ## inputs:
-##  A,B,C,G, or Sys: state space representation of system.  
-##  Sigw, Sigv: covariance matrices of independent Gaussian noise processes 
+##  A,B,C,G, or Sys: state space representation of system.
+##  Sigw, Sigv: covariance matrices of independent Gaussian noise processes
 ##      (as above)
-##  Q, R: state, control weighting matrices for dlqr call respectively.  
+##  Q, R: state, control weighting matrices for dlqr call respectively.
 ##
 ## See also: lqg, dlqe, dlqr
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: August 1995
 
 function [K, Q, P, Ee, Er] = dlqg (A, B, C, G, Sigw, Sigv, Q, R)
 
@@ -65,20 +65,20 @@ function [K, Q, P, Ee, Er] = dlqg (A, B,
     endif
 
     if(ncstates)
       error("dlqg: system has continuous-time states (try lqg?)")
     elseif(ndstates < 1)
       error("dlqg: system has no discrete time states")
     elseif(nin <= columns(Sigw))
       error(["dlqg: ",num2str(nin)," inputs provided, noise dimension is ", ...
-	  num2str(columns(Sigw))])
+          num2str(columns(Sigw))])
     elseif(nout != columns(Sigv))
       error(["dlqg: number of outputs (",num2str(nout),") incompatible with ", ...
-	  "dimension of Sigv (",num2str(columns(Sigv)),")"])
+          "dimension of Sigv (",num2str(columns(Sigv)),")"])
     endif
 
     ## put parameters into correct variables
     R = Sigw;
     Q = G;
     Sigv = C;
     Sigw = B;
     [A,B,C,D] = sys2ss(Sys)
diff --git a/scripts/control/obsolete/minfo.m b/scripts/control/obsolete/minfo.m
--- a/scripts/control/obsolete/minfo.m
+++ b/scripts/control/obsolete/minfo.m
@@ -1,77 +1,77 @@
 ## Copyright (C) 1996 Auburn University.  All rights reserved.
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ##  function [systype, nout, nin, ncstates, ndstates] = minfo(inmat)
 ##
 ## MINFO:  Determines the type of system matrix.  INMAT can be
 ##         a varying(*), system, constant, and empty matrix.
 ##
 ##    Returns:
 ##      systype can be one of:
 ##            varying, system, constant, and empty
 ##      nout is the number of outputs of the system
 ##      nin is the number of inputs of the system
 ##      ncstates is the number of continuous states of the system
-##	 ndstates is the number of discrete states of the system
+##       ndstates is the number of discrete states of the system
 
 ## Author: R. Bruce Tenison <btenison@eng.auburn.edu>
 ## Created: July 29, 1994
 ## Modified by David Clem November 13, 1994
 ## Modified by A. S. Hodel July 1995
 
 function [systype, nout, nin, ncstates, ndstates] = minfo (inmat)
 
   warning("minfo: obsolete.  Use sys2ss, sys2tf, or sys2zp.");
-    
+
   if (nargin ~= 1 )
     disp ("MINFO: Wrong number of arguments")
     systype = nout = nin = ncstates = ndstates = [];
   endif
-  
+
   [rr,cc] = size(inmat);
-  
+
   ## Check for empty matrix first!
   if (isempty(inmat))
     systype = "empty";
     nout = nin = ncstates = ndstates = 0;
     return
-  
+
   ## Check for Constant matrix
 
   elseif (rr == 1 || cc == 1)
     systype = "constant";
     nout = nin = ncstates = ndstates = 1;
     return
-  
+
   ## Check for system type matrix
   elseif (inmat(rr,cc) == -Inf)
     systype = "system";
     ncstates = inmat(1,cc);
     ndstates = inmat(rr,1);
     nstates = ncstates + ndstates;
     nout = rr - nstates - 1;
     nin = cc - nstates - 1;
-  
+
   ## Check for Varying type matrix
   elseif (inmat(rr,cc) == Inf)
     systype = "varying";
     npoints = inmat(rr,cc-1);
     nin = cc - 1;
     nout = rr / npoints;
     nstates = 0;
 
diff --git a/scripts/control/obsolete/packsys.m b/scripts/control/obsolete/packsys.m
--- a/scripts/control/obsolete/packsys.m
+++ b/scripts/control/obsolete/packsys.m
@@ -1,56 +1,56 @@
 ## Copyright (C) 1996 Auburn University.  All rights reserved.
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## O B S O L E T E: use ss2sys instead.
 ## function Asys = packsys(a,b,c[,d,dflg])
-## 
+##
 ##   dflg: 0 for continuous time system, 1 for discrete-time system.
-## 
+##
 ## defaults:
 ##      D: 0 matrix of appropriate dimension.
 ##   dflg: 0 (continuous time)
-## 
+##
 ## Note: discrete-state sampling time is not included!
 
 ## Author: R. Bruce Tenison <btenison@eng.auburn.edu>
 ## Created: July 29, 1994
 ## Modified by David Clem November 13, 1994
 ## Modified by A. S. Hodel April 1995
 
 function Asys = packsys (a, b, c, d, dflg)
 
   warning("packsys is obsolete!  Use ss2sys instead.");
-  
+
   if (nargin < 3 || nargin > 5)
     disp("packsys: Invalid number of arguments")
   endif
 
   ## check dflg
   if(nargin == 5)
     if( !is_scalar(dflg))
       [m,n] = size(dflg);
       error(["packsys: dflg (",num2str(m),",",num2str(n), ...
-	") must be a scalar."]);
+        ") must be a scalar."]);
     elseif( (dflg != 0) && (dflg != 1))
       error(["packsys: dflg=",num2str(dflg),"must be 0 or 1"]);
     endif
   else
     ## default condition
     dflg = 0;
   endif
 
@@ -60,12 +60,12 @@ function Asys = packsys (a, b, c, d, dfl
     [crows,ccols] = size(c);
     d = zeros(crows,bcols);
   endif
 
   [n,m,p] = abcddim(a,b,c,d);
   if (n == -1 || m == -1 || p == -1)
     error("packsys: incompatible dimensions")
   endif
-  
+
   Asys = ss2sys(a,b,c,d,dflg);
 
 endfunction
diff --git a/scripts/control/obsolete/qzval.m b/scripts/control/obsolete/qzval.m
--- a/scripts/control/obsolete/qzval.m
+++ b/scripts/control/obsolete/qzval.m
@@ -1,45 +1,45 @@
 ## Copyright (C) 1998 Auburn University.  All rights reserved.
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File } { @var{x} =} qzval (@var{A}, @var{B})
-## Compute generalized eigenvalues of the matrix pencil 
+## Compute generalized eigenvalues of the matrix pencil
 ## @ifinfo
 ## @example
 ## (A - lambda B).
 ## @end example
 ## @end ifinfo
 ## @iftex
 ## @tex
 ## $(A - \lambda B)$.
 ## @end tex
 ## @end iftex
-## 
+##
 ## @var{A} and @var{B} must be real matrices.
-##  
+##
 ## @strong{Note} @code{qzval} is obsolete; use @code{qz} instead.
 ## @end deftypefn
- 
+
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: July 1998
 
 function lam = qzval (A, B)
 
   warning("qzval is obsolete; calling qz instead")
   lam = qz(A,B);
 
diff --git a/scripts/control/obsolete/series.m b/scripts/control/obsolete/series.m
--- a/scripts/control/obsolete/series.m
+++ b/scripts/control/obsolete/series.m
@@ -1,39 +1,39 @@
 ## Copyright (C) 1996 Auburn University.  All rights reserved.
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## Forms the series connection of two systems.
 ##
 ## Superseded by sysmult.  Do not use this routine!
 ## used internally in zp2ss
 ##
 ## Type of input: Transfer functions
 ## Command:       [num,den]=series(num1,den1,num2,den2)
 ## Forms the series representation of the two transfer functions.
 ##
 ## Type of input: State space systems
 ## Command:       [a,b,c,d]=series(a1,b1,c1,d1,a2,b2,c2,d2)
 ## Forms the series representation of the two state space system arguments.
-## The series connected system will have the inputs of system 1 and the 
+## The series connected system will have the inputs of system 1 and the
 ## outputs of system 2.
 ##
 ## Type of input: system data structure
 ## Command:       syst=series(syst1,syst2)
 ## Forms the series representation of the two mu system arguments.
 
 ## Author: David Clem
 ## Created: August 15, 1994
@@ -50,27 +50,27 @@ function [a, b, c, d] = series (a1, b1, 
     [a1,b1,c1,d1]=sys2ss(a1);
     [a2,b2,c2,d2]=sys2ss(temp);
     muflag = 1;
   endif
 
   ## If four arguments input, put two transfer functions in series
 
   if(nargin == 4)
-    a = conv(a1,c1);	% was conv1
-    b = conv(b1,d1);	% was conv1
+    a = conv(a1,c1);    % was conv1
+    b = conv(b1,d1);    % was conv1
     c = 0;
     d = 0;
 
     ## Find series combination of 2 state space systems
 
   elseif((nargin == 8)||(muflag == 1))
 
     ## check matrix dimensions
-  
+
     [n1,m1,p1] = abcddim(a1,b1,c1,d1);
     [n2,m2,p2] = abcddim(a2,b2,c2,d2);
 
     if((n1 == -1) || (n2 == -1))
       error("Incorrect matrix dimensions");
     endif
 
     ## check to make sure the number of outputs of system1 equals the number
@@ -87,13 +87,13 @@ function [a, b, c, d] = series (a1, b1, 
     c = [d2*c1, c2];
     d = [d2*d1];
 
     ## take care of mu output
 
     if(muflag == 1)
       a=ss2sys(a,b,c,d);
       b=c=d=0;
-    endif 
+    endif
   endif
 
 endfunction
 
diff --git a/scripts/control/obsolete/swapcols.m b/scripts/control/obsolete/swapcols.m
--- a/scripts/control/obsolete/swapcols.m
+++ b/scripts/control/obsolete/swapcols.m
@@ -1,38 +1,38 @@
 ## Copyright (C) 1996 Auburn University.  All rights reserved.
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File } { outputs =} swapcols ( inputs ) 
+## @deftypefn {Function File } { outputs =} swapcols ( inputs )
 ## @format
 ##  function B = swapcols(A)
 ##  permute columns of A into reverse order
 ## @end format
 ## @end deftypefn
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: July 23, 1992
 ## Conversion to Octave R. Bruce Tenison July 4, 1994
 
 function B = swapcols (A)
-  
+
   m = length(A(1,:));
   idx = m:-1:1;
   B = A(:,idx);
 
 endfunction
 
diff --git a/scripts/control/obsolete/swaprows.m b/scripts/control/obsolete/swaprows.m
--- a/scripts/control/obsolete/swaprows.m
+++ b/scripts/control/obsolete/swaprows.m
@@ -1,38 +1,38 @@
 ## Copyright (C) 1996 Auburn University.  All rights reserved.
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File } { outputs =} swaprows ( inputs ) 
+## @deftypefn {Function File } { outputs =} swaprows ( inputs )
 ## @format
 ##  function B = swaprows(A)
 ##  permute rows of A into reverse order
 ## @end format
 ## @end deftypefn
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: July 23, 1992
 ## Conversion to Octave R. Bruce Tenison July 4, 1994
-  
+
 function B = swaprows (A)
 
   m = rows(A);
   idx = m:-1:1;
   B = A(idx,:);
 
 endfunction
 
diff --git a/scripts/control/obsolete/syschnames.m b/scripts/control/obsolete/syschnames.m
--- a/scripts/control/obsolete/syschnames.m
+++ b/scripts/control/obsolete/syschnames.m
@@ -1,27 +1,27 @@
 ## Copyright (C) 1996, 1998 Auburn University.  All rights reserved.
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
-## -*- texinfo -*- 
+## -*- texinfo -*-
 ## @deftypefn {Function File } {@var{retsys} =} syschnames (@var{sys}, @var{opt}, @var{list}, @var{names})
 ## Superseded by @code{syssetsignals}
 ## @end deftypefn
 
 ## Author: John Ingram <ingraje@eng.auburn.edu>
 ## Created: August 1996
 ## updated by A. S. Hodel 1998
 
diff --git a/scripts/control/obsolete/unpacksys.m b/scripts/control/obsolete/unpacksys.m
--- a/scripts/control/obsolete/unpacksys.m
+++ b/scripts/control/obsolete/unpacksys.m
@@ -1,25 +1,25 @@
 ## Copyright (C) 1996 Auburn University.  All rights reserved.
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## [a,b,c,d] = unpacksys(sys)
 ## Obsolete.  Use sys2ss instead.
 
 ## Author: David Clem
 ## Created: August 19, 1994
 
 function [a, b, c, d] = unpacksys (syst)
diff --git a/scripts/elfun/gcd.m b/scripts/elfun/gcd.m
--- a/scripts/elfun/gcd.m
+++ b/scripts/elfun/gcd.m
@@ -15,32 +15,32 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Mapping Function} {} gcd (@var{x}, @code{...})
 ## Compute the greatest common divisor of the elements of @var{x}, or the
-## list of all the arguments.  For example, 
-## 
+## list of all the arguments.  For example,
+##
 ## @example
 ## gcd (a1, ..., ak)
 ## @end example
-## 
+##
 ## @noindent
 ## is the same as
-## 
+##
 ## @example
 ## gcd ([a1, ..., ak])
 ## @end example
-## 
+##
 ## An optional second return value, @var{v}
 ## contains an integer vector such that
-## 
+##
 ## @example
 ## g = v(1) * a(k) + ... + v(k) * a(k)
 ## @end example
 ## @end deftypefn
 ## @seealso{lcm, min, max, ceil, and floor}
 
 ## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Created: 16 September 1994
diff --git a/scripts/elfun/lcm.m b/scripts/elfun/lcm.m
--- a/scripts/elfun/lcm.m
+++ b/scripts/elfun/lcm.m
@@ -15,30 +15,30 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Mapping Function} {} lcm (@var{x}, @code{...})
 ## Compute the least common multiple of the elements elements of @var{x}, or
-## the list of all the arguments.  For example, 
-## 
+## the list of all the arguments.  For example,
+##
 ## @example
 ## lcm (a1, ..., ak)
 ## @end example
-## 
+##
 ## @noindent
 ## is the same as
-## 
+##
 ## @example
 ## lcm ([a1, ..., ak]).
 ## @end example
 ## @end deftypefn
-## @seealso{gcd, min, max, ceil, and floor}  
+## @seealso{gcd, min, max, ceil, and floor}
 
 ## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Created: 16 September 1994
 ## Adapted-By: jwe
 
 function l = lcm (a, ...)
 
   if (nargin == 0)
diff --git a/scripts/finance/fv.m b/scripts/finance/fv.m
--- a/scripts/finance/fv.m
+++ b/scripts/finance/fv.m
@@ -1,20 +1,20 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  fv (r, n, p [, l] [, method])
 ##
 ## Returns the future value at the end of period n of an investment
 ## which consisting of n payments of p in each period, assuming an
@@ -22,40 +22,40 @@
 ##
 ## With the optional scalar argument l, one can specify an additional
 ## lump-sum payment. With the optional argument `method', one can
 ## specify whether the payments are made at the end ("e", default) or at
 ## the beginning ("b") of each period.
 ##
 ## Note that the rate r is not specified in percent, i.e., one has to
 ## write 0.05 rather than 5 %.
-  
+
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  Future value of an investment
 
 function v = fv (r, n, p, l, m)
-  
+
   if ((nargin < 3) || (nargin > 5))
     usage ("fv (r, n, p [, l] [, method])");
   endif
-  
+
   if !(is_scalar (r) && (r > -1))
     error ("fv:  r must be a scalar > -1");
   elseif !(is_scalar (n) && (n > 0))
     error ("fv:  n must be a positive scalar");
   elseif !is_scalar (p)
     error ("fv:  p must be a scalar.");
   endif
-  
+
   if (r != 0)
     v = p * ((1 + r)^n - 1) / r;
   else
     v = p * n;
   endif
-  
+
   if (nargin > 3)
     if (nargin == 5)
       if !isstr (m)
         error ("fv:  `method' must be a string");
       endif
     elseif isstr (l)
       m = l;
       l = 0;
@@ -66,11 +66,11 @@ function v = fv (r, n, p, l, m)
       v = v * (1 + r);
     endif
     if is_scalar (l)
       v = v + fvl (r, n, l);
     else
       error ("fv:  l must be a scalar");
     endif
   endif
-  
+
 endfunction
-      
+
diff --git a/scripts/finance/fvl.m b/scripts/finance/fvl.m
--- a/scripts/finance/fvl.m
+++ b/scripts/finance/fvl.m
@@ -1,41 +1,41 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  fvl (r, n, l)
 ##
 ## Returns the future value at the end of n periods of an initial lump
 ## sum investment l, given a per-period interest rate r.
 
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  Future value of an initial lump sum investment
-  
+
 function v = fvl (r, n, l)
-  
+
   if (nargin != 3)
     usage ("fvl (r, n, l)");
   endif
-  
+
   if !(is_scalar (r) && (r > -1))
     error ("fvl:  r has to be a scalar > -1");
   elseif !(is_scalar (n) && (n > 0))
     error ("fvl:  n has to be a positive scalar");
   elseif !is_scalar (l)
     error ("fvl:  l has to be a scalar");
   endif
-  
+
   v = l * (1 + r)^n;
-  
+
 endfunction
\ No newline at end of file
diff --git a/scripts/finance/irr.m b/scripts/finance/irr.m
--- a/scripts/finance/irr.m
+++ b/scripts/finance/irr.m
@@ -1,56 +1,56 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  irr (p [, i])
 ##
 ## Computes the internal rate of return of a series of payments p from
 ## an initial investment i, i.e., the solution of npv (r, p) = i. If the
 ## second argument is omitted, i = 0 is used.
 ##
 ## See also:  npv;  pv, rate.
-  
+
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  Internal rate of return of an investment
 
 function r = irr (p, i)
-  
+
   if (nargin == 1)
     i = 0;
   elseif !(nargin == 2)
     usage ("irr (p [, i])");
   endif
-  
+
   tmp = output_precision;
   output_precision = 15;
   if !(is_vector (p))
     error ("irr:  p must be a vector");
   else
     p_string = type p;
   endif
 
   if !is_scalar (i)
     error ("irr:  i must be a scalar");
   endif
-  
+
   string = ["function delta = f (r) ", ...
       "delta = npv (r, %s) - %g;  end"];
   eval (sprintf (string, p_string, i));
 
   r = fsolve ("f", 0.01);
-  
+
   output_precision = tmp;
-  
+
 endfunction
diff --git a/scripts/finance/nper.m b/scripts/finance/nper.m
--- a/scripts/finance/nper.m
+++ b/scripts/finance/nper.m
@@ -1,20 +1,20 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} nper (@var{r}, @var{p}, @var{a} [, @var{l}] [, @var{method}])
 ##
 ## Computes the number of regular payments of @var{p} necessary to amortize @var{a}
@@ -25,26 +25,26 @@
 ## the optional string argument `method', one can specify whether
 ## payments are made at the end ("e", default) or at the beginning ("b")
 ## of each period.
 ##
 ## Note that the rate r is not specified in percent, i.e., one has to
 ## write 0.05 rather than 5 %.
 ## @end deftypefn
 ## @seealso{pv, pmt, rate, and npv}
-  
+
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  Number of payments needed for amortizing a loan
 
 function n = nper (r, p, a, l, m)
-  
+
   if ((nargin < 3) || (nargin > 5))
     usage ("nper (r, p, a [, l] [, method])");
   endif
-  
+
   if !(is_scalar (r) && (r > -1))
     error ("nper:  r must be a scalar > -1");
   elseif !is_scalar (p)
     error ("nper:  p must be a scalar");
   elseif !is_scalar (a)
     error ("nper:  a must be a scalar");
   endif
 
@@ -58,23 +58,23 @@ function n = nper (r, p, a, l, m)
       l = 0;
     else
       m = "e";
     endif
   else
     m = "e";
     l = 0;
   endif
-  
+
   if strcmp (m, "b")
     p = p * (1 + r);
   endif
-  
+
   q = (p - r * a) / (p - r * l);
-  
+
   if (q > 0)
     n = - log (q) / log (1 + r);
   else
     n = Inf;
   endif
-  
+
 endfunction
 
diff --git a/scripts/finance/npv.m b/scripts/finance/npv.m
--- a/scripts/finance/npv.m
+++ b/scripts/finance/npv.m
@@ -1,20 +1,20 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} npv (@var{r}, @var{p} [, @var{i}])
 ## Returns the net present value of a series of irregular (i.e., not
 ## necessarily identical) payments @var{p} which occur at the ends of @var{n}
@@ -24,33 +24,33 @@
 ##
 ## With the optional scalar argument @var{i}, one can specify an initial
 ## investment.
 ##
 ## Note that rates are not specified in percent, i.e., one has to write
 ## 0.05 rather than 5 %.
 ## @end deftypefn
 ## @seealso{irr and pv}
-  
+
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  Net present value of a series of payments
 
 function v = npv (r, p, i)
-  
+
   if ((nargin < 2) || (nargin > 3))
     usage ("npv (r, p [, i]");
   endif
-  
+
   if !(is_vector (p))
     error ("npv:  p has to be a vector");
   else
     n = length (p);
     p = reshape (p, 1, n);
   endif
-  
+
   if any (any (r <= -1))
     error ("npv:  all interest rates must be > -1");
   endif
   if is_scalar (r)
     d = 1 ./ (1 + r) .^ (0 : n);
   elseif (is_vector (r) && (length (r) == n))
     d = [1, (1 ./ cumprod (reshape (1 + r, 1, n)))];
   else
@@ -59,13 +59,13 @@ function v = npv (r, p, i)
 
   if (nargin == 3)
     if !is_scalar (i)
       error ("npv:  I_0 must be a scalar");
     endif
   else
     i = 0;
   endif
-  
+
   p = [i, p];
   v = sum (d .* p);
-  
+
 endfunction
diff --git a/scripts/finance/pmt.m b/scripts/finance/pmt.m
--- a/scripts/finance/pmt.m
+++ b/scripts/finance/pmt.m
@@ -1,73 +1,73 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-## -*- texinfo -*- 
+## -*- texinfo -*-
 ## @deftypefn {Function File} {} pmt (@var{r}, @var{n}, @var{a} [, @var{l}] [, @var{method}])
 ## Compute the amount of periodic payment necessary to amortize a loan
 ## of amount a with interest rate @var{r} in @var{n} periods.
 ##
 ## With the optional scalar argument l, one can specify an initial
 ## lump-sum payment. With the optional string argument `method', one can
 ## specify whether payments are made at the end ("e", default) or at the
 ## beginning ("b") of each period.
 ## @end deftypefn
 ## @seealso{pv, nper, and rate}
-  
+
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  Amount of periodic payment needed to amortize a loan
 
 function p = pmt (r, n, a, l, m)
-  
+
   if ((nargin < 3) || (nargin > 5))
     usage ("pmt (r, n, a [, l] [, method])");
   endif
-  
+
   if !(is_scalar (r) && (r > -1))
     error ("pmt:  rate must be a scalar > -1");
   elseif !(is_scalar (n) && (n > 0))
     error ("pmt:  n must be a positive scalar");
   elseif !(is_scalar (a) && (a > 0))
     error ("pmt:  a must be a positive scalar.");
   endif
-  
+
   if (nargin == 5)
     if !isstr (m)
       error ("pmt:  `method' must be a string");
     endif
   elseif (nargin == 4)
     if isstr (l)
       m = l;
       l = 0;
     else
       m = "e";
     endif
   else
     l = 0;
     m = "e";
   endif
-  
+
   p = r * (a - l * (1 + r)^(-n)) / (1 - (1 + r)^(-n));
-  
+
   if strcmp (m, "b")
     p = p / (1 + r);
   endif
-  
-  
+
+
 endfunction
-      
 
 
 
+
diff --git a/scripts/finance/pv.m b/scripts/finance/pv.m
--- a/scripts/finance/pv.m
+++ b/scripts/finance/pv.m
@@ -1,20 +1,20 @@
 ## Copyright (C) 1995, 1996  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} pv (@var{r}, @var{n}, @var{p} [, @var{l}] [, @var{method}])
 ## Returns the present value of an investment that will pay off @var{p} for @var{n}
 ## consecutive periods, assuming an interest @var{r}.
@@ -25,55 +25,55 @@
 ## With the optional string argument `method', one can specify whether
 ## payments are made at the end ("e", default) or at the beginning ("b")
 ## of each period.
 ##
 ## Note that the rate r is not specified in percent, i.e., one has to
 ## write 0.05 rather than 5 %.
 ## @end deftypefn
 ## @seealso{pmt, nper, rate, and npv}
-  
+
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  Present value of an investment
 
 function v = pv (r, n, p, l, m)
-  
+
   if ((nargin < 3) || (nargin > 5))
     usage ("pv (r, n, p [, l] [, method])");
   endif
-  
+
   if !(is_scalar (r) && (r > -1))
     error ("pv:  r must be a scalar > -1");
   elseif !(is_scalar (n) && (n > 0))
     error ("pv:  n must be a positive scalar");
   elseif !is_scalar (p)
     error ("pv:  p must be a scalar.");
   endif
-  
+
   if (r != 0)
     v = p * (1 - (1 + r)^(-n)) / r;
   else
     v = p * n;
   endif
-  
+
   if (nargin > 3)
     if (nargin == 5)
       if !isstr (m)
-	error ("pv:  `method' must be a string");
+        error ("pv:  `method' must be a string");
       endif
     elseif isstr (l)
       m = l;
       l = 0;
     else
       m = "e";
     endif
     if strcmp (m, "b")
       v = v * (1 + r);
     endif
     if is_scalar (l)
       v = v + pvl (r, n, l);
     else
       error ("pv:  l must be a scalar");
     endif
   endif
-  
+
 endfunction
-      
+
diff --git a/scripts/finance/pvl.m b/scripts/finance/pvl.m
--- a/scripts/finance/pvl.m
+++ b/scripts/finance/pvl.m
@@ -1,41 +1,41 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  pvl (r, n, p)
 ##
 ## Returns the present value of an investment that will pay off p in one
 ## lump sum at the end of n periods, given the interest rate r.
 
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  Present value of an investment that pays off at the end
 
 function v = pvl (r, n, p)
-  
+
   if (nargin != 3)
     usage ("pvl (r, n, p)");
   endif
-  
+
   if !(is_scalar (r) && (r > -1))
     error ("pvl:  r has to be a scalar > -1");
   elseif !(is_scalar (n) && (n > 0))
     error ("pvl:  n has to be a positive scalar");
   elseif !is_scalar (p)
     error ("pvl:  p has to be a scalar");
   endif
-  
+
   v = p / (1 + r)^n;
-  
+
 endfunction
diff --git a/scripts/finance/rate.m b/scripts/finance/rate.m
--- a/scripts/finance/rate.m
+++ b/scripts/finance/rate.m
@@ -1,45 +1,45 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-## -*- texinfo -*- 
+## -*- texinfo -*-
 ## @deftypefn {Function File} {} rate (@var{n}, @var{p}, @var{v} [, @var{l}] [,@var{method}])
 ## Computes the rate of return on an investment of present value @var{v} which
 ## pays @var{p} in @var{n} consecutive periods.
 ##
 ## With the optional scalar argument @var{l}, one can specify an additional
 ## lump-sum payment made at the end of @var{n} periods. With the optional
 ## string argument @var{`method'}, one can specify whether payments are made
 ## at the end ("e", default) or at the beginning ("b") of each period.
 ## @end deftypefn
 ## @seealso{pv, pmt, nper, and npv}
-  
+
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  Rate of return of an investment
-  
+
 function r = rate (n, p, v, l, m)
 
   if ((nargin < 3) || (nargin > 5))
     usage ("rate (n, p, v [, l] [, method])");
   endif
-  
+
   if !(is_scalar (n) && (n > 0))
     error ("rate:  n must be a positive scalar");
   elseif !is_scalar (p)
     error ("rate:  p must be a scalar");
   elseif !is_scalar (v)
     error ("rate:  p must be a scalar");
   endif
 
@@ -53,20 +53,20 @@ function r = rate (n, p, v, l, m)
       l = 0;
     else
       m = "e";
     endif
   else
     l = 0;
     m = "e";
   endif
-  
+
   if !is_scalar (l)
     error ("rate:  l must be a scalar");
   endif
-  
+
   string = ["function delta = f (r) ", ...
       "delta = pv (r, %g, %g, %g, \"%s\") - %g;  end"];
   eval (sprintf (string, n, p, l, m, v));
-  
+
   [r, info] = fsolve ("f", 0);
-  
+
 endfunction
diff --git a/scripts/finance/vol.m b/scripts/finance/vol.m
--- a/scripts/finance/vol.m
+++ b/scripts/finance/vol.m
@@ -1,20 +1,20 @@
 ## Copyright (C) 1995, 1996, 1997  Friedrich Leisch
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  vol (X, m [, n])
 ##
 ## vol returns the volatility of each column of the input matrix X. m is
 ## the number of data sets per period (e.g. the number of data per year
@@ -56,15 +56,15 @@ function retval = vol (X, m, n)
   U = log(U);
   U = U - ones (xr - 1, 1) * sum (U) / (xr - 1);
 
   retval = zeros (xr - n * m, xc);
 
   retval(1, :) = sumsq (U((1 : n*m), :));
   for i = 2 : (xr - n * m)
     retval(i, :) = retval(i - 1, :) ...
-	- U(i - 1, :).^2 + U(i + n * m - 1, :).^2;
+        - U(i - 1, :).^2 + U(i + n * m - 1, :).^2;
   endfor
 
   retval = sqrt (retval * m / (n * m - 1));
 
 endfunction
 
diff --git a/scripts/general/common_size.m b/scripts/general/common_size.m
--- a/scripts/general/common_size.m
+++ b/scripts/general/common_size.m
@@ -1,73 +1,73 @@
 ## Copyright (C) 1995, 1996  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{err}, @var{y1}, ...] =} common_size (@var{x1}, ...)
 ## Determine if all input arguments are either scalar or of common
 ## size.  If so, @var{err} is zero, and @var{yi} is a matrix of the
 ## common size with all entries equal to @var{xi} if this is a scalar or
 ## @var{xi} otherwise.  If the inputs cannot be brought to a common size,
 ## errorcode is 1, and @var{yi} is @var{xi}.  For example,
-## 
+##
 ## @example
 ## @group
 ## [errorcode, a, b] = common_size ([1 2; 3 4], 5)
 ##      @result{} errorcode = 0
 ##      @result{} a = [ 1, 2; 3, 4 ]
 ##      @result{} b = [ 5, 5; 5, 5 ]
 ## @end group
 ## @end example
-## 
+##
 ## @noindent
 ## This is useful for implementing functions where arguments can either
 ## be scalars or of common size.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Created: 15 October 1994
 ## Adapted-By: jwe
 
 function [errorcode, ...] = common_size (...)
-  
+
   if (nargin < 2)
     error ("common_size: only makes sense if nargin >= 2");
   endif
 
   va_start ();
   for k = 1 : nargin
     s(k, :) = size (va_arg ());
   endfor
-  
+
   m = max (s);
   if (any (any ((s != 1)') & any ((s != ones (nargin, 1) * m)')))
     errorcode = 1;
     va_start ();
     for k = 1 : nargin
       vr_val (va_arg ());
     endfor
   else
     errorcode = 0;
     va_start ();
     for k = 1 : nargin
       if (prod (s(k, :)) == 1)
-	vr_val (va_arg () * ones (m));
+        vr_val (va_arg () * ones (m));
       else
-	vr_val (va_arg ());
+        vr_val (va_arg ());
       endif
     endfor
   endif
 
 endfunction
diff --git a/scripts/general/diff.m b/scripts/general/diff.m
--- a/scripts/general/diff.m
+++ b/scripts/general/diff.m
@@ -1,80 +1,80 @@
 ## Copyright (C) 1995, 1996  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} diff (@var{x}, @var{k})
 ## If @var{x} is a vector of length @var{n}, @code{diff (@var{x})} is the
 ## vector of first differences
 ## @iftex
 ## @tex
 ##  $x_2 - x_1, \ldots{}, x_n - x_{n-1}$.
 ## @end tex
 ## @end iftex
 ## @ifinfo
 ##  @var{x}(2) - @var{x}(1), @dots{}, @var{x}(n) - @var{x}(n-1).
 ## @end ifinfo
-## 
+##
 ## If @var{x} is a matrix, @code{diff (@var{x})} is the matrix of column
 ## differences.
-## 
+##
 ## The second argument is optional.  If supplied, @code{diff (@var{x},
 ## @var{k})}, where @var{k} is a nonnegative integer, returns the
 ## @var{k}-th differences.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Created: 2 February 1995
 ## Adapted-By: jwe
 
 function x = diff (x, k)
-  
+
   if (nargin == 1)
     k = 1;
   elseif (nargin == 2)
     if (! (is_scalar (k) && k == round (k) && k >= 0))
       error ("diff: k must be a nonnegative integer");
     elseif (k == 0)
       return;
     endif
   else
     usage ("diff (x [, k]");
   endif
-  
+
   if (isstr (x))
     error ("diff: symbolic differentiation not (yet) supported");
   elseif (is_vector (x))
     n = length (x);
     if (n <= k)
       x = [];
     else
       for i = 1 : k
-	x = x (2 : (n - i + 1)) - x (1 : (n - i));
+        x = x (2 : (n - i + 1)) - x (1 : (n - i));
       endfor
     endif
   elseif (is_matrix (x))
     n = rows (x);
     if (n <= k)
       x = [];
     else
       for i = 1 : k
-	x = x (2 : (n - i + 1), :) - x (1: (n - i), :);
+        x = x (2 : (n - i + 1), :) - x (1: (n - i), :);
       endfor
     endif
   else
     x = [];
   endif
 
 endfunction
diff --git a/scripts/general/fliplr.m b/scripts/general/fliplr.m
--- a/scripts/general/fliplr.m
+++ b/scripts/general/fliplr.m
@@ -15,18 +15,18 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} fliplr (@var{x})
 ## Return a copy of @var{x} with the order of the columns reversed.  For
-## example, 
-## 
+## example,
+##
 ## @example
 ## @group
 ## fliplr ([1, 2; 3, 4])
 ##      @result{}  2  1
 ##          4  3
 ## @end group
 ## @end example
 ## @end deftypefn
diff --git a/scripts/general/flipud.m b/scripts/general/flipud.m
--- a/scripts/general/flipud.m
+++ b/scripts/general/flipud.m
@@ -16,17 +16,17 @@
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} flipud (@var{x})
 ## Return a copy of @var{x} with the order of the rows reversed.  For
 ## example,
-## 
+##
 ## @example
 ## @group
 ## flipud ([1, 2; 3, 4])
 ##      @result{}  3  4
 ##          1  2
 ## @end group
 ## @end example
 ## @end deftypefn
diff --git a/scripts/general/is_duplicate_entry.m b/scripts/general/is_duplicate_entry.m
--- a/scripts/general/is_duplicate_entry.m
+++ b/scripts/general/is_duplicate_entry.m
@@ -36,9 +36,9 @@ function retval = is_duplicate_entry (x)
     else
       error ("is_duplicate_entry: expecting matrix argument");
     endif
   else
     usage ("is_duplicate_entry (x)");
   endif
 
 endfunction
-  
+
diff --git a/scripts/general/is_square.m b/scripts/general/is_square.m
--- a/scripts/general/is_square.m
+++ b/scripts/general/is_square.m
@@ -31,16 +31,16 @@
 function retval = is_square (x)
 
   retval = 0;
 
   if (nargin == 1)
     if (is_matrix (x))
       [nr, nc] = size (x);
       if (nr == nc && nr > 0)
-      	retval = nr;
+        retval = nr;
       endif
     endif
   else
     usage ("is_square (x)");
   endif
 
 endfunction
diff --git a/scripts/general/is_symmetric.m b/scripts/general/is_symmetric.m
--- a/scripts/general/is_symmetric.m
+++ b/scripts/general/is_symmetric.m
@@ -14,34 +14,34 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} is_symmetric (@var{x}, @var{tol})
-## If @var{x} is symmetric within the tolerance specified by @var{tol}, 
+## If @var{x} is symmetric within the tolerance specified by @var{tol},
 ## then return the dimension of @var{x}.  Otherwise, return 0.  If
 ## @var{tol} is omitted, use a tolerance equal to the machine precision.
 ## @end deftypefn
 ## @seealso{size, rows, columns, length, is_matrix, is_scalar,
 ## is_square, and is_vector}
 
 ## Author: A. S. Hodel <scotte@eng.auburn.edu>
 ## Created: August 1993
 ## Adapted-By: jwe
 
 function retval = is_symmetric (x,tol)
 
   if (nargin == 1 || nargin == 2)
     retval = is_square (x);
     if (retval != 0)
       if (nargin == 1)
-	tol = eps;
+        tol = eps;
       endif
       if (norm (x - x') / norm(x) > tol)
         retval = 0;
       endif
     endif
   else
     usage ("is_symmetric (x {,tol})");
   endif
diff --git a/scripts/general/logspace.m b/scripts/general/logspace.m
--- a/scripts/general/logspace.m
+++ b/scripts/general/logspace.m
@@ -24,17 +24,17 @@
 ## @iftex
 ## @tex
 ## $10^{base}$ to $10^{limit}$.
 ## @end tex
 ## @end iftex
 ## @ifinfo
 ## 10^base to 10^limit.
 ## @end ifinfo
-## 
+##
 ## If @var{limit} is equal to
 ## @iftex
 ## @tex
 ## $\pi$,
 ## @end tex
 ## @end iftex
 ## @ifinfo
 ## pi,
diff --git a/scripts/general/nargchk.m b/scripts/general/nargchk.m
--- a/scripts/general/nargchk.m
+++ b/scripts/general/nargchk.m
@@ -17,17 +17,17 @@
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} nargchk (@var{nargin_min}, @var{nargin_max}, @var{n})
 ## If @var{n} is in the range @var{nargin_min} through @var{nargin_max}
 ## inclusive, return the empty matrix.  Otherwise, return a message
 ## indicating whether @var{n} is too large or too small.
-## 
+##
 ## This is useful for checking to see that the number of arguments supplied
 ## to a function is within an acceptable range.
 ## @end deftypefn
 
 ## Author: jwe
 
 function retval = nargchk (nargin_min, nargin_max, n)
 
diff --git a/scripts/general/nextpow2.m b/scripts/general/nextpow2.m
--- a/scripts/general/nextpow2.m
+++ b/scripts/general/nextpow2.m
@@ -1,57 +1,57 @@
 ## Copyright (C) 1995, 1996 Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} nextpow2 (@var{x})
 ## If @var{x} is a scalar, returns the first integer @var{n} such that
 ## @iftex
 ## @tex
 ##  $2^n \ge |x|$.
 ## @end tex
 ## @end iftex
 ## @ifinfo
 ##  2^n >= abs (x).
 ## @end ifinfo
-## 
+##
 ## If @var{x} is a vector, return @code{nextpow2 (length (@var{x}))}.
 ## @end deftypefn
 ## @seealso{pow2}
 
 ## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Created: 7 October 1994
 ## Adapted-By: jwe
 
 function n = nextpow2 (x)
-  
+
   if (nargin != 1)
     usage ("nextpow2 (x)");
   endif
 
   if (! (is_scalar (x) || is_vector (x)))
     error ("nextpow2: x must be a scalar or a vector");
   endif
 
   t = length (x);
   if (t > 1)
     x = t;
   endif
-  
+
   [f, n] = log2 (abs (x));
   if (f == 0.5)
     n = n - 1;
   endif
-  
+
 endfunction
diff --git a/scripts/general/rem.m b/scripts/general/rem.m
--- a/scripts/general/rem.m
+++ b/scripts/general/rem.m
@@ -16,21 +16,21 @@
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Mapping Function} {} rem (@var{x}, @var{y})
 ## Return the remainder of @code{@var{x} / @var{y}}, computed using the
 ## expression
-## 
+##
 ## @example
 ## x - y .* fix (x ./ y)
 ## @end example
-## 
+##
 ## An error message is printed if the dimensions of the arguments do not
 ## agree, or if either of the arguments is complex.
 ## @end deftypefn
 ## @seealso{round}
 
 ## Author: jwe
 
 function retval = rem (x, y)
diff --git a/scripts/general/reshape.m b/scripts/general/reshape.m
--- a/scripts/general/reshape.m
+++ b/scripts/general/reshape.m
@@ -18,37 +18,37 @@
 ## 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} reshape (@var{a}, @var{m}, @var{n})
 ## Return a matrix with @var{m} rows and @var{n} columns whose elements are
 ## taken from the matrix @var{a}.  To decide how to order the elements,
 ## Octave pretends that the elements of a matrix are stored in column-major
 ## order (like Fortran arrays are stored).
-## 
+##
 ## For example,
-## 
+##
 ## @example
 ## @group
 ## reshape ([1, 2, 3, 4], 2, 2)
 ##      @result{}  1  3
 ##          2  4
 ## @end group
 ## @end example
-## 
+##
 ## If the variable @code{do_fortran_indexing} is nonzero, the
 ## @code{reshape} function is equivalent to
-## 
+##
 ## @example
 ## @group
 ## retval = zeros (m, n);
 ## retval (:) = a;
 ## @end group
 ## @end example
-## 
+##
 ## @noindent
 ## but it is somewhat less cryptic to use @code{reshape} instead of the
 ## colon operator.  Note that the total number of elements in the original
 ## matrix must match the total number of elements in the new matrix.
 ## @end deftypefn
 ## @seealso{`:' and do_fortran_indexing}
 
 ## Author: jwe
@@ -63,25 +63,25 @@ function retval = reshape (a, m, n)
 
   if (nargin == 3)
     [nr, nc] = size (a);
     if (nr * nc == m * n)
       dfi = do_fortran_indexing;
       istno = implicit_str_to_num_ok;
       unwind_protect
         do_fortran_indexing = 1;
-	implicit_str_to_num_ok = 1;
+        implicit_str_to_num_ok = 1;
         retval = zeros (m, n);
         retval (:) = a;
-	if (isstr (a))
-	  retval = setstr (retval);
-	endif
+        if (isstr (a))
+          retval = setstr (retval);
+        endif
       unwind_protect_cleanup
         do_fortran_indexing = dfi;
-	implicit_str_to_num_ok = istno;
+        implicit_str_to_num_ok = istno;
       end_unwind_protect
     else
       error ("reshape: sizes must match");
     endif
   else
     usage ("reshape (a, m, n) or reshape (a, size (b))");
   endif
 
diff --git a/scripts/general/rot90.m b/scripts/general/rot90.m
--- a/scripts/general/rot90.m
+++ b/scripts/general/rot90.m
@@ -19,29 +19,29 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} rot90 (@var{x}, @var{n})
 ## Return a copy of @var{x} with the elements rotated counterclockwise in
 ## 90-degree increments.  The second argument is optional, and specifies
 ## how many 90-degree rotations are to be applied (the default value is 1).
 ## Negative values of @var{n} rotate the matrix in a clockwise direction.
 ## For example,
-## 
+##
 ## @example
 ## @group
 ## rot90 ([1, 2; 3, 4], -1)
 ##      @result{}  3  1
 ##          4  2
 ## @end group
 ## @end example
-## 
+##
 ## @noindent
 ## rotates the given matrix clockwise by 90 degrees.  The following are all
 ## equivalent statements:
-## 
+##
 ## @example
 ## @group
 ## rot90 ([1, 2; 3, 4], -1)
 ## @equiv{}
 ## rot90 ([1, 2; 3, 4], 3)
 ## @equiv{}
 ## rot90 ([1, 2; 3, 4], 7)
 ## @end group
diff --git a/scripts/general/shift.m b/scripts/general/shift.m
--- a/scripts/general/shift.m
+++ b/scripts/general/shift.m
@@ -1,44 +1,44 @@
 ## Copyright (C) 1995, 1996  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} shift (@var{x}, @var{b})
 ## If @var{x} is a vector, perform a circular shift of length @var{b} of
 ## the elements of @var{x}.
-## 
+##
 ## If @var{x} is a matrix, do the same for each column of @var{x}.
 ## @end deftypefn
 
 ## Author: AW <Andreas.Weingessel@ci.tuwien.ac.at>
 ## Created: 14 September 1994
 ## Adapted-By: jwe
 
 function y = shift (x, b)
-  
+
   if (nargin != 2)
     error ("usage: shift (X, b)");
   endif
 
   [nr, nc] = size (x);
-  
+
   if (nr == 0 || nc == 0)
     error ("shift: x must not be empty");
   elseif (nr == 1)
     x = x.';
     nr = nc;
     nc = 0;
   endif
 
diff --git a/scripts/general/tril.m b/scripts/general/tril.m
--- a/scripts/general/tril.m
+++ b/scripts/general/tril.m
@@ -20,42 +20,42 @@
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} tril (@var{a}, @var{k})
 ## @deftypefnx {Function File} {} triu (@var{a}, @var{k})
 ## Return a new matrix formed by extracting extract the lower (@code{tril})
 ## or upper (@code{triu}) triangular part of the matrix @var{a}, and
 ## setting all other elements to zero.  The second argument is optional,
 ## and specifies how many diagonals above or below the main diagonal should
 ## also be set to zero.
-## 
+##
 ## The default value of @var{k} is zero, so that @code{triu} and
 ## @code{tril} normally include the main diagonal as part of the result
 ## matrix.
-## 
+##
 ## If the value of @var{k} is negative, additional elements above (for
 ## @code{tril}) or below (for @code{triu}) the main diagonal are also
 ## selected.
-## 
+##
 ## The absolute value of @var{k} must not be greater than the number of
 ## sub- or super-diagonals.
-## 
+##
 ## For example,
-## 
+##
 ## @example
 ## @group
 ## tril (ones (3), -1)
 ##      @result{}  0  0  0
 ##          1  0  0
 ##          1  1  0
 ## @end group
 ## @end example
-## 
+##
 ## @noindent
 ## and
-## 
+##
 ## @example
 ## @group
 ## tril (ones (3), 1)
 ##      @result{}  1  1  0
 ##          1  1  1
 ##          1  1  1
 ## @end group
 ## @end example
diff --git a/scripts/image/colormap.m b/scripts/image/colormap.m
--- a/scripts/image/colormap.m
+++ b/scripts/image/colormap.m
@@ -16,25 +16,25 @@
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} colormap (@var{map})
 ## @deftypefnx {Function File} {} colormap ("default")
 ## Set the current colormap.
-## 
+##
 ## @code{colormap (@var{map})} sets the current colormap to @var{map}.  The
 ## color map should be an @var{n} row by 3 column matrix.  The columns
 ## contain red, green, and blue intensities respectively.  All entries
 ## should be between 0 and 1 inclusive.  The new colormap is returned.
-## 
+##
 ## @code{colormap ("default")} restores the default colormap (a gray scale
 ## colormap with 64 entries).  The default colormap is returned.
-## 
+##
 ## With no arguments, @code{colormap} returns the current color map.
 ## @end deftypefn
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: July 1994
 ## Adapted-By: jwe
 
 function cmap = colormap (map)
@@ -46,29 +46,29 @@ function cmap = colormap (map)
   endif
 
   if (nargin == 1)
 
     if (isstr (map))
       if (strcmp (map, "default"))
         map = gray ();
       else
-	unwind_protect
-	  save_default_eval_print_flag = default_eval_print_flag;
-	  default_eval_print_flag = 0;
-	  map = eval (map);
-	unwind_protect_cleanup
-	  default_eval_print_flag = save_default_eval_print_flag;
-	end_unwind_protect
+        unwind_protect
+          save_default_eval_print_flag = default_eval_print_flag;
+          default_eval_print_flag = 0;
+          map = eval (map);
+        unwind_protect_cleanup
+          default_eval_print_flag = save_default_eval_print_flag;
+        end_unwind_protect
       endif
     endif
 
     if (! isempty (map))
       if (columns (map) != 3)
-	error( "colormap: map must have 3 columns: [R,G,B]." );
+        error( "colormap: map must have 3 columns: [R,G,B]." );
       endif
       if (min (min (map)) < 0 || max (max (map)) > 1)
         error( "colormap: map must have values in [0,1]." );
       endif
       ## Set the new color map
       __current_color_map__ = map;
     endif
 
diff --git a/scripts/image/image.m b/scripts/image/image.m
--- a/scripts/image/image.m
+++ b/scripts/image/image.m
@@ -17,17 +17,17 @@
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} image (@var{x}, @var{zoom})
 ## Display a matrix as a color image.  The elements of @var{x} are indices
 ## into the current colormap and should have values between 1 and the
 ## length of the colormap.  If @var{zoom} is omitted, a value of 4 is
-## assumed. 
+## assumed.
 ## @end deftypefn
 
 ## SEE ALSO: imshow, imagesc, colormap.
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: July 1994
 ## Adapted-By: jwe
 
@@ -54,13 +54,13 @@ function image (x, zoom)
   xloadimage = sprintf ("xloadimage -zoom %f %s", zoom*100, ppm_name);
 
   rm = sprintf ("rm -f %s", ppm_name);
 
   ## Need to let the shell clean up the tmp file because we are putting
   ## the viewer in the background.
 
   command = sprintf ("( %s || %s && %s ) > /dev/null 2>&1 &",
-		     xv, xloadimage, rm);
+                     xv, xloadimage, rm);
 
   system (command);
 
 endfunction
diff --git a/scripts/image/imshow.m b/scripts/image/imshow.m
--- a/scripts/image/imshow.m
+++ b/scripts/image/imshow.m
@@ -18,25 +18,25 @@
 ## 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} imshow (@var{x}, @var{map})
 ## @deftypefnx {Function File} {} imshow (@var{x}, @var{n})
 ## @deftypefnx {Function File} {} imshow (@var{i}, @var{n})
 ## @deftypefnx {Function File} {} imshow (@var{r}, @var{g}, @var{b})
 ## Display images.
-## 
+##
 ## @code{imshow (@var{x})} displays an indexed image using the current
 ## colormap.
-## 
+##
 ## @code{imshow (@var{x}, @var{map})} displays an indexed image using the
 ## specified colormap.
-## 
+##
 ## @code{imshow (@var{i}, @var{n})} displays a gray scale intensity image.
-## 
+##
 ## @code{imshow (@var{r}, @var{g}, @var{b})} displays an RGB image.
 ## @end deftypefn
 
 ## SEE ALSO: image, imagesc, colormap, gray2ind, rgb2ind.
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: July 1994
 ## Adapted-By: jwe
diff --git a/scripts/image/saveimage.m b/scripts/image/saveimage.m
--- a/scripts/image/saveimage.m
+++ b/scripts/image/saveimage.m
@@ -16,32 +16,32 @@
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} saveimage (@var{file}, @var{x}, @var{fmt}, @var{map})
 ## Save the matrix @var{x} to @var{file} in image format @var{fmt}.  Valid
 ## values for @var{fmt} are
-## 
+##
 ## @table @code
 ## @item "img"
 ## Octave's image format.  The current colormap is also saved in the file.
-## 
+##
 ## @item "ppm"
 ## Portable pixmap format.
-## 
+##
 ## @item "ps"
 ## PostScript format.  Note that images saved in PostScript format can not
 ## be read back into Octave with loadimage.
 ## @end table
-## 
+##
 ## If the fourth argument is supplied, the specified colormap will also be
 ## saved along with the image.
-## 
+##
 ## Note: if the colormap contains only two entries and these entries are
 ## black and white, the bitmap ppm and PostScript formats are used.  If the
 ## image is a gray scale image (the entries within each row of the colormap
 ## are equal) the gray scale ppm and PostScript image formats are used,
 ## otherwise the full color formats are used.
 ## @end deftypefn
 
 ## The conversion to PostScript is based on pbmtolps.c, which was
@@ -92,17 +92,17 @@ function saveimage (filename, img, img_f
   endif
 
   if (nargin < 3)
     img_form = "img";
   elseif (! isstr (img_form))
     error ("image format specification must be a string");
   elseif (! (strcmp (img_form, "img")
              || strcmp (img_form, "ppm")
-	     || strcmp (img_form, "ps")))
+             || strcmp (img_form, "ps")))
     error ("unsupported image format specification");
   endif
 
   if (! is_matrix (img))
     warning ("image variable is not a matrix");
   endif
 
   if (! isstr (filename))
@@ -149,42 +149,42 @@ function saveimage (filename, img, img_f
 
   idx = find (img <= 0);
   img (idx) = ones (size (idx));
 
   if (strcmp (img_form, "ppm"))
     if (grey && map_nr == 2 && bw)
 
       if (map(1) != 0)
-      	map = [1; 0];
+        map = [1; 0];
       else
-      	map = [0; 1];
+        map = [0; 1];
       endif
 
       n_long = rem (img_nc, 8);
       tmp = zeros (ceil (img_nc/8), img_nr);
 
       for i = 1:img_nr
-	idx = (i-1)*img_nc+1:i*img_nc;
-      	if (n_long > 0)
-	  img_row = [map(img(idx)); (zeros (8-n_long, 1))];
-	else
-      	  img_row = map(img(idx));
-	endif
-	img_row
-	tmp
-	if (img_nc < 8)
-	  for j = 1:8
-	    tmp(:,i) = tmp(:,i) + img_row (j) * 2^(8-j);
-	  endfor
-	else
-	  for j = 1:8
-	    tmp(:,i) = tmp(:,i) + img_row (j:8:img_nc) * 2^(8-j);
-	  endfor
-	endif
+        idx = (i-1)*img_nc+1:i*img_nc;
+        if (n_long > 0)
+          img_row = [map(img(idx)); (zeros (8-n_long, 1))];
+        else
+          img_row = map(img(idx));
+        endif
+        img_row
+        tmp
+        if (img_nc < 8)
+          for j = 1:8
+            tmp(:,i) = tmp(:,i) + img_row (j) * 2^(8-j);
+          endfor
+        else
+          for j = 1:8
+            tmp(:,i) = tmp(:,i) + img_row (j:8:img_nc) * 2^(8-j);
+          endfor
+        endif
       endfor
 
       fid = fopen (filename, "w");
       fprintf (fid, "P4\n%d %d\n", img_nr, img_nc);
       fwrite (fid, tmp, "char");
       fprintf (fid, "\n");
       fclose (fid);
 
@@ -240,24 +240,24 @@ function saveimage (filename, img, img_f
     padright = (((img_nr * bps + 7) / 8) * 8 - img_nr * bps) / bps;
 
     scols = img_nr * pixfac;
     srows = img_nc * pixfac;
     scale = 1;
 
     if (scols > pagewid * MARGIN || srows > pagehgt * MARGIN)
       if (scols > pagewid * MARGIN)
-	scale = scale * (pagewid / scols * MARGIN);
-	scols = scale * img_nr * pixfac;
-	srows = scale * img_nc * pixfac;
+        scale = scale * (pagewid / scols * MARGIN);
+        scols = scale * img_nr * pixfac;
+        srows = scale * img_nc * pixfac;
       endif
       if (srows > pagehgt * MARGIN)
-	scale = scale * (pagehgt / srows * MARGIN);
-	scols = scale * img_nr * pixfac;
-	srows = scale * img_nc * pixfac;
+        scale = scale * (pagehgt / srows * MARGIN);
+        scols = scale * img_nr * pixfac;
+        srows = scale * img_nc * pixfac;
       endif
       warning ("image too large for page, rescaling to %g", scale);
     endif
 
     llx = (pagewid - scols) / 2;
     lly = (pagehgt - srows) / 2;
     urx = llx + fix (scols + 0.5);
     ury = lly + fix (srows + 0.5);
diff --git a/scripts/linear-algebra/commutation_matrix.m b/scripts/linear-algebra/commutation_matrix.m
--- a/scripts/linear-algebra/commutation_matrix.m
+++ b/scripts/linear-algebra/commutation_matrix.m
@@ -1,20 +1,20 @@
 ## Copyright (C) 1995, 1996  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} commutation_matrix (@var{m}, @var{n})
 ## Return the commutation matrix
 ## @iftex
@@ -56,51 +56,51 @@
 ## @iftex
 ## @tex
 ##  $A$.
 ## @end tex
 ## @end iftex
 ## @ifinfo
 ##  @var{A}.
 ## @end ifinfo
-## 
+##
 ## If only one argument @var{m} is given,
 ## @iftex
 ## @tex
 ##  $K_{m,m}$
 ## @end tex
 ## @end iftex
 ## @ifinfo
 ##  K(m,m)
 ## @end ifinfo
 ##  is returned.
-## 
+##
 ## See Magnus and Neudecker (1988), Matrix differential calculus with
 ## applications in statistics and econometrics.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Created: 8 May 1995
 ## Adapted-By: jwe
 
 function k = commutation_matrix (m, n)
-  
+
   if (nargin < 1 || nargin > 2)
     usage ("commutation_matrix (m [, n])");
   else
     if (! (is_scalar (m) && m == round (m) && m > 0))
       error ("commutation_matrix: m must be a positive integer");
     endif
     if (nargin == 1)
       n = m;
     elseif (! (is_scalar (n) && n == round (n) && n > 0))
       error ("commutation_matrix: n must be a positive integer");
     endif
   endif
-  
+
   ## It is clearly possible to make this a LOT faster!
   k = zeros (m * n, m * n);
   for i = 1 : m
     for j = 1 : n
       k ((i - 1) * n + j, (j - 1) * m + i) = 1;
     endfor
   endfor
 
diff --git a/scripts/linear-algebra/cond.m b/scripts/linear-algebra/cond.m
--- a/scripts/linear-algebra/cond.m
+++ b/scripts/linear-algebra/cond.m
@@ -42,18 +42,18 @@ function retval = cond (a)
     endif
     if (any (any (isinf (a) | isnan (a))))
       error ("cond: argument must not contain Inf or NaN values");
     else
       sigma = svd (a);
       sigma_1 = sigma(1);
       sigma_n = sigma(length (sigma));
       if (sigma_1 == 0 || sigma_n == 0)
-	retval = Inf;
+        retval = Inf;
       else
-	retval = sigma_1 / sigma_n;
+        retval = sigma_1 / sigma_n;
       endif
     endif
   else
     usage ("cond (a)");
   endif
 
 endfunction
diff --git a/scripts/linear-algebra/cross.m b/scripts/linear-algebra/cross.m
--- a/scripts/linear-algebra/cross.m
+++ b/scripts/linear-algebra/cross.m
@@ -1,46 +1,46 @@
 ## Copyright (C) 1995, 1996  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} cross (@var{x}, @var{y})
 ## Computes the vector cross product of the two 3-dimensional vectors
 ## @var{x} and @var{y}.
 ##
 ## A row vector is returned if @var{x} and @var{y} are both row vectors;
 ## otherwise, a column vector is returned.
-## 
+##
 ## @example
 ## @group
 ## cross ([1,1,0], [0,1,1])
 ##      @result{} [ 1; -1; 1 ]
 ## @end group
 ## @end example
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Created: 15 October 1994
 ## Adapted-By: jwe
 
 function z = cross (x, y)
-  
+
   if (nargin != 2)
     usage ("cross (x, y)");
   endif
 
   if (length (x) == 3 && length (y) == 3)
 
     z = [x(2)*y(3) - x(3)*y(2); x(3)*y(1) - x(1)*y(3); x(1)*y(2) - x(2)*y(1)];
 
diff --git a/scripts/linear-algebra/dmult.m b/scripts/linear-algebra/dmult.m
--- a/scripts/linear-algebra/dmult.m
+++ b/scripts/linear-algebra/dmult.m
@@ -1,38 +1,38 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  dmult (a, B)
 ##
 ## If a is a vector of length rows (B), return diag (a) * B (but
 ## computed much more efficiently).
-  
+
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  Rescale the rows of a matrix
-  
+
 function M = dmult (a, B)
-  
+
   if (nargin != 2)
     usage ("dmult (a, B)");
   endif
-  
+
   s = size (a);
   if ((min (s) > 1) || (max (s) != rows (B)))
     error ("dmult:  a must be a vector of length rows (B)");
   endif
-  
+
   M = (reshape (a, max (s), 1) * ones (1, columns (B))) .* B;
-  
+
 endfunction
diff --git a/scripts/linear-algebra/dot.m b/scripts/linear-algebra/dot.m
--- a/scripts/linear-algebra/dot.m
+++ b/scripts/linear-algebra/dot.m
@@ -1,49 +1,49 @@
 ## Copyright (C) 1998 John W. Eaton
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  dot (x, y)
 ##
 ## Computes the dot product of two vectors.
 
 ## Author: jwe
 
 function z = dot (x, y)
-  
+
   if (nargin != 2)
     usage ("dot (x, y)");
   endif
 
   if (is_vector (x) && is_vector (y) && length (x) == length (y))
     [x_nr, x_nc] = size (x);
     [y_nr, y_nc] = size (y);
     if (x_nr == 1)
       if (y_nr == 1)
-	z = x * y.';
+        z = x * y.';
       else
-	z = x * y;
+        z = x * y;
       endif
     else
       if (y_nr == 1)
-	z = y * x;
+        z = y * x;
       else
-	z = y.' * x;
+        z = y.' * x;
       endif
     endif
   else
     error ("dot: both arguments must be vectors of the same length");
   endif
 
 endfunction
diff --git a/scripts/linear-algebra/duplication_matrix.m b/scripts/linear-algebra/duplication_matrix.m
--- a/scripts/linear-algebra/duplication_matrix.m
+++ b/scripts/linear-algebra/duplication_matrix.m
@@ -1,25 +1,25 @@
 ## Copyright (C) 1995, 1996  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-## -*- texinfo -*- 
+## -*- texinfo -*-
 ## @deftypefn {Function File} {} duplication_matrix (@var{n})
 ## Return the duplication matrix
 ## @iftex
 ## @tex
 ##  $D_n$
 ## @end tex
 ## @end iftex
 ## @ifinfo
@@ -56,17 +56,17 @@
 ## @iftex
 ## @tex
 ##  $A$.
 ## @end tex
 ## @end iftex
 ## @ifinfo
 ##  @var{A}.
 ## @end ifinfo
-## 
+##
 ## See Magnus and Neudecker (1988), Matrix differential calculus with
 ## applications in statistics and econometrics.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Created: 8 May 1995
 ## Adapged-By: jwe
 
diff --git a/scripts/linear-algebra/housh.m b/scripts/linear-algebra/housh.m
--- a/scripts/linear-algebra/housh.m
+++ b/scripts/linear-algebra/housh.m
@@ -23,35 +23,35 @@ function [housv,beta,zer] = housh(x,j,z)
   # inputs
   #   x: vector
   #   j: index into vector
   #   z: threshold for zero  (usually should be the number 0)
   # outputs: (see Golub and Van Loan)
   #   beta: If beta = 0, then no reflection need be applied (zer set to 0)
   #   housv: householder vector
   # mar 6,1987 : rev dec 17,1988
-  #		rev sep 19,1991 (blas)
+  #             rev sep 19,1991 (blas)
   # translated from FORTRAN Aug 1995
   # A. S. Hodel
 
   # $Revision: 1.1.1.1 $
   # $Log$
 
   # check for legal inputs
   if( !is_vector(x) && !is_scalar(x))
     error("housh: first input must be a vector")
   elseif( !is_scalar(j) )
     error("housh: second argment must be an integer scalar")
   else
     housv = x;
     m = max(abs(housv));
-    if (m ~= 0.0) 
+    if (m ~= 0.0)
       housv = housv/m;
       alpha = norm(housv);
-      if (alpha > z) 
+      if (alpha > z)
         beta = 1.0/(alpha*(alpha+abs(housv(j))));
         sg = sign(housv(j));
         if( sg == 0)
           sg = 1;
         endif
         housv(j) = housv(j) + alpha*sg;
       else
         beta = 0.0;
diff --git a/scripts/linear-algebra/kron.m b/scripts/linear-algebra/kron.m
--- a/scripts/linear-algebra/kron.m
+++ b/scripts/linear-algebra/kron.m
@@ -15,23 +15,23 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} kron (@var{a}, @var{b})
 ## Form the kronecker product of two matrices, defined block by block as
-## 
+##
 ## @example
 ## x = [a(i, j) b]
 ## @end example
-## 
+##
 ## For example,
-## 
+##
 ## @example
 ## @group
 ## kron (1:4, ones (3, 1))
 ##      @result{}  1  2  3  4
 ##          1  2  3  4
 ##          1  2  3  4
 ## @end group
 ## @end example
@@ -43,24 +43,24 @@
 
 function x = kron (a, b)
 
   if (nargin == 2)
 
     [m, n] = size (b);
     [ma, na] = size (a);
 
-    x = zeros (ma*m, na*n);	
+    x = zeros (ma*m, na*n);
     i_vec = 1:m;
     j_vec = 1:n;
 
     for jj = 1:na
       for ii = 1:ma
-	x(i_vec+(ii-1)*m,j_vec) = a(ii,jj) * b;
+        x(i_vec+(ii-1)*m,j_vec) = a(ii,jj) * b;
       endfor
       j_vec = j_vec + n;
     endfor
-    
+
   else
     usage ("kron (a, b)");
   endif
 
 endfunction
diff --git a/scripts/linear-algebra/krylov.m b/scripts/linear-algebra/krylov.m
--- a/scripts/linear-algebra/krylov.m
+++ b/scripts/linear-algebra/krylov.m
@@ -104,17 +104,17 @@ function [Uret,H,nu] = krylov(A,V,k,eps1
         V = V(:,1:(nv-1));
         nu = nu - 1;    # one less reflection
 
       else
         # new householder reflection
         if(pflg)
           # locate max magnitude element in short_q
           asq = abs(short_q);
-	  maxv = max(asq);
+          maxv = max(asq);
           maxidx = find(asq == maxv);
           pivot_idx = short_pv(maxidx(1));
 
           # see if need to change the pivot list
           if(pivot_idx != pivot_vec(nu))
             swapidx = maxidx(1) + (nu-1);
             [pivot_vec(nu),pivot_vec(swapidx)] = ...
               swap(pivot_vec(nu),pivot_vec(swapidx));
diff --git a/scripts/linear-algebra/krylovb.m b/scripts/linear-algebra/krylovb.m
--- a/scripts/linear-algebra/krylovb.m
+++ b/scripts/linear-algebra/krylovb.m
@@ -14,17 +14,17 @@
 #
 # You should have received a copy of the GNU General Public License
 # along with Octave; see the file COPYING.  If not, write to the Free
 # Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 function [Uret,Ucols] = krylovb(A,V,k,eps1,pflg);
   # function [U,Ucols] = krylovb(A,V,k{,eps1,pflg});
   # construct orthogonal basis U of block Krylov subspace;
-  # 	[V AV A^2*V ... A^(k+1)*V];
+  #     [V AV A^2*V ... A^(k+1)*V];
   # method used: householder reflections to guard against loss of
   # orthogonality
   # eps1: threshhold for 0 (default: 1e-12)
   # pflg: permutation flag
   # outputs:
   #   returned basis U is orthogonal matrix; due to "zeroed"
   #   columns of product, may not satisfy A U = U H identity
   # Ucols: dimension of span of krylov subspace (based on eps1)
diff --git a/scripts/linear-algebra/norm.m b/scripts/linear-algebra/norm.m
--- a/scripts/linear-algebra/norm.m
+++ b/scripts/linear-algebra/norm.m
@@ -16,44 +16,44 @@
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} norm (@var{a}, @var{p})
 ## Compute the p-norm of the matrix @var{a}.  If the second argument is
 ## missing, @code{p = 2} is assumed.
-## 
+##
 ## If @var{a} is a matrix:
-## 
+##
 ## @table @asis
 ## @item @var{p} = @code{1}
 ## 1-norm, the largest column sum of @var{a}.
-## 
+##
 ## @item @var{p} = @code{2}
 ## Largest singular value of @var{a}.
-## 
+##
 ## @item @var{p} = @code{Inf}
 ## @cindex infinity norm
 ## Infinity norm, the largest row sum of @var{a}.
-## 
+##
 ## @item @var{p} = @code{"fro"}
 ## @cindex Frobenius norm
 ## Frobenius norm of @var{a}, @code{sqrt (sum (diag (@var{a}' * @var{a})))}.
 ## @end table
-## 
+##
 ## If @var{a} is a vector or a scalar:
-## 
+##
 ## @table @asis
 ## @item @var{p} = @code{Inf}
 ## @code{max (abs (@var{a}))}.
-## 
+##
 ## @item @var{p} = @code{-Inf}
 ## @code{min (abs (@var{a}))}.
-## 
+##
 ## @item other
 ## p-norm of @var{a}, @code{(sum (abs (@var{a}) .^ @var{p})) ^ (1/@var{p})}.
 ## @end table
 ## @end deftypefn
 ## @seealso{cond and svd}
 
 ## Author: jwe
 
@@ -77,23 +77,23 @@ function retval = norm (x, p)
         if (strcmp (p, "fro"))
           retval = sqrt (sum (diag (x' * x)));
         elseif (strcmp (p, "inf"))
           retval = max (abs (x));
         else
           error ("norm: unrecognized norm");
         endif
       else
-	if (p == Inf)
-	  retval = max (abs (x));
-	elseif (p == -Inf)
-	  retval = min (abs (x));
-	else
-	  retval = sum (abs (x) .^ p) ^ (1/p);
-	endif
+        if (p == Inf)
+          retval = max (abs (x));
+        elseif (p == -Inf)
+          retval = min (abs (x));
+        else
+          retval = sum (abs (x) .^ p) ^ (1/p);
+        endif
       endif
     elseif (nargin == 1)
       retval = sum (abs (x) .^ 2) ^ 0.5;
     endif
 
   else
 
     if (nargin == 2)
diff --git a/scripts/linear-algebra/null.m b/scripts/linear-algebra/null.m
--- a/scripts/linear-algebra/null.m
+++ b/scripts/linear-algebra/null.m
@@ -15,21 +15,21 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} null (@var{a}, @var{tol})
 ## Return an orthonormal basis of the null space of @var{a}.
-## 
+##
 ## The dimension of the null space is taken as the number of singular
 ## values of @var{a} not greater than @var{tol}.  If the argument @var{tol}
 ## is missing, it is computed as
-## 
+##
 ## @example
 ## max (size (@var{a})) * max (svd (@var{a})) * eps
 ## @end example
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Created: 24 December 1993.
 ## Adapted-By: jwe
diff --git a/scripts/linear-algebra/orth.m b/scripts/linear-algebra/orth.m
--- a/scripts/linear-algebra/orth.m
+++ b/scripts/linear-algebra/orth.m
@@ -15,21 +15,21 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} orth (@var{a}, @var{tol})
 ## Return an orthonormal basis of the range space of @var{a}.
-## 
+##
 ## The dimension of the range space is taken as the number of singular
 ## values of @var{a} greater than @var{tol}.  If the argument @var{tol} is
 ## missing, it is computed as
-## 
+##
 ## @example
 ## max (size (@var{a})) * max (svd (@var{a})) * eps
 ## @end example
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Created: 24 December 1993.
 ## Adapted-By: jwe
diff --git a/scripts/linear-algebra/qzhess.m b/scripts/linear-algebra/qzhess.m
--- a/scripts/linear-algebra/qzhess.m
+++ b/scripts/linear-algebra/qzhess.m
@@ -16,33 +16,33 @@
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{aa}, @var{bb}, @var{q}, @var{z}] =} qzhess (@var{a}, @var{b})
 ## Compute the Hessenberg-triangular decomposition of the matrix pencil
 ## @code{(@var{a}, @var{b})}, returning
-## @code{@var{aa} = @var{q} * @var{a} * @var{z}}, 
+## @code{@var{aa} = @var{q} * @var{a} * @var{z}},
 ## @code{@var{bb} = @var{q} * @var{b} * @var{z}}, with @var{q} and @var{z}
 ## orthogonal.  For example,
-## 
+##
 ## @example
 ## @group
 ## [aa, bb, q, z] = qzhess ([1, 2; 3, 4], [5, 6; 7, 8])
 ##      @result{} aa = [ -3.02244, -4.41741;  0.92998,  0.69749 ]
 ##      @result{} bb = [ -8.60233, -9.99730;  0.00000, -0.23250 ]
 ##      @result{}  q = [ -0.58124, -0.81373; -0.81373,  0.58124 ]
 ##      @result{}  z = [ 1, 0; 0, 1 ]
 ## @end group
 ## @end example
-## 
+##
 ## The Hessenberg-triangular decomposition is the first step in
 ## Moler and Stewart's QZ decomposition algorithm.
-## 
+##
 ## Algorithm taken from Golub and Van Loan, @cite{Matrix Computations, 2nd
 ## edition}.
 ## @end deftypefn
 
 ## Author: A. S. Hodel <scotte@eng.auburn.edu>
 ## Created: August 1993
 ## Adapted-By: jwe
 
diff --git a/scripts/linear-algebra/rank.m b/scripts/linear-algebra/rank.m
--- a/scripts/linear-algebra/rank.m
+++ b/scripts/linear-algebra/rank.m
@@ -18,21 +18,21 @@
 ## 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} rank (@var{a}, @var{tol})
 ## Compute the rank of @var{a}, using the singular value decomposition.
 ## The rank is taken to be the number  of singular values of @var{a} that
 ## are greater than the specified tolerance @var{tol}.  If the second
 ## argument is omitted, it is taken to be
-## 
+##
 ## @example
 ## tol = max (size (@var{a})) * sigma (1) * eps;
 ## @end example
-## 
+##
 ## @noindent
 ## where @code{eps} is machine precision and @code{sigma} is the largest
 ## singular value of @var{a}.
 ## @end deftypefn
 
 ## Author: jwe
 
 function retval = rank (A, tol)
diff --git a/scripts/linear-algebra/vec.m b/scripts/linear-algebra/vec.m
--- a/scripts/linear-algebra/vec.m
+++ b/scripts/linear-algebra/vec.m
@@ -1,20 +1,20 @@
 ## Copyright (C) 1995, 1996  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} vec (@var{x})
 ## Return the vector obtained by stacking the columns of the matrix @var{x}
 ## one above the other.
@@ -23,16 +23,16 @@
 ## See Magnus and Neudecker (1988), Matrix differential calculus with
 ## applications in statistics and econometrics.
 
 ## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Created: 8 May 1995
 ## Adapted-By: jwe
 
 function v = vec (x)
-  
+
   if (nargin != 1)
-    usage ("vec (x)"); 
-  endif 
-  
+    usage ("vec (x)");
+  endif
+
   v = reshape (x, prod (size (x)), 1);
 
 endfunction
diff --git a/scripts/linear-algebra/vech.m b/scripts/linear-algebra/vech.m
--- a/scripts/linear-algebra/vech.m
+++ b/scripts/linear-algebra/vech.m
@@ -1,20 +1,20 @@
 ## Copyright (C) 1995, 1996  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} vech (@var{x})
 ## Return the vector obtained by eliminating all supradiagonal elements of
 ## the square matrix @var{x} and stacking the result one column above the
@@ -24,29 +24,29 @@
 ## See Magnus and Neudecker (1988), Matrix differential calculus with
 ## applications in statistics and econometrics.
 
 ## Author KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Created: 8 May 1995
 ## Adapted-By: jwe
 
 function v = vech (x)
-  
+
   if (nargin != 1)
     usage ("vech (x)");
   endif
-  
+
   if (! is_square (x))
     error ("vech:  x must be square");
   endif
-  
+
   ## This should be quicker than having an inner `for' loop as well.
   ## Ideally, vech should be written in C++.
   n = rows (x);
   v = zeros ((n+1)*n/2, 1);
   count = 0;
   for j = 1 : n
-    i = j : n; 
+    i = j : n;
     v (count + i) = x (i, j);
     count = count + n - j;
   endfor
 
 endfunction
diff --git a/scripts/miscellaneous/bincoeff.m b/scripts/miscellaneous/bincoeff.m
--- a/scripts/miscellaneous/bincoeff.m
+++ b/scripts/miscellaneous/bincoeff.m
@@ -1,102 +1,102 @@
 ## Copyright (C) 1995, 1996  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Mapping Function} {} bincoeff (@var{n}, @var{k})
 ## Return the binomial coefficient of @var{n} and @var{k}, defined as
 ## @iftex
 ## @tex
 ## $$
 ##  {n \choose k} = {n (n-1) (n-2) \cdots (n-k+1) \over k!}
 ## $$
 ## @end tex
 ## @end iftex
 ## @ifinfo
-## 
+##
 ## @example
 ## @group
 ##  /   \
 ##  | n |    n (n-1) (n-2) ... (n-k+1)
 ##  |   |  = -------------------------
 ##  | k |               k!
 ##  \   /
 ## @end group
 ## @end example
 ## @end ifinfo
-## 
+##
 ## For example,
-## 
+##
 ## @example
 ## @group
 ## bincoeff (5, 2)
 ##      @result{} 10
 ## @end group
 ## @end example
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Created: 8 October 1994
 ## Adapted-By: jwe
 
 function b = bincoeff (n, k)
-  
+
   if (nargin != 2)
     usage ("bincoeff (n, k)");
   endif
-  
+
   [retval, n, k] = common_size (n, k);
   if (retval > 0)
     error ("bincoeff:  n and k must be of common size or scalars");
   endif
-  
+
   [r, c] = size (n);
   s = r * c;
   n   = reshape (n, s, 1);
   k   = reshape (k, s, 1);
   b   = zeros (s, 1);
-  
+
   ind = find (! (k >= 0) | (k != real (round (k))) | isnan (n));
   if (any (ind))
     b(ind) = NaN * ones (length (ind), 1);
   endif
-  
+
   ind = find (k == 0);
   if (any (ind))
     b(ind) = ones (length (ind), 1);
   endif
 
   ind = find ((k > 0) & ((n == real (round (n))) & (n < 0)));
   if any (ind)
     b(ind) = (-1) .^ k(ind) .* exp (lgamma (abs (n(ind)) + k(ind)) ...
-	- lgamma (k(ind) + 1) - lgamma (abs (n(ind))));
+        - lgamma (k(ind) + 1) - lgamma (abs (n(ind))));
   endif
-  
+
   ind = find ((k > 0) & ((n != real (round (n))) | (n >= k)));
   if (length (ind) > 0)
     b(ind) = exp (lgamma (n(ind) + 1) - lgamma (k(ind) + 1) ...
-	- lgamma (n(ind) - k(ind) + 1));
+        - lgamma (n(ind) - k(ind) + 1));
   endif
-  
+
   ## clean up rounding errors
   ind = find (n == round (n));
   if (any (ind))
     b(ind) = round (b(ind));
   endif
-  
+
   b = reshape (b, r, c);
-  
+
 endfunction
 
diff --git a/scripts/miscellaneous/comma.m b/scripts/miscellaneous/comma.m
--- a/scripts/miscellaneous/comma.m
+++ b/scripts/miscellaneous/comma.m
@@ -12,12 +12,12 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
-## @deftypefn {Operator} {} , 
+## @deftypefn {Operator} {} ,
 ## Array index, function argument, or command separator.
 ## @end deftypefn
 ## @seealso{semicolon}
diff --git a/scripts/miscellaneous/dump_prefs.m b/scripts/miscellaneous/dump_prefs.m
--- a/scripts/miscellaneous/dump_prefs.m
+++ b/scripts/miscellaneous/dump_prefs.m
@@ -32,81 +32,81 @@ function dump_prefs (file)
   endif
 
   ## XXX FIXME XXX -- it would be nice to be able to get the list of
   ## built-in variables directly from Octave so that we wouldn't have to
   ## remember to update it each time the list of preference variables
   ## changes
 
   var_list = ["EDITOR";
-	      "EXEC_PATH";
-	      "IMAGEPATH";
-	      "INFO_FILE";
-	      "INFO_PROGRAM";
-	      "LOADPATH";
-	      "PAGER";
-	      "PS1";
-	      "PS2";
-	      "PS4";
-	      "automatic_replot";
-	      "beep_on_error";
-	      "completion_append_char";
-	      "default_eval_print_flag";
-	      "default_global_variable_value";
-	      "default_return_value";
-	      "default_save_format";
-	      "define_all_return_values";
-	      "do_fortran_indexing";
-	      "echo_executing_commands";
-	      "empty_list_elements_ok";
-	      "fixed_point_format";
-	      "gnuplot_binary";
-	      "gnuplot_command_end";
-	      "gnuplot_command_plot";
-	      "gnuplot_command_replot";
-	      "gnuplot_command_splot";
-	      "gnuplot_command_title";
-	      "gnuplot_command_using";
-	      "gnuplot_command_with";
-	      "gnuplot_has_frames";
-	      "gnuplot_has_multiplot";
-	      "history_file";
-	      "history_size";
-	      "ignore_function_time_stamp";
-	      "implicit_num_to_str_ok";
-	      "implicit_str_to_num_ok";
-	      "initialize_global_variables";
-	      "max_recursion_depth";
-	      "ok_to_lose_imaginary_part";
-	      "output_max_field_width";
-	      "output_precision";
-	      "page_output_immediately";
-	      "page_screen_output";
-	      "prefer_column_vectors";
-	      "print_answer_id_name";
-	      "print_empty_dimensions";
-	      "print_rhs_assign_val";
-	      "propagate_empty_matrices";
-	      "resize_on_range_error";
-	      "return_last_computed_value";
-	      "save_precision";
-	      "saving_history";
-	      "silent_functions";
-	      "split_long_rows";
-	      "string_fill_char";
-	      "struct_levels_to_print";
-	      "suppress_verbose_help_message";
-	      "treat_neg_dim_as_zero";
-	      "warn_assign_as_truth_value";
-	      "warn_divide_by_zero";
-	      "warn_function_name_clash";
-	      "warn_future_time_stamp";
-	      "warn_missing_semicolon";
-	      "warn_variable_switch_label";
-	      "whitespace_in_literal_matrix"];
+              "EXEC_PATH";
+              "IMAGEPATH";
+              "INFO_FILE";
+              "INFO_PROGRAM";
+              "LOADPATH";
+              "PAGER";
+              "PS1";
+              "PS2";
+              "PS4";
+              "automatic_replot";
+              "beep_on_error";
+              "completion_append_char";
+              "default_eval_print_flag";
+              "default_global_variable_value";
+              "default_return_value";
+              "default_save_format";
+              "define_all_return_values";
+              "do_fortran_indexing";
+              "echo_executing_commands";
+              "empty_list_elements_ok";
+              "fixed_point_format";
+              "gnuplot_binary";
+              "gnuplot_command_end";
+              "gnuplot_command_plot";
+              "gnuplot_command_replot";
+              "gnuplot_command_splot";
+              "gnuplot_command_title";
+              "gnuplot_command_using";
+              "gnuplot_command_with";
+              "gnuplot_has_frames";
+              "gnuplot_has_multiplot";
+              "history_file";
+              "history_size";
+              "ignore_function_time_stamp";
+              "implicit_num_to_str_ok";
+              "implicit_str_to_num_ok";
+              "initialize_global_variables";
+              "max_recursion_depth";
+              "ok_to_lose_imaginary_part";
+              "output_max_field_width";
+              "output_precision";
+              "page_output_immediately";
+              "page_screen_output";
+              "prefer_column_vectors";
+              "print_answer_id_name";
+              "print_empty_dimensions";
+              "print_rhs_assign_val";
+              "propagate_empty_matrices";
+              "resize_on_range_error";
+              "return_last_computed_value";
+              "save_precision";
+              "saving_history";
+              "silent_functions";
+              "split_long_rows";
+              "string_fill_char";
+              "struct_levels_to_print";
+              "suppress_verbose_help_message";
+              "treat_neg_dim_as_zero";
+              "warn_assign_as_truth_value";
+              "warn_divide_by_zero";
+              "warn_function_name_clash";
+              "warn_future_time_stamp";
+              "warn_missing_semicolon";
+              "warn_variable_switch_label";
+              "whitespace_in_literal_matrix"];
 
   for i = 1:rows(var_list)
     var = deblank (var_list(i,:));
     try
       fprintf (file, "  %s = %s\n", var, type ("-q", var));
     catch
       fprintf (file, "# %s = <no value or error in displaying it>\n", var);
     end_try_catch
diff --git a/scripts/miscellaneous/etime.m b/scripts/miscellaneous/etime.m
--- a/scripts/miscellaneous/etime.m
+++ b/scripts/miscellaneous/etime.m
@@ -16,23 +16,23 @@
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} etime (@var{t1}, @var{t2})
 ## Return the difference (in seconds) between two time values returned from
 ## @code{clock}.  For example:
-## 
+##
 ## @example
 ## t0 = clock ();
 ## # many computations later...
 ## elapsed_time = etime (clock (), t0);
 ## @end example
-## 
+##
 ## @noindent
 ## will set the variable @code{elapsed_time} to the number of seconds since
 ## the variable @code{t0} was set.
 ## @end deftypefn
 ## @seealso{tic, toc, clock, and cputime}
 
 ## Author: jwe
 
diff --git a/scripts/miscellaneous/is_leap_year.m b/scripts/miscellaneous/is_leap_year.m
--- a/scripts/miscellaneous/is_leap_year.m
+++ b/scripts/miscellaneous/is_leap_year.m
@@ -17,17 +17,17 @@
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} is_leap_year (@var{year})
 ## Return 1 if the given year is a leap year and 0 otherwise.  If no
 ## arguments are provided, @code{is_leap_year} will use the current year.
 ## For example,
-## 
+##
 ## @example
 ## @group
 ## is_leap_year (2000)
 ##      @result{} 1
 ## @end group
 ## @end example
 ## @end deftypefn
 
@@ -40,11 +40,11 @@ function retval = is_leap_year (year)
   endif
 
   if (nargin == 0)
     t = clock ();
     year = t (1);
   endif
 
   retval = ((rem (year, 4) == 0 & rem (year, 100) != 0) ...
-	    | rem (year, 400) == 0);
+            | rem (year, 400) == 0);
 
 endfunction
diff --git a/scripts/miscellaneous/menu.m b/scripts/miscellaneous/menu.m
--- a/scripts/miscellaneous/menu.m
+++ b/scripts/miscellaneous/menu.m
@@ -54,26 +54,26 @@ function num = menu (t, ...)
       printf ("\n");
     endif
 
     nopt = nargin - 1;
 
     while (1)
       va_start ();
       for i = 1:nopt
-	printf ("  [%2d] ", i);
-	disp (va_arg ());
+        printf ("  [%2d] ", i);
+        disp (va_arg ());
       endfor
       printf ("\n");
       s = input ("pick a number, any number: ", "s");
       eval (sprintf ("num = %s;", s), "num = [];");
       if (! is_scalar (num) || num < 1 || num > nopt)
-	printf ("\nerror: input invalid or out of range\n\n");
+        printf ("\nerror: input invalid or out of range\n\n");
       else
-	break;
+        break;
       endif
     endwhile
 
   unwind_protect_cleanup
 
     page_screen_output = save_page_screen_output;
 
   end_unwind_protect
diff --git a/scripts/miscellaneous/path.m b/scripts/miscellaneous/path.m
--- a/scripts/miscellaneous/path.m
+++ b/scripts/miscellaneous/path.m
@@ -35,17 +35,17 @@
 ## Author: jwe
 
 function p = path (...)
 
   if (nargin == 0)
     if (nargout == 0)
       stdout << "\nLOADPATH contains the following directories:\n\n  ";
       stdout << strrep (LOADPATH, ":", "\n  ") << "\n\n";
-    else    
+    else
       p = LOADPATH;
     endif
   else
     p = va_arg ();
     for i = 2:nargin
       p = sprintf ("%s:%s", p, va_arg ());
     endfor
     LOADPATH = p;
diff --git a/scripts/miscellaneous/popen2.m b/scripts/miscellaneous/popen2.m
--- a/scripts/miscellaneous/popen2.m
+++ b/scripts/miscellaneous/popen2.m
@@ -21,19 +21,19 @@
 ## @deftypefn {Function File} {[@var{in}, @var{out}, @var{pid}] =} popen2 (@var{command}, @var{args})
 ## Start a subprocess with two-way communication.  The name of the process
 ## is given by @var{command}, and @var{args} is an array of strings
 ## containing options for the command.  The file identifiers for the input
 ## and output streams of the subprocess are returned in @var{in} and
 ## @var{out}.  If execution of the command is successful, @var{pid}
 ## contains the process ID of the subprocess.  Otherwise, @var{pid} is
 ## @minus{}1.
-## 
+##
 ## For example,
-## 
+##
 ## @example
 ## @group
 ## [in, out, pid] = popen2 ("sort", "-nr");
 ## fputs (in, "these\nare\nsome\nstrings\n");
 ## fclose (in);
 ## while (isstr (s = fgets (out)))
 ##   fputs (stdout, s);
 ## endwhile
@@ -62,51 +62,51 @@ function [in, out, pid] = popen2 (comman
 
     if (isstr (command))
 
       [stdin_pipe, stdin_status] = pipe ();
       [stdout_pipe, stdout_status] = pipe ();
 
       if (stdin_status == 0 && stdout_status == 0)
 
-	pid = fork ();
+        pid = fork ();
 
-	if (pid == 0)
+        if (pid == 0)
 
-	  fclose (stdin_pipe (2));
-	  fclose (stdout_pipe (1));
+          fclose (stdin_pipe (2));
+          fclose (stdout_pipe (1));
 
-	  dup2 (stdin_pipe (1), stdin);
-	  fclose (stdin_pipe (1));
+          dup2 (stdin_pipe (1), stdin);
+          fclose (stdin_pipe (1));
 
-	  dup2 (stdout_pipe (2), stdout);
-	  fclose (stdout_pipe (2));
+          dup2 (stdout_pipe (2), stdout);
+          fclose (stdout_pipe (2));
 
-	  if (exec (command, args) < 0)
-	    error ("popen2: unable to start process `%s'", command);
-	    exit (0);
-	  endif
+          if (exec (command, args) < 0)
+            error ("popen2: unable to start process `%s'", command);
+            exit (0);
+          endif
 
-	elseif (pid)
+        elseif (pid)
 
-	  fclose (stdin_pipe (1));
-	  fclose (stdout_pipe (2));
+          fclose (stdin_pipe (1));
+          fclose (stdout_pipe (2));
 
-	  if (fcntl (stdout_pipe (1), __F_SETFL__, __O_NONBLOCK__) < 0)
-	    error ("popen2: error setting file mode");
-	  else
-	    in = stdin_pipe (2);
-	    out = stdout_pipe (1);
-	  endif
+          if (fcntl (stdout_pipe (1), __F_SETFL__, __O_NONBLOCK__) < 0)
+            error ("popen2: error setting file mode");
+          else
+            in = stdin_pipe (2);
+            out = stdout_pipe (1);
+          endif
 
-	elseif (pid < 0)
-	  error ("popen2: fork failed -- unable to create child process");
-	endif
+        elseif (pid < 0)
+          error ("popen2: fork failed -- unable to create child process");
+        endif
       else
-	error ("popen2: pipe creation failed");
+        error ("popen2: pipe creation failed");
       endif
     else
       error ("popen2: file name must be a string");
     endif
   else
     usage ("[in, out, pid] = popen2 (command, args)");
   endif
 
diff --git a/scripts/miscellaneous/texas_lotto.m b/scripts/miscellaneous/texas_lotto.m
--- a/scripts/miscellaneous/texas_lotto.m
+++ b/scripts/miscellaneous/texas_lotto.m
@@ -16,17 +16,17 @@
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## @deftypefn {Function File } {@var{winning_numbers} =} texas_lotto ()
 ##
 ## Pick 6 unique numbers between 1 and 50 that are guaranteed to win
 ## the Texas Lotto.
-## @end deftypefn 
+## @end deftypefn
 ## @seealso{rand}
 
 ## Author: jwe
 
 function picks = texas_lotto ()
 
   if (nargin != 0)
     warning ("win_texas_lotto: ignoring extra arguments");
diff --git a/scripts/miscellaneous/tic.m b/scripts/miscellaneous/tic.m
--- a/scripts/miscellaneous/tic.m
+++ b/scripts/miscellaneous/tic.m
@@ -16,42 +16,42 @@
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} tic ()
 ## @deftypefnx {Function File} {} toc ()
 ## These functions set and check a wall-clock timer.  For example,
-## 
+##
 ## @example
 ## tic ();
 ## # many computations later...
 ## elapsed_time = toc ();
 ## @end example
-## 
+##
 ## @noindent
 ## will set the variable @code{elapsed_time} to the number of seconds since
 ## the most recent call to the function @code{tic}.
-## 
+##
 ## If you are more interested in the CPU time that your process used, you
 ## should use the @code{cputime} function instead.  The @code{tic} and
 ## @code{toc} functions report the actual wall clock time that elapsed
 ## between the calls.  This may include time spent processing other jobs or
 ## doing nothing at all.  For example,
-## 
+##
 ## @example
 ## @group
 ## tic (); sleep (5); toc ()
 ##      @result{} 5
 ## t = cputime (); sleep (5); cputime () - t
 ##      @result{} 0
 ## @end group
 ## @end example
-## 
+##
 ## @noindent
 ## (This example also illustrates that the CPU timer may have a fairly
 ## coarse resolution.)
 ## @end deftypefn
 
 ## Author: jwe
 
 function tic ()
diff --git a/scripts/miscellaneous/xor.m b/scripts/miscellaneous/xor.m
--- a/scripts/miscellaneous/xor.m
+++ b/scripts/miscellaneous/xor.m
@@ -1,20 +1,20 @@
 ## Copyright (C) 1995, 1996  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Mapping Function} {} xor (@var{x}, @var{y})
 ## Return the `exclusive or' of the entries of @var{x} and @var{y}.
 ## For boolean expressions @var{x} and @var{y},
@@ -24,17 +24,17 @@
 
 ## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Created: 16 September 1994
 ## Adapted-By: jwe
 
 function z = xor (x, y)
 
   if (nargin == 2)
-    if (is_scalar (x) || is_scalar (y) || size (x) == size (y))  
+    if (is_scalar (x) || is_scalar (y) || size (x) == size (y))
       z = logical ((x | y) - (x & y));
     else
       error ("xor: x and y must be of common size or scalars");
     endif
   else
     usage ("xor (x, y)");
   endif
 
diff --git a/scripts/plot/__plr2__.m b/scripts/plot/__plr2__.m
--- a/scripts/plot/__plr2__.m
+++ b/scripts/plot/__plr2__.m
@@ -39,75 +39,75 @@ function __plr2__ (theta, rho, fmt)
     if (is_scalar (rho))
       x = rho * cos (theta);
       y = rho * sin (theta);
       __plt2ss__ (x, y, fmt);
     endif
   elseif (is_vector (theta))
     if (is_vector (rho))
       if (length (theta) != length (rho))
-	error ("polar: vector lengths must match");
+        error ("polar: vector lengths must match");
       endif
       if (rows (rho) == 1)
-	rho = rho';
+        rho = rho';
       endif
       if (rows (theta) == 1)
-	theta = theta';
+        theta = theta';
       endif
       x = rho .* cos (theta);
       y = rho .* sin (theta);
       __plt2vv__ (x, y, fmt);
     elseif (is_matrix (rho))
       [t_nr, t_nc] = size (theta);
       if (t_nr == 1)
-	theta = theta';
-	tmp = t_nr;
-	t_nr = t_nc;
-	t_nc = tmp;
+        theta = theta';
+        tmp = t_nr;
+        t_nr = t_nc;
+        t_nc = tmp;
       endif
       [r_nr, r_nc] = size (rho);
       if (t_nr != r_nr)
-	rho = rho';
-	tmp = r_nr;
-	r_nr = r_nc;
-	r_nc = tmp;
+        rho = rho';
+        tmp = r_nr;
+        r_nr = r_nc;
+        r_nc = tmp;
       endif
       if (t_nr != r_nr)
-	error ("polar: vector and matrix sizes must match");
+        error ("polar: vector and matrix sizes must match");
       endif
       x = diag (cos (theta)) * rho;
       y = diag (sin (theta)) * rho;
       __plt2vm__ (x, y, fmt);
     endif
   elseif (is_matrix (theta))
     if (is_vector (rho))
       [r_nr, r_nc] = size (rho);
       if (r_nr == 1)
-	rho = rho';
-	tmp = r_nr;
-	r_nr = r_nc;
-	r_nc = tmp;
+        rho = rho';
+        tmp = r_nr;
+        r_nr = r_nc;
+        r_nc = tmp;
       endif
       [t_nr, t_nc] = size (theta);
       if (r_nr != t_nr)
-	theta = theta';
-	tmp = t_nr;
-	t_nr = t_nc;
-	t_nc = tmp;
+        theta = theta';
+        tmp = t_nr;
+        t_nr = t_nc;
+        t_nc = tmp;
       endif
       if (r_nr != t_nr)
-	error ("polar: vector and matrix sizes must match");
+        error ("polar: vector and matrix sizes must match");
       endif
       diag_r = diag (rho);
       x = diag_r * cos (theta);
       y = diag_r * sin (theta);
       __plt2mv__ (x, y, fmt);
     elseif (is_matrix (rho))
       if (size (rho) != size (theta))
-	error ("polar: matrix dimensions must match");
+        error ("polar: matrix dimensions must match");
       endif
       x = rho .* cos (theta);
       y = rho .* sin (theta);
       __plt2mm__ (x, y, fmt);
     endif
   endif
 
 endfunction
diff --git a/scripts/plot/__plt2mm__.m b/scripts/plot/__plt2mm__.m
--- a/scripts/plot/__plt2mm__.m
+++ b/scripts/plot/__plt2mm__.m
@@ -35,26 +35,26 @@ function __plt2mm__ (x, y, fmt)
   [y_nr, y_nc] = size (y);
 
   k = 1;
   fmt_nr = rows (fmt);
   if (x_nr == y_nr && x_nc == y_nc)
     if (x_nc > 0)
       tmp = [x, y];
       cmd = sprintf ("gplot tmp(:,%d:%d:%d) %s", 1, x_nc, x_nc+1,
-		     deblank (fmt (k, :)));
+                     deblank (fmt (k, :)));
       if (k < fmt_nr)
-      	k++;
+        k++;
       endif
       for i = 2:x_nc
         cmd = sprintf ("%s, tmp(:,%d:%d:%d) %s", cmd, i, x_nc, x_nc+i,
-		       deblank (fmt (k, :)));
-	if (k < fmt_nr)
-	  k++;
-	endif
+                       deblank (fmt (k, :)));
+        if (k < fmt_nr)
+          k++;
+        endif
       endfor
       eval (cmd);
     else
       error ("__plt2mm__: arguments must be a matrices");
     endif
   else
     error ("__plt2mm__: matrix dimensions must match");
   endif
diff --git a/scripts/plot/__plt2mv__.m b/scripts/plot/__plt2mv__.m
--- a/scripts/plot/__plt2mv__.m
+++ b/scripts/plot/__plt2mv__.m
@@ -52,25 +52,25 @@ function __plt2mv__ (x, y, fmt)
     error ("__plt2mv__: matrix dimensions must match");
   endif
 
   k = 1;
   fmt_nr = rows (fmt);
   if (x_nc > 0)
     tmp = [x, y];
     cmd = sprintf ("gplot tmp(:,%d:%d:%d) %s", 1, x_nc, x_nc+1,
-		   deblank (fmt (k, :)));
+                   deblank (fmt (k, :)));
     if (k < fmt_nr)
       k++;
     endif
     for i = 2:x_nc
       cmd = sprintf ("%s, tmp(:,%d:%d:%d) %s", cmd, i, x_nc-i+1, x_nc+1,
-		     deblank (fmt (k, :)));
+                     deblank (fmt (k, :)));
       if (k < fmt_nr)
-      	k++;
+        k++;
       endif
     endfor
     eval (cmd);
   else
     error ("__plt2mv__: arguments must be a matrices");
   endif
 
 endfunction
diff --git a/scripts/plot/__plt2vm__.m b/scripts/plot/__plt2vm__.m
--- a/scripts/plot/__plt2vm__.m
+++ b/scripts/plot/__plt2vm__.m
@@ -52,25 +52,25 @@ function __plt2vm__ (x, y, fmt)
     error ("__plt2vm__: matrix dimensions must match");
   endif
 
   k = 1;
   fmt_nr = rows (fmt);
   if (y_nc > 0)
     tmp = [x, y];
     cmd = sprintf ("gplot tmp(:,%d:%d:%d) %s", 1, x_nc, x_nc+1,
-		   deblank (fmt (k, :)));
+                   deblank (fmt (k, :)));
     if (k < fmt_nr)
       k++;
     endif
     for i = 2:y_nc
       cmd = sprintf ("%s, tmp(:,%d:%d:%d) %s", cmd, 1, i, i+1,
-		     deblank (fmt (k, :)));
+                     deblank (fmt (k, :)));
       if (k < fmt_nr)
-      	k++;
+        k++;
       endif
     endfor
     eval (cmd);
   else
     error ("__plt2vm__: arguments must be a matrices");
   endif
 
 endfunction
diff --git a/scripts/plot/__plt__.m b/scripts/plot/__plt__.m
--- a/scripts/plot/__plt__.m
+++ b/scripts/plot/__plt__.m
@@ -38,57 +38,57 @@ function __plt__ (caller, ...)
       nargin = nargin - 2;
       x_set = 1;
       y_set = 0;
 
       ## Gather arguments, decode format, and plot lines.
 
       while (nargin-- > 0)
 
-	fmt = "";
-	new = va_arg ();
+        fmt = "";
+        new = va_arg ();
 
-	if (isstr (new))
-	  if (! x_set)
-	    error ("plot: no data to plot");
-	  endif
-	  fmt = __pltopt__ (caller, new);
-	  if (! y_set)
-	    __plt1__ (x, fmt);
-	  else
-	    __plt2__ (x, y, fmt);
-	  endif
-	  hold on;
-	  x_set = 0;
-	  y_set = 0;
-	elseif (x_set)
-	  if (y_set)
-	    __plt2__ (x, y, fmt);
-	    hold on;
-	    x = new;
-	    y_set = 0;
-	  else
-	    y = new;
-	    y_set = 1;
-	  endif
-	else
-	  x = new;
-	  x_set = 1;
-	endif
+        if (isstr (new))
+          if (! x_set)
+            error ("plot: no data to plot");
+          endif
+          fmt = __pltopt__ (caller, new);
+          if (! y_set)
+            __plt1__ (x, fmt);
+          else
+            __plt2__ (x, y, fmt);
+          endif
+          hold on;
+          x_set = 0;
+          y_set = 0;
+        elseif (x_set)
+          if (y_set)
+            __plt2__ (x, y, fmt);
+            hold on;
+            x = new;
+            y_set = 0;
+          else
+            y = new;
+            y_set = 1;
+          endif
+        else
+          x = new;
+          x_set = 1;
+        endif
 
       endwhile
 
       ## Handle last plot.
 
       if  (x_set)
-	if (y_set)
-	  __plt2__ (x, y, fmt);
-	else
-	  __plt1__ (x, fmt);
-	endif
+        if (y_set)
+          __plt2__ (x, y, fmt);
+        else
+          __plt1__ (x, fmt);
+        endif
       endif
 
     unwind_protect_cleanup
 
       if (! hold_state)
         hold off;
       endif
 
diff --git a/scripts/plot/__pltopt1__.m b/scripts/plot/__pltopt1__.m
--- a/scripts/plot/__pltopt1__.m
+++ b/scripts/plot/__pltopt1__.m
@@ -92,22 +92,22 @@ function fmt = __pltopt1__ (caller, opt)
     elseif (strcmp (char, "#"))
       set_boxes = 1;
     elseif (strcmp (char, "0") || strcmp (char, "1") ...
             || strcmp (char, "2") || strcmp (char, "3") ...
             || strcmp (char, "4") || strcmp (char, "5") ...
             || strcmp (char, "6") || strcmp (char, "7") ...
             || strcmp (char, "8") || strcmp (char, "9"))
       if (set_color)
-	set_points = 1;
-	symbol = char;
-	set_symbol = 1;
+        set_points = 1;
+        symbol = char;
+        set_symbol = 1;
       else
-	color = char;
-	set_color = 1;
+        color = char;
+        set_color = 1;
       endif
     elseif (strcmp (char, "r"))
       set_color = 1;
       color = "1";
     elseif (strcmp (char, "g"))
       set_color = 1;
       color = "2";
     elseif (strcmp (char, "b"))
@@ -136,40 +136,40 @@ function fmt = __pltopt1__ (caller, opt)
       symbol = "1";
     elseif (strcmp (char, "x"))
       set_points = 1;
       set_symbol = 1;
       symbol = "4";
     elseif (strcmp (char, ";"))  # title mode.
       set_key = 1;
       working = 1;
-      key_title = ""; 
+      key_title = "";
       while (working)
         if (max (size (opt)) > 1)
-	  char = opt(1);
-	  opt = opt(2:length(opt));
+          char = opt(1);
+          opt = opt(2:length(opt));
         else
-	  char = opt;
-	  if (! strcmp (char, ";"))
+          char = opt;
+          if (! strcmp (char, ";"))
             error ("%s: unfinished key label", caller);
           end
           more_opts = 0;
           working = 0;
         endif
         if strcmp (char, ";")
           working = 0;
         else
-	  if (isempty (key_title))  # needs this to avoid empty matrix warning.
+          if (isempty (key_title))  # needs this to avoid empty matrix warning.
             key_title = char;
-	  else
+          else
             key_title = strcat (key_title, char);
-	  endif
+          endif
         endif
       endwhile
-    elseif (strcmp (char, " ")) 
+    elseif (strcmp (char, " "))
       ## whitespace -- do nothing.
     else
       error ("%s: unrecognized format character: '%s'", caller, char);
     endif
   endwhile
 
   ## Now create format string.
 
diff --git a/scripts/plot/__pltopt__.m b/scripts/plot/__pltopt__.m
--- a/scripts/plot/__pltopt__.m
+++ b/scripts/plot/__pltopt__.m
@@ -46,25 +46,25 @@
 ##      "+", "*", "o", "x" will display points in that style for term x11.
 ##
 ##   The legend may be fixed to include the name of the variable
 ##   plotted in some future version of Octave.
 ##
 ##   The colors, line styles, and point styles have the following
 ##   meanings for X11 and Postscript terminals under Gnuplot 3.6.
 ##
-##   Number ------ Color -------  Line Style      ---- Points Style ----   
-##          x11       postscript  postscript      x11         postscript   
+##   Number ------ Color -------  Line Style      ---- Points Style ----
+##          x11       postscript  postscript      x11         postscript
 ##   =====================================================================
-##     1    red       green       solid           "o"         "+"         
-##     2    green     blue        long dash       "+"         "x"         
-##     3    blue      red         short dash     square       "*"         
-##     4    magenta   magenta     dotted          "x"        open square  
+##     1    red       green       solid           "o"         "+"
+##     2    green     blue        long dash       "+"         "x"
+##     3    blue      red         short dash     square       "*"
+##     4    magenta   magenta     dotted          "x"        open square
 ##     5    cyan      cyan        dot long dash  triangle    filled square
-##     6    brown     yellow      dot short dash  "*"         "o"         
+##     6    brown     yellow      dot short dash  "*"         "o"
 ##
 ## @seealso{__pltopt1__}
 
 ## Author: jwe
 ## Adapted-By: jwe
 ## Maintainer: jwe
 
 function fmt = __pltopt__ (caller, opt)
diff --git a/scripts/plot/axis.m b/scripts/plot/axis.m
--- a/scripts/plot/axis.m
+++ b/scripts/plot/axis.m
@@ -15,24 +15,24 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} axis (@var{limits})
 ## Sets the axis limits for plots.
-## 
+##
 ## The argument @var{limits} should be a 2, 4, or 6 element vector.  The
 ## first and second elements specify the lower and upper limits for the x
 ## axis.  The third and fourth specify the limits for the y axis, and the
 ## fifth and sixth specify the limits for the z axis.
-## 
+##
 ## With no arguments, @code{axis} turns autoscaling on.
-## 
+##
 ## If your plot is already drawn, then you need to use @code{replot} before
 ## the new axis limits will take effect.  You can get this to happen
 ## automatically by setting the built-in variable @code{automatic_replot}
 ## to a nonzero value.
 ## @end deftypefn
 
 ## Author: jwe
 
diff --git a/scripts/plot/bar.m b/scripts/plot/bar.m
--- a/scripts/plot/bar.m
+++ b/scripts/plot/bar.m
@@ -15,35 +15,35 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} bar (@var{x}, @var{y})
 ## Given two vectors of x-y data, @code{bar} produces a bar graph.
-## 
+##
 ## If only one argument is given, it is taken as a vector of y-values
 ## and the x coordinates are taken to be the indices of the elements.
-## 
+##
 ## If two output arguments are specified, the data are generated but
 ## not plotted.  For example,
-## 
+##
 ## @example
 ## bar (x, y);
 ## @end example
-## 
+##
 ## @noindent
 ## and
-## 
+##
 ## @example
 ## [xb, yb] = bar (x, y);
 ## plot (xb, yb);
 ## @end example
-## 
+##
 ## @noindent
 ## are equivalent.
 ## @end deftypefn
 ## @seealso{plot, semilogx, semilogy, loglog, polar, mesh, contour,
 ## stairs, gplot, gsplot, replot, xlabel, ylabel, and title}
 
 ## Author: jwe
 
@@ -78,37 +78,37 @@ function [xb, yb] = bar (x, y)
         cutoff = zeros (1, xlen-1);
         for i = 1:xlen-1
           cutoff(i) = (x(i) + x(i+1)) / 2.0;
         endfor
         delta_p = cutoff(1) - x(1);
         delta_m = delta_p;
         tmp_xb(1) = x(1) - delta_m;
         tmp_yb(1) = 0.0;
-	k = 1;
+        k = 1;
         for i = 2:3:len
           tmp_xb(i) = tmp_xb(i-1);
           tmp_xb(i+1) = x(k) + delta_p;
           tmp_xb(i+2) = tmp_xb(i+1);
-	  tmp_yb(i) = y(k);
-	  tmp_yb(i+1) = y(k);
-	  tmp_yb(i+2) = 0.0;
+          tmp_yb(i) = y(k);
+          tmp_yb(i+1) = y(k);
+          tmp_yb(i+2) = 0.0;
           if (k < xlen)
             if (x(k+1) < x(k))
               error ("bar: x vector values must be in ascending order");
             endif
-	    delta_m = x(k+1) - cutoff(k);
+            delta_m = x(k+1) - cutoff(k);
             k++;
             if (k < xlen)
               delta_p = cutoff(k) - x(k);
-	    else
-	      delta_p = delta_m;
+            else
+              delta_p = delta_m;
             endif
-	  endif
-	endfor
+          endif
+        endfor
       else
         error ("bar: arguments must be the same length");
       endif
     else
       error ("bar: arguments must be vectors");
     endif
   else
     usage ("[xb, yb] = bar (x, y)");
diff --git a/scripts/plot/contour.m b/scripts/plot/contour.m
--- a/scripts/plot/contour.m
+++ b/scripts/plot/contour.m
@@ -39,23 +39,23 @@ function contour (z, n, x, y)
   ## no way to determine their current values.
 
   if (nargin == 1 || nargin == 2)
     if (is_matrix (z))
       gset nosurface;
       gset contour;
       gset cntrparam bspline;
       if (is_scalar (n))
-	command = sprintf ("gset cntrparam levels %d", n);
+        command = sprintf ("gset cntrparam levels %d", n);
       elseif (is_vector (n))
-	tmp = sprintf ("%f", n(1));
-	for i = 2:length (n)
-	  tmp = sprintf ("%s, %f", tmp, n(i));
-	endfor
-	command = sprintf ("gset cntrparam levels discrete %s", tmp);
+        tmp = sprintf ("%f", n(1));
+        for i = 2:length (n)
+          tmp = sprintf ("%s, %f", tmp, n(i));
+        endfor
+        command = sprintf ("gset cntrparam levels discrete %s", tmp);
       endif
       eval (command);
       gset noparametric;
       gset view 0, 0, 1, 1;
       gsplot z w l 1;
     else
       error ("contour: argument must be a matrix");
     endif
@@ -74,29 +74,29 @@ function contour (z, n, x, y)
           zz(:,i)   = x;
           zz(:,i+1) = y(k) * ones (xlen, 1);
           zz(:,i+2) = z(:,k);
           k++;
         endfor
         gset nosurface;
         gset contour;
         gset cntrparam bspline;
-	if (is_scalar (n))
+        if (is_scalar (n))
           command = sprintf ("gset cntrparam levels %d", n);
-	elseif (is_vector (n))
-	  tmp = sprintf ("%f", n(1));
-	  for i = 2:length (n)
-	    tmp = sprintf ("%s, %f", tmp, n(i));
-	  endfor
-	  command = sprintf ("gset cntrparam levels discrete %s", tmp);
-	endif
+        elseif (is_vector (n))
+          tmp = sprintf ("%f", n(1));
+          for i = 2:length (n)
+            tmp = sprintf ("%s, %f", tmp, n(i));
+          endfor
+          command = sprintf ("gset cntrparam levels discrete %s", tmp);
+        endif
         eval (command);
-	gset parametric;
+        gset parametric;
         gset view 0, 0, 1, 1;
-	gsplot zz w l 1;
+        gsplot zz w l 1;
       else
         msg = "contour: rows (z) must be the same as length (x) and";
         msg = sprintf ("%s\ncolumns (z) must be the same as length (y)", msg);
         error (msg);
       endif
     else
       error ("contour: x and y must be vectors and z must be a matrix");
     endif
diff --git a/scripts/plot/figure.m b/scripts/plot/figure.m
--- a/scripts/plot/figure.m
+++ b/scripts/plot/figure.m
@@ -35,21 +35,21 @@ function f = figure (n)
     f = max (figure_list) + 1;
   else
     f = n;
   endif
 
   if (nargin < 2)
     if (gnuplot_has_frames)
       if (! isempty (getenv ("DISPLAY")))
-	oneplot ();
-	figure_list = union (figure_list, f);
-	eval (sprintf ("gset term x11 %d\n", f));
+        oneplot ();
+        figure_list = union (figure_list, f);
+        eval (sprintf ("gset term x11 %d\n", f));
       else
-	error ("figure: requires X11 and valid DISPLAY");
+        error ("figure: requires X11 and valid DISPLAY");
       endif
     else
       error ("figure: gnuplot doesn't appear to support this feature");
     endif
   elseif (rem (nargin, 2) == 0)
     if (! figure_called)
       figure_called = 1;
       warning ("figure: setting figure properties is unsupported");
diff --git a/scripts/plot/hist.m b/scripts/plot/hist.m
--- a/scripts/plot/hist.m
+++ b/scripts/plot/hist.m
@@ -15,29 +15,29 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} hist (@var{y}, @var{x})
 ## Produce histogram counts or plots.
-## 
+##
 ## With one vector input argument, plot a histogram of the values with
 ## 10 bins.  The range of the histogram bins is determined by the range
 ## of the data.
-## 
+##
 ## Given a second scalar argument, use that as the number of bins.
-## 
+##
 ## Given a second vector argument, use that as the centers of the bins,
 ## with the width of the bins determined from the adjacent values in
 ## the vector.
-## 
+##
 ## Extreme values are lumped in the first and last bins.
-## 
+##
 ## With two output arguments, produce the values @var{nn} and @var{xx} such
 ## that @code{bar (@var{xx}, @var{nn})} will plot the histogram.
 ## @end deftypefn
 ## @seealso{bar}
 
 ## Author: jwe
 
 function [nn, xx] = hist (y, x)
diff --git a/scripts/plot/mesh.m b/scripts/plot/mesh.m
--- a/scripts/plot/mesh.m
+++ b/scripts/plot/mesh.m
@@ -62,51 +62,51 @@ function mesh (x, y, z)
         zz = zeros (ylen, len);
         k = 1;
         for i = 1:3:len
           zz(:,i)   = x(k) * ones (ylen, 1);
           zz(:,i+1) = y;
           zz(:,i+2) = z(:,k);
           k++;
         endfor
-	gset hidden3d;
-	gset data style lines;
+        gset hidden3d;
+        gset data style lines;
         gset surface;
         gset nocontour;
-	gset parametric;
+        gset parametric;
         gset view 60, 30, 1, 1
-	gsplot (zz);
-	gset noparametric;
+        gsplot (zz);
+        gset noparametric;
       else
         msg = "mesh: rows (z) must be the same as length (x) and";
         msg = sprintf ("%s\ncolumns (z) must be the same as length (y)", msg);
         error (msg);
       endif
     elseif (is_matrix (x) && is_matrix (y) && is_matrix (z))
       xlen = columns (z);
       ylen = rows (z);
       if (xlen == columns (x) && xlen == columns (y) &&
-	ylen == rows (x) && ylen == rows(y))
+        ylen == rows (x) && ylen == rows(y))
         len = 3 * xlen;
         zz = zeros (ylen, len);
         k = 1;
         for i = 1:3:len
           zz(:,i)   = x(:,k);
           zz(:,i+1) = y(:,k);
           zz(:,i+2) = z(:,k);
           k++;
         endfor
-	gset hidden3d;
-	gset data style lines;
+        gset hidden3d;
+        gset data style lines;
         gset surface;
         gset nocontour;
-	gset parametric;
+        gset parametric;
         gset view 60, 30, 1, 1
-	gsplot (zz);
-	gset noparametric;
+        gsplot (zz);
+        gset noparametric;
       else
         error ("mesh: x, y, and z must have same dimensions");
       endif
     else
       error ("mesh: x and y must be vectors and z must be a matrix");
     endif
   else
     usage ("mesh (z)");
diff --git a/scripts/plot/meshdom.m b/scripts/plot/meshdom.m
--- a/scripts/plot/meshdom.m
+++ b/scripts/plot/meshdom.m
@@ -16,17 +16,17 @@
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} meshdom (@var{x}, @var{y})
 ## Given vectors of @var{x} and @var{y} coordinates, return two matrices
 ## corresponding to the @var{x} and @var{y} coordinates of the mesh.
-## 
+##
 ## See the file @file{sombrero.m} for an example of using @code{mesh} and
 ## @code{meshdom}.
 ##
 ## Note: this function is provided for compatibility with older versions
 ## of @sc{Matlab}.  You should use @code{meshgrid} instead.
 ## @end deftypefn
 
 ## Author: jwe
diff --git a/scripts/plot/mplot.m b/scripts/plot/mplot.m
--- a/scripts/plot/mplot.m
+++ b/scripts/plot/mplot.m
@@ -17,20 +17,20 @@
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} mplot (@var{x}, @var{y})
 ## @deftypefnx {Function File} {} mplot (@var{x}, @var{y}, @var{fmt})
 ## @deftypefnx {Function File} {} mplot (@var{x1}, @var{y1}, @var{x2}, @var{y2})
 ## This is a modified version of the @code{plot} function that works with
-## the multiplot version of @code{gnuplot} to plot multiple plots per page. 
+## the multiplot version of @code{gnuplot} to plot multiple plots per page.
 ## This plot version automatically advances to the next subplot position
 ## after each set of arguments are processed.
-## 
+##
 ## See the description of the @var{plot} function for the various options.
 ## @end deftypefn
 
 ## Author: Vinayak Dutt <Dutt.Vinayak@mayo.EDU>
 ## Adapted-By: jwe
 
 function mplot (...)
 
@@ -57,19 +57,19 @@ function mplot (...)
 
   if (__multiplot_mode__)
 
     if (__multiplot_xi__ < __multiplot_xn__)
       __multiplot_xi__++;
     else
       __multiplot_xi__ = 1;
       if (__multiplot_yi__ < __multiplot_yn__)
-	__multiplot_yi__++;
+        __multiplot_yi__++;
       else
-	__multiplot_yi__ = 1;
+        __multiplot_yi__ = 1;
       endif
     endif
 
     xo = (__multiplot_xi__ - 1.0) * __multiplot_xsize__;
     yo = (__multiplot_yn__ - __multiplot_yi__) * __multiplot_ysize__;
 
     eval (sprintf ("gset origin %g, %g", xo, yo));
 
diff --git a/scripts/plot/multiplot.m b/scripts/plot/multiplot.m
--- a/scripts/plot/multiplot.m
+++ b/scripts/plot/multiplot.m
@@ -15,17 +15,17 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} multiplot (@var{xn}, @var{yn})
 ## Sets and resets multiplot mode.
-## 
+##
 ## If the arguments are non-zero, @code{multiplot} will set up multiplot
 ## mode with @var{xn}, @var{yn} subplots along the @var{x} and @var{y}
 ## axes.  If both arguments are zero, @code{multiplot} closes multiplot
 ## mode.
 ## @end deftypefn
 
 ## Author: Vinayak Dutt, Dutt.Vinayak@mayo.EDU
 ## Created: 3 July 95
diff --git a/scripts/plot/plot.m b/scripts/plot/plot.m
--- a/scripts/plot/plot.m
+++ b/scripts/plot/plot.m
@@ -16,147 +16,147 @@
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} plot (@var{args})
 ## This function produces two-dimensional plots.  Many different
 ## combinations of arguments are possible.  The simplest form is
-## 
+##
 ## @example
 ## plot (@var{y})
 ## @end example
-## 
+##
 ## @noindent
 ## where the argument is taken as the set of @var{y} coordinates and the
 ## @var{x} coordinates are taken to be the indices of the elements,
 ## starting with 1.
-## 
+##
 ## If more than one argument is given, they are interpreted as
-## 
+##
 ## @example
 ## plot (@var{x}, @var{y}, @var{fmt} ...)
 ## @end example
-## 
+##
 ## @noindent
 ## where @var{y} and @var{fmt} are optional, and any number of argument
 ## sets may appear.  The @var{x} and @var{y} values are
 ## interpreted as follows:
-## 
+##
 ## @itemize @bullet
 ## @item
 ## If a single data argument is supplied, it is taken as the set of @var{y}
 ## coordinates and the @var{x} coordinates are taken to be the indices of
 ## the elements, starting with 1.
-## 
+##
 ## @item
 ## If the first argument is a vector and the second is a matrix, the
 ## the vector is plotted versus the columns (or rows) of the matrix.
 ## (using whichever combination matches, with columns tried first.)
-## 
+##
 ## @item
 ## If the first argument is a matrix and the second is a vector, the
 ## the columns (or rows) of the matrix are plotted versus the vector.
 ## (using whichever combination matches, with columns tried first.)
-## 
+##
 ## @item
 ## If both arguments are vectors, the elements of @var{y} are plotted versus
 ## the elements of @var{x}.
-## 
+##
 ## @item
 ## If both arguments are matrices, the columns of @var{y} are plotted
 ## versus the columns of @var{x}.  In this case, both matrices must have
 ## the same number of rows and columns and no attempt is made to transpose
 ## the arguments to make the number of rows match.
-## 
+##
 ## If both arguments are scalars, a single point is plotted.
 ## @end itemize
-## 
+##
 ## If the @var{fmt} argument is supplied, it is interpreted as
 ## follows.  If @var{fmt} is missing, the default gnuplot line style
 ## is assumed.
-## 
+##
 ## @table @samp
 ## @item -
 ## Set lines plot style (default).
-## 
+##
 ## @item .
 ## Set dots plot style.
-## 
+##
 ## @item @@
 ## Set points plot style.
-## 
+##
 ## @item -@@
 ## Set linespoints plot style.
-## 
+##
 ## @item ^
 ## Set impulses plot style.
-## 
+##
 ## @item L
 ## Set steps plot style.
-## 
+##
 ## @item #
 ## Set boxes plot style.
-## 
+##
 ## @item ~
 ## Set errorbars plot style.
-## 
+##
 ## @item #~
 ## Set boxerrorbars plot style.
-## 
+##
 ## @item @var{n}
 ## Interpreted as the plot color if @var{n} is an integer in the range 1 to
 ## 6.
-## 
+##
 ## @item @var{nm}
 ## If @var{nm} is a two digit integer and @var{m} is an integer in the
 ## range 1 to 6, @var{m} is interpreted as the point style.  This is only
 ## valid in combination with the @code{@@} or @code{-@@} specifiers.
-## 
+##
 ## @item @var{c}
 ## If @var{c} is one of @code{"r"}, @code{"g"}, @code{"b"}, @code{"m"},
 ## @code{"c"}, or @code{"w"}, it is interpreted as the plot color (red,
 ## green, blue, magenta, cyan, or white).
-## 
+##
 ## @item +
 ## @itemx *
 ## @itemx o
 ## @itemx x
 ## Used in combination with the points or linespoints styles, set the point
 ## style.
 ## @end table
-## 
+##
 ## The color line styles have the following meanings on terminals that
 ## support color.
-## 
+##
 ## @example
 ## Number  Gnuplot colors  (lines)points style
 ##   1       red                   *
 ##   2       green                 +
 ##   3       blue                  o
 ##   4       magenta               x
 ##   5       cyan                house
 ##   6       brown            there exists
 ## @end example
-## 
+##
 ## Here are some plot examples:
-## 
+##
 ## @example
 ## plot (x, y, "@@12", x, y2, x, y3, "4", x, y4, "+")
 ## @end example
-## 
+##
 ## This command will plot @code{y} with points of type 2 (displayed as
 ## @samp{+}) and color 1 (red), @code{y2} with lines, @code{y3} with lines of
 ## color 4 (magenta) and @code{y4} with points displayed as @samp{+}.
-## 
+##
 ## @example
 ## plot (b, "*")
 ## @end example
-## 
+##
 ## This command will plot the data in the variable @code{b} will be plotted
 ## with points displayed as @samp{*}.
 ## @end deftypefn
 ## @seealso{semilogx, semilogy, loglog, polar, mesh, contour, __pltopt__
 ## bar, stairs, gplot, gsplot, replot, xlabel, ylabel, and title}
 
 ## Author: jwe
 
diff --git a/scripts/plot/plot_border.m b/scripts/plot/plot_border.m
--- a/scripts/plot/plot_border.m
+++ b/scripts/plot/plot_border.m
@@ -16,37 +16,37 @@
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} plot_border (...)
 ## Multiple arguments allowed to specify the sides on which the border
 ## is shown.  Allowed arguments include:
-## 
+##
 ## @table @code
 ## @item "blank"
 ## No borders displayed.
-## 
+##
 ## @item "all"
 ## All borders displayed
-## 
+##
 ## @item "north"
 ## North Border
-## 
+##
 ## @item "south"
 ## South Border
-## 
+##
 ## @item "east"
 ## East Border
-## 
+##
 ## @item "west"
 ## West Border
 ## @end table
-## 
+##
 ## @noindent
 ## The arguments may be abbreviated to single characters.  Without any
 ## arguments, @code{plot_border} turns borders off.
 ## @end deftypefn
 
 ## Author: Vinayak Dutt <Dutt.Vinayak@mayo.EDU>
 ## Created: 3 July 95
 ## Adapted-By: jwe
@@ -78,30 +78,30 @@ function plot_border (...)
     ## after "b", do that and ignore "b".
 
     if (strcmp (arg, "blank") || strcmp (arg, "BLANK")
         || strcmp (arg, "b") || strcmp (arg, "B"))
       none = 1;
     else
       none = 0;
       if (strcmp (arg, "south") || strcmp (arg, "SOUTH")
-	  || strcmp (arg, "s") || strcmp (arg, "S"))
-	south = 1;
+          || strcmp (arg, "s") || strcmp (arg, "S"))
+        south = 1;
       elseif (strcmp (arg, "west") || strcmp (arg, "WEST")
-	      || strcmp (arg, "w") || strcmp (arg, "W"))
-	west = 2;
+              || strcmp (arg, "w") || strcmp (arg, "W"))
+        west = 2;
       elseif (strcmp (arg, "north") || strcmp (arg, "NORTH")
-	      || strcmp (arg, "n") || strcmp (arg, "N"))
-	north = 4;
+              || strcmp (arg, "n") || strcmp (arg, "N"))
+        north = 4;
       elseif (strcmp (arg, "east") || strcmp (arg, "EAST")
-	      || strcmp (arg, "e") || strcmp (arg, "E"))
-	east = 8;
+              || strcmp (arg, "e") || strcmp (arg, "E"))
+        east = 8;
       elseif (strcmp (arg, "all") || strcmp (arg, "ALL")
-	      || strcmp (arg, "a") || strcmp (arg, "A"))
-	all = 1;
+              || strcmp (arg, "a") || strcmp (arg, "A"))
+        all = 1;
       endif
     endif
   endwhile
 
   if (none)
     gset noborder;
   else
     if (all)
diff --git a/scripts/plot/shg.m b/scripts/plot/shg.m
--- a/scripts/plot/shg.m
+++ b/scripts/plot/shg.m
@@ -12,23 +12,23 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
-## -*- texinfo -*- 
+## -*- texinfo -*-
 ## @deftypefn {Function File} {} shg
 ##
 ## Show the graph window.  Currently, this is the same as executing
 ## replot without any arguments.
-## 
-## @end deftypefn 
+##
+## @end deftypefn
 ## @seealso{plot, semilogx, semilogy, loglog, polar, mesh, contour,
 ## bar, stairs, gplot, gsplot, replot, xlabel, and ylabel}
 
 ## Author: jwe
 
 function shg ()
 
   if (nargin != 0)
diff --git a/scripts/plot/stairs.m b/scripts/plot/stairs.m
--- a/scripts/plot/stairs.m
+++ b/scripts/plot/stairs.m
@@ -15,35 +15,35 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} stairs (@var{x}, @var{y})
 ## Given two vectors of x-y data, bar produces a `stairstep' plot.
-## 
+##
 ## If only one argument is given, it is taken as a vector of y-values
 ## and the x coordinates are taken to be the indices of the elements.
-## 
+##
 ## If two output arguments are specified, the data are generated but
 ## not plotted.  For example,
-## 
+##
 ## @example
 ## stairs (x, y);
 ## @end example
-## 
+##
 ## @noindent
 ## and
-## 
+##
 ## @example
 ## [xs, ys] = stairs (x, y);
 ## plot (xs, ys);
 ## @end example
-## 
+##
 ## @noindent
 ## are equivalent.
 ## @end deftypefn
 ## @seealso{plot, semilogx, semilogy, loglog, polar, mesh, contour,
 ## bar, gplot, gsplot, replot, xlabel, ylabel, and title}
 
 ## Author: jwe
 
@@ -66,28 +66,28 @@ function [xs, ys] = stairs (x, y)
     endif
   elseif (nargin == 2)
     if (is_vector (x) && is_vector (y))
       xlen = length (x);
       ylen = length (y);
       if (xlen == ylen)
         len = 2 * xlen;
         tmp_xs = tmp_ys = zeros (len, 1);
-	k = 1;
+        k = 1;
         len_m2 = len - 2;
-	for i = 1:2:len_m2
-	  tmp_xs(i) = x(k);
-	  tmp_ys(i) = y(k);
-	  tmp_ys(i+1) = y(k);
+        for i = 1:2:len_m2
+          tmp_xs(i) = x(k);
+          tmp_ys(i) = y(k);
+          tmp_ys(i+1) = y(k);
           k++;
-	  tmp_xs(i+1) = x(k);
+          tmp_xs(i+1) = x(k);
           if (x(k) < x(k-1))
             error ("stairs: x vector values must be in ascending order");
           endif
-	endfor
+        endfor
         tmp_xs(len-1) = x(xlen);
         delta = x(xlen) - x(xlen-1);
         tmp_xs(len) = x(xlen) + delta;
         tmp_ys(len-1) = y(ylen);
         tmp_ys(len) = y(ylen);
       else
         error ("stairs: arguments must be the same length");
       endif
diff --git a/scripts/plot/subplot.m b/scripts/plot/subplot.m
--- a/scripts/plot/subplot.m
+++ b/scripts/plot/subplot.m
@@ -17,37 +17,37 @@
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} subplot (@var{rows}, @var{cols}, @var{index})
 ## @deftypefnx {Function File} {} subplot (@var{rcn})
 ## Sets @code{gnuplot} in multiplot mode and plots in location
 ## given by index (there are @var{cols} by @var{rows} subwindows).
-## 
+##
 ## Input:
-## 
+##
 ## @table @var
 ## @item rows
 ## Number of rows in subplot grid.
-## 
+##
 ## @item columns
 ## Number of columns in subplot grid.
-## 
+##
 ## @item index
 ## Index of subplot where to make the next plot.
 ## @end table
-## 
+##
 ## If only one argument is supplied, then it must be a three digit value
 ## specifying the location in digits 1 (rows) and 2 (columns) and the plot
 ## index in digit 3.
-## 
+##
 ## The plot index runs row-wise.  First all the columns in a row are filled
 ## and then the next row is filled.
-## 
+##
 ## For example, a plot with 4 by 2 grid will have plot indices running as
 ## follows:
 ## @iftex
 ## @tex
 ## \vskip 10pt
 ## \hfil\vbox{\offinterlineskip\hrule
 ## \halign{\vrule#&&\qquad\hfil#\hfil\qquad\vrule\cr
 ## height13pt&1&2&3&4\cr height12pt&&&&\cr\noalign{\hrule}
@@ -132,31 +132,31 @@ function subplot (rows, columns, index)
     __multiplot_xn__ = 1;
     __multiplot_yn__ = 1;
 
   else
 
     ## doing multiplot plots
 
     if (! __multiplot_mode__
- 	|| __multiplot_xn__ != columns
-	|| __multiplot_yn__ != rows)
+        || __multiplot_xn__ != columns
+        || __multiplot_yn__ != rows)
 
       __multiplot_mode__ = 1;
       __multiplot_xn__ = columns;
       __multiplot_yn__ = rows;
       __multiplot_xsize__ = 1.0 ./ columns;
       __multiplot_ysize__ = 1.0 ./ rows;
 
       gnuplot_command_replot = "cle;rep";
 
       gset multiplot;
 
       eval (sprintf ("gset size %g, %g", __multiplot_xsize__,
-		     __multiplot_ysize__));
+                     __multiplot_ysize__));
     endif
 
     ## get the sub plot location
 
     yp = fix ((index-1)/columns);
     xp = index - yp*columns - 1;
     __multiplot_xi__ = ++xp;
     __multiplot_yi__ = ++yp;
diff --git a/scripts/polynomial/compan.m b/scripts/polynomial/compan.m
--- a/scripts/polynomial/compan.m
+++ b/scripts/polynomial/compan.m
@@ -16,44 +16,44 @@
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} compan (@var{c})
 ## Compute the companion matrix corresponding to polynomial coefficient
 ## vector @var{c}.
-## 
+##
 ## The companion matrix is
 ## @iftex
 ## @tex
 ## $$
 ## A = \left[\matrix{
 ##  -c_2/c_1 & -c_3/c_1 & \cdots & -c_N/c_1 & -c_{N+1}/c_1\cr
 ##      1    &     0    & \cdots &     0    &         0   \cr
 ##      0    &     1    & \cdots &     0    &         0   \cr
 ##   \vdots  &   \vdots & \ddots &  \vdots  &      \vdots \cr
 ##      0    &     0    & \cdots &     1    &         0}\right].
 ## $$
 ## @end tex
 ## @end iftex
 ## @ifinfo
-## 
+##
 ## @smallexample
 ##      _                                                        _
 ##     |  -c(2)/c(1)   -c(3)/c(1)  ...  -c(N)/c(1)  -c(N+1)/c(1)  |
 ##     |       1            0      ...       0             0      |
 ##     |       0            1      ...       0             0      |
 ## A = |       .            .   .            .             .      |
 ##     |       .            .       .        .             .      |
 ##     |       .            .           .    .             .      |
 ##     |_      0            0      ...       1             0     _|
 ## @end smallexample
 ## @end ifinfo
-## 
+##
 ## The eigenvalues of the companion matrix are equal to the roots of the
 ## polynomial.
 ## @end deftypefn
 
 ## SEE ALSO: poly, roots, residue, conv, deconv, polyval, polyderiv, polyinteg
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: June 1994
diff --git a/scripts/polynomial/conv.m b/scripts/polynomial/conv.m
--- a/scripts/polynomial/conv.m
+++ b/scripts/polynomial/conv.m
@@ -15,17 +15,17 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} conv (@var{a}, @var{b})
 ## Convolve two vectors.
-## 
+##
 ## @code{y = conv (a, b)} returns a vector of length equal to
 ## @code{length (a) + length (b) - 1}.
 ## If @var{a} and @var{b} are polynomial coefficient vectors, @code{conv}
 ## returns the coefficients of the product polynomial.
 ## @end deftypefn
 
 ## SEE ALSO: deconv, poly, roots, residue, polyval, polyderiv, polyinteg
 
diff --git a/scripts/polynomial/deconv.m b/scripts/polynomial/deconv.m
--- a/scripts/polynomial/deconv.m
+++ b/scripts/polynomial/deconv.m
@@ -15,20 +15,20 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} deconv (@var{y}, @var{a})
 ## Deconvolve two vectors.
-## 
+##
 ## @code{[b, r] = deconv (y, a)} solves for @var{b} and @var{r} such that
 ## @code{y = conv (a, b) + r}.
-## 
+##
 ## If @var{y} and @var{a} are polynomial coefficient vectors, @var{b} will
 ## contain the coefficients of the polynomial quotient and @var{r} will be
 ## a remander polynomial of lowest order.
 ## @end deftypefn
 
 ## SEE ALSO: conv, poly, roots, residue, polyval, polyderiv, polyinteg
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
diff --git a/scripts/polynomial/polyfit.m b/scripts/polynomial/polyfit.m
--- a/scripts/polynomial/polyfit.m
+++ b/scripts/polynomial/polyfit.m
@@ -15,33 +15,33 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{p}, @var{yf}] =} polyfit (@var{x}, @var{y}, @var{n})
 ## Return the coefficients of a polynomial @var{p}(@var{x}) of degree
-## @var{n} that minimizes 
+## @var{n} that minimizes
 ## @iftex
 ## @tex
 ## $$
 ## \sum_{i=1}^N (p(x_i) - y_i)^2
 ## $$
 ## @end tex
 ## @end iftex
 ## @ifinfo
 ## @code{sumsq (p(x(i)) - y(i))},
 ## @end ifinfo
 ##  to best fit the data in the least squares sense.
 ##
 ## The polynomial coefficients are returned in a row vector if @var{x}
 ## and @var{y} are both row vectors; otherwise, they are returned in a
 ## column vector.
-## 
+##
 ## If two output arguments are requested, the second contains the values of
 ## the polynomial for each value of @var{x}.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Created: 13 December 1994
 ## Adapted-By: jwe
 
diff --git a/scripts/polynomial/polyinteg.m b/scripts/polynomial/polyinteg.m
--- a/scripts/polynomial/polyinteg.m
+++ b/scripts/polynomial/polyinteg.m
@@ -16,17 +16,17 @@
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} polyinteg (@var{c})
 ## Return the coefficients of the integral of the polynomial whose
 ## coefficients are represented by the vector @var{c}.
-## 
+##
 ## The constant of integration is set to zero.
 ## @end deftypefn
 
 ## SEE ALSO: poly, polyderiv, polyreduce, roots, conv, deconv, residue,
 ##           filter, polyval, polyvalm
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: June 1994
diff --git a/scripts/polynomial/polyout.m b/scripts/polynomial/polyout.m
--- a/scripts/polynomial/polyout.m
+++ b/scripts/polynomial/polyout.m
@@ -13,40 +13,40 @@
 ## for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{y} =} polyout (@var{c}@{, @var{x}@})
-## write formatted polynomial 
+## write formatted polynomial
 ## @example
 ##    c(x) = c(1) * x^n + ... + c(n) x + c(n+1)
 ## @end example
 ##  to string @var{y} or to the screen (if @var{y} is omitted)
 ##  @var{x} defaults to the string @code{"s"}
 ## @end deftypefn
-## @seealso{polyval, polyvalm, poly, roots, conv, deconv, residue, 
+## @seealso{polyval, polyvalm, poly, roots, conv, deconv, residue,
 ## filter, polyderiv, and polyinteg}
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: May 1995
 ## Nov 1998: Correctly handles complex coefficients
-  
+
 function y = polyout (c, x)
 
   if (nargin < 1 ) || (nargin > 2) || (nargout < 0 ) || (nargout > 1)
     usage("[y = ] polyout(c,[x])");
   endif
 
   if (!is_vector(c))
     error("polyout: first argument must be a vector");
   endif
-  
+
   if (nargin == 1)
     x = "s";
   elseif( ! isstr(x) )
     error("polyout: second argument must be a string");
   endif
 
   n = length(c);
   if(n > 0)
@@ -58,17 +58,17 @@ function y = polyout (c, x)
     for ii=2:n
       if(real(c(ii)) < 0)     ns = " - ";    c(ii) = -c(ii);
       else                    ns = " + ";                      endif
 
       if( imag(c(ii)) )       nstr = sprintf("(%s)",com2str(c(ii)) );
       else                    nstr = num2str(c(ii));           endif
 
       tmp = sprintf("%s*%s^%d%s%s",tmp,x,n1-ii,ns,nstr);
-      
+
     endfor
   else
     tmp = " ";
   endif
 
   if(nargout == 0)
     disp(tmp)
   else
diff --git a/scripts/polynomial/polyreduce.m b/scripts/polynomial/polyreduce.m
--- a/scripts/polynomial/polyreduce.m
+++ b/scripts/polynomial/polyreduce.m
@@ -45,23 +45,23 @@ function p = polyreduce (p)
     index = find (p == 0);
 
     if (length (index) != 0)
 
       index = find (index == 1:length (index));
 
       if (length (index) != 0)
 
-      	if (length (p) > 1)
-	  p = p (index (length (index))+1:length (p));
-      	endif
+        if (length (p) > 1)
+          p = p (index (length (index))+1:length (p));
+        endif
 
-      	if (length (p) == 0)
-	  p = 0;
-      	endif
+        if (length (p) == 0)
+          p = 0;
+        endif
 
       endif
 
     endif
 
   endif
 
 endfunction
diff --git a/scripts/polynomial/polyval.m b/scripts/polynomial/polyval.m
--- a/scripts/polynomial/polyval.m
+++ b/scripts/polynomial/polyval.m
@@ -15,20 +15,20 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} polyval (@var{c}, @var{x})
 ## Evaluate a polynomial.
-## 
+##
 ## @code{polyval (@var{c}, @var{x})} will evaluate the polynomial at the
 ## specified value of @var{x}.
-## 
+##
 ## If @var{x} is a vector or matrix, the polynomial is evaluated at each of
 ## the elements of @var{x}.
 ## @end deftypefn
 
 ## SEE ALSO: polyvalm, poly, roots, conv, deconv, residue, filter,
 ##           polyderiv, polyinteg
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
diff --git a/scripts/polynomial/polyvalm.m b/scripts/polynomial/polyvalm.m
--- a/scripts/polynomial/polyvalm.m
+++ b/scripts/polynomial/polyvalm.m
@@ -15,21 +15,21 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} polyvalm (@var{c}, @var{x})
 ## Evaluate a polynomial in the matrix sense.
-## 
+##
 ## @code{polyvalm (@var{c}, @var{x})} will evaluate the polynomial in the
 ## matrix sense, i.e. matrix multiplication is used instead of element by
 ## element multiplication as is used in polyval.
-## 
+##
 ## The argument @var{x} must be a square matrix.
 ## @end deftypefn
 
 ## SEE ALSO: polyval, poly, roots, conv, deconv, residue, filter,
 ##           polyderiv, polyinteg
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: June 1994
diff --git a/scripts/polynomial/residue.m b/scripts/polynomial/residue.m
--- a/scripts/polynomial/residue.m
+++ b/scripts/polynomial/residue.m
@@ -18,23 +18,23 @@
 ## 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} residue (@var{b}, @var{a}, @var{tol})
 ## If @var{b} and @var{a} are vectors of polynomial coefficients, then
 ## residue calculates the partial fraction expansion corresponding to the
 ## ratio of the two polynomials.
 ## @cindex partial fraction expansion
-## 
+##
 ## The function @code{residue} returns @var{r}, @var{p}, @var{k}, and
 ## @var{e}, where the vector @var{r} contains the residue terms, @var{p}
 ## contains the pole values, @var{k} contains the coefficients of a direct
 ## polynomial term (if it exists) and @var{e} is a vector containing the
 ## powers of the denominators in the partial fraction terms.
-## 
+##
 ## Assuming @var{b} and @var{a} represent polynomials
 ## @iftex
 ## @tex
 ## $P(s)$ and $Q(s)$
 ## @end tex
 ## @end iftex
 ## @ifinfo
 ##  P (s) and Q(s)
@@ -44,60 +44,60 @@
 ## @tex
 ## $$
 ## {P(s)\over Q(s)} = \sum_{m=1}^M {r_m\over (s-p_m)^e_m}
 ##   + \sum_{i=1}^N k_i s^{N-i}.
 ## $$
 ## @end tex
 ## @end iftex
 ## @ifinfo
-## 
+##
 ## @example
 ##  P(s)    M       r(m)         N
 ##  ---- = SUM -------------  + SUM k(i)*s^(N-i)
 ##  Q(s)   m=1 (s-p(m))^e(m)    i=1
 ## @end example
 ## @end ifinfo
-## 
+##
 ## @noindent
 ## where @var{M} is the number of poles (the length of the @var{r},
 ## @var{p}, and @var{e} vectors) and @var{N} is the length of the @var{k}
 ## vector.
-## 
+##
 ## The argument @var{tol} is optional, and if not specified, a default
 ## value of 0.001 is assumed.  The tolerance value is used to determine
 ## whether poles with small imaginary components are declared real.  It is
 ## also used to determine if two poles are distinct.  If the ratio of the
 ## imaginary part of a pole to the real part is less than @var{tol}, the
 ## imaginary part is discarded.  If two poles are farther apart than
 ## @var{tol} they are distinct.  For example,
-## 
+##
 ## @example
 ## @group
 ##  b = [1, 1, 1];
 ##  a = [1, -5, 8, -4];
 ##  [r, p, k, e] = residue (b, a);
 ##      @result{} r = [-2, 7, 3]
 ##      @result{} p = [2, 2, 1]
 ##      @result{} k = [](0x0)
 ##      @result{} e = [1, 2, 1]
 ## @end group
 ## @end example
-## 
+##
 ## @noindent
 ## which implies the following partial fraction expansion
 ## @iftex
 ## @tex
 ## $$
 ## {s^2+s+1\over s^3-5s^2+8s-4} = {-2\over s-2} + {7\over (s-2)^2} + {3\over s-1}
 ## $$
 ## @end tex
 ## @end iftex
 ## @ifinfo
-## 
+##
 ## @example
 ##         s^2 + s + 1       -2        7        3
 ##    ------------------- = ----- + ------- + -----
 ##    s^3 - 5s^2 + 8s - 4   (s-2)   (s-2)^2   (s-1)
 ## @end example
 ## @end ifinfo
 ## @end deftypefn
 
diff --git a/scripts/polynomial/roots.m b/scripts/polynomial/roots.m
--- a/scripts/polynomial/roots.m
+++ b/scripts/polynomial/roots.m
@@ -14,28 +14,28 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} roots (@var{v})
-## 
+##
 ## For a vector @var{v} with @var{N} components, return
 ## the roots of the polynomial
 ## @iftex
 ## @tex
 ## $$
 ## v_1 z^{N-1} + \cdots + v_{N-1} z + v_N.
 ## $$
 ## @end tex
 ## @end iftex
 ## @ifinfo
-## 
+##
 ## @example
 ## v(1) * z^(N-1) + ... + v(N-1) * z + v(N).
 ## @end example
 ## @end ifinfo
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Created: 24 December 1993
@@ -60,17 +60,17 @@ function r = roots (v)
     v = v(f(1):f(m));
     l = max (size (v));
     if (l > 1)
       A = diag (ones (1, l-2), -1);
       A(1,:) = -v(2:l) ./ v(1);
       r = eig (A);
       if (f(m) < n)
         tmp = zeros (n - f(m), 1);
-	r = [r; tmp];
+        r = [r; tmp];
       endif
     else
       r = zeros (n - f(m), 1);
     endif
   else
     r = [];
   endif
 
diff --git a/scripts/quaternion/quaternion.m b/scripts/quaternion/quaternion.m
--- a/scripts/quaternion/quaternion.m
+++ b/scripts/quaternion/quaternion.m
@@ -1,20 +1,20 @@
 function [a,b,c,d] = quaternion(w,x,y,z)
 # quaternion: construct or extract a quaternion
 #  w = a*i + b*j + c*k + d from given data.
 #
 # calling formats:
-# [a,b,c,d]   = quaternion(w)		-or-
+# [a,b,c,d]   = quaternion(w)           -or-
 # [vv,theta] = quaternion(w)
 # w           = quaternion(a,b,c,d)
 # w           = quaternion(vv,theta)
 
 switch(nargin)
-case(1),					# extract information
+case(1),                                        # extract information
   if(!(is_vector(w) & length(w) == 4) )
     error("input vector must be of length 4)")
   endif
   # extract data
   switch(nargout)
   case(4),
     a = w(1);
     b = w(2);
@@ -50,29 +50,29 @@ case(2),
   vv = w;
   theta = x;
 
   if(!is_vector(vv) | length(vv) != 3)
     error("vv must be a length three vector")
   elseif(!is_scalar(theta))
     error("theta must be a scalar");
   elseif(norm(vv) == 0)
-    error("quaternion: vv is zero.") 
+    error("quaternion: vv is zero.")
   elseif(abs(norm(vv)-1) > 1e-12)
     warning("quaternion: ||vv|| != 1, normalizing")
     vv = vv/norm(vv);
   endif
 
   if(abs(theta) > 2*pi)
     warning("quaternion: |theta| > 2 pi, normalizing")
     theta = rem(theta,2*pi);
   endif
   vv = vv*sin(theta/2);
   d = cos(theta/2);
-  a = quaternion(vv(1), vv(2), vv(3), d); 
+  a = quaternion(vv(1), vv(2), vv(3), d);
 
 case(4),
   if(nargout != 1)
     usage("w = quaterion(a,b,c,d)");
   endif
   if ( !(is_scalar(w) & is_scalar(x) & is_scalar(y) & is_scalar(z)) )
     error("input values must be scalars.")
   endif
diff --git a/scripts/set/complement.m b/scripts/set/complement.m
--- a/scripts/set/complement.m
+++ b/scripts/set/complement.m
@@ -16,17 +16,17 @@
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} complement (@var{x}, @var{y})
 ## Return the elements of set @var{y} that are not in set @var{x}.  For
 ## example,
-## 
+##
 ## @example
 ## @group
 ## complement ([ 1, 2, 3 ], [ 2, 3, 5 ])
 ##      @result{} 5
 ## @end group
 ## @end example
 ## @end deftypefn
 ## @seealso{create_set, union, and intersection}
diff --git a/scripts/set/create_set.m b/scripts/set/create_set.m
--- a/scripts/set/create_set.m
+++ b/scripts/set/create_set.m
@@ -16,17 +16,17 @@
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} create_set (@var{x})
 ## Return a row vector containing the unique values in @var{x}, sorted in
 ## ascending order.  For example,
-## 
+##
 ## @example
 ## @group
 ## create_set ([ 1, 2; 3, 4; 4, 2 ])
 ##      @result{} [ 1, 2, 3, 4 ]
 ## @end group
 ## @end example
 ## @end deftypefn
 ## @seealso{union, intersection, and complement}
diff --git a/scripts/set/intersection.m b/scripts/set/intersection.m
--- a/scripts/set/intersection.m
+++ b/scripts/set/intersection.m
@@ -16,17 +16,17 @@
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} intersection (@var{x}, @var{y})
 ## Return the set of elements that are in both sets @var{x} and @var{y}.
 ## For example,
-## 
+##
 ## @example
 ## @group
 ## intersection ([ 1, 2, 3 ], [ 2, 3, 5 ])
 ##      @result{} [ 2, 3 ]
 ## @end group
 ## @end example
 ## @end deftypefn
 ## @seealso{create_set, union, and complement}
diff --git a/scripts/set/union.m b/scripts/set/union.m
--- a/scripts/set/union.m
+++ b/scripts/set/union.m
@@ -16,17 +16,17 @@
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} union (@var{x}, @var{y})
 ## Return the set of elements that are in either of the sets @var{x} and
 ## @var{y}.  For example,
-## 
+##
 ## @example
 ## @group
 ## union ([ 1, 2, 4 ], [ 2, 3, 5 ])
 ##      @result{} [ 1, 2, 3, 4, 5 ]
 ## @end group
 ## @end example
 ## @end deftypefn
 ## @seealso{create_set, intersection, and complement}
diff --git a/scripts/signal/arch_fit.m b/scripts/signal/arch_fit.m
--- a/scripts/signal/arch_fit.m
+++ b/scripts/signal/arch_fit.m
@@ -1,25 +1,25 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-## usage:  [a, b] = arch_fit (y, X, p [, ITER [, gamma [, a0, b0]]]) 
+## usage:  [a, b] = arch_fit (y, X, p [, ITER [, gamma [, a0, b0]]])
 ##
 ## Fits an ARCH regression model to the time series y using the scoring
 ## algorithm in Engle's original ARCH paper.  The model is
 ##    y(t) = b(1) * x(t,1) + ... + b(k) * x(t,k) + e(t),
 ##    h(t) = a(1) + a(2) * e(t-1)^2 + ... + a(p+1) * e(t-p)^2,
 ## where e(t) is N(0, h(t)), given y up to time t-1 and X up to t.
 ##
 ## If invoked as arch_fit (y, k, p) with a positive integer k, fit an
@@ -28,59 +28,59 @@
 ##
 ## Optionally, one can specify the number of iterations ITER, the
 ## updating factor gamma, and initial values a0 and b0 for the scoring
 ## algorithm.
 ##
 ## The input parameters are:
 ##    y     ... time series (vector)
 ##    X     ... matrix of (ordinary) regressors or order of
-##              autoregression 
+##              autoregression
 ##    p     ... order of the regression of the residual variance
 
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  Fit an ARCH regression model
 
 function [a, b] = arch_fit (y, X, p, ITER, gamma, a0, b0)
 
   if ((nargin < 3) || (nargin == 6) || (nargin > 7))
     usage ("arch_fit (y, X, p [, ITER [, gamma [, a0, b0]]])");
   endif
-  
+
   if !(is_vector (y))
     error ("arch_test:  y must be a vector");
   endif
 
   T   = length (y);
   y   = reshape (y, T, 1);
   [rx, cx] = size (X);
   if ((rx == 1) && (cx == 1))
     X = autoreg_matrix (y, X);
   elseif !(rx == T)
     error (["arch_test:  ", ...
-	    "either rows (X) == length (y), or X is a scalar"]);
+            "either rows (X) == length (y), or X is a scalar"]);
   endif
 
   [T, k] = size (X);
-  
+
   if (nargin == 7)
     a   = a0;
     b   = b0;
     e   = y - X * b;
   else
     [b, v_b, e] = ols (y, X);
     a   = [v_b, (zeros (1, p))]';
     if (nargin < 5)
       gamma = 0.1;
       if (nargin < 4)
-	ITER = 50;
+        ITER = 50;
       endif
     endif
   endif
-  
+
   esq = e.^2;
   Z   = autoreg_matrix (esq, p);
 
   for i = 1 : ITER;
     h    = Z * a;
     tmp  = esq ./ h.^2 - 1 ./ h;
     s    = 1 ./ h(1:T-p);
     for j = 1 : p;
@@ -99,10 +99,10 @@ function [a, b] = arch_fit (y, X, p, ITE
     esq = e .^ 2;
     Z   = autoreg_matrix (esq, p);
     h   = Z * a;
     f   = esq ./ h - ones(T,1);
     Z_tilde = Z ./ (h * ones (1, p+1));
     delta_a = inv (Z_tilde' * Z_tilde) * Z_tilde' * f;
     a   = a + gamma * delta_a;
   endfor
-  
+
 endfunction
diff --git a/scripts/signal/arch_rnd.m b/scripts/signal/arch_rnd.m
--- a/scripts/signal/arch_rnd.m
+++ b/scripts/signal/arch_rnd.m
@@ -1,87 +1,86 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-## usage:  y = arch_rnd (a, b, T)  
+## usage:  y = arch_rnd (a, b, T)
 ##
 ## Simulates an ARCH sequence y of length T with AR coefficients b and
 ## CH coefficients a.
 ## I.e., y follows the model
 ##     y(t) = b(1) + b(2) * y(t-1) + ... + b(lb) * y(t-lb+1) + e(t),
 ## where e(t), given y up to time t-1, is N(0, h(t)), with
 ##     h(t) = a(1) + a(2) * e(t-1)^2 + ... + a(la) * e(t-la+1)^2.
 
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  Simulate an ARCH process
 
 function y = arch_rnd (a, b, T)
-  
+
   if (nargin != 3)
     usage ("arch_rnd (a, b, T)");
   endif
-  
+
   if !( (min (size (a)) == 1) && (min (size (b)) == 1) )
     error ("arch_rnd:  a and b must both be scalars or vectors");
   endif
   if !( is_scalar (T) && (T > 0) && (rem (T, 1) == 0) )
     error ("arch_rnd:  T must be a positive integer");
   endif
-  
+
   if !(a(1) > 0)
     error ("arch_rnd:  a(1) must be positive");
   endif
   ## perhaps add a test for the roots of a(z) here ...
-  
+
   la = length (a);
   a  = reshape (a, 1, la);
   if (la == 1)
     a  = [a, 0];
     la = la + 1;
   endif
   lb = length (b);
   b  = reshape (b, 1, lb);
   if (lb == 1)
     b  = [b, 0];
     lb = lb + 1;
   endif
   M  = max([la, lb]);
-  
+
   e  = zeros (T, 1);
   h  = zeros (T, 1);
   y  = zeros (T, 1);
-  
+
   h(1) = a(1);
   e(1) = sqrt (h(1)) * randn;
   y(1) = b(1) + e(1);
-  
+
   for t= 2 : M;
     ta   = min ([t, la]);
     h(t) = a(1) + a(2:ta) * e(t-1:t-ta+1).^2;
     e(t) = sqrt (h(t)) * randn;
     tb   = min ([t, lb]);
     y(t) = b(1) + b(2:tb) * y(t-1:t-tb+1) + e(t);
   endfor
   if (T > M)
     for t = M+1 : T;
       h(t) = a(1) + a(2:la) * e(t-1:t-la+1).^2;
       e(t) = sqrt (h(t)) * randn;
       y(t) = b(1) + b(2:lb) * y(t-1:t-tb+1) + e(t);
     endfor
   endif
-  
+
   y = y(1:T);
-  
+
 endfunction
-    
\ No newline at end of file
diff --git a/scripts/signal/arch_test.m b/scripts/signal/arch_test.m
--- a/scripts/signal/arch_test.m
+++ b/scripts/signal/arch_test.m
@@ -1,70 +1,70 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  [pval, lm] = arch_test (y, X, p)
 ##         [pval, lm] = arch_test (y, k, p)
 ##
 ## arch_test (y, X, p) performs a Lagrange Multiplier (LM) test of the
 ## null hypothesis of no conditional heteroscedascity in the linear
-## regression model y = X * b + e against the alternative of CH(p).   
+## regression model y = X * b + e against the alternative of CH(p).
 ## I.e., the model is
 ##     y(t) = b(1) * x(t,1) + ... + b(k) * x(t,k) + e(t),
 ## where given y up to t-1 and x up to t, e(t) is N(0, h(t)) with
 ##     h(t) = v + a(1) * e(t-1)^2 + ... + a(p) * e(t-p)^2,
 ## and the null is a(1) == ... == a(p) == 0.
 ##
 ## arch_test (y, k, p) does the same in a linear autoregression model of
-## order k, i.e., with [1, y(t-1), ..., y(t-k)] as the t-th row of X. 
+## order k, i.e., with [1, y(t-1), ..., y(t-k)] as the t-th row of X.
 ##
 ## Under the null, lm approximately has a chisquare distribution with p
 ## degrees of freedom.  pval is the p-value (1 minus the CDF of this
 ## distribution at lm) of the test.
 ##
 ## If no output argument is given, the p-value is displayed.
-  
+
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  Test for conditional heteroscedascity
-  
+
 function [pval, lm] = arch_test (y, X, p)
 
   if (nargin != 3)
     error ("arch_test needs 3 input arguments");
   endif
 
   if !(is_vector (y))
     error ("arch_test:  y must be a vector");
   endif
   T   = length (y);
   y   = reshape (y, T, 1);
   [rx, cx] = size (X);
   if ((rx == 1) && (cx == 1))
     X = autoreg_matrix (y, X);
   elseif !(rx == T)
     error (["arch_test:  ", ...
-	    "either rows(X) == length(y), or X is a scalar"]);
+            "either rows(X) == length(y), or X is a scalar"]);
   endif
   if !(is_scalar(p) && (rem(p, 1) == 0) && (p > 0))
     error ("arch_test:  p must be a positive integer.");
   endif
-  
+
   [b, v_b, e] = ols (y, X);
   Z    = autoreg_matrix (e.^2, p);
   f    = e.^2 / v_b - ones (T, 1);
   f    = Z' * f;
   lm   = f' * inv (Z'*Z) * f / 2;
   pval = 1 - chisquare_cdf (lm, p);
-  
+
 endfunction
\ No newline at end of file
diff --git a/scripts/signal/arma_rnd.m b/scripts/signal/arma_rnd.m
--- a/scripts/signal/arma_rnd.m
+++ b/scripts/signal/arma_rnd.m
@@ -1,79 +1,79 @@
 ## Copyright (C) 1995, 1996, 1997  Friedrich Leisch
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  arma_rnd (a, b, v, t [, n])
 ##
 ## Returns a simulation of the ARMA model
 ##   x(n) = a(1) * x(n-1) + ... + a(k) * x(n-k) +
 ##              + e(n) + b(1) * e(n-1) + ... + b(l) * e(n-l),
 ## where k is the length of vector a, l is the length of vector b and e
 ## is gaussian white noise with variance v.  The function returns a
 ## vector of length t.
 ##
 ## The optional parameter n gives the number of dummy x(i) used for
 ## initialization, i.e., a sequence of length t+n is generated and
-## x(n+1:t+n) is returned.  If n is omitted, n=100 is used. 
-  
+## x(n+1:t+n) is returned.  If n is omitted, n=100 is used.
+
 ## Author:  FL <Friedrich.Leisch@ci.tuwien.ac.at>
 ## Description:  Simulate an ARMA process
 
 function x = arma_rnd (a, b, v, t, n)
 
   unwind_protect
     orig_listelemok = empty_list_elements_ok;
     empty_list_elements_ok = "true";
-  
+
     if (nargin == 4)
       n = 100;
     elseif (nargin == 5)
       if (!is_scalar (t))
-      	error ("arma_rnd: n must be a scalar");
+        error ("arma_rnd: n must be a scalar");
       endif
     else
       usage ("arma_rnd (a, b, v, t [, n])");
     endif
 
     if ( (min (size (a)) > 1) || (min (size (b)) > 1) )
       error ("arma_rnd:  a and b must not be matrices");
     endif
-  
+
     if (!is_scalar (t))
       error ("arma_rnd:  t must be a scalar");
     endif
-  
+
     ar = length (a);
     br = length (b);
 
     a = reshape (a, ar, 1);
     b = reshape (b, br, 1);
-  
-    a = [1; -a];			# apply our notational convention
+
+    a = [1; -a];                        # apply our notational convention
     b = [1; b];
-    
+
     n = min (n, ar + br);
-    
+
     e = sqrt (v) * randn (t + n, 1);
-  
+
     x = filter (b, a, e);
     x = x(n + 1 : t + n);
 
   unwind_protect_cleanup
-    
+
     empty_list_elements_ok = orig_listelemok;
-    
+
   end_unwind_protect
 
 endfunction
diff --git a/scripts/signal/autocor.m b/scripts/signal/autocor.m
--- a/scripts/signal/autocor.m
+++ b/scripts/signal/autocor.m
@@ -1,44 +1,44 @@
 ## Copyright (C) 1995, 1996, 1997  Friedrich Leisch
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  autocor (X [, h])
-## 
+##
 ## returns the autocorrelations from lag 0 to h of vector X.
 ## If h is omitted, all autocorrelations are computed.
 ## If X is a matrix, the autocorrelations of every single column are
-## computed. 
-  
+## computed.
+
 ## Author:  FL <Friedrich.Leisch@ci.tuwien.ac.at>
 ## Description:  Compute autocorrelations
-  
+
 function retval = autocor (X, h)
-  
+
   if (nargin == 1)
     retval = autocov (X);
   elseif (nargin == 2)
     retval = autocov (X, h);
   else
-    usage ("autocor (X [, h])");    
+    usage ("autocor (X [, h])");
   endif
-  
+
   if (min (retval (1,:)) != 0)
     retval = retval ./ ( ones (rows (retval), 1) * retval(1, :) );
   endif
-  
+
 endfunction
-    
+
 
-  
+
diff --git a/scripts/signal/autocov.m b/scripts/signal/autocov.m
--- a/scripts/signal/autocov.m
+++ b/scripts/signal/autocov.m
@@ -1,49 +1,49 @@
 ## Copyright (C) 1995, 1996, 1997  Friedrich Leisch
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  autocov (X [, h])
-## 
+##
 ## returns the autocovariances from lag 0 to h of vector X.
 ## If h is omitted, all autocovariances are computed.
 ## If X is a matrix, the autocovariances of every single column are
-## computed. 
+## computed.
 
 ## Author:  FL <Friedrich.Leisch@ci.tuwien.ac.at>
 ## Description:  Compute autocovariances
-  
+
 function retval = autocov (X, h)
-  
+
   [n, c] = size (X);
-  
+
   if (is_vector (X))
     n = length (X);
     c = 1;
     X = reshape (X, n, 1);
   endif
-  
+
   X = center (X);
-  
+
   if (nargin == 1)
     h = n - 1;
   endif
-  
+
   retval = zeros (h + 1, c);
-  
+
   for i = 0 : h
     retval(i+1, :) = diag (X(i+1:n, :).' * conj (X(1:n-i, :))) / n;
   endfor
-  
+
 endfunction
diff --git a/scripts/signal/autoreg_matrix.m b/scripts/signal/autoreg_matrix.m
--- a/scripts/signal/autoreg_matrix.m
+++ b/scripts/signal/autoreg_matrix.m
@@ -1,44 +1,44 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  X = autoreg_matrix (y, k)
 ##
 ## Given a time series (vector) y, returns a matrix X with ones in the
 ## first column and the first k lagged values of y in the other columns.
 ## I.e., for t > k, [1, y(t-1), ..., y(t-k)] is the t-th row of X. X can
 ## be used as regressor matrix in autoregressions.
-  
+
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  Design matrix for autoregressions
 
 function X = autoreg_matrix (y, k)
 
   if (nargin != 2)
     usage ("autoreg_matrix (y, k)");
   endif
-  
+
   if !(is_vector (y))
     error ("autoreg_matrix:  y must be a vector");
   endif
-  
+
   T = length (y);
   y = reshape (y, T, 1);
   X = ones (T, k+1);
   for j = 1 : k;
     X(:, j+1) = [(zeros (j, 1)); y(1:T-j)];
   endfor
-  
+
 endfunction
diff --git a/scripts/signal/bartlett.m b/scripts/signal/bartlett.m
--- a/scripts/signal/bartlett.m
+++ b/scripts/signal/bartlett.m
@@ -1,45 +1,45 @@
 ## Copyright (C) 1995, 1996, 1997  Andreas Weingessel
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  bartlett (m)
 ##
 ## Returns the filter coefficients of a Bartlett (triangular) window of
 ## length m.
 ##
 ## For a definition of the Bartlett window, see e.g. A. V. Oppenheim &
 ## R. W. Schafer, "Discrete-Time Signal Processing".
 
 ## Author:  AW <Andreas.Weingessel@ci.tuwien.ac.at>
 ## Description:  Coefficients of the Bartlett (triangular) window
 
 function c = bartlett (m)
-  
+
   if (nargin != 1)
     usage ("bartlett (m)");
   endif
-  
+
   if !(is_scalar (m) && (m == round (m)) && (m > 0))
     error ("bartlett:  m has to be an integer > 0");
   endif
-  
+
   if (m == 1)
     c = 1;
   else
     m = m - 1;
     n = fix (m / 2);
     c (1 : n+1) = 2 * (0 : n)' / m;
     c (n+2 : m+1) = 2 - 2 * (n+1 : m)'/m;
   endif
diff --git a/scripts/signal/blackman.m b/scripts/signal/blackman.m
--- a/scripts/signal/blackman.m
+++ b/scripts/signal/blackman.m
@@ -1,45 +1,45 @@
 ## Copyright (C) 1995, 1996, 1997  Andreas Weingessel
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  blackman (m)
 ##
 ## Returns the filter coefficients of a Blackman window of length m.
 ##
 ## For a definition of the  Blackman window, see e.g. A. V. Oppenheim &
 ## R. W. Schafer, "Discrete-Time Signal Processing".
 
 ## Author:  AW <Andreas.Weingessel@ci.tuwien.ac.at>
 ## Description:  Coefficients of the Blackman window
-  
+
 function c = blackman (m)
-  
+
   if (nargin != 1)
     usage ("blackman (m)");
   endif
-  
+
   if !(is_scalar (m) && (m == round (m)) && (m > 0))
     error ("blackman:  m has to be an integer > 0");
   endif
-  
+
   if (m == 1)
     c = 1;
   else
     m = m - 1;
     k = (0 : m)' / m;
     c = 0.42 - 0.5 * cos (2 * pi * k) + 0.08 * cos (4 * pi * k);
   endif
-  
+
 endfunction
diff --git a/scripts/signal/detrend.m b/scripts/signal/detrend.m
--- a/scripts/signal/detrend.m
+++ b/scripts/signal/detrend.m
@@ -1,58 +1,58 @@
 ## Copyright (C) 1995, 1996  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} detrend (@var{x}, @var{p})
 ## If @var{x} is a vector, @code{detrend (@var{x}, @var{p})} removes the
 ## best fit of a polynomial of order @var{p} from the data @var{x}.
-## 
+##
 ## If @var{x} is a matrix, @code{detrend (@var{x}, @var{p})} does the same
 ## for each column in @var{x}.
-## 
+##
 ## The second argument is optional.  If it is not specified, a value of 1
 ## is assumed.  This corresponds to removing a linear trend.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Created: 11 October 1994
 ## Adapted-By: jwe
-  
+
 function y = detrend (x, p)
-  
+
   if (nargin == 1)
     p = 1;
   elseif (nargin == 2)
     if (! (is_scalar (p) && p == round (p) && p >= 0))
       error ("detrend:  p must be a nonnegative integer");
     endif
   else
     usage ("detrend (x [, p])");
   endif
-  
+
   [m, n] = size (x);
   if (m == 1)
     x = x';
   endif
-  
+
   r = rows (x);
   b = ((1 : r)' * ones (1, p + 1)) .^ (ones (r, 1) * (0 : p));
   y = x - b * (b \ x);
-  
+
   if (m == 1)
     y = y';
   endif
-  
+
 endfunction
diff --git a/scripts/signal/diffpara.m b/scripts/signal/diffpara.m
--- a/scripts/signal/diffpara.m
+++ b/scripts/signal/diffpara.m
@@ -1,20 +1,20 @@
 ## Copyright (C) 1995, 1996, 1997  Friedrich Leisch
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  [d, D] = diffpara (X [, a [, b]])
 ##
 ## Returns the estimator d for the differencing parameter of an
 ## integrated time series.
@@ -25,22 +25,22 @@
 ## sqrt(T) is used, where T is the sample size. If X is a matrix, the
 ## differencing parameter of every single column is estimated.
 ##
 ## D contains the estimators for all frequencies in the intervals
 ## described above, d is simply mean(D).
 ##
 ## Reference: Brockwell, Peter J. & Davis, Richard A. Time Series:
 ## Theory and Methods Springer 1987
-  
+
 ## Author:  FL <Friedrich.Leisch@ci.tuwien.ac.at>
 ## Description:  Estimate the fractional differencing parameter
 
 function [d, D] = diffpara (X, a, b)
-  
+
   if ((nargin < 1) || (nargin > 3))
     usage ("[d [, D]] = diffpara (X [, a [, b]])");
   else
     if is_vector (X)
       n = length (X);
       k = 1;
       X = reshape (X, n, 1);
     else
@@ -49,35 +49,35 @@ function [d, D] = diffpara (X, a, b)
     if (nargin == 1)
       a = 0.5 * sqrt (n);
       b = 1.5 * sqrt (n);
     elseif (nargin == 2)
       b = a;
       a = 1;
     endif
   endif
-    
+
   if !(is_scalar (a) && is_scalar (b))
     error ("diffpara:  a and b must be scalars");
   endif
-    
+
   D = zeros (b - a + 1, k);
-  
+
   for l = 1:k
-    
+
     w = 2 * pi * (1 : n-1) / n;
-    
+
     x = 2 * log (abs( 1 - exp (-i*w)));
     y = log (periodogram (X(2:n,l)));
-  
+
     x = center (x);
     y = center (y);
-  
+
     for m = a:b
       D(m-a+1) = - x(1:m) * y(1:m) / sumsq (x(1:m));
     endfor
-    
+
   endfor
-  
+
   d = mean (D);
-  
+
 endfunction
 
diff --git a/scripts/signal/durbinlevinson.m b/scripts/signal/durbinlevinson.m
--- a/scripts/signal/durbinlevinson.m
+++ b/scripts/signal/durbinlevinson.m
@@ -1,89 +1,89 @@
 ## Copyright (C) 1995  Friedrich Leisch
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  durbinlevinson (c, [oldphi, oldv])
 ##
 ## Performs one step of the Durbin-Levinson algorithm.
 ##
 ## The vector c_t = [gamma_0, ..., gamma_t] contains the autocovariances
 ## from lag 0 to t, oldphi the coefficients based on c_(t-1) and oldv
 ## the corresponding error.
 ##
 ## If oldphi is omitted, all steps from 1 to t of the algorithm are
 ## performed.
-   
+
 ## Author:  FL <Friedrich.Leisch@ci.tuwien.ac.at>
 ## Description:  Perform one step of the Durbin-Levinson algorithm
-  
+
 function [newphi, newv] = durbinlevinson (c, oldphi, oldv)
-  
+
   if( !((nargin == 1) || (nargin == 3)) )
     usage ("durbinlevinson (c, [oldphi, oldv])");
   endif
-  
+
   if( columns (c) > 1 )
     c=c';
   endif
 
   newphi = 0;
   newv = 0;
-  
+
   if (nargin == 3)
-    
+
     t = length (oldphi) + 1;
-  
+
     if (length (c) < t+1)
       error ("durbilevinson:  c too small");
     endif
-  
+
     if (oldv == 0)
       error ("durbinlevinson: oldv = 0");
     endif
-    
+
     if (rows (oldphi) > 1 )
       oldphi = oldphi';
     endif
-    
+
     newphi = zeros (1, t);
     newphi(1) = ( c(t+1) - oldphi * c(2:t) ) / oldv;
     for i = 2 : t
       newphi(i) = oldphi(i-1) - newphi(1) * oldphi(t-i+1);
     endfor
     newv = ( 1 - newphi(1)^2 ) * oldv;
-    
+
   elseif(nargin == 1)
-    
+
     tt = length (c)-1;
     oldphi = c(2) / c(1);
     oldv = ( 1 - oldphi^2 ) * c(1);
-    
+
     for t = 2 : tt
-    
+
       newphi = zeros (1, t);
       newphi(1) = ( c(t+1) - oldphi * c(2:t) ) / oldv;
       for i = 2 : t
-	newphi(i) = oldphi(i-1) - newphi(1) * oldphi(t-i+1);
+        newphi(i) = oldphi(i-1) - newphi(1) * oldphi(t-i+1);
       endfor
       newv = ( 1 - newphi(1)^2 ) * oldv;
-      
+
       oldv = newv;
       oldphi = newphi;
-    
+
     endfor
-    
+
   endif
 
 endfunction
diff --git a/scripts/signal/fftconv.m b/scripts/signal/fftconv.m
--- a/scripts/signal/fftconv.m
+++ b/scripts/signal/fftconv.m
@@ -18,17 +18,17 @@
 ## 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} fftconv (@var{a}, @var{b}, @var{n})
 ## Return the convolution of the vectors @var{a} and @var{b}, as a vector
 ## with length equal to the @code{length (a) + length (b) - 1}.  If @var{a}
 ## and @var{b} are the coefficient vectors of two polynomials, the returned
 ## value is the coefficient vector of the product polynomial.
-## 
+##
 ## The computation uses the FFT by calling the function @code{fftfilt}.  If
 ## the optional argument @var{n} is specified, an N-point FFT is used.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Created: 3 September 1994
 ## Adapted-By: jwe
 
@@ -48,15 +48,15 @@ function c = fftconv (a, b, N)
   else
     lc = la + lb - 1;
     a(lc) = 0;
     b(lc) = 0;
     if (nargin == 2)
       c = fftfilt (a, b);
     else
       if !(is_scalar (N))
-	error ("fftconv: N has to be a scalar");
+        error ("fftconv: N has to be a scalar");
       endif
       c = fftfilt (a, b, N);
     endif
   endif
 
 endfunction
diff --git a/scripts/signal/fftfilt.m b/scripts/signal/fftfilt.m
--- a/scripts/signal/fftfilt.m
+++ b/scripts/signal/fftfilt.m
@@ -14,20 +14,20 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} fftfilt (@var{b}, @var{x}, @var{n})
-## 
+##
 ## With two arguments, @code{fftfilt} filters @var{x} with the FIR filter
 ## @var{b} using the FFT.
-## 
+##
 ## Given the optional third argument, @var{n}, @code{fftfilt} uses the
 ## overlap-add method to filter @var{x} with @var{b} using an N-point FFT.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Created: 3 September 1994
 ## Adapted-By: jwe
 
diff --git a/scripts/signal/fftshift.m b/scripts/signal/fftshift.m
--- a/scripts/signal/fftshift.m
+++ b/scripts/signal/fftshift.m
@@ -1,20 +1,20 @@
 ## Copyright (C) 1997 by Vincent Cautaerts
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage: y = fftshift(W)
 ##
 ## Performs a shift of the vector V, for use with the "fft" and "ifft"
 ## functions, in order the move the frequency 0 to the centre of
diff --git a/scripts/signal/fractdiff.m b/scripts/signal/fractdiff.m
--- a/scripts/signal/fractdiff.m
+++ b/scripts/signal/fractdiff.m
@@ -1,62 +1,62 @@
 ## Copyright (C) 1995, 1996, 1997  Friedrich Leisch
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  fractdiff(x, d)
 ##
 ## Computes the fractional differences (1-L)^d x where L denotes the
 ## lag-operator and d > -1.
-  
+
 ## Author:  FL <Friedrich.Leisch@ci.tuwien.ac.at>
 ## Description:  Compute fractional differences
-    
+
 function retval = fractdiff (x, d)
-    
+
   N = 100;
-  
+
   if !is_vector (x)
     error ("fractdiff:  x must be a vector")
   endif
-  
+
   if !is_scalar (d)
     error ("fractdiff:  d must be a scalar")
   endif
-  
-    
+
+
   if (d >= 1)
     for k = 1 : d
       x = x(2 : length (x)) - x(1 : length (x) - 1);
     endfor
   endif
-  
+
   if (d > -1)
-    
+
     d = rem (d, 1);
-  
+
     if (d != 0)
       n = (0 : N)';
       w = real (gamma (-d+n) ./ gamma (-d) ./ gamma (n+1));
       retval = fftfilt (w, x);
       retval = retval(1 : length (x));
     else
       retval = x;
     endif
-    
+
   else
     error ("fractdiff:  d must be > -1");
-    
+
   endif
-  
+
 endfunction
diff --git a/scripts/signal/freqz.m b/scripts/signal/freqz.m
--- a/scripts/signal/freqz.m
+++ b/scripts/signal/freqz.m
@@ -26,36 +26,36 @@
 ## @ifinfo
 ##  2*pi.
 ## @end ifinfo
 ## @iftex
 ## @tex
 ##  $2\pi$.
 ## @end tex
 ## @end iftex
-## 
+##
 ## @noindent
 ## The output value @var{w} is a vector of the frequencies.
-## 
+##
 ## If the fourth argument is omitted, the response is evaluated at
 ## frequencies between 0 and
 ## @ifinfo
 ##  pi.
 ## @end ifinfo
 ## @iftex
 ## @tex
 ##  $\pi$.
 ## @end tex
 ## @end iftex
-## 
+##
 ## If @var{n} is omitted, a value of 512 is assumed.
-## 
+##
 ## If @var{a} is omitted, the denominator is assumed to be 1 (this
 ## corresponds to a simple FIR filter).
-## 
+##
 ## For fastest computation, @var{n} should factor into a small number of
 ## small primes.
 ## @end deftypefn
 
 ## Author: jwe ???
 
 function [h, w] = freqz(b,...)
 
diff --git a/scripts/signal/hamming.m b/scripts/signal/hamming.m
--- a/scripts/signal/hamming.m
+++ b/scripts/signal/hamming.m
@@ -1,44 +1,44 @@
 ## Copyright (C) 1995, 1996, 1997  Andreas Weingessel
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  hamming (m)
 ##
 ## Returns the filter coefficients of a Hamming window of length m.
 ##
 ## For a definition of the Hamming window, see e.g. A. V. Oppenheim &
 ## R. W. Schafer, "Discrete-Time Signal Processing".
 
 ## Author:  AW <Andreas.Weingessel@ci.tuwien.ac.at>
 ## Description:  Coefficients of the Hamming window
 
 function c = hamming (m)
-  
+
   if (nargin != 1)
     usage ("hamming (m)");
   endif
-  
+
   if !(is_scalar (m) && (m == round (m)) && (m > 0))
     error ("hamming:  m has to be an integer > 0");
   endif
-  
+
   if (m == 1)
     c = 1;
   else
     m = m - 1;
     c = 0.54 - 0.46 * cos (2 * pi * (0:m)' / m);
   endif
-  
+
 endfunction
diff --git a/scripts/signal/hanning.m b/scripts/signal/hanning.m
--- a/scripts/signal/hanning.m
+++ b/scripts/signal/hanning.m
@@ -1,44 +1,44 @@
 ## Copyright (C) 1995, 1996, 1997  Andreas Weingessel
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  hanning (m)
 ##
 ## Returns the filter coefficients of a Hanning window of length m.
 ##
 ## For a definition of this window type, see e.g. A. V. Oppenheim &
 ## R. W. Schafer, "Discrete-Time Signal Processing".
-  
+
 ## Author:  AW <Andreas.Weingessel@ci.tuwien.ac.at>
 ## Description:  Coefficients of the Hanning window
 
 function c = hanning (m)
-  
+
   if (nargin != 1)
     usage ("hanning (m)");
   endif
-  
+
   if !(is_scalar (m) && (m == round (m)) && (m > 0))
     error ("hanning:  m has to be an integer > 0");
   endif
-  
+
   if (m == 1)
     c = 1;
   else
     m = m - 1;
     c = 0.5 - 0.5 * cos (2 * pi * (0 : m)' / m);
   endif
-  
+
 endfunction
diff --git a/scripts/signal/hurst.m b/scripts/signal/hurst.m
--- a/scripts/signal/hurst.m
+++ b/scripts/signal/hurst.m
@@ -1,45 +1,45 @@
 ## Copyright (C) 1995, 1996, 1997  Friedrich Leisch
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  H = hurst (x)
 ##
 ## Estimates the Hurst parameter of sample x via the rescaled range
 ## statistic. If x is a matrix, the parameter is estimated for every
 ## single column.
 
 ## Author:  FL <Friedrich.Leisch@ci.tuwien.ac.at>
 ## Description:  Estimate the Hurst parameter
-  
+
 function H = hurst (x)
 
   if (nargin != 1)
     usage ("hurst (x)");
   endif
 
   if (is_scalar (x))
     error ("hurst:  x must not be a scalar")
   elseif is_vector (x)
     x = reshape (x, length (x), 1);
   end
-    
+
   [xr, xc] = size (x);
 
   s = std (x);
   w = cumsum (x - mean (x));
   RS = (max(w) - min(w)) ./ s;
   H = log (RS) / log (xr);
-  
+
 endfunction
diff --git a/scripts/signal/periodogram.m b/scripts/signal/periodogram.m
--- a/scripts/signal/periodogram.m
+++ b/scripts/signal/periodogram.m
@@ -1,41 +1,41 @@
 ## Copyright (C) 1995, 1996, 1997  Friedrich Leisch
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  periodogram (x)
 ##
 ## For a data matrix x from a sample of size n, return the periodogram.
-  
+
 ## Author: FL <Friedrich.Leisch@ci.tuwien.ac.at>
 ## Description:  Compute the periodogram
 
 function retval = periodogram (x)
 
   [r, c] = size(x);
 
   if (r == 1)
     r = c;
   endif
-  
+
   retval = (abs (fft (x - mean (x)))) .^ 2 / r;
-  
+
 endfunction
 
-  
-
 
 
 
 
+
+
diff --git a/scripts/signal/rectangle_lw.m b/scripts/signal/rectangle_lw.m
--- a/scripts/signal/rectangle_lw.m
+++ b/scripts/signal/rectangle_lw.m
@@ -1,32 +1,32 @@
 ## Copyright (C) 1995, 1996, 1997  Friedrich Leisch
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  retval = rectangle_lw (n, b)
 ##
 ## Rectangular lag window. Subfunction used for spectral density
 ## estimation.
-  
+
 ## Author:  FL <Friedrich.Leisch@ci.tuwien.ac.at>
 ## Description:  Rectangular lag window
 
 function retval = rectangle_lw (n, b)
-  
+
   retval = zeros (n, 1);
   t = floor (1 / b);
-  
+
   retval (1:t, 1) = ones (t, 1);
 
 endfunction
diff --git a/scripts/signal/rectangle_sw.m b/scripts/signal/rectangle_sw.m
--- a/scripts/signal/rectangle_sw.m
+++ b/scripts/signal/rectangle_sw.m
@@ -1,42 +1,42 @@
 ## Copyright (C) 1995, 1996, 1997  Friedrich Leisch
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  retval = rectangle_sw (n, b)
 ##
 ## Rectangular spectral window. Subfunction used for spectral density
 ## estimation.
-  
+
 ## Author:  FL <Friedrich.Leisch@ci.tuwien.ac.at>
 ## Description:  Rectangular spectral window
 
 function retval = rectangle_sw (n, b)
-  
+
   retval = zeros (n, 1);
   retval(1) = 2 / b + 1;
 
   l = (2:n)' - 1;
   l = 2 * pi * l / n;
 
   retval(2:n) = sin( (2/b + 1) * l / 2 ) ./ sin (l / 2);
-    
+
 endfunction
 
 
 
 
 
 
 
diff --git a/scripts/signal/sinetone.m b/scripts/signal/sinetone.m
--- a/scripts/signal/sinetone.m
+++ b/scripts/signal/sinetone.m
@@ -1,60 +1,60 @@
 ## Copyright (C) 1995, 1996, 1997  Friedrich Leisch
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  sinetone (freq [, rate [, sec [, ampl]]])
 ##
 ## Returns a sinetone of frequency freq with length of sec seconds at
 ## sampling rate rate and with amplitude ampl.  freq and ampl may be
 ## vectors of common size.
 ##
 ## Defaults are rate = 8000, sec = 1 and ampl = 64.
-    
+
 ## Author:  FL <Friedrich.Leisch@ci.tuwien.ac.at>
 ## Description:  Compute a sine tone
-  
+
 function retval = sinetone (f, r, s, a)
-  
+
   if (nargin == 1)
     r = 8000;
     s = 1;
     a = 64;
   elseif (nargin == 2)
     s = 1;
     a = 64;
   elseif (nargin == 3)
     a = 64;
   elseif ((nargin < 1) || (nargin > 4))
     usage ("sinetone (freq [, rate [, sec [, ampl]]])");
   endif
-  
+
   [err, f, a] = common_size (f, a);
   if (err || ! is_vector (f))
     error ("sinetone:  freq and ampl must be vectors of common size");
   endif
-  
+
   if !(is_scalar (r) && is_scalar (s))
     error ("sinetone:  rate and sec must be scalars");
   endif
 
   n = length (f);
 
   retval = zeros (r * s, n);
   for k = 1:n
     retval (:, k) = a(k) * sin (2 * pi * (1:r*s) / r * f(k))';
   endfor
-  
+
 endfunction
 
diff --git a/scripts/signal/sinewave.m b/scripts/signal/sinewave.m
--- a/scripts/signal/sinewave.m
+++ b/scripts/signal/sinewave.m
@@ -1,36 +1,36 @@
 ## Copyright (C) 1995, 1996, 1997  Andreas Weingessel
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  sinewave (m, n [, d])
 ##
 ## Computes an (m x 1)-vector X with i-th element X(i) given by sin (2 *
 ## pi * (i+d-1) / n).
 ##
 ## The default value for d is 0.
 
 ## Author:  AW <Andreas.Weingessel@ci.tuwien.ac.at>
 ## Description:  Compute a sine wave
 
 function x = sinewave (m, n, d)
-  
+
   if (nargin == 2)
     d = 0;
   elseif (nargin != 3)
     usage ("sinewave (m, n [, d])");
   endif
 
   x = sin ( ((1 : m) + d - 1) * 2 * pi / n);
 
diff --git a/scripts/signal/spectral_adf.m b/scripts/signal/spectral_adf.m
--- a/scripts/signal/spectral_adf.m
+++ b/scripts/signal/spectral_adf.m
@@ -1,61 +1,61 @@
 ## Copyright (C) 1995, 1996, 1997  Friedrich Leisch
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  retval = spectral_adf (c, [win, [b]])
-## 
+##
 ## Returns the spectral density estimator.
 ## c ....... vector of autocovariances (starting at lag 0)
 ## win ..... window name, eg. "triangle" or "rectangle"
 ##           spectral_adf searches for a function called win_lw ()
 ## b ....... bandwidth
-## 
+##
 ## If win is omitted, the triangle window is used as default.
 ## If b is omitted, 1 / sqrt( length (c)) is used as default.
-  
+
 ## Author:  FL <Friedrich.Leisch@ci.tuwien.ac.at>
 ## Description:  Spectral density estimation
-  
+
 function retval = spectral_adf (c, win, b)
-  
+
   cr = length (c);
-  
+
   if (columns (c) > 1)
     c=c';
   endif
 
   if (nargin < 3)
     b = 1 / ceil (sqrt (cr));
   endif
 
   if (nargin == 1)
     w = triangle_lw (cr, b);
   else
     win = [win, "_lw"];
     w = feval (win, cr, b);
   endif
-      
+
   c = c .* w;
-  
+
   retval = 2 * real (fft (c)) - c(1);
   retval = [(zeros (cr, 1)), retval];
   retval(:, 1) = (0 : cr-1)' / cr;
-  
+
 endfunction
-    
-
-  
 
 
+
+
+
diff --git a/scripts/signal/spectral_xdf.m b/scripts/signal/spectral_xdf.m
--- a/scripts/signal/spectral_xdf.m
+++ b/scripts/signal/spectral_xdf.m
@@ -1,66 +1,66 @@
 ## Copyright (C) 1995, 1996, 1997  Friedrich Leisch
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  retval = spectral_xdf (X, [win, [b]])
-## 
+##
 ## Returns the spectral density estimator.
 ## X ....... data vector
 ## win ..... window name, eg. "triangle" or "rectangle"
 ##           spectral_adf searches for a function called win_sw ()
 ## b ....... bandwidth
-## 
+##
 ## If win is omitted, the triangle window is used as default.
 ## If b is omitted, 1 / sqrt (length (X)) is used as default.
-  
+
 ## Author:  FL <Friedrich.Leisch@ci.tuwien.ac.at>
 ## Description:  Spectral density estimation
-  
+
 function retval = spectral_xdf (X, win, b)
-  
+
   xr = length (X);
-  
+
   if (columns (X) > 1)
     X = X';
   endif
-  
+
   if (nargin < 3)
     b = 1 / ceil (sqrt (xr));
   endif
-  
+
   if (nargin == 1)
     w = triangle_sw (xr, b);
   else
     win = [win, "_sw"];
     w = feval (win, xr, b);
   endif
-  
+
   X = X - sum (X) / xr;
 
   retval = (abs (fft (X)) / xr).^2;
   retval = real (ifft (fft(retval) .* fft(w)));
-  
+
   retval = [(zeros (xr, 1)), retval];
   retval(:, 1) = (0 : xr-1)' / xr;
-  
+
 endfunction
-    
-
-  
 
 
 
 
 
+
+
+
diff --git a/scripts/signal/spencer.m b/scripts/signal/spencer.m
--- a/scripts/signal/spencer.m
+++ b/scripts/signal/spencer.m
@@ -1,55 +1,55 @@
 ## Copyright (C) 1995, 1996, 1997  Friedrich Leisch
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  spencer (X)
 ##
 ## returns Spencer's 15 point moving average of every single column of X
- 
+
 ## Author:  FL <Friedrich.Leisch@ci.tuwien.ac.at>
 ## Description:  Apply Spencer's 15-point MA filter
 
 function retval = spencer (X)
-  
+
   if (nargin != 1)
     usage ("spencer (X)");
   endif
 
   [xr, xc] = size(X);
-  
+
   n = xr;
   c = xc;
-  
+
   if (is_vector(X))
    n = length(X);
    c = 1;
    X = reshape(X, n, 1);
   endif
-   
+
   W = [-3, -6, -5, 3, 21, 46, 67, 74, 67, 46, 21, 3, -5, -6, -3] / 320;
 
   retval = fftfilt (W, X);
   retval = [zeros(7,c); retval(15:n,:); zeros(7,c);];
-  
+
   retval = reshape(retval, xr, xc);
-  
+
 endfunction
 
 
 
 
 
 
 
diff --git a/scripts/signal/stft.m b/scripts/signal/stft.m
--- a/scripts/signal/stft.m
+++ b/scripts/signal/stft.m
@@ -1,20 +1,20 @@
 ## Copyright (C) 1995, 1996, 1997  Andreas Weingessel
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  [Y, c] = stft (X [, win_size [, inc [, num_coef [, w_type]]]])
 ##
 ## Computes the short-term Fourier transform of the vector X with
 ## "num_coef" coefficients by applying a window of "win_size" data
@@ -33,73 +33,73 @@
 ## [Y, c] = stft (X [, ...]) returns the entire STFT-matrix Y and a
 ## vector c = [win_size, inc, w_type] which is needed by the synthesis
 ## function.
 
 ## Author:  AW <Andreas.Weingessel@ci.tuwien.ac.at>
 ## Description:  Short-term Fourier transform
 
 function [Y, c] = stft(X, win, inc, coef, w_type)
-  
+
   ## default values of unspecified arguments
   if (nargin < 5)
     w_type = 1;
     if (nargin < 4)
       coef = 64;
       if (nargin < 3)
-	inc = 24;
-	if (nargin < 2)
-	  win = 80;
-	endif
+        inc = 24;
+        if (nargin < 2)
+          win = 80;
+        endif
       endif
     endif
-  elseif (nargin == 5)  
+  elseif (nargin == 5)
     if (isstr (w_type))
       if (strcmp (w_type, "hanning"))
-	w_type = 1;
+        w_type = 1;
       elseif (strcmp (w_type, "hamming"))
-	w_type = 2;
+        w_type = 2;
       elseif (strcmp (w_type, "rectangle"))
-	w_type = 3;
+        w_type = 3;
       else
-	error (["stft:  unknown window type `", w_type, "'"])
+        error (["stft:  unknown window type `", w_type, "'"])
       endif
     endif
   else
     usage ("[Y [, c]] = ", ...
-	   "stft(X [, win_size [, inc [, num_coef [, w_type]]]])");
+           "stft(X [, win_size [, inc [, num_coef [, w_type]]]])");
   endif
 
   ## check whether X is a vector
   [nr, nc] = size (X);
   if (nc != 1)
     if (nr == 1)
-      X = X'; 
+      X = X';
       nr = nc;
     else
       error ("stft:  X must be a vector");
     endif
   endif
 
   num_coef = 2 * coef;
   if (win > num_coef)
     win = num_coef;
     printf ("stft:  window size adjusted to %f\n", win);
   endif
   num_win = fix ((nr - win) / inc);
 
   ## compute the window coefficients
-  if (w_type == 3)		# rectangular window 
+  if (w_type == 3)              # rectangular window
     WIN_COEF = ones (win, 1);
-  elseif (w_type == 2)		# Hamming window
+  elseif (w_type == 2)          # Hamming window
     WIN_COEF = hamming (win);
-  else				# Hanning window
+  else                          # Hanning window
     WIN_COEF = hanning (win);
   endif
-  
+
   ## create a matrix Z whose columns contain the windowed time-slices
   Z = zeros (num_coef, num_win + 1);
   start = 1;
   for i = 0:num_win
     Z(1:win, i+1) = X(start:start+win-1) .* WIN_COEF;
     start = start + inc;
   endfor
 
diff --git a/scripts/signal/synthesis.m b/scripts/signal/synthesis.m
--- a/scripts/signal/synthesis.m
+++ b/scripts/signal/synthesis.m
@@ -1,65 +1,65 @@
 ## Copyright (C) 1995, 1996, 1997  Andreas Weingessel
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  X = synthesis (Y, c)
 ##
 ## recovers a signal X from its short-time Fourier transform Y. c =
 ## [win_size, increment, window_type].
 ##
 ## Y and c can be derived by [Y, c] = stft (X [, ...]).
-  
+
 ## Author:  AW <Andreas.Weingessel@ci.tuwien.ac.at>
 ## Description:  Recover a signal from its short-term Fourier transform
 
 function X = synthesis (Y, c)
-  
+
   if (nargin != 2)
     usage ("X = synthesis (Y, c)");
   endif
-  
+
   [nr, nc] = size (c);
   if (nr * nc != 3)
     error ("synthesis:  c must contain exactly 3 elements");
   endif
-  
+
   ## not necessary, enables better reading
-  win = c(1);      
+  win = c(1);
   inc = c(2);
   w_type = c(3);
-  
+
   if (w_type == 1)
     H = hanning (win);
   elseif (w_type == 2)
     H = hamming (win);
   elseif (w_type == 3)
     H = ones (win, 1);
   else
     error ("synthesis:  window_type must be 1, 2, or 3");
   endif
-    
+
   Z = real (ifft (Y));
   st = fix ((win-inc) / 2);
   Z = Z(st:st+inc-1, :);
   H = H(st:st+inc-1);
 
   nc = columns(Z);
   for i = 1:nc
     Z(:, i) = Z(:, i) ./ H;
   endfor
-  
+
   X = reshape(Z, inc * nc, 1);
-  
+
 endfunction
diff --git a/scripts/signal/triangle_lw.m b/scripts/signal/triangle_lw.m
--- a/scripts/signal/triangle_lw.m
+++ b/scripts/signal/triangle_lw.m
@@ -1,31 +1,31 @@
 ## Copyright (C) 1995, 1996, 1997  Friedrich Leisch
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  retval = triangle_lw (n, b)
 ##
 ## Triangular lag window. Subfunction used for spectral density
 ## estimation.
-  
+
 ## Author:  FL <Friedrich.Leisch@ci.tuwien.ac.at>
 ## Description:  Triangular lag window
-  
+
 function retval = triangle_lw (n, b)
-  
+
   retval = 1 - (0 : n-1)' * b;
   retval = max ([retval'; (zeros (1, n))])';
 
 endfunction
 
diff --git a/scripts/signal/triangle_sw.m b/scripts/signal/triangle_sw.m
--- a/scripts/signal/triangle_sw.m
+++ b/scripts/signal/triangle_sw.m
@@ -1,40 +1,40 @@
 ## Copyright (C) 1995, 1996, 1997  Friedrich Leisch
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  retval = triangle_sw (n, b)
 ##
 ## Triangular spectral window.  Subfunction used for spectral density
 ## estimation.
-  
+
 ## Author:  FL <Friedrich.Leisch@ci.tuwien.ac.at>
 ## Description:  Triangular spectral window
 
 function retval = triangle_sw (n, b)
-  
+
   retval = zeros(n,1);
   retval(1) = 1 / b;
 
   l = (2:n)' - 1;
   l = 2 * pi * l / n;
-  
+
   retval(2:n) = b * (sin (l / (2*b)) ./ sin (l / 2) ).^2;
 
 endfunction
 
 
 
 
 
diff --git a/scripts/signal/yulewalker.m b/scripts/signal/yulewalker.m
--- a/scripts/signal/yulewalker.m
+++ b/scripts/signal/yulewalker.m
@@ -1,52 +1,52 @@
 ## Copyright (C) 1995, 1996, 1997  Friedrich Leisch
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  [a, v] = yulewalker (c)
-## 
+##
 ## fits an AR (p)-model with Yule-Walker estimates.
 ## c = [gamma_0, ..., gamma_p] autocovariances
 ## a .... AR coefficients
 ## v .... variance of white noise
-  
+
 ## Author:  FL <Friedrich.Leisch@ci.tuwien.ac.at>
 ## Description:  Fit AR model by Yule-Walker method
-  
+
 function [a, v] = yulewalker (c)
-  
+
   p = length (c) - 1;
-  
+
   if (columns (c) > 1)
     c = c';
   endif
-  
+
   cp = c(2 : p+1);
   CP = zeros(p, p);
-  
+
   for i = 1:p
     for j = 1:p
       CP (i, j) = c (abs (i-j) + 1);
     endfor
   endfor
-  
+
   a = inv (CP) * cp;
   v = c(1) - a' * cp;
-  
+
 endfunction
-    
-
-  
 
 
+
+
+
diff --git a/scripts/specfun/bessel.m b/scripts/specfun/bessel.m
--- a/scripts/specfun/bessel.m
+++ b/scripts/specfun/bessel.m
@@ -18,38 +18,38 @@
 ## 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Mapping Function} {} besseli (@var{alpha}, @var{x})
 ## @deftypefnx {Mapping Function} {} besselj (@var{alpha}, @var{x})
 ## @deftypefnx {Mapping Function} {} besselk (@var{alpha}, @var{x})
 ## @deftypefnx {Mapping Function} {} bessely (@var{alpha}, @var{x})
 ## Compute Bessel functions of the following types:
-## 
+##
 ## @table @code
 ## @item besselj
 ## Bessel functions of the first kind.
-## 
+##
 ## @item bessely
 ## Bessel functions of the second kind.
-## 
+##
 ## @item besseli
 ## Modified Bessel functions of the first kind.
-## 
+##
 ## @item besselk
 ## Modified Bessel functions of the second kind.
 ## @end table
-## 
+##
 ## The second argument, @var{x}, must be a real matrix, vector, or scalar.
-## 
+##
 ## The first argument, @var{alpha}, must be greater than or equal to zero.
 ## If @var{alpha} is a range, it must have an increment equal to one.
-## 
+##
 ## If @var{alpha} is a scalar, the result is the same size as @var{x}.
-## 
+##
 ## If @var{alpha} is a range, @var{x} must be a vector or scalar, and the
 ## result is a matrix with @code{length(@var{x})} rows and
 ## @code{length(@var{alpha})} columns.
 ## @end deftypefn
 
 function bessel ()
   error ("bessel: you must use besselj, bessely, besseli, or besselk");
 endfunction
diff --git a/scripts/specfun/beta.m b/scripts/specfun/beta.m
--- a/scripts/specfun/beta.m
+++ b/scripts/specfun/beta.m
@@ -23,17 +23,17 @@
 ## @iftex
 ## @tex
 ## $$
 ##  B (a, b) = {\Gamma (a) \Gamma (b) \over \Gamma (a + b)}.
 ## $$
 ## @end tex
 ## @end iftex
 ## @ifinfo
-## 
+##
 ## @example
 ## beta (a, b) = gamma (a) * gamma (b) / gamma (a + b).
 ## @end example
 ## @end ifinfo
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Created: 13 June 1993
diff --git a/scripts/specfun/betai.m b/scripts/specfun/betai.m
--- a/scripts/specfun/betai.m
+++ b/scripts/specfun/betai.m
@@ -23,26 +23,26 @@
 ## @iftex
 ## @tex
 ## $$
 ##  \beta (a, b, x) = B (a, b)^{-1} \int_0^x t^{(a-z)} (1-t)^{(b-1)} dt.
 ## $$
 ## @end tex
 ## @end iftex
 ## @ifinfo
-## 
+##
 ## @smallexample
 ##                                     x
 ##                                    /
 ## betai (a, b, x) = beta (a, b)^(-1) | t^(a-1) (1-t)^(b-1) dt.
 ##                                    /
 ##                                 t=0
 ## @end smallexample
 ## @end ifinfo
-## 
+##
 ## If x has more than one component, both @var{a} and @var{b} must be
 ## scalars.  If @var{x} is a scalar, @var{a} and @var{b} must be of
 ## compatible dimensions.
 ## @end deftypefn
 
 ## Author: jwe
 ## Created: 30 Jan 1998
 
diff --git a/scripts/specfun/erfinv.m b/scripts/specfun/erfinv.m
--- a/scripts/specfun/erfinv.m
+++ b/scripts/specfun/erfinv.m
@@ -1,46 +1,46 @@
 ## Copyright (C) 1995, 1996  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Mapping Function} {} erfinv (@var{z})
 ## Computes the inverse of the error function,
 ## @end deftypefn
 ## @seealso{erf and erfc}
 
 ## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Created: 27 September 1994
 ## Adapted-By: jwe
 
 function [y, iterations] = erfinv (x)
-  
+
   if (nargin != 1)
     usage ("erfinv (x)");
   endif
 
   maxit = 100;
   tol = eps;
 
   iterations = 0;
 
-  [m, n] = size (x);  
+  [m, n] = size (x);
   x = reshape (x, m * n, 1);
   y = zeros (m * n, 1);
 
   i = find ((x < -1) | (x > 1));
   if any (i)
     y(i) = NaN * ones (length (i), 1);
   endif
 
@@ -54,18 +54,18 @@ function [y, iterations] = erfinv (x)
   if any (i)
     s = sqrt (pi) / 2;
     z_old = ones (length (i), 1);
     z_new = sqrt (-log (1 - abs (x(i)))) .* sign (x(i));
     while (any (abs (erf (z_old) - x(i)) > tol * abs (x(i))))
       z_old = z_new;
       z_new = z_old - (erf (z_old) - x(i)) .* exp (z_old.^2) * s;
       if (++iterations > maxit)
-	warning ("erfinv: iteration limit exceeded");
-	break;
+        warning ("erfinv: iteration limit exceeded");
+        break;
       endif
     endwhile
     y(i) = z_new;
   endif
-  
+
   y = reshape (y, m, n);
-    
+
 endfunction
diff --git a/scripts/specfun/gammai.m b/scripts/specfun/gammai.m
--- a/scripts/specfun/gammai.m
+++ b/scripts/specfun/gammai.m
@@ -23,29 +23,29 @@
 ## @iftex
 ## @tex
 ## $$
 ##  \gamma (a, x) = {\displaystyle\int_0^x e^{-t} t^{a-1} dt \over \Gamma (a)}
 ## $$
 ## @end tex
 ## @end iftex
 ## @ifinfo
-## 
+##
 ## @smallexample
 ##                               x
 ##                     1        /
 ## gammai (a, x) = ---------    | exp (-t) t^(a-1) dt
 ##                 gamma (a)    /
 ##                           t=0
 ## @end smallexample
 ## @end ifinfo
-## 
+##
 ## If @var{a} is scalar, then @code{gammai (@var{a}, @var{x})} is returned
 ## for each element of @var{x} and vice versa.
-## 
+##
 ## If neither @var{a} nor @var{x} is scalar, the sizes of @var{a} and
 ## @var{x} must agree, and @var{gammai} is applied element-by-element.
 ## @end deftypefn
 ## @seealso{gamma and lgamma}
 
 ## Author: jwe
 ## Created: 30 Jan 1998
 
diff --git a/scripts/specfun/log2.m b/scripts/specfun/log2.m
--- a/scripts/specfun/log2.m
+++ b/scripts/specfun/log2.m
@@ -1,20 +1,20 @@
 ## Copyright (C) 1995, 1996  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Mapping Function} {@var{y} =} log2 (@var{x})
 ## @deftypefnx {Mapping Function} {[@var{f}, @var{e}]} log2 (@var{x})
 ## Compute the base-2 logarithm of @var{x}.  With two outputs, returns
@@ -40,17 +40,17 @@ function [f, e] = log2 (x)
     usage ("y = log2 (x) or [f, e] = log2 (x)");
   endif
 
   if (nargout < 2)
     f = log (x) / log (2);
   elseif (nargout == 2)
     ## Only deal with the real parts ...
     x = real (x);
-    ## Since log (0) gives problems, 0 entries are replaced by 1.  
+    ## Since log (0) gives problems, 0 entries are replaced by 1.
     ## This is corrected later by multiplication with the sign.
     f = abs (x) + (x == 0);
     e = (floor (log (f) / log (2)) + 1) .* (x != 0);
     f = sign (x) .* f ./ (2 .^ e);
   else
     error ("log2 takes at most 2 output arguments");
   endif
 
diff --git a/scripts/specfun/pow2.m b/scripts/specfun/pow2.m
--- a/scripts/specfun/pow2.m
+++ b/scripts/specfun/pow2.m
@@ -1,20 +1,20 @@
 ## Copyright (C) 1995, 1996  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Mapping Function} {} pow2 (@var{x})
 ## @deftypefnx {Mapping Function} {} pow2 (@var{f}, @var{e})
 ## With one argument, computes
@@ -38,17 +38,17 @@
 ## @end deftypefn
 ## @seealso{nextpow2}
 
 ## Author: AW <Andreas.Weingessel@ci.tuwien.ac.at>
 ## Created: 17 October 1994
 ## Adapted-By: jwe
 
 function y = pow2 (f, e)
-  
+
   if (nargin == 1)
     y = 2 .^ f;
   elseif (nargin == 2)
     y = f .* (2 .^ e);
   else
     usage ("y = pow2 (f [, e])");
   endif
 
diff --git a/scripts/special-matrix/hankel.m b/scripts/special-matrix/hankel.m
--- a/scripts/special-matrix/hankel.m
+++ b/scripts/special-matrix/hankel.m
@@ -19,28 +19,28 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} hankel (@var{c}, @var{r})
 ## Return the Hankel matrix constructed given the first column @var{c}, and
 ## (optionally) the last row @var{r}.  If the last element of @var{c} is
 ## not the same as the first element of @var{r}, the last element of
 ## @var{c} is used.  If the second argument is omitted, the last row is
 ## taken to be the same as the first column.
-## 
+##
 ## A Hankel matrix formed from an m-vector @var{c}, and an n-vector
 ## @var{r}, has the elements
 ## @iftex
 ## @tex
 ## $$
 ## H (i, j) = \cases{c_{i+j-1},&$i+j-1\le m$;\cr r_{i+j-m},&otherwise.\cr}
 ## $$
 ## @end tex
 ## @end iftex
 ## @ifinfo
-## 
+##
 ## @example
 ## @group
 ## H (i, j) = c (i+j-1),  i+j-1 <= m;
 ## H (i, j) = r (i+j-m),  otherwise
 ## @end group
 ## @end example
 ## @end ifinfo
 ## @end deftypefn
diff --git a/scripts/special-matrix/hilb.m b/scripts/special-matrix/hilb.m
--- a/scripts/special-matrix/hilb.m
+++ b/scripts/special-matrix/hilb.m
@@ -32,17 +32,17 @@
 ## @iftex
 ## @tex
 ## $$
 ## H (i, j) = {1 \over (i + j - 1)}
 ## $$
 ## @end tex
 ## @end iftex
 ## @ifinfo
-## 
+##
 ## @example
 ## H (i, j) = 1 / (i + j - 1)
 ## @end example
 ## @end ifinfo
 ## @end deftypefn
 ## @seealso{hankel, vander, sylvester_matrix, invhilb, and toeplitz}
 
 ## Author: jwe
diff --git a/scripts/special-matrix/toeplitz.m b/scripts/special-matrix/toeplitz.m
--- a/scripts/special-matrix/toeplitz.m
+++ b/scripts/special-matrix/toeplitz.m
@@ -19,40 +19,40 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} toeplitz (@var{c}, @var{r})
 ## Return the Toeplitz matrix constructed given the first column @var{c},
 ## and (optionally) the first row @var{r}.  If the first element of @var{c}
 ## is not the same as the first element of @var{r}, the first element of
 ## @var{c} is used.  If the second argument is omitted, the first row is
 ## taken to be the same as the first column.
-## 
+##
 ## A square Toeplitz matrix has the form
 ## @iftex
 ## @tex
 ## $$
 ## \left[\matrix{c_0    & r_1     & r_2      & \ldots & r_n\cr
 ##               c_1    & c_0     & r_1      &        & c_{n-1}\cr
 ##               c_2    & c_1     & c_0      &        & c_{n-2}\cr
 ##               \vdots &         &          &        & \vdots\cr
 ##               c_n    & c_{n-1} & c_{n-2} & \ldots & c_0}\right].
 ## $$
 ## @end tex
 ## @end iftex
 ## @ifinfo
-## 
+##
 ## @example
 ## @group
 ## c(0)  r(1)   r(2)  ...  r(n)
 ## c(1)  c(0)   r(1)      r(n-1)
 ## c(2)  c(1)   c(0)      r(n-2)
 ##  .                       .
 ##  .                       .
 ##  .                       .
-## 
+##
 ## c(n) c(n-1) c(n-2) ...  c(0)
 ## @end group
 ## @end example
 ## @end ifinfo
 ## @end deftypefn
 ## @seealso{hankel, vander, sylvester_matrix, hilb, and invhib}
 
 ## Author: jwe
diff --git a/scripts/special-matrix/vander.m b/scripts/special-matrix/vander.m
--- a/scripts/special-matrix/vander.m
+++ b/scripts/special-matrix/vander.m
@@ -15,38 +15,38 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} vander (@var{c})
 ## Return the Vandermonde matrix whose next to last column is @var{c}.
-## 
+##
 ## A Vandermonde matrix has the form
 ## @iftex
 ## @tex
 ## $$
 ## \left[\matrix{c_0^n  & \ldots & c_0^2  & c_0    & 1\cr
 ##               c_1^n  & \ldots & c_1^2  & c_1    & 1\cr
 ##               \vdots &        & \vdots & \vdots & \vdots\cr
 ##               c_n^n  & \ldots & c_n^2  & c_n    & 1}\right].
 ## $$
 ## @end tex
 ## @end iftex
 ## @ifinfo
-## 
+##
 ## @example
 ## @group
 ## c(0)^n ... c(0)^2  c(0)  1
 ## c(1)^n ... c(1)^2  c(1)  1
 ##  .           .      .    .
 ##  .           .      .    .
 ##  .           .      .    .
-##                  
+##
 ## c(n)^n ... c(n)^2  c(n)  1
 ## @end group
 ## @end example
 ## @end ifinfo
 ## @end deftypefn
 ## @seealso{hankel, sylvester_matrix, hilb, invhilb, and toeplitz}
 
 ## Author: jwe
diff --git a/scripts/statistics/base/center.m b/scripts/statistics/base/center.m
--- a/scripts/statistics/base/center.m
+++ b/scripts/statistics/base/center.m
@@ -1,34 +1,34 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  center (x)
 ##
 ## If x is a vector, subtract its mean.
 ## If x is a matrix, do the above for each column.
 
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  Center by subtracting means
-  
+
 function retval = center (x)
-  
+
   if (nargin != 1)
     usage ("center (x)");
   endif
 
   if is_vector (x)
     retval = x - mean(x);
   elseif is_matrix (x)
     retval = x - ones (rows (x), 1) * mean(x);
diff --git a/scripts/statistics/base/cloglog.m b/scripts/statistics/base/cloglog.m
--- a/scripts/statistics/base/cloglog.m
+++ b/scripts/statistics/base/cloglog.m
@@ -1,31 +1,31 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## Returns cloglog (x) = - log (- log (x)), the complementary log-log
 ## function.
-  
+
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  Complementary log-log function
-  
+
 function y = cloglog (x)
-  
+
   if (nargin != 1)
     usage ("cloglog (x)");
   endif
-  
+
   y = - log (- log (x));
-  
+
 endfunction
\ No newline at end of file
diff --git a/scripts/statistics/base/cor.m b/scripts/statistics/base/cor.m
--- a/scripts/statistics/base/cor.m
+++ b/scripts/statistics/base/cor.m
@@ -1,20 +1,20 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  cor (x [, y])
 ##
 ## The (i,j)-th entry of cor (x, y) is the correlation between the i-th
 ## variable in x and the j-th variable in y.
diff --git a/scripts/statistics/base/cov.m b/scripts/statistics/base/cov.m
--- a/scripts/statistics/base/cov.m
+++ b/scripts/statistics/base/cov.m
@@ -1,20 +1,20 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} cov (@var{x}, @var{y})
 ## If each row of @var{x} and @var{y} is an observation and each column is
 ## a variable, the (@var{i},@var{j})-th entry of
@@ -37,17 +37,17 @@ function c = cov (x, y)
   endif
   n = rows (x);
 
   if (nargin == 2)
     if (rows (y) == 1)
       y = y';
     endif
     if (rows (y) != n)
-      error ("cov: x and y must have the same number of observations."); 
+      error ("cov: x and y must have the same number of observations.");
     endif
     x = x - ones (n, 1) * sum (x) / n;
     y = y - ones (n, 1) * sum (y) / n;
     c = conj (x' * y / (n - 1));
   elseif (nargin == 1)
     x = x - ones (n, 1) * sum (x) / n;
     c = conj (x' * x / (n - 1));
   endif
diff --git a/scripts/statistics/base/cut.m b/scripts/statistics/base/cut.m
--- a/scripts/statistics/base/cut.m
+++ b/scripts/statistics/base/cut.m
@@ -1,20 +1,20 @@
 ## Copyright (C) 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  cut (X, BREAKS)
 ##
 ## Create categorical data out of numerical or continuous data by
 ## cutting into intervals.
@@ -26,17 +26,17 @@
 ## Returns a vector of the same size as X telling which group each point
 ## in X belongs to.  Groups are labelled from 1 to the number of groups;
 ## points outside the range of BREAKS are labelled by NaN.
 
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  Cut data into intervals
 
 function group = cut (X, BREAKS)
-  
+
   if (nargin != 2)
     usage ("cut (X, BREAKS)");
   endif
 
   if !is_vector (X)
     error ("cut:  X must be a vector");
   endif
   if is_scalar (BREAKS)
@@ -48,12 +48,12 @@ function group = cut (X, BREAKS)
     error ("cut:  BREAKS must be a scalar or vector");
   endif
 
   group = NaN * ones (size (X));
   m = length (BREAKS);
   if any (k = find ((X >= min (BREAKS)) & (X <= max (BREAKS))))
     n = length (k);
     group(k) = sum ((ones (m, 1) * reshape (X(k), 1, n))
-		    > (reshape (BREAKS, m, 1) * ones (1, n)));
+                    > (reshape (BREAKS, m, 1) * ones (1, n)));
   endif
 
 endfunction
diff --git a/scripts/statistics/base/gls.m b/scripts/statistics/base/gls.m
--- a/scripts/statistics/base/gls.m
+++ b/scripts/statistics/base/gls.m
@@ -27,42 +27,42 @@
 ## @end tex
 ## @end iftex
 ## @ifinfo
 ## @code{@var{y} = @var{x} * @var{b} + @var{e}} with @code{mean (@var{e}) =
 ## 0} and @code{cov (vec (@var{e})) = (@var{s}^2)*@var{o}},
 ## @end ifinfo
 ##  where
 ## @iftex
-## @tex 
+## @tex
 ## $y$ is a $t \times p$ matrix, $x$ is a $t \times k$ matrix, $b$ is a $k
 ## \times p$ matrix, $e$ is a $t \times p$ matrix, and $o$ is a $tp \times
 ## tp$ matrix.
 ## @end tex
 ## @end iftex
 ## @ifinfo
 ## @var{Y} is a @var{T} by @var{p} matrix, @var{X} is a @var{T} by @var{k}
 ## matrix, @var{B} is a @var{k} by @var{p} matrix, @var{E} is a @var{T} by
 ## @var{p} matrix, and @var{O} is a @var{T}@var{p} by @var{T}@var{p}
 ## matrix.
 ## @end ifinfo
-## 
+##
 ## @noindent
 ## Each row of Y and X is an observation and each column a variable.
-## 
+##
 ## The return values @var{beta}, @var{v}, and @var{r} are defined as
 ## follows.
-## 
+##
 ## @table @var
 ## @item beta
 ## The GLS estimator for @var{b}.
-## 
+##
 ## @item v
 ## The GLS estimator for @code{@var{s}^2}.
-## 
+##
 ## @item r
 ## The matrix of GLS residuals, @code{@var{r} = @var{y} - @var{x} *
 ## @var{beta}}.
 ## @end table
 ## @end deftypefn
 
 ## Author: Teresa Twaroch <twaroch@ci.tuwien.ac.at>
 ## Created: May 1993
diff --git a/scripts/statistics/base/iqr.m b/scripts/statistics/base/iqr.m
--- a/scripts/statistics/base/iqr.m
+++ b/scripts/statistics/base/iqr.m
@@ -1,35 +1,35 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  iqr (x)
 ##
 ## If x is a vector, return the interquartile range, i.e., the
 ## difference between the upper and lower quartile, of the input data.
 ##
 ## If x is a matrix, do the above for each column of x.
-  
+
 ## Author KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  Interquartile range
 
 function y = iqr (x)
-  
+
   if (nargin != 1)
     usage ("iqr (x)");
   endif
 
   y = empirical_inv (3/4, x) - empirical_inv (1/4, x);
-  
+
 endfunction
diff --git a/scripts/statistics/base/kendall.m b/scripts/statistics/base/kendall.m
--- a/scripts/statistics/base/kendall.m
+++ b/scripts/statistics/base/kendall.m
@@ -1,20 +1,20 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  kendall (x [, y])
 ##
 ## Computes Kendall's tau for each of the variables specified by the
 ## input arguments.
@@ -33,39 +33,39 @@
 ## If x and y are drawn from independent distributions, Kendall's tau is
 ## asymptotically normal with mean 0 and variance (2 * (2n+5)) / (9 * n
 ## * (n-1)).
 
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  Kendall's rank correlation tau
 
 function tau = kendall (x, y)
-  
+
   if ((nargin < 1) || (nargin > 2))
     usage ("kendall (x [, y])");
   endif
 
   if (rows (x) == 1)
     x = x';
   endif
   [n, c] = size (x);
 
   if (nargin == 2)
     if (rows (y) == 1)
       y = y';
     endif
     if (rows (y) != n)
       error (["kendall:  ", ...
-	      "x and y must have the same number of observations"]);
+              "x and y must have the same number of observations"]);
     else
       x = [x, y];
     endif
   endif
-  
+
   r   = ranks (x);
   m   = sign (kron (r, ones (n, 1)) - kron (ones (n, 1), r));
   tau = cor (m);
-  
+
   if (nargin == 2)
     tau = tau (1 : c, (c + 1) : columns (x));
   endif
-  
+
 endfunction
\ No newline at end of file
diff --git a/scripts/statistics/base/kurtosis.m b/scripts/statistics/base/kurtosis.m
--- a/scripts/statistics/base/kurtosis.m
+++ b/scripts/statistics/base/kurtosis.m
@@ -23,22 +23,22 @@
 ## @iftex
 ## @tex
 ## $$
 ##  {\rm kurtosis} (x) = {1\over N \sigma(x)^4} \sum_{i=1}^N (x_i-\bar{x})^4 - 3
 ## $$
 ## @end tex
 ## @end iftex
 ## @ifinfo
-## 
+##
 ## @example
 ## kurtosis (x) = N^(-1) std(x)^(-4) sum ((x - mean(x)).^4) - 3
 ## @end example
 ## @end ifinfo
-## 
+##
 ## @noindent
 ## of @var{x}.  If @var{x} is a matrix, return the row vector containing
 ## the kurtosis of each column.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Created: 29 July 1994
 ## Adapted-By: jwe
diff --git a/scripts/statistics/base/logit.m b/scripts/statistics/base/logit.m
--- a/scripts/statistics/base/logit.m
+++ b/scripts/statistics/base/logit.m
@@ -1,30 +1,30 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## For each component of p, return the logit log (p / (1-p)) of p.
-  
+
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  Logit transformation
 
 function y = logit (p)
-  
+
   if (nargin == 1)
     y = logistic_inv (p);
   else
     usage ("logit (p)");
   endif
 
 endfunction
\ No newline at end of file
diff --git a/scripts/statistics/base/mean.m b/scripts/statistics/base/mean.m
--- a/scripts/statistics/base/mean.m
+++ b/scripts/statistics/base/mean.m
@@ -1,34 +1,34 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} mean (@var{x}, @var{opt})
 ## If @var{x} is a vector, compute the mean of the elements of @var{x}
 ## @iftex
 ## @tex
 ## $$ {\rm mean}(x) = \bar{x} = {1\over N} \sum_{i=1}^N x_i $$
 ## @end tex
 ## @end iftex
 ## @ifinfo
-## 
+##
 ## @example
 ## mean (x) = SUM_i x(i) / N
 ## @end example
 ## @end ifinfo
 ## If @var{x} is a matrix, compute the mean for each column and return them
 ## in a row vector.
 ##
 ## With the optional argument @var{opt}, the kind of mean computed can be
@@ -40,40 +40,40 @@
 ##
 ## @item "g"
 ## Computer the geometric mean.
 ##
 ## @item "h"
 ## Compute the harmonic mean.
 ## @end table
 ## @end deftypefn
-  
+
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  Compute arithmetic, geometric, and harmonic mean
 
 function y = mean (x, opt)
 
   if ((nargin < 1) || (nargin > 2))
     usage ("mean (x [, opt])");
   endif
 
   if isempty (x)
     error ("mean:  x must not be empty");
   endif
-  
+
   if (rows (x) == 1)
     x = x.';
   endif
-  
+
   if (nargin == 1)
     opt = "a";
   endif
 
   [r, c] = size (x);
-  
+
   if (strcmp (opt, "a"))
     y = sum (x) / r;
   elseif (strcmp (opt, "g"))
     y = NaN * ones (1, c);
     i = find (all (x > 0));
     if any (i)
       y(i) = exp (sum (log (x(:, i))) / r);
     endif
@@ -81,10 +81,10 @@ function y = mean (x, opt)
     y = NaN * ones (1, c);
     i = find (all (x != 0));
     if any (i)
       y(i) = r ./ sum (1 ./ x(:, i));
     endif
   else
     error (sprintf ("mean:  option `%s' not recognized", opt));
   endif
-    
+
 endfunction
diff --git a/scripts/statistics/base/meansq.m b/scripts/statistics/base/meansq.m
--- a/scripts/statistics/base/meansq.m
+++ b/scripts/statistics/base/meansq.m
@@ -1,34 +1,34 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:   meansq (x)
 ##
 ## For vector arguments, return the mean square of the values.
 ## For matrix arguments, return a row vector contaning the mean square
 ## of each column.
-  
+
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  Compute mean square
 
 function y = meansq (x)
-  
+
   if (nargin != 1)
     usage ("meansq (x)");
   endif
-  
+
   y = mean (x.^2);
-  
+
 endfunction
diff --git a/scripts/statistics/base/median.m b/scripts/statistics/base/median.m
--- a/scripts/statistics/base/median.m
+++ b/scripts/statistics/base/median.m
@@ -26,21 +26,21 @@
 ## $$
 ## {\rm median} (x) =
 ##   \cases{x(\lceil N/2\rceil), & $N$ odd;\cr
 ##           (x(N/2)+x(N/2+1))/2, & $N$ even.}
 ## $$
 ## @end tex
 ## @end iftex
 ## @ifinfo
-## 
+##
 ## @example
 ## @group
 ##             x(ceil(N/2)),             N odd
-## median(x) = 
+## median(x) =
 ##             (x(N/2) + x((N/2)+1))/2,  N even
 ## @end group
 ## @end example
 ## @end ifinfo
 ## If @var{x} is a matrix, compute the median value for each
 ## column and return them in a row vector.
 ## @end deftypefn
 ## @seealso{std and mean}
diff --git a/scripts/statistics/base/moment.m b/scripts/statistics/base/moment.m
--- a/scripts/statistics/base/moment.m
+++ b/scripts/statistics/base/moment.m
@@ -1,61 +1,61 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  moment (x, p [, opt])
 ##
 ## Computes the p-th moment of x if it is a vector;  if x is a matrix,
 ## return the row vector of the p-th moment of each column.
 ##
 ## With the optional string opt, the kind of moment to be computed can
 ## be specified.  If opt contains `c' or `a', central and/or absolute
 ## moments are returned.  I.e., `moment(x, 3, "ac")' computes the third
 ## central absolute moment of x.
 
 ## Can easily be made to work for continuous distributions (using quad)
 ## as well, but how does the general case work?
-  
+
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  Compute moments
-  
+
 function m = moment (x, p, opt)
-  
+
   if ((nargin < 2) || (nargin > 3))
     usage ("moment (x, p [, type]")
   endif
-  
+
   [nr, nc] = size (x);
   if (nr == 0 || nc == 0)
     error ("moment:  x must not be empty");
   elseif (nr == 1)
     x  = reshape (x, nc, 1);
     nr = nc;
   endif
-  
+
   if (nargin == 3)
     tmp = implicit_str_to_num_ok;
     implicit_str_to_num_ok = "true";
     if any (opt == "c")
       x = x - ones (nr, 1) * sum (x) / nr;
     endif
     if any (opt == "a")
       x = abs (x);
     endif
     implicit_str_to_num_ok = tmp;
   endif
-  
+
   m = sum(x .^ p) / nr;
-  
+
 endfunction
diff --git a/scripts/statistics/base/ols.m b/scripts/statistics/base/ols.m
--- a/scripts/statistics/base/ols.m
+++ b/scripts/statistics/base/ols.m
@@ -30,49 +30,49 @@
 ## @ifinfo
 ## @code{@var{y} = @var{x}*@var{b} + @var{e}} with
 ## @code{mean (@var{e}) = 0} and @code{cov (vec (@var{e})) = kron (@var{s},
 ## @var{I})}.
 ## @end ifinfo
 ##  where
 ## @iftex
 ## @tex
-## $y$ is a $t \times p$ matrix, $x$ is a $t \times k$ matrix, 
+## $y$ is a $t \times p$ matrix, $x$ is a $t \times k$ matrix,
 ## $b$ is a $k \times p$ matrix, and $e$ is a $t \times p$ matrix.
 ## @end tex
 ## @end iftex
 ## @ifinfo
 ## @var{y} is a @var{t} by @var{p} matrix, @var{X} is a @var{t} by @var{k}
 ## matrix, @var{B} is a @var{k} by @var{p} matrix, and @var{e} is a @var{t}
 ## by @var{p} matrix.
 ## @end ifinfo
-## 
+##
 ## Each row of @var{y} and @var{x} is an observation and each column a
 ## variable.
-## 
+##
 ## The return values @var{beta}, @var{sigma}, and @var{r} are defined as
 ## follows.
-## 
+##
 ## @table @var
 ## @item beta
 ## The OLS estimator for @var{b}, @code{@var{beta} = pinv (@var{x}) *
 ## @var{y}}, where @code{pinv (@var{x})} denotes the pseudoinverse of
 ## @var{x}.
-## 
+##
 ## @item sigma
 ## The OLS estimator for the matrix @var{s},
-## 
+##
 ## @example
 ## @group
 ## @var{sigma} = (@var{y}-@var{x}*@var{beta})'
 ##   * (@var{y}-@var{x}*@var{beta})
 ##   / (@var{t}-rank(@var{x}))
 ## @end group
 ## @end example
-## 
+##
 ## @item r
 ## The matrix of OLS residuals, @code{@var{r} = @var{y} - @var{x} *
 ## @var{beta}}.
 ## @end table
 ## @end deftypefn
 
 ## Author: Teresa Twaroch <twaroch@ci.tuwien.ac.at>
 ## Created: May 1993
diff --git a/scripts/statistics/base/ppplot.m b/scripts/statistics/base/ppplot.m
--- a/scripts/statistics/base/ppplot.m
+++ b/scripts/statistics/base/ppplot.m
@@ -1,20 +1,20 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  [p, y] = ppplot (x [, dist [, params]])
 ##
 ## Performs a PP-plot (probability plot).
 ##
@@ -30,21 +30,21 @@
 ## [2,4] ans x, use `ppplot (x, "uniform", 2, 4)'.
 ##
 ## If no output arguments are given, the data are plotted directly.
 
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  Perform a PP-plot (probability plot)
 
 function [p, y] = ppplot (x, dist, ...)
-  
+
   if (nargin < 1)
     usage ("ppplot (x [, dist [, params]])");
   endif
-  
+
   if !is_vector (x)
     error ("ppplot:  x must be a vector.");
   endif
 
   s = sort (x);
   n = length (x);
   p = ((1 : n)' - 0.5) / n;
   if (nargin == 1)
@@ -52,16 +52,16 @@ function [p, y] = ppplot (x, dist, ...)
   else
     F = sprintf ("%s_cdf", dist);
   endif;
   if (nargin <= 2)
     y = feval (F, s);
   else
     y = feval (F, s, all_va_args);
   endif
-  
+
   if (nargout == 0)
     axis ([0, 1, 0, 1]);
     set nokey;
     plot (p, y);
   endif
 
 endfunction
diff --git a/scripts/statistics/base/probit.m b/scripts/statistics/base/probit.m
--- a/scripts/statistics/base/probit.m
+++ b/scripts/statistics/base/probit.m
@@ -1,32 +1,31 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## For each component of p, return the probit (the quantile of the
 ## standard normal distribution) of p.
-  
+
 ## Written by KH <Kurt.Hornik@ci.tuwien.ac.at> on 1995/02/04
 ## Description:  Probit transformation
 
 function y = probit (p)
-  
+
   if (nargin == 1)
     y = stdnormal_inv (p);
   else
     usage ("probit (p)");
   endif
 
 endfunction
-  
\ No newline at end of file
diff --git a/scripts/statistics/base/qqplot.m b/scripts/statistics/base/qqplot.m
--- a/scripts/statistics/base/qqplot.m
+++ b/scripts/statistics/base/qqplot.m
@@ -1,20 +1,20 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  [q, s] = qqplot (x [, dist [, params]])
 ##
 ## Performs a QQ-plot (quantile plot).
 ##
@@ -32,21 +32,21 @@
 ## [2,4] and x, use `qqplot (x, "uniform", 2, 4)'.
 ##
 ## If no output arguments are given, the data are plotted directly.
 
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  Perform a QQ-plot (quantile plot)
 
 function [q, s] = qqplot (x, dist, ...)
-  
+
   if (nargin < 1)
     usage ("qqplot (x [,dist [,params]])");
   endif
-  
+
   if !(is_vector(x))
     error ("qqplot:  x must be a vector.");
   endif
 
   s = sort (x);
   n = length (x);
   t = ((1 : n)' - .5) / n;
   if (nargin == 1)
@@ -60,17 +60,17 @@ function [q, s] = qqplot (x, dist, ...)
   else
     param_string = sprintf ("%g", va_arg ());
     for k = 2 : (nargin - 2);
       param_string = sprintf ("%s, %g", param_string, va_arg ())
     endfor
     q = eval (sprintf ("%s (t, %s);", f, param_string));
     q_label = sprintf ("%s with parameter(s) %s", f, param_string);
   endif
-  
+
   if (nargout == 0)
     xlabel (q_label);
     ylabel ("sample points");
     set nokey;
     plot (q, s);
   endif
 
 endfunction
diff --git a/scripts/statistics/base/range.m b/scripts/statistics/base/range.m
--- a/scripts/statistics/base/range.m
+++ b/scripts/statistics/base/range.m
@@ -1,34 +1,34 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  range (x)
 ##
 ## If x is a vector, return the range, i.e., the difference between the
-## maximum and the minimum, of the input data.  
+## maximum and the minimum, of the input data.
 ## If x is a matrix, do the above for each column of x.
-  
+
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  Compute range
 
 function y = range (x)
-  
+
   if (nargin != 1)
     usage ("range (x)");
   endif
 
   y = max (x) - min (x);
-  
+
 endfunction
diff --git a/scripts/statistics/base/ranks.m b/scripts/statistics/base/ranks.m
--- a/scripts/statistics/base/ranks.m
+++ b/scripts/statistics/base/ranks.m
@@ -1,49 +1,49 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  ranks (x)
 ##
 ## If x is a vector, return the (column) vector of ranks of x adjusted
-## for ties.  
+## for ties.
 ## If x is a matrix, do the above for each column of x.
-  
+
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  Compute ranks
 
 ## This code is rather ugly, but is there an easy way to get the ranks
 ## adjusted for ties from sort?
-  
+
 function y = ranks (x)
 
   if (nargin != 1)
     usage ("ranks (x)");
   endif
-  
+
   y = [];
 
   [r, c] = size (x);
   if ((r == 1) && (c > 0))
     p = x' * ones (1, c);
     y = sum (p < p') + (sum (p == p') + 1) / 2;
   elseif (r > 1)
     o = ones (1, r);
     for i = 1 : c;
       p = x (:, i) * o;
       y = [y, ( sum (p < p') + (sum (p == p') + 1) / 2 )'];
     endfor
   endif
-  
+
 endfunction
diff --git a/scripts/statistics/base/run_count.m b/scripts/statistics/base/run_count.m
--- a/scripts/statistics/base/run_count.m
+++ b/scripts/statistics/base/run_count.m
@@ -1,57 +1,57 @@
 ## Copyright (C) 1995, 1996, 1997  Friedrich Leisch
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  run_count (x, n)
 ##
 ## Counts the upward runs in the columns of x of length 1, 2, ... n-1
 ## and >= n.
 
 ## Author:  FL <Friedrich.Leisch@ci.tuwien.ac.at>
 ## Description:  Count upward runs
 
 function retval = run_count (x, n)
-  
+
   [xr, xc] = size(x);
-  
+
   tmp = zeros (xr,xc);
   retval = zeros (n, xc);
-  
+
   for j = 1 : xc
     run = 1;
     count = 1;
 
     for k = 2 : xr
 
       if x(k, j) < x(k-1, j)
-	tmp(run, j) = count;
-	run = run + 1;
-	count = 0;
+        tmp(run, j) = count;
+        run = run + 1;
+        count = 0;
       endif
-    
+
       count = count + 1;
 
     endfor
 
     tmp(run, j) = count;
-  
+
   endfor
-  
+
   for k=1 : (n-1)
     retval(k, :) = sum (tmp == k);
   endfor
   retval(n, :) = sum (tmp >= n);
-  
+
 endfunction
diff --git a/scripts/statistics/base/skewness.m b/scripts/statistics/base/skewness.m
--- a/scripts/statistics/base/skewness.m
+++ b/scripts/statistics/base/skewness.m
@@ -23,22 +23,22 @@
 ## @iftex
 ## @tex
 ## $$
 ## {\rm skewness} (x) = {1\over N \sigma(x)^3} \sum_{i=1}^N (x_i-\bar{x})^3
 ## $$
 ## @end tex
 ## @end iftex
 ## @ifinfo
-## 
+##
 ## @example
 ## skewness (x) = N^(-1) std(x)^(-3) sum ((x - mean(x)).^3)
 ## @end example
 ## @end ifinfo
-## 
+##
 ## @noindent
 ## of @var{x}.  If @var{x} is a matrix, return the row vector containing
 ## the skewness of each column.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Created: 29 July 1994
 ## Adapted-By: jwe
diff --git a/scripts/statistics/base/spearman.m b/scripts/statistics/base/spearman.m
--- a/scripts/statistics/base/spearman.m
+++ b/scripts/statistics/base/spearman.m
@@ -1,20 +1,20 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  spearman (x [, y])
 ##
 ## Computes Spearman's rank correlation coefficient rho for each of the
 ## variables specified by the input arguments.
@@ -30,32 +30,32 @@
 ## If x and y are drawn from independent distributions, rho has zero
 ## mean and variance 1 / (n - 1), and is asymptotically normally
 ## distributed.
 
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  Spearman's rank correlation rho
 
 function rho = spearman (x, y)
-  
+
   if ((nargin < 1) || (nargin > 2))
     usage ("spearman (x [, y])");
   endif
 
   if (rows (x) == 1)
     x = x';
   endif
   n = rows (x);
-  
+
   if (nargin == 1)
     rho = cor (ranks (x));
   else
     if (rows (y) == 1)
       y = y';
     endif
     if (rows (y) != n)
       error (["spearman:  ", ...
-	      "x and y must have the same number of observations"]);
+              "x and y must have the same number of observations"]);
     endif
     rho = cor (ranks (x), ranks (y));
   endif
-  
+
 endfunction
diff --git a/scripts/statistics/base/statistics.m b/scripts/statistics/base/statistics.m
--- a/scripts/statistics/base/statistics.m
+++ b/scripts/statistics/base/statistics.m
@@ -1,51 +1,51 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  S = statistics (X)
 ##
 ## If X is a matrix, return a matrix S with the min, first quartile,
 ## median, third quartile, max, mean, std, skewness and kurtosis of the
 ## columns of X as its rows.
 ##
 ## If X is a vector, treat it as a column vector.
-  
+
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  Compute basic statistics
 
 function S = statistics (X)
-  
+
   if (nargin != 1)
     usage ("S = statistics (X)");
   endif
 
   if (prod (size (X)) > 1)
     if (is_vector (X))
       X = reshape (X, length (X), 1);
     endif
     for k=1:columns(X)
       S(:,k) = [(min (X(:,k)));
-		(empirical_inv ([0.25;0.5;0.75], X(:,k)));
-	 	(max (X(:,k)));
-		(mean (X(:,k)));
-		(std (X(:,k)));
-		(skewness (X(:,k)));
-		(kurtosis (X(:,k)))];
-    endfor 
+                (empirical_inv ([0.25;0.5;0.75], X(:,k)));
+                (max (X(:,k)));
+                (mean (X(:,k)));
+                (std (X(:,k)));
+                (skewness (X(:,k)));
+                (kurtosis (X(:,k)))];
+    endfor
   else
     error ("statistics:  invalid argument");
   endif
-  
+
 endfunction
diff --git a/scripts/statistics/base/std.m b/scripts/statistics/base/std.m
--- a/scripts/statistics/base/std.m
+++ b/scripts/statistics/base/std.m
@@ -24,17 +24,17 @@
 ## @iftex
 ## @tex
 ## $$
 ## {\rm std} (x) = \sigma (x) = \sqrt{{\sum_{i=1}^N (x_i - \bar{x}) \over N - 1}}
 ## $$
 ## @end tex
 ## @end iftex
 ## @ifinfo
-## 
+##
 ## @example
 ## @group
 ## std (x) = sqrt (sumsq (x - mean (x)) / (n - 1))
 ## @end group
 ## @end example
 ## @end ifinfo
 ## If @var{x} is a matrix, compute the standard deviation for
 ## each column and return them in a row vector.
diff --git a/scripts/statistics/base/studentize.m b/scripts/statistics/base/studentize.m
--- a/scripts/statistics/base/studentize.m
+++ b/scripts/statistics/base/studentize.m
@@ -1,36 +1,36 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  studentize (x)
 ##
 ## If x is a vector, subtract its mean and divide by its standard
 ## deviation.
 ##
 ## If x is a matrix, do the above for each column.
 
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  Subtract mean and divide by standard deviation
 
 function t = studentize (x)
-  
+
   if (nargin != 1)
     usage ("studentize (x)");
   endif
 
   if is_vector (x)
     if (std (x) == 0)
       t = zeros (size (x));
     else
diff --git a/scripts/statistics/base/table.m b/scripts/statistics/base/table.m
--- a/scripts/statistics/base/table.m
+++ b/scripts/statistics/base/table.m
@@ -1,54 +1,54 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  [t, l_x] = table (x)
 ##         [t, l_x, l_y] = table (x, y)
 ##
 ## Create a contingency table t from data vectors.  The l vectors are
 ## the corresponding levels.
 ##
 ## Currently, only 1- and 2-dimensional tables are supported.
-  
+
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  Cross tabulation
-  
+
 function [t, v, w] = table (x, y)
-  
+
   if (nargin == 1)
     if !(is_vector (x))
       error ("table:  x must be a vector");
     endif
     v = values (x);
     for i = 1 : length (v)
       t(i) = sum (x == v(i) | isnan (v(i)) * isnan (x));
     endfor
   elseif (nargin == 2)
     if !(is_vector (x) && is_vector (y) && (length (x) == length (y)))
       error ("table:  x and y must be vectors of the same length");
     endif
     v = values (x);
     w = values (y);
     for i = 1 : length (v)
       for j = 1 : length (w)
-	t(i,j) = sum ((x == v(i) | isnan (v(i)) * isnan (x)) &
-		      (y == w(j) | isnan (w(j)) * isnan (y)));
+        t(i,j) = sum ((x == v(i) | isnan (v(i)) * isnan (x)) &
+                      (y == w(j) | isnan (w(j)) * isnan (y)));
       endfor
     endfor
   else
     usage ("[t, l_x, ...] = table (x, ...)");
   endif
-  
+
 endfunction
\ No newline at end of file
diff --git a/scripts/statistics/base/values.m b/scripts/statistics/base/values.m
--- a/scripts/statistics/base/values.m
+++ b/scripts/statistics/base/values.m
@@ -1,44 +1,44 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  values (x)
 ##
 ## Return the different values in a column vector, arranged in ascending
 ## order.
-  
+
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  Extract unique elements
 
 function v = values (x)
-  
+
   if (nargin != 1)
     usage ("values (x)");
   endif
-  
+
   if !(is_vector (x))
     error ("values:  x must be a vector");
   endif
 
   i = any (isnan (x));
-  x = x(find(!isnan (x)));	# HACK!
+  x = x(find(!isnan (x)));      # HACK!
   n = length (x);
   x = reshape (x, n, 1);
   s = sort (x);
   v = s([1; (find (s(2:n) > s(1:n-1)) + 1)]);
   if (i)
     v = [v; NaN];
   endif
 
diff --git a/scripts/statistics/base/var.m b/scripts/statistics/base/var.m
--- a/scripts/statistics/base/var.m
+++ b/scripts/statistics/base/var.m
@@ -1,44 +1,44 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  var (x)
 ##
 ## For vector arguments, return the (real) variance of the values.
 ## For matrix arguments, return a row vector contaning the variance for
 ## each column.
-  
+
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  Compute variance
 
 function y = var(x)
-  
+
   if (nargin != 1)
     usage ("var (x)");
   endif
-  
+
   [nr, nc] = size (x);
   if (nr == 0 || nc == 0)
     error ("var:  x must not be empty");
   elseif ((nr == 1) && (nc == 1))
     y = 0;
   elseif ((nr == 1) || (nc == 1))
     n = length (x);
     y = (sumsq (x) - sum(x)^2 / n) / (n - 1);
   else
     y = (sumsq (x) - sum(x).^2 / nr) / (nr - 1);
   endif
-  
+
 endfunction
diff --git a/scripts/statistics/distributions/beta_cdf.m b/scripts/statistics/distributions/beta_cdf.m
--- a/scripts/statistics/distributions/beta_cdf.m
+++ b/scripts/statistics/distributions/beta_cdf.m
@@ -1,60 +1,60 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  beta_cdf (x, a, b)
 ##
 ## For each element of x, returns the CDF at x of the beta distribution
 ## with parameters a and b, i.e., PROB( beta(a,b) <= x).
 
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  CDF of the Beta distribution
 
 function cdf = beta_cdf (x, a, b)
-  
+
   if (nargin != 3)
     usage ("beta_cdf (a, b, x)");
   endif
 
   [retval, x, a, b] = common_size (x, a, b);
   if (retval > 0)
     error ("beta_cdf:  x, a and b must be of common size or scalar");
   endif
-  
+
   [r, c] = size (x);
   s = r * c;
   x   = reshape (x, s, 1);
   a   = reshape (a, s, 1);
   b   = reshape (b, s, 1);
   cdf = zeros (s, 1);
-  
+
   k = find (!(a > 0) | !(b > 0) | isnan (x));
   if any (k)
     cdf (k) = NaN * ones (length (k), 1);
   endif
-  
+
   k = find ((x >= 1) & (a > 0) & (b > 0));
   if any (k)
     cdf (k) = ones (length (k), 1);
   endif
-  
+
   k = find ((x > 0) & (x < 1) & (a > 0) & (b > 0));
   if any (k)
     cdf (k) = betai (a(k), b(k), x(k));
   endif
-  
+
   cdf = reshape (cdf, r, c);
-  
+
 endfunction
diff --git a/scripts/statistics/distributions/beta_inv.m b/scripts/statistics/distributions/beta_inv.m
--- a/scripts/statistics/distributions/beta_inv.m
+++ b/scripts/statistics/distributions/beta_inv.m
@@ -1,60 +1,60 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  beta_inv (x, a, b)
 ##
 ## For each component of x, compute the quantile (the inverse of the
 ## CDF) at x of the Beta distribution with parameters a and b.
-  
+
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  Quantile function of the Beta distribution
 
 function inv = beta_inv (x, a, b)
-  
+
   if (nargin != 3)
     usage ("beta_inv (x, a, b)");
   endif
-  
+
   [retval, x, a, b] = common_size (x, a, b);
   if (retval > 0)
     error ("beta_inv:  x, a and b must be of common size or scalars");
   endif
 
   [r, c] = size (x);
   s   = r * c;
   x   = reshape (x, s, 1);
   a   = reshape (a, s, 1);
   b   = reshape (b, s, 1);
   inv = zeros (s, 1);
-  
+
   k = find ((x < 0) | (x > 1) | !(a > 0) | !(b > 0) | isnan (x));
   if any (k)
     inv (k) = NaN * ones (length (k), 1);
   endif
-  
+
   k = find ((x == 1) & (a > 0) & (b > 0));
   if any (k)
     inv (k) = ones (length (k), 1);
   endif
-  
+
   k = find ((x > 0) & (x < 1) & (a > 0) & (b > 0));
   if any (k)
     a = a (k);
     b = b (k);
     x = x (k);
     y = a ./ b;
     l = find (y < eps);
     if any (l)
@@ -66,27 +66,27 @@ function inv = beta_inv (x, a, b)
     endif
 
     y_old = y;
     for i = 1 : 100
       h     = (beta_cdf (y_old, a, b) - x) ./ beta_pdf (y_old, a, b);
       y_new = y_old - h;
       ind   = find (y_new <= eps);
       if (any (ind))
-	y_new (ind) = y_old (ind) / 10;
+        y_new (ind) = y_old (ind) / 10;
       endif
       ind = find (y_new >= 1 - eps);
       if any (ind)
-	y_new (ind) = 1 - (1 - y_old (ind)) / 10;
+        y_new (ind) = 1 - (1 - y_old (ind)) / 10;
       endif
       h = y_old - y_new;
       if (max (abs (h)) < sqrt (eps))
-	break;
+        break;
       endif
       y_old = y_new;
     endfor
-    
+
     inv (k) = y_new;
   endif
 
   inv = reshape (inv, r, c);
-  
+
 endfunction
diff --git a/scripts/statistics/distributions/beta_pdf.m b/scripts/statistics/distributions/beta_pdf.m
--- a/scripts/statistics/distributions/beta_pdf.m
+++ b/scripts/statistics/distributions/beta_pdf.m
@@ -1,56 +1,56 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  beta_pdf (x, a, b)
 ##
 ## For each element of x, returns the PDF at x of the beta distribution
 ## with parameters a and b.
 
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  PDF of the Beta distribution
 
 function pdf = beta_pdf (x, a, b)
-  
+
   if (nargin != 3)
     usage ("beta_pdf (a, b, x)");
   endif
 
   [retval, x, a, b] = common_size (x, a, b);
   if (retval > 0)
     error ("beta_pdf:  x, a and b must be of common size or scalar");
   endif
 
   [r, c] = size (x);
   s = r * c;
   x   = reshape (x, s, 1);
   a   = reshape (a, s, 1);
   b   = reshape (b, s, 1);
   pdf = zeros (s, 1);
-  
+
   k = find (!(a > 0) | !(b > 0) | isnan (x));
   if any (k)
     pdf (k) = NaN * ones (length (k), 1);
   endif
 
   k = find ((x > 0) & (x < 1) & (a > 0) & (b > 0));
   if any (k)
     pdf(k) = exp ((a(k) - 1) .* log (x(k)) ...
-	+ (b(k) - 1) .* log (1 - x(k))) ./ beta (a(k), b(k));  
+        + (b(k) - 1) .* log (1 - x(k))) ./ beta (a(k), b(k));
   endif
 
   pdf = reshape (pdf, r, c);
-  
+
 endfunction
diff --git a/scripts/statistics/distributions/beta_rnd.m b/scripts/statistics/distributions/beta_rnd.m
--- a/scripts/statistics/distributions/beta_rnd.m
+++ b/scripts/statistics/distributions/beta_rnd.m
@@ -1,72 +1,72 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  beta_rnd (a, b [, r, c])
 ##
 ## beta_rnd (a, b) returns a matrix of random samples from the Beta
 ## distribution with parameters a and b.  The size of the matrix is the
 ## common size of a and b.
 ##
 ## beta_rnd (a, b, r, c) returns an r by c matrix of random samples from
 ## the Beta distribution with parameters a and b.  Both a and b must be
 ## scalar or of size r by c.
-  
+
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  Random deviates from the Beta distribution
 
 function rnd = beta_rnd (a, b, r, c)
 
   if (nargin == 4)
     if ( !(is_scalar (r) && (r > 0) && (r == round (r))) )
       error ("beta_rnd:  r must be a positive integer");
     endif
     if ( !(is_scalar (c) && (c > 0) && (c == round (c))) )
       error ("beta_rnd:  c must be a positive integer");
     endif
     [retval, a, b] = common_size (a, b, zeros (r, c));
     if (retval > 0)
       error (strcat("beta_rnd:  ",
-		    "a and b must be scalar or of size ",
-		    sprintf ("%d by %d", r, c)));
+                    "a and b must be scalar or of size ",
+                    sprintf ("%d by %d", r, c)));
     endif
   elseif (nargin == 2)
     [retval, a, b] = common_size (a, b);
     if (retval > 0)
       error ("beta_rnd:  a and b must be of common size or scalar");
     endif
   else
     usage ("beta_rnd (a, b [, r, c])");
   endif
 
   [r, c] = size (a);
   s = r * c;
   a = reshape (a, 1, s);
   b = reshape (b, 1, s);
   rnd = zeros (1, s);
-  
+
   k = find (!(a > 0) | !(a < Inf) | !(b > 0) | !(b < Inf));
   if (any (k))
     rnd(k) = NaN * ones (1, length (k));
   endif
-  
+
   k = find ((a > 0) & (a < Inf) & (b > 0) & (b < Inf));
   if (any (k))
     rnd(k) = beta_inv (rand (1, length (k)), a(k), b(k));
   endif
-  
+
   rnd = reshape (rnd, r, c);
-  
+
 endfunction
\ No newline at end of file
diff --git a/scripts/statistics/distributions/binomial_cdf.m b/scripts/statistics/distributions/binomial_cdf.m
--- a/scripts/statistics/distributions/binomial_cdf.m
+++ b/scripts/statistics/distributions/binomial_cdf.m
@@ -1,65 +1,65 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  binomial_cdf (x, n, p)
 ##
 ## For each element of x, compute the CDF at x of the binomial
 ## distribution with parameters n and p.
 
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  CDF of the binomial distribution
 
 function cdf = binomial_cdf (x, n, p)
-  
+
   if (nargin != 3)
     usage ("binomial_cdf (x, n, p)");
   endif
-  
+
   [retval, x, n, p] = common_size (x, n, p);
   if (retval > 0)
     error (["binomial_cdf:  ", ...
-	    "x, n and p must be of common size or scalar"]);
+            "x, n and p must be of common size or scalar"]);
   endif
-  
+
   [r, c] = size (x);
   s = r * c;
   x   = reshape (x, 1, s);
   n   = reshape (n, 1, s);
   p   = reshape (p, 1, s);
   cdf = zeros (1, s);
 
   k = find (isnan (x) | !(n >= 0) | (n != round (n)) ...
       | !(p >= 0) | !(p <= 1));
   if any (k)
     cdf(k) = NaN * ones (1, length (k));
   endif
-  
+
   k = find ((x >= n) & (n >= 0) & (n == round (n)) ...
-      & (p >= 0) & (p <= 1)); 
+      & (p >= 0) & (p <= 1));
   if any (k)
     cdf(k) = ones (1, length (k));
   endif
-  
+
   k = find ((x >= 0) & (x < n) & (n == round (n)) ...
       & (p >= 0) & (p <= 1));
   if any (k)
     tmp = floor (x(k));
     cdf(k) = 1 - betai (tmp + 1, n(k) - tmp, p(k));
   endif
-  
+
   cdf = reshape (cdf, r, c);
-  
+
 endfunction
diff --git a/scripts/statistics/distributions/binomial_inv.m b/scripts/statistics/distributions/binomial_inv.m
--- a/scripts/statistics/distributions/binomial_inv.m
+++ b/scripts/statistics/distributions/binomial_inv.m
@@ -1,67 +1,67 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  binomial_inv (x, n, p)
 ##
 ## For each element of x, compute the quantile at x of the binomial
 ## distribution with parameters n and p.
 
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  Quantile function of the binomial distribution
 
 function inv = binomial_inv (x, n, p)
-  
+
   if (nargin != 3)
     usage ("binomial_inv (x, n, p)");
   endif
-  
+
   [retval, x, n, p] = common_size (x, n, p);
   if (retval > 0)
     error (["binomial_inv:  ", ...
-	    "x, n and p must be of common size or scalars"]);
+            "x, n and p must be of common size or scalars"]);
   endif
 
   [r, c] = size (x);
   s   = r * c;
   x   = reshape (x, 1, s);
   n   = reshape (n, 1, s);
   p   = reshape (p, 1, s);
   inv = zeros (1, s);
-  
+
   k = find (!(x >= 0) | !(x <= 1) | !(n >= 0) | (n != round (n)) ...
       | !(p >= 0) | !(p <= 1));
   if any (k)
     inv(k) = NaN * ones (1, length (k));
   endif
-  
+
   k = find ((x >= 0) & (x <= 1) & (n >= 0) & (n == round (n)) ...
       & (p >= 0) & (p <= 1));
   if any (k)
     cdf = binomial_pdf (0, n(k), p(k));
     while (any (inv(k) < n(k)))
       m = find (cdf < x(k));
       if any (m)
-	inv(k(m)) = inv(k(m)) + 1;
-	cdf(m) = cdf(m) + binomial_pdf (inv(k(m)), n(k(m)), p(k(m)));
+        inv(k(m)) = inv(k(m)) + 1;
+        cdf(m) = cdf(m) + binomial_pdf (inv(k(m)), n(k(m)), p(k(m)));
       else
-	break;
+        break;
       endif
     endwhile
   endif
 
   inv = reshape (inv, r, c);
-  
+
 endfunction
diff --git a/scripts/statistics/distributions/binomial_pdf.m b/scripts/statistics/distributions/binomial_pdf.m
--- a/scripts/statistics/distributions/binomial_pdf.m
+++ b/scripts/statistics/distributions/binomial_pdf.m
@@ -1,59 +1,59 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  binomial_pdf (x, n, p)
 ##
 ## For each element of x, compute the probability density function (PDF)
 ## at x of the binomial distribution with parameters n and p.
 
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  PDF of the binomial distribution
 
 function pdf = binomial_pdf (x, n, p)
-  
+
   if (nargin != 3)
     usage ("binomial_pdf (x, n, p)");
   endif
 
   [retval, x, n, p] = common_size (x, n, p);
   if (retval > 0)
     error (["binomial_pdf:  ", ...
-	    "x, n and p must be of common size or scalar"]);
+            "x, n and p must be of common size or scalar"]);
   endif
-  
+
   [r, c] = size (x);
   s = r * c;
   x   = reshape (x, 1, s);
   n   = reshape (n, 1, s);
   p   = reshape (p, 1, s);
   cdf = zeros (1, s);
 
   k = find (isnan (x) | !(n >= 0) | (n != round (n)) ...
       | !(p >= 0) | !(p <= 1));
   if any (k)
     pdf(k) = NaN * ones (1, length (k));
   endif
-  
+
   k = find ((x >= 0) & (x <= n) & (x == round (x)) ...
       & (n == round (n)) & (p >= 0) & (p <= 1));
   if any (k)
     pdf(k) = bincoeff (n(k), x(k)) .* (p(k) .^ x(k)) ...
-	.* ((1 - p(k)) .^ (n(k) - x(k)));
+        .* ((1 - p(k)) .^ (n(k) - x(k)));
   endif
- 
+
   pdf = reshape (pdf, r, c);
-  
+
 endfunction
diff --git a/scripts/statistics/distributions/binomial_rnd.m b/scripts/statistics/distributions/binomial_rnd.m
--- a/scripts/statistics/distributions/binomial_rnd.m
+++ b/scripts/statistics/distributions/binomial_rnd.m
@@ -1,78 +1,78 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  binomial_rnd (n, p [, r, c])
 ##
 ## binomial_rnd (n, p) returns a matrix of random samples from the
 ## binomial distribution with parameters n and p.  The size of the
 ## matrix is the common size of n and p.
 ##
 ## binomial_rnd (n, p, r, c) returns an r by c matrix of random samples
 ## from the binomial distribution with parameters n and p. Both n and p
 ## must be scalar or of size r by c.
-  
+
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  Random deviates from the binomial distribution
 
 function rnd = binomial_rnd (n, p, r, c)
 
   if (nargin == 4)
     if ( !(is_scalar (r) && (r > 0) && (r == round (r))) )
       error ("binomial_rnd:  r must be a positive integer");
     endif
     if ( !(is_scalar (c) && (c > 0) && (c == round (c))) )
       error ("binomial_rnd:  c must be a positive integer");
     endif
     [retval, n, p] = common_size (n, p, zeros (r, c));
     if (retval > 0)
       error (strcat("binomial_rnd:  ",
-		    "n and p must be scalar or of size ",
-		    sprintf ("%d by %d", r, c)));
+                    "n and p must be scalar or of size ",
+                    sprintf ("%d by %d", r, c)));
     endif
   elseif (nargin == 2)
     [retval, n, p] = common_size (n, p);
     if (retval > 0)
       error ("binomial_rnd:  n and p must be of common size or scalar");
     endif
   else
     usage ("binomial_rnd (n, p [, r, c])");
   endif
 
   [r, c] = size (n);
   s = r * c;
   n = reshape (n, 1, s);
   p = reshape (p, 1, s);
   rnd = zeros (1, s);
-  
+
   k = find (!(n > 0) | !(n < Inf) | !(n == round (n)) |
-	    !(p <= 0) | !(p >= 1));
+            !(p <= 0) | !(p >= 1));
   if any (k)
     rnd(k) = NaN * ones (1, length (k));
   endif
-  
+
   k = find ((n > 0) & (n < Inf) & (n == round (n)) & (p >= 0) & (p <= 1));
   if any (k)
     N = max (n(k));
     L = length (k);
     tmp = rand (N, L);
     ind = (1 : N)' * ones (1, L);
     rnd(k) = sum ((tmp < ones (N, 1) * p(k)) &
-		  (ind <= ones (N, 1) * n(k)));
+                  (ind <= ones (N, 1) * n(k)));
   endif
-  
+
   rnd = reshape (rnd, r, c);
-  
+
 endfunction
\ No newline at end of file
diff --git a/scripts/statistics/distributions/cauchy_cdf.m b/scripts/statistics/distributions/cauchy_cdf.m
--- a/scripts/statistics/distributions/cauchy_cdf.m
+++ b/scripts/statistics/distributions/cauchy_cdf.m
@@ -1,58 +1,58 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  cauchy_cdf (x [, lambda, sigma])
 ##
 ## For each element of x, compute the cumulative distribution function
 ## (CDF) at x of the Cauchy distribution with location parameter lambda
 ## and scale parameter sigma. Default values are lambda = 0, sigma = 1.
 
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  CDF of the Cauchy distribution
 
 function cdf = cauchy_cdf (x, location, scale)
-  
+
   if !(nargin == 1 || nargin == 3)
     usage ("cauchy_cdf (x [, lambda, sigma])");
   endif
-  
+
   if (nargin == 1)
     location = 0;
     scale = 1;
   endif
-  
+
   [retval, x, location, scale] = common_size (x, location, scale);
   if (retval > 0)
     error (["cauchy_cdf:  ", ...
             "x, lambda and sigma must be of common size or scalar"]);
   endif
 
   [r, c] = size (x);
   s = r * c;
   x = reshape (x, 1, s);
   location = reshape (location, 1, s);
   scale = reshape (scale, 1, s);
   cdf = NaN * ones (1, s);
 
-  k = find ((x > -Inf) & (x < Inf) & (location > -Inf) & 
-	    (location < Inf) & (scale > 0) & (scale < Inf));
+  k = find ((x > -Inf) & (x < Inf) & (location > -Inf) &
+            (location < Inf) & (scale > 0) & (scale < Inf));
   if any (k)
     cdf(k) = 0.5 + atan ((x(k) - location(k)) ./ scale(k)) / pi;
   endif
-  
+
   cdf = reshape (cdf, r, c);
-  
+
 endfunction
diff --git a/scripts/statistics/distributions/cauchy_inv.m b/scripts/statistics/distributions/cauchy_inv.m
--- a/scripts/statistics/distributions/cauchy_inv.m
+++ b/scripts/statistics/distributions/cauchy_inv.m
@@ -1,71 +1,71 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  cauchy_inv (x [, lambda, sigma])
 ##
 ## For each element of x, compute the quantile (the inverse of the CDF)
 ## at x of the Cauchy distribution with location parameter lambda and
 ## scale parameter sigma. Default values are lambda = 0, sigma = 1.
 
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  Quantile function of the Cauchy distribution
 
 function inv = cauchy_inv (x, location, scale)
-  
+
   if !(nargin == 1 || nargin == 3)
     usage ("cauchy_inv (x [, lambda, sigma])");
   endif
-  
+
   if (nargin == 1)
     location = 0;
     scale = 1;
   endif
-  
+
   [retval, x, location, scale] = common_size (x, location, scale);
   if (retval > 0)
     error (["cauchy_inv:  ", ...
-	    "x, lambda and sigma must be of common size or scalar"]);
+            "x, lambda and sigma must be of common size or scalar"]);
   endif
-  
+
   [r, c] = size (x);
   s = r * c;
   x = reshape (x, 1, s);
   location = reshape (location, 1, s);
   scale = reshape (scale, 1, s);
-  
+
   inv = NaN * ones (1, s);
-  
+
   ok = ((location > -Inf) & (location < Inf) &
        (scale > 0) & (scale < Inf));
-  
+
   k = find ((x == 0) & ok);
   if any (k)
     inv(k) = -Inf * ones (1, length (k));
   endif
-  
+
   k = find ((x > 0) & (x < 1) & ok);
   if any (k)
     inv(k) = location(k) - scale(k) .* cot (pi * x(k));
   endif
-  
+
   k = find ((x == 1) & ok);
   if any (k)
     inv(k) = Inf * ones (1, length (k));
   endif
-  
+
   inv = reshape (inv, r, c);
-  
+
 endfunction
diff --git a/scripts/statistics/distributions/cauchy_pdf.m b/scripts/statistics/distributions/cauchy_pdf.m
--- a/scripts/statistics/distributions/cauchy_pdf.m
+++ b/scripts/statistics/distributions/cauchy_pdf.m
@@ -1,60 +1,60 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  cauchy_pdf (x [, lambda, sigma])
 ##
 ## For each element of x, compute the probability density function (PDF)
 ## at x of the Cauchy distribution with location parameter lambda and
 ## scale parameter sigma > 0. Default values are lambda = 0, sigma = 1.
 
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  PDF of the Cauchy distribution
 
 function pdf = cauchy_pdf (x, location, scale)
-  
+
   if !(nargin == 1 || nargin == 3)
     usage ("cauchy_pdf (x [, lambda, sigma])");
   endif
-  
+
   if (nargin == 1)
     location = 0;
     scale = 1;
   endif
-  
+
   [retval, x, location, scale] = common_size (x, location, scale);
   if (retval > 0)
     error (["cauchy_pdf:  ", ...
             "x, lambda and sigma must be of common size or scalar"]);
   endif
-  
+
   [r, c] = size (x);
   s = r * c;
   x = reshape (x, 1, s);
   location = reshape (location, 1, s);
   scale = reshape (scale, 1, s);
-  
+
   pdf = NaN * ones (1, s);
-  
-  k = find ((x > -Inf) & (x < Inf) & (location > -Inf) & 
-	    (location < Inf) & (scale > 0) & (scale < Inf));
+
+  k = find ((x > -Inf) & (x < Inf) & (location > -Inf) &
+            (location < Inf) & (scale > 0) & (scale < Inf));
   if any (k)
     pdf(k) = (1 ./ (1 + ((x(k) - location(k)) ./ scale(k)) .^ 2)) ...
              / pi ./ scale(k);
   endif
-  
+
   pdf = reshape (pdf, r, c);
-  
+
 endfunction
diff --git a/scripts/statistics/distributions/cauchy_rnd.m b/scripts/statistics/distributions/cauchy_rnd.m
--- a/scripts/statistics/distributions/cauchy_rnd.m
+++ b/scripts/statistics/distributions/cauchy_rnd.m
@@ -1,69 +1,69 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  cauchy_rnd (lambda, sigma [, r, c])
 ##
 ## cauchy_rnd (lambda, sigma) returns a matrix of random samples from
 ## the Cauchy distribution with parameters lambda and sigma.  The size
 ## of the matrix is the common size of the parameters.
 ##
 ## cauchy_rnd (lambda, sigma, r, c) returns an r by c matrix of random
 ## samples from the Cauchy distribution with parameters lambda and sigma
 ## which must both be scalar or of size r by c.
-  
+
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  Random deviates from the Cauchy distribution
 
 function rnd = cauchy_rnd (l, scale, r, c)
-  
+
   if (nargin == 4)
     if ( !(is_scalar (r) && (r > 0) && (r == round (r))) )
       error ("cauchy_rnd:  r must be a positive integer");
     endif
     if ( !(is_scalar (c) && (c > 0) && (c == round (c))) )
       error ("cauchy_rnd:  c must be a positive integer");
     endif
     [retval, l, scale] = common_size (l, scale, zeros (r, c));
     if (retval > 0)
       error (strcat("cauchy_rnd:  ",
-		    "lambda and sigma must be scalar or of size",
-		    sprintf ("%d by %d.", r, c)));
+                    "lambda and sigma must be scalar or of size",
+                    sprintf ("%d by %d.", r, c)));
     endif
   elseif (nargin == 2)
     [retval, l, scale] = common_size (l, scale);
     if (retval > 0)
       error (["cauchy_rnd:  ", ...
-	      "lambda and sigma must be of common size or scalar"]);
+              "lambda and sigma must be of common size or scalar"]);
     endif
     [r, c] = size (l);
   else
     usage ("cauchy_rnd (lambda, sigma [, r, c])");
   endif
-      
+
   s = r * c;
   l = reshape (l, 1, s);
   scale = reshape (scale, 1, s);
-  
+
   rnd = NaN * ones (1, s);
-  
+
   k = find ((l > -Inf) & (l < Inf) & (scale > 0) & (scale < Inf));
   if (any (k))
     rnd(k) = l(k) - cot (pi * rand (1, length (k))) .* scale(k);
   endif
 
   rnd = reshape (rnd, r, c);
-  
+
 endfunction
diff --git a/scripts/statistics/distributions/chisquare_cdf.m b/scripts/statistics/distributions/chisquare_cdf.m
--- a/scripts/statistics/distributions/chisquare_cdf.m
+++ b/scripts/statistics/distributions/chisquare_cdf.m
@@ -1,50 +1,50 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  chisquare_cdf (x, n)
 ##
 ## For each element of x, compute the cumulative distribution function
 ## (CDF) at x of the chisquare distribution with n degrees of freedom.
-  
+
 ## Author:  TT <Teresa.Twaroch@ci.tuwien.ac.at>
 ## Description:  CDF of the chi-square distribution
 
 function cdf = chisquare_cdf (x, n)
-  
+
   if (nargin != 2)
     usage ("chisquare_cdf (x, n)");
   endif
 
   [retval, x, n] = common_size (x, n);
   if (retval > 0)
     error (["chisquare_cdf:  ", ...
-	    "x and n must be of common size or scalar"]);
+            "x and n must be of common size or scalar"]);
   endif
-  
+
   cdf = gamma_cdf (x, n / 2, 1 / 2);
-  
+
   ## should we really only allow for positive integer n?
   k = find (n != round (n));
   if any (k)
     fprintf (stderr, ...
-	     "WARNING:  n should be positive integer\n");
+             "WARNING:  n should be positive integer\n");
     [r, c] = size (x);
     cdf = reshape (cdf, 1, r * c);
     cdf(k) = NaN * ones (1, length (k));
-    cdf = reshape (cdf, r, c);  
+    cdf = reshape (cdf, r, c);
   endif
 
 endfunction
diff --git a/scripts/statistics/distributions/chisquare_inv.m b/scripts/statistics/distributions/chisquare_inv.m
--- a/scripts/statistics/distributions/chisquare_inv.m
+++ b/scripts/statistics/distributions/chisquare_inv.m
@@ -1,49 +1,49 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  chisquare_inv (x, n)
 ##
 ## For each element of x, compute the quantile (the inverse of the CDF)
 ## at x of the chisquare distribution with n degrees of freedom.
-  
+
 ## Author:  TT <Teresa.Twaroch@ci.tuwien.ac.at>
 ## Description:  Quantile function of the chi-square distribution
-  
+
 function inv = chisquare_inv (x, n)
-  
+
   if (nargin != 2)
     usage ("chisquare_inv (x, n)");
   endif
 
   [retval, x, n] = common_size (x, n);
   if (retval > 0)
     error ("chisquare_inv:  x and n must be of common size or scalar");
   endif
 
   inv = gamma_inv (x, n / 2, 1 / 2);
-  
+
   ## Allow only for (positive) integer n.
   k = find (n != round (n));
   if any (k)
     fprintf (stderr, ...
-	     "WARNING:  n should be positive integer\n");
+             "WARNING:  n should be positive integer\n");
     [r, c] = size (x);
     inv = reshape (inv, 1, r * c);
     inv(k) = NaN * ones (1, length (k));
     inv = reshape (inv, r, c);
   endif
-  
+
 endfunction
diff --git a/scripts/statistics/distributions/chisquare_pdf.m b/scripts/statistics/distributions/chisquare_pdf.m
--- a/scripts/statistics/distributions/chisquare_pdf.m
+++ b/scripts/statistics/distributions/chisquare_pdf.m
@@ -1,50 +1,50 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  chisquare_pdf (x, n)
 ##
 ## For each element of x, compute the probability density function (PDF)
 ## at x of the chisquare distribution with k degrees of freedom.
 
 ## Author:  TT <Teresa.Twaroch@ci.tuwien.ac.at>
 ## Description:  PDF of the chi-sqaure distribution
 
 function pdf = chisquare_pdf (x, n)
-  
+
   if (nargin != 2)
     usage ("chisquare_pdf (x, n)");
   endif
 
   [retval, x, n] = common_size (x, n);
   if (retval > 0)
     error (["chisquare_pdf:  ", ...
-	    "x and n must be of common size or scalar"]);
+            "x and n must be of common size or scalar"]);
   endif
-  
+
   pdf = gamma_pdf (x, n / 2, 1 / 2);
-  
+
   ## should we really only allow for positive integer n?
   k = find (n != round (n));
   if any (k)
     fprintf (stderr, ...
-	     "WARNING:  n should be positive integer\n");
+             "WARNING:  n should be positive integer\n");
     [r, c] = size (x);
     pdf = reshape (pdf, 1, r * c);
     pdf(k) = NaN * ones (1, length (k));
     pdf = reshape (pdf, r, c);
   endif
-  
+
 endfunction
diff --git a/scripts/statistics/distributions/chisquare_rnd.m b/scripts/statistics/distributions/chisquare_rnd.m
--- a/scripts/statistics/distributions/chisquare_rnd.m
+++ b/scripts/statistics/distributions/chisquare_rnd.m
@@ -1,66 +1,66 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  chisquare_rnd (n [, r, c])
 ##
 ## chisquare_rnd (n) returns a matrix of random samples from the
 ## chisquare distribution with n degrees of freedom.  The size of the
 ## matrix is the size of n.
 ##
 ## chisquare_rnd (n, r, c) returns an r by c matrix of random samples
 ## from the chisquare distribution with n degrees of freedom.  n must be
 ## a scalar or of size r by c.
-  
+
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  Random deviates from the chi-square distribution
 
 function rnd = chisquare_rnd (n, r, c)
 
   if (nargin == 3)
     if ( !(is_scalar (r) && (r > 0) && (r == round (r))) )
       error ("chisquare_rnd:  r must be a positive integer");
     endif
     if ( !(is_scalar (c) && (c > 0) && (c == round (c))) )
       error ("chisquare_rnd:  c must be a positive integer");
     endif
     [retval, n] = common_size (n, zeros (r, c));
     if (retval > 0)
       error (strcat("chisquare_rnd:  ",
-		    "n must be scalar or of size ",
-		    sprintf ("%d by %d", r, c)));
+                    "n must be scalar or of size ",
+                    sprintf ("%d by %d", r, c)));
     endif
   elseif (nargin != 1)
     usage ("chisquare_rnd (n [, r, c])");
   endif
-  
+
   [r, c] = size (n);
   s = r * c;
   n = reshape (n, 1, s);
   rnd = zeros (1, s);
-  
+
   k = find (!(n > 0) | !(n < Inf) | !(n == round (n)));
   if (any (k))
     rnd(k) = NaN * ones (1, length (k));
   endif
-  
+
   k = find ((n > 0) & (n < Inf) & (n == round (n)));
   if (any (k))
     rnd(k) = chisquare_inv (rand (1, length (k)), n(k));
   endif
-  
+
   rnd = reshape (rnd, r, c);
-  
+
 endfunction
diff --git a/scripts/statistics/distributions/discrete_cdf.m b/scripts/statistics/distributions/discrete_cdf.m
--- a/scripts/statistics/distributions/discrete_cdf.m
+++ b/scripts/statistics/distributions/discrete_cdf.m
@@ -1,35 +1,35 @@
 ## Copyright (C) 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  discrete_cdf (X, V, P)
 ##
 ## For each element of X, compute the cumulative distribution function
 ## (CDF) at X of a univariate discrete distribution which assumes the
 ## values in V with probabilities P.
 
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  CDF of a discrete distribution
 
 function cdf = discrete_cdf (X, V, P)
-  
+
   if (nargin != 3)
     usage ("discrete_cdf (X, V, P)");
   endif
 
   [r, c] = size (X);
 
   if (! is_vector (V))
     error ("discrete_cdf: V must be a vector");
diff --git a/scripts/statistics/distributions/discrete_inv.m b/scripts/statistics/distributions/discrete_inv.m
--- a/scripts/statistics/distributions/discrete_inv.m
+++ b/scripts/statistics/distributions/discrete_inv.m
@@ -1,35 +1,35 @@
 ## Copyright (C) 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  discrete_inv (X, V, P)
 ##
 ## For each component of X, compute the quantile (the inverse of the
 ## CDF) at X of the univariate distribution which assumes the values in
 ## V with probabilities P.
 
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  Quantile function of a discrete distribution
 
 function inv = discrete_inv (X, V, P)
-  
+
   if (nargin != 3)
     usage ("discrete_inv (X, V, P)");
   endif
 
   [r, c] = size (X);
 
   if (! is_vector (V))
     error ("discrete_inv:  V must be a vector");
diff --git a/scripts/statistics/distributions/discrete_pdf.m b/scripts/statistics/distributions/discrete_pdf.m
--- a/scripts/statistics/distributions/discrete_pdf.m
+++ b/scripts/statistics/distributions/discrete_pdf.m
@@ -1,35 +1,35 @@
 ## Copyright (C) 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  discrete_pdf (X, V, P)
 ##
 ## For each element of X, compute the probability density function (PDF)
 ## at X of a univariate discrete distribution which assumes the values
 ## in V with probabilities P.
 
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  PDF of a discrete distribution
 
 function pdf = discrete_pdf (X, V, P)
-  
+
   if (nargin != 3)
     usage ("discrete_pdf (X, V, P)");
   endif
 
   [r, c] = size (X);
 
   if (! is_vector (V))
     error ("discrete_pdf:  V must be a vector");
diff --git a/scripts/statistics/distributions/discrete_rnd.m b/scripts/statistics/distributions/discrete_rnd.m
--- a/scripts/statistics/distributions/discrete_rnd.m
+++ b/scripts/statistics/distributions/discrete_rnd.m
@@ -1,37 +1,37 @@
 ## Copyright (C) 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  discrete_rnd (N, V, P)
 ##
 ## Generate a row vector containing a random sample of size N from the
 ## univariate distribution which assumes the values in V with
 ## probabilities P.
 ##
 ## Currently, N must be a scalar.
 
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  Random deviates from a discrete distribution
 
 function rnd = discrete_rnd (N, V, P)
-  
+
   if (nargin != 3)
     usage ("discrete_rnd (N, V, P)");
   endif
 
   if (! is_scalar (N))
     error ("discrete_rnd:  N must be a scalar");
   endif
 
@@ -43,10 +43,10 @@ function rnd = discrete_rnd (N, V, P)
     error ("discrete_rnd:  P must be a nonzero, nonnegative vector");
   endif
 
   u = rand (1, N);
   m = length (P);
   s = reshape (cumsum (P / sum (P)), m, 1);
 
   rnd = V (1 + sum ((s * ones (1, N)) <= ((ones (m, 1) * u))));
-  
+
 endfunction
diff --git a/scripts/statistics/distributions/empirical_cdf.m b/scripts/statistics/distributions/empirical_cdf.m
--- a/scripts/statistics/distributions/empirical_cdf.m
+++ b/scripts/statistics/distributions/empirical_cdf.m
@@ -1,34 +1,34 @@
 ## Copyright (C) 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  empirical_cdf (X, DATA)
 ##
 ## For each element of X, compute the cumulative distribution function
 ## (CDF) at X of the empirical distribution obtained from the univariate
 ## sample DATA.
 
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  CDF of the empirical distribution
-  
+
 function cdf = empirical_cdf (X, DATA)
-  
+
   if (! is_vector (DATA))
     error ("empirical_cdf:  DATA must be a vector");
   endif
 
   cdf = discrete_cdf (X, DATA, ones (size (DATA)) / length (DATA));
 
 endfunction
diff --git a/scripts/statistics/distributions/empirical_inv.m b/scripts/statistics/distributions/empirical_inv.m
--- a/scripts/statistics/distributions/empirical_inv.m
+++ b/scripts/statistics/distributions/empirical_inv.m
@@ -1,34 +1,34 @@
 ## Copyright (C) 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  empirical_inv (X, DATA)
 ##
 ## For each element of X, compute the quantile (the inverse of the CDF)
 ## at X of the empirical distribution obtained from the univariate
 ## sample DATA.
 
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  Quantile function of the empirical distribution
-  
+
 function inv = empirical_inv (X, DATA)
-  
+
   if (! is_vector (DATA))
     error ("empirical_inv:  DATA must be a vector");
   endif
 
   inv = discrete_inv (X, DATA, ones (size (DATA)) / length (DATA));
 
 endfunction
diff --git a/scripts/statistics/distributions/empirical_pdf.m b/scripts/statistics/distributions/empirical_pdf.m
--- a/scripts/statistics/distributions/empirical_pdf.m
+++ b/scripts/statistics/distributions/empirical_pdf.m
@@ -1,34 +1,34 @@
 ## Copyright (C) 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  empirical_pdf (X, DATA)
 ##
 ## For each element of X, compute the probability density function (PDF)
 ## at X of the empirical distribution obtained from the univariate
 ## sample DATA.
 
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  PDF of the empirical distribution
-  
+
 function pdf = empirical_pdf (X, DATA)
-  
+
   if (! is_vector (DATA))
     error ("empirical_pdf:  DATA must be a vector");
   endif
 
   pdf = discrete_pdf (X, DATA, ones (size (DATA)) / length (DATA));
 
 endfunction
diff --git a/scripts/statistics/distributions/empirical_rnd.m b/scripts/statistics/distributions/empirical_rnd.m
--- a/scripts/statistics/distributions/empirical_rnd.m
+++ b/scripts/statistics/distributions/empirical_rnd.m
@@ -1,33 +1,33 @@
 ## Copyright (C) 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  empirical_rnd (N, DATA)
 ##
 ## Generate a bootstrap sample of size N from the empirical distribution
 ## obtained from the univariate sample DATA.
 
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  Bootstrap samples from the empirical distribution
-  
+
 function rnd = empirical_rnd (N, DATA)
-  
+
   if (! is_vector (DATA))
     error ("empirical_rnd:  DATA must be a vector");
   endif
 
   rnd = discrete_rnd (N, DATA, ones (size (DATA)) / length (DATA));
 
 endfunction
diff --git a/scripts/statistics/distributions/exponential_cdf.m b/scripts/statistics/distributions/exponential_cdf.m
--- a/scripts/statistics/distributions/exponential_cdf.m
+++ b/scripts/statistics/distributions/exponential_cdf.m
@@ -1,61 +1,61 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  exponential_cdf (x, lambda)
 ##
 ## For each element of x, compute the cumulative distribution function
 ## (CDF) at x of the exponential distribution with parameter lambda.
 ##
 ## The arguments can be of common size or scalar.
-  
+
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  CDF of the exponential distribution
 
 function cdf = exponential_cdf (x, l)
-  
+
   if (nargin != 2)
     usage ("exponential_cdf (x, lambda)");
   endif
-  
+
   [retval, x, l] = common_size (x, l);
   if (retval > 0)
     error ("exponential_cdf: x and lambda must be of common size or scalar");
   endif
-  
+
   [r, c] = size (x);
   s = r * c;
   x = reshape (x, 1, s);
   l = reshape (l, 1, s);
   cdf = zeros (1, s);
-  
+
   k = find (isnan (x) | !(l > 0));
   if any (k)
     cdf(k) = NaN * ones (1, length (k));
   endif
-  
+
   k = find ((x == Inf) & (l > 0));
   if any (k)
     cdf(k) = ones (1, length (k));
   endif
-  
+
   k = find ((x > 0) & (x < Inf) & (l > 0));
   if any (k)
     cdf (k) = 1 - exp (- l(k) .* x(k));
   endif
 
   cdf = reshape (cdf, r, c);
-  
+
 endfunction
diff --git a/scripts/statistics/distributions/exponential_inv.m b/scripts/statistics/distributions/exponential_inv.m
--- a/scripts/statistics/distributions/exponential_inv.m
+++ b/scripts/statistics/distributions/exponential_inv.m
@@ -1,60 +1,60 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  exponential_inv (x, lambda)
 ##
 ## For each element of x, compute the quantile (the inverse of the CDF)
 ## at x of the exponential distribution with parameter lambda.
-  
+
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  Quantile function of the exponential distribution
 
 function inv = exponential_inv (x, l)
-  
+
   if (nargin != 2)
     usage ("exponential_inv (x, lambda)");
   endif
-  
+
   [retval, x, l] = common_size (x, l);
   if (retval > 0)
     error (["exponential_inv:  ", ...
-	    "x and lambda must be of common size or scalar"]);
+            "x and lambda must be of common size or scalar"]);
   endif
 
   [r, c] = size (x);
   s = r * c;
   x = reshape (x, 1, s);
   l = reshape (l, 1, s);
   inv = zeros (1, s);
-  
+
   k = find (!(l > 0) | (x < 0) | (x > 1) | isnan (x));
   if any (k)
     inv(k) = NaN * ones (1, length (k));
   endif
-  
+
   k = find ((x == 1) & (l > 0));
   if any (k)
     inv(k) = Inf * ones (1, length (k));
   endif
-  
+
   k = find ((x > 0) & (x < 1) & (l > 0));
   if any (k)
     inv(k) = - log (1 - x(k)) ./ l(k);
   endif
 
   inv = reshape (inv, r, c);
-  
+
 endfunction
diff --git a/scripts/statistics/distributions/exponential_pdf.m b/scripts/statistics/distributions/exponential_pdf.m
--- a/scripts/statistics/distributions/exponential_pdf.m
+++ b/scripts/statistics/distributions/exponential_pdf.m
@@ -1,55 +1,55 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  exponential_pdf (x, lambda)
 ##
 ## For each element of x, compute the probability density function (PDF)
 ## of the exponential distribution with parameter lambda.
 
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  PDF of the exponential distribution
 
 function pdf = exponential_pdf (x, l)
-  
+
   if (nargin != 2)
     usage ("exponential_pdf (x, lambda)");
   endif
-  
+
   [retval, x, l] = common_size (x, l);
   if (retval > 0)
     error (["exponential_pdf:  ", ...
-	    "x and lambda must be of common size or scalar"]);
+            "x and lambda must be of common size or scalar"]);
   endif
 
   [r, c] = size (x);
   s = r * c;
   x = reshape (x, 1, s);
   l = reshape (l, 1, s);
   pdf = zeros (1, s);
 
   k = find (!(l > 0) | isnan (x));
   if any (k)
     pdf(k) = NaN * ones (1, length (k));
   endif
-  
+
   k = find ((x > 0) & (x < Inf) & (l > 0));
   if any (k)
     pdf(k) = l(k) .* exp (- l(k) .* x(k));
   endif
 
   pdf = reshape (pdf, r, c);
-  
+
 endfunction
diff --git a/scripts/statistics/distributions/exponential_rnd.m b/scripts/statistics/distributions/exponential_rnd.m
--- a/scripts/statistics/distributions/exponential_rnd.m
+++ b/scripts/statistics/distributions/exponential_rnd.m
@@ -1,65 +1,65 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  exponential_rnd (lambda [, r, c])
 ##
 ## exponential_rnd (lambda) returns a matrix of random samples from the
 ## exponential distribution with parameter lambda.  The size of the
 ## matrix is the size of lambda.
 ##
 ## exponential_rnd (lambda, r, c) returns an r by c matrix of random
 ## samples from the exponential distribution with parameter lambda,
 ## which must be a scalar or of size r by c.
-  
+
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  Random deviates from the exponential distribution
-  
+
 function rnd = exponential_rnd (l, r, c)
 
   if (nargin == 3)
     if ( !(is_scalar (r) && (r > 0) && (r == round (r))) )
       error ("exponential_rnd:  r must be a positive integer");
     endif
     if ( !(is_scalar (c) && (c > 0) && (c == round (c))) )
       error ("exponential_rnd:  c must be a positive integer");
     endif
     [retval, l] = common_size (l, zeros (r, c));
     if (retval > 0)
       error (strcat("exponential_rnd:  ",
-		    "lambda must be scalar or of size ",
-		    sprintf ("%d by %d", r, c)));
+                    "lambda must be scalar or of size ",
+                    sprintf ("%d by %d", r, c)));
     endif
   elseif (nargin != 1)
     usage ("exponential_rnd (lambda [, r, c])");
   endif
-  
+
   [r, c] = size (l);
   s = r * c;
   l = reshape (l, 1, s);
   rnd = zeros (1, s);
-  
+
   k = find (!(l > 0) | !(l < Inf));
   if (any (k))
     rnd(k) = NaN * ones (1, length (k));
   endif
   k = find ((l > 0) & (l < Inf));
   if (any (k))
     rnd(k) = - log (1 - rand (1, length (k))) ./ l(k);
   endif
-  
+
   rnd = reshape (rnd, r, c);
-  
+
 endfunction
diff --git a/scripts/statistics/distributions/f_cdf.m b/scripts/statistics/distributions/f_cdf.m
--- a/scripts/statistics/distributions/f_cdf.m
+++ b/scripts/statistics/distributions/f_cdf.m
@@ -1,69 +1,69 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  f_cdf (x, m, n)
 ##
 ## For each element of x, compute the CDF at x of the F distribution
 ## with m and n degrees of freedom, i.e., PROB( F(m,n) <= x ).
 
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  CDF of the F distribution
 
 function cdf = f_cdf (x, m, n)
-  
+
   if (nargin != 3)
     usage ("f_cdf (x, m, n)");
   endif
-  
+
   [retval, x, m, n] = common_size (x, m, n);
   if (retval > 0)
     error ("f_cdf:  x, m and n must be of common size or scalar");
   endif
-  
+
   [r, c] = size (x);
   s = r * c;
   x = reshape (x, 1, s);
   m = reshape (m, 1, s);
   n = reshape (n, 1, s);
   cdf = zeros (1, s);
 
   k = find (!(m > 0) | !(n > 0) | isnan (x));
   if any (k)
     cdf(k) = NaN * ones (1, length (k));
   endif
-  
+
   k = find ((x == Inf) & (m > 0) & (n > 0));
   if any (k)
     cdf(k) = ones (1, length (k));
   endif
-  
+
   k = find ((x > 0) & (x < Inf) & (m > 0) & (n > 0));
   if any (k)
     cdf(k) = 1 - betai (n(k) / 2, m(k) / 2, ...
-	1 ./ (1 + m(k) .* x(k) ./ n(k)));
+        1 ./ (1 + m(k) .* x(k) ./ n(k)));
   endif
-  
+
   ## should we really only allow for positive integer m, n?
   k = find ((m != round (m)) | (n != round (n)));
   if any (k)
     fprintf (stderr, ...
-	     "WARNING:  m and n should be positive integers\n");
+             "WARNING:  m and n should be positive integers\n");
     cdf(k) = NaN * ones (1, length (k));
   endif
-  
+
   cdf = reshape (cdf, r, c);
-  
+
 endfunction
diff --git a/scripts/statistics/distributions/f_inv.m b/scripts/statistics/distributions/f_inv.m
--- a/scripts/statistics/distributions/f_inv.m
+++ b/scripts/statistics/distributions/f_inv.m
@@ -1,20 +1,20 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  f_inv (x, m, n)
 ##
 ## For each component of x, compute the quantile (the inverse of the
 ## CDF) at x of the F distribution with parameters m and n.
@@ -27,43 +27,43 @@ function inv = f_inv (x, m, n)
   if (nargin != 3)
     usage ("f_inv (x, m, n)");
   endif
 
   [retval, x, m, n] = common_size (x, m, n);
   if (retval > 0)
     error ("f_inv:  x, m and n must be of common size or scalar");
   endif
-  
+
   [r, c] = size (x);
   s = r * c;
   x = reshape (x, 1, s);
   m = reshape (m, 1, s);
   n = reshape (n, 1, s);
   inv = zeros (1, s);
 
   k = find ((x < 0) | (x > 1) | isnan (x) | !(m > 0) | !(n > 0));
   if any (k)
     inv(k) = NaN * ones (1, length (k));
   endif
-  
+
   k = find ((x == 1) & (m > 0) & (n > 0));
   if any (k)
     inv(k) = Inf * ones (1, length (k));
   endif
-  
+
   k = find ((x > 0) & (x < 1) & (m > 0) & (n > 0));
   if any (k)
     inv(k) = (1 ./ beta_inv (1 - x(k), n(k) / 2, m(k) / 2) - 1) ...
-	.* n(k) ./ m(k);
+        .* n(k) ./ m(k);
   endif
 
   ## should we really only allow for positive integer m, n?
   k = find ((m != round (m)) | (n != round (n)));
   if any (k)
     fprintf (stderr, ...
-	     "WARNING:  m and n should be positive integers\n");
+             "WARNING:  m and n should be positive integers\n");
     inv(k) = NaN * ones (1, length (k));
   endif
-  
+
   inv = reshape (inv, r, c);
-  
+
 endfunction
\ No newline at end of file
diff --git a/scripts/statistics/distributions/f_pdf.m b/scripts/statistics/distributions/f_pdf.m
--- a/scripts/statistics/distributions/f_pdf.m
+++ b/scripts/statistics/distributions/f_pdf.m
@@ -1,66 +1,66 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  f_pdf (x, m, n)
 ##
 ## For each element of x, compute the probability density function (PDF)
 ## at x of the F distribution with m and n degrees of freedom.
 
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  PDF of the F distribution
 
 function pdf = f_pdf (x, m, n)
-  
+
   if (nargin != 3)
     usage ("f_pdf (x, m, n).");
   endif
-  
+
   [retval, x, m, n] = common_size (x, m, n);
   if (retval > 0)
     error ("f_pdf:  x, m and n must be of common size or scalar");
   endif
-  
+
   [r, c] = size (x);
   s = r * c;
   x = reshape (x, 1, s);
   m = reshape (m, 1, s);
   n = reshape (n, 1, s);
   pdf = zeros (1, s);
-  
+
   k = find (isnan (x) | !(m > 0) | !(n > 0));
   if any (k)
     pdf(k) = NaN * ones (1, length (k));
   endif
-  
+
   k = find ((x > 0) & (x < Inf) & (m > 0) & (n > 0));
   if any (k)
     tmp = m(k) .* x(k) ./ n(k);
     pdf(k) = exp ((m(k) / 2 - 1) .* log (tmp) ...
-	- ((m(k) + n(k)) / 2) .* log (1 + tmp)) ...
-	.* (m(k) ./ n(k)) ./ beta (m(k) / 2, n(k) / 2);
+        - ((m(k) + n(k)) / 2) .* log (1 + tmp)) ...
+        .* (m(k) ./ n(k)) ./ beta (m(k) / 2, n(k) / 2);
   endif
 
   ## should we really only allow for positive integer m, n?
   k = find ((m != round (m)) | (n != round (n)));
   if any (k)
     fprintf (stderr, ...
-	     "WARNING:  m and n should be positive integers\n");
+             "WARNING:  m and n should be positive integers\n");
     pdf(k) = NaN * ones (1, length (k));
   endif
 
   pdf = reshape (pdf, r, c);
-  
+
 endfunction
diff --git a/scripts/statistics/distributions/f_rnd.m b/scripts/statistics/distributions/f_rnd.m
--- a/scripts/statistics/distributions/f_rnd.m
+++ b/scripts/statistics/distributions/f_rnd.m
@@ -1,74 +1,74 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  f_rnd (m, n [, r, c])
 ##
 ## f_rnd (m, n) returns a matrix of random samples from the F
 ## distribution with m and n degrees of freedom.  The size of the matrix
 ## is the common size of m and n.
 ##
 ## f_rnd (m, n, r, c) returns an r by c matrix of random samples from
 ## the F distribution with m and n degrees of freedom.  Both m and n
 ## must be scalar or of size r by c.
-  
+
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  Random deviates from the F distribution
-  
+
 function rnd = f_rnd (m, n, r, c)
 
   if (nargin == 4)
     if ( !(is_scalar (r) && (r > 0) && (r == round (r))) )
       error ("f_rnd:  r must be a positive integer");
     endif
     if ( !(is_scalar (c) && (c > 0) && (c == round (c))) )
       error ("f_rnd:  c must be a positive integer");
     endif
     [retval, m, n] = common_size (m, n, zeros (r, c));
     if (retval > 0)
       error (strcat("f_rnd:  ",
-		    "m and n must be scalar or of size ",
-		    sprintf ("%d by %d", r, c)));
+                    "m and n must be scalar or of size ",
+                    sprintf ("%d by %d", r, c)));
     endif
   elseif (nargin == 2)
     [retval, m, n] = common_size (m, n);
     if (retval > 0)
       error ("f_rnd:  m and n must be of common size or scalar");
     endif
   else
     usage ("f_rnd (m, n [, r, c])");
   endif
 
   [r, c] = size (m);
   s = r * c;
   m = reshape (m, 1, s);
   n = reshape (n, 1, s);
   rnd = zeros (1, s);
-  
+
   k = find (!(m > 0) | !(m < Inf) | !(m == round (m)) |
-	    !(n > 0) | !(n < Inf) | !(n == round (n)));
+            !(n > 0) | !(n < Inf) | !(n == round (n)));
   if (any (k))
     rnd(k) = NaN * ones (1, length (k));
   endif
-  
+
   k = find ((m > 0) & (m < Inf) & (m == round (m)) &
-	    (n > 0) & (n < Inf) & (n == round (n)));
+            (n > 0) & (n < Inf) & (n == round (n)));
   if (any (k))
     rnd(k) = f_inv (rand (1, length (k)), m(k), n(k));
   endif
-  
+
   rnd = reshape (rnd, r, c);
-  
+
 endfunction
\ No newline at end of file
diff --git a/scripts/statistics/distributions/gamma_cdf.m b/scripts/statistics/distributions/gamma_cdf.m
--- a/scripts/statistics/distributions/gamma_cdf.m
+++ b/scripts/statistics/distributions/gamma_cdf.m
@@ -1,55 +1,55 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  gamma_cdf (x, a, b)
 ##
 ## For each element of x, compute the cumulative distribution function
 ## (CDF) at x of the Gamma distribution with parameters a and b.
 
 ## Author:  TT <Teresa.Twaroch@ci.tuwien.ac.at>
 ## Description:  CDF of the Gamma distribution
-  
+
 function cdf = gamma_cdf (x, a, b)
-  
+
   if (nargin != 3)
     usage ("gamma_cdf (x, a, b)");
   endif
-  
+
   [retval, x, a, b] = common_size (x, a, b);
   if (retval > 0)
     error ("gamma_cdf:  x, a and b must be of common size or scalars");
   endif
-  
+
   [r, c] = size (x);
   s = r * c;
   x   = reshape (x, s, 1);
   a   = reshape (a, s, 1);
   b   = reshape (b, s, 1);
   cdf = zeros (s, 1);
-  
+
   k = find (!(a > 0) | !(b > 0) | isnan (x));
   if any (k)
     cdf (k) = NaN * ones (length (k), 1);
   endif
-  
+
   k = find ((x > 0) & (a > 0) & (b > 0));
   if any (k)
     cdf (k) = gammai (a(k), b(k) .* x(k));
   endif
-    
+
   cdf = reshape (cdf, r, c);
-  
+
 endfunction
diff --git a/scripts/statistics/distributions/gamma_inv.m b/scripts/statistics/distributions/gamma_inv.m
--- a/scripts/statistics/distributions/gamma_inv.m
+++ b/scripts/statistics/distributions/gamma_inv.m
@@ -1,60 +1,60 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  gamma_inv (x, a, b)
 ##
 ## For each component of x, compute the quantile (the inverse of the
 ## CDF) at x of the Gamma distribution with parameters a and b.
-  
+
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  Quantile function of the Gamma distribution
 
 function inv = gamma_inv (x, a, b)
-  
+
   if (nargin != 3)
     usage ("gamma_inv (x, a, b)");
   endif
-  
+
   [retval, x, a, b] = common_size (x, a, b);
   if (retval > 0)
     error ("gamma_inv:  x, a and b must be of common size or scalars");
   endif
 
   [r, c] = size (x);
   s   = r * c;
   x   = reshape (x, s, 1);
   a   = reshape (a, s, 1);
   b   = reshape (b, s, 1);
   inv = zeros (s, 1);
-  
+
   k = find ((x < 0) | (x > 1) | isnan (x) | !(a > 0) | !(b > 0));
   if any (k)
     inv (k) = NaN * ones (length (k), 1);
   endif
-  
+
   k = find ((x == 1) & (a > 0) & (b > 0));
   if any (k)
     inv (k) = Inf * ones (length (k), 1);
   endif
-  
+
   k = find ((x > 0) & (x < 1) & (a > 0) & (b > 0));
   if any (k)
     a = a (k);
     b = b (k);
     x = x (k);
     y = a ./ b;
     l = find (x < eps);
     if any (l)
@@ -62,23 +62,23 @@ function inv = gamma_inv (x, a, b)
     endif
 
     y_old = y;
     for i = 1 : 100
       h     = (gamma_cdf (y_old, a, b) - x) ./ gamma_pdf (y_old, a, b);
       y_new = y_old - h;
       ind   = find (y_new <= eps);
       if (any (ind))
-	y_new (ind) = y_old (ind) / 10;
-	h = y_old - y_new;
+        y_new (ind) = y_old (ind) / 10;
+        h = y_old - y_new;
       endif
       if (max (abs (h)) < sqrt (eps))
-	break;
+        break;
       endif
       y_old = y_new;
     endfor
-    
+
     inv (k) = y_new;
   endif
 
   inv = reshape (inv, r, c);
-  
+
 endfunction
diff --git a/scripts/statistics/distributions/gamma_pdf.m b/scripts/statistics/distributions/gamma_pdf.m
--- a/scripts/statistics/distributions/gamma_pdf.m
+++ b/scripts/statistics/distributions/gamma_pdf.m
@@ -1,56 +1,56 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  gamma_pdf (x, a, b)
 ##
 ## For each element of x, return the probability density function (PDF)
 ## at x of the Gamma distribution with parameters a and b.
-  
+
 ## Author:  TT <Teresa.Twaroch@ci.tuwien.ac.at>
 ## Description:  PDF of the Gamma distribution
 
 function pdf = gamma_pdf (x, a, b)
-  
+
   if (nargin != 3)
     usage ("gamma_pdf (x, a, b)");
   endif
 
   [retval, x, a, b] = common_size (x, a, b);
   if (retval > 0)
     error ("gamma_pdf:  x, a and b must be of common size or scalars");
   endif
 
   [r, c] = size (x);
   s = r * c;
   x   = reshape (x, s, 1);
   a   = reshape (a, s, 1);
   b   = reshape (b, s, 1);
   pdf = zeros (s, 1);
-  
+
   k = find (!(a > 0) | !(b > 0) | isnan (x));
   if any (k)
     pdf (k) = NaN * ones (length (k), 1);
   endif
 
   k = find ((x > 0) & (a > 0) & (b > 0));
   if any (k)
     pdf (k) = (b(k) .^ a(k)) .* (x(k) .^ (a(k) - 1)) ...
-	.* exp(-b(k) .* x(k)) ./ gamma (a(k));
+        .* exp(-b(k) .* x(k)) ./ gamma (a(k));
   endif
 
   pdf = reshape (pdf, r, c);
-  
+
 endfunction
diff --git a/scripts/statistics/distributions/gamma_rnd.m b/scripts/statistics/distributions/gamma_rnd.m
--- a/scripts/statistics/distributions/gamma_rnd.m
+++ b/scripts/statistics/distributions/gamma_rnd.m
@@ -1,72 +1,72 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  gamma_rnd (a, b [, r, c])
 ##
 ## gamma_rnd (a, b) returns a matrix of random samples from the Gamma
 ## distribution with parameters a and b.  The size of the matrix is the
 ## common size of a and b.
 ##
 ## gamma_rnd (a, b, r, c) returns an r by c matrix of random samples
 ## from the Gamma distribution with parameters a and b.  Both a and b
 ## must be scalar or of size r by c.
-  
+
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  Random deviates from the Gamma distribution
-  
+
 function rnd = gamma_rnd (a, b, r, c)
 
   if (nargin == 4)
     if ( !(is_scalar (r) && (r > 0) && (r == round (r))) )
       error ("gamma_rnd:  r must be a positive integer");
     endif
     if ( !(is_scalar (c) && (c > 0) && (c == round (c))) )
       error ("gamma_rnd:  c must be a positive integer");
     endif
     [retval, a, b] = common_size (a, b, zeros (r, c));
     if (retval > 0)
       error (strcat("gamma_rnd:  ",
-		    "a and b must be scalar or of size ",
-		    sprintf ("%d by %d", r, c)));
+                    "a and b must be scalar or of size ",
+                    sprintf ("%d by %d", r, c)));
     endif
   elseif (nargin == 2)
     [retval, a, b] = common_size (a, b);
     if (retval > 0)
       error (["gamma_rnd:  ", ...
-	      "a and b must be of common size or scalar"]);
+              "a and b must be of common size or scalar"]);
     endif
   else
     usage ("gamma_rnd (a, b [, r, c])");
   endif
 
   [r, c] = size (a);
   s = r * c;
   a = reshape (a, 1, s);
   b = reshape (b, 1, s);
   rnd = zeros (1, s);
-  
+
   k = find (!(a > 0) | !(a < Inf) | !(b > 0) | !(b < Inf));
   if (any (k))
     rnd(k) = NaN * ones (1, length (k));
   endif
   k = find ((a > 0) & (a < Inf) & (b > 0) & (b < Inf));
   if (any (k))
     rnd(k) = gamma_inv (rand (1, length (k)), a(k), b(k));
   endif
-  
+
   rnd = reshape (rnd, r, c);
-  
+
 endfunction
\ No newline at end of file
diff --git a/scripts/statistics/distributions/geometric_cdf.m b/scripts/statistics/distributions/geometric_cdf.m
--- a/scripts/statistics/distributions/geometric_cdf.m
+++ b/scripts/statistics/distributions/geometric_cdf.m
@@ -1,61 +1,61 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  geometric_cdf (x, p)
 ##
 ## For each element of x, compute the CDF at x of the geometric
 ## distribution with parameter p.
 
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  CDF of the geometric distribution
 
 function cdf = geometric_cdf (x, p)
-  
+
   if (nargin != 2)
     usage ("geometric_cdf (x, p)");
   endif
 
   [retval, x, p] = common_size (x, p);
   if (retval > 0)
     error (["geometric_cdf:  ", ...
-	    "x and p must be of common size or scalar"]);
+            "x and p must be of common size or scalar"]);
   endif
-  
+
   [r, c] = size (x);
   s = r * c;
   x   = reshape (x, 1, s);
   p   = reshape (p, 1, s);
   cdf = zeros (1, s);
 
   k = find (isnan (x) | !(p >= 0) | !(p <= 1));
   if any (k)
     cdf(k) = NaN * ones (1, length (k));
   endif
-  
+
   k = find ((x == Inf) & (p >= 0) & (p <= 1));
   if any (k)
     cdf(k) = ones (1, length (k));
   endif
-  
+
   k = find ((x >= 0) & (x < Inf) & (x == round (x)) ...
       & (p > 0) & (p <= 1));
   if any (k)
     cdf(k) = 1 - ((1 - p(k)) .^ (x(k) + 1));
   endif
- 
+
   cdf = reshape (cdf, r, c);
-  
+
 endfunction
diff --git a/scripts/statistics/distributions/geometric_inv.m b/scripts/statistics/distributions/geometric_inv.m
--- a/scripts/statistics/distributions/geometric_inv.m
+++ b/scripts/statistics/distributions/geometric_inv.m
@@ -1,61 +1,61 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  geometric_inv (x, p)
 ##
 ## For each element of x, compute the quantile at x of the geometric
 ## distribution with parameter p.
 
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  Quantile function of the geometric distribution
 
 function inv = geometric_inv (x, p)
-  
+
   if (nargin != 2)
     usage ("geometric_inv (x, p)");
   endif
 
   [retval, x, p] = common_size (x, p);
   if (retval > 0)
     error (["geometric_inv:  ", ...
-	    "x and p must be of common size or scalar"]);
+            "x and p must be of common size or scalar"]);
   endif
-  
+
   [r, c] = size (x);
   s = r * c;
   x   = reshape (x, 1, s);
   p   = reshape (p, 1, s);
   inv = zeros (1, s);
 
   k = find (!(x >= 0) | !(x <= 1) | !(p >= 0) | !(p <= 1));
   if any (k)
     inv(k) = NaN * ones (1, length (k));
   endif
-  
+
   k = find ((x == 1) & (p >= 0) & (p <= 1));
   if any (k)
     inv(k) = Inf * ones (1, length (k));
   endif
-  
+
   k = find ((x > 0) & (x < 1) & (p > 0) & (p <= 1));
   if any (k)
     inv(k) = max (ceil (log (1 - x(k)) ./ log (1 - p(k))) - 1, ...
-	zeros (1, length (k)));
+        zeros (1, length (k)));
   endif
- 
+
   inv = reshape (inv, r, c);
-  
+
 endfunction
diff --git a/scripts/statistics/distributions/geometric_pdf.m b/scripts/statistics/distributions/geometric_pdf.m
--- a/scripts/statistics/distributions/geometric_pdf.m
+++ b/scripts/statistics/distributions/geometric_pdf.m
@@ -1,62 +1,62 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  geometric_pdf (x, p)
 ##
 ## For each element of x, compute the probability density function (PDF)
 ## at x of the geometric distribution with parameter p.
 
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  PDF of the geometric distribution
 
 function pdf = geometric_pdf (x, p)
-  
+
   if (nargin != 2)
     usage ("geometric_pdf (x, p)");
   endif
 
   [retval, x, p] = common_size (x, p);
   if (retval > 0)
     error (["geometric_pdf:  ", ...
-	    "x and p must be of common size or scalar"]);
+            "x and p must be of common size or scalar"]);
   endif
-  
+
   [r, c] = size (x);
   s = r * c;
   x   = reshape (x, 1, s);
   p   = reshape (p, 1, s);
   cdf = zeros (1, s);
 
   k = find (isnan (x) | !(p >= 0) | !(p <= 1));
   if any (k)
     pdf(k) = NaN * ones (1, length (k));
   endif
-  
+
   ## Just for the fun of it ...
   k = find ((x == Inf) & (p == 0));
   if any (k)
     pdf(k) = ones (1, length (k));
   endif
-  
+
   k = find ((x >= 0) & (x < Inf) & (x == round (x)) ...
       & (p > 0) & (p <= 1));
   if any (k)
     pdf(k) = p(k) .* ((1 - p(k)) .^ x(k));
   endif
- 
+
   pdf = reshape (pdf, r, c);
-  
+
 endfunction
diff --git a/scripts/statistics/distributions/geometric_rnd.m b/scripts/statistics/distributions/geometric_rnd.m
--- a/scripts/statistics/distributions/geometric_rnd.m
+++ b/scripts/statistics/distributions/geometric_rnd.m
@@ -1,71 +1,71 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  geometric_rnd (p [, r, c])
 ##
 ## geometric_rnd (p) returns a matrix of random samples from the
 ## geometric distribution with parameter p.  The size of the matrix is
 ## the size of p.
 ##
 ## geometric_rnd (p, r, c) returns an r by c matrix of random samples
 ## from the geometric distribution with parameter p, which must be a
 ## scalar or of size r by c.
-  
+
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  Random deviates from the geometric distribution
-  
+
 function rnd = geometric_rnd (p, r, c)
 
   if (nargin == 3)
     if ( !(is_scalar (r) && (r > 0) && (r == round (r))) )
       error ("geometric_rnd:  r must be a positive integer");
     endif
     if ( !(is_scalar (c) && (c > 0) && (c == round (c))) )
       error ("geometric_rnd:  c must be a positive integer");
     endif
     [retval, p] = common_size (p, zeros (r, c));
     if (retval > 0)
       error (strcat("geometric_rnd:  ",
-		    "p must be scalar or of size ",
-		    sprintf ("%d by %d", r, c)));
+                    "p must be scalar or of size ",
+                    sprintf ("%d by %d", r, c)));
     endif
   elseif (nargin != 1)
     usage ("geometric_rnd (p [, r, c])");
   endif
-  
+
   [r, c] = size (p);
   s = r * c;
   p = reshape (p, 1, s);
   rnd = zeros (1, s);
-  
+
   k = find (!(p >= 0) | !(p <= 1));
   if (any (k))
     rnd(k) = NaN * ones (1, length (k));
   endif
-  
+
   k = find (p == 0);
   if (any (k))
     rnd(k) = Inf * ones (1, length (k));
   endif
-  
+
   k = find ((p > 0) & (p < 1));
   if (any (k))
     rnd(k) = floor (log (rand (1, length (k))) ./ log (1 - p(k)));
   endif
-  
+
   rnd = reshape (rnd, r, c);
-  
+
 endfunction
diff --git a/scripts/statistics/distributions/hypergeometric_cdf.m b/scripts/statistics/distributions/hypergeometric_cdf.m
--- a/scripts/statistics/distributions/hypergeometric_cdf.m
+++ b/scripts/statistics/distributions/hypergeometric_cdf.m
@@ -1,20 +1,20 @@
 ## Copyright (C) 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## Compute the cumulative distribution function (CDF) at x of the
 ## hypergeometric distribution with parameters m, t, and n.  This is the
 ## probability of obtaining not more than x marked items when randomly
 ## drawing a sample of size n without replacement from a population of
@@ -27,19 +27,18 @@
 ## Description:  CDF of the hypergeometric distribution
 
 function cdf = hypergeometric_cdf (x, m, t, n)
 
   if (nargin != 4)
     usage ("hypergeometrix_cdf (x, m, t, n)");
   endif
 
-  if ((m < 0) | (t < 0) | (n <= 0) | (m != round (m)) | 
+  if ((m < 0) | (t < 0) | (n <= 0) | (m != round (m)) |
       (t != round (t)) | (n != round (n)) | (m > t) | (n > t))
     cdf = NaN * ones (size (x))
   else
     cdf = discrete_cdf (x, 0 : n, hypergeometric_pdf (0 : n, m, t, n));
   endif
 
 endfunction
-  
 
-  
\ No newline at end of file
+
diff --git a/scripts/statistics/distributions/hypergeometric_inv.m b/scripts/statistics/distributions/hypergeometric_inv.m
--- a/scripts/statistics/distributions/hypergeometric_inv.m
+++ b/scripts/statistics/distributions/hypergeometric_inv.m
@@ -1,20 +1,20 @@
 ## Copyright (C) 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## For each element of x, compute the quantile at x of the hypergeometric
 ## distribution with parameters m, t, and n.
 ##
 ## The parameters m, t, and n must positive integers with m and n not
@@ -24,16 +24,16 @@
 ## Description:  Random deviates from the hypergeometric distribution
 
 function inv = hypergeometric_inv (x, m, t, n)
 
   if (nargin != 4)
     usage ("hypergeometric_inv (x, m, t, n)");
   endif
 
-  if ((m < 0) | (t < 0) | (n <= 0) | (m != round (m)) | 
+  if ((m < 0) | (t < 0) | (n <= 0) | (m != round (m)) |
       (t != round (t)) | (n != round (n)) | (m > t) | (n > t))
     inv = NaN * ones (size (x))
   else
     inv = discrete_inv (x, 0 : n, hypergeometric_pdf (0 : n, m, t, n));
   endif
 
 endfunction
diff --git a/scripts/statistics/distributions/hypergeometric_pdf.m b/scripts/statistics/distributions/hypergeometric_pdf.m
--- a/scripts/statistics/distributions/hypergeometric_pdf.m
+++ b/scripts/statistics/distributions/hypergeometric_pdf.m
@@ -1,64 +1,64 @@
 ## Copyright (C) 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  hypergeometric_pdf (x, m, t, n)
 ##
 ## Compute the probability density function (PDF) at x of the
 ## hypergeometric distribution with parameters m, t, and n. This is the
 ## probability of obtaining x marked items when randomly drawing a
 ## sample of size n without replacement from a population of total size
 ## t containing m marked items.
 ##
 ## The arguments must be of common size or scalar.
 
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  PDF of the hypergeometric distribution
-  
+
 function pdf = hypergeometric_pdf (x, m, t, n)
-  
+
   if (nargin != 4)
     usage ("hypergeometric_pdf (x, m, t, n)");
   endif
-  
+
   [retval, x, m, t, n] = common_size (x, m, t, n);
   if (retval > 0)
     error (["hypergeometric_pdf:  ", ...
-	    "x, m, t, and n must be of common size or scalar"]);
+            "x, m, t, and n must be of common size or scalar"]);
   endif
-  
+
   [r, c] = size (x);
   s = r * c;
   x = reshape (x, 1, s);
   m = reshape (m, 1, s);
   t = reshape (t, 1, s);
   n = reshape (n, 1, s);
   pdf = zeros * ones (1, s);
   ## everything in i1 gives NaN
-  i1 = ((m < 0) | (t < 0) | (n <= 0) | (m != round (m)) | 
-	(t != round (t)) | (n != round (n)) | (m > t) | (n > t));
+  i1 = ((m < 0) | (t < 0) | (n <= 0) | (m != round (m)) |
+        (t != round (t)) | (n != round (n)) | (m > t) | (n > t));
   ## everything in i2 gives 0 unless in i1
   i2 = ((x != round (x)) | (x < 0) | (x > m) | (n < x) | (n-x > t-m));
   k = find (i1);
   if any (k)
     pdf (k) = NaN * ones (size (k));
   endif
   k = find (!i1 & !i2);
   if any (k)
     pdf (k) = (bincoeff (m(k), x(k)) .* bincoeff (t(k)-m(k), n(k)-x(k))
-	       ./ bincoeff (t(k), n(k)));
+               ./ bincoeff (t(k), n(k)));
   endif
-  
+
 endfunction
diff --git a/scripts/statistics/distributions/hypergeometric_rnd.m b/scripts/statistics/distributions/hypergeometric_rnd.m
--- a/scripts/statistics/distributions/hypergeometric_rnd.m
+++ b/scripts/statistics/distributions/hypergeometric_rnd.m
@@ -1,36 +1,36 @@
 ## Copyright (C) 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## Generate a row vector containing a random sample of size N from the
 ## hypergeometric distribution with parameters m, t, and n.
 ##
 ## The parameters m, t, and n must positive integers with m and n not
 ## greater than t.
 
 function rnd = hypergeometric_rnd (N, m, t, n)
 
   if (nargin != 4)
     usage ("hypergeometric_rnd (N, m, t, n)");
   endif
 
-  if ((m < 0) | (t < 0) | (n <= 0) | (m != round (m)) | 
+  if ((m < 0) | (t < 0) | (n <= 0) | (m != round (m)) |
       (t != round (t)) | (n != round (n)) | (m > t) | (n > t))
     rnd = NaN * ones (1, N)
   else
     rnd = discrete_rnd (N, 0 : n, hypergeometric_pdf (0 : n, m, t, n));
   endif
 
 endfunction
diff --git a/scripts/statistics/distributions/kolmogorov_smirnov_cdf.m b/scripts/statistics/distributions/kolmogorov_smirnov_cdf.m
--- a/scripts/statistics/distributions/kolmogorov_smirnov_cdf.m
+++ b/scripts/statistics/distributions/kolmogorov_smirnov_cdf.m
@@ -1,47 +1,47 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  kolmogorov_smirnov_cdf (x [, tol])
 ##
 ## Returns the CDF at x of the Kolmogorov-Smirnov distribution,
 ## i.e. Q(x) = sum_{k=-\infty}^\infty (-1)^k exp(-2 k^2 x^2), x > 0.
 ##
 ## The optional tol specifies the precision up to which the series
 ## should be evaluated;  the default is tol = eps.
-  
+
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  CDF of the Kolmogorov-Smirnov distribution
 
 function cdf = kolmogorov_smirnov_cdf (x, tol)
-  
+
   if (nargin < 1 || nargin > 2)
     usage ("kolmogorov_smirnov_cdf (x [, tol])");
   endif
 
   if (nargin == 1)
     tol = eps;
-  else 
+  else
     if (!is_scalar (tol) || !(tol > 0))
       error (["kolmogorov_smirnov_cdf:  ", ...
-	      "tol has to be a positive scalar."]);
+              "tol has to be a positive scalar."]);
     endif
   endif
 
   [nr, nc] = size(x);
   if (min (nr, nc) == 0)
     error ("kolmogorov_smirnov_cdf:  x must not be empty.");
   endif
 
@@ -55,10 +55,10 @@ function cdf = kolmogorov_smirnov_cdf (x
     k   = (1:K)';
     A   = exp( - 2 * k.^2 * y.^2 );
     odd = find (rem (k, 2) == 1);
     A(odd, :) = -A(odd, :);
     cdf(ind) = 1 + 2 * sum (A);
   endif
 
   cdf = reshape (cdf, nr, nc);
-  
+
 endfunction
diff --git a/scripts/statistics/distributions/laplace_cdf.m b/scripts/statistics/distributions/laplace_cdf.m
--- a/scripts/statistics/distributions/laplace_cdf.m
+++ b/scripts/statistics/distributions/laplace_cdf.m
@@ -1,20 +1,20 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  laplace_cdf (x)
 ##
 ## For each element of x, compute the cumulative distribution function
 ## (CDF) at x of the Laplace distribution.
@@ -32,22 +32,22 @@ function cdf = laplace_cdf (x)
   s = r * c;
   x = reshape (x, 1, s);
   cdf = zeros (1, s);
 
   k = find (isnan (x));
   if any (k)
     cdf(k) = NaN * ones (1, length (k));
   endif
-  
+
   k = find (x == Inf);
   if any (k)
     cdf(k) = ones (1, length (k));
   endif
-  
+
   k = find ((x > -Inf) & (x < Inf));
   if any (k)
     cdf(k) = (1 + sign (x(k)) .* (1 - exp (- abs (x(k))))) / 2;
   endif
 
   cdf = reshape (cdf, r, c);
-  
+
 endfunction
\ No newline at end of file
diff --git a/scripts/statistics/distributions/laplace_inv.m b/scripts/statistics/distributions/laplace_inv.m
--- a/scripts/statistics/distributions/laplace_inv.m
+++ b/scripts/statistics/distributions/laplace_inv.m
@@ -1,20 +1,20 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  laplace_inv (x)
 ##
 ## For each element of x, compute the quantile (the inverse of the CDF)
 ## at x of the Laplace distribution.
@@ -32,23 +32,23 @@ function inv = laplace_inv (x)
   s = r * c;
   x = reshape (x, 1, s);
   inv = (-Inf) * ones (1, s);
 
   k = find (isnan (x) | (x < 0) | (x > 1));
   if any (k)
     inv(k) = NaN * ones (1, length (k));
   endif
-  
+
   k = find (x == 1);
   if any (k)
     inv(k) = Inf * ones (1, length (k));
   endif
-  
+
   k = find ((x > 0) & (x < 1));
   if any (k)
     inv(k) = (x(k) < 1/2) .* log (2 * x(k)) ...
-	- (x(k) > 1/2) .* log (2 * (1 - x(k)));
+        - (x(k) > 1/2) .* log (2 * (1 - x(k)));
   endif
 
   inv = reshape (inv, r, c);
-  
+
 endfunction
\ No newline at end of file
diff --git a/scripts/statistics/distributions/laplace_pdf.m b/scripts/statistics/distributions/laplace_pdf.m
--- a/scripts/statistics/distributions/laplace_pdf.m
+++ b/scripts/statistics/distributions/laplace_pdf.m
@@ -1,20 +1,20 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  laplace_pdf (x)
 ##
 ## For each element of x, compute the probability density function (PDF)
 ## at x of the Laplace distribution.
@@ -32,17 +32,17 @@ function pdf = laplace_pdf (x)
   s = r * c;
   x = reshape (x, 1, s);
   pdf = zeros (1, s);
 
   k = find (isnan (x));
   if any (k)
     pdf(k) = NaN * ones (1, length (k));
   endif
-  
+
   k = find ((x > -Inf) & (x < Inf));
   if any (k)
     pdf(k) = exp (- abs (x(k))) / 2;
   endif
 
   pdf = reshape (pdf, r, c);
-  
+
 endfunction
\ No newline at end of file
diff --git a/scripts/statistics/distributions/laplace_rnd.m b/scripts/statistics/distributions/laplace_rnd.m
--- a/scripts/statistics/distributions/laplace_rnd.m
+++ b/scripts/statistics/distributions/laplace_rnd.m
@@ -1,42 +1,42 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  laplace_rnd (r, c)
 ##
 ## Return an r by c matrix of random numbers from the Laplace
 ## distribution.
-  
+
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  Random deviates from the Laplace distribution
 
 function rnd = laplace_rnd (r, c)
-  
+
   if (nargin != 2)
     usage ("laplace_rnd (r, c)");
   endif
 
   if ( !(is_scalar (r) && (r > 0) && (r == round (r))) )
     error ("laplace_rnd:  r must be a positive integer");
   endif
   if ( !(is_scalar (c) && (c > 0) && (c == round (c))) )
     error ("laplace_rnd:  c must be a positive integer");
   endif
 
   tmp = rand (r, c);
-  rnd = ((tmp < 1/2) .* log (2 * tmp) 
-	 - (tmp > 1/2) .* log (2 * (1 - tmp)));
-  
+  rnd = ((tmp < 1/2) .* log (2 * tmp)
+         - (tmp > 1/2) .* log (2 * (1 - tmp)));
+
 endfunction
diff --git a/scripts/statistics/distributions/logistic_cdf.m b/scripts/statistics/distributions/logistic_cdf.m
--- a/scripts/statistics/distributions/logistic_cdf.m
+++ b/scripts/statistics/distributions/logistic_cdf.m
@@ -1,33 +1,33 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  logistic_cdf (x)
 ##
 ## For each component of x, compute the CDF at x of the logistic
 ## distribution.
-  
+
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  CDF of the logistic distribution
 
 function cdf = logistic_cdf (x)
-  
+
   if (nargin != 1)
     usage ("logistic_cdf (x)");
   endif
 
   cdf = 1 ./ (1 + exp (- x));
-  
+
 endfunction
diff --git a/scripts/statistics/distributions/logistic_inv.m b/scripts/statistics/distributions/logistic_inv.m
--- a/scripts/statistics/distributions/logistic_inv.m
+++ b/scripts/statistics/distributions/logistic_inv.m
@@ -1,20 +1,20 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  logistic_inv (x)
 ##
 ## For each component of x, compute the quantile (the inverse of the
 ## CDF) at x of the logistic distribution.
@@ -42,17 +42,17 @@ function inv = logistic_inv (x)
   if any (k)
     inv(k) = (-Inf) * ones (1, length (k));
   endif
 
   k = find (x == 1);
   if any (k)
     inv(k) = Inf * ones (1, length (k));
   endif
-  
+
   k = find ((x > 0) & (x < 1));
   if any (k)
     inv (k) = - log (1 ./ x(k) - 1);
   endif
-  
+
   inv = reshape (inv, r, c);
-  
+
 endfunction
diff --git a/scripts/statistics/distributions/logistic_pdf.m b/scripts/statistics/distributions/logistic_pdf.m
--- a/scripts/statistics/distributions/logistic_pdf.m
+++ b/scripts/statistics/distributions/logistic_pdf.m
@@ -1,34 +1,34 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  logistic_pdf (x)
 ##
 ## For each component of x, compute the PDF at x of the logistic
 ## distribution.
 
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  PDF of the logistic distribution
 
 function pdf = logistic_pdf (x)
-  
+
   if (nargin != 1)
     usage ("logistic_pdf (x)");
   endif
 
   cdf = logistic_cdf (x);
   pdf = cdf .* (1 - cdf);
-  
+
 endfunction
diff --git a/scripts/statistics/distributions/logistic_rnd.m b/scripts/statistics/distributions/logistic_rnd.m
--- a/scripts/statistics/distributions/logistic_rnd.m
+++ b/scripts/statistics/distributions/logistic_rnd.m
@@ -1,40 +1,40 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  logistic_rnd (r, c)
 ##
 ## Return an r by c matrix of random numbers from the logistic
 ## distribution.
-  
+
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  Random deviates from the logistic distribution
 
 function rnd = logistic_rnd (r, c)
-  
+
   if (nargin != 2)
     usage ("logistic_rnd (r, c)");
   endif
 
   if ( !(is_scalar (r) && (r > 0) && (r == round (r))) )
     error ("logistic_rnd:  r must be a positive integer");
   endif
   if ( !(is_scalar (c) && (c > 0) && (c == round (c))) )
     error ("logistic_rnd:  c must be a positive integer");
   endif
 
   rnd = - log (1 ./ rand (r, c) - 1);
-  
+
 endfunction
diff --git a/scripts/statistics/distributions/lognormal_cdf.m b/scripts/statistics/distributions/lognormal_cdf.m
--- a/scripts/statistics/distributions/lognormal_cdf.m
+++ b/scripts/statistics/distributions/lognormal_cdf.m
@@ -1,20 +1,20 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  lognormal_cdf (x [, a, v])
 ##
 ## For each element of x, compute the cumulative distribution function
 ## (CDF) at x of the lognormal distribution with parameters a and v. If
@@ -49,29 +49,29 @@ function cdf = lognormal_cdf (x, a, v)
   endif
 
   [r, c] = size (x);
   s = r * c;
   x = reshape (x, 1, s);
   a = reshape (a, 1, s);
   v = reshape (v, 1, s);
   cdf = zeros (1, s);
-  
+
   k = find (isnan (x) | !(a > 0) | !(a < Inf) ...
       | !(v > 0) | !(v < Inf));
   if any (k)
     cdf(k) = NaN * ones (1, length (k));
   endif
-  
+
   k = find ((x == Inf) & (a > 0) & (a < Inf) & (v > 0) & (v < Inf));
   if any (k)
     cdf(k) = ones (1, length (k));
   endif
-  
+
   k = find ((x > 0) & (x < Inf) & (a > 0) & (a < Inf) ...
       & (v > 0) & (v < Inf));
   if any (k)
     cdf(k) = stdnormal_cdf ((log (x(k)) - log (a(k))) ./ sqrt (v(k)));
   endif
-  
+
   cdf = reshape (cdf, r, c);
-  
+
 endfunction
diff --git a/scripts/statistics/distributions/lognormal_inv.m b/scripts/statistics/distributions/lognormal_inv.m
--- a/scripts/statistics/distributions/lognormal_inv.m
+++ b/scripts/statistics/distributions/lognormal_inv.m
@@ -1,20 +1,20 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  lognormal_inv (x [, a, v])
 ##
 ## For each element of x, compute the quantile (the inverse of the CDF)
 ## at x of the lognormal distribution with parameters a and v. If a
@@ -36,42 +36,42 @@ function inv = lognormal_inv (x, a, v)
     a = 1;
     v = 1;
   endif
 
   ## The following "straightforward" implementation unfortunately does
   ## not work (because exp (Inf) -> NaN):
   ## inv = exp (normal_inv (x, log (a), v));
   ## Hence ...
-  
+
   [retval, x, a, v] = common_size (x, a, v);
   if (retval > 0)
     error (["lognormal_inv:  ", ...
-	    "x, a and v must be of common size or scalars"]);
+            "x, a and v must be of common size or scalars"]);
   endif
 
   [r, c] = size (x);
   s = r * c;
   x = reshape (x, 1, s);
   a = reshape (a, 1, s);
   v = reshape (v, 1, s);
   inv = zeros (1, s);
 
   k = find (!(x >= 0) | !(x <= 1) | !(a > 0) | !(a < Inf) ...
-      | !(v > 0) | !(v < Inf)); 
+      | !(v > 0) | !(v < Inf));
   if any (k)
     inv(k) = NaN * ones (1, length (k));
   endif
-  
+
   k = find ((x == 1) & (a > 0) & (a < Inf) & (v > 0) & (v < Inf));
   if any (k)
     inv(k) = Inf * ones (1, length (k));
   endif
-  
+
   k = find ((x > 0) & (x < 1) & (a > 0) & (a < Inf) ...
       & (v > 0) & (v < Inf));
   if any (k)
     inv(k) = a(k) .* exp (sqrt (v(k)) .* stdnormal_inv (x(k)));
   endif
 
   inv = reshape (inv, r, c);
-  
+
 endfunction
diff --git a/scripts/statistics/distributions/lognormal_pdf.m b/scripts/statistics/distributions/lognormal_pdf.m
--- a/scripts/statistics/distributions/lognormal_pdf.m
+++ b/scripts/statistics/distributions/lognormal_pdf.m
@@ -1,33 +1,33 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  lognormal_pdf (x [, a, v])
 ##
 ## For each element of x, compute the probability density function (PDF)
 ## at x of the lognormal distribution with parameters a and v. If a
 ## random variable follows this distribution, its logarithm is normally
 ## distributed with mean log (a) and variance v.
 ##
 ## Default values are a = 1, v = 1.
-  
+
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  PDF of the log normal distribution
 
 function pdf = lognormal_pdf (x, a, v)
 
   if !((nargin == 1) || (nargin == 3))
     usage ("lognormal_pdf (x [, a, v])");
   endif
@@ -36,37 +36,37 @@ function pdf = lognormal_pdf (x, a, v)
     a = 1;
     v = 1;
   endif
 
   ## The following "straightforward" implementation unfortunately does
   ## not work for the special cases (Inf, ...)
   ## pdf = (x > 0) ./ x .* normal_pdf (log (x), log (a), v);
   ## Hence ...
-  
+
   [retval, x, a, v] = common_size (x, a, v);
   if (retval > 0)
     error (["lognormal_pdf:  ", ...
-	    "x, a and v must be of common size or scalars"]);
+            "x, a and v must be of common size or scalars"]);
   endif
-  
+
   [r, c] = size (x);
   s = r * c;
   x = reshape (x, 1, s);
   a = reshape (a, 1, s);
   v = reshape (v, 1, s);
   pdf = zeros (1, s);
 
   k = find (isnan (x) | !(a > 0) | !(a < Inf) ...
-      | !(v > 0) | !(v < Inf)); 
+      | !(v > 0) | !(v < Inf));
   if any (k)
     pdf(k) = NaN * ones (1, length (k));
   endif
-  
+
   k = find ((x > 0) & (x < Inf) & (a > 0) & (a < Inf) ...
       & (v > 0) & (v < Inf));
   if any (k)
     pdf(k) = normal_pdf (log (x(k)), log (a(k)), v(k)) ./ x(k);
   endif
 
   pdf = reshape (pdf, r, c);
-  
+
 endfunction
diff --git a/scripts/statistics/distributions/lognormal_rnd.m b/scripts/statistics/distributions/lognormal_rnd.m
--- a/scripts/statistics/distributions/lognormal_rnd.m
+++ b/scripts/statistics/distributions/lognormal_rnd.m
@@ -1,73 +1,73 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  lognormal_rnd (a, v [, r, c])
 ##
 ## lognormal_rnd (a, v) returns a matrix of random samples from the
 ## lognormal distribution with parameters a and v.  The size of the
 ## matrix is the common size of a and v.
 ##
 ## lognormal_rnd (a, v, r, c) returns an r by c matrix of random samples
 ## from the lognormal distribution with parameters a and v. Both a and v
 ## must be scalar or of size r by c.
-  
+
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  Random deviates from the log normal distribution
-  
+
 function rnd = lognormal_rnd (a, v, r, c)
 
   if (nargin == 4)
     if ( !(is_scalar (r) && (r > 0) && (r == round (r))) )
       error ("lognormal_rnd:  r must be a positive integer");
     endif
     if ( !(is_scalar (c) && (c > 0) && (c == round (c))) )
       error ("lognormal_rnd:  c must be a positive integer");
     endif
     [retval, a, v] = common_size (a, v, zeros (r, c));
     if (retval > 0)
       error (strcat("lognormal_rnd:  ",
-		    "a and v must be scalar or of size ",
-		    sprintf ("%d by %d", r, c)));
+                    "a and v must be scalar or of size ",
+                    sprintf ("%d by %d", r, c)));
     endif
   elseif (nargin == 2)
     [retval, a, v] = common_size (a, v);
     if (retval > 0)
       error (strcat("lognormal_rnd:  ",
-		    "a and v must be of common size or scalar"));
+                    "a and v must be of common size or scalar"));
     endif
   else
     usage ("lognormal_rnd (a, v [, r, c])");
   endif
 
   [r, c] = size (a);
   s = r * c;
   a = reshape (a, 1, s);
   v = reshape (v, 1, s);
   rnd = zeros (1, s);
-  
+
   k = find (!(a > 0) | !(a < Inf) | !(v > 0) | !(v < Inf));
   if any (k)
     rnd(k) = NaN * ones (1, length (k));
   endif
-  
+
   k = find ((a > 0) & (a < Inf) & (v > 0) & (v < Inf));
   if any (k)
     rnd(k) = a(k) .* exp (sqrt (v(k)) .* randn (1, length (k)));
   endif
-  
+
   rnd = reshape (rnd, r, c);
-  
+
 endfunction
\ No newline at end of file
diff --git a/scripts/statistics/distributions/normal_cdf.m b/scripts/statistics/distributions/normal_cdf.m
--- a/scripts/statistics/distributions/normal_cdf.m
+++ b/scripts/statistics/distributions/normal_cdf.m
@@ -1,31 +1,31 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  normal_cdf (x [, m, v])
 ##
 ## For each element of x, compute the cumulative distribution function
 ## (CDF) at x of the normal distribution with mean m and variance v.
 ##
 ## Default values are m = 0, v = 1.
-  
+
 ## Author:  TT <Teresa.Twaroch@ci.tuwien.ac.at>
 ## Description:  CDF of the normal distribution
 
 function cdf = normal_cdf (x, m, v)
 
   if !((nargin == 1) || (nargin == 3))
     usage ("normal_cdf (x [, m, v])");
   endif
@@ -33,31 +33,31 @@ function cdf = normal_cdf (x, m, v)
   if (nargin == 1)
     m = 0;
     v = 1;
   endif
 
   [retval, x, m, v] = common_size (x, m, v);
   if (retval > 0)
     error (["normal_cdf:  ", ...
-	    "x, m and v must be of common size or scalars"]);
+            "x, m and v must be of common size or scalars"]);
   endif
 
   [r, c] = size (x);
   s = r * c;
   x = reshape (x, 1, s);
   m = reshape (m, 1, s);
   v = reshape (v, 1, s);
   cdf = zeros (1, s);
 
   k = find (isinf (m) | isnan (m) | !(v >= 0) | !(v < Inf));
   if any (k)
     cdf(k) = NaN * ones (1, length (k));
   endif
-  
+
   k = find (!isinf (m) & !isnan (m) & (v > 0) & (v < Inf));
   if any (k)
     cdf(k) = stdnormal_cdf ((x(k) - m(k)) ./ sqrt (v(k)));
   endif
 
   cdf = reshape (cdf, r, c);
-  
+
 endfunction
diff --git a/scripts/statistics/distributions/normal_inv.m b/scripts/statistics/distributions/normal_inv.m
--- a/scripts/statistics/distributions/normal_inv.m
+++ b/scripts/statistics/distributions/normal_inv.m
@@ -1,31 +1,31 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  normal_inv (x [, m, v])
 ##
 ## For each element of x, compute the quantile (the inverse of the CDF)
 ## at x of the normal distribution with mean m and variance v.
 ##
 ## Default values are m = 0, v = 1.
-  
+
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  Quantile function of the normal distribution
 
 function inv = normal_inv (x, m, v)
 
   if !((nargin == 1) || (nargin == 3))
     usage ("normal_inv (x [, m, v])");
   endif
@@ -33,31 +33,31 @@ function inv = normal_inv (x, m, v)
   if (nargin == 1)
     m = 0;
     v = 1;
   endif
 
   [retval, x, m, v] = common_size (x, m, v);
   if (retval > 0)
     error (["normal_inv:  ", ...
-	    "x, m and v must be of common size or scalars"]);
+            "x, m and v must be of common size or scalars"]);
   endif
 
   [r, c] = size (x);
   s = r * c;
   x = reshape (x, 1, s);
   m = reshape (m, 1, s);
   v = reshape (v, 1, s);
   inv = zeros (1, s);
 
   k = find (isinf (m) | isnan (m) | !(v >= 0) | !(v < Inf));
   if any (k)
     inv(k) = NaN * ones (1, length (k));
   endif
-  
+
   k = find (!isinf (m) & !isnan (m) & (v > 0) & (v < Inf));
   if any (k)
     inv(k) = m(k) + sqrt (v(k)) .* stdnormal_inv (x(k));
   endif
 
   inv = reshape (inv, r, c);
-  
+
 endfunction
diff --git a/scripts/statistics/distributions/normal_pdf.m b/scripts/statistics/distributions/normal_pdf.m
--- a/scripts/statistics/distributions/normal_pdf.m
+++ b/scripts/statistics/distributions/normal_pdf.m
@@ -1,31 +1,31 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  normal_pdf (x [, m, v])
 ##
 ## For each element of x, compute the probability density function (PDF)
 ## at x of the normal distribution with mean m and variance v.
 ##
 ## Default values are m = 0, v = 1.
-  
+
 ## Author:  TT <Teresa.Twaroch@ci.tuwien.ac.at>
 ## Description:  PDF of the normal distribution
 
 function pdf = normal_pdf (x, m, v)
 
   if !((nargin == 1) || (nargin == 3))
     usage ("normal_pdf (x [, m, v])");
   endif
@@ -33,32 +33,32 @@ function pdf = normal_pdf (x, m, v)
   if (nargin == 1)
     m = 0;
     v = 1;
   endif
 
   [retval, x, m, v] = common_size (x, m, v);
   if (retval > 0)
     error (["normal_pdf:  ", ...
-	    "x, m and v must be of common size or scalars"]);
+            "x, m and v must be of common size or scalars"]);
   endif
 
   [r, c] = size (x);
   s = r * c;
   x = reshape (x, 1, s);
   m = reshape (m, 1, s);
   v = reshape (v, 1, s);
   pdf = zeros (1, s);
 
   k = find (isinf (m) | isnan (m) | !(v >= 0) | !(v < Inf));
   if any (k)
     pdf(k) = NaN * ones (1, length (k));
   endif
-  
+
   k = find (!isinf (m) & !isnan (m) & (v > 0) & (v < Inf));
   if any (k)
     pdf(k) = stdnormal_pdf ((x(k) - m(k)) ./ sqrt (v(k))) ...
-	./ sqrt (v(k)); 
+        ./ sqrt (v(k));
   endif
 
   pdf = reshape (pdf, r, c);
-  
+
 endfunction
diff --git a/scripts/statistics/distributions/normal_rnd.m b/scripts/statistics/distributions/normal_rnd.m
--- a/scripts/statistics/distributions/normal_rnd.m
+++ b/scripts/statistics/distributions/normal_rnd.m
@@ -1,20 +1,20 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  normal_rnd (m, v [, r, c])
 ##
 ## normal_rnd (m, v) returns a matrix of random samples from the normal
 ## distribution with parameters m and v.  The size of the matrix is the
@@ -34,39 +34,39 @@ function rnd = normal_rnd (m, v, r, c)
       error ("normal_rnd:  r must be a positive integer");
     endif
     if ( !(is_scalar (c) && (c > 0) && (c == round (c))) )
       error ("normal_rnd:  c must be a positive integer");
     endif
     [retval, m, v] = common_size (m, v, zeros (r, c));
     if (retval > 0)
       error (strcat("normal_rnd:  ",
-		    "m and v must be scalar or of size ",
-		    sprintf ("%d by %d", r, c)));
+                    "m and v must be scalar or of size ",
+                    sprintf ("%d by %d", r, c)));
     endif
   elseif (nargin == 2)
     [retval, m, v] = common_size (m, v);
     if (retval > 0)
       error ("normal_rnd:  m and v must be of common size or scalar");
     endif
   else
     usage ("normal_rnd (m, v [, r, c])");
   endif
 
   [r, c] = size (m);
   s = r * c;
   m = reshape (m, 1, s);
   v = reshape (v, 1, s);
   rnd = zeros (1, s);
-  
+
   k = find (isnan (m) | isinf (m) | !(v > 0) | !(v < Inf));
   if any (k)
     rnd(k) = NaN * ones (1, length (k));
   endif
-  
+
   k = find ((m > -Inf) & (m < Inf) & (v > 0) & (v < Inf));
   if any (k)
     rnd(k) = m(k) + sqrt (v(k)) .* randn (1, length (k));
   endif
-  
+
   rnd = reshape (rnd, r, c);
-  
+
 endfunction
\ No newline at end of file
diff --git a/scripts/statistics/distributions/pascal_cdf.m b/scripts/statistics/distributions/pascal_cdf.m
--- a/scripts/statistics/distributions/pascal_cdf.m
+++ b/scripts/statistics/distributions/pascal_cdf.m
@@ -1,82 +1,82 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  pascal_cdf (x, n, p)
 ##
 ## For each element of x, compute the CDF at x of the Pascal (negative
 ## binomial) distribution with parameters n and p.
 ##
 ## The number of failures in a Bernoulli experiment with success
 ## probability p before the n-th success follows this distribution.
 
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  CDF of the Pascal (negative binomial) distribution
 
 function cdf = pascal_cdf (x, n, p)
-  
+
   if (nargin != 3)
     usage ("pascal_cdf (x, n, p)");
   endif
 
   [retval, x, n, p] = common_size (x, n, p);
   if (retval > 0)
     error (["pascal_cdf:  ", ...
-	    "x, n and p must be of common size or scalar"]);
+            "x, n and p must be of common size or scalar"]);
   endif
-  
+
   [r, c] = size (x);
   s = r * c;
   x   = reshape (x, 1, s);
   n   = reshape (n, 1, s);
   p   = reshape (p, 1, s);
   cdf = zeros (1, s);
 
   k = find (isnan (x) | (n < 1) | (n == Inf) | (n != round (n)) ...
       | (p < 0) | (p > 1));
   if any (k)
     cdf(k) = NaN * ones (1, length (k));
   endif
-  
+
   k = find ((x == Inf) & (n > 0) & (n < Inf) & (n == round (n)) ...
       & (p >= 0) & (p <= 1));
   if any (k)
     cdf(k) = ones (1, length (k));
   endif
-  
+
   k = find ((x >= 0) & (x < Inf) & (x == round (x)) & (n > 0) ...
       & (n < Inf) & (n == round (n)) & (p > 0) & (p <= 1));
   if any (k)
     ## Does anyone know a better way to do the summation?
     m = zeros (1, length (k));
     x = floor (x(k));
     n = n(k);
     p = p(k);
     y = cdf(k);
     while (1)
       l = find (m <= x);
       if any (l)
-	y(l) = y(l) + pascal_pdf (m(l), n(l), p(l));
-	m(l) = m(l) + 1;
+        y(l) = y(l) + pascal_pdf (m(l), n(l), p(l));
+        m(l) = m(l) + 1;
       else
-	break;
+        break;
       endif
     endwhile
     cdf(k) = y;
   endif
- 
+
   cdf = reshape (cdf, r, c);
-  
+
 endfunction
diff --git a/scripts/statistics/distributions/pascal_inv.m b/scripts/statistics/distributions/pascal_inv.m
--- a/scripts/statistics/distributions/pascal_inv.m
+++ b/scripts/statistics/distributions/pascal_inv.m
@@ -1,81 +1,81 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  pascal_inv (x, n, p)
 ##
 ## For each element of x, compute the quantile at x of the Pascal
 ## (negative binomial) distribution with parameters n and p.
 ##
 ## The number of failures in a Bernoulli experiment with success
 ## probability p before the n-th success follows this distribution.
 
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  Quantile function of the Pascal distribution
 
 function inv = pascal_inv (x, n, p)
-  
+
   if (nargin != 3)
     usage ("pascal_inv (x, n, p)");
   endif
 
   [retval, x, n, p] = common_size (x, n, p);
   if (retval > 0)
     error (["pascal_inv:  ", ...
-	    "x, n and p must be of common size or scalar"]);
+            "x, n and p must be of common size or scalar"]);
   endif
-  
+
   [r, c] = size (x);
   s = r * c;
   x   = reshape (x, 1, s);
   n   = reshape (n, 1, s);
   p   = reshape (p, 1, s);
   inv = zeros (1, s);
 
   k = find (isnan (x) | (x < 0) | (x > 1) | (n < 1) | (n == Inf) ...
       | (n != round (n)) | (p < 0) | (p > 1));
   if any (k)
     inv(k) = NaN * ones (1, length (k));
   endif
-  
+
   k = find ((x == 1) & (n > 0) & (n < Inf) & (n == round (n)) ...
       & (p >= 0) & (p <= 1));
   if any (k)
     inv(k) = Inf * ones (1, length (k));
   endif
-  
+
   k = find ((x >= 0) & (x < 1) & (n > 0) & (n < Inf) ...
       & (n == round (n)) & (p > 0) & (p <= 1));
   if any (k)
     x = x(k);
     n = n(k);
     p = p(k);
     m = zeros (1, length (k));
     s = p .^ n;
     while (1)
       l = find (s < x);
       if any (l)
-	m(l) = m(l) + 1;
-	s(l) = s(l) + pascal_pdf (m(l), n(l), p(l));
+        m(l) = m(l) + 1;
+        s(l) = s(l) + pascal_pdf (m(l), n(l), p(l));
       else
-	break;
+        break;
       endif
     endwhile
     inv(k) = m;
   endif
- 
+
   inv = reshape (inv, r, c);
-  
+
 endfunction
diff --git a/scripts/statistics/distributions/pascal_pdf.m b/scripts/statistics/distributions/pascal_pdf.m
--- a/scripts/statistics/distributions/pascal_pdf.m
+++ b/scripts/statistics/distributions/pascal_pdf.m
@@ -1,20 +1,20 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  pascal_pdf (x, n, p)
 ##
 ## For each element of x, compute the probability density function (PDF)
 ## at x of the Pascal (negative binomial) distribution with parameters n
@@ -22,49 +22,49 @@
 ##
 ## The number of failures in a Bernoulli experiment with success
 ## probability p before the n-th success follows this distribution.
 
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  PDF of the Pascal (negative binomial) distribution
 
 function pdf = pascal_pdf (x, n, p)
-  
+
   if (nargin != 3)
     usage ("pascal_pdf (x, n, p)");
   endif
 
   [retval, x, n, p] = common_size (x, n, p);
   if (retval > 0)
     error (["pascal_pdf:  ", ...
-	    "x, n and p must be of common size or scalar"]);
+            "x, n and p must be of common size or scalar"]);
   endif
-  
+
   [r, c] = size (x);
   s = r * c;
   x   = reshape (x, 1, s);
   n   = reshape (n, 1, s);
   p   = reshape (p, 1, s);
   cdf = zeros (1, s);
 
   k = find (isnan (x) | (n < 1) | (n == Inf) | (n != round (n)) ...
       | (p < 0) | (p > 1));
   if any (k)
     pdf(k) = NaN * ones (1, length (k));
   endif
-  
+
   ## Just for the fun of it ...
   k = find ((x == Inf) & (n > 0) & (n < Inf) & (n == round (n)) ...
       & (p == 0));
   if any (k)
     pdf(k) = ones (1, length (k));
   endif
-  
+
   k = find ((x >= 0) & (x < Inf) & (x == round (x)) & (n > 0) ...
       & (n < Inf) & (n == round (n)) & (p > 0) & (p <= 1));
   if any (k)
     pdf(k) = bincoeff (-n(k), x(k)) .* (p(k) .^ n(k)) ...
-	.* ((p(k) - 1) .^ x(k));
+        .* ((p(k) - 1) .^ x(k));
   endif
- 
+
   pdf = reshape (pdf, r, c);
-  
+
 endfunction
diff --git a/scripts/statistics/distributions/pascal_rnd.m b/scripts/statistics/distributions/pascal_rnd.m
--- a/scripts/statistics/distributions/pascal_rnd.m
+++ b/scripts/statistics/distributions/pascal_rnd.m
@@ -1,78 +1,78 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  pascal_rnd (n, p [, r, c])
 ##
 ## pascal_rnd (n, p) returns a matrix of random samples from the Pascal
 ## (negative binomial) distribution with parameters n and p. The size of
 ## the matrix is the common size of n and p.
 ##
 ## pascal_rnd (n, p, r, c) returns an r by c matrix of random samples
 ## from the Pascal distribution with parameters n and p. Both n and p
 ## must be scalar or of size r by c.
-  
+
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  Random deviates from the Pascal distribution
-  
+
 function rnd = pascal_rnd (n, p, r, c)
 
   if (nargin == 4)
     if ( !(is_scalar (r) && (r > 0) && (r == round (r))) )
       error ("pascal_rnd:  r must be a positive integer");
     endif
     if ( !(is_scalar (c) && (c > 0) && (c == round (c))) )
       error ("pascal_rnd:  c must be a positive integer");
     endif
     [retval, n, p] = common_size (n, p, zeros (r, c));
     if (retval > 0)
       error (strcat("pascal_rnd:  ",
-		    "n and p must be scalar or of size ",
-		    sprintf ("%d by %d", r, c)));
+                    "n and p must be scalar or of size ",
+                    sprintf ("%d by %d", r, c)));
     endif
   elseif (nargin == 2)
     [retval, n, p] = common_size (n, p);
     if (retval > 0)
       error ("pascal_rnd:  n and p must be of common size or scalar");
     endif
   else
     usage ("pascal_rnd (n, p [, r, c])");
   endif
 
   [r, c] = size (n);
   s = r * c;
   n = reshape (n, 1, s);
   p = reshape (p, 1, s);
   rnd = zeros (1, s);
-  
+
   k = find (!(n > 0) | !(n < Inf) | !(n == round (n)) ...
       | !(p <= 0) | !(p >= 1));
   if (any (k))
     rnd(k) = NaN * ones (1, length (k));
   endif
-  
+
   k = find ((n > 0) & (n < Inf) & (n == round (n)) ...
       & (p >= 0) & (p <= 1));
   if (any (k))
     N = max (n(k));
     L = length (k);
     tmp = floor (log (rand (N, L)) ./ (ones (N, 1) * log (1 - p(k))));
     ind = (1 : N)' * ones (1, L);
     rnd(k) = sum (tmp .* (ind <= ones (N, 1) * n(k)));
   endif
-  
+
   rnd = reshape (rnd, r, c);
-  
+
 endfunction
\ No newline at end of file
diff --git a/scripts/statistics/distributions/poisson_cdf.m b/scripts/statistics/distributions/poisson_cdf.m
--- a/scripts/statistics/distributions/poisson_cdf.m
+++ b/scripts/statistics/distributions/poisson_cdf.m
@@ -1,59 +1,59 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  poisson_cdf (x, lambda)
 ##
 ## For each element of x, compute the cumulative distribution function
 ## (CDF) at x of the Poisson distribution with parameter lambda.
 
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  CDF of the Poisson distribution
 
 function cdf = poisson_cdf (x, l)
-  
+
   if (nargin != 2)
     usage ("poisson_cdf (x, lambda)");
   endif
-  
+
   [retval, x, l] = common_size (x, l);
   if (retval > 0)
     error ("poisson_cdf: x and lambda must be of common size or scalar");
   endif
-  
+
   [r, c] = size (x);
   s = r * c;
   x = reshape (x, 1, s);
   l = reshape (l, 1, s);
   cdf = zeros (1, s);
-  
+
   k = find (isnan (x) | !(l > 0));
   if any (k)
     cdf(k) = NaN * ones (1, length (k));
   endif
-  
+
   k = find ((x == Inf) & (l > 0));
   if any (k)
     cdf(k) = ones (1, length (k));
   endif
-  
+
   k = find ((x >= 0) & (x < Inf) & (l > 0));
   if any (k)
     cdf(k) = 1 - gammai (floor (x(k)) + 1, l(k));
   endif
 
   cdf = reshape (cdf, r, c);
-  
+
 endfunction
diff --git a/scripts/statistics/distributions/poisson_inv.m b/scripts/statistics/distributions/poisson_inv.m
--- a/scripts/statistics/distributions/poisson_inv.m
+++ b/scripts/statistics/distributions/poisson_inv.m
@@ -1,69 +1,69 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  poisson_inv (x, lambda)
 ##
 ## For each component of x, compute the quantile (the inverse of the
 ## CDF) at x of the Poisson distribution with parameter lambda.
 
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  Quantile function of the Poisson distribution
 
 function inv = poisson_inv (x, l)
-  
+
   if (nargin != 2)
     usage ("poisson_inv (x, lambda)");
   endif
 
   [retval, x, l] = common_size (x, l);
   if (retval > 0)
     error (["poisson_inv:  ", ...
-	    "x and lambda must be of common size or scalar"]);
+            "x and lambda must be of common size or scalar"]);
   endif
-  
+
   [r, c] = size (x);
   s = r * c;
   x = reshape (x, 1, s);
   l = reshape (l, 1, s);
   inv = zeros (1, s);
 
   k = find ((x < 0) | (x > 1) | isnan (x) | !(l > 0));
   if any (k)
     inv(k) = NaN * ones (1, length (k));
   endif
 
   k = find ((x == 1) & (l > 0));
   if any (k)
     inv(k) = Inf * ones (1, length (k));
   endif
-  
+
   k = find ((x > 0) & (x < 1) & (l > 0));
   if any (k)
     cdf = exp (-l(k));
     while (1)
       m = find (cdf < x(k));
       if any (m)
-	inv(k(m)) = inv(k(m)) + 1;
-	cdf(m) = cdf(m) + poisson_pdf (inv(k(m)), l(k(m)));
+        inv(k(m)) = inv(k(m)) + 1;
+        cdf(m) = cdf(m) + poisson_pdf (inv(k(m)), l(k(m)));
       else
-	break;
+        break;
       endif
     endwhile
   endif
-    
+
   inv = reshape (inv, r, c);
-  
+
 endfunction
\ No newline at end of file
diff --git a/scripts/statistics/distributions/poisson_pdf.m b/scripts/statistics/distributions/poisson_pdf.m
--- a/scripts/statistics/distributions/poisson_pdf.m
+++ b/scripts/statistics/distributions/poisson_pdf.m
@@ -1,42 +1,42 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  poisson_pdf (x, lambda)
 ##
 ## For each element of x, compute the probability density function (PDF)
 ## at x of the poisson distribution with parameter lambda.
 
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  PDF of the Poisson distribution
 
 function pdf = poisson_pdf (x, l)
-  
+
   if (nargin != 2)
     usage ("poisson_pdf (x, lambda)");
   endif
-  
+
   [retval, x, l] = common_size (x, l);
   if (retval > 0)
     error (["poisson_pdf:  ", ...
-	    "x and lambda must be of common size or scalar"]);
+            "x and lambda must be of common size or scalar"]);
   endif
 
   [r, c] = size (x);
   s = r * c;
   x = reshape (x, 1, s);
   l = reshape (l, 1, s);
   pdf = zeros (1, s);
 
@@ -44,12 +44,12 @@ function pdf = poisson_pdf (x, l)
   if any (k)
     pdf(k) = NaN * ones (1, length (k));
   endif
 
   k = find ((x >= 0) & (x < Inf) & (x == round (x)) & (l > 0));
   if any (k)
     pdf(k) = exp (x(k) .* log (l(k)) - l(k) - lgamma (x(k) + 1));
   endif
-  
+
   pdf = reshape (pdf, r, c);
-  
+
 endfunction
diff --git a/scripts/statistics/distributions/poisson_rnd.m b/scripts/statistics/distributions/poisson_rnd.m
--- a/scripts/statistics/distributions/poisson_rnd.m
+++ b/scripts/statistics/distributions/poisson_rnd.m
@@ -1,80 +1,80 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  poisson_rnd (lambda [, r, c])
 ##
 ## poisson_rnd (lambda) returns a matrix of random samples from the
 ## Poisson distribution with parameter lambda.  The size of the matrix
 ## is the size of lambda.
 ##
 ## poisson_rnd (lambda, r, c) returns an r by c matrix of random samples
 ## from the Poisson distribution with parameter lambda, which must be a
 ## scalar or of size r by c.
-  
+
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  Random deviates from the Poisson distribution
-  
+
 function rnd = poisson_rnd (l, r, c)
 
   if (nargin == 3)
     if ( !(is_scalar (r) && (r > 0) && (r == round (r))) )
       error ("poisson_rnd:  r must be a positive integer");
     endif
     if ( !(is_scalar (c) && (c > 0) && (c == round (c))) )
       error ("poisson_rnd:  c must be a positive integer");
     endif
     [retval, l] = common_size (l, zeros (r, c));
     if (retval > 0)
       error (strcat("poisson_rnd:  ",
-		    "lambda must be scalar or of size ",
-		    sprintf ("%d by %d", r, c)));
+                    "lambda must be scalar or of size ",
+                    sprintf ("%d by %d", r, c)));
     endif
   elseif (nargin != 1)
     usage ("poisson_rnd (lambda [, r, c])");
   endif
-  
+
   [r, c] = size (l);
   s = r * c;
   l = reshape (l, 1, s);
   rnd = zeros (1, s);
-  
+
   k = find (!(l > 0) | !(l < Inf));
   if (any (k))
     rnd(k) = NaN * ones (1, length (k));
   endif
-  
+
   k = find ((l > 0) & (l < Inf));
   if (any (k))
     l = l(k);
     len = length (k);
     num = zeros (1, len);
     sum = - log (1 - rand (1, len)) ./ l;
     while (1)
       ind = find (sum < 1);
       if (any (ind))
-	sum(ind) = (sum(ind)
-		    - log (1 - rand (1, length (ind))) ./ l(ind));
-	num(ind) = num(ind) + 1;
+        sum(ind) = (sum(ind)
+                    - log (1 - rand (1, length (ind))) ./ l(ind));
+        num(ind) = num(ind) + 1;
       else
-	break;
+        break;
       endif
     endwhile
     rnd(k) = num;
   endif
-  
+
   rnd = reshape (rnd, r, c);
-  
+
 endfunction
diff --git a/scripts/statistics/distributions/stdnormal_cdf.m b/scripts/statistics/distributions/stdnormal_cdf.m
--- a/scripts/statistics/distributions/stdnormal_cdf.m
+++ b/scripts/statistics/distributions/stdnormal_cdf.m
@@ -1,42 +1,42 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  stdnormal_cdf (x)
 ##
 ## For each component of x, compute the CDF of the standard normal
 ## distribution at x.
 
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  CDF of the standard normal distribution
 
 function cdf = stdnormal_cdf (x)
-  
+
   if (nargin != 1)
     usage ("stdnormal_cdf (x)");
   endif
 
   [r_x, c_x] = size (x);
   if (r_x * c_x == 0)
     error ("stdnormal_cdf:  x must not be empty.");
   endif
 
-  cdf = ( ones (r_x, c_x) + erf (x / sqrt(2)) ) / 2; 
-  
+  cdf = ( ones (r_x, c_x) + erf (x / sqrt(2)) ) / 2;
+
 endfunction
-  
 
 
 
+
diff --git a/scripts/statistics/distributions/stdnormal_inv.m b/scripts/statistics/distributions/stdnormal_inv.m
--- a/scripts/statistics/distributions/stdnormal_inv.m
+++ b/scripts/statistics/distributions/stdnormal_inv.m
@@ -1,33 +1,33 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  stdnormal_inv (x)
 ##
 ## For each component of x, compute compute the quantile (the inverse of
 ## the CDF) at x of the standard normal distribution.
-  
+
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  Quantile function of the standard normal distribution
-  
+
 function inv = stdnormal_inv (x)
-  
+
   if (nargin != 1)
     usage ("stdnormal_inv (x)");
   endif
-  
+
   inv = sqrt (2) * erfinv (2 * x - 1);
-  
+
 endfunction
diff --git a/scripts/statistics/distributions/stdnormal_pdf.m b/scripts/statistics/distributions/stdnormal_pdf.m
--- a/scripts/statistics/distributions/stdnormal_pdf.m
+++ b/scripts/statistics/distributions/stdnormal_pdf.m
@@ -1,48 +1,48 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  stdnormal_pdf (x)
 ##
 ## For each element of x, compute the probability density function (PDF)
 ## of the standard normal distribution at x.
-  
+
 ## Author:  TT <Teresa.Twaroch@ci.tuwien.ac.at>
 ## Description:  PDF of the standard normal distribution
 
 function pdf = stdnormal_pdf (x)
 
   if (nargin != 1)
     usage ("stdnormal_pdf (x)");
   endif
-  
+
   [r, c] = size (x);
   s = r * c;
   x = reshape (x, 1, s);
   pdf = zeros (1, s);
-  
+
   k = find (isnan (x));
   if any (k)
     pdf(k) = NaN * ones (1, length (k));
   endif
-  
+
   k = find (!isinf (x));
   if any (k)
     pdf (k) = (2 * pi)^(- 1/2) * exp( - x(k) .^ 2 / 2);
   endif
-  
+
   pdf = reshape (pdf, r, c);
-  
+
 endfunction
\ No newline at end of file
diff --git a/scripts/statistics/distributions/stdnormal_rnd.m b/scripts/statistics/distributions/stdnormal_rnd.m
--- a/scripts/statistics/distributions/stdnormal_rnd.m
+++ b/scripts/statistics/distributions/stdnormal_rnd.m
@@ -1,40 +1,40 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  stdnormal_rnd (r, c)
 ##
 ## Return an r by c matrix of random numbers from the standard normal
 ## distribution.
-  
+
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  Random deviates from the standard normal distribution
 
 function rnd = stdnormal_rnd (r, c)
-  
+
   if (nargin != 2)
     usage ("stdnormal_rnd (r, c)");
   endif
 
   if ( !(is_scalar (r) && (r > 0) && (r == round (r))) )
     error ("stdnormal_rnd:  r must be a positive integer");
   endif
   if ( !(is_scalar (c) && (c > 0) && (c == round (c))) )
     error ("stdnormal_rnd:  c must be a positive integer");
   endif
 
   rnd = randn (r, c);
-  
+
 endfunction
diff --git a/scripts/statistics/distributions/t_cdf.m b/scripts/statistics/distributions/t_cdf.m
--- a/scripts/statistics/distributions/t_cdf.m
+++ b/scripts/statistics/distributions/t_cdf.m
@@ -1,54 +1,54 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  t_cdf (x, n)
 ##
 ## For each element of x, compute the CDF at x of the Student (t)
 ## distribution with n degrees of freedom, i.e., PROB( t(n) <= x ).
 
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  CDF of the t distribution
 
 function cdf = t_cdf (x, n)
-  
+
   if (nargin != 2)
     usage ("t_cdf (x, n)");
   endif
 
   [retval, x, n] = common_size (x, n);
   if (retval > 0)
     error ("t_cdf:  x and n must be of common size or scalar");
   endif
-  
+
   [r, c] = size (x);
   s = r * c;
   x = reshape (x, 1, s);
   n = reshape (n, 1, s);
   cdf = zeros (1, s);
-  
+
   k = find (isnan (x) | !(n > 0));
   if any (k)
     cdf(k) = NaN * ones (1, length (k));
   endif
-  
+
   k = find ((x == Inf) & (n > 0));
   if any (k)
     cdf(k) = ones (1, length (k));
   endif
 
   k = find ((x > -Inf) & (x < Inf) & (n > 0));
   if any (k)
     cdf(k) = betai (n(k) / 2, 1 / 2, 1 ./ (1 + x(k) .^ 2 ./ n(k))) / 2;
@@ -57,15 +57,15 @@ function cdf = t_cdf (x, n)
       cdf(k(ind)) = 1 - cdf(k(ind));
     endif
   endif
 
   ## should we really only allow for positive integer n?
   k = find (n != round (n));
   if any (k)
     fprintf (stderr, ...
-	     "WARNING:  n should be positive integer\n");
+             "WARNING:  n should be positive integer\n");
     cdf(k) = NaN * ones (1, length (k));
   endif
 
   cdf = reshape (cdf, r, c);
-  
+
 endfunction
diff --git a/scripts/statistics/distributions/t_inv.m b/scripts/statistics/distributions/t_inv.m
--- a/scripts/statistics/distributions/t_inv.m
+++ b/scripts/statistics/distributions/t_inv.m
@@ -1,20 +1,20 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  t_inv (x, n)
 ##
 ## For each component of x, compute the quantile (the inverse of the
 ## CDF) at x of the t (Student) distribution with parameter n.
@@ -31,17 +31,17 @@ function inv = t_inv (x, n)
   if (nargin != 2)
     usage ("t_inv (x, n)");
   endif
 
   [retval, x, n] = common_size (x, n);
   if (retval > 0)
     error ("t_inv:  x and n must be of common size or scalar");
   endif
-  
+
   [r, c] = size (x);
   s = r * c;
   x = reshape (x, 1, s);
   n = reshape (n, 1, s);
   inv = zeros (1, s);
 
   k = find ((x < 0) | (x > 1) | isnan (x) | !(n > 0));
   if any (k)
@@ -52,32 +52,32 @@ function inv = t_inv (x, n)
   if any (k)
     inv(k) = (-Inf) * ones (1, length (k));
   endif
 
   k = find ((x == 1) & (n > 0));
   if any (k)
     inv(k) = Inf * ones (1, length (k));
   endif
-  
+
   k = find ((x > 0) & (x < 1) & (n > 0) & (n < 10000));
   if any (k)
     inv(k) = sign (x(k) - 1/2) .* sqrt (n(k) .* (1 ...
-	./ beta_inv (2 * min (x(k), 1 - x(k)), n(k) / 2, 1 / 2) - 1));
+        ./ beta_inv (2 * min (x(k), 1 - x(k)), n(k) / 2, 1 / 2) - 1));
   endif
-  
+
   ## For large n, use the quantiles of the standard normal
   k = find ((x > 0) & (x < 1) & (n >= 10000));
   if any (k)
     inv(k) = stdnormal_inv (x(k));
   endif
-    
+
   ## should we really only allow for positive integer n?
   k = find (n != round (n));
   if any (k)
     fprintf (stderr, ...
-	     "WARNING:  n should be positive integer\n");
+             "WARNING:  n should be positive integer\n");
     inv(k) = NaN * ones (1, length (k));
   endif
-  
+
   inv = reshape (inv, r, c);
-  
+
 endfunction
\ No newline at end of file
diff --git a/scripts/statistics/distributions/t_pdf.m b/scripts/statistics/distributions/t_pdf.m
--- a/scripts/statistics/distributions/t_pdf.m
+++ b/scripts/statistics/distributions/t_pdf.m
@@ -1,63 +1,63 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  t_pdf (x, n)
 ##
 ## For each element of x, compute the probability density function (PDF)
 ## at x of the t (Student) distribution with n degrees of freedom.
 
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  PDF of the t distribution
 
 function pdf = t_pdf (x, n)
-  
+
   if (nargin != 2)
     usage ("t_pdf (x, n)");
   endif
 
   [retval, x, n] = common_size (x, n);
   if (retval > 0)
     error ("t_pdf:  x and n must be of common size or scalar");
   endif
-  
+
   [r, c] = size (x);
   s = r * c;
   x = reshape (x, 1, s);
   n = reshape (n, 1, s);
   pdf = zeros (1, s);
 
   k = find (isnan (x) | !(n > 0) | !(n < Inf));
   if any (k)
     pdf(k) = NaN * ones (1, length (k));
   endif
-  
+
   k = find (!isinf (x) & !isnan (x) & (n > 0) & (n < Inf));
   if any (k)
     pdf(k) = exp (- (n(k) + 1) .* log (1 + x(k) .^ 2 ./ n(k)) / 2) ...
       ./ (sqrt (n(k)) .* beta (n(k) / 2, 1 / 2));
   endif
 
   ## should we really only allow for positive integer n?
   k = find (n != round (n));
   if any (k)
     fprintf (stderr, ...
-	"WARNING:  n should be positive integer\n");
+        "WARNING:  n should be positive integer\n");
     pdf(k) = NaN * ones (1, length (k));
   endif
 
   pdf = reshape (pdf, r, c);
 
 endfunction
diff --git a/scripts/statistics/distributions/t_rnd.m b/scripts/statistics/distributions/t_rnd.m
--- a/scripts/statistics/distributions/t_rnd.m
+++ b/scripts/statistics/distributions/t_rnd.m
@@ -1,66 +1,66 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  t_rnd (n [, r, c])
 ##
 ## t_rnd (n) returns a matrix of random samples from the t (Student)
 ## distribution with n degrees of freedom.  The size of the matrix is
 ## the size of n.
 ##
 ## t_rnd (n, r, c) returns an r by c matrix of random samples from the t
 ## distribution with n degrees of freedom.  n must be a scalar or of
 ## size r by c.
-  
+
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  Random deviates from the t distribution
 
 function rnd = t_rnd (n, r, c)
 
   if (nargin == 3)
     if ( !(is_scalar (r) && (r > 0) && (r == round (r))) )
       error ("t_rnd:  r must be a positive integer");
     endif
     if ( !(is_scalar (c) && (c > 0) && (c == round (c))) )
       error ("t_rnd:  c must be a positive integer");
     endif
     [retval, n] = common_size (n, zeros (r, c));
     if (retval > 0)
       error (strcat("t_rnd:  ",
-		    "n must be scalar or of size ",
-		    sprintf ("%d by %d", r, c)));
+                    "n must be scalar or of size ",
+                    sprintf ("%d by %d", r, c)));
     endif
   elseif (nargin != 1)
     usage ("t_rnd (n [, r, c])");
   endif
-  
+
   [r, c] = size (n);
   s = r * c;
   n = reshape (n, 1, s);
   rnd = zeros (1, s);
-  
+
   k = find (!(n > 0) | !(n < Inf) | !(n == round (n)));
   if any (k)
     rnd(k) = NaN * ones (1, length (k));
   endif
-  
+
   k = find ((n > 0) & (n < Inf) & (n == round (n)));
   if any (k)
     rnd(k) = t_inv (rand (1, length (k)), n(k));
   endif
-  
+
   rnd = reshape (rnd, r, c);
-  
+
 endfunction
diff --git a/scripts/statistics/distributions/uniform_cdf.m b/scripts/statistics/distributions/uniform_cdf.m
--- a/scripts/statistics/distributions/uniform_cdf.m
+++ b/scripts/statistics/distributions/uniform_cdf.m
@@ -1,68 +1,68 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  uniform_cdf (x [, a, b])
 ##
 ## Returns the CDF at x of the uniform distribution on [a, b], i.e.,
 ## PROB( uniform(a,b) <= x ).
 ##
 ## Default values are a = 0, b = 1.
-  
+
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  CDF of the uniform distribution
 
 function cdf = uniform_cdf (x, a, b)
-  
+
   if !(nargin == 1 || nargin == 3)
     usage ("uniform_cdf (x [, a, b])");
   endif
 
   if (nargin == 1)
     a = 0;
     b = 1;
   endif
 
   [retval, x, a, b] = common_size (x, a, b);
   if (retval > 0)
     error (["uniform_cdf:  ", ...
-	    "x, a and b must be of common size or scalar"]);
+            "x, a and b must be of common size or scalar"]);
   endif
 
   [r, c] = size (x);
   s = r * c;
   x = reshape (x, 1, s);
   a = reshape (a, 1, s);
   b = reshape (b, 1, s);
   cdf = zeros (1, s);
-  
+
   k = find (isnan (x) | !(a < b));
   if any (k)
     cdf(k) = NaN * ones (1, length (k));
   endif
 
   k = find ((x >= b) & (a < b));
   if any (k)
     cdf(k) = ones (1, length (k));
   endif
-  
+
   k = find ((x > a) & (x < b));
   if any (k)
     cdf(k) = (x(k) < b(k)) .* (x(k) - a(k)) ./ (b(k) - a(k));
   endif
-  
+
   cdf = reshape (cdf, r, c);
-  
+
 endfunction
diff --git a/scripts/statistics/distributions/uniform_inv.m b/scripts/statistics/distributions/uniform_inv.m
--- a/scripts/statistics/distributions/uniform_inv.m
+++ b/scripts/statistics/distributions/uniform_inv.m
@@ -1,62 +1,62 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  uniform_inv (x [, a, b])
 ##
 ## For each element of x, compute the quantile (the inverse of the CDF)
 ## at x of the uniform distribution on [a, b].
 ##
 ## Default values are a = 0, b = 1.
-  
+
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  Quantile function of the uniform distribution
 
 function inv = uniform_inv (x, a, b)
-  
+
   if !(nargin == 1 || nargin == 3)
     usage ("uniform_inv (x [, a, b])");
   endif
 
   if (nargin == 1)
     a = 0;
     b = 1;
   endif
-  
+
   [retval, x, a, b] = common_size (x, a, b);
   if (retval > 0)
     error ("uniform_inv:  x, a and b must be of common size or scalars");
   endif
 
   [r, c] = size (x);
   s   = r * c;
   x   = reshape (x, 1, s);
   a   = reshape (a, 1, s);
   b   = reshape (b, 1, s);
   inv = zeros (1, s);
-  
+
   k = find ((x < 0) | (x > 1) | isnan (x) | !(a < b));
   if any (k)
     inv(k) = NaN * ones (1, length (k));
   endif
-  
+
   k = find ((x >= 0) & (x <= 1) & (a < b));
   if any (k)
     inv(k) = a(k) + x(k) .* (b(k) - a(k));
   endif
 
   inv = reshape (inv, r, c);
-  
+
 endfunction
diff --git a/scripts/statistics/distributions/uniform_pdf.m b/scripts/statistics/distributions/uniform_pdf.m
--- a/scripts/statistics/distributions/uniform_pdf.m
+++ b/scripts/statistics/distributions/uniform_pdf.m
@@ -1,63 +1,63 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  uniform_pdf (x [, a, b])
 ##
 ## For each element of x, compute the PDF at x of the uniform
 ## distribution on [a, b].
 ##
 ## Default values are a = 0, b = 1.
 
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  PDF of the uniform distribution
-  
+
 function pdf = uniform_pdf (x, a, b)
-  
+
   if !(nargin == 1 || nargin == 3)
     usage ("uniform_pdf (x [, a, b])");
   endif
 
   if (nargin == 1)
     a = 0;
     b = 1;
   endif
 
   [retval, x, a, b] = common_size (x, a, b);
   if (retval > 0)
     error (["uniform_pdf:  ", ...
-	    "x, a and b must be of common size or scalars"]);
+            "x, a and b must be of common size or scalars"]);
   endif
 
   [r, c] = size (x);
   s = r * c;
   x = reshape (x, 1, s);
   a = reshape (a, 1, s);
   b = reshape (b, 1, s);
   pdf = zeros (1, s);
-  
+
   k = find (isnan (x) | !(a < b));
   if any (k)
     pdf(k) = NaN * ones (1, length (k));
   endif
-  
+
   k = find ((x > a) & (x < b));
   if any (k)
     pdf(k) = 1 ./ (b(k) - a(k));
   endif
-  
+
   pdf = reshape (pdf, r, c);
-  
+
 endfunction
diff --git a/scripts/statistics/distributions/uniform_rnd.m b/scripts/statistics/distributions/uniform_rnd.m
--- a/scripts/statistics/distributions/uniform_rnd.m
+++ b/scripts/statistics/distributions/uniform_rnd.m
@@ -1,72 +1,72 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  uniform_rnd (a, b [, r, c])
 ##
 ## uniform_rnd (a, b) returns a matrix of random samples from the
 ## uniform distribution on [a, b].  The size of the matrix is the common
 ## size of a and b.
 ##
 ## uniform_rnd (a, b, r, c) returns an r by c matrix of random samples
 ## from the uniform distribution on [a, b].  Both a and b must be scalar
 ## or of size r by c.
-  
+
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  Random deviates from the uniform distribution
-  
+
 function rnd = uniform_rnd (a, b, r, c)
 
   if (nargin == 4)
     if ( !(is_scalar (r) && (r > 0) && (r == round (r))) )
       error ("uniform_rnd:  r must be a positive integer");
     endif
     if ( !(is_scalar (c) && (c > 0) && (c == round (c))) )
       error ("uniform_rnd:  c must be a positive integer");
     endif
     [retval, a, b] = common_size (a, b, zeros (r, c));
     if (retval > 0)
       error (strcat("uniform_rnd:  ",
-		    "a and b must be scalar or of size ",
-		    sprintf ("%d by %d", r, c)));
+                    "a and b must be scalar or of size ",
+                    sprintf ("%d by %d", r, c)));
     endif
   elseif (nargin == 2)
     [retval, a, b] = common_size (a, b);
     if (retval > 0)
       error ("uniform_rnd:  a and b must be of common size or scalar");
     endif
   else
     usage ("uniform_rnd (a, b [, r, c])");
   endif
 
   [r, c] = size (a);
   s = r * c;
   a = reshape (a, 1, s);
   b = reshape (b, 1, s);
   rnd = zeros (1, s);
-  
+
   k = find (!(-Inf < a) | !(a < b) | !(b < Inf));
   if any (k)
     rnd(k) = NaN * ones (1, length (k));
   endif
-  
+
   k = find ((-Inf < a) & (a < b) & (b < Inf));
   if any (k)
     rnd(k) = a(k) + (b(k) - a(k)) .* rand (1, length (k));
   endif
-  
+
   rnd = reshape (rnd, r, c);
-  
+
 endfunction
\ No newline at end of file
diff --git a/scripts/statistics/distributions/weibull_cdf.m b/scripts/statistics/distributions/weibull_cdf.m
--- a/scripts/statistics/distributions/weibull_cdf.m
+++ b/scripts/statistics/distributions/weibull_cdf.m
@@ -1,65 +1,65 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  weibull_cdf (x, alpha, sigma)
 ##
 ## Compute the cumulative distribution function (CDF) at x of the
 ## Weibull distribution with shape parameter alpha and scale parameter
 ## sigma, which is 1 - exp(-(x/sigma)^alpha), x >= 0.
-  
+
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  CDF of the Weibull distribution
 
 function cdf = weibull_cdf (x, shape, scale)
-  
+
   if (nargin != 3)
     usage ("weibull_cdf (x, alpha, sigma)");
   endif
 
   [retval, x, shape, scale] = common_size (x, shape, scale);
   if (retval > 0)
     error (["weibull_cdf:  ", ...
-	    "x, alpha and sigma must be of common size or scalar"]);
+            "x, alpha and sigma must be of common size or scalar"]);
   endif
 
   [r, c] = size (x);
   s = r * c;
   x = reshape (x, 1, s);
   shape = reshape (shape, 1, s);
   scale = reshape (scale, 1, s);
 
   cdf = NaN * ones (1, s);
-  
+
   ok = ((shape > 0) & (shape < Inf) & (scale > 0) & (scale < Inf));
-  
+
   k = find ((x <= 0) & ok);
   if any (k)
     cdf(k) = zeros (1, length (k));
   endif
-  
+
   k = find ((x > 0) & (x < Inf) & ok);
   if any (k)
     cdf(k) = 1 - exp (- (x(k) ./ scale(k)) .^ shape(k));
   endif
-  
+
   k = find ((x == Inf) & ok);
   if any (k)
     cdf(k) = ones (1, length (k));
   endif
-  
+
   cdf = reshape (cdf, r, c);
-  
+
 endfunction
diff --git a/scripts/statistics/distributions/weibull_inv.m b/scripts/statistics/distributions/weibull_inv.m
--- a/scripts/statistics/distributions/weibull_inv.m
+++ b/scripts/statistics/distributions/weibull_inv.m
@@ -1,63 +1,63 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  weibull_inv (x, lambda, alpha)
 ##
 ## Compute the quantile (the inverse of the CDF) at x of the Weibull
 ## distribution with shape parameter alpha and scale parameter sigma.
-  
+
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  Quantile function of the Weibull distribution
 
 function inv = weibull_inv (x, shape, scale)
-  
+
   if (nargin != 3)
     usage ("weibull_inv (x, alpha, sigma)");
   endif
 
   [retval, x, shape, scale] = common_size (x, shape, scale);
   if (retval > 0)
     error (["weibull_inv:  ", ...
-	    "x, alpha and sigma must be of common size or scalar"]);
+            "x, alpha and sigma must be of common size or scalar"]);
   endif
 
   [r, c] = size (x);
   s = r * c;
   x = reshape (x, 1, s);
   shape = reshape (shape, 1, s);
   scale = reshape (scale, 1, s);
 
   inv = NaN * ones (1, s);
   ok = ((shape > 0) & (shape < Inf) & (scale > 0) & (scale < Inf));
-  
+
   k = find ((x == 0) & ok);
   if any (k)
     inv(k) = -Inf * ones (1, length (k));
   endif
-  
+
   k = find ((x > 0) & (x < 1) & ok);
   if any (k)
     inv(k) = scale(k) .* (- log (1 - x(k))) .^ (1 ./ shape(k));
   endif
 
   k = find ((x == 1) & ok);
   if any (k)
     inv(k) = Inf * ones (1, length (k));
   endif
-  
+
   inv = reshape (inv, r, c);
-  
+
 endfunction
diff --git a/scripts/statistics/distributions/weibull_pdf.m b/scripts/statistics/distributions/weibull_pdf.m
--- a/scripts/statistics/distributions/weibull_pdf.m
+++ b/scripts/statistics/distributions/weibull_pdf.m
@@ -1,63 +1,63 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  weibull_pdf (x, alpha, sigma)
 ##
 ## Compute the probability density function (PDF) at x of the Weibull
 ## distribution with shape parameter alpha and scale parameter sigma
-## which is given by 
+## which is given by
 ##    alpha * sigma^(-alpha) * x^(alpha-1) * exp(-(x/sigma)^alpha)
 ## for x > 0.
-  
+
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  PDF of the Weibull distribution
 
 function pdf = weibull_pdf (x, shape, scale)
-  
+
   if (nargin != 3)
     usage ("weibull_pdf (x, alpha, sigma)");
   endif
 
   [retval, x, shape, scale] = common_size (x, shape, scale);
   if (retval > 0)
     error (["weibull_pdf:  ", ...
-	    "x, alpha and sigma must be of common size or scalar"]);
+            "x, alpha and sigma must be of common size or scalar"]);
   endif
 
   [r, c] = size (x);
   s = r * c;
   x = reshape (x, 1, s);
   shape = reshape (shape, 1, s);
   scale = reshape (scale, 1, s);
 
   pdf = NaN * ones (1, s);
   ok = ((shape > 0) & (shape < Inf) & (scale > 0) & (scale < Inf));
-  
+
   k = find ((x > -Inf) & (x <= 0) & ok);
   if any (k)
     pdf(k) = zeros (1, length (k));
   endif
-  
+
   k = find ((x > 0) & (x < Inf) & ok);
   if any (k)
     pdf(k) = (shape(k) .* (scale(k) .^ shape(k))
-	      .* (x(k) .^ (shape(k) - 1)) 
-	      .* exp(- (x(k) ./ scale(k)) .^ shape(k)));
+              .* (x(k) .^ (shape(k) - 1))
+              .* exp(- (x(k) ./ scale(k)) .^ shape(k)));
   endif
 
   pdf = reshape (pdf, r, c);
-  
+
 endfunction
diff --git a/scripts/statistics/distributions/weibull_rnd.m b/scripts/statistics/distributions/weibull_rnd.m
--- a/scripts/statistics/distributions/weibull_rnd.m
+++ b/scripts/statistics/distributions/weibull_rnd.m
@@ -1,69 +1,69 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  weibull_rnd (alpha, sigma [, r, c])
 ##
 ## weibull_rnd (alpha, sigma) returns a matrix of random samples from
 ## the Weibull distribution with parameters alpha and sigma. The size of
 ## the matrix is the common size of alpha and sigma.
 ##
 ## weibull_rnd (alpha, sigma, r, c) returns an r by c matrix of random
 ## samples from the Weibull distribution with parameters alpha and sigma
 ## which must be scalar or of size r by c.
-  
+
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  Random deviates from the Weibull distribution
 
 function rnd = weibull_rnd (shape, scale, r, c)
 
   if (nargin == 4)
     if ( !(is_scalar (r) && (r > 0) && (r == round (r))) )
       error ("weibull_rnd:  r must be a positive integer");
     endif
     if ( !(is_scalar (c) && (c > 0) && (c == round (c))) )
       error ("weibull_rnd:  c must be a positive integer");
     endif
     [retval, shape, scale] = common_size (shape, scale, zeros (r, c));
     if (retval > 0)
       error (strcat("weibull_rnd:  ",
-		    "alpha and sigma must be scalar or of size ",
-		    sprintf ("%d by %d", r, c)));
+                    "alpha and sigma must be scalar or of size ",
+                    sprintf ("%d by %d", r, c)));
     endif
   elseif (nargin == 2)
     [retval, shape, scale] = common_size (shape, scale);
     if (retval > 0)
       error (strcat("weibull_rnd:  ",
-		    "alpha and sigma must be of common size or scalar"));
+                    "alpha and sigma must be of common size or scalar"));
     endif
   else
     usage ("weibull_rnd (alpha, sigma [, r, c])");
   endif
 
   [r, c] = size (shape);
   s = r * c;
   shape = reshape (shape, 1, s);
   scale = reshape (scale, 1, s);
 
   rnd = NaN * ones (1, s);
   k = find ((shape > 0) & (shape < Inf) & (scale > 0) & (scale < Inf));
   if any (k)
-    rnd(k) = (scale(k) 
-	      .* (- log (1 - rand (1, length (k)))) .^ (1 ./ shape(k)));
+    rnd(k) = (scale(k)
+              .* (- log (1 - rand (1, length (k)))) .^ (1 ./ shape(k)));
   endif
-  
+
   rnd = reshape (rnd, r, c);
-  
+
 endfunction
\ No newline at end of file
diff --git a/scripts/statistics/distributions/wiener_rnd.m b/scripts/statistics/distributions/wiener_rnd.m
--- a/scripts/statistics/distributions/wiener_rnd.m
+++ b/scripts/statistics/distributions/wiener_rnd.m
@@ -1,20 +1,20 @@
 ## Copyright (C) 1995, 1996, 1997  Friedrich Leisch
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  wiener_rnd (t [, d [,n]])
 ##
 ## Returns a simulated realization of the d-dimensional Wiener Process
 ## on the interval [0,t].  If d is omitted, d=1 is used. The first
diff --git a/scripts/statistics/models/logistic_regression.m b/scripts/statistics/models/logistic_regression.m
--- a/scripts/statistics/models/logistic_regression.m
+++ b/scripts/statistics/models/logistic_regression.m
@@ -1,20 +1,20 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## Performs ordinal logistic regression.
 ##
 ## Suppose Y takes values in k ordered categories, and let gamma_i (x)
 ## be the cumulative probability that Y falls in one of the first i
@@ -45,87 +45,87 @@
 ##
 ## `dev' holds minus twice the log-likelihood.
 ##
 ## `dl' and `d2l' are the vector of first and the matrix of second
 ## derivatives of the log-likelihood with respect to theta and beta.
 ##
 ## `p' holds estimates for the conditional distribution of Y given x.
 
-## Original for MATLAB written by Gordon K Smyth <gks@maths.uq.oz.au>, 
+## Original for MATLAB written by Gordon K Smyth <gks@maths.uq.oz.au>,
 ## U of Queensland, Australia, on Nov 19, 1990.  Last revision Aug 3,
 ## 1992.
 
-## Author:  Gordon K Smyth <gks@maths.uq.oz.au>, 
+## Author:  Gordon K Smyth <gks@maths.uq.oz.au>,
 ## Adapted-By:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  Ordinal logistic regression
 
 ## Uses the auxiliary functions logistic_regression_derivatives and
 ## logistic_regression_likelihood.
 
 function [theta, beta, dev, dl, d2l, p] ...
       = logistic_regression (y, x, print, theta, beta)
-  
+
   ## check input
-  y = round (vec (y)); 
-  [my, ny] = size (y);   
+  y = round (vec (y));
+  [my, ny] = size (y);
   if (nargin < 2)
-    x = zeros (my, 0); 
+    x = zeros (my, 0);
   endif;
   [mx, nx] = size (x);
   if (mx != my)
     error ("x and y must have the same number of observations");
   endif
-  
+
   ## initial calculations
   x = -x;
   tol = 1e-6; incr = 10; decr = 2;
   ymin = min (y); ymax = max (y); yrange = ymax - ymin;
   z  = (y * ones (1, yrange)) == ((y * 0 + 1) * (ymin : (ymax - 1)));
   z1 = (y * ones (1, yrange)) == ((y * 0 + 1) * ((ymin + 1) : ymax));
-  z  = z(:, any (z)); 
-  z1 = z1 (:, any(z1)); 
+  z  = z(:, any (z));
+  z1 = z1 (:, any(z1));
   [mz, nz] = size (z);
-  
+
   ## starting values
   if (nargin < 3)
-    print = 0; 
+    print = 0;
   endif;
-  if (nargin < 4) 
-    beta = zeros (nx, 1);     
+  if (nargin < 4)
+    beta = zeros (nx, 1);
   endif;
-  if (nargin < 5) 
-    g = cumsum (sum (z))' ./ my; 
-    theta = log (g ./ (1 - g)); 
+  if (nargin < 5)
+    g = cumsum (sum (z))' ./ my;
+    theta = log (g ./ (1 - g));
   endif;
   tb = [theta; beta];
 
   ## likelihood and derivatives at starting values
   [g, g1, p, dev] = logistic_regression_likelihood (y, x, tb, z, z1);
   [dl, d2l] = logistic_regression_derivatives (x, z, z1, g, g1, p);
   epsilon = std (vec (d2l)) / 1000;
-  
+
   ## maximize likelihood using Levenberg modified Newton's method
   iter = 0;
   while (abs (dl' * (d2l \ dl) / length (dl)) > tol)
     iter = iter + 1;
     tbold = tb;
     devold = dev;
     tb = tbold - d2l \ dl;
     [g, g1, p, dev] = logistic_regression_likelihood (y, x, tb, z, z1);
     if ((dev - devold) / (dl' * (tb - tbold)) < 0)
       epsilon = epsilon / decr;
     else
       while ((dev - devold) / (dl' * (tb - tbold)) > 0)
-	epsilon = epsilon * incr;
+        epsilon = epsilon * incr;
          if (epsilon > 1e+15)
-	   error ("epsilon too large");
+           error ("epsilon too large");
          endif
-	 tb = tbold - (d2l - epsilon * eye (size (d2l))) \ dl;
-	 [g, g1, p, dev] = logistic_regression_likelihood (y, x, tb, z, z1);
+         tb = tbold - (d2l - epsilon * eye (size (d2l))) \ dl;
+         [g, g1, p, dev] = logistic_regression_likelihood (y, x, tb, z, z1);
          disp ("epsilon"); disp (epsilon);
       endwhile
     endif
     [dl, d2l] = logistic_regression_derivatives (x, z, z1, g, g1, p);
     if (print == 2)
       disp ("Iteration"); disp (iter);
       disp ("Deviance"); disp (dev);
       disp ("First derivative"); disp (dl');
@@ -136,35 +136,35 @@ function [theta, beta, dev, dl, d2l, p] 
   ## tidy up output
 
   theta = tb (1 : nz, 1);
   beta  = tb ((nz + 1) : (nz + nx), 1);
 
   if (print >= 1)
     printf ("\n");
     printf ("Logistic Regression Results:\n");
-    printf ("\n");    
+    printf ("\n");
     printf ("Number of Iterations:  %d\n", iter);
     printf ("Deviance:              %f\n", dev);
     printf ("Parameter Estimates:\n");
     printf ("     Theta         S.E.\n");
-    se = sqrt (diag (inv (-d2l)));    
+    se = sqrt (diag (inv (-d2l)));
     for i = 1 : nz
       printf ("   %8.4f     %8.4f\n", tb (i), se (i));
     endfor
     if (nx > 0)
       printf ("      Beta         S.E.\n");
       for i = (nz + 1) : (nz + nx)
-	printf ("   %8.4f     %8.4f\n", tb (i), se (i));
+        printf ("   %8.4f     %8.4f\n", tb (i), se (i));
       endfor
     endif
   endif
 
   if (nargout == 6)
     if (nx > 0)
       e = ((x * beta) * ones (1, nz)) + ((y * 0 + 1) * theta');
     else
       e = (y * 0 + 1) * theta';
     endif
     gamma = diff ([(y * 0), (exp (e) ./ (1 + exp (e))), (y * 0 + 1)]')';
   endif
-  
+
 endfunction
diff --git a/scripts/statistics/models/logistic_regression_derivatives.m b/scripts/statistics/models/logistic_regression_derivatives.m
--- a/scripts/statistics/models/logistic_regression_derivatives.m
+++ b/scripts/statistics/models/logistic_regression_derivatives.m
@@ -1,37 +1,37 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## Called by logistic_regression.  Calculates derivates of the
 ## log-likelihood for ordinal logistic regression model.
-  
+
 ## Author:  Gordon K. Smyth <gks@maths.uq.oz.au>
 ## Adapted-By:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  Derivates of log-likelihood in logistic regression
 
 function [dl, d2l] ...
       = logistic_regression_derivatives (x, z, z1, g, g1, p)
-  
+
   ## first derivative
   v = g .* (1 - g) ./ p; v1 = g1 .* (1 - g1) ./ p;
   dlogp = [(dmult (v, z) - dmult (v1, z1)), (dmult (v - v1, x))];
   dl = sum (dlogp)';
 
   ## second derivative
   w = v .* (1 - 2 * g); w1 = v1 .* (1 - 2 * g1);
   d2l = [z, x]' * dmult (w, [z, x]) - [z1, x]' * dmult (w1, [z1, x]) ...
       - dlogp' * dlogp;
-  
+
 endfunction
\ No newline at end of file
diff --git a/scripts/statistics/models/logistic_regression_likelihood.m b/scripts/statistics/models/logistic_regression_likelihood.m
--- a/scripts/statistics/models/logistic_regression_likelihood.m
+++ b/scripts/statistics/models/logistic_regression_likelihood.m
@@ -1,34 +1,34 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## Calculates likelihood for the ordinal logistic regression model.
 ## Called by logistic_regression.
-  
+
 ## Author:  Gordon K. Smyth <gks@maths.uq.oz.au>
 ## Adapted-By:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  Likelihood in logistic regression
 
 function [g, g1, p, dev] ...
       = logistic_regression_likelihood (y, x, beta, z, z1)
-  
+
   e = exp ([z, x] * beta); e1 = exp ([z1, x] * beta);
   g = e ./ (1 + e); g1 = e1 ./ (1 + e1);
   g = max (y == max (y), g); g1 = min (y > min(y), g1);
-  
+
   p = g - g1;
-  dev = -2 * sum (log (p));  
+  dev = -2 * sum (log (p));
 
 endfunction
diff --git a/scripts/statistics/tests/anova.m b/scripts/statistics/tests/anova.m
--- a/scripts/statistics/tests/anova.m
+++ b/scripts/statistics/tests/anova.m
@@ -1,20 +1,20 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## Performs a one-way analysis of variance (ANOVA).  The goal is to test
 ## whether the population means of data taken from k different groups
 ## are all equal.
 ##
@@ -32,74 +32,74 @@
 ## distribution with df_b and df_w degrees of freedom.  pval is the
 ## p-value (1 minus the CDF of this distribution at f) of the test.
 ##
 ## If no output argument is given, the standard one-way ANOVA table is
 ## printed.
 
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  One-way analysis of variance (ANOVA)
-  
+
 function [pval, f, df_b, df_w] = anova (y, g)
-  
+
   if ((nargin < 1) || (nargin > 2))
     usage ("anova (y [, g])");
   elseif (nargin == 1)
     if (is_vector (y))
       error ("anova:  for `anova (y)', y must not be a vector");
     endif
     [group_count, k] = size (y);
     n = group_count * k;
     group_mean = mean (y);
   else
     if (! is_vector (y))
       error ("anova:  for `anova (y, g)', y must be a vector");
     endif
     n = length (y);
     if (! is_vector (g) || (length (g) != n))
       error (["anova:  for `anova (y, g)', g must be a vector", ...
-		" of the same length y"]);
+                " of the same length y"]);
     endif
     s = sort (g);
     i = find (s (2 : n) > s(1 : (n-1)));
     k = length (i) + 1;
     if (k == 1)
       error ("anova:  there should be at least 2 groups");
     else
       group_label = s ([1, (reshape (i, 1, k-1) + 1)]);
     endif
     for i = 1 : k;
       v = y (find (g == group_label (i)));
       group_count (i) = length (v);
       group_mean (i) = mean (v);
     endfor
-    
+
   endif
-  
-  total_mean = mean (group_mean);  
+
+  total_mean = mean (group_mean);
   SSB = sum (group_count .* (group_mean - total_mean) .^ 2);
-  SST = sumsq (reshape (y, n, 1) - total_mean); 
+  SST = sumsq (reshape (y, n, 1) - total_mean);
   SSW = SST - SSB;
   df_b = k - 1;
   df_w = n - k;
   v_b = SSB / df_b;
   v_w = SSW / df_w;
   f = v_b / v_w;
   pval = 1 - f_cdf (f, df_b, df_w);
-  
+
   if (nargout == 0)
     ## This eventually needs to be done more cleanly ...
     printf ("\n");
     printf ("One-way ANOVA Table:\n");
     printf ("\n");
     printf ("Source of Variation   Sum of Squares    df  Empirical Var\n");
     printf ("*********************************************************\n");
     printf ("Between Groups       %15.4f  %4d  %13.4f\n", SSB, df_b, v_b);
     printf ("Within Groups        %15.4f  %4d  %13.4f\n", SSW, df_w, v_w);
     printf ("---------------------------------------------------------\n");
     printf ("Total                %15.4f  %4d\n", SST, n - 1);
     printf ("\n");
-    printf ("Test Statistic f     %15.4f\n", f);    
+    printf ("Test Statistic f     %15.4f\n", f);
     printf ("p-value              %15.4f\n", pval);
     printf ("\n");
-  endif  
-  
+  endif
+
 endfunction
diff --git a/scripts/statistics/tests/bartlett_test.m b/scripts/statistics/tests/bartlett_test.m
--- a/scripts/statistics/tests/bartlett_test.m
+++ b/scripts/statistics/tests/bartlett_test.m
@@ -1,20 +1,20 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  [pval, chisq, df] = bartlett_test (x1, ...)
 ##
 ## Performs a Bartlett test for the homogeneity of variances in the data
 ## vectors x1, x2, ..., xk, where k > 1.
@@ -49,14 +49,14 @@ function [pval, chisq, df] = bartlett_te
   endfor
 
   f_tot = sum (f);
   v_tot = sum (f .* v) / f_tot;
   c     = 1 + (sum (1 ./ f) - 1 / f_tot) / (3 * (k - 1));
   chisq = (f_tot * log (v_tot) - sum (f .* log (v))) / c;
   df    = k;
   pval  = 1 - chisquare_cdf (chisq, df);
-  
+
   if (nargout == 0)
     printf("  pval:  %g\n", pval);
   endif
 
 endfunction
diff --git a/scripts/statistics/tests/chisquare_test_homogeneity.m b/scripts/statistics/tests/chisquare_test_homogeneity.m
--- a/scripts/statistics/tests/chisquare_test_homogeneity.m
+++ b/scripts/statistics/tests/chisquare_test_homogeneity.m
@@ -1,20 +1,20 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  [pval, chisq, df] = chisquare_test_homogeneity (x, y, c)
 ##
 ## Given two samples x and y, perform a chisquare test for homogeneity
 ## of the null hypothesis that x and y come from the same distribution,
@@ -27,37 +27,37 @@
 ## test.
 ##
 ## If no output argument is given, the p-value is displayed.
 
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  Chi-square test for homogeneity
 
 function [pval, chisq, df] = chisquare_test_homogeneity (x, y, c)
-  
+
   if (nargin != 3)
     usage ("[pval, chisq, df] = chisquare_test_homogeneity (x, y, c)");
   endif
-  
+
   if (! (is_vector(x) && is_vector(y) && is_vector(c)))
     error ("chisquare_test_homogeneity: x, y and c must be vectors");
   endif
   ## Now test c for strictly increasing entries
   df = length (c);
   if (any ( (c(2 : df) - c(1 : (df - 1))) <= 0))
     error ("chisquare_test_homogeneity:  c must be increasing");
   endif
-  
+
   c     = [(reshape (c, 1, df)), Inf];
   l_x   = length (x);
   x     = reshape (x, l_x, 1);
   n_x   = sum (x * ones (1, df+1) < ones (l_x, 1) * c);
   l_y   = length (y);
   y     = reshape (y, l_y, 1);
   n_y   = sum(y * ones (1, df+1) < ones (l_y, 1) * c);
   chisq = l_x * l_y * sum ((n_x/l_x - n_y/l_y).^2 ./ (n_x + n_y));
   pval  = 1 - chisquare_cdf (chisq, df);
-  
+
   if (nargout == 0)
     printf("  pval:  %g\n", pval);
   endif
 
 endfunction
diff --git a/scripts/statistics/tests/chisquare_test_independence.m b/scripts/statistics/tests/chisquare_test_independence.m
--- a/scripts/statistics/tests/chisquare_test_independence.m
+++ b/scripts/statistics/tests/chisquare_test_independence.m
@@ -1,20 +1,20 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  [pval, chisq, df] = chisquare_test_independence (X)
 ##
 ## Perform a chi-square test for indepence based on the contingency
 ## table X.
@@ -28,22 +28,22 @@
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  Chi-square test for independence
 
 function [pval, chisq, df] = chisquare_test_independence (X)
 
   if (nargin != 1)
     usage ("chisquare_test_independence (X)");
   endif
-  
+
   [r, s] = size (X);
   df = (r - 1) * (s - 1);
   n = sum (sum (X));
   Y = sum (X')' * sum (X) / n;
   X = (X - Y) .^2 ./ Y;
   chisq = sum (sum (X));
   pval  = 1 - chisquare_cdf (chisq, df);
-  
+
   if (nargout == 0)
     printf("  pval:  %g\n", pval);
   endif
 
 endfunction
\ No newline at end of file
diff --git a/scripts/statistics/tests/cor_test.m b/scripts/statistics/tests/cor_test.m
--- a/scripts/statistics/tests/cor_test.m
+++ b/scripts/statistics/tests/cor_test.m
@@ -1,20 +1,20 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  cor_test (X, Y [, ALTERNATIVE [, METHOD]])
 ##
 ## Test whether two samples X and Y come from uncorrelated populations.
 ##
@@ -28,32 +28,32 @@
 ## moment correlation coefficient is used.  In this case, the data
 ## should come from a bivariate normal distribution.  Otherwise, the
 ## other two methods offer nonparametric alternatives.
 ## If METHOD is "kendall", then Kendall's rank correlation tau is used.
 ## If METHOD is "spearman", then Spearman's rank correlation rho is used.
 ## Only the first character is necessary.
 ##
 ## The output is a structure with the following elements:
-##	pval		The p-value of the test.
-##	stat		The value of the test statistic.
-##	dist		The distribution of the test statistic.
-##	params		The parameters of the null distribution of the
-##			test statistic.
-##	alternative	The alternative hypothesis.
-##	method		The method used for testing.
+##      pval            The p-value of the test.
+##      stat            The value of the test statistic.
+##      dist            The distribution of the test statistic.
+##      params          The parameters of the null distribution of the
+##                      test statistic.
+##      alternative     The alternative hypothesis.
+##      method          The method used for testing.
 ##
 ## If no output argument is given, the pval is displayed.
 
 ## Author:  FL <Friedrich.Leisch@ci.tuwien.ac.at>
 ## Adapted-by:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  Test for zero correlation
 
 function t = cor_test (X, Y, ALTERNATIVE, METHOD)
-  
+
   if ((nargin < 2) || (nargin > 4))
     usage ("cor_test (X, Y [, ALTERNATIVE [, METHOD]])")
   endif
 
   if (!is_vector (X) || !is_vector (Y) || length (X) != length (Y))
     error ("cor_test:  X and Y must be vectors of the same length")
   endif
 
@@ -77,27 +77,27 @@ function t = cor_test (X, Y, ALTERNATIVE
     df = n - 2;
     t.method = "Pearson's product moment correlation";
     t.params = df;
     t.stat = sqrt (df) .* r / sqrt (1 - r.^2);
     t.dist = "t";
     cdf  = t_cdf (t.stat, df);
   elseif (m == "k")
     tau = kendall (X, Y);
-    t.method = "Kendall's rank correlation tau";    
+    t.method = "Kendall's rank correlation tau";
     t.params = [];
     t.stat = tau / sqrt ((2 * (2*n+5)) / (9*n*(n-1)));
     t.dist = "stdnormal";
     cdf = stdnormal_cdf (t.stat);
   elseif (m == "s")
     rho = spearman (X, Y);
     t.method = "Spearman's rank correlation rho";
     t.params = [];
     t.stat = sqrt (n-1) * (rho - 6/(n^3-n));
-    t.dist = "stdnormal";    
+    t.dist = "stdnormal";
     cdf = stdnormal_cdf (t.stat);
   else
     error ("cor_test:  method `%s' not recognized", METHOD)
   endif
 
   if (strcmp (ALTERNATIVE, "!=") || strcmp (ALTERNATIVE, "<>"))
     t.pval = 2 * min (cdf, 1 - cdf);
   elseif (strcmp (ALTERNATIVE, ">"))
@@ -108,10 +108,10 @@ function t = cor_test (X, Y, ALTERNATIVE
     error ("cor_test:  alternative `%s' not recognized", ALTERNATIVE);
   endif
 
   t.alternative = ALTERNATIVE;
 
   if (nargout == 0)
     printf ("pval:  %g\n", t.pval);
   endif
-  
+
 endfunction
diff --git a/scripts/statistics/tests/f_test_regression.m b/scripts/statistics/tests/f_test_regression.m
--- a/scripts/statistics/tests/f_test_regression.m
+++ b/scripts/statistics/tests/f_test_regression.m
@@ -1,20 +1,20 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  [pval, f, df_num, df_den] = f_test_regression (y, X, R [, r])
 ##
 ## Performs an F test for the null hypothesis R * b = r in a classical
 ## normal regression model y = X * b + e.
@@ -26,51 +26,51 @@
 ## If not given explicitly, r = 0.
 ##
 ## If no output argument is given, the p-value is displayed.
 
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  Test linear hypotheses in linear regression model
 
 function [pval, f, df_num, df_den] = f_test_regression (y, X, R, r)
-  
+
   if (nargin < 3 || nargin > 4)
     usage (["[pval, f, df_num, df_den] ", ...
-	    "= f_test_regression (y, X, R [, r])"]);
+            "= f_test_regression (y, X, R [, r])"]);
   endif
 
   [T, k] = size (X);
   if !( is_vector (y) && (length (y) == T) )
     error (["f_test_regression:  ", ...
-	    "y must be a vector of length rows (X)."]);
+            "y must be a vector of length rows (X)."]);
   endif
   y = reshape (y, T, 1);
-  
+
   [q, c_R ] = size (R);
   if (c_R != k)
     error (["f_test_regression:  ", ...
-	    "R must have as many columns as X."]);
+            "R must have as many columns as X."]);
   endif
-  
+
   if (nargin == 4)
     s_r = size (r);
     if ((min (s_r) != 1) || (max (s_r) != q))
       error (["f_test_regression:  ", ...
-	      "r must be a vector of length rows (R)."]); 
+              "r must be a vector of length rows (R)."]);
     endif
     r = reshape (r, q, 1);
   else
     r = zeros (q, 1);
   endif
 
   df_num = q;
   df_den = T - k;
-  
+
   [b, v] = ols (y, X);
   diff   = R * b - r;
   f      = diff' * inv (R * inv (X' * X) * R') * diff / ( q * v );
   pval  = 1 - f_cdf (f, df_num, df_den);
-  
+
   if (nargout == 0)
     printf ("  pval:  %g\n", pval);
   endif
 
 endfunction
diff --git a/scripts/statistics/tests/hotelling_test.m b/scripts/statistics/tests/hotelling_test.m
--- a/scripts/statistics/tests/hotelling_test.m
+++ b/scripts/statistics/tests/hotelling_test.m
@@ -1,20 +1,20 @@
 ## Copyright (C) 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  [pval, Tsq] = hotelling_test (x, m)
 ##
 ## For a sample x from a multivariate normal distribution with unknown
 ## mean and covariance matrix, test the null hypothesis that mean (x) ==
@@ -22,49 +22,49 @@
 ##
 ## Tsq is Hotelling's T^2.  Under the null, (n-p) T^2 / (p(n-1)) has an
 ## F distribution with p and n-p degrees of freedom, where n and p are
 ## the numbers of samples and variables, respectively.
 ##
 ## pval is the p-value of the test.
 ##
 ## If no output argument is given, the p-value of the test is displayed.
-  
+
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  Test for mean of a multivariate normal
-  
+
 function [pval, Tsq] = hotelling_test (x, m)
-  
+
   if (nargin != 2)
     usage ("hotelling_test (x, m)");
   endif
-  
+
   if (is_vector (x))
     if (! is_scalar (m))
       error ("hotelling_test:  If x is a vector, m must be a scalar.");
     endif
     n = length (x);
     p = 1;
   elseif (is_matrix (x))
     [n, p] = size (x);
     if (n <= p)
       error ("hotelling_test:  x must have more rows than columns.");
     endif
     if (is_vector (m) && length (m) == p)
       m = reshape (m, 1, p);
     else
       error (strcat ("hotelling_test:  ",
-		     "If x is a matrix, m must be a vector\n",
-		     "\tof length columns (x)"));
+                     "If x is a matrix, m must be a vector\n",
+                     "\tof length columns (x)"));
     endif
   else
     error ("hotelling_test:  x must be a matrix or vector");
   endif
-  
+
   d    = mean (x) - m;
   Tsq  = n * d * (cov (x) \ d');
   pval = 1 - f_cdf ((n-p) * Tsq / (p * (n-1)), p, n-p);
-  
+
   if (nargout == 0)
     printf ("  pval:  %g\n", pval);
   endif
-  
+
 endfunction
diff --git a/scripts/statistics/tests/hotelling_test_2.m b/scripts/statistics/tests/hotelling_test_2.m
--- a/scripts/statistics/tests/hotelling_test_2.m
+++ b/scripts/statistics/tests/hotelling_test_2.m
@@ -1,71 +1,71 @@
 ## Copyright (C) 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  [pval, Tsq] = hotelling_test_2 (x, y)
 ##
 ## For two samples x from multivariate normal distributions with the
 ## same number of variables (columns), unknown means and unknown equal
 ## covariance matrices, test the null hypothesis mean (x) == mean (y).
 ##
-## Tsq is Hotelling's two-sample T^2.  Under the null, 
+## Tsq is Hotelling's two-sample T^2.  Under the null,
 ##    (n_x+n_y-p-1) T^2 / (p(n_x+n_y-2))
 ## has an F distribution with p and n_x+n_y-p-1 degrees of freedom,
 ## where n_x and n_y are the sample sizes and p is the number of
 ## variables.
 ##
 ## pval is the p-value of the test.
 ##
 ## If no output argument is given, the p-value of the test is displayed.
 
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  Compare means of two multivariate normals
-  
+
 function [pval, Tsq] = hotelling_test_2 (x, y)
-  
+
   if (nargin != 2)
     usage ("hotelling_test_2 (x, y)");
   endif
-  
+
   if (is_vector (x))
     n_x = length (x);
     if (! is_vector (y))
       error ("hotelling_test_2:  If x is a vector, y must be too.");
     else
       n_y = length (y);
       p   = 1;
     endif
   elseif (is_matrix (x))
     [n_x, p] = size (x);
     [n_y, q] = size (y);
     if (p != q)
       error (strcat ("hotelling_test_2:  ",
-		     "x and y must have the same number of columns"));
+                     "x and y must have the same number of columns"));
     endif
   else
     error ("hotelling_test_2:  x and y must be matrices (or vectors)");
   endif
-  
+
   d    = mean (x) - mean (y);
   S    = ((n_x - 1) * cov (x) + (n_y - 1) * cov (y)) / (n_x + n_y - 2);
   Tsq  = (n_x * n_y / (n_x + n_y)) * d * (S \ d');
   pval = 1 - f_cdf ((n_x + n_y - p - 1) * Tsq / (p * (n_x + n_y - 2)),
-		    p, n_x + n_y - p - 1);
-	      
+                    p, n_x + n_y - p - 1);
+
   if (nargout == 0)
     printf ("  pval:  %g\n", pval);
   endif
-  
+
 endfunction
\ No newline at end of file
diff --git a/scripts/statistics/tests/kolmogorov_smirnov_test.m b/scripts/statistics/tests/kolmogorov_smirnov_test.m
--- a/scripts/statistics/tests/kolmogorov_smirnov_test.m
+++ b/scripts/statistics/tests/kolmogorov_smirnov_test.m
@@ -1,25 +1,25 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-## usage:  
+## usage:
 ##   [pval, ks] = kolmogorov_smirnov_test (x, dist [, params] [, alt])
 ##
 ##
 ## Performs a Kolmogorov-Smirnov test of the null hypothesis that the
 ## sample x comes from the (continuous) distribution dist. I.e., if F
 ## and G are the CDFs corresponding to the sample and dist, respectively,
 ## then the null is that F == G.
 ##
@@ -39,59 +39,59 @@
 ## pval is the p-value of the test.
 ##
 ## If no output argument is given, the p-value is displayed.
 
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  One-sample Kolmogorov-Smirnov test
 
 function [pval, ks] = kolmogorov_smirnov_test (x, dist, ...)
-  
+
   if (nargin < 2)
     error (sprintf (["usage:\n\t", ...
-	"[pval, ks] = ", ...
-	"kolmogorov_smirnov_test (x, dist, [, params] [, alt])"]));
+        "[pval, ks] = ", ...
+        "kolmogorov_smirnov_test (x, dist, [, params] [, alt])"]));
   endif
 
   if (! is_vector (x))
     error ("kolmogorov_smirnov_test:  x must be a vector.");
   endif
 
   n = length (x);
   s = sort (x);
   f = sprintf ("%s_cdf", dist);
 
   alt  = "!=";
-  
+
   if (nargin == 2)
     z = reshape (feval (f, s), 1, n);
   else
     args = "";
     for k = 1 : (nargin-2);
       tmp  = va_arg ();
       if isstr (tmp)
-	alt = tmp;
+        alt = tmp;
       else
-	args = sprintf ("%s, %g", args, tmp);
+        args = sprintf ("%s, %g", args, tmp);
       endif
     endfor
     z = reshape (eval (sprintf ("%s(s%s);", f, args)), 1, n);
-  endif    
+  endif
 
   if (strcmp (alt, "!=") || strcmp (alt, "<>"))
     ks   = sqrt(n) * max(max([abs(z - (0:(n-1))/n); abs(z - (1:n)/n)]));
     pval = 1 - kolmogorov_smirnov_cdf (ks);
   elseif (strcmp (alt, ">"))
     ks   = sqrt(n) * max (max ([z - (0:(n-1))/n; z - (1:n)/n]));
     pval = exp(- 2 * ks^2);
   elseif (strcmp (alt, "<"))
     ks   = - sqrt(n) * min (min ([z - (0:(n-1))/n; z - (1:n)/n]));
     pval = exp(- 2 * ks^2);
   else
     error (sprintf (["kolmogorov_smirnov_test:  ", ...
-	"alternative %s not recognized"], alt));
+        "alternative %s not recognized"], alt));
   endif
-    
+
   if (nargout == 0)
     printf ("pval:  %g\n", pval);
   endif
-  
+
 endfunction
diff --git a/scripts/statistics/tests/kolmogorov_smirnov_test_2.m b/scripts/statistics/tests/kolmogorov_smirnov_test_2.m
--- a/scripts/statistics/tests/kolmogorov_smirnov_test_2.m
+++ b/scripts/statistics/tests/kolmogorov_smirnov_test_2.m
@@ -1,62 +1,62 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  [pval, ks] = kolmogorov_smirnov_test_2 (x, y [, alt])
 ##
 ## Performs a 2-sample Kolmogorov-Smirnov test of the null hypothesis
 ## that the samples x and y come from the same (continuous) distribution.
 ## I.e., if F and G are the CDFs corresponding to the x and y samples,
 ## respectively, then the null is that F == G.
 ##
 ## With the optional argument string alt, the alternative of interest
-## can be selected.  
+## can be selected.
 ## If alt is "!=" or "<>", the null is tested against the two-sided
 ## alternative F != G.  In this case, the test statistic ks follows a
 ## two-sided Kolmogorov-Smirnov distribution.
 ## If alt is ">", the one-sided alternative F > G is considered,
 ## similarly for "<".  In this case, the test statistic ks has a
 ## one-sided Kolmogorov-Smirnov distribution.
 ## The default is the two-sided case.
 ##
 ## pval is the p-value of the test.
 ##
-## If no output argument is given, the p-value is displayed.  
+## If no output argument is given, the p-value is displayed.
 
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  Two-sample Kolmogorov-Smirnov test
 
 function [pval, ks] = kolmogorov_smirnov_test_2 (x, y, alt)
-  
+
   if (nargin < 2 || nargin > 3)
     usage (strcat ("[pval, ks] = ",
-		   "kolmogorov_smirnov_test_2 (x, y [, tol])"));
+                   "kolmogorov_smirnov_test_2 (x, y [, tol])"));
   endif
 
   if !( is_vector (x) && is_vector (y))
     error ("kolmogorov_smirnov_test_2:  both x and y must be vectors.");
   endif
 
   if (nargin == 2)
     alt = "!=";
-  else 
+  else
     if (! isstr (alt))
       error ("kolmogorov_smirnov_test_2:  alt must be a string.");
     endif
   endif
 
   n_x = length (x);
   n_y = length (y);
   n   = n_x * n_y / (n_x + n_y);
@@ -71,16 +71,16 @@ function [pval, ks] = kolmogorov_smirnov
   elseif (strcmp (alt, ">"))
     ks   = sqrt (n) * max (cumsum (count));
     pval = exp(- 2 * ks^2);
   elseif (strcmp(alt, "<"))
     ks   = - sqrt (n) * min (cumsum (count));
     pval = exp(- 2 * ks^2);
   else
     error (sprintf (["kolmogorov_smirnov_test_2:  ", ...
-		     "option %s not recognized"], alt));
+                     "option %s not recognized"], alt));
   endif
-    
+
   if (nargout == 0)
     printf ("  pval:  %g\n", pval);
   endif
 
 endfunction
diff --git a/scripts/statistics/tests/kruskal_wallis_test.m b/scripts/statistics/tests/kruskal_wallis_test.m
--- a/scripts/statistics/tests/kruskal_wallis_test.m
+++ b/scripts/statistics/tests/kruskal_wallis_test.m
@@ -1,20 +1,20 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  [pval, k, df] = kruskal_wallis_test (x1, ...)
 ##
 ## Perform a Kruskal-Wallis one-factor "analysis of variance".
 ##
@@ -25,50 +25,50 @@
 ## affected by the group memberships, the test statistic k is
 ## approximately chi-square with df = k - 1 degrees of freedom. pval is
 ## the p-value (1 minus the CDF of this distribution at k) of this test.
 ##
 ## If no output argument is given, the pval is displayed.
 
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  Kruskal-Wallis test
-  
+
 function [pval, k, df] = kruskal_wallis_test (...)
-  
+
   m = nargin;
   if (m < 2)
     usage ("[pval, k, df] = kruskal_wallis_test (x1, ...)");
   endif
-  
+
   n = [];
   p = [];
   va_start;
   for i = 1 : m;
     x = va_arg ();
     if (! is_vector (x))
       error ("kruskal_wallis_test:  all arguments must be vectors");
     endif
     l = length (x);
     n = [n, l];
     p = [p, (reshape (x, 1, l))];
   endfor
-  
+
   r = ranks (p);
 
   k = 0;
   j = 0;
   for i = 1 : m;
     k = k + (sum (r ((j + 1) : (j + n(i))))) ^ 2 / n(i);
     j = j + n(i);
   endfor
-  
+
   n    = length (p);
   k    = 12 * k / (n * (n + 1)) - 3 * (n + 1);
   df   = m - 1;
   pval = 1 - chisquare_cdf (k, df);
-  
+
   if (nargout == 0)
     printf ("pval:  %g\n", pval);
   endif
 
 endfunction
 
 
diff --git a/scripts/statistics/tests/manova.m b/scripts/statistics/tests/manova.m
--- a/scripts/statistics/tests/manova.m
+++ b/scripts/statistics/tests/manova.m
@@ -28,17 +28,17 @@
 ## same as rows (Y).
 ##
 ## The LR test statistic (Wilks' Lambda) and approximate p-values are
 ## computed and displayed.
 
 ## Three test statistics (Wilks, Hotelling-Lawley, and Pillai-Bartlett)
 ## and corresponding approximate p-values are calculated and displayed.
 ## (Currently NOT because the f_cdf respectively betai code is too bad.)
-  
+
 ## Author:  TF <Thomas.Fuereder@ci.tuwien.ac.at>
 ## Adapted-By:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  One-way multivariate analysis of variance (MANOVA)
 
 function manova (Y, g)
 
   if (nargin != 2)
     usage ("manova (Y, g)");
@@ -52,17 +52,17 @@ function manova (Y, g)
 
   if (!is_vector (g) || (length (g) != n))
     error ("manova:  g must be a vector of length rows (Y)");
   endif
 
   s = sort (g);
   i = find (s (2:n) > s(1:(n-1)));
   k = length (i) + 1;
-    
+
   if (k == 1)
     error ("manova:  there should be at least 2 groups");
   else
     group_label = s ([1, (reshape (i, 1, k - 1) + 1)]);
   endif
 
   Y = Y - ones (n, 1) * mean (Y);
   SST = Y' * Y;
@@ -70,85 +70,85 @@ function manova (Y, g)
   s = zeros (1, p);
   SSB = zeros (p, p);
   for i = 1 : k;
     v = Y (find (g == group_label (i)), :);
     s = sum (v);
     SSB = SSB + s' * s / rows (v);
   endfor
   n_b = k - 1;
-    
+
   SSW = SST - SSB;
   n_w = n - k;
 
   l = real (eig (SSB / SSW));
   l (l < eps) = 0;
 
   ## Wilks' Lambda
   ## =============
 
   Lambda = prod (1 ./ (1 + l));
-  
+
   delta = n_w + n_b - (p + n_b + 1) / 2
   df_num = p * n_b
   W_pval_1 = 1 - chisquare_cdf (- delta * log (Lambda), df_num);
-  
+
   if (p < 3)
     eta = p;
   else
     eta = sqrt ((p^2 * n_b^2 - 4) / (p^2 + n_b^2 - 5))
   endif
 
   df_den = delta * eta - df_num / 2 + 1
-  
+
   WT = exp (- log (Lambda) / eta) - 1
   W_pval_2 = 1 - f_cdf (WT * df_den / df_num, df_num, df_den);
 
   if (0)
 
     ## Hotelling-Lawley Test
     ## =====================
-  
+
     HL = sum (l);
-  
+
     theta = min (p, n_b);
-    u = (abs (p - n_b) - 1) / 2; 
+    u = (abs (p - n_b) - 1) / 2;
     v = (n_w - p - 1) / 2;
 
     df_num = theta * (2 * u + theta + 1);
     df_den = 2 * (theta * v + 1);
 
     HL_pval = 1 - f_cdf (HL * df_den / df_num, df_num, df_den);
 
     ## Pillai-Bartlett
     ## ===============
-  
+
     PB = sum (l ./ (1 + l));
 
     df_den = theta * (2 * v + theta + 1);
     PB_pval = 1 - f_cdf (PB * df_den / df_num, df_num, df_den);
 
     printf ("\n");
     printf ("One-way MANOVA Table:\n");
-    printf ("\n"); 
+    printf ("\n");
     printf ("Test             Test Statistic      Approximate p\n");
     printf ("**************************************************\n");
     printf ("Wilks            %10.4f           %10.9f \n", Lambda, W_pval_1);
     printf ("                                      %10.9f \n", W_pval_2);
     printf ("Hotelling-Lawley %10.4f           %10.9f \n", HL, HL_pval);
     printf ("Pillai-Bartlett  %10.4f           %10.9f \n", PB, PB_pval);
     printf ("\n");
 
   endif
 
   printf ("\n");
   printf ("MANOVA Results:\n");
   printf ("\n");
-  printf ("# of groups:     %d\n", k);  
+  printf ("# of groups:     %d\n", k);
   printf ("# of samples:    %d\n", n);
   printf ("# of variables:  %d\n", p);
-  printf ("\n");  
+  printf ("\n");
   printf ("Wilks' Lambda:   %5.4f\n", Lambda);
   printf ("Approximate p:   %10.9f (chisquare approximation)\n", W_pval_1);
   printf ("                 %10.9f (F approximation)\n", W_pval_2);
   printf ("\n");
-  
+
 endfunction
diff --git a/scripts/statistics/tests/mcnemar_test.m b/scripts/statistics/tests/mcnemar_test.m
--- a/scripts/statistics/tests/mcnemar_test.m
+++ b/scripts/statistics/tests/mcnemar_test.m
@@ -1,64 +1,64 @@
 ## Copyright (C) 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  [pval, chisq, df] = mcnemar_test (x)
 ##
 ## For a square contingency table x of data cross-classified on the row
 ## and column variables, McNemar's test can be used for testing the null
 ## hypothesis of symmetry of the classification probabilities.
 ##
 ## Under the null, chisq is approximately distributed as chisquare with
 ## df degrees of freedom, and pval is the p-value (1 minus the CDF of
 ## this distribution at chisq) of the test.
 ##
 ## If no output argument is given, the p-value of the test is displayed.
-  
+
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  McNemar's test for symmetry
-  
+
 function [pval, chisq, df] = mcnemar_test (x)
-  
+
   if (nargin != 1)
     usage ("mcnemar_test (x)");
   endif
-  
+
   if (! (min (size (x)) > 1) && is_square (x))
     error (strcat ("mcnemar_test:  ",
-		   "x must be a square matrix of size > 1."));
+                   "x must be a square matrix of size > 1."));
   elseif (! (all (all (x >= 0)) && all (all (x == round (x)))))
     error (strcat ("mcnemar_test:  ",
-		   "all entries of x must be nonnegative integers."));
+                   "all entries of x must be nonnegative integers."));
   endif
-  
+
   r = rows (x);
   df = r * (r - 1) / 2;
   if (r == 2)
     num = max (abs (x - x') - 1, 0) .^ 2;
   else
     num = abs (x - x') .^ 2;
   endif
-  
+
   chisq = sum (sum (triu (num ./ (x + x'), 1)));
   pval = 1 - chisquare_cdf (chisq, df);
-  
+
   if (nargout == 0)
     printf ("  pval:  %g\n", pval);
   endif
-  
+
 endfunction
-  
 
 
+
diff --git a/scripts/statistics/tests/prop_test_2.m b/scripts/statistics/tests/prop_test_2.m
--- a/scripts/statistics/tests/prop_test_2.m
+++ b/scripts/statistics/tests/prop_test_2.m
@@ -1,63 +1,63 @@
 ## Copyright (C) 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  [pval, z] = prop_test_2 (x1, n1, x2, n2 [, alt])
 ##
 ## If x1 and n1 are the counts of successes and trials in one sample,
 ## and x2 and n2 those in a second one, test the null hypothesis that
 ## the success probabilities p1 and p2 are the same.
 ## Under the null, the test statistic z approximately follows a
 ## standard normal distribution.
 ##
 ## With the optional argument string alt, the alternative of interest
-## can be selected.  
+## can be selected.
 ## If alt is "!=" or "<>", the null is tested against the two-sided
 ## alternative p1 != p2.
 ## If alt is ">", the one-sided alternative p1 > p2 is used, similarly
 ## for "<".
 ## The default is the two-sided case.
 ##
 ## pval is the p-value of the test.
-##  
+##
 ## If no output argument is given, the p-value of the test is displayed.
-  
+
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  Compare two proportions
 
 function [pval, z] = prop_test_2 (x1, n1, x2, n2, alt)
-  
+
   if ((nargin < 4) || (nargin > 5))
-	usage ("[pval, z] = prop_test_2 (x1, n1, x2, n2 [, alt])");
+        usage ("[pval, z] = prop_test_2 (x1, n1, x2, n2 [, alt])");
   endif
-    
+
   ## Could do sanity checking on x1, n1, x2, n2 here
 
   p1  = x1 / n1;
   p2  = x2 / n2;
   pc  = (x1 + x2) / (n1 + n2);
-  
+
   z   = (p1 - p2) / sqrt (pc * (1 - pc) * (1/n1 + 1/n2));
-  
+
   cdf = stdnormal_cdf (z);
-  
+
   if (nargin == 4)
     alt  = "!=";
   endif
 
   if !isstr (alt)
     error ("prop_test_2:  alt must be a string");
   endif
   if (strcmp (alt, "!=") || strcmp (alt, "<>"))
diff --git a/scripts/statistics/tests/run_test.m b/scripts/statistics/tests/run_test.m
--- a/scripts/statistics/tests/run_test.m
+++ b/scripts/statistics/tests/run_test.m
@@ -1,53 +1,53 @@
 ## Copyright (C) 1995, 1996, 1997  Friedrich Leisch
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  [pval, chisq] = run_test (x)
 ##
 ## Performs a chi-square test with 6 degrees of freedom based on the
 ## upward runs in the columns of x.  Can be used to test whether x
 ## contains independent data.
 ##
 ## If no output argument is given, the pval is displayed.
-  
+
 ## Author:  FL <Friedrich.Leisch@ci.tuwien.ac.at>
 ## Description:  Run test for independence
-  
+
 function [pval, chisq] = run_test (x)
 
   if (nargin != 1)
     usage ("run_test (x)");
   endif
 
   A = [4529.4,  9044.9, 13568,  18091,  22615,  27892;
        9044.4, 18097,   27139,  36187,  45234,  55789;
       13568,   27139,   40721,  54281,  67852,  83685;
       18091,   36187,   54281,  72414,  90470, 111580;
       22615,   45234,   67852,  90470, 113262, 139476;
       27892,   55789,   83685, 111580, 139476, 172860];
 
   b = [1/6; 5/24; 11/120; 19/720; 29/5040; 1/840];
-  
+
   n = rows (x);
   r = run_count (x, 6) - n * b * ones (1, columns(x));
 
   chisq = diag (r' * A * r)' / n;
   pval  = chisquare_cdf (chisq, 6);
-  
+
   if (nargout == 0)
     printf("pval:  %g\n", pval);
   endif
-  
+
 endfunction
diff --git a/scripts/statistics/tests/sign_test.m b/scripts/statistics/tests/sign_test.m
--- a/scripts/statistics/tests/sign_test.m
+++ b/scripts/statistics/tests/sign_test.m
@@ -1,77 +1,77 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  [pval, b, n] = sign_test (x, y [, alt])
 ##
 ## For two matched-pair samples x and y, perform a sign test of the
 ## null hypothesis PROB(x > y) == PROB(x < y) == 1/2.
 ## Under the null, the test statistic b roughly follows a binomial
 ## distribution with parameters n = sum (x != y) and p = 1/2.
 ##
 ## With the optional argument alt, the alternative of interest can be
 ## selected.
 ## If alt is "!=" or "<>", the null hypothesis is tested against the
-## two-sided alternative PROB(x < y) != 1/2. 
+## two-sided alternative PROB(x < y) != 1/2.
 ## If alt is ">", the one-sided alternative PROB(x > y) > 1/2 ("x is
 ## stochastically greater than y") is considered, similarly for "<".
 ## The default is the two-sided case.
 ##
 ## pval is the p-value of the test.
-##  
+##
 ## If no output argument is given, the p-value of the test is displayed.
 
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  Sign test
 
 function [pval, b, n] = sign_test (x, y, alt)
 
   if ((nargin < 2) || (nargin > 3))
     usage ("[pval, b, n] = sign_test (x, y [, alt])");
   endif
-    
+
   if (! (is_vector (x) && is_vector (y) && (length (x) == length (y))))
     error ("sign_test:  x and y must be vectors of the same length");
   endif
 
   n   = length (x);
   x   = reshape (x, 1, n);
   y   = reshape (y, 1, n);
   n   = sum (x != y);
   b   = sum (x > y);
   cdf = binomial_cdf (b, n, 1/2);
-  
+
   if (nargin == 2)
     alt  = "!=";
   endif
 
   if (! isstr (alt))
     error ("sign_test:  alt must be a string");
   endif
   if (strcmp (alt, "!=") || strcmp (alt, "<>"))
     pval = 2 * min (cdf, 1 - cdf);
   elseif strcmp (alt, ">")
     pval = 1 - cdf;
   elseif strcmp (alt, "<")
     pval = cdf;
   else
     error (sprintf ("sign_test:  option %s not recognized", alt));
   endif
-  
+
   if (nargout == 0)
     printf ("  pval:  %g\n", pval);
   endif
-  
+
 endfunction
diff --git a/scripts/statistics/tests/t_test.m b/scripts/statistics/tests/t_test.m
--- a/scripts/statistics/tests/t_test.m
+++ b/scripts/statistics/tests/t_test.m
@@ -1,64 +1,64 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  [pval, t, df] = t_test (x, m [, alt])
 ##
 ## For a sample x from a normal distribution with unknown mean and
 ## variance, perform a t-test of the null hypothesis mean(x) == m.
 ## Under the null, the test statistic t follows a Student distribution
 ## with df = length (x) - 1 degrees of freedom.
 ##
 ## With the optional argument string alt, the alternative of interest
-## can be selected.  
+## can be selected.
 ## If alt is "!=" or "<>", the null is tested against the two-sided
 ## alternative mean(x) != m.
 ## If alt is ">", the one-sided alternative mean(x) > m is considered,
-## similarly for "<".  
+## similarly for "<".
 ## The default is the two-sided case.
 ##
 ## pval is the p-value of the test.
-##  
+##
 ## If no output argument is given, the p-value of the test is displayed.
-  
+
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  Student's one-sample t test 
+## Description:  Student's one-sample t test
 
 function [pval, t, df] = t_test (x, m, alt)
-  
+
   if ((nargin < 2) || (nargin > 3))
     usage ("[pval, t, df] = t_test (x, m [, alt])");
   endif
-    
+
   if (! is_vector (x))
     error ("t_test:  x must be a vector.");
   endif
   if (! is_scalar (m))
     error ("t_test:  m must be a scalar.");
   endif
-  
+
   n   = length (x);
   df  = n - 1;
   t   = sqrt (n) * (sum (x) / n - m) / std (x);
   cdf = t_cdf (t, df);
-  
+
   if (nargin == 2)
     alt  = "!=";
   endif
 
   if (! isstr (alt))
     error ("t_test:  alt must be a string");
   endif
   if (strcmp (alt, "!=") || strcmp (alt, "<>"))
@@ -69,10 +69,10 @@ function [pval, t, df] = t_test (x, m, a
     pval = cdf;
   else
     error (sprintf ("t_test:  option %s not recognized", alt));
   endif
 
   if (nargout == 0)
     printf ("  pval:  %g\n", pval);
   endif
-  
+
 endfunction
diff --git a/scripts/statistics/tests/t_test_2.m b/scripts/statistics/tests/t_test_2.m
--- a/scripts/statistics/tests/t_test_2.m
+++ b/scripts/statistics/tests/t_test_2.m
@@ -1,53 +1,53 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  [pval, t, df] = t_test_2 (x, y [, alt])
 ##
 ## For two samples x and y from normal distributions with unknown means
 ## and unknown equal variances, perform a two-sample t-test of the null
 ## hypothesis of equal means.
 ## Under the null, the test statistic t follows a Student distribution
 ## with df degrees of freedom.
 ##
 ## With the optional argument string alt, the alternative of interest
-## can be selected.  
+## can be selected.
 ## If alt is "!=" or "<>", the null is tested against the two-sided
 ## alternative mean(x) != mean(y).
 ## If alt is ">", the one-sided alternative mean(x) > mean(y) is used,
-## similarly for "<".  
+## similarly for "<".
 ## The default is the two-sided case.
 ##
 ## pval is the p-value of the test.
-##  
+##
 ## If no output argument is given, the p-value of the test is displayed.
-  
+
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  Student's two-sample t test
 
 function [pval, t, df] = t_test_2 (x, y, alt)
-  
+
   if ((nargin < 2) || (nargin > 3))
-	usage ("[pval, t, df] = t_test_2 (x, y [, alt])");
+        usage ("[pval, t, df] = t_test_2 (x, y [, alt])");
   endif
-    
+
   if (! (is_vector (x) && is_vector (y)))
     error ("t_test_2:  both x and y must be vectors");
   endif
 
   n_x  = length (x);
   n_y  = length (y);
   df   = n_x + n_y - 2;
   mu_x = sum (x) / n_x;
diff --git a/scripts/statistics/tests/t_test_regression.m b/scripts/statistics/tests/t_test_regression.m
--- a/scripts/statistics/tests/t_test_regression.m
+++ b/scripts/statistics/tests/t_test_regression.m
@@ -1,96 +1,96 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  [pval, t, df] = t_test_regression (y, X, R [, r] [, alt])
 ##
 ## Performs an t test for the null hypothesis R * b = r in a classical
 ## normal regression model y = X * b + e.
 ## Under the null, the test statistic t follows a t distribution with
 ## df degrees of freedom.
 ##
 ## r is taken as 0 if not given explicitly.
 ##
 ## With the optional argument string alt, the alternative of interest
-## can be selected.  
+## can be selected.
 ## If alt is "!=" or "<>", the null is tested against the two-sided
 ## alternative R * b != r.
 ## If alt is ">", the one-sided alternative R * b > r is used,
-## similarly for "<".   
+## similarly for "<".
 ## The default is the two-sided case.
 ##
 ## pval is the p-value of the test.
-##  
+##
 ## If no output argument is given, the p-value of the test is displayed.
 
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  Test one linear hypothesis in linear regression model
 
 function [pval, t, df] = t_test_regression (y, X, R, r, alt)
-  
+
   if (nargin == 3)
     r   = 0;
     alt = "!=";
   elseif (nargin == 4)
     if (isstr (r))
       alt = r;
       r   = 0;
     else
       alt = "!=";
     endif
   elseif !(nargin == 5)
     usage (["[pval, t, df] ", ...
-	    "= t_test_regression (y, X, R [, r] [, alt]"]);
+            "= t_test_regression (y, X, R [, r] [, alt]"]);
   endif
-      
+
   if (! is_scalar (r))
     error ("t_test_regression:  r must be a scalar");
   elseif (! isstr (alt))
     error ("t_test_regression:  alt must be a string");
   endif
-  
+
   [T, k] = size (X);
   if !(is_vector (y) && (length (y) == T))
     error (["t_test_regression:  ", ...
-	    "y must be a vector of length rows (X)"]);
+            "y must be a vector of length rows (X)"]);
   endif
   s      = size (R);
   if !((max (s) == k) && (min (s) == 1))
     error (["t_test_regression:  ", ...
-	    "R must be a vector of length columns (X)"]);
+            "R must be a vector of length columns (X)"]);
   endif
-  
+
   R      = reshape (R, 1, k);
   y      = reshape (y, T, 1);
   [b, v] = ols (y, X);
   df     = T - k;
   t      = (R * b - r) / sqrt (v * R * inv (X' * X) * R');
   cdf    = t_cdf (t, df);
-  
+
   if (strcmp (alt, "!=") || strcmp (alt, "<>"))
     pval = 2 * min (cdf, 1 - cdf);
   elseif strcmp (alt, ">")
     pval = 1 - cdf;
   elseif strcmp (alt, "<")
     pval = cdf;
   else
     error ("t_test_regression: the value `%s' for alt is not possible", alt);
   endif
-  
+
   if (nargout == 0)
     printf ("pval:  %g\n", pval);
   endif
 
 endfunction
diff --git a/scripts/statistics/tests/u_test.m b/scripts/statistics/tests/u_test.m
--- a/scripts/statistics/tests/u_test.m
+++ b/scripts/statistics/tests/u_test.m
@@ -1,68 +1,68 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  [pval, z] = u_test (x, y [, alt])
 ##
 ## For two samples x and y, perform a Mann-Whitney U-test of the null
 ## hypothesis PROB(x > y) == 1/2 == PROB(x < y).  Under the null, the
 ## test statistic z approximately follows a standard normal
 ## distribution.  Note that this test is equivalent to the Wilcoxon
 ## rank-sum test.
 ##
 ## With the optional argument string alt, the alternative of interest
-## can be selected.  
+## can be selected.
 ## If alt is "!=" or "<>", the null is tested against the two-sided
 ## alternative PROB(x > y) != 1/2.
 ## If alt is ">", the one-sided alternative PROB(x > y) > 1/2 is
-## considered, similarly for "<".  
+## considered, similarly for "<".
 ## The default is the two-sided case.
 ##
 ## pval is the p-value of the test.
-##  
+##
 ## If no output argument is given, the p-value of the test is displayed.
-  
+
 ## This implementation is still incomplete---for small sample sizes,
 ## the normal approximation is rather bad ...
 
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  Mann-Whitney U-test
 
 function [pval, z] = u_test (x, y, alt)
-  
+
   if ((nargin < 2) || (nargin > 3))
     usage ("[pval, z] = u_test (x, y [, alt])");
   endif
-    
+
   if (! (is_vector (x) && is_vector (y)))
     error ("u_test:  both x and y must be vectors");
   endif
 
   n_x  = length (x);
   n_y  = length (y);
   r    = ranks ([(reshape (x, 1, n_x)), (reshape (y, 1, n_y))]);
   z    = (sum (r(1 : n_x)) - n_x * (n_x + n_y + 1) / 2) ...
-           / sqrt (n_x * n_y * (n_x + n_y + 1) / 12);  
+           / sqrt (n_x * n_y * (n_x + n_y + 1) / 12);
 
   cdf  = stdnormal_cdf (z);
-  
+
   if (nargin == 2)
     alt  = "!=";
   endif
 
   if (! isstr (alt))
     error("u_test:  alt must be a string");
   endif
   if (strcmp (alt, "!=") || strcmp (alt, "<>"))
@@ -73,10 +73,10 @@ function [pval, z] = u_test (x, y, alt)
     pval = 1 - cdf;
   else
     error (sprintf ("u_test:  option %s not recognized", alt));
   endif
 
   if (nargout == 0)
     printf ("  pval:  %g\n", pval);
   endif
-  
+
 endfunction
diff --git a/scripts/statistics/tests/var_test.m b/scripts/statistics/tests/var_test.m
--- a/scripts/statistics/tests/var_test.m
+++ b/scripts/statistics/tests/var_test.m
@@ -1,76 +1,76 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  [pval, f, df_num, df_den] = var_test (x, y [, alt])
 ##
-## For two samples x and y from normal distributions with unknown 
+## For two samples x and y from normal distributions with unknown
 ## means and unknown variances, perform an F-test of the null
 ## hypothesis of equal variances.
 ## Under the null, the test statistic f follows an F-distribution
 ## with df_num and df_den degrees of freedom.
 ##
 ## With the optional argument string alt, the alternative of interest
-## can be selected.  
+## can be selected.
 ## If alt is "!=" or "<>", the null is tested against the two-sided
 ## alternative var(x) != var(y).
 ## If alt is ">", the one-sided alternative var(x) > var(y) is used,
-## similarly for "<".  
+## similarly for "<".
 ## The default is the two-sided case.
 ##
 ## pval is the p-value of the test.
-##  
+##
 ## If no output argument is given, the p-value of the test is displayed.
 
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  F test to compare two variances
 
 function [pval, f, df_num, df_den] = var_test (x, y, alt)
-  
+
   if ((nargin < 2) || (nargin > 3))
     usage ("[pval, f, df_num, df_den] = var_test (x, y [, alt])");
   endif
-    
+
   if (! (is_vector (x) && is_vector (y)))
     error ("var_test:  both x and y must be vectors");
   endif
 
   df_num = length (x) - 1;
   df_den = length (y) - 1;
   f      = var (x) / var (y);
   cdf    = f_cdf (f, df_num, df_den);
-  
+
   if (nargin == 2)
     alt  = "!=";
   endif
-    
+
   if (! isstr (alt))
     error ("var_test:  alt must be a string");
   endif
   if (strcmp (alt, "!=") || strcmp (alt, "<>"))
     pval = 2 * min (cdf, 1 - cdf);
   elseif (strcmp (alt, ">"))
     pval = 1 - cdf;
   elseif (strcmp (alt, "<"))
     pval = cdf;
   else
     error (sprintf ("var_test:  option %s not recognized", alt));
   endif
-  
+
   if (nargout == 0)
     printf ("pval:  %g\n", pval);
   endif
 
 endfunction
diff --git a/scripts/statistics/tests/welch_test.m b/scripts/statistics/tests/welch_test.m
--- a/scripts/statistics/tests/welch_test.m
+++ b/scripts/statistics/tests/welch_test.m
@@ -1,53 +1,53 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  [pval, t, df] = welch_test (x, y [, alt])
 ##
 ## For two samples x and y from normal distributions with unknown means
 ## and unknown and not necessarily equal variances, perform a Welch test
 ## of the null hypothesis of equal means.
 ## Under the null, the test statistic t approximately follows a Student
 ## distribution with df degrees of freedom.
 ##
 ## With the optional argument string alt, the alternative of interest
-## can be selected.  
+## can be selected.
 ## If alt is "!=" or "<>", the null is tested against the two-sided
 ## alternative mean(x) != m.
 ## If alt is ">", the one-sided alternative mean(x) > m is considered,
-## similarly for "<".  
+## similarly for "<".
 ## The default is the two-sided case.
 ##
 ## pval is the p-value of the test.
-##  
+##
 ## If no output argument is given, the p-value of the test is displayed.
 
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  Welch two-sample t test
 
 function [pval, t, df] = welch_test (x, y, alt)
-  
+
   if ((nargin < 2) || (nargin > 3))
     usage ("[pval, t, df] = welch_test (x, y [, alt])");
   endif
-    
+
   if (! (is_vector (x) && is_vector (y)))
     error ("welch_test:  both x and y must be vectors");
   endif
 
   n_x  = length (x);
   n_y  = length (y);
   mu_x = sum (x) / n_x;
   mu_y = sum (y) / n_y;
@@ -56,27 +56,27 @@ function [pval, t, df] = welch_test (x, 
   c    = v_x / (v_x + v_y);
   df   = 1 / ( c^2 / (n_x - 1) + (1 - c)^2 / (n_y - 1));
   t    = (mu_x - mu_y) / sqrt (v_x + v_y);
   cdf  = t_cdf (t, df);
 
   if (nargin == 2)
     alt  = "!=";
   endif
-  
+
   if (! isstr (alt))
     error ("welch_test:  alt must be a string");
   endif
   if (strcmp (alt, "!=") || strcmp (alt, "<>"))
     pval = 2 * min (cdf, 1 - cdf);
   elseif (strcmp (alt, ">"))
     pval = 1 - cdf;
   elseif (strcmp (alt, "<"))
     pval = cdf;
   else
     error (sprintf ("welch_test:  option %s not recognized", alt));
   endif
-  
+
   if (nargout == 0)
     printf ("  pval:  %g\n", pval);
   endif
 
 endfunction
diff --git a/scripts/statistics/tests/wilcoxon_test.m b/scripts/statistics/tests/wilcoxon_test.m
--- a/scripts/statistics/tests/wilcoxon_test.m
+++ b/scripts/statistics/tests/wilcoxon_test.m
@@ -1,52 +1,52 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  [pval, z] = wilcoxon_test (x, y [, alt])
 ##
 ## For two matched-pair sample vectors x and y, perform a Wilcoxon
 ## signed-rank test of the null hypothesis PROB(x > y) == 1/2.
 ## Under the null, the test statistic z approximately follows a
-## standard normal distribution. 
+## standard normal distribution.
 ##
 ## With the optional argument string alt, the alternative of interest
-## can be selected.  
+## can be selected.
 ## If alt is "!=" or "<>", the null is tested against the two-sided
 ## alternative PROB(x > y) != 1/2.
 ## If alt is ">", the one-sided alternative PROB(x > y) > 1/2 is
 ## considered, similarly for "<".
 ## The default is the two-sided case.
 ##
 ## pval is the p-value of the test.
-##  
+##
 ## If no output argument is given, the p-value of the test is displayed.
 
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  Wilcoxon signed-rank test
-  
+
 function [pval, z] = wilcoxon_test (x, y, alt)
-  
+
   if ((nargin < 2) || (nargin > 3))
     usage ("[pval, z] = wilcoxon_test (x, y [, alt])");
   endif
-    
+
   if (! (is_vector (x) && is_vector (y) && (length (x) == length (y))))
     error ("wilcoxon_test:  x and y must be vectors of the same length");
   endif
 
   n = length (x);
   x = reshape (x, 1, n);
   y = reshape (y, 1, n);
   d = x - y;
@@ -56,17 +56,17 @@ function [pval, z] = wilcoxon_test (x, y
     r = ranks (abs (d));
     z = sum (r (find (d > 0)));
     z = ((z - n * (n + 1) / 4) / sqrt (n * (n + 1) * (2 * n + 1) / 24));
   else
     z = 0;
   endif
 
   cdf = stdnormal_cdf (z);
-  
+
   if (nargin == 2)
     alt = "!=";
   endif
 
   if (! isstr (alt))
     error("wilcoxon_test:  alt must be a string");
   elseif (strcmp (alt, "!=") || strcmp (alt, "<>"))
     pval = 2 * min (cdf, 1 - cdf);
@@ -76,10 +76,10 @@ function [pval, z] = wilcoxon_test (x, y
     pval = cdf;
   else
     error (sprintf ("wilcoxon_test:  option %s not recognized", alt));
   endif
 
   if (nargout == 0)
     printf ("  pval:  %g\n", pval);
   endif
-  
+
 endfunction
diff --git a/scripts/statistics/tests/z_test.m b/scripts/statistics/tests/z_test.m
--- a/scripts/statistics/tests/z_test.m
+++ b/scripts/statistics/tests/z_test.m
@@ -1,83 +1,83 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  [pval, z] = z_test (x, m, v [, alt])
 ##
-## Perform a Z-test of the null hypothesis mean(x) == m for a sample x 
-## from a normal distribution with unknown mean and known variance v. 
+## Perform a Z-test of the null hypothesis mean(x) == m for a sample x
+## from a normal distribution with unknown mean and known variance v.
 ## Under the null, the test statistic z follows a standard normal
 ## distribution.
 ##
 ## With the optional argument string alt, the alternative of interest
-## can be selected.  
+## can be selected.
 ## If alt is "!=" or "<>", the null is tested against the two-sided
 ## alternative mean(x) != m.
-## If alt is ">", the one-sided alternative mean(x) > m is considered, 
-## similarly for "<".  
+## If alt is ">", the one-sided alternative mean(x) > m is considered,
+## similarly for "<".
 ## The default is the two-sided case.
 ##
 ## pval is the p-value of the test.
-##  
+##
 ## If no output argument is given, the p-value of the test is displayed
-## along with some information. 
+## along with some information.
 
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  Test for mean of a normal sample with known variance
 
 function [pval, z] = z_test (x, m, v, alt)
-  
+
   if ((nargin < 3) || (nargin > 4))
     usage ("[pval, z] = z_test (x, m, v [, alt])");
   endif
-    
+
   if (! is_vector (x))
     error ("z_test:  x must be a vector.");
   endif
   if (! is_scalar (m))
     error ("z_test:  m must be a scalar.");
   endif
   if (! (is_scalar (v) && (v > 0)))
     error ("z_test:  v must be a positive scalar.");
   endif
-  
+
   n = length (x);
   z = sqrt (n/v) * (sum (x) / n - m);
   cdf = stdnormal_cdf (z);
-  
+
   if (nargin == 3)
     alt = "!=";
   endif
 
   if (! isstr (alt))
     error ("z_test:  alt must be a string");
   elseif (strcmp (alt, "!=") || strcmp (alt, "<>"))
     pval = 2 * min (cdf, 1 - cdf);
   elseif (strcmp (alt, ">"))
     pval = 1 - cdf;
   elseif (strcmp (alt, "<"))
     pval = cdf;
   else
     error (sprintf ("z_test:  option %s not recognized", alt));
   endif
-  
+
   if (nargout == 0)
     s = strcat ("Z-test of mean(x) == %g against mean(x) %s %g,\n",
-	      	"with known var(x) == %g:\n",
-	      	"  pval = %g\n");
+                "with known var(x) == %g:\n",
+                "  pval = %g\n");
     printf (s, m, alt, m, v, pval);
   endif
 
 endfunction
diff --git a/scripts/statistics/tests/z_test_2.m b/scripts/statistics/tests/z_test_2.m
--- a/scripts/statistics/tests/z_test_2.m
+++ b/scripts/statistics/tests/z_test_2.m
@@ -1,85 +1,85 @@
 ## Copyright (C) 1995, 1996, 1997  Kurt Hornik
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details. 
-## 
+## General Public License for more details.
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## usage:  [pval, z] = z_test_2 (x, y, v_x, v_y [, alt])
 ##
 ## For two samples x and y from normal distributions with unknown
 ## means and known variances v_x and v_y, perform a Z-test of the
 ## hypothesis of equal means.
 ## Under the null, the test statistic z follows a standard normal
 ## distribution.
 ##
 ## With the optional argument string alt, the alternative of interest
-## can be selected.  
+## can be selected.
 ## If alt is "!=" or "<>", the null is tested against the two-sided
 ## alternative mean(x) != mean(y).
 ## If alt is ">", the one-sided alternative mean(x) > mean(y) is
-## used, similarly for "<".  
+## used, similarly for "<".
 ## The default is the two-sided case.
 ##
 ## pval is the p-value of the test.
-##  
+##
 ## If no output argument is given, the p-value of the test is displayed
 ## along with some information.
 
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  Compare means of two normal samples with known variances
 
 function [pval, z] = z_test_2 (x, y, v_x, v_y, alt)
-  
+
   if ((nargin < 4) || (nargin > 5))
     usage ("[pval, z] = z_test_2 (x, y, v_x, v_y [, alt])");
   endif
-    
+
   if (! (is_vector (x) && is_vector (y)))
     error("z_test_2:  both x and y must be vectors");
   elseif (! (is_scalar (v_x) && (v_x > 0)
-	     && is_scalar (v_y) && (v_y > 0)))
+             && is_scalar (v_y) && (v_y > 0)))
     error ("z_test_2:  both v_x and v_y must be positive scalars.");
   endif
-  
+
   n_x  = length (x);
   n_y  = length (y);
   mu_x = sum (x) / n_x;
   mu_y = sum (y) / n_y;
   z    = (mu_x - mu_y) / sqrt (v_x / n_x + v_y / n_y);
   cdf  = stdnormal_cdf (z);
-  
+
   if (nargin == 4)
     alt = "!=";
   endif
 
   if (! isstr (alt))
     error ("z_test_2:  alt must be a string");
   elseif (strcmp (alt, "!=") || strcmp (alt, "<>"))
     pval = 2 * min (cdf, 1 - cdf);
   elseif (strcmp (alt, ">"))
     pval = 1 - cdf;
   elseif (strcmp (alt, "<"))
     pval = cdf;
   else
     error (sprintf ("z_test_2:  option %s not recognized", alt));
   endif
-  
+
   if (nargout == 0)
     s = strcat ("Two-sample Z-test of mean(x) == mean(y) against ",
-		"mean(x) %s mean(y),\n",
-		"with known var(x) == %g and var(y) == %g:\n",
-		"  pval = %g\n");
+                "mean(x) %s mean(y),\n",
+                "with known var(x) == %g and var(y) == %g:\n",
+                "  pval = %g\n");
     printf (s, alt, v_x, v_y, pval);
   endif
 
 endfunction
diff --git a/scripts/strings/deblank.m b/scripts/strings/deblank.m
--- a/scripts/strings/deblank.m
+++ b/scripts/strings/deblank.m
@@ -14,17 +14,17 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} deblank (@var{s})
-## Removes the trailing blanks from the string @var{s}. 
+## Removes the trailing blanks from the string @var{s}.
 ## @end deftypefn
 
 ## Author: Kurt Hornik <Kurt.Hornik@ci.tuwien.ac.at>
 ## Adapted-By: jwe
 
 function t = deblank (s)
 
   if (nargin != 1)
diff --git a/scripts/strings/dec2bin.m b/scripts/strings/dec2bin.m
--- a/scripts/strings/dec2bin.m
+++ b/scripts/strings/dec2bin.m
@@ -16,17 +16,17 @@
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} dec2bin (@var{n})
 ## Return a binary number corresponding the nonnegative decimal number
 ## @var{n}, as a string of ones and zeros.  For example,
-## 
+##
 ## @example
 ## dec2bin (14)
 ##      @result{} "1110"
 ## @end example
 ## @end deftypefn
 
 ## Author: Kurt Hornik <Kurt.Hornik@ci.tuwien.ac.at>
 ## Adapted-By: jwe
@@ -45,24 +45,24 @@ function y = dec2bin (x)
 
   eleo = empty_list_elements_ok;
   unwind_protect
     empty_list_elements_ok = 1;
     y = [];
     for i = 1:len
       tmp = x (i);
       if (tmp == round (tmp) && tmp >= 0)
-	while (tmp >= 2)
-	  z = fix (tmp ./ 2);
-	  y = [y, tmp - 2 * z];
-	  tmp = z;
-	endwhile
-	y = [y, tmp];
+        while (tmp >= 2)
+          z = fix (tmp ./ 2);
+          y = [y, tmp - 2 * z];
+          tmp = z;
+        endwhile
+        y = [y, tmp];
       else
-	error ("dec2hex: invalid conversion");
+        error ("dec2hex: invalid conversion");
       endif
     endfor
     y = fliplr (y);
     y = setstr (y + toascii ("0"));
   unwind_protect_cleanup
     empty_list_elements_ok = eleo;
   end_unwind_protect
 
diff --git a/scripts/strings/dec2hex.m b/scripts/strings/dec2hex.m
--- a/scripts/strings/dec2hex.m
+++ b/scripts/strings/dec2hex.m
@@ -16,17 +16,17 @@
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} dec2hex (@var{n})
 ## Return the hexadecimal number corresponding to the nonnegative decimal
 ## number @var{n}, as a string.  For example,
-## 
+##
 ## @example
 ## dec2hex (2748)
 ##      @result{} "abc"
 ## @end example
 ## @end deftypefn
 
 ## Author: Kurt Hornik <Kurt.Hornik@ci.tuwien.ac.at>
 ## Adapted-By: jwe
@@ -45,18 +45,18 @@ function h = dec2hex (d)
 
   eleo = empty_list_elements_ok;
   unwind_protect
     empty_list_elements_ok = 1;
     h = "";
     for i = 1:len
       tmp = d (i);
       if (tmp == round (tmp))
-	h = sprintf ("%s%x", h, tmp);
+        h = sprintf ("%s%x", h, tmp);
       else
-	error ("dec2hex: invalid conversion");
+        error ("dec2hex: invalid conversion");
       endif
     endfor
   unwind_protect_cleanup
     empty_list_elements_ok = eleo;
   end_unwind_protect
 
 endfunction
diff --git a/scripts/strings/findstr.m b/scripts/strings/findstr.m
--- a/scripts/strings/findstr.m
+++ b/scripts/strings/findstr.m
@@ -18,17 +18,17 @@
 ## 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} findstr (@var{s}, @var{t}, @var{overlap})
 ## Return the vector of all positions in the longer of the two strings
 ## @var{s} and @var{t} where an occurrence of the shorter of the two starts.
 ## If the optional argument @var{overlap} is nonzero, the returned vector
 ## can include overlapping positions (this is the default).  For example,
-## 
+##
 ## @example
 ## findstr ("ababab", "a")
 ##      @result{} [ 1, 3, 5 ]
 ## findstr ("abababa", "aba", 0)
 ##      @result{} [ 1, 5 ]
 ## @end example
 ## @end deftypefn
 
@@ -63,20 +63,20 @@ function v = findstr (s, t, overlap)
     ind = 1 : l_t;
     limit = length (s) - l_t + 1;
     v  = zeros (1, limit);
     i = 0;
 
     k = 1;
     while (k <= limit)
       if (s (ind + k - 1) == t)
-	v (++i) = k;
-	if (! overlap)
-	  k = k + l_t - 1;
-	endif
+        v (++i) = k;
+        if (! overlap)
+          k = k + l_t - 1;
+        endif
       endif
       k++;
     endwhile
 
     if (i > 0)
       v = v (1:i);
     else
       v = [];
diff --git a/scripts/strings/hex2dec.m b/scripts/strings/hex2dec.m
--- a/scripts/strings/hex2dec.m
+++ b/scripts/strings/hex2dec.m
@@ -16,17 +16,17 @@
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} hex2dec (@var{s})
 ## Return the decimal number corresponding to the hexadecimal number stored
 ## in the string @var{s}.  For example,
-## 
+##
 ## @example
 ## hex2dec ("12B")
 ##      @result{} 299
 ## hex2dec ("12b")
 ##      @result{} 299
 ## @end example
 ## @end deftypefn
 
@@ -40,23 +40,23 @@ function d = hex2dec (h)
   endif
 
   if (isstr (h))
     nr = rows (h);
     d = zeros (nr, 1);
     for i = 1:nr
       s = h (i, :);
       if (isxdigit (s))
-	tmp = sscanf (s, "%x");
-	if (isempty (tmp))
-	  error ("hex2dec: invalid conversion");
-	else
-	  d (i) = tmp;
-	endif
+        tmp = sscanf (s, "%x");
+        if (isempty (tmp))
+          error ("hex2dec: invalid conversion");
+        else
+          d (i) = tmp;
+        endif
       else
-	error ("hex2dec: argument must be a string of hexadecimal digits");
+        error ("hex2dec: argument must be a string of hexadecimal digits");
       endif
     endfor
   else
     error ("hex2dec: expecting a string argument");
   endif
 
 endfunction
diff --git a/scripts/strings/index.m b/scripts/strings/index.m
--- a/scripts/strings/index.m
+++ b/scripts/strings/index.m
@@ -16,22 +16,22 @@
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} index (@var{s}, @var{t})
 ## Return the position of the first occurrence of the string @var{t} in the
 ## string @var{s}, or 0 if no occurrence is found.  For example,
-## 
+##
 ## @example
 ## index ("Teststring", "t")
 ##      @result{} 4
 ## @end example
-## 
+##
 ## @strong{Note:}  This function does not work for arrays of strings.
 ## @end deftypefn
 
 ## Author: Kurt Hornik <Kurt.Hornik@ci.tuwien.ac.at>
 ## Adapted-By: jwe
 
 function n = index (s, t)
 
@@ -50,20 +50,20 @@ function n = index (s, t)
 
     if (nr_s != 1 || nr_t != 1)
       error ("index: arguments cannot be string arrays");
     endif
 
     if (l_t <= l_s)
       tmp = l_s - l_t + 1;
       for idx = 1 : tmp
-	if (strcmp (substr (s, idx, l_t), t))
-	  n = idx;
-	  return;
-	endif
+        if (strcmp (substr (s, idx, l_t), t))
+          n = idx;
+          return;
+        endif
       endfor
     endif
 
   else
     error ("index: expecting string arguments");
   endif
 
 endfunction
diff --git a/scripts/strings/isletter.m b/scripts/strings/isletter.m
--- a/scripts/strings/isletter.m
+++ b/scripts/strings/isletter.m
@@ -13,17 +13,17 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## @deftypefn {Function File } { @var{bool} =} isletter(@var{s})
-## Returns true if @var{s} is a letter false otherwise.  
+## Returns true if @var{s} is a letter false otherwise.
 ## @end deftypefn
 ## @seealso{isalpha}
 
 ## Author: jwe
 
 function retval = isletter (s)
 
   if (nargin != 1)
diff --git a/scripts/strings/rindex.m b/scripts/strings/rindex.m
--- a/scripts/strings/rindex.m
+++ b/scripts/strings/rindex.m
@@ -16,22 +16,22 @@
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} rindex (@var{s}, @var{t})
 ## Return the position of the last occurrence of the string @var{t} in the
 ## string @var{s}, or 0 if no occurrence is found.  For example,
-## 
+##
 ## @example
 ## rindex ("Teststring", "t")
 ##      @result{} 6
 ## @end example
-## 
+##
 ## @strong{Note:}  This function does not work for arrays of strings.
 ## @end deftypefn
 
 ## Author: Kurt Hornik <Kurt.Hornik@ci.tuwien.ac.at>
 ## Adapted-By: jwe
 
 function n = rindex (s, t)
 
@@ -46,20 +46,20 @@ function n = rindex (s, t)
   if (isstr (s) && isstr (t))
 
     l_s = length (s);
     l_t = length (t);
 
     if (l_t <= l_s)
       tmp = l_s - l_t + 1;
       for idx = tmp : -1 : 1
-	if (strcmp (substr (s, idx, l_t), t))
-	  n = idx;
-	  return;
-	endif
+        if (strcmp (substr (s, idx, l_t), t))
+          n = idx;
+          return;
+        endif
       endfor
     endif
 
   else
     error ("rindex: expecting string arguments");
   endif
 
 endfunction
diff --git a/scripts/strings/split.m b/scripts/strings/split.m
--- a/scripts/strings/split.m
+++ b/scripts/strings/split.m
@@ -17,17 +17,17 @@
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} split (@var{s}, @var{t})
 ## Divides the string @var{s} into pieces separated by @var{t}, returning
 ## the result in a string array (padded with blanks to form a valid
 ## matrix).  For example,
-## 
+##
 ## @example
 ## split ("Test string", "t")
 ##      @result{} "Tes "
 ##         " s  "
 ##         "ring"
 ## @end example
 ## @end deftypefn
 
diff --git a/scripts/strings/str2mat.m b/scripts/strings/str2mat.m
--- a/scripts/strings/str2mat.m
+++ b/scripts/strings/str2mat.m
@@ -17,17 +17,17 @@
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} str2mat (@var{s_1}, @dots{}, @var{s_n})
 ## Return a matrix containing the strings @var{s_1}, @dots{}, @var{s_n} as
 ## its rows.  Each string is padded with blanks in order to form a valid
 ## matrix.
-## 
+##
 ## @strong{Note:}
 ## This function is modelled after @sc{Matlab}.  In Octave, you can create
 ## a matrix of strings by @code{[@var{s_1}; @dots{}; @var{s_n}]} even if
 ## the strings are not all the same length.
 ## @end deftypefn
 
 ## Author: Kurt Hornik <Kurt.Hornik@ci.tuwien.ac.at>
 ## Adapted-By: jwe
diff --git a/scripts/strings/strcat.m b/scripts/strings/strcat.m
--- a/scripts/strings/strcat.m
+++ b/scripts/strings/strcat.m
@@ -15,17 +15,17 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} strcat (@var{s1}, @var{s2}, @dots{})
 ## Return a string containing all the arguments concatenated.  For example,
-## 
+##
 ## @example
 ## @group
 ## s = [ "ab"; "cde" ];
 ## strcat (s, s, s)
 ##      @result{} "ab ab ab "
 ##         "cdecdecde"
 ## @end group
 ## @end example
@@ -35,28 +35,28 @@
 
 function st = strcat (s, t, ...)
 
   if (nargin > 1)
     save_empty_list_elements_ok = empty_list_elements_ok;
     unwind_protect
       empty_list_elements_ok = 1;
       if (isstr (s) && isstr (t))
-      	tmpst = [s, t];
+        tmpst = [s, t];
       else
-      	error ("strcat: all arguments must be strings");
+        error ("strcat: all arguments must be strings");
       endif
       n = nargin - 2;
       while (n--)
-      	tmp = va_arg ();
-      	if (isstr (tmp))
+        tmp = va_arg ();
+        if (isstr (tmp))
           tmpst = [tmpst, tmp];
-      	else
+        else
           error ("strcat: all arguments must be strings");
-      	endif
+        endif
       endwhile
     unwind_protect_cleanup
       empty_list_elements_ok = save_empty_list_elements_ok;
     end_unwind_protect
   else
     usage ("strcat (s, t, ...)");
   endif
 
diff --git a/scripts/strings/strcmp.m b/scripts/strings/strcmp.m
--- a/scripts/strings/strcmp.m
+++ b/scripts/strings/strcmp.m
@@ -15,17 +15,17 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} strcmp (@var{s1}, @var{s2})
 ## Compares two strings, returning 1 if they are the same, and 0 otherwise.
-## 
+##
 ## @strong{Note:}  For compatibility with @sc{Matlab}, Octave's strcmp
 ## function returns 1 if the strings are equal, and 0 otherwise.  This is
 ## just the opposite of the corresponding C library function.
 ## @end deftypefn
 
 ## Author: jwe
 
 function status = strcmp (s1, s2)
diff --git a/scripts/strings/strrep.m b/scripts/strings/strrep.m
--- a/scripts/strings/strrep.m
+++ b/scripts/strings/strrep.m
@@ -16,17 +16,17 @@
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} strrep (@var{s}, @var{x}, @var{y})
 ## Replaces all occurrences of the substring @var{x} of the string @var{s}
 ## with the string @var{y}.  For example,
-## 
+##
 ## @example
 ## strrep ("This is a test string", "is", "&%$")
 ##      @result{} "Th&%$ &%$ a test string"
 ## @end example
 ## @end deftypefn
 
 ## Author: Kurt Hornik <Kurt.Hornik@ci.tuwien.ac.at>
 ## Created: 11 November 1994
@@ -54,18 +54,18 @@ function t = strrep (s, x, y)
   else
     save_empty_list_elements_ok = empty_list_elements_ok;
     unwind_protect
       empty_list_elements_ok = 1;
       l_x = length (x);
       tmp = s (1 : ind (1) - 1);
       t = strcat (tmp, y);
       for k = 1 : len - 1
-      	tmp = s (ind (k) + l_x : ind (k+1) - 1);
-      	t = strcat (t, tmp, y);
+        tmp = s (ind (k) + l_x : ind (k+1) - 1);
+        t = strcat (t, tmp, y);
       endfor
       tmp = s (ind(len) + l_x : length (s));
       t = [t, tmp];
     unwind_protect_cleanup
       empty_list_elements_ok = save_empty_list_elements_ok;
     end_unwind_protect
   endif
 
diff --git a/scripts/strings/substr.m b/scripts/strings/substr.m
--- a/scripts/strings/substr.m
+++ b/scripts/strings/substr.m
@@ -16,61 +16,61 @@
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} substr (@var{s}, @var{beg}, @var{len})
 ## Return the substring of @var{s} which starts at character number
 ## @var{beg} and is @var{len} characters long.
-## 
+##
 ## If OFFSET is negative, extraction starts that far from the end of
 ## the string.  If LEN is omitted, the substring extends to the end
 ## of S.
-## 
+##
 ##   For example,
-## 
+##
 ## @example
 ## substr ("This is a test string", 6, 9)
 ##      @result{} "is a test"
 ## @end example
-## 
+##
 ## @quotation
 ## @strong{Note:}
 ## This function is patterned after AWK.  You can get the same result by
-## @code{@var{s} (@var{beg} : (@var{beg} + @var{len} - 1))}.  
+## @code{@var{s} (@var{beg} : (@var{beg} + @var{len} - 1))}.
 ## @end quotation
 ## @end deftypefn
 
 ## Author: Kurt Hornik <Kurt.Hornik@ci.tuwien.ac.at>
 ## Adapted-By: jwe
 
 function t = substr (s, offset, len)
 
   if (nargin < 2 || nargin > 3)
     usage ("substr (s, offset [, len])");
   endif
 
   if (isstr (s))
     nc = columns (s);
     if (abs (offset) > 0 && abs (offset) <= nc)
       if (offset > 0)
-	beg = offset;
+        beg = offset;
       else
-	beg = nc + offset + 1;
+        beg = nc + offset + 1;
       endif
       if (nargin == 2)
-	eos = nc;
+        eos = nc;
       else
-	eos = beg + len - 1;
+        eos = beg + len - 1;
       endif
       if (eos <= nc)
-	t = s (:, beg:eos);
+        t = s (:, beg:eos);
       else
-	error ("substr: length = %d out of range", len);
+        error ("substr: length = %d out of range", len);
       endif
     else
       error ("substr: offset = %d out of range", offset);
     endif
   else
     error ("substr: expecting string argument");
   endif
 
diff --git a/scripts/time/asctime.m b/scripts/time/asctime.m
--- a/scripts/time/asctime.m
+++ b/scripts/time/asctime.m
@@ -16,24 +16,24 @@
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} asctime (@var{tm_struct})
 ## Convert a time structure to a string using the following five-field
 ## format: Thu Mar 28 08:40:14 1996.  For example,
-## 
+##
 ## @example
 ## @group
 ## asctime (localtime (time ())
 ##      @result{} "Mon Feb 17 01:15:06 1997\n"
 ## @end group
 ## @end example
-## 
+##
 ## This is equivalent to @code{ctime (time ())}.
 ## @end deftypefn
 
 ## Author: jwe
 
 function retval = asctime (t)
 
   if (nargin == 1)
diff --git a/scripts/time/clock.m b/scripts/time/clock.m
--- a/scripts/time/clock.m
+++ b/scripts/time/clock.m
@@ -16,24 +16,24 @@
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} clock ()
 ## Return a vector containing the current year, month (1-12), day (1-31),
 ## hour (0-23), minute (0-59) and second (0-61).  For example,
-## 
+##
 ## @example
 ## @group
 ## clock ()
 ##      @result{} [ 1993, 8, 20, 4, 56, 1 ]
 ## @end group
 ## @end example
-## 
+##
 ## The function clock is more accurate on systems that have the
 ## @code{gettimeofday} function.
 ## @end deftypefn
 
 ## Author: jwe
 
 function retval = clock ()
 
diff --git a/scripts/time/ctime.m b/scripts/time/ctime.m
--- a/scripts/time/ctime.m
+++ b/scripts/time/ctime.m
@@ -18,17 +18,17 @@
 ## 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} ctime (@var{t})
 ## Convert a value returned from @code{time} (or any other nonnegative
 ## integer), to the local time and return a string of the same form as
 ## @code{asctime}.  The function @code{ctime (time)} is equivalent to
 ## @code{asctime (localtime (time))}.  For example,
-## 
+##
 ## @example
 ## @group
 ## ctime (time ())
 ##      @result{} "Mon Feb 17 01:15:06 1997"
 ## @end group
 ## @end example
 ## @end deftypefn
 
diff --git a/scripts/time/date.m b/scripts/time/date.m
--- a/scripts/time/date.m
+++ b/scripts/time/date.m
@@ -16,17 +16,17 @@
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} date ()
 ## Return the date as a character string in the form DD-MMM-YY.  For
 ## example,
-## 
+##
 ## @example
 ## @group
 ## date ()
 ##      @result{} "20-Aug-93"
 ## @end group
 ## @end example
 ## @end deftypefn
 
