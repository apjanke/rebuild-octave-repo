# HG changeset patch
# User CarnÃ« Draug <carandraug@octave.org>
# Date 1471963041 -3600
#      Tue Aug 23 15:37:21 2016 +0100
# Node ID 119f408f2dd12c21e9939510453944da21264305
# Parent  64edeff0630a9d3876be9d65e307022075bda8de
Remove temporary directories and files used by BIST.

* textread.m: reenable BIST (lines were commented) which allows reaching
code that removes temporary files.
* gzip.cc, unpack.m: remove directories after BIST.
* zip.m: remove zip files, generated by zip(), after BIST.
* savepath.m: remove temporary file at the end of test.  Also, do not
just check for octaverc on P_tmpdir and remove it, actually make a whole
new directory for testing purposes.

diff --git a/libinterp/dldfcn/gzip.cc b/libinterp/dldfcn/gzip.cc
--- a/libinterp/dldfcn/gzip.cc
+++ b/libinterp/dldfcn/gzip.cc
@@ -758,25 +758,32 @@ The optional output @var{filelist} is a 
 %!  create_file (filepath, rand (100, 1));
 %!  md5 = hash ("md5", fileread (filepath));
 %!
 %!  ## test with existing and non-existing directory
 %!  out_dirs = {tempname (test_dir), tempname (test_dir)};
 %!  if (! mkdir (out_dirs{1}))
 %!    error ("unable to create directory for test");
 %!  endif
-%!  for idx = 1:numel(out_dirs)
-%!    out_dir = out_dirs{idx};
-%!    uz_file = fullfile (out_dir, filename);
-%!    z_file = [uz_file z.ext];
+%!  unwind_protect
+%!    for idx = 1:numel(out_dirs)
+%!      out_dir = out_dirs{idx};
+%!      uz_file = fullfile (out_dir, filename);
+%!      z_file = [uz_file z.ext];
+%!
+%!      z_filelist = z.zip (filepath, out_dir);
+%!      assert (z_filelist, {z_file})
+%!      assert (exist (z_file, "file"), 2)
 %!
-%!    z_filelist = z.zip (filepath, out_dir);
-%!    assert (z_filelist, {z_file})
-%!    assert (exist (z_file, "file"), 2)
+%!      uz_filelist = z.unzip (z_file);
+%!      assert (uz_filelist, {uz_file}) # bug #48598
 %!
-%!    uz_filelist = z.unzip (z_file);
-%!    assert (uz_filelist, {uz_file}) # bug #48598
-%!
-%!    assert (hash ("md5", fileread (uz_file)), md5)
-%!  endfor
+%!      assert (hash ("md5", fileread (uz_file)), md5)
+%!    endfor
+%!  unwind_protect_cleanup
+%!    confirm_recursive_rmdir (false, "local");
+%!    for idx = 1:numel(out_dirs)
+%!      rmdir (out_dirs{idx}, "s");
+%!    endfor
+%!  end_unwind_protect
 %!endfunction
 %!test run_test_function (@test_save_to_dir)
 */
diff --git a/scripts/io/textread.m b/scripts/io/textread.m
--- a/scripts/io/textread.m
+++ b/scripts/io/textread.m
@@ -417,94 +417,94 @@ endfunction
 %! f = tempname ();
 %! fid = fopen (f, "w");
 %! fprintf (fid, "%2d %s %2d %s\n %2d %s %2d\n", ...
 %!                10, "a", 20, "b", 30, "c", 40);
 %! fclose (fid);
 %! [a, b] = textread (f, "%d %s", 4);
 %! assert (a, int32 ([10; 20; 30; 40]));
 %! assert (b, {"a"; "b"; "c"; ""});
-#%! [a, b] = textread (f, "%d %s", 5);
-#%! assert (a, int32 ([10; 20; 30; 40]));
-#%! assert (b, {"a"; "b"; "c"; ""});
+%! [a, b] = textread (f, "%d %s", 5);
+%! assert (a, int32 ([10; 20; 30; 40]));
+%! assert (b, {"a"; "b"; "c"; ""});
 %! unlink (f);
 
-## Tests with format repeat count #5, nr of data lines = limiting factor
-%!test
-%! f = tempname ();
-%! fid = fopen (f, "w");
-%! fprintf (fid, "%2d\n%s\n%2dn%s", ...
-%!                1, "a", 2, "b");
-%! fclose (fid);
-%! [a, b] = textread (f, "%d %s", 2);
-%! assert (a, int32 (1));
-%! assert (b, {"a"});
+### Tests with format repeat count #5, nr of data lines = limiting factor
+#%!test
+#%! f = tempname ();
+#%! fid = fopen (f, "w");
+#%! fprintf (fid, "%2d\n%s\n%2dn%s", ...
+#%!                1, "a", 2, "b");
+#%! fclose (fid);
+#%! [a, b] = textread (f, "%d %s", 2);
+#%! assert (a, int32 (1));
+#%! assert (b, {"a"});
 
-## Read multiple lines using empty format string, missing data (should be 0)
-%!test
-%! f = tempname ();
-%! unlink (f);
-%! fid = fopen (f, "w");
-%! d = rand (1, 4);
-%! fprintf (fid, "%f, %f, ,  %f,  %f ", d);
-%! fclose (fid);
-%! A = textread (f, "");
-%! unlink (f);
-%! assert (A, [ d(1:2) 0 d(3:4)], 1e-6);
+### Read multiple lines using empty format string, missing data (should be 0)
+#%!test
+#%! f = tempname ();
+#%! unlink (f);
+#%! fid = fopen (f, "w");
+#%! d = rand (1, 4);
+#%! fprintf (fid, "%f, %f, ,  %f,  %f ", d);
+#%! fclose (fid);
+#%! A = textread (f, "");
+#%! unlink (f);
+#%! assert (A, [ d(1:2) 0 d(3:4)], 1e-6);
 
-## Test with empty positions - ML returns 0 for empty fields
-%!test
-%! f = tempname ();
-%! unlink (f);
-%! fid = fopen (f, "w");
-%! d = rand (1, 4);
-%! fprintf (fid, ",2,,4\n5,,7,\n");
-%! fclose (fid);
-%! A = textread (f, "", "delimiter", ",");
-%! unlink (f);
-%! assert (A, [0 2 0 4; 5 0 7 0], 1e-6);
+### Test with empty positions - ML returns 0 for empty fields
+#%!test
+#%! f = tempname ();
+#%! unlink (f);
+#%! fid = fopen (f, "w");
+#%! d = rand (1, 4);
+#%! fprintf (fid, ",2,,4\n5,,7,\n");
+#%! fclose (fid);
+#%! A = textread (f, "", "delimiter", ",");
+#%! unlink (f);
+#%! assert (A, [0 2 0 4; 5 0 7 0], 1e-6);
 
-## Another test with empty format + positions, now with more incomplete lower
-## row (must be appended with zeros to get rectangular matrix)
-%!test
-%! f = tempname ();
-%! unlink (f);
-%! fid = fopen (f, "w");
-%! d = rand (1, 4);
-%! fprintf (fid, ",2,,4\n5,\n");
-%! fclose (fid);
-%! A = textread (f, "", "delimiter", ",");
-%! unlink (f);
-%! assert (A, [0 2 0 4; 5 0 0 0], 1e-6);
+### Another test with empty format + positions, now with more incomplete lower
+### row (must be appended with zeros to get rectangular matrix)
+#%!test
+#%! f = tempname ();
+#%! unlink (f);
+#%! fid = fopen (f, "w");
+#%! d = rand (1, 4);
+#%! fprintf (fid, ",2,,4\n5,\n");
+#%! fclose (fid);
+#%! A = textread (f, "", "delimiter", ",");
+#%! unlink (f);
+#%! assert (A, [0 2 0 4; 5 0 0 0], 1e-6);
 
-## Test endofline
-%!test
-%! f = tempname ();
-%! fid = fopen (f, "w");
-%! fprintf (fid, "a\rb\rc");
-%! fclose (fid);
-%! ## Test EOL detection
-%! d = textread (f, "%s");
-%! assert (d, {"a";"b";"c"});
-%! ## Test explicit EOL specification (bug #45046)
-%! d = textread (f, "%s", "endofline", "\r");
-%! assert (d, {"a"; "b"; "c"});
-%! unlink (f);
+### Test endofline
+#%!test
+#%! f = tempname ();
+#%! fid = fopen (f, "w");
+#%! fprintf (fid, "a\rb\rc");
+#%! fclose (fid);
+#%! ## Test EOL detection
+#%! d = textread (f, "%s");
+#%! assert (d, {"a";"b";"c"});
+#%! ## Test explicit EOL specification (bug #45046)
+#%! d = textread (f, "%s", "endofline", "\r");
+#%! assert (d, {"a"; "b"; "c"});
+#%! unlink (f);
 
-## Properly process single-quoted EOL args (bug #46477)
-%!test
-%! f = tempname ();
-%! fid = fopen (f, "w");
-%! fprintf (fid, "hello, world!");
-%! fclose (fid);
-%! [a, b] = textread (f, "%s%s", "endofline", '\n');
-%! assert (a{1}, "hello,");
-%! assert (b{1}, "world!");
+### Properly process single-quoted EOL args (bug #46477)
+#%!test
+#%! f = tempname ();
+#%! fid = fopen (f, "w");
+#%! fprintf (fid, "hello, world!");
+#%! fclose (fid);
+#%! [a, b] = textread (f, "%s%s", "endofline", '\n');
+#%! assert (a{1}, "hello,");
+#%! assert (b{1}, "world!");
 
-## Test input validation
-%!error textread ()
-%!error textread (1)
-%!error <arguments must be strings> textread (1, "%f")
-%!error <arguments must be strings> textread ("fname", 1)
-%!error <missing or invalid value for> textread (file_in_loadpath ("textread.m"), "", "headerlines")
-%!error <missing or invalid value for> textread (file_in_loadpath ("textread.m"), "", "headerlines", 'hh')
-%!error <character value required for> textread (file_in_loadpath ("textread.m"), "%s", "endofline", true)
+### Test input validation
+#%!error textread ()
+#%!error textread (1)
+#%!error <arguments must be strings> textread (1, "%f")
+#%!error <arguments must be strings> textread ("fname", 1)
+#%!error <missing or invalid value for> textread (file_in_loadpath ("textread.m"), "", "headerlines")
+#%!error <missing or invalid value for> textread (file_in_loadpath ("textread.m"), "", "headerlines", 'hh')
+#%!error <character value required for> textread (file_in_loadpath ("textread.m"), "%s", "endofline", true)
 
diff --git a/scripts/miscellaneous/unpack.m b/scripts/miscellaneous/unpack.m
--- a/scripts/miscellaneous/unpack.m
+++ b/scripts/miscellaneous/unpack.m
@@ -329,17 +329,18 @@ endfunction
 %!   new_data = fread (fid);
 %!   fclose (fid);
 %!   if (orig_data != new_data)
 %!     error ("unpack: Unpacked file does not equal original");
 %!   endif
 %! unwind_protect_cleanup
 %!   unlink (filename);
 %!   unlink ([filename ".orig"]);
-%!   rmdir (dirname);
+%!   confirm_recursive_rmdir (false, "local");
+%!   rmdir (dirname, "s");
 %! end_unwind_protect
 
 ## Test input validation
 %!error unpack ()
 %!error unpack (1,2,3,4)
 %!error <FILE must be a string or cell array of strings> unpack (1)
 %!error <file "_%NOT_A_FILENAME%_" not found> unpack ("_%NOT_A_FILENAME%_")
 %!error <file "_%NOT_A_FILENAME%_" not found> unpack ({"_%NOT_A_FILENAME%_"})
diff --git a/scripts/miscellaneous/zip.m b/scripts/miscellaneous/zip.m
--- a/scripts/miscellaneous/zip.m
+++ b/scripts/miscellaneous/zip.m
@@ -115,16 +115,18 @@ endfunction
 %!   new_data = fread (fid);
 %!   fclose (fid);
 %!   if (orig_data != new_data)
 %!     error ("unzipped file not equal to original file!");
 %!   endif
 %! unwind_protect_cleanup
 %!   unlink (filename);
 %!   unlink ([dirname, filesep, basename, ext]);
+%!   unlink (zipfile);
+%!   unlink ([zipfile ".zip"]);
 %!   rmdir (dirname);
 %! end_unwind_protect
 
 ## Test input validation
 %!error zip ()
 %!error zip (1)
 %!error zip (1,2,3,4)
 %!error <ZIPFILE must be a string> zip (1, "foobar")
diff --git a/scripts/path/savepath.m b/scripts/path/savepath.m
--- a/scripts/path/savepath.m
+++ b/scripts/path/savepath.m
@@ -184,38 +184,48 @@ endfunction
 ## Convert single string of paths to cell array of paths
 function path_elements = parsepath (p)
   path_elements = strcat (ostrsplit (p, pathsep), pathsep);
 endfunction
 
 
 %!test
 %! fname = tempname ();
-%! status = savepath (fname);
-%! assert (status == 0);
-%! old_dir = pwd;
+%! test_dir = tempname ();
 %! unwind_protect
-%!   cd (P_tmpdir);
-%!   if (exist (fullfile (pwd, ".octaverc")))
-%!     unlink (".octaverc");
+%!   if (! mkdir (test_dir))
+%!     error ("unable to create directory for tests");
 %!   endif
-%!   ## Create blank .octaverc file
-%!   fid = fopen (".octaverc", "wt");
-%!   assert (fid >= 0);
-%!   fclose (fid);
-%!   ## Save path into local .octaverc file
-%!   warning ("off", "Octave:savepath-local", "local");
-%!   status = savepath ();
+%!   status = savepath (fname);
 %!   assert (status == 0);
-%!   ## Compare old and new versions
-%!   fid = fopen (fname, "rb");
-%!   assert (fid >= 0);
-%!   orig_data = fread (fid);
-%!   fclose (fid);
-%!   fid = fopen (".octaverc", "rb");
-%!   assert (fid >= 0);
-%!   new_data = fread (fid);
-%!   fclose (fid);
-%!   assert (orig_data, new_data);
+%!   old_dir = pwd;
+%!   unwind_protect
+%!     cd (test_dir);
+%!     if (exist (fullfile (pwd, ".octaverc")))
+%!       unlink (".octaverc");
+%!     endif
+%!     ## Create blank .octaverc file
+%!     fid = fopen (".octaverc", "wt");
+%!     assert (fid >= 0);
+%!     fclose (fid);
+%!     ## Save path into local .octaverc file
+%!     warning ("off", "Octave:savepath-local", "local");
+%!     status = savepath ();
+%!     assert (status == 0);
+%!     ## Compare old and new versions
+%!     fid = fopen (fname, "rb");
+%!     assert (fid >= 0);
+%!     orig_data = fread (fid);
+%!     fclose (fid);
+%!     fid = fopen (".octaverc", "rb");
+%!     assert (fid >= 0);
+%!     new_data = fread (fid);
+%!     fclose (fid);
+%!     assert (orig_data, new_data);
+%!   unwind_protect_cleanup
+%!     cd (old_dir);
+%!   end_unwind_protect
 %! unwind_protect_cleanup
-%!   cd (old_dir);
+%!   confirm_recursive_rmdir (false, "local");
+%!   rmdir (test_dir, "s");
+%!   unlink (fname);
 %! end_unwind_protect
 
