# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1484887314 18000
#      Thu Jan 19 23:41:54 2017 -0500
# Node ID 4e3d47dc7e257f7714f6a9e4502278ccf4fb5947
# Parent  15be0726ebd004a15736cf3ed6e78e131f4c03d2
move parse tree classes inside octave namespace

* lex.h, lex.ll, oct-parse.in.yy, parse.h, pt-all.h, pt-arg-list.cc,
pt-arg-list.h, pt-array-list.cc, pt-array-list.h, pt-assign.cc,
pt-assign.h, pt-binop.cc, pt-binop.h, pt-bp.cc, pt-bp.h, pt-cbinop.cc,
pt-cbinop.h, pt.cc, pt-cell.cc, pt-cell.h, pt-check.cc, pt-check.h,
pt-classdef.cc, pt-classdef.h, pt-cmd.cc, pt-cmd.h, pt-colon.cc,
pt-colon.h, pt-const.cc, pt-const.h, pt-decl.cc, pt-decl.h,
pt-eval.cc, pt-eval.h, pt-except.cc, pt-except.h, pt-exp.cc, pt-exp.h,
pt-fcn-handle.cc, pt-fcn-handle.h, pt-funcall.cc, pt-funcall.h, pt.h,
pt-id.cc, pt-id.h, pt-idx.cc, pt-idx.h, pt-jump.cc, pt-jump.h,
pt-loop.cc, pt-loop.h, pt-mat.cc, pt-mat.h, pt-misc.cc, pt-misc.h,
pt-pr-code.cc, pt-pr-code.h, pt-select.cc, pt-select.h, pt-stmt.cc,
pt-stmt.h, pt-unop.cc, pt-unop.h, pt-walk.h, token.cc, token.h:
Move classes and most functions inside octave namespace.
Change all uses.

diff --git a/libinterp/corefcn/__ichol__.cc b/libinterp/corefcn/__ichol__.cc
--- a/libinterp/corefcn/__ichol__.cc
+++ b/libinterp/corefcn/__ichol__.cc
@@ -193,27 +193,27 @@ Undocumented internal function.
   // In ICHOL0 algorithm the zero-pattern of the input matrix is preserved
   // so its structure does not change during the algorithm.  The same input
   // matrix is used to build the output matrix due to that fact.
   octave_value_list arg_list;
   if (! args(0).is_complex_type ())
     {
       SparseMatrix sm = args(0).sparse_matrix_value ();
       arg_list.append (sm);
-      sm = feval ("tril", arg_list)(0).sparse_matrix_value ();
+      sm = octave::feval ("tril", arg_list)(0).sparse_matrix_value ();
       ichol_0 <SparseMatrix, double, ichol_mult_real,
                ichol_checkpivot_real> (sm, michol);
 
       return ovl (sm);
     }
   else
     {
       SparseComplexMatrix sm = args(0).sparse_complex_matrix_value ();
       arg_list.append (sm);
-      sm = feval ("tril", arg_list)(0).sparse_complex_matrix_value ();
+      sm = octave::feval ("tril", arg_list)(0).sparse_complex_matrix_value ();
       ichol_0 <SparseComplexMatrix, Complex, ichol_mult_complex,
                ichol_checkpivot_complex> (sm, michol);
 
       return ovl (sm);
     }
 }
 
 template <typename octave_matrix_t, typename T,  T (*ichol_mult) (T, T),
@@ -436,39 +436,39 @@ Undocumented internal function.
 
   octave_value_list arg_list;
   if (! args(0).is_complex_type ())
     {
       Array <double> cols_norm;
       SparseMatrix L;
       arg_list.append (args(0).sparse_matrix_value ());
       SparseMatrix sm_l =
-        feval ("tril", arg_list)(0).sparse_matrix_value ();
+        octave::feval ("tril", arg_list)(0).sparse_matrix_value ();
       arg_list(0) = sm_l;
       arg_list(1) = 1;
       arg_list(2) = "cols";
-      cols_norm = feval ("norm", arg_list)(0).vector_value ();
+      cols_norm = octave::feval ("norm", arg_list)(0).vector_value ();
       arg_list.clear ();
       ichol_t <SparseMatrix,
                double, ichol_mult_real, ichol_checkpivot_real>
                (sm_l, L, cols_norm.fortran_vec (), droptol, michol);
 
       return ovl (L);
     }
   else
     {
       Array <Complex> cols_norm;
       SparseComplexMatrix L;
       arg_list.append (args(0).sparse_complex_matrix_value ());
       SparseComplexMatrix sm_l =
-        feval ("tril", arg_list)(0).sparse_complex_matrix_value ();
+        octave::feval ("tril", arg_list)(0).sparse_complex_matrix_value ();
       arg_list(0) = sm_l;
       arg_list(1) = 1;
       arg_list(2) = "cols";
-      cols_norm = feval ("norm", arg_list)(0).complex_vector_value ();
+      cols_norm = octave::feval ("norm", arg_list)(0).complex_vector_value ();
       arg_list.clear ();
       ichol_t <SparseComplexMatrix,
                Complex, ichol_mult_complex, ichol_checkpivot_complex>
                (sm_l, L, cols_norm.fortran_vec (),
                 Complex (droptol), michol);
 
       return ovl (L);
     }
diff --git a/libinterp/corefcn/__ilu__.cc b/libinterp/corefcn/__ilu__.cc
--- a/libinterp/corefcn/__ilu__.cc
+++ b/libinterp/corefcn/__ilu__.cc
@@ -155,35 +155,35 @@ Undocumented internal function.
   // matrix is used to build the output matrix due to that fact.
   octave_value_list arg_list;
   if (! args(0).is_complex_type ())
     {
       SparseMatrix sm = args(0).sparse_matrix_value ();
       ilu_0 <SparseMatrix, double> (sm, milu);
 
       arg_list.append (sm);
-      retval(1) = feval ("triu", arg_list)(0).sparse_matrix_value ();
+      retval(1) = octave::feval ("triu", arg_list)(0).sparse_matrix_value ();
       SparseMatrix eye =
-        feval ("speye", ovl (sm.cols ()))(0).sparse_matrix_value ();
+        octave::feval ("speye", ovl (sm.cols ()))(0).sparse_matrix_value ();
       arg_list.append (-1);
       retval(0) = eye +
-                  feval ("tril", arg_list)(0).sparse_matrix_value ();
+        octave::feval ("tril", arg_list)(0).sparse_matrix_value ();
     }
   else
     {
       SparseComplexMatrix sm = args(0).sparse_complex_matrix_value ();
       ilu_0 <SparseComplexMatrix, Complex> (sm, milu);
 
       arg_list.append (sm);
-      retval(1) = feval ("triu", arg_list)(0).sparse_complex_matrix_value ();
+      retval(1) = octave::feval ("triu", arg_list)(0).sparse_complex_matrix_value ();
       SparseComplexMatrix eye =
-        feval ("speye", ovl (sm.cols ()))(0).sparse_complex_matrix_value ();
+        octave::feval ("speye", ovl (sm.cols ()))(0).sparse_complex_matrix_value ();
       arg_list.append (-1);
       retval(0) = eye +
-                  feval ("tril", arg_list)(0).sparse_complex_matrix_value ();
+        octave::feval ("tril", arg_list)(0).sparse_complex_matrix_value ();
     }
 
   return retval;
 }
 
 template <typename octave_matrix_t, typename T>
 void ilu_crout (octave_matrix_t& sm_l, octave_matrix_t& sm_u,
                 octave_matrix_t& L, octave_matrix_t& U, T* cols_norm,
@@ -489,55 +489,55 @@ Undocumented internal function.
   if (nargin == 3)
     milu = args(2).string_value ();
 
   octave_value_list arg_list;
   if (! args(0).is_complex_type ())
     {
       Array<double> cols_norm, rows_norm;
       arg_list.append (args(0).sparse_matrix_value ());
-      SparseMatrix sm_u = feval ("triu", arg_list)(0).sparse_matrix_value ();
+      SparseMatrix sm_u = octave::feval ("triu", arg_list)(0).sparse_matrix_value ();
       arg_list.append (-1);
-      SparseMatrix sm_l = feval ("tril", arg_list)(0).sparse_matrix_value ();
+      SparseMatrix sm_l = octave::feval ("tril", arg_list)(0).sparse_matrix_value ();
       arg_list(1) = "rows";
-      rows_norm = feval ("norm", arg_list)(0).vector_value ();
+      rows_norm = octave::feval ("norm", arg_list)(0).vector_value ();
       arg_list(1) = "cols";
-      cols_norm = feval ("norm", arg_list)(0).vector_value ();
+      cols_norm = octave::feval ("norm", arg_list)(0).vector_value ();
       arg_list.clear ();
       SparseMatrix U, L;
       ilu_crout <SparseMatrix, double> (sm_l, sm_u, L, U,
                                         cols_norm.fortran_vec (),
                                         rows_norm.fortran_vec (),
                                         droptol, milu);
       arg_list.append (octave_value (L.cols ()));
-      SparseMatrix eye = feval ("speye", arg_list)(0).sparse_matrix_value ();
+      SparseMatrix eye = octave::feval ("speye", arg_list)(0).sparse_matrix_value ();
       return ovl (L + eye, U);
     }
   else
     {
       Array<Complex> cols_norm, rows_norm;
       arg_list.append (args(0).sparse_complex_matrix_value ());
       SparseComplexMatrix sm_u =
-        feval ("triu", arg_list)(0).sparse_complex_matrix_value ();
+        octave::feval ("triu", arg_list)(0).sparse_complex_matrix_value ();
       arg_list.append (-1);
       SparseComplexMatrix sm_l =
-        feval ("tril", arg_list)(0).sparse_complex_matrix_value ();
+        octave::feval ("tril", arg_list)(0).sparse_complex_matrix_value ();
       arg_list(1) = "rows";
-      rows_norm = feval ("norm", arg_list)(0).complex_vector_value ();
+      rows_norm = octave::feval ("norm", arg_list)(0).complex_vector_value ();
       arg_list(1) = "cols";
-      cols_norm = feval ("norm", arg_list)(0).complex_vector_value ();
+      cols_norm = octave::feval ("norm", arg_list)(0).complex_vector_value ();
       arg_list.clear ();
       SparseComplexMatrix U, L;
       ilu_crout <SparseComplexMatrix, Complex>
                 (sm_l, sm_u, L, U, cols_norm.fortran_vec (),
                  rows_norm.fortran_vec (), Complex (droptol), milu);
 
       arg_list.append (octave_value (L.cols ()));
       SparseComplexMatrix eye =
-        feval ("speye", arg_list)(0).sparse_complex_matrix_value ();
+        octave::feval ("speye", arg_list)(0).sparse_complex_matrix_value ();
       return ovl (L + eye, U);
     }
 }
 
 // This function implements the IKJ and JKI variants of gaussian elimination
 // to perform the ILUTP decomposition.  The behavior is controlled by milu
 // parameter.  If milu = ['off'|'col'] the JKI version is performed taking
 // advantage of CCS format of the input matrix.  Row pivoting is performed.
@@ -961,33 +961,33 @@ Undocumented internal function.
 
   octave_value_list arg_list;
   octave_idx_type nnz_u, nnz_l;
   if (! args(0).is_complex_type ())
     {
       Array <double> rc_norm;
       SparseMatrix sm = args(0).sparse_matrix_value ();
       arg_list.append (sm);
-      nnz_u =  (feval ("triu", arg_list)(0).sparse_matrix_value ()).nnz ();
+      nnz_u = (octave::feval ("triu", arg_list)(0).sparse_matrix_value ()).nnz ();
       arg_list.append (-1);
-      nnz_l =  (feval ("tril", arg_list)(0).sparse_matrix_value ()).nnz ();
+      nnz_l = (octave::feval ("tril", arg_list)(0).sparse_matrix_value ()).nnz ();
       if (milu == "row")
         arg_list (1) = "rows";
       else
         arg_list (1) = "cols";
-      rc_norm = feval ("norm", arg_list)(0).vector_value ();
+      rc_norm = octave::feval ("norm", arg_list)(0).vector_value ();
       arg_list.clear ();
       Array <octave_idx_type> perm (dim_vector (sm.cols (), 1));
       SparseMatrix U, L;
       ilu_tp <SparseMatrix, double> (sm, L, U, nnz_u, nnz_l,
                                      rc_norm.fortran_vec (),
                                      perm, droptol, thresh, milu, udiag);
       arg_list.append (octave_value (L.cols ()));
       SparseMatrix eye =
-        feval ("speye", arg_list)(0).sparse_matrix_value ();
+        octave::feval ("speye", arg_list)(0).sparse_matrix_value ();
       if (milu == "row")
         {
           if (nargout == 3)
             {
               retval(2) = eye.index (idx_vector::colon, perm);
               retval(1) = U.index (idx_vector::colon, perm);
             }
           else if (nargout == 2)
@@ -1010,35 +1010,35 @@ Undocumented internal function.
         }
     }
   else
     {
       Array <Complex> rc_norm;
       SparseComplexMatrix sm = args(0).sparse_complex_matrix_value ();
       arg_list.append (sm);
       nnz_u =
-        feval ("triu", arg_list)(0).sparse_complex_matrix_value ().nnz ();
+        octave::feval ("triu", arg_list)(0).sparse_complex_matrix_value ().nnz ();
       arg_list.append (-1);
       nnz_l =
-        feval ("tril", arg_list)(0).sparse_complex_matrix_value ().nnz ();
+        octave::feval ("tril", arg_list)(0).sparse_complex_matrix_value ().nnz ();
       if (milu == "row")
         arg_list(1) = "rows";
       else
         arg_list(1) = "cols";
-      rc_norm = feval ("norm", arg_list)(0).complex_vector_value ();
+      rc_norm = octave::feval ("norm", arg_list)(0).complex_vector_value ();
       arg_list.clear ();
       Array <octave_idx_type> perm (dim_vector (sm.cols (), 1));
       SparseComplexMatrix U, L;
       ilu_tp <SparseComplexMatrix, Complex>
               (sm, L, U, nnz_u, nnz_l, rc_norm.fortran_vec (), perm,
                Complex (droptol), Complex (thresh), milu, udiag);
 
       arg_list.append (octave_value (L.cols ()));
       SparseComplexMatrix eye =
-        feval ("speye", arg_list)(0).sparse_complex_matrix_value ();
+        octave::feval ("speye", arg_list)(0).sparse_complex_matrix_value ();
       if (milu == "row")
         {
           if (nargout == 3)
             {
               retval(2) = eye.index (idx_vector::colon, perm);
               retval(1) = U.index (idx_vector::colon, perm);
             }
           else if (nargout == 2)
diff --git a/libinterp/corefcn/data.cc b/libinterp/corefcn/data.cc
--- a/libinterp/corefcn/data.cc
+++ b/libinterp/corefcn/data.cc
@@ -1784,17 +1784,17 @@ do_cat (const octave_value_list& xargs, 
         {
           if (i == 0)
             {
               result_type = args(i).class_name ();
 
               first_elem_is_struct = args(i).is_map ();
             }
           else
-            result_type = get_concat_class (result_type, args(i).class_name ());
+            result_type = octave::get_concat_class (result_type, args(i).class_name ());
 
           if (all_strings_p && ! args(i).is_string ())
             all_strings_p = false;
           if (all_sq_strings_p && ! args(i).is_sq_string ())
             all_sq_strings_p = false;
           if (all_dq_strings_p && ! args(i).is_dq_string ())
             all_dq_strings_p = false;
           if (all_real_p && ! args(i).is_real_type ())
@@ -1860,17 +1860,17 @@ do_cat (const octave_value_list& xargs, 
       else if (result_type == "char")
         {
           char type = all_dq_strings_p ? '"' : '\'';
 
           if (! all_strings_p)
             warn_implicit_conversion ("Octave:num-to-str",
                                       "numeric", result_type);
           else
-            maybe_warn_string_concat (all_dq_strings_p, all_sq_strings_p);
+            octave::maybe_warn_string_concat (all_dq_strings_p, all_sq_strings_p);
 
           charNDArray result = do_single_type_concat<charNDArray> (args, dim);
 
           retval = octave_value (result, type);
         }
       else if (result_type == "logical")
         {
           if (any_sparse_p)
diff --git a/libinterp/corefcn/debug.cc b/libinterp/corefcn/debug.cc
--- a/libinterp/corefcn/debug.cc
+++ b/libinterp/corefcn/debug.cc
@@ -233,53 +233,53 @@ parse_dbfunction_params (const char *who
   lines = bp_table::intmap ();
 
   if (nargin == 0 || ! args(0).is_string ())
     print_usage (who);
 
   // elements already processed
   bool seen_in = false, seen_at = false, seen_if = false;
   int pos = 0;
-  dbstop_args token = dbstop_none;
+  dbstop_args tok = dbstop_none;
   while (pos < nargin)
     {
       // allow "in" and "at" to be implicit
       if (args(pos).is_string ())
         {
           std::string arg = args(pos).string_value ();
           if (arg == "in")
             {
-              token = dbstop_in;
+              tok = dbstop_in;
               pos++;
             }
           else if (arg == "at")
             {
-              token = dbstop_at;
+              tok = dbstop_at;
               pos++;
             }
           else if (arg == "if")
             {
-              token = dbstop_if;
+              tok = dbstop_if;
               pos++;
             }
           else if (atoi (args(pos).string_value ().c_str ()) > 0)
-            token = dbstop_at;
+            tok = dbstop_at;
           else
-            token = dbstop_in;
+            tok = dbstop_in;
         }
       else
-        token = dbstop_at;
+        tok = dbstop_at;
 
       if (pos >= nargin)
         error ("%s: '%s' missing argument", who,
-               ( token == dbstop_in ? "in" :
-                (token == dbstop_at ? "at" : "if")));
+               (tok == dbstop_in
+                ? "in" : (tok == dbstop_at ? "at" : "if")));
 
       // process the actual arguments
-      switch (token)
+      switch (tok)
         {
         case dbstop_in:
           symbol_name = args(pos).string_value ();
           if (seen_in)
             error ("%s: Too many function names specified -- %s",
                    who, symbol_name.c_str ());
           else if (seen_at || seen_if)
             error ("%s: function name must come before line number and 'if'",
@@ -580,17 +580,17 @@ bool
 bp_table::do_add_breakpoint_1 (octave_user_code *fcn,
                                const std::string& fname,
                                const bp_table::intmap& line,
                                const std::string& condition,
                                bp_table::intmap& retval)
 {
   bool found = false;
 
-  tree_statement_list *cmds = fcn->body ();
+  octave::tree_statement_list *cmds = fcn->body ();
 
   std::string file = fcn->fcn_file_name ();
 
   if (cmds)
     {
       retval = cmds->add_breakpoint (file, line, condition);
 
       for (auto& idx_line_p : retval)
@@ -625,27 +625,27 @@ bp_table::condition_valid (const std::st
     {
       octave::parser parser (cond + " ;"); // ; to reject partial expr like "y=="
       parser.reset ();
       int parse_status = parser.run ();
       if (parse_status)
         error ("dbstop: Cannot parse condition '%s'", cond.c_str ());
       else
         {
-          tree_statement *stmt = 0;
+          octave::tree_statement *stmt = 0;
           if (! parser.stmt_list)
             error ("dbstop: "
                    "condition is not empty, but has nothing to evaluate");
           else
             {
               if (parser.stmt_list->length () == 1
                   && (stmt = parser.stmt_list->front ())
                   && stmt->is_expression ())
                 {
-                  tree_expression *expr = stmt->expression ();
+                  octave::tree_expression *expr = stmt->expression ();
                   if (expr->is_assignment_expression ())
                     error ("dbstop: condition cannot be an assignment.  "
                            "Did you mean '=='?");
                 }
               else
                 error ("dbstop: condition must be an expression");
             }
         }
@@ -763,17 +763,17 @@ int
 bp_table::do_remove_breakpoint_1 (octave_user_code *fcn,
                                   const std::string& fname,
                                   const bp_table::intmap& line)
 {
   int retval = 0;
 
   std::string file = fcn->fcn_file_name ();
 
-  tree_statement_list *cmds = fcn->body ();
+  octave::tree_statement_list *cmds = fcn->body ();
 
   // FIXME: move the operation on cmds to the tree_statement_list class?
 
   if (cmds)
     {
       octave_value_list results = cmds->list_breakpoints ();
 
       if (results.length () > 0)
@@ -866,17 +866,17 @@ bp_table::do_remove_all_breakpoints_in_f
   intmap retval;
 
   octave_user_code *dbg_fcn = get_user_code (fname);
 
   if (dbg_fcn)
     {
       std::string file = dbg_fcn->fcn_file_name ();
 
-      tree_statement_list *cmds = dbg_fcn->body ();
+      octave::tree_statement_list *cmds = dbg_fcn->body ();
 
       if (cmds)
         {
           retval = cmds->remove_all_breakpoints (file);
 
           bp_set_iterator it = bp_set.find (fname);
           if (it != bp_set.end ())
             bp_set.erase (it);
@@ -937,17 +937,17 @@ bp_table::do_get_breakpoint_list (const 
     {
       if (fname_list.empty ()
           || do_find_bkpt_list (fname_list, bp_fname) != "")
         {
           octave_user_code *f = get_user_code (bp_fname);
 
           if (f)
             {
-              tree_statement_list *cmds = f->body ();
+              octave::tree_statement_list *cmds = f->body ();
 
               // FIXME: move the operation on cmds to the
               //        tree_statement_list class?
               if (cmds)
                 {
                   std::list<bp_type> bkpts = cmds->breakpoints_and_conds ();
 
                   if (! bkpts.empty ())
diff --git a/libinterp/corefcn/defun.cc b/libinterp/corefcn/defun.cc
--- a/libinterp/corefcn/defun.cc
+++ b/libinterp/corefcn/defun.cc
@@ -56,17 +56,17 @@ print_usage (void)
     print_usage (cur->name ());
   else
     error ("print_usage: invalid function");
 }
 
 void
 print_usage (const std::string& name)
 {
-  feval ("print_usage", octave_value (name), 0);
+  octave::feval ("print_usage", octave_value (name), 0);
 }
 
 void
 check_version (const std::string& version, const std::string& fcn)
 {
   if (version != OCTAVE_API_VERSION)
     {
       error ("API version %s found in .oct file function '%s'\n"
diff --git a/libinterp/corefcn/dot.cc b/libinterp/corefcn/dot.cc
--- a/libinterp/corefcn/dot.cc
+++ b/libinterp/corefcn/dot.cc
@@ -176,17 +176,17 @@ but avoids forming a temporary array and
     }
   else
     {
       // Non-optimized evaluation.
       octave_value_list tmp;
       tmp(1) = dim + 1;
       tmp(0) = do_binary_op (octave_value::op_el_mul, argx, argy);
 
-      tmp = feval ("sum", tmp, 1);
+      tmp = octave::feval ("sum", tmp, 1);
       if (! tmp.empty ())
         retval = tmp(0);
     }
 
   return retval;
 }
 
 /*
diff --git a/libinterp/corefcn/graphics.cc b/libinterp/corefcn/graphics.cc
--- a/libinterp/corefcn/graphics.cc
+++ b/libinterp/corefcn/graphics.cc
@@ -9735,24 +9735,24 @@ gh_manager::do_execute_callback (const g
         fcn = cb.function_value ();
       else if (cb.is_string ())
         {
           int status;
           std::string s = cb.string_value ();
 
           try
             {
-              eval_string (s, false, status, 0);
+              octave::eval_string (s, false, status, 0);
             }
           catch (octave::execution_exception&)
             {
               std::cerr << "execution error in graphics callback function"
                         << std::endl;
-              feval ("lasterr",
-                     ovl ("execution error in graphics callback function"));
+              octave::feval ("lasterr",
+                             ovl ("execution error in graphics callback function"));
               recover_from_exception ();
             }
         }
       else if (cb.is_cell () && cb.length () > 0
                && (cb.rows () == 1 || cb.columns () == 1)
                && (cb.cell_value ()(0).is_function ()
                    || cb.cell_value ()(0).is_function_handle ()))
         {
@@ -9768,24 +9768,24 @@ gh_manager::do_execute_callback (const g
           std::string nm = cb.class_name ();
           error ("trying to execute non-executable object (class = %s)",
                  nm.c_str ());
         }
 
       if (fcn)
         try
           {
-            feval (fcn, args);
+            octave::feval (fcn, args);
           }
         catch (octave::execution_exception&)
           {
             std::cerr << "execution error in graphics callback function"
                       << std::endl;
-            feval ("lasterr",
-                   ovl ("execution error in graphics callback function"));
+            octave::feval ("lasterr",
+                           ovl ("execution error in graphics callback function"));
             recover_from_exception ();
           }
 
       // Redraw after interacting with a user-interface (ui*) object.
       if (Vdrawnow_requested)
         {
           graphics_object go = get_object (h);
 
@@ -11031,17 +11031,17 @@ gtk_manager::do_get_toolkit (void) const
       const_available_toolkits_iterator pa = available_toolkits.find (dtk);
 
       if (pa == available_toolkits.end ())
         error ("default graphics toolkit '%s' is not available!",
                dtk.c_str ());
 
       octave_value_list args;
       args(0) = dtk;
-      feval ("graphics_toolkit", args);
+      octave::feval ("graphics_toolkit", args);
 
       pl = loaded_toolkits.find (dtk);
 
       if (pl == loaded_toolkits.end ())
         error ("failed to load %s graphics toolkit", dtk.c_str ());
 
       retval = pl->second;
     }
@@ -11545,17 +11545,17 @@ set_property_in_handle (double handle, c
 static bool
 compare_property_values (const octave_value& ov1, const octave_value& ov2)
 {
   octave_value_list args(2);
 
   args(0) = ov1;
   args(1) = ov2;
 
-  octave_value_list result = feval ("isequal", args, 1);
+  octave_value_list result = octave::feval ("isequal", args, 1);
 
   if (result.length () > 0)
     return result(0).bool_value ();
 
   return false;
 }
 
 static std::map<uint32_t, bool> waitfor_results;
diff --git a/libinterp/corefcn/help.cc b/libinterp/corefcn/help.cc
--- a/libinterp/corefcn/help.cc
+++ b/libinterp/corefcn/help.cc
@@ -190,17 +190,17 @@ make_name_list (void)
   const int cfl_len = cfl.numel ();
 
   const string_vector lcl = symbol_table::variable_names ();
   const int lcl_len = lcl.numel ();
 
   const string_vector ffl = load_path::fcn_names ();
   const int ffl_len = ffl.numel ();
 
-  const string_vector afl = autoloaded_functions ();
+  const string_vector afl = octave::autoloaded_functions ();
   const int afl_len = afl.numel ();
 
   const string_vector lfl = local_functions ();
   const int lfl_len = lfl.numel ();
 
   const int total_len
     = key_len + bif_len + cfl_len + lcl_len + ffl_len + afl_len + lfl_len;
 
@@ -293,17 +293,17 @@ raw_help_from_symbol_table (const std::s
 }
 
 static bool
 raw_help_from_file (const std::string& nm, std::string& h,
                     std::string& file, bool& symbol_found)
 {
   bool retval = false;
 
-  h = get_help_from_file (nm, symbol_found, file);
+  h = octave::get_help_from_file (nm, symbol_found, file);
 
   if (h.length () > 0)
     retval = true;
 
   return retval;
 }
 
 static bool
@@ -836,17 +836,17 @@ in that directory.
 @end deftypefn */)
 {
   octave_value retval;
 
   if (args.length () == 0)
     {
       // Get list of all functions
       string_vector ffl = load_path::fcn_names ();
-      string_vector afl = autoloaded_functions ();
+      string_vector afl = octave::autoloaded_functions ();
 
       retval = Cell (ffl.append (afl));
     }
   else
     {
       std::string dir = args(0).xstring_value ("__list_functions__: DIRECTORY argument must be a string");
 
       string_vector fl = load_path::files (dir, true);
diff --git a/libinterp/corefcn/hook-fcn.h b/libinterp/corefcn/hook-fcn.h
--- a/libinterp/corefcn/hook-fcn.h
+++ b/libinterp/corefcn/hook-fcn.h
@@ -123,17 +123,17 @@ public:
 
   void eval (const octave_value_list& initial_args)
   {
     octave_value_list args = initial_args;
 
     if (data.is_defined ())
       args.append (data);
 
-    feval (name, args, 0);
+    octave::feval (name, args, 0);
   }
 
   std::string id (void) { return name; }
 
   bool is_valid (void) { return is_valid_function (name); }
 
 private:
 
diff --git a/libinterp/corefcn/input.cc b/libinterp/corefcn/input.cc
--- a/libinterp/corefcn/input.cc
+++ b/libinterp/corefcn/input.cc
@@ -200,17 +200,17 @@ interactive_input (const std::string& s,
   Vlast_prompt_time.stamp ();
 
   if (Vdrawnow_requested && octave::application::interactive ())
     {
       bool eval_error = false;
 
       try
         {
-          feval ("drawnow");
+          octave::feval ("drawnow");
         }
       catch (const octave::execution_exception& e)
         {
           eval_error = true;
 
           std::string stack_trace = e.info ();
 
           if (! stack_trace.empty ())
@@ -826,17 +826,17 @@ get_user_input (const octave_value_list&
         retval(0) = "";
       else
         retval(0) = input_buf;
     }
   else
     {
       int parse_status = 0;
 
-      retval = eval_string (input_buf, true, parse_status, nargout);
+      retval = octave::eval_string (input_buf, true, parse_status, nargout);
 
       if (! Vdebugging && retval.empty ())
         retval(0) = Matrix ();
     }
 
   return retval;
 }
 
diff --git a/libinterp/corefcn/interpreter.cc b/libinterp/corefcn/interpreter.cc
--- a/libinterp/corefcn/interpreter.cc
+++ b/libinterp/corefcn/interpreter.cc
@@ -355,17 +355,17 @@ from the list, so if a function was plac
 static void
 safe_source_file (const std::string& file_name,
                   const std::string& context = "",
                   bool verbose = false, bool require_file = true,
                   const std::string& warn_for = "")
 {
   try
     {
-      source_file (file_name, context, verbose, require_file, warn_for);
+      octave::source_file (file_name, context, verbose, require_file, warn_for);
     }
   catch (const octave::index_exception& e)
     {
       recover_from_exception ();
 
       std::cerr << "error: index exception in " << file_name << ": "
                 << e.message () << std::endl;
     }
@@ -986,17 +986,17 @@ namespace octave
     while (! octave_atexit_functions.empty ())
       {
         std::string fcn = octave_atexit_functions.front ();
 
         octave_atexit_functions.pop_front ();
 
         OCTAVE_SAFE_CALL (reset_error_handler, ());
 
-        OCTAVE_SAFE_CALL (feval, (fcn, octave_value_list (), 0));
+        OCTAVE_SAFE_CALL (octave::feval, (fcn, octave_value_list (), 0));
 
         OCTAVE_SAFE_CALL (octave::flush_stdout, ());
       }
 
     if (! deja_vu)
       {
         deja_vu = true;
 
diff --git a/libinterp/corefcn/load-path.cc b/libinterp/corefcn/load-path.cc
--- a/libinterp/corefcn/load-path.cc
+++ b/libinterp/corefcn/load-path.cc
@@ -2144,17 +2144,17 @@ execute_pkg_add_or_del (const std::strin
 
   octave::unwind_protect frame;
 
   std::string file = octave::sys::file_ops::concat (dir, script_file);
 
   octave::sys::file_stat fs (file);
 
   if (fs.exists ())
-    source_file (file, "base");
+    octave::source_file (file, "base");
 }
 
 void
 load_path::execute_pkg_add (const std::string& dir)
 {
   execute_pkg_add_or_del (dir, "PKG_ADD");
 }
 
diff --git a/libinterp/corefcn/ls-mat5.cc b/libinterp/corefcn/ls-mat5.cc
--- a/libinterp/corefcn/ls-mat5.cc
+++ b/libinterp/corefcn/ls-mat5.cc
@@ -882,17 +882,17 @@ read_mat5_binary_element (std::istream& 
                     if (fs.exists ())
                       {
                         size_t xpos
                           = str.find_last_of (octave::sys::file_ops::dir_sep_chars ());
 
                         std::string dir_name = str.substr (0, xpos);
 
                         octave_function *fcn
-                          = load_fcn_from_file (str, dir_name, "", "", fname);
+                          = octave::load_fcn_from_file (str, dir_name, "", "", fname);
 
                         if (fcn)
                           {
                             octave_value tmp (fcn);
 
                             tc = octave_value (new octave_fcn_handle (tmp,
                                                                       fname));
                           }
@@ -911,17 +911,17 @@ read_mat5_binary_element (std::istream& 
                           octave::sys::env::make_absolute (p.find_first_of (names));
 
                         size_t xpos
                           = str.find_last_of (octave::sys::file_ops::dir_sep_chars ());
 
                         std::string dir_name = str.substr (0, xpos);
 
                         octave_function *fcn
-                          = load_fcn_from_file (str, dir_name, "", "", fname);
+                          = octave::load_fcn_from_file (str, dir_name, "", "", fname);
 
                         if (fcn)
                           {
                             octave_value tmp (fcn);
 
                             tc = octave_value (new octave_fcn_handle (tmp,
                                                                       fname));
                           }
@@ -936,17 +936,17 @@ read_mat5_binary_element (std::istream& 
                 else
                   {
                     size_t xpos
                       = fpath.find_last_of (octave::sys::file_ops::dir_sep_chars ());
 
                     std::string dir_name = fpath.substr (0, xpos);
 
                     octave_function *fcn
-                      = load_fcn_from_file (fpath, dir_name, "", "", fname);
+                      = octave::load_fcn_from_file (fpath, dir_name, "", "", fname);
 
                     if (fcn)
                       {
                         octave_value tmp (fcn);
 
                         tc = octave_value (new octave_fcn_handle (tmp, fname));
                       }
                     else
@@ -999,17 +999,17 @@ read_mat5_binary_element (std::istream& 
                     octave_value val = m2.contents (p0);
 
                     symbol_table::assign (key, val, local_scope, 0);
                   }
               }
 
             int parse_status;
             octave_value anon_fcn_handle =
-              eval_string (fname.substr (4), true, parse_status);
+              octave::eval_string (fname.substr (4), true, parse_status);
 
             if (parse_status != 0)
               error ("load: failed to load anonymous function handle");
 
             octave_fcn_handle *fh =
               anon_fcn_handle.fcn_handle_value ();
 
             if (! fh)
@@ -1204,17 +1204,17 @@ read_mat5_binary_element (std::istream& 
                       warning ("load: unable to reconstruct object inheritance");
 
                     tc = cls;
                     if (load_path::find_method (classname, "loadobj")
                         != "")
                       {
                         try
                           {
-                            octave_value_list tmp = feval ("loadobj", tc, 1);
+                            octave_value_list tmp = octave::feval ("loadobj", tc, 1);
 
                             tc = tmp(0);
                           }
                         catch (const octave::execution_exception&)
                           {
                             goto data_read_error;
                           }
                       }
@@ -2601,17 +2601,17 @@ save_mat5_binary_element (std::ostream& 
       octave_map m;
 
       if (tc.is_object ()
           && load_path::find_method (tc.class_name (),
                                      "saveobj") != "")
         {
           try
             {
-              octave_value_list tmp = feval ("saveobj", tc, 1);
+              octave_value_list tmp = octave::feval ("saveobj", tc, 1);
 
               m = tmp(0).map_value ();
             }
           catch (const octave::execution_exception&)
             {
               error ("save: error while writing '%s' to MAT file",
                      name.c_str ());
             }
diff --git a/libinterp/corefcn/mex.cc b/libinterp/corefcn/mex.cc
--- a/libinterp/corefcn/mex.cc
+++ b/libinterp/corefcn/mex.cc
@@ -3175,17 +3175,17 @@ mexCallMATLAB (int nargout, mxArray *arg
     args(i) = mxArray::as_octave_value (argin[i]);
 
   bool execution_error = false;
 
   octave_value_list retval;
 
   try
     {
-      retval = feval (fname, args, nargout);
+      retval = octave::feval (fname, args, nargout);
     }
   catch (const octave::execution_exception&)
     {
       if (mex_context->trap_feval_error)
         {
           recover_from_exception ();
 
           execution_error = true;
@@ -3257,17 +3257,17 @@ mexEvalString (const char *s)
 
   int parse_status;
   bool execution_error = false;
 
   octave_value_list ret;
 
   try
     {
-      ret = eval_string (s, false, parse_status, 0);
+      ret = octave::eval_string (s, false, parse_status, 0);
     }
   catch (const octave::execution_exception&)
     {
       recover_from_exception ();
 
       execution_error = true;
     }
 
@@ -3284,17 +3284,17 @@ mexEvalStringWithTrap (const char *s)
 
   int parse_status;
   bool execution_error = false;
 
   octave_value_list ret;
 
   try
     {
-      ret = eval_string (s, false, parse_status, 0);
+      ret = octave::eval_string (s, false, parse_status, 0);
     }
   catch (const octave::execution_exception&)
     {
       recover_from_exception ();
 
       execution_error = true;
     }
 
diff --git a/libinterp/corefcn/oct-hist.cc b/libinterp/corefcn/oct-hist.cc
--- a/libinterp/corefcn/oct-hist.cc
+++ b/libinterp/corefcn/oct-hist.cc
@@ -498,17 +498,17 @@ do_edit_history (const octave_value_list
 
   frame.add_fcn (unlink_cleanup, name.c_str ());
   frame.protect_var (Vecho_executing_commands);
   frame.protect_var (input_from_tmp_history_file);
 
   Vecho_executing_commands = ECHO_CMD_LINE;
   input_from_tmp_history_file = true;
 
-  source_file (name);
+  octave::source_file (name);
 }
 
 static void
 do_run_history (const octave_value_list& args)
 {
   std::string name = mk_tmp_hist_file (args, false, "run_history");
 
   if (name.empty ())
@@ -520,17 +520,17 @@ do_run_history (const octave_value_list&
 
   frame.add_fcn (unlink_cleanup, name.c_str ());
   frame.protect_var (Vecho_executing_commands);
   frame.protect_var (input_from_tmp_history_file);
 
   Vecho_executing_commands = ECHO_CMD_LINE;
   input_from_tmp_history_file = true;
 
-  source_file (name);
+  octave::source_file (name);
 }
 
 void
 initialize_history (bool read_history_file)
 {
   octave::command_history::initialize (read_history_file,
                                        default_history_file (),
                                        default_history_size (),
diff --git a/libinterp/corefcn/pr-output.cc b/libinterp/corefcn/pr-output.cc
--- a/libinterp/corefcn/pr-output.cc
+++ b/libinterp/corefcn/pr-output.cc
@@ -3647,17 +3647,17 @@ myobj = myclass (@dots{})
   // disp is done.
 
   bool print_newlines = false;
   if (valid_identifier (name))
     print_newlines = value.print_name_tag (octave_stdout, name);
 
   // Use feval so that dispatch will also work for disp.
 
-  feval ("disp", ovl (value));
+  octave::feval ("disp", ovl (value));
 
   if (print_newlines)
     octave_stdout << std::endl;
 
   return ovl ();
 }
 
 /*
diff --git a/libinterp/corefcn/quadcc.cc b/libinterp/corefcn/quadcc.cc
--- a/libinterp/corefcn/quadcc.cc
+++ b/libinterp/corefcn/quadcc.cc
@@ -1670,17 +1670,17 @@ Mathematical Software, Vol. 37, Issue 3,
             ex(i) = tan (M_PI / 2 * (m + xi[i] * h));
         }
       else
         {
           for (i = 0; i <= n[3]; i++)
             ex(i) = m + xi[i] * h;
         }
       fargs(0) = ex;
-      fvals = feval (fcn, fargs, 1);
+      fvals = octave::feval (fcn, fargs, 1);
       if (fvals.length () != 1 || ! fvals(0).is_real_matrix ())
         error ("quadcc: integrand F must return a single, real-valued vector");
 
       Matrix effex = fvals(0).matrix_value ();
       if (effex.numel () != ex.numel ())
         error ("quadcc: integrand F must return a single, real-valued vector of the same size as the input");
 
       for (i = 0; i <= n[3]; i++)
@@ -1780,17 +1780,17 @@ Mathematical Software, Vol. 37, Issue 3,
                   ex(i) = tan (M_PI / 2 * (m + xi[(2 * i + 1) * skip[d]] * h));
               }
             else
               {
                 for (i = 0; i < n[d] / 2; i++)
                   ex(i) = m + xi[(2 * i + 1) * skip[d]] * h;
               }
             fargs(0) = ex;
-            fvals = feval (fcn, fargs, 1);
+            fvals = octave::feval (fcn, fargs, 1);
             if (fvals.length () != 1 || ! fvals(0).is_real_matrix ())
               error ("quadcc: integrand F must return a single, real-valued vector");
 
             Matrix effex = fvals(0).matrix_value ();
             if (effex.numel () != ex.numel ())
               error ("quadcc: integrand F must return a single, real-valued vector of the same size as the input");
 
             neval += effex.numel ();
@@ -1917,17 +1917,17 @@ Mathematical Software, Vol. 37, Issue 3,
                   ex(i) = tan (M_PI / 2 * (ml + xi[(i + 1) * skip[0]] * hl));
               }
             else
               {
                 for (i = 0; i < n[0] - 1; i++)
                   ex(i) = ml + xi[(i + 1) * skip[0]] * hl;
               }
             fargs(0) = ex;
-            fvals = feval (fcn, fargs, 1);
+            fvals = octave::feval (fcn, fargs, 1);
             if (fvals.length () != 1 || ! fvals(0).is_real_matrix ())
               error ("quadcc: integrand F must return a single, real-valued vector");
 
             Matrix effex = fvals(0).matrix_value ();
             if (effex.numel () != ex.numel ())
               error ("quadcc: integrand F must return a single, real-valued vector of the same size as the input");
 
             neval += effex.numel ();
@@ -2008,17 +2008,17 @@ Mathematical Software, Vol. 37, Issue 3,
                   ex(i) = tan (M_PI / 2 * (mr + xi[(i + 1) * skip[0]] * hr));
               }
             else
               {
                 for (i = 0; i < n[0] - 1; i++)
                   ex(i) = mr + xi[(i + 1) * skip[0]] * hr;
               }
             fargs(0) = ex;
-            fvals = feval (fcn, fargs, 1);
+            fvals = octave::feval (fcn, fargs, 1);
             if (fvals.length () != 1 || ! fvals(0).is_real_matrix ())
               error ("quadcc: integrand F must return a single, real-valued vector");
 
             Matrix effex = fvals(0).matrix_value ();
             if (effex.numel () != ex.numel ())
               error ("quadcc: integrand F must return a single, real-valued vector of the same size as the input");
 
             neval += effex.numel ();
diff --git a/libinterp/corefcn/symtab.cc b/libinterp/corefcn/symtab.cc
--- a/libinterp/corefcn/symtab.cc
+++ b/libinterp/corefcn/symtab.cc
@@ -189,18 +189,19 @@ split_name_with_package (const std::stri
 static inline bool
 load_out_of_date_fcn (const std::string& ff, const std::string& dir_name,
                       octave_value& function,
                       const std::string& dispatch_type = "",
                       const std::string& package_name = "")
 {
   bool retval = false;
 
-  octave_function *fcn = load_fcn_from_file (ff, dir_name, dispatch_type,
-                                             package_name);
+  octave_function *fcn
+    = octave::load_fcn_from_file (ff, dir_name, dispatch_type,
+                                  package_name);
 
   if (fcn)
     {
       retval = true;
 
       function = octave_value (fcn);
     }
   else
@@ -293,17 +294,17 @@ out_of_date_check (octave_value& functio
 
                                       it++;
                                     }
                                 }
                             }
 
                           // Maybe it's an autoload?
                           if (file.empty ())
-                            file = lookup_autoload (nm);
+                            file = octave::lookup_autoload (nm);
 
                           if (file.empty ())
                             file = load_path::find_fcn (nm, dir_name, pack);
                         }
 
                       if (! file.empty ())
                         is_same_file = same_file (file, ff);
                     }
@@ -386,17 +387,17 @@ symbol_table::fcn_info::fcn_info_rep::lo
   (const std::string& dir_name)
 {
   octave_value retval;
 
   std::string file_name = load_path::find_private_fcn (dir_name, name);
 
   if (! file_name.empty ())
     {
-      octave_function *fcn = load_fcn_from_file (file_name, dir_name);
+      octave_function *fcn = octave::load_fcn_from_file (file_name, dir_name);
 
       if (fcn)
         {
           std::string class_name;
 
           size_t pos = dir_name.find_last_of (octave::sys::file_ops::dir_sep_chars ());
 
           if (pos != std::string::npos)
@@ -425,18 +426,19 @@ symbol_table::fcn_info::fcn_info_rep::lo
 
   std::string dir_name;
 
   std::string file_name = load_path::find_method (name, name, dir_name,
                                                   package_name);
 
   if (! file_name.empty ())
     {
-      octave_function *fcn = load_fcn_from_file (file_name, dir_name, name,
-                                                 package_name);
+      octave_function *fcn
+        = octave::load_fcn_from_file (file_name, dir_name, name,
+                                      package_name);
 
       if (fcn)
         {
           retval = octave_value (fcn);
 
           class_constructors[name] = retval;
           class_methods[name] = retval;
         }
@@ -491,18 +493,19 @@ symbol_table::fcn_info::fcn_info_rep::lo
         {
           std::string dir_name;
 
           std::string file_name = load_path::find_method (dispatch_type, name,
                                                           dir_name);
 
           if (! file_name.empty ())
             {
-              octave_function *fcn = load_fcn_from_file (file_name, dir_name,
-                                                         dispatch_type);
+              octave_function *fcn
+                = octave::load_fcn_from_file (file_name, dir_name,
+                                              dispatch_type);
 
               if (fcn)
                 {
                   retval = octave_value (fcn);
 
                   class_methods[dispatch_type] = retval;
                 }
             }
@@ -1004,26 +1007,27 @@ symbol_table::fcn_info::fcn_info_rep::fi
 {
   // Autoloaded function.
 
   if (autoload_function.is_defined ())
     out_of_date_check (autoload_function);
 
   if (! autoload_function.is_defined ())
     {
-      std::string file_name = lookup_autoload (name);
+      std::string file_name = octave::lookup_autoload (name);
 
       if (! file_name.empty ())
         {
           size_t pos = file_name.find_last_of (octave::sys::file_ops::dir_sep_chars ());
 
           std::string dir_name = file_name.substr (0, pos);
 
-          octave_function *fcn = load_fcn_from_file (file_name, dir_name, "",
-                                                     "", name, true);
+          octave_function *fcn
+            = octave::load_fcn_from_file (file_name, dir_name, "", "",
+                                          name, true);
 
           if (fcn)
             autoload_function = octave_value (fcn);
         }
     }
 
   return autoload_function;
 }
@@ -1040,18 +1044,19 @@ symbol_table::fcn_info::fcn_info_rep::fi
     {
       std::string dir_name;
 
       std::string file_name = load_path::find_fcn (name, dir_name,
                                                    package_name);
 
       if (! file_name.empty ())
         {
-          octave_function *fcn = load_fcn_from_file (file_name, dir_name, "",
-                                                     package_name);
+          octave_function *fcn
+            = octave::load_fcn_from_file (file_name, dir_name, "",
+                                          package_name);
 
           if (fcn)
             function_on_path = octave_value (fcn);
         }
     }
 
   return function_on_path;
 }
@@ -1818,17 +1823,17 @@ Undocumented internal function.
   octave_user_function *f = ov.user_function_value ();
 
   octave_value_list retval;
 
   if (f)
     {
       std::ostringstream buf;
 
-      tree_print_code tpc (buf);
+      octave::tree_print_code tpc (buf);
 
       f->accept (tpc);
 
       retval = ovl (buf.str ());
     }
 
   return retval;
 }
diff --git a/libinterp/corefcn/variables.cc b/libinterp/corefcn/variables.cc
--- a/libinterp/corefcn/variables.cc
+++ b/libinterp/corefcn/variables.cc
@@ -156,17 +156,17 @@ extract_function (const octave_value& ar
                                          warn_for.c_str ());
 
       std::string cmd = header;
       cmd.append (s);
       cmd.append (trailer);
 
       int parse_status;
 
-      eval_string (cmd, true, parse_status, 0);
+      octave::eval_string (cmd, true, parse_status, 0);
 
       if (parse_status != 0)
         error ("%s: '%s' is not valid as a function",
                warn_for.c_str (), fname.c_str ());
 
       retval = is_valid_function (fname, warn_for, 0);
 
       if (! retval)
@@ -272,17 +272,17 @@ generate_struct_completions (const std::
           frame.protect_var (discard_error_messages);
           frame.protect_var (discard_warning_messages);
 
           discard_error_messages = true;
           discard_warning_messages = true;
 
           try
             {
-              octave_value tmp = eval_string (prefix, true, parse_status);
+              octave_value tmp = octave::eval_string (prefix, true, parse_status);
 
               frame.run ();
 
               if (tmp.is_defined ()
                   && (tmp.is_map () || tmp.is_java () || tmp.is_classdef_object ()))
                 names = tmp.map_keys ();
             }
           catch (const octave::execution_exception&)
@@ -418,17 +418,17 @@ symbol_exist (const std::string& name, c
       octave_value val = symbol_table::find_cmdline_function (name);
 
       if (val.is_defined ())
         return 103;
     }
 
   if (search_any || search_file || search_dir)
     {
-      std::string file_name = lookup_autoload (name);
+      std::string file_name = octave::lookup_autoload (name);
 
       if (file_name.empty ())
         file_name = load_path::find_fcn (name);
 
       size_t len = file_name.length ();
 
       if (len > 0)
         {
@@ -1662,17 +1662,17 @@ do_who (int argc, const string_vector& a
 
           symbol_table::set_scope (tmp_scope);
 
           octave::call_stack::push (tmp_scope, 0);
           frame.add_fcn (octave::call_stack::pop);
 
           frame.add_fcn (symbol_table::clear_variables);
 
-          feval ("load", octave_value (nm), 0);
+          octave::feval ("load", octave_value (nm), 0);
 
           std::string newmsg = std::string ("Variables in the file ")
                                + nm + ":\n\n";
 
           retval = do_who (i, argv, return_list, verbose, newmsg);
 
           return retval;
         }
@@ -1747,17 +1747,17 @@ do_who (int argc, const string_vector& a
                       symbol_table::symbol_record sr
                         = symbol_table::find_symbol (base_name);
 
                       if (! global_only || sr.is_global ())
                         {
                           int parse_status;
 
                           octave_value expr_val
-                            = eval_string (pat, true, parse_status);
+                            = octave::eval_string (pat, true, parse_status);
 
                           symbol_stats.append (sr, pat, expr_val);
                         }
                     }
                 }
             }
           else
             {
@@ -1951,30 +1951,30 @@ bind_ans (const octave_value& val, bool 
         {
           symbol_table::force_assign (ans, val);
 
           if (print)
             {
               octave_value_list args = ovl (val);
               args.stash_name_tags (string_vector (ans));
 
-              feval ("display", args);
+              octave::feval ("display", args);
             }
         }
     }
 }
 
 void
 bind_internal_variable (const std::string& fname, const octave_value& val)
 {
   octave_value_list args;
 
   args(0) = val;
 
-  feval (fname, args, 0);
+  octave::feval (fname, args, 0);
 }
 
 void
 mlock (void)
 {
   octave_function *fcn = octave::call_stack::current ();
 
   if (! fcn)
@@ -2635,17 +2635,17 @@ void maybe_missing_function_hook (const 
           octave::unwind_protect frame;
           frame.protect_var (Vmissing_function_hook);
 
           // Clear the variable prior to calling the function.
           const std::string func_name = Vmissing_function_hook;
           Vmissing_function_hook.clear ();
 
           // Call.
-          feval (func_name, octave_value (name));
+          octave::feval (func_name, octave_value (name));
         }
     }
 }
 
 DEFUN (__varval__, args, ,
        doc: /* -*- texinfo -*-
 @deftypefn {} {} __varval__ (@var{name})
 Return the value of the variable @var{name} directly from the symbol table.
diff --git a/libinterp/corefcn/variables.h b/libinterp/corefcn/variables.h
--- a/libinterp/corefcn/variables.h
+++ b/libinterp/corefcn/variables.h
@@ -23,22 +23,26 @@ along with Octave; see the file COPYING.
 #if ! defined (octave_variables_h)
 #define octave_variables_h 1
 
 #include "octave-config.h"
 
 class octave_function;
 class octave_user_function;
 
-class tree_identifier;
 class octave_value;
 class octave_value_list;
 class octave_builtin;
 class string_vector;
 
+namespace octave
+{
+  class tree_identifier;
+}
+
 #include <cfloat>
 
 #include <limits>
 #include <string>
 
 #include "lo-ieee.h"
 
 #include "ov.h"
diff --git a/libinterp/dldfcn/__init_fltk__.cc b/libinterp/dldfcn/__init_fltk__.cc
--- a/libinterp/dldfcn/__init_fltk__.cc
+++ b/libinterp/dldfcn/__init_fltk__.cc
@@ -1062,17 +1062,17 @@ private:
   // Menu height
   static const int menu_h = 25;
 
   // Window callback.
   static void window_close (Fl_Widget*, void* data)
   {
     octave_value_list args;
     args(0) = static_cast<plot_window*> (data)->number ();
-    feval ("close", args);
+    octave::feval ("close", args);
   }
 
   // Button callbacks.
   static void button_callback (Fl_Widget* ww, void* data)
   {
     static_cast<plot_window*> (data)->button_press (ww, data);
   }
 
@@ -1129,28 +1129,28 @@ private:
 
   void axis_auto (void)
   {
     octave_value_list args;
     if (fp.get_currentaxes ().ok ())
       {
         args(0) = fp.get_currentaxes ().as_octave_value ();
         args(1) = "auto";
-        feval ("axis", args);
+        octave::feval ("axis", args);
         mark_modified ();
       }
   }
 
   void toggle_grid (void)
   {
     octave_value_list args;
     if (fp.get_currentaxes ().ok ())
       args(0) = fp.get_currentaxes ().as_octave_value ();
 
-    feval ("grid", args);
+    octave::feval ("grid", args);
     mark_modified ();
   }
 
   void pixel2pos (const graphics_handle& ax, int px, int py, double& xx,
                   double& yy) const
   {
     pixel2pos (gh_manager::get_object (ax), px, py, xx, yy);
   }
diff --git a/libinterp/dldfcn/__init_gnuplot__.cc b/libinterp/dldfcn/__init_gnuplot__.cc
--- a/libinterp/dldfcn/__init_gnuplot__.cc
+++ b/libinterp/dldfcn/__init_gnuplot__.cc
@@ -102,30 +102,30 @@ public:
           }
       }
   }
 
   void redraw_figure (const graphics_object& go) const
   {
     octave_value_list args;
     args(0) = go.get_handle ().as_octave_value ();
-    feval ("__gnuplot_drawnow__", args);
+    octave::feval ("__gnuplot_drawnow__", args);
   }
 
   void print_figure (const graphics_object& go, const std::string& term,
                      const std::string& file,
                      const std::string& debug_file) const
   {
     octave_value_list args;
     if (! debug_file.empty ())
       args(3) = debug_file;
     args(2) = file;
     args(1) = term;
     args(0) = go.get_handle ().as_octave_value ();
-    feval ("__gnuplot_drawnow__", args);
+    octave::feval ("__gnuplot_drawnow__", args);
   }
 
   Matrix get_canvas_size (const graphics_handle&) const
   {
     Matrix sz (1, 2, 0.0);
     return sz;
   }
 
@@ -176,17 +176,18 @@ static bool
 have_gnuplot_binary (void)
 {
   const std::string exeext = octave::build_env::EXEEXT;
   const std::string path = octave::sys::env::getenv ("PATH");
   bool retval = false;
 
   try
     {
-      octave_value_list tmp = feval ("gnuplot_binary", octave_value_list ());
+      octave_value_list tmp
+        = octave::feval ("gnuplot_binary", octave_value_list ());
 
       if (tmp(0).is_string ())
         {
           std::string gnuplot_binary = tmp(0).string_value ();
 
           string_vector args (gnuplot_binary);
           std::string gnuplot_path = search_path_for_file (path, args);
 
diff --git a/libinterp/dldfcn/__ode15__.cc b/libinterp/dldfcn/__ode15__.cc
--- a/libinterp/dldfcn/__ode15__.cc
+++ b/libinterp/dldfcn/__ode15__.cc
@@ -649,25 +649,25 @@ namespace octave
 
     octave_value_list args = ovl (tsol, y, yp);
 
     // cont is the number of steps reached by the solver
     // temp is the number of events registered
 
     if (flag == "init")
       {
-        octave_value_list output = feval (event_fcn, args, 3);
+        octave_value_list output = octave::feval (event_fcn, args, 3);
         oldval = output(0).vector_value ();
         oldisterminal = output(1).vector_value ();
         olddir = output(2).vector_value ();
       }
     else if (flag == "")
       {
         ColumnVector index (0);
-        octave_value_list output = feval (event_fcn, args, 3);
+        octave_value_list output = octave::feval (event_fcn, args, 3);
         ColumnVector val = output(0).vector_value ();
         ColumnVector isterminal = output(1).vector_value ();
         ColumnVector dir = output(2).vector_value ();
 
         // Get the index of the changed values
         for (octave_idx_type i = 0; i < val.numel (); i++)
           {
             if ((val(i) > 0 && oldval(i) < 0 && dir(i) != -1) // increasing
@@ -829,28 +829,28 @@ namespace octave
 
     if (flag == "init")
       {
         ColumnVector toutput(2);
         toutput(0) = tsol;
         toutput(1) = tend;
         output(0) = toutput;
 
-        feval (output_fcn, output, 0);
+        octave::feval (output_fcn, output, 0);
       }
     else if (flag == "")
       {
         output(0) = tsol;
-        octave_value_list val = feval (output_fcn, output, 1);
+        octave_value_list val = octave::feval (output_fcn, output, 1);
         status = val(0).bool_value ();
       }
     else
       {  // Cleanup plotter
         output(0) = tend;
-        feval (output_fcn, output, 0);
+        octave::feval (output_fcn, output, 0);
       }
 
     return status;
   }
 
   void
   IDA::set_maxstep (realtype maxstep)
   {
diff --git a/libinterp/dldfcn/audiodevinfo.cc b/libinterp/dldfcn/audiodevinfo.cc
--- a/libinterp/dldfcn/audiodevinfo.cc
+++ b/libinterp/dldfcn/audiodevinfo.cc
@@ -538,18 +538,19 @@ octave_play_callback (const void *, void
                       const PaStreamCallbackTimeInfo *,
                       PaStreamCallbackFlags, void *data)
 {
   audioplayer *player = static_cast<audioplayer *> (data);
 
   if (! player)
     error ("audio player callback function called without player");
 
-  octave_value_list retval = feval (player->octave_callback_function,
-                                    ovl (static_cast<double> (frames)), 1);
+  octave_value_list retval
+    = octave::feval (player->octave_callback_function,
+                     ovl (static_cast<double> (frames)), 1);
 
   if (retval.length () < 2)
     error ("audio player callback function failed");
 
   const Matrix sound = retval(0).matrix_value ();
   int return_status = retval(1).int_value ();
 
   if (frames - sound.rows () != 0 || sound.columns () < 1
@@ -1363,17 +1364,17 @@ octave_record_callback (const void *inpu
             sample_r32 |= 0xff000000;
 
           sound(i,0) = sample_l32 / scale_factor;
           sound(i,1) = sample_r32 / scale_factor;
         }
     }
 
   octave_value_list retval
-    = feval (recorder->octave_callback_function, ovl (sound), 1);
+    = octave::feval (recorder->octave_callback_function, ovl (sound), 1);
 
   return retval(0).int_value ();
 }
 
 static int
 portaudio_record_callback (const void *input, void *, unsigned long frames,
                            const PaStreamCallbackTimeInfo *,
                            PaStreamCallbackFlags, void *data)
diff --git a/libinterp/octave-value/ov-base-diag.h b/libinterp/octave-value/ov-base-diag.h
--- a/libinterp/octave-value/ov-base-diag.h
+++ b/libinterp/octave-value/ov-base-diag.h
@@ -32,18 +32,16 @@ along with Octave; see the file COPYING.
 
 #include "mx-base.h"
 #include "str-vec.h"
 
 #include "ovl.h"
 #include "ov-base.h"
 #include "ov-typeinfo.h"
 
-class tree_walker;
-
 // Real matrix values.
 
 template <typename DMT, typename MT>
 class
 octave_base_diag : public octave_base_value
 {
 
 public:
diff --git a/libinterp/octave-value/ov-base-mat.h b/libinterp/octave-value/ov-base-mat.h
--- a/libinterp/octave-value/ov-base-mat.h
+++ b/libinterp/octave-value/ov-base-mat.h
@@ -35,18 +35,16 @@ along with Octave; see the file COPYING.
 #include "str-vec.h"
 #include "MatrixType.h"
 
 #include "error.h"
 #include "ovl.h"
 #include "ov-base.h"
 #include "ov-typeinfo.h"
 
-class tree_walker;
-
 // Real matrix values.
 
 template <typename MT>
 class
 octave_base_matrix : public octave_base_value
 {
 public:
 
diff --git a/libinterp/octave-value/ov-base-sparse.h b/libinterp/octave-value/ov-base-sparse.h
--- a/libinterp/octave-value/ov-base-sparse.h
+++ b/libinterp/octave-value/ov-base-sparse.h
@@ -36,18 +36,16 @@ along with Octave; see the file COPYING.
 #include "error.h"
 #include "ovl.h"
 #include "ov-base.h"
 #include "ov-typeinfo.h"
 
 #include "boolSparse.h"
 #include "MatrixType.h"
 
-class tree_walker;
-
 class octave_sparse_bool_matrix;
 
 template <typename T>
 class
 octave_base_sparse : public octave_base_value
 {
 public:
 
diff --git a/libinterp/octave-value/ov-base.h b/libinterp/octave-value/ov-base.h
--- a/libinterp/octave-value/ov-base.h
+++ b/libinterp/octave-value/ov-base.h
@@ -51,18 +51,16 @@ class octave_function;
 class octave_user_function;
 class octave_user_script;
 class octave_user_code;
 class octave_fcn_handle;
 class octave_fcn_inline;
 class octave_value_list;
 class octave_lvalue;
 
-class tree_walker;
-
 enum builtin_type_t
 {
   btyp_double,
   btyp_float,
   btyp_complex,
   btyp_float_complex,
   btyp_int8,
   btyp_int16,
diff --git a/libinterp/octave-value/ov-bool-mat.h b/libinterp/octave-value/ov-bool-mat.h
--- a/libinterp/octave-value/ov-bool-mat.h
+++ b/libinterp/octave-value/ov-bool-mat.h
@@ -39,18 +39,16 @@ along with Octave; see the file COPYING.
 #include "ov-base-mat.h"
 #include "ov-re-mat.h"
 #include "ov-typeinfo.h"
 
 #include "MatrixType.h"
 
 class octave_value_list;
 
-class tree_walker;
-
 // Character matrix values.
 
 class
 octave_bool_matrix : public octave_base_matrix<boolNDArray>
 {
 public:
 
   octave_bool_matrix (void)
diff --git a/libinterp/octave-value/ov-bool-sparse.h b/libinterp/octave-value/ov-bool-sparse.h
--- a/libinterp/octave-value/ov-bool-sparse.h
+++ b/libinterp/octave-value/ov-bool-sparse.h
@@ -40,18 +40,16 @@ along with Octave; see the file COPYING.
 #include "ov-typeinfo.h"
 
 #include "boolSparse.h"
 #include "ov-base-sparse.h"
 #include "ov-re-sparse.h"
 
 class octave_value_list;
 
-class tree_walker;
-
 class
 OCTINTERP_API
 octave_sparse_bool_matrix : public octave_base_sparse<SparseBoolMatrix>
 {
 public:
 
   octave_sparse_bool_matrix (void)
     : octave_base_sparse<SparseBoolMatrix> () { }
diff --git a/libinterp/octave-value/ov-bool.h b/libinterp/octave-value/ov-bool.h
--- a/libinterp/octave-value/ov-bool.h
+++ b/libinterp/octave-value/ov-bool.h
@@ -38,18 +38,16 @@ along with Octave; see the file COPYING.
 #include "ov-base.h"
 #include "ov-base-scalar.h"
 #include "ov-bool-mat.h"
 #include "ov-scalar.h"
 #include "ov-typeinfo.h"
 
 class octave_value_list;
 
-class tree_walker;
-
 // Real scalar values.
 
 class
 OCTINTERP_API
 octave_bool : public octave_base_scalar<bool>
 {
 public:
 
diff --git a/libinterp/octave-value/ov-cell.h b/libinterp/octave-value/ov-cell.h
--- a/libinterp/octave-value/ov-cell.h
+++ b/libinterp/octave-value/ov-cell.h
@@ -37,18 +37,16 @@ along with Octave; see the file COPYING.
 
 #include "Cell.h"
 #include "error.h"
 #include "ov-base-mat.h"
 #include "ov-typeinfo.h"
 
 class octave_value_list;
 
-class tree_walker;
-
 // Cells.
 
 class
 octave_cell : public octave_base_matrix<Cell>
 {
 public:
 
   octave_cell (void)
diff --git a/libinterp/octave-value/ov-ch-mat.h b/libinterp/octave-value/ov-ch-mat.h
--- a/libinterp/octave-value/ov-ch-mat.h
+++ b/libinterp/octave-value/ov-ch-mat.h
@@ -39,18 +39,16 @@ along with Octave; see the file COPYING.
 #include "ov-base.h"
 #include "ov-base-mat.h"
 #include "ov-int64.h"
 #include "ov-re-mat.h"
 #include "ov-typeinfo.h"
 
 class octave_value_list;
 
-class tree_walker;
-
 // Character matrix values.
 
 class
 octave_char_matrix : public octave_base_matrix<charNDArray>
 {
 protected:
 
   octave_char_matrix (void)
diff --git a/libinterp/octave-value/ov-class.cc b/libinterp/octave-value/ov-class.cc
--- a/libinterp/octave-value/ov-class.cc
+++ b/libinterp/octave-value/ov-class.cc
@@ -293,17 +293,17 @@ octave_class::size (void)
   Matrix retval (1, 2, 1.0);
   octave_value meth = symbol_table::find_method ("size", class_name ());
 
   if (meth.is_defined ())
     {
       count++;
       octave_value_list args (1, octave_value (this));
 
-      octave_value_list lv = feval (meth.function_value (), args, 1);
+      octave_value_list lv = octave::feval (meth.function_value (), args, 1);
       if (lv.length () <= 0
           || ! lv(0).is_matrix_type () || ! lv(0).dims ().is_vector ())
         error ("@%s/size: invalid return value", class_name ().c_str ());
 
       retval = lv(0).matrix_value ();
     }
   else
     {
@@ -336,17 +336,17 @@ octave_class::numel (const octave_value_
       octave_value_list args (idx.length () + 1, octave_value ());
 
       count++;
       args(0) = octave_value (this);
 
       for (octave_idx_type i = 0; i < idx.length (); i++)
         args(i+1) = idx(i);
 
-      octave_value_list lv = feval (meth.function_value (), args, 1);
+      octave_value_list lv = octave::feval (meth.function_value (), args, 1);
       if (lv.length () != 1 || ! lv(0).is_scalar_type ())
         error ("@%s/numel: invalid return value", cn.c_str ());
 
       retval = lv(0).idx_type_value (true);
     }
   else
     retval = octave_base_value::numel (idx);
 
@@ -447,17 +447,17 @@ octave_class::subsref (const std::string
           if (maybe_cs_list_query)
             {
               // Set up a proper nargout for the subsref call by calling numel.
               octave_value_list tmp;
               if (type[0] != '.') tmp = idx.front ();
               true_nargout = numel (tmp);
             }
 
-          retval = feval (meth.function_value (), args, true_nargout);
+          retval = octave::feval (meth.function_value (), args, true_nargout);
 
           // Since we're handling subsref, return the list in the first value
           // if it has more than one element, to be able to pass through
           // rvalue1 calls.
           if (retval.length () > 1)
             retval = octave_value (retval, true);
         }
       else
@@ -556,20 +556,20 @@ octave_class::subsasgn_common (const oct
 
           if (obsolete_copies == 0 && meth.is_user_function ()
               && meth.user_function_value ()->subsasgn_optimization_ok ())
             {
               octave::unwind_protect frame;
               frame.protect_var (obsolete_copies);
               obsolete_copies = 2;
 
-              tmp = feval (meth.function_value (), args);
+              tmp = octave::feval (meth.function_value (), args);
             }
           else
-            tmp = feval (meth.function_value (), args);
+            tmp = octave::feval (meth.function_value (), args);
 
           // FIXME: Should the subsasgn method be able to return
           //        more than one value?
 
           if (tmp.length () > 1)
             error ("@%s/subsasgn returned more than one value",
                    class_name ().c_str ());
 
@@ -799,17 +799,17 @@ octave_class::index_vector (bool require
 
   if (! meth.is_defined ())
     error ("no subsindex method defined for class %s",
            class_name ().c_str ());
 
   octave_value_list args;
   args(0) = octave_value (new octave_class (map, c_name, parent_list));
 
-  octave_value_list tmp = feval (meth.function_value (), args, 1);
+  octave_value_list tmp = octave::feval (meth.function_value (), args, 1);
 
   if (tmp(0).is_object ())
     error ("subsindex function must return a valid index vector");
 
   // Index vector returned by subsindex is zero based
   // (why this inconsistency Mathworks?), and so we must
   // add one to the value returned as the index_vector method
   // expects it to be one based.
@@ -842,17 +842,17 @@ octave_class::is_true (void) const
   bool retval = false;
 
   octave_value meth = symbol_table::find_method ("logical", class_name ());
 
   if (meth.is_defined ())
     {
       octave_value in = new octave_class (*this);
 
-      octave_value_list tmp = feval (meth.function_value (), in, 1);
+      octave_value_list tmp = octave::feval (meth.function_value (), in, 1);
       retval = tmp(0).is_true ();
     }
 
   return retval;
 }
 
 string_vector
 octave_class::map_keys (void) const
@@ -960,17 +960,17 @@ octave_class::string_vector_value (bool 
   octave_value meth = symbol_table::find_method ("char", class_name ());
 
   if (! meth.is_defined ())
     error ("no char method defined for class %s", class_name ().c_str ());
 
   octave_value_list args;
   args(0) = octave_value (new octave_class (map, c_name, parent_list));
 
-  octave_value_list tmp = feval (meth.function_value (), args, 1);
+  octave_value_list tmp = octave::feval (meth.function_value (), args, 1);
 
   if (tmp.length () >= 1)
     {
       if (! tmp(0).is_string ())
         error ("cname/char method did not return a string");
 
       retval = tmp(0).string_vector_value (pad);
     }
@@ -1147,17 +1147,17 @@ octave_class::reconstruct_parents (void)
 bool
 octave_class::save_ascii (std::ostream& os)
 {
   os << "# classname: " << class_name () << "\n";
   octave_map m;
   if (load_path::find_method (class_name (), "saveobj") != "")
     {
       octave_value in = new octave_class (*this);
-      octave_value_list tmp = feval ("saveobj", in, 1);
+      octave_value_list tmp = octave::feval ("saveobj", in, 1);
 
       m = tmp(0).map_value ();
     }
   else
     m = map_value ();
 
   os << "# length: " << m.nfields () << "\n";
 
@@ -1220,17 +1220,17 @@ octave_class::load_ascii (std::istream& 
 
       if (! reconstruct_parents ())
         warning ("load: unable to reconstruct object inheritance");
 
       if (load_path::find_method (classname, "loadobj")
           != "")
         {
           octave_value in = new octave_class (*this);
-          octave_value_list tmp = feval ("loadobj", in, 1);
+          octave_value_list tmp = octave::feval ("loadobj", in, 1);
 
           map = tmp(0).map_value ();
         }
     }
   else if (len == 0)
     {
       map = octave_map (dim_vector (1, 1));
       c_name = classname;
@@ -1248,17 +1248,17 @@ octave_class::save_binary (std::ostream&
 
   os.write (reinterpret_cast<char *> (&classname_len), 4);
   os << class_name ();
 
   octave_map m;
   if (load_path::find_method (class_name (), "saveobj") != "")
     {
       octave_value in = new octave_class (*this);
-      octave_value_list tmp = feval ("saveobj", in, 1);
+      octave_value_list tmp = octave::feval ("saveobj", in, 1);
 
       m = tmp(0).map_value ();
     }
   else
     m = map_value ();
 
   int32_t len = m.nfields ();
   os.write (reinterpret_cast<char *> (&len), 4);
@@ -1335,17 +1335,17 @@ octave_class::load_binary (std::istream&
           map = m;
 
           if (! reconstruct_parents ())
             warning ("load: unable to reconstruct object inheritance");
 
           if (load_path::find_method (c_name, "loadobj") != "")
             {
               octave_value in = new octave_class (*this);
-              octave_value_list tmp = feval ("loadobj", in, 1);
+              octave_value_list tmp = octave::feval ("loadobj", in, 1);
 
               map = tmp(0).map_value ();
             }
         }
       else
         {
           warning ("load: failed to load class");
           success = false;
@@ -1412,17 +1412,17 @@ octave_class::save_hdf5 (octave_hdf5_id 
   data_hid = H5Gcreate (group_hid, "value", 0);
 #endif
   if (data_hid < 0)
     goto error_cleanup;
 
   if (load_path::find_method (class_name (), "saveobj") != "")
     {
       octave_value in = new octave_class (*this);
-      octave_value_list tmp = feval ("saveobj", in, 1);
+      octave_value_list tmp = octave::feval ("saveobj", in, 1);
 
       m = tmp(0).map_value ();
     }
   else
     m = map_value ();
 
   // recursively add each element of the class to this group
   i = m.begin ();
@@ -1580,17 +1580,17 @@ octave_class::load_hdf5 (octave_hdf5_id 
       map = m;
 
       if (! reconstruct_parents ())
         warning ("load: unable to reconstruct object inheritance");
 
       if (load_path::find_method (c_name, "loadobj") != "")
         {
           octave_value in = new octave_class (*this);
-          octave_value_list tmp = feval ("loadobj", in, 1);
+          octave_value_list tmp = octave::feval ("loadobj", in, 1);
 
           map = tmp(0).map_value ();
           retval = true;
         }
     }
 
 error_cleanup:
   if (data_hid > 0)
diff --git a/libinterp/octave-value/ov-class.h b/libinterp/octave-value/ov-class.h
--- a/libinterp/octave-value/ov-class.h
+++ b/libinterp/octave-value/ov-class.h
@@ -36,18 +36,16 @@ along with Octave; see the file COPYING.
 
 #include "error.h"
 #include "oct-map.h"
 #include "ov-base.h"
 #include "ov-typeinfo.h"
 
 class octave_value_list;
 
-class tree_walker;
-
 // Data structures.
 
 class
 octave_class : public octave_base_value
 {
 public:
 
   octave_class (void)
diff --git a/libinterp/octave-value/ov-classdef.cc b/libinterp/octave-value/ov-classdef.cc
--- a/libinterp/octave-value/ov-classdef.cc
+++ b/libinterp/octave-value/ov-classdef.cc
@@ -439,17 +439,17 @@ is_method_executing (const octave_value&
 
       if (uf)
         {
           // At this point, the method is executing, but we still need to
           // check the context object for which the method is executing.  For
           // methods, it's the first argument of the function; for ctors, it
           // is the first return value.
 
-          tree_parameter_list* pl = uf->is_classdef_constructor ()
+          octave::tree_parameter_list* pl = uf->is_classdef_constructor ()
             ? uf->return_list () : uf->parameter_list ();
 
           if (pl && pl->size () > 0)
             {
               octave_value arg0 = pl->front ()->lvalue ().value ();
 
               if (arg0.is_defined () && arg0.type_name () == "object")
                 {
@@ -1176,17 +1176,17 @@ private:
     octave_function *of = octave::call_stack::current ();
 
     if (of->is_classdef_constructor ())
       {
         octave_user_function *uf = of->user_function_value (true);
 
         if (uf)
           {
-            tree_parameter_list *ret_list = uf->return_list ();
+            octave::tree_parameter_list *ret_list = uf->return_list ();
 
             if (ret_list && ret_list->length () == 1)
               return (ret_list->front ()->name () == nm);
           }
       }
 
     return false;
   }
@@ -1826,50 +1826,50 @@ cdef_class::cdef_class_rep::find_method 
           if (meth.ok ())
             return meth;
         }
     }
 
   return cdef_method ();
 }
 
-class ctor_analyzer : public tree_walker
+class ctor_analyzer : public octave::tree_walker
 {
 public:
   ctor_analyzer (const std::string& ctor, const std::string& obj)
-    : tree_walker (), who (ctor), obj_name (obj) { }
-
-  void visit_statement_list (tree_statement_list& t)
+    : octave::tree_walker (), who (ctor), obj_name (obj) { }
+
+  void visit_statement_list (octave::tree_statement_list& t)
   {
     for (const auto& stmt_p : t)
       stmt_p->accept (*this);
   }
 
-  void visit_statement (tree_statement& t)
+  void visit_statement (octave::tree_statement& t)
   {
     if (t.is_expression ())
       t.expression ()->accept (*this);
   }
 
-  void visit_simple_assignment (tree_simple_assignment& t)
+  void visit_simple_assignment (octave::tree_simple_assignment& t)
   {
     t.right_hand_side ()->accept (*this);
   }
 
-  void visit_multi_assignment (tree_multi_assignment& t)
+  void visit_multi_assignment (octave::tree_multi_assignment& t)
   {
     t.right_hand_side ()->accept (*this);
   }
 
-  void visit_index_expression (tree_index_expression& t)
+  void visit_index_expression (octave::tree_index_expression& t)
   {
     t.expression ()->accept (*this);
   }
 
-  void visit_funcall (tree_funcall& t)
+  void visit_funcall (octave::tree_funcall& t)
   {
     octave_value fcn = t.function ();
 
     if (fcn.is_function ())
       {
         octave_function *of = fcn.function_value (true);
 
         if (of)
@@ -1891,52 +1891,52 @@ public:
           }
       }
   }
 
   std::list<cdef_class> get_constructor_list (void) const
   { return ctor_list; }
 
   // NO-OP
-  void visit_anon_fcn_handle (tree_anon_fcn_handle&) { }
-  void visit_argument_list (tree_argument_list&) { }
-  void visit_binary_expression (tree_binary_expression&) { }
-  void visit_break_command (tree_break_command&) { }
-  void visit_colon_expression (tree_colon_expression&) { }
-  void visit_continue_command (tree_continue_command&) { }
-  void visit_global_command (tree_global_command&) { }
-  void visit_persistent_command (tree_persistent_command&) { }
-  void visit_decl_elt (tree_decl_elt&) { }
-  void visit_decl_init_list (tree_decl_init_list&) { }
-  void visit_simple_for_command (tree_simple_for_command&) { }
-  void visit_complex_for_command (tree_complex_for_command&) { }
+  void visit_anon_fcn_handle (octave::tree_anon_fcn_handle&) { }
+  void visit_argument_list (octave::tree_argument_list&) { }
+  void visit_binary_expression (octave::tree_binary_expression&) { }
+  void visit_break_command (octave::tree_break_command&) { }
+  void visit_colon_expression (octave::tree_colon_expression&) { }
+  void visit_continue_command (octave::tree_continue_command&) { }
+  void visit_global_command (octave::tree_global_command&) { }
+  void visit_persistent_command (octave::tree_persistent_command&) { }
+  void visit_decl_elt (octave::tree_decl_elt&) { }
+  void visit_decl_init_list (octave::tree_decl_init_list&) { }
+  void visit_simple_for_command (octave::tree_simple_for_command&) { }
+  void visit_complex_for_command (octave::tree_complex_for_command&) { }
   void visit_octave_user_script (octave_user_script&) { }
   void visit_octave_user_function (octave_user_function&) { }
-  void visit_function_def (tree_function_def&) { }
-  void visit_identifier (tree_identifier&) { }
-  void visit_if_clause (tree_if_clause&) { }
-  void visit_if_command (tree_if_command&) { }
-  void visit_if_command_list (tree_if_command_list&) { }
-  void visit_switch_case (tree_switch_case&) { }
-  void visit_switch_case_list (tree_switch_case_list&) { }
-  void visit_switch_command (tree_switch_command&) { }
-  void visit_matrix (tree_matrix&) { }
-  void visit_cell (tree_cell&) { }
-  void visit_no_op_command (tree_no_op_command&) { }
-  void visit_constant (tree_constant&) { }
-  void visit_fcn_handle (tree_fcn_handle&) { }
-  void visit_parameter_list (tree_parameter_list&) { }
-  void visit_postfix_expression (tree_postfix_expression&) { }
-  void visit_prefix_expression (tree_prefix_expression&) { }
-  void visit_return_command (tree_return_command&) { }
-  void visit_return_list (tree_return_list&) { }
-  void visit_try_catch_command (tree_try_catch_command&) { }
-  void visit_unwind_protect_command (tree_unwind_protect_command&) { }
-  void visit_while_command (tree_while_command&) { }
-  void visit_do_until_command (tree_do_until_command&) { }
+  void visit_function_def (octave::tree_function_def&) { }
+  void visit_identifier (octave::tree_identifier&) { }
+  void visit_if_clause (octave::tree_if_clause&) { }
+  void visit_if_command (octave::tree_if_command&) { }
+  void visit_if_command_list (octave::tree_if_command_list&) { }
+  void visit_switch_case (octave::tree_switch_case&) { }
+  void visit_switch_case_list (octave::tree_switch_case_list&) { }
+  void visit_switch_command (octave::tree_switch_command&) { }
+  void visit_matrix (octave::tree_matrix&) { }
+  void visit_cell (octave::tree_cell&) { }
+  void visit_no_op_command (octave::tree_no_op_command&) { }
+  void visit_constant (octave::tree_constant&) { }
+  void visit_fcn_handle (octave::tree_fcn_handle&) { }
+  void visit_parameter_list (octave::tree_parameter_list&) { }
+  void visit_postfix_expression (octave::tree_postfix_expression&) { }
+  void visit_prefix_expression (octave::tree_prefix_expression&) { }
+  void visit_return_command (octave::tree_return_command&) { }
+  void visit_return_list (octave::tree_return_list&) { }
+  void visit_try_catch_command (octave::tree_try_catch_command&) { }
+  void visit_unwind_protect_command (octave::tree_unwind_protect_command&) { }
+  void visit_while_command (octave::tree_while_command&) { }
+  void visit_do_until_command (octave::tree_do_until_command&) { }
 
 private:
   // The name of the constructor being analyzed.
   std::string who;
 
   // The name of the first output argument of the constructor.
   std::string obj_name;
 
@@ -1959,18 +1959,18 @@ cdef_class::cdef_class_rep::install_meth
       octave_function *of = meth.get_function ().function_value (true);
 
       if (of)
         {
           octave_user_function *uf = of->user_function_value (true);
 
           if (uf)
             {
-              tree_parameter_list *ret_list = uf->return_list ();
-              tree_statement_list *body = uf->body ();
+              octave::tree_parameter_list *ret_list = uf->return_list ();
+              octave::tree_statement_list *body = uf->body ();
 
               if (! ret_list || ret_list->size () != 1)
                 error ("%s: invalid constructor output arguments",
                        meth.get_name ().c_str ());
 
               std::string obj_name = ret_list->front ()->name ();
               ctor_analyzer a (meth.get_name (), obj_name);
 
@@ -2492,17 +2492,17 @@ cdef_class::cdef_class_rep::construct_ob
 
       return obj;
     }
 
   return cdef_object ();
 }
 
 static octave_value
-compute_attribute_value (tree_classdef_attribute* t)
+compute_attribute_value (octave::tree_classdef_attribute* t)
 {
   if (t->expression ())
     {
       if (t->expression ()->is_identifier ())
         {
           std::string s = t->expression ()->name ();
 
           if (s == "public")
@@ -2527,17 +2527,17 @@ attribute_value_to_string (T* t, octave_
     return v.string_value ();
   else if (t->expression ())
     return t->expression ()->original_text ();
   else
     return std::string ("true");
 }
 
 cdef_class
-cdef_class::make_meta_class (tree_classdef* t, bool is_at_folder)
+cdef_class::make_meta_class (octave::tree_classdef* t, bool is_at_folder)
 {
   cdef_class retval;
   std::string class_name, full_class_name;
 
   // Class creation
 
   class_name = full_class_name = t->ident ()->name ();
   if (! t->package_name ().empty ())
@@ -2594,29 +2594,29 @@ cdef_class::make_meta_class (tree_classd
           std::cerr << "class attribute: " << aname << " = "
                     << attribute_value_to_string (attr, avalue) << std::endl;
 #endif
 
           retval.put (aname, avalue);
         }
     }
 
-  tree_classdef_body* b = t->body ();
+  octave::tree_classdef_body* b = t->body ();
 
   if (b)
     {
       // Keep track of the get/set accessor methods.  They will be used
       // later on when creating properties.
 
       std::map<std::string, octave_value> get_methods;
       std::map<std::string, octave_value> set_methods;
 
       // Method blocks
 
-      std::list<tree_classdef_methods_block *> mb_list = b->methods_list ();
+      std::list<octave::tree_classdef_methods_block *> mb_list = b->methods_list ();
 
       for (auto& mb_p : mb_list)
         {
           std::map<std::string, octave_value> amap;
 
 #if DEBUG_TRACE
           std::cerr << "method block" << std::endl;
 #endif
@@ -2710,17 +2710,17 @@ cdef_class::make_meta_class (tree_classd
 
       // Property blocks
 
       // FIXME: default property expression should be able to call static
       //        methods of the class being constructed.  A restricted CLASSNAME
       //        symbol should be added to the scope before evaluating default
       //        value expressions.
 
-      std::list<tree_classdef_properties_block *> pb_list
+      std::list<octave::tree_classdef_properties_block *> pb_list
         = b->properties_list ();
 
       for (auto& pb_p : pb_list)
         {
           std::map<std::string, octave_value> amap;
 
 #if DEBUG_TRACE
           std::cerr << "property block" << std::endl;
@@ -2972,19 +2972,19 @@ cdef_method::cdef_method_rep::check_meth
             }
 
           std::string dir_name;
           std::string file_name = load_path::find_method (cls_name, name,
                                                           dir_name, pack_name);
 
           if (! file_name.empty ())
             {
-              octave_function *fcn = load_fcn_from_file (file_name, dir_name,
-                                                         dispatch_type,
-                                                         pack_name);
+              octave_function *fcn = octave::load_fcn_from_file (file_name, dir_name,
+                                                                 dispatch_type,
+                                                                 pack_name);
 
               if (fcn)
                 {
                   function = octave_value (fcn);
 
                   make_function_of_class (dispatch_type, function);
                 }
             }
diff --git a/libinterp/octave-value/ov-classdef.h b/libinterp/octave-value/ov-classdef.h
--- a/libinterp/octave-value/ov-classdef.h
+++ b/libinterp/octave-value/ov-classdef.h
@@ -35,17 +35,20 @@ along with Octave; see the file COPYING.
 #include "symtab.h"
 
 class cdef_object;
 class cdef_class;
 class cdef_property;
 class cdef_method;
 class cdef_package;
 
-class tree_classdef;
+namespace octave
+{
+  class tree_classdef;
+}
 
 // This is mainly a boostrap class to declare the expected interface.
 // The actual base class is cdef_class_base, which is declared after
 // cdef_object, such that it can contain cdef_object objects.
 class
 cdef_object_rep
 {
 public:
@@ -824,17 +827,17 @@ public:
   { return get_rep ()->get_name (); }
 
   bool is_builtin (void) const
   { return get_directory ().empty (); }
 
   void delete_object (cdef_object obj)
   { get_rep ()->delete_object (obj); }
 
-  static cdef_class make_meta_class (tree_classdef* t,
+  static cdef_class make_meta_class (octave::tree_classdef* t,
                                      bool is_at_folder = false);
 
   octave_function* get_method_function (const std::string& nm);
 
   octave_function* get_constructor_function (void)
   { return get_method_function (get_name ()); }
 
   octave_value construct (const octave_value_list& args)
diff --git a/libinterp/octave-value/ov-colon.h b/libinterp/octave-value/ov-colon.h
--- a/libinterp/octave-value/ov-colon.h
+++ b/libinterp/octave-value/ov-colon.h
@@ -34,18 +34,16 @@ along with Octave; see the file COPYING.
 #include "str-vec.h"
 
 #include "error.h"
 #include "ov-base.h"
 #include "ov-typeinfo.h"
 
 class octave_value_list;
 
-class tree_walker;
-
 // A type to represent ':' as used for indexing.
 
 class
 octave_magic_colon : public octave_base_value
 {
 public:
 
   octave_magic_colon (void)
diff --git a/libinterp/octave-value/ov-complex.h b/libinterp/octave-value/ov-complex.h
--- a/libinterp/octave-value/ov-complex.h
+++ b/libinterp/octave-value/ov-complex.h
@@ -38,18 +38,16 @@ along with Octave; see the file COPYING.
 #include "error.h"
 #include "ov-base.h"
 #include "ov-cx-mat.h"
 #include "ov-base-scalar.h"
 #include "ov-typeinfo.h"
 
 class octave_value_list;
 
-class tree_walker;
-
 // Complex scalar values.
 
 class
 OCTINTERP_API
 octave_complex : public octave_base_scalar<Complex>
 {
 public:
 
diff --git a/libinterp/octave-value/ov-cs-list.h b/libinterp/octave-value/ov-cs-list.h
--- a/libinterp/octave-value/ov-cs-list.h
+++ b/libinterp/octave-value/ov-cs-list.h
@@ -33,18 +33,16 @@ along with Octave; see the file COPYING.
 #include "mx-base.h"
 #include "str-vec.h"
 
 #include "Cell.h"
 #include "error.h"
 #include "ovl.h"
 #include "ov-typeinfo.h"
 
-class tree_walker;
-
 // Lists.
 
 class
 octave_cs_list : public octave_base_value
 {
 public:
 
   octave_cs_list (void)
diff --git a/libinterp/octave-value/ov-cx-mat.h b/libinterp/octave-value/ov-cx-mat.h
--- a/libinterp/octave-value/ov-cx-mat.h
+++ b/libinterp/octave-value/ov-cx-mat.h
@@ -39,18 +39,16 @@ along with Octave; see the file COPYING.
 #include "ov-base.h"
 #include "ov-base-mat.h"
 #include "ov-typeinfo.h"
 
 #include "MatrixType.h"
 
 class octave_value_list;
 
-class tree_walker;
-
 // Complex matrix values.
 
 class
 OCTINTERP_API
 octave_complex_matrix : public octave_base_matrix<ComplexNDArray>
 {
 public:
 
diff --git a/libinterp/octave-value/ov-cx-sparse.h b/libinterp/octave-value/ov-cx-sparse.h
--- a/libinterp/octave-value/ov-cx-sparse.h
+++ b/libinterp/octave-value/ov-cx-sparse.h
@@ -40,18 +40,16 @@ along with Octave; see the file COPYING.
 #include "ov-typeinfo.h"
 
 #include "CSparse.h"
 #include "ov-base-sparse.h"
 #include "ov-re-sparse.h"
 
 class octave_value_list;
 
-class tree_walker;
-
 class
 OCTINTERP_API
 octave_sparse_complex_matrix : public octave_base_sparse<SparseComplexMatrix>
 {
 public:
 
   octave_sparse_complex_matrix (void)
     : octave_base_sparse<SparseComplexMatrix> () { }
diff --git a/libinterp/octave-value/ov-fcn-handle.cc b/libinterp/octave-value/ov-fcn-handle.cc
--- a/libinterp/octave-value/ov-fcn-handle.cc
+++ b/libinterp/octave-value/ov-fcn-handle.cc
@@ -273,17 +273,17 @@ octave_fcn_handle::set_fcn (const std::s
 
       if (fs.exists ())
         {
           size_t xpos = str.find_last_of (octave::sys::file_ops::dir_sep_chars ());
 
           std::string dir_name = str.substr (0, xpos);
 
           octave_function *xfcn
-            = load_fcn_from_file (str, dir_name, "", "", nm);
+            = octave::load_fcn_from_file (str, dir_name, "", "", nm);
 
           if (! xfcn)
             error ("function handle points to non-existent function");
 
           octave_value tmp (xfcn);
 
           fcn = octave_value (new octave_fcn_handle (tmp, nm));
         }
@@ -298,17 +298,17 @@ octave_fcn_handle::set_fcn (const std::s
           octave::directory_path p (load_path::system_path ());
 
           str = octave::sys::env::make_absolute (p.find_first_of (names));
 
           size_t xpos = str.find_last_of (octave::sys::file_ops::dir_sep_chars ());
 
           std::string dir_name = str.substr (0, xpos);
 
-          octave_function *xfcn = load_fcn_from_file (str, dir_name, "", "", nm);
+          octave_function *xfcn = octave::load_fcn_from_file (str, dir_name, "", "", nm);
 
           if (! xfcn)
             error ("function handle points to non-existent function");
 
           octave_value tmp (xfcn);
 
           fcn = octave_value (new octave_fcn_handle (tmp, nm));
         }
@@ -316,17 +316,17 @@ octave_fcn_handle::set_fcn (const std::s
   else
     {
       if (fpath.length () > 0)
         {
           size_t xpos = fpath.find_last_of (octave::sys::file_ops::dir_sep_chars ());
 
           std::string dir_name = fpath.substr (0, xpos);
 
-          octave_function *xfcn = load_fcn_from_file (fpath, dir_name, "", "", nm);
+          octave_function *xfcn = octave::load_fcn_from_file (fpath, dir_name, "", "", nm);
 
           if (! xfcn)
             error ("function handle points to non-existent function");
 
           octave_value tmp (xfcn);
 
           fcn = octave_value (new octave_fcn_handle (tmp, nm));
         }
@@ -466,17 +466,17 @@ octave_fcn_handle::load_ascii (std::istr
           is.seekg (pos);
           is.clear ();
         }
 
       if (is && success)
         {
           int parse_status;
           octave_value anon_fcn_handle =
-            eval_string (buf, true, parse_status);
+            octave::eval_string (buf, true, parse_status);
 
           if (parse_status == 0)
             {
               octave_fcn_handle *fh =
                 anon_fcn_handle.fcn_handle_value ();
 
               if (fh)
                 {
@@ -640,18 +640,18 @@ octave_fcn_handle::load_binary (std::ist
 
               symbol_table::assign (name, t2, local_scope);
             }
         }
 
       if (is && success)
         {
           int parse_status;
-          octave_value anon_fcn_handle =
-            eval_string (ctmp2, true, parse_status);
+          octave_value anon_fcn_handle
+            = octave::eval_string (ctmp2, true, parse_status);
 
           if (parse_status == 0)
             {
               octave_fcn_handle *fh = anon_fcn_handle.fcn_handle_value ();
 
               if (fh)
                 {
                   fcn = fh->fcn;
@@ -1163,18 +1163,18 @@ octave_fcn_handle::load_hdf5 (octave_hdf
 
               symbol_table::assign (dsub.name, dsub.tc, local_scope);
             }
         }
 
       if (success)
         {
           int parse_status;
-          octave_value anon_fcn_handle =
-            eval_string (fcn_tmp, true, parse_status);
+          octave_value anon_fcn_handle
+            = octave::eval_string (fcn_tmp, true, parse_status);
 
           if (parse_status == 0)
             {
               octave_fcn_handle *fh = anon_fcn_handle.fcn_handle_value ();
 
               if (fh)
                 {
                   fcn = fh->fcn;
@@ -1396,28 +1396,28 @@ octave_fcn_handle::print (std::ostream& 
 
 void
 octave_fcn_handle::print_raw (std::ostream& os, bool pr_as_read_syntax) const
 {
   bool printed = false;
 
   if (nm == anonymous)
     {
-      tree_print_code tpc (os);
+      octave::tree_print_code tpc (os);
 
       // FCN is const because this member function is, so we can't
       // use it to call user_function_value, so we make a copy first.
 
       octave_value ftmp = fcn;
 
       octave_user_function *f = ftmp.user_function_value ();
 
       if (f)
         {
-          tree_parameter_list *p = f->parameter_list ();
+          octave::tree_parameter_list *p = f->parameter_list ();
 
           os << "@(";
 
           if (p)
             p->accept (tpc);
 
           os << ") ";
 
@@ -1832,18 +1832,18 @@ functions are ignored in the lookup.
 
   std::string nm = args(0).xstring_value ("str2func: FCN_NAME must be a string");
 
   octave_value retval;
 
   if (nm[0] == '@')
     {
       int parse_status;
-      octave_value anon_fcn_handle =
-        eval_string (nm, true, parse_status);
+      octave_value anon_fcn_handle
+        = octave::eval_string (nm, true, parse_status);
 
       if (parse_status == 0)
         retval = anon_fcn_handle;
     }
   else
     retval = make_fcn_handle (nm, nargin != 2);
 
   return retval;
@@ -1916,90 +1916,90 @@ octave_fcn_binder::octave_fcn_binder (co
 { }
 
 octave_fcn_handle *
 octave_fcn_binder::maybe_binder (const octave_value& f)
 {
   octave_fcn_handle *retval = 0;
 
   octave_user_function *usr_fcn = f.user_function_value (false);
-  tree_parameter_list *param_list = usr_fcn ? usr_fcn->parameter_list () : 0;
+  octave::tree_parameter_list *param_list = usr_fcn ? usr_fcn->parameter_list () : 0;
 
-  tree_statement_list *cmd_list = 0;
-  tree_expression *body_expr = 0;
+  octave::tree_statement_list *cmd_list = 0;
+  octave::tree_expression *body_expr = 0;
 
   if (usr_fcn)
     {
       cmd_list = usr_fcn->body ();
       if (cmd_list)
         {
           // Verify that body is a single expression (always true in theory).
           body_expr = (cmd_list->length () == 1
                        ? cmd_list->front ()->expression () : 0);
         }
     }
 
   if (body_expr && body_expr->is_index_expression ()
       && ! (param_list && param_list->takes_varargs ()))
     {
       // It's an index expression.
-      tree_index_expression *idx_expr = dynamic_cast<tree_index_expression *>
+      octave::tree_index_expression *idx_expr = dynamic_cast<octave::tree_index_expression *>
                                         (body_expr);
-      tree_expression *head_expr = idx_expr->expression ();
-      std::list<tree_argument_list *> arg_lists = idx_expr->arg_lists ();
+      octave::tree_expression *head_expr = idx_expr->expression ();
+      std::list<octave::tree_argument_list *> arg_lists = idx_expr->arg_lists ();
       std::string type_tags = idx_expr->type_tags ();
 
       if (type_tags.length () == 1 && type_tags[0] == '('
           && head_expr->is_identifier ())
         {
           assert (arg_lists.size () == 1);
 
           // It's a single index expression: a(x,y,....)
-          tree_identifier *head_id =
-            dynamic_cast<tree_identifier *> (head_expr);
-          tree_argument_list *arg_list = arg_lists.front ();
+          octave::tree_identifier *head_id =
+            dynamic_cast<octave::tree_identifier *> (head_expr);
+          octave::tree_argument_list *arg_list = arg_lists.front ();
 
           // Build a map of input params to their position.
           std::map<std::string, int> arginmap;
           int npar = 0;
 
           if (param_list)
             {
               for (auto& param_p : *param_list)
                 {
-                  tree_decl_elt *elt = param_p;
-                  tree_identifier *id = elt ? elt->ident () : 0;
+                  octave::tree_decl_elt *elt = param_p;
+                  octave::tree_identifier *id = elt ? elt->ident () : 0;
                   if (id && ! id->is_black_hole ())
                     arginmap[id->name ()] = npar;
                 }
             }
 
           if (arg_list && arg_list->length () > 0)
             {
               bool bad = false;
               int nargs = arg_list->length ();
               octave_value_list arg_template (nargs);
               std::vector<int> arg_mask (nargs);
 
               // Verify that each argument is either a named param, a constant,
               // or a defined identifier.
               int iarg = 0;
-              for (tree_argument_list::iterator it = arg_list->begin ();
+              for (octave::tree_argument_list::iterator it = arg_list->begin ();
                    it != arg_list->end (); ++it, ++iarg)
                 {
-                  tree_expression *elt = *it;
+                  octave::tree_expression *elt = *it;
                   if (elt && elt->is_constant ())
                     {
                       arg_template(iarg) = elt->rvalue1 ();
                       arg_mask[iarg] = -1;
                     }
                   else if (elt && elt->is_identifier ())
                     {
-                      tree_identifier *elt_id =
-                        dynamic_cast<tree_identifier *> (elt);
+                      octave::tree_identifier *elt_id =
+                        dynamic_cast<octave::tree_identifier *> (elt);
                       if (arginmap.find (elt_id->name ()) != arginmap.end ())
                         {
                           arg_mask[iarg] = arginmap[elt_id->name ()];
                         }
                       else if (elt_id->is_defined ())
                         {
                           arg_template(iarg) = elt_id->rvalue1 ();
                           arg_mask[iarg] = -1;
diff --git a/libinterp/octave-value/ov-fcn-inline.cc b/libinterp/octave-value/ov-fcn-inline.cc
--- a/libinterp/octave-value/ov-fcn-inline.cc
+++ b/libinterp/octave-value/ov-fcn-inline.cc
@@ -77,17 +77,17 @@ octave_fcn_inline::octave_fcn_inline (co
         buf << ", ";
 
       buf << ifargs(i);
     }
 
   buf << ") " << iftext;
 
   int parse_status;
-  octave_value anon_fcn_handle = eval_string (buf.str (), true, parse_status);
+  octave_value anon_fcn_handle = octave::eval_string (buf.str (), true, parse_status);
 
   if (parse_status == 0)
     {
       octave_fcn_handle *fh = anon_fcn_handle.fcn_handle_value ();
 
       if (fh)
         {
           fcn = fh->fcn_val ();
diff --git a/libinterp/octave-value/ov-fcn.h b/libinterp/octave-value/ov-fcn.h
--- a/libinterp/octave-value/ov-fcn.h
+++ b/libinterp/octave-value/ov-fcn.h
@@ -30,17 +30,20 @@ along with Octave; see the file COPYING.
 #include "oct-time.h"
 #include "str-vec.h"
 
 #include "ovl.h"
 #include "ov-base.h"
 #include "ov-typeinfo.h"
 #include "symtab.h"
 
-class tree_walker;
+namespace octave
+{
+  class tree_walker;
+}
 
 // Functions.
 
 class
 OCTINTERP_API
 octave_function : public octave_base_value
 {
 public:
@@ -185,17 +188,17 @@ public:
   }
 
   void document (const std::string& ds) { doc = ds; }
 
   std::string doc_string (void) const { return doc; }
 
   virtual void unload (void) { }
 
-  virtual void accept (tree_walker&) { }
+  virtual void accept (octave::tree_walker&) { }
 
   virtual bool is_postfix_index_handled (char type) const
   { return (type == '(' || type == '{'); }
 
 protected:
 
   octave_function (const std::string& nm,
                    const std::string& ds = "")
diff --git a/libinterp/octave-value/ov-float.h b/libinterp/octave-value/ov-float.h
--- a/libinterp/octave-value/ov-float.h
+++ b/libinterp/octave-value/ov-float.h
@@ -40,18 +40,16 @@ along with Octave; see the file COPYING.
 #include "ov-base.h"
 #include "ov-re-mat.h"
 #include "ov-flt-re-mat.h"
 #include "ov-base-scalar.h"
 #include "ov-typeinfo.h"
 
 class octave_value_list;
 
-class tree_walker;
-
 // Real scalar values.
 
 class
 OCTINTERP_API
 octave_float_scalar : public octave_base_scalar<float>
 {
 public:
 
diff --git a/libinterp/octave-value/ov-flt-complex.h b/libinterp/octave-value/ov-flt-complex.h
--- a/libinterp/octave-value/ov-flt-complex.h
+++ b/libinterp/octave-value/ov-flt-complex.h
@@ -38,18 +38,16 @@ along with Octave; see the file COPYING.
 #include "error.h"
 #include "ov-base.h"
 #include "ov-flt-cx-mat.h"
 #include "ov-base-scalar.h"
 #include "ov-typeinfo.h"
 
 class octave_value_list;
 
-class tree_walker;
-
 // Complex scalar values.
 
 class
 OCTINTERP_API
 octave_float_complex : public octave_base_scalar<FloatComplex>
 {
 public:
 
diff --git a/libinterp/octave-value/ov-flt-cx-mat.h b/libinterp/octave-value/ov-flt-cx-mat.h
--- a/libinterp/octave-value/ov-flt-cx-mat.h
+++ b/libinterp/octave-value/ov-flt-cx-mat.h
@@ -39,18 +39,16 @@ along with Octave; see the file COPYING.
 #include "ov-base.h"
 #include "ov-base-mat.h"
 #include "ov-typeinfo.h"
 
 #include "MatrixType.h"
 
 class octave_value_list;
 
-class tree_walker;
-
 // Complex matrix values.
 
 class
 OCTINTERP_API
 octave_float_complex_matrix : public octave_base_matrix<FloatComplexNDArray>
 {
 public:
 
diff --git a/libinterp/octave-value/ov-flt-re-mat.h b/libinterp/octave-value/ov-flt-re-mat.h
--- a/libinterp/octave-value/ov-flt-re-mat.h
+++ b/libinterp/octave-value/ov-flt-re-mat.h
@@ -39,18 +39,16 @@ along with Octave; see the file COPYING.
 #include "ov-base.h"
 #include "ov-base-mat.h"
 #include "ov-typeinfo.h"
 
 #include "MatrixType.h"
 
 class octave_value_list;
 
-class tree_walker;
-
 // Real matrix values.
 
 class
 OCTINTERP_API
 octave_float_matrix : public octave_base_matrix<FloatNDArray>
 {
 public:
 
diff --git a/libinterp/octave-value/ov-java.cc b/libinterp/octave-value/ov-java.cc
--- a/libinterp/octave-value/ov-java.cc
+++ b/libinterp/octave-value/ov-java.cc
@@ -1814,17 +1814,17 @@ Java_org_octave_Octave_call (JNIEnv *env
   int nargout = env->GetArrayLength (argout);
   int nargin = env->GetArrayLength (argin);
 
   octave_value_list varargin, varargout;
 
   for (int i = 0; i < nargin; i++)
     varargin(i) = box (env, env->GetObjectArrayElement (argin, i), 0);
 
-  varargout = feval (fname, varargin, nargout);
+  varargout = octave::feval (fname, varargin, nargout);
 
   jobjectArray_ref out_objs (env, argout), out_clss (env);
   out_objs.detach ();
   return unbox (env, varargout, out_objs, out_clss);
 }
 
 JNIEXPORT void JNICALL
 Java_org_octave_OctaveReference_doFinalize (JNIEnv *, jclass, jint ID)
@@ -1850,43 +1850,43 @@ Java_org_octave_Octave_doInvoke (JNIEnv 
           oct_args(i) = box (env, jobj, 0);
         }
 
       BEGIN_INTERRUPT_WITH_EXCEPTIONS;
 
       if (val.is_function_handle ())
         {
           octave_function *fcn = val.function_value ();
-          feval (fcn, oct_args);
+          octave::feval (fcn, oct_args);
         }
       else if (val.is_cell () && val.length () > 0
                && (val.rows () == 1 || val.columns () == 1)
                && val.cell_value()(0).is_function_handle ())
         {
           Cell c = val.cell_value ();
           octave_function *fcn = c(0).function_value ();
 
           for (int i=1; i<c.numel (); i++)
             oct_args(len+i-1) = c(i);
 
-          feval (fcn, oct_args);
+          octave::feval (fcn, oct_args);
         }
       else
         error ("trying to invoke non-invocable object");
 
       END_INTERRUPT_WITH_EXCEPTIONS;
     }
 }
 
 JNIEXPORT void JNICALL
 Java_org_octave_Octave_doEvalString (JNIEnv *env, jclass, jstring cmd)
 {
   std::string s = jstring_to_string (env, cmd);
   int pstatus;
-  eval_string (s, false, pstatus, 0);
+  octave::eval_string (s, false, pstatus, 0);
 }
 
 JNIEXPORT jboolean JNICALL
 Java_org_octave_Octave_needThreadedInvokation (JNIEnv *env, jclass)
 {
   return (get_current_thread_ID (env) != octave_thread_ID);
 }
 
@@ -1975,26 +1975,26 @@ octave_java::subsref (const std::string&
       if (type.length () > 1 && type[1] == '(')
         {
           octave_value_list ovl;
           count++;
           ovl(1) = octave_value (this);
           ovl(0) = (idx.front ())(0);
           std::list<octave_value_list>::const_iterator it = idx.begin ();
           ovl.append (*++it);
-          retval = feval (std::string ("javaMethod"), ovl, 1);
+          retval = octave::feval (std::string ("javaMethod"), ovl, 1);
           skip++;
         }
       else
         {
           octave_value_list ovl;
           count++;
           ovl(0) = octave_value (this);
           ovl(1) = (idx.front ())(0);
-          retval = feval (std::string ("__java_get__"), ovl, 1);
+          retval = octave::feval (std::string ("__java_get__"), ovl, 1);
         }
       break;
 
     case '(':
       if (current_env)
         retval = get_array_elements
           (current_env, TO_JOBJECT (to_java ()), idx.front ());
       break;
@@ -2040,17 +2040,17 @@ octave_java::subsasgn (const std::string
       if (type.length () == 1)
         {
           // field assignment
           octave_value_list ovl;
           count++;
           ovl(0) = octave_value (this);
           ovl(1) = (idx.front ())(0);
           ovl(2) = rhs;
-          feval ("__java_set__", ovl, 0);
+          octave::feval ("__java_set__", ovl, 0);
 
           count++;
           retval = octave_value (this);
         }
       else if (type.length () > 2 && type[1] == '(')
         {
           std::list<octave_value_list> new_idx;
           std::list<octave_value_list>::const_iterator it = idx.begin ();
diff --git a/libinterp/octave-value/ov-oncleanup.cc b/libinterp/octave-value/ov-oncleanup.cc
--- a/libinterp/octave-value/ov-oncleanup.cc
+++ b/libinterp/octave-value/ov-oncleanup.cc
@@ -43,17 +43,17 @@ octave_oncleanup::octave_oncleanup (cons
       if (! fptr)
         error ("onCleanup: no default dispatch for function handle");
 
       octave_user_function *uptr
         = dynamic_cast<octave_user_function *> (fptr);
 
       if (uptr != 0)
         {
-          tree_parameter_list *pl = uptr->parameter_list ();
+          octave::tree_parameter_list *pl = uptr->parameter_list ();
 
           if (pl != 0 && pl->length () > 0)
             warning ("onCleanup: cleanup action takes parameters");
         }
     }
   else
     {
       fcn = octave_value ();
diff --git a/libinterp/octave-value/ov-range.h b/libinterp/octave-value/ov-range.h
--- a/libinterp/octave-value/ov-range.h
+++ b/libinterp/octave-value/ov-range.h
@@ -40,18 +40,16 @@ along with Octave; see the file COPYING.
 #include "error.h"
 #include "oct-stream.h"
 #include "ov-base.h"
 #include "ov-re-mat.h"
 #include "ov-typeinfo.h"
 
 class octave_value_list;
 
-class tree_walker;
-
 // Range values.
 
 class
 octave_range : public octave_base_value
 {
 public:
 
   octave_range (void)
diff --git a/libinterp/octave-value/ov-re-mat.h b/libinterp/octave-value/ov-re-mat.h
--- a/libinterp/octave-value/ov-re-mat.h
+++ b/libinterp/octave-value/ov-re-mat.h
@@ -39,18 +39,16 @@ along with Octave; see the file COPYING.
 #include "ov-base.h"
 #include "ov-base-mat.h"
 #include "ov-typeinfo.h"
 
 #include "MatrixType.h"
 
 class octave_value_list;
 
-class tree_walker;
-
 // Real matrix values.
 
 class
 OCTINTERP_API
 octave_matrix : public octave_base_matrix<NDArray>
 {
 public:
 
diff --git a/libinterp/octave-value/ov-re-sparse.h b/libinterp/octave-value/ov-re-sparse.h
--- a/libinterp/octave-value/ov-re-sparse.h
+++ b/libinterp/octave-value/ov-re-sparse.h
@@ -41,18 +41,16 @@ along with Octave; see the file COPYING.
 
 #include "dSparse.h"
 #include "MatrixType.h"
 #include "ov-base-sparse.h"
 #include "ov-cx-sparse.h"
 
 class octave_value_list;
 
-class tree_walker;
-
 class
 OCTINTERP_API
 octave_sparse_matrix : public octave_base_sparse<SparseMatrix>
 {
 public:
 
   octave_sparse_matrix (void)
     : octave_base_sparse<SparseMatrix> () { }
diff --git a/libinterp/octave-value/ov-scalar.h b/libinterp/octave-value/ov-scalar.h
--- a/libinterp/octave-value/ov-scalar.h
+++ b/libinterp/octave-value/ov-scalar.h
@@ -39,18 +39,16 @@ along with Octave; see the file COPYING.
 #include "errwarn.h"
 #include "ov-base.h"
 #include "ov-re-mat.h"
 #include "ov-base-scalar.h"
 #include "ov-typeinfo.h"
 
 class octave_value_list;
 
-class tree_walker;
-
 // Real scalar values.
 
 class
 OCTINTERP_API
 octave_scalar : public octave_base_scalar<double>
 {
 public:
 
diff --git a/libinterp/octave-value/ov-str-mat.h b/libinterp/octave-value/ov-str-mat.h
--- a/libinterp/octave-value/ov-str-mat.h
+++ b/libinterp/octave-value/ov-str-mat.h
@@ -38,18 +38,16 @@ along with Octave; see the file COPYING.
 #include "oct-stream.h"
 #include "ov.h"
 #include "ov-ch-mat.h"
 #include "ov-re-mat.h"
 #include "ov-typeinfo.h"
 
 class octave_value_list;
 
-class tree_walker;
-
 // Character matrix values with special properties for use as
 // strings.
 
 class
 OCTINTERP_API
 octave_char_matrix_str : public octave_char_matrix
 {
 public:
diff --git a/libinterp/octave-value/ov-struct.h b/libinterp/octave-value/ov-struct.h
--- a/libinterp/octave-value/ov-struct.h
+++ b/libinterp/octave-value/ov-struct.h
@@ -35,18 +35,16 @@ along with Octave; see the file COPYING.
 
 #include "error.h"
 #include "oct-map.h"
 #include "ov-base.h"
 #include "ov-typeinfo.h"
 
 class octave_value_list;
 
-class tree_walker;
-
 // Data structures.
 
 class
 octave_struct : public octave_base_value
 {
 public:
 
   octave_struct (void)
diff --git a/libinterp/octave-value/ov-usr-fcn.cc b/libinterp/octave-value/ov-usr-fcn.cc
--- a/libinterp/octave-value/ov-usr-fcn.cc
+++ b/libinterp/octave-value/ov-usr-fcn.cc
@@ -78,17 +78,17 @@ octave_user_script::octave_user_script (
   : octave_user_code (), cmd_list (0), file_name (),
     t_parsed (static_cast<time_t> (0)),
     t_checked (static_cast<time_t> (0)),
     call_depth (-1)
 { }
 
 octave_user_script::octave_user_script (const std::string& fnm,
                                         const std::string& nm,
-                                        tree_statement_list *cmds,
+                                        octave::tree_statement_list *cmds,
                                         const std::string& ds)
   : octave_user_code (nm, ds), cmd_list (cmds), file_name (fnm),
     t_parsed (static_cast<time_t> (0)),
     t_checked (static_cast<time_t> (0)),
     call_depth (-1)
 {
   if (cmd_list)
     cmd_list->mark_as_script_body ();
@@ -149,44 +149,44 @@ octave_user_script::do_multi_index_op (i
       octave::tree_evaluator::statement_context = octave::tree_evaluator::script;
 
       BEGIN_PROFILER_BLOCK (octave_user_script)
 
         cmd_list->accept (*octave::current_evaluator);
 
       END_PROFILER_BLOCK
 
-      if (tree_return_command::returning)
-        tree_return_command::returning = 0;
+      if (octave::tree_return_command::returning)
+        octave::tree_return_command::returning = 0;
 
-      if (tree_break_command::breaking)
-        tree_break_command::breaking--;
+      if (octave::tree_break_command::breaking)
+        octave::tree_break_command::breaking--;
     }
 
   return retval;
 }
 
 void
-octave_user_script::accept (tree_walker& tw)
+octave_user_script::accept (octave::tree_walker& tw)
 {
   tw.visit_octave_user_script (*this);
 }
 
 // User defined functions.
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_user_function,
                                      "user-defined function",
                                      "user-defined function");
 
 // Ugh.  This really needs to be simplified (code/data?
 // extrinsic/intrinsic state?).
 
 octave_user_function::octave_user_function
-  (symbol_table::scope_id sid, tree_parameter_list *pl,
-   tree_parameter_list *rl, tree_statement_list *cl)
+  (symbol_table::scope_id sid, octave::tree_parameter_list *pl,
+   octave::tree_parameter_list *rl, octave::tree_statement_list *cl)
   : octave_user_code ("", ""),
     param_list (pl), ret_list (rl), cmd_list (cl),
     lead_comm (), trail_comm (), file_name (),
     location_line (0), location_column (0),
     parent_name (), t_parsed (static_cast<time_t> (0)),
     t_checked (static_cast<time_t> (0)),
     system_fcn_file (false), call_depth (-1),
     num_named_args (param_list ? param_list->length () : 0),
@@ -221,17 +221,17 @@ octave_user_function::~octave_user_funct
   delete jit_info;
 #endif
 
   // FIXME: this is really playing with fire.
   symbol_table::erase_scope (local_scope);
 }
 
 octave_user_function *
-octave_user_function::define_ret_list (tree_parameter_list *t)
+octave_user_function::define_ret_list (octave::tree_parameter_list *t)
 {
   ret_list = t;
 
   return this;
 }
 
 void
 octave_user_function::stash_fcn_file_name (const std::string& nm)
@@ -247,37 +247,37 @@ octave_user_function::stash_fcn_file_nam
 // after the end of the parameter list, but we aren't tracking that
 // information (yet).
 
 void
 octave_user_function::maybe_relocate_end_internal (void)
 {
   if (cmd_list && ! cmd_list->empty ())
     {
-      tree_statement *last_stmt = cmd_list->back ();
+      octave::tree_statement *last_stmt = cmd_list->back ();
 
       if (last_stmt && last_stmt->is_end_of_fcn_or_script ()
           && last_stmt->is_end_of_file ())
         {
-          tree_statement_list::reverse_iterator
+          octave::tree_statement_list::reverse_iterator
             next_to_last_elt = cmd_list->rbegin ();
 
           next_to_last_elt++;
 
           int new_eof_line;
           int new_eof_col;
 
           if (next_to_last_elt == cmd_list->rend ())
             {
               new_eof_line = beginning_line ();
               new_eof_col = beginning_column ();
             }
           else
             {
-              tree_statement *next_to_last_stmt = *next_to_last_elt;
+              octave::tree_statement *next_to_last_stmt = *next_to_last_elt;
 
               new_eof_line = next_to_last_stmt->line ();
               new_eof_col = next_to_last_stmt->column ();
             }
 
           last_stmt->set_location (new_eof_line + 1, new_eof_col);
         }
     }
@@ -484,17 +484,17 @@ octave_user_function::do_multi_index_op 
           args = args.slice (1, args.length () - 1, true);
         }
       else
         panic_impossible ();
     }
 
 #if defined (HAVE_LLVM)
   if (is_special_expr ()
-      && tree_jit::execute (*this, args, retval))
+      && octave::tree_jit::execute (*this, args, retval))
     return retval;
 #endif
 
   octave::unwind_protect frame;
 
   frame.protect_var (call_depth);
   call_depth++;
 
@@ -536,24 +536,24 @@ octave_user_function::do_multi_index_op 
       ret_list->define_from_arg_vector (ret_args);
     }
 
   // Force parameter list to be undefined when this function exits.
   // Doing so decrements the reference counts on the values of local
   // variables that are also named function parameters.
 
   if (param_list)
-    frame.add_method (param_list, &tree_parameter_list::undefine);
+    frame.add_method (param_list, &octave::tree_parameter_list::undefine);
 
   // Force return list to be undefined when this function exits.
   // Doing so decrements the reference counts on the values of local
   // variables that are also named values returned by this function.
 
   if (ret_list)
-    frame.add_method (ret_list, &tree_parameter_list::undefine);
+    frame.add_method (ret_list, &octave::tree_parameter_list::undefine);
 
   if (call_depth == 0)
     {
       // Force symbols to be undefined again when this function
       // exits.
       //
       // This cleanup function is added to the unwind_protect stack
       // after the calls to clear the parameter lists so that local
@@ -587,19 +587,19 @@ octave_user_function::do_multi_index_op 
   octave::tree_evaluator::statement_context = octave::tree_evaluator::function;
 
   BEGIN_PROFILER_BLOCK (octave_user_function)
 
   if (is_special_expr ())
     {
       assert (cmd_list->length () == 1);
 
-      tree_statement *stmt = cmd_list->front ();
+      octave::tree_statement *stmt = cmd_list->front ();
 
-      tree_expression *expr = stmt->expression ();
+      octave::tree_expression *expr = stmt->expression ();
 
       if (expr)
         {
           octave::call_stack::set_location (stmt->line (), stmt->column ());
 
           retval = (lvalue_list
                     ? expr->rvalue (nargout, lvalue_list)
                     : expr->rvalue (nargout));
@@ -608,21 +608,21 @@ octave_user_function::do_multi_index_op 
   else
     cmd_list->accept (*octave::current_evaluator);
 
   END_PROFILER_BLOCK
 
   if (echo_commands)
     print_code_function_trailer ();
 
-  if (tree_return_command::returning)
-    tree_return_command::returning = 0;
+  if (octave::tree_return_command::returning)
+    octave::tree_return_command::returning = 0;
 
-  if (tree_break_command::breaking)
-    tree_break_command::breaking--;
+  if (octave::tree_break_command::breaking)
+    octave::tree_break_command::breaking--;
 
   // Copy return values out.
 
   if (ret_list && ! is_special_expr ())
     {
       ret_list->initialize_undefined_elements (my_name, nargout, Matrix ());
 
       Cell varargout;
@@ -637,42 +637,42 @@ octave_user_function::do_multi_index_op 
 
       retval = ret_list->convert_to_const_vector (nargout, varargout);
     }
 
   return retval;
 }
 
 void
-octave_user_function::accept (tree_walker& tw)
+octave_user_function::accept (octave::tree_walker& tw)
 {
   tw.visit_octave_user_function (*this);
 }
 
-tree_expression *
+octave::tree_expression *
 octave_user_function::special_expr (void)
 {
   assert (is_special_expr ());
   assert (cmd_list->length () == 1);
 
-  tree_statement *stmt = cmd_list->front ();
+  octave::tree_statement *stmt = cmd_list->front ();
   return stmt->expression ();
 }
 
 bool
 octave_user_function::subsasgn_optimization_ok (void)
 {
   bool retval = false;
   if (Voptimize_subsasgn_calls
       && param_list && ret_list
       && param_list->length () > 0 && ! param_list->varargs_only ()
       && ret_list->length () == 1 && ! ret_list->takes_varargs ())
     {
-      tree_identifier *par1 = param_list->front ()->ident ();
-      tree_identifier *ret1 = ret_list->front ()->ident ();
+      octave::tree_identifier *par1 = param_list->front ()->ident ();
+      octave::tree_identifier *ret1 = ret_list->front ()->ident ();
       retval = par1->name () == ret1->name ();
     }
 
   return retval;
 }
 
 #if 0
 void
@@ -680,25 +680,25 @@ octave_user_function::print_symtab_info 
 {
   symbol_table::print_info (os, local_scope);
 }
 #endif
 
 void
 octave_user_function::print_code_function_header (void)
 {
-  tree_print_code tpc (octave_stdout, VPS4);
+  octave::tree_print_code tpc (octave_stdout, VPS4);
 
   tpc.visit_octave_user_function_header (*this);
 }
 
 void
 octave_user_function::print_code_function_trailer (void)
 {
-  tree_print_code tpc (octave_stdout, VPS4);
+  octave::tree_print_code tpc (octave_stdout, VPS4);
 
   tpc.visit_octave_user_function_trailer (*this);
 }
 
 void
 octave_user_function::bind_automatic_vars
   (const string_vector& arg_names, int nargin, int nargout,
    const octave_value_list& va_args,
@@ -854,17 +854,17 @@ Programming Note: @code{nargin} does not
           // Matlab gives up for histc, so maybe it's ok that we
           // give up sometimes too?
 
           std::string type = fcn_val->type_name ();
           error ("nargin: number of input arguments unavailable for %s objects",
                  type.c_str ());
         }
 
-      tree_parameter_list *param_list = fcn->parameter_list ();
+      octave::tree_parameter_list *param_list = fcn->parameter_list ();
 
       retval = param_list ? param_list->length () : 0;
       if (fcn->takes_varargs ())
         retval = -1 - retval;
     }
   else
     {
       retval = symbol_table::varval (".nargin.");
@@ -973,17 +973,17 @@ returns -1 for all anonymous functions.
           // Matlab gives up for histc, so maybe it's ok that we
           // give up sometimes too?
 
           std::string type = fcn_val->type_name ();
           error ("nargout: number of output arguments unavailable for %s objects",
                  type.c_str ());
         }
 
-      tree_parameter_list *ret_list = fcn->return_list ();
+      octave::tree_parameter_list *ret_list = fcn->return_list ();
 
       retval = ret_list ? ret_list->length () : 0;
 
       if (fcn->takes_var_return ())
         retval = -1 - retval;
     }
   else
     {
diff --git a/libinterp/octave-value/ov-usr-fcn.h b/libinterp/octave-value/ov-usr-fcn.h
--- a/libinterp/octave-value/ov-usr-fcn.h
+++ b/libinterp/octave-value/ov-usr-fcn.h
@@ -35,21 +35,24 @@ along with Octave; see the file COPYING.
 #include "ov-fcn.h"
 #include "ov-typeinfo.h"
 #include "symtab.h"
 #include "unwind-prot.h"
 
 class string_vector;
 
 class octave_value;
-class tree_parameter_list;
-class tree_statement_list;
-class tree_va_return_list;
-class tree_expression;
-class tree_walker;
+
+namespace octave
+{
+  class tree_parameter_list;
+  class tree_statement_list;
+  class tree_expression;
+  class tree_walker;
+}
 
 #if defined (HAVE_LLVM)
 class jit_function_info;
 #endif
 
 class
 octave_user_code : public octave_function
 {
@@ -71,30 +74,30 @@ public:
   octave_user_code& operator = (const octave_user_code& f) = delete;
 
   ~octave_user_code (void) = default;
 
   bool is_user_code (void) const { return true; }
 
   virtual std::map<std::string, octave_value> subfunctions (void) const;
 
-  virtual tree_statement_list *body (void) = 0;
+  virtual octave::tree_statement_list *body (void) = 0;
 };
 
 // Scripts.
 
 class
 octave_user_script : public octave_user_code
 {
 public:
 
   octave_user_script (void);
 
   octave_user_script (const std::string& fnm, const std::string& nm,
-                      tree_statement_list *cmds,
+                      octave::tree_statement_list *cmds,
                       const std::string& ds = "");
 
   octave_user_script (const std::string& fnm, const std::string& nm,
                       const std::string& ds = "");
 
   // No copying!
 
   octave_user_script (const octave_user_script& f) = delete;
@@ -139,24 +142,24 @@ public:
 
   octave_value_list subsref (const std::string& type,
                              const std::list<octave_value_list>& idx,
                              int nargout);
 
   octave_value_list
   do_multi_index_op (int nargout, const octave_value_list& args);
 
-  tree_statement_list *body (void) { return cmd_list; }
+  octave::tree_statement_list *body (void) { return cmd_list; }
 
-  void accept (tree_walker& tw);
+  void accept (octave::tree_walker& tw);
 
 private:
 
   // The list of commands that make up the body of this function.
-  tree_statement_list *cmd_list;
+  octave::tree_statement_list *cmd_list;
 
   // The name of the file we parsed.
   std::string file_name;
 
   // The time the file was parsed.
   octave::sys::time t_parsed;
 
   // The time the file was last checked to see if it needs to be
@@ -172,19 +175,19 @@ private:
 // User-defined functions.
 
 class
 octave_user_function : public octave_user_code
 {
 public:
 
   octave_user_function (symbol_table::scope_id sid = -1,
-                        tree_parameter_list *pl = 0,
-                        tree_parameter_list *rl = 0,
-                        tree_statement_list *cl = 0);
+                        octave::tree_parameter_list *pl = 0,
+                        octave::tree_parameter_list *rl = 0,
+                        octave::tree_statement_list *cl = 0);
 
   // No copying!
 
   octave_user_function (const octave_user_function& fn) = delete;
 
   octave_user_function& operator = (const octave_user_function& fn) = delete;
 
   ~octave_user_function (void);
@@ -196,19 +199,19 @@ public:
   }
 
   octave_function *function_value (bool = false) { return this; }
 
   octave_user_function *user_function_value (bool = false) { return this; }
 
   octave_user_code *user_code_value (bool = false) { return this; }
 
-  octave_user_function *define_param_list (tree_parameter_list *t);
+  octave_user_function *define_param_list (octave::tree_parameter_list *t);
 
-  octave_user_function *define_ret_list (tree_parameter_list *t);
+  octave_user_function *define_ret_list (octave::tree_parameter_list *t);
 
   void stash_fcn_file_name (const std::string& nm);
 
   void stash_fcn_location (int line, int col)
   {
     location_line = line;
     location_column = col;
   }
@@ -374,33 +377,33 @@ public:
 
   octave_value_list
   do_multi_index_op (int nargout, const octave_value_list& args);
 
   octave_value_list
   do_multi_index_op (int nargout, const octave_value_list& args,
                      const std::list<octave_lvalue>* lvalue_list);
 
-  tree_parameter_list *parameter_list (void) { return param_list; }
+  octave::tree_parameter_list *parameter_list (void) { return param_list; }
 
-  tree_parameter_list *return_list (void) { return ret_list; }
+  octave::tree_parameter_list *return_list (void) { return ret_list; }
 
-  tree_statement_list *body (void) { return cmd_list; }
+  octave::tree_statement_list *body (void) { return cmd_list; }
 
   octave_comment_list *leading_comment (void) { return lead_comm; }
 
   octave_comment_list *trailing_comment (void) { return trail_comm; }
 
   // If is_special_expr is true, retrieve the sigular expression that forms the
   // body.  May be null (even if is_special_expr is true).
-  tree_expression *special_expr (void);
+  octave::tree_expression *special_expr (void);
 
   bool subsasgn_optimization_ok (void);
 
-  void accept (tree_walker& tw);
+  void accept (octave::tree_walker& tw);
 
   template <typename T>
   bool local_protect (T& variable)
   {
     if (curr_unwind_protect_frame)
       {
         curr_unwind_protect_frame->protect_var (variable);
         return true;
@@ -424,24 +427,24 @@ private:
   enum class_ctor_type
   {
     none,
     legacy,
     classdef
   };
 
   // List of arguments for this function.  These are local variables.
-  tree_parameter_list *param_list;
+  octave::tree_parameter_list *param_list;
 
   // List of parameters we return.  These are also local variables in
   // this function.
-  tree_parameter_list *ret_list;
+  octave::tree_parameter_list *ret_list;
 
   // The list of commands that make up the body of this function.
-  tree_statement_list *cmd_list;
+  octave::tree_statement_list *cmd_list;
 
   // The comments preceding the FUNCTION token.
   octave_comment_list *lead_comm;
 
   // The comments preceding the ENDFUNCTION token.
   octave_comment_list *trail_comm;
 
   // The name of the file we parsed.
diff --git a/libinterp/octave-value/ov.cc b/libinterp/octave-value/ov.cc
--- a/libinterp/octave-value/ov.cc
+++ b/libinterp/octave-value/ov.cc
@@ -2549,17 +2549,17 @@ do_colon_op (const octave_value& base, c
           args(2) = limit;
           args(1) = increment;
         }
       else
         args(1) = limit;
 
       args(0) = base;
 
-      octave_value_list tmp = feval (meth.function_value (), args, 1);
+      octave_value_list tmp = octave::feval (meth.function_value (), args, 1);
 
       if (tmp.length () > 0)
         retval = tmp(0);
     }
   else
     {
       bool result_is_str = (base.is_string () && limit.is_string ());
       bool dq_str = (base.is_dq_string () || limit.is_dq_string ());
diff --git a/libinterp/operators/op-class.cc b/libinterp/operators/op-class.cc
--- a/libinterp/operators/op-class.cc
+++ b/libinterp/operators/op-class.cc
@@ -51,17 +51,17 @@ along with Octave; see the file COPYING.
     if (meth.is_undefined ())                                           \
       error ("%s method not defined for %s class", #name,               \
              class_name.c_str ());                                      \
                                                                         \
     octave_value_list args;                                             \
                                                                         \
     args(0) = a;                                                        \
                                                                         \
-    octave_value_list tmp = feval (meth.function_value (), args, 1);    \
+    octave_value_list tmp = octave::feval (meth.function_value (), args, 1); \
                                                                         \
     if (tmp.length () > 0)                                              \
       retval = tmp(0);                                                  \
                                                                         \
     return retval;                                                      \
   }
 
 DEF_CLASS_UNOP (not)
@@ -87,17 +87,17 @@ DEF_CLASS_UNOP (ctranspose)
       error ("%s method not defined for %s class", #name,               \
              dispatch_type.c_str ());                                   \
                                                                         \
     octave_value_list args;                                             \
                                                                         \
     args(1) = a2;                                                       \
     args(0) = a1;                                                       \
                                                                         \
-    octave_value_list tmp = feval (meth.function_value (), args, 1);    \
+    octave_value_list tmp = octave::feval (meth.function_value (), args, 1); \
                                                                         \
     if (tmp.length () > 0)                                              \
       retval = tmp(0);                                                  \
                                                                         \
     return retval;                                                      \
   }
 
 DEF_CLASS_BINOP (plus)
diff --git a/libinterp/parse-tree/lex.h b/libinterp/parse-tree/lex.h
--- a/libinterp/parse-tree/lex.h
+++ b/libinterp/parse-tree/lex.h
@@ -849,9 +849,8 @@ namespace octave
 
   protected:
 
     int pflag;
   };
 }
 
 #endif
-
diff --git a/libinterp/parse-tree/lex.ll b/libinterp/parse-tree/lex.ll
--- a/libinterp/parse-tree/lex.ll
+++ b/libinterp/parse-tree/lex.ll
@@ -852,20 +852,20 @@ ANY_INCLUDING_NL (.|{NL})
 
     curr_lexer->pop_start_state ();
 
     if (curr_lexer->start_state() != COMMAND_START)
       {
         curr_lexer->looking_for_object_index = true;
         curr_lexer->at_beginning_of_statement = false;
 
-        curr_lexer->push_token (new token (DQ_STRING,
-                                           curr_lexer->string_text,
-                                           curr_lexer->string_line,
-                                           curr_lexer->string_column));
+        curr_lexer->push_token (new octave::token (DQ_STRING,
+                                                   curr_lexer->string_text,
+                                                   curr_lexer->string_line,
+                                                   curr_lexer->string_column));
 
         curr_lexer->string_text = "";
 
         return curr_lexer->count_token_internal (DQ_STRING);
       }
   }
 
 <DQ_STRING_START>\\[0-7]{1,3} {
@@ -873,21 +873,21 @@ ANY_INCLUDING_NL (.|{NL})
 
     curr_lexer->current_input_column += yyleng;
 
     int result;
     sscanf (yytext+1, "%o", &result);
 
     if (result > 0xff)
       {
-        token *tok
-          = new token (LEXICAL_ERROR,
-                       "invalid octal escape sequence in character string",
-                       curr_lexer->input_line_number,
-                       curr_lexer->current_input_column);
+        octave::token *tok
+          = new octave::token (LEXICAL_ERROR,
+                               "invalid octal escape sequence in character string",
+                               curr_lexer->input_line_number,
+                               curr_lexer->current_input_column);
 
         curr_lexer->push_token (tok);
 
         return curr_lexer->count_token_internal (LEXICAL_ERROR);
       }
     else
       curr_lexer->string_text += static_cast<unsigned char> (result);
   }
@@ -1015,20 +1015,21 @@ ANY_INCLUDING_NL (.|{NL})
 
     curr_lexer->current_input_column += yyleng;
     curr_lexer->string_text += yytext;
   }
 
 <DQ_STRING_START>{NL} {
     curr_lexer->lexer_debug ("<DQ_STRING_START>{NL}");
 
-    token *tok = new token (LEXICAL_ERROR,
-                            "unterminated character string constant",
-                            curr_lexer->input_line_number,
-                            curr_lexer->current_input_column);
+    octave::token *tok
+      = new octave::token (LEXICAL_ERROR,
+                           "unterminated character string constant",
+                           curr_lexer->input_line_number,
+                           curr_lexer->current_input_column);
 
     curr_lexer->push_token (tok);
 
     curr_lexer->input_line_number++;
     curr_lexer->current_input_column = 1;
 
     return curr_lexer->count_token_internal (LEXICAL_ERROR);
   }
@@ -1051,20 +1052,20 @@ ANY_INCLUDING_NL (.|{NL})
 
     curr_lexer->pop_start_state ();
 
     if (curr_lexer->start_state() != COMMAND_START)
       {
         curr_lexer->looking_for_object_index = true;
         curr_lexer->at_beginning_of_statement = false;
 
-        curr_lexer->push_token (new token (SQ_STRING,
-                                           curr_lexer->string_text,
-                                           curr_lexer->string_line,
-                                           curr_lexer->string_column));
+        curr_lexer->push_token (new octave::token (SQ_STRING,
+                                                   curr_lexer->string_text,
+                                                   curr_lexer->string_line,
+                                                   curr_lexer->string_column));
 
         curr_lexer->string_text = "";
 
         return curr_lexer->count_token_internal (SQ_STRING);
       }
   }
 
 <SQ_STRING_START>[^\'\n\r]+ {
@@ -1072,20 +1073,21 @@ ANY_INCLUDING_NL (.|{NL})
 
     curr_lexer->current_input_column += yyleng;
     curr_lexer->string_text += yytext;
   }
 
 <SQ_STRING_START>{NL} {
     curr_lexer->lexer_debug ("<SQ_STRING_START>{NL}");
 
-    token *tok = new token (LEXICAL_ERROR,
-                            "unterminated character string constant",
-                            curr_lexer->input_line_number,
-                            curr_lexer->current_input_column);
+    octave::token *tok
+      = new octave::token (LEXICAL_ERROR,
+                           "unterminated character string constant",
+                           curr_lexer->input_line_number,
+                           curr_lexer->current_input_column);
 
     curr_lexer->push_token (tok);
 
     curr_lexer->input_line_number++;
     curr_lexer->current_input_column = 1;
 
     return curr_lexer->count_token_internal (LEXICAL_ERROR);
   }
@@ -1363,20 +1365,21 @@ ANY_INCLUDING_NL (.|{NL})
         curr_lexer->current_input_column = 1;
 
         curr_lexer->at_beginning_of_statement = true;
 
         return curr_lexer->count_token ('\n');
       }
     else if (curr_lexer->nesting_level.is_bracket_or_brace ())
       {
-        token *tok = new token (LEXICAL_ERROR,
-                                "unexpected internal lexer error",
-                                curr_lexer->input_line_number,
-                                curr_lexer->current_input_column);
+        octave::token *tok
+          = new octave::token (LEXICAL_ERROR,
+                               "unexpected internal lexer error",
+                               curr_lexer->input_line_number,
+                               curr_lexer->current_input_column);
 
         curr_lexer->push_token (tok);
 
         curr_lexer->input_line_number++;
         curr_lexer->current_input_column = 1;
 
         return curr_lexer->count_token_internal (LEXICAL_ERROR);
       }
@@ -1752,19 +1755,20 @@ ANY_INCLUDING_NL (.|{NL})
     else
       {
         std::ostringstream buf;
 
         buf << "invalid character '"
             << undo_string_escape (static_cast<char> (c))
             << "' (ASCII " << c << ")";
 
-        token *tok = new token (LEXICAL_ERROR, buf.str (),
-                                curr_lexer->input_line_number,
-                                curr_lexer->current_input_column);
+        octave::token *tok
+          = new octave::token (LEXICAL_ERROR, buf.str (),
+                               curr_lexer->input_line_number,
+                               curr_lexer->current_input_column);
 
         curr_lexer->push_token (tok);
 
         curr_lexer->current_input_column++;
 
         return curr_lexer->count_token_internal (LEXICAL_ERROR);
       }
   }
diff --git a/libinterp/parse-tree/oct-parse.in.yy b/libinterp/parse-tree/oct-parse.in.yy
--- a/libinterp/parse-tree/oct-parse.in.yy
+++ b/libinterp/parse-tree/oct-parse.in.yy
@@ -137,68 +137,68 @@ static void yyerror (octave::base_parser
 %parse-param { octave::base_parser& parser }
 %lex-param { void *scanner }
 
 %union
 {
   int dummy_type;
 
   // The type of the basic tokens returned by the lexer.
-  token *tok_val;
+  octave::token *tok_val;
 
   // Comment strings that we need to deal with mid-rule.
   octave_comment_list *comment_type;
 
   // Types for the nonterminals we generate.
   char punct_type;
-  tree *tree_type;
-  tree_matrix *tree_matrix_type;
-  tree_cell *tree_cell_type;
-  tree_expression *tree_expression_type;
-  tree_constant *tree_constant_type;
-  tree_fcn_handle *tree_fcn_handle_type;
-  tree_funcall *tree_funcall_type;
-  tree_function_def *tree_function_def_type;
-  tree_anon_fcn_handle *tree_anon_fcn_handle_type;
-  tree_identifier *tree_identifier_type;
-  tree_index_expression *tree_index_expression_type;
-  tree_colon_expression *tree_colon_expression_type;
-  tree_argument_list *tree_argument_list_type;
-  tree_parameter_list *tree_parameter_list_type;
-  tree_command *tree_command_type;
-  tree_if_command *tree_if_command_type;
-  tree_if_clause *tree_if_clause_type;
-  tree_if_command_list *tree_if_command_list_type;
-  tree_switch_command *tree_switch_command_type;
-  tree_switch_case *tree_switch_case_type;
-  tree_switch_case_list *tree_switch_case_list_type;
-  tree_decl_elt *tree_decl_elt_type;
-  tree_decl_init_list *tree_decl_init_list_type;
-  tree_decl_command *tree_decl_command_type;
-  tree_statement *tree_statement_type;
-  tree_statement_list *tree_statement_list_type;
+  octave::tree *tree_type;
+  octave::tree_matrix *tree_matrix_type;
+  octave::tree_cell *tree_cell_type;
+  octave::tree_expression *tree_expression_type;
+  octave::tree_constant *tree_constant_type;
+  octave::tree_fcn_handle *tree_fcn_handle_type;
+  octave::tree_funcall *tree_funcall_type;
+  octave::tree_function_def *tree_function_def_type;
+  octave::tree_anon_fcn_handle *tree_anon_fcn_handle_type;
+  octave::tree_identifier *tree_identifier_type;
+  octave::tree_index_expression *tree_index_expression_type;
+  octave::tree_colon_expression *tree_colon_expression_type;
+  octave::tree_argument_list *tree_argument_list_type;
+  octave::tree_parameter_list *tree_parameter_list_type;
+  octave::tree_command *tree_command_type;
+  octave::tree_if_command *tree_if_command_type;
+  octave::tree_if_clause *tree_if_clause_type;
+  octave::tree_if_command_list *tree_if_command_list_type;
+  octave::tree_switch_command *tree_switch_command_type;
+  octave::tree_switch_case *tree_switch_case_type;
+  octave::tree_switch_case_list *tree_switch_case_list_type;
+  octave::tree_decl_elt *tree_decl_elt_type;
+  octave::tree_decl_init_list *tree_decl_init_list_type;
+  octave::tree_decl_command *tree_decl_command_type;
+  octave::tree_statement *tree_statement_type;
+  octave::tree_statement_list *tree_statement_list_type;
   octave_user_function *octave_user_function_type;
 
-  tree_classdef *tree_classdef_type;
-  tree_classdef_attribute* tree_classdef_attribute_type;
-  tree_classdef_attribute_list* tree_classdef_attribute_list_type;
-  tree_classdef_superclass* tree_classdef_superclass_type;
-  tree_classdef_superclass_list* tree_classdef_superclass_list_type;
-  tree_classdef_body* tree_classdef_body_type;
-  tree_classdef_property* tree_classdef_property_type;
-  tree_classdef_property_list* tree_classdef_property_list_type;
-  tree_classdef_properties_block* tree_classdef_properties_block_type;
-  tree_classdef_methods_list* tree_classdef_methods_list_type;
-  tree_classdef_methods_block* tree_classdef_methods_block_type;
-  tree_classdef_event* tree_classdef_event_type;
-  tree_classdef_events_list* tree_classdef_events_list_type;
-  tree_classdef_events_block* tree_classdef_events_block_type;
-  tree_classdef_enum* tree_classdef_enum_type;
-  tree_classdef_enum_list* tree_classdef_enum_list_type;
-  tree_classdef_enum_block* tree_classdef_enum_block_type;
+  octave::tree_classdef *tree_classdef_type;
+  octave::tree_classdef_attribute* tree_classdef_attribute_type;
+  octave::tree_classdef_attribute_list* tree_classdef_attribute_list_type;
+  octave::tree_classdef_superclass* tree_classdef_superclass_type;
+  octave::tree_classdef_superclass_list* tree_classdef_superclass_list_type;
+  octave::tree_classdef_body* tree_classdef_body_type;
+  octave::tree_classdef_property* tree_classdef_property_type;
+  octave::tree_classdef_property_list* tree_classdef_property_list_type;
+  octave::tree_classdef_properties_block* tree_classdef_properties_block_type;
+  octave::tree_classdef_methods_list* tree_classdef_methods_list_type;
+  octave::tree_classdef_methods_block* tree_classdef_methods_block_type;
+  octave::tree_classdef_event* tree_classdef_event_type;
+  octave::tree_classdef_events_list* tree_classdef_events_list_type;
+  octave::tree_classdef_events_block* tree_classdef_events_block_type;
+  octave::tree_classdef_enum* tree_classdef_enum_type;
+  octave::tree_classdef_enum_list* tree_classdef_enum_list_type;
+  octave::tree_classdef_enum_block* tree_classdef_enum_block_type;
 }
 
 // Tokens with line and column information.
 %token <tok_val> '=' ':' '-' '+' '*' '/'
 %token <tok_val> ADD_EQ SUB_EQ MUL_EQ DIV_EQ LEFTDIV_EQ POW_EQ
 %token <tok_val> EMUL_EQ EDIV_EQ ELEFTDIV_EQ EPOW_EQ AND_EQ OR_EQ
 %token <tok_val> EXPR_AND_AND EXPR_OR_OR
 %token <tok_val> EXPR_AND EXPR_OR EXPR_NOT
@@ -418,17 +418,17 @@ simple_list     : opt_sep_no_nl
 
 simple_list1    : statement
                   { $$ = parser.make_statement_list ($1); }
                 | simple_list1 sep_no_nl statement
                   { $$ = parser.append_statement_list ($1, $2, $3, false); }
                 ;
 
 opt_list        : // empty
-                  { $$ = new tree_statement_list (); }
+                  { $$ = new octave::tree_statement_list (); }
                 | list
                   { $$ = $1; }
                 ;
 
 list            : list1 opt_sep
                   { $$ = parser.set_stmt_print_flag ($1, $2, true); }
                 ;
 
@@ -461,32 +461,32 @@ word_list_cmd   : identifier word_list
                       {
                         // make_index_expression deleted $1 and $2.
                         YYABORT;
                       }
                   }
                 ;
 
 word_list       : string
-                  { $$ = new tree_argument_list ($1); }
+                  { $$ = new octave::tree_argument_list ($1); }
                 | word_list string
                   {
                     $1->append ($2);
                     $$ = $1;
                   }
                 ;
 
 // ===========
 // Expressions
 // ===========
 
 identifier      : NAME
                   {
                     symbol_table::symbol_record *sr = $1->sym_rec ();
-                    $$ = new tree_identifier (*sr, $1->line (), $1->column ());
+                    $$ = new octave::tree_identifier (*sr, $1->line (), $1->column ());
                   }
                 ;
 
 superclass_identifier
                 : SUPERCLASSREF
                   {
                     std::string method_nm = $1->superclass_method_name ();
                     std::string class_nm = $1->superclass_class_name ();
@@ -517,48 +517,48 @@ constant        : NUM
                   { $$ = $1; }
                 ;
 
 matrix          : '[' matrix_rows ']'
                   { $$ = parser.finish_matrix ($2); }
                 ;
 
 matrix_rows     : cell_or_matrix_row
-                  { $$ = $1 ? new tree_matrix ($1) : 0; }
+                  { $$ = $1 ? new octave::tree_matrix ($1) : 0; }
                 | matrix_rows ';' cell_or_matrix_row
                   {
                     if ($1)
                       {
                         if ($3)
                           $1->append ($3);
 
                         $$ = $1;
                       }
                     else
-                      $$ = $3 ? new tree_matrix ($3) : 0;
+                      $$ = $3 ? new octave::tree_matrix ($3) : 0;
                   }
                 ;
 
 cell            : '{' cell_rows '}'
                   { $$ = parser.finish_cell ($2); }
                 ;
 
 cell_rows       : cell_or_matrix_row
-                  { $$ = $1 ? new tree_cell ($1) : 0; }
+                  { $$ = $1 ? new octave::tree_cell ($1) : 0; }
                 | cell_rows ';' cell_or_matrix_row
                   {
                     if ($1)
                       {
                         if ($3)
                           $1->append ($3);
 
                         $$ = $1;
                       }
                     else
-                      $$ = $3 ? new tree_cell ($3) : 0;
+                      $$ = $3 ? new octave::tree_cell ($3) : 0;
                   }
                 ;
 
 // tree_argument_list objects can't be empty or have leading or trailing
 // commas, but those are all allowed in matrix and cell array rows.
 
 cell_or_matrix_row
                 : // empty
@@ -610,34 +610,34 @@ primary_expr    : identifier
                   { $$ = $2->mark_in_parens (); }
                 ;
 
 magic_colon     : ':'
                   {
                     YYUSE ($1);
 
                     octave_value tmp (octave_value::magic_colon_t);
-                    $$ = new tree_constant (tmp);
+                    $$ = new octave::tree_constant (tmp);
                   }
                 ;
 
 magic_tilde     : EXPR_NOT
                   {
                     YYUSE ($1);
 
-                    $$ = new tree_black_hole ();
+                    $$ = new octave::tree_black_hole ();
                   }
                 ;
 
 arg_list        : expression
-                  { $$ = new tree_argument_list ($1); }
+                  { $$ = new octave::tree_argument_list ($1); }
                 | magic_colon
-                  { $$ = new tree_argument_list ($1); }
+                  { $$ = new octave::tree_argument_list ($1); }
                 | magic_tilde
-                  { $$ = new tree_argument_list ($1); }
+                  { $$ = new octave::tree_argument_list ($1); }
                 | arg_list ',' magic_colon
                   {
                     $1->append ($3);
                     $$ = $1;
                   }
                 | arg_list ',' magic_tilde
                   {
                     $1->append ($3);
@@ -801,17 +801,17 @@ power_expr      : primary_expr
                   { $$ = parser.make_prefix_op ('-', $2, $1); }
                 ;
 
 colon_expr      : colon_expr1
                   { $$ = parser.finish_colon_expression ($1); }
                 ;
 
 colon_expr1     : oper_expr
-                  { $$ = new tree_colon_expression ($1); }
+                  { $$ = new octave::tree_colon_expression ($1); }
                 | colon_expr1 ':' oper_expr
                   {
                     YYUSE ($2);
 
                     if (! ($$ = $1->append ($3)))
                       {
                         delete $1;
                         delete $3;
@@ -944,38 +944,38 @@ declaration     : GLOBAL decl1
                 | PERSISTENT decl1
                   {
                     $$ = parser.make_decl_command (PERSISTENT, $1, $2);
                     lexer.looking_at_decl_list = false;
                   }
                 ;
 
 decl1           : decl2
-                  { $$ = new tree_decl_init_list ($1); }
+                  { $$ = new octave::tree_decl_init_list ($1); }
                 | decl1 decl2
                   {
                     $1->append ($2);
                     $$ = $1;
                   }
                 ;
 
 decl_param_init : // empty
                   {
                     $$ = 0;
                     lexer.looking_at_initializer_expression = true;
                   }
 
 decl2           : identifier
-                  { $$ = new tree_decl_elt ($1); }
+                  { $$ = new octave::tree_decl_elt ($1); }
                 | identifier '=' decl_param_init expression
                   {
                     YYUSE ($2);
 
                     lexer.looking_at_initializer_expression = false;
-                    $$ = new tree_decl_elt ($1, $4);
+                    $$ = new octave::tree_decl_elt ($1, $4);
                   }
                 ;
 
 // ====================
 // Selection statements
 // ====================
 
 select_command  : if_command
@@ -1033,17 +1033,17 @@ elseif_clause   : ELSEIF stash_comment o
                   }
                 ;
 
 else_clause     : ELSE stash_comment opt_sep opt_list
                   {
                     YYUSE ($1);
                     YYUSE ($3);
 
-                    $$ = new tree_if_clause ($4, $2);
+                    $$ = new octave::tree_if_clause ($4, $2);
                   }
                 ;
 
 // ================
 // Switch statement
 // ================
 
 switch_command  : SWITCH stash_comment expression opt_sep case_list END
@@ -1054,30 +1054,30 @@ switch_command  : SWITCH stash_comment e
                       {
                         // finish_switch_command deleted $3 adn $5.
                         YYABORT;
                       }
                   }
                 ;
 
 case_list       : // empty
-                  { $$ = new tree_switch_case_list (); }
+                  { $$ = new octave::tree_switch_case_list (); }
                 | default_case
-                  { $$ = new tree_switch_case_list ($1); }
+                  { $$ = new octave::tree_switch_case_list ($1); }
                 | case_list1
                   { $$ = $1; }
                 | case_list1 default_case
                   {
                     $1->append ($2);
                     $$ = $1;
                   }
                 ;
 
 case_list1      : switch_case
-                  { $$ = new tree_switch_case_list ($1); }
+                  { $$ = new octave::tree_switch_case_list ($1); }
                 | case_list1 switch_case
                   {
                     $1->append ($2);
                     $$ = $1;
                   }
                 ;
 
 switch_case     : CASE stash_comment opt_sep expression stmt_begin opt_sep opt_list
@@ -1089,17 +1089,17 @@ switch_case     : CASE stash_comment opt
                   }
                 ;
 
 default_case    : OTHERWISE stash_comment opt_sep opt_list
                   {
                     YYUSE ($1);
                     YYUSE ($3);
 
-                    $$ = new tree_switch_case ($4, $2);
+                    $$ = new octave::tree_switch_case ($4, $2);
                   }
                 ;
 
 // =======
 // Looping
 // =======
 
 loop_command    : WHILE stash_comment expression stmt_begin opt_sep opt_list END
@@ -1301,94 +1301,94 @@ param_list      : param_list_beg param_l
                   }
                 ;
 
 param_list1     : // empty
                   { $$ = 0; }
                 | param_list2
                   {
                     $1->mark_as_formal_parameters ();
-                    if ($1->validate (tree_parameter_list::in))
+                    if ($1->validate (octave::tree_parameter_list::in))
                       {
                         lexer.mark_as_variables ($1->variable_names ());
                         $$ = $1;
                       }
                     else
                       {
                         delete $1;
                         YYABORT;
                       }
                   }
                 ;
 
 param_list2     : param_list_elt
-                  { $$ = new tree_parameter_list ($1); }
+                  { $$ = new octave::tree_parameter_list ($1); }
                 | param_list2 ',' param_list_elt
                   {
                     $1->append ($3);
                     $$ = $1;
                   }
                 ;
 
 param_list_elt  : decl2
                   { $$ = $1; }
                 | magic_tilde
-                  { $$ = new tree_decl_elt ($1); }
+                  { $$ = new octave::tree_decl_elt ($1); }
                 ;
 
 // ===================================
 // List of function return value names
 // ===================================
 
 return_list     : '[' ']'
                   {
                     lexer.looking_at_return_list = false;
 
-                    $$ = new tree_parameter_list ();
+                    $$ = new octave::tree_parameter_list ();
                   }
                 | identifier
                   {
                     lexer.looking_at_return_list = false;
 
-                    tree_parameter_list *tmp = new tree_parameter_list ($1);
+                    octave::tree_parameter_list *tmp = new octave::tree_parameter_list ($1);
 
                     // Even though this parameter list can contain only
                     // a single identifier, we still need to validate it
                     // to check for varargin or varargout.
 
-                    if (tmp->validate (tree_parameter_list::out))
+                    if (tmp->validate (octave::tree_parameter_list::out))
                       $$ = tmp;
                     else
                       {
                         delete tmp;
                         YYABORT;
                       }
                   }
                 | '[' return_list1 ']'
                   {
                     lexer.looking_at_return_list = false;
 
                     // Check for duplicate parameter names, varargin,
                     // or varargout.
 
-                    if ($2->validate (tree_parameter_list::out))
+                    if ($2->validate (octave::tree_parameter_list::out))
                       $$ = $2;
                     else
                       {
                         delete $2;
                         YYABORT;
                       }
                   }
                 ;
 
 return_list1    : identifier
-                  { $$ = new tree_parameter_list (new tree_decl_elt ($1)); }
+                  { $$ = new octave::tree_parameter_list (new octave::tree_decl_elt ($1)); }
                 | return_list1 ',' identifier
                   {
-                    $1->append (new tree_decl_elt ($3));
+                    $1->append (new octave::tree_decl_elt ($3));
                     $$ = $1;
                   }
                 ;
 
 // =======================
 // Script or function file
 // =======================
 
@@ -1403,17 +1403,17 @@ file            : INPUT_FILE opt_nl opt_
                         // definitions found in the file have already
                         // been stored in the symbol table or in
                         // base_parser::primary_fcn_ptr.
 
                         delete $3;
                       }
                     else
                       {
-                        tree_statement *end_of_script
+                        octave::tree_statement *end_of_script
                           = parser.make_end ("endscript", true,
                                              lexer.input_line_number,
                                              lexer.current_input_column);
 
                         parser.make_script ($3, end_of_script);
                       }
 
                     $$ = 0;
@@ -1625,38 +1625,38 @@ classdef        : classdef_beg stash_com
 
 opt_attr_list   : // empty
                   { $$ = 0; }
                 | '(' attr_list ')'
                   { $$ = $2; }
                 ;
 
 attr_list       : attr
-                  { $$ = new tree_classdef_attribute_list ($1); }
+                  { $$ = new octave::tree_classdef_attribute_list ($1); }
                 | attr_list ',' attr
                   {
                     $1->append ($3);
                     $$ = $1;
                   }
                 ;
 
 attr            : identifier
-                  { $$ = new tree_classdef_attribute ($1); }
+                  { $$ = new octave::tree_classdef_attribute ($1); }
                 | identifier '=' decl_param_init expression
                   {
                     YYUSE ($2);
 
                     lexer.looking_at_initializer_expression = false;
-                    $$ = new tree_classdef_attribute ($1, $4);
+                    $$ = new octave::tree_classdef_attribute ($1, $4);
                   }
                 | EXPR_NOT identifier
                   {
                     YYUSE ($1);
 
-                    $$ = new tree_classdef_attribute ($2, false);
+                    $$ = new octave::tree_classdef_attribute ($2, false);
                   }
                 ;
 
 opt_superclass_list
                 : // empty
                   { $$ = 0; }
                 | superclass_list
                   { $$ = $1; }
@@ -1664,42 +1664,42 @@ opt_superclass_list
 
 superclass_list : EXPR_LT
                   {
                     YYUSE ($1);
 
                     lexer.enable_fq_identifier ();
                   }
                   superclass
-                  { $$ = new tree_classdef_superclass_list ($3); }
+                  { $$ = new octave::tree_classdef_superclass_list ($3); }
                 | superclass_list EXPR_AND
                   {
                     YYUSE ($2);
 
                     lexer.enable_fq_identifier ();
                   }
                   superclass
                   {
                     $1->append ($4);
                     $$ = $1;
                   }
                 ;
 
 superclass      : FQ_IDENT
-                  { $$ = new tree_classdef_superclass ($1->text ()); }
+                  { $$ = new octave::tree_classdef_superclass ($1->text ()); }
                 ;
 
 class_body      : properties_block
-                  { $$ = new tree_classdef_body ($1); }
+                  { $$ = new octave::tree_classdef_body ($1); }
                 | methods_block
-                  { $$ = new tree_classdef_body ($1); }
+                  { $$ = new octave::tree_classdef_body ($1); }
                 | events_block
-                  { $$ = new tree_classdef_body ($1); }
+                  { $$ = new octave::tree_classdef_body ($1); }
                 | enum_block
-                  { $$ = new tree_classdef_body ($1); }
+                  { $$ = new octave::tree_classdef_body ($1); }
                 | class_body opt_sep properties_block
                   {
                     YYUSE ($2);
 
                     $1->append ($3);
                     $$ = $1;
                   }
                 | class_body opt_sep methods_block
@@ -1748,34 +1748,34 @@ properties_block
                         // make_classdef_properties_block delete $3.
                         YYABORT;
                       }
                   }
                 ;
 
 property_list
                 : class_property
-                  { $$ = new tree_classdef_property_list ($1); }
+                  { $$ = new octave::tree_classdef_property_list ($1); }
                 | property_list sep class_property
                   {
                     YYUSE ($2);
 
                     $1->append ($3);
                     $$ = $1;
                   }
                 ;
 
 class_property  : identifier
-                  { $$ = new tree_classdef_property ($1); }
+                  { $$ = new octave::tree_classdef_property ($1); }
                 | identifier '=' decl_param_init expression
                   {
                     YYUSE ($2);
 
                     lexer.looking_at_initializer_expression = false;
-                    $$ = new tree_classdef_property ($1, $4);
+                    $$ = new octave::tree_classdef_property ($1, $4);
                   }
                 ;
 
 methods_block   : METHODS stash_comment opt_attr_list opt_sep methods_list opt_sep END
                   {
                     YYUSE ($4);
                     YYUSE ($6);
 
@@ -1836,17 +1836,17 @@ method          : method_decl
                 ;
 
 methods_list    : method
                   {
                     octave_value fcn;
                     if ($1)
                       fcn = $1->function ();
                     delete $1;
-                    $$ = new tree_classdef_methods_list (fcn);
+                    $$ = new octave::tree_classdef_methods_list (fcn);
                   }
                 | methods_list opt_sep method
                   {
                     YYUSE ($2);
 
                     octave_value fcn;
                     if ($3)
                       fcn = $3->function ();
@@ -1878,28 +1878,28 @@ events_block    : EVENTS stash_comment o
                       {
                         // make_classdef_events_block deleted $3.
                         YYABORT;
                       }
                   }
                 ;
 
 events_list     : class_event
-                  { $$ = new tree_classdef_events_list ($1); }
+                  { $$ = new octave::tree_classdef_events_list ($1); }
                 | events_list opt_sep class_event
                   {
                     YYUSE ($2);
 
                     $1->append ($3);
                     $$ = $1;
                   }
                 ;
 
 class_event     : identifier
-                  { $$ = new tree_classdef_event ($1); }
+                  { $$ = new octave::tree_classdef_event ($1); }
                 ;
 
 enum_block      : ENUMERATION stash_comment opt_attr_list opt_sep enum_list opt_sep END
                   {
                     YYUSE ($4);
                     YYUSE ($6);
 
                     if (! ($$ = parser.make_classdef_enum_block
@@ -1918,28 +1918,28 @@ enum_block      : ENUMERATION stash_comm
                       {
                         // make_classdef_enum_block deleted $3.
                         YYABORT;
                       }
                   }
                 ;
 
 enum_list       : class_enum
-                  { $$ = new tree_classdef_enum_list ($1); }
+                  { $$ = new octave::tree_classdef_enum_list ($1); }
                 | enum_list opt_sep class_enum
                   {
                     YYUSE ($2);
 
                     $1->append ($3);
                     $$ = $1;
                   }
                 ;
 
 class_enum      : identifier '(' expression ')'
-                  { $$ = new tree_classdef_enum ($1, $3); }
+                  { $$ = new octave::tree_classdef_enum ($1, $3); }
                 ;
 
 // =============
 // Miscellaneous
 // =============
 
 stmt_begin      : // empty
                   {
@@ -4331,187 +4331,190 @@ parse_fcn_file (const std::string& full_
     error ("no such file, '%s'", full_file.c_str ());
   else if (! warn_for.empty ())
     error ("%s: unable to open file '%s'", warn_for.c_str (),
            full_file.c_str ());
 
   return fcn_ptr;
 }
 
-std::string
-get_help_from_file (const std::string& nm, bool& symbol_found,
-                    std::string& full_file)
-{
-  std::string retval;
-
-  full_file = fcn_file_in_path (nm);
-
-  std::string file = full_file;
-
-  size_t file_len = file.length ();
-
-  if ((file_len > 4 && file.substr (file_len-4) == ".oct")
-      || (file_len > 4 && file.substr (file_len-4) == ".mex")
-      || (file_len > 2 && file.substr (file_len-2) == ".m"))
-    {
-      file = octave::sys::env::base_pathname (file);
-      file = file.substr (0, file.find_last_of ('.'));
-
-      size_t pos = file.find_last_of (octave::sys::file_ops::dir_sep_str ());
-      if (pos != std::string::npos)
-        file = file.substr (pos+1);
-    }
-
-  if (! file.empty ())
-    {
-      symbol_found = true;
-
-      octave_function *fcn
-        = parse_fcn_file (full_file, file, "", "", true, false, false, false,
-                          "");
-
-      if (fcn)
-        {
-          retval = fcn->doc_string ();
-
-          delete fcn;
-        }
-    }
-
-  return retval;
-}
-
-std::string
-get_help_from_file (const std::string& nm, bool& symbol_found)
-{
-  std::string file;
-  return get_help_from_file (nm, symbol_found, file);
-}
-
-std::string
-lookup_autoload (const std::string& nm)
-{
-  std::string retval;
-
-  typedef std::map<std::string, std::string>::const_iterator am_iter;
-
-  am_iter p = autoload_map.find (nm);
-
-  if (p != autoload_map.end ())
-    retval = load_path::find_file (p->second);
-
-  return retval;
-}
-
-string_vector
-autoloaded_functions (void)
-{
-  string_vector names (autoload_map.size ());
-
-  octave_idx_type i = 0;
-  for (const auto& fcn_fname : autoload_map)
-    names[i++] = fcn_fname.first;
-
-  return names;
-}
-
-string_vector
-reverse_lookup_autoload (const std::string& nm)
+namespace octave
 {
-  string_vector names;
-
-  for (const auto& fcn_fname : autoload_map)
-    if (nm == fcn_fname.second)
-      names.append (fcn_fname.first);
-
-  return names;
-}
-
-octave_function *
-load_fcn_from_file (const std::string& file_name, const std::string& dir_name,
-                    const std::string& dispatch_type,
-                    const std::string& package_name,
-                    const std::string& fcn_name, bool autoload)
-{
-  octave_function *retval = 0;
-
-  octave::unwind_protect frame;
-
-  std::string nm = file_name;
-
-  size_t nm_len = nm.length ();
-
-  std::string file;
-
-  bool relative_lookup = false;
-
-  file = nm;
-
-  if ((nm_len > 4 && nm.substr (nm_len-4) == ".oct")
-      || (nm_len > 4 && nm.substr (nm_len-4) == ".mex")
-      || (nm_len > 2 && nm.substr (nm_len-2) == ".m"))
-    {
-      nm = octave::sys::env::base_pathname (file);
-      nm = nm.substr (0, nm.find_last_of ('.'));
-
-      size_t pos = nm.find_last_of (octave::sys::file_ops::dir_sep_str ());
-      if (pos != std::string::npos)
-        nm = nm.substr (pos+1);
-    }
-
-  relative_lookup = ! octave::sys::env::absolute_pathname (file);
-
-  file = octave::sys::env::make_absolute (file);
-
-  int len = file.length ();
-
-  if (len > 4 && file.substr (len-4, len-1) == ".oct")
-    {
-      if (autoload && ! fcn_name.empty ())
-        nm = fcn_name;
-
-      retval = octave::dynamic_loader::load_oct (nm, file, relative_lookup);
-    }
-  else if (len > 4 && file.substr (len-4, len-1) == ".mex")
-    {
-      // Temporarily load m-file version of mex-file, if it exists,
-      // to get the help-string to use.
-
-      octave_function *tmpfcn = parse_fcn_file (file.substr (0, len - 2),
-                                                nm, dispatch_type,
-                                                package_name, false,
-                                                autoload, autoload,
-                                                relative_lookup, "");
-
-      retval = octave::dynamic_loader::load_mex (nm, file, relative_lookup);
-
-      if (tmpfcn)
-        retval->document (tmpfcn->doc_string ());
-      delete tmpfcn;
-    }
-  else if (len > 2)
-    {
-      retval = parse_fcn_file (file, nm, dispatch_type, package_name, true,
-                               autoload, autoload, relative_lookup, "");
-    }
-
-  if (retval)
-    {
-      retval->stash_dir_name (dir_name);
-      retval->stash_package_name (package_name);
-
-      if (retval->is_user_function ())
-        {
-          symbol_table::scope_id id = retval->scope ();
-
-          symbol_table::stash_dir_name_for_subfunctions (id, dir_name);
-        }
-    }
-
-  return retval;
+  std::string
+  get_help_from_file (const std::string& nm, bool& symbol_found,
+                      std::string& full_file)
+  {
+    std::string retval;
+
+    full_file = fcn_file_in_path (nm);
+
+    std::string file = full_file;
+
+    size_t file_len = file.length ();
+
+    if ((file_len > 4 && file.substr (file_len-4) == ".oct")
+        || (file_len > 4 && file.substr (file_len-4) == ".mex")
+        || (file_len > 2 && file.substr (file_len-2) == ".m"))
+      {
+        file = octave::sys::env::base_pathname (file);
+        file = file.substr (0, file.find_last_of ('.'));
+
+        size_t pos = file.find_last_of (octave::sys::file_ops::dir_sep_str ());
+        if (pos != std::string::npos)
+          file = file.substr (pos+1);
+      }
+
+    if (! file.empty ())
+      {
+        symbol_found = true;
+
+        octave_function *fcn
+          = parse_fcn_file (full_file, file, "", "", true, false, false, false,
+                            "");
+
+        if (fcn)
+          {
+            retval = fcn->doc_string ();
+
+            delete fcn;
+          }
+      }
+
+    return retval;
+  }
+
+  std::string
+  get_help_from_file (const std::string& nm, bool& symbol_found)
+  {
+    std::string file;
+    return get_help_from_file (nm, symbol_found, file);
+  }
+
+  std::string
+  lookup_autoload (const std::string& nm)
+  {
+    std::string retval;
+
+    typedef std::map<std::string, std::string>::const_iterator am_iter;
+
+    am_iter p = autoload_map.find (nm);
+
+    if (p != autoload_map.end ())
+      retval = load_path::find_file (p->second);
+
+    return retval;
+  }
+
+  string_vector
+  autoloaded_functions (void)
+  {
+    string_vector names (autoload_map.size ());
+
+    octave_idx_type i = 0;
+    for (const auto& fcn_fname : autoload_map)
+      names[i++] = fcn_fname.first;
+
+    return names;
+  }
+
+  string_vector
+  reverse_lookup_autoload (const std::string& nm)
+  {
+    string_vector names;
+
+    for (const auto& fcn_fname : autoload_map)
+      if (nm == fcn_fname.second)
+        names.append (fcn_fname.first);
+
+    return names;
+  }
+
+  octave_function *
+  load_fcn_from_file (const std::string& file_name, const std::string& dir_name,
+                      const std::string& dispatch_type,
+                      const std::string& package_name,
+                      const std::string& fcn_name, bool autoload)
+  {
+    octave_function *retval = 0;
+
+    octave::unwind_protect frame;
+
+    std::string nm = file_name;
+
+    size_t nm_len = nm.length ();
+
+    std::string file;
+
+    bool relative_lookup = false;
+
+    file = nm;
+
+    if ((nm_len > 4 && nm.substr (nm_len-4) == ".oct")
+        || (nm_len > 4 && nm.substr (nm_len-4) == ".mex")
+        || (nm_len > 2 && nm.substr (nm_len-2) == ".m"))
+      {
+        nm = octave::sys::env::base_pathname (file);
+        nm = nm.substr (0, nm.find_last_of ('.'));
+
+        size_t pos = nm.find_last_of (octave::sys::file_ops::dir_sep_str ());
+        if (pos != std::string::npos)
+          nm = nm.substr (pos+1);
+      }
+
+    relative_lookup = ! octave::sys::env::absolute_pathname (file);
+
+    file = octave::sys::env::make_absolute (file);
+
+    int len = file.length ();
+
+    if (len > 4 && file.substr (len-4, len-1) == ".oct")
+      {
+        if (autoload && ! fcn_name.empty ())
+          nm = fcn_name;
+
+        retval = octave::dynamic_loader::load_oct (nm, file, relative_lookup);
+      }
+    else if (len > 4 && file.substr (len-4, len-1) == ".mex")
+      {
+        // Temporarily load m-file version of mex-file, if it exists,
+        // to get the help-string to use.
+
+        octave_function *tmpfcn = parse_fcn_file (file.substr (0, len - 2),
+                                                  nm, dispatch_type,
+                                                  package_name, false,
+                                                  autoload, autoload,
+                                                  relative_lookup, "");
+
+        retval = octave::dynamic_loader::load_mex (nm, file, relative_lookup);
+
+        if (tmpfcn)
+          retval->document (tmpfcn->doc_string ());
+        delete tmpfcn;
+      }
+    else if (len > 2)
+      {
+        retval = parse_fcn_file (file, nm, dispatch_type, package_name, true,
+                                 autoload, autoload, relative_lookup, "");
+      }
+
+    if (retval)
+      {
+        retval->stash_dir_name (dir_name);
+        retval->stash_package_name (package_name);
+
+        if (retval->is_user_function ())
+          {
+            symbol_table::scope_id id = retval->scope ();
+
+            symbol_table::stash_dir_name_for_subfunctions (id, dir_name);
+          }
+      }
+
+    return retval;
+  }
 }
 
 DEFUN (autoload, args, ,
        doc: /* -*- texinfo -*-
 @deftypefn  {} {@var{autoload_map} =} autoload ()
 @deftypefnx {} {} autoload (@var{function}, @var{file})
 @deftypefnx {} {} autoload (@dots{}, "remove")
 Define @var{function} to autoload from @var{file}.
@@ -4624,158 +4627,161 @@ not loaded anymore during the current Oc
           symbol_table::clear_dld_function (argv[1]);
           autoload_map.erase (argv[1]);
         }
     }
 
   return retval;
 }
 
-void
-source_file (const std::string& file_name, const std::string& context,
-             bool verbose, bool require_file, const std::string& warn_for)
+namespace octave
 {
-  // Map from absolute name of script file to recursion level.  We
-  // use a map instead of simply placing a limit on recursion in the
-  // source_file function so that two mutually recursive scripts
-  // written as
-  //
-  //   foo1.m:
-  //   ------
-  //   foo2
-  //
-  //   foo2.m:
-  //   ------
-  //   foo1
-  //
-  // and called with
-  //
-  //   foo1
-  //
-  // (for example) will behave the same if they are written as
-  //
-  //   foo1.m:
-  //   ------
-  //   source ("foo2.m")
-  //
-  //   foo2.m:
-  //   ------
-  //   source ("foo1.m")
-  //
-  // and called with
-  //
-  //   source ("foo1.m")
-  //
-  // (for example).
-
-  static std::map<std::string, int> source_call_depth;
-
-  std::string file_full_name = octave::sys::file_ops::tilde_expand (file_name);
-
-  file_full_name = octave::sys::env::make_absolute (file_full_name);
-
-  octave::unwind_protect frame;
-
-  if (source_call_depth.find (file_full_name) == source_call_depth.end ())
-    source_call_depth[file_full_name] = -1;
-
-  frame.protect_var (source_call_depth[file_full_name]);
-
-  source_call_depth[file_full_name]++;
-
-  if (source_call_depth[file_full_name] >= Vmax_recursion_depth)
-    error ("max_recursion_depth exceeded");
-
-  if (! context.empty ())
-    {
-      if (context == "caller")
-        octave::call_stack::goto_caller_frame ();
-      else if (context == "base")
-        octave::call_stack::goto_base_frame ();
-      else
-        error ("source: context must be \"caller\" or \"base\"");
-
-      frame.add_fcn (octave::call_stack::pop);
-    }
-
-  octave_function *fcn = 0;
-  // Don't delete a function already in symbol_table
-  bool delete_fcn = false;
-
-  // Find symbol name that would be in symbol_table, if it were loaded.
-  size_t dir_end = file_name.find_last_of (octave::sys::file_ops::dir_sep_chars ());
-  dir_end = (dir_end == std::string::npos) ? 0 : dir_end + 1;
-
-  size_t extension = file_name.find_last_of ('.');
-  if (extension == std::string::npos)
-    extension = file_name.length ();
-
-  std::string symbol = file_name.substr (dir_end, extension - dir_end);
-  std::string full_name = octave::sys::canonicalize_file_name (file_name);
-
-  // Check if this file is already loaded (or in the path)
-  octave_value loaded_sym = symbol_table::find (symbol);
-  if (loaded_sym.is_function ())
-    {
-      fcn = loaded_sym.function_value ();
-      if (fcn)
-        {
-          if (octave::sys::canonicalize_file_name (fcn->fcn_file_name ())
-              != full_name)
-            {
-              fcn = 0;             // wrong file, so load it below
-              delete_fcn = true;   // and delete it when done.
-            }
-        }
-    }
-
-  // If no symbol of this name, or the symbol is for a different file, load
-  if (! fcn)
-    {
-      try
-        {
-          fcn = parse_fcn_file (file_full_name, file_name, "", "",
-                                require_file, true, false, false, warn_for);
-        }
-      catch (octave::execution_exception& e)
-        {
-          error (e, "source: error sourcing file '%s'",
-                 file_full_name.c_str ());
-        }
-    }
-
-  // Return or error if we don't have a valid script
-  if (! fcn)
-    return;
-
-  if (! fcn->is_user_code ())
-    {
-      if (delete_fcn)
-        delete fcn;
-      error ("source: %s is not a script", full_name.c_str ());
-    }
-
-  // Parameter checking is over.  Now run.
-  octave_value_list args;
-
-  if (verbose)
-    {
-      std::cout << "executing commands from " << full_name << " ... ";
-      reading_startup_message_printed = true;
-      std::cout.flush ();
-    }
-
-  fcn->do_multi_index_op (0, args);
-
-  if (verbose)
-    std::cout << "done." << std::endl;
-
-  // Delete scripts not on the path, so they don't shadow ones that are.
-  if (delete_fcn)
-    delete fcn;
+  void
+  source_file (const std::string& file_name, const std::string& context,
+               bool verbose, bool require_file, const std::string& warn_for)
+  {
+    // Map from absolute name of script file to recursion level.  We
+    // use a map instead of simply placing a limit on recursion in the
+    // source_file function so that two mutually recursive scripts
+    // written as
+    //
+    //   foo1.m:
+    //   ------
+    //   foo2
+    //
+    //   foo2.m:
+    //   ------
+    //   foo1
+    //
+    // and called with
+    //
+    //   foo1
+    //
+    // (for example) will behave the same if they are written as
+    //
+    //   foo1.m:
+    //   ------
+    //   source ("foo2.m")
+    //
+    //   foo2.m:
+    //   ------
+    //   source ("foo1.m")
+    //
+    // and called with
+    //
+    //   source ("foo1.m")
+    //
+    // (for example).
+
+    static std::map<std::string, int> source_call_depth;
+
+    std::string file_full_name = octave::sys::file_ops::tilde_expand (file_name);
+
+    file_full_name = octave::sys::env::make_absolute (file_full_name);
+
+    octave::unwind_protect frame;
+
+    if (source_call_depth.find (file_full_name) == source_call_depth.end ())
+      source_call_depth[file_full_name] = -1;
+
+    frame.protect_var (source_call_depth[file_full_name]);
+
+    source_call_depth[file_full_name]++;
+
+    if (source_call_depth[file_full_name] >= Vmax_recursion_depth)
+      error ("max_recursion_depth exceeded");
+
+    if (! context.empty ())
+      {
+        if (context == "caller")
+          octave::call_stack::goto_caller_frame ();
+        else if (context == "base")
+          octave::call_stack::goto_base_frame ();
+        else
+          error ("source: context must be \"caller\" or \"base\"");
+
+        frame.add_fcn (octave::call_stack::pop);
+      }
+
+    octave_function *fcn = 0;
+    // Don't delete a function already in symbol_table
+    bool delete_fcn = false;
+
+    // Find symbol name that would be in symbol_table, if it were loaded.
+    size_t dir_end = file_name.find_last_of (octave::sys::file_ops::dir_sep_chars ());
+    dir_end = (dir_end == std::string::npos) ? 0 : dir_end + 1;
+
+    size_t extension = file_name.find_last_of ('.');
+    if (extension == std::string::npos)
+      extension = file_name.length ();
+
+    std::string symbol = file_name.substr (dir_end, extension - dir_end);
+    std::string full_name = octave::sys::canonicalize_file_name (file_name);
+
+    // Check if this file is already loaded (or in the path)
+    octave_value loaded_sym = symbol_table::find (symbol);
+    if (loaded_sym.is_function ())
+      {
+        fcn = loaded_sym.function_value ();
+        if (fcn)
+          {
+            if (octave::sys::canonicalize_file_name (fcn->fcn_file_name ())
+                != full_name)
+              {
+                fcn = 0;             // wrong file, so load it below
+                delete_fcn = true;   // and delete it when done.
+              }
+          }
+      }
+
+    // If no symbol of this name, or the symbol is for a different file, load
+    if (! fcn)
+      {
+        try
+          {
+            fcn = parse_fcn_file (file_full_name, file_name, "", "",
+                                  require_file, true, false, false, warn_for);
+          }
+        catch (octave::execution_exception& e)
+          {
+            error (e, "source: error sourcing file '%s'",
+                   file_full_name.c_str ());
+          }
+      }
+
+    // Return or error if we don't have a valid script
+    if (! fcn)
+      return;
+
+    if (! fcn->is_user_code ())
+      {
+        if (delete_fcn)
+          delete fcn;
+        error ("source: %s is not a script", full_name.c_str ());
+      }
+
+    // Parameter checking is over.  Now run.
+    octave_value_list args;
+
+    if (verbose)
+      {
+        std::cout << "executing commands from " << full_name << " ... ";
+        reading_startup_message_printed = true;
+        std::cout.flush ();
+      }
+
+    fcn->do_multi_index_op (0, args);
+
+    if (verbose)
+      std::cout << "done." << std::endl;
+
+    // Delete scripts not on the path, so they don't shadow ones that are.
+    if (delete_fcn)
+      delete fcn;
+  }
 }
 
 DEFUN (mfilename, args, ,
        doc: /* -*- texinfo -*-
 @deftypefn  {} {} mfilename ()
 @deftypefnx {} {} mfilename ("fullpath")
 @deftypefnx {} {} mfilename ("fullpathext")
 Return the name of the currently executing file.
@@ -4859,106 +4865,112 @@ context of the function that called the 
 
   std::string file_name = args(0).xstring_value ("source: FILE must be a string");
 
   std::string context;
 
   if (nargin == 2)
     context = args(1).xstring_value ("source: CONTEXT must be a string");
 
-  source_file (file_name, context);
+  octave::source_file (file_name, context);
 
   return retval;
 }
 
-/*!
+namespace octave
+{
+  /*!
     Evaluate an Octave function (built-in or interpreted) and return
     the list of result values.
 
     @param name The name of the function to call.
     @param args The arguments to the function.
     @param nargout The number of output arguments expected.
     @return A list of output values.  The length of the list is not
-      necessarily the same as @c nargout.
-
-*/
-octave_value_list
-feval (const std::string& name, const octave_value_list& args, int nargout)
-{
-  octave_value_list retval;
-
-  octave_value fcn = symbol_table::find_function (name, args);
-
-  if (fcn.is_defined ())
-    retval = fcn.do_multi_index_op (nargout, args);
-  else
-    error ("feval: function '%s' not found", name.c_str ());
-
-  return retval;
-}
-
-octave_value_list
-feval (octave_function *fcn, const octave_value_list& args, int nargout)
-{
-  octave_value_list retval;
-
-  if (fcn)
-    retval = fcn->do_multi_index_op (nargout, args);
-
-  return retval;
+    necessarily the same as @c nargout.
+
+  */
+  octave_value_list
+  feval (const std::string& name, const octave_value_list& args, int nargout)
+  {
+    octave_value_list retval;
+
+    octave_value fcn = symbol_table::find_function (name, args);
+
+    if (fcn.is_defined ())
+      retval = fcn.do_multi_index_op (nargout, args);
+    else
+      error ("feval: function '%s' not found", name.c_str ());
+
+    return retval;
+  }
+
+  octave_value_list
+  feval (octave_function *fcn, const octave_value_list& args, int nargout)
+  {
+    octave_value_list retval;
+
+    if (fcn)
+      retval = fcn->do_multi_index_op (nargout, args);
+
+    return retval;
+  }
 }
 
 static octave_value_list
 get_feval_args (const octave_value_list& args)
 {
   return args.slice (1, args.length () - 1, true);
 }
 
-/*!
+namespace octave
+{
+  /*!
     Evaluate an Octave function (built-in or interpreted) and return
     the list of result values.
 
     @param args The first element of @c args is the function to call.
-      It may be the name of the function as a string, a function
-      handle, or an inline function.  The remaining arguments are
-      passed to the function.
+    It may be the name of the function as a string, a function
+    handle, or an inline function.  The remaining arguments are
+    passed to the function.
     @param nargout The number of output arguments expected.
     @return A list of output values.  The length of the list is not
-      necessarily the same as @c nargout.
-*/
-octave_value_list
-feval (const octave_value_list& args, int nargout)
-{
-  octave_value_list retval;
-
-  if (args.length () > 0)
-    {
-      octave_value f_arg = args(0);
-
-      if (f_arg.is_string ())
-        {
-          std::string name = f_arg.string_value ();
-
-          octave_value_list tmp_args = get_feval_args (args);
-
-          retval = feval (name, tmp_args, nargout);
-        }
-      else if (f_arg.is_function_handle ()
-               || f_arg.is_anonymous_function ()
-               || f_arg.is_inline_function ())
-        {
-          const octave_value_list tmp_args = get_feval_args (args);
-
-          retval = f_arg.do_multi_index_op (nargout, tmp_args);
-        }
-      else
-        error ("feval: first argument must be a string, inline function, or a function handle");
-    }
-
-  return retval;
+    necessarily the same as @c nargout.
+  */
+  octave_value_list
+  feval (const octave_value_list& args, int nargout)
+  {
+    octave_value_list retval;
+
+    if (args.length () > 0)
+      {
+        octave_value f_arg = args(0);
+
+        if (f_arg.is_string ())
+          {
+            std::string name = f_arg.string_value ();
+
+            octave_value_list tmp_args = get_feval_args (args);
+
+            retval = octave::feval (name, tmp_args, nargout);
+          }
+        else if (f_arg.is_function_handle ()
+                 || f_arg.is_anonymous_function ()
+                 || f_arg.is_inline_function ())
+          {
+            const octave_value_list tmp_args = get_feval_args (args);
+
+            retval = f_arg.do_multi_index_op (nargout, tmp_args);
+          }
+        else
+          error ("feval: first argument must be a string, inline function, or a function handle");
+      }
+
+    return retval;
+  }
 }
 
 DEFUN (feval, args, nargout,
        doc: /* -*- texinfo -*-
 @deftypefn {} {} feval (@var{name}, @dots{})
 Evaluate the function named @var{name}.
 
 Any arguments after the first are passed as inputs to the named function.
@@ -4994,17 +5006,17 @@ are equivalent ways to call the function
 cannot be predicted beforehand whether @var{f} is a function handle,
 function name in a string, or inline function then @code{feval} can be used
 instead.
 @end deftypefn */)
 {
   if (args.length () == 0)
     print_usage ();
 
-  return feval (args, nargout);
+  return octave::feval (args, nargout);
 }
 
 DEFUN (builtin, args, nargout,
        doc: /* -*- texinfo -*-
 @deftypefn {} {[@dots{}] =} builtin (@var{f}, @dots{})
 Call the base function @var{f} even if @var{f} is overloaded to another
 function for the given type signature.
 
@@ -5033,121 +5045,124 @@ builtin ("sin", 0)
   if (args.length () == 0)
     print_usage ();
 
   const std::string name (args(0).xstring_value ("builtin: function name (F) must be a string"));
 
   octave_value fcn = symbol_table::builtin_find (name);
 
   if (fcn.is_defined ())
-    retval = feval (fcn.function_value (), args.splice (0, 1), nargout);
+    retval = octave::feval (fcn.function_value (), args.splice (0, 1), nargout);
   else
     error ("builtin: lookup for symbol '%s' failed", name.c_str ());
 
   return retval;
 }
 
-octave_value_list
-eval_string (const std::string& eval_str, bool silent,
-             int& parse_status, int nargout)
+namespace octave
 {
-  octave_value_list retval;
-
-  octave::parser parser (eval_str);
-
-  do
-    {
-      parser.reset ();
-
-      parse_status = parser.run ();
-
-      if (parse_status == 0)
-        {
-          if (parser.stmt_list)
-            {
-              tree_statement *stmt = 0;
-
-              if (parser.stmt_list->length () == 1
-                  && (stmt = parser.stmt_list->front ())
-                  && stmt->is_expression ())
-                {
-                  tree_expression *expr = stmt->expression ();
-
-                  if (silent)
-                    expr->set_print_flag (false);
-
-                  bool do_bind_ans = false;
-
-                  if (expr->is_identifier ())
-                    {
-                      tree_identifier *id
-                        = dynamic_cast<tree_identifier *> (expr);
-
-                      do_bind_ans = (! id->is_variable ());
-                    }
-                  else
-                    do_bind_ans = (! expr->is_assignment_expression ());
-
-                  retval = expr->rvalue (nargout);
-
-                  if (do_bind_ans && ! retval.empty ())
-                    bind_ans (retval(0), expr->print_result ());
-
-                  if (nargout == 0)
-                    retval = octave_value_list ();
-                }
-              else if (nargout == 0)
-                parser.stmt_list->accept (*octave::current_evaluator);
-              else
-                error ("eval: invalid use of statement list");
-
-              if (tree_return_command::returning
-                  || tree_break_command::breaking
-                  || tree_continue_command::continuing)
-                break;
-            }
-          else if (parser.lexer.end_of_input)
-            break;
-        }
-    }
-  while (parse_status == 0);
-
-  return retval;
-}
-
-octave_value
-eval_string (const std::string& eval_str, bool silent, int& parse_status)
-{
-  octave_value retval;
-
-  octave_value_list tmp = eval_string (eval_str, silent, parse_status, 1);
-
-  if (! tmp.empty ())
-    retval = tmp(0);
-
-  return retval;
-}
-
-static octave_value_list
-eval_string (const octave_value& arg, bool silent, int& parse_status,
-             int nargout)
-{
-  std::string s = arg.xstring_value ("eval: expecting std::string argument");
-
-  return eval_string (s, silent, parse_status, nargout);
-}
-
-void
-cleanup_statement_list (tree_statement_list **lst)
-{
-  if (*lst)
-    {
-      delete *lst;
-      *lst = 0;
-    }
+  octave_value_list
+  eval_string (const std::string& eval_str, bool silent,
+               int& parse_status, int nargout)
+  {
+    octave_value_list retval;
+
+    octave::parser parser (eval_str);
+
+    do
+      {
+        parser.reset ();
+
+        parse_status = parser.run ();
+
+        if (parse_status == 0)
+          {
+            if (parser.stmt_list)
+              {
+                tree_statement *stmt = 0;
+
+                if (parser.stmt_list->length () == 1
+                    && (stmt = parser.stmt_list->front ())
+                    && stmt->is_expression ())
+                  {
+                    tree_expression *expr = stmt->expression ();
+
+                    if (silent)
+                      expr->set_print_flag (false);
+
+                    bool do_bind_ans = false;
+
+                    if (expr->is_identifier ())
+                      {
+                        tree_identifier *id
+                          = dynamic_cast<tree_identifier *> (expr);
+
+                        do_bind_ans = (! id->is_variable ());
+                      }
+                    else
+                      do_bind_ans = (! expr->is_assignment_expression ());
+
+                    retval = expr->rvalue (nargout);
+
+                    if (do_bind_ans && ! retval.empty ())
+                      bind_ans (retval(0), expr->print_result ());
+
+                    if (nargout == 0)
+                      retval = octave_value_list ();
+                  }
+                else if (nargout == 0)
+                  parser.stmt_list->accept (*octave::current_evaluator);
+                else
+                  error ("eval: invalid use of statement list");
+
+                if (tree_return_command::returning
+                    || tree_break_command::breaking
+                    || tree_continue_command::continuing)
+                  break;
+              }
+            else if (parser.lexer.end_of_input)
+              break;
+          }
+      }
+    while (parse_status == 0);
+
+    return retval;
+  }
+
+  octave_value
+  eval_string (const std::string& eval_str, bool silent, int& parse_status)
+  {
+    octave_value retval;
+
+    octave_value_list tmp = eval_string (eval_str, silent, parse_status, 1);
+
+    if (! tmp.empty ())
+      retval = tmp(0);
+
+    return retval;
+  }
+
+  static octave_value_list
+  eval_string (const octave_value& arg, bool silent, int& parse_status,
+               int nargout)
+  {
+    std::string s = arg.xstring_value ("eval: expecting std::string argument");
+
+    return eval_string (s, silent, parse_status, nargout);
+  }
+
+  void
+  cleanup_statement_list (tree_statement_list **lst)
+  {
+    if (*lst)
+      {
+        delete *lst;
+        *lst = 0;
+      }
+  }
 }
 
 DEFUN (eval, args, nargout,
        doc: /* -*- texinfo -*-
 @deftypefn  {} {} eval (@var{try})
 @deftypefnx {} {} eval (@var{try}, @var{catch})
 Parse the string @var{try} and evaluate it as if it were an Octave
 program.
@@ -5203,33 +5218,33 @@ does.
   int parse_status = 0;
 
   bool execution_error = false;
 
   octave_value_list tmp;
 
   try
     {
-      tmp = eval_string (args(0), nargout > 0, parse_status, nargout);
+      tmp = octave::eval_string (args(0), nargout > 0, parse_status, nargout);
     }
   catch (const octave::execution_exception&)
     {
       recover_from_exception ();
 
       execution_error = true;
     }
 
   if (nargin > 1 && (parse_status != 0 || execution_error))
     {
       // Set up for letting the user print any messages from
       // errors that occurred in the first part of this eval().
 
       buffer_error_messages--;
 
-      tmp = eval_string (args(1), nargout > 0, parse_status, nargout);
+      tmp = octave::eval_string (args(1), nargout > 0, parse_status, nargout);
 
       if (nargout > 0)
         retval = tmp;
     }
   else
     {
       if (nargout > 0)
         retval = tmp;
@@ -5372,35 +5387,35 @@ Like @code{eval}, except that the expres
   int parse_status = 0;
 
   bool execution_error = false;
 
   octave_value_list tmp;
 
   try
     {
-      tmp = eval_string (args(1), nargout > 0,
-                         parse_status, nargout);
+      tmp = octave::eval_string (args(1), nargout > 0,
+                                 parse_status, nargout);
     }
   catch (const octave::execution_exception&)
     {
       recover_from_exception ();
 
       execution_error = true;
     }
 
   if (nargin > 2 && (parse_status != 0 || execution_error))
     {
       // Set up for letting the user print any messages from
       // errors that occurred in the first part of this eval().
 
       buffer_error_messages--;
 
-      tmp = eval_string (args(2), nargout > 0,
-                         parse_status, nargout);
+      tmp = octave::eval_string (args(2), nargout > 0,
+                                 parse_status, nargout);
 
       retval = (nargout > 0) ? tmp : octave_value_list ();
     }
   else
     {
       if (nargout > 0)
         retval = tmp;
 
diff --git a/libinterp/parse-tree/parse.h b/libinterp/parse-tree/parse.h
--- a/libinterp/parse-tree/parse.h
+++ b/libinterp/parse-tree/parse.h
@@ -35,114 +35,69 @@ along with Octave; see the file COPYING.
 
 #include "lex.h"
 #include "symtab.h"
 #include "token.h"
 
 class octave_comment_list;
 class octave_function;
 class octave_user_function;
-class tree;
-class tree_anon_fcn_handle;
-class tree_argument_list;
-class tree_array_list;
-class tree_cell;
-class tree_classdef;
-class tree_classdef_attribute_list;
-class tree_classdef_body;
-class tree_classdef_enum_block;
-class tree_classdef_enum_list;
-class tree_classdef_events_block;
-class tree_classdef_events_list;
-class tree_classdef_methods_block;
-class tree_classdef_methods_list;
-class tree_classdef_properties_block;
-class tree_classdef_property_list;
-class tree_classdef_superclass_list;
-class tree_colon_expression;
-class tree_command;
-class tree_constant;
-class tree_decl_command;
-class tree_decl_init_list;
-class tree_expression;
-class tree_fcn_handle;
-class tree_funcall;
-class tree_function_def;
-class tree_identifier;
-class tree_if_clause;
-class tree_if_command;
-class tree_if_command_list;
-class tree_index_expression;
-class tree_matrix;
-class tree_matrix;
-class tree_parameter_list;
-class tree_statement;
-class tree_statement_list;
-class tree_statement_listtree_statement;
-class tree_switch_case;
-class tree_switch_case_list;
-class tree_switch_command;
+
+namespace octave
+{
+  class tree;
+  class tree_anon_fcn_handle;
+  class tree_argument_list;
+  class tree_array_list;
+  class tree_cell;
+  class tree_classdef;
+  class tree_classdef_attribute_list;
+  class tree_classdef_body;
+  class tree_classdef_enum_block;
+  class tree_classdef_enum_list;
+  class tree_classdef_events_block;
+  class tree_classdef_events_list;
+  class tree_classdef_methods_block;
+  class tree_classdef_methods_list;
+  class tree_classdef_properties_block;
+  class tree_classdef_property_list;
+  class tree_classdef_superclass_list;
+  class tree_colon_expression;
+  class tree_command;
+  class tree_constant;
+  class tree_decl_command;
+  class tree_decl_init_list;
+  class tree_expression;
+  class tree_fcn_handle;
+  class tree_funcall;
+  class tree_function_def;
+  class tree_identifier;
+  class tree_if_clause;
+  class tree_if_command;
+  class tree_if_command_list;
+  class tree_index_expression;
+  class tree_matrix;
+  class tree_matrix;
+  class tree_parameter_list;
+  class tree_statement;
+  class tree_statement_list;
+  class tree_statement_listtree_statement;
+  class tree_switch_case;
+  class tree_switch_case_list;
+  class tree_switch_command;
+}
 
 #include "ovl.h"
 
 // Nonzero means print parser debugging info (-d).
 extern int octave_debug;
 
 // TRUE means we printed messages about reading startup files.
 extern bool reading_startup_message_printed;
 
-extern OCTINTERP_API std::string
-get_help_from_file (const std::string& nm, bool& symbol_found,
-                    std::string& file);
-
-extern OCTINTERP_API std::string
-get_help_from_file (const std::string& nm, bool& symbol_found);
-
-extern OCTINTERP_API std::string lookup_autoload (const std::string& nm);
-
-extern OCTINTERP_API string_vector autoloaded_functions (void);
-
-extern OCTINTERP_API string_vector
-reverse_lookup_autoload (const std::string& nm);
-
-extern OCTINTERP_API octave_function *
-load_fcn_from_file (const std::string& file_name,
-                    const std::string& dir_name = "",
-                    const std::string& dispatch_type = "",
-                    const std::string& package_name = "",
-                    const std::string& fcn_name = "",
-                    bool autoload = false);
-
-extern OCTINTERP_API void
-source_file (const std::string& file_name,
-             const std::string& context = "",
-             bool verbose = false, bool require_file = true,
-             const std::string& warn_for = "");
-
-extern OCTINTERP_API octave_value_list
-feval (const std::string& name,
-       const octave_value_list& args = octave_value_list (),
-       int nargout = 0);
-
-extern OCTINTERP_API octave_value_list
-feval (octave_function *fcn,
-       const octave_value_list& args = octave_value_list (),
-       int nargout = 0);
-
-extern OCTINTERP_API octave_value_list
-feval (const octave_value_list& args, int nargout = 0);
-
-extern OCTINTERP_API octave_value_list
-eval_string (const std::string&, bool silent, int& parse_status, int nargout);
-
-extern OCTINTERP_API octave_value
-eval_string (const std::string&, bool silent, int& parse_status);
-
-extern OCTINTERP_API void cleanup_statement_list (tree_statement_list **lst);
-
 namespace octave
 {
   // Global access to currently active lexer.
   // FIXME: to be removed after more parser+lexer refactoring.
   extern base_lexer *LEXER;
 
   class
   base_parser
@@ -558,12 +513,172 @@ namespace octave
     push_parser (const push_parser&) = delete;
 
     push_parser& operator = (const push_parser&) = delete;
 
     ~push_parser (void) = default;
 
     int run (const std::string& input, bool eof);
   };
+
+  extern OCTINTERP_API std::string
+  get_help_from_file (const std::string& nm, bool& symbol_found,
+                      std::string& file);
+
+  extern OCTINTERP_API std::string
+  get_help_from_file (const std::string& nm, bool& symbol_found);
+
+  extern OCTINTERP_API
+  std::string lookup_autoload (const std::string& nm);
+
+  extern OCTINTERP_API string_vector
+  autoloaded_functions (void);
+
+  extern OCTINTERP_API string_vector
+  reverse_lookup_autoload (const std::string& nm);
+
+  extern OCTINTERP_API octave_function *
+  load_fcn_from_file (const std::string& file_name,
+                      const std::string& dir_name = "",
+                      const std::string& dispatch_type = "",
+                      const std::string& package_name = "",
+                      const std::string& fcn_name = "",
+                      bool autoload = false);
+
+  extern OCTINTERP_API void
+  source_file (const std::string& file_name,
+               const std::string& context = "",
+               bool verbose = false, bool require_file = true,
+               const std::string& warn_for = "");
+
+  extern OCTINTERP_API octave_value_list
+  feval (const std::string& name,
+         const octave_value_list& args = octave_value_list (),
+         int nargout = 0);
+
+  extern OCTINTERP_API octave_value_list
+  feval (octave_function *fcn,
+         const octave_value_list& args = octave_value_list (),
+         int nargout = 0);
+
+  extern OCTINTERP_API octave_value_list
+  feval (const octave_value_list& args, int nargout = 0);
+
+  extern OCTINTERP_API octave_value_list
+  eval_string (const std::string&, bool silent, int& parse_status, int nargout);
+
+  extern OCTINTERP_API octave_value
+  eval_string (const std::string&, bool silent, int& parse_status);
+
+  extern OCTINTERP_API void
+  cleanup_statement_list (octave::tree_statement_list **lst);
+}
+
+#if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
+
+OCTAVE_DEPRECATED ("use 'octave::get_help_from_file' instead")
+static inline std::string
+get_help_from_file (const std::string& nm, bool& symbol_found,
+                    std::string& file)
+{
+  return octave::get_help_from_file (nm, symbol_found, file);
+}
+
+OCTAVE_DEPRECATED ("use 'octave::get_help_from_file' instead")
+static inline std::string
+get_help_from_file (const std::string& nm, bool& symbol_found)
+{
+  return octave::get_help_from_file (nm, symbol_found);
+}
+
+OCTAVE_DEPRECATED ("use 'octave::lookup_autoload' instead")
+static inline std::string
+lookup_autoload (const std::string& nm)
+{
+  return octave::lookup_autoload (nm);
+}
+
+OCTAVE_DEPRECATED ("use 'octave::autoloaded_functions' instead")
+static inline string_vector
+autoloaded_functions (void)
+{
+  return octave::autoloaded_functions ();
+}
+
+OCTAVE_DEPRECATED ("use 'octave::reverse_lookup_autoload' instead")
+static inline string_vector
+reverse_lookup_autoload (const std::string& nm)
+{
+  return octave::reverse_lookup_autoload (nm);
+}
+
+OCTAVE_DEPRECATED ("use 'octave::load_fcn_from_file' instead")
+static inline octave_function *
+load_fcn_from_file (const std::string& file_name,
+                    const std::string& dir_name = "",
+                    const std::string& dispatch_type = "",
+                    const std::string& package_name = "",
+                    const std::string& fcn_name = "",
+                    bool autoload = false)
+{
+  return octave::load_fcn_from_file (file_name, dir_name, dispatch_type,
+                                     package_name, fcn_name, autoload);
+}
+
+OCTAVE_DEPRECATED ("use 'octave::source_file' instead")
+static inline void
+source_file (const std::string& file_name,
+             const std::string& context = "",
+             bool verbose = false, bool require_file = true,
+             const std::string& warn_for = "")
+{
+  octave::source_file (file_name, context, verbose, require_file, warn_for);
+}
+
+OCTAVE_DEPRECATED ("use 'octave::feval' instead")
+static inline octave_value_list
+feval (const std::string& name,
+       const octave_value_list& args = octave_value_list (),
+       int nargout = 0)
+{
+  return octave::feval (name, args, nargout);
+}
+
+OCTAVE_DEPRECATED ("use 'octave::feval' instead")
+static inline octave_value_list
+feval (octave_function *fcn,
+       const octave_value_list& args = octave_value_list (),
+       int nargout = 0)
+{
+  return octave::feval (fcn, args, nargout);
+}
+
+OCTAVE_DEPRECATED ("use 'octave::feval' instead")
+static inline octave_value_list
+feval (const octave_value_list& args, int nargout = 0)
+{
+  return octave::feval (args, nargout);
+}
+
+OCTAVE_DEPRECATED ("use 'octave::eval_string' instead")
+static inline octave_value_list
+eval_string (const std::string& str, bool silent, int& parse_status, int nargout)
+{
+  return octave::eval_string (str, silent, parse_status, nargout);
+}
+
+OCTAVE_DEPRECATED ("use 'octave::eval_string' instead")
+static inline octave_value
+eval_string (const std::string& str, bool silent, int& parse_status)
+{
+  return octave::eval_string (str, silent, parse_status);
+}
+
+OCTAVE_DEPRECATED ("use 'octave::cleanup_statement_list' instead")
+static inline void
+cleanup_statement_list (octave::tree_statement_list **lst)
+{
+  octave::cleanup_statement_list (lst);
 }
 
 #endif
 
+#endif
diff --git a/libinterp/parse-tree/pt-all.h b/libinterp/parse-tree/pt-all.h
--- a/libinterp/parse-tree/pt-all.h
+++ b/libinterp/parse-tree/pt-all.h
@@ -51,9 +51,8 @@ along with Octave; see the file COPYING.
 #include "pt-pr-code.h"
 #include "pt-select.h"
 #include "pt-stmt.h"
 #include "pt-unop.h"
 #include "pt-pr-code.h"
 #include "pt-walk.h"
 
 #endif
-
diff --git a/libinterp/parse-tree/pt-arg-list.cc b/libinterp/parse-tree/pt-arg-list.cc
--- a/libinterp/parse-tree/pt-arg-list.cc
+++ b/libinterp/parse-tree/pt-arg-list.cc
@@ -39,118 +39,121 @@ along with Octave; see the file COPYING.
 #include "pt-arg-list.h"
 #include "pt-exp.h"
 #include "pt-id.h"
 #include "pt-pr-code.h"
 #include "pt-walk.h"
 #include "interpreter.h"
 #include "unwind-prot.h"
 
-// Argument lists.
-
-tree_argument_list::~tree_argument_list (void)
-{
-  while (! empty ())
-    {
-      iterator p = begin ();
-      delete *p;
-      erase (p);
-    }
-}
-
-bool
-tree_argument_list::has_magic_end (void) const
+namespace octave
 {
-  for (const tree_expression* elt : *this)
-    {
-      if (elt && elt->has_magic_end ())
-        return true;
-    }
+  // Argument lists.
+
+  tree_argument_list::~tree_argument_list (void)
+  {
+    while (! empty ())
+      {
+        iterator p = begin ();
+        delete *p;
+        erase (p);
+      }
+  }
 
-  return false;
-}
+  bool
+  tree_argument_list::has_magic_end (void) const
+  {
+    for (const tree_expression* elt : *this)
+      {
+        if (elt && elt->has_magic_end ())
+          return true;
+      }
 
-void
-tree_argument_list::append (const element_type& s)
-{
-  octave::base_list<tree_expression *>::append (s);
+    return false;
+  }
 
-  if (! list_includes_magic_end && s && s->has_magic_end ())
-    list_includes_magic_end = true;
+  void
+  tree_argument_list::append (const element_type& s)
+  {
+    octave::base_list<tree_expression *>::append (s);
+
+    if (! list_includes_magic_end && s && s->has_magic_end ())
+      list_includes_magic_end = true;
 
-  if (! list_includes_magic_tilde && s && s->is_identifier ())
-    {
-      tree_identifier *id = dynamic_cast<tree_identifier *> (s);
-      list_includes_magic_tilde = id && id->is_black_hole ();
-    }
-}
+    if (! list_includes_magic_tilde && s && s->is_identifier ())
+      {
+        tree_identifier *id = dynamic_cast<tree_identifier *> (s);
+        list_includes_magic_tilde = id && id->is_black_hole ();
+      }
+  }
 
-bool
-tree_argument_list::all_elements_are_constant (void) const
-{
-  for (const tree_expression* elt : *this)
-    {
-      if (! elt->is_constant ())
-        return false;
-    }
+  bool
+  tree_argument_list::all_elements_are_constant (void) const
+  {
+    for (const tree_expression* elt : *this)
+      {
+        if (! elt->is_constant ())
+          return false;
+      }
 
-  return true;
-}
+    return true;
+  }
 
-bool
-tree_argument_list::is_valid_lvalue_list (void) const
-{
-  bool retval = true;
+  bool
+  tree_argument_list::is_valid_lvalue_list (void) const
+  {
+    bool retval = true;
 
-  for (const tree_expression* elt : *this)
-    {
-      // There is no need for a separate check for the magic "~" because it
-      // is represented by tree_black_hole, and that is derived from
-      // tree_identifier.
-      if (! (elt->is_identifier () || elt->is_index_expression ()))
-        {
-          retval = false;
-          break;
-        }
-    }
+    for (const tree_expression* elt : *this)
+      {
+        // There is no need for a separate check for the magic "~" because it
+        // is represented by tree_black_hole, and that is derived from
+        // tree_identifier.
+        if (! (elt->is_identifier () || elt->is_index_expression ()))
+          {
+            retval = false;
+            break;
+          }
+      }
 
-  return retval;
+    return retval;
+  }
 }
 
 static const octave_value *indexed_object = 0;
 static int index_position = 0;
 static int num_indices = 0;
 
 // END is documented in op-kw-docs.
 DEFCONSTFUN (end, , ,
              doc: /* -*- texinfo -*-
-@deftypefn {} {} end
-Last element of an array or the end of any @code{for}, @code{parfor},
-@code{if}, @code{do}, @code{while}, @code{function}, @code{switch},
-@code{try}, or @code{unwind_protect} block.
+                     @deftypefn {} {} end
+                     Last element of an array or the end of any @code{for}, @code{parfor},
+                     @code{if}, @code{do}, @code{while}, @code{function}, @code{switch},
+                     @code{try}, or @code{unwind_protect} block.
 
-As an index of an array, the magic index @qcode{"end"} refers to the
-last valid entry in an indexing operation.
+                     As an index of an array, the magic index @qcode{"end"} refers to the
+                     last valid entry in an indexing operation.
 
-Example:
+                     Example:
 
-@example
-@group
-@var{x} = [ 1 2 3
-      4 5 6 ];
-@var{x}(1,end)
-    @result{} 3
-@var{x}(end,1)
-    @result{} 4
-@var{x}(end,end)
-    @result{} 6
-@end group
-@end example
-@seealso{for, parfor, if, do, while, function, switch, try, unwind_protect}
-@end deftypefn */)
+                     @example
+                     @group
+                     @var{x} = [ 1 2 3
+                     4 5 6 ];
+                     @var{x}(1,end)
+                     @result{} 3
+                     @var{x}(end,1)
+                     @result{} 4
+                     @var{x}(end,end)
+                     @result{} 6
+                     @end group
+                     @end example
+                     @seealso{for, parfor, if, do, while, function, switch, try, unwind_protect}
+                     @end deftypefn */)
 {
   octave_value retval;
 
   if (! indexed_object)
     error ("invalid use of end");
 
   if (indexed_object->is_object ())
     {
@@ -160,17 +163,17 @@ Example:
       args(1) = index_position + 1;
       args(0) = *indexed_object;
 
       std::string class_name = indexed_object->class_name ();
 
       octave_value meth = symbol_table::find_method ("end", class_name);
 
       if (meth.is_defined ())
-        return feval (meth.function_value (), args, 1);
+        return octave::feval (meth.function_value (), args, 1);
     }
 
   dim_vector dv = indexed_object->dims ();
   int ndims = dv.ndims ();
 
   if (num_indices < ndims)
     {
       for (int i = num_indices; i < ndims; i++)
@@ -192,137 +195,139 @@ Example:
   if (index_position < ndims)
     retval = dv(index_position);
   else
     retval = 1;
 
   return retval;
 }
 
-octave_value_list
-tree_argument_list::convert_to_const_vector (const octave_value *object)
+namespace octave
 {
-  // END doesn't make sense for functions.  Maybe we need a different
-  // way of asking an octave_value object this question?
+  octave_value_list
+  tree_argument_list::convert_to_const_vector (const octave_value *object)
+  {
+    // END doesn't make sense for functions.  Maybe we need a different
+    // way of asking an octave_value object this question?
 
-  bool stash_object = (list_includes_magic_end
-                       && object
-                       && ! (object->is_function ()
-                             || object->is_function_handle ()));
-
-  octave::unwind_protect frame;
+    bool stash_object = (list_includes_magic_end
+                         && object
+                         && ! (object->is_function ()
+                               || object->is_function_handle ()));
 
-  if (stash_object)
-    {
-      frame.protect_var (indexed_object);
+    octave::unwind_protect frame;
 
-      indexed_object = object;
-    }
-
-  int len = length ();
+    if (stash_object)
+      {
+        frame.protect_var (indexed_object);
 
-  std::list<octave_value_list> args;
+        indexed_object = object;
+      }
 
-  iterator p = begin ();
-  for (int k = 0; k < len; k++)
-    {
-      if (stash_object)
-        {
-          frame.protect_var (index_position);
-          frame.protect_var (num_indices);
+    int len = length ();
+
+    std::list<octave_value_list> args;
 
-          index_position = k;
-          num_indices = len;
-        }
+    iterator p = begin ();
+    for (int k = 0; k < len; k++)
+      {
+        if (stash_object)
+          {
+            frame.protect_var (index_position);
+            frame.protect_var (num_indices);
 
-      tree_expression *elt = *p++;
+            index_position = k;
+            num_indices = len;
+          }
 
-      if (elt)
-        {
-          octave_value tmp = elt->rvalue1 ();
+        tree_expression *elt = *p++;
+
+        if (elt)
+          {
+            octave_value tmp = elt->rvalue1 ();
 
-          if (tmp.is_cs_list ())
-            args.push_back (tmp.list_value ());
-          else if (tmp.is_defined ())
-            args.push_back (tmp);
-        }
-      else
-        {
-          args.push_back (octave_value ());
-          break;
-        }
-    }
+            if (tmp.is_cs_list ())
+              args.push_back (tmp.list_value ());
+            else if (tmp.is_defined ())
+              args.push_back (tmp);
+          }
+        else
+          {
+            args.push_back (octave_value ());
+            break;
+          }
+      }
 
-  return args;
-}
+    return args;
+  }
 
-std::list<octave_lvalue>
-tree_argument_list::lvalue_list (void)
-{
-  std::list<octave_lvalue> retval;
-
-  for (tree_expression* elt : *this)
-    retval.push_back (elt->lvalue ());
+  std::list<octave_lvalue>
+  tree_argument_list::lvalue_list (void)
+  {
+    std::list<octave_lvalue> retval;
 
-  return retval;
-}
+    for (tree_expression* elt : *this)
+      retval.push_back (elt->lvalue ());
+
+    return retval;
+  }
 
-string_vector
-tree_argument_list::get_arg_names (void) const
-{
-  int len = length ();
+  string_vector
+  tree_argument_list::get_arg_names (void) const
+  {
+    int len = length ();
 
-  string_vector retval (len);
+    string_vector retval (len);
 
-  int k = 0;
+    int k = 0;
 
-  for (tree_expression* elt : *this)
-    retval(k++) = elt->str_print_code ();
+    for (tree_expression* elt : *this)
+      retval(k++) = elt->str_print_code ();
 
-  return retval;
-}
+    return retval;
+  }
 
-std::list<std::string>
-tree_argument_list::variable_names (void) const
-{
-  std::list<std::string> retval;
+  std::list<std::string>
+  tree_argument_list::variable_names (void) const
+  {
+    std::list<std::string> retval;
 
-  for (tree_expression* elt : *this)
-    {
-      if (elt->is_identifier ())
-        {
-          tree_identifier *id = dynamic_cast<tree_identifier *> (elt);
+    for (tree_expression* elt : *this)
+      {
+        if (elt->is_identifier ())
+          {
+            tree_identifier *id = dynamic_cast<tree_identifier *> (elt);
 
-          retval.push_back (id->name ());
-        }
-      else if (elt->is_index_expression ())
-        {
-          tree_index_expression *idx_expr
-            = dynamic_cast<tree_index_expression *> (elt);
+            retval.push_back (id->name ());
+          }
+        else if (elt->is_index_expression ())
+          {
+            tree_index_expression *idx_expr
+              = dynamic_cast<tree_index_expression *> (elt);
 
-          retval.push_back (idx_expr->name ());
-        }
-    }
+            retval.push_back (idx_expr->name ());
+          }
+      }
 
-  return retval;
-}
+    return retval;
+  }
 
-tree_argument_list *
-tree_argument_list::dup (symbol_table::scope_id scope,
-                         symbol_table::context_id context) const
-{
-  tree_argument_list *new_list = new tree_argument_list ();
+  tree_argument_list *
+  tree_argument_list::dup (symbol_table::scope_id scope,
+                           symbol_table::context_id context) const
+  {
+    tree_argument_list *new_list = new tree_argument_list ();
 
-  new_list->list_includes_magic_end = list_includes_magic_end;
-  new_list->simple_assign_lhs = simple_assign_lhs;
+    new_list->list_includes_magic_end = list_includes_magic_end;
+    new_list->simple_assign_lhs = simple_assign_lhs;
 
-  for (const tree_expression* elt : *this)
-    new_list->append (elt ? elt->dup (scope, context) : 0);
+    for (const tree_expression* elt : *this)
+      new_list->append (elt ? elt->dup (scope, context) : 0);
 
-  return new_list;
-}
+    return new_list;
+  }
 
-void
-tree_argument_list::accept (tree_walker& tw)
-{
-  tw.visit_argument_list (*this);
+  void
+  tree_argument_list::accept (tree_walker& tw)
+  {
+    tw.visit_argument_list (*this);
+  }
 }
-
diff --git a/libinterp/parse-tree/pt-arg-list.h b/libinterp/parse-tree/pt-arg-list.h
--- a/libinterp/parse-tree/pt-arg-list.h
+++ b/libinterp/parse-tree/pt-arg-list.h
@@ -24,90 +24,99 @@ along with Octave; see the file COPYING.
 #define octave_pt_arg_list_h 1
 
 #include "octave-config.h"
 
 #include <list>
 
 class octave_value_list;
 class octave_lvalue;
-class tree_expression;
-class tree_walker;
 
 #include "str-vec.h"
 
 #include "base-list.h"
 #include "symtab.h"
 
-// Argument lists.  Used to hold the list of expressions that are the
-// arguments in a function call or index expression.
-
-class
-tree_argument_list : public octave::base_list<tree_expression *>
+namespace octave
 {
-public:
-
-  typedef tree_expression* element_type;
-
-  tree_argument_list (void)
-    : list_includes_magic_end (false), list_includes_magic_tilde (false),
-      simple_assign_lhs (false) { }
+  class tree_expression;
 
-  tree_argument_list (tree_expression *t)
-    : list_includes_magic_end (false), list_includes_magic_tilde (false),
-      simple_assign_lhs (false)
-  { append (t); }
-
-  // No copying!
-
-  tree_argument_list (const tree_argument_list&) = delete;
+  class tree_walker;
 
-  tree_argument_list& operator = (const tree_argument_list&) = delete;
-
-  ~tree_argument_list (void);
+  // Argument lists.  Used to hold the list of expressions that are the
+  // arguments in a function call or index expression.
 
-  bool has_magic_end (void) const;
-
-  bool has_magic_tilde (void) const
-  { return list_includes_magic_tilde; }
-
-  tree_expression *remove_front (void)
+  class tree_argument_list : public octave::base_list<tree_expression *>
   {
-    iterator p = begin ();
-    tree_expression *retval = *p;
-    erase (p);
-    return retval;
-  }
+  public:
+
+    typedef tree_expression* element_type;
+
+    tree_argument_list (void)
+      : list_includes_magic_end (false), list_includes_magic_tilde (false),
+        simple_assign_lhs (false) { }
 
-  void append (const element_type& s);
+    tree_argument_list (tree_expression *t)
+      : list_includes_magic_end (false), list_includes_magic_tilde (false),
+        simple_assign_lhs (false)
+    { append (t); }
+
+    // No copying!
+
+    tree_argument_list (const tree_argument_list&) = delete;
 
-  void mark_as_simple_assign_lhs (void) { simple_assign_lhs = true; }
+    tree_argument_list& operator = (const tree_argument_list&) = delete;
 
-  bool is_simple_assign_lhs (void) { return simple_assign_lhs; }
+    ~tree_argument_list (void);
+
+    bool has_magic_end (void) const;
 
-  bool all_elements_are_constant (void) const;
+    bool has_magic_tilde (void) const
+    { return list_includes_magic_tilde; }
 
-  bool is_valid_lvalue_list (void) const;
-
-  octave_value_list convert_to_const_vector (const octave_value *object = 0);
+    tree_expression *remove_front (void)
+    {
+      iterator p = begin ();
+      tree_expression *retval = *p;
+      erase (p);
+      return retval;
+    }
 
-  std::list<octave_lvalue> lvalue_list (void);
+    void append (const element_type& s);
+
+    void mark_as_simple_assign_lhs (void) { simple_assign_lhs = true; }
 
-  string_vector get_arg_names (void) const;
+    bool is_simple_assign_lhs (void) { return simple_assign_lhs; }
+
+    bool all_elements_are_constant (void) const;
 
-  std::list<std::string> variable_names (void) const;
+    bool is_valid_lvalue_list (void) const;
+
+    octave_value_list convert_to_const_vector (const octave_value *object = 0);
 
-  tree_argument_list *dup (symbol_table::scope_id scope,
-                           symbol_table::context_id context) const;
+    std::list<octave_lvalue> lvalue_list (void);
+
+    string_vector get_arg_names (void) const;
+
+    std::list<std::string> variable_names (void) const;
 
-  void accept (tree_walker& tw);
+    tree_argument_list *dup (symbol_table::scope_id scope,
+                             symbol_table::context_id context) const;
 
-private:
+    void accept (tree_walker& tw);
+
+  private:
+
+    bool list_includes_magic_end;
 
-  bool list_includes_magic_end;
+    bool list_includes_magic_tilde;
 
-  bool list_includes_magic_tilde;
+    bool simple_assign_lhs;
+  };
+}
 
-  bool simple_assign_lhs;
-};
+#if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
+
+// tree_argument_list is derived from a template.
 
 #endif
 
+#endif
diff --git a/libinterp/parse-tree/pt-array-list.cc b/libinterp/parse-tree/pt-array-list.cc
--- a/libinterp/parse-tree/pt-array-list.cc
+++ b/libinterp/parse-tree/pt-array-list.cc
@@ -24,77 +24,79 @@ along with Octave; see the file COPYING.
 #  include "config.h"
 #endif
 
 #include <iostream>
 
 #include "error.h"
 #include "pt-array-list.h"
 
-tree_array_list::~tree_array_list (void)
+namespace octave
 {
-  while (! empty ())
-    {
-      iterator p = begin ();
-      delete *p;
-      erase (p);
-    }
-}
-
-bool
-tree_array_list::all_elements_are_constant (void) const
-{
-  for (const tree_argument_list* elt : *this)
-    {
-      octave_quit ();
+  tree_array_list::~tree_array_list (void)
+  {
+    while (! empty ())
+      {
+        iterator p = begin ();
+        delete *p;
+        erase (p);
+      }
+  }
 
-      if (! elt->all_elements_are_constant ())
-        return false;
-    }
-
-  return true;
-}
+  bool
+  tree_array_list::all_elements_are_constant (void) const
+  {
+    for (const tree_argument_list* elt : *this)
+      {
+        octave_quit ();
 
-bool
-tree_array_list::has_magic_end (void) const
-{
-  for (const tree_argument_list* elt : *this)
-    {
-      octave_quit ();
+        if (! elt->all_elements_are_constant ())
+          return false;
+      }
+
+    return true;
+  }
 
-      if (elt && elt->has_magic_end ())
-        return true;
-    }
+  bool
+  tree_array_list::has_magic_end (void) const
+  {
+    for (const tree_argument_list* elt : *this)
+      {
+        octave_quit ();
 
-  return false;
-}
+        if (elt && elt->has_magic_end ())
+          return true;
+      }
 
-void
-tree_array_list::copy_base (const tree_array_list& array_list)
-{
-  tree_expression::copy_base (array_list);
-}
+    return false;
+  }
 
-void
-tree_array_list::copy_base (const tree_array_list& array_list,
-                            symbol_table::scope_id scope,
-                            symbol_table::context_id context)
-{
-  for (const tree_argument_list* elt : array_list)
-    append (elt ? elt->dup (scope, context) : 0);
+  void
+  tree_array_list::copy_base (const tree_array_list& array_list)
+  {
+    tree_expression::copy_base (array_list);
+  }
 
-  copy_base (*this);
-}
+  void
+  tree_array_list::copy_base (const tree_array_list& array_list,
+                              symbol_table::scope_id scope,
+                              symbol_table::context_id context)
+  {
+    for (const tree_argument_list* elt : array_list)
+      append (elt ? elt->dup (scope, context) : 0);
+
+    copy_base (*this);
+  }
 
-tree_expression *
-tree_array_list::dup (symbol_table::scope_id,
-                      symbol_table::context_id) const
-{
-  panic_impossible ();
-  return 0;
+  tree_expression *
+  tree_array_list::dup (symbol_table::scope_id,
+                        symbol_table::context_id) const
+  {
+    panic_impossible ();
+    return 0;
+  }
+
+  void
+  tree_array_list::accept (tree_walker&)
+  {
+    panic_impossible ();
+  }
 }
-
-void
-tree_array_list::accept (tree_walker&)
-{
-  panic_impossible ();
-}
-
diff --git a/libinterp/parse-tree/pt-array-list.h b/libinterp/parse-tree/pt-array-list.h
--- a/libinterp/parse-tree/pt-array-list.h
+++ b/libinterp/parse-tree/pt-array-list.h
@@ -25,59 +25,67 @@ along with Octave; see the file COPYING.
 
 #include "octave-config.h"
 
 #include "base-list.h"
 #include "pt-arg-list.h"
 #include "pt-exp.h"
 #include "symtab.h"
 
-// Base class for cell arrays and matrices.
+namespace octave
+{
+  // Base class for cell arrays and matrices.
 
-class
-tree_array_list : public tree_expression,
-                  public octave::base_list<tree_argument_list *>
-{
-public:
+  class tree_array_list : public tree_expression,
+                          public octave::base_list<tree_argument_list *>
+  {
+  public:
 
-  typedef octave::base_list<tree_argument_list *>::iterator iterator;
-  typedef octave::base_list<tree_argument_list *>::const_iterator const_iterator;
+    typedef octave::base_list<tree_argument_list *>::iterator iterator;
+    typedef octave::base_list<tree_argument_list *>::const_iterator const_iterator;
 
-  tree_array_list (tree_argument_list *row = 0, int l = -1, int c = -1)
-    : tree_expression (l, c), octave::base_list<tree_argument_list *> ()
-  {
-    if (row)
-      append (row);
-  }
+    tree_array_list (tree_argument_list *row = 0, int l = -1, int c = -1)
+      : tree_expression (l, c), octave::base_list<tree_argument_list *> ()
+    {
+      if (row)
+        append (row);
+    }
 
-  // No copying!
+    // No copying!
+
+    tree_array_list (const tree_array_list&) = delete;
 
-  tree_array_list (const tree_array_list&) = delete;
+    tree_array_list& operator = (const tree_array_list&) = delete;
 
-  tree_array_list& operator = (const tree_array_list&) = delete;
+    ~tree_array_list (void);
 
-  ~tree_array_list (void);
+    bool all_elements_are_constant (void) const;
+
+    bool has_magic_end (void) const;
 
-  bool all_elements_are_constant (void) const;
+    // FIXME: should we import the functions from the base class and
+    // overload them here, or should we use a different name so we don't
+    // have to do this?  Without the using declaration or a name change,
+    // the base class functions will be hidden.  That may be OK, but it
+    // can also cause some confusion.
+    using tree_expression::copy_base;
 
-  bool has_magic_end (void) const;
+    void copy_base (const tree_array_list& array_list);
 
-  // FIXME: should we import the functions from the base class and
-  // overload them here, or should we use a different name so we don't
-  // have to do this?  Without the using declaration or a name change,
-  // the base class functions will be hidden.  That may be OK, but it
-  // can also cause some confusion.
-  using tree_expression::copy_base;
+    void copy_base (const tree_array_list& array_list,
+                    symbol_table::scope_id scope,
+                    symbol_table::context_id context);
 
-  void copy_base (const tree_array_list& array_list);
+    tree_expression *dup (symbol_table::scope_id scope,
+                          symbol_table::context_id context) const;
 
-  void copy_base (const tree_array_list& array_list,
-                  symbol_table::scope_id scope,
-                  symbol_table::context_id context);
+    void accept (tree_walker& tw);
+  };
+}
 
-  tree_expression *dup (symbol_table::scope_id scope,
-                        symbol_table::context_id context) const;
+#if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
 
-  void accept (tree_walker& tw);
-};
+OCTAVE_DEPRECATED ("use 'octave::tree_array_list' instead")
+typedef octave::tree_array_list tree_array_list;
 
 #endif
 
+#endif
diff --git a/libinterp/parse-tree/pt-assign.cc b/libinterp/parse-tree/pt-assign.cc
--- a/libinterp/parse-tree/pt-assign.cc
+++ b/libinterp/parse-tree/pt-assign.cc
@@ -39,348 +39,350 @@ along with Octave; see the file COPYING.
 #include "pt-arg-list.h"
 #include "pt-bp.h"
 #include "pt-assign.h"
 #include "pt-eval.h"
 #include "pt-walk.h"
 #include "utils.h"
 #include "variables.h"
 
-// Simple assignment expressions.
+namespace octave
+{
+  // Simple assignment expressions.
 
-tree_simple_assignment::tree_simple_assignment
+  tree_simple_assignment::tree_simple_assignment
   (tree_expression *le, tree_expression *re,
    bool plhs, int l, int c, octave_value::assign_op t)
- : tree_expression (l, c), lhs (le), rhs (re), preserve (plhs), etype (t)
-{ }
+    : tree_expression (l, c), lhs (le), rhs (re), preserve (plhs), etype (t)
+  { }
 
-tree_simple_assignment::~tree_simple_assignment (void)
-{
-  if (! preserve)
-    delete lhs;
+  tree_simple_assignment::~tree_simple_assignment (void)
+  {
+    if (! preserve)
+      delete lhs;
 
-  delete rhs;
-}
+    delete rhs;
+  }
 
-octave_value_list
-tree_simple_assignment::rvalue (int nargout)
-{
-  if (nargout > 1)
-    error ("invalid number of output arguments for expression X = RHS");
+  octave_value_list
+  tree_simple_assignment::rvalue (int nargout)
+  {
+    if (nargout > 1)
+      error ("invalid number of output arguments for expression X = RHS");
 
-  return rvalue1 (nargout);
-}
+    return rvalue1 (nargout);
+  }
 
-octave_value
-tree_simple_assignment::rvalue1 (int)
-{
-  octave_value retval;
+  octave_value
+  tree_simple_assignment::rvalue1 (int)
+  {
+    octave_value retval;
 
-  if (rhs)
-    {
-      octave_value rhs_val = rhs->rvalue1 ();
+    if (rhs)
+      {
+        octave_value rhs_val = rhs->rvalue1 ();
 
-      if (rhs_val.is_undefined ())
-        error ("value on right hand side of assignment is undefined");
+        if (rhs_val.is_undefined ())
+          error ("value on right hand side of assignment is undefined");
 
-      if (rhs_val.is_cs_list ())
-        {
-          const octave_value_list lst = rhs_val.list_value ();
+        if (rhs_val.is_cs_list ())
+          {
+            const octave_value_list lst = rhs_val.list_value ();
 
-          if (lst.empty ())
-            error ("invalid number of elements on RHS of assignment");
+            if (lst.empty ())
+              error ("invalid number of elements on RHS of assignment");
 
-          rhs_val = lst(0);
-        }
+            rhs_val = lst(0);
+          }
 
-      try
-        {
-          octave_lvalue ult = lhs->lvalue ();
+        try
+          {
+            octave_lvalue ult = lhs->lvalue ();
 
-          if (ult.numel () != 1)
-            err_nonbraced_cs_list_assignment ();
+            if (ult.numel () != 1)
+              err_nonbraced_cs_list_assignment ();
 
-          ult.assign (etype, rhs_val);
+            ult.assign (etype, rhs_val);
 
-          if (etype == octave_value::op_asn_eq)
-            retval = rhs_val;
-          else
-            retval = ult.value ();
+            if (etype == octave_value::op_asn_eq)
+              retval = rhs_val;
+            else
+              retval = ult.value ();
 
-          if (print_result ()
-              && octave::tree_evaluator::statement_printing_enabled ())
-            {
-              // We clear any index here so that we can
-              // get the new value of the referenced
-              // object below, instead of the indexed
-              // value (which should be the same as the
-              // right hand side value).
+            if (print_result ()
+                && octave::tree_evaluator::statement_printing_enabled ())
+              {
+                // We clear any index here so that we can
+                // get the new value of the referenced
+                // object below, instead of the indexed
+                // value (which should be the same as the
+                // right hand side value).
 
-              ult.clear_index ();
+                ult.clear_index ();
 
-              octave_value lhs_val = ult.value ();
+                octave_value lhs_val = ult.value ();
 
-              octave_value_list args = ovl (lhs_val, lhs->name ());
-              string_vector name_tags (2);
-              name_tags(0) = lhs->name ();
-              name_tags(1) = "name";
-              args.stash_name_tags (name_tags);
-              feval ("display", args);
-            }
-        }
-      catch (octave::index_exception& e)
-        {
-          e.set_var (lhs->name ());
-          std::string msg = e.message ();
-          error_with_id (e.err_id (), msg.c_str ());
-        }
-    }
+                octave_value_list args = ovl (lhs_val, lhs->name ());
+                string_vector name_tags (2);
+                name_tags(0) = lhs->name ();
+                name_tags(1) = "name";
+                args.stash_name_tags (name_tags);
+                octave::feval ("display", args);
+              }
+          }
+        catch (octave::index_exception& e)
+          {
+            e.set_var (lhs->name ());
+            std::string msg = e.message ();
+            error_with_id (e.err_id (), msg.c_str ());
+          }
+      }
 
-  return retval;
-}
+    return retval;
+  }
 
-std::string
-tree_simple_assignment::oper (void) const
-{
-  return octave_value::assign_op_as_string (etype);
-}
+  std::string
+  tree_simple_assignment::oper (void) const
+  {
+    return octave_value::assign_op_as_string (etype);
+  }
 
-tree_expression *
-tree_simple_assignment::dup (symbol_table::scope_id scope,
-                             symbol_table::context_id context) const
-{
-  tree_simple_assignment *new_sa
-    = new tree_simple_assignment (lhs ? lhs->dup (scope, context) : 0,
-                                  rhs ? rhs->dup (scope, context) : 0,
-                                  preserve, etype);
+  tree_expression *
+  tree_simple_assignment::dup (symbol_table::scope_id scope,
+                               symbol_table::context_id context) const
+  {
+    tree_simple_assignment *new_sa
+      = new tree_simple_assignment (lhs ? lhs->dup (scope, context) : 0,
+                                    rhs ? rhs->dup (scope, context) : 0,
+                                    preserve, etype);
 
-  new_sa->copy_base (*this);
+    new_sa->copy_base (*this);
 
-  return new_sa;
-}
+    return new_sa;
+  }
 
-void
-tree_simple_assignment::accept (tree_walker& tw)
-{
-  tw.visit_simple_assignment (*this);
-}
+  void
+  tree_simple_assignment::accept (tree_walker& tw)
+  {
+    tw.visit_simple_assignment (*this);
+  }
 
-// Multi-valued assignment expressions.
+  // Multi-valued assignment expressions.
 
-tree_multi_assignment::tree_multi_assignment
+  tree_multi_assignment::tree_multi_assignment
   (tree_argument_list *lst, tree_expression *r,
    bool plhs, int l, int c)
-  : tree_expression (l, c), lhs (lst), rhs (r), preserve (plhs)
-{ }
+    : tree_expression (l, c), lhs (lst), rhs (r), preserve (plhs)
+  { }
 
-tree_multi_assignment::~tree_multi_assignment (void)
-{
-  if (! preserve)
-    delete lhs;
+  tree_multi_assignment::~tree_multi_assignment (void)
+  {
+    if (! preserve)
+      delete lhs;
+
+    delete rhs;
+  }
 
-  delete rhs;
-}
+  octave_value
+  tree_multi_assignment::rvalue1 (int nargout)
+  {
+    octave_value retval;
 
-octave_value
-tree_multi_assignment::rvalue1 (int nargout)
-{
-  octave_value retval;
+    const octave_value_list tmp = rvalue (nargout);
 
-  const octave_value_list tmp = rvalue (nargout);
+    if (! tmp.empty ())
+      retval = tmp(0);
+
+    return retval;
+  }
 
-  if (! tmp.empty ())
-    retval = tmp(0);
+  // FIXME: this works, but it would look a little better if
+  // it were broken up into a couple of separate functions.
 
-  return retval;
-}
+  octave_value_list
+  tree_multi_assignment::rvalue (int)
+  {
+    octave_value_list retval;
 
-// FIXME: this works, but it would look a little better if
-// it were broken up into a couple of separate functions.
+    if (rhs)
+      {
+        std::list<octave_lvalue> lvalue_list = lhs->lvalue_list ();
 
-octave_value_list
-tree_multi_assignment::rvalue (int)
-{
-  octave_value_list retval;
+        octave_idx_type n_out = 0;
+
+        for (const auto& lval : lvalue_list)
+          n_out += lval.numel ();
 
-  if (rhs)
-    {
-      std::list<octave_lvalue> lvalue_list = lhs->lvalue_list ();
-
-      octave_idx_type n_out = 0;
-
-      for (const auto& lval : lvalue_list)
-        n_out += lval.numel ();
+        // The following trick is used to keep rhs_val constant.
+        const octave_value_list rhs_val1 = rhs->rvalue (n_out, &lvalue_list);
+        const octave_value_list rhs_val = (rhs_val1.length () == 1
+                                           && rhs_val1(0).is_cs_list ()
+                                           ? rhs_val1(0).list_value ()
+                                           : rhs_val1);
 
-      // The following trick is used to keep rhs_val constant.
-      const octave_value_list rhs_val1 = rhs->rvalue (n_out, &lvalue_list);
-      const octave_value_list rhs_val = (rhs_val1.length () == 1
-                                         && rhs_val1(0).is_cs_list ()
-                                         ? rhs_val1(0).list_value ()
-                                         : rhs_val1);
+        octave_idx_type k = 0;
+
+        octave_idx_type n = rhs_val.length ();
 
-      octave_idx_type k = 0;
-
-      octave_idx_type n = rhs_val.length ();
+        // To avoid copying per elements and possible optimizations, we
+        // postpone joining the final values.
+        std::list<octave_value_list> retval_list;
 
-      // To avoid copying per elements and possible optimizations, we
-      // postpone joining the final values.
-      std::list<octave_value_list> retval_list;
-
-      tree_argument_list::iterator q = lhs->begin ();
+        tree_argument_list::iterator q = lhs->begin ();
 
-      for (octave_lvalue ult : lvalue_list)
-        {
-          tree_expression *lhs_elt = *q++;
+        for (octave_lvalue ult : lvalue_list)
+          {
+            tree_expression *lhs_elt = *q++;
 
-          octave_idx_type nel = ult.numel ();
+            octave_idx_type nel = ult.numel ();
 
-          if (nel != 1)
-            {
-              // Huge kluge so that wrapper scripts with lines like
-              //
-              //   [varargout{1:nargout}] = fcn (args);
-              //
-              // Will work the same as calling fcn directly when nargout
-              // is 0 and fcn produces more than one output even when
-              // nargout is 0.  This only works if varargout has not yet
-              // been defined.  See also bug #43813.
+            if (nel != 1)
+              {
+                // Huge kluge so that wrapper scripts with lines like
+                //
+                //   [varargout{1:nargout}] = fcn (args);
+                //
+                // Will work the same as calling fcn directly when nargout
+                // is 0 and fcn produces more than one output even when
+                // nargout is 0.  This only works if varargout has not yet
+                // been defined.  See also bug #43813.
 
-              if (lvalue_list.size () == 1 && nel == 0 && n > 0
-                  && ! ult.is_black_hole () && ult.is_undefined ()
-                  && ult.index_type () == "{" && ult.index_is_empty ())
-                {
-                  // Convert undefined lvalue with empty index to a cell
-                  // array with a single value and indexed by 1 to
-                  // handle a single output.
+                if (lvalue_list.size () == 1 && nel == 0 && n > 0
+                    && ! ult.is_black_hole () && ult.is_undefined ()
+                    && ult.index_type () == "{" && ult.index_is_empty ())
+                  {
+                    // Convert undefined lvalue with empty index to a cell
+                    // array with a single value and indexed by 1 to
+                    // handle a single output.
+
+                    nel = 1;
+
+                    ult.define (Cell (1, 1));
 
-                  nel = 1;
+                    ult.clear_index ();
+                    std::list<octave_value_list> idx;
+                    idx.push_back (octave_value_list (octave_value (1)));
+                    ult.set_index ("{", idx);
+                  }
 
-                  ult.define (Cell (1, 1));
+                if (k + nel > n)
+                  error ("some elements undefined in return list");
+
+                // This won't do a copy.
+                octave_value_list ovl = rhs_val.slice (k, nel);
 
-                  ult.clear_index ();
-                  std::list<octave_value_list> idx;
-                  idx.push_back (octave_value_list (octave_value (1)));
-                  ult.set_index ("{", idx);
-                }
+                ult.assign (octave_value::op_asn_eq,
+                            octave_value (ovl, true));
+
+                retval_list.push_back (ovl);
 
-              if (k + nel > n)
-                error ("some elements undefined in return list");
+                k += nel;
+              }
+            else
+              {
+                if (k < n)
+                  {
+                    ult.assign (octave_value::op_asn_eq, rhs_val(k));
 
-              // This won't do a copy.
-              octave_value_list ovl = rhs_val.slice (k, nel);
-
-              ult.assign (octave_value::op_asn_eq,
-                          octave_value (ovl, true));
-
-              retval_list.push_back (ovl);
+                    if (ult.is_black_hole ())
+                      {
+                        k++;
+                        continue;
+                      }
+                    else
+                      {
+                        retval_list.push_back (rhs_val(k));
 
-              k += nel;
-            }
-          else
-            {
-              if (k < n)
-                {
-                  ult.assign (octave_value::op_asn_eq, rhs_val(k));
+                        k++;
+                      }
+                  }
+                else
+                  {
+                    // This can happen for a function like
+                    //
+                    //   function varargout = f ()
+                    //     varargout{1} = nargout;
+                    //   endfunction
+                    //
+                    // called with
+                    //
+                    //    [a, ~] = f ();
+                    //
+                    // Then the list of of RHS values will contain one
+                    // element but we are iterating over the list of all
+                    // RHS values.  We shouldn't complain that a value we
+                    // don't need is missing from the list.
 
-                  if (ult.is_black_hole ())
-                    {
-                      k++;
-                      continue;
-                    }
-                  else
-                    {
-                      retval_list.push_back (rhs_val(k));
+                    if (! ult.is_black_hole ())
+                      error ("element number %d undefined in return list", k+1);
+
+                    k++;
+                    continue;
+                  }
+              }
 
-                      k++;
-                    }
-                }
-              else
-                {
-                  // This can happen for a function like
-                  //
-                  //   function varargout = f ()
-                  //     varargout{1} = nargout;
-                  //   endfunction
-                  //
-                  // called with
-                  //
-                  //    [a, ~] = f ();
-                  //
-                  // Then the list of of RHS values will contain one
-                  // element but we are iterating over the list of all
-                  // RHS values.  We shouldn't complain that a value we
-                  // don't need is missing from the list.
+            if (print_result ()
+                && octave::tree_evaluator::statement_printing_enabled ())
+              {
+                // We clear any index here so that we can get
+                // the new value of the referenced object below,
+                // instead of the indexed value (which should be
+                // the same as the right hand side value).
+
+                ult.clear_index ();
+
+                octave_value lhs_val = ult.value ();
 
-                  if (! ult.is_black_hole ())
-                    error ("element number %d undefined in return list", k+1);
+                octave_value_list args = ovl (lhs_val, lhs_elt->name ());
+                string_vector name_tags (2);
+                name_tags(0) = lhs_elt->name ();
+                name_tags(1) = "name";
+                args.stash_name_tags (name_tags);
+                octave::feval ("display", args);
+              }
+          }
+
+        // Concatenate return values.
+        retval = retval_list;
+      }
 
-                  k++;
-                  continue;
-                }
-            }
+    return retval;
+  }
 
-          if (print_result ()
-              && octave::tree_evaluator::statement_printing_enabled ())
-            {
-              // We clear any index here so that we can get
-              // the new value of the referenced object below,
-              // instead of the indexed value (which should be
-              // the same as the right hand side value).
-
-              ult.clear_index ();
+  std::string
+  tree_multi_assignment::oper (void) const
+  {
+    return octave_value::assign_op_as_string (op_type ());
+  }
 
-              octave_value lhs_val = ult.value ();
+  tree_expression *
+  tree_multi_assignment::dup (symbol_table::scope_id scope,
+                              symbol_table::context_id context) const
+  {
+    tree_multi_assignment *new_ma
+      = new tree_multi_assignment (lhs ? lhs->dup (scope, context) : 0,
+                                   rhs ? rhs->dup (scope, context) : 0,
+                                   preserve);
 
-              octave_value_list args = ovl (lhs_val, lhs_elt->name ());
-              string_vector name_tags (2);
-              name_tags(0) = lhs_elt->name ();
-              name_tags(1) = "name";
-              args.stash_name_tags (name_tags);
-              feval ("display", args);
-            }
-        }
+    new_ma->copy_base (*this);
+
+    return new_ma;
+  }
 
-      // Concatenate return values.
-      retval = retval_list;
-    }
-
-  return retval;
+  void
+  tree_multi_assignment::accept (tree_walker& tw)
+  {
+    tw.visit_multi_assignment (*this);
+  }
 }
 
 /*
 %!function varargout = f ()
 %!  varargout{1} = nargout;
 %!endfunction
 %!
 %!test
 %! [a, ~] = f ();
 %! assert (a, 2);
 %!test
 %! [a, ~, ~, ~, ~] = f ();
 %! assert (a, 5);
 */
-
-std::string
-tree_multi_assignment::oper (void) const
-{
-  return octave_value::assign_op_as_string (op_type ());
-}
-
-tree_expression *
-tree_multi_assignment::dup (symbol_table::scope_id scope,
-                            symbol_table::context_id context) const
-{
-  tree_multi_assignment *new_ma
-    = new tree_multi_assignment (lhs ? lhs->dup (scope, context) : 0,
-                                 rhs ? rhs->dup (scope, context) : 0,
-                                 preserve);
-
-  new_ma->copy_base (*this);
-
-  return new_ma;
-}
-
-void
-tree_multi_assignment::accept (tree_walker& tw)
-{
-  tw.visit_multi_assignment (*this);
-}
-
diff --git a/libinterp/parse-tree/pt-assign.h b/libinterp/parse-tree/pt-assign.h
--- a/libinterp/parse-tree/pt-assign.h
+++ b/libinterp/parse-tree/pt-assign.h
@@ -23,148 +23,159 @@ along with Octave; see the file COPYING.
 #if ! defined (octave_pt_assign_h)
 #define octave_pt_assign_h 1
 
 #include "octave-config.h"
 
 #include <iosfwd>
 #include <string>
 
-class tree_argument_list;
-class tree_walker;
-
 class octave_value;
 class octave_value_list;
 class octave_lvalue;
 
 #include "ov.h"
 #include "pt-exp.h"
 #include "symtab.h"
 
-// Simple assignment expressions.
-
-class
-tree_simple_assignment : public tree_expression
+namespace octave
 {
-public:
+  class tree_argument_list;
+
+  class tree_walker;
 
-  tree_simple_assignment (bool plhs = false, int l = -1, int c = -1,
-                          octave_value::assign_op t = octave_value::op_asn_eq)
-    : tree_expression (l, c), lhs (0), rhs (0), preserve (plhs), ans_ass (),
-      etype (t) { }
+  // Simple assignment expressions.
+
+  class tree_simple_assignment : public tree_expression
+  {
+  public:
 
-  tree_simple_assignment (tree_expression *le, tree_expression *re,
-                          bool plhs = false, int l = -1, int c = -1,
-                          octave_value::assign_op t = octave_value::op_asn_eq);
+    tree_simple_assignment (bool plhs = false, int l = -1, int c = -1,
+                            octave_value::assign_op t = octave_value::op_asn_eq)
+      : tree_expression (l, c), lhs (0), rhs (0), preserve (plhs), ans_ass (),
+        etype (t) { }
 
-  // No copying!
-
-  tree_simple_assignment (const tree_simple_assignment&) = delete;
+    tree_simple_assignment (tree_expression *le, tree_expression *re,
+                            bool plhs = false, int l = -1, int c = -1,
+                            octave_value::assign_op t = octave_value::op_asn_eq);
 
-  tree_simple_assignment& operator = (const tree_simple_assignment&) = delete;
+    // No copying!
 
-  ~tree_simple_assignment (void);
+    tree_simple_assignment (const tree_simple_assignment&) = delete;
+
+    tree_simple_assignment& operator = (const tree_simple_assignment&) = delete;
 
-  bool has_magic_end (void) const { return (rhs && rhs->has_magic_end ()); }
+    ~tree_simple_assignment (void);
 
-  bool rvalue_ok (void) const { return true; }
+    bool has_magic_end (void) const { return (rhs && rhs->has_magic_end ()); }
 
-  octave_value rvalue1 (int nargout = 1);
+    bool rvalue_ok (void) const { return true; }
 
-  octave_value_list rvalue (int nargout);
+    octave_value rvalue1 (int nargout = 1);
+
+    octave_value_list rvalue (int nargout);
 
-  bool is_assignment_expression (void) const { return true; }
+    bool is_assignment_expression (void) const { return true; }
 
-  std::string oper (void) const;
+    std::string oper (void) const;
 
-  tree_expression *left_hand_side (void) { return lhs; }
+    tree_expression *left_hand_side (void) { return lhs; }
 
-  tree_expression *right_hand_side (void) { return rhs; }
+    tree_expression *right_hand_side (void) { return rhs; }
 
-  tree_expression *dup (symbol_table::scope_id scope,
-                        symbol_table::context_id context) const;
+    tree_expression *dup (symbol_table::scope_id scope,
+                          symbol_table::context_id context) const;
 
-  void accept (tree_walker& tw);
+    void accept (tree_walker& tw);
 
-  octave_value::assign_op op_type (void) const { return etype; }
+    octave_value::assign_op op_type (void) const { return etype; }
 
-private:
+  private:
 
-  void do_assign (octave_lvalue& ult, const octave_value_list& args,
-                  const octave_value& rhs_val);
+    void do_assign (octave_lvalue& ult, const octave_value_list& args,
+                    const octave_value& rhs_val);
 
-  void do_assign (octave_lvalue& ult, const octave_value& rhs_val);
+    void do_assign (octave_lvalue& ult, const octave_value& rhs_val);
 
-  // The left hand side of the assignment.
-  tree_expression *lhs;
+    // The left hand side of the assignment.
+    tree_expression *lhs;
 
-  // The right hand side of the assignment.
-  tree_expression *rhs;
+    // The right hand side of the assignment.
+    tree_expression *rhs;
 
-  // True if we should not delete the lhs.
-  bool preserve;
+    // True if we should not delete the lhs.
+    bool preserve;
 
-  // True if this is an assignment to the automatic variable ans.
-  bool ans_ass;
+    // True if this is an assignment to the automatic variable ans.
+    bool ans_ass;
 
-  // The type of the expression.
-  octave_value::assign_op etype;
-};
+    // The type of the expression.
+    octave_value::assign_op etype;
+  };
 
-// Multi-valued assignment expressions.
+  // Multi-valued assignment expressions.
 
-class
-tree_multi_assignment : public tree_expression
-{
-public:
+  class tree_multi_assignment : public tree_expression
+  {
+  public:
+
+    tree_multi_assignment (bool plhs = false, int l = -1, int c = -1)
+      : tree_expression (l, c), lhs (0), rhs (0), preserve (plhs) { }
 
-  tree_multi_assignment (bool plhs = false, int l = -1, int c = -1)
-    : tree_expression (l, c), lhs (0), rhs (0), preserve (plhs) { }
+    tree_multi_assignment (tree_argument_list *lst, tree_expression *r,
+                           bool plhs = false, int l = -1, int c = -1);
 
-  tree_multi_assignment (tree_argument_list *lst, tree_expression *r,
-                         bool plhs = false, int l = -1, int c = -1);
+    // No copying!
 
-  // No copying!
+    tree_multi_assignment (const tree_multi_assignment&) = delete;
+
+    tree_multi_assignment& operator = (const tree_multi_assignment&) = delete;
 
-  tree_multi_assignment (const tree_multi_assignment&) = delete;
+    ~tree_multi_assignment (void);
 
-  tree_multi_assignment& operator = (const tree_multi_assignment&) = delete;
+    bool has_magic_end (void) const { return (rhs && rhs->has_magic_end ()); }
 
-  ~tree_multi_assignment (void);
+    bool is_assignment_expression (void) const { return true; }
 
-  bool has_magic_end (void) const { return (rhs && rhs->has_magic_end ()); }
+    bool rvalue_ok (void) const { return true; }
 
-  bool is_assignment_expression (void) const { return true; }
+    octave_value rvalue1 (int nargout = 1);
 
-  bool rvalue_ok (void) const { return true; }
+    octave_value_list rvalue (int nargout);
+
+    std::string oper (void) const;
 
-  octave_value rvalue1 (int nargout = 1);
+    tree_argument_list *left_hand_side (void) { return lhs; }
 
-  octave_value_list rvalue (int nargout);
+    tree_expression *right_hand_side (void) { return rhs; }
 
-  std::string oper (void) const;
+    tree_expression *dup (symbol_table::scope_id scope,
+                          symbol_table::context_id context) const;
 
-  tree_argument_list *left_hand_side (void) { return lhs; }
+    void accept (tree_walker& tw);
 
-  tree_expression *right_hand_side (void) { return rhs; }
+    octave_value::assign_op op_type (void) const
+    { return octave_value::op_asn_eq; }
 
-  tree_expression *dup (symbol_table::scope_id scope,
-                        symbol_table::context_id context) const;
+  private:
 
-  void accept (tree_walker& tw);
+    // The left hand side of the assignment.
+    tree_argument_list *lhs;
 
-  octave_value::assign_op op_type (void) const
-  { return octave_value::op_asn_eq; }
-
-private:
+    // The right hand side of the assignment.
+    tree_expression *rhs;
 
-  // The left hand side of the assignment.
-  tree_argument_list *lhs;
+    // True if we should not delete the lhs.
+    bool preserve;
+  };
+}
 
-  // The right hand side of the assignment.
-  tree_expression *rhs;
+#if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
 
-  // True if we should not delete the lhs.
-  bool preserve;
-};
+OCTAVE_DEPRECATED ("use 'octave::tree_simple_assignment' instead")
+typedef octave::tree_simple_assignment tree_simple_assignment;
+
+OCTAVE_DEPRECATED ("use 'octave::tree_multi_assignment' instead")
+typedef octave::tree_multi_assignment tree_multi_assignment;
 
 #endif
 
+#endif
diff --git a/libinterp/parse-tree/pt-binop.cc b/libinterp/parse-tree/pt-binop.cc
--- a/libinterp/parse-tree/pt-binop.cc
+++ b/libinterp/parse-tree/pt-binop.cc
@@ -29,229 +29,230 @@ along with Octave; see the file COPYING.
 #include "ovl.h"
 #include "ov.h"
 #include "profiler.h"
 #include "pt-binop.h"
 #include "pt-bp.h"
 #include "pt-walk.h"
 #include "variables.h"
 
-
-// Binary expressions.
-
-octave_value_list
-tree_binary_expression::rvalue (int nargout)
-{
-  octave_value_list retval;
-
-  if (nargout > 1)
-    error ("binary operator '%s': invalid number of output arguments",
-           oper ().c_str ());
-
-  retval = rvalue1 (nargout);
-
-  return retval;
-}
-
-void
-tree_binary_expression::matlab_style_short_circuit_warning (const char *op)
-{
-  warning_with_id ("Octave:possible-matlab-short-circuit-operator",
-                   "Matlab-style short-circuit operation performed for operator %s",
-                   op);
-
-  braindead_shortcircuit_warning_issued = true;
-}
-
-octave_value
-tree_binary_expression::rvalue1 (int)
-{
-  octave_value retval;
-
-  if (eligible_for_braindead_shortcircuit)
-    {
-      if (op_lhs)
-        {
-          octave_value a = op_lhs->rvalue1 ();
-
-          if (a.ndims () == 2 && a.rows () == 1 && a.columns () == 1)
-            {
-              bool result = false;
-
-              bool a_true = a.is_true ();
-
-              if (a_true)
-                {
-                  if (etype == octave_value::op_el_or)
-                    {
-                      matlab_style_short_circuit_warning ("|");
-                      return octave_value (true);
-                    }
-                }
-              else
-                {
-                  if (etype == octave_value::op_el_and)
-                    {
-                      matlab_style_short_circuit_warning ("&");
-                      return octave_value (false);
-                    }
-                }
-
-              if (op_rhs)
-                {
-                  octave_value b = op_rhs->rvalue1 ();
-
-                  result = b.is_true ();
-                }
-
-              return octave_value (result);
-            }
-        }
-    }
-
-  if (op_lhs)
-    {
-      octave_value a = op_lhs->rvalue1 ();
-
-      if (a.is_defined () && op_rhs)
-        {
-          octave_value b = op_rhs->rvalue1 ();
-
-          if (b.is_defined ())
-            {
-              BEGIN_PROFILER_BLOCK (tree_binary_expression)
-
-              // Note: The profiler does not catch the braindead
-              // short-circuit evaluation code above, but that should be
-              // ok.  The evaluation of operands and the operator itself
-              // is entangled and it's not clear where to start/stop
-              // timing the operator to make it reasonable.
-
-              retval = ::do_binary_op (etype, a, b);
-
-              END_PROFILER_BLOCK
-            }
-        }
-    }
-
-  return retval;
-}
-
-std::string
-tree_binary_expression::oper (void) const
-{
-  return octave_value::binary_op_as_string (etype);
-}
-
-tree_expression *
-tree_binary_expression::dup (symbol_table::scope_id scope,
-                             symbol_table::context_id context) const
+namespace octave
 {
-  tree_binary_expression *new_be
-    = new tree_binary_expression (op_lhs ? op_lhs->dup (scope, context) : 0,
-                                  op_rhs ? op_rhs->dup (scope, context) : 0,
-                                  line (), column (), etype);
+  // Binary expressions.
+
+  octave_value_list
+  tree_binary_expression::rvalue (int nargout)
+  {
+    octave_value_list retval;
 
-  new_be->copy_base (*this);
+    if (nargout > 1)
+      error ("binary operator '%s': invalid number of output arguments",
+             oper ().c_str ());
 
-  return new_be;
-}
+    retval = rvalue1 (nargout);
+
+    return retval;
+  }
 
-void
-tree_binary_expression::accept (tree_walker& tw)
-{
-  tw.visit_binary_expression (*this);
-}
+  void
+  tree_binary_expression::matlab_style_short_circuit_warning (const char *op)
+  {
+    warning_with_id ("Octave:possible-matlab-short-circuit-operator",
+                     "Matlab-style short-circuit operation performed for operator %s",
+                     op);
+
+    braindead_shortcircuit_warning_issued = true;
+  }
 
-// Boolean expressions.
+  octave_value
+  tree_binary_expression::rvalue1 (int)
+  {
+    octave_value retval;
 
-octave_value_list
-tree_boolean_expression::rvalue (int nargout)
-{
-  octave_value_list retval;
+    if (eligible_for_braindead_shortcircuit)
+      {
+        if (op_lhs)
+          {
+            octave_value a = op_lhs->rvalue1 ();
+
+            if (a.ndims () == 2 && a.rows () == 1 && a.columns () == 1)
+              {
+                bool result = false;
+
+                bool a_true = a.is_true ();
 
-  if (nargout > 1)
-    error ("binary operator '%s': invalid number of output arguments",
-           oper ().c_str ());
+                if (a_true)
+                  {
+                    if (etype == octave_value::op_el_or)
+                      {
+                        matlab_style_short_circuit_warning ("|");
+                        return octave_value (true);
+                      }
+                  }
+                else
+                  {
+                    if (etype == octave_value::op_el_and)
+                      {
+                        matlab_style_short_circuit_warning ("&");
+                        return octave_value (false);
+                      }
+                  }
 
-  retval = rvalue1 (nargout);
+                if (op_rhs)
+                  {
+                    octave_value b = op_rhs->rvalue1 ();
 
-  return retval;
-}
+                    result = b.is_true ();
+                  }
+
+                return octave_value (result);
+              }
+          }
+      }
 
-octave_value
-tree_boolean_expression::rvalue1 (int)
-{
-  octave_value retval;
+    if (op_lhs)
+      {
+        octave_value a = op_lhs->rvalue1 ();
 
-  bool result = false;
+        if (a.is_defined () && op_rhs)
+          {
+            octave_value b = op_rhs->rvalue1 ();
+
+            if (b.is_defined ())
+              {
+                BEGIN_PROFILER_BLOCK (tree_binary_expression)
 
-  // This evaluation is not caught by the profiler, since we can't find
-  // a reasonable place where to time.  Note that we don't want to
-  // include evaluation of LHS or RHS into the timing, but this is
-  // entangled together with short-circuit evaluation here.
+                  // Note: The profiler does not catch the braindead
+                  // short-circuit evaluation code above, but that should be
+                  // ok.  The evaluation of operands and the operator itself
+                  // is entangled and it's not clear where to start/stop
+                  // timing the operator to make it reasonable.
+
+                  retval = ::do_binary_op (etype, a, b);
 
-  if (op_lhs)
-    {
-      octave_value a = op_lhs->rvalue1 ();
+                END_PROFILER_BLOCK
+                  }
+          }
+      }
 
-      bool a_true = a.is_true ();
+    return retval;
+  }
+
+  std::string
+  tree_binary_expression::oper (void) const
+  {
+    return octave_value::binary_op_as_string (etype);
+  }
 
-      if (a_true)
-        {
-          if (etype == bool_or)
-            return octave_value (true);
-        }
-      else
-        {
-          if (etype == bool_and)
-            return octave_value (false);
-        }
+  tree_expression *
+  tree_binary_expression::dup (symbol_table::scope_id scope,
+                               symbol_table::context_id context) const
+  {
+    tree_binary_expression *new_be
+      = new tree_binary_expression (op_lhs ? op_lhs->dup (scope, context) : 0,
+                                    op_rhs ? op_rhs->dup (scope, context) : 0,
+                                    line (), column (), etype);
+
+    new_be->copy_base (*this);
+
+    return new_be;
+  }
+
+  void
+  tree_binary_expression::accept (tree_walker& tw)
+  {
+    tw.visit_binary_expression (*this);
+  }
+
+  // Boolean expressions.
+
+  octave_value_list
+  tree_boolean_expression::rvalue (int nargout)
+  {
+    octave_value_list retval;
 
-      if (op_rhs)
-        {
-          octave_value b = op_rhs->rvalue1 ();
+    if (nargout > 1)
+      error ("binary operator '%s': invalid number of output arguments",
+             oper ().c_str ());
 
-          result = b.is_true ();
-        }
+    retval = rvalue1 (nargout);
+
+    return retval;
+  }
 
-      retval = octave_value (result);
-    }
+  octave_value
+  tree_boolean_expression::rvalue1 (int)
+  {
+    octave_value retval;
+
+    bool result = false;
 
-  return retval;
-}
+    // This evaluation is not caught by the profiler, since we can't find
+    // a reasonable place where to time.  Note that we don't want to
+    // include evaluation of LHS or RHS into the timing, but this is
+    // entangled together with short-circuit evaluation here.
 
-std::string
-tree_boolean_expression::oper (void) const
-{
-  std::string retval = "<unknown>";
+    if (op_lhs)
+      {
+        octave_value a = op_lhs->rvalue1 ();
+
+        bool a_true = a.is_true ();
 
-  switch (etype)
-    {
-    case bool_and:
-      retval = "&&";
-      break;
+        if (a_true)
+          {
+            if (etype == bool_or)
+              return octave_value (true);
+          }
+        else
+          {
+            if (etype == bool_and)
+              return octave_value (false);
+          }
+
+        if (op_rhs)
+          {
+            octave_value b = op_rhs->rvalue1 ();
+
+            result = b.is_true ();
+          }
+
+        retval = octave_value (result);
+      }
+
+    return retval;
+  }
+
+  std::string
+  tree_boolean_expression::oper (void) const
+  {
+    std::string retval = "<unknown>";
 
-    case bool_or:
-      retval = "||";
-      break;
+    switch (etype)
+      {
+      case bool_and:
+        retval = "&&";
+        break;
+
+      case bool_or:
+        retval = "||";
+        break;
+
+      default:
+        break;
+      }
 
-    default:
-      break;
-    }
+    return retval;
+  }
 
-  return retval;
+  tree_expression *
+  tree_boolean_expression::dup (symbol_table::scope_id scope,
+                                symbol_table::context_id context) const
+  {
+    tree_boolean_expression *new_be
+      = new tree_boolean_expression (op_lhs ? op_lhs->dup (scope, context) : 0,
+                                     op_rhs ? op_rhs->dup (scope, context) : 0,
+                                     line (), column (), etype);
+
+    new_be->copy_base (*this);
+
+    return new_be;
+  }
 }
-
-tree_expression *
-tree_boolean_expression::dup (symbol_table::scope_id scope,
-                              symbol_table::context_id context) const
-{
-  tree_boolean_expression *new_be
-    = new tree_boolean_expression (op_lhs ? op_lhs->dup (scope, context) : 0,
-                                   op_rhs ? op_rhs->dup (scope, context) : 0,
-                                   line (), column (), etype);
-
-  new_be->copy_base (*this);
-
-  return new_be;
-}
-
diff --git a/libinterp/parse-tree/pt-binop.h b/libinterp/parse-tree/pt-binop.h
--- a/libinterp/parse-tree/pt-binop.h
+++ b/libinterp/parse-tree/pt-binop.h
@@ -22,165 +22,175 @@ along with Octave; see the file COPYING.
 
 #if ! defined (octave_pt_binop_h)
 #define octave_pt_binop_h 1
 
 #include "octave-config.h"
 
 #include <string>
 
-class tree_walker;
-
 class octave_value;
 class octave_value_list;
 class octave_lvalue;
 
 #include "ov.h"
 #include "pt-exp.h"
 #include "symtab.h"
 
-// Binary expressions.
-
-class
-tree_binary_expression : public tree_expression
+namespace octave
 {
-public:
+  class tree_walker;
+
+  // Binary expressions.
 
-  tree_binary_expression (int l = -1, int c = -1,
-                          octave_value::binary_op t
+  class tree_binary_expression : public tree_expression
+  {
+  public:
+
+    tree_binary_expression (int l = -1, int c = -1,
+                            octave_value::binary_op t
                             = octave_value::unknown_binary_op)
-    : tree_expression (l, c), op_lhs (0), op_rhs (0), etype (t),
-      eligible_for_braindead_shortcircuit (false),
-      braindead_shortcircuit_warning_issued (false) { }
-
-  tree_binary_expression (tree_expression *a, tree_expression *b,
-                          int l = -1, int c = -1,
-                          octave_value::binary_op t
-                            = octave_value::unknown_binary_op)
-    : tree_expression (l, c), op_lhs (a), op_rhs (b), etype (t),
-      eligible_for_braindead_shortcircuit (false),
-      braindead_shortcircuit_warning_issued (false) { }
-
-  // No copying!
-
-  tree_binary_expression (const tree_binary_expression&) = delete;
+      : tree_expression (l, c), op_lhs (0), op_rhs (0), etype (t),
+        eligible_for_braindead_shortcircuit (false),
+        braindead_shortcircuit_warning_issued (false) { }
 
-  tree_binary_expression& operator = (const tree_binary_expression&) = delete;
+    tree_binary_expression (tree_expression *a, tree_expression *b,
+                            int l = -1, int c = -1,
+                            octave_value::binary_op t
+                            = octave_value::unknown_binary_op)
+      : tree_expression (l, c), op_lhs (a), op_rhs (b), etype (t),
+        eligible_for_braindead_shortcircuit (false),
+        braindead_shortcircuit_warning_issued (false) { }
 
-  ~tree_binary_expression (void)
-  {
-    delete op_lhs;
-    delete op_rhs;
-  }
+    // No copying!
+
+    tree_binary_expression (const tree_binary_expression&) = delete;
+
+    tree_binary_expression& operator = (const tree_binary_expression&) = delete;
 
-  void mark_braindead_shortcircuit (void)
-  {
-    if (etype == octave_value::op_el_and || etype == octave_value::op_el_or)
-      {
-        eligible_for_braindead_shortcircuit = true;
+    ~tree_binary_expression (void)
+    {
+      delete op_lhs;
+      delete op_rhs;
+    }
 
-        op_lhs->mark_braindead_shortcircuit ();
-        op_rhs->mark_braindead_shortcircuit ();
-      }
-  }
+    void mark_braindead_shortcircuit (void)
+    {
+      if (etype == octave_value::op_el_and || etype == octave_value::op_el_or)
+        {
+          eligible_for_braindead_shortcircuit = true;
 
-  bool has_magic_end (void) const
-  {
-    return ((op_lhs && op_lhs->has_magic_end ())
-            || (op_rhs && op_rhs->has_magic_end ()));
-  }
-
-  bool is_binary_expression (void) const { return true; }
+          op_lhs->mark_braindead_shortcircuit ();
+          op_rhs->mark_braindead_shortcircuit ();
+        }
+    }
 
-  bool rvalue_ok (void) const { return true; }
-
-  octave_value rvalue1 (int nargout = 1);
-
-  octave_value_list rvalue (int nargout);
+    bool has_magic_end (void) const
+    {
+      return ((op_lhs && op_lhs->has_magic_end ())
+              || (op_rhs && op_rhs->has_magic_end ()));
+    }
 
-  std::string oper (void) const;
+    bool is_binary_expression (void) const { return true; }
 
-  octave_value::binary_op op_type (void) const { return etype; }
+    bool rvalue_ok (void) const { return true; }
 
-  tree_expression *lhs (void) { return op_lhs; }
-  tree_expression *rhs (void) { return op_rhs; }
+    octave_value rvalue1 (int nargout = 1);
 
-  tree_expression *dup (symbol_table::scope_id scope,
-                        symbol_table::context_id context) const;
+    octave_value_list rvalue (int nargout);
 
-  void accept (tree_walker& tw);
+    std::string oper (void) const;
+
+    octave_value::binary_op op_type (void) const { return etype; }
 
-  std::string profiler_name (void) const { return "binary " + oper (); }
-
-protected:
+    tree_expression *lhs (void) { return op_lhs; }
+    tree_expression *rhs (void) { return op_rhs; }
 
-  // The operands for the expression.
-  tree_expression *op_lhs;
-  tree_expression *op_rhs;
+    tree_expression *dup (symbol_table::scope_id scope,
+                          symbol_table::context_id context) const;
 
-private:
+    void accept (tree_walker& tw);
 
-  // The type of the expression.
-  octave_value::binary_op etype;
+    std::string profiler_name (void) const { return "binary " + oper (); }
+
+  protected:
 
-  // TRUE if this is an | or & expression in the condition of an IF
-  // or WHILE statement.
-  bool eligible_for_braindead_shortcircuit;
+    // The operands for the expression.
+    tree_expression *op_lhs;
+    tree_expression *op_rhs;
 
-  // TRUE if we have already issued a warning about short circuiting
-  // for this operator.
-  bool braindead_shortcircuit_warning_issued;
+  private:
 
-  void matlab_style_short_circuit_warning (const char *op);
-};
-
-// Boolean expressions.
+    // The type of the expression.
+    octave_value::binary_op etype;
 
-class
-tree_boolean_expression : public tree_binary_expression
-{
-public:
+    // TRUE if this is an | or & expression in the condition of an IF
+    // or WHILE statement.
+    bool eligible_for_braindead_shortcircuit;
 
-  enum type
-  {
-    unknown,
-    bool_and,
-    bool_or
+    // TRUE if we have already issued a warning about short circuiting
+    // for this operator.
+    bool braindead_shortcircuit_warning_issued;
+
+    void matlab_style_short_circuit_warning (const char *op);
   };
 
-  tree_boolean_expression (int l = -1, int c = -1, type t = unknown)
-    : tree_binary_expression (l, c), etype (t) { }
+  // Boolean expressions.
+
+  class tree_boolean_expression : public tree_binary_expression
+  {
+  public:
 
-  tree_boolean_expression (tree_expression *a, tree_expression *b,
-                           int l = -1, int c = -1, type t = unknown)
-    : tree_binary_expression (a, b, l, c), etype (t) { }
+    enum type
+      {
+        unknown,
+        bool_and,
+        bool_or
+      };
 
-  // No copying!
+    tree_boolean_expression (int l = -1, int c = -1, type t = unknown)
+      : tree_binary_expression (l, c), etype (t) { }
 
-  tree_boolean_expression (const tree_boolean_expression&) = delete;
+    tree_boolean_expression (tree_expression *a, tree_expression *b,
+                             int l = -1, int c = -1, type t = unknown)
+      : tree_binary_expression (a, b, l, c), etype (t) { }
 
-  tree_boolean_expression& operator = (const tree_boolean_expression&) = delete;
+    // No copying!
+
+    tree_boolean_expression (const tree_boolean_expression&) = delete;
 
-  ~tree_boolean_expression (void) = default;
+    tree_boolean_expression& operator = (const tree_boolean_expression&) = delete;
 
-  bool is_boolean_expression (void) const { return true; }
+    ~tree_boolean_expression (void) = default;
 
-  bool rvalue_ok (void) const { return true; }
+    bool is_boolean_expression (void) const { return true; }
 
-  octave_value rvalue1 (int nargout = 1);
+    bool rvalue_ok (void) const { return true; }
+
+    octave_value rvalue1 (int nargout = 1);
 
-  octave_value_list rvalue (int nargout);
+    octave_value_list rvalue (int nargout);
+
+    std::string oper (void) const;
 
-  std::string oper (void) const;
+    type op_type (void) const { return etype; }
+
+    tree_expression *dup (symbol_table::scope_id scope,
+                          symbol_table::context_id context) const;
 
-  type op_type (void) const { return etype; }
+  private:
 
-  tree_expression *dup (symbol_table::scope_id scope,
-                        symbol_table::context_id context) const;
+    // The type of the expression.
+    type etype;
+  };
+}
 
-private:
+#if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
 
-  // The type of the expression.
-  type etype;
-};
+OCTAVE_DEPRECATED ("use 'octave::tree_binary_expression' instead")
+typedef octave::tree_binary_expression tree_binary_expression;
+
+OCTAVE_DEPRECATED ("use 'octave::tree_boolean_expression' instead")
+typedef octave::tree_boolean_expression tree_boolean_expression;
 
 #endif
 
+#endif
diff --git a/libinterp/parse-tree/pt-bp.cc b/libinterp/parse-tree/pt-bp.cc
--- a/libinterp/parse-tree/pt-bp.cc
+++ b/libinterp/parse-tree/pt-bp.cc
@@ -23,483 +23,485 @@ along with Octave; see the file COPYING.
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
 #include "ov-usr-fcn.h"
 #include "pager.h"
 #include "pt-all.h"
 
-// TRUE means SIGINT should put us in the debugger at the next
-// available breakpoint.
-bool octave_debug_on_interrupt_state = false;
-
-void
-tree_breakpoint::visit_while_command (tree_while_command& cmd)
-{
-  if (cmd.line () >= line)
-    take_action (cmd);
-
-  if (! found)
-    {
-      tree_statement_list *lst = cmd.body ();
-
-      if (lst)
-        lst->accept (*this);
-    }
-}
-
-void
-tree_breakpoint::visit_do_until_command (tree_do_until_command& cmd)
-{
-  if (! found)
-    {
-      tree_statement_list *lst = cmd.body ();
-
-      if (lst)
-        lst->accept (*this);
-
-      if (! found)
-        {
-          if (cmd.line () >= line)
-            take_action (cmd);
-        }
-    }
-}
-
-void
-tree_breakpoint::visit_argument_list (tree_argument_list&)
-{
-  panic_impossible ();
-}
-
-void
-tree_breakpoint::visit_binary_expression (tree_binary_expression&)
-{
-  panic_impossible ();
-}
-
-void
-tree_breakpoint::visit_break_command (tree_break_command& cmd)
-{
-  if (cmd.line () >= line)
-    take_action (cmd);
-}
-
-void
-tree_breakpoint::visit_colon_expression (tree_colon_expression&)
-{
-  panic_impossible ();
-}
-
-void
-tree_breakpoint::visit_continue_command (tree_continue_command& cmd)
-{
-  if (cmd.line () >= line)
-    take_action (cmd);
-}
-
-void
-tree_breakpoint::do_decl_command (tree_decl_command& cmd)
-{
-  if (cmd.line () >= line)
-    take_action (cmd);
-}
-
-void
-tree_breakpoint::visit_global_command (tree_global_command& cmd)
-{
-  do_decl_command (cmd);
-}
-
-void
-tree_breakpoint::visit_persistent_command (tree_persistent_command& cmd)
-{
-  do_decl_command (cmd);
-}
-
-void
-tree_breakpoint::visit_decl_elt (tree_decl_elt&)
-{
-  panic_impossible ();
-}
-
-void
-tree_breakpoint::visit_decl_init_list (tree_decl_init_list&)
-{
-  panic_impossible ();
-}
-
-void
-tree_breakpoint::visit_simple_for_command (tree_simple_for_command& cmd)
-{
-  if (cmd.line () >= line)
-    take_action (cmd);
-
-  if (! found)
-    {
-      tree_statement_list *lst = cmd.body ();
-
-      if (lst)
-        lst->accept (*this);
-    }
-}
-
-void
-tree_breakpoint::visit_complex_for_command (tree_complex_for_command& cmd)
+namespace octave
 {
-  if (cmd.line () >= line)
-    take_action (cmd);
+  // TRUE means SIGINT should put us in the debugger at the next
+  // available breakpoint.
+  bool octave_debug_on_interrupt_state = false;
+
+  void
+  tree_breakpoint::visit_while_command (tree_while_command& cmd)
+  {
+    if (cmd.line () >= line)
+      take_action (cmd);
 
-  if (! found)
-    {
-      tree_statement_list *lst = cmd.body ();
+    if (! found)
+      {
+        tree_statement_list *lst = cmd.body ();
 
-      if (lst)
-        lst->accept (*this);
-    }
-}
+        if (lst)
+          lst->accept (*this);
+      }
+  }
+
+  void
+  tree_breakpoint::visit_do_until_command (tree_do_until_command& cmd)
+  {
+    if (! found)
+      {
+        tree_statement_list *lst = cmd.body ();
 
-void
-tree_breakpoint::visit_octave_user_script (octave_user_script& fcn)
-{
-  tree_statement_list *cmd_list = fcn.body ();
+        if (lst)
+          lst->accept (*this);
+
+        if (! found)
+          {
+            if (cmd.line () >= line)
+              take_action (cmd);
+          }
+      }
+  }
 
-  if (cmd_list)
-    cmd_list->accept (*this);
-}
+  void
+  tree_breakpoint::visit_argument_list (tree_argument_list&)
+  {
+    panic_impossible ();
+  }
 
-void
-tree_breakpoint::visit_octave_user_function (octave_user_function& fcn)
-{
-  tree_statement_list *cmd_list = fcn.body ();
+  void
+  tree_breakpoint::visit_binary_expression (tree_binary_expression&)
+  {
+    panic_impossible ();
+  }
+
+  void
+  tree_breakpoint::visit_break_command (tree_break_command& cmd)
+  {
+    if (cmd.line () >= line)
+      take_action (cmd);
+  }
 
-  if (cmd_list)
-    cmd_list->accept (*this);
-}
+  void
+  tree_breakpoint::visit_colon_expression (tree_colon_expression&)
+  {
+    panic_impossible ();
+  }
+
+  void
+  tree_breakpoint::visit_continue_command (tree_continue_command& cmd)
+  {
+    if (cmd.line () >= line)
+      take_action (cmd);
+  }
 
-void
-tree_breakpoint::visit_octave_user_function_header (octave_user_function&)
-{
-  panic_impossible ();
-}
+  void
+  tree_breakpoint::do_decl_command (tree_decl_command& cmd)
+  {
+    if (cmd.line () >= line)
+      take_action (cmd);
+  }
 
-void
-tree_breakpoint::visit_octave_user_function_trailer (octave_user_function&)
-{
-  panic_impossible ();
-}
+  void
+  tree_breakpoint::visit_global_command (tree_global_command& cmd)
+  {
+    do_decl_command (cmd);
+  }
 
-void
-tree_breakpoint::visit_function_def (tree_function_def& fdef)
-{
-  octave_value fcn = fdef.function ();
+  void
+  tree_breakpoint::visit_persistent_command (tree_persistent_command& cmd)
+  {
+    do_decl_command (cmd);
+  }
 
-  octave_function *f = fcn.function_value ();
+  void
+  tree_breakpoint::visit_decl_elt (tree_decl_elt&)
+  {
+    panic_impossible ();
+  }
 
-  if (f)
-    f->accept (*this);
-}
+  void
+  tree_breakpoint::visit_decl_init_list (tree_decl_init_list&)
+  {
+    panic_impossible ();
+  }
 
-void
-tree_breakpoint::visit_identifier (tree_identifier&)
-{
-  panic_impossible ();
-}
+  void
+  tree_breakpoint::visit_simple_for_command (tree_simple_for_command& cmd)
+  {
+    if (cmd.line () >= line)
+      take_action (cmd);
+
+    if (! found)
+      {
+        tree_statement_list *lst = cmd.body ();
+
+        if (lst)
+          lst->accept (*this);
+      }
+  }
 
-void
-tree_breakpoint::visit_if_clause (tree_if_clause&)
-{
-  panic_impossible ();
-}
+  void
+  tree_breakpoint::visit_complex_for_command (tree_complex_for_command& cmd)
+  {
+    if (cmd.line () >= line)
+      take_action (cmd);
+
+    if (! found)
+      {
+        tree_statement_list *lst = cmd.body ();
 
-void
-tree_breakpoint::visit_if_command (tree_if_command& cmd)
-{
-  tree_if_command_list *lst = cmd.cmd_list ();
+        if (lst)
+          lst->accept (*this);
+      }
+  }
+
+  void
+  tree_breakpoint::visit_octave_user_script (octave_user_script& fcn)
+  {
+    tree_statement_list *cmd_list = fcn.body ();
+
+    if (cmd_list)
+      cmd_list->accept (*this);
+  }
 
-  if (lst)
-    lst->accept (*this);
-}
+  void
+  tree_breakpoint::visit_octave_user_function (octave_user_function& fcn)
+  {
+    tree_statement_list *cmd_list = fcn.body ();
+
+    if (cmd_list)
+      cmd_list->accept (*this);
+  }
+
+  void
+  tree_breakpoint::visit_octave_user_function_header (octave_user_function&)
+  {
+    panic_impossible ();
+  }
 
-void
-tree_breakpoint::visit_if_command_list (tree_if_command_list& lst)
-{
-  for (tree_if_clause* t : lst)
-    {
-      if (t->line () >= line)
-        take_action (*t);
+  void
+  tree_breakpoint::visit_octave_user_function_trailer (octave_user_function&)
+  {
+    panic_impossible ();
+  }
 
-      if (! found)
-        {
-          tree_statement_list *stmt_lst = t->commands ();
+  void
+  tree_breakpoint::visit_function_def (tree_function_def& fdef)
+  {
+    octave_value fcn = fdef.function ();
+
+    octave_function *f = fcn.function_value ();
+
+    if (f)
+      f->accept (*this);
+  }
 
-          if (stmt_lst)
-            stmt_lst->accept (*this);
-        }
+  void
+  tree_breakpoint::visit_identifier (tree_identifier&)
+  {
+    panic_impossible ();
+  }
+
+  void
+  tree_breakpoint::visit_if_clause (tree_if_clause&)
+  {
+    panic_impossible ();
+  }
 
-      if (found)
-        break;
-    }
-}
+  void
+  tree_breakpoint::visit_if_command (tree_if_command& cmd)
+  {
+    tree_if_command_list *lst = cmd.cmd_list ();
+
+    if (lst)
+      lst->accept (*this);
+  }
 
-void
-tree_breakpoint::visit_index_expression (tree_index_expression&)
-{
-  panic_impossible ();
-}
+  void
+  tree_breakpoint::visit_if_command_list (tree_if_command_list& lst)
+  {
+    for (tree_if_clause* t : lst)
+      {
+        if (t->line () >= line)
+          take_action (*t);
+
+        if (! found)
+          {
+            tree_statement_list *stmt_lst = t->commands ();
 
-void
-tree_breakpoint::visit_matrix (tree_matrix&)
-{
-  panic_impossible ();
-}
+            if (stmt_lst)
+              stmt_lst->accept (*this);
+          }
+
+        if (found)
+          break;
+      }
+  }
+
+  void
+  tree_breakpoint::visit_index_expression (tree_index_expression&)
+  {
+    panic_impossible ();
+  }
 
-void
-tree_breakpoint::visit_cell (tree_cell&)
-{
-  panic_impossible ();
-}
+  void
+  tree_breakpoint::visit_matrix (tree_matrix&)
+  {
+    panic_impossible ();
+  }
 
-void
-tree_breakpoint::visit_multi_assignment (tree_multi_assignment&)
-{
-  panic_impossible ();
-}
+  void
+  tree_breakpoint::visit_cell (tree_cell&)
+  {
+    panic_impossible ();
+  }
+
+  void
+  tree_breakpoint::visit_multi_assignment (tree_multi_assignment&)
+  {
+    panic_impossible ();
+  }
 
-void
-tree_breakpoint::visit_no_op_command (tree_no_op_command& cmd)
-{
-  if (cmd.is_end_of_fcn_or_script () && cmd.line () >= line)
-    take_action (cmd);
-}
+  void
+  tree_breakpoint::visit_no_op_command (tree_no_op_command& cmd)
+  {
+    if (cmd.is_end_of_fcn_or_script () && cmd.line () >= line)
+      take_action (cmd);
+  }
 
-void
-tree_breakpoint::visit_anon_fcn_handle (tree_anon_fcn_handle&)
-{
-  panic_impossible ();
-}
+  void
+  tree_breakpoint::visit_anon_fcn_handle (tree_anon_fcn_handle&)
+  {
+    panic_impossible ();
+  }
 
-void
-tree_breakpoint::visit_constant (tree_constant&)
-{
-  panic_impossible ();
-}
+  void
+  tree_breakpoint::visit_constant (tree_constant&)
+  {
+    panic_impossible ();
+  }
 
-void
-tree_breakpoint::visit_fcn_handle (tree_fcn_handle&)
-{
-  panic_impossible ();
-}
+  void
+  tree_breakpoint::visit_fcn_handle (tree_fcn_handle&)
+  {
+    panic_impossible ();
+  }
 
-void
-tree_breakpoint::visit_funcall (tree_funcall&)
-{
-  panic_impossible ();
-}
+  void
+  tree_breakpoint::visit_funcall (tree_funcall&)
+  {
+    panic_impossible ();
+  }
 
-void
-tree_breakpoint::visit_parameter_list (tree_parameter_list&)
-{
-  panic_impossible ();
-}
+  void
+  tree_breakpoint::visit_parameter_list (tree_parameter_list&)
+  {
+    panic_impossible ();
+  }
 
-void
-tree_breakpoint::visit_postfix_expression (tree_postfix_expression&)
-{
-  panic_impossible ();
-}
+  void
+  tree_breakpoint::visit_postfix_expression (tree_postfix_expression&)
+  {
+    panic_impossible ();
+  }
 
-void
-tree_breakpoint::visit_prefix_expression (tree_prefix_expression&)
-{
-  panic_impossible ();
-}
+  void
+  tree_breakpoint::visit_prefix_expression (tree_prefix_expression&)
+  {
+    panic_impossible ();
+  }
 
-void
-tree_breakpoint::visit_return_command (tree_return_command& cmd)
-{
-  if (cmd.line () >= line)
-    take_action (cmd);
-}
+  void
+  tree_breakpoint::visit_return_command (tree_return_command& cmd)
+  {
+    if (cmd.line () >= line)
+      take_action (cmd);
+  }
 
-void
-tree_breakpoint::visit_return_list (tree_return_list&)
-{
-  panic_impossible ();
-}
+  void
+  tree_breakpoint::visit_return_list (tree_return_list&)
+  {
+    panic_impossible ();
+  }
 
-void
-tree_breakpoint::visit_simple_assignment (tree_simple_assignment&)
-{
-  panic_impossible ();
-}
+  void
+  tree_breakpoint::visit_simple_assignment (tree_simple_assignment&)
+  {
+    panic_impossible ();
+  }
 
-void
-tree_breakpoint::visit_statement (tree_statement& stmt)
-{
-  if (stmt.is_command ())
-    {
-      tree_command *cmd = stmt.command ();
+  void
+  tree_breakpoint::visit_statement (tree_statement& stmt)
+  {
+    if (stmt.is_command ())
+      {
+        tree_command *cmd = stmt.command ();
 
-      cmd->accept (*this);
-    }
-  else
-    {
-      if (stmt.line () >= line)
-        take_action (stmt);
-    }
-}
+        cmd->accept (*this);
+      }
+    else
+      {
+        if (stmt.line () >= line)
+          take_action (stmt);
+      }
+  }
 
-// Called by
-//   tree_statement_list::set_breakpoint (int line, std::string& condition)
-// with <lst> consisting of a user function in which to set a breakpoint.
-void
-tree_breakpoint::visit_statement_list (tree_statement_list& lst)
-{
-  for (tree_statement* elt : lst)
-    {
-      if (elt)
-        {
-          elt->accept (*this);
+  // Called by
+  //   tree_statement_list::set_breakpoint (int line, std::string& condition)
+  // with <lst> consisting of a user function in which to set a breakpoint.
+  void
+  tree_breakpoint::visit_statement_list (tree_statement_list& lst)
+  {
+    for (tree_statement* elt : lst)
+      {
+        if (elt)
+          {
+            elt->accept (*this);
 
-          if (found)
-            break;
-        }
-    }
-}
+            if (found)
+              break;
+          }
+      }
+  }
 
-void
-tree_breakpoint::visit_switch_case (tree_switch_case&)
-{
-  panic_impossible ();
-}
+  void
+  tree_breakpoint::visit_switch_case (tree_switch_case&)
+  {
+    panic_impossible ();
+  }
 
-void
-tree_breakpoint::visit_switch_case_list (tree_switch_case_list& lst)
-{
-  for (tree_switch_case* t : lst)
-    {
-      if (t->line () >= line)
-        take_action (*t);
+  void
+  tree_breakpoint::visit_switch_case_list (tree_switch_case_list& lst)
+  {
+    for (tree_switch_case* t : lst)
+      {
+        if (t->line () >= line)
+          take_action (*t);
 
-      if (! found)
-        {
-          tree_statement_list *stmt_lst = t->commands ();
+        if (! found)
+          {
+            tree_statement_list *stmt_lst = t->commands ();
+
+            if (stmt_lst)
+              stmt_lst->accept (*this);
+          }
+
+        if (found)
+          break;
+      }
+  }
 
-          if (stmt_lst)
-            stmt_lst->accept (*this);
-        }
+  void
+  tree_breakpoint::visit_switch_command (tree_switch_command& cmd)
+  {
+    if (cmd.line () >= line)
+      take_action (cmd);
 
-      if (found)
-        break;
-    }
-}
+    if (! found)
+      {
+        tree_switch_case_list *lst = cmd.case_list ();
+
+        if (lst)
+          lst->accept (*this);
+      }
+  }
 
-void
-tree_breakpoint::visit_switch_command (tree_switch_command& cmd)
-{
-  if (cmd.line () >= line)
-    take_action (cmd);
+  void
+  tree_breakpoint::visit_try_catch_command (tree_try_catch_command& cmd)
+  {
+    tree_statement_list *try_code = cmd.body ();
+
+    if (try_code)
+      try_code->accept (*this);
+
+    if (! found)
+      {
+        tree_statement_list *catch_code = cmd.cleanup ();
 
-  if (! found)
-    {
-      tree_switch_case_list *lst = cmd.case_list ();
+        if (catch_code)
+          catch_code->accept (*this);
+      }
+  }
 
-      if (lst)
-        lst->accept (*this);
-    }
-}
+  void
+  tree_breakpoint::visit_unwind_protect_command (tree_unwind_protect_command& cmd)
+  {
+    tree_statement_list *body = cmd.body ();
+
+    if (body)
+      body->accept (*this);
+
+    if (! found)
+      {
+        tree_statement_list *cleanup = cmd.cleanup ();
 
-void
-tree_breakpoint::visit_try_catch_command (tree_try_catch_command& cmd)
-{
-  tree_statement_list *try_code = cmd.body ();
-
-  if (try_code)
-    try_code->accept (*this);
-
-  if (! found)
-    {
-      tree_statement_list *catch_code = cmd.cleanup ();
+        if (cleanup)
+          cleanup->accept (*this);
+      }
+  }
 
-      if (catch_code)
-        catch_code->accept (*this);
-    }
-}
-
-void
-tree_breakpoint::visit_unwind_protect_command (tree_unwind_protect_command& cmd)
-{
-  tree_statement_list *body = cmd.body ();
+  void
+  tree_breakpoint::take_action (tree& tr)
+  {
+    if (act == set)
+      {
+        tr.set_breakpoint (condition);
+        line = tr.line ();
+        found = true;
+      }
+    else if (act == clear)
+      {
+        if (tr.is_breakpoint ())
+          {
+            tr.delete_breakpoint ();
+            found = true;
+          }
+      }
+    else if (act == list)
+      {
+        if (tr.is_breakpoint ())
+          {
+            bp_list.append (octave_value (tr.line ()));
+            bp_cond_list.append (octave_value (tr.bp_cond ()));
+          }
+      }
+    else
+      panic_impossible ();
+  }
 
-  if (body)
-    body->accept (*this);
+  void
+  tree_breakpoint::take_action (tree_statement& stmt)
+  {
+    int lineno = stmt.line ();
 
-  if (! found)
-    {
-      tree_statement_list *cleanup = cmd.cleanup ();
-
-      if (cleanup)
-        cleanup->accept (*this);
-    }
+    if (act == set)
+      {
+        stmt.set_breakpoint (condition);
+        line = lineno;
+        found = true;
+      }
+    else if (act == clear)
+      {
+        if (stmt.is_breakpoint ())
+          {
+            stmt.delete_breakpoint ();
+            found = true;
+          }
+      }
+    else if (act == list)
+      {
+        if (stmt.is_breakpoint ())
+          {
+            bp_list.append (octave_value (lineno));
+            bp_cond_list.append (octave_value (stmt.bp_cond ()));
+          }
+      }
+    else
+      panic_impossible ();
+  }
 }
-
-void
-tree_breakpoint::take_action (tree& tr)
-{
-  if (act == set)
-    {
-      tr.set_breakpoint (condition);
-      line = tr.line ();
-      found = true;
-    }
-  else if (act == clear)
-    {
-      if (tr.is_breakpoint ())
-        {
-          tr.delete_breakpoint ();
-          found = true;
-        }
-    }
-  else if (act == list)
-    {
-      if (tr.is_breakpoint ())
-        {
-          bp_list.append (octave_value (tr.line ()));
-          bp_cond_list.append (octave_value (tr.bp_cond ()));
-        }
-    }
-  else
-    panic_impossible ();
-}
-
-void
-tree_breakpoint::take_action (tree_statement& stmt)
-{
-  int lineno = stmt.line ();
-
-  if (act == set)
-    {
-      stmt.set_breakpoint (condition);
-      line = lineno;
-      found = true;
-    }
-  else if (act == clear)
-    {
-      if (stmt.is_breakpoint ())
-        {
-          stmt.delete_breakpoint ();
-          found = true;
-        }
-    }
-  else if (act == list)
-    {
-      if (stmt.is_breakpoint ())
-        {
-          bp_list.append (octave_value (lineno));
-          bp_cond_list.append (octave_value (stmt.bp_cond ()));
-        }
-    }
-  else
-    panic_impossible ();
-}
-
diff --git a/libinterp/parse-tree/pt-bp.h b/libinterp/parse-tree/pt-bp.h
--- a/libinterp/parse-tree/pt-bp.h
+++ b/libinterp/parse-tree/pt-bp.h
@@ -26,157 +26,165 @@ along with Octave; see the file COPYING.
 #include "octave-config.h"
 
 #include "input.h"
 #include "ov-usr-fcn.h"
 #include "pt-walk.h"
 #include "pt-pr-code.h"
 #include "interpreter.h"
 
-class tree;
-class tree_decl_command;
+namespace octave
+{
+  class tree;
+  class tree_decl_command;
 
-class
-tree_breakpoint : public tree_walker
-{
-public:
+  class tree_breakpoint : public tree_walker
+  {
+  public:
 
-  enum action { set = 1, clear = 2, list = 3 };
+    enum action { set = 1, clear = 2, list = 3 };
 
-  tree_breakpoint (int l, action a, const std::string& c = "")
-    : line (l), act (a), condition (c), found (false), bp_list () { }
+    tree_breakpoint (int l, action a, const std::string& c = "")
+      : line (l), act (a), condition (c), found (false), bp_list () { }
 
-  // No copying!
+    // No copying!
 
-  tree_breakpoint (const tree_breakpoint&) = delete;
+    tree_breakpoint (const tree_breakpoint&) = delete;
 
-  tree_breakpoint& operator = (const tree_breakpoint&) = delete;
+    tree_breakpoint& operator = (const tree_breakpoint&) = delete;
 
-  ~tree_breakpoint (void) = default;
+    ~tree_breakpoint (void) = default;
 
-  bool success (void) const { return found; }
+    bool success (void) const { return found; }
 
-  void visit_argument_list (tree_argument_list&);
+    void visit_argument_list (tree_argument_list&);
+
+    void visit_binary_expression (tree_binary_expression&);
 
-  void visit_binary_expression (tree_binary_expression&);
+    void visit_break_command (tree_break_command&);
 
-  void visit_break_command (tree_break_command&);
+    void visit_colon_expression (tree_colon_expression&);
 
-  void visit_colon_expression (tree_colon_expression&);
+    void visit_continue_command (tree_continue_command&);
 
-  void visit_continue_command (tree_continue_command&);
+    void visit_global_command (tree_global_command&);
 
-  void visit_global_command (tree_global_command&);
+    void visit_persistent_command (tree_persistent_command&);
 
-  void visit_persistent_command (tree_persistent_command&);
+    void visit_decl_elt (tree_decl_elt&);
 
-  void visit_decl_elt (tree_decl_elt&);
+    void visit_decl_init_list (tree_decl_init_list&);
 
-  void visit_decl_init_list (tree_decl_init_list&);
+    void visit_while_command (tree_while_command&);
 
-  void visit_while_command (tree_while_command&);
+    void visit_do_until_command (tree_do_until_command&);
 
-  void visit_do_until_command (tree_do_until_command&);
+    void visit_simple_for_command (tree_simple_for_command&);
 
-  void visit_simple_for_command (tree_simple_for_command&);
+    void visit_complex_for_command (tree_complex_for_command&);
 
-  void visit_complex_for_command (tree_complex_for_command&);
+    void visit_octave_user_script (octave_user_script&);
 
-  void visit_octave_user_script (octave_user_script&);
+    void visit_octave_user_function (octave_user_function&);
 
-  void visit_octave_user_function (octave_user_function&);
+    void visit_octave_user_function_header (octave_user_function&);
 
-  void visit_octave_user_function_header (octave_user_function&);
+    void visit_octave_user_function_trailer (octave_user_function&);
 
-  void visit_octave_user_function_trailer (octave_user_function&);
+    void visit_function_def (tree_function_def&);
 
-  void visit_function_def (tree_function_def&);
+    void visit_identifier (tree_identifier&);
 
-  void visit_identifier (tree_identifier&);
+    void visit_if_clause (tree_if_clause&);
 
-  void visit_if_clause (tree_if_clause&);
+    void visit_if_command (tree_if_command&);
 
-  void visit_if_command (tree_if_command&);
+    void visit_if_command_list (tree_if_command_list&);
 
-  void visit_if_command_list (tree_if_command_list&);
+    void visit_index_expression (tree_index_expression&);
 
-  void visit_index_expression (tree_index_expression&);
+    void visit_matrix (tree_matrix&);
 
-  void visit_matrix (tree_matrix&);
+    void visit_cell (tree_cell&);
 
-  void visit_cell (tree_cell&);
+    void visit_multi_assignment (tree_multi_assignment&);
 
-  void visit_multi_assignment (tree_multi_assignment&);
+    void visit_no_op_command (tree_no_op_command&);
 
-  void visit_no_op_command (tree_no_op_command&);
+    void visit_anon_fcn_handle (tree_anon_fcn_handle&);
 
-  void visit_anon_fcn_handle (tree_anon_fcn_handle&);
+    void visit_constant (tree_constant&);
 
-  void visit_constant (tree_constant&);
+    void visit_fcn_handle (tree_fcn_handle&);
 
-  void visit_fcn_handle (tree_fcn_handle&);
+    void visit_funcall (tree_funcall&);
 
-  void visit_funcall (tree_funcall&);
+    void visit_parameter_list (tree_parameter_list&);
 
-  void visit_parameter_list (tree_parameter_list&);
+    void visit_postfix_expression (tree_postfix_expression&);
 
-  void visit_postfix_expression (tree_postfix_expression&);
+    void visit_prefix_expression (tree_prefix_expression&);
 
-  void visit_prefix_expression (tree_prefix_expression&);
+    void visit_return_command (tree_return_command&);
 
-  void visit_return_command (tree_return_command&);
+    void visit_return_list (tree_return_list&);
 
-  void visit_return_list (tree_return_list&);
+    void visit_simple_assignment (tree_simple_assignment&);
 
-  void visit_simple_assignment (tree_simple_assignment&);
+    void visit_statement (tree_statement&);
 
-  void visit_statement (tree_statement&);
+    void visit_statement_list (tree_statement_list&);
+
+    void visit_switch_case (tree_switch_case&);
 
-  void visit_statement_list (tree_statement_list&);
+    void visit_switch_case_list (tree_switch_case_list&);
 
-  void visit_switch_case (tree_switch_case&);
+    void visit_switch_command (tree_switch_command&);
 
-  void visit_switch_case_list (tree_switch_case_list&);
+    void visit_try_catch_command (tree_try_catch_command&);
 
-  void visit_switch_command (tree_switch_command&);
+    void visit_unwind_protect_command (tree_unwind_protect_command&);
 
-  void visit_try_catch_command (tree_try_catch_command&);
+    octave_value_list get_list (void) { return bp_list; }
+    octave_value_list get_cond_list (void) { return bp_cond_list; }
 
-  void visit_unwind_protect_command (tree_unwind_protect_command&);
+    int get_line (void) { return found ? line : 0; }
+
+  private:
 
-  octave_value_list get_list (void) { return bp_list; }
-  octave_value_list get_cond_list (void) { return bp_cond_list; }
+    void do_decl_command (tree_decl_command&);
 
-  int get_line (void) { return found ? line : 0; }
-
-private:
+    void take_action (tree& tr);
 
-  void do_decl_command (tree_decl_command&);
+    void take_action (tree_statement& stmt);
 
-  void take_action (tree& tr);
+    // Statement line number we are looking for.
+    int line;
 
-  void take_action (tree_statement& stmt);
+    // What to do.
+    action act;
 
-  // Statement line number we are looking for.
-  int line;
+    // Expression which must be true to break
+    std::string condition;
 
-  // What to do.
-  action act;
+    // Have we already found the line?
+    bool found;
 
-  // Expression which must be true to break
-  std::string condition;
+    // List of breakpoint line numbers.
+    octave_value_list bp_list;
 
-  // Have we already found the line?
-  bool found;
+    // List of breakpoint conditions.
+    octave_value_list bp_cond_list;
+  };
 
-  // List of breakpoint line numbers.
-  octave_value_list bp_list;
+  // TRUE means SIGINT should put us in the debugger at the next
+  // available breakpoint.
+  extern bool octave_debug_on_interrupt_state;
+}
 
-  // List of breakpoint conditions.
-  octave_value_list bp_cond_list;
-};
+#if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
 
-// TRUE means SIGINT should put us in the debugger at the next
-// available breakpoint.
-extern bool octave_debug_on_interrupt_state;
+OCTAVE_DEPRECATED ("use 'octave::tree_breakpoint' instead")
+typedef octave::tree_breakpoint tree_breakpoint;
 
 #endif
 
+#endif
diff --git a/libinterp/parse-tree/pt-cbinop.cc b/libinterp/parse-tree/pt-cbinop.cc
--- a/libinterp/parse-tree/pt-cbinop.cc
+++ b/libinterp/parse-tree/pt-cbinop.cc
@@ -27,85 +27,88 @@ along with Octave; see the file COPYING.
 #include "error.h"
 #include "ovl.h"
 #include "ov.h"
 #include "pt-cbinop.h"
 #include "pt-bp.h"
 #include "pt-unop.h"
 #include "pt-walk.h"
 
-typedef tree_expression* tree_expression_ptr_t;
+namespace octave
+{
+  typedef tree_expression* tree_expression_ptr_t;
 
-octave_value_list
-tree_compound_binary_expression::rvalue (int nargout)
-{
-  octave_value_list retval;
+  octave_value_list
+  tree_compound_binary_expression::rvalue (int nargout)
+  {
+    octave_value_list retval;
 
-  if (nargout > 1)
-    error ("binary operator '%s': invalid number of output arguments",
-           oper ().c_str ());
+    if (nargout > 1)
+      error ("binary operator '%s': invalid number of output arguments",
+             oper ().c_str ());
 
-  retval = rvalue1 (nargout);
+    retval = rvalue1 (nargout);
 
-  return retval;
-}
+    return retval;
+  }
 
-octave_value
-tree_compound_binary_expression::rvalue1 (int)
-{
-  octave_value retval;
+  octave_value
+  tree_compound_binary_expression::rvalue1 (int)
+  {
+    octave_value retval;
 
-  if (op_lhs)
-    {
-      octave_value a = op_lhs->rvalue1 ();
+    if (op_lhs)
+      {
+        octave_value a = op_lhs->rvalue1 ();
 
-      if (a.is_defined () && op_rhs)
-        {
-          octave_value b = op_rhs->rvalue1 ();
+        if (a.is_defined () && op_rhs)
+          {
+            octave_value b = op_rhs->rvalue1 ();
 
-          if (b.is_defined ())
-            retval = ::do_binary_op (etype, a, b);
-        }
-    }
+            if (b.is_defined ())
+              retval = ::do_binary_op (etype, a, b);
+          }
+      }
 
-  return retval;
+    return retval;
+  }
 }
 
 // If a tree expression is a transpose or hermitian transpose, return
 // the argument and corresponding operator.
 
 static octave_value::unary_op
-strip_trans_herm (tree_expression_ptr_t& exp)
+strip_trans_herm (octave::tree_expression_ptr_t& exp)
 {
   if (exp->is_unary_expression ())
     {
-      tree_unary_expression *uexp =
-        dynamic_cast<tree_unary_expression *> (exp);
+      octave::tree_unary_expression *uexp =
+        dynamic_cast<octave::tree_unary_expression *> (exp);
 
       octave_value::unary_op op = uexp->op_type ();
 
       if (op == octave_value::op_transpose
           || op == octave_value::op_hermitian)
         exp = uexp->operand ();
       else
         op = octave_value::unknown_unary_op;
 
       return op;
     }
   else
     return octave_value::unknown_unary_op;
 }
 
 static octave_value::unary_op
-strip_not (tree_expression_ptr_t& exp)
+strip_not (octave::tree_expression_ptr_t& exp)
 {
   if (exp->is_unary_expression ())
     {
-      tree_unary_expression *uexp =
-        dynamic_cast<tree_unary_expression *> (exp);
+      octave::tree_unary_expression *uexp =
+        dynamic_cast<octave::tree_unary_expression *> (exp);
 
       octave_value::unary_op op = uexp->op_type ();
 
       if (op == octave_value::op_not)
         exp = uexp->operand ();
       else
         op = octave_value::unknown_unary_op;
 
@@ -114,17 +117,18 @@ strip_not (tree_expression_ptr_t& exp)
   else
     return octave_value::unknown_unary_op;
 }
 
 // Possibly convert multiplication to trans_mul, mul_trans, herm_mul,
 // or mul_herm.
 
 static octave_value::compound_binary_op
-simplify_mul_op (tree_expression_ptr_t& a, tree_expression_ptr_t& b)
+simplify_mul_op (octave::tree_expression_ptr_t& a,
+                 octave::tree_expression_ptr_t& b)
 {
   octave_value::compound_binary_op retop
     = octave_value::unknown_compound_binary_op;
 
   octave_value::unary_op opa = strip_trans_herm (a);
 
   if (opa == octave_value::op_hermitian)
     retop = octave_value::op_herm_mul;
@@ -141,17 +145,18 @@ simplify_mul_op (tree_expression_ptr_t& 
     }
 
   return retop;
 }
 
 // Possibly convert left division to trans_ldiv or herm_ldiv.
 
 static octave_value::compound_binary_op
-simplify_ldiv_op (tree_expression_ptr_t& a, tree_expression_ptr_t&)
+simplify_ldiv_op (octave::tree_expression_ptr_t& a,
+                  octave::tree_expression_ptr_t&)
 {
   octave_value::compound_binary_op retop
     = octave_value::unknown_compound_binary_op;
 
   octave_value::unary_op opa = strip_trans_herm (a);
 
   if (opa == octave_value::op_hermitian)
     retop = octave_value::op_herm_ldiv;
@@ -159,17 +164,18 @@ simplify_ldiv_op (tree_expression_ptr_t&
     retop = octave_value::op_trans_ldiv;
 
   return retop;
 }
 
 // Possibly contract and/or with negation.
 
 static octave_value::compound_binary_op
-simplify_and_or_op (tree_expression_ptr_t& a, tree_expression_ptr_t& b,
+simplify_and_or_op (octave::tree_expression_ptr_t& a,
+                    octave::tree_expression_ptr_t& b,
                     octave_value::binary_op op)
 {
   octave_value::compound_binary_op retop
     = octave_value::unknown_compound_binary_op;
 
   octave_value::unary_op opa = strip_not (a);
 
   if (opa == octave_value::op_not)
@@ -190,45 +196,47 @@ simplify_and_or_op (tree_expression_ptr_
           else if (op == octave_value::op_el_or)
             retop = octave_value::op_el_or_not;
         }
     }
 
   return retop;
 }
 
-tree_binary_expression *
-maybe_compound_binary_expression (tree_expression *a, tree_expression *b,
-                                  int l, int c, octave_value::binary_op t)
+namespace octave
 {
-  tree_expression *ca = a;
-  tree_expression *cb = b;
-  octave_value::compound_binary_op ct;
+  tree_binary_expression *
+  maybe_compound_binary_expression (tree_expression *a, tree_expression *b,
+                                    int l, int c, octave_value::binary_op t)
+  {
+    tree_expression *ca = a;
+    tree_expression *cb = b;
+    octave_value::compound_binary_op ct;
 
-  switch (t)
-    {
-    case octave_value::op_mul:
-      ct = simplify_mul_op (ca, cb);
-      break;
+    switch (t)
+      {
+      case octave_value::op_mul:
+        ct = simplify_mul_op (ca, cb);
+        break;
 
-    case octave_value::op_ldiv:
-      ct = simplify_ldiv_op (ca, cb);
-      break;
+      case octave_value::op_ldiv:
+        ct = simplify_ldiv_op (ca, cb);
+        break;
 
-    case octave_value::op_el_and:
-    case octave_value::op_el_or:
-      ct = simplify_and_or_op (ca, cb, t);
-      break;
+      case octave_value::op_el_and:
+      case octave_value::op_el_or:
+        ct = simplify_and_or_op (ca, cb, t);
+        break;
 
-    default:
-      ct = octave_value::unknown_compound_binary_op;
-      break;
-    }
+      default:
+        ct = octave_value::unknown_compound_binary_op;
+        break;
+      }
 
-  tree_binary_expression *ret = (ct == octave_value::unknown_compound_binary_op)
-                                ? new tree_binary_expression (a, b, l, c, t)
-                                : new tree_compound_binary_expression (a, b, l,
-                                                                       c, t, ca,
-                                                                       cb, ct);
+    tree_binary_expression *ret = (ct == octave_value::unknown_compound_binary_op)
+      ? new tree_binary_expression (a, b, l, c, t)
+      : new tree_compound_binary_expression (a, b, l,
+                                             c, t, ca,
+                                             cb, ct);
 
-  return ret;
+    return ret;
+  }
 }
-
diff --git a/libinterp/parse-tree/pt-cbinop.h b/libinterp/parse-tree/pt-cbinop.h
--- a/libinterp/parse-tree/pt-cbinop.h
+++ b/libinterp/parse-tree/pt-cbinop.h
@@ -22,65 +22,73 @@ along with Octave; see the file COPYING.
 
 #if ! defined (octave_pt_cbinop_h)
 #define octave_pt_cbinop_h 1
 
 #include "octave-config.h"
 
 #include <string>
 
-class tree_walker;
-
 class octave_value;
 class octave_value_list;
 class octave_lvalue;
 
 #include "ov.h"
 #include "pt-binop.h"
 #include "symtab.h"
 
-// Binary expressions that can be reduced to compound operations
+namespace octave
+{
+  class tree_walker;
 
-class
-tree_compound_binary_expression : public tree_binary_expression
-{
-public:
+  // Binary expressions that can be reduced to compound operations
+
+  class tree_compound_binary_expression : public tree_binary_expression
+  {
+  public:
 
-  tree_compound_binary_expression (tree_expression *a, tree_expression *b,
-                                   int l, int c,
-                                   octave_value::binary_op t,
-                                   tree_expression *ca, tree_expression *cb,
-                                   octave_value::compound_binary_op ct)
-    : tree_binary_expression (a, b, l, c, t), op_lhs (ca), op_rhs (cb),
-      etype (ct) { }
+    tree_compound_binary_expression (tree_expression *a, tree_expression *b,
+                                     int l, int c,
+                                     octave_value::binary_op t,
+                                     tree_expression *ca, tree_expression *cb,
+                                     octave_value::compound_binary_op ct)
+      : tree_binary_expression (a, b, l, c, t), op_lhs (ca), op_rhs (cb),
+        etype (ct) { }
 
-  octave_value::compound_binary_op cop_type (void) const { return etype; }
+    octave_value::compound_binary_op cop_type (void) const { return etype; }
+
+    bool rvalue_ok (void) const { return true; }
 
-  bool rvalue_ok (void) const { return true; }
+    octave_value rvalue1 (int nargout = 1);
 
-  octave_value rvalue1 (int nargout = 1);
+    octave_value_list rvalue (int nargout);
 
-  octave_value_list rvalue (int nargout);
+  private:
 
-private:
+    tree_expression *op_lhs;
+    tree_expression *op_rhs;
+    octave_value::compound_binary_op etype;
 
-  tree_expression *op_lhs;
-  tree_expression *op_rhs;
-  octave_value::compound_binary_op etype;
+    // No copying!
+
+    tree_compound_binary_expression (const tree_compound_binary_expression&) = delete;
 
-  // No copying!
-
-  tree_compound_binary_expression (const tree_compound_binary_expression&) = delete;
+    tree_compound_binary_expression& operator =
+    (const tree_compound_binary_expression&) = delete;
+  };
 
-  tree_compound_binary_expression& operator =
-    (const tree_compound_binary_expression&) = delete;
-};
-
-// a "virtual constructor"
+  // a "virtual constructor"
 
-tree_binary_expression *
-maybe_compound_binary_expression (tree_expression *a, tree_expression *b,
-                                  int l = -1, int c = -1,
-                                  octave_value::binary_op t
-                                  = octave_value::unknown_binary_op);
+  tree_binary_expression *
+  maybe_compound_binary_expression (tree_expression *a, tree_expression *b,
+                                    int l = -1, int c = -1,
+                                    octave_value::binary_op t
+                                    = octave_value::unknown_binary_op);
+}
+
+#if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
+
+OCTAVE_DEPRECATED ("use 'octave::tree_compound_binary_expression' instead")
+typedef octave::tree_compound_binary_expression tree_compound_binary_expression;
 
 #endif
 
+#endif
diff --git a/libinterp/parse-tree/pt-cell.cc b/libinterp/parse-tree/pt-cell.cc
--- a/libinterp/parse-tree/pt-cell.cc
+++ b/libinterp/parse-tree/pt-cell.cc
@@ -29,85 +29,87 @@ along with Octave; see the file COPYING.
 #include "Cell.h"
 #include "ovl.h"
 #include "pt-arg-list.h"
 #include "pt-exp.h"
 #include "pt-cell.h"
 #include "pt-walk.h"
 #include "ov.h"
 
-octave_value
-tree_cell::rvalue1 (int)
+namespace octave
 {
-  octave_value retval;
-
-  octave_idx_type nr = length ();
-  octave_idx_type nc = -1;
+  octave_value
+  tree_cell::rvalue1 (int)
+  {
+    octave_value retval;
 
-  Cell val;
+    octave_idx_type nr = length ();
+    octave_idx_type nc = -1;
 
-  octave_idx_type i = 0;
+    Cell val;
 
-  for (tree_argument_list* elt : *this)
-    {
-      octave_value_list row = elt->convert_to_const_vector ();
+    octave_idx_type i = 0;
+
+    for (tree_argument_list* elt : *this)
+      {
+        octave_value_list row = elt->convert_to_const_vector ();
 
-      if (nr == 1)
-        // Optimize the single row case.
-        val = row.cell_value ();
-      else if (nc < 0)
-        {
-          nc = row.length ();
+        if (nr == 1)
+          // Optimize the single row case.
+          val = row.cell_value ();
+        else if (nc < 0)
+          {
+            nc = row.length ();
 
-          val = Cell (nr, nc);
-        }
-      else
-        {
-          octave_idx_type this_nc = row.length ();
+            val = Cell (nr, nc);
+          }
+        else
+          {
+            octave_idx_type this_nc = row.length ();
 
-          if (this_nc != nc)
-            {
-              if (this_nc == 0)
-                continue;  // blank line
-              else
-                error ("number of columns must match");
-            }
-        }
+            if (this_nc != nc)
+              {
+                if (this_nc == 0)
+                  continue;  // blank line
+                else
+                  error ("number of columns must match");
+              }
+          }
 
-      for (octave_idx_type j = 0; j < nc; j++)
-        val(i,j) = row(j);
+        for (octave_idx_type j = 0; j < nc; j++)
+          val(i,j) = row(j);
 
-      i++;
-    }
+        i++;
+      }
 
-  if (i < nr)
-    val.resize (dim_vector (i, nc));  // there were blank rows
-  retval = val;
+    if (i < nr)
+      val.resize (dim_vector (i, nc));  // there were blank rows
+    retval = val;
 
-  return retval;
-}
+    return retval;
+  }
 
-octave_value_list
-tree_cell::rvalue (int nargout)
-{
-  if (nargout > 1)
-    error ("invalid number of output arguments for cell array");
+  octave_value_list
+  tree_cell::rvalue (int nargout)
+  {
+    if (nargout > 1)
+      error ("invalid number of output arguments for cell array");
 
-  return rvalue1 (nargout);
-}
+    return rvalue1 (nargout);
+  }
 
-tree_expression *
-tree_cell::dup (symbol_table::scope_id scope,
-                symbol_table::context_id context) const
-{
-  tree_cell *new_cell = new tree_cell (0, line (), column ());
+  tree_expression *
+  tree_cell::dup (symbol_table::scope_id scope,
+                  symbol_table::context_id context) const
+  {
+    tree_cell *new_cell = new tree_cell (0, line (), column ());
 
-  new_cell->copy_base (*this, scope, context);
+    new_cell->copy_base (*this, scope, context);
 
-  return new_cell;
-}
+    return new_cell;
+  }
 
-void
-tree_cell::accept (tree_walker& tw)
-{
-  tw.visit_cell (*this);
+  void
+  tree_cell::accept (tree_walker& tw)
+  {
+    tw.visit_cell (*this);
+  }
 }
-
diff --git a/libinterp/parse-tree/pt-cell.h b/libinterp/parse-tree/pt-cell.h
--- a/libinterp/parse-tree/pt-cell.h
+++ b/libinterp/parse-tree/pt-cell.h
@@ -24,50 +24,59 @@ along with Octave; see the file COPYING.
 #define octave_pt_cell_h 1
 
 #include "octave-config.h"
 
 #include <iosfwd>
 
 class octave_value;
 class octave_value_list;
-class tree_argument_list;
-
-class tree_walker;
 
 #include "pt-mat.h"
 #include "symtab.h"
 
-// General cells.
+namespace octave
+{
+  class tree_argument_list;
 
-class
-tree_cell : public tree_array_list
-{
-public:
+  class tree_walker;
+
+  // General cells.
 
-  tree_cell (tree_argument_list *row = 0, int l = -1, int c = -1)
-    : tree_array_list (row, l, c)
-  { }
+  class tree_cell : public tree_array_list
+  {
+  public:
 
-  // No copying!
+    tree_cell (tree_argument_list *row = 0, int l = -1, int c = -1)
+      : tree_array_list (row, l, c)
+    { }
 
-  tree_cell (const tree_cell&) = delete;
+    // No copying!
+
+    tree_cell (const tree_cell&) = delete;
+
+    tree_cell& operator = (const tree_cell&) = delete;
 
-  tree_cell& operator = (const tree_cell&) = delete;
+    ~tree_cell (void) = default;
 
-  ~tree_cell (void) = default;
+    bool is_cell (void) const { return true; }
 
-  bool is_cell (void) const { return true; }
+    bool rvalue_ok (void) const { return true; }
 
-  bool rvalue_ok (void) const { return true; }
+    octave_value rvalue1 (int nargout = 1);
+
+    octave_value_list rvalue (int);
 
-  octave_value rvalue1 (int nargout = 1);
-
-  octave_value_list rvalue (int);
+    tree_expression *dup (symbol_table::scope_id scope,
+                          symbol_table::context_id context) const;
 
-  tree_expression *dup (symbol_table::scope_id scope,
-                        symbol_table::context_id context) const;
+    void accept (tree_walker& tw);
+  };
+}
 
-  void accept (tree_walker& tw);
-};
+#if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
+
+OCTAVE_DEPRECATED ("use 'octave::tree_cell' instead")
+typedef octave::tree_cell tree_cell;
 
 #endif
 
+#endif
diff --git a/libinterp/parse-tree/pt-check.cc b/libinterp/parse-tree/pt-check.cc
--- a/libinterp/parse-tree/pt-check.cc
+++ b/libinterp/parse-tree/pt-check.cc
@@ -24,541 +24,543 @@ along with Octave; see the file COPYING.
 #  include "config.h"
 #endif
 
 #include "error.h"
 #include "input.h"
 #include "ov-usr-fcn.h"
 #include "pt-all.h"
 
-void
-tree_checker::visit_argument_list (tree_argument_list& lst)
+namespace octave
 {
-  tree_argument_list::iterator p = lst.begin ();
+  void
+  tree_checker::visit_argument_list (tree_argument_list& lst)
+  {
+    tree_argument_list::iterator p = lst.begin ();
 
-  while (p != lst.end ())
-    {
-      tree_expression *elt = *p++;
+    while (p != lst.end ())
+      {
+        tree_expression *elt = *p++;
 
-      if (elt)
-        {
-          if (do_lvalue_check && ! elt->lvalue_ok ())
-            errmsg ("invalid lvalue in multiple assignment", elt->line ());
-        }
-    }
-}
+        if (elt)
+          {
+            if (do_lvalue_check && ! elt->lvalue_ok ())
+              errmsg ("invalid lvalue in multiple assignment", elt->line ());
+          }
+      }
+  }
 
-void
-tree_checker::visit_binary_expression (tree_binary_expression& expr)
-{
-  tree_expression *op1 = expr.lhs ();
+  void
+  tree_checker::visit_binary_expression (tree_binary_expression& expr)
+  {
+    tree_expression *op1 = expr.lhs ();
 
-  if (op1)
-    op1->accept (*this);
+    if (op1)
+      op1->accept (*this);
 
-  tree_expression *op2 = expr.rhs ();
-
-  if (op2)
-    op2->accept (*this);
-}
+    tree_expression *op2 = expr.rhs ();
 
-void
-tree_checker::visit_break_command (tree_break_command&)
-{ }
+    if (op2)
+      op2->accept (*this);
+  }
+
+  void
+  tree_checker::visit_break_command (tree_break_command&)
+  { }
 
-void
-tree_checker::visit_colon_expression (tree_colon_expression& expr)
-{
-  tree_expression *op1 = expr.base ();
+  void
+  tree_checker::visit_colon_expression (tree_colon_expression& expr)
+  {
+    tree_expression *op1 = expr.base ();
 
-  if (op1)
-    op1->accept (*this);
+    if (op1)
+      op1->accept (*this);
 
-  tree_expression *op3 = expr.increment ();
+    tree_expression *op3 = expr.increment ();
 
-  if (op3)
-    op3->accept (*this);
+    if (op3)
+      op3->accept (*this);
 
-  tree_expression *op2 = expr.limit ();
+    tree_expression *op2 = expr.limit ();
 
-  if (op2)
-    op2->accept (*this);
-}
+    if (op2)
+      op2->accept (*this);
+  }
 
-void
-tree_checker::visit_continue_command (tree_continue_command&)
-{ }
+  void
+  tree_checker::visit_continue_command (tree_continue_command&)
+  { }
 
-void
-tree_checker::do_decl_command (tree_decl_command& cmd)
-{
-  tree_decl_init_list *init_list = cmd.initializer_list ();
+  void
+  tree_checker::do_decl_command (tree_decl_command& cmd)
+  {
+    tree_decl_init_list *init_list = cmd.initializer_list ();
 
-  if (init_list)
-    init_list->accept (*this);
-}
+    if (init_list)
+      init_list->accept (*this);
+  }
 
-void
-tree_checker::visit_global_command (tree_global_command& cmd)
-{
-  do_decl_command (cmd);
-}
+  void
+  tree_checker::visit_global_command (tree_global_command& cmd)
+  {
+    do_decl_command (cmd);
+  }
 
-void
-tree_checker::visit_persistent_command (tree_persistent_command& cmd)
-{
-  do_decl_command (cmd);
-}
+  void
+  tree_checker::visit_persistent_command (tree_persistent_command& cmd)
+  {
+    do_decl_command (cmd);
+  }
 
-void
-tree_checker::visit_decl_elt (tree_decl_elt& cmd)
-{
-  tree_identifier *id = cmd.ident ();
+  void
+  tree_checker::visit_decl_elt (tree_decl_elt& cmd)
+  {
+    tree_identifier *id = cmd.ident ();
 
-  if (id)
-    id->accept (*this);
+    if (id)
+      id->accept (*this);
 
-  tree_expression *expr = cmd.expression ();
+    tree_expression *expr = cmd.expression ();
 
-  if (expr)
-    expr->accept (*this);
-}
+    if (expr)
+      expr->accept (*this);
+  }
 
-void
-tree_checker::visit_decl_init_list (tree_decl_init_list& lst)
-{
-  tree_decl_init_list::iterator p = lst.begin ();
+  void
+  tree_checker::visit_decl_init_list (tree_decl_init_list& lst)
+  {
+    tree_decl_init_list::iterator p = lst.begin ();
 
-  while (p != lst.end ())
-    {
-      tree_decl_elt *elt = *p++;
+    while (p != lst.end ())
+      {
+        tree_decl_elt *elt = *p++;
 
-      if (elt)
-        elt->accept (*this);
-    }
-}
+        if (elt)
+          elt->accept (*this);
+      }
+  }
 
-void
-tree_checker::visit_simple_for_command (tree_simple_for_command& cmd)
-{
-  tree_expression *lhs = cmd.left_hand_side ();
+  void
+  tree_checker::visit_simple_for_command (tree_simple_for_command& cmd)
+  {
+    tree_expression *lhs = cmd.left_hand_side ();
 
-  if (lhs)
-    {
-      if (! lhs->lvalue_ok ())
-        errmsg ("invalid lvalue in for command", cmd.line ());
-    }
+    if (lhs)
+      {
+        if (! lhs->lvalue_ok ())
+          errmsg ("invalid lvalue in for command", cmd.line ());
+      }
 
-  tree_expression *expr = cmd.control_expr ();
+    tree_expression *expr = cmd.control_expr ();
 
-  if (expr)
-    expr->accept (*this);
+    if (expr)
+      expr->accept (*this);
 
-  tree_expression *maxproc = cmd.maxproc_expr ();
+    tree_expression *maxproc = cmd.maxproc_expr ();
 
-  if (maxproc)
-    maxproc->accept (*this);
+    if (maxproc)
+      maxproc->accept (*this);
 
-  tree_statement_list *list = cmd.body ();
+    tree_statement_list *list = cmd.body ();
 
-  if (list)
-    list->accept (*this);
-}
+    if (list)
+      list->accept (*this);
+  }
 
-void
-tree_checker::visit_complex_for_command (tree_complex_for_command& cmd)
-{
-  tree_argument_list *lhs = cmd.left_hand_side ();
+  void
+  tree_checker::visit_complex_for_command (tree_complex_for_command& cmd)
+  {
+    tree_argument_list *lhs = cmd.left_hand_side ();
 
-  if (lhs)
-    {
-      int len = lhs->length ();
+    if (lhs)
+      {
+        int len = lhs->length ();
 
-      if (len == 0 || len > 2)
-        errmsg ("invalid number of output arguments in for command",
-                cmd.line ());
+        if (len == 0 || len > 2)
+          errmsg ("invalid number of output arguments in for command",
+                  cmd.line ());
 
-      do_lvalue_check = true;
+        do_lvalue_check = true;
 
-      lhs->accept (*this);
+        lhs->accept (*this);
 
-      do_lvalue_check = false;
-    }
+        do_lvalue_check = false;
+      }
 
-  tree_expression *expr = cmd.control_expr ();
+    tree_expression *expr = cmd.control_expr ();
 
-  if (expr)
-    expr->accept (*this);
+    if (expr)
+      expr->accept (*this);
 
-  tree_statement_list *list = cmd.body ();
+    tree_statement_list *list = cmd.body ();
 
-  if (list)
-    list->accept (*this);
-}
+    if (list)
+      list->accept (*this);
+  }
 
-void
-tree_checker::visit_octave_user_script (octave_user_script& fcn)
-{
-  tree_statement_list *cmd_list = fcn.body ();
+  void
+  tree_checker::visit_octave_user_script (octave_user_script& fcn)
+  {
+    tree_statement_list *cmd_list = fcn.body ();
 
-  if (cmd_list)
-    cmd_list->accept (*this);
-}
+    if (cmd_list)
+      cmd_list->accept (*this);
+  }
 
-void
-tree_checker::visit_octave_user_function (octave_user_function& fcn)
-{
-  tree_statement_list *cmd_list = fcn.body ();
+  void
+  tree_checker::visit_octave_user_function (octave_user_function& fcn)
+  {
+    tree_statement_list *cmd_list = fcn.body ();
 
-  if (cmd_list)
-    cmd_list->accept (*this);
-}
+    if (cmd_list)
+      cmd_list->accept (*this);
+  }
 
-void
-tree_checker::visit_function_def (tree_function_def& fdef)
-{
-  octave_value fcn = fdef.function ();
+  void
+  tree_checker::visit_function_def (tree_function_def& fdef)
+  {
+    octave_value fcn = fdef.function ();
 
-  octave_function *f = fcn.function_value ();
+    octave_function *f = fcn.function_value ();
 
-  if (f)
-    f->accept (*this);
-}
+    if (f)
+      f->accept (*this);
+  }
 
-void
-tree_checker::visit_identifier (tree_identifier& /* id */)
-{ }
+  void
+  tree_checker::visit_identifier (tree_identifier& /* id */)
+  { }
 
-void
-tree_checker::visit_if_clause (tree_if_clause& cmd)
-{
-  tree_expression *expr = cmd.condition ();
+  void
+  tree_checker::visit_if_clause (tree_if_clause& cmd)
+  {
+    tree_expression *expr = cmd.condition ();
 
-  if (expr)
-    expr->accept (*this);
+    if (expr)
+      expr->accept (*this);
 
-  tree_statement_list *list = cmd.commands ();
+    tree_statement_list *list = cmd.commands ();
 
-  if (list)
-    list->accept (*this);
-}
+    if (list)
+      list->accept (*this);
+  }
 
-void
-tree_checker::visit_if_command (tree_if_command& cmd)
-{
-  tree_if_command_list *list = cmd.cmd_list ();
+  void
+  tree_checker::visit_if_command (tree_if_command& cmd)
+  {
+    tree_if_command_list *list = cmd.cmd_list ();
 
-  if (list)
-    list->accept (*this);
-}
+    if (list)
+      list->accept (*this);
+  }
 
-void
-tree_checker::visit_if_command_list (tree_if_command_list& lst)
-{
-  tree_if_command_list::iterator p = lst.begin ();
+  void
+  tree_checker::visit_if_command_list (tree_if_command_list& lst)
+  {
+    tree_if_command_list::iterator p = lst.begin ();
 
-  while (p != lst.end ())
-    {
-      tree_if_clause *elt = *p++;
+    while (p != lst.end ())
+      {
+        tree_if_clause *elt = *p++;
 
-      if (elt)
-        elt->accept (*this);
-    }
-}
+        if (elt)
+          elt->accept (*this);
+      }
+  }
 
-void
-tree_checker::visit_index_expression (tree_index_expression& expr)
-{
-  tree_expression *e = expr.expression ();
+  void
+  tree_checker::visit_index_expression (tree_index_expression& expr)
+  {
+    tree_expression *e = expr.expression ();
 
-  if (e)
-    e->accept (*this);
+    if (e)
+      e->accept (*this);
 
-  std::list<tree_argument_list *> lst = expr.arg_lists ();
+    std::list<tree_argument_list *> lst = expr.arg_lists ();
 
-  std::list<tree_argument_list *>::iterator p = lst.begin ();
+    std::list<tree_argument_list *>::iterator p = lst.begin ();
 
-  while (p != lst.end ())
-    {
-      tree_argument_list *elt = *p++;
+    while (p != lst.end ())
+      {
+        tree_argument_list *elt = *p++;
 
-      if (elt)
-        elt->accept (*this);
-    }
-}
+        if (elt)
+          elt->accept (*this);
+      }
+  }
 
-void
-tree_checker::visit_matrix (tree_matrix& lst)
-{
-  tree_matrix::iterator p = lst.begin ();
+  void
+  tree_checker::visit_matrix (tree_matrix& lst)
+  {
+    tree_matrix::iterator p = lst.begin ();
 
-  while (p != lst.end ())
-    {
-      tree_argument_list *elt = *p++;
+    while (p != lst.end ())
+      {
+        tree_argument_list *elt = *p++;
 
-      if (elt)
-        elt->accept (*this);
-    }
-}
+        if (elt)
+          elt->accept (*this);
+      }
+  }
 
-void
-tree_checker::visit_cell (tree_cell& lst)
-{
-  tree_matrix::iterator p = lst.begin ();
+  void
+  tree_checker::visit_cell (tree_cell& lst)
+  {
+    tree_matrix::iterator p = lst.begin ();
 
-  while (p != lst.end ())
-    {
-      tree_argument_list *elt = *p++;
+    while (p != lst.end ())
+      {
+        tree_argument_list *elt = *p++;
 
-      if (elt)
-        elt->accept (*this);
-    }
-}
+        if (elt)
+          elt->accept (*this);
+      }
+  }
 
-void
-tree_checker::visit_multi_assignment (tree_multi_assignment& expr)
-{
-  tree_argument_list *lhs = expr.left_hand_side ();
+  void
+  tree_checker::visit_multi_assignment (tree_multi_assignment& expr)
+  {
+    tree_argument_list *lhs = expr.left_hand_side ();
 
-  if (lhs)
-    {
-      do_lvalue_check = true;
+    if (lhs)
+      {
+        do_lvalue_check = true;
 
-      lhs->accept (*this);
+        lhs->accept (*this);
 
-      do_lvalue_check = false;
-    }
+        do_lvalue_check = false;
+      }
 
-  tree_expression *rhs = expr.right_hand_side ();
+    tree_expression *rhs = expr.right_hand_side ();
 
-  if (rhs)
-    rhs->accept (*this);
-}
+    if (rhs)
+      rhs->accept (*this);
+  }
 
-void
-tree_checker::visit_no_op_command (tree_no_op_command& /* cmd */)
-{ }
+  void
+  tree_checker::visit_no_op_command (tree_no_op_command& /* cmd */)
+  { }
 
-void
-tree_checker::visit_anon_fcn_handle (tree_anon_fcn_handle& /* afh */)
-{ }
+  void
+  tree_checker::visit_anon_fcn_handle (tree_anon_fcn_handle& /* afh */)
+  { }
 
-void
-tree_checker::visit_constant (tree_constant& /* val */)
-{ }
+  void
+  tree_checker::visit_constant (tree_constant& /* val */)
+  { }
 
-void
-tree_checker::visit_fcn_handle (tree_fcn_handle& /* fh */)
-{ }
+  void
+  tree_checker::visit_fcn_handle (tree_fcn_handle& /* fh */)
+  { }
 
-void
-tree_checker::visit_funcall (tree_funcall& /* fc */)
-{ }
+  void
+  tree_checker::visit_funcall (tree_funcall& /* fc */)
+  { }
 
-void
-tree_checker::visit_parameter_list (tree_parameter_list& lst)
-{
-  tree_parameter_list::iterator p = lst.begin ();
+  void
+  tree_checker::visit_parameter_list (tree_parameter_list& lst)
+  {
+    tree_parameter_list::iterator p = lst.begin ();
 
-  while (p != lst.end ())
-    {
-      tree_decl_elt *elt = *p++;
+    while (p != lst.end ())
+      {
+        tree_decl_elt *elt = *p++;
 
-      if (elt)
-        elt->accept (*this);
-    }
-}
+        if (elt)
+          elt->accept (*this);
+      }
+  }
 
-void
-tree_checker::visit_postfix_expression (tree_postfix_expression& expr)
-{
-  tree_expression *e = expr.operand ();
+  void
+  tree_checker::visit_postfix_expression (tree_postfix_expression& expr)
+  {
+    tree_expression *e = expr.operand ();
 
-  if (e)
-    e->accept (*this);
-}
+    if (e)
+      e->accept (*this);
+  }
 
-void
-tree_checker::visit_prefix_expression (tree_prefix_expression& expr)
-{
-  tree_expression *e = expr.operand ();
+  void
+  tree_checker::visit_prefix_expression (tree_prefix_expression& expr)
+  {
+    tree_expression *e = expr.operand ();
 
-  if (e)
-    e->accept (*this);
-}
+    if (e)
+      e->accept (*this);
+  }
 
-void
-tree_checker::visit_return_command (tree_return_command&)
-{ }
+  void
+  tree_checker::visit_return_command (tree_return_command&)
+  { }
 
-void
-tree_checker::visit_return_list (tree_return_list& lst)
-{
-  tree_return_list::iterator p = lst.begin ();
+  void
+  tree_checker::visit_return_list (tree_return_list& lst)
+  {
+    tree_return_list::iterator p = lst.begin ();
 
-  while (p != lst.end ())
-    {
-      tree_index_expression *elt = *p++;
+    while (p != lst.end ())
+      {
+        tree_index_expression *elt = *p++;
 
-      if (elt)
-        elt->accept (*this);
-    }
-}
+        if (elt)
+          elt->accept (*this);
+      }
+  }
 
-void
-tree_checker::visit_simple_assignment (tree_simple_assignment& expr)
-{
-  tree_expression *lhs = expr.left_hand_side ();
+  void
+  tree_checker::visit_simple_assignment (tree_simple_assignment& expr)
+  {
+    tree_expression *lhs = expr.left_hand_side ();
 
-  if (lhs)
-    {
-      if (! lhs->lvalue_ok ())
-        errmsg ("invalid lvalue in assignment", expr.line ());
-    }
+    if (lhs)
+      {
+        if (! lhs->lvalue_ok ())
+          errmsg ("invalid lvalue in assignment", expr.line ());
+      }
 
-  tree_expression *rhs = expr.right_hand_side ();
+    tree_expression *rhs = expr.right_hand_side ();
 
-  if (rhs)
-    rhs->accept (*this);
-}
+    if (rhs)
+      rhs->accept (*this);
+  }
 
-void
-tree_checker::visit_statement (tree_statement& stmt)
-{
-  tree_command *cmd = stmt.command ();
+  void
+  tree_checker::visit_statement (tree_statement& stmt)
+  {
+    tree_command *cmd = stmt.command ();
 
-  if (cmd)
-    cmd->accept (*this);
-  else
-    {
-      tree_expression *expr = stmt.expression ();
+    if (cmd)
+      cmd->accept (*this);
+    else
+      {
+        tree_expression *expr = stmt.expression ();
 
-      if (expr)
-        expr->accept (*this);
-    }
-}
+        if (expr)
+          expr->accept (*this);
+      }
+  }
 
-void
-tree_checker::visit_statement_list (tree_statement_list& lst)
-{
-  for (tree_statement* elt : lst)
-    {
-      if (elt)
-        elt->accept (*this);
-    }
-}
+  void
+  tree_checker::visit_statement_list (tree_statement_list& lst)
+  {
+    for (tree_statement* elt : lst)
+      {
+        if (elt)
+          elt->accept (*this);
+      }
+  }
 
-void
-tree_checker::visit_switch_case (tree_switch_case& cs)
-{
-  tree_expression *label = cs.case_label ();
+  void
+  tree_checker::visit_switch_case (tree_switch_case& cs)
+  {
+    tree_expression *label = cs.case_label ();
 
-  if (label)
-    label->accept (*this);
+    if (label)
+      label->accept (*this);
 
-  tree_statement_list *list = cs.commands ();
+    tree_statement_list *list = cs.commands ();
 
-  if (list)
-    list->accept (*this);
-}
+    if (list)
+      list->accept (*this);
+  }
 
-void
-tree_checker::visit_switch_case_list (tree_switch_case_list& lst)
-{
-  tree_switch_case_list::iterator p = lst.begin ();
+  void
+  tree_checker::visit_switch_case_list (tree_switch_case_list& lst)
+  {
+    tree_switch_case_list::iterator p = lst.begin ();
 
-  while (p != lst.end ())
-    {
-      tree_switch_case *elt = *p++;
+    while (p != lst.end ())
+      {
+        tree_switch_case *elt = *p++;
 
-      if (elt)
-        elt->accept (*this);
-    }
-}
+        if (elt)
+          elt->accept (*this);
+      }
+  }
 
-void
-tree_checker::visit_switch_command (tree_switch_command& cmd)
-{
-  tree_expression *expr = cmd.switch_value ();
+  void
+  tree_checker::visit_switch_command (tree_switch_command& cmd)
+  {
+    tree_expression *expr = cmd.switch_value ();
 
-  if (expr)
-    expr->accept (*this);
+    if (expr)
+      expr->accept (*this);
 
-  tree_switch_case_list *list = cmd.case_list ();
+    tree_switch_case_list *list = cmd.case_list ();
 
-  if (list)
-    list->accept (*this);
-}
+    if (list)
+      list->accept (*this);
+  }
 
-void
-tree_checker::visit_try_catch_command (tree_try_catch_command& cmd)
-{
-  tree_statement_list *try_code = cmd.body ();
+  void
+  tree_checker::visit_try_catch_command (tree_try_catch_command& cmd)
+  {
+    tree_statement_list *try_code = cmd.body ();
 
-  tree_identifier *expr_id = cmd.identifier ();
+    tree_identifier *expr_id = cmd.identifier ();
 
-  if (expr_id)
-    {
-      if (! expr_id->lvalue_ok ())
-        errmsg ("invalid lvalue used for identifier in try-catch command",
-                cmd.line ());
-    }
+    if (expr_id)
+      {
+        if (! expr_id->lvalue_ok ())
+          errmsg ("invalid lvalue used for identifier in try-catch command",
+                  cmd.line ());
+      }
 
-  if (try_code)
-    try_code->accept (*this);
+    if (try_code)
+      try_code->accept (*this);
 
-  tree_statement_list *catch_code = cmd.cleanup ();
+    tree_statement_list *catch_code = cmd.cleanup ();
 
-  if (catch_code)
-    catch_code->accept (*this);
-}
+    if (catch_code)
+      catch_code->accept (*this);
+  }
 
-void
-tree_checker::visit_unwind_protect_command (tree_unwind_protect_command& cmd)
-{
-  tree_statement_list *unwind_protect_code = cmd.body ();
+  void
+  tree_checker::visit_unwind_protect_command (tree_unwind_protect_command& cmd)
+  {
+    tree_statement_list *unwind_protect_code = cmd.body ();
 
-  if (unwind_protect_code)
-    unwind_protect_code->accept (*this);
+    if (unwind_protect_code)
+      unwind_protect_code->accept (*this);
 
-  tree_statement_list *cleanup_code = cmd.cleanup ();
+    tree_statement_list *cleanup_code = cmd.cleanup ();
 
-  if (cleanup_code)
-    cleanup_code->accept (*this);
-}
+    if (cleanup_code)
+      cleanup_code->accept (*this);
+  }
 
-void
-tree_checker::visit_while_command (tree_while_command& cmd)
-{
-  tree_expression *expr = cmd.condition ();
+  void
+  tree_checker::visit_while_command (tree_while_command& cmd)
+  {
+    tree_expression *expr = cmd.condition ();
 
-  if (expr)
-    expr->accept (*this);
+    if (expr)
+      expr->accept (*this);
 
-  tree_statement_list *list = cmd.body ();
+    tree_statement_list *list = cmd.body ();
 
-  if (list)
-    list->accept (*this);
-}
+    if (list)
+      list->accept (*this);
+  }
 
-void
-tree_checker::visit_do_until_command (tree_do_until_command& cmd)
-{
-  tree_statement_list *list = cmd.body ();
+  void
+  tree_checker::visit_do_until_command (tree_do_until_command& cmd)
+  {
+    tree_statement_list *list = cmd.body ();
 
-  if (list)
-    list->accept (*this);
+    if (list)
+      list->accept (*this);
 
-  tree_expression *expr = cmd.condition ();
+    tree_expression *expr = cmd.condition ();
 
-  if (expr)
-    expr->accept (*this);
-}
+    if (expr)
+      expr->accept (*this);
+  }
 
-void
-tree_checker::errmsg (const std::string& msg, int line)
-{
-  if (file_name.empty ())
-    error ("%s", msg.c_str ());
-  else
-    error ("%s: %d: %s", file_name.c_str (), line, msg.c_str ());
+  void
+  tree_checker::errmsg (const std::string& msg, int line)
+  {
+    if (file_name.empty ())
+      error ("%s", msg.c_str ());
+    else
+      error ("%s: %d: %s", file_name.c_str (), line, msg.c_str ());
+  }
 }
-
diff --git a/libinterp/parse-tree/pt-check.h b/libinterp/parse-tree/pt-check.h
--- a/libinterp/parse-tree/pt-check.h
+++ b/libinterp/parse-tree/pt-check.h
@@ -22,125 +22,133 @@ along with Octave; see the file COPYING.
 
 #if ! defined (octave_pt_check_h)
 #define octave_pt_check_h 1
 
 #include "octave-config.h"
 
 #include "pt-walk.h"
 
-class tree_decl_command;
-
-// How to check the semantics of the code that the parse trees represent.
-
-class
-tree_checker : public tree_walker
+namespace octave
 {
-public:
+  class tree_decl_command;
+
+  // How to check the semantics of the code that the parse trees represent.
 
-  tree_checker (void)
-    : do_lvalue_check (false), file_name () { }
+  class tree_checker : public tree_walker
+  {
+  public:
 
-  // No copying!
+    tree_checker (void)
+      : do_lvalue_check (false), file_name () { }
 
-  tree_checker (const tree_checker&) = delete;
+    // No copying!
+
+    tree_checker (const tree_checker&) = delete;
 
-  tree_checker& operator = (const tree_checker&) = delete;
+    tree_checker& operator = (const tree_checker&) = delete;
 
-  ~tree_checker (void) = default;
+    ~tree_checker (void) = default;
 
-  void visit_argument_list (tree_argument_list&);
+    void visit_argument_list (tree_argument_list&);
 
-  void visit_binary_expression (tree_binary_expression&);
+    void visit_binary_expression (tree_binary_expression&);
 
-  void visit_break_command (tree_break_command&);
+    void visit_break_command (tree_break_command&);
 
-  void visit_colon_expression (tree_colon_expression&);
+    void visit_colon_expression (tree_colon_expression&);
 
-  void visit_continue_command(tree_continue_command&);
+    void visit_continue_command(tree_continue_command&);
+
+    void visit_global_command (tree_global_command&);
 
-  void visit_global_command (tree_global_command&);
+    void visit_persistent_command (tree_persistent_command&);
 
-  void visit_persistent_command (tree_persistent_command&);
+    void visit_decl_elt (tree_decl_elt&);
 
-  void visit_decl_elt (tree_decl_elt&);
+    void visit_decl_init_list (tree_decl_init_list&);
 
-  void visit_decl_init_list (tree_decl_init_list&);
+    void visit_simple_for_command (tree_simple_for_command&);
 
-  void visit_simple_for_command (tree_simple_for_command&);
+    void visit_complex_for_command (tree_complex_for_command&);
 
-  void visit_complex_for_command (tree_complex_for_command&);
+    void visit_octave_user_script (octave_user_script&);
 
-  void visit_octave_user_script (octave_user_script&);
+    void visit_octave_user_function (octave_user_function&);
+
+    void visit_function_def (tree_function_def&);
 
-  void visit_octave_user_function (octave_user_function&);
+    void visit_identifier (tree_identifier&);
 
-  void visit_function_def (tree_function_def&);
+    void visit_if_clause (tree_if_clause&);
 
-  void visit_identifier (tree_identifier&);
+    void visit_if_command (tree_if_command&);
 
-  void visit_if_clause (tree_if_clause&);
+    void visit_if_command_list (tree_if_command_list&);
 
-  void visit_if_command (tree_if_command&);
+    void visit_index_expression (tree_index_expression&);
 
-  void visit_if_command_list (tree_if_command_list&);
+    void visit_matrix (tree_matrix&);
 
-  void visit_index_expression (tree_index_expression&);
+    void visit_cell (tree_cell&);
 
-  void visit_matrix (tree_matrix&);
+    void visit_multi_assignment (tree_multi_assignment&);
 
-  void visit_cell (tree_cell&);
+    void visit_no_op_command (tree_no_op_command&);
 
-  void visit_multi_assignment (tree_multi_assignment&);
+    void visit_anon_fcn_handle (tree_anon_fcn_handle&);
 
-  void visit_no_op_command (tree_no_op_command&);
+    void visit_constant (tree_constant&);
 
-  void visit_anon_fcn_handle (tree_anon_fcn_handle&);
+    void visit_fcn_handle (tree_fcn_handle&);
 
-  void visit_constant (tree_constant&);
+    void visit_funcall (tree_funcall&);
 
-  void visit_fcn_handle (tree_fcn_handle&);
+    void visit_parameter_list (tree_parameter_list&);
+
+    void visit_postfix_expression (tree_postfix_expression&);
 
-  void visit_funcall (tree_funcall&);
+    void visit_prefix_expression (tree_prefix_expression&);
 
-  void visit_parameter_list (tree_parameter_list&);
+    void visit_return_command (tree_return_command&);
 
-  void visit_postfix_expression (tree_postfix_expression&);
+    void visit_return_list (tree_return_list&);
 
-  void visit_prefix_expression (tree_prefix_expression&);
+    void visit_simple_assignment (tree_simple_assignment&);
 
-  void visit_return_command (tree_return_command&);
+    void visit_statement (tree_statement&);
 
-  void visit_return_list (tree_return_list&);
+    void visit_statement_list (tree_statement_list&);
 
-  void visit_simple_assignment (tree_simple_assignment&);
+    void visit_switch_case (tree_switch_case&);
 
-  void visit_statement (tree_statement&);
+    void visit_switch_case_list (tree_switch_case_list&);
 
-  void visit_statement_list (tree_statement_list&);
+    void visit_switch_command (tree_switch_command&);
 
-  void visit_switch_case (tree_switch_case&);
+    void visit_try_catch_command (tree_try_catch_command&);
 
-  void visit_switch_case_list (tree_switch_case_list&);
+    void visit_unwind_protect_command (tree_unwind_protect_command&);
 
-  void visit_switch_command (tree_switch_command&);
+    void visit_while_command (tree_while_command&);
 
-  void visit_try_catch_command (tree_try_catch_command&);
+    void visit_do_until_command (tree_do_until_command&);
 
-  void visit_unwind_protect_command (tree_unwind_protect_command&);
+  private:
 
-  void visit_while_command (tree_while_command&);
+    bool do_lvalue_check;
 
-  void visit_do_until_command (tree_do_until_command&);
+    std::string file_name;
 
-private:
+    void do_decl_command (tree_decl_command&);
 
-  bool do_lvalue_check;
-
-  std::string file_name;
+    OCTAVE_NORETURN void errmsg (const std::string& msg, int line);
+  };
+}
 
-  void do_decl_command (tree_decl_command&);
+#if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
 
-  OCTAVE_NORETURN void errmsg (const std::string& msg, int line);
-};
+OCTAVE_DEPRECATED ("use 'octave::tree_checker' instead")
+typedef octave::tree_checker tree_checker;
 
 #endif
 
+#endif
diff --git a/libinterp/parse-tree/pt-classdef.cc b/libinterp/parse-tree/pt-classdef.cc
--- a/libinterp/parse-tree/pt-classdef.cc
+++ b/libinterp/parse-tree/pt-classdef.cc
@@ -22,238 +22,240 @@ along with Octave; see the file COPYING.
 
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
 #include "ov-classdef.h"
 #include "pt-classdef.h"
 
-// Classdef attribute
-
-void
-tree_classdef_attribute::accept (tree_walker& tw)
-{
-  tw.visit_classdef_attribute (*this);
-}
-
-// Classdef attribute_list
-
-tree_classdef_attribute_list::~tree_classdef_attribute_list (void)
-{
-  while (! empty ())
-    {
-      iterator p = begin ();
-      delete *p;
-      erase (p);
-    }
-}
-
-void
-tree_classdef_attribute_list::accept (tree_walker& tw)
-{
-  tw.visit_classdef_attribute_list (*this);
-}
-
-// Classdef superclass
-
-void
-tree_classdef_superclass::accept (tree_walker& tw)
-{
-  tw.visit_classdef_superclass (*this);
-}
-
-// Classdef superclass_list
-
-tree_classdef_superclass_list::~tree_classdef_superclass_list (void)
-{
-  while (! empty ())
-    {
-      iterator p = begin ();
-      delete *p;
-      erase (p);
-    }
-}
-
-void
-tree_classdef_superclass_list::accept (tree_walker& tw)
-{
-  tw.visit_classdef_superclass_list (*this);
-}
-
-// Classdef property
-
-void
-tree_classdef_property::accept (tree_walker& tw)
-{
-  tw.visit_classdef_property (*this);
-}
-
-// Classdef property_list
-
-tree_classdef_property_list::~tree_classdef_property_list (void)
-{
-  while (! empty ())
-    {
-      iterator p = begin ();
-      delete *p;
-      erase (p);
-    }
-}
-
-void
-tree_classdef_property_list::accept (tree_walker& tw)
-{
-  tw.visit_classdef_property_list (*this);
-}
-
-// Classdef properties_block
-
-void
-tree_classdef_properties_block::accept (tree_walker& tw)
-{
-  tw.visit_classdef_properties_block (*this);
-}
-
-// Classdef methods_list
-
-void
-tree_classdef_methods_list::accept (tree_walker& tw)
-{
-  tw.visit_classdef_methods_list (*this);
-}
-
-// Classdef methods_block
-
-void
-tree_classdef_methods_block::accept (tree_walker& tw)
-{
-  tw.visit_classdef_methods_block (*this);
-}
-
-// Classdef event
-
-void
-tree_classdef_event::accept (tree_walker& tw)
-{
-  tw.visit_classdef_event (*this);
-}
-
-// Classdef events_list
-
-tree_classdef_events_list::~tree_classdef_events_list (void)
+namespace octave
 {
-  while (! empty ())
-    {
-      iterator p = begin ();
-      delete *p;
-      erase (p);
-    }
-}
+  // Classdef attribute
+
+  void
+  tree_classdef_attribute::accept (tree_walker& tw)
+  {
+    tw.visit_classdef_attribute (*this);
+  }
+
+  // Classdef attribute_list
+
+  tree_classdef_attribute_list::~tree_classdef_attribute_list (void)
+  {
+    while (! empty ())
+      {
+        iterator p = begin ();
+        delete *p;
+        erase (p);
+      }
+  }
+
+  void
+  tree_classdef_attribute_list::accept (tree_walker& tw)
+  {
+    tw.visit_classdef_attribute_list (*this);
+  }
 
-void
-tree_classdef_events_list::accept (tree_walker& tw)
-{
-  tw.visit_classdef_events_list (*this);
-}
+  // Classdef superclass
 
-// Classdef events_block
+  void
+  tree_classdef_superclass::accept (tree_walker& tw)
+  {
+    tw.visit_classdef_superclass (*this);
+  }
+
+  // Classdef superclass_list
 
-void
-tree_classdef_events_block::accept (tree_walker& tw)
-{
-  tw.visit_classdef_events_block (*this);
-}
+  tree_classdef_superclass_list::~tree_classdef_superclass_list (void)
+  {
+    while (! empty ())
+      {
+        iterator p = begin ();
+        delete *p;
+        erase (p);
+      }
+  }
 
-// Classdef enum
+  void
+  tree_classdef_superclass_list::accept (tree_walker& tw)
+  {
+    tw.visit_classdef_superclass_list (*this);
+  }
+
+  // Classdef property
 
-void
-tree_classdef_enum::accept (tree_walker& tw)
-{
-  tw.visit_classdef_enum (*this);
-}
+  void
+  tree_classdef_property::accept (tree_walker& tw)
+  {
+    tw.visit_classdef_property (*this);
+  }
+
+  // Classdef property_list
 
-// Classdef enum_list
+  tree_classdef_property_list::~tree_classdef_property_list (void)
+  {
+    while (! empty ())
+      {
+        iterator p = begin ();
+        delete *p;
+        erase (p);
+      }
+  }
+
+  void
+  tree_classdef_property_list::accept (tree_walker& tw)
+  {
+    tw.visit_classdef_property_list (*this);
+  }
+
+  // Classdef properties_block
 
-tree_classdef_enum_list::~tree_classdef_enum_list (void)
-{
-  while (! empty ())
-    {
-      iterator p = begin ();
-      delete *p;
-      erase (p);
-    }
-}
+  void
+  tree_classdef_properties_block::accept (tree_walker& tw)
+  {
+    tw.visit_classdef_properties_block (*this);
+  }
+
+  // Classdef methods_list
+
+  void
+  tree_classdef_methods_list::accept (tree_walker& tw)
+  {
+    tw.visit_classdef_methods_list (*this);
+  }
+
+  // Classdef methods_block
 
-void
-tree_classdef_enum_list::accept (tree_walker& tw)
-{
-  tw.visit_classdef_enum_list (*this);
-}
+  void
+  tree_classdef_methods_block::accept (tree_walker& tw)
+  {
+    tw.visit_classdef_methods_block (*this);
+  }
 
-// Classdef enum_block
+  // Classdef event
 
-void
-tree_classdef_enum_block::accept (tree_walker& tw)
-{
-  tw.visit_classdef_enum_block (*this);
-}
+  void
+  tree_classdef_event::accept (tree_walker& tw)
+  {
+    tw.visit_classdef_event (*this);
+  }
 
-// Classdef body
+  // Classdef events_list
 
-tree_classdef_body::~tree_classdef_body (void)
-{
-  while (! properties_lst.empty ())
-    {
-      properties_list_iterator p = properties_lst.begin ();
-      delete *p;
-      properties_lst.erase (p);
-    }
+  tree_classdef_events_list::~tree_classdef_events_list (void)
+  {
+    while (! empty ())
+      {
+        iterator p = begin ();
+        delete *p;
+        erase (p);
+      }
+  }
+
+  void
+  tree_classdef_events_list::accept (tree_walker& tw)
+  {
+    tw.visit_classdef_events_list (*this);
+  }
+
+  // Classdef events_block
+
+  void
+  tree_classdef_events_block::accept (tree_walker& tw)
+  {
+    tw.visit_classdef_events_block (*this);
+  }
+
+  // Classdef enum
 
-  while (! methods_lst.empty ())
-    {
-      methods_list_iterator p = methods_lst.begin ();
-      delete *p;
-      methods_lst.erase (p);
-    }
+  void
+  tree_classdef_enum::accept (tree_walker& tw)
+  {
+    tw.visit_classdef_enum (*this);
+  }
+
+  // Classdef enum_list
 
-  while (! events_lst.empty ())
-    {
-      events_list_iterator p = events_lst.begin ();
-      delete *p;
-      events_lst.erase (p);
-    }
+  tree_classdef_enum_list::~tree_classdef_enum_list (void)
+  {
+    while (! empty ())
+      {
+        iterator p = begin ();
+        delete *p;
+        erase (p);
+      }
+  }
+
+  void
+  tree_classdef_enum_list::accept (tree_walker& tw)
+  {
+    tw.visit_classdef_enum_list (*this);
+  }
+
+  // Classdef enum_block
+
+  void
+  tree_classdef_enum_block::accept (tree_walker& tw)
+  {
+    tw.visit_classdef_enum_block (*this);
+  }
 
-  while (! enum_lst.empty ())
-    {
-      enum_list_iterator p = enum_lst.begin ();
-      delete *p;
-      enum_lst.erase (p);
-    }
-}
+  // Classdef body
+
+  tree_classdef_body::~tree_classdef_body (void)
+  {
+    while (! properties_lst.empty ())
+      {
+        properties_list_iterator p = properties_lst.begin ();
+        delete *p;
+        properties_lst.erase (p);
+      }
 
-// Classdef
+    while (! methods_lst.empty ())
+      {
+        methods_list_iterator p = methods_lst.begin ();
+        delete *p;
+        methods_lst.erase (p);
+      }
 
-octave_function*
-tree_classdef::make_meta_class (bool is_at_folder)
-{
-  cdef_class cls = cdef_class::make_meta_class (this, is_at_folder);
-
-  if (cls.ok ())
-    return cls.get_constructor_function ();
+    while (! events_lst.empty ())
+      {
+        events_list_iterator p = events_lst.begin ();
+        delete *p;
+        events_lst.erase (p);
+      }
 
-  return 0;
-}
+    while (! enum_lst.empty ())
+      {
+        enum_list_iterator p = enum_lst.begin ();
+        delete *p;
+        enum_lst.erase (p);
+      }
+  }
+
+  // Classdef
+
+  octave_function*
+  tree_classdef::make_meta_class (bool is_at_folder)
+  {
+    cdef_class cls = cdef_class::make_meta_class (this, is_at_folder);
+
+    if (cls.ok ())
+      return cls.get_constructor_function ();
 
-tree_classdef *
-tree_classdef::dup (symbol_table::scope_id,
-                    symbol_table::context_id) const
-{
-  // FIXME
-  return 0;
+    return 0;
+  }
+
+  tree_classdef *
+  tree_classdef::dup (symbol_table::scope_id,
+                      symbol_table::context_id) const
+  {
+    // FIXME
+    return 0;
+  }
+
+  void
+  tree_classdef::accept (tree_walker& tw)
+  {
+    tw.visit_classdef (*this);
+  }
 }
-
-void
-tree_classdef::accept (tree_walker& tw)
-{
-  tw.visit_classdef (*this);
-}
-
diff --git a/libinterp/parse-tree/pt-classdef.h b/libinterp/parse-tree/pt-classdef.h
--- a/libinterp/parse-tree/pt-classdef.h
+++ b/libinterp/parse-tree/pt-classdef.h
@@ -22,625 +22,633 @@ along with Octave; see the file COPYING.
 
 #if ! defined (octave_tree_classdef_h)
 #define octave_tree_classdef_h 1
 
 #include "octave-config.h"
 
 class octave_value;
 
-class tree_walker;
-
 #include "pt-cmd.h"
 #include "pt-exp.h"
 #include "pt-id.h"
 
 #include "base-list.h"
 
 #include <list>
 
-class tree_classdef_attribute
+namespace octave
 {
-public:
-
-  tree_classdef_attribute (tree_identifier *i = 0, tree_expression *e = 0)
-    : id (i), expr (e), neg (false) { }
+  class tree_walker;
 
-  tree_classdef_attribute (tree_identifier *i, bool b)
-    : id (i), expr (0), neg (b) { }
-
-  // No copying!
-
-  tree_classdef_attribute (const tree_classdef_attribute&) = delete;
-
-  tree_classdef_attribute& operator = (const tree_classdef_attribute&) = delete;
-
-  ~tree_classdef_attribute (void)
+  class tree_classdef_attribute
   {
-    delete id;
-    delete expr;
-  }
+  public:
+
+    tree_classdef_attribute (tree_identifier *i = 0, tree_expression *e = 0)
+      : id (i), expr (e), neg (false) { }
+
+    tree_classdef_attribute (tree_identifier *i, bool b)
+      : id (i), expr (0), neg (b) { }
+
+    // No copying!
 
-  tree_identifier *ident (void) { return id; }
+    tree_classdef_attribute (const tree_classdef_attribute&) = delete;
+
+    tree_classdef_attribute& operator = (const tree_classdef_attribute&) = delete;
 
-  tree_expression *expression (void) { return expr; }
+    ~tree_classdef_attribute (void)
+    {
+      delete id;
+      delete expr;
+    }
 
-  bool negate (void) { return neg; }
+    tree_identifier *ident (void) { return id; }
 
-  void accept (tree_walker&);
+    tree_expression *expression (void) { return expr; }
+
+    bool negate (void) { return neg; }
 
-private:
+    void accept (tree_walker&);
+
+  private:
 
-  tree_identifier *id;
-  tree_expression *expr;
-  bool neg;
-};
+    tree_identifier *id;
+    tree_expression *expr;
+    bool neg;
+  };
 
-class tree_classdef_attribute_list : public octave::base_list<tree_classdef_attribute *>
-{
-public:
+  class tree_classdef_attribute_list : public octave::base_list<tree_classdef_attribute *>
+  {
+  public:
+
+    tree_classdef_attribute_list (void) { }
+
+    tree_classdef_attribute_list (tree_classdef_attribute *a) { append (a); }
+
+    tree_classdef_attribute_list (const octave::base_list<tree_classdef_attribute *>& a)
+      : octave::base_list<tree_classdef_attribute *> (a) { }
 
-  tree_classdef_attribute_list (void) { }
+    // No copying!
 
-  tree_classdef_attribute_list (tree_classdef_attribute *a) { append (a); }
+    tree_classdef_attribute_list (const tree_classdef_attribute_list&) = delete;
 
-  tree_classdef_attribute_list (const octave::base_list<tree_classdef_attribute *>& a)
-    : octave::base_list<tree_classdef_attribute *> (a) { }
+    tree_classdef_attribute_list&
+    operator = (const tree_classdef_attribute_list&) = delete;
 
-  // No copying!
+    ~tree_classdef_attribute_list (void);
+
+    void accept (tree_walker&);
+  };
 
-  tree_classdef_attribute_list (const tree_classdef_attribute_list&) = delete;
+  class tree_classdef_superclass
+  {
+  public:
 
-  tree_classdef_attribute_list&
-  operator = (const tree_classdef_attribute_list&) = delete;
+    tree_classdef_superclass (const std::string& cname)
+      : cls_name (cname) { }
 
-  ~tree_classdef_attribute_list (void);
+    // No copying!
 
-  void accept (tree_walker&);
-};
+    tree_classdef_superclass (const tree_classdef_superclass&) = delete;
+
+    tree_classdef_superclass&
+    operator = (const tree_classdef_superclass&) = delete;
 
-class tree_classdef_superclass
-{
-public:
+    ~tree_classdef_superclass (void) = default;
+
+    std::string class_name (void) { return cls_name; }
 
-  tree_classdef_superclass (const std::string& cname)
-    : cls_name (cname) { }
+    void accept (tree_walker&);
 
-  // No copying!
+  private:
 
-  tree_classdef_superclass (const tree_classdef_superclass&) = delete;
+    std::string cls_name;
+  };
 
-  tree_classdef_superclass&
-  operator = (const tree_classdef_superclass&) = delete;
+  class tree_classdef_superclass_list : public octave::base_list<tree_classdef_superclass *>
+  {
+  public:
 
-  ~tree_classdef_superclass (void) = default;
+    tree_classdef_superclass_list (void) { }
 
-  std::string class_name (void) { return cls_name; }
+    tree_classdef_superclass_list (tree_classdef_superclass *sc) { append (sc); }
 
-  void accept (tree_walker&);
+    tree_classdef_superclass_list (const octave::base_list<tree_classdef_superclass *>& a)
+      : octave::base_list<tree_classdef_superclass *> (a) { }
 
-private:
+    // No copying!
+
+    tree_classdef_superclass_list (const tree_classdef_superclass_list&) = delete;
 
-  std::string cls_name;
-};
+    tree_classdef_superclass_list&
+    operator = (const tree_classdef_superclass_list&) = delete;
 
-class tree_classdef_superclass_list : public octave::base_list<tree_classdef_superclass *>
-{
-public:
+    ~tree_classdef_superclass_list (void);
 
-  tree_classdef_superclass_list (void) { }
+    void accept (tree_walker&);
+  };
 
-  tree_classdef_superclass_list (tree_classdef_superclass *sc) { append (sc); }
-
-  tree_classdef_superclass_list (const octave::base_list<tree_classdef_superclass *>& a)
-    : octave::base_list<tree_classdef_superclass *> (a) { }
+  template <typename T>
+  class tree_classdef_element : public tree
+  {
+  public:
 
-  // No copying!
+    tree_classdef_element (tree_classdef_attribute_list *a,
+                           octave::base_list<T> *elist,
+                           octave_comment_list *lc, octave_comment_list *tc,
+                           int l = -1, int c = -1)
+      : tree (l, c), attr_list (a), elt_list (elist),
+        lead_comm (lc), trail_comm (tc)
+    { }
 
-  tree_classdef_superclass_list (const tree_classdef_superclass_list&) = delete;
+    // No copying!
 
-  tree_classdef_superclass_list&
-  operator = (const tree_classdef_superclass_list&) = delete;
+    tree_classdef_element (const tree_classdef_element&) = delete;
 
-  ~tree_classdef_superclass_list (void);
-
-  void accept (tree_walker&);
-};
+    tree_classdef_element& operator = (const tree_classdef_element&) = delete;
 
-template <typename T>
-class tree_classdef_element : public tree
-{
-public:
+    ~tree_classdef_element (void)
+    {
+      delete attr_list;
+      delete elt_list;
+      delete lead_comm;
+      delete trail_comm;
+    }
+
+    tree_classdef_attribute_list *attribute_list (void) { return attr_list; }
+
+    octave::base_list<T> *element_list (void) { return elt_list; }
 
-  tree_classdef_element (tree_classdef_attribute_list *a,
-                         octave::base_list<T> *elist,
-                         octave_comment_list *lc, octave_comment_list *tc,
-                         int l = -1, int c = -1)
-    : tree (l, c), attr_list (a), elt_list (elist),
-      lead_comm (lc), trail_comm (tc)
-  { }
+    octave_comment_list *leading_comment (void) { return lead_comm; }
+
+    octave_comment_list *trailing_comment (void) { return trail_comm; }
+
+    void accept (tree_walker&) { }
 
-  // No copying!
+  private:
 
-  tree_classdef_element (const tree_classdef_element&) = delete;
+    // List of attributes that apply to this class.
+    tree_classdef_attribute_list *attr_list;
+
+    // The list of objects contained in this block.
+    octave::base_list<T> *elt_list;
 
-  tree_classdef_element& operator = (const tree_classdef_element&) = delete;
+    // Comment preceding the token marking the beginning of the block.
+    octave_comment_list *lead_comm;
 
-  ~tree_classdef_element (void)
+    // Comment preceding END token.
+    octave_comment_list *trail_comm;
+  };
+
+  class tree_classdef_property
   {
-    delete attr_list;
-    delete elt_list;
-    delete lead_comm;
-    delete trail_comm;
-  }
+  public:
 
-  tree_classdef_attribute_list *attribute_list (void) { return attr_list; }
+    tree_classdef_property (tree_identifier *i = 0, tree_expression *e = 0)
+      : id (i), expr (e) { }
 
-  octave::base_list<T> *element_list (void) { return elt_list; }
+    // No copying!
 
-  octave_comment_list *leading_comment (void) { return lead_comm; }
+    tree_classdef_property (const tree_classdef_property&) = delete;
 
-  octave_comment_list *trailing_comment (void) { return trail_comm; }
+    tree_classdef_property& operator = (const tree_classdef_property&) = delete;
 
-  void accept (tree_walker&) { }
-
-private:
+    ~tree_classdef_property (void)
+    {
+      delete id;
+      delete expr;
+    }
 
-  // List of attributes that apply to this class.
-  tree_classdef_attribute_list *attr_list;
+    tree_identifier *ident (void) { return id; }
+
+    tree_expression *expression (void) { return expr; }
+
+    void accept (tree_walker&);
 
-  // The list of objects contained in this block.
-  octave::base_list<T> *elt_list;
+  private:
 
-  // Comment preceding the token marking the beginning of the block.
-  octave_comment_list *lead_comm;
+    tree_identifier *id;
+    tree_expression *expr;
+  };
 
-  // Comment preceding END token.
-  octave_comment_list *trail_comm;
-};
+  class tree_classdef_property_list : public octave::base_list<tree_classdef_property *>
+  {
+  public:
+
+    tree_classdef_property_list (void) { }
 
-class tree_classdef_property
-{
-public:
+    tree_classdef_property_list (tree_classdef_property* p) { append (p); }
 
-  tree_classdef_property (tree_identifier *i = 0, tree_expression *e = 0)
-    : id (i), expr (e) { }
+    tree_classdef_property_list (const octave::base_list<tree_classdef_property *>& a)
+      : octave::base_list<tree_classdef_property *> (a) { }
 
-  // No copying!
+    // No copying!
+
+    tree_classdef_property_list (const tree_classdef_property_list&) = delete;
 
-  tree_classdef_property (const tree_classdef_property&) = delete;
+    tree_classdef_property_list&
+    operator = (const tree_classdef_property_list&) = delete;
+
+    ~tree_classdef_property_list (void);
 
-  tree_classdef_property& operator = (const tree_classdef_property&) = delete;
+    void accept (tree_walker&);
+  };
 
-  ~tree_classdef_property (void)
+  class tree_classdef_properties_block
+    : public tree_classdef_element<tree_classdef_property *>
   {
-    delete id;
-    delete expr;
-  }
-
-  tree_identifier *ident (void) { return id; }
+  public:
 
-  tree_expression *expression (void) { return expr; }
+    tree_classdef_properties_block (tree_classdef_attribute_list *a,
+                                    tree_classdef_property_list *plist,
+                                    octave_comment_list *lc,
+                                    octave_comment_list *tc,
+                                    int l = -1, int c = -1)
+      : tree_classdef_element<tree_classdef_property *> (a, plist, lc, tc, l, c) { }
 
-  void accept (tree_walker&);
+    // No copying!
 
-private:
+    tree_classdef_properties_block (const tree_classdef_properties_block&) = delete;
 
-  tree_identifier *id;
-  tree_expression *expr;
-};
+    tree_classdef_properties_block&
+    operator = (const tree_classdef_properties_block&) = delete;
+
+    ~tree_classdef_properties_block (void) = default;
 
-class tree_classdef_property_list : public octave::base_list<tree_classdef_property *>
-{
-public:
+    void accept (tree_walker&);
+  };
 
-  tree_classdef_property_list (void) { }
-
-  tree_classdef_property_list (tree_classdef_property* p) { append (p); }
+  class tree_classdef_methods_list : public octave::base_list<octave_value>
+  {
+  public:
 
-  tree_classdef_property_list (const octave::base_list<tree_classdef_property *>& a)
-    : octave::base_list<tree_classdef_property *> (a) { }
+    tree_classdef_methods_list (void) { }
 
-  // No copying!
+    tree_classdef_methods_list (const octave_value& f) { append (f); }
+
+    tree_classdef_methods_list (const octave::base_list<octave_value>& a)
+      : octave::base_list<octave_value> (a) { }
 
-  tree_classdef_property_list (const tree_classdef_property_list&) = delete;
+    // No copying!
 
-  tree_classdef_property_list&
-  operator = (const tree_classdef_property_list&) = delete;
+    tree_classdef_methods_list (const tree_classdef_methods_list&) = delete;
 
-  ~tree_classdef_property_list (void);
+    tree_classdef_methods_list&
+    operator = (const tree_classdef_methods_list&) = delete;
 
-  void accept (tree_walker&);
-};
+    ~tree_classdef_methods_list (void) = default;
 
-class tree_classdef_properties_block
-  : public tree_classdef_element<tree_classdef_property *>
-{
-public:
+    void accept (tree_walker&);
+  };
+
+  class tree_classdef_methods_block : public tree_classdef_element<octave_value>
+  {
+  public:
 
-  tree_classdef_properties_block (tree_classdef_attribute_list *a,
-                                  tree_classdef_property_list *plist,
-                                  octave_comment_list *lc,
-                                  octave_comment_list *tc,
-                                  int l = -1, int c = -1)
-    : tree_classdef_element<tree_classdef_property *> (a, plist, lc, tc, l, c) { }
+    tree_classdef_methods_block (tree_classdef_attribute_list *a,
+                                 tree_classdef_methods_list *mlist,
+                                 octave_comment_list *lc,
+                                 octave_comment_list *tc, int l = -1, int c = -1)
+      : tree_classdef_element<octave_value> (a, mlist, lc, tc, l, c) { }
 
-  // No copying!
+    // No copying!
+
+    tree_classdef_methods_block (const tree_classdef_methods_block&) = delete;
 
-  tree_classdef_properties_block (const tree_classdef_properties_block&) = delete;
+    tree_classdef_methods_block&
+    operator = (const tree_classdef_methods_block&) = delete;
+
+    ~tree_classdef_methods_block (void) = default;
 
-  tree_classdef_properties_block&
-  operator = (const tree_classdef_properties_block&) = delete;
+    void accept (tree_walker&);
+  };
 
-  ~tree_classdef_properties_block (void) = default;
+  class tree_classdef_event
+  {
+  public:
 
-  void accept (tree_walker&);
-};
+    tree_classdef_event (tree_identifier *i = 0) : id (i) { }
+
+    // No copying!
+
+    tree_classdef_event (const tree_classdef_event&) = delete;
 
-class tree_classdef_methods_list : public octave::base_list<octave_value>
-{
-public:
+    tree_classdef_event& operator = (const tree_classdef_event&) = delete;
 
-  tree_classdef_methods_list (void) { }
+    ~tree_classdef_event (void)
+    {
+      delete id;
+    }
 
-  tree_classdef_methods_list (const octave_value& f) { append (f); }
+    tree_identifier *ident (void) { return id; }
+
+    void accept (tree_walker&);
 
-  tree_classdef_methods_list (const octave::base_list<octave_value>& a)
-    : octave::base_list<octave_value> (a) { }
+  private:
 
-  // No copying!
-
-  tree_classdef_methods_list (const tree_classdef_methods_list&) = delete;
+    tree_identifier *id;
+  };
 
-  tree_classdef_methods_list&
-  operator = (const tree_classdef_methods_list&) = delete;
+  class tree_classdef_events_list : public octave::base_list<tree_classdef_event *>
+  {
+  public:
 
-  ~tree_classdef_methods_list (void) = default;
+    tree_classdef_events_list (void) { }
 
-  void accept (tree_walker&);
-};
+    tree_classdef_events_list (tree_classdef_event *e) { append (e); }
+
+    tree_classdef_events_list (const octave::base_list<tree_classdef_event *>& a)
+      : octave::base_list<tree_classdef_event *> (a) { }
 
-class tree_classdef_methods_block : public tree_classdef_element<octave_value>
-{
-public:
+    // No copying!
+
+    tree_classdef_events_list (const tree_classdef_events_list&) = delete;
 
-  tree_classdef_methods_block (tree_classdef_attribute_list *a,
-                               tree_classdef_methods_list *mlist,
-                               octave_comment_list *lc,
-                               octave_comment_list *tc, int l = -1, int c = -1)
-    : tree_classdef_element<octave_value> (a, mlist, lc, tc, l, c) { }
+    tree_classdef_events_list&
+    operator = (const tree_classdef_events_list&) = delete;
 
-  // No copying!
+    ~tree_classdef_events_list (void);
+
+    void accept (tree_walker&);
+  };
 
-  tree_classdef_methods_block (const tree_classdef_methods_block&) = delete;
-
-  tree_classdef_methods_block&
-  operator = (const tree_classdef_methods_block&) = delete;
+  class tree_classdef_events_block
+    : public tree_classdef_element<tree_classdef_event *>
+  {
+  public:
 
-  ~tree_classdef_methods_block (void) = default;
+    tree_classdef_events_block (tree_classdef_attribute_list *a,
+                                tree_classdef_events_list *elist,
+                                octave_comment_list *lc,
+                                octave_comment_list *tc, int l = -1, int c = -1)
+      : tree_classdef_element<tree_classdef_event *> (a, elist, lc, tc, l, c) { }
 
-  void accept (tree_walker&);
-};
+    // No copying!
 
-class tree_classdef_event
-{
-public:
+    tree_classdef_events_block (const tree_classdef_events_block&) = delete;
 
-  tree_classdef_event (tree_identifier *i = 0) : id (i) { }
+    tree_classdef_events_block&
+    operator = (const tree_classdef_events_block&) = delete;
+
+    ~tree_classdef_events_block (void) = default;
 
-  // No copying!
+    void accept (tree_walker&);
+  };
 
-  tree_classdef_event (const tree_classdef_event&) = delete;
+  class tree_classdef_enum
+  {
+  public:
 
-  tree_classdef_event& operator = (const tree_classdef_event&) = delete;
+    tree_classdef_enum (void) : id (0), expr (0) { }
 
-  ~tree_classdef_event (void)
-  {
-    delete id;
-  }
+    tree_classdef_enum (tree_identifier *i, tree_expression *e)
+      : id (i), expr (e) { }
 
-  tree_identifier *ident (void) { return id; }
+    // No copying!
 
-  void accept (tree_walker&);
+    tree_classdef_enum (const tree_classdef_enum&) = delete;
 
-private:
+    tree_classdef_enum& operator = (const tree_classdef_enum&) = delete;
 
-  tree_identifier *id;
-};
+    ~tree_classdef_enum (void)
+    {
+      delete id;
+      delete expr;
+    }
+
+    tree_identifier *ident (void) { return id; }
 
-class tree_classdef_events_list : public octave::base_list<tree_classdef_event *>
-{
-public:
+    tree_expression *expression (void) { return expr; }
+
+    void accept (tree_walker&);
 
-  tree_classdef_events_list (void) { }
+  private:
 
-  tree_classdef_events_list (tree_classdef_event *e) { append (e); }
+    tree_identifier *id;
+    tree_expression *expr;
+  };
 
-  tree_classdef_events_list (const octave::base_list<tree_classdef_event *>& a)
-    : octave::base_list<tree_classdef_event *> (a) { }
+  class tree_classdef_enum_list : public octave::base_list<tree_classdef_enum *>
+  {
+  public:
 
-  // No copying!
+    tree_classdef_enum_list (void) { }
 
-  tree_classdef_events_list (const tree_classdef_events_list&) = delete;
+    tree_classdef_enum_list (tree_classdef_enum *e) { append (e); }
 
-  tree_classdef_events_list&
-  operator = (const tree_classdef_events_list&) = delete;
+    tree_classdef_enum_list (const octave::base_list<tree_classdef_enum *>& a)
+      : octave::base_list<tree_classdef_enum *> (a) { }
+
+    // No copying!
+
+    tree_classdef_enum_list (const tree_classdef_enum_list&) = delete;
 
-  ~tree_classdef_events_list (void);
+    tree_classdef_enum_list& operator = (const tree_classdef_enum_list&) = delete;
 
-  void accept (tree_walker&);
-};
+    ~tree_classdef_enum_list (void);
+
+    void accept (tree_walker&);
+  };
 
-class tree_classdef_events_block
-  : public tree_classdef_element<tree_classdef_event *>
-{
-public:
+  class tree_classdef_enum_block
+    : public tree_classdef_element<tree_classdef_enum *>
+  {
+  public:
 
-  tree_classdef_events_block (tree_classdef_attribute_list *a,
-                              tree_classdef_events_list *elist,
+    tree_classdef_enum_block (tree_classdef_attribute_list *a,
+                              tree_classdef_enum_list *elist,
                               octave_comment_list *lc,
                               octave_comment_list *tc, int l = -1, int c = -1)
-    : tree_classdef_element<tree_classdef_event *> (a, elist, lc, tc, l, c) { }
-
-  // No copying!
-
-  tree_classdef_events_block (const tree_classdef_events_block&) = delete;
-
-  tree_classdef_events_block&
-  operator = (const tree_classdef_events_block&) = delete;
-
-  ~tree_classdef_events_block (void) = default;
-
-  void accept (tree_walker&);
-};
-
-class tree_classdef_enum
-{
-public:
-
-  tree_classdef_enum (void) : id (0), expr (0) { }
-
-  tree_classdef_enum (tree_identifier *i, tree_expression *e)
-    : id (i), expr (e) { }
-
-  // No copying!
-
-  tree_classdef_enum (const tree_classdef_enum&) = delete;
-
-  tree_classdef_enum& operator = (const tree_classdef_enum&) = delete;
+      : tree_classdef_element<tree_classdef_enum *> (a, elist, lc, tc, l, c) { }
 
-  ~tree_classdef_enum (void)
-  {
-    delete id;
-    delete expr;
-  }
-
-  tree_identifier *ident (void) { return id; }
-
-  tree_expression *expression (void) { return expr; }
-
-  void accept (tree_walker&);
-
-private:
-
-  tree_identifier *id;
-  tree_expression *expr;
-};
+    // No copying!
 
-class tree_classdef_enum_list : public octave::base_list<tree_classdef_enum *>
-{
-public:
-
-  tree_classdef_enum_list (void) { }
-
-  tree_classdef_enum_list (tree_classdef_enum *e) { append (e); }
-
-  tree_classdef_enum_list (const octave::base_list<tree_classdef_enum *>& a)
-    : octave::base_list<tree_classdef_enum *> (a) { }
-
-  // No copying!
-
-  tree_classdef_enum_list (const tree_classdef_enum_list&) = delete;
-
-  tree_classdef_enum_list& operator = (const tree_classdef_enum_list&) = delete;
-
-  ~tree_classdef_enum_list (void);
+    tree_classdef_enum_block (const tree_classdef_enum_block&) = delete;
 
-  void accept (tree_walker&);
-};
-
-class tree_classdef_enum_block
-  : public tree_classdef_element<tree_classdef_enum *>
-{
-public:
-
-  tree_classdef_enum_block (tree_classdef_attribute_list *a,
-                            tree_classdef_enum_list *elist,
-                            octave_comment_list *lc,
-                            octave_comment_list *tc, int l = -1, int c = -1)
-    : tree_classdef_element<tree_classdef_enum *> (a, elist, lc, tc, l, c) { }
-
-  // No copying!
+    tree_classdef_enum_block&
+    operator = (const tree_classdef_enum_block&) = delete;
 
-  tree_classdef_enum_block (const tree_classdef_enum_block&) = delete;
-
-  tree_classdef_enum_block&
-  operator = (const tree_classdef_enum_block&) = delete;
-
-  ~tree_classdef_enum_block (void) = default;
-
-  void accept (tree_walker&);
-};
-
-class tree_classdef_body
-{
-public:
-
-  typedef std::list<tree_classdef_properties_block *>::iterator properties_list_iterator;
-  typedef std::list<tree_classdef_properties_block *>::const_iterator properties_list_const_iterator;
+    ~tree_classdef_enum_block (void) = default;
 
-  typedef std::list<tree_classdef_methods_block *>::iterator methods_list_iterator;
-  typedef std::list<tree_classdef_methods_block *>::const_iterator methods_list_const_iterator;
-
-  typedef std::list<tree_classdef_events_block *>::iterator events_list_iterator;
-  typedef std::list<tree_classdef_events_block *>::const_iterator events_list_const_iterator;
-
-  typedef std::list<tree_classdef_enum_block *>::iterator enum_list_iterator;
-  typedef std::list<tree_classdef_enum_block *>::const_iterator enum_list_const_iterator;
-
-  tree_classdef_body (void)
-    : properties_lst (), methods_lst (), events_lst (), enum_lst () { }
+    void accept (tree_walker&);
+  };
 
-  tree_classdef_body (tree_classdef_properties_block *pb)
-    : properties_lst (), methods_lst (), events_lst (), enum_lst ()
-  {
-    append (pb);
-  }
-
-  tree_classdef_body (tree_classdef_methods_block *mb)
-    : properties_lst (), methods_lst (), events_lst (), enum_lst ()
-  {
-    append (mb);
-  }
-
-  tree_classdef_body (tree_classdef_events_block *evb)
-    : properties_lst (), methods_lst (), events_lst (), enum_lst ()
-  {
-    append (evb);
-  }
-
-  tree_classdef_body (tree_classdef_enum_block *enb)
-    : properties_lst (), methods_lst (), events_lst (), enum_lst ()
+  class tree_classdef_body
   {
-    append (enb);
-  }
+  public:
 
-  // No copying!
+    typedef std::list<tree_classdef_properties_block *>::iterator properties_list_iterator;
+    typedef std::list<tree_classdef_properties_block *>::const_iterator properties_list_const_iterator;
+
+    typedef std::list<tree_classdef_methods_block *>::iterator methods_list_iterator;
+    typedef std::list<tree_classdef_methods_block *>::const_iterator methods_list_const_iterator;
 
-  tree_classdef_body (const tree_classdef_body&) = delete;
+    typedef std::list<tree_classdef_events_block *>::iterator events_list_iterator;
+    typedef std::list<tree_classdef_events_block *>::const_iterator events_list_const_iterator;
 
-  tree_classdef_body& operator = (const tree_classdef_body&) = delete;
+    typedef std::list<tree_classdef_enum_block *>::iterator enum_list_iterator;
+    typedef std::list<tree_classdef_enum_block *>::const_iterator enum_list_const_iterator;
 
-  ~tree_classdef_body (void);
+    tree_classdef_body (void)
+      : properties_lst (), methods_lst (), events_lst (), enum_lst () { }
 
-  void append (tree_classdef_properties_block *pb)
-  {
-    properties_lst.push_back (pb);
-  }
+    tree_classdef_body (tree_classdef_properties_block *pb)
+      : properties_lst (), methods_lst (), events_lst (), enum_lst ()
+    {
+      append (pb);
+    }
 
-  void append (tree_classdef_methods_block *mb)
-  {
-    methods_lst.push_back (mb);
-  }
+    tree_classdef_body (tree_classdef_methods_block *mb)
+      : properties_lst (), methods_lst (), events_lst (), enum_lst ()
+    {
+      append (mb);
+    }
 
-  void append (tree_classdef_events_block *evb)
-  {
-    events_lst.push_back (evb);
-  }
+    tree_classdef_body (tree_classdef_events_block *evb)
+      : properties_lst (), methods_lst (), events_lst (), enum_lst ()
+    {
+      append (evb);
+    }
 
-  void append (tree_classdef_enum_block *enb)
-  {
-    enum_lst.push_back (enb);
-  }
+    tree_classdef_body (tree_classdef_enum_block *enb)
+      : properties_lst (), methods_lst (), events_lst (), enum_lst ()
+    {
+      append (enb);
+    }
 
-  std::list<tree_classdef_properties_block *> properties_list (void)
-  {
-    return properties_lst;
-  }
+    // No copying!
+
+    tree_classdef_body (const tree_classdef_body&) = delete;
+
+    tree_classdef_body& operator = (const tree_classdef_body&) = delete;
+
+    ~tree_classdef_body (void);
 
-  std::list<tree_classdef_methods_block *> methods_list (void)
-  {
-    return methods_lst;
-  }
+    void append (tree_classdef_properties_block *pb)
+    {
+      properties_lst.push_back (pb);
+    }
 
-  std::list<tree_classdef_events_block *> events_list (void)
-  {
-    return events_lst;
-  }
+    void append (tree_classdef_methods_block *mb)
+    {
+      methods_lst.push_back (mb);
+    }
 
-  std::list<tree_classdef_enum_block *> enum_list (void)
-  {
-    return enum_lst;
-  }
+    void append (tree_classdef_events_block *evb)
+    {
+      events_lst.push_back (evb);
+    }
 
-  void accept (tree_walker&);
-
-private:
+    void append (tree_classdef_enum_block *enb)
+    {
+      enum_lst.push_back (enb);
+    }
 
-  std::list<tree_classdef_properties_block *> properties_lst;
-
-  std::list<tree_classdef_methods_block *> methods_lst;
+    std::list<tree_classdef_properties_block *> properties_list (void)
+    {
+      return properties_lst;
+    }
 
-  std::list<tree_classdef_events_block *> events_lst;
+    std::list<tree_classdef_methods_block *> methods_list (void)
+    {
+      return methods_lst;
+    }
 
-  std::list<tree_classdef_enum_block *> enum_lst;
-};
-
-// Classdef definition.
+    std::list<tree_classdef_events_block *> events_list (void)
+    {
+      return events_lst;
+    }
 
-class tree_classdef : public tree_command
-{
-public:
+    std::list<tree_classdef_enum_block *> enum_list (void)
+    {
+      return enum_lst;
+    }
+
+    void accept (tree_walker&);
+
+  private:
 
-  tree_classdef (tree_classdef_attribute_list *a, tree_identifier *i,
-                 tree_classdef_superclass_list *sc,
-                 tree_classdef_body *b, octave_comment_list *lc,
-                 octave_comment_list *tc,
-                 const std::string& pn = "", int l = -1,
-                 int c = -1)
-    : tree_command (l, c), attr_list (a), id (i),
-      supclass_list (sc), element_list (b), lead_comm (lc), trail_comm (tc),
-      pack_name (pn) { }
+    std::list<tree_classdef_properties_block *> properties_lst;
+
+    std::list<tree_classdef_methods_block *> methods_lst;
 
-  // No copying!
+    std::list<tree_classdef_events_block *> events_lst;
+
+    std::list<tree_classdef_enum_block *> enum_lst;
+  };
+
+  // Classdef definition.
 
-  tree_classdef (const tree_classdef&) = delete;
-
-  tree_classdef& operator = (const tree_classdef&) = delete;
-
-  ~tree_classdef (void)
+  class tree_classdef : public tree_command
   {
-    delete attr_list;
-    delete id;
-    delete supclass_list;
-    delete element_list;
-    delete lead_comm;
-    delete trail_comm;
-  }
+  public:
 
-  tree_classdef_attribute_list *attribute_list (void) { return attr_list; }
+    tree_classdef (tree_classdef_attribute_list *a, tree_identifier *i,
+                   tree_classdef_superclass_list *sc,
+                   tree_classdef_body *b, octave_comment_list *lc,
+                   octave_comment_list *tc,
+                   const std::string& pn = "", int l = -1,
+                   int c = -1)
+      : tree_command (l, c), attr_list (a), id (i),
+        supclass_list (sc), element_list (b), lead_comm (lc), trail_comm (tc),
+        pack_name (pn) { }
+
+    // No copying!
+
+    tree_classdef (const tree_classdef&) = delete;
+
+    tree_classdef& operator = (const tree_classdef&) = delete;
 
-  tree_identifier *ident (void) { return id; }
+    ~tree_classdef (void)
+    {
+      delete attr_list;
+      delete id;
+      delete supclass_list;
+      delete element_list;
+      delete lead_comm;
+      delete trail_comm;
+    }
 
-  tree_classdef_superclass_list *superclass_list (void) { return supclass_list; }
-
-  tree_classdef_body *body (void) { return element_list; }
+    tree_classdef_attribute_list *attribute_list (void) { return attr_list; }
 
-  octave_comment_list *leading_comment (void) { return lead_comm; }
-  octave_comment_list *trailing_comment (void) { return trail_comm; }
+    tree_identifier *ident (void) { return id; }
 
-  const std::string& package_name (void) const { return pack_name; }
+    tree_classdef_superclass_list *superclass_list (void) { return supclass_list; }
+
+    tree_classdef_body *body (void) { return element_list; }
 
-  octave_function* make_meta_class (bool is_at_folder = false);
+    octave_comment_list *leading_comment (void) { return lead_comm; }
+    octave_comment_list *trailing_comment (void) { return trail_comm; }
 
-  tree_classdef *dup (symbol_table::scope_id scope,
-                      symbol_table::context_id context) const;
+    const std::string& package_name (void) const { return pack_name; }
+
+    octave_function* make_meta_class (bool is_at_folder = false);
 
-  void accept (tree_walker& tw);
+    tree_classdef *dup (symbol_table::scope_id scope,
+                        symbol_table::context_id context) const;
 
-private:
+    void accept (tree_walker& tw);
 
-  tree_classdef_attribute_list *attr_list;
+  private:
+
+    tree_classdef_attribute_list *attr_list;
 
-  tree_identifier *id;
+    tree_identifier *id;
+
+    tree_classdef_superclass_list *supclass_list;
 
-  tree_classdef_superclass_list *supclass_list;
+    tree_classdef_body *element_list;
 
-  tree_classdef_body *element_list;
+    octave_comment_list *lead_comm;
+    octave_comment_list *trail_comm;
 
-  octave_comment_list *lead_comm;
-  octave_comment_list *trail_comm;
+    std::string pack_name;
+  };
+}
 
-  std::string pack_name;
-};
+#if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
+
+// Hmm, a lot of these are templates, so not sure how to typedef them.
 
 #endif
 
+#endif
diff --git a/libinterp/parse-tree/pt-cmd.cc b/libinterp/parse-tree/pt-cmd.cc
--- a/libinterp/parse-tree/pt-cmd.cc
+++ b/libinterp/parse-tree/pt-cmd.cc
@@ -22,39 +22,41 @@ along with Octave; see the file COPYING.
 
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
 #include "pt-cmd.h"
 #include "pt-walk.h"
 
-// No-op.
-
-tree_command *
-tree_no_op_command::dup (symbol_table::scope_id,
-                         symbol_table::context_id) const
+namespace octave
 {
-  return new tree_no_op_command (orig_cmd, is_end_of_file (),
-                                 line (), column ());
-}
+  // No-op.
 
-void
-tree_no_op_command::accept (tree_walker& tw)
-{
-  tw.visit_no_op_command (*this);
-}
+  tree_command *
+  tree_no_op_command::dup (symbol_table::scope_id,
+                           symbol_table::context_id) const
+  {
+    return new tree_no_op_command (orig_cmd, is_end_of_file (),
+                                   line (), column ());
+  }
 
-// Function definition.
+  void
+  tree_no_op_command::accept (tree_walker& tw)
+  {
+    tw.visit_no_op_command (*this);
+  }
+
+  // Function definition.
 
-tree_command *
-tree_function_def::dup (symbol_table::scope_id,
-                        symbol_table::context_id) const
-{
-  return new tree_function_def (fcn, line (), column ());
+  tree_command *
+  tree_function_def::dup (symbol_table::scope_id,
+                          symbol_table::context_id) const
+  {
+    return new tree_function_def (fcn, line (), column ());
+  }
+
+  void
+  tree_function_def::accept (tree_walker& tw)
+  {
+    tw.visit_function_def (*this);
+  }
 }
-
-void
-tree_function_def::accept (tree_walker& tw)
-{
-  tw.visit_function_def (*this);
-}
-
diff --git a/libinterp/parse-tree/pt-cmd.h b/libinterp/parse-tree/pt-cmd.h
--- a/libinterp/parse-tree/pt-cmd.h
+++ b/libinterp/parse-tree/pt-cmd.h
@@ -22,112 +22,124 @@ along with Octave; see the file COPYING.
 
 #if ! defined (octave_pt_cmd_h)
 #define octave_pt_cmd_h 1
 
 #include "octave-config.h"
 
 #include <string>
 
-class tree_walker;
-
 #include "ov-fcn.h"
 #include "pt.h"
 #include "pt-bp.h"
 #include "symtab.h"
 
-// A base class for commands.
-
-class
-tree_command : public tree
+namespace octave
 {
-public:
+  class tree_walker;
+
+  // A base class for commands.
 
-  tree_command (int l = -1, int c = -1)
-    : tree (l, c) { }
+  class tree_command : public tree
+  {
+  public:
 
-  // No copying!
+    tree_command (int l = -1, int c = -1)
+      : tree (l, c) { }
 
-  tree_command (const tree_command&) = delete;
+    // No copying!
 
-  tree_command& operator = (const tree_command&) = delete;
+    tree_command (const tree_command&) = delete;
 
-  virtual ~tree_command (void) = default;
+    tree_command& operator = (const tree_command&) = delete;
+
+    virtual ~tree_command (void) = default;
 
-  virtual tree_command *dup (symbol_table::scope_id,
-                             symbol_table::context_id context) const = 0;
-};
+    virtual tree_command *dup (symbol_table::scope_id,
+                               symbol_table::context_id context) const = 0;
+  };
 
-// No-op.
+  // No-op.
+
+  class tree_no_op_command : public tree_command
+  {
+  public:
 
-class
-tree_no_op_command : public tree_command
-{
-public:
+    tree_no_op_command (const std::string& cmd = "no_op", bool e = false,
+                        int l = -1, int c = -1)
+      : tree_command (l, c), eof (e), orig_cmd (cmd) { }
 
-  tree_no_op_command (const std::string& cmd = "no_op", bool e = false,
-                      int l = -1, int c = -1)
-    : tree_command (l, c), eof (e), orig_cmd (cmd) { }
+    // No copying!
+
+    tree_no_op_command (const tree_no_op_command&) = delete;
 
-  // No copying!
+    tree_no_op_command& operator = (const tree_no_op_command&) = delete;
 
-  tree_no_op_command (const tree_no_op_command&) = delete;
+    ~tree_no_op_command (void) = default;
 
-  tree_no_op_command& operator = (const tree_no_op_command&) = delete;
+    tree_command *dup (symbol_table::scope_id scope,
+                       symbol_table::context_id context) const;
 
-  ~tree_no_op_command (void) = default;
+    void accept (tree_walker& tw);
 
-  tree_command *dup (symbol_table::scope_id scope,
-                     symbol_table::context_id context) const;
-
-  void accept (tree_walker& tw);
+    bool is_end_of_fcn_or_script (void) const
+    {
+      return (orig_cmd == "endfunction" || orig_cmd == "endscript");
+    }
 
-  bool is_end_of_fcn_or_script (void) const
-  {
-    return (orig_cmd == "endfunction" || orig_cmd == "endscript");
-  }
+    bool is_end_of_file (void) const { return eof; }
+
+    std::string original_command (void) { return orig_cmd; }
+
+  private:
 
-  bool is_end_of_file (void) const { return eof; }
+    bool eof;
 
-  std::string original_command (void) { return orig_cmd; }
+    std::string orig_cmd;
+  };
 
-private:
+  // Function definition.
 
-  bool eof;
-
-  std::string orig_cmd;
-};
+  class tree_function_def : public tree_command
+  {
+  public:
 
-// Function definition.
+    tree_function_def (octave_function *f, int l = -1, int c = -1)
+      : tree_command (l, c), fcn (f) { }
 
-class
-tree_function_def : public tree_command
-{
-public:
+    // No copying!
+
+    tree_function_def (const tree_function_def&) = delete;
+
+    tree_function_def& operator = (const tree_function_def&) = delete;
 
-  tree_function_def (octave_function *f, int l = -1, int c = -1)
-    : tree_command (l, c), fcn (f) { }
+    ~tree_function_def (void) = default;
 
-  // No copying!
+    tree_command *dup (symbol_table::scope_id scope,
+                       symbol_table::context_id context) const;
 
-  tree_function_def (const tree_function_def&) = delete;
+    void accept (tree_walker& tw);
+
+    octave_value function (void) { return fcn; }
 
-  tree_function_def& operator = (const tree_function_def&) = delete;
+  private:
 
-  ~tree_function_def (void) = default;
+    octave_value fcn;
 
-  tree_command *dup (symbol_table::scope_id scope,
-                     symbol_table::context_id context) const;
+    tree_function_def (const octave_value& v, int l = -1, int c = -1)
+      : tree_command (l, c), fcn (v) { }
+  };
+}
 
-  void accept (tree_walker& tw);
-
-  octave_value function (void) { return fcn; }
+#if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
 
-private:
-
-  octave_value fcn;
+OCTAVE_DEPRECATED ("use 'octave::tree_command' instead")
+typedef octave::tree_command tree_command;
 
-  tree_function_def (const octave_value& v, int l = -1, int c = -1)
-    : tree_command (l, c), fcn (v) { }
-};
+OCTAVE_DEPRECATED ("use 'octave::tree_no_op_command' instead")
+typedef octave::tree_no_op_command tree_no_op_command;
+
+OCTAVE_DEPRECATED ("use 'octave::tree_function_def' instead")
+typedef octave::tree_function_def tree_function_def;
 
 #endif
 
+#endif
diff --git a/libinterp/parse-tree/pt-colon.cc b/libinterp/parse-tree/pt-colon.cc
--- a/libinterp/parse-tree/pt-colon.cc
+++ b/libinterp/parse-tree/pt-colon.cc
@@ -27,147 +27,149 @@ along with Octave; see the file COPYING.
 #include "error.h"
 #include "ovl.h"
 #include "pager.h"
 #include "ov.h"
 #include "pt-bp.h"
 #include "pt-colon.h"
 #include "pt-walk.h"
 
-// Colon expressions.
-
-tree_colon_expression *
-tree_colon_expression::append (tree_expression *t)
-{
-  tree_colon_expression *retval = 0;
-
-  if (! op_base)
-    error ("invalid colon expression");
-
-  if (op_limit)
-    {
-      if (op_increment)
-        error ("invalid colon expression");
-
-      // Stupid syntax:
-      //
-      // base : limit
-      // base : increment : limit
-
-      op_increment = op_limit;
-      op_limit = t;
-    }
-  else
-    op_limit = t;
-
-  retval = this;
-
-  return retval;
-}
-
-octave_value_list
-tree_colon_expression::rvalue (int nargout)
+namespace octave
 {
-  if (nargout > 1)
-    error ("invalid number of output arguments for colon expression");
+  // Colon expressions.
 
-  return rvalue1 (nargout);
-}
+  tree_colon_expression *
+  tree_colon_expression::append (tree_expression *t)
+  {
+    tree_colon_expression *retval = 0;
+
+    if (! op_base)
+      error ("invalid colon expression");
 
-octave_value
-tree_colon_expression::rvalue1 (int)
-{
-  octave_value retval;
+    if (op_limit)
+      {
+        if (op_increment)
+          error ("invalid colon expression");
 
-  if (! op_base || ! op_limit)
-    return retval;
+        // Stupid syntax:
+        //
+        // base : limit
+        // base : increment : limit
 
-  octave_value ov_base = op_base->rvalue1 ();
+        op_increment = op_limit;
+        op_limit = t;
+      }
+    else
+      op_limit = t;
 
-  octave_value ov_limit = op_limit->rvalue1 ();
+    retval = this;
 
-  if (ov_base.is_object () || ov_limit.is_object ())
-    {
-      octave_value_list tmp1;
+    return retval;
+  }
 
-      if (op_increment)
-        {
-          octave_value ov_increment = op_increment->rvalue1 ();
+  octave_value_list
+  tree_colon_expression::rvalue (int nargout)
+  {
+    if (nargout > 1)
+      error ("invalid number of output arguments for colon expression");
+
+    return rvalue1 (nargout);
+  }
 
-          tmp1(2) = ov_limit;
-          tmp1(1) = ov_increment;
-          tmp1(0) = ov_base;
-        }
-      else
-        {
-          tmp1(1) = ov_limit;
-          tmp1(0) = ov_base;
-        }
+  octave_value
+  tree_colon_expression::rvalue1 (int)
+  {
+    octave_value retval;
+
+    if (! op_base || ! op_limit)
+      return retval;
+
+    octave_value ov_base = op_base->rvalue1 ();
+
+    octave_value ov_limit = op_limit->rvalue1 ();
+
+    if (ov_base.is_object () || ov_limit.is_object ())
+      {
+        octave_value_list tmp1;
+
+        if (op_increment)
+          {
+            octave_value ov_increment = op_increment->rvalue1 ();
 
-      octave_value fcn = symbol_table::find_function ("colon", tmp1);
-
-      if (! fcn.is_defined ())
-        error ("can not find overloaded colon function");
+            tmp1(2) = ov_limit;
+            tmp1(1) = ov_increment;
+            tmp1(0) = ov_base;
+          }
+        else
+          {
+            tmp1(1) = ov_limit;
+            tmp1(0) = ov_base;
+          }
 
-      octave_value_list tmp2 = fcn.do_multi_index_op (1, tmp1);
+        octave_value fcn = symbol_table::find_function ("colon", tmp1);
 
-      retval = tmp2 (0);
-    }
-  else
-    {
-      octave_value ov_increment = 1.0;
+        if (! fcn.is_defined ())
+          error ("can not find overloaded colon function");
+
+        octave_value_list tmp2 = fcn.do_multi_index_op (1, tmp1);
 
-      if (op_increment)
-        ov_increment = op_increment->rvalue1 ();
+        retval = tmp2 (0);
+      }
+    else
+      {
+        octave_value ov_increment = 1.0;
 
-      retval = do_colon_op (ov_base, ov_increment, ov_limit,
-                            is_for_cmd_expr ());
-    }
+        if (op_increment)
+          ov_increment = op_increment->rvalue1 ();
 
-  return retval;
-}
+        retval = do_colon_op (ov_base, ov_increment, ov_limit,
+                              is_for_cmd_expr ());
+      }
 
-void
-tree_colon_expression::eval_error (const std::string& s) const
-{
-  error ("%s", s.c_str ());
-}
+    return retval;
+  }
+
+  void
+  tree_colon_expression::eval_error (const std::string& s) const
+  {
+    error ("%s", s.c_str ());
+  }
 
-int
-tree_colon_expression::line (void) const
-{
-  return (op_base ? op_base->line ()
-          : (op_increment ? op_increment->line ()
-             : (op_limit ? op_limit->line ()
-                : -1)));
-}
+  int
+  tree_colon_expression::line (void) const
+  {
+    return (op_base ? op_base->line ()
+            : (op_increment ? op_increment->line ()
+               : (op_limit ? op_limit->line ()
+                  : -1)));
+  }
 
-int
-tree_colon_expression::column (void) const
-{
-  return (op_base ? op_base->column ()
-          : (op_increment ? op_increment->column ()
-             : (op_limit ? op_limit->column ()
-                : -1)));
-}
+  int
+  tree_colon_expression::column (void) const
+  {
+    return (op_base ? op_base->column ()
+            : (op_increment ? op_increment->column ()
+               : (op_limit ? op_limit->column ()
+                  : -1)));
+  }
 
-tree_expression *
-tree_colon_expression::dup (symbol_table::scope_id scope,
-                            symbol_table::context_id context) const
-{
-  tree_colon_expression *new_ce = new
-    tree_colon_expression (op_base ? op_base->dup (scope, context) : 0,
-                           op_limit ? op_limit->dup (scope, context) : 0,
-                           op_increment ? op_increment->dup (scope, context)
-                                        : 0,
-                           line (), column ());
+  tree_expression *
+  tree_colon_expression::dup (symbol_table::scope_id scope,
+                              symbol_table::context_id context) const
+  {
+    tree_colon_expression *new_ce = new
+      tree_colon_expression (op_base ? op_base->dup (scope, context) : 0,
+                             op_limit ? op_limit->dup (scope, context) : 0,
+                             op_increment ? op_increment->dup (scope, context)
+                             : 0,
+                             line (), column ());
 
-  new_ce->copy_base (*new_ce);
+    new_ce->copy_base (*new_ce);
 
-  return new_ce;
-}
+    return new_ce;
+  }
 
-void
-tree_colon_expression::accept (tree_walker& tw)
-{
-  tw.visit_colon_expression (*this);
+  void
+  tree_colon_expression::accept (tree_walker& tw)
+  {
+    tw.visit_colon_expression (*this);
+  }
 }
-
diff --git a/libinterp/parse-tree/pt-colon.h b/libinterp/parse-tree/pt-colon.h
--- a/libinterp/parse-tree/pt-colon.h
+++ b/libinterp/parse-tree/pt-colon.h
@@ -22,97 +22,105 @@ along with Octave; see the file COPYING.
 
 #if ! defined (octave_pt_colon_h)
 #define octave_pt_colon_h 1
 
 #include "octave-config.h"
 
 #include <string>
 
-class tree_walker;
-
 class octave_value;
 class octave_value_list;
 class octave_lvalue;
 
 #include "pt-exp.h"
 #include "symtab.h"
 
-// Colon expressions.
-
-class
-tree_colon_expression : public tree_expression
+namespace octave
 {
-public:
-
-  tree_colon_expression (int l = -1, int c = -1)
-    : tree_expression (l, c), op_base (0), op_limit (0),
-      op_increment (0), save_base (false) { }
-
-  tree_colon_expression (tree_expression *e, int l = -1, int c = -1)
-    : tree_expression (l, c), op_base (e), op_limit (0),
-      op_increment (0), save_base (false) { }
+  class tree_walker;
 
-  tree_colon_expression (tree_expression *bas, tree_expression *lim,
-                         tree_expression *inc, int l = -1, int c = -1)
-    : tree_expression (l, c), op_base (bas), op_limit (lim),
-      op_increment (inc), save_base (false) { }
-
-  // No copying!
-
-  tree_colon_expression (const tree_colon_expression&) = delete;
-
-  tree_colon_expression& operator = (const tree_colon_expression&) = delete;
+  // Colon expressions.
 
-  ~tree_colon_expression (void)
-  {
-    if (! save_base)
-      delete op_base;
-
-    delete op_limit;
-    delete op_increment;
-  }
-
-  bool has_magic_end (void) const
+  class tree_colon_expression : public tree_expression
   {
-    return ((op_base && op_base->has_magic_end ())
-            || (op_limit && op_limit->has_magic_end ())
-            || (op_increment && op_increment->has_magic_end ()));
-  }
+  public:
+
+    tree_colon_expression (int l = -1, int c = -1)
+      : tree_expression (l, c), op_base (0), op_limit (0),
+        op_increment (0), save_base (false) { }
 
-  void preserve_base (void) { save_base = true; }
+    tree_colon_expression (tree_expression *e, int l = -1, int c = -1)
+      : tree_expression (l, c), op_base (e), op_limit (0),
+        op_increment (0), save_base (false) { }
 
-  tree_colon_expression *append (tree_expression *t);
+    tree_colon_expression (tree_expression *bas, tree_expression *lim,
+                           tree_expression *inc, int l = -1, int c = -1)
+      : tree_expression (l, c), op_base (bas), op_limit (lim),
+        op_increment (inc), save_base (false) { }
+
+    // No copying!
+
+    tree_colon_expression (const tree_colon_expression&) = delete;
 
-  bool rvalue_ok (void) const { return true; }
+    tree_colon_expression& operator = (const tree_colon_expression&) = delete;
 
-  octave_value rvalue1 (int nargout = 1);
+    ~tree_colon_expression (void)
+    {
+      if (! save_base)
+        delete op_base;
 
-  octave_value_list rvalue (int nargout);
+      delete op_limit;
+      delete op_increment;
+    }
 
-  void eval_error (const std::string& s) const;
+    bool has_magic_end (void) const
+    {
+      return ((op_base && op_base->has_magic_end ())
+              || (op_limit && op_limit->has_magic_end ())
+              || (op_increment && op_increment->has_magic_end ()));
+    }
 
-  tree_expression *base (void) { return op_base; }
+    void preserve_base (void) { save_base = true; }
 
-  tree_expression *limit (void) { return op_limit; }
+    tree_colon_expression *append (tree_expression *t);
+
+    bool rvalue_ok (void) const { return true; }
 
-  tree_expression *increment (void) { return op_increment; }
+    octave_value rvalue1 (int nargout = 1);
+
+    octave_value_list rvalue (int nargout);
 
-  int line (void) const;
-  int column (void) const;
+    void eval_error (const std::string& s) const;
+
+    tree_expression *base (void) { return op_base; }
 
-  tree_expression *dup (symbol_table::scope_id scope,
-                        symbol_table::context_id context) const;
+    tree_expression *limit (void) { return op_limit; }
+
+    tree_expression *increment (void) { return op_increment; }
+
+    int line (void) const;
+    int column (void) const;
 
-  void accept (tree_walker& tw);
+    tree_expression *dup (symbol_table::scope_id scope,
+                          symbol_table::context_id context) const;
 
-private:
+    void accept (tree_walker& tw);
+
+  private:
 
-  // The components of the expression.
-  tree_expression *op_base;
-  tree_expression *op_limit;
-  tree_expression *op_increment;
+    // The components of the expression.
+    tree_expression *op_base;
+    tree_expression *op_limit;
+    tree_expression *op_increment;
 
-  bool save_base;
-};
+    bool save_base;
+  };
+}
+
+#if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
+
+OCTAVE_DEPRECATED ("use 'octave::tree_colon_expression' instead")
+typedef octave::tree_colon_expression tree_colon_expression;
 
 #endif
 
+#endif
diff --git a/libinterp/parse-tree/pt-const.cc b/libinterp/parse-tree/pt-const.cc
--- a/libinterp/parse-tree/pt-const.cc
+++ b/libinterp/parse-tree/pt-const.cc
@@ -27,62 +27,64 @@ along with Octave; see the file COPYING.
 #include <iostream>
 
 #include "error.h"
 #include "ovl.h"
 #include "pager.h"
 #include "pt-const.h"
 #include "pt-walk.h"
 
-// We are likely to have a lot of tree_constant objects to allocate,
-// so make the grow_size large.
-
-void
-tree_constant::print (std::ostream& os, bool pr_as_read_syntax,
-                      bool pr_orig_text)
-{
-  if (pr_orig_text && ! orig_text.empty ())
-    os << orig_text;
-  else
-    val.print (os, pr_as_read_syntax);
-}
-
-void
-tree_constant::print_raw (std::ostream& os, bool pr_as_read_syntax,
-                          bool pr_orig_text)
-{
-  if (pr_orig_text && ! orig_text.empty ())
-    os << orig_text;
-  else
-    val.print_raw (os, pr_as_read_syntax);
-}
-
-octave_value_list
-tree_constant::rvalue (int nargout)
+namespace octave
 {
-  octave_value_list retval;
-
-  if (nargout > 1)
-    error ("invalid number of output arguments for constant expression");
+  // We are likely to have a lot of tree_constant objects to allocate,
+  // so make the grow_size large.
 
-  retval = rvalue1 (nargout);
+  void
+  tree_constant::print (std::ostream& os, bool pr_as_read_syntax,
+                        bool pr_orig_text)
+  {
+    if (pr_orig_text && ! orig_text.empty ())
+      os << orig_text;
+    else
+      val.print (os, pr_as_read_syntax);
+  }
 
-  return retval;
-}
+  void
+  tree_constant::print_raw (std::ostream& os, bool pr_as_read_syntax,
+                            bool pr_orig_text)
+  {
+    if (pr_orig_text && ! orig_text.empty ())
+      os << orig_text;
+    else
+      val.print_raw (os, pr_as_read_syntax);
+  }
 
-tree_expression *
-tree_constant::dup (symbol_table::scope_id,
-                    symbol_table::context_id) const
-{
-  tree_constant *new_tc
-    = new tree_constant (val, orig_text, line (), column ());
+  octave_value_list
+  tree_constant::rvalue (int nargout)
+  {
+    octave_value_list retval;
 
-  new_tc->copy_base (*this);
+    if (nargout > 1)
+      error ("invalid number of output arguments for constant expression");
+
+    retval = rvalue1 (nargout);
+
+    return retval;
+  }
 
-  return new_tc;
-}
+  tree_expression *
+  tree_constant::dup (symbol_table::scope_id,
+                      symbol_table::context_id) const
+  {
+    tree_constant *new_tc
+      = new tree_constant (val, orig_text, line (), column ());
+
+    new_tc->copy_base (*this);
 
-void
-tree_constant::accept (tree_walker& tw)
-{
-  tw.visit_constant (*this);
+    return new_tc;
+  }
+
+  void
+  tree_constant::accept (tree_walker& tw)
+  {
+    tw.visit_constant (*this);
+  }
 }
-
diff --git a/libinterp/parse-tree/pt-const.h b/libinterp/parse-tree/pt-const.h
--- a/libinterp/parse-tree/pt-const.h
+++ b/libinterp/parse-tree/pt-const.h
@@ -23,83 +23,91 @@ along with Octave; see the file COPYING.
 #if ! defined (octave_pt_const_h)
 #define octave_pt_const_h 1
 
 #include "octave-config.h"
 
 #include <iosfwd>
 #include <string>
 
-
 class octave_value_list;
-class tree_walker;
 
 #include "ov.h"
 #include "pt-bp.h"
 #include "pt-exp.h"
 #include "symtab.h"
 
-class
-tree_constant : public tree_expression
+namespace octave
 {
-public:
+  class tree_walker;
 
-  tree_constant (int l = -1, int c = -1)
-    : tree_expression (l, c), val (), orig_text () { }
+  class tree_constant : public tree_expression
+  {
+  public:
 
-  tree_constant (const octave_value& v, int l = -1, int c = -1)
-    : tree_expression (l, c), val (v), orig_text () { }
+    tree_constant (int l = -1, int c = -1)
+      : tree_expression (l, c), val (), orig_text () { }
 
-  tree_constant (const octave_value& v, const std::string& ot,
-                 int l = -1, int c = -1)
-    : tree_expression (l, c), val (v), orig_text (ot) { }
+    tree_constant (const octave_value& v, int l = -1, int c = -1)
+      : tree_expression (l, c), val (v), orig_text () { }
 
-  // No copying!
-
-  tree_constant (const tree_constant&) = delete;
+    tree_constant (const octave_value& v, const std::string& ot,
+                   int l = -1, int c = -1)
+      : tree_expression (l, c), val (v), orig_text (ot) { }
 
-  tree_constant& operator = (const tree_constant&) = delete;
+    // No copying!
 
-  ~tree_constant (void) = default;
+    tree_constant (const tree_constant&) = delete;
+
+    tree_constant& operator = (const tree_constant&) = delete;
 
-  bool has_magic_end (void) const { return false; }
+    ~tree_constant (void) = default;
 
-  // Type.  It would be nice to eliminate the need for this.
+    bool has_magic_end (void) const { return false; }
 
-  bool is_constant (void) const { return true; }
+    // Type.  It would be nice to eliminate the need for this.
 
-  void maybe_mutate (void) { val.maybe_mutate (); }
+    bool is_constant (void) const { return true; }
+
+    void maybe_mutate (void) { val.maybe_mutate (); }
 
-  void print (std::ostream& os, bool pr_as_read_syntax = false,
-              bool pr_orig_txt = true);
+    void print (std::ostream& os, bool pr_as_read_syntax = false,
+                bool pr_orig_txt = true);
 
-  void print_raw (std::ostream& os, bool pr_as_read_syntax = false,
-                  bool pr_orig_txt = true);
+    void print_raw (std::ostream& os, bool pr_as_read_syntax = false,
+                    bool pr_orig_txt = true);
+
+    bool rvalue_ok (void) const { return true; }
 
-  bool rvalue_ok (void) const { return true; }
+    octave_value rvalue1 (int = 1) { return val; }
 
-  octave_value rvalue1 (int = 1) { return val; }
+    octave_value_list rvalue (int nargout);
 
-  octave_value_list rvalue (int nargout);
+    tree_expression *dup (symbol_table::scope_id scope,
+                          symbol_table::context_id context) const;
 
-  tree_expression *dup (symbol_table::scope_id scope,
-                        symbol_table::context_id context) const;
+    void accept (tree_walker& tw);
 
-  void accept (tree_walker& tw);
+    // Store the original text corresponding to this constant for later
+    // pretty printing.
 
-  // Store the original text corresponding to this constant for later
-  // pretty printing.
+    void stash_original_text (const std::string& s) { orig_text = s; }
 
-  void stash_original_text (const std::string& s) { orig_text = s; }
+    std::string original_text (void) const { return orig_text; }
 
-  std::string original_text (void) const { return orig_text; }
+  private:
 
-private:
+    // The actual value that this constant refers to.
+    octave_value val;
 
-  // The actual value that this constant refers to.
-  octave_value val;
+    // The original text form of this constant.
+    std::string orig_text;
+  };
+}
 
-  // The original text form of this constant.
-  std::string orig_text;
-};
+#if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
+
+OCTAVE_DEPRECATED ("use 'octave::tree_constant' instead")
+typedef octave::tree_constant tree_constant;
 
 #endif
 
+#endif
diff --git a/libinterp/parse-tree/pt-decl.cc b/libinterp/parse-tree/pt-decl.cc
--- a/libinterp/parse-tree/pt-decl.cc
+++ b/libinterp/parse-tree/pt-decl.cc
@@ -32,111 +32,113 @@ along with Octave; see the file COPYING.
 #include "pt-bp.h"
 #include "pt-decl.h"
 #include "pt-exp.h"
 #include "pt-id.h"
 #include "pt-walk.h"
 #include "utils.h"
 #include "variables.h"
 
-// Declarations (global, static, etc.).
-
-tree_decl_elt::~tree_decl_elt (void)
-{
-  delete id;
-  delete expr;
-}
-
-bool
-tree_decl_elt::eval (void)
+namespace octave
 {
-  bool retval = false;
+  // Declarations (global, static, etc.).
 
-  if (id && expr)
-    {
-      octave_lvalue ult = id->lvalue ();
+  tree_decl_elt::~tree_decl_elt (void)
+  {
+    delete id;
+    delete expr;
+  }
 
-      octave_value init_val = expr->rvalue1 ();
+  bool
+  tree_decl_elt::eval (void)
+  {
+    bool retval = false;
 
-      ult.assign (octave_value::op_asn_eq, init_val);
+    if (id && expr)
+      {
+        octave_lvalue ult = id->lvalue ();
 
-      retval = true;
-    }
+        octave_value init_val = expr->rvalue1 ();
+
+        ult.assign (octave_value::op_asn_eq, init_val);
 
-  return retval;
-}
+        retval = true;
+      }
+
+    return retval;
+  }
 
-tree_decl_elt *
-tree_decl_elt::dup (symbol_table::scope_id scope,
-                    symbol_table::context_id context) const
-{
-  return new tree_decl_elt (id ? id->dup (scope, context) : 0,
-                            expr ? expr->dup (scope, context) : 0);
-}
+  tree_decl_elt *
+  tree_decl_elt::dup (symbol_table::scope_id scope,
+                      symbol_table::context_id context) const
+  {
+    return new tree_decl_elt (id ? id->dup (scope, context) : 0,
+                              expr ? expr->dup (scope, context) : 0);
+  }
 
-void
-tree_decl_elt::accept (tree_walker& tw)
-{
-  tw.visit_decl_elt (*this);
-}
-
-// Initializer lists for declaration statements.
+  void
+  tree_decl_elt::accept (tree_walker& tw)
+  {
+    tw.visit_decl_elt (*this);
+  }
 
-tree_decl_init_list *
-tree_decl_init_list::dup (symbol_table::scope_id scope,
-                          symbol_table::context_id context) const
-{
-  tree_decl_init_list *new_dil = new tree_decl_init_list ();
+  // Initializer lists for declaration statements.
 
-  for (const tree_decl_elt* elt : *this)
-    new_dil->append (elt ? elt->dup (scope, context) : 0);
+  tree_decl_init_list *
+  tree_decl_init_list::dup (symbol_table::scope_id scope,
+                            symbol_table::context_id context) const
+  {
+    tree_decl_init_list *new_dil = new tree_decl_init_list ();
 
-  return new_dil;
-}
+    for (const tree_decl_elt* elt : *this)
+      new_dil->append (elt ? elt->dup (scope, context) : 0);
+
+    return new_dil;
+  }
 
-void
-tree_decl_init_list::accept (tree_walker& tw)
-{
-  tw.visit_decl_init_list (*this);
-}
+  void
+  tree_decl_init_list::accept (tree_walker& tw)
+  {
+    tw.visit_decl_init_list (*this);
+  }
 
-// Base class for declaration commands (global, static).
+  // Base class for declaration commands (global, static).
+
+  tree_decl_command::~tree_decl_command (void)
+  {
+    delete init_list;
+  }
+
+  // Global.
 
-tree_decl_command::~tree_decl_command (void)
-{
-  delete init_list;
-}
+  tree_command *
+  tree_global_command::dup (symbol_table::scope_id scope,
+                            symbol_table::context_id context) const
+  {
+    return
+      new tree_global_command (init_list ? init_list->dup (scope, context) : 0,
+                               line (), column ());
+  }
 
-// Global.
+  void
+  tree_global_command::accept (tree_walker& tw)
+  {
+    tw.visit_global_command (*this);
+  }
 
-tree_command *
-tree_global_command::dup (symbol_table::scope_id scope,
-                          symbol_table::context_id context) const
-{
-  return
-    new tree_global_command (init_list ? init_list->dup (scope, context) : 0,
-                             line (), column ());
+  // Static.
+
+  tree_command *
+  tree_persistent_command::dup (symbol_table::scope_id scope,
+                                symbol_table::context_id context) const
+  {
+    return
+      new tree_persistent_command (init_list ? init_list->dup (scope, context)
+                                   : 0,
+                                   line (), column ());
+  }
+
+  void
+  tree_persistent_command::accept (tree_walker& tw)
+  {
+    tw.visit_persistent_command (*this);
+  }
 }
-
-void
-tree_global_command::accept (tree_walker& tw)
-{
-  tw.visit_global_command (*this);
-}
-
-// Static.
-
-tree_command *
-tree_persistent_command::dup (symbol_table::scope_id scope,
-                              symbol_table::context_id context) const
-{
-  return
-    new tree_persistent_command (init_list ? init_list->dup (scope, context)
-                                           : 0,
-                                 line (), column ());
-}
-
-void
-tree_persistent_command::accept (tree_walker& tw)
-{
-  tw.visit_persistent_command (*this);
-}
-
diff --git a/libinterp/parse-tree/pt-decl.h b/libinterp/parse-tree/pt-decl.h
--- a/libinterp/parse-tree/pt-decl.h
+++ b/libinterp/parse-tree/pt-decl.h
@@ -20,223 +20,238 @@ along with Octave; see the file COPYING.
 
 */
 
 #if ! defined (octave_pt_decl_h)
 #define octave_pt_decl_h 1
 
 #include "octave-config.h"
 
-class tree_expression;
-class tree_identifier;
-
-class tree_walker;
-
 #include <string>
 
 #include "base-list.h"
 #include "oct-lvalue.h"
 #include "pt-cmd.h"
 #include "pt-id.h"
 #include "symtab.h"
 
-// List of expressions that make up a declaration statement.
-
-class
-tree_decl_elt
+namespace octave
 {
-public:
+  class tree_expression;
+  class tree_identifier;
+
+  class tree_walker;
 
-  tree_decl_elt (tree_identifier *i = 0, tree_expression *e = 0)
-    : id (i), expr (e) { }
+  // List of expressions that make up a declaration statement.
 
-  // No copying!
+  class tree_decl_elt
+  {
+  public:
 
-  tree_decl_elt (const tree_decl_elt&) = delete;
+    tree_decl_elt (tree_identifier *i = 0, tree_expression *e = 0)
+      : id (i), expr (e) { }
 
-  tree_decl_elt& operator = (const tree_decl_elt&) = delete;
-
-  ~tree_decl_elt (void);
+    // No copying!
 
-  bool eval (void);
+    tree_decl_elt (const tree_decl_elt&) = delete;
+
+    tree_decl_elt& operator = (const tree_decl_elt&) = delete;
 
-  bool is_defined (void) { return id ? id->is_defined () : false; }
+    ~tree_decl_elt (void);
 
-  bool is_variable (void) { return id ? id->is_variable () : false; }
+    bool eval (void);
 
-  void mark_as_formal_parameter (void)
-  {
-    if (id)
-      id->mark_as_formal_parameter ();
-  }
+    bool is_defined (void) { return id ? id->is_defined () : false; }
+
+    bool is_variable (void) { return id ? id->is_variable () : false; }
 
-  bool lvalue_ok (void) { return id ? id->lvalue_ok () : false; }
+    void mark_as_formal_parameter (void)
+    {
+      if (id)
+        id->mark_as_formal_parameter ();
+    }
+
+    bool lvalue_ok (void) { return id ? id->lvalue_ok () : false; }
 
-  // Do not allow functions to return null values.
-  octave_value rvalue1 (int nargout = 1)
-  {
-    return id ? id->rvalue1 (nargout).storable_value () : octave_value ();
-  }
+    // Do not allow functions to return null values.
+    octave_value rvalue1 (int nargout = 1)
+    {
+      return id ? id->rvalue1 (nargout).storable_value () : octave_value ();
+    }
 
-  octave_value_list rvalue (int nargout)
-  {
-    octave_value_list retval;
+    octave_value_list rvalue (int nargout)
+    {
+      octave_value_list retval;
 
-    if (nargout > 1)
-      error ("invalid number of output arguments in declaration list");
+      if (nargout > 1)
+        error ("invalid number of output arguments in declaration list");
 
-    retval = rvalue1 (nargout);
-
-    return retval;
-  }
+      retval = rvalue1 (nargout);
 
-  octave_lvalue lvalue (void) { return id ? id->lvalue () : octave_lvalue (); }
+      return retval;
+    }
 
-  tree_identifier *ident (void) { return id; }
+    octave_lvalue lvalue (void) { return id ? id->lvalue () : octave_lvalue (); }
 
-  std::string name (void) { return id ? id->name () : ""; }
+    tree_identifier *ident (void) { return id; }
 
-  tree_expression *expression (void) { return expr; }
+    std::string name (void) { return id ? id->name () : ""; }
 
-  tree_decl_elt *dup (symbol_table::scope_id scope,
-                      symbol_table::context_id context) const;
+    tree_expression *expression (void) { return expr; }
 
-  void accept (tree_walker& tw);
+    tree_decl_elt *dup (symbol_table::scope_id scope,
+                        symbol_table::context_id context) const;
 
-private:
+    void accept (tree_walker& tw);
+
+  private:
 
-  // An identifier to tag with the declared property.
-  tree_identifier *id;
+    // An identifier to tag with the declared property.
+    tree_identifier *id;
 
-  // An initializer expression (may be zero);
-  tree_expression *expr;
-};
+    // An initializer expression (may be zero);
+    tree_expression *expr;
+  };
 
-class
-tree_decl_init_list : public octave::base_list<tree_decl_elt *>
-{
-public:
+  class tree_decl_init_list : public octave::base_list<tree_decl_elt *>
+  {
+  public:
+
+    tree_decl_init_list (void) { }
 
-  tree_decl_init_list (void) { }
+    tree_decl_init_list (tree_decl_elt *t) { append (t); }
 
-  tree_decl_init_list (tree_decl_elt *t) { append (t); }
+    // No copying!
 
-  // No copying!
+    tree_decl_init_list (const tree_decl_init_list&) = delete;
 
-  tree_decl_init_list (const tree_decl_init_list&) = delete;
+    tree_decl_init_list& operator = (const tree_decl_init_list&) = delete;
 
-  tree_decl_init_list& operator = (const tree_decl_init_list&) = delete;
+    ~tree_decl_init_list (void)
+    {
+      while (! empty ())
+        {
+          iterator p = begin ();
+          delete *p;
+          erase (p);
+        }
+    }
 
-  ~tree_decl_init_list (void)
-  {
-    while (! empty ())
-      {
-        iterator p = begin ();
-        delete *p;
-        erase (p);
-      }
-  }
+    tree_decl_init_list *dup (symbol_table::scope_id scope,
+                              symbol_table::context_id context) const;
 
-  tree_decl_init_list *dup (symbol_table::scope_id scope,
-                            symbol_table::context_id context) const;
+    void accept (tree_walker& tw);
+  };
 
-  void accept (tree_walker& tw);
-};
+  // Base class for declaration commands -- global, static, etc.
 
-// Base class for declaration commands -- global, static, etc.
+  class tree_decl_command : public tree_command
+  {
+  public:
 
-class
-tree_decl_command : public tree_command
-{
-public:
+    tree_decl_command (const std::string& n, int l = -1, int c = -1)
+      : tree_command (l, c), cmd_name (n), init_list (0) { }
+
+    tree_decl_command (const std::string& n, tree_decl_init_list *t,
+                       int l = -1, int c = -1)
+      : tree_command (l, c), cmd_name (n), init_list (t) { }
 
-  tree_decl_command (const std::string& n, int l = -1, int c = -1)
-    : tree_command (l, c), cmd_name (n), init_list (0) { }
+    // No copying!
+
+    tree_decl_command (const tree_decl_command&) = delete;
+
+    tree_decl_command& operator = (const tree_decl_command&) = delete;
 
-  tree_decl_command (const std::string& n, tree_decl_init_list *t,
-                     int l = -1, int c = -1)
-    : tree_command (l, c), cmd_name (n), init_list (t) { }
+    ~tree_decl_command (void);
+
+    tree_decl_init_list *initializer_list (void) { return init_list; }
 
-  // No copying!
+    std::string name (void) { return cmd_name; }
 
-  tree_decl_command (const tree_decl_command&) = delete;
-
-  tree_decl_command& operator = (const tree_decl_command&) = delete;
+  protected:
 
-  ~tree_decl_command (void);
-
-  tree_decl_init_list *initializer_list (void) { return init_list; }
+    // The name of this command -- global, static, etc.
+    std::string cmd_name;
 
-  std::string name (void) { return cmd_name; }
+    // The list of variables or initializers in this declaration command.
+    tree_decl_init_list *init_list;
+  };
 
-protected:
+  // Global.
 
-  // The name of this command -- global, static, etc.
-  std::string cmd_name;
+  class tree_global_command : public tree_decl_command
+  {
+  public:
 
-  // The list of variables or initializers in this declaration command.
-  tree_decl_init_list *init_list;
-};
+    tree_global_command (int l = -1, int c = -1)
+      : tree_decl_command ("global", l, c) { }
 
-// Global.
+    tree_global_command (tree_decl_init_list *t, int l = -1, int c = -1)
+      : tree_decl_command ("global", t, l, c) { }
 
-class
-tree_global_command : public tree_decl_command
-{
-public:
+    // No copying!
+
+    tree_global_command (const tree_global_command&) = delete;
 
-  tree_global_command (int l = -1, int c = -1)
-    : tree_decl_command ("global", l, c) { }
+    tree_global_command& operator = (const tree_global_command&) = delete;
+
+    ~tree_global_command (void) = default;
 
-  tree_global_command (tree_decl_init_list *t, int l = -1, int c = -1)
-    : tree_decl_command ("global", t, l, c) { }
+    tree_command *dup (symbol_table::scope_id scope,
+                       symbol_table::context_id context) const;
 
-  // No copying!
+    void accept (tree_walker& tw);
 
-  tree_global_command (const tree_global_command&) = delete;
+  private:
 
-  tree_global_command& operator = (const tree_global_command&) = delete;
+    static void do_init (tree_decl_elt& elt);
+  };
 
-  ~tree_global_command (void) = default;
+  // Persistent.
 
-  tree_command *dup (symbol_table::scope_id scope,
-                     symbol_table::context_id context) const;
+  class tree_persistent_command : public tree_decl_command
+  {
+  public:
 
-  void accept (tree_walker& tw);
+    tree_persistent_command (int l = -1, int c = -1)
+      : tree_decl_command ("persistent", l, c) { }
 
-private:
+    tree_persistent_command (tree_decl_init_list *t, int l = -1, int c = -1)
+      : tree_decl_command ("persistent", t, l, c) { }
 
-  static void do_init (tree_decl_elt& elt);
-};
+    // No copying!
 
-// Persistent.
+    tree_persistent_command (const tree_persistent_command&) = delete;
+
+    tree_persistent_command& operator = (const tree_persistent_command&) = delete;
 
-class
-tree_persistent_command : public tree_decl_command
-{
-public:
+    ~tree_persistent_command (void) = default;
+
+    tree_command *dup (symbol_table::scope_id scope,
+                       symbol_table::context_id context) const;
 
-  tree_persistent_command (int l = -1, int c = -1)
-    : tree_decl_command ("persistent", l, c) { }
+    void accept (tree_walker& tw);
+
+  private:
 
-  tree_persistent_command (tree_decl_init_list *t, int l = -1, int c = -1)
-    : tree_decl_command ("persistent", t, l, c) { }
-
-  // No copying!
+    static void do_init (tree_decl_elt& elt);
+  };
+}
 
-  tree_persistent_command (const tree_persistent_command&) = delete;
+#if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
 
-  tree_persistent_command& operator = (const tree_persistent_command&) = delete;
+OCTAVE_DEPRECATED ("use 'octave::tree_decl_elt' instead")
+typedef octave::tree_decl_elt tree_decl_elt;
 
-  ~tree_persistent_command (void) = default;
+// tree_decl_init_list is derived from a template.
 
-  tree_command *dup (symbol_table::scope_id scope,
-                     symbol_table::context_id context) const;
-
-  void accept (tree_walker& tw);
+OCTAVE_DEPRECATED ("use 'octave::tree_decl_command' instead")
+typedef octave::tree_decl_command tree_decl_command;
 
-private:
+OCTAVE_DEPRECATED ("use 'octave::tree_global_command' instead")
+typedef octave::tree_global_command tree_global_command;
 
-  static void do_init (tree_decl_elt& elt);
-};
+OCTAVE_DEPRECATED ("use 'octave::tree_persistent_command' instead")
+typedef octave::tree_persistent_command tree_persistent_command;
 
 #endif
 
+#endif
diff --git a/libinterp/parse-tree/pt-eval.cc b/libinterp/parse-tree/pt-eval.cc
--- a/libinterp/parse-tree/pt-eval.cc
+++ b/libinterp/parse-tree/pt-eval.cc
@@ -132,56 +132,56 @@ namespace octave
   tree_evaluator::statement_printing_enabled (void)
   {
     return ! (Vsilent_functions && (statement_context == function
                                     || statement_context == script));
   }
 }
 
 static inline void
-do_global_init (tree_decl_elt& elt)
+do_global_init (octave::tree_decl_elt& elt)
 {
-  tree_identifier *id = elt.ident ();
+  octave::tree_identifier *id = elt.ident ();
 
   if (id)
     {
       id->mark_global ();
 
       octave_lvalue ult = id->lvalue ();
 
       if (ult.is_undefined ())
         {
-          tree_expression *expr = elt.expression ();
+          octave::tree_expression *expr = elt.expression ();
 
           octave_value init_val;
 
           if (expr)
             init_val = expr->rvalue1 ();
           else
             init_val = Matrix ();
 
           ult.assign (octave_value::op_asn_eq, init_val);
         }
     }
 }
 
 static inline void
-do_static_init (tree_decl_elt& elt)
+do_static_init (octave::tree_decl_elt& elt)
 {
-  tree_identifier *id = elt.ident ();
+  octave::tree_identifier *id = elt.ident ();
 
   if (id)
     {
       id->mark_as_static ();
 
       octave_lvalue ult = id->lvalue ();
 
       if (ult.is_undefined ())
         {
-          tree_expression *expr = elt.expression ();
+          octave::tree_expression *expr = elt.expression ();
 
           octave_value init_val;
 
           if (expr)
             init_val = expr->rvalue1 ();
           else
             init_val = Matrix ();
 
@@ -1226,9 +1226,8 @@ The original variable value is restored 
 %! old_val = silent_functions (! orig_val);
 %! assert (orig_val, old_val);
 %! assert (silent_functions (), ! orig_val);
 %! silent_functions (orig_val);
 %! assert (silent_functions (), orig_val);
 
 %!error (silent_functions (1, 2))
 */
-
diff --git a/libinterp/parse-tree/pt-eval.h b/libinterp/parse-tree/pt-eval.h
--- a/libinterp/parse-tree/pt-eval.h
+++ b/libinterp/parse-tree/pt-eval.h
@@ -27,35 +27,33 @@ along with Octave; see the file COPYING.
 
 #include <stack>
 #include <string>
 
 #include "comment-list.h"
 #include "ovl.h"
 #include "pt-walk.h"
 
-class tree_expression;
-
 namespace octave
 {
+  class tree_expression;
+
   class interpreter;
 
   // How to evaluate the code that the parse trees represent.
 
-  class
-  OCTINTERP_API
-  tree_evaluator : public tree_walker
+  class OCTINTERP_API tree_evaluator : public tree_walker
   {
   public:
 
     typedef void (*decl_elt_init_fcn) (tree_decl_elt&);
 
     tree_evaluator (interpreter *interp_context)
       : m_interp_context (interp_context)
-    { }
+      { }
 
     // No copying!
 
     tree_evaluator (const tree_evaluator&) = delete;
 
     tree_evaluator& operator = (const tree_evaluator&) = delete;
 
     ~tree_evaluator (void) = default;
@@ -197,10 +195,16 @@ namespace octave
     interpreter *m_interp_context;
   };
 }
 
 // Maximum nesting level for functions, scripts, or sourced files called
 // recursively.
 extern int Vmax_recursion_depth;
 
+#if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
+
+OCTAVE_DEPRECATED ("use 'octave::tree_evaluator' instead")
+typedef octave::tree_evaluator tree_evaluator;
+
 #endif
 
+#endif
diff --git a/libinterp/parse-tree/pt-except.cc b/libinterp/parse-tree/pt-except.cc
--- a/libinterp/parse-tree/pt-except.cc
+++ b/libinterp/parse-tree/pt-except.cc
@@ -35,70 +35,72 @@ along with Octave; see the file COPYING.
 #include "pt-exp.h"
 #include "pt-id.h"
 #include "pt-jump.h"
 #include "pt-stmt.h"
 #include "pt-walk.h"
 #include "unwind-prot.h"
 #include "variables.h"
 
-// Simple exception handling.
-
-tree_try_catch_command::~tree_try_catch_command (void)
+namespace octave
 {
-  delete expr_id;
-  delete try_code;
-  delete catch_code;
-  delete lead_comm;
-  delete mid_comm;
-  delete trail_comm;
-}
+  // Simple exception handling.
+
+  tree_try_catch_command::~tree_try_catch_command (void)
+  {
+    delete expr_id;
+    delete try_code;
+    delete catch_code;
+    delete lead_comm;
+    delete mid_comm;
+    delete trail_comm;
+  }
+
+  tree_command *
+  tree_try_catch_command::dup (symbol_table::scope_id scope,
+                               symbol_table::context_id context) const
+  {
+    return new
+      tree_try_catch_command (try_code ? try_code->dup (scope, context) : 0,
+                              catch_code ? catch_code->dup (scope, context) : 0,
+                              expr_id ? expr_id->dup (scope, context) : 0,
+                              lead_comm ? lead_comm->dup () : 0,
+                              mid_comm ? mid_comm->dup () : 0,
+                              trail_comm ? trail_comm->dup () : 0,
+                              line (), column ());
+  }
 
-tree_command *
-tree_try_catch_command::dup (symbol_table::scope_id scope,
-                             symbol_table::context_id context) const
-{
-  return new
-    tree_try_catch_command (try_code ? try_code->dup (scope, context) : 0,
-                            catch_code ? catch_code->dup (scope, context) : 0,
-                            expr_id ? expr_id->dup (scope, context) : 0,
-                            lead_comm ? lead_comm->dup () : 0,
-                            mid_comm ? mid_comm->dup () : 0,
-                            trail_comm ? trail_comm->dup () : 0,
-                            line (), column ());
-}
+  void
+  tree_try_catch_command::accept (tree_walker& tw)
+  {
+    tw.visit_try_catch_command (*this);
+  }
+
+  // Simple exception handling.
+
+  tree_unwind_protect_command::~tree_unwind_protect_command (void)
+  {
+    delete unwind_protect_code;
+    delete cleanup_code;
+    delete lead_comm;
+    delete mid_comm;
+    delete trail_comm;
+  }
 
-void
-tree_try_catch_command::accept (tree_walker& tw)
-{
-  tw.visit_try_catch_command (*this);
+  tree_command *
+  tree_unwind_protect_command::dup (symbol_table::scope_id scope,
+                                    symbol_table::context_id context) const
+  {
+    return new tree_unwind_protect_command
+      (unwind_protect_code ? unwind_protect_code->dup (scope, context) : 0,
+       cleanup_code ? cleanup_code->dup (scope, context) : 0,
+       lead_comm ? lead_comm->dup () : 0,
+       mid_comm ? mid_comm->dup () : 0,
+       trail_comm ? trail_comm->dup () : 0,
+       line (), column ());
+  }
+
+  void
+  tree_unwind_protect_command::accept (tree_walker& tw)
+  {
+    tw.visit_unwind_protect_command (*this);
+  }
 }
-
-// Simple exception handling.
-
-tree_unwind_protect_command::~tree_unwind_protect_command (void)
-{
-  delete unwind_protect_code;
-  delete cleanup_code;
-  delete lead_comm;
-  delete mid_comm;
-  delete trail_comm;
-}
-
-tree_command *
-tree_unwind_protect_command::dup (symbol_table::scope_id scope,
-                                  symbol_table::context_id context) const
-{
-  return new tree_unwind_protect_command
-    (unwind_protect_code ? unwind_protect_code->dup (scope, context) : 0,
-     cleanup_code ? cleanup_code->dup (scope, context) : 0,
-     lead_comm ? lead_comm->dup () : 0,
-     mid_comm ? mid_comm->dup () : 0,
-     trail_comm ? trail_comm->dup () : 0,
-     line (), column ());
-}
-
-void
-tree_unwind_protect_command::accept (tree_walker& tw)
-{
-  tw.visit_unwind_protect_command (*this);
-}
-
diff --git a/libinterp/parse-tree/pt-except.h b/libinterp/parse-tree/pt-except.h
--- a/libinterp/parse-tree/pt-except.h
+++ b/libinterp/parse-tree/pt-except.h
@@ -20,148 +20,158 @@ along with Octave; see the file COPYING.
 
 */
 
 #if ! defined (octave_pt_except_h)
 #define octave_pt_except_h 1
 
 #include "octave-config.h"
 
-class tree_statement_list;
-
-class tree_walker;
-
 #include "comment-list.h"
 #include "pt-cmd.h"
 #include "pt-id.h"
 #include "symtab.h"
 
-// Simple exception handling.
-
-class
-tree_try_catch_command : public tree_command
+namespace octave
 {
-public:
+  class tree_statement_list;
+
+  class tree_walker;
+
+  // Simple exception handling.
 
-  tree_try_catch_command (int l = -1, int c = -1)
-    : tree_command (l, c), try_code (0), catch_code (0), expr_id (0),
-      lead_comm (0), mid_comm (0), trail_comm (0) { }
+  class tree_try_catch_command : public tree_command
+  {
+  public:
+
+    tree_try_catch_command (int l = -1, int c = -1)
+      : tree_command (l, c), try_code (0), catch_code (0), expr_id (0),
+        lead_comm (0), mid_comm (0), trail_comm (0) { }
 
-  tree_try_catch_command (tree_statement_list *tc, tree_statement_list *cc,
-                          tree_identifier *id,
-                          octave_comment_list *cl = 0,
-                          octave_comment_list *cm = 0,
-                          octave_comment_list *ct = 0,
-                          int l = -1, int c = -1)
-    : tree_command (l, c), try_code (tc), catch_code (cc), expr_id (id),
-      lead_comm (cl), mid_comm (cm), trail_comm (ct) { }
+    tree_try_catch_command (tree_statement_list *tc, tree_statement_list *cc,
+                            tree_identifier *id,
+                            octave_comment_list *cl = 0,
+                            octave_comment_list *cm = 0,
+                            octave_comment_list *ct = 0,
+                            int l = -1, int c = -1)
+      : tree_command (l, c), try_code (tc), catch_code (cc), expr_id (id),
+        lead_comm (cl), mid_comm (cm), trail_comm (ct) { }
 
-  // No copying!
+    // No copying!
 
-  tree_try_catch_command (const tree_try_catch_command&) = delete;
+    tree_try_catch_command (const tree_try_catch_command&) = delete;
 
-  tree_try_catch_command& operator = (const tree_try_catch_command&) = delete;
+    tree_try_catch_command& operator = (const tree_try_catch_command&) = delete;
 
-  ~tree_try_catch_command (void);
+    ~tree_try_catch_command (void);
 
-  tree_identifier *identifier (void) { return expr_id; }
+    tree_identifier *identifier (void) { return expr_id; }
 
-  tree_statement_list *body (void) { return try_code; }
+    tree_statement_list *body (void) { return try_code; }
+
+    tree_statement_list *cleanup (void) { return catch_code; }
 
-  tree_statement_list *cleanup (void) { return catch_code; }
+    octave_comment_list *leading_comment (void) { return lead_comm; }
 
-  octave_comment_list *leading_comment (void) { return lead_comm; }
+    octave_comment_list *middle_comment (void) { return mid_comm; }
 
-  octave_comment_list *middle_comment (void) { return mid_comm; }
-
-  octave_comment_list *trailing_comment (void) { return trail_comm; }
+    octave_comment_list *trailing_comment (void) { return trail_comm; }
 
-  tree_command *dup (symbol_table::scope_id scope,
-                     symbol_table::context_id context) const;
+    tree_command *dup (symbol_table::scope_id scope,
+                       symbol_table::context_id context) const;
 
-  void accept (tree_walker& tw);
+    void accept (tree_walker& tw);
+
+  private:
 
-private:
+    // The first block of code to attempt to execute.
+    tree_statement_list *try_code;
 
-  // The first block of code to attempt to execute.
-  tree_statement_list *try_code;
+    // The code to execute if an error occurs in the first block.
+    tree_statement_list *catch_code;
 
-  // The code to execute if an error occurs in the first block.
-  tree_statement_list *catch_code;
+    // Identifier to modify.
+    tree_identifier *expr_id;
 
-  // Identifier to modify.
-  tree_identifier *expr_id;
+    // Comment preceding TRY token.
+    octave_comment_list *lead_comm;
 
-  // Comment preceding TRY token.
-  octave_comment_list *lead_comm;
+    // Comment preceding CATCH token.
+    octave_comment_list *mid_comm;
 
-  // Comment preceding CATCH token.
-  octave_comment_list *mid_comm;
+    // Comment preceding END_TRY_CATCH token.
+    octave_comment_list *trail_comm;
+  };
 
-  // Comment preceding END_TRY_CATCH token.
-  octave_comment_list *trail_comm;
-};
-
-// Simple exception handling.
+  // Simple exception handling.
 
-class
-tree_unwind_protect_command : public tree_command
-{
-public:
+  class tree_unwind_protect_command : public tree_command
+  {
+  public:
 
-  tree_unwind_protect_command (int l = -1, int c = -1)
-    : tree_command (l, c), unwind_protect_code (0), cleanup_code (0),
-      lead_comm (0), mid_comm (0), trail_comm (0) { }
+    tree_unwind_protect_command (int l = -1, int c = -1)
+      : tree_command (l, c), unwind_protect_code (0), cleanup_code (0),
+        lead_comm (0), mid_comm (0), trail_comm (0) { }
 
-  tree_unwind_protect_command (tree_statement_list *tc,
-                               tree_statement_list *cc,
-                               octave_comment_list *cl = 0,
-                               octave_comment_list *cm = 0,
-                               octave_comment_list *ct = 0,
-                               int l = -1, int c = -1)
-    : tree_command (l, c), unwind_protect_code (tc), cleanup_code (cc),
-      lead_comm (cl), mid_comm (cm), trail_comm (ct) { }
+    tree_unwind_protect_command (tree_statement_list *tc,
+                                 tree_statement_list *cc,
+                                 octave_comment_list *cl = 0,
+                                 octave_comment_list *cm = 0,
+                                 octave_comment_list *ct = 0,
+                                 int l = -1, int c = -1)
+      : tree_command (l, c), unwind_protect_code (tc), cleanup_code (cc),
+        lead_comm (cl), mid_comm (cm), trail_comm (ct) { }
+
+    // No copying!
 
-  // No copying!
+    tree_unwind_protect_command (const tree_unwind_protect_command&) = delete;
 
-  tree_unwind_protect_command (const tree_unwind_protect_command&) = delete;
+    tree_unwind_protect_command&
+    operator = (const tree_unwind_protect_command&) = delete;
 
-  tree_unwind_protect_command&
-  operator = (const tree_unwind_protect_command&) = delete;
+    ~tree_unwind_protect_command (void);
+
+    tree_statement_list *body (void) { return unwind_protect_code; }
 
-  ~tree_unwind_protect_command (void);
+    tree_statement_list *cleanup (void) { return cleanup_code; }
+
+    octave_comment_list *leading_comment (void) { return lead_comm; }
 
-  tree_statement_list *body (void) { return unwind_protect_code; }
+    octave_comment_list *middle_comment (void) { return mid_comm; }
 
-  tree_statement_list *cleanup (void) { return cleanup_code; }
+    octave_comment_list *trailing_comment (void) { return trail_comm; }
 
-  octave_comment_list *leading_comment (void) { return lead_comm; }
+    tree_command *dup (symbol_table::scope_id scope,
+                       symbol_table::context_id context) const;
 
-  octave_comment_list *middle_comment (void) { return mid_comm; }
+    void accept (tree_walker& tw);
 
-  octave_comment_list *trailing_comment (void) { return trail_comm; }
+  private:
 
-  tree_command *dup (symbol_table::scope_id scope,
-                     symbol_table::context_id context) const;
+    // The first body of code to attempt to execute.
+    tree_statement_list *unwind_protect_code;
 
-  void accept (tree_walker& tw);
-
-private:
+    // The body of code to execute no matter what happens in the first
+    // body of code.
+    tree_statement_list *cleanup_code;
 
-  // The first body of code to attempt to execute.
-  tree_statement_list *unwind_protect_code;
+    // Comment preceding UNWIND_PROTECT token.
+    octave_comment_list *lead_comm;
 
-  // The body of code to execute no matter what happens in the first
-  // body of code.
-  tree_statement_list *cleanup_code;
+    // Comment preceding UNWIND_PROTECT_CLEANUP token.
+    octave_comment_list *mid_comm;
 
-  // Comment preceding UNWIND_PROTECT token.
-  octave_comment_list *lead_comm;
+    // Comment preceding END_UNWIND_PROTECT token.
+    octave_comment_list *trail_comm;
+  };
+}
 
-  // Comment preceding UNWIND_PROTECT_CLEANUP token.
-  octave_comment_list *mid_comm;
+#if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
 
-  // Comment preceding END_UNWIND_PROTECT token.
-  octave_comment_list *trail_comm;
-};
+OCTAVE_DEPRECATED ("use 'octave::tree_try_catch_command' instead")
+typedef octave::tree_try_catch_command tree_try_catch_command;
+
+OCTAVE_DEPRECATED ("use 'octave::tree_unwind_protect_command' instead")
+typedef octave::tree_unwind_protect_command tree_unwind_protect_command;
 
 #endif
 
+#endif
diff --git a/libinterp/parse-tree/pt-exp.cc b/libinterp/parse-tree/pt-exp.cc
--- a/libinterp/parse-tree/pt-exp.cc
+++ b/libinterp/parse-tree/pt-exp.cc
@@ -28,55 +28,57 @@ along with Octave; see the file COPYING.
 #include <string>
 
 #include "error.h"
 #include "pager.h"
 #include "oct-lvalue.h"
 #include "ov.h"
 #include "pt-exp.h"
 
-// Expressions.
+namespace octave
+{
+  // Expressions.
 
-bool
-tree_expression::is_logically_true (const char *warn_for)
-{
-  bool expr_value = false;
+  bool
+  tree_expression::is_logically_true (const char *warn_for)
+  {
+    bool expr_value = false;
 
-  octave_value t1 = rvalue1 ();
+    octave_value t1 = rvalue1 ();
 
-  if (t1.is_defined ())
-    return t1.is_true ();
-  else
-    error ("%s: undefined value used in conditional expression", warn_for);
+    if (t1.is_defined ())
+      return t1.is_true ();
+    else
+      error ("%s: undefined value used in conditional expression", warn_for);
 
-  return expr_value;
-}
+    return expr_value;
+  }
 
-octave_value
-tree_expression::rvalue1 (int)
-{
-  error ("invalid rvalue function called in expression");
-}
+  octave_value
+  tree_expression::rvalue1 (int)
+  {
+    error ("invalid rvalue function called in expression");
+  }
 
-octave_value_list
-tree_expression::rvalue (int)
-{
-  error ("invalid rvalue function called in expression");
-}
+  octave_value_list
+  tree_expression::rvalue (int)
+  {
+    error ("invalid rvalue function called in expression");
+  }
 
-octave_value_list
-tree_expression::rvalue (int nargout, const std::list<octave_lvalue> *)
-{
-  return rvalue (nargout);
-}
+  octave_value_list
+  tree_expression::rvalue (int nargout, const std::list<octave_lvalue> *)
+  {
+    return rvalue (nargout);
+  }
 
-octave_lvalue
-tree_expression::lvalue (void)
-{
-  error ("invalid lvalue function called in expression");
-}
+  octave_lvalue
+  tree_expression::lvalue (void)
+  {
+    error ("invalid lvalue function called in expression");
+  }
 
-std::string
-tree_expression::original_text (void) const
-{
-  return "";
+  std::string
+  tree_expression::original_text (void) const
+  {
+    return "";
+  }
 }
-
diff --git a/libinterp/parse-tree/pt-exp.h b/libinterp/parse-tree/pt-exp.h
--- a/libinterp/parse-tree/pt-exp.h
+++ b/libinterp/parse-tree/pt-exp.h
@@ -29,140 +29,148 @@ along with Octave; see the file COPYING.
 #include <list>
 
 class octave_value;
 class octave_lvalue;
 
 #include "pt.h"
 #include "symtab.h"
 
-// A base class for expressions.
+namespace octave
+{
+  // A base class for expressions.
 
-class
-tree_expression : public tree
-{
-public:
+  class tree_expression : public tree
+  {
+  public:
 
-  tree_expression (int l = -1, int c = -1)
-    : tree (l, c), num_parens (0), postfix_index_type ('\0'),
-      for_cmd_expr (false), print_flag (false) { }
+    tree_expression (int l = -1, int c = -1)
+      : tree (l, c), num_parens (0), postfix_index_type ('\0'),
+        for_cmd_expr (false), print_flag (false) { }
 
-  // No copying!
+    // No copying!
 
-  tree_expression (const tree_expression&) = delete;
+    tree_expression (const tree_expression&) = delete;
 
-  tree_expression& operator = (const tree_expression&) = delete;
+    tree_expression& operator = (const tree_expression&) = delete;
 
-  virtual ~tree_expression (void) = default;
+    virtual ~tree_expression (void) = default;
 
-  virtual bool has_magic_end (void) const = 0;
+    virtual bool has_magic_end (void) const = 0;
 
-  virtual tree_expression *dup (symbol_table::scope_id,
-                                symbol_table::context_id context) const = 0;
+    virtual tree_expression *dup (symbol_table::scope_id,
+                                  symbol_table::context_id context) const = 0;
 
-  virtual bool is_constant (void) const { return false; }
+    virtual bool is_constant (void) const { return false; }
 
-  virtual bool is_matrix (void) const { return false; }
+    virtual bool is_matrix (void) const { return false; }
 
-  virtual bool is_cell (void) const { return false; }
+    virtual bool is_cell (void) const { return false; }
 
-  virtual bool is_identifier (void) const { return false; }
+    virtual bool is_identifier (void) const { return false; }
 
-  virtual bool is_index_expression (void) const { return false; }
+    virtual bool is_index_expression (void) const { return false; }
 
-  virtual bool is_assignment_expression (void) const { return false; }
+    virtual bool is_assignment_expression (void) const { return false; }
 
-  virtual bool is_prefix_expression (void) const { return false; }
+    virtual bool is_prefix_expression (void) const { return false; }
 
-  virtual bool is_unary_expression (void) const { return false; }
+    virtual bool is_unary_expression (void) const { return false; }
 
-  virtual bool is_binary_expression (void) const { return false; }
+    virtual bool is_binary_expression (void) const { return false; }
 
-  virtual bool is_boolean_expression (void) const { return false; }
+    virtual bool is_boolean_expression (void) const { return false; }
 
-  virtual bool is_logically_true (const char *);
+    virtual bool is_logically_true (const char *);
 
-  virtual bool lvalue_ok (void) const { return false; }
+    virtual bool lvalue_ok (void) const { return false; }
 
-  virtual bool rvalue_ok (void) const { return false; }
+    virtual bool rvalue_ok (void) const { return false; }
 
-  virtual octave_value rvalue1 (int nargout = 1);
+    virtual octave_value rvalue1 (int nargout = 1);
 
-  virtual octave_value_list rvalue (int nargout);
+    virtual octave_value_list rvalue (int nargout);
 
-  virtual octave_value_list
-  rvalue (int nargout, const std::list<octave_lvalue> *lvalue_list);
+    virtual octave_value_list
+    rvalue (int nargout, const std::list<octave_lvalue> *lvalue_list);
 
-  virtual octave_lvalue lvalue (void);
+    virtual octave_lvalue lvalue (void);
 
-  int paren_count (void) const { return num_parens; }
+    int paren_count (void) const { return num_parens; }
 
-  bool is_postfix_indexed (void) const { return (postfix_index_type != '\0'); }
+    bool is_postfix_indexed (void) const { return (postfix_index_type != '\0'); }
 
-  char postfix_index (void) const { return postfix_index_type; }
+    char postfix_index (void) const { return postfix_index_type; }
 
-  // Check if the result of the expression should be printed.
-  // Should normally be used in conjunction with
-  // octave::tree_evaluator::statement_printing_enabled.
-  bool print_result (void) const { return print_flag; }
+    // Check if the result of the expression should be printed.
+    // Should normally be used in conjunction with
+    // octave::tree_evaluator::statement_printing_enabled.
+    bool print_result (void) const { return print_flag; }
+
+    virtual std::string oper (void) const { return "<unknown>"; }
 
-  virtual std::string oper (void) const { return "<unknown>"; }
+    virtual std::string name (void) const { return "<unknown>"; }
 
-  virtual std::string name (void) const { return "<unknown>"; }
+    virtual std::string original_text (void) const;
 
-  virtual std::string original_text (void) const;
+    virtual void mark_braindead_shortcircuit (void) { }
 
-  virtual void mark_braindead_shortcircuit (void) { }
+    void mark_as_for_cmd_expr (void) { for_cmd_expr = true; }
+
+    bool is_for_cmd_expr (void) const { return for_cmd_expr; }
 
-  void mark_as_for_cmd_expr (void) { for_cmd_expr = true; }
-
-  bool is_for_cmd_expr (void) const { return for_cmd_expr; }
+    tree_expression *mark_in_parens (void)
+    {
+      num_parens++;
+      return this;
+    }
 
-  tree_expression *mark_in_parens (void)
-  {
-    num_parens++;
-    return this;
-  }
+    tree_expression *set_postfix_index (char type)
+    {
+      postfix_index_type = type;
+      return this;
+    }
 
-  tree_expression *set_postfix_index (char type)
-  {
-    postfix_index_type = type;
-    return this;
-  }
+    tree_expression *set_print_flag (bool print)
+    {
+      print_flag = print;
+      return this;
+    }
 
-  tree_expression *set_print_flag (bool print)
-  {
-    print_flag = print;
-    return this;
-  }
+    virtual void copy_base (const tree_expression& e)
+    {
+      num_parens = e.num_parens;
+      postfix_index_type = e.postfix_index_type;
+      print_flag = e.print_flag;
+    }
 
-  virtual void copy_base (const tree_expression& e)
-  {
-    num_parens = e.num_parens;
-    postfix_index_type = e.postfix_index_type;
-    print_flag = e.print_flag;
-  }
+  protected:
 
-protected:
+    // A count of the number of times this expression appears directly
+    // inside a set of parentheses.
+    //
+    //   (((e1)) + e2)  ==> 2 for expression e1
+    //                  ==> 1 for expression ((e1)) + e2
+    //                  ==> 0 for expression e2
+    int num_parens;
 
-  // A count of the number of times this expression appears directly
-  // inside a set of parentheses.
-  //
-  //   (((e1)) + e2)  ==> 2 for expression e1
-  //                  ==> 1 for expression ((e1)) + e2
-  //                  ==> 0 for expression e2
-  int num_parens;
+    // The first index type associated with this expression.  This field
+    // is 0 (character '\0') if the expression has no associated index.
+    // See the code in tree_identifier::rvalue for the rationale.
+    char postfix_index_type;
+
+    // TRUE if this expression is the EXPR in for loop:
+    // FOR i = EXPR ... END
+    bool for_cmd_expr;
 
-  // The first index type associated with this expression.  This field
-  // is 0 (character '\0') if the expression has no associated index.
-  // See the code in tree_identifier::rvalue for the rationale.
-  char postfix_index_type;
+    // Print result of rvalue for this expression?
+    bool print_flag;
+  };
+}
 
-  // TRUE if this expression is the EXPR in for loop:
-  // FOR i = EXPR ... END
-  bool for_cmd_expr;
+#if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
 
-  // Print result of rvalue for this expression?
-  bool print_flag;
-};
+OCTAVE_DEPRECATED ("use 'octave::tree_expression' instead")
+typedef octave::tree_expression tree_expression;
 
 #endif
 
+#endif
diff --git a/libinterp/parse-tree/pt-fcn-handle.cc b/libinterp/parse-tree/pt-fcn-handle.cc
--- a/libinterp/parse-tree/pt-fcn-handle.cc
+++ b/libinterp/parse-tree/pt-fcn-handle.cc
@@ -31,119 +31,167 @@ along with Octave; see the file COPYING.
 #include "ovl.h"
 #include "ov-fcn-handle.h"
 #include "pt-fcn-handle.h"
 #include "pager.h"
 #include "pt-const.h"
 #include "pt-walk.h"
 #include "variables.h"
 
-void
-tree_fcn_handle::print (std::ostream& os, bool pr_as_read_syntax,
-                        bool pr_orig_text)
-{
-  print_raw (os, pr_as_read_syntax, pr_orig_text);
-}
-
-void
-tree_fcn_handle::print_raw (std::ostream& os, bool pr_as_read_syntax,
-                            bool pr_orig_text)
+namespace octave
 {
-  os << ((pr_as_read_syntax || pr_orig_text) ? "@" : "") << nm;
-}
+  void
+  tree_fcn_handle::print (std::ostream& os, bool pr_as_read_syntax,
+                          bool pr_orig_text)
+  {
+    print_raw (os, pr_as_read_syntax, pr_orig_text);
+  }
+
+  void
+  tree_fcn_handle::print_raw (std::ostream& os, bool pr_as_read_syntax,
+                              bool pr_orig_text)
+  {
+    os << ((pr_as_read_syntax || pr_orig_text) ? "@" : "") << nm;
+  }
 
-octave_value
-tree_fcn_handle::rvalue1 (int)
-{
-  return make_fcn_handle (nm);
-}
+  octave_value
+  tree_fcn_handle::rvalue1 (int)
+  {
+    return make_fcn_handle (nm);
+  }
 
-octave_value_list
-tree_fcn_handle::rvalue (int nargout)
-{
-  octave_value_list retval;
+  octave_value_list
+  tree_fcn_handle::rvalue (int nargout)
+  {
+    octave_value_list retval;
+
+    if (nargout > 1)
+      error ("invalid number of output arguments for function handle expression");
+
+    retval = rvalue1 (nargout);
+
+    return retval;
+  }
 
-  if (nargout > 1)
-    error ("invalid number of output arguments for function handle expression");
+  tree_expression *
+  tree_fcn_handle::dup (symbol_table::scope_id,
+                        symbol_table::context_id) const
+  {
+    tree_fcn_handle *new_fh = new tree_fcn_handle (nm, line (), column ());
+
+    new_fh->copy_base (*this);
 
-  retval = rvalue1 (nargout);
+    return new_fh;
+  }
 
-  return retval;
-}
+  void
+  tree_fcn_handle::accept (tree_walker& tw)
+  {
+    tw.visit_fcn_handle (*this);
+  }
 
-tree_expression *
-tree_fcn_handle::dup (symbol_table::scope_id,
-                      symbol_table::context_id) const
-{
-  tree_fcn_handle *new_fh = new tree_fcn_handle (nm, line (), column ());
+  octave_value
+  tree_anon_fcn_handle::rvalue1 (int)
+  {
+    // FIXME: should CMD_LIST be limited to a single expression?
+    // I think that is what Matlab does.
 
-  new_fh->copy_base (*this);
+    tree_parameter_list *param_list = parameter_list ();
+    tree_parameter_list *ret_list = return_list ();
+    tree_statement_list *cmd_list = body ();
+    symbol_table::scope_id this_scope = scope ();
 
-  return new_fh;
-}
+    symbol_table::scope_id new_scope = symbol_table::dup_scope (this_scope);
+
+    if (new_scope > 0)
+      symbol_table::inherit (new_scope, symbol_table::current_scope (),
+                             symbol_table::current_context ());
 
-void
-tree_fcn_handle::accept (tree_walker& tw)
-{
-  tw.visit_fcn_handle (*this);
-}
+    octave_user_function *uf
+      = new octave_user_function (new_scope,
+                                  param_list ? param_list->dup (new_scope, 0) : 0,
+                                  ret_list ? ret_list->dup (new_scope, 0) : 0,
+                                  cmd_list ? cmd_list->dup (new_scope, 0) : 0);
 
-octave_value
-tree_anon_fcn_handle::rvalue1 (int)
-{
-  // FIXME: should CMD_LIST be limited to a single expression?
-  // I think that is what Matlab does.
+    octave_function *curr_fcn = octave::call_stack::current ();
+
+    if (curr_fcn)
+      {
+        // FIXME: maybe it would be better to just stash curr_fcn
+        // instead of individual bits of info about it?
 
-  tree_parameter_list *param_list = parameter_list ();
-  tree_parameter_list *ret_list = return_list ();
-  tree_statement_list *cmd_list = body ();
-  symbol_table::scope_id this_scope = scope ();
+        uf->stash_parent_fcn_name (curr_fcn->name ());
+        uf->stash_dir_name (curr_fcn->dir_name ());
+
+        symbol_table::scope_id parent_scope = curr_fcn->parent_fcn_scope ();
+
+        if (parent_scope < 0)
+          parent_scope = curr_fcn->scope ();
+
+        uf->stash_parent_fcn_scope (parent_scope);
 
-  symbol_table::scope_id new_scope = symbol_table::dup_scope (this_scope);
+        if (curr_fcn->is_class_method () || curr_fcn->is_class_constructor ())
+          uf->stash_dispatch_class (curr_fcn->dispatch_class ());
+      }
 
-  if (new_scope > 0)
-    symbol_table::inherit (new_scope, symbol_table::current_scope (),
-                           symbol_table::current_context ());
+    uf->mark_as_anonymous_function ();
+    uf->stash_fcn_file_name (file_name);
+    uf->stash_fcn_location (line (), column ());
+
+    octave_value ov_fcn (uf);
 
-  octave_user_function *uf
-    = new octave_user_function (new_scope,
-                                param_list ? param_list->dup (new_scope, 0) : 0,
-                                ret_list ? ret_list->dup (new_scope, 0) : 0,
-                                cmd_list ? cmd_list->dup (new_scope, 0) : 0);
+    octave_value fh (octave_fcn_binder::maybe_binder (ov_fcn));
+
+    return fh;
+  }
 
-  octave_function *curr_fcn = octave::call_stack::current ();
+  octave_value_list
+  tree_anon_fcn_handle::rvalue (int nargout)
+  {
+    octave_value_list retval;
 
-  if (curr_fcn)
-    {
-      // FIXME: maybe it would be better to just stash curr_fcn
-      // instead of individual bits of info about it?
+    if (nargout > 1)
+      error ("invalid number of output arguments for anonymous function handle expression");
+
+    retval = rvalue1 (nargout);
+
+    return retval;
+  }
 
-      uf->stash_parent_fcn_name (curr_fcn->name ());
-      uf->stash_dir_name (curr_fcn->dir_name ());
+  tree_expression *
+  tree_anon_fcn_handle::dup (symbol_table::scope_id,
+                             symbol_table::context_id) const
+  {
+    tree_parameter_list *param_list = parameter_list ();
+    tree_parameter_list *ret_list = return_list ();
+    tree_statement_list *cmd_list = body ();
+    symbol_table::scope_id this_scope = scope ();
 
-      symbol_table::scope_id parent_scope = curr_fcn->parent_fcn_scope ();
-
-      if (parent_scope < 0)
-        parent_scope = curr_fcn->scope ();
+    symbol_table::scope_id new_scope = symbol_table::dup_scope (this_scope);
 
-      uf->stash_parent_fcn_scope (parent_scope);
+    if (new_scope > 0)
+      symbol_table::inherit (new_scope, symbol_table::current_scope (),
+                             symbol_table::current_context ());
 
-      if (curr_fcn->is_class_method () || curr_fcn->is_class_constructor ())
-        uf->stash_dispatch_class (curr_fcn->dispatch_class ());
-    }
+    tree_anon_fcn_handle *new_afh = new
+      tree_anon_fcn_handle (param_list ? param_list->dup (new_scope, 0) : 0,
+                            ret_list ? ret_list->dup (new_scope, 0) : 0,
+                            cmd_list ? cmd_list->dup (new_scope, 0) : 0,
+                            new_scope, line (), column ());
 
-  uf->mark_as_anonymous_function ();
-  uf->stash_fcn_file_name (file_name);
-  uf->stash_fcn_location (line (), column ());
+    new_afh->copy_base (*this);
+
+    return new_afh;
+  }
 
-  octave_value ov_fcn (uf);
-
-  octave_value fh (octave_fcn_binder::maybe_binder (ov_fcn));
-
-  return fh;
+  void
+  tree_anon_fcn_handle::accept (tree_walker& tw)
+  {
+    tw.visit_anon_fcn_handle (*this);
+  }
 }
 
 /*
 %!function r = __f2 (f, x)
 %!  r = f (x);
 %!endfunction
 %!function f = __f1 (k)
 %!  f = @(x) __f2 (@(y) y-k, x);
@@ -169,54 +217,8 @@ intentional, so don't change it.
 %!test
 %! f = @() 'foo';
 %! assert (f (), 'foo');
 
 %!test
 %! f = @()'foo';
 %! assert (f (), 'foo');
 */
-
-octave_value_list
-tree_anon_fcn_handle::rvalue (int nargout)
-{
-  octave_value_list retval;
-
-  if (nargout > 1)
-    error ("invalid number of output arguments for anonymous function handle expression");
-
-  retval = rvalue1 (nargout);
-
-  return retval;
-}
-
-tree_expression *
-tree_anon_fcn_handle::dup (symbol_table::scope_id,
-                           symbol_table::context_id) const
-{
-  tree_parameter_list *param_list = parameter_list ();
-  tree_parameter_list *ret_list = return_list ();
-  tree_statement_list *cmd_list = body ();
-  symbol_table::scope_id this_scope = scope ();
-
-  symbol_table::scope_id new_scope = symbol_table::dup_scope (this_scope);
-
-  if (new_scope > 0)
-    symbol_table::inherit (new_scope, symbol_table::current_scope (),
-                           symbol_table::current_context ());
-
-  tree_anon_fcn_handle *new_afh = new
-    tree_anon_fcn_handle (param_list ? param_list->dup (new_scope, 0) : 0,
-                          ret_list ? ret_list->dup (new_scope, 0) : 0,
-                          cmd_list ? cmd_list->dup (new_scope, 0) : 0,
-                          new_scope, line (), column ());
-
-  new_afh->copy_base (*this);
-
-  return new_afh;
-}
-
-void
-tree_anon_fcn_handle::accept (tree_walker& tw)
-{
-  tw.visit_anon_fcn_handle (*this);
-}
-
diff --git a/libinterp/parse-tree/pt-fcn-handle.h b/libinterp/parse-tree/pt-fcn-handle.h
--- a/libinterp/parse-tree/pt-fcn-handle.h
+++ b/libinterp/parse-tree/pt-fcn-handle.h
@@ -31,129 +31,139 @@ along with Octave; see the file COPYING.
 #include "pt-bp.h"
 #include "pt-exp.h"
 #include "pt-misc.h"
 #include "pt-stmt.h"
 #include "symtab.h"
 
 class octave_value_list;
 
-class tree_walker;
-
 #include "ov.h"
 #include "ov-usr-fcn.h"
 #include "symtab.h"
 
-class
-tree_fcn_handle : public tree_expression
+namespace octave
 {
-public:
+  class tree_walker;
 
-  tree_fcn_handle (int l = -1, int c = -1)
-    : tree_expression (l, c), nm () { }
+  class tree_fcn_handle : public tree_expression
+  {
+  public:
 
-  tree_fcn_handle (const std::string& n, int l = -1, int c = -1)
-    : tree_expression (l, c), nm (n) { }
-
-  // No copying!
+    tree_fcn_handle (int l = -1, int c = -1)
+      : tree_expression (l, c), nm () { }
 
-  tree_fcn_handle (const tree_fcn_handle&) = delete;
+    tree_fcn_handle (const std::string& n, int l = -1, int c = -1)
+      : tree_expression (l, c), nm (n) { }
 
-  tree_fcn_handle& operator = (const tree_fcn_handle&) = delete;
+    // No copying!
 
-  ~tree_fcn_handle (void) = default;
+    tree_fcn_handle (const tree_fcn_handle&) = delete;
 
-  bool has_magic_end (void) const { return false; }
+    tree_fcn_handle& operator = (const tree_fcn_handle&) = delete;
+
+    ~tree_fcn_handle (void) = default;
 
-  void print (std::ostream& os, bool pr_as_read_syntax = false,
-              bool pr_orig_txt = true);
+    bool has_magic_end (void) const { return false; }
 
-  void print_raw (std::ostream& os, bool pr_as_read_syntax = false,
-                  bool pr_orig_txt = true);
+    void print (std::ostream& os, bool pr_as_read_syntax = false,
+                bool pr_orig_txt = true);
 
-  std::string name (void) const { return nm; }
+    void print_raw (std::ostream& os, bool pr_as_read_syntax = false,
+                    bool pr_orig_txt = true);
 
-  bool rvalue_ok (void) const { return true; }
+    std::string name (void) const { return nm; }
 
-  octave_value rvalue1 (int nargout = 1);
+    bool rvalue_ok (void) const { return true; }
 
-  octave_value_list rvalue (int nargout);
+    octave_value rvalue1 (int nargout = 1);
 
-  tree_expression *dup (symbol_table::scope_id scope,
-                        symbol_table::context_id context) const;
+    octave_value_list rvalue (int nargout);
 
-  void accept (tree_walker& tw);
+    tree_expression *dup (symbol_table::scope_id scope,
+                          symbol_table::context_id context) const;
 
-private:
+    void accept (tree_walker& tw);
 
-  // The name of this function handle.
-  std::string nm;
-};
+  private:
 
-class
-tree_anon_fcn_handle : public tree_expression
-{
-public:
+    // The name of this function handle.
+    std::string nm;
+  };
 
-  tree_anon_fcn_handle (int l = -1, int c = -1)
-    : tree_expression (l, c), fcn (0), file_name () { }
+  class tree_anon_fcn_handle : public tree_expression
+  {
+  public:
+
+    tree_anon_fcn_handle (int l = -1, int c = -1)
+      : tree_expression (l, c), fcn (0), file_name () { }
 
-  tree_anon_fcn_handle (tree_parameter_list *pl, tree_parameter_list *rl,
-                        tree_statement_list *cl, symbol_table::scope_id sid,
-                        int l = -1, int c = -1)
-    : tree_expression (l, c),
-      fcn (new octave_user_function (sid, pl, rl, cl)),
-      file_name () { }
+    tree_anon_fcn_handle (tree_parameter_list *pl, tree_parameter_list *rl,
+                          tree_statement_list *cl, symbol_table::scope_id sid,
+                          int l = -1, int c = -1)
+      : tree_expression (l, c),
+        fcn (new octave_user_function (sid, pl, rl, cl)),
+        file_name () { }
 
-  // No copying!
+    // No copying!
+
+    tree_anon_fcn_handle (const tree_anon_fcn_handle&) = delete;
 
-  tree_anon_fcn_handle (const tree_anon_fcn_handle&) = delete;
+    tree_anon_fcn_handle& operator = (const tree_anon_fcn_handle&) = delete;
 
-  tree_anon_fcn_handle& operator = (const tree_anon_fcn_handle&) = delete;
+    ~tree_anon_fcn_handle (void) { delete fcn; }
 
-  ~tree_anon_fcn_handle (void) { delete fcn; }
+    bool has_magic_end (void) const { return false; }
+
+    bool rvalue_ok (void) const { return true; }
 
-  bool has_magic_end (void) const { return false; }
+    octave_value rvalue1 (int nargout = 1);
 
-  bool rvalue_ok (void) const { return true; }
+    octave_value_list rvalue (int nargout);
 
-  octave_value rvalue1 (int nargout = 1);
-
-  octave_value_list rvalue (int nargout);
+    tree_parameter_list *parameter_list (void) const
+    {
+      return fcn ? fcn->parameter_list () : 0;
+    }
 
-  tree_parameter_list *parameter_list (void) const
-  {
-    return fcn ? fcn->parameter_list () : 0;
-  }
+    tree_parameter_list *return_list (void) const
+    {
+      return fcn ? fcn->return_list () : 0;
+    }
 
-  tree_parameter_list *return_list (void) const
-  {
-    return fcn ? fcn->return_list () : 0;
-  }
+    tree_statement_list *body (void) const
+    {
+      return fcn ? fcn->body () : 0;
+    }
 
-  tree_statement_list *body (void) const
-  {
-    return fcn ? fcn->body () : 0;
-  }
+    symbol_table::scope_id scope (void) const
+    {
+      return fcn ? fcn->scope () : -1;
+    }
 
-  symbol_table::scope_id scope (void) const
-  {
-    return fcn ? fcn->scope () : -1;
-  }
+    tree_expression *dup (symbol_table::scope_id scope,
+                          symbol_table::context_id context) const;
+
+    void accept (tree_walker& tw);
+
+    void stash_file_name (const std::string& file) { file_name = file; }
 
-  tree_expression *dup (symbol_table::scope_id scope,
-                        symbol_table::context_id context) const;
+  private:
 
-  void accept (tree_walker& tw);
-
-  void stash_file_name (const std::string& file) { file_name = file; }
+    // The function.
+    octave_user_function *fcn;
 
-private:
+    // Filename where the handle was defined.
+    std::string file_name;
+  };
+}
 
-  // The function.
-  octave_user_function *fcn;
+#if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
 
-  // Filename where the handle was defined.
-  std::string file_name;
-};
+OCTAVE_DEPRECATED ("use 'octave::tree_fcn_handle' instead")
+typedef octave::tree_fcn_handle tree_fcn_handle;
+
+OCTAVE_DEPRECATED ("use 'octave::tree_anon_fcn_handle' instead")
+typedef octave::tree_anon_fcn_handle tree_anon_fcn_handle;
 
 #endif
 
+#endif
diff --git a/libinterp/parse-tree/pt-funcall.cc b/libinterp/parse-tree/pt-funcall.cc
--- a/libinterp/parse-tree/pt-funcall.cc
+++ b/libinterp/parse-tree/pt-funcall.cc
@@ -23,89 +23,91 @@ along with Octave; see the file COPYING.
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
 #include "ov-fcn.h"
 #include "pt-funcall.h"
 #include "pt-walk.h"
 
-// Function call objects.
-
-void
-tree_funcall::print (std::ostream& os, bool pr_as_read_syntax,
-                     bool pr_orig_text)
-{
-  print_raw (os, pr_as_read_syntax, pr_orig_text);
-}
-
-void
-tree_funcall::print_raw (std::ostream& os, bool pr_as_read_syntax,
-                         bool pr_orig_text)
-{
-  if (pr_orig_text)
-    {
-      os << original_text ();
-    }
-  else
-    {
-      octave_function *fp = fcn.function_value ();
-      std::string nm = fp ? fp->name () : std::string ("<invalid-function>");
-
-      os << nm << " (";
-
-      octave_idx_type n = args.length ();
-      for (octave_idx_type i = 0; i < n; i++)
-        {
-          args(i).print_raw (os, pr_as_read_syntax);
-
-          if (i < n - 1)
-            os << ", ";
-        }
-
-      os << ")";
-    }
-}
-
-tree_funcall *
-tree_funcall::dup (symbol_table::scope_id, symbol_table::context_id) const
+namespace octave
 {
-  tree_funcall *new_fc = new tree_funcall (fcn, args, line (), column ());
+  // Function call objects.
 
-  new_fc->copy_base (*new_fc);
-
-  return new_fc;
-}
+  void
+  tree_funcall::print (std::ostream& os, bool pr_as_read_syntax,
+                       bool pr_orig_text)
+  {
+    print_raw (os, pr_as_read_syntax, pr_orig_text);
+  }
 
-void
-tree_funcall::accept (tree_walker& tw)
-{
-  tw.visit_funcall (*this);
-}
+  void
+  tree_funcall::print_raw (std::ostream& os, bool pr_as_read_syntax,
+                           bool pr_orig_text)
+  {
+    if (pr_orig_text)
+      {
+        os << original_text ();
+      }
+    else
+      {
+        octave_function *fp = fcn.function_value ();
+        std::string nm = fp ? fp->name () : std::string ("<invalid-function>");
 
-octave_value_list
-tree_funcall::rvalue (int nargout)
-{
-  octave_value_list retval;
+        os << nm << " (";
+
+        octave_idx_type n = args.length ();
+        for (octave_idx_type i = 0; i < n; i++)
+          {
+            args(i).print_raw (os, pr_as_read_syntax);
 
-  retval = feval (fcn.function_value (), args, nargout);
+            if (i < n - 1)
+              os << ", ";
+          }
+
+        os << ")";
+      }
+  }
 
-  if (retval.length () == 1 && retval(0).is_function ())
-    {
-      // The return object is a function.  We may need to re-index it using the
-      // same logic as for identifier.  This is primarily used for superclass
-      // references in classdef.
+  tree_funcall *
+  tree_funcall::dup (symbol_table::scope_id, symbol_table::context_id) const
+  {
+    tree_funcall *new_fc = new tree_funcall (fcn, args, line (), column ());
+
+    new_fc->copy_base (*new_fc);
+
+    return new_fc;
+  }
 
-      octave_value val = retval(0);
-      octave_function *f = val.function_value (true);
+  void
+  tree_funcall::accept (tree_walker& tw)
+  {
+    tw.visit_funcall (*this);
+  }
+
+  octave_value_list
+  tree_funcall::rvalue (int nargout)
+  {
+    octave_value_list retval;
 
-      if (f && ! (is_postfix_indexed ()
-                  && f->is_postfix_index_handled (postfix_index ())))
-        {
-          octave_value_list tmp_args;
+    retval = octave::feval (fcn.function_value (), args, nargout);
+
+    if (retval.length () == 1 && retval(0).is_function ())
+      {
+        // The return object is a function.  We may need to re-index it using the
+        // same logic as for identifier.  This is primarily used for superclass
+        // references in classdef.
+
+        octave_value val = retval(0);
+        octave_function *f = val.function_value (true);
 
-          retval = val.do_multi_index_op (nargout, tmp_args);
-        }
-    }
+        if (f && ! (is_postfix_indexed ()
+                    && f->is_postfix_index_handled (postfix_index ())))
+          {
+            octave_value_list tmp_args;
 
-  return retval;
+            retval = val.do_multi_index_op (nargout, tmp_args);
+          }
+      }
+
+    return retval;
+  }
 }
-
diff --git a/libinterp/parse-tree/pt-funcall.h b/libinterp/parse-tree/pt-funcall.h
--- a/libinterp/parse-tree/pt-funcall.h
+++ b/libinterp/parse-tree/pt-funcall.h
@@ -25,77 +25,85 @@ along with Octave; see the file COPYING.
 
 #include "octave-config.h"
 
 #include "ov.h"
 #include "ovl.h"
 #include "parse.h"
 #include "pt-exp.h"
 
-// Function call.  This class only represents function calls that have
-// known functions (most useful for calls to built-in functions that
-// are generated by the parser) and fixed argument lists, known at
-// compile time.
+namespace octave
+{
+  // Function call.  This class only represents function calls that have
+  // known functions (most useful for calls to built-in functions that
+  // are generated by the parser) and fixed argument lists, known at
+  // compile time.
 
-class
-tree_funcall : public tree_expression
-{
-public:
-
-  tree_funcall (const octave_value& f, const octave_value_list& a,
-                int l = -1, int c = -1)
-    : tree_expression (l, c), fcn (f), args (a)
+  class tree_funcall : public tree_expression
   {
-    if (! fcn.is_function ())
-      error ("tree_funcall: invalid function");
-  }
+  public:
 
-  // No copying!
+    tree_funcall (const octave_value& f, const octave_value_list& a,
+                  int l = -1, int c = -1)
+      : tree_expression (l, c), fcn (f), args (a)
+    {
+      if (! fcn.is_function ())
+        error ("tree_funcall: invalid function");
+    }
 
-  tree_funcall (const tree_funcall&) = delete;
+    // No copying!
 
-  tree_funcall& operator = (const tree_funcall&) = delete;
+    tree_funcall (const tree_funcall&) = delete;
 
-  ~tree_funcall (void) = default;
+    tree_funcall& operator = (const tree_funcall&) = delete;
+
+    ~tree_funcall (void) = default;
 
-  bool has_magic_end (void) const { return false; }
+    bool has_magic_end (void) const { return false; }
 
-  void print (std::ostream& os, bool pr_as_read_syntax = false,
-              bool pr_orig_txt = true);
+    void print (std::ostream& os, bool pr_as_read_syntax = false,
+                bool pr_orig_txt = true);
+
+    void print_raw (std::ostream& os, bool pr_as_read_syntax = false,
+                    bool pr_orig_txt = true);
 
-  void print_raw (std::ostream& os, bool pr_as_read_syntax = false,
-                  bool pr_orig_txt = true);
+    tree_funcall *dup (symbol_table::scope_id,
+                       symbol_table::context_id context) const;
 
-  tree_funcall *dup (symbol_table::scope_id,
-                     symbol_table::context_id context) const;
+    octave_value rvalue1 (int nargout)
+    {
+      octave_value retval;
+
+      const octave_value_list tmp = rvalue (nargout);
 
-  octave_value rvalue1 (int nargout)
-  {
-    octave_value retval;
-
-    const octave_value_list tmp = rvalue (nargout);
+      if (! tmp.empty ())
+        retval = tmp(0);
 
-    if (! tmp.empty ())
-      retval = tmp(0);
+      return retval;
+    }
 
-    return retval;
-  }
+    octave_value_list rvalue (int nargout);
+
+    octave_value function (void) const { return fcn; }
 
-  octave_value_list rvalue (int nargout);
+    octave_value_list arguments (void) const { return args; }
 
-  octave_value function (void) const { return fcn; }
+    void accept (tree_walker& tw);
 
-  octave_value_list arguments (void) const { return args; }
+  private:
 
-  void accept (tree_walker& tw);
+    // Function to call.  Error if not a valid function at time of
+    // construction.
+    octave_value fcn;
 
-private:
+    // Argument list.
+    octave_value_list args;
+  };
+}
 
-  // Function to call.  Error if not a valid function at time of
-  // construction.
-  octave_value fcn;
+#if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
 
-  // Argument list.
-  octave_value_list args;
-};
+OCTAVE_DEPRECATED ("use 'octave::tree_funcall' instead")
+typedef octave::tree_funcall tree_funcall;
 
 #endif
 
+#endif
diff --git a/libinterp/parse-tree/pt-id.cc b/libinterp/parse-tree/pt-id.cc
--- a/libinterp/parse-tree/pt-id.cc
+++ b/libinterp/parse-tree/pt-id.cc
@@ -33,133 +33,135 @@ along with Octave; see the file COPYING.
 #include "pt-const.h"
 #include "pt-eval.h"
 #include "pt-id.h"
 #include "pt-walk.h"
 #include "symtab.h"
 #include "utils.h"
 #include "variables.h"
 
-// Symbols from the symbol table.
-
-void
-tree_identifier::eval_undefined_error (void)
+namespace octave
 {
-  int l = line ();
-  int c = column ();
+  // Symbols from the symbol table.
 
-  maybe_missing_function_hook (name ());
+  void
+  tree_identifier::eval_undefined_error (void)
+  {
+    int l = line ();
+    int c = column ();
 
-  if (l == -1 && c == -1)
-    error_with_id ("Octave:undefined-function",
-                   "'%s' undefined", name ().c_str ());
-  else
-    error_with_id ("Octave:undefined-function",
-                   "'%s' undefined near line %d column %d",
-                   name ().c_str (), l, c);
-}
+    maybe_missing_function_hook (name ());
 
-octave_value_list
-tree_identifier::rvalue (int nargout,
-                         const std::list<octave_lvalue> *lvalue_list)
-{
-  octave_value_list retval;
+    if (l == -1 && c == -1)
+      error_with_id ("Octave:undefined-function",
+                     "'%s' undefined", name ().c_str ());
+    else
+      error_with_id ("Octave:undefined-function",
+                     "'%s' undefined near line %d column %d",
+                     name ().c_str (), l, c);
+  }
 
-  octave_value val = sym->find ();
+  octave_value_list
+  tree_identifier::rvalue (int nargout,
+                           const std::list<octave_lvalue> *lvalue_list)
+  {
+    octave_value_list retval;
+
+    octave_value val = sym->find ();
 
-  if (val.is_defined ())
-    {
-      // GAGME -- this would be cleaner if we required
-      // parens to indicate function calls.
-      //
-      // If this identifier refers to a function, we need to know
-      // whether it is indexed so that we can do the same thing
-      // for 'f' and 'f()'.  If the index is present and the function
-      // object declares it can handle it, return the function object
-      // and let tree_index_expression::rvalue handle indexing.
-      // Otherwise, arrange to call the function here, so that we don't
-      // return the function definition as a value.
+    if (val.is_defined ())
+      {
+        // GAGME -- this would be cleaner if we required
+        // parens to indicate function calls.
+        //
+        // If this identifier refers to a function, we need to know
+        // whether it is indexed so that we can do the same thing
+        // for 'f' and 'f()'.  If the index is present and the function
+        // object declares it can handle it, return the function object
+        // and let tree_index_expression::rvalue handle indexing.
+        // Otherwise, arrange to call the function here, so that we don't
+        // return the function definition as a value.
 
-      octave_function *fcn = 0;
+        octave_function *fcn = 0;
 
-      if (val.is_function ())
-        fcn = val.function_value (true);
+        if (val.is_function ())
+          fcn = val.function_value (true);
 
-      if (fcn && ! (is_postfix_indexed ()
-                    && fcn->is_postfix_index_handled (postfix_index ())))
-        {
-          octave_value_list tmp_args;
+        if (fcn && ! (is_postfix_indexed ()
+                      && fcn->is_postfix_index_handled (postfix_index ())))
+          {
+            octave_value_list tmp_args;
 
-          retval = (lvalue_list
-                    ? val.do_multi_index_op (nargout, tmp_args, lvalue_list)
-                    : val.do_multi_index_op (nargout, tmp_args));
-        }
-      else
-        {
-          if (print_result () && nargout == 0
-              && octave::tree_evaluator::statement_printing_enabled ())
-            {
-              octave_value_list args = ovl (val, name ());
-              string_vector name_tags (2);
-              name_tags(0) = name ();
-              name_tags(1) = "name";
-              args.stash_name_tags (name_tags);
-              feval ("display", args);
-            }
+            retval = (lvalue_list
+                      ? val.do_multi_index_op (nargout, tmp_args, lvalue_list)
+                      : val.do_multi_index_op (nargout, tmp_args));
+          }
+        else
+          {
+            if (print_result () && nargout == 0
+                && octave::tree_evaluator::statement_printing_enabled ())
+              {
+                octave_value_list args = ovl (val, name ());
+                string_vector name_tags (2);
+                name_tags(0) = name ();
+                name_tags(1) = "name";
+                args.stash_name_tags (name_tags);
+                octave::feval ("display", args);
+              }
 
-          retval = val;
-        }
-    }
-  else if (sym->is_added_static ())
-    static_workspace_error ();
-  else
-    eval_undefined_error ();
+            retval = val;
+          }
+      }
+    else if (sym->is_added_static ())
+      static_workspace_error ();
+    else
+      eval_undefined_error ();
 
-  return retval;
-}
+    return retval;
+  }
 
-octave_value
-tree_identifier::rvalue1 (int nargout)
-{
-  octave_value retval;
+  octave_value
+  tree_identifier::rvalue1 (int nargout)
+  {
+    octave_value retval;
 
-  octave_value_list tmp = rvalue (nargout);
+    octave_value_list tmp = rvalue (nargout);
 
-  if (! tmp.empty ())
-    retval = tmp(0);
+    if (! tmp.empty ())
+      retval = tmp(0);
 
-  return retval;
-}
+    return retval;
+  }
 
-octave_lvalue
-tree_identifier::lvalue (void)
-{
-  if (sym->is_added_static ())
-    static_workspace_error ();
+  octave_lvalue
+  tree_identifier::lvalue (void)
+  {
+    if (sym->is_added_static ())
+      static_workspace_error ();
 
-  return octave_lvalue (sym);
-}
+    return octave_lvalue (sym);
+  }
 
-tree_identifier *
-tree_identifier::dup (symbol_table::scope_id sc,
-                      symbol_table::context_id) const
-{
-  // The new tree_identifier object contains a symbol_record
-  // entry from the duplicated scope.
+  tree_identifier *
+  tree_identifier::dup (symbol_table::scope_id sc,
+                        symbol_table::context_id) const
+  {
+    // The new tree_identifier object contains a symbol_record
+    // entry from the duplicated scope.
 
-  // FIXME: is this the best way?
-  symbol_table::symbol_record new_sym
-    = symbol_table::find_symbol (name (), sc);
+    // FIXME: is this the best way?
+    symbol_table::symbol_record new_sym
+      = symbol_table::find_symbol (name (), sc);
 
-  tree_identifier *new_id
-    = new tree_identifier (new_sym, line (), column ());
+    tree_identifier *new_id
+      = new tree_identifier (new_sym, line (), column ());
 
-  new_id->copy_base (*this);
+    new_id->copy_base (*this);
 
-  return new_id;
-}
+    return new_id;
+  }
 
-void
-tree_identifier::accept (tree_walker& tw)
-{
-  tw.visit_identifier (*this);
+  void
+  tree_identifier::accept (tree_walker& tw)
+  {
+    tw.visit_identifier (*this);
+  }
 }
-
diff --git a/libinterp/parse-tree/pt-id.h b/libinterp/parse-tree/pt-id.h
--- a/libinterp/parse-tree/pt-id.h
+++ b/libinterp/parse-tree/pt-id.h
@@ -27,148 +27,159 @@ along with Octave; see the file COPYING.
 
 #include <iosfwd>
 #include <string>
 
 class octave_value;
 class octave_value_list;
 class octave_function;
 
-class tree_walker;
-
 #include "oct-lvalue.h"
 #include "pt-bp.h"
 #include "pt-exp.h"
 #include "symtab.h"
 
-// Symbols from the symbol table.
-
-class
-tree_identifier : public tree_expression
+namespace octave
 {
-  friend class tree_index_expression;
+  class tree_walker;
+
+  // Symbols from the symbol table.
 
-public:
+  class tree_identifier : public tree_expression
+  {
+    friend class tree_index_expression;
 
-  tree_identifier (int l = -1, int c = -1)
-    : tree_expression (l, c) { }
+  public:
+
+    tree_identifier (int l = -1, int c = -1)
+      : tree_expression (l, c) { }
 
-  tree_identifier (const symbol_table::symbol_record& s,
-                   int l = -1, int c = -1,
-                   symbol_table::scope_id sc = symbol_table::current_scope ())
-    : tree_expression (l, c), sym (s, sc) { }
+    tree_identifier (const symbol_table::symbol_record& s,
+                     int l = -1, int c = -1,
+                     symbol_table::scope_id sc = symbol_table::current_scope ())
+      : tree_expression (l, c), sym (s, sc) { }
 
-  // No copying!
+    // No copying!
 
-  tree_identifier (const tree_identifier&) = delete;
+    tree_identifier (const tree_identifier&) = delete;
 
-  tree_identifier& operator = (const tree_identifier&) = delete;
+    tree_identifier& operator = (const tree_identifier&) = delete;
 
-  ~tree_identifier (void) = default;
+    ~tree_identifier (void) = default;
 
-  bool has_magic_end (void) const { return (name () == "end"); }
+    bool has_magic_end (void) const { return (name () == "end"); }
 
-  bool is_identifier (void) const { return true; }
+    bool is_identifier (void) const { return true; }
 
-  // The name doesn't change with scope, so use sym instead of
-  // accessing it through sym so that this function may remain const.
-  std::string name (void) const { return sym.name (); }
+    // The name doesn't change with scope, so use sym instead of
+    // accessing it through sym so that this function may remain const.
+    std::string name (void) const { return sym.name (); }
 
-  bool is_defined (void) { return sym->is_defined (); }
+    bool is_defined (void) { return sym->is_defined (); }
 
-  virtual bool is_variable (void) const { return sym->is_variable (); }
+    virtual bool is_variable (void) const { return sym->is_variable (); }
 
-  virtual bool is_black_hole (void) { return false; }
+    virtual bool is_black_hole (void) { return false; }
 
-  // Try to find a definition for an identifier.  Here's how:
-  //
-  //   * If the identifier is already defined and is a function defined
-  //     in an function file that has been modified since the last time
-  //     we parsed it, parse it again.
-  //
-  //   * If the identifier is not defined, try to find a builtin
-  //     variable or an already compiled function with the same name.
-  //
-  //   * If the identifier is still undefined, try looking for an
-  //     function file to parse.
-  //
-  //   * On systems that support dynamic linking, we prefer .oct files,
-  //     then .mex files, then .m files.
+    // Try to find a definition for an identifier.  Here's how:
+    //
+    //   * If the identifier is already defined and is a function defined
+    //     in an function file that has been modified since the last time
+    //     we parsed it, parse it again.
+    //
+    //   * If the identifier is not defined, try to find a builtin
+    //     variable or an already compiled function with the same name.
+    //
+    //   * If the identifier is still undefined, try looking for an
+    //     function file to parse.
+    //
+    //   * On systems that support dynamic linking, we prefer .oct files,
+    //     then .mex files, then .m files.
 
-  octave_value
-  do_lookup (const octave_value_list& args = octave_value_list ())
-  {
-    return sym->find (args);
-  }
+    octave_value
+    do_lookup (const octave_value_list& args = octave_value_list ())
+    {
+      return sym->find (args);
+    }
 
-  void mark_global (void) { sym->mark_global (); }
+    void mark_global (void) { sym->mark_global (); }
 
-  void mark_as_static (void) { sym->init_persistent (); }
+    void mark_as_static (void) { sym->init_persistent (); }
+
+    void mark_as_formal_parameter (void) { sym->mark_formal (); }
 
-  void mark_as_formal_parameter (void) { sym->mark_formal (); }
+    // We really need to know whether this symbol referst to a variable
+    // or a function, but we may not know that yet.
 
-  // We really need to know whether this symbol referst to a variable
-  // or a function, but we may not know that yet.
+    bool lvalue_ok (void) const { return true; }
 
-  bool lvalue_ok (void) const { return true; }
+    octave_value rvalue1 (int nargout = 1);
 
-  octave_value rvalue1 (int nargout = 1);
+    octave_value_list rvalue (int nargout)
+    {
+      return rvalue (nargout, 0);
+    }
 
-  octave_value_list rvalue (int nargout)
-  {
-    return rvalue (nargout, 0);
-  }
+    octave_value_list rvalue (int nargout,
+                              const std::list<octave_lvalue> *lvalue_list);
+
+    octave_lvalue lvalue (void);
 
-  octave_value_list rvalue (int nargout,
-                            const std::list<octave_lvalue> *lvalue_list);
+    void eval_undefined_error (void);
 
-  octave_lvalue lvalue (void);
-
-  void eval_undefined_error (void);
+    void static_workspace_error (void)
+    {
+      error ("can not add variable \"%s\" to a static workspace",
+             name ().c_str ());
+    }
 
-  void static_workspace_error (void)
-  {
-    error ("can not add variable \"%s\" to a static workspace",
-           name ().c_str ());
-  }
+    tree_identifier *dup (symbol_table::scope_id scope,
+                          symbol_table::context_id context) const;
+
+    void accept (tree_walker& tw);
 
-  tree_identifier *dup (symbol_table::scope_id scope,
-                        symbol_table::context_id context) const;
-
-  void accept (tree_walker& tw);
+    symbol_table::symbol_reference symbol (void) const
+    {
+      return sym;
+    }
+  private:
 
-  symbol_table::symbol_reference symbol (void) const
+    // The symbol record that this identifier references.
+    symbol_table::symbol_reference sym;
+  };
+
+  class tree_black_hole : public tree_identifier
   {
-    return sym;
-  }
-private:
+  public:
 
-  // The symbol record that this identifier references.
-  symbol_table::symbol_reference sym;
-};
+    tree_black_hole (int l = -1, int c = -1)
+      : tree_identifier (l, c) { }
 
-class tree_black_hole : public tree_identifier
-{
-public:
+    std::string name (void) const { return "~"; }
 
-  tree_black_hole (int l = -1, int c = -1)
-    : tree_identifier (l, c) { }
+    bool is_variable (void) const { return false; }
+
+    bool is_black_hole (void) { return true; }
 
-  std::string name (void) const { return "~"; }
-
-  bool is_variable (void) const { return false; }
-
-  bool is_black_hole (void) { return true; }
+    tree_black_hole *dup (symbol_table::scope_id,
+                          symbol_table::context_id) const
+    {
+      return new tree_black_hole;
+    }
 
-  tree_black_hole *dup (symbol_table::scope_id,
-                        symbol_table::context_id) const
-  {
-    return new tree_black_hole;
-  }
+    octave_lvalue lvalue (void)
+    {
+      return octave_lvalue (); // black hole lvalue
+    }
+  };
+}
 
-  octave_lvalue lvalue (void)
-  {
-    return octave_lvalue (); // black hole lvalue
-  }
-};
+#if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
+
+OCTAVE_DEPRECATED ("use 'octave::tree_identifier' instead")
+typedef octave::tree_identifier tree_identifier;
+
+OCTAVE_DEPRECATED ("use 'octave::tree_black_hole' instead")
+typedef octave::tree_black_hole tree_black_hole;
 
 #endif
 
+#endif
diff --git a/libinterp/parse-tree/pt-idx.cc b/libinterp/parse-tree/pt-idx.cc
--- a/libinterp/parse-tree/pt-idx.cc
+++ b/libinterp/parse-tree/pt-idx.cc
@@ -35,121 +35,124 @@ along with Octave; see the file COPYING.
 #include "pt-bp.h"
 #include "pt-id.h"
 #include "pt-idx.h"
 #include "pt-walk.h"
 #include "utils.h"
 #include "variables.h"
 #include "errwarn.h"
 
-// Index expressions.
-
-tree_index_expression::tree_index_expression (int l, int c)
-  : tree_expression (l, c), expr (0), args (0), type (),
-    arg_nm (), dyn_field () { }
-
-tree_index_expression::tree_index_expression (tree_expression *e,
-                                              tree_argument_list *lst,
-                                              int l, int c, char t)
-  : tree_expression (l, c), expr (e), args (0), type (),
-    arg_nm (), dyn_field ()
-{
-  append (lst, t);
-}
-
-tree_index_expression::tree_index_expression (tree_expression *e,
-                                              const std::string& n,
-                                              int l, int c)
-  : tree_expression (l, c), expr (e), args (0), type (),
-    arg_nm (), dyn_field ()
-{
-  append (n);
-}
-
-tree_index_expression::tree_index_expression (tree_expression *e,
-                                              tree_expression *df,
-                                              int l, int c)
-  : tree_expression (l, c), expr (e), args (0), type (),
-    arg_nm (), dyn_field ()
-{
-  append (df);
-}
-
-void
-tree_index_expression::append (tree_argument_list *lst, char t)
-{
-  args.push_back (lst);
-  type.append (1, t);
-  arg_nm.push_back (lst ? lst->get_arg_names () : string_vector ());
-  dyn_field.push_back (static_cast<tree_expression *> (0));
-
-  if (lst && lst->has_magic_tilde ())
-    error ("invalid use of empty argument (~) in index expression");
-}
-
-void
-tree_index_expression::append (const std::string& n)
+namespace octave
 {
-  args.push_back (static_cast<tree_argument_list *> (0));
-  type.append (".");
-  arg_nm.push_back (n);
-  dyn_field.push_back (static_cast<tree_expression *> (0));
-}
+  // Index expressions.
+
+  tree_index_expression::tree_index_expression (int l, int c)
+    : tree_expression (l, c), expr (0), args (0), type (),
+      arg_nm (), dyn_field () { }
+
+  tree_index_expression::tree_index_expression (tree_expression *e,
+                                                tree_argument_list *lst,
+                                                int l, int c, char t)
+    : tree_expression (l, c), expr (e), args (0), type (),
+      arg_nm (), dyn_field ()
+  {
+    append (lst, t);
+  }
 
-void
-tree_index_expression::append (tree_expression *df)
-{
-  args.push_back (static_cast<tree_argument_list *> (0));
-  type.append (".");
-  arg_nm.push_back ("");
-  dyn_field.push_back (df);
-}
+  tree_index_expression::tree_index_expression (tree_expression *e,
+                                                const std::string& n,
+                                                int l, int c)
+    : tree_expression (l, c), expr (e), args (0), type (),
+      arg_nm (), dyn_field ()
+  {
+    append (n);
+  }
 
-tree_index_expression::~tree_index_expression (void)
-{
-  delete expr;
+  tree_index_expression::tree_index_expression (tree_expression *e,
+                                                tree_expression *df,
+                                                int l, int c)
+    : tree_expression (l, c), expr (e), args (0), type (),
+      arg_nm (), dyn_field ()
+  {
+    append (df);
+  }
 
-  while (! args.empty ())
-    {
-      std::list<tree_argument_list *>::iterator p = args.begin ();
-      delete *p;
-      args.erase (p);
-    }
+  void
+  tree_index_expression::append (tree_argument_list *lst, char t)
+  {
+    args.push_back (lst);
+    type.append (1, t);
+    arg_nm.push_back (lst ? lst->get_arg_names () : string_vector ());
+    dyn_field.push_back (static_cast<tree_expression *> (0));
+
+    if (lst && lst->has_magic_tilde ())
+      error ("invalid use of empty argument (~) in index expression");
+  }
 
-  while (! dyn_field.empty ())
-    {
-      std::list<tree_expression *>::iterator p = dyn_field.begin ();
-      delete *p;
-      dyn_field.erase (p);
-    }
-}
+  void
+  tree_index_expression::append (const std::string& n)
+  {
+    args.push_back (static_cast<tree_argument_list *> (0));
+    type.append (".");
+    arg_nm.push_back (n);
+    dyn_field.push_back (static_cast<tree_expression *> (0));
+  }
+
+  void
+  tree_index_expression::append (tree_expression *df)
+  {
+    args.push_back (static_cast<tree_argument_list *> (0));
+    type.append (".");
+    arg_nm.push_back ("");
+    dyn_field.push_back (df);
+  }
+
+  tree_index_expression::~tree_index_expression (void)
+  {
+    delete expr;
+
+    while (! args.empty ())
+      {
+        std::list<tree_argument_list *>::iterator p = args.begin ();
+        delete *p;
+        args.erase (p);
+      }
 
-bool
-tree_index_expression::has_magic_end (void) const
-{
-  for (const tree_argument_list* elt : args)
-    {
-      if (elt && elt->has_magic_end ())
-        return true;
-    }
+    while (! dyn_field.empty ())
+      {
+        std::list<tree_expression *>::iterator p = dyn_field.begin ();
+        delete *p;
+        dyn_field.erase (p);
+      }
+  }
 
-  return false;
-}
+  bool
+  tree_index_expression::has_magic_end (void) const
+  {
+    for (const tree_argument_list* elt : args)
+      {
+        if (elt && elt->has_magic_end ())
+          return true;
+      }
 
-// This is useful for printing the name of the variable in an indexed
-// assignment.
+    return false;
+  }
+
+  // This is useful for printing the name of the variable in an indexed
+  // assignment.
 
-std::string
-tree_index_expression::name (void) const
-{
-  return expr->name ();
+  std::string
+  tree_index_expression::name (void) const
+  {
+    return expr->name ();
+  }
 }
 
 static Cell
-make_subs_cell (tree_argument_list *args, const string_vector& arg_nm)
+make_subs_cell (octave::tree_argument_list *args, const string_vector& arg_nm)
 {
   Cell retval;
 
   octave_value_list arg_values;
 
   if (args)
     arg_values = args->convert_to_const_vector ();
 
@@ -164,17 +167,17 @@ make_subs_cell (tree_argument_list *args
       for (int i = 0; i < n; i++)
         retval(0,i) = arg_values(i);
     }
 
   return retval;
 }
 
 static inline octave_value_list
-make_value_list (tree_argument_list *args, const string_vector& arg_nm,
+make_value_list (octave::tree_argument_list *args, const string_vector& arg_nm,
                  const octave_value *object, bool rvalue = true)
 {
   octave_value_list retval;
 
   if (args)
     {
       if (rvalue && object && args->has_magic_end () && object->is_undefined ())
         err_invalid_inquiry_subscript ();
@@ -185,102 +188,106 @@ make_value_list (tree_argument_list *arg
   octave_idx_type n = retval.length ();
 
   if (n > 0)
     retval.stash_name_tags (arg_nm);
 
   return retval;
 }
 
-std::string
-tree_index_expression::get_struct_index
+namespace octave
+{
+  std::string
+  tree_index_expression::get_struct_index
   (std::list<string_vector>::const_iterator p_arg_nm,
    std::list<tree_expression *>::const_iterator p_dyn_field) const
-{
-  std::string fn = (*p_arg_nm)(0);
+  {
+    std::string fn = (*p_arg_nm)(0);
 
-  if (fn.empty ())
-    {
-      tree_expression *df = *p_dyn_field;
+    if (fn.empty ())
+      {
+        tree_expression *df = *p_dyn_field;
 
-      if (df)
-        {
-          octave_value t = df->rvalue1 ();
+        if (df)
+          {
+            octave_value t = df->rvalue1 ();
 
-          fn = t.xstring_value ("dynamic structure field names must be strings");
-        }
-      else
-        panic_impossible ();
-    }
+            fn = t.xstring_value ("dynamic structure field names must be strings");
+          }
+        else
+          panic_impossible ();
+      }
 
-  return fn;
-}
+    return fn;
+  }
 
-octave_map
-tree_index_expression::make_arg_struct (void) const
-{
-  int n = args.size ();
+  octave_map
+  tree_index_expression::make_arg_struct (void) const
+  {
+    int n = args.size ();
 
-  Cell type_field (n, 1);
-  Cell subs_field (n, 1);
+    Cell type_field (n, 1);
+    Cell subs_field (n, 1);
 
-  std::list<tree_argument_list *>::const_iterator p_args = args.begin ();
-  std::list<string_vector>::const_iterator p_arg_nm = arg_nm.begin ();
-  std::list<tree_expression *>::const_iterator p_dyn_field = dyn_field.begin ();
+    std::list<tree_argument_list *>::const_iterator p_args = args.begin ();
+    std::list<string_vector>::const_iterator p_arg_nm = arg_nm.begin ();
+    std::list<tree_expression *>::const_iterator p_dyn_field = dyn_field.begin ();
 
-  octave_map m;
+    octave_map m;
 
-  for (int i = 0; i < n; i++)
-    {
-      switch (type[i])
-        {
-        case '(':
-          subs_field(i) = make_subs_cell (*p_args, *p_arg_nm);
-          break;
+    for (int i = 0; i < n; i++)
+      {
+        switch (type[i])
+          {
+          case '(':
+            subs_field(i) = make_subs_cell (*p_args, *p_arg_nm);
+            break;
 
-        case '{':
-          subs_field(i) = make_subs_cell (*p_args, *p_arg_nm);
-          break;
+          case '{':
+            subs_field(i) = make_subs_cell (*p_args, *p_arg_nm);
+            break;
 
-        case '.':
-          subs_field(i) = get_struct_index (p_arg_nm, p_dyn_field);
-          break;
+          case '.':
+            subs_field(i) = get_struct_index (p_arg_nm, p_dyn_field);
+            break;
 
-        default:
-          panic_impossible ();
-        }
+          default:
+            panic_impossible ();
+          }
 
-      p_args++;
-      p_arg_nm++;
-      p_dyn_field++;
-    }
+        p_args++;
+        p_arg_nm++;
+        p_dyn_field++;
+      }
 
-  m.assign ("type", type_field);
-  m.assign ("subs", subs_field);
+    m.assign ("type", type_field);
+    m.assign ("subs", subs_field);
+
+    return m;
+  }
 
-  return m;
-}
-
-octave_value_list
-tree_index_expression::rvalue (int nargout)
-{
-  return tree_index_expression::rvalue (nargout, 0);
+  octave_value_list
+  tree_index_expression::rvalue (int nargout)
+  {
+    return tree_index_expression::rvalue (nargout, 0);
+  }
 }
 
 // Final step of processing an indexing error.  Add the name of the
 // variable being indexed, if any, then issue an error.  (Will this also
 // be needed by pt-lvalue, which calls subsref?)
 
 static void
-final_index_error (octave::index_exception& e, const tree_expression *expr)
+final_index_error (octave::index_exception& e,
+                   const octave::tree_expression *expr)
 {
   std::string extra_message;
 
   if (expr->is_identifier ()
-      && dynamic_cast<const tree_identifier *> (expr)->is_variable ())
+      && dynamic_cast<const octave::tree_identifier *> (expr)->is_variable ())
     {
       std::string var = expr->name ();
 
       e.set_var (var);
 
       octave_value fcn = symbol_table::find_function (var);
 
       if (fcn.is_function ())
@@ -292,348 +299,389 @@ final_index_error (octave::index_excepti
         }
     }
 
   std::string msg = e.message () + extra_message;
 
   error_with_id (e.err_id (), msg.c_str ());
 }
 
-octave_value_list
-tree_index_expression::rvalue (int nargout,
-                               const std::list<octave_lvalue> *lvalue_list)
+namespace octave
 {
-  octave_value_list retval;
+  octave_value_list
+  tree_index_expression::rvalue (int nargout,
+                                 const std::list<octave_lvalue> *lvalue_list)
+  {
+    octave_value_list retval;
+
+    octave_value first_expr_val;
+
+    octave_value_list first_args;
 
-  octave_value first_expr_val;
+    bool have_args = false;
+
+    if (expr->is_identifier () && type[0] == '(')
+      {
+        tree_identifier *id = dynamic_cast<tree_identifier *> (expr);
 
-  octave_value_list first_args;
+        if (! (id->is_variable () || args.empty ()))
+          {
+            tree_argument_list *al = *(args.begin ());
+
+            size_t n = al ? al->length () : 0;
 
-  bool have_args = false;
+            if (n > 0)
+              {
+                string_vector anm = *(arg_nm.begin ());
+                have_args = true;
+                first_args = al -> convert_to_const_vector ();
+                first_args.stash_name_tags (anm);
 
-  if (expr->is_identifier () && type[0] == '(')
-    {
-      tree_identifier *id = dynamic_cast<tree_identifier *> (expr);
+                first_expr_val = id->do_lookup  (first_args);
+              }
+          }
+      }
 
-      if (! (id->is_variable () || args.empty ()))
-        {
-          tree_argument_list *al = *(args.begin ());
+    if (first_expr_val.is_undefined ())
+      first_expr_val = expr->rvalue1 ();
+
+    octave_value tmp = first_expr_val;
+    octave_idx_type tmpi = 0;
 
-          size_t n = al ? al->length () : 0;
+    std::list<octave_value_list> idx;
+
+    int n = args.size ();
+
+    std::list<tree_argument_list *>::iterator p_args = args.begin ();
+    std::list<string_vector>::iterator p_arg_nm = arg_nm.begin ();
+    std::list<tree_expression *>::iterator p_dyn_field = dyn_field.begin ();
 
-          if (n > 0)
-            {
-              string_vector anm = *(arg_nm.begin ());
-              have_args = true;
-              first_args = al -> convert_to_const_vector ();
-              first_args.stash_name_tags (anm);
+    for (int i = 0; i < n; i++)
+      {
+        if (i > 0)
+          {
+            tree_argument_list *al = *p_args;
+
+            // In Matlab, () can only be followed by '.'.  In Octave, we do not
+            // enforce this for rvalue expressions, but we'll split the
+            // evaluation at this point.  This will, hopefully, allow Octave's
+            // looser rules apply smoothly for Matlab overloaded subsref
+            // codes.
+            bool force_split = type[i-1] == '(' && type[i] != '.';
 
-              first_expr_val = id->do_lookup  (first_args);
-            }
-        }
-    }
+            if (force_split || (al && al->has_magic_end ()))
+              {
+                // (we have force_split, or) we have an expression like
+                //
+                //   x{end}.a(end)
+                //
+                // and we are looking at the argument list that
+                // contains the second (or third, etc.) "end" token,
+                // so we must evaluate everything up to the point of
+                // that argument list so we can pass the appropriate
+                // value to the built-in end function.
+
+                try
+                  {
+                    octave_value_list tmp_list
+                      =tmp.subsref (type.substr (tmpi, i-tmpi), idx, nargout);
 
-  if (first_expr_val.is_undefined ())
-    first_expr_val = expr->rvalue1 ();
+                    tmp = tmp_list.length () ? tmp_list(0) : octave_value ();
+                    tmpi = i;
+                    idx.clear ();
+
+                    if (tmp.is_cs_list ())
+                      err_indexed_cs_list ();
 
-  octave_value tmp = first_expr_val;
-  octave_idx_type tmpi = 0;
+                    if (tmp.is_function ())
+                      {
+                        octave_function *fcn = tmp.function_value (true);
+
+                        if (fcn && ! fcn->is_postfix_index_handled (type[i]))
+                          {
+                            octave_value_list empty_args;
 
-  std::list<octave_value_list> idx;
-
-  int n = args.size ();
+                            tmp_list = tmp.do_multi_index_op (1, empty_args);
+                            tmp = (tmp_list.length ()
+                                   ? tmp_list(0) : octave_value ());
 
-  std::list<tree_argument_list *>::iterator p_args = args.begin ();
-  std::list<string_vector>::iterator p_arg_nm = arg_nm.begin ();
-  std::list<tree_expression *>::iterator p_dyn_field = dyn_field.begin ();
+                            if (tmp.is_cs_list ())
+                              err_indexed_cs_list ();
+                          }
+                      }
+                  }
+                catch (octave::index_exception& e)  // problems with index range, type etc.
+                  {
+                    final_index_error (e, expr);
+                  }
+              }
+          }
 
-  for (int i = 0; i < n; i++)
-    {
-      if (i > 0)
-        {
-          tree_argument_list *al = *p_args;
+        switch (type[i])
+          {
+          case '(':
+            if (have_args)
+              {
+                idx.push_back (first_args);
+                have_args = false;
+              }
+            else
+              idx.push_back (make_value_list (*p_args, *p_arg_nm, &tmp));
+            break;
+
+          case '{':
+            idx.push_back (make_value_list (*p_args, *p_arg_nm, &tmp));
+            break;
+
+          case '.':
+            idx.push_back (octave_value (get_struct_index (p_arg_nm,
+                                                           p_dyn_field)));
+            break;
+
+          default:
+            panic_impossible ();
+          }
+
+        p_args++;
+        p_arg_nm++;
+        p_dyn_field++;
+      }
 
-          // In Matlab, () can only be followed by '.'.  In Octave, we do not
-          // enforce this for rvalue expressions, but we'll split the
-          // evaluation at this point.  This will, hopefully, allow Octave's
-          // looser rules apply smoothly for Matlab overloaded subsref
-          // codes.
-          bool force_split = type[i-1] == '(' && type[i] != '.';
+    try
+      {
+        retval = tmp.subsref (type.substr (tmpi, n - tmpi), idx, nargout,
+                              lvalue_list);
+      }
+    catch (octave::index_exception& e)  // range problems, bad index type, etc.
+      {
+        final_index_error (e, expr);
+      }
+
+    octave_value val = retval.length () ? retval(0) : octave_value ();
+
+    if (val.is_function ())
+      {
+        octave_function *fcn = val.function_value (true);
+
+        if (fcn)
+          {
+            octave_value_list empty_args;
+
+            retval = (lvalue_list
+                      ? val.do_multi_index_op (nargout, empty_args,
+                                               lvalue_list)
+                      : val.do_multi_index_op (nargout, empty_args));
+          }
+      }
+
+    return retval;
+  }
 
-          if (force_split || (al && al->has_magic_end ()))
+  octave_value
+  tree_index_expression::rvalue1 (int nargout)
+  {
+    octave_value retval;
+
+    const octave_value_list tmp = rvalue (nargout);
+
+    if (! tmp.empty ())
+      retval = tmp(0);
+
+    return retval;
+  }
+
+  octave_lvalue
+  tree_index_expression::lvalue (void)
+  {
+    octave_lvalue retval;
+
+    std::list<octave_value_list> idx;
+    std::string tmp_type;
+
+    int n = args.size ();
+
+    std::list<tree_argument_list *>::iterator p_args = args.begin ();
+    std::list<string_vector>::iterator p_arg_nm = arg_nm.begin ();
+    std::list<tree_expression *>::iterator p_dyn_field = dyn_field.begin ();
+
+    retval = expr->lvalue ();
+
+    octave_value tmp = retval.value ();
+
+    octave_idx_type tmpi = 0;
+    std::list<octave_value_list> tmpidx;
+
+    for (int i = 0; i < n; i++)
+      {
+        if (retval.numel () != 1)
+          err_indexed_cs_list ();
+
+        if (tmpi < i)
+          {
+            try
+              {
+                tmp = tmp.subsref (type.substr (tmpi, i-tmpi), tmpidx, true);
+              }
+            catch (octave::index_exception& e)  // problems with range, invalid type etc.
+              {
+                final_index_error (e, expr);
+              }
+
+            tmpidx.clear ();
+          }
+
+        switch (type[i])
+          {
+          case '(':
             {
-              // (we have force_split, or) we have an expression like
-              //
-              //   x{end}.a(end)
-              //
-              // and we are looking at the argument list that
-              // contains the second (or third, etc.) "end" token,
-              // so we must evaluate everything up to the point of
-              // that argument list so we can pass the appropriate
-              // value to the built-in end function.
+              octave_value_list tidx
+                = make_value_list (*p_args, *p_arg_nm, &tmp, false);
 
-              try
+              idx.push_back (tidx);
+
+              if (i < n - 1)
                 {
-                  octave_value_list tmp_list
-                    =tmp.subsref (type.substr (tmpi, i-tmpi), idx, nargout);
-
-                  tmp = tmp_list.length () ? tmp_list(0) : octave_value ();
-                  tmpi = i;
-                  idx.clear ();
-
-                  if (tmp.is_cs_list ())
-                    err_indexed_cs_list ();
-
-                  if (tmp.is_function ())
-                    {
-                      octave_function *fcn = tmp.function_value (true);
+                  if (type[i+1] != '.')
+                    error ("() must be followed by . or close the index chain");
 
-                      if (fcn && ! fcn->is_postfix_index_handled (type[i]))
-                        {
-                          octave_value_list empty_args;
-
-                          tmp_list = tmp.do_multi_index_op (1, empty_args);
-                          tmp = (tmp_list.length ()
-                                 ? tmp_list(0) : octave_value ());
-
-                          if (tmp.is_cs_list ())
-                            err_indexed_cs_list ();
-                        }
-                    }
-                }
-              catch (octave::index_exception& e)  // problems with index range, type etc.
-                {
-                  final_index_error (e, expr);
+                  tmpidx.push_back (tidx);
+                  tmpi = i+1;
                 }
             }
-        }
+            break;
 
-      switch (type[i])
-        {
-        case '(':
-          if (have_args)
+          case '{':
             {
-              idx.push_back (first_args);
-              have_args = false;
-            }
-          else
-            idx.push_back (make_value_list (*p_args, *p_arg_nm, &tmp));
-          break;
-
-        case '{':
-          idx.push_back (make_value_list (*p_args, *p_arg_nm, &tmp));
-          break;
-
-        case '.':
-          idx.push_back (octave_value (get_struct_index (p_arg_nm,
-                                                         p_dyn_field)));
-          break;
+              octave_value_list tidx
+                = make_value_list (*p_args, *p_arg_nm, &tmp, false);
 
-        default:
-          panic_impossible ();
-        }
-
-      p_args++;
-      p_arg_nm++;
-      p_dyn_field++;
-    }
+              if (tmp.is_undefined ())
+                {
+                  if (tidx.has_magic_colon ())
+                    err_invalid_inquiry_subscript ();
 
-  try
-    {
-      retval = tmp.subsref (type.substr (tmpi, n - tmpi), idx, nargout,
-                            lvalue_list);
-    }
-  catch (octave::index_exception& e)  // range problems, bad index type, etc.
-    {
-      final_index_error (e, expr);
-    }
+                  tmp = Cell ();
+                }
+              else if (tmp.is_zero_by_zero ()
+                       && (tmp.is_matrix_type () || tmp.is_string ()))
+                {
+                  tmp = Cell ();
+                }
 
-  octave_value val = retval.length () ? retval(0) : octave_value ();
-
-  if (val.is_function ())
-    {
-      octave_function *fcn = val.function_value (true);
-
-      if (fcn)
-        {
-          octave_value_list empty_args;
+              retval.numel (tmp.numel (tidx));
 
-          retval = (lvalue_list
-                    ? val.do_multi_index_op (nargout, empty_args,
-                                             lvalue_list)
-                    : val.do_multi_index_op (nargout, empty_args));
-        }
-    }
-
-  return retval;
-}
+              idx.push_back (tidx);
+              tmpidx.push_back (tidx);
+              tmpi = i;
+            }
+            break;
 
-octave_value
-tree_index_expression::rvalue1 (int nargout)
-{
-  octave_value retval;
-
-  const octave_value_list tmp = rvalue (nargout);
+          case '.':
+            {
+              octave_value tidx = get_struct_index (p_arg_nm, p_dyn_field);
 
-  if (! tmp.empty ())
-    retval = tmp(0);
-
-  return retval;
-}
-
-octave_lvalue
-tree_index_expression::lvalue (void)
-{
-  octave_lvalue retval;
+              bool autoconv = (tmp.is_zero_by_zero ()
+                               && (tmp.is_matrix_type () || tmp.is_string ()
+                                   || tmp.is_cell ()));
 
-  std::list<octave_value_list> idx;
-  std::string tmp_type;
-
-  int n = args.size ();
-
-  std::list<tree_argument_list *>::iterator p_args = args.begin ();
-  std::list<string_vector>::iterator p_arg_nm = arg_nm.begin ();
-  std::list<tree_expression *>::iterator p_dyn_field = dyn_field.begin ();
-
-  retval = expr->lvalue ();
-
-  octave_value tmp = retval.value ();
-
-  octave_idx_type tmpi = 0;
-  std::list<octave_value_list> tmpidx;
+              if (i > 0 && type[i-1] == '(')
+                {
+                  octave_value_list pidx = idx.back ();
 
-  for (int i = 0; i < n; i++)
-    {
-      if (retval.numel () != 1)
-        err_indexed_cs_list ();
+                  // Use octave_map, not octave_scalar_map so that the
+                  // dimensions are 0x0, not 1x1.
+                  if (tmp.is_undefined ())
+                    {
+                      if (pidx.has_magic_colon ())
+                        err_invalid_inquiry_subscript ();
 
-      if (tmpi < i)
-        {
-          try
-            {
-              tmp = tmp.subsref (type.substr (tmpi, i-tmpi), tmpidx, true);
-            }
-          catch (octave::index_exception& e)  // problems with range, invalid type etc.
-            {
-              final_index_error (e, expr);
-            }
+                      tmp = octave_map ();
+                    }
+                  else if (autoconv)
+                    tmp = octave_map ();
+
+                  retval.numel (tmp.numel (pidx));
 
-          tmpidx.clear ();
-        }
-
-      switch (type[i])
-        {
-        case '(':
-          {
-            octave_value_list tidx
-              = make_value_list (*p_args, *p_arg_nm, &tmp, false);
-
-            idx.push_back (tidx);
-
-            if (i < n - 1)
-              {
-                if (type[i+1] != '.')
-                  error ("() must be followed by . or close the index chain");
-
-                tmpidx.push_back (tidx);
-                tmpi = i+1;
-              }
-          }
-          break;
-
-        case '{':
-          {
-            octave_value_list tidx
-              = make_value_list (*p_args, *p_arg_nm, &tmp, false);
+                  tmpi = i-1;
+                  tmpidx.push_back (tidx);
+                }
+              else
+                {
+                  if (tmp.is_undefined () || autoconv)
+                    {
+                      tmpi = i+1;
+                      tmp = octave_value ();
+                    }
+                  else
+                    {
+                      retval.numel (tmp.numel (octave_value_list ()));
 
-            if (tmp.is_undefined ())
-              {
-                if (tidx.has_magic_colon ())
-                  err_invalid_inquiry_subscript ();
+                      tmpi = i;
+                      tmpidx.push_back (tidx);
+                    }
+                }
 
-                tmp = Cell ();
-              }
-            else if (tmp.is_zero_by_zero ()
-                     && (tmp.is_matrix_type () || tmp.is_string ()))
-              {
-                tmp = Cell ();
-              }
+              idx.push_back (tidx);
+            }
+            break;
 
-            retval.numel (tmp.numel (tidx));
+          default:
+            panic_impossible ();
+          }
 
-            idx.push_back (tidx);
-            tmpidx.push_back (tidx);
-            tmpi = i;
-          }
-          break;
+        if (idx.back ().empty ())
+          error ("invalid empty index list");
 
-        case '.':
-          {
-            octave_value tidx = get_struct_index (p_arg_nm, p_dyn_field);
+        p_args++;
+        p_arg_nm++;
+        p_dyn_field++;
+      }
 
-            bool autoconv = (tmp.is_zero_by_zero ()
-                             && (tmp.is_matrix_type () || tmp.is_string ()
-                                 || tmp.is_cell ()));
+    retval.set_index (type, idx);
 
-            if (i > 0 && type[i-1] == '(')
-              {
-                octave_value_list pidx = idx.back ();
+    return retval;
+  }
 
-                // Use octave_map, not octave_scalar_map so that the
-                // dimensions are 0x0, not 1x1.
-                if (tmp.is_undefined ())
-                  {
-                    if (pidx.has_magic_colon ())
-                      err_invalid_inquiry_subscript ();
+  tree_index_expression *
+  tree_index_expression::dup (symbol_table::scope_id scope,
+                              symbol_table::context_id context) const
+  {
+    tree_index_expression *new_idx_expr
+      = new tree_index_expression (line (), column ());
 
-                    tmp = octave_map ();
-                  }
-                else if (autoconv)
-                  tmp = octave_map ();
+    new_idx_expr->expr = expr ? expr->dup (scope, context) : 0;
+
+    std::list<tree_argument_list *> new_args;
 
-                retval.numel (tmp.numel (pidx));
+    for (const tree_argument_list* elt : args)
+      new_args.push_back (elt ? elt->dup (scope, context) : 0);
+
+    new_idx_expr->args = new_args;
 
-                tmpi = i-1;
-                tmpidx.push_back (tidx);
-              }
-            else
-              {
-                if (tmp.is_undefined () || autoconv)
-                  {
-                    tmpi = i+1;
-                    tmp = octave_value ();
-                  }
-                else
-                  {
-                    retval.numel (tmp.numel (octave_value_list ()));
+    new_idx_expr->type = type;
+
+    new_idx_expr->arg_nm = arg_nm;
 
-                    tmpi = i;
-                    tmpidx.push_back (tidx);
-                  }
-              }
+    std::list<tree_expression *> new_dyn_field;
+
+    for (const tree_expression* elt : dyn_field)
+      new_dyn_field.push_back (elt ? elt->dup (scope, context) : 0);
+
+    new_idx_expr->dyn_field = new_dyn_field;
 
-            idx.push_back (tidx);
-          }
-          break;
+    new_idx_expr->copy_base (*this);
 
-        default:
-          panic_impossible ();
-        }
+    return new_idx_expr;
+  }
 
-      if (idx.back ().empty ())
-        error ("invalid empty index list");
-
-      p_args++;
-      p_arg_nm++;
-      p_dyn_field++;
-    }
-
-  retval.set_index (type, idx);
-
-  return retval;
+  void
+  tree_index_expression::accept (tree_walker& tw)
+  {
+    tw.visit_index_expression (*this);
+  }
 }
 
 /*
 %!test
 %! clear x;
 %! clear y;
 %! y = 3;
 %! x(y(end)) = 1;
@@ -662,47 +710,8 @@ tree_index_expression::lvalue (void)
 %! x(2).b = 1;
 %! assert (x(2).b == 1);
 
 %!test
 %! x = struct (zeros (0, 1), {"a", "b"});
 %! x(2).b = 1;
 %! assert (x(2).b == 1);
 */
-
-tree_index_expression *
-tree_index_expression::dup (symbol_table::scope_id scope,
-                            symbol_table::context_id context) const
-{
-  tree_index_expression *new_idx_expr
-    = new tree_index_expression (line (), column ());
-
-  new_idx_expr->expr = expr ? expr->dup (scope, context) : 0;
-
-  std::list<tree_argument_list *> new_args;
-
-  for (const tree_argument_list* elt : args)
-    new_args.push_back (elt ? elt->dup (scope, context) : 0);
-
-  new_idx_expr->args = new_args;
-
-  new_idx_expr->type = type;
-
-  new_idx_expr->arg_nm = arg_nm;
-
-  std::list<tree_expression *> new_dyn_field;
-
-  for (const tree_expression* elt : dyn_field)
-    new_dyn_field.push_back (elt ? elt->dup (scope, context) : 0);
-
-  new_idx_expr->dyn_field = new_dyn_field;
-
-  new_idx_expr->copy_base (*this);
-
-  return new_idx_expr;
-}
-
-void
-tree_index_expression::accept (tree_walker& tw)
-{
-  tw.visit_index_expression (*this);
-}
-
diff --git a/libinterp/parse-tree/pt-idx.h b/libinterp/parse-tree/pt-idx.h
--- a/libinterp/parse-tree/pt-idx.h
+++ b/libinterp/parse-tree/pt-idx.h
@@ -22,114 +22,122 @@ along with Octave; see the file COPYING.
 
 #if ! defined (octave_pt_idx_h)
 #define octave_pt_idx_h 1
 
 #include "octave-config.h"
 
 #include <list>
 
-class tree_argument_list;
-
-class tree_walker;
-
 class octave_map;
 class octave_value;
 class octave_value_list;
 class octave_lvalue;
 
 #include "str-vec.h"
 
 #include "pt-exp.h"
 #include "symtab.h"
 
-// Index expressions.
-
-class
-tree_index_expression : public tree_expression
+namespace octave
 {
-public:
+  class tree_argument_list;
 
-  tree_index_expression (tree_expression *e = 0, tree_argument_list *lst = 0,
-                         int l = -1, int c = -1, char t = '(');
+  class tree_walker;
+
+  // Index expressions.
 
-  tree_index_expression (tree_expression *e, const std::string& n,
-                         int l = -1, int c = -1);
+  class tree_index_expression : public tree_expression
+  {
+  public:
 
-  tree_index_expression (tree_expression *e, tree_expression* df,
-                         int l = -1, int c = -1);
+    tree_index_expression (tree_expression *e = 0, tree_argument_list *lst = 0,
+                           int l = -1, int c = -1, char t = '(');
 
-  // No copying!
+    tree_index_expression (tree_expression *e, const std::string& n,
+                           int l = -1, int c = -1);
 
-  tree_index_expression (const tree_index_expression&) = delete;
+    tree_index_expression (tree_expression *e, tree_expression* df,
+                           int l = -1, int c = -1);
 
-  tree_index_expression& operator = (const tree_index_expression&) = delete;
+    // No copying!
 
-  ~tree_index_expression (void);
+    tree_index_expression (const tree_index_expression&) = delete;
+
+    tree_index_expression& operator = (const tree_index_expression&) = delete;
 
-  bool has_magic_end (void) const;
+    ~tree_index_expression (void);
 
-  void append (tree_argument_list *lst = 0, char t = '(');
+    bool has_magic_end (void) const;
 
-  void append (const std::string& n);
+    void append (tree_argument_list *lst = 0, char t = '(');
 
-  void append (tree_expression *df);
+    void append (const std::string& n);
 
-  bool is_index_expression (void) const { return true; }
+    void append (tree_expression *df);
 
-  std::string name (void) const;
+    bool is_index_expression (void) const { return true; }
 
-  tree_expression *expression (void) { return expr; }
+    std::string name (void) const;
 
-  std::list<tree_argument_list *> arg_lists (void) { return args; }
+    tree_expression *expression (void) { return expr; }
 
-  std::string type_tags (void) { return type; }
+    std::list<tree_argument_list *> arg_lists (void) { return args; }
 
-  std::list<string_vector> arg_names (void) { return arg_nm; }
+    std::string type_tags (void) { return type; }
 
-  bool lvalue_ok (void) const { return expr->lvalue_ok (); }
+    std::list<string_vector> arg_names (void) { return arg_nm; }
 
-  bool rvalue_ok (void) const { return true; }
+    bool lvalue_ok (void) const { return expr->lvalue_ok (); }
 
-  octave_value rvalue1 (int nargout = 1);
+    bool rvalue_ok (void) const { return true; }
 
-  octave_value_list rvalue (int nargout);
+    octave_value rvalue1 (int nargout = 1);
 
-  octave_value_list rvalue (int nargout,
-                            const std::list<octave_lvalue> *lvalue_list);
+    octave_value_list rvalue (int nargout);
 
-  octave_lvalue lvalue (void);
+    octave_value_list rvalue (int nargout,
+                              const std::list<octave_lvalue> *lvalue_list);
 
-  tree_index_expression *dup (symbol_table::scope_id scope,
-                              symbol_table::context_id context) const;
+    octave_lvalue lvalue (void);
 
-  void accept (tree_walker& tw);
+    tree_index_expression *dup (symbol_table::scope_id scope,
+                                symbol_table::context_id context) const;
 
-private:
+    void accept (tree_walker& tw);
 
-  // The LHS of this index expression.
-  tree_expression *expr;
+  private:
+
+    // The LHS of this index expression.
+    tree_expression *expr;
 
-  // The indices (only valid if type == paren || type == brace).
-  std::list<tree_argument_list *> args;
+    // The indices (only valid if type == paren || type == brace).
+    std::list<tree_argument_list *> args;
 
-  // The type of this index expression.
-  std::string type;
+    // The type of this index expression.
+    std::string type;
 
-  // The names of the arguments.  Used for constant struct element
-  // references.
-  std::list<string_vector> arg_nm;
+    // The names of the arguments.  Used for constant struct element
+    // references.
+    std::list<string_vector> arg_nm;
 
-  // The list of dynamic field names, if any.
-  std::list<tree_expression *> dyn_field;
+    // The list of dynamic field names, if any.
+    std::list<tree_expression *> dyn_field;
 
-  tree_index_expression (int l, int c);
+    tree_index_expression (int l, int c);
 
-  octave_map make_arg_struct (void) const;
+    octave_map make_arg_struct (void) const;
 
-  std::string
-  get_struct_index
+    std::string
+    get_struct_index
     (std::list<string_vector>::const_iterator p_arg_nm,
      std::list<tree_expression *>::const_iterator p_dyn_field) const;
-};
+  };
+}
+
+#if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
+
+OCTAVE_DEPRECATED ("use 'octave::tree_index_expression' instead")
+typedef octave::tree_index_expression tree_index_expression;
 
 #endif
 
+#endif
diff --git a/libinterp/parse-tree/pt-jump.cc b/libinterp/parse-tree/pt-jump.cc
--- a/libinterp/parse-tree/pt-jump.cc
+++ b/libinterp/parse-tree/pt-jump.cc
@@ -27,62 +27,64 @@ along with Octave; see the file COPYING.
 #include "error.h"
 #include "ovl.h"
 #include "pt-bp.h"
 #include "pt-jump.h"
 #include "pt-walk.h"
 
 class octave_value_list;
 
-// Break.
-
-// Nonzero means we're breaking out of a loop or function body.
-int tree_break_command::breaking = 0;
-
-tree_command *
-tree_break_command::dup (symbol_table::scope_id,
-                         symbol_table::context_id) const
-{
-  return new tree_break_command (line (), column ());
-}
-
-void
-tree_break_command::accept (tree_walker& tw)
-{
-  tw.visit_break_command (*this);
-}
-
-// Continue.
-
-// Nonzero means we're jumping to the end of a loop.
-int tree_continue_command::continuing = 0;
-
-tree_command *
-tree_continue_command::dup (symbol_table::scope_id,
-                            symbol_table::context_id) const
+namespace octave
 {
-  return new tree_continue_command (line (), column ());
-}
+  // Break.
+
+  // Nonzero means we're breaking out of a loop or function body.
+  int tree_break_command::breaking = 0;
 
-void
-tree_continue_command::accept (tree_walker& tw)
-{
-  tw.visit_continue_command (*this);
-}
+  tree_command *
+  tree_break_command::dup (symbol_table::scope_id,
+                           symbol_table::context_id) const
+  {
+    return new tree_break_command (line (), column ());
+  }
 
-// Return.
+  void
+  tree_break_command::accept (tree_walker& tw)
+  {
+    tw.visit_break_command (*this);
+  }
 
-// Nonzero means we're returning from a function.
-int tree_return_command::returning = 0;
+  // Continue.
+
+  // Nonzero means we're jumping to the end of a loop.
+  int tree_continue_command::continuing = 0;
 
-tree_command *
-tree_return_command::dup (symbol_table::scope_id,
-                          symbol_table::context_id) const
-{
-  return new tree_return_command (line (), column ());
-}
+  tree_command *
+  tree_continue_command::dup (symbol_table::scope_id,
+                              symbol_table::context_id) const
+  {
+    return new tree_continue_command (line (), column ());
+  }
+
+  void
+  tree_continue_command::accept (tree_walker& tw)
+  {
+    tw.visit_continue_command (*this);
+  }
+
+  // Return.
 
-void
-tree_return_command::accept (tree_walker& tw)
-{
-  tw.visit_return_command (*this);
+  // Nonzero means we're returning from a function.
+  int tree_return_command::returning = 0;
+
+  tree_command *
+  tree_return_command::dup (symbol_table::scope_id,
+                            symbol_table::context_id) const
+  {
+    return new tree_return_command (line (), column ());
+  }
+
+  void
+  tree_return_command::accept (tree_walker& tw)
+  {
+    tw.visit_return_command (*this);
+  }
 }
-
diff --git a/libinterp/parse-tree/pt-jump.h b/libinterp/parse-tree/pt-jump.h
--- a/libinterp/parse-tree/pt-jump.h
+++ b/libinterp/parse-tree/pt-jump.h
@@ -20,93 +20,105 @@ along with Octave; see the file COPYING.
 
 */
 
 #if ! defined (octave_pt_jump_h)
 #define octave_pt_jump_h 1
 
 #include "octave-config.h"
 
-class tree_walker;
-
 #include "pt-cmd.h"
 #include "symtab.h"
 
-// Break.
+namespace octave
+{
+  class tree_walker;
 
-class
-tree_break_command : public tree_command
-{
-public:
+  // Break.
+
+  class tree_break_command : public tree_command
+  {
+  public:
 
-  tree_break_command (int l = -1, int c = -1)
-    : tree_command (l, c) { }
+    tree_break_command (int l = -1, int c = -1)
+      : tree_command (l, c) { }
 
-  // No copying!
+    // No copying!
 
-  tree_break_command (const tree_break_command&) = delete;
+    tree_break_command (const tree_break_command&) = delete;
 
-  tree_break_command& operator = (const tree_break_command&) = delete;
+    tree_break_command& operator = (const tree_break_command&) = delete;
 
-  ~tree_break_command (void) = default;
+    ~tree_break_command (void) = default;
 
-  tree_command *dup (symbol_table::scope_id scope,
-                     symbol_table::context_id context) const;
+    tree_command *dup (symbol_table::scope_id scope,
+                       symbol_table::context_id context) const;
 
-  void accept (tree_walker& tw);
+    void accept (tree_walker& tw);
 
-  static int breaking;
-};
+    static int breaking;
+  };
 
-// Continue.
+  // Continue.
 
-class
-tree_continue_command : public tree_command
-{
-public:
+  class tree_continue_command : public tree_command
+  {
+  public:
 
-  tree_continue_command (int l = -1, int c = -1)
-    : tree_command (l, c) { }
+    tree_continue_command (int l = -1, int c = -1)
+      : tree_command (l, c) { }
 
-  // No copying!
+    // No copying!
+
+    tree_continue_command (const tree_continue_command&) = delete;
+
+    tree_continue_command& operator = (const tree_continue_command&) = delete;
 
-  tree_continue_command (const tree_continue_command&) = delete;
+    ~tree_continue_command (void) = default;
+
+    tree_command *dup (symbol_table::scope_id scope,
+                       symbol_table::context_id context) const;
 
-  tree_continue_command& operator = (const tree_continue_command&) = delete;
+    void accept (tree_walker& tw);
 
-  ~tree_continue_command (void) = default;
+    static int continuing;
+  };
 
-  tree_command *dup (symbol_table::scope_id scope,
-                     symbol_table::context_id context) const;
+  // Return.
 
-  void accept (tree_walker& tw);
+  class tree_return_command : public tree_command
+  {
+  public:
 
-  static int continuing;
-};
+    tree_return_command (int l = -1, int c = -1)
+      : tree_command (l, c) { }
 
-// Return.
+    // No copying!
+
+    tree_return_command (const tree_return_command&) = delete;
 
-class
-tree_return_command : public tree_command
-{
-public:
+    tree_return_command& operator = (const tree_return_command&) = delete;
+
+    ~tree_return_command (void) = default;
 
-  tree_return_command (int l = -1, int c = -1)
-    : tree_command (l, c) { }
+    tree_command *dup (symbol_table::scope_id scope,
+                       symbol_table::context_id context) const;
 
-  // No copying!
-
-  tree_return_command (const tree_return_command&) = delete;
+    void accept (tree_walker& tw);
 
-  tree_return_command& operator = (const tree_return_command&) = delete;
+    static int returning;
+  };
+}
 
-  ~tree_return_command (void) = default;
+#if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
 
-  tree_command *dup (symbol_table::scope_id scope,
-                     symbol_table::context_id context) const;
+OCTAVE_DEPRECATED ("use 'octave::tree_break_command' instead")
+typedef octave::tree_break_command tree_break_command;
 
-  void accept (tree_walker& tw);
+OCTAVE_DEPRECATED ("use 'octave::tree_continue_command' instead")
+typedef octave::tree_continue_command tree_continue_command;
 
-  static int returning;
-};
+OCTAVE_DEPRECATED ("use 'octave::tree_return_command' instead")
+typedef octave::tree_return_command tree_return_command;
 
 #endif
 
+#endif
diff --git a/libinterp/parse-tree/pt-loop.cc b/libinterp/parse-tree/pt-loop.cc
--- a/libinterp/parse-tree/pt-loop.cc
+++ b/libinterp/parse-tree/pt-loop.cc
@@ -37,118 +37,120 @@ along with Octave; see the file COPYING.
 #include "pt-exp.h"
 #include "pt-jit.h"
 #include "pt-jump.h"
 #include "pt-loop.h"
 #include "pt-stmt.h"
 #include "pt-walk.h"
 #include "unwind-prot.h"
 
-// While.
-
-tree_while_command::~tree_while_command (void)
-{
-  delete expr;
-  delete list;
-  delete lead_comm;
-  delete trail_comm;
-#if defined (HAVE_LLVM)
-  delete compiled;
-#endif
-}
-
-tree_command *
-tree_while_command::dup (symbol_table::scope_id scope,
-                         symbol_table::context_id context) const
-{
-  return new tree_while_command (expr ? expr->dup (scope, context) : 0,
-                                 list ? list->dup (scope, context) : 0,
-                                 lead_comm ? lead_comm->dup () : 0,
-                                 trail_comm ? trail_comm->dup (): 0,
-                                 line (), column ());
-}
-
-void
-tree_while_command::accept (tree_walker& tw)
-{
-  tw.visit_while_command (*this);
-}
-
-// Do-Until
-
-tree_command *
-tree_do_until_command::dup (symbol_table::scope_id scope,
-                            symbol_table::context_id context) const
-{
-  return new tree_do_until_command (expr ? expr->dup (scope, context) : 0,
-                                    list ? list->dup (scope, context) : 0,
-                                    lead_comm ? lead_comm->dup () : 0,
-                                    trail_comm ? trail_comm->dup (): 0,
-                                    line (), column ());
-}
-
-void
-tree_do_until_command::accept (tree_walker& tw)
-{
-  tw.visit_do_until_command (*this);
-}
-
-// For.
-
-tree_simple_for_command::~tree_simple_for_command (void)
+namespace octave
 {
-  delete lhs;
-  delete expr;
-  delete maxproc;
-  delete list;
-  delete lead_comm;
-  delete trail_comm;
+  // While.
+
+  tree_while_command::~tree_while_command (void)
+  {
+    delete expr;
+    delete list;
+    delete lead_comm;
+    delete trail_comm;
 #if defined (HAVE_LLVM)
-  delete compiled;
+    delete compiled;
 #endif
-}
+  }
 
-tree_command *
-tree_simple_for_command::dup (symbol_table::scope_id scope,
+  tree_command *
+  tree_while_command::dup (symbol_table::scope_id scope,
+                           symbol_table::context_id context) const
+  {
+    return new tree_while_command (expr ? expr->dup (scope, context) : 0,
+                                   list ? list->dup (scope, context) : 0,
+                                   lead_comm ? lead_comm->dup () : 0,
+                                   trail_comm ? trail_comm->dup (): 0,
+                                   line (), column ());
+  }
+
+  void
+  tree_while_command::accept (tree_walker& tw)
+  {
+    tw.visit_while_command (*this);
+  }
+
+  // Do-Until
+
+  tree_command *
+  tree_do_until_command::dup (symbol_table::scope_id scope,
                               symbol_table::context_id context) const
-{
-  return new tree_simple_for_command
-    (parallel, lhs ? lhs->dup (scope, context) : 0,
-     expr ? expr->dup (scope, context) : 0,
-     maxproc ? maxproc->dup (scope, context) : 0,
-     list ? list->dup (scope, context) : 0,
-     lead_comm ? lead_comm->dup () : 0,
-     trail_comm ? trail_comm->dup () : 0, line (), column ());
-}
+  {
+    return new tree_do_until_command (expr ? expr->dup (scope, context) : 0,
+                                      list ? list->dup (scope, context) : 0,
+                                      lead_comm ? lead_comm->dup () : 0,
+                                      trail_comm ? trail_comm->dup (): 0,
+                                      line (), column ());
+  }
+
+  void
+  tree_do_until_command::accept (tree_walker& tw)
+  {
+    tw.visit_do_until_command (*this);
+  }
+
+  // For.
+
+  tree_simple_for_command::~tree_simple_for_command (void)
+  {
+    delete lhs;
+    delete expr;
+    delete maxproc;
+    delete list;
+    delete lead_comm;
+    delete trail_comm;
+#if defined (HAVE_LLVM)
+    delete compiled;
+#endif
+  }
 
-void
-tree_simple_for_command::accept (tree_walker& tw)
-{
-  tw.visit_simple_for_command (*this);
+  tree_command *
+  tree_simple_for_command::dup (symbol_table::scope_id scope,
+                                symbol_table::context_id context) const
+  {
+    return new tree_simple_for_command
+      (parallel, lhs ? lhs->dup (scope, context) : 0,
+       expr ? expr->dup (scope, context) : 0,
+       maxproc ? maxproc->dup (scope, context) : 0,
+       list ? list->dup (scope, context) : 0,
+       lead_comm ? lead_comm->dup () : 0,
+       trail_comm ? trail_comm->dup () : 0, line (), column ());
+  }
+
+  void
+  tree_simple_for_command::accept (tree_walker& tw)
+  {
+    tw.visit_simple_for_command (*this);
+  }
+
+  tree_complex_for_command::~tree_complex_for_command (void)
+  {
+    delete lhs;
+    delete expr;
+    delete list;
+    delete lead_comm;
+    delete trail_comm;
+  }
+
+  tree_command *
+  tree_complex_for_command::dup (symbol_table::scope_id scope,
+                                 symbol_table::context_id context) const
+  {
+    return new tree_complex_for_command (lhs ? lhs->dup (scope, context) : 0,
+                                         expr ? expr->dup (scope, context) : 0,
+                                         list ? list->dup (scope, context) : 0,
+                                         lead_comm ? lead_comm->dup () : 0,
+                                         trail_comm ? trail_comm->dup () : 0,
+                                         line (), column ());
+  }
+
+  void
+  tree_complex_for_command::accept (tree_walker& tw)
+  {
+    tw.visit_complex_for_command (*this);
+  }
 }
-
-tree_complex_for_command::~tree_complex_for_command (void)
-{
-  delete lhs;
-  delete expr;
-  delete list;
-  delete lead_comm;
-  delete trail_comm;
-}
-
-tree_command *
-tree_complex_for_command::dup (symbol_table::scope_id scope,
-                               symbol_table::context_id context) const
-{
-  return new tree_complex_for_command (lhs ? lhs->dup (scope, context) : 0,
-                                       expr ? expr->dup (scope, context) : 0,
-                                       list ? list->dup (scope, context) : 0,
-                                       lead_comm ? lead_comm->dup () : 0,
-                                       trail_comm ? trail_comm->dup () : 0,
-                                       line (), column ());
-}
-
-void
-tree_complex_for_command::accept (tree_walker& tw)
-{
-  tw.visit_complex_for_command (*this);
-}
-
diff --git a/libinterp/parse-tree/pt-loop.h b/libinterp/parse-tree/pt-loop.h
--- a/libinterp/parse-tree/pt-loop.h
+++ b/libinterp/parse-tree/pt-loop.h
@@ -23,307 +23,321 @@ along with Octave; see the file COPYING.
 #if ! defined (octave_pt_loop_h)
 #define octave_pt_loop_h 1
 
 #include "octave-config.h"
 
 class octave_value;
 class octave_lvalue;
 
-class tree_argument_list;
-class tree_expression;
-class tree_statement_list;
-
-class tree_walker;
-
 #include "comment-list.h"
 #include "pt-cmd.h"
 #include "symtab.h"
 
 class jit_info;
 
-// While.
-
-class
-tree_while_command : public tree_command
+namespace octave
 {
-public:
+  class tree_argument_list;
+  class tree_expression;
+  class tree_statement_list;
+
+  class tree_walker;
+
+  // While.
 
-  tree_while_command (int l = -1, int c = -1)
-    : tree_command (l, c), expr (0), list (0), lead_comm (0),
-      trail_comm (0)
+  class tree_while_command : public tree_command
+  {
+  public:
+
+    tree_while_command (int l = -1, int c = -1)
+      : tree_command (l, c), expr (0), list (0), lead_comm (0),
+        trail_comm (0)
 #if defined (HAVE_LLVM)
       , compiled (0)
 #endif
-  { }
+    { }
 
-  tree_while_command (tree_expression *e,
-                      octave_comment_list *lc = 0,
-                      octave_comment_list *tc = 0,
-                      int l = -1, int c = -1)
-    : tree_command (l, c), expr (e), list (0), lead_comm (lc),
-      trail_comm (tc)
+    tree_while_command (tree_expression *e,
+                        octave_comment_list *lc = 0,
+                        octave_comment_list *tc = 0,
+                        int l = -1, int c = -1)
+      : tree_command (l, c), expr (e), list (0), lead_comm (lc),
+        trail_comm (tc)
 #if defined (HAVE_LLVM)
       , compiled (0)
 #endif
-  { }
+    { }
 
-  tree_while_command (tree_expression *e, tree_statement_list *lst,
-                      octave_comment_list *lc = 0,
-                      octave_comment_list *tc = 0,
-                      int l = -1, int c = -1)
-    : tree_command (l, c), expr (e), list (lst), lead_comm (lc),
-      trail_comm (tc)
+    tree_while_command (tree_expression *e, tree_statement_list *lst,
+                        octave_comment_list *lc = 0,
+                        octave_comment_list *tc = 0,
+                        int l = -1, int c = -1)
+      : tree_command (l, c), expr (e), list (lst), lead_comm (lc),
+        trail_comm (tc)
 #if defined (HAVE_LLVM)
       , compiled (0)
 #endif
-  { }
+    { }
 
-  // No copying!
+    // No copying!
 
-  tree_while_command (const tree_while_command&) = delete;
+    tree_while_command (const tree_while_command&) = delete;
 
-  tree_while_command& operator = (const tree_while_command&) = delete;
+    tree_while_command& operator = (const tree_while_command&) = delete;
 
-  ~tree_while_command (void);
+    ~tree_while_command (void);
 
-  tree_expression *condition (void) { return expr; }
+    tree_expression *condition (void) { return expr; }
 
-  tree_statement_list *body (void) { return list; }
+    tree_statement_list *body (void) { return list; }
 
-  octave_comment_list *leading_comment (void) { return lead_comm; }
+    octave_comment_list *leading_comment (void) { return lead_comm; }
 
-  octave_comment_list *trailing_comment (void) { return trail_comm; }
+    octave_comment_list *trailing_comment (void) { return trail_comm; }
 
-  tree_command *dup (symbol_table::scope_id scope,
-                     symbol_table::context_id context) const;
+    tree_command *dup (symbol_table::scope_id scope,
+                       symbol_table::context_id context) const;
 
-  void accept (tree_walker& tw);
+    void accept (tree_walker& tw);
 
 #if defined (HAVE_LLVM)
-  // some functions use by tree_jit
-  jit_info *get_info (void) const
-  {
-    return compiled;
-  }
+    // some functions use by tree_jit
+    jit_info *get_info (void) const
+    {
+      return compiled;
+    }
 
-  void stash_info (jit_info *jinfo)
-  {
-    compiled = jinfo;
-  }
+    void stash_info (jit_info *jinfo)
+    {
+      compiled = jinfo;
+    }
 #endif
 
-protected:
+  protected:
 
-  // Expression to test.
-  tree_expression *expr;
+    // Expression to test.
+    tree_expression *expr;
 
-  // List of commands to execute.
-  tree_statement_list *list;
+    // List of commands to execute.
+    tree_statement_list *list;
 
-  // Comment preceding WHILE token.
-  octave_comment_list *lead_comm;
+    // Comment preceding WHILE token.
+    octave_comment_list *lead_comm;
 
-  // Comment preceding ENDWHILE token.
-  octave_comment_list *trail_comm;
+    // Comment preceding ENDWHILE token.
+    octave_comment_list *trail_comm;
 
-private:
+  private:
 
 #if defined (HAVE_LLVM)
-  // compiled version of the loop
-  jit_info *compiled;
+    // compiled version of the loop
+    jit_info *compiled;
 #endif
-};
+  };
 
-// Do-Until.
+  // Do-Until.
 
-class
-tree_do_until_command : public tree_while_command
-{
-public:
+  class tree_do_until_command : public tree_while_command
+  {
+  public:
 
-  tree_do_until_command (int l = -1, int c = -1)
-    : tree_while_command (l, c) { }
+    tree_do_until_command (int l = -1, int c = -1)
+      : tree_while_command (l, c) { }
 
-  tree_do_until_command (tree_expression *e,
-                         octave_comment_list *lc = 0,
-                         octave_comment_list *tc = 0,
-                         int l = -1, int c = -1)
-    : tree_while_command (e, lc, tc, l, c) { }
+    tree_do_until_command (tree_expression *e,
+                           octave_comment_list *lc = 0,
+                           octave_comment_list *tc = 0,
+                           int l = -1, int c = -1)
+      : tree_while_command (e, lc, tc, l, c) { }
 
-  tree_do_until_command (tree_expression *e, tree_statement_list *lst,
-                         octave_comment_list *lc = 0,
-                         octave_comment_list *tc = 0,
-                         int l = -1, int c = -1)
-    : tree_while_command (e, lst, lc, tc, l, c) { }
+    tree_do_until_command (tree_expression *e, tree_statement_list *lst,
+                           octave_comment_list *lc = 0,
+                           octave_comment_list *tc = 0,
+                           int l = -1, int c = -1)
+      : tree_while_command (e, lst, lc, tc, l, c) { }
 
-  // No copying!
+    // No copying!
 
-  tree_do_until_command (const tree_do_until_command&) = delete;
+    tree_do_until_command (const tree_do_until_command&) = delete;
 
-  tree_do_until_command& operator = (const tree_do_until_command&) = delete;
+    tree_do_until_command& operator = (const tree_do_until_command&) = delete;
 
-  ~tree_do_until_command (void) = default;
+    ~tree_do_until_command (void) = default;
 
-  tree_command *dup (symbol_table::scope_id scope,
-                     symbol_table::context_id context) const;
+    tree_command *dup (symbol_table::scope_id scope,
+                       symbol_table::context_id context) const;
 
-  void accept (tree_walker& tw);
-};
+    void accept (tree_walker& tw);
+  };
 
-// For.
+  // For.
 
-class
-tree_simple_for_command : public tree_command
-{
-public:
+  class tree_simple_for_command : public tree_command
+  {
+  public:
 
-  tree_simple_for_command (int l = -1, int c = -1)
-    : tree_command (l, c), parallel (false), lhs (0), expr (0),
-      maxproc (0), list (0), lead_comm (0), trail_comm (0)
+    tree_simple_for_command (int l = -1, int c = -1)
+      : tree_command (l, c), parallel (false), lhs (0), expr (0),
+        maxproc (0), list (0), lead_comm (0), trail_comm (0)
 #if defined (HAVE_LLVM)
       , compiled (0)
 #endif
-  { }
+    { }
 
-  tree_simple_for_command (bool parallel_arg, tree_expression *le,
-                           tree_expression *re,
-                           tree_expression *maxproc_arg,
-                           tree_statement_list *lst,
-                           octave_comment_list *lc = 0,
-                           octave_comment_list *tc = 0,
-                           int l = -1, int c = -1)
-    : tree_command (l, c), parallel (parallel_arg), lhs (le),
-      expr (re), maxproc (maxproc_arg), list (lst),
-      lead_comm (lc), trail_comm (tc)
+    tree_simple_for_command (bool parallel_arg, tree_expression *le,
+                             tree_expression *re,
+                             tree_expression *maxproc_arg,
+                             tree_statement_list *lst,
+                             octave_comment_list *lc = 0,
+                             octave_comment_list *tc = 0,
+                             int l = -1, int c = -1)
+      : tree_command (l, c), parallel (parallel_arg), lhs (le),
+        expr (re), maxproc (maxproc_arg), list (lst),
+        lead_comm (lc), trail_comm (tc)
 #if defined (HAVE_LLVM)
       , compiled (0)
 #endif
-  { }
+    { }
 
-  // No copying!
+    // No copying!
 
-  tree_simple_for_command (const tree_simple_for_command&) = delete;
+    tree_simple_for_command (const tree_simple_for_command&) = delete;
 
-  tree_simple_for_command& operator = (const tree_simple_for_command&) = delete;
+    tree_simple_for_command& operator = (const tree_simple_for_command&) = delete;
 
-  ~tree_simple_for_command (void);
+    ~tree_simple_for_command (void);
 
-  bool in_parallel (void) { return parallel; }
+    bool in_parallel (void) { return parallel; }
 
-  tree_expression *left_hand_side (void) { return lhs; }
+    tree_expression *left_hand_side (void) { return lhs; }
 
-  tree_expression *control_expr (void) { return expr; }
+    tree_expression *control_expr (void) { return expr; }
 
-  tree_expression *maxproc_expr (void) { return maxproc; }
+    tree_expression *maxproc_expr (void) { return maxproc; }
 
-  tree_statement_list *body (void) { return list; }
+    tree_statement_list *body (void) { return list; }
 
-  octave_comment_list *leading_comment (void) { return lead_comm; }
+    octave_comment_list *leading_comment (void) { return lead_comm; }
 
-  octave_comment_list *trailing_comment (void) { return trail_comm; }
+    octave_comment_list *trailing_comment (void) { return trail_comm; }
 
-  tree_command *dup (symbol_table::scope_id scope,
-                     symbol_table::context_id context) const;
+    tree_command *dup (symbol_table::scope_id scope,
+                       symbol_table::context_id context) const;
 
-  void accept (tree_walker& tw);
+    void accept (tree_walker& tw);
 
 #if defined (HAVE_LLVM)
-  // some functions use by tree_jit
-  jit_info *get_info (void) const
-  {
-    return compiled;
-  }
+    // some functions use by tree_jit
+    jit_info *get_info (void) const
+    {
+      return compiled;
+    }
 
-  void stash_info (jit_info *jinfo)
-  {
-    compiled = jinfo;
-  }
+    void stash_info (jit_info *jinfo)
+    {
+      compiled = jinfo;
+    }
 #endif
 
-private:
-  // TRUE means operate in parallel (subject to the value of the
-  // maxproc expression).
-  bool parallel;
+  private:
+    // TRUE means operate in parallel (subject to the value of the
+    // maxproc expression).
+    bool parallel;
 
-  // Expression to modify.
-  tree_expression *lhs;
+    // Expression to modify.
+    tree_expression *lhs;
+
+    // Expression to evaluate.
+    tree_expression *expr;
 
-  // Expression to evaluate.
-  tree_expression *expr;
+    // Expression to tell how many processors should be used (only valid
+    // if parallel is TRUE).
+    tree_expression *maxproc;
 
-  // Expression to tell how many processors should be used (only valid
-  // if parallel is TRUE).
-  tree_expression *maxproc;
+    // List of commands to execute.
+    tree_statement_list *list;
 
-  // List of commands to execute.
-  tree_statement_list *list;
+    // Comment preceding FOR token.
+    octave_comment_list *lead_comm;
+
+    // Comment preceding ENDFOR token.
+    octave_comment_list *trail_comm;
 
-  // Comment preceding FOR token.
-  octave_comment_list *lead_comm;
+    // compiled version of the loop
+    jit_info *compiled;
+  };
 
-  // Comment preceding ENDFOR token.
-  octave_comment_list *trail_comm;
+  class tree_complex_for_command : public tree_command
+  {
+  public:
+
+    tree_complex_for_command (int l = -1, int c = -1)
+      : tree_command (l, c), lhs (0), expr (0), list (0), lead_comm (0),
+        trail_comm (0) { }
 
-  // compiled version of the loop
-  jit_info *compiled;
-};
+    tree_complex_for_command (tree_argument_list *le, tree_expression *re,
+                              tree_statement_list *lst,
+                              octave_comment_list *lc = 0,
+                              octave_comment_list *tc = 0,
+                              int l = -1, int c = -1)
+      : tree_command (l, c), lhs (le), expr (re), list (lst),
+        lead_comm (lc), trail_comm (tc) { }
 
-class
-tree_complex_for_command : public tree_command
-{
-public:
+    // No copying!
 
-  tree_complex_for_command (int l = -1, int c = -1)
-    : tree_command (l, c), lhs (0), expr (0), list (0), lead_comm (0),
-      trail_comm (0) { }
+    tree_complex_for_command (const tree_complex_for_command&) = delete;
+
+    tree_complex_for_command& operator = (const tree_complex_for_command&) = delete;
 
-  tree_complex_for_command (tree_argument_list *le, tree_expression *re,
-                            tree_statement_list *lst,
-                            octave_comment_list *lc = 0,
-                            octave_comment_list *tc = 0,
-                            int l = -1, int c = -1)
-    : tree_command (l, c), lhs (le), expr (re), list (lst),
-      lead_comm (lc), trail_comm (tc) { }
+    ~tree_complex_for_command (void);
+
+    tree_argument_list *left_hand_side (void) { return lhs; }
+
+    tree_expression *control_expr (void) { return expr; }
 
-  // No copying!
+    tree_statement_list *body (void) { return list; }
 
-  tree_complex_for_command (const tree_complex_for_command&) = delete;
+    octave_comment_list *leading_comment (void) { return lead_comm; }
+
+    octave_comment_list *trailing_comment (void) { return trail_comm; }
 
-  tree_complex_for_command& operator = (const tree_complex_for_command&) = delete;
+    tree_command *dup (symbol_table::scope_id scope,
+                       symbol_table::context_id context) const;
 
-  ~tree_complex_for_command (void);
-
-  tree_argument_list *left_hand_side (void) { return lhs; }
+    void accept (tree_walker& tw);
 
-  tree_expression *control_expr (void) { return expr; }
+  private:
 
-  tree_statement_list *body (void) { return list; }
+    // Expression to modify.
+    tree_argument_list *lhs;
 
-  octave_comment_list *leading_comment (void) { return lead_comm; }
+    // Expression to evaluate.
+    tree_expression *expr;
 
-  octave_comment_list *trailing_comment (void) { return trail_comm; }
-
-  tree_command *dup (symbol_table::scope_id scope,
-                     symbol_table::context_id context) const;
+    // List of commands to execute.
+    tree_statement_list *list;
 
-  void accept (tree_walker& tw);
+    // Comment preceding FOR token.
+    octave_comment_list *lead_comm;
 
-private:
-
-  // Expression to modify.
-  tree_argument_list *lhs;
+    // Comment preceding ENDFOR token.
+    octave_comment_list *trail_comm;
+  };
+}
 
-  // Expression to evaluate.
-  tree_expression *expr;
+#if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
 
-  // List of commands to execute.
-  tree_statement_list *list;
+OCTAVE_DEPRECATED ("use 'octave::tree_while_command' instead")
+typedef octave::tree_while_command tree_while_command;
 
-  // Comment preceding FOR token.
-  octave_comment_list *lead_comm;
+OCTAVE_DEPRECATED ("use 'octave::tree_do_until_command' instead")
+typedef octave::tree_do_until_command tree_do_until_command;
 
-  // Comment preceding ENDFOR token.
-  octave_comment_list *trail_comm;
-};
+OCTAVE_DEPRECATED ("use 'octave::tree_simple_for_command' instead")
+typedef octave::tree_simple_for_command tree_simple_for_command;
+
+OCTAVE_DEPRECATED ("use 'octave::tree_complex_for_command' instead")
+typedef octave::tree_complex_for_command tree_complex_for_command;
 
 #endif
 
+#endif
diff --git a/libinterp/parse-tree/pt-mat.cc b/libinterp/parse-tree/pt-mat.cc
--- a/libinterp/parse-tree/pt-mat.cc
+++ b/libinterp/parse-tree/pt-mat.cc
@@ -47,627 +47,632 @@ along with Octave; see the file COPYING.
 #include "ov-cx-mat.h"
 #include "ov-flt-cx-mat.h"
 #include "ov-re-sparse.h"
 #include "ov-cx-sparse.h"
 
 // The character to fill with when creating string arrays.
 char Vstring_fill_char = ' ';
 
-// General matrices.  This list type is much more work to handle than
-// constant matrices, but it allows us to construct matrices from
-// other matrices, variables, and functions.
+namespace octave
+{
+  // General matrices.  This list type is much more work to handle than
+  // constant matrices, but it allows us to construct matrices from
+  // other matrices, variables, and functions.
 
-// But first, some internal classes that make our job much easier.
-
-class
-tm_row_const
-{
-private:
+  // But first, some internal classes that make our job much easier.
 
   class
-  tm_row_const_rep : public octave::base_list<octave_value>
+  tm_row_const
+  {
+  private:
+
+    class
+    tm_row_const_rep : public octave::base_list<octave_value>
+    {
+    public:
+
+      tm_row_const_rep (void)
+        : count (1), dv (0, 0), all_str (false),
+          all_sq_str (false), all_dq_str (false),
+          some_str (false), all_real (false), all_cmplx (false),
+          all_mt (true), any_cell (false), any_sparse (false),
+          any_class (false), all_1x1 (false),
+          first_elem_is_struct (false), class_nm (), ok (false)
+      { }
+
+      tm_row_const_rep (const tree_argument_list& row)
+        : count (1), dv (0, 0), all_str (false), all_sq_str (false),
+          some_str (false), all_real (false), all_cmplx (false),
+          all_mt (true), any_cell (false), any_sparse (false),
+          any_class (false), all_1x1 (! row.empty ()),
+          first_elem_is_struct (false), class_nm (), ok (false)
+      { init (row); }
+
+      ~tm_row_const_rep (void) = default;
+
+      octave::refcount<int> count;
+
+      dim_vector dv;
+
+      bool all_str;
+      bool all_sq_str;
+      bool all_dq_str;
+      bool some_str;
+      bool all_real;
+      bool all_cmplx;
+      bool all_mt;
+      bool any_cell;
+      bool any_sparse;
+      bool any_class;
+      bool all_1x1;
+      bool first_elem_is_struct;
+
+      std::string class_nm;
+
+      bool ok;
+
+      void do_init_element (const octave_value&, bool&);
+
+      void init (const tree_argument_list&);
+
+      void cellify (void);
+
+    private:
+
+      tm_row_const_rep (const tm_row_const_rep&);
+
+      tm_row_const_rep& operator = (const tm_row_const_rep&);
+
+    };
+
+  public:
+
+    typedef tm_row_const_rep::iterator iterator;
+    typedef tm_row_const_rep::const_iterator const_iterator;
+
+    tm_row_const (void)
+      : rep (0) { }
+
+    tm_row_const (const tree_argument_list& row)
+      : rep (new tm_row_const_rep (row)) { }
+
+    tm_row_const (const tm_row_const& x)
+      : rep (x.rep)
+    {
+      if (rep)
+        rep->count++;
+    }
+
+    tm_row_const& operator = (const tm_row_const& x)
+    {
+      if (this != &x && rep != x.rep)
+        {
+          if (rep && --rep->count == 0)
+            delete rep;
+
+          rep = x.rep;
+
+          if (rep)
+            rep->count++;
+        }
+
+      return *this;
+    }
+
+    ~tm_row_const (void)
+    {
+      if (rep && --rep->count == 0)
+        delete rep;
+    }
+
+    octave_idx_type rows (void) { return rep->dv(0); }
+    octave_idx_type cols (void) { return rep->dv(1); }
+
+    bool empty (void) const { return rep->empty (); }
+
+    size_t length (void) const { return rep->length (); }
+
+    dim_vector dims (void) { return rep->dv; }
+
+    bool all_strings_p (void) const { return rep->all_str; }
+    bool all_sq_strings_p (void) const { return rep->all_sq_str; }
+    bool all_dq_strings_p (void) const { return rep->all_dq_str; }
+    bool some_strings_p (void) const { return rep->some_str; }
+    bool all_real_p (void) const { return rep->all_real; }
+    bool all_complex_p (void) const { return rep->all_cmplx; }
+    bool all_empty_p (void) const { return rep->all_mt; }
+    bool any_cell_p (void) const { return rep->any_cell; }
+    bool any_sparse_p (void) const { return rep->any_sparse; }
+    bool any_class_p (void) const { return rep->any_class; }
+    bool all_1x1_p (void) const { return rep->all_1x1; }
+    bool first_elem_struct_p (void) const { return rep->first_elem_is_struct; }
+
+    std::string class_name (void) const { return rep->class_nm; }
+
+    void cellify (void) { rep->cellify (); }
+
+    operator bool () const { return (rep && rep->ok); }
+
+    iterator begin (void) { return rep->begin (); }
+    const_iterator begin (void) const { return rep->begin (); }
+
+    iterator end (void) { return rep->end (); }
+    const_iterator end (void) const { return rep->end (); }
+
+  private:
+
+    tm_row_const_rep *rep;
+  };
+
+  std::string
+  get_concat_class (const std::string& c1, const std::string& c2)
+  {
+    std::string retval = octave_base_value::static_class_name ();
+
+    if (c1 == c2)
+      retval = c1;
+    else if (c1.empty ())
+      retval = c2;
+    else if (c2.empty ())
+      retval = c1;
+    else if (c1 == "class" || c2 == "class")
+      retval = "class";
+    else
+      {
+        bool c1_is_int = (c1 == "int8" || c1 == "uint8"
+                          || c1 == "int16" || c1 == "uint16"
+                          || c1 == "int32" || c1 == "uint32"
+                          || c1 == "int64" || c1 == "uint64");
+        bool c2_is_int = (c2 == "int8" || c2 == "uint8"
+                          || c2 == "int16" || c2 == "uint16"
+                          || c2 == "int32" || c2 == "uint32"
+                          || c2 == "int64" || c2 == "uint64");
+
+        bool c1_is_char = (c1 == "char");
+        bool c2_is_char = (c2 == "char");
+
+        bool c1_is_double = (c1 == "double");
+        bool c2_is_double = (c2 == "double");
+
+        bool c1_is_single = (c1 == "single");
+        bool c2_is_single = (c2 == "single");
+
+        bool c1_is_logical = (c1 == "logical");
+        bool c2_is_logical = (c2 == "logical");
+
+        bool c1_is_built_in_type
+          = (c1_is_int || c1_is_char || c1_is_double || c1_is_single
+             || c1_is_logical);
+
+        bool c2_is_built_in_type
+          = (c2_is_int || c2_is_char ||  c2_is_double || c2_is_single
+             || c2_is_logical);
+
+        // Order is important here...
+
+        if (c1 == "struct" && c2 == c1)
+          retval = c1;
+        else if (c1 == "cell" || c2 == "cell")
+          retval = "cell";
+        else if (c1_is_char && c2_is_built_in_type)
+          retval = c1;
+        else if (c2_is_char && c1_is_built_in_type)
+          retval = c2;
+        else if (c1_is_int && c2_is_built_in_type)
+          retval = c1;
+        else if (c2_is_int && c1_is_built_in_type)
+          retval = c2;
+        else if (c1_is_single && c2_is_built_in_type)
+          retval = c1;
+        else if (c2_is_single && c1_is_built_in_type)
+          retval = c2;
+        else if (c1_is_double && c2_is_built_in_type)
+          retval = c1;
+        else if (c2_is_double && c1_is_built_in_type)
+          retval = c2;
+        else if (c1_is_logical && c2_is_logical)
+          retval = c1;
+      }
+
+    return retval;
+  }
+}
+
+OCTAVE_NORETURN static
+void
+eval_error (const char *msg, const dim_vector& x, const dim_vector& y)
+{
+  error ("%s (%s vs %s)", msg, x.str ().c_str (), y.str ().c_str ());
+}
+
+namespace octave
+{
+  void
+  tm_row_const::tm_row_const_rep::do_init_element (const octave_value& val,
+                                                   bool& first_elem)
+  {
+    std::string this_elt_class_nm
+      = val.is_object () ? std::string ("class") : val.class_name ();
+
+    class_nm = get_concat_class (class_nm, this_elt_class_nm);
+
+    dim_vector this_elt_dv = val.dims ();
+
+    if (! this_elt_dv.zero_by_zero ())
+      {
+        all_mt = false;
+
+        if (first_elem)
+          {
+            if (val.is_map ())
+              first_elem_is_struct = true;
+
+            first_elem = false;
+          }
+      }
+
+    append (val);
+
+    if (all_str && ! val.is_string ())
+      all_str = false;
+
+    if (all_sq_str && ! val.is_sq_string ())
+      all_sq_str = false;
+
+    if (all_dq_str && ! val.is_dq_string ())
+      all_dq_str = false;
+
+    if (! some_str && val.is_string ())
+      some_str = true;
+
+    if (all_real && ! val.is_real_type ())
+      all_real = false;
+
+    if (all_cmplx && ! (val.is_complex_type () || val.is_real_type ()))
+      all_cmplx = false;
+
+    if (! any_cell && val.is_cell ())
+      any_cell = true;
+
+    if (! any_sparse && val.is_sparse_type ())
+      any_sparse = true;
+
+    if (! any_class && val.is_object ())
+      any_class = true;
+
+    // Special treatment of sparse matrices to avoid out-of-memory error
+    all_1x1 = all_1x1 && ! val.is_sparse_type () && val.numel () == 1;
+  }
+
+  void
+  tm_row_const::tm_row_const_rep::init (const tree_argument_list& row)
+  {
+    all_str = true;
+    all_sq_str = true;
+    all_dq_str = true;
+    all_real = true;
+    all_cmplx = true;
+    any_cell = false;
+    any_sparse = false;
+    any_class = false;
+
+    bool first_elem = true;
+
+    for (tree_expression* elt : row)
+      {
+        octave_quit ();
+
+        octave_value tmp = elt->rvalue1 ();
+
+        if (tmp.is_undefined ())
+          {
+            ok = true;
+            return;
+          }
+        else
+          {
+            if (tmp.is_cs_list ())
+              {
+                octave_value_list tlst = tmp.list_value ();
+
+                for (octave_idx_type i = 0; i < tlst.length (); i++)
+                  {
+                    octave_quit ();
+
+                    do_init_element (tlst(i), first_elem);
+                  }
+              }
+            else
+              do_init_element (tmp, first_elem);
+          }
+      }
+
+    if (any_cell && ! any_class && ! first_elem_is_struct)
+      cellify ();
+
+    first_elem = true;
+
+    for (const octave_value& val : *this)
+      {
+        octave_quit ();
+
+        dim_vector this_elt_dv = val.dims ();
+
+        if (! this_elt_dv.zero_by_zero ())
+          {
+            all_mt = false;
+
+            if (first_elem)
+              {
+                first_elem = false;
+                dv = this_elt_dv;
+              }
+            else if ((! any_class) && (! dv.hvcat (this_elt_dv, 1)))
+              eval_error ("horizontal dimensions mismatch", dv, this_elt_dv);
+          }
+      }
+
+    ok = true;
+  }
+
+  void
+  tm_row_const::tm_row_const_rep::cellify (void)
+  {
+    bool elt_changed = false;
+
+    for (auto& elt : *this)
+      {
+        octave_quit ();
+
+        if (! elt.is_cell ())
+          {
+            elt_changed = true;
+
+            if (elt.is_empty ())
+              elt = Cell ();
+            else
+              elt = Cell (elt);
+          }
+      }
+
+    if (elt_changed)
+      {
+        bool first_elem = true;
+
+        for (const octave_value& val : *this)
+          {
+            octave_quit ();
+
+            dim_vector this_elt_dv = val.dims ();
+
+            if (! this_elt_dv.zero_by_zero ())
+              {
+                if (first_elem)
+                  {
+                    first_elem = false;
+                    dv = this_elt_dv;
+                  }
+                else if (! dv.hvcat (this_elt_dv, 1))
+                  eval_error ("horizontal dimensions mismatch", dv, this_elt_dv);
+              }
+          }
+      }
+  }
+
+  class
+  tm_const : public octave::base_list<tm_row_const>
   {
   public:
 
-    tm_row_const_rep (void)
-      : count (1), dv (0, 0), all_str (false),
-        all_sq_str (false), all_dq_str (false),
+    tm_const (const tree_matrix& tm)
+      : dv (0, 0), all_str (false), all_sq_str (false), all_dq_str (false),
         some_str (false), all_real (false), all_cmplx (false),
         all_mt (true), any_cell (false), any_sparse (false),
-        any_class (false), all_1x1 (false),
-        first_elem_is_struct (false), class_nm (), ok (false)
-    { }
+        any_class (false), class_nm (), ok (false)
+    { init (tm); }
+
+    ~tm_const (void) = default;
+
+    octave_idx_type rows (void) const { return dv.elem (0); }
+    octave_idx_type cols (void) const { return dv.elem (1); }
+
+    dim_vector dims (void) const { return dv; }
 
-    tm_row_const_rep (const tree_argument_list& row)
-      : count (1), dv (0, 0), all_str (false), all_sq_str (false),
-        some_str (false), all_real (false), all_cmplx (false),
-        all_mt (true), any_cell (false), any_sparse (false),
-        any_class (false), all_1x1 (! row.empty ()),
-        first_elem_is_struct (false), class_nm (), ok (false)
-    { init (row); }
+    bool all_strings_p (void) const { return all_str; }
+    bool all_sq_strings_p (void) const { return all_sq_str; }
+    bool all_dq_strings_p (void) const { return all_dq_str; }
+    bool some_strings_p (void) const { return some_str; }
+    bool all_real_p (void) const { return all_real; }
+    bool all_complex_p (void) const { return all_cmplx; }
+    bool all_empty_p (void) const { return all_mt; }
+    bool any_cell_p (void) const { return any_cell; }
+    bool any_sparse_p (void) const { return any_sparse; }
+    bool any_class_p (void) const { return any_class; }
+    bool all_1x1_p (void) const { return all_1x1; }
 
-    ~tm_row_const_rep (void) = default;
+    std::string class_name (void) const { return class_nm; }
 
-    octave::refcount<int> count;
+    operator bool () const { return ok; }
+
+  private:
 
     dim_vector dv;
 
     bool all_str;
     bool all_sq_str;
     bool all_dq_str;
     bool some_str;
     bool all_real;
     bool all_cmplx;
     bool all_mt;
     bool any_cell;
     bool any_sparse;
     bool any_class;
     bool all_1x1;
-    bool first_elem_is_struct;
 
     std::string class_nm;
 
     bool ok;
 
-    void do_init_element (const octave_value&, bool&);
+    tm_const (void);
 
-    void init (const tree_argument_list&);
-
-    void cellify (void);
+    tm_const (const tm_const&);
 
-  private:
+    tm_const& operator = (const tm_const&);
 
-    tm_row_const_rep (const tm_row_const_rep&);
-
-    tm_row_const_rep& operator = (const tm_row_const_rep&);
-
+    void init (const tree_matrix& tm);
   };
 
-public:
-
-  typedef tm_row_const_rep::iterator iterator;
-  typedef tm_row_const_rep::const_iterator const_iterator;
-
-  tm_row_const (void)
-    : rep (0) { }
-
-  tm_row_const (const tree_argument_list& row)
-    : rep (new tm_row_const_rep (row)) { }
-
-  tm_row_const (const tm_row_const& x)
-    : rep (x.rep)
+  void
+  tm_const::init (const tree_matrix& tm)
   {
-    if (rep)
-      rep->count++;
-  }
+    all_str = true;
+    all_sq_str = true;
+    all_dq_str = true;
+    all_real = true;
+    all_cmplx = true;
+    any_cell = false;
+    any_sparse = false;
+    any_class = false;
+    all_1x1 = ! tm.empty ();
 
-  tm_row_const& operator = (const tm_row_const& x)
-  {
-    if (this != &x && rep != x.rep)
+    bool first_elem = true;
+    bool first_elem_is_struct = false;
+
+    // Just eval and figure out if what we have is complex or all strings.
+    // We can't check columns until we know that this is a numeric matrix --
+    // collections of strings can have elements of different lengths.
+    for (const tree_argument_list* elt : tm)
       {
-        if (rep && --rep->count == 0)
-          delete rep;
+        octave_quit ();
+
+        tm_row_const tmp (*elt);
+
+        if (first_elem)
+          {
+            first_elem_is_struct = tmp.first_elem_struct_p ();
+
+            first_elem = false;
+          }
+
+        if (tmp && ! tmp.empty ())
+          {
+            if (all_str && ! tmp.all_strings_p ())
+              all_str = false;
+
+            if (all_sq_str && ! tmp.all_sq_strings_p ())
+              all_sq_str = false;
+
+            if (all_dq_str && ! tmp.all_dq_strings_p ())
+              all_dq_str = false;
+
+            if (! some_str && tmp.some_strings_p ())
+              some_str = true;
 
-        rep = x.rep;
+            if (all_real && ! tmp.all_real_p ())
+              all_real = false;
+
+            if (all_cmplx && ! tmp.all_complex_p ())
+              all_cmplx = false;
+
+            if (all_mt && ! tmp.all_empty_p ())
+              all_mt = false;
+
+            if (! any_cell && tmp.any_cell_p ())
+              any_cell = true;
 
-        if (rep)
-          rep->count++;
+            if (! any_sparse && tmp.any_sparse_p ())
+              any_sparse = true;
+
+            if (! any_class && tmp.any_class_p ())
+              any_class = true;
+
+            all_1x1 = all_1x1 && tmp.all_1x1_p ();
+
+            append (tmp);
+          }
+        else
+          break;
       }
 
-    return *this;
-  }
+    if (any_cell && ! any_class && ! first_elem_is_struct)
+      {
+        for (auto& elt : *this)
+          {
+            octave_quit ();
+
+            elt.cellify ();
+          }
+      }
+
+    first_elem = true;
+
+    for (tm_row_const& elt : *this)
+      {
+        octave_quit ();
+
+        octave_idx_type this_elt_nr = elt.rows ();
+        octave_idx_type this_elt_nc = elt.cols ();
+
+        std::string this_elt_class_nm = elt.class_name ();
+        class_nm = get_concat_class (class_nm, this_elt_class_nm);
 
-  ~tm_row_const (void)
-  {
-    if (rep && --rep->count == 0)
-      delete rep;
+        dim_vector this_elt_dv = elt.dims ();
+
+        all_mt = false;
+
+        if (first_elem)
+          {
+            first_elem = false;
+
+            dv = this_elt_dv;
+          }
+        else if (all_str && dv.ndims () == 2
+                 && this_elt_dv.ndims () == 2)
+          {
+            // FIXME: this is Octave's specialty.
+            // Character matrices allow rows of unequal length.
+            if (this_elt_nc > cols ())
+              dv(1) = this_elt_nc;
+            dv(0) += this_elt_nr;
+          }
+        else if ((! any_class) && (! dv.hvcat (this_elt_dv, 0)))
+          eval_error ("vertical dimensions mismatch", dv, this_elt_dv);
+      }
+
+    ok = true;
   }
 
-  octave_idx_type rows (void) { return rep->dv(0); }
-  octave_idx_type cols (void) { return rep->dv(1); }
-
-  bool empty (void) const { return rep->empty (); }
-
-  size_t length (void) const { return rep->length (); }
-
-  dim_vector dims (void) { return rep->dv; }
-
-  bool all_strings_p (void) const { return rep->all_str; }
-  bool all_sq_strings_p (void) const { return rep->all_sq_str; }
-  bool all_dq_strings_p (void) const { return rep->all_dq_str; }
-  bool some_strings_p (void) const { return rep->some_str; }
-  bool all_real_p (void) const { return rep->all_real; }
-  bool all_complex_p (void) const { return rep->all_cmplx; }
-  bool all_empty_p (void) const { return rep->all_mt; }
-  bool any_cell_p (void) const { return rep->any_cell; }
-  bool any_sparse_p (void) const { return rep->any_sparse; }
-  bool any_class_p (void) const { return rep->any_class; }
-  bool all_1x1_p (void) const { return rep->all_1x1; }
-  bool first_elem_struct_p (void) const { return rep->first_elem_is_struct; }
-
-  std::string class_name (void) const { return rep->class_nm; }
-
-  void cellify (void) { rep->cellify (); }
-
-  operator bool () const { return (rep && rep->ok); }
-
-  iterator begin (void) { return rep->begin (); }
-  const_iterator begin (void) const { return rep->begin (); }
-
-  iterator end (void) { return rep->end (); }
-  const_iterator end (void) const { return rep->end (); }
-
-private:
-
-  tm_row_const_rep *rep;
-};
-
-std::string
-get_concat_class (const std::string& c1, const std::string& c2)
-{
-  std::string retval = octave_base_value::static_class_name ();
-
-  if (c1 == c2)
-    retval = c1;
-  else if (c1.empty ())
-    retval = c2;
-  else if (c2.empty ())
-    retval = c1;
-  else if (c1 == "class" || c2 == "class")
-    retval = "class";
-  else
-    {
-      bool c1_is_int = (c1 == "int8" || c1 == "uint8"
-                        || c1 == "int16" || c1 == "uint16"
-                        || c1 == "int32" || c1 == "uint32"
-                        || c1 == "int64" || c1 == "uint64");
-      bool c2_is_int = (c2 == "int8" || c2 == "uint8"
-                        || c2 == "int16" || c2 == "uint16"
-                        || c2 == "int32" || c2 == "uint32"
-                        || c2 == "int64" || c2 == "uint64");
-
-      bool c1_is_char = (c1 == "char");
-      bool c2_is_char = (c2 == "char");
-
-      bool c1_is_double = (c1 == "double");
-      bool c2_is_double = (c2 == "double");
-
-      bool c1_is_single = (c1 == "single");
-      bool c2_is_single = (c2 == "single");
-
-      bool c1_is_logical = (c1 == "logical");
-      bool c2_is_logical = (c2 == "logical");
-
-      bool c1_is_built_in_type
-        = (c1_is_int || c1_is_char || c1_is_double || c1_is_single
-           || c1_is_logical);
-
-      bool c2_is_built_in_type
-        = (c2_is_int || c2_is_char ||  c2_is_double || c2_is_single
-           || c2_is_logical);
-
-      // Order is important here...
-
-      if (c1 == "struct" && c2 == c1)
-        retval = c1;
-      else if (c1 == "cell" || c2 == "cell")
-        retval = "cell";
-      else if (c1_is_char && c2_is_built_in_type)
-        retval = c1;
-      else if (c2_is_char && c1_is_built_in_type)
-        retval = c2;
-      else if (c1_is_int && c2_is_built_in_type)
-        retval = c1;
-      else if (c2_is_int && c1_is_built_in_type)
-        retval = c2;
-      else if (c1_is_single && c2_is_built_in_type)
-        retval = c1;
-      else if (c2_is_single && c1_is_built_in_type)
-        retval = c2;
-      else if (c1_is_double && c2_is_built_in_type)
-        retval = c1;
-      else if (c2_is_double && c1_is_built_in_type)
-        retval = c2;
-      else if (c1_is_logical && c2_is_logical)
-        retval = c1;
-    }
-
-  return retval;
-}
-
-OCTAVE_NORETURN static
-void
-eval_error (const char *msg, const dim_vector& x, const dim_vector& y)
-{
-  error ("%s (%s vs %s)", msg, x.str ().c_str (), y.str ().c_str ());
-}
-
-void
-tm_row_const::tm_row_const_rep::do_init_element (const octave_value& val,
-                                                 bool& first_elem)
-{
-  std::string this_elt_class_nm
-    = val.is_object () ? std::string ("class") : val.class_name ();
-
-  class_nm = get_concat_class (class_nm, this_elt_class_nm);
-
-  dim_vector this_elt_dv = val.dims ();
-
-  if (! this_elt_dv.zero_by_zero ())
-    {
-      all_mt = false;
-
-      if (first_elem)
-        {
-          if (val.is_map ())
-            first_elem_is_struct = true;
-
-          first_elem = false;
-        }
-    }
-
-  append (val);
-
-  if (all_str && ! val.is_string ())
-    all_str = false;
-
-  if (all_sq_str && ! val.is_sq_string ())
-    all_sq_str = false;
-
-  if (all_dq_str && ! val.is_dq_string ())
-    all_dq_str = false;
-
-  if (! some_str && val.is_string ())
-    some_str = true;
-
-  if (all_real && ! val.is_real_type ())
-    all_real = false;
-
-  if (all_cmplx && ! (val.is_complex_type () || val.is_real_type ()))
-    all_cmplx = false;
-
-  if (! any_cell && val.is_cell ())
-    any_cell = true;
-
-  if (! any_sparse && val.is_sparse_type ())
-    any_sparse = true;
-
-  if (! any_class && val.is_object ())
-    any_class = true;
-
-  // Special treatment of sparse matrices to avoid out-of-memory error
-  all_1x1 = all_1x1 && ! val.is_sparse_type () && val.numel () == 1;
-}
-
-void
-tm_row_const::tm_row_const_rep::init (const tree_argument_list& row)
-{
-  all_str = true;
-  all_sq_str = true;
-  all_dq_str = true;
-  all_real = true;
-  all_cmplx = true;
-  any_cell = false;
-  any_sparse = false;
-  any_class = false;
-
-  bool first_elem = true;
-
-  for (tree_expression* elt : row)
-    {
-      octave_quit ();
-
-      octave_value tmp = elt->rvalue1 ();
-
-      if (tmp.is_undefined ())
-        {
-          ok = true;
-          return;
-        }
-      else
-        {
-          if (tmp.is_cs_list ())
-            {
-              octave_value_list tlst = tmp.list_value ();
-
-              for (octave_idx_type i = 0; i < tlst.length (); i++)
-                {
-                  octave_quit ();
-
-                  do_init_element (tlst(i), first_elem);
-                }
-            }
-          else
-            do_init_element (tmp, first_elem);
-        }
-    }
-
-  if (any_cell && ! any_class && ! first_elem_is_struct)
-    cellify ();
-
-  first_elem = true;
-
-  for (const octave_value& val : *this)
-    {
-      octave_quit ();
-
-      dim_vector this_elt_dv = val.dims ();
-
-      if (! this_elt_dv.zero_by_zero ())
-        {
-          all_mt = false;
-
-          if (first_elem)
-            {
-              first_elem = false;
-              dv = this_elt_dv;
-            }
-          else if ((! any_class) && (! dv.hvcat (this_elt_dv, 1)))
-            eval_error ("horizontal dimensions mismatch", dv, this_elt_dv);
-        }
-    }
+  octave_value_list
+  tree_matrix::rvalue (int nargout)
+  {
+    if (nargout > 1)
+      error ("invalid number of output arguments for matrix list");
 
-  ok = true;
-}
-
-void
-tm_row_const::tm_row_const_rep::cellify (void)
-{
-  bool elt_changed = false;
-
-  for (auto& elt : *this)
-    {
-      octave_quit ();
-
-      if (! elt.is_cell ())
-        {
-          elt_changed = true;
-
-          if (elt.is_empty ())
-            elt = Cell ();
-          else
-            elt = Cell (elt);
-        }
-    }
-
-  if (elt_changed)
-    {
-      bool first_elem = true;
-
-      for (const octave_value& val : *this)
-        {
-          octave_quit ();
-
-          dim_vector this_elt_dv = val.dims ();
-
-          if (! this_elt_dv.zero_by_zero ())
-            {
-              if (first_elem)
-                {
-                  first_elem = false;
-                  dv = this_elt_dv;
-                }
-              else if (! dv.hvcat (this_elt_dv, 1))
-                eval_error ("horizontal dimensions mismatch", dv, this_elt_dv);
-            }
-        }
-    }
-}
-
-class
-tm_const : public octave::base_list<tm_row_const>
-{
-public:
-
-  tm_const (const tree_matrix& tm)
-    : dv (0, 0), all_str (false), all_sq_str (false), all_dq_str (false),
-      some_str (false), all_real (false), all_cmplx (false),
-      all_mt (true), any_cell (false), any_sparse (false),
-      any_class (false), class_nm (), ok (false)
-  { init (tm); }
-
-  ~tm_const (void) = default;
-
-  octave_idx_type rows (void) const { return dv.elem (0); }
-  octave_idx_type cols (void) const { return dv.elem (1); }
-
-  dim_vector dims (void) const { return dv; }
-
-  bool all_strings_p (void) const { return all_str; }
-  bool all_sq_strings_p (void) const { return all_sq_str; }
-  bool all_dq_strings_p (void) const { return all_dq_str; }
-  bool some_strings_p (void) const { return some_str; }
-  bool all_real_p (void) const { return all_real; }
-  bool all_complex_p (void) const { return all_cmplx; }
-  bool all_empty_p (void) const { return all_mt; }
-  bool any_cell_p (void) const { return any_cell; }
-  bool any_sparse_p (void) const { return any_sparse; }
-  bool any_class_p (void) const { return any_class; }
-  bool all_1x1_p (void) const { return all_1x1; }
-
-  std::string class_name (void) const { return class_nm; }
-
-  operator bool () const { return ok; }
-
-private:
-
-  dim_vector dv;
-
-  bool all_str;
-  bool all_sq_str;
-  bool all_dq_str;
-  bool some_str;
-  bool all_real;
-  bool all_cmplx;
-  bool all_mt;
-  bool any_cell;
-  bool any_sparse;
-  bool any_class;
-  bool all_1x1;
-
-  std::string class_nm;
-
-  bool ok;
-
-  tm_const (void);
-
-  tm_const (const tm_const&);
-
-  tm_const& operator = (const tm_const&);
-
-  void init (const tree_matrix& tm);
-};
+    return rvalue1 (nargout);
+  }
 
-void
-tm_const::init (const tree_matrix& tm)
-{
-  all_str = true;
-  all_sq_str = true;
-  all_dq_str = true;
-  all_real = true;
-  all_cmplx = true;
-  any_cell = false;
-  any_sparse = false;
-  any_class = false;
-  all_1x1 = ! tm.empty ();
-
-  bool first_elem = true;
-  bool first_elem_is_struct = false;
-
-  // Just eval and figure out if what we have is complex or all strings.
-  // We can't check columns until we know that this is a numeric matrix --
-  // collections of strings can have elements of different lengths.
-  for (const tree_argument_list* elt : tm)
-    {
-      octave_quit ();
-
-      tm_row_const tmp (*elt);
-
-      if (first_elem)
-        {
-          first_elem_is_struct = tmp.first_elem_struct_p ();
-
-          first_elem = false;
-        }
-
-      if (tmp && ! tmp.empty ())
-        {
-          if (all_str && ! tmp.all_strings_p ())
-            all_str = false;
-
-          if (all_sq_str && ! tmp.all_sq_strings_p ())
-            all_sq_str = false;
-
-          if (all_dq_str && ! tmp.all_dq_strings_p ())
-            all_dq_str = false;
-
-          if (! some_str && tmp.some_strings_p ())
-            some_str = true;
-
-          if (all_real && ! tmp.all_real_p ())
-            all_real = false;
-
-          if (all_cmplx && ! tmp.all_complex_p ())
-            all_cmplx = false;
-
-          if (all_mt && ! tmp.all_empty_p ())
-            all_mt = false;
-
-          if (! any_cell && tmp.any_cell_p ())
-            any_cell = true;
-
-          if (! any_sparse && tmp.any_sparse_p ())
-            any_sparse = true;
-
-          if (! any_class && tmp.any_class_p ())
-            any_class = true;
-
-          all_1x1 = all_1x1 && tmp.all_1x1_p ();
-
-          append (tmp);
-        }
-      else
-        break;
-    }
-
-  if (any_cell && ! any_class && ! first_elem_is_struct)
-    {
-      for (auto& elt : *this)
-        {
-          octave_quit ();
-
-          elt.cellify ();
-        }
-    }
-
-  first_elem = true;
-
-  for (tm_row_const& elt : *this)
-    {
-      octave_quit ();
-
-      octave_idx_type this_elt_nr = elt.rows ();
-      octave_idx_type this_elt_nc = elt.cols ();
-
-      std::string this_elt_class_nm = elt.class_name ();
-      class_nm = get_concat_class (class_nm, this_elt_class_nm);
-
-      dim_vector this_elt_dv = elt.dims ();
-
-      all_mt = false;
-
-      if (first_elem)
-        {
-          first_elem = false;
-
-          dv = this_elt_dv;
-        }
-      else if (all_str && dv.ndims () == 2
-               && this_elt_dv.ndims () == 2)
-        {
-          // FIXME: this is Octave's specialty.
-          // Character matrices allow rows of unequal length.
-          if (this_elt_nc > cols ())
-            dv(1) = this_elt_nc;
-          dv(0) += this_elt_nr;
-        }
-      else if ((! any_class) && (! dv.hvcat (this_elt_dv, 0)))
-        eval_error ("vertical dimensions mismatch", dv, this_elt_dv);
-    }
-
-  ok = true;
-}
-
-octave_value_list
-tree_matrix::rvalue (int nargout)
-{
-  if (nargout > 1)
-    error ("invalid number of output arguments for matrix list");
-
-  return rvalue1 (nargout);
-}
-
-void
-maybe_warn_string_concat (bool all_dq_strings_p, bool all_sq_strings_p)
-{
-  if (! (all_dq_strings_p || all_sq_strings_p))
-    warning_with_id ("Octave:mixed-string-concat",
-                     "concatenation of different character string types may have unintended consequences");
+  void
+  maybe_warn_string_concat (bool all_dq_strings_p, bool all_sq_strings_p)
+  {
+    if (! (all_dq_strings_p || all_sq_strings_p))
+      warning_with_id ("Octave:mixed-string-concat",
+                       "concatenation of different character string types may have unintended consequences");
+  }
 }
 
 template <typename TYPE, typename T>
 static void
-single_type_concat (Array<T>& result,
-                    tm_const& tmp)
+single_type_concat (Array<T>& result, octave::tm_const& tmp)
 {
   octave_idx_type r = 0;
   octave_idx_type c = 0;
 
-  for (tm_row_const& row : tmp)
+  for (octave::tm_row_const& row : tmp)
     {
       // Skip empty arrays to allow looser rules.
       if (row.dims ().any_zero ())
         continue;
 
       for (auto& elt : row)
         {
           octave_quit ();
@@ -686,31 +691,30 @@ single_type_concat (Array<T>& result,
 
       r += row.rows ();
       c = 0;
     }
 }
 
 template <typename TYPE, typename T>
 static void
-single_type_concat (Array<T>& result,
-                    const dim_vector& dv,
-                    tm_const& tmp)
+single_type_concat (Array<T>& result, const dim_vector& dv,
+                    octave::tm_const& tmp)
 {
   if (dv.any_zero ())
     {
       result = Array<T> (dv);
       return;
     }
 
   if (tmp.length () == 1)
     {
       // If possible, forward the operation to liboctave.
       // Single row.
-      tm_row_const& row = tmp.front ();
+      octave::tm_row_const& row = tmp.front ();
       if (! (equal_types<T, char>::value || equal_types<T, octave_value>::value)
           && row.all_1x1_p ())
         {
           // Optimize all scalars case.
           result.clear (dv);
           assert (static_cast<size_t> (result.numel ()) == row.length ());
           octave_idx_type i = 0;
           for (const auto& elt : row)
@@ -736,33 +740,32 @@ single_type_concat (Array<T>& result,
     {
       result = Array<T> (dv);
       single_type_concat<TYPE> (result, tmp);
     }
 }
 
 template <typename TYPE, typename T>
 static void
-single_type_concat (Sparse<T>& result,
-                    const dim_vector& dv,
-                    tm_const& tmp)
+single_type_concat (Sparse<T>& result, const dim_vector& dv,
+                    octave::tm_const& tmp)
 {
   if (dv.any_zero ())
     {
       result = Sparse<T> (dv);
       return;
     }
 
   // Sparse matrices require preallocation for efficient indexing; besides,
   // only horizontal concatenation can be efficiently handled by indexing.
   // So we just cat all rows through liboctave, then cat the final column.
   octave_idx_type nrows = tmp.length ();
   octave_idx_type j = 0;
   OCTAVE_LOCAL_BUFFER (Sparse<T>, sparse_row_list, nrows);
-  for (tm_row_const& row : tmp)
+  for (octave::tm_row_const& row : tmp)
     {
       octave_idx_type ncols = row.length ();
       octave_idx_type i = 0;
       OCTAVE_LOCAL_BUFFER (Sparse<T>, sparse_list, ncols);
 
       for (auto& elt : row)
         {
           octave_quit ();
@@ -776,30 +779,29 @@ single_type_concat (Sparse<T>& result,
       j++;
     }
 
   result = Sparse<T>::cat (-1, nrows, sparse_row_list);
 }
 
 template <typename MAP>
 static void
-single_type_concat (octave_map& result,
-                    const dim_vector& dv,
-                    tm_const& tmp)
+single_type_concat (octave_map& result, const dim_vector& dv,
+                    octave::tm_const& tmp)
 {
   if (dv.any_zero ())
     {
       result = octave_map (dv);
       return;
     }
 
   octave_idx_type nrows = tmp.length ();
   octave_idx_type j = 0;
   OCTAVE_LOCAL_BUFFER (octave_map, map_row_list, nrows);
-  for (tm_row_const& row : tmp)
+  for (octave::tm_row_const& row : tmp)
     {
       octave_idx_type ncols = row.length ();
       octave_idx_type i = 0;
       OCTAVE_LOCAL_BUFFER (MAP, map_list, ncols);
 
       for (auto& elt : row)
         {
           octave_quit ();
@@ -813,50 +815,48 @@ single_type_concat (octave_map& result,
       j++;
     }
 
   result = octave_map::cat (-1, nrows, map_row_list);
 }
 
 template <typename TYPE>
 static octave_value
-do_single_type_concat (const dim_vector& dv,
-                       tm_const& tmp)
+do_single_type_concat (const dim_vector& dv, octave::tm_const& tmp)
 {
   TYPE result;
 
   single_type_concat<TYPE> (result, dv, tmp);
 
   return result;
 }
 
 template <>
 octave_value
-do_single_type_concat<octave_map> (const dim_vector& dv,
-                                   tm_const& tmp)
+do_single_type_concat<octave_map> (const dim_vector& dv, octave::tm_const& tmp)
 {
   octave_map result;
 
   if (tmp.all_1x1_p ())
     single_type_concat<octave_scalar_map> (result, dv, tmp);
   else
     single_type_concat<octave_map> (result, dv, tmp);
 
   return result;
 }
 
 static octave_value
-do_class_concat (tm_const& tmc)
+do_class_concat (octave::tm_const& tmc)
 {
   octave_value retval;
 
   octave_value_list rows (tmc.length (), octave_value ());
 
   octave_idx_type j = 0;
-  for (tm_row_const& tmrc : tmc)
+  for (octave::tm_row_const& tmrc : tmc)
     {
       octave_quit ();
 
       if (tmrc.length () == 1)
         rows(j++) = *(tmrc.begin ());
       else
         {
           octave_value_list row (tmrc.length (), octave_value ());
@@ -872,229 +872,233 @@ do_class_concat (tm_const& tmc)
   if (rows.length () == 1)
     retval = rows(0);
   else
     retval = do_class_concat (rows, "vertcat", 0);
 
   return retval;
 }
 
-octave_value
-tree_matrix::rvalue1 (int)
+namespace octave
 {
-  octave_value retval = Matrix ();
+  octave_value
+  tree_matrix::rvalue1 (int)
+  {
+    octave_value retval = Matrix ();
 
-  bool all_strings_p = false;
-  bool all_sq_strings_p = false;
-  bool all_dq_strings_p = false;
-  bool all_empty_p = false;
-  bool all_real_p = false;
-  bool any_sparse_p = false;
-  bool any_class_p = false;
-  bool frc_str_conv = false;
-
-  tm_const tmp (*this);
+    bool all_strings_p = false;
+    bool all_sq_strings_p = false;
+    bool all_dq_strings_p = false;
+    bool all_empty_p = false;
+    bool all_real_p = false;
+    bool any_sparse_p = false;
+    bool any_class_p = false;
+    bool frc_str_conv = false;
 
-  if (tmp && ! tmp.empty ())
-    {
-      dim_vector dv = tmp.dims ();
-      all_strings_p = tmp.all_strings_p ();
-      all_sq_strings_p = tmp.all_sq_strings_p ();
-      all_dq_strings_p = tmp.all_dq_strings_p ();
-      all_empty_p = tmp.all_empty_p ();
-      all_real_p = tmp.all_real_p ();
-      any_sparse_p = tmp.any_sparse_p ();
-      any_class_p = tmp.any_class_p ();
-      frc_str_conv = tmp.some_strings_p ();
+    tm_const tmp (*this);
 
-      // Try to speed up the common cases.
+    if (tmp && ! tmp.empty ())
+      {
+        dim_vector dv = tmp.dims ();
+        all_strings_p = tmp.all_strings_p ();
+        all_sq_strings_p = tmp.all_sq_strings_p ();
+        all_dq_strings_p = tmp.all_dq_strings_p ();
+        all_empty_p = tmp.all_empty_p ();
+        all_real_p = tmp.all_real_p ();
+        any_sparse_p = tmp.any_sparse_p ();
+        any_class_p = tmp.any_class_p ();
+        frc_str_conv = tmp.some_strings_p ();
 
-      std::string result_type = tmp.class_name ();
+        // Try to speed up the common cases.
+
+        std::string result_type = tmp.class_name ();
 
-      if (any_class_p)
-        {
-          retval = do_class_concat (tmp);
-        }
-      else if (result_type == "double")
-        {
-          if (any_sparse_p)
-            {
-              if (all_real_p)
-                retval = do_single_type_concat<SparseMatrix> (dv, tmp);
-              else
-                retval = do_single_type_concat<SparseComplexMatrix> (dv, tmp);
-            }
-          else
-            {
-              if (all_real_p)
-                retval = do_single_type_concat<NDArray> (dv, tmp);
-              else
-                retval = do_single_type_concat<ComplexNDArray> (dv, tmp);
-            }
-        }
-      else if (result_type == "single")
-        {
-          if (all_real_p)
-            retval = do_single_type_concat<FloatNDArray> (dv, tmp);
-          else
-            retval = do_single_type_concat<FloatComplexNDArray> (dv, tmp);
-        }
-      else if (result_type == "char")
-        {
-          char type = all_dq_strings_p ? '"' : '\'';
+        if (any_class_p)
+          {
+            retval = do_class_concat (tmp);
+          }
+        else if (result_type == "double")
+          {
+            if (any_sparse_p)
+              {
+                if (all_real_p)
+                  retval = do_single_type_concat<SparseMatrix> (dv, tmp);
+                else
+                  retval = do_single_type_concat<SparseComplexMatrix> (dv, tmp);
+              }
+            else
+              {
+                if (all_real_p)
+                  retval = do_single_type_concat<NDArray> (dv, tmp);
+                else
+                  retval = do_single_type_concat<ComplexNDArray> (dv, tmp);
+              }
+          }
+        else if (result_type == "single")
+          {
+            if (all_real_p)
+              retval = do_single_type_concat<FloatNDArray> (dv, tmp);
+            else
+              retval = do_single_type_concat<FloatComplexNDArray> (dv, tmp);
+          }
+        else if (result_type == "char")
+          {
+            char type = all_dq_strings_p ? '"' : '\'';
 
-          if (! all_strings_p)
-            warn_implicit_conversion ("Octave:num-to-str",
-                                      "numeric", result_type);
-          else
-            maybe_warn_string_concat (all_dq_strings_p, all_sq_strings_p);
+            if (! all_strings_p)
+              warn_implicit_conversion ("Octave:num-to-str",
+                                        "numeric", result_type);
+            else
+              maybe_warn_string_concat (all_dq_strings_p, all_sq_strings_p);
 
-          charNDArray result (dv, Vstring_fill_char);
+            charNDArray result (dv, Vstring_fill_char);
 
-          single_type_concat<charNDArray> (result, tmp);
+            single_type_concat<charNDArray> (result, tmp);
 
-          retval = octave_value (result, type);
-        }
-      else if (result_type == "logical")
-        {
-          if (any_sparse_p)
-            retval = do_single_type_concat<SparseBoolMatrix> (dv, tmp);
-          else
-            retval = do_single_type_concat<boolNDArray> (dv, tmp);
-        }
-      else if (result_type == "int8")
-        retval = do_single_type_concat<int8NDArray> (dv, tmp);
-      else if (result_type == "int16")
-        retval = do_single_type_concat<int16NDArray> (dv, tmp);
-      else if (result_type == "int32")
-        retval = do_single_type_concat<int32NDArray> (dv, tmp);
-      else if (result_type == "int64")
-        retval = do_single_type_concat<int64NDArray> (dv, tmp);
-      else if (result_type == "uint8")
-        retval = do_single_type_concat<uint8NDArray> (dv, tmp);
-      else if (result_type == "uint16")
-        retval = do_single_type_concat<uint16NDArray> (dv, tmp);
-      else if (result_type == "uint32")
-        retval = do_single_type_concat<uint32NDArray> (dv, tmp);
-      else if (result_type == "uint64")
-        retval = do_single_type_concat<uint64NDArray> (dv, tmp);
-      else if (result_type == "cell")
-        retval = do_single_type_concat<Cell> (dv, tmp);
-      else if (result_type == "struct")
-        retval = do_single_type_concat<octave_map> (dv, tmp);
-      else
-        {
-          // The line below might seem crazy, since we take a copy of
-          // the first argument, resize it to be empty and then resize
-          // it to be full.  This is done since it means that there is
-          // no recopying of data, as would happen if we used a single
-          // resize.  It should be noted that resize operation is also
-          // significantly slower than the do_cat_op function, so it
-          // makes sense to have an empty matrix and copy all data.
-          //
-          // We might also start with a empty octave_value using
-          //
-          //    ctmp = octave_value_typeinfo::lookup_type
-          //          (tmp.begin() -> begin() -> type_name());
-          //
-          // and then directly resize.  However, for some types there
-          // might be some additional setup needed, and so this should
-          // be avoided.
+            retval = octave_value (result, type);
+          }
+        else if (result_type == "logical")
+          {
+            if (any_sparse_p)
+              retval = do_single_type_concat<SparseBoolMatrix> (dv, tmp);
+            else
+              retval = do_single_type_concat<boolNDArray> (dv, tmp);
+          }
+        else if (result_type == "int8")
+          retval = do_single_type_concat<int8NDArray> (dv, tmp);
+        else if (result_type == "int16")
+          retval = do_single_type_concat<int16NDArray> (dv, tmp);
+        else if (result_type == "int32")
+          retval = do_single_type_concat<int32NDArray> (dv, tmp);
+        else if (result_type == "int64")
+          retval = do_single_type_concat<int64NDArray> (dv, tmp);
+        else if (result_type == "uint8")
+          retval = do_single_type_concat<uint8NDArray> (dv, tmp);
+        else if (result_type == "uint16")
+          retval = do_single_type_concat<uint16NDArray> (dv, tmp);
+        else if (result_type == "uint32")
+          retval = do_single_type_concat<uint32NDArray> (dv, tmp);
+        else if (result_type == "uint64")
+          retval = do_single_type_concat<uint64NDArray> (dv, tmp);
+        else if (result_type == "cell")
+          retval = do_single_type_concat<Cell> (dv, tmp);
+        else if (result_type == "struct")
+          retval = do_single_type_concat<octave_map> (dv, tmp);
+        else
+          {
+            // The line below might seem crazy, since we take a copy of
+            // the first argument, resize it to be empty and then resize
+            // it to be full.  This is done since it means that there is
+            // no recopying of data, as would happen if we used a single
+            // resize.  It should be noted that resize operation is also
+            // significantly slower than the do_cat_op function, so it
+            // makes sense to have an empty matrix and copy all data.
+            //
+            // We might also start with a empty octave_value using
+            //
+            //    ctmp = octave_value_typeinfo::lookup_type
+            //          (tmp.begin() -> begin() -> type_name());
+            //
+            // and then directly resize.  However, for some types there
+            // might be some additional setup needed, and so this should
+            // be avoided.
 
-          octave_value ctmp;
+            octave_value ctmp;
+
+            // Find the first non-empty object
 
-          // Find the first non-empty object
+            if (any_sparse_p)
+              {
+                // Start with sparse matrix to avoid issues memory issues
+                // with things like [ones(1,4),sprandn(1e8,4,1e-4)]
+                if (all_real_p)
+                  ctmp = octave_sparse_matrix ().resize (dv);
+                else
+                  ctmp = octave_sparse_complex_matrix ().resize (dv);
+              }
+            else
+              {
+                for (tm_row_const& row : tmp)
+                  {
+                    octave_quit ();
 
-          if (any_sparse_p)
-            {
-              // Start with sparse matrix to avoid issues memory issues
-              // with things like [ones(1,4),sprandn(1e8,4,1e-4)]
-              if (all_real_p)
-                ctmp = octave_sparse_matrix ().resize (dv);
-              else
-                ctmp = octave_sparse_complex_matrix ().resize (dv);
-            }
-          else
-            {
-              for (tm_row_const& row : tmp)
-                {
-                  octave_quit ();
+                    for (auto& elt : row)
+                      {
+                        octave_quit ();
+
+                        ctmp = elt;
+
+                        if (! ctmp.all_zero_dims ())
+                          goto found_non_empty;
+                      }
+                  }
+
+                ctmp = (*(tmp.begin () -> begin ()));
+
+              found_non_empty:
 
-                  for (auto& elt : row)
-                    {
-                      octave_quit ();
+                if (! all_empty_p)
+                  ctmp = ctmp.resize (dim_vector (0,0)).resize (dv);
+              }
 
-                      ctmp = elt;
+            // Now, extract the values from the individual elements and
+            // insert them in the result matrix.
 
-                      if (! ctmp.all_zero_dims ())
-                        goto found_non_empty;
-                    }
-                }
+            int dv_len = dv.ndims ();
+            octave_idx_type ntmp = dv_len > 1 ? dv_len : 2;
+            Array<octave_idx_type> ra_idx (dim_vector (ntmp, 1), 0);
 
-              ctmp = (*(tmp.begin () -> begin ()));
-
-            found_non_empty:
+            for (tm_row_const& row : tmp)
+              {
+                octave_quit ();
 
-              if (! all_empty_p)
-                ctmp = ctmp.resize (dim_vector (0,0)).resize (dv);
-            }
+                for (auto& elt : row)
+                  {
+                    octave_quit ();
 
-          // Now, extract the values from the individual elements and
-          // insert them in the result matrix.
+                    if (elt.is_empty ())
+                      continue;
 
-          int dv_len = dv.ndims ();
-          octave_idx_type ntmp = dv_len > 1 ? dv_len : 2;
-          Array<octave_idx_type> ra_idx (dim_vector (ntmp, 1), 0);
+                    ctmp = do_cat_op (ctmp, elt, ra_idx);
+
+                    ra_idx (1) += elt.columns ();
+                  }
 
-          for (tm_row_const& row : tmp)
-            {
-              octave_quit ();
+                ra_idx (0) += row.rows ();
+                ra_idx (1) = 0;
+              }
 
-              for (auto& elt : row)
-                {
-                  octave_quit ();
+            retval = ctmp;
 
-                  if (elt.is_empty ())
-                    continue;
+            if (frc_str_conv && ! retval.is_string ())
+              retval = retval.convert_to_str ();
+          }
+      }
 
-                  ctmp = do_cat_op (ctmp, elt, ra_idx);
+    return retval;
+  }
 
-                  ra_idx (1) += elt.columns ();
-                }
-
-              ra_idx (0) += row.rows ();
-              ra_idx (1) = 0;
-            }
+  tree_expression *
+  tree_matrix::dup (symbol_table::scope_id scope,
+                    symbol_table::context_id context) const
+  {
+    tree_matrix *new_matrix = new tree_matrix (0, line (), column ());
 
-          retval = ctmp;
+    new_matrix->copy_base (*this, scope, context);
+
+    return new_matrix;
+  }
 
-          if (frc_str_conv && ! retval.is_string ())
-            retval = retval.convert_to_str ();
-        }
-    }
-
-  return retval;
+  void
+  tree_matrix::accept (tree_walker& tw)
+  {
+    tw.visit_matrix (*this);
+  }
 }
 
-tree_expression *
-tree_matrix::dup (symbol_table::scope_id scope,
-                  symbol_table::context_id context) const
-{
-  tree_matrix *new_matrix = new tree_matrix (0, line (), column ());
-
-  new_matrix->copy_base (*this, scope, context);
-
-  return new_matrix;
-}
-
-void
-tree_matrix::accept (tree_walker& tw)
-{
-  tw.visit_matrix (*this);
-}
 
 /*
 ## test concatenation with all zero matrices
 %!assert ([ "" 65*ones(1,10) ], "AAAAAAAAAA")
 %!assert ([ 65*ones(1,10) "" ], "AAAAAAAAAA")
 
 %!test
 %! c = {"foo"; "bar"; "bazoloa"};
@@ -1355,9 +1359,8 @@ The original variable value is restored 
 %! assert (["these"; "are"; "strings"], ["theseXX"; "areXXXX"; "strings"]);
 %! string_fill_char (orig_val);
 %! assert (string_fill_char (), orig_val);
 
 %!assert ( [ [], {1} ], {1} )
 
 %!error (string_fill_char (1, 2))
 */
-
diff --git a/libinterp/parse-tree/pt-mat.h b/libinterp/parse-tree/pt-mat.h
--- a/libinterp/parse-tree/pt-mat.h
+++ b/libinterp/parse-tree/pt-mat.h
@@ -24,62 +24,85 @@ along with Octave; see the file COPYING.
 #define octave_pt_mat_h 1
 
 #include "octave-config.h"
 
 #include <iosfwd>
 
 class octave_value;
 class octave_value_list;
-class tree_argument_list;
-
-class tree_walker;
 
 #include "base-list.h"
 #include "pt-array-list.h"
 #include "pt-exp.h"
 #include "symtab.h"
 
-// General matrices.  This allows us to construct matrices from
-// other matrices, variables, and functions.
-
-class
-tree_matrix : public tree_array_list
-{
-public:
-
-  tree_matrix (tree_argument_list *row = 0, int l = -1, int c = -1)
-    : tree_array_list (row, l, c)
-  { }
-
-  // No copying!
-
-  tree_matrix (const tree_matrix&) = delete;
-
-  tree_matrix& operator = (const tree_matrix&) = delete;
-
-  ~tree_matrix (void) = default;
-
-  bool is_matrix (void) const { return true; }
-
-  bool rvalue_ok (void) const { return true; }
-
-  octave_value rvalue1 (int nargout = 1);
-
-  octave_value_list rvalue (int nargout);
-
-  tree_expression *dup (symbol_table::scope_id scope,
-                        symbol_table::context_id context) const;
-
-  void accept (tree_walker& tw);
-};
-
 // The character to fill with when creating string arrays.
 extern char Vstring_fill_char;
 
-extern std::string
-get_concat_class (const std::string& c1, const std::string& c2);
+namespace octave
+{
+  class tree_argument_list;
+
+  class tree_walker;
+
+  // General matrices.  This allows us to construct matrices from
+  // other matrices, variables, and functions.
+
+  class tree_matrix : public tree_array_list
+  {
+  public:
+
+    tree_matrix (tree_argument_list *row = 0, int l = -1, int c = -1)
+      : tree_array_list (row, l, c)
+    { }
+
+    // No copying!
+
+    tree_matrix (const tree_matrix&) = delete;
+
+    tree_matrix& operator = (const tree_matrix&) = delete;
+
+    ~tree_matrix (void) = default;
+
+    bool is_matrix (void) const { return true; }
+
+    bool rvalue_ok (void) const { return true; }
+
+    octave_value rvalue1 (int nargout = 1);
 
-extern void
-maybe_warn_string_concat (bool all_dq_strings_p, bool all_sq_strings_p);
+    octave_value_list rvalue (int nargout);
+
+    tree_expression *dup (symbol_table::scope_id scope,
+                          symbol_table::context_id context) const;
+
+    void accept (tree_walker& tw);
+  };
+
+  extern std::string
+  get_concat_class (const std::string& c1, const std::string& c2);
+
+  extern void
+  maybe_warn_string_concat (bool all_dq_strings_p, bool all_sq_strings_p);
+}
+
+#if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
+
+OCTAVE_DEPRECATED ("use 'octave::tree_matrix' instead")
+typedef octave::tree_matrix tree_matrix;
+
+OCTAVE_DEPRECATED ("use 'octave::get_concat_class' instead")
+static inline std::string
+get_concat_class (const std::string& c1, const std::string& c2)
+{
+  return octave::get_concat_class (c1, c2);
+}
+
+OCTAVE_DEPRECATED ("use 'octave::maybe_warn_string_concat' instead")
+static inline void
+maybe_warn_string_concat (bool all_dq_strings_p, bool all_sq_strings_p)
+{
+  octave::maybe_warn_string_concat (all_dq_strings_p, all_sq_strings_p);
+}
 
 #endif
 
+#endif
diff --git a/libinterp/parse-tree/pt-misc.cc b/libinterp/parse-tree/pt-misc.cc
--- a/libinterp/parse-tree/pt-misc.cc
+++ b/libinterp/parse-tree/pt-misc.cc
@@ -31,303 +31,305 @@ along with Octave; see the file COPYING.
 #include "ov.h"
 #include "oct-lvalue.h"
 #include "pt-id.h"
 #include "pt-idx.h"
 #include "pt-misc.h"
 #include "pt-walk.h"
 #include "utils.h"
 
-// Parameter lists.
-
-tree_parameter_list::~tree_parameter_list (void)
-{
-  while (! empty ())
-    {
-      iterator p = begin ();
-      delete *p;
-      erase (p);
-    }
-}
-
-void
-tree_parameter_list::mark_as_formal_parameters (void)
+namespace octave
 {
-  for (tree_decl_elt* elt : *this)
-    elt->mark_as_formal_parameter ();
-}
+  // Parameter lists.
 
-bool
-tree_parameter_list::validate (in_or_out type)
-{
-  bool retval = true;
+  tree_parameter_list::~tree_parameter_list (void)
+  {
+    while (! empty ())
+      {
+        iterator p = begin ();
+        delete *p;
+        erase (p);
+      }
+  }
 
-  std::set<std::string> dict;
+  void
+  tree_parameter_list::mark_as_formal_parameters (void)
+  {
+    for (tree_decl_elt* elt : *this)
+      elt->mark_as_formal_parameter ();
+  }
 
-  for (tree_decl_elt* elt : *this)
-    {
-      tree_identifier *id = elt->ident ();
+  bool
+  tree_parameter_list::validate (in_or_out type)
+  {
+    bool retval = true;
 
-      if (id)
-        {
-          std::string name = id->name ();
+    std::set<std::string> dict;
+
+    for (tree_decl_elt* elt : *this)
+      {
+        tree_identifier *id = elt->ident ();
 
-          if (id->is_black_hole ())
-            {
-              if (type != in)
-                error ("invalid use of ~ in output list");
-            }
-          else if (dict.find (name) != dict.end ())
-            error ("'%s' appears more than once in parameter list",
-                   name.c_str ());
-          else
-            dict.insert (name);
-        }
-    }
+        if (id)
+          {
+            std::string name = id->name ();
 
-  std::string va_type = (type == in ? "varargin" : "varargout");
-
-  size_t len = length ();
+            if (id->is_black_hole ())
+              {
+                if (type != in)
+                  error ("invalid use of ~ in output list");
+              }
+            else if (dict.find (name) != dict.end ())
+              error ("'%s' appears more than once in parameter list",
+                     name.c_str ());
+            else
+              dict.insert (name);
+          }
+      }
 
-  if (len > 0)
-    {
-      tree_decl_elt *elt = back ();
+    std::string va_type = (type == in ? "varargin" : "varargout");
+
+    size_t len = length ();
 
-      tree_identifier *id = elt->ident ();
+    if (len > 0)
+      {
+        tree_decl_elt *elt = back ();
 
-      if (id && id->name () == va_type)
-        {
-          if (len == 1)
-            mark_varargs_only ();
-          else
-            mark_varargs ();
+        tree_identifier *id = elt->ident ();
 
-          iterator p = end ();
-          --p;
-          delete *p;
-          erase (p);
-        }
-    }
+        if (id && id->name () == va_type)
+          {
+            if (len == 1)
+              mark_varargs_only ();
+            else
+              mark_varargs ();
 
-  return retval;
-}
+            iterator p = end ();
+            --p;
+            delete *p;
+            erase (p);
+          }
+      }
+
+    return retval;
+  }
 
-void
-tree_parameter_list::initialize_undefined_elements (const std::string& warnfor,
-                                                    int nargout,
-                                                    const octave_value& val)
-{
-  bool warned = false;
+  void
+  tree_parameter_list::initialize_undefined_elements (const std::string& warnfor,
+                                                      int nargout,
+                                                      const octave_value& val)
+  {
+    bool warned = false;
 
-  int count = 0;
+    int count = 0;
 
-  octave_value tmp = symbol_table::varval (".ignored.");
-  const Matrix ignored = tmp.is_defined () ? tmp.matrix_value () : Matrix ();
-
-  octave_idx_type k = 0;
+    octave_value tmp = symbol_table::varval (".ignored.");
+    const Matrix ignored = tmp.is_defined () ? tmp.matrix_value () : Matrix ();
 
-  for (tree_decl_elt* elt : *this)
-    {
-      if (++count > nargout)
-        break;
+    octave_idx_type k = 0;
+
+    for (tree_decl_elt* elt : *this)
+      {
+        if (++count > nargout)
+          break;
 
-      if (! elt->is_variable ())
-        {
-          if (! warned)
-            {
-              warned = true;
+        if (! elt->is_variable ())
+          {
+            if (! warned)
+              {
+                warned = true;
 
-              while (k < ignored.numel ())
-                {
-                  octave_idx_type l = ignored (k);
-                  if (l == count)
-                    {
-                      warned = false;
+                while (k < ignored.numel ())
+                  {
+                    octave_idx_type l = ignored (k);
+                    if (l == count)
+                      {
+                        warned = false;
+                        break;
+                      }
+                    else if (l > count)
                       break;
-                    }
-                  else if (l > count)
-                    break;
-                  else
-                    k++;
-                }
+                    else
+                      k++;
+                  }
 
-              if (warned)
-                {
-                  warning_with_id
-                    ("Octave:undefined-return-values",
-                     "%s: some elements in list of return values are undefined",
-                     warnfor.c_str ());
-                }
-            }
+                if (warned)
+                  {
+                    warning_with_id
+                      ("Octave:undefined-return-values",
+                       "%s: some elements in list of return values are undefined",
+                       warnfor.c_str ());
+                  }
+              }
 
-          octave_lvalue lval = elt->lvalue ();
+            octave_lvalue lval = elt->lvalue ();
 
-          lval.assign (octave_value::op_asn_eq, val);
-        }
-    }
-}
+            lval.assign (octave_value::op_asn_eq, val);
+          }
+      }
+  }
 
-void
-tree_parameter_list::define_from_arg_vector (const octave_value_list& args)
-{
-  int expected_nargin = length ();
+  void
+  tree_parameter_list::define_from_arg_vector (const octave_value_list& args)
+  {
+    int expected_nargin = length ();
 
-  iterator p = begin ();
+    iterator p = begin ();
 
-  for (int i = 0; i < expected_nargin; i++)
-    {
-      tree_decl_elt *elt = *p++;
+    for (int i = 0; i < expected_nargin; i++)
+      {
+        tree_decl_elt *elt = *p++;
 
-      octave_lvalue ref = elt->lvalue ();
+        octave_lvalue ref = elt->lvalue ();
 
-      if (i < args.length ())
-        {
-          if (args(i).is_defined () && args(i).is_magic_colon ())
-            {
-              if (! elt->eval ())
-                error ("no default value for argument %d", i+1);
-            }
-          else
-            ref.define (args(i));
-        }
-      else
-        elt->eval ();
-    }
-}
+        if (i < args.length ())
+          {
+            if (args(i).is_defined () && args(i).is_magic_colon ())
+              {
+                if (! elt->eval ())
+                  error ("no default value for argument %d", i+1);
+              }
+            else
+              ref.define (args(i));
+          }
+        else
+          elt->eval ();
+      }
+  }
 
-void
-tree_parameter_list::undefine (void)
-{
-  int len = length ();
+  void
+  tree_parameter_list::undefine (void)
+  {
+    int len = length ();
 
-  iterator p = begin ();
+    iterator p = begin ();
 
-  for (int i = 0; i < len; i++)
-    {
-      tree_decl_elt *elt = *p++;
+    for (int i = 0; i < len; i++)
+      {
+        tree_decl_elt *elt = *p++;
 
-      octave_lvalue ref = elt->lvalue ();
+        octave_lvalue ref = elt->lvalue ();
 
-      ref.assign (octave_value::op_asn_eq, octave_value ());
-    }
-}
+        ref.assign (octave_value::op_asn_eq, octave_value ());
+      }
+  }
 
-std::list<std::string>
-tree_parameter_list::variable_names (void) const
-{
-  std::list<std::string> retval;
+  std::list<std::string>
+  tree_parameter_list::variable_names (void) const
+  {
+    std::list<std::string> retval;
 
-  for (tree_decl_elt* elt : *this)
-    retval.push_back (elt->name ());
+    for (tree_decl_elt* elt : *this)
+      retval.push_back (elt->name ());
 
-  return retval;
-}
+    return retval;
+  }
 
-octave_value_list
-tree_parameter_list::convert_to_const_vector (int nargout,
-                                              const Cell& varargout)
-{
-  octave_idx_type vlen = varargout.numel ();
-  int len = length ();
+  octave_value_list
+  tree_parameter_list::convert_to_const_vector (int nargout,
+                                                const Cell& varargout)
+  {
+    octave_idx_type vlen = varargout.numel ();
+    int len = length ();
 
-  // Special case.  Will do a shallow copy.
-  if (len == 0)
-    return varargout;
-  else if (nargout <= len)
-    {
-      octave_value_list retval (nargout);
+    // Special case.  Will do a shallow copy.
+    if (len == 0)
+      return varargout;
+    else if (nargout <= len)
+      {
+        octave_value_list retval (nargout);
 
-      int i = 0;
+        int i = 0;
 
-      for (tree_decl_elt* elt : *this)
-        {
-          if (elt->is_defined ())
-            retval(i++) = elt->rvalue1 ();
-          else
-            break;
-        }
+        for (tree_decl_elt* elt : *this)
+          {
+            if (elt->is_defined ())
+              retval(i++) = elt->rvalue1 ();
+            else
+              break;
+          }
 
-      return retval;
-    }
-  else
-    {
-      octave_value_list retval (len + vlen);
+        return retval;
+      }
+    else
+      {
+        octave_value_list retval (len + vlen);
 
-      int i = 0;
+        int i = 0;
 
-      for (tree_decl_elt* elt : *this)
-        retval(i++) = elt->rvalue1 ();
+        for (tree_decl_elt* elt : *this)
+          retval(i++) = elt->rvalue1 ();
 
-      for (octave_idx_type j = 0; j < vlen; j++)
-        retval(i++) = varargout(j);
+        for (octave_idx_type j = 0; j < vlen; j++)
+          retval(i++) = varargout(j);
 
-      return retval;
-    }
-}
+        return retval;
+      }
+  }
 
-bool
-tree_parameter_list::is_defined (void)
-{
-  bool status = true;
+  bool
+  tree_parameter_list::is_defined (void)
+  {
+    bool status = true;
 
-  for (tree_decl_elt* elt : *this)
-    {
-      if (! elt->is_variable ())
-        {
-          status = false;
-          break;
-        }
-    }
+    for (tree_decl_elt* elt : *this)
+      {
+        if (! elt->is_variable ())
+          {
+            status = false;
+            break;
+          }
+      }
 
-  return status;
-}
+    return status;
+  }
 
-tree_parameter_list *
-tree_parameter_list::dup (symbol_table::scope_id scope,
-                          symbol_table::context_id context) const
-{
-  tree_parameter_list *new_list = new tree_parameter_list ();
+  tree_parameter_list *
+  tree_parameter_list::dup (symbol_table::scope_id scope,
+                            symbol_table::context_id context) const
+  {
+    tree_parameter_list *new_list = new tree_parameter_list ();
 
-  if (takes_varargs ())
-    new_list->mark_varargs ();
+    if (takes_varargs ())
+      new_list->mark_varargs ();
 
-  for (const tree_decl_elt* elt : *this)
-    new_list->append (elt->dup (scope, context));
+    for (const tree_decl_elt* elt : *this)
+      new_list->append (elt->dup (scope, context));
 
-  return new_list;
-}
+    return new_list;
+  }
 
-void
-tree_parameter_list::accept (tree_walker& tw)
-{
-  tw.visit_parameter_list (*this);
-}
+  void
+  tree_parameter_list::accept (tree_walker& tw)
+  {
+    tw.visit_parameter_list (*this);
+  }
+
+  // Return lists.
 
-// Return lists.
+  tree_return_list::~tree_return_list (void)
+  {
+    while (! empty ())
+      {
+        iterator p = begin ();
+        delete *p;
+        erase (p);
+      }
+  }
 
-tree_return_list::~tree_return_list (void)
-{
-  while (! empty ())
-    {
-      iterator p = begin ();
-      delete *p;
-      erase (p);
-    }
+  tree_return_list *
+  tree_return_list::dup (symbol_table::scope_id scope,
+                         symbol_table::context_id context) const
+  {
+    tree_return_list *new_list = new tree_return_list ();
+
+    for (const tree_index_expression* elt : *this)
+      new_list->append (elt->dup (scope, context));
+
+    return new_list;
+  }
+
+  void
+  tree_return_list::accept (tree_walker& tw)
+  {
+    tw.visit_return_list (*this);
+  }
 }
-
-tree_return_list *
-tree_return_list::dup (symbol_table::scope_id scope,
-                       symbol_table::context_id context) const
-{
-  tree_return_list *new_list = new tree_return_list ();
-
-  for (const tree_index_expression* elt : *this)
-    new_list->append (elt->dup (scope, context));
-
-  return new_list;
-}
-
-void
-tree_return_list::accept (tree_walker& tw)
-{
-  tw.visit_return_list (*this);
-}
-
diff --git a/libinterp/parse-tree/pt-misc.h b/libinterp/parse-tree/pt-misc.h
--- a/libinterp/parse-tree/pt-misc.h
+++ b/libinterp/parse-tree/pt-misc.h
@@ -25,130 +25,137 @@ along with Octave; see the file COPYING.
 
 #include "octave-config.h"
 
 class Cell;
 
 class octave_value;
 class octave_value_list;
 
-class tree_identifier;
-class tree_index_expression;
-class tree_va_return_list;
-
-class tree_walker;
-
 #include "base-list.h"
 #include "pt-decl.h"
 #include "symtab.h"
 
-// Parameter lists.  Used to hold the list of input and output
-// parameters in a function definition.  Elements are identifiers
-// only.
-
-class
-tree_parameter_list : public octave::base_list<tree_decl_elt *>
+namespace octave
 {
-public:
+  class tree_identifier;
+  class tree_index_expression;
+  class tree_va_return_list;
+
+  class tree_walker;
+
+  // Parameter lists.  Used to hold the list of input and output
+  // parameters in a function definition.  Elements are identifiers
+  // only.
+
+  class tree_parameter_list : public octave::base_list<tree_decl_elt *>
+  {
+  public:
+
+    enum in_or_out
+      {
+        in = 1,
+        out = 2
+      };
+
+    tree_parameter_list (void)
+      : marked_for_varargs (0) { }
+
+    tree_parameter_list (tree_decl_elt *t)
+      : marked_for_varargs (0) { append (t); }
+
+    tree_parameter_list (tree_identifier *id)
+      : marked_for_varargs (0) { append (new tree_decl_elt (id)); }
+
+    // No copying!
+
+    tree_parameter_list (const tree_parameter_list&) = delete;
+
+    tree_parameter_list& operator = (const tree_parameter_list&) = delete;
 
-  enum in_or_out
-  {
-    in = 1,
-    out = 2
+    ~tree_parameter_list (void);
+
+    void mark_as_formal_parameters (void);
+
+    bool validate (in_or_out type);
+
+    bool takes_varargs (void) const { return marked_for_varargs != 0; }
+
+    bool varargs_only (void) { return (marked_for_varargs < 0); }
+
+    void initialize_undefined_elements (const std::string& warnfor,
+                                        int nargout, const octave_value& val);
+
+    void define_from_arg_vector (const octave_value_list& args);
+
+    void undefine (void);
+
+    bool is_defined (void);
+
+    std::list<std::string> variable_names (void) const;
+
+    octave_value_list convert_to_const_vector (int nargout,
+                                               const Cell& varargout);
+
+    tree_parameter_list *dup (symbol_table::scope_id scope,
+                              symbol_table::context_id context) const;
+
+    void accept (tree_walker& tw);
+
+  private:
+
+    int marked_for_varargs;
+
+    void mark_varargs (void) { marked_for_varargs = 1; }
+
+    void mark_varargs_only (void) { marked_for_varargs = -1; }
   };
 
-  tree_parameter_list (void)
-    : marked_for_varargs (0) { }
-
-  tree_parameter_list (tree_decl_elt *t)
-    : marked_for_varargs (0) { append (t); }
-
-  tree_parameter_list (tree_identifier *id)
-    : marked_for_varargs (0) { append (new tree_decl_elt (id)); }
-
-  // No copying!
+  // Return lists.  Used to hold the right hand sides of multiple
+  // assignment expressions.
 
-  tree_parameter_list (const tree_parameter_list&) = delete;
-
-  tree_parameter_list& operator = (const tree_parameter_list&) = delete;
-
-  ~tree_parameter_list (void);
+  class tree_return_list : public octave::base_list<tree_index_expression *>
+  {
+  public:
 
-  void mark_as_formal_parameters (void);
+    tree_return_list (void) { }
 
-  bool validate (in_or_out type);
-
-  bool takes_varargs (void) const { return marked_for_varargs != 0; }
+    tree_return_list (tree_index_expression *t) { append (t); }
 
-  bool varargs_only (void) { return (marked_for_varargs < 0); }
-
-  void initialize_undefined_elements (const std::string& warnfor,
-                                      int nargout, const octave_value& val);
+    // No copying!
 
-  void define_from_arg_vector (const octave_value_list& args);
-
-  void undefine (void);
-
-  bool is_defined (void);
+    tree_return_list (const tree_return_list&) = delete;
 
-  std::list<std::string> variable_names (void) const;
-
-  octave_value_list convert_to_const_vector (int nargout,
-                                             const Cell& varargout);
+    tree_return_list& operator = (const tree_return_list&) = delete;
 
-  tree_parameter_list *dup (symbol_table::scope_id scope,
-                            symbol_table::context_id context) const;
+    ~tree_return_list (void);
 
-  void accept (tree_walker& tw);
-
-private:
+    tree_return_list *dup (symbol_table::scope_id scope,
+                           symbol_table::context_id context) const;
 
-  int marked_for_varargs;
-
-  void mark_varargs (void) { marked_for_varargs = 1; }
-
-  void mark_varargs_only (void) { marked_for_varargs = -1; }
-};
-
-// Return lists.  Used to hold the right hand sides of multiple
-// assignment expressions.
+    void accept (tree_walker& tw);
+  };
 
-class
-tree_return_list : public octave::base_list<tree_index_expression *>
-{
-public:
+  class tree_va_return_list : public octave::base_list<octave_value>
+  {
+  public:
 
-  tree_return_list (void) { }
-
-  tree_return_list (tree_index_expression *t) { append (t); }
+    tree_va_return_list (void) { }
 
-  // No copying!
-
-  tree_return_list (const tree_return_list&) = delete;
+    // No copying!
 
-  tree_return_list& operator = (const tree_return_list&) = delete;
-
-  ~tree_return_list (void);
+    tree_va_return_list (const tree_va_return_list&) = delete;
 
-  tree_return_list *dup (symbol_table::scope_id scope,
-                         symbol_table::context_id context) const;
-
-  void accept (tree_walker& tw);
-};
+    tree_va_return_list& operator = (const tree_va_return_list&) = delete;
 
-class
-tree_va_return_list : public octave::base_list<octave_value>
-{
-public:
-
-  tree_va_return_list (void) { }
+    ~tree_va_return_list (void) = default;
+  };
+}
 
-  // No copying!
-
-  tree_va_return_list (const tree_va_return_list&) = delete;
+#if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
 
-  tree_va_return_list& operator = (const tree_va_return_list&) = delete;
-
-  ~tree_va_return_list (void) = default;
-};
+// tree_parameter_list is derived from a template.
+// tree_return_list is derived from a template.
+// tree_va_return_list is derived from a template.
 
 #endif
 
+#endif
diff --git a/libinterp/parse-tree/pt-pr-code.cc b/libinterp/parse-tree/pt-pr-code.cc
--- a/libinterp/parse-tree/pt-pr-code.cc
+++ b/libinterp/parse-tree/pt-pr-code.cc
@@ -29,1313 +29,1315 @@ along with Octave; see the file COPYING.
 #include <iostream>
 
 #include "comment-list.h"
 #include "error.h"
 #include "ov-usr-fcn.h"
 #include "pr-output.h"
 #include "pt-all.h"
 
-void
-tree_print_code::visit_anon_fcn_handle (tree_anon_fcn_handle& afh)
-{
-  indent ();
-
-  print_parens (afh, "(");
-
-  os << "@(";
-
-  tree_parameter_list *param_list = afh.parameter_list ();
-
-  if (param_list)
-    param_list->accept (*this);
-
-  os << ") ";
-
-  print_fcn_handle_body (afh.body ());
-
-  print_parens (afh, ")");
-}
-
-void
-tree_print_code::visit_argument_list (tree_argument_list& lst)
-{
-  tree_argument_list::iterator p = lst.begin ();
-
-  while (p != lst.end ())
-    {
-      tree_expression *elt = *p++;
-
-      if (elt)
-        {
-          elt->accept (*this);
-
-          if (p != lst.end ())
-            os << ", ";
-        }
-    }
-}
-
-void
-tree_print_code::visit_binary_expression (tree_binary_expression& expr)
-{
-  indent ();
-
-  print_parens (expr, "(");
-
-  tree_expression *op1 = expr.lhs ();
-
-  if (op1)
-    op1->accept (*this);
-
-  os << " " << expr.oper () << " ";
-
-  tree_expression *op2 = expr.rhs ();
-
-  if (op2)
-    op2->accept (*this);
-
-  print_parens (expr, ")");
-}
-
-void
-tree_print_code::visit_break_command (tree_break_command&)
-{
-  indent ();
-
-  os << "break";
-}
-
-void
-tree_print_code::visit_colon_expression (tree_colon_expression& expr)
+namespace octave
 {
-  indent ();
-
-  print_parens (expr, "(");
-
-  tree_expression *op1 = expr.base ();
-
-  if (op1)
-    op1->accept (*this);
-
-  // Stupid syntax.
-
-  tree_expression *op3 = expr.increment ();
-
-  if (op3)
-    {
-      os << ":";
-      op3->accept (*this);
-    }
-
-  tree_expression *op2 = expr.limit ();
-
-  if (op2)
-    {
-      os << ":";
-      op2->accept (*this);
-    }
-
-  print_parens (expr, ")");
-}
-
-void
-tree_print_code::visit_continue_command (tree_continue_command&)
-{
-  indent ();
-
-  os << "continue";
-}
-
-void
-tree_print_code::do_decl_command (tree_decl_command& cmd)
-{
-  indent ();
-
-  os << cmd.name () << " ";
-
-  tree_decl_init_list *init_list = cmd.initializer_list ();
-
-  if (init_list)
-    init_list->accept (*this);
-}
-
-void
-tree_print_code::visit_global_command (tree_global_command& cmd)
-{
-  do_decl_command (cmd);
-}
-
-void
-tree_print_code::visit_persistent_command (tree_persistent_command& cmd)
-{
-  do_decl_command (cmd);
-}
-
-void
-tree_print_code::visit_decl_elt (tree_decl_elt& cmd)
-{
-  tree_identifier *id = cmd.ident ();
-
-  if (id)
-    id->accept (*this);
-
-  tree_expression *expr = cmd.expression ();
-
-  if (expr)
-    {
-      os << " = ";
-
-      expr->accept (*this);
-    }
-}
-
-void
-tree_print_code::visit_decl_init_list (tree_decl_init_list& lst)
-{
-  tree_decl_init_list::iterator p = lst.begin ();
-
-  while (p != lst.end ())
-    {
-      tree_decl_elt *elt = *p++;
-
-      if (elt)
-        {
-          elt->accept (*this);
-
-          if (p != lst.end ())
-            os << ", ";
-        }
-    }
-}
-
-void
-tree_print_code::visit_simple_for_command (tree_simple_for_command& cmd)
-{
-  print_comment_list (cmd.leading_comment ());
-
-  indent ();
-
-  os << (cmd.in_parallel () ? "parfor " : "for ");
-
-  tree_expression *lhs = cmd.left_hand_side ();
+  void
+  tree_print_code::visit_anon_fcn_handle (tree_anon_fcn_handle& afh)
+  {
+    indent ();
 
-  tree_expression *maxproc = cmd.maxproc_expr ();
-
-  if (maxproc)
-    os << "(";
-
-  if (lhs)
-    lhs->accept (*this);
-
-  os << " = ";
-
-  tree_expression *expr = cmd.control_expr ();
-
-  if (expr)
-    expr->accept (*this);
-
-  if (maxproc)
-    {
-      os << ", ";
-      maxproc->accept (*this);
-      os << ")";
-    }
-
-  newline ();
-
-  tree_statement_list *list = cmd.body ();
-
-  if (list)
-    {
-      increment_indent_level ();
-
-      list->accept (*this);
-
-      decrement_indent_level ();
-    }
-
-  print_indented_comment (cmd.trailing_comment ());
-
-  indent ();
-
-  os << (cmd.in_parallel () ? "endparfor" : "endfor");
-}
+    print_parens (afh, "(");
 
-void
-tree_print_code::visit_complex_for_command (tree_complex_for_command& cmd)
-{
-  print_comment_list (cmd.leading_comment ());
-
-  indent ();
-
-  os << "for [";
-  nesting.push ('[');
-
-  tree_argument_list *lhs = cmd.left_hand_side ();
-
-  if (lhs)
-    lhs->accept (*this);
-
-  nesting.pop ();
-  os << "] = ";
-
-  tree_expression *expr = cmd.control_expr ();
-
-  if (expr)
-    expr->accept (*this);
-
-  newline ();
-
-  tree_statement_list *list = cmd.body ();
-
-  if (list)
-    {
-      increment_indent_level ();
-
-      list->accept (*this);
-
-      decrement_indent_level ();
-    }
-
-  print_indented_comment (cmd.trailing_comment ());
-
-  indent ();
-
-  os << "endfor";
-}
-
-void
-tree_print_code::visit_octave_user_script (octave_user_script& fcn)
-{
-  reset ();
-
-  tree_statement_list *cmd_list = fcn.body ();
+    os << "@(";
 
-  if (cmd_list)
-    cmd_list->accept (*this);
-}
-
-void
-tree_print_code::visit_octave_user_function (octave_user_function& fcn)
-{
-  reset ();
-
-  visit_octave_user_function_header (fcn);
-
-  tree_statement_list *cmd_list = fcn.body ();
-
-  if (cmd_list)
-    {
-      increment_indent_level ();
-
-      cmd_list->accept (*this);
-
-      // endfunction will decrement the indent level.
-    }
-
-  visit_octave_user_function_trailer (fcn);
-}
-
-void
-tree_print_code::visit_octave_user_function_header (octave_user_function& fcn)
-{
-  octave_comment_list *leading_comment = fcn.leading_comment ();
-
-  if (leading_comment)
-    {
-      print_comment_list (leading_comment);
-      newline ();
-    }
-
-  indent ();
-
-  os << "function ";
-
-  tree_parameter_list *ret_list = fcn.return_list ();
-
-  if (ret_list)
-    {
-      bool takes_var_return = fcn.takes_var_return ();
+    tree_parameter_list *param_list = afh.parameter_list ();
 
-      int len = ret_list->length ();
-
-      if (len > 1 || takes_var_return)
-        {
-          os << "[";
-          nesting.push ('[');
-        }
-
-      ret_list->accept (*this);
-
-      if (takes_var_return)
-        {
-          if (len > 0)
-            os << ", ";
-
-          os << "varargout";
-        }
-
-      if (len > 1 || takes_var_return)
-        {
-          nesting.pop ();
-          os << "]";
-        }
-
-      os << " = ";
-    }
-
-  std::string fcn_name = fcn.name ();
-
-  os << (fcn_name.empty () ? std::string ("(empty)") : fcn_name) << " ";
-
-  tree_parameter_list *param_list = fcn.parameter_list ();
-
-  if (param_list)
-    {
-      bool takes_varargs = fcn.takes_varargs ();
-
-      int len = param_list->length ();
-
-      if (len > 0 || takes_varargs)
-        {
-          os << "(";
-          nesting.push ('(');
-        }
-
+    if (param_list)
       param_list->accept (*this);
 
-      if (takes_varargs)
-        {
-          if (len > 0)
-            os << ", ";
+    os << ") ";
+
+    print_fcn_handle_body (afh.body ());
+
+    print_parens (afh, ")");
+  }
+
+  void
+  tree_print_code::visit_argument_list (tree_argument_list& lst)
+  {
+    tree_argument_list::iterator p = lst.begin ();
+
+    while (p != lst.end ())
+      {
+        tree_expression *elt = *p++;
+
+        if (elt)
+          {
+            elt->accept (*this);
 
-          os << "varargin";
-        }
+            if (p != lst.end ())
+              os << ", ";
+          }
+      }
+  }
+
+  void
+  tree_print_code::visit_binary_expression (tree_binary_expression& expr)
+  {
+    indent ();
+
+    print_parens (expr, "(");
+
+    tree_expression *op1 = expr.lhs ();
+
+    if (op1)
+      op1->accept (*this);
+
+    os << " " << expr.oper () << " ";
+
+    tree_expression *op2 = expr.rhs ();
 
-      if (len > 0 || takes_varargs)
-        {
-          nesting.pop ();
-          os << ")";
-          newline ();
-        }
-    }
-  else
-    {
-      os << "()";
-      newline ();
-    }
-}
+    if (op2)
+      op2->accept (*this);
+
+    print_parens (expr, ")");
+  }
+
+  void
+  tree_print_code::visit_break_command (tree_break_command&)
+  {
+    indent ();
+
+    os << "break";
+  }
+
+  void
+  tree_print_code::visit_colon_expression (tree_colon_expression& expr)
+  {
+    indent ();
+
+    print_parens (expr, "(");
+
+    tree_expression *op1 = expr.base ();
 
-void
-tree_print_code::visit_octave_user_function_trailer (octave_user_function& fcn)
-{
-  print_indented_comment (fcn.trailing_comment ());
+    if (op1)
+      op1->accept (*this);
 
-  newline ();
-}
+    // Stupid syntax.
+
+    tree_expression *op3 = expr.increment ();
 
-void
-tree_print_code::visit_function_def (tree_function_def& fdef)
-{
-  indent ();
+    if (op3)
+      {
+        os << ":";
+        op3->accept (*this);
+      }
+
+    tree_expression *op2 = expr.limit ();
 
-  octave_value fcn = fdef.function ();
+    if (op2)
+      {
+        os << ":";
+        op2->accept (*this);
+      }
 
-  octave_function *f = fcn.function_value ();
+    print_parens (expr, ")");
+  }
 
-  if (f)
-    f->accept (*this);
-}
+  void
+  tree_print_code::visit_continue_command (tree_continue_command&)
+  {
+    indent ();
+
+    os << "continue";
+  }
 
-void
-tree_print_code::visit_identifier (tree_identifier& id)
-{
-  indent ();
+  void
+  tree_print_code::do_decl_command (tree_decl_command& cmd)
+  {
+    indent ();
 
-  print_parens (id, "(");
+    os << cmd.name () << " ";
+
+    tree_decl_init_list *init_list = cmd.initializer_list ();
+
+    if (init_list)
+      init_list->accept (*this);
+  }
 
-  std::string nm = id.name ();
-  os << (nm.empty () ? std::string ("(empty)") : nm);
+  void
+  tree_print_code::visit_global_command (tree_global_command& cmd)
+  {
+    do_decl_command (cmd);
+  }
 
-  print_parens (id, ")");
-}
+  void
+  tree_print_code::visit_persistent_command (tree_persistent_command& cmd)
+  {
+    do_decl_command (cmd);
+  }
 
-void
-tree_print_code::visit_if_clause (tree_if_clause& cmd)
-{
-  tree_expression *expr = cmd.condition ();
+  void
+  tree_print_code::visit_decl_elt (tree_decl_elt& cmd)
+  {
+    tree_identifier *id = cmd.ident ();
+
+    if (id)
+      id->accept (*this);
+
+    tree_expression *expr = cmd.expression ();
 
-  if (expr)
-    expr->accept (*this);
+    if (expr)
+      {
+        os << " = ";
 
-  newline ();
+        expr->accept (*this);
+      }
+  }
 
-  tree_statement_list *list = cmd.commands ();
+  void
+  tree_print_code::visit_decl_init_list (tree_decl_init_list& lst)
+  {
+    tree_decl_init_list::iterator p = lst.begin ();
 
-  if (list)
-    {
-      increment_indent_level ();
+    while (p != lst.end ())
+      {
+        tree_decl_elt *elt = *p++;
+
+        if (elt)
+          {
+            elt->accept (*this);
 
-      list->accept (*this);
+            if (p != lst.end ())
+              os << ", ";
+          }
+      }
+  }
 
-      decrement_indent_level ();
-    }
-}
+  void
+  tree_print_code::visit_simple_for_command (tree_simple_for_command& cmd)
+  {
+    print_comment_list (cmd.leading_comment ());
+
+    indent ();
 
-void
-tree_print_code::visit_if_command (tree_if_command& cmd)
-{
-  print_comment_list (cmd.leading_comment ());
+    os << (cmd.in_parallel () ? "parfor " : "for ");
+
+    tree_expression *lhs = cmd.left_hand_side ();
+
+    tree_expression *maxproc = cmd.maxproc_expr ();
 
-  indent ();
+    if (maxproc)
+      os << "(";
+
+    if (lhs)
+      lhs->accept (*this);
+
+    os << " = ";
+
+    tree_expression *expr = cmd.control_expr ();
 
-  os << "if ";
+    if (expr)
+      expr->accept (*this);
 
-  tree_if_command_list *list = cmd.cmd_list ();
+    if (maxproc)
+      {
+        os << ", ";
+        maxproc->accept (*this);
+        os << ")";
+      }
 
-  if (list)
-    list->accept (*this);
+    newline ();
+
+    tree_statement_list *list = cmd.body ();
 
-  print_indented_comment (cmd.trailing_comment ());
+    if (list)
+      {
+        increment_indent_level ();
+
+        list->accept (*this);
 
-  indent ();
+        decrement_indent_level ();
+      }
+
+    print_indented_comment (cmd.trailing_comment ());
 
-  os << "endif";
-}
+    indent ();
+
+    os << (cmd.in_parallel () ? "endparfor" : "endfor");
+  }
 
-void
-tree_print_code::visit_if_command_list (tree_if_command_list& lst)
-{
-  tree_if_command_list::iterator p = lst.begin ();
+  void
+  tree_print_code::visit_complex_for_command (tree_complex_for_command& cmd)
+  {
+    print_comment_list (cmd.leading_comment ());
+
+    indent ();
 
-  bool first_elt = true;
+    os << "for [";
+    nesting.push ('[');
+
+    tree_argument_list *lhs = cmd.left_hand_side ();
+
+    if (lhs)
+      lhs->accept (*this);
 
-  while (p != lst.end ())
-    {
-      tree_if_clause *elt = *p++;
+    nesting.pop ();
+    os << "] = ";
+
+    tree_expression *expr = cmd.control_expr ();
+
+    if (expr)
+      expr->accept (*this);
+
+    newline ();
 
-      if (elt)
-        {
-          if (! first_elt)
-            {
-              print_indented_comment (elt->leading_comment ());
+    tree_statement_list *list = cmd.body ();
+
+    if (list)
+      {
+        increment_indent_level ();
+
+        list->accept (*this);
+
+        decrement_indent_level ();
+      }
+
+    print_indented_comment (cmd.trailing_comment ());
 
-              indent ();
+    indent ();
+
+    os << "endfor";
+  }
+
+  void
+  tree_print_code::visit_octave_user_script (octave_user_script& fcn)
+  {
+    reset ();
 
-              if (elt->is_else_clause ())
-                os << "else";
-              else
-                os << "elseif ";
-            }
+    tree_statement_list *cmd_list = fcn.body ();
+
+    if (cmd_list)
+      cmd_list->accept (*this);
+  }
 
-          elt->accept (*this);
-        }
+  void
+  tree_print_code::visit_octave_user_function (octave_user_function& fcn)
+  {
+    reset ();
+
+    visit_octave_user_function_header (fcn);
 
-      first_elt = false;
-    }
-}
+    tree_statement_list *cmd_list = fcn.body ();
+
+    if (cmd_list)
+      {
+        increment_indent_level ();
+
+        cmd_list->accept (*this);
 
-void
-tree_print_code::visit_index_expression (tree_index_expression& expr)
-{
-  indent ();
+        // endfunction will decrement the indent level.
+      }
+
+    visit_octave_user_function_trailer (fcn);
+  }
+
+  void
+  tree_print_code::visit_octave_user_function_header (octave_user_function& fcn)
+  {
+    octave_comment_list *leading_comment = fcn.leading_comment ();
 
-  print_parens (expr, "(");
+    if (leading_comment)
+      {
+        print_comment_list (leading_comment);
+        newline ();
+      }
 
-  tree_expression *e = expr.expression ();
+    indent ();
+
+    os << "function ";
+
+    tree_parameter_list *ret_list = fcn.return_list ();
 
-  if (e)
-    e->accept (*this);
+    if (ret_list)
+      {
+        bool takes_var_return = fcn.takes_var_return ();
+
+        int len = ret_list->length ();
 
-  std::list<tree_argument_list *> arg_lists = expr.arg_lists ();
-  std::string type_tags = expr.type_tags ();
-  std::list<string_vector> arg_names = expr.arg_names ();
+        if (len > 1 || takes_var_return)
+          {
+            os << "[";
+            nesting.push ('[');
+          }
+
+        ret_list->accept (*this);
 
-  int n = type_tags.length ();
-
-  std::list<tree_argument_list *>::iterator p_arg_lists = arg_lists.begin ();
-  std::list<string_vector>::iterator p_arg_names = arg_names.begin ();
+        if (takes_var_return)
+          {
+            if (len > 0)
+              os << ", ";
 
-  for (int i = 0; i < n; i++)
-    {
-      switch (type_tags[i])
-        {
-        case '(':
+            os << "varargout";
+          }
+
+        if (len > 1 || takes_var_return)
           {
-            char nc = nesting.top ();
-            if ((nc == '[' || nc == '{') && expr.paren_count () == 0)
-              os << "(";
-            else
-              os << " (";
+            nesting.pop ();
+            os << "]";
+          }
+
+        os << " = ";
+      }
+
+    std::string fcn_name = fcn.name ();
+
+    os << (fcn_name.empty () ? std::string ("(empty)") : fcn_name) << " ";
+
+    tree_parameter_list *param_list = fcn.parameter_list ();
+
+    if (param_list)
+      {
+        bool takes_varargs = fcn.takes_varargs ();
+
+        int len = param_list->length ();
+
+        if (len > 0 || takes_varargs)
+          {
+            os << "(";
             nesting.push ('(');
+          }
 
-            tree_argument_list *l = *p_arg_lists;
-            if (l)
-              l->accept (*this);
+        param_list->accept (*this);
 
+        if (takes_varargs)
+          {
+            if (len > 0)
+              os << ", ";
+
+            os << "varargin";
+          }
+
+        if (len > 0 || takes_varargs)
+          {
             nesting.pop ();
             os << ")";
-          }
-          break;
-
-        case '{':
-          {
-            char nc = nesting.top ();
-            if ((nc == '[' || nc == '{') && expr.paren_count () == 0)
-              os << "{";
-            else
-              os << " {";
-            // We only care about whitespace inside [] and {} when we
-            // are defining matrix and cell objects, not when indexing.
-            nesting.push ('(');
-
-            tree_argument_list *l = *p_arg_lists;
-            if (l)
-              l->accept (*this);
-
-            nesting.pop ();
-            os << "}";
+            newline ();
           }
-          break;
-
-        case '.':
-          {
-            string_vector nm = *p_arg_names;
-            assert (nm.numel () == 1);
-            os << "." << nm(0);
-          }
-          break;
-
-        default:
-          panic_impossible ();
-        }
-
-      p_arg_lists++;
-      p_arg_names++;
-    }
-
-  print_parens (expr, ")");
-}
+      }
+    else
+      {
+        os << "()";
+        newline ();
+      }
+  }
 
-void
-tree_print_code::visit_matrix (tree_matrix& lst)
-{
-  indent ();
-
-  print_parens (lst, "(");
-
-  os << "[";
-  nesting.push ('[');
-
-  tree_matrix::iterator p = lst.begin ();
-
-  while (p != lst.end ())
-    {
-      tree_argument_list *elt = *p++;
-
-      if (elt)
-        {
-          elt->accept (*this);
+  void
+  tree_print_code::visit_octave_user_function_trailer (octave_user_function& fcn)
+  {
+    print_indented_comment (fcn.trailing_comment ());
 
-          if (p != lst.end ())
-            os << "; ";
-        }
-    }
-
-  nesting.pop ();
-  os << "]";
-
-  print_parens (lst, ")");
-}
-
-void
-tree_print_code::visit_cell (tree_cell& lst)
-{
-  indent ();
-
-  print_parens (lst, "(");
-
-  os << "{";
-  nesting.push ('{');
-
-  tree_cell::iterator p = lst.begin ();
+    newline ();
+  }
 
-  while (p != lst.end ())
-    {
-      tree_argument_list *elt = *p++;
-
-      if (elt)
-        {
-          elt->accept (*this);
-
-          if (p != lst.end ())
-            os << "; ";
-        }
-    }
-
-  nesting.pop ();
-  os << "}";
-
-  print_parens (lst, ")");
-}
+  void
+  tree_print_code::visit_function_def (tree_function_def& fdef)
+  {
+    indent ();
 
-void
-tree_print_code::visit_multi_assignment (tree_multi_assignment& expr)
-{
-  indent ();
-
-  print_parens (expr, "(");
-
-  tree_argument_list *lhs = expr.left_hand_side ();
+    octave_value fcn = fdef.function ();
 
-  if (lhs)
-    {
-      int len = lhs->length ();
-
-      if (len > 1)
-        {
-          os << "[";
-          nesting.push ('[');
-        }
-
-      lhs->accept (*this);
+    octave_function *f = fcn.function_value ();
 
-      if (len > 1)
-        {
-          nesting.pop ();
-          os << "]";
-        }
-    }
-
-  os << " " << expr.oper () << " ";
-
-  tree_expression *rhs = expr.right_hand_side ();
-
-  if (rhs)
-    rhs->accept (*this);
-
-  print_parens (expr, ")");
-}
-
-void
-tree_print_code::visit_no_op_command (tree_no_op_command& cmd)
-{
-  if (cmd.is_end_of_fcn_or_script () && curr_print_indent_level > 1)
-    decrement_indent_level ();
-
-  indent ();
+    if (f)
+      f->accept (*this);
+  }
 
-  os << cmd.original_command ();
-}
-
-void
-tree_print_code::visit_constant (tree_constant& val)
-{
-  indent ();
-
-  print_parens (val, "(");
-
-  val.print_raw (os, true, print_original_text);
+  void
+  tree_print_code::visit_identifier (tree_identifier& id)
+  {
+    indent ();
 
-  print_parens (val, ")");
-}
-
-void
-tree_print_code::visit_fcn_handle (tree_fcn_handle& fh)
-{
-  indent ();
-
-  print_parens (fh, "(");
-
-  fh.print_raw (os, true, print_original_text);
-
-  print_parens (fh, ")");
-}
+    print_parens (id, "(");
 
-void
-tree_print_code::visit_funcall (tree_funcall& fc)
-{
-  indent ();
-
-  print_parens (fc, "(");
-
-  fc.print_raw (os, true, print_original_text);
-
-  print_parens (fc, ")");
-}
-
-void
-tree_print_code::visit_parameter_list (tree_parameter_list& lst)
-{
-  tree_parameter_list::iterator p = lst.begin ();
-
-  while (p != lst.end ())
-    {
-      tree_decl_elt *elt = *p++;
+    std::string nm = id.name ();
+    os << (nm.empty () ? std::string ("(empty)") : nm);
 
-      if (elt)
-        {
-          elt->accept (*this);
-
-          if (p != lst.end ())
-            os << ", ";
-        }
-    }
-}
-
-void
-tree_print_code::visit_postfix_expression (tree_postfix_expression& expr)
-{
-  indent ();
-
-  print_parens (expr, "(");
-
-  tree_expression *e = expr.operand ();
-
-  if (e)
-    e->accept (*this);
+    print_parens (id, ")");
+  }
 
-  os << expr.oper ();
-
-  print_parens (expr, ")");
-}
-
-void
-tree_print_code::visit_prefix_expression (tree_prefix_expression& expr)
-{
-  indent ();
-
-  print_parens (expr, "(");
-
-  os << expr.oper ();
-
-  tree_expression *e = expr.operand ();
-
-  if (e)
-    e->accept (*this);
+  void
+  tree_print_code::visit_if_clause (tree_if_clause& cmd)
+  {
+    tree_expression *expr = cmd.condition ();
 
-  print_parens (expr, ")");
-}
-
-void
-tree_print_code::visit_return_command (tree_return_command&)
-{
-  indent ();
-
-  os << "return";
-}
+    if (expr)
+      expr->accept (*this);
 
-void
-tree_print_code::visit_return_list (tree_return_list& lst)
-{
-  tree_return_list::iterator p = lst.begin ();
+    newline ();
 
-  while (p != lst.end ())
-    {
-      tree_index_expression *elt = *p++;
-
-      if (elt)
-        {
-          elt->accept (*this);
+    tree_statement_list *list = cmd.commands ();
 
-          if (p != lst.end ())
-            os << ", ";
-        }
-    }
-}
-
-void
-tree_print_code::visit_simple_assignment (tree_simple_assignment& expr)
-{
-  indent ();
-
-  print_parens (expr, "(");
-
-  tree_expression *lhs = expr.left_hand_side ();
-
-  if (lhs)
-    lhs->accept (*this);
-
-  os << " " << expr.oper () << " ";
-
-  tree_expression *rhs = expr.right_hand_side ();
+    if (list)
+      {
+        increment_indent_level ();
 
-  if (rhs)
-    rhs->accept (*this);
-
-  print_parens (expr, ")");
-}
-
-void
-tree_print_code::visit_statement (tree_statement& stmt)
-{
-  print_comment_list (stmt.comment_text ());
+        list->accept (*this);
 
-  tree_command *cmd = stmt.command ();
-
-  if (cmd)
-    {
-      cmd->accept (*this);
-
-      newline ();
-    }
-  else
-    {
-      tree_expression *expr = stmt.expression ();
+        decrement_indent_level ();
+      }
+  }
 
-      if (expr)
-        {
-          expr->accept (*this);
-
-          if (! stmt.print_result ())
-            {
-              os << ";";
-              newline (" ");
-            }
-          else
-            newline ();
-        }
-    }
-}
-
-void
-tree_print_code::visit_statement_list (tree_statement_list& lst)
-{
-  for (tree_statement* elt : lst)
-    {
-      if (elt)
-        elt->accept (*this);
-    }
-}
+  void
+  tree_print_code::visit_if_command (tree_if_command& cmd)
+  {
+    print_comment_list (cmd.leading_comment ());
 
-void
-tree_print_code::visit_switch_case (tree_switch_case& cs)
-{
-  print_comment_list (cs.leading_comment ());
+    indent ();
 
-  indent ();
-
-  if (cs.is_default_case ())
-    os << "otherwise";
-  else
-    os << "case ";
+    os << "if ";
 
-  tree_expression *label = cs.case_label ();
-
-  if (label)
-    label->accept (*this);
-
-  newline ();
+    tree_if_command_list *list = cmd.cmd_list ();
 
-  tree_statement_list *list = cs.commands ();
-
-  if (list)
-    {
-      increment_indent_level ();
-
+    if (list)
       list->accept (*this);
 
-      newline ();
+    print_indented_comment (cmd.trailing_comment ());
+
+    indent ();
+
+    os << "endif";
+  }
+
+  void
+  tree_print_code::visit_if_command_list (tree_if_command_list& lst)
+  {
+    tree_if_command_list::iterator p = lst.begin ();
 
-      decrement_indent_level ();
-    }
-}
+    bool first_elt = true;
+
+    while (p != lst.end ())
+      {
+        tree_if_clause *elt = *p++;
+
+        if (elt)
+          {
+            if (! first_elt)
+              {
+                print_indented_comment (elt->leading_comment ());
+
+                indent ();
 
-void
-tree_print_code::visit_switch_case_list (tree_switch_case_list& lst)
-{
-  tree_switch_case_list::iterator p = lst.begin ();
+                if (elt->is_else_clause ())
+                  os << "else";
+                else
+                  os << "elseif ";
+              }
+
+            elt->accept (*this);
+          }
+
+        first_elt = false;
+      }
+  }
 
-  while (p != lst.end ())
-    {
-      tree_switch_case *elt = *p++;
+  void
+  tree_print_code::visit_index_expression (tree_index_expression& expr)
+  {
+    indent ();
+
+    print_parens (expr, "(");
 
-      if (elt)
-        elt->accept (*this);
-    }
-}
+    tree_expression *e = expr.expression ();
+
+    if (e)
+      e->accept (*this);
+
+    std::list<tree_argument_list *> arg_lists = expr.arg_lists ();
+    std::string type_tags = expr.type_tags ();
+    std::list<string_vector> arg_names = expr.arg_names ();
 
-void
-tree_print_code::visit_switch_command (tree_switch_command& cmd)
-{
-  print_comment_list (cmd.leading_comment ());
+    int n = type_tags.length ();
 
-  indent ();
+    std::list<tree_argument_list *>::iterator p_arg_lists = arg_lists.begin ();
+    std::list<string_vector>::iterator p_arg_names = arg_names.begin ();
 
-  os << "switch ";
+    for (int i = 0; i < n; i++)
+      {
+        switch (type_tags[i])
+          {
+          case '(':
+            {
+              char nc = nesting.top ();
+              if ((nc == '[' || nc == '{') && expr.paren_count () == 0)
+                os << "(";
+              else
+                os << " (";
+              nesting.push ('(');
 
-  tree_expression *expr = cmd.switch_value ();
+              tree_argument_list *l = *p_arg_lists;
+              if (l)
+                l->accept (*this);
 
-  if (expr)
-    expr->accept (*this);
+              nesting.pop ();
+              os << ")";
+            }
+            break;
 
-  newline ();
-
-  tree_switch_case_list *list = cmd.case_list ();
+          case '{':
+            {
+              char nc = nesting.top ();
+              if ((nc == '[' || nc == '{') && expr.paren_count () == 0)
+                os << "{";
+              else
+                os << " {";
+              // We only care about whitespace inside [] and {} when we
+              // are defining matrix and cell objects, not when indexing.
+              nesting.push ('(');
 
-  if (list)
-    {
-      increment_indent_level ();
+              tree_argument_list *l = *p_arg_lists;
+              if (l)
+                l->accept (*this);
 
-      list->accept (*this);
+              nesting.pop ();
+              os << "}";
+            }
+            break;
 
-      decrement_indent_level ();
-    }
-
-  print_indented_comment (cmd.leading_comment ());
+          case '.':
+            {
+              string_vector nm = *p_arg_names;
+              assert (nm.numel () == 1);
+              os << "." << nm(0);
+            }
+            break;
 
-  indent ();
+          default:
+            panic_impossible ();
+          }
 
-  os << "endswitch";
-}
+        p_arg_lists++;
+        p_arg_names++;
+      }
+
+    print_parens (expr, ")");
+  }
 
-void
-tree_print_code::visit_try_catch_command (tree_try_catch_command& cmd)
-{
-  print_comment_list (cmd.leading_comment ());
+  void
+  tree_print_code::visit_matrix (tree_matrix& lst)
+  {
+    indent ();
+
+    print_parens (lst, "(");
 
-  indent ();
+    os << "[";
+    nesting.push ('[');
+
+    tree_matrix::iterator p = lst.begin ();
+
+    while (p != lst.end ())
+      {
+        tree_argument_list *elt = *p++;
 
-  os << "try";
+        if (elt)
+          {
+            elt->accept (*this);
 
-  newline ();
+            if (p != lst.end ())
+              os << "; ";
+          }
+      }
+
+    nesting.pop ();
+    os << "]";
+
+    print_parens (lst, ")");
+  }
 
-  tree_statement_list *try_code = cmd.body ();
-  tree_identifier *expr_id = cmd.identifier ();
+  void
+  tree_print_code::visit_cell (tree_cell& lst)
+  {
+    indent ();
+
+    print_parens (lst, "(");
 
-  if (try_code)
-    {
-      increment_indent_level ();
+    os << "{";
+    nesting.push ('{');
 
-      try_code->accept (*this);
+    tree_cell::iterator p = lst.begin ();
+
+    while (p != lst.end ())
+      {
+        tree_argument_list *elt = *p++;
 
-      decrement_indent_level ();
-    }
+        if (elt)
+          {
+            elt->accept (*this);
+
+            if (p != lst.end ())
+              os << "; ";
+          }
+      }
+
+    nesting.pop ();
+    os << "}";
 
-  print_indented_comment (cmd.middle_comment ());
+    print_parens (lst, ")");
+  }
+
+  void
+  tree_print_code::visit_multi_assignment (tree_multi_assignment& expr)
+  {
+    indent ();
 
-  indent ();
+    print_parens (expr, "(");
+
+    tree_argument_list *lhs = expr.left_hand_side ();
 
-  os << "catch";
+    if (lhs)
+      {
+        int len = lhs->length ();
 
-  if (expr_id)
-    {
-      os << " ";
-      expr_id->accept (*this);
-    }
+        if (len > 1)
+          {
+            os << "[";
+            nesting.push ('[');
+          }
 
-  newline ();
+        lhs->accept (*this);
+
+        if (len > 1)
+          {
+            nesting.pop ();
+            os << "]";
+          }
+      }
 
-  tree_statement_list *catch_code = cmd.cleanup ();
+    os << " " << expr.oper () << " ";
+
+    tree_expression *rhs = expr.right_hand_side ();
+
+    if (rhs)
+      rhs->accept (*this);
 
-  if (catch_code)
-    {
-      increment_indent_level ();
+    print_parens (expr, ")");
+  }
 
-      catch_code->accept (*this);
-
+  void
+  tree_print_code::visit_no_op_command (tree_no_op_command& cmd)
+  {
+    if (cmd.is_end_of_fcn_or_script () && curr_print_indent_level > 1)
       decrement_indent_level ();
-    }
+
+    indent ();
 
-  print_indented_comment (cmd.trailing_comment ());
+    os << cmd.original_command ();
+  }
+
+  void
+  tree_print_code::visit_constant (tree_constant& val)
+  {
+    indent ();
 
-  indent ();
+    print_parens (val, "(");
+
+    val.print_raw (os, true, print_original_text);
 
-  os << "end_try_catch";
-}
+    print_parens (val, ")");
+  }
+
+  void
+  tree_print_code::visit_fcn_handle (tree_fcn_handle& fh)
+  {
+    indent ();
 
-void
-tree_print_code::visit_unwind_protect_command (tree_unwind_protect_command& cmd)
-{
-  print_comment_list (cmd.leading_comment ());
+    print_parens (fh, "(");
+
+    fh.print_raw (os, true, print_original_text);
+
+    print_parens (fh, ")");
+  }
+
+  void
+  tree_print_code::visit_funcall (tree_funcall& fc)
+  {
+    indent ();
 
-  indent ();
+    print_parens (fc, "(");
 
-  os << "unwind_protect";
+    fc.print_raw (os, true, print_original_text);
 
-  newline ();
+    print_parens (fc, ")");
+  }
 
-  tree_statement_list *unwind_protect_code = cmd.body ();
+  void
+  tree_print_code::visit_parameter_list (tree_parameter_list& lst)
+  {
+    tree_parameter_list::iterator p = lst.begin ();
 
-  if (unwind_protect_code)
-    {
-      increment_indent_level ();
+    while (p != lst.end ())
+      {
+        tree_decl_elt *elt = *p++;
 
-      unwind_protect_code->accept (*this);
+        if (elt)
+          {
+            elt->accept (*this);
 
-      decrement_indent_level ();
-    }
+            if (p != lst.end ())
+              os << ", ";
+          }
+      }
+  }
 
-  print_indented_comment (cmd.middle_comment ());
+  void
+  tree_print_code::visit_postfix_expression (tree_postfix_expression& expr)
+  {
+    indent ();
 
-  indent ();
+    print_parens (expr, "(");
+
+    tree_expression *e = expr.operand ();
 
-  os << "unwind_protect_cleanup";
+    if (e)
+      e->accept (*this);
 
-  newline ();
+    os << expr.oper ();
 
-  tree_statement_list *cleanup_code = cmd.cleanup ();
+    print_parens (expr, ")");
+  }
 
-  if (cleanup_code)
-    {
-      increment_indent_level ();
+  void
+  tree_print_code::visit_prefix_expression (tree_prefix_expression& expr)
+  {
+    indent ();
+
+    print_parens (expr, "(");
 
-      cleanup_code->accept (*this);
+    os << expr.oper ();
+
+    tree_expression *e = expr.operand ();
 
-      decrement_indent_level ();
-    }
+    if (e)
+      e->accept (*this);
+
+    print_parens (expr, ")");
+  }
 
-  print_indented_comment (cmd.trailing_comment ());
+  void
+  tree_print_code::visit_return_command (tree_return_command&)
+  {
+    indent ();
 
-  indent ();
+    os << "return";
+  }
 
-  os << "end_unwind_protect";
-}
+  void
+  tree_print_code::visit_return_list (tree_return_list& lst)
+  {
+    tree_return_list::iterator p = lst.begin ();
 
-void
-tree_print_code::visit_while_command (tree_while_command& cmd)
-{
-  print_comment_list (cmd.leading_comment ());
+    while (p != lst.end ())
+      {
+        tree_index_expression *elt = *p++;
+
+        if (elt)
+          {
+            elt->accept (*this);
 
-  indent ();
+            if (p != lst.end ())
+              os << ", ";
+          }
+      }
+  }
 
-  os << "while ";
+  void
+  tree_print_code::visit_simple_assignment (tree_simple_assignment& expr)
+  {
+    indent ();
 
-  tree_expression *expr = cmd.condition ();
+    print_parens (expr, "(");
 
-  if (expr)
-    expr->accept (*this);
+    tree_expression *lhs = expr.left_hand_side ();
+
+    if (lhs)
+      lhs->accept (*this);
+
+    os << " " << expr.oper () << " ";
 
-  newline ();
+    tree_expression *rhs = expr.right_hand_side ();
 
-  tree_statement_list *list = cmd.body ();
+    if (rhs)
+      rhs->accept (*this);
+
+    print_parens (expr, ")");
+  }
 
-  if (list)
-    {
-      increment_indent_level ();
+  void
+  tree_print_code::visit_statement (tree_statement& stmt)
+  {
+    print_comment_list (stmt.comment_text ());
 
-      list->accept (*this);
+    tree_command *cmd = stmt.command ();
 
-      decrement_indent_level ();
-    }
+    if (cmd)
+      {
+        cmd->accept (*this);
 
-  print_indented_comment (cmd.trailing_comment ());
+        newline ();
+      }
+    else
+      {
+        tree_expression *expr = stmt.expression ();
 
-  indent ();
+        if (expr)
+          {
+            expr->accept (*this);
 
-  os << "endwhile";
-}
+            if (! stmt.print_result ())
+              {
+                os << ";";
+                newline (" ");
+              }
+            else
+              newline ();
+          }
+      }
+  }
 
-void
-tree_print_code::visit_do_until_command (tree_do_until_command& cmd)
-{
-  print_comment_list (cmd.leading_comment ());
+  void
+  tree_print_code::visit_statement_list (tree_statement_list& lst)
+  {
+    for (tree_statement* elt : lst)
+      {
+        if (elt)
+          elt->accept (*this);
+      }
+  }
 
-  indent ();
+  void
+  tree_print_code::visit_switch_case (tree_switch_case& cs)
+  {
+    print_comment_list (cs.leading_comment ());
 
-  os << "do";
-
-  newline ();
+    indent ();
 
-  tree_statement_list *list = cmd.body ();
+    if (cs.is_default_case ())
+      os << "otherwise";
+    else
+      os << "case ";
+
+    tree_expression *label = cs.case_label ();
+
+    if (label)
+      label->accept (*this);
 
-  if (list)
-    {
-      increment_indent_level ();
+    newline ();
+
+    tree_statement_list *list = cs.commands ();
 
-      list->accept (*this);
+    if (list)
+      {
+        increment_indent_level ();
+
+        list->accept (*this);
+
+        newline ();
 
-      decrement_indent_level ();
-    }
+        decrement_indent_level ();
+      }
+  }
 
-  print_indented_comment (cmd.trailing_comment ());
+  void
+  tree_print_code::visit_switch_case_list (tree_switch_case_list& lst)
+  {
+    tree_switch_case_list::iterator p = lst.begin ();
+
+    while (p != lst.end ())
+      {
+        tree_switch_case *elt = *p++;
 
-  indent ();
+        if (elt)
+          elt->accept (*this);
+      }
+  }
 
-  os << "until ";
+  void
+  tree_print_code::visit_switch_command (tree_switch_command& cmd)
+  {
+    print_comment_list (cmd.leading_comment ());
 
-  tree_expression *expr = cmd.condition ();
+    indent ();
+
+    os << "switch ";
+
+    tree_expression *expr = cmd.switch_value ();
 
-  if (expr)
-    expr->accept (*this);
+    if (expr)
+      expr->accept (*this);
+
+    newline ();
+
+    tree_switch_case_list *list = cmd.case_list ();
+
+    if (list)
+      {
+        increment_indent_level ();
 
-  newline ();
-}
+        list->accept (*this);
+
+        decrement_indent_level ();
+      }
+
+    print_indented_comment (cmd.leading_comment ());
+
+    indent ();
+
+    os << "endswitch";
+  }
 
-void
-tree_print_code::print_fcn_handle_body (tree_statement_list *b)
-{
-  if (b)
-    {
-      assert (b->length () == 1);
+  void
+  tree_print_code::visit_try_catch_command (tree_try_catch_command& cmd)
+  {
+    print_comment_list (cmd.leading_comment ());
+
+    indent ();
+
+    os << "try";
+
+    newline ();
+
+    tree_statement_list *try_code = cmd.body ();
+    tree_identifier *expr_id = cmd.identifier ();
 
-      tree_statement *s = b->front ();
+    if (try_code)
+      {
+        increment_indent_level ();
+
+        try_code->accept (*this);
 
-      if (s)
-        {
-          if (s->is_expression ())
-            {
-              tree_expression *e = s->expression ();
+        decrement_indent_level ();
+      }
+
+    print_indented_comment (cmd.middle_comment ());
+
+    indent ();
+
+    os << "catch";
 
-              if (e)
-                {
-                  suppress_newlines++;
-                  e->accept (*this);
-                  suppress_newlines--;
-                }
-            }
-          else
-            {
-              tree_command *c = s->command ();
+    if (expr_id)
+      {
+        os << " ";
+        expr_id->accept (*this);
+      }
+
+    newline ();
+
+    tree_statement_list *catch_code = cmd.cleanup ();
+
+    if (catch_code)
+      {
+        increment_indent_level ();
+
+        catch_code->accept (*this);
+
+        decrement_indent_level ();
+      }
+
+    print_indented_comment (cmd.trailing_comment ());
+
+    indent ();
+
+    os << "end_try_catch";
+  }
 
-              suppress_newlines++;
-              c->accept (*this);
-              suppress_newlines--;
-            }
-        }
-    }
-}
+  void
+  tree_print_code::visit_unwind_protect_command (tree_unwind_protect_command& cmd)
+  {
+    print_comment_list (cmd.leading_comment ());
+
+    indent ();
+
+    os << "unwind_protect";
+
+    newline ();
+
+    tree_statement_list *unwind_protect_code = cmd.body ();
 
-// Each print_code() function should call this before printing anything.
+    if (unwind_protect_code)
+      {
+        increment_indent_level ();
+
+        unwind_protect_code->accept (*this);
 
-void
-tree_print_code::indent (void)
-{
-  assert (curr_print_indent_level >= 0);
+        decrement_indent_level ();
+      }
+
+    print_indented_comment (cmd.middle_comment ());
+
+    indent ();
+
+    os << "unwind_protect_cleanup";
 
-  if (beginning_of_line)
-    {
-      os << prefix;
+    newline ();
+
+    tree_statement_list *cleanup_code = cmd.cleanup ();
 
-      os << std::string (curr_print_indent_level, ' ');
+    if (cleanup_code)
+      {
+        increment_indent_level ();
+
+        cleanup_code->accept (*this);
+
+        decrement_indent_level ();
+      }
 
-      beginning_of_line = false;
-    }
-}
+    print_indented_comment (cmd.trailing_comment ());
+
+    indent ();
+
+    os << "end_unwind_protect";
+  }
 
-// All print_code() functions should use this to print new lines.
+  void
+  tree_print_code::visit_while_command (tree_while_command& cmd)
+  {
+    print_comment_list (cmd.leading_comment ());
+
+    indent ();
 
-void
-tree_print_code::newline (const char *alt_txt)
-{
-  if (suppress_newlines)
-    os << alt_txt;
-  else
-    {
-      // Print prefix for blank lines.
-      indent ();
+    os << "while ";
+
+    tree_expression *expr = cmd.condition ();
+
+    if (expr)
+      expr->accept (*this);
+
+    newline ();
+
+    tree_statement_list *list = cmd.body ();
 
-      os << "\n";
+    if (list)
+      {
+        increment_indent_level ();
+
+        list->accept (*this);
 
-      beginning_of_line = true;
-    }
-}
+        decrement_indent_level ();
+      }
+
+    print_indented_comment (cmd.trailing_comment ());
 
-// For ressetting print_code state.
+    indent ();
+
+    os << "endwhile";
+  }
 
-void
-tree_print_code::reset (void)
-{
-  beginning_of_line = true;
-  curr_print_indent_level = 0;
-  while (nesting.top () != 'n')
-    nesting.pop ();
-}
+  void
+  tree_print_code::visit_do_until_command (tree_do_until_command& cmd)
+  {
+    print_comment_list (cmd.leading_comment ());
+
+    indent ();
+
+    os << "do";
+
+    newline ();
+
+    tree_statement_list *list = cmd.body ();
+
+    if (list)
+      {
+        increment_indent_level ();
+
+        list->accept (*this);
+
+        decrement_indent_level ();
+      }
+
+    print_indented_comment (cmd.trailing_comment ());
 
-void
-tree_print_code::print_parens (const tree_expression& expr, const char *txt)
-{
-  int n = expr.paren_count ();
+    indent ();
+
+    os << "until ";
+
+    tree_expression *expr = cmd.condition ();
+
+    if (expr)
+      expr->accept (*this);
+
+    newline ();
+  }
 
-  for (int i = 0; i < n; i++)
-    os << txt;
-}
+  void
+  tree_print_code::print_fcn_handle_body (tree_statement_list *b)
+  {
+    if (b)
+      {
+        assert (b->length () == 1);
 
-void
-tree_print_code::print_comment_elt (const octave_comment_elt& elt)
-{
-  bool printed_something = false;
+        tree_statement *s = b->front ();
 
-  bool prev_char_was_newline = false;
+        if (s)
+          {
+            if (s->is_expression ())
+              {
+                tree_expression *e = s->expression ();
 
-  std::string comment = elt.text ();
-
-  size_t len = comment.length ();
+                if (e)
+                  {
+                    suppress_newlines++;
+                    e->accept (*this);
+                    suppress_newlines--;
+                  }
+              }
+            else
+              {
+                tree_command *c = s->command ();
 
-  size_t i = 0;
+                suppress_newlines++;
+                c->accept (*this);
+                suppress_newlines--;
+              }
+          }
+      }
+  }
 
-  while (i < len && comment[i++] == '\n')
-    ; // Skip leading new lines.
-  i--;
+  // Each print_code() function should call this before printing anything.
+
+  void
+  tree_print_code::indent (void)
+  {
+    assert (curr_print_indent_level >= 0);
 
-  while (i < len)
-    {
-      char c = comment[i++];
+    if (beginning_of_line)
+      {
+        os << prefix;
+
+        os << std::string (curr_print_indent_level, ' ');
+
+        beginning_of_line = false;
+      }
+  }
+
+  // All print_code() functions should use this to print new lines.
 
-      if (c == '\n')
-        {
-          if (prev_char_was_newline)
-            {
-              printed_something = true;
+  void
+  tree_print_code::newline (const char *alt_txt)
+  {
+    if (suppress_newlines)
+      os << alt_txt;
+    else
+      {
+        // Print prefix for blank lines.
+        indent ();
 
-              indent ();
+        os << "\n";
 
-              os << "##";
-            }
+        beginning_of_line = true;
+      }
+  }
 
-          newline ();
+  // For ressetting print_code state.
 
-          prev_char_was_newline = true;
-        }
-      else
-        {
-          if (beginning_of_line)
-            {
-              printed_something = true;
+  void
+  tree_print_code::reset (void)
+  {
+    beginning_of_line = true;
+    curr_print_indent_level = 0;
+    while (nesting.top () != 'n')
+      nesting.pop ();
+  }
 
-              indent ();
+  void
+  tree_print_code::print_parens (const tree_expression& expr, const char *txt)
+  {
+    int n = expr.paren_count ();
 
-              os << "##";
+    for (int i = 0; i < n; i++)
+      os << txt;
+  }
+
+  void
+  tree_print_code::print_comment_elt (const octave_comment_elt& elt)
+  {
+    bool printed_something = false;
+
+    bool prev_char_was_newline = false;
 
-              if (! (isspace (c) || c == '!'))
-                os << " ";
-            }
+    std::string comment = elt.text ();
+
+    size_t len = comment.length ();
 
-          os << static_cast<char> (c);
+    size_t i = 0;
+
+    while (i < len && comment[i++] == '\n')
+      ; // Skip leading new lines.
+    i--;
 
-          prev_char_was_newline = false;
-        }
-    }
+    while (i < len)
+      {
+        char c = comment[i++];
 
-  if (printed_something && ! beginning_of_line)
-    newline ();
-}
+        if (c == '\n')
+          {
+            if (prev_char_was_newline)
+              {
+                printed_something = true;
+
+                indent ();
+
+                os << "##";
+              }
+
+            newline ();
 
-void
-tree_print_code::print_comment_list (octave_comment_list *comment_list)
-{
-  if (comment_list)
-    {
-      octave_comment_list::iterator p = comment_list->begin ();
+            prev_char_was_newline = true;
+          }
+        else
+          {
+            if (beginning_of_line)
+              {
+                printed_something = true;
+
+                indent ();
+
+                os << "##";
 
-      while (p != comment_list->end ())
-        {
-          octave_comment_elt elt = *p++;
+                if (! (isspace (c) || c == '!'))
+                  os << " ";
+              }
+
+            os << static_cast<char> (c);
 
-          print_comment_elt (elt);
+            prev_char_was_newline = false;
+          }
+      }
+
+    if (printed_something && ! beginning_of_line)
+      newline ();
+  }
 
-          if (p != comment_list->end ())
-            newline ();
-        }
-    }
-}
+  void
+  tree_print_code::print_comment_list (octave_comment_list *comment_list)
+  {
+    if (comment_list)
+      {
+        octave_comment_list::iterator p = comment_list->begin ();
+
+        while (p != comment_list->end ())
+          {
+            octave_comment_elt elt = *p++;
+
+            print_comment_elt (elt);
 
-void
-tree_print_code::print_indented_comment (octave_comment_list *comment_list)
-{
-  increment_indent_level ();
+            if (p != comment_list->end ())
+              newline ();
+          }
+      }
+  }
 
-  print_comment_list (comment_list);
+  void
+  tree_print_code::print_indented_comment (octave_comment_list *comment_list)
+  {
+    increment_indent_level ();
 
-  decrement_indent_level ();
+    print_comment_list (comment_list);
+
+    decrement_indent_level ();
+  }
 }
-
diff --git a/libinterp/parse-tree/pt-pr-code.h b/libinterp/parse-tree/pt-pr-code.h
--- a/libinterp/parse-tree/pt-pr-code.h
+++ b/libinterp/parse-tree/pt-pr-code.h
@@ -26,176 +26,184 @@ along with Octave; see the file COPYING.
 #include "octave-config.h"
 
 #include <stack>
 #include <string>
 
 #include "comment-list.h"
 #include "pt-walk.h"
 
-class tree_decl_command;
-class tree_expression;
-
-// How to print the code that the parse trees represent.
-
-class
-tree_print_code : public tree_walker
+namespace octave
 {
-public:
+  class tree_decl_command;
+  class tree_expression;
 
-  tree_print_code (std::ostream& os_arg,
-                   const std::string& pfx = "",
-                   bool pr_orig_txt = true)
-    : os (os_arg), prefix (pfx), nesting (),
-      print_original_text (pr_orig_txt),
-      curr_print_indent_level (0), beginning_of_line (true),
-      suppress_newlines (0)
+  // How to print the code that the parse trees represent.
+
+  class tree_print_code : public tree_walker
   {
-    // For "none".
-    nesting.push ('n');
-  }
+  public:
 
-  // No copying!
+    tree_print_code (std::ostream& os_arg,
+                     const std::string& pfx = "",
+                     bool pr_orig_txt = true)
+      : os (os_arg), prefix (pfx), nesting (),
+        print_original_text (pr_orig_txt),
+        curr_print_indent_level (0), beginning_of_line (true),
+        suppress_newlines (0)
+    {
+      // For "none".
+      nesting.push ('n');
+    }
 
-  tree_print_code (const tree_print_code&) = delete;
-
-  tree_print_code& operator = (const tree_print_code&) = delete;
+    // No copying!
 
-  ~tree_print_code (void) = default;
+    tree_print_code (const tree_print_code&) = delete;
+
+    tree_print_code& operator = (const tree_print_code&) = delete;
 
-  void visit_anon_fcn_handle (tree_anon_fcn_handle&);
+    ~tree_print_code (void) = default;
 
-  void visit_argument_list (tree_argument_list&);
+    void visit_anon_fcn_handle (tree_anon_fcn_handle&);
 
-  void visit_binary_expression (tree_binary_expression&);
+    void visit_argument_list (tree_argument_list&);
+
+    void visit_binary_expression (tree_binary_expression&);
 
-  void visit_break_command (tree_break_command&);
+    void visit_break_command (tree_break_command&);
 
-  void visit_colon_expression (tree_colon_expression&);
+    void visit_colon_expression (tree_colon_expression&);
 
-  void visit_continue_command (tree_continue_command&);
+    void visit_continue_command (tree_continue_command&);
 
-  void visit_global_command (tree_global_command&);
+    void visit_global_command (tree_global_command&);
 
-  void visit_persistent_command (tree_persistent_command&);
+    void visit_persistent_command (tree_persistent_command&);
 
-  void visit_decl_elt (tree_decl_elt&);
+    void visit_decl_elt (tree_decl_elt&);
 
-  void visit_decl_init_list (tree_decl_init_list&);
+    void visit_decl_init_list (tree_decl_init_list&);
 
-  void visit_simple_for_command (tree_simple_for_command&);
+    void visit_simple_for_command (tree_simple_for_command&);
 
-  void visit_complex_for_command (tree_complex_for_command&);
+    void visit_complex_for_command (tree_complex_for_command&);
+
+    void visit_octave_user_script (octave_user_script&);
 
-  void visit_octave_user_script (octave_user_script&);
+    void visit_octave_user_function (octave_user_function&);
 
-  void visit_octave_user_function (octave_user_function&);
+    void visit_octave_user_function_header (octave_user_function&);
 
-  void visit_octave_user_function_header (octave_user_function&);
+    void visit_octave_user_function_trailer (octave_user_function&);
 
-  void visit_octave_user_function_trailer (octave_user_function&);
+    void visit_function_def (tree_function_def&);
 
-  void visit_function_def (tree_function_def&);
+    void visit_identifier (tree_identifier&);
 
-  void visit_identifier (tree_identifier&);
+    void visit_if_clause (tree_if_clause&);
 
-  void visit_if_clause (tree_if_clause&);
+    void visit_if_command (tree_if_command&);
 
-  void visit_if_command (tree_if_command&);
+    void visit_if_command_list (tree_if_command_list&);
 
-  void visit_if_command_list (tree_if_command_list&);
+    void visit_index_expression (tree_index_expression&);
 
-  void visit_index_expression (tree_index_expression&);
+    void visit_matrix (tree_matrix&);
 
-  void visit_matrix (tree_matrix&);
+    void visit_cell (tree_cell&);
 
-  void visit_cell (tree_cell&);
+    void visit_multi_assignment (tree_multi_assignment&);
 
-  void visit_multi_assignment (tree_multi_assignment&);
+    void visit_no_op_command (tree_no_op_command&);
 
-  void visit_no_op_command (tree_no_op_command&);
+    void visit_constant (tree_constant&);
 
-  void visit_constant (tree_constant&);
+    void visit_fcn_handle (tree_fcn_handle&);
 
-  void visit_fcn_handle (tree_fcn_handle&);
+    void visit_funcall (tree_funcall&);
 
-  void visit_funcall (tree_funcall&);
+    void visit_parameter_list (tree_parameter_list&);
 
-  void visit_parameter_list (tree_parameter_list&);
+    void visit_postfix_expression (tree_postfix_expression&);
 
-  void visit_postfix_expression (tree_postfix_expression&);
+    void visit_prefix_expression (tree_prefix_expression&);
 
-  void visit_prefix_expression (tree_prefix_expression&);
+    void visit_return_command (tree_return_command&);
 
-  void visit_return_command (tree_return_command&);
+    void visit_return_list (tree_return_list&);
+
+    void visit_simple_assignment (tree_simple_assignment&);
 
-  void visit_return_list (tree_return_list&);
+    void visit_statement (tree_statement&);
 
-  void visit_simple_assignment (tree_simple_assignment&);
+    void visit_statement_list (tree_statement_list&);
 
-  void visit_statement (tree_statement&);
+    void visit_switch_case (tree_switch_case&);
 
-  void visit_statement_list (tree_statement_list&);
+    void visit_switch_case_list (tree_switch_case_list&);
 
-  void visit_switch_case (tree_switch_case&);
+    void visit_switch_command (tree_switch_command&);
 
-  void visit_switch_case_list (tree_switch_case_list&);
+    void visit_try_catch_command (tree_try_catch_command&);
 
-  void visit_switch_command (tree_switch_command&);
+    void visit_unwind_protect_command (tree_unwind_protect_command&);
 
-  void visit_try_catch_command (tree_try_catch_command&);
+    void visit_while_command (tree_while_command&);
 
-  void visit_unwind_protect_command (tree_unwind_protect_command&);
+    void visit_do_until_command (tree_do_until_command&);
 
-  void visit_while_command (tree_while_command&);
+    void print_fcn_handle_body (tree_statement_list *);
 
-  void visit_do_until_command (tree_do_until_command&);
+  private:
 
-  void print_fcn_handle_body (tree_statement_list *);
+    std::ostream& os;
 
-private:
+    std::string prefix;
 
-  std::ostream& os;
+    std::stack<char> nesting;
 
-  std::string prefix;
-
-  std::stack<char> nesting;
+    bool print_original_text;
 
-  bool print_original_text;
+    // Current indentation.
+    int curr_print_indent_level;
 
-  // Current indentation.
-  int curr_print_indent_level;
+    // TRUE means we are at the beginning of a line.
+    bool beginning_of_line;
 
-  // TRUE means we are at the beginning of a line.
-  bool beginning_of_line;
+    // Nonzero means we are not printing newlines and indenting.
+    int suppress_newlines;
 
-  // Nonzero means we are not printing newlines and indenting.
-  int suppress_newlines;
+    void do_decl_command (tree_decl_command& cmd);
 
-  void do_decl_command (tree_decl_command& cmd);
+    void reset_indent_level (void) { curr_print_indent_level = 0; }
+
+    void increment_indent_level (void) { curr_print_indent_level += 2; }
 
-  void reset_indent_level (void) { curr_print_indent_level = 0; }
+    void decrement_indent_level (void) { curr_print_indent_level -= 2; }
 
-  void increment_indent_level (void) { curr_print_indent_level += 2; }
+    void newline (const char *alt_txt = ", ");
 
-  void decrement_indent_level (void) { curr_print_indent_level -= 2; }
+    void indent (void);
 
-  void newline (const char *alt_txt = ", ");
+    void reset (void);
 
-  void indent (void);
+    void print_parens (const tree_expression& expr, const char *txt);
 
-  void reset (void);
+    void print_comment_list (octave_comment_list *comment_list);
 
-  void print_parens (const tree_expression& expr, const char *txt);
+    void print_comment_elt (const octave_comment_elt& comment_elt);
 
-  void print_comment_list (octave_comment_list *comment_list);
+    void print_indented_comment (octave_comment_list *comment_list);
 
-  void print_comment_elt (const octave_comment_elt& comment_elt);
+    // Must create with an output stream!
 
-  void print_indented_comment (octave_comment_list *comment_list);
+    tree_print_code (void);
+  };
+}
 
-  // Must create with an output stream!
+#if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
 
-  tree_print_code (void);
-};
+OCTAVE_DEPRECATED ("use 'octave::tree_print_code' instead")
+typedef octave::tree_print_code tree_print_code;
 
 #endif
 
+#endif
diff --git a/libinterp/parse-tree/pt-select.cc b/libinterp/parse-tree/pt-select.cc
--- a/libinterp/parse-tree/pt-select.cc
+++ b/libinterp/parse-tree/pt-select.cc
@@ -30,177 +30,179 @@ along with Octave; see the file COPYING.
 #include "pt-cmd.h"
 #include "pt-exp.h"
 #include "pt-select.h"
 #include "pt-stmt.h"
 #include "pt-walk.h"
 #include "Cell.h"
 #include "ov-typeinfo.h"
 
-// If clauses.
-
-tree_if_clause::~tree_if_clause (void)
-{
-  delete expr;
-  delete list;
-  delete lead_comm;
-}
-
-tree_if_clause *
-tree_if_clause::dup (symbol_table::scope_id scope,
-                     symbol_table::context_id context) const
-{
-  return new tree_if_clause (expr ? expr->dup (scope, context) : 0,
-                             list ? list->dup (scope, context) : 0,
-                             lead_comm ? lead_comm->dup () : 0);
-}
-
-void
-tree_if_clause::accept (tree_walker& tw)
+namespace octave
 {
-  tw.visit_if_clause (*this);
-}
-
-// List of if commands.
-
-tree_if_command_list *
-tree_if_command_list::dup (symbol_table::scope_id scope,
-                           symbol_table::context_id context) const
-{
-  tree_if_command_list *new_icl = new tree_if_command_list ();
-
-  for (const tree_if_clause* elt : *this)
-    new_icl->append (elt ? elt->dup (scope, context) : 0);
-
-  return new_icl;
-}
-
-void
-tree_if_command_list::accept (tree_walker& tw)
-{
-  tw.visit_if_command_list (*this);
-}
-
-// If.
-
-tree_if_command::~tree_if_command (void)
-{
-  delete list;
-  delete lead_comm;
-  delete trail_comm;
-}
+  // If clauses.
 
-tree_command *
-tree_if_command::dup (symbol_table::scope_id scope,
-                      symbol_table::context_id context) const
-{
-  return new tree_if_command (list ? list->dup (scope, context) : 0,
-                              lead_comm ? lead_comm->dup () : 0,
-                              trail_comm ? trail_comm->dup () : 0,
-                              line (), column ());
-}
-
-void
-tree_if_command::accept (tree_walker& tw)
-{
-  tw.visit_if_command (*this);
-}
-
-// Switch cases.
-
-tree_switch_case::~tree_switch_case (void)
-{
-  delete label;
-  delete list;
-  delete lead_comm;
-}
-
-bool
-tree_switch_case::label_matches (const octave_value& val)
-{
-  octave_value label_value = label->rvalue1 ();
+  tree_if_clause::~tree_if_clause (void)
+  {
+    delete expr;
+    delete list;
+    delete lead_comm;
+  }
 
-  if (label_value.is_defined ())
-    {
-      if (label_value.is_cell ())
-        {
-          Cell cell (label_value.cell_value ());
-
-          for (octave_idx_type i = 0; i < cell.rows (); i++)
-            {
-              for (octave_idx_type j = 0; j < cell.columns (); j++)
-                {
-                  bool match = val.is_equal (cell(i,j));
-
-                  if (match)
-                    return true;
-                }
-            }
-        }
-      else
-        return val.is_equal (label_value);
-    }
-
-  return false;
-}
-
-tree_switch_case *
-tree_switch_case::dup (symbol_table::scope_id scope,
+  tree_if_clause *
+  tree_if_clause::dup (symbol_table::scope_id scope,
                        symbol_table::context_id context) const
-{
-  return new tree_switch_case (label ? label->dup (scope, context) : 0,
+  {
+    return new tree_if_clause (expr ? expr->dup (scope, context) : 0,
                                list ? list->dup (scope, context) : 0,
                                lead_comm ? lead_comm->dup () : 0);
-}
+  }
+
+  void
+  tree_if_clause::accept (tree_walker& tw)
+  {
+    tw.visit_if_clause (*this);
+  }
+
+  // List of if commands.
 
-void
-tree_switch_case::accept (tree_walker& tw)
-{
-  tw.visit_switch_case (*this);
-}
+  tree_if_command_list *
+  tree_if_command_list::dup (symbol_table::scope_id scope,
+                             symbol_table::context_id context) const
+  {
+    tree_if_command_list *new_icl = new tree_if_command_list ();
+
+    for (const tree_if_clause* elt : *this)
+      new_icl->append (elt ? elt->dup (scope, context) : 0);
 
-// List of switch cases.
+    return new_icl;
+  }
+
+  void
+  tree_if_command_list::accept (tree_walker& tw)
+  {
+    tw.visit_if_command_list (*this);
+  }
+
+  // If.
 
-tree_switch_case_list *
-tree_switch_case_list::dup (symbol_table::scope_id scope,
-                            symbol_table::context_id context) const
-{
-  tree_switch_case_list *new_scl = new tree_switch_case_list ();
+  tree_if_command::~tree_if_command (void)
+  {
+    delete list;
+    delete lead_comm;
+    delete trail_comm;
+  }
 
-  for (const tree_switch_case* elt : *this)
-    new_scl->append (elt ? elt->dup (scope, context) : 0);
+  tree_command *
+  tree_if_command::dup (symbol_table::scope_id scope,
+                        symbol_table::context_id context) const
+  {
+    return new tree_if_command (list ? list->dup (scope, context) : 0,
+                                lead_comm ? lead_comm->dup () : 0,
+                                trail_comm ? trail_comm->dup () : 0,
+                                line (), column ());
+  }
 
-  return new_scl;
-}
+  void
+  tree_if_command::accept (tree_walker& tw)
+  {
+    tw.visit_if_command (*this);
+  }
+
+  // Switch cases.
 
-void
-tree_switch_case_list::accept (tree_walker& tw)
-{
-  tw.visit_switch_case_list (*this);
-}
+  tree_switch_case::~tree_switch_case (void)
+  {
+    delete label;
+    delete list;
+    delete lead_comm;
+  }
+
+  bool
+  tree_switch_case::label_matches (const octave_value& val)
+  {
+    octave_value label_value = label->rvalue1 ();
+
+    if (label_value.is_defined ())
+      {
+        if (label_value.is_cell ())
+          {
+            Cell cell (label_value.cell_value ());
 
-// Switch.
+            for (octave_idx_type i = 0; i < cell.rows (); i++)
+              {
+                for (octave_idx_type j = 0; j < cell.columns (); j++)
+                  {
+                    bool match = val.is_equal (cell(i,j));
+
+                    if (match)
+                      return true;
+                  }
+              }
+          }
+        else
+          return val.is_equal (label_value);
+      }
 
-tree_switch_command::~tree_switch_command (void)
-{
-  delete expr;
-  delete list;
-  delete lead_comm;
-  delete trail_comm;
-}
+    return false;
+  }
+
+  tree_switch_case *
+  tree_switch_case::dup (symbol_table::scope_id scope,
+                         symbol_table::context_id context) const
+  {
+    return new tree_switch_case (label ? label->dup (scope, context) : 0,
+                                 list ? list->dup (scope, context) : 0,
+                                 lead_comm ? lead_comm->dup () : 0);
+  }
+
+  void
+  tree_switch_case::accept (tree_walker& tw)
+  {
+    tw.visit_switch_case (*this);
+  }
+
+  // List of switch cases.
 
-tree_command *
-tree_switch_command::dup (symbol_table::scope_id scope,
-                          symbol_table::context_id context) const
-{
-  return new tree_switch_command (expr ? expr->dup (scope, context) : 0,
-                                  list ? list->dup (scope, context) : 0,
-                                  lead_comm ? lead_comm->dup () : 0,
-                                  trail_comm ? trail_comm->dup () : 0,
-                                  line (), column ());
+  tree_switch_case_list *
+  tree_switch_case_list::dup (symbol_table::scope_id scope,
+                              symbol_table::context_id context) const
+  {
+    tree_switch_case_list *new_scl = new tree_switch_case_list ();
+
+    for (const tree_switch_case* elt : *this)
+      new_scl->append (elt ? elt->dup (scope, context) : 0);
+
+    return new_scl;
+  }
+
+  void
+  tree_switch_case_list::accept (tree_walker& tw)
+  {
+    tw.visit_switch_case_list (*this);
+  }
+
+  // Switch.
+
+  tree_switch_command::~tree_switch_command (void)
+  {
+    delete expr;
+    delete list;
+    delete lead_comm;
+    delete trail_comm;
+  }
+
+  tree_command *
+  tree_switch_command::dup (symbol_table::scope_id scope,
+                            symbol_table::context_id context) const
+  {
+    return new tree_switch_command (expr ? expr->dup (scope, context) : 0,
+                                    list ? list->dup (scope, context) : 0,
+                                    lead_comm ? lead_comm->dup () : 0,
+                                    trail_comm ? trail_comm->dup () : 0,
+                                    line (), column ());
+  }
+
+  void
+  tree_switch_command::accept (tree_walker& tw)
+  {
+    tw.visit_switch_command (*this);
+  }
 }
-
-void
-tree_switch_command::accept (tree_walker& tw)
-{
-  tw.visit_switch_command (*this);
-}
-
diff --git a/libinterp/parse-tree/pt-select.h b/libinterp/parse-tree/pt-select.h
--- a/libinterp/parse-tree/pt-select.h
+++ b/libinterp/parse-tree/pt-select.h
@@ -20,282 +20,298 @@ along with Octave; see the file COPYING.
 
 */
 
 #if ! defined (octave_pt_select_h)
 #define octave_pt_select_h 1
 
 #include "octave-config.h"
 
-class expression;
-class tree_statement_list;
-
-class tree_walker;
-
 #include "base-list.h"
 #include "comment-list.h"
 #include "pt-cmd.h"
 #include "symtab.h"
 
-// If.
+namespace octave
+{
+  class tree_expression;
+  class tree_statement_list;
+
+  class tree_walker;
+
+  // If.
+
+  class tree_if_clause : public tree
+  {
+  public:
 
-class
-tree_if_clause : public tree
-{
-public:
+    tree_if_clause (int l = -1, int c = -1)
+      : tree (l, c), expr (0), list (0), lead_comm (0) { }
+
+    tree_if_clause (tree_statement_list *sl, octave_comment_list *lc = 0,
+                    int l = -1, int c = -1)
+      : tree (l, c), expr (0), list (sl), lead_comm (lc) { }
+
+    tree_if_clause (tree_expression *e, tree_statement_list *sl,
+                    octave_comment_list *lc = 0,
+                    int l = -1, int c = -1)
+      : tree (l, c), expr (e), list (sl), lead_comm (lc) { }
+
+    // No copying!
 
-  tree_if_clause (int l = -1, int c = -1)
-    : tree (l, c), expr (0), list (0), lead_comm (0) { }
+    tree_if_clause (const tree_if_clause&) = delete;
+
+    tree_if_clause& operator = (const tree_if_clause&) = delete;
+
+    ~tree_if_clause (void);
+
+    bool is_else_clause (void) { return ! expr; }
+
+    tree_expression *condition (void) { return expr; }
+
+    tree_statement_list *commands (void) { return list; }
 
-  tree_if_clause (tree_statement_list *sl, octave_comment_list *lc = 0,
-                  int l = -1, int c = -1)
-    : tree (l, c), expr (0), list (sl), lead_comm (lc) { }
+    octave_comment_list *leading_comment (void) { return lead_comm; }
+
+    tree_if_clause *dup (symbol_table::scope_id scope,
+                         symbol_table::context_id context) const;
+
+    void accept (tree_walker& tw);
+
+  private:
+
+    // The condition to test.
+    tree_expression *expr;
+
+    // The list of statements to evaluate if expr is true.
+    tree_statement_list *list;
 
-  tree_if_clause (tree_expression *e, tree_statement_list *sl,
-                  octave_comment_list *lc = 0,
-                  int l = -1, int c = -1)
-    : tree (l, c), expr (e), list (sl), lead_comm (lc) { }
+    // Comment preceding ELSE or ELSEIF token.
+    octave_comment_list *lead_comm;
+  };
+
+  class tree_if_command_list : public octave::base_list<tree_if_clause *>
+  {
+  public:
+
+    tree_if_command_list (void) { }
+
+    tree_if_command_list (tree_if_clause *t) { append (t); }
+
+    // No copying!
 
-  // No copying!
+    tree_if_command_list (const tree_if_command_list&) = delete;
+
+    tree_if_command_list& operator = (const tree_if_command_list&) = delete;
 
-  tree_if_clause (const tree_if_clause&) = delete;
-
-  tree_if_clause& operator = (const tree_if_clause&) = delete;
+    ~tree_if_command_list (void)
+    {
+      while (! empty ())
+        {
+          iterator p = begin ();
+          delete *p;
+          erase (p);
+        }
+    }
 
-  ~tree_if_clause (void);
+    tree_if_command_list *dup (symbol_table::scope_id scope,
+                               symbol_table::context_id context) const;
+
+    void accept (tree_walker& tw);
+  };
 
-  bool is_else_clause (void) { return ! expr; }
+  class tree_if_command : public tree_command
+  {
+  public:
 
-  tree_expression *condition (void) { return expr; }
+    tree_if_command (int l = -1, int c = -1)
+      : tree_command (l, c), list (0), lead_comm (0), trail_comm (0) { }
 
-  tree_statement_list *commands (void) { return list; }
+    tree_if_command (tree_if_command_list *lst, octave_comment_list *lc,
+                     octave_comment_list *tc, int l = -1, int c = -1)
+      : tree_command (l, c), list (lst), lead_comm (lc), trail_comm (tc) { }
+
+    // No copying!
+
+    tree_if_command (const tree_if_command&) = delete;
+
+    tree_if_command& operator = (const tree_if_command&) = delete;
 
-  octave_comment_list *leading_comment (void) { return lead_comm; }
+    ~tree_if_command (void);
+
+    tree_if_command_list *cmd_list (void) { return list; }
 
-  tree_if_clause *dup (symbol_table::scope_id scope,
+    octave_comment_list *leading_comment (void) { return lead_comm; }
+
+    octave_comment_list *trailing_comment (void) { return trail_comm; }
+
+    tree_command *dup (symbol_table::scope_id scope,
                        symbol_table::context_id context) const;
 
-  void accept (tree_walker& tw);
+    void accept (tree_walker& tw);
 
-private:
+  private:
 
-  // The condition to test.
-  tree_expression *expr;
+    // List of if commands (if, elseif, elseif, ... else, endif)
+    tree_if_command_list *list;
 
-  // The list of statements to evaluate if expr is true.
-  tree_statement_list *list;
+    // Comment preceding IF token.
+    octave_comment_list *lead_comm;
 
-  // Comment preceding ELSE or ELSEIF token.
-  octave_comment_list *lead_comm;
-};
+    // Comment preceding ENDIF token.
+    octave_comment_list *trail_comm;
+  };
 
-class
-tree_if_command_list : public octave::base_list<tree_if_clause *>
-{
-public:
+  // Switch.
 
-  tree_if_command_list (void) { }
-
-  tree_if_command_list (tree_if_clause *t) { append (t); }
-
-  // No copying!
+  class tree_switch_case : public tree
+  {
+  public:
 
-  tree_if_command_list (const tree_if_command_list&) = delete;
-
-  tree_if_command_list& operator = (const tree_if_command_list&) = delete;
+    tree_switch_case (int l = -1, int c = -1)
+      : tree (l, c), label (0), list (0), lead_comm (0) { }
 
-  ~tree_if_command_list (void)
-  {
-    while (! empty ())
-      {
-        iterator p = begin ();
-        delete *p;
-        erase (p);
-      }
-  }
+    tree_switch_case (tree_statement_list *sl, octave_comment_list *lc = 0,
+                      int l = -1, int c = -1)
+      : tree (l, c), label (0), list (sl), lead_comm (lc) { }
 
-  tree_if_command_list *dup (symbol_table::scope_id scope,
-                             symbol_table::context_id context) const;
-
-  void accept (tree_walker& tw);
-};
+    tree_switch_case (tree_expression *e, tree_statement_list *sl,
+                      octave_comment_list *lc = 0,
+                      int l = -1, int c = -1)
+      : tree (l, c), label (e), list (sl), lead_comm (lc) { }
 
-class
-tree_if_command : public tree_command
-{
-public:
+    // No copying!
+
+    tree_switch_case (const tree_switch_case&) = delete;
 
-  tree_if_command (int l = -1, int c = -1)
-    : tree_command (l, c), list (0), lead_comm (0), trail_comm (0) { }
+    tree_switch_case& operator = (const tree_switch_case&) = delete;
+
+    ~tree_switch_case (void);
 
-  tree_if_command (tree_if_command_list *lst, octave_comment_list *lc,
-                   octave_comment_list *tc, int l = -1, int c = -1)
-    : tree_command (l, c), list (lst), lead_comm (lc), trail_comm (tc) { }
+    bool is_default_case (void) { return ! label; }
 
-  // No copying!
+    bool label_matches (const octave_value& val);
 
-  tree_if_command (const tree_if_command&) = delete;
-
-  tree_if_command& operator = (const tree_if_command&) = delete;
+    tree_expression *case_label (void) { return label; }
 
-  ~tree_if_command (void);
+    tree_statement_list *commands (void) { return list; }
 
-  tree_if_command_list *cmd_list (void) { return list; }
+    octave_comment_list *leading_comment (void) { return lead_comm; }
 
-  octave_comment_list *leading_comment (void) { return lead_comm; }
+    tree_switch_case *dup (symbol_table::scope_id scope,
+                           symbol_table::context_id context) const;
 
-  octave_comment_list *trailing_comment (void) { return trail_comm; }
-
-  tree_command *dup (symbol_table::scope_id scope,
-                     symbol_table::context_id context) const;
+    void accept (tree_walker& tw);
 
-  void accept (tree_walker& tw);
+  private:
 
-private:
-
-  // List of if commands (if, elseif, elseif, ... else, endif)
-  tree_if_command_list *list;
+    // The case label.
+    tree_expression *label;
 
-  // Comment preceding IF token.
-  octave_comment_list *lead_comm;
-
-  // Comment preceding ENDIF token.
-  octave_comment_list *trail_comm;
-};
+    // The list of statements to evaluate if the label matches.
+    tree_statement_list *list;
 
-// Switch.
-
-class
-tree_switch_case : public tree
-{
-public:
+    // Comment preceding CASE or OTHERWISE token.
+    octave_comment_list *lead_comm;
+  };
 
-  tree_switch_case (int l = -1, int c = -1)
-    : tree (l, c), label (0), list (0), lead_comm (0) { }
+  class tree_switch_case_list : public octave::base_list<tree_switch_case *>
+  {
+  public:
 
-  tree_switch_case (tree_statement_list *sl, octave_comment_list *lc = 0,
-                    int l = -1, int c = -1)
-    : tree (l, c), label (0), list (sl), lead_comm (lc) { }
+    tree_switch_case_list (void) { }
 
-  tree_switch_case (tree_expression *e, tree_statement_list *sl,
-                    octave_comment_list *lc = 0,
-                    int l = -1, int c = -1)
-    : tree (l, c), label (e), list (sl), lead_comm (lc) { }
+    tree_switch_case_list (tree_switch_case *t) { append (t); }
+
+    // No copying!
 
-  // No copying!
+    tree_switch_case_list (const tree_switch_case_list&) = delete;
 
-  tree_switch_case (const tree_switch_case&) = delete;
+    tree_switch_case_list& operator = (const tree_switch_case_list&) = delete;
 
-  tree_switch_case& operator = (const tree_switch_case&) = delete;
-
-  ~tree_switch_case (void);
-
-  bool is_default_case (void) { return ! label; }
-
-  bool label_matches (const octave_value& val);
-
-  tree_expression *case_label (void) { return label; }
-
-  tree_statement_list *commands (void) { return list; }
+    ~tree_switch_case_list (void)
+    {
+      while (! empty ())
+        {
+          iterator p = begin ();
+          delete *p;
+          erase (p);
+        }
+    }
 
-  octave_comment_list *leading_comment (void) { return lead_comm; }
-
-  tree_switch_case *dup (symbol_table::scope_id scope,
-                         symbol_table::context_id context) const;
-
-  void accept (tree_walker& tw);
+    tree_switch_case_list *dup (symbol_table::scope_id scope,
+                                symbol_table::context_id context) const;
 
-private:
+    void accept (tree_walker& tw);
+  };
 
-  // The case label.
-  tree_expression *label;
-
-  // The list of statements to evaluate if the label matches.
-  tree_statement_list *list;
+  class tree_switch_command : public tree_command
+  {
+  public:
 
-  // Comment preceding CASE or OTHERWISE token.
-  octave_comment_list *lead_comm;
-};
+    tree_switch_command (int l = -1, int c = -1)
+      : tree_command (l, c), expr (0), list (0), lead_comm (0),
+        trail_comm (0) { }
 
-class
-tree_switch_case_list : public octave::base_list<tree_switch_case *>
-{
-public:
-
-  tree_switch_case_list (void) { }
-
-  tree_switch_case_list (tree_switch_case *t) { append (t); }
+    tree_switch_command (tree_expression *e, tree_switch_case_list *lst,
+                         octave_comment_list *lc, octave_comment_list *tc,
+                         int l = -1, int c = -1)
+      : tree_command (l, c), expr (e), list (lst), lead_comm (lc),
+        trail_comm (tc) { }
 
-  // No copying!
+    // No copying!
 
-  tree_switch_case_list (const tree_switch_case_list&) = delete;
+    tree_switch_command (const tree_switch_command&) = delete;
 
-  tree_switch_case_list& operator = (const tree_switch_case_list&) = delete;
+    tree_switch_command& operator = (const tree_switch_command&) = delete;
 
-  ~tree_switch_case_list (void)
-  {
-    while (! empty ())
-      {
-        iterator p = begin ();
-        delete *p;
-        erase (p);
-      }
-  }
+    ~tree_switch_command (void);
+
+    tree_expression *switch_value (void) { return expr; }
+
+    tree_switch_case_list *case_list (void) { return list; }
 
-  tree_switch_case_list *dup (symbol_table::scope_id scope,
-                              symbol_table::context_id context) const;
+    octave_comment_list *leading_comment (void) { return lead_comm; }
+
+    octave_comment_list *trailing_comment (void) { return trail_comm; }
 
-  void accept (tree_walker& tw);
-};
+    tree_command *dup (symbol_table::scope_id scope,
+                       symbol_table::context_id context) const;
 
-class
-tree_switch_command : public tree_command
-{
-public:
+    void accept (tree_walker& tw);
 
-  tree_switch_command (int l = -1, int c = -1)
-    : tree_command (l, c), expr (0), list (0), lead_comm (0),
-      trail_comm (0) { }
+  private:
+
+    // Value on which to switch.
+    tree_expression *expr;
 
-  tree_switch_command (tree_expression *e, tree_switch_case_list *lst,
-                       octave_comment_list *lc, octave_comment_list *tc,
-                       int l = -1, int c = -1)
-    : tree_command (l, c), expr (e), list (lst), lead_comm (lc),
-      trail_comm (tc) { }
+    // List of cases (case 1, case 2, ..., default)
+    tree_switch_case_list *list;
 
-  // No copying!
-
-  tree_switch_command (const tree_switch_command&) = delete;
-
-  tree_switch_command& operator = (const tree_switch_command&) = delete;
+    // Comment preceding SWITCH token.
+    octave_comment_list *lead_comm;
 
-  ~tree_switch_command (void);
-
-  tree_expression *switch_value (void) { return expr; }
-
-  tree_switch_case_list *case_list (void) { return list; }
+    // Comment preceding ENDSWITCH token.
+    octave_comment_list *trail_comm;
+  };
+}
 
-  octave_comment_list *leading_comment (void) { return lead_comm; }
-
-  octave_comment_list *trailing_comment (void) { return trail_comm; }
+#if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
 
-  tree_command *dup (symbol_table::scope_id scope,
-                     symbol_table::context_id context) const;
-
-  void accept (tree_walker& tw);
+OCTAVE_DEPRECATED ("use 'octave::tree_if_clause' instead")
+typedef octave::tree_if_clause tree_if_clause;
 
-private:
+// tree_if_command_list is derived from a template.
 
-  // Value on which to switch.
-  tree_expression *expr;
+OCTAVE_DEPRECATED ("use 'octave::tree_if_command' instead")
+typedef octave::tree_if_command tree_if_command;
 
-  // List of cases (case 1, case 2, ..., default)
-  tree_switch_case_list *list;
+OCTAVE_DEPRECATED ("use 'octave::tree_switch_case' instead")
+typedef octave::tree_switch_case tree_switch_case;
 
-  // Comment preceding SWITCH token.
-  octave_comment_list *lead_comm;
+// tree_switch_case_list is derived from a template.
 
-  // Comment preceding ENDSWITCH token.
-  octave_comment_list *trail_comm;
-};
+OCTAVE_DEPRECATED ("use 'octave::tree_switch_command' instead")
+typedef octave::tree_switch_command tree_switch_command;
 
 #endif
 
+#endif
diff --git a/libinterp/parse-tree/pt-stmt.cc b/libinterp/parse-tree/pt-stmt.cc
--- a/libinterp/parse-tree/pt-stmt.cc
+++ b/libinterp/parse-tree/pt-stmt.cc
@@ -45,280 +45,282 @@ along with Octave; see the file COPYING.
 #include "pt-stmt.h"
 #include "pt-walk.h"
 #include "unwind-prot.h"
 #include "utils.h"
 #include "variables.h"
 
 #include "debug.h"
 
-// A list of commands to be executed.
-
-tree_statement::~tree_statement (void)
-{
-  delete cmd;
-  delete expr;
-  delete comm;
-}
-
-void
-tree_statement::set_print_flag (bool print_flag)
-{
-  if (expr)
-    expr->set_print_flag (print_flag);
-}
-
-bool
-tree_statement::print_result (void)
-{
-  return expr && expr->print_result ();
-}
-
-void
-tree_statement::set_breakpoint (const std::string& condition)
-{
-  if (cmd)
-    cmd->set_breakpoint (condition);
-  else if (expr)
-    expr->set_breakpoint (condition);
-}
-
-void
-tree_statement::delete_breakpoint (void)
-{
-  if (cmd)
-    cmd->delete_breakpoint ();
-  else if (expr)
-    expr->delete_breakpoint ();
-}
-
-bool
-tree_statement::is_breakpoint (bool check_active) const
-{
-  return cmd ? cmd->is_breakpoint (check_active)
-             : (expr ? expr->is_breakpoint (check_active) : false);
-}
-
-std::string
-tree_statement::bp_cond () const
-{
-  return cmd ? cmd->bp_cond () : (expr ? expr->bp_cond () : "0");
-}
-
-int
-tree_statement::line (void) const
-{
-  return cmd ? cmd->line () : (expr ? expr->line () : -1);
-}
-
-int
-tree_statement::column (void) const
-{
-  return cmd ? cmd->column () : (expr ? expr->column () : -1);
-}
-
-void
-tree_statement::set_location (int l, int c)
+namespace octave
 {
-  if (cmd)
-    cmd->set_location (l, c);
-  else if (expr)
-    expr->set_location (l, c);
-}
+  // A list of commands to be executed.
+
+  tree_statement::~tree_statement (void)
+  {
+    delete cmd;
+    delete expr;
+    delete comm;
+  }
+
+  void
+  tree_statement::set_print_flag (bool print_flag)
+  {
+    if (expr)
+      expr->set_print_flag (print_flag);
+  }
+
+  bool
+  tree_statement::print_result (void)
+  {
+    return expr && expr->print_result ();
+  }
+
+  void
+  tree_statement::set_breakpoint (const std::string& condition)
+  {
+    if (cmd)
+      cmd->set_breakpoint (condition);
+    else if (expr)
+      expr->set_breakpoint (condition);
+  }
 
-void
-tree_statement::echo_code (void)
-{
-  tree_print_code tpc (octave_stdout, VPS4);
+  void
+  tree_statement::delete_breakpoint (void)
+  {
+    if (cmd)
+      cmd->delete_breakpoint ();
+    else if (expr)
+      expr->delete_breakpoint ();
+  }
+
+  bool
+  tree_statement::is_breakpoint (bool check_active) const
+  {
+    return cmd ? cmd->is_breakpoint (check_active)
+      : (expr ? expr->is_breakpoint (check_active) : false);
+  }
 
-  accept (tpc);
-}
+  std::string
+  tree_statement::bp_cond () const
+  {
+    return cmd ? cmd->bp_cond () : (expr ? expr->bp_cond () : "0");
+  }
+
+  int
+  tree_statement::line (void) const
+  {
+    return cmd ? cmd->line () : (expr ? expr->line () : -1);
+  }
+
+  int
+  tree_statement::column (void) const
+  {
+    return cmd ? cmd->column () : (expr ? expr->column () : -1);
+  }
 
-bool
-tree_statement::is_end_of_fcn_or_script (void) const
-{
-  bool retval = false;
+  void
+  tree_statement::set_location (int l, int c)
+  {
+    if (cmd)
+      cmd->set_location (l, c);
+    else if (expr)
+      expr->set_location (l, c);
+  }
+
+  void
+  tree_statement::echo_code (void)
+  {
+    tree_print_code tpc (octave_stdout, VPS4);
+
+    accept (tpc);
+  }
+
+  bool
+  tree_statement::is_end_of_fcn_or_script (void) const
+  {
+    bool retval = false;
+
+    if (cmd)
+      {
+        tree_no_op_command *no_op_cmd
+          = dynamic_cast<tree_no_op_command *> (cmd);
+
+        if (no_op_cmd)
+          retval = no_op_cmd->is_end_of_fcn_or_script ();
+      }
 
-  if (cmd)
-    {
-      tree_no_op_command *no_op_cmd
-        = dynamic_cast<tree_no_op_command *> (cmd);
+    return retval;
+  }
+
+  bool
+  tree_statement::is_end_of_file (void) const
+  {
+    bool retval = false;
+
+    if (cmd)
+      {
+        tree_no_op_command *no_op_cmd
+          = dynamic_cast<tree_no_op_command *> (cmd);
+
+        if (no_op_cmd)
+          retval = no_op_cmd->is_end_of_file ();
+      }
 
-      if (no_op_cmd)
-        retval = no_op_cmd->is_end_of_fcn_or_script ();
-    }
+    return retval;
+  }
+
+  tree_statement *
+  tree_statement::dup (symbol_table::scope_id scope,
+                       symbol_table::context_id context) const
+  {
+    tree_statement *new_stmt = new tree_statement ();
 
-  return retval;
-}
+    new_stmt->cmd = cmd ? cmd->dup (scope, context) : 0;
+
+    new_stmt->expr = expr ? expr->dup (scope, context) : 0;
+
+    new_stmt->comm = comm ? comm->dup () : 0;
+
+    return new_stmt;
+  }
 
-bool
-tree_statement::is_end_of_file (void) const
-{
-  bool retval = false;
+  void
+  tree_statement::accept (tree_walker& tw)
+  {
+    tw.visit_statement (*this);
+  }
+
+  // Create a "breakpoint" tree-walker, and get it to "walk" this statement list
+  // (FIXME: What does that do???)
+  int
+  tree_statement_list::set_breakpoint (int line, const std::string& condition)
+  {
+    tree_breakpoint tbp (line, tree_breakpoint::set, condition);
+    accept (tbp);
+
+    return tbp.get_line ();
+  }
+
+  void
+  tree_statement_list::delete_breakpoint (int line)
+  {
+    if (line < 0)
+      {
+        octave_value_list bp_lst = list_breakpoints ();
+
+        int len = bp_lst.length ();
 
-  if (cmd)
-    {
-      tree_no_op_command *no_op_cmd
-        = dynamic_cast<tree_no_op_command *> (cmd);
+        for (int i = 0; i < len; i++)
+          {
+            tree_breakpoint tbp (i, tree_breakpoint::clear);
+            accept (tbp);
+          }
+      }
+    else
+      {
+        tree_breakpoint tbp (line, tree_breakpoint::clear);
+        accept (tbp);
+      }
+  }
+
+  octave_value_list
+  tree_statement_list::list_breakpoints (void)
+  {
+    tree_breakpoint tbp (0, tree_breakpoint::list);
+    accept (tbp);
 
-      if (no_op_cmd)
-        retval = no_op_cmd->is_end_of_file ();
-    }
+    return tbp.get_list ();
+  }
+
+  // Get list of pairs (breakpoint line, breakpoint condition)
+  std::list<bp_type>
+  tree_statement_list::breakpoints_and_conds (void)
+  {
+    tree_breakpoint tbp (0, tree_breakpoint::list);
+    accept (tbp);
 
-  return retval;
-}
+    std::list<bp_type> retval;
+    octave_value_list lines = tbp.get_list ();
+    octave_value_list conds = tbp.get_cond_list ();
+
+    for (int i = 0; i < lines.length (); i++)
+      {
+        retval.push_back (bp_type (lines(i).double_value (),
+                                   conds(i).string_value ()));
+      }
+
+    return retval;
+  }
 
-tree_statement *
-tree_statement::dup (symbol_table::scope_id scope,
-                     symbol_table::context_id context) const
-{
-  tree_statement *new_stmt = new tree_statement ();
+  // Add breakpoints to  file  at multiple lines (the second arguments of  line),
+  // to stop only if  condition  is true.
+  // Updates GUI via  octave_link::update_breakpoint.
+  // FIXME: COME BACK TO ME.
+  bp_table::intmap
+  tree_statement_list::add_breakpoint (const std::string& file,
+                                       const bp_table::intmap& line,
+                                       const std::string& condition)
+  {
+    bp_table::intmap retval;
+
+    octave_idx_type len = line.size ();
+
+    for (int i = 0; i < len; i++)
+      {
+        bp_table::const_intmap_iterator p = line.find (i);
 
-  new_stmt->cmd = cmd ? cmd->dup (scope, context) : 0;
+        if (p != line.end ())
+          {
+            int lineno = p->second;
+
+            retval[i] = set_breakpoint (lineno, condition);
 
-  new_stmt->expr = expr ? expr->dup (scope, context) : 0;
+            if (retval[i] != 0 && ! file.empty ())
+              octave_link::update_breakpoint (true, file, retval[i], condition);
+          }
+      }
+
+    return retval;
+  }
+
+  bp_table::intmap
+  tree_statement_list::remove_all_breakpoints (const std::string& file)
+  {
+    bp_table::intmap retval;
 
-  new_stmt->comm = comm ? comm->dup () : 0;
+    octave_value_list bkpts = list_breakpoints ();
+
+    for (int i = 0; i < bkpts.length (); i++)
+      {
+        int lineno = static_cast<int> (bkpts(i).int_value ());
+
+        delete_breakpoint (lineno);
 
-  return new_stmt;
-}
+        retval[i] = lineno;
+
+        if (! file.empty ())
+          octave_link::update_breakpoint (false, file, lineno);
+      }
+
+    return retval;
+  }
 
-void
-tree_statement::accept (tree_walker& tw)
-{
-  tw.visit_statement (*this);
+  tree_statement_list *
+  tree_statement_list::dup (symbol_table::scope_id scope,
+                            symbol_table::context_id context) const
+  {
+    tree_statement_list *new_list = new tree_statement_list ();
+
+    new_list->function_body = function_body;
+
+    for (const tree_statement* elt : *this)
+      new_list->append (elt ? elt->dup (scope, context) : 0);
+
+    return new_list;
+  }
+
+  void
+  tree_statement_list::accept (tree_walker& tw)
+  {
+    tw.visit_statement_list (*this);
+  }
 }
-
-// Create a "breakpoint" tree-walker, and get it to "walk" this statement list
-// (FIXME: What does that do???)
-int
-tree_statement_list::set_breakpoint (int line, const std::string& condition)
-{
-  tree_breakpoint tbp (line, tree_breakpoint::set, condition);
-  accept (tbp);
-
-  return tbp.get_line ();
-}
-
-void
-tree_statement_list::delete_breakpoint (int line)
-{
-  if (line < 0)
-    {
-      octave_value_list bp_lst = list_breakpoints ();
-
-      int len = bp_lst.length ();
-
-      for (int i = 0; i < len; i++)
-        {
-          tree_breakpoint tbp (i, tree_breakpoint::clear);
-          accept (tbp);
-        }
-    }
-  else
-    {
-      tree_breakpoint tbp (line, tree_breakpoint::clear);
-      accept (tbp);
-    }
-}
-
-octave_value_list
-tree_statement_list::list_breakpoints (void)
-{
-  tree_breakpoint tbp (0, tree_breakpoint::list);
-  accept (tbp);
-
-  return tbp.get_list ();
-}
-
-// Get list of pairs (breakpoint line, breakpoint condition)
-std::list<bp_type>
-tree_statement_list::breakpoints_and_conds (void)
-{
-  tree_breakpoint tbp (0, tree_breakpoint::list);
-  accept (tbp);
-
-  std::list<bp_type> retval;
-  octave_value_list lines = tbp.get_list ();
-  octave_value_list conds = tbp.get_cond_list ();
-
-  for (int i = 0; i < lines.length (); i++)
-    {
-      retval.push_back (bp_type (lines(i).double_value (),
-                                 conds(i).string_value ()));
-    }
-
-  return retval;
-}
-
-// Add breakpoints to  file  at multiple lines (the second arguments of  line),
-// to stop only if  condition  is true.
-// Updates GUI via  octave_link::update_breakpoint.
-// FIXME: COME BACK TO ME.
-bp_table::intmap
-tree_statement_list::add_breakpoint (const std::string& file,
-                                     const bp_table::intmap& line,
-                                     const std::string& condition)
-{
-  bp_table::intmap retval;
-
-  octave_idx_type len = line.size ();
-
-  for (int i = 0; i < len; i++)
-    {
-      bp_table::const_intmap_iterator p = line.find (i);
-
-      if (p != line.end ())
-        {
-          int lineno = p->second;
-
-          retval[i] = set_breakpoint (lineno, condition);
-
-          if (retval[i] != 0 && ! file.empty ())
-            octave_link::update_breakpoint (true, file, retval[i], condition);
-        }
-    }
-
-  return retval;
-}
-
-bp_table::intmap
-tree_statement_list::remove_all_breakpoints (const std::string& file)
-{
-  bp_table::intmap retval;
-
-  octave_value_list bkpts = list_breakpoints ();
-
-  for (int i = 0; i < bkpts.length (); i++)
-    {
-      int lineno = static_cast<int> (bkpts(i).int_value ());
-
-      delete_breakpoint (lineno);
-
-      retval[i] = lineno;
-
-      if (! file.empty ())
-        octave_link::update_breakpoint (false, file, lineno);
-    }
-
-  return retval;
-}
-
-tree_statement_list *
-tree_statement_list::dup (symbol_table::scope_id scope,
-                          symbol_table::context_id context) const
-{
-  tree_statement_list *new_list = new tree_statement_list ();
-
-  new_list->function_body = function_body;
-
-  for (const tree_statement* elt : *this)
-    new_list->append (elt ? elt->dup (scope, context) : 0);
-
-  return new_list;
-}
-
-void
-tree_statement_list::accept (tree_walker& tw)
-{
-  tw.visit_statement_list (*this);
-}
-
diff --git a/libinterp/parse-tree/pt-stmt.h b/libinterp/parse-tree/pt-stmt.h
--- a/libinterp/parse-tree/pt-stmt.h
+++ b/libinterp/parse-tree/pt-stmt.h
@@ -22,183 +22,193 @@ along with Octave; see the file COPYING.
 
 #if ! defined (octave_pt_stmt_h)
 #define octave_pt_stmt_h 1
 
 #include "octave-config.h"
 
 class octave_value_list;
 
-class tree_command;
-class tree_expression;
-
-class tree_walker;
-
 #include <deque>
 
 #include "base-list.h"
 #include "comment-list.h"
 #include "debug.h"
 #include "symtab.h"
 #include "pt.h"
 
-// A statement is either a command to execute or an expression to
-// evaluate.
+namespace octave
+{
+  class tree_command;
+  class tree_expression;
 
-class
-tree_statement : public tree
-{
-public:
+  class tree_walker;
+
+  // A statement is either a command to execute or an expression to
+  // evaluate.
 
-  tree_statement (void)
-    : cmd (0), expr (0), comm (0) { }
+  class tree_statement : public tree
+  {
+  public:
 
-  tree_statement (tree_command *c, octave_comment_list *cl)
-    : cmd (c), expr (0), comm (cl) { }
+    tree_statement (void)
+      : cmd (0), expr (0), comm (0) { }
 
-  tree_statement (tree_expression *e, octave_comment_list *cl)
-    : cmd (0), expr (e), comm (cl) { }
+    tree_statement (tree_command *c, octave_comment_list *cl)
+      : cmd (c), expr (0), comm (cl) { }
 
-  // No copying!
-
-  tree_statement (const tree_statement&) = delete;
+    tree_statement (tree_expression *e, octave_comment_list *cl)
+      : cmd (0), expr (e), comm (cl) { }
 
-  tree_statement& operator = (const tree_statement&) = delete;
+    // No copying!
 
-  ~tree_statement (void);
+    tree_statement (const tree_statement&) = delete;
 
-  void set_print_flag (bool print_flag);
+    tree_statement& operator = (const tree_statement&) = delete;
 
-  bool print_result (void);
+    ~tree_statement (void);
 
-  bool is_command (void) const { return cmd != 0; }
+    void set_print_flag (bool print_flag);
+
+    bool print_result (void);
 
-  bool is_expression (void) const { return expr != 0; }
+    bool is_command (void) const { return cmd != 0; }
 
-  void set_breakpoint (const std::string& condition);
+    bool is_expression (void) const { return expr != 0; }
 
-  void delete_breakpoint (void);
+    void set_breakpoint (const std::string& condition);
 
-  bool is_breakpoint (bool check_valid = false) const;
-  std::string bp_cond () const;
+    void delete_breakpoint (void);
+
+    bool is_breakpoint (bool check_valid = false) const;
+    std::string bp_cond () const;
 
-  int line (void) const;
-  int column (void) const;
+    int line (void) const;
+    int column (void) const;
 
-  void set_location (int l, int c);
-
-  void echo_code (void);
+    void set_location (int l, int c);
 
-  tree_command *command (void) { return cmd; }
+    void echo_code (void);
 
-  tree_expression *expression (void) { return expr; }
+    tree_command *command (void) { return cmd; }
+
+    tree_expression *expression (void) { return expr; }
 
-  octave_comment_list *comment_text (void) { return comm; }
+    octave_comment_list *comment_text (void) { return comm; }
 
-  bool is_null_statement (void) const { return ! (cmd || expr || comm); }
+    bool is_null_statement (void) const { return ! (cmd || expr || comm); }
 
-  bool is_end_of_fcn_or_script (void) const;
+    bool is_end_of_fcn_or_script (void) const;
 
-  bool is_end_of_file (void) const;
+    bool is_end_of_file (void) const;
 
-  // Allow modification of this statement.  Note that there is no
-  // checking.  If you use these, are you sure you knwo what you are
-  // doing?
+    // Allow modification of this statement.  Note that there is no
+    // checking.  If you use these, are you sure you knwo what you are
+    // doing?
 
-  void set_command (tree_command *c) { cmd = c; }
+    void set_command (tree_command *c) { cmd = c; }
 
-  void set_expression (tree_expression *e) { expr = e; }
+    void set_expression (tree_expression *e) { expr = e; }
 
-  tree_statement *dup (symbol_table::scope_id scope,
-                       symbol_table::context_id context) const;
+    tree_statement *dup (symbol_table::scope_id scope,
+                         symbol_table::context_id context) const;
 
-  void accept (tree_walker& tw);
+    void accept (tree_walker& tw);
 
-private:
+  private:
 
-  // Only one of cmd or expr can be valid at once.
+    // Only one of cmd or expr can be valid at once.
 
-  // Command to execute.
-  tree_command *cmd;
+    // Command to execute.
+    tree_command *cmd;
 
-  // Expression to evaluate.
-  tree_expression *expr;
+    // Expression to evaluate.
+    tree_expression *expr;
 
-  // Comment associated with this statement.
-  octave_comment_list *comm;
-};
+    // Comment associated with this statement.
+    octave_comment_list *comm;
+  };
 
-// A list of statements to evaluate.
+  // A list of statements to evaluate.
 
-class
-tree_statement_list : public octave::base_list<tree_statement *>
-{
-public:
+  class tree_statement_list : public octave::base_list<tree_statement *>
+  {
+  public:
 
-  tree_statement_list (void)
-    : function_body (false), anon_function_body (false),
-      script_body (false) { }
+    tree_statement_list (void)
+      : function_body (false), anon_function_body (false),
+        script_body (false) { }
+
+    tree_statement_list (tree_statement *s)
+      : function_body (false), anon_function_body (false),
+        script_body (false) { append (s); }
 
-  tree_statement_list (tree_statement *s)
-    : function_body (false), anon_function_body (false),
-      script_body (false) { append (s); }
+    // No copying!
 
-  // No copying!
+    tree_statement_list (const tree_statement_list&) = delete;
 
-  tree_statement_list (const tree_statement_list&) = delete;
-
-  tree_statement_list& operator = (const tree_statement_list&) = delete;
+    tree_statement_list& operator = (const tree_statement_list&) = delete;
 
-  ~tree_statement_list (void)
-  {
-    while (! empty ())
-      {
-        iterator p = begin ();
-        delete *p;
-        erase (p);
-      }
-  }
+    ~tree_statement_list (void)
+    {
+      while (! empty ())
+        {
+          iterator p = begin ();
+          delete *p;
+          erase (p);
+        }
+    }
 
-  void mark_as_function_body (void) { function_body = true; }
+    void mark_as_function_body (void) { function_body = true; }
+
+    void mark_as_anon_function_body (void) { anon_function_body = true; }
+
+    void mark_as_script_body (void) { script_body = true; }
 
-  void mark_as_anon_function_body (void) { anon_function_body = true; }
+    bool is_function_body (void) const { return function_body; }
 
-  void mark_as_script_body (void) { script_body = true; }
+    bool is_anon_function_body (void) const { return anon_function_body; }
 
-  bool is_function_body (void) const { return function_body; }
+    bool is_script_body (void) const { return script_body; }
 
-  bool is_anon_function_body (void) const { return anon_function_body; }
+    int set_breakpoint (int line, const std::string& condition);
+
+    void delete_breakpoint (int line);
 
-  bool is_script_body (void) const { return script_body; }
+    octave_value_list list_breakpoints (void);
 
-  int set_breakpoint (int line, const std::string& condition);
+    std::list<bp_type> breakpoints_and_conds (void);
 
-  void delete_breakpoint (int line);
+    bp_table::intmap add_breakpoint (const std::string& file,
+                                     const bp_table::intmap& line,
+                                     const std::string& condition);
 
-  octave_value_list list_breakpoints (void);
+    bp_table::intmap remove_all_breakpoints (const std::string& file);
 
-  std::list<bp_type> breakpoints_and_conds (void);
+    tree_statement_list *dup (symbol_table::scope_id scope,
+                              symbol_table::context_id context) const;
 
-  bp_table::intmap add_breakpoint (const std::string& file,
-                                   const bp_table::intmap& line,
-                                   const std::string& condition);
+    void accept (tree_walker& tw);
+
+  private:
 
-  bp_table::intmap remove_all_breakpoints (const std::string& file);
+    // Does this list of statements make up the body of a function?
+    bool function_body;
 
-  tree_statement_list *dup (symbol_table::scope_id scope,
-                            symbol_table::context_id context) const;
-
-  void accept (tree_walker& tw);
+    // Does this list of statements make up the body of a function?
+    bool anon_function_body;
 
-private:
-
-  // Does this list of statements make up the body of a function?
-  bool function_body;
+    // Does this list of statements make up the body of a script?
+    bool script_body;
+  };
+}
 
-  // Does this list of statements make up the body of a function?
-  bool anon_function_body;
+#if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
 
-  // Does this list of statements make up the body of a script?
-  bool script_body;
-};
+OCTAVE_DEPRECATED ("use 'octave::tree_statement' instead")
+typedef octave::tree_statement tree_statement;
+
+OCTAVE_DEPRECATED ("use 'octave::tree_statement_list' instead")
+typedef octave::tree_statement_list tree_statement_list;
 
 #endif
 
+#endif
diff --git a/libinterp/parse-tree/pt-unop.cc b/libinterp/parse-tree/pt-unop.cc
--- a/libinterp/parse-tree/pt-unop.cc
+++ b/libinterp/parse-tree/pt-unop.cc
@@ -28,165 +28,167 @@ along with Octave; see the file COPYING.
 #include "ovl.h"
 #include "oct-lvalue.h"
 #include "ov.h"
 #include "profiler.h"
 #include "pt-bp.h"
 #include "pt-unop.h"
 #include "pt-walk.h"
 
-// Unary expressions.
-
-std::string
-tree_unary_expression::oper (void) const
+namespace octave
 {
-  return octave_value::unary_op_as_string (etype);
-}
+  // Unary expressions.
 
-// Prefix expressions.
+  std::string
+  tree_unary_expression::oper (void) const
+  {
+    return octave_value::unary_op_as_string (etype);
+  }
 
-octave_value_list
-tree_prefix_expression::rvalue (int nargout)
-{
-  octave_value_list retval;
+  // Prefix expressions.
 
-  if (nargout > 1)
-    error ("prefix operator '%s': invalid number of output arguments",
-           oper ().c_str ());
+  octave_value_list
+  tree_prefix_expression::rvalue (int nargout)
+  {
+    octave_value_list retval;
 
-  retval = rvalue1 (nargout);
-
-  return retval;
-}
+    if (nargout > 1)
+      error ("prefix operator '%s': invalid number of output arguments",
+             oper ().c_str ());
 
-octave_value
-tree_prefix_expression::rvalue1 (int)
-{
-  octave_value retval;
+    retval = rvalue1 (nargout);
+
+    return retval;
+  }
 
-  if (op)
-    {
-      if (etype == octave_value::op_incr || etype == octave_value::op_decr)
-        {
-          octave_lvalue ref = op->lvalue ();
+  octave_value
+  tree_prefix_expression::rvalue1 (int)
+  {
+    octave_value retval;
 
-          BEGIN_PROFILER_BLOCK (tree_prefix_expression)
+    if (op)
+      {
+        if (etype == octave_value::op_incr || etype == octave_value::op_decr)
+          {
+            octave_lvalue ref = op->lvalue ();
 
-          ref.do_unary_op (etype);
+            BEGIN_PROFILER_BLOCK (tree_prefix_expression)
 
-          retval = ref.value ();
+              ref.do_unary_op (etype);
 
-          END_PROFILER_BLOCK
-        }
-      else
-        {
-          octave_value val = op->rvalue1 ();
+            retval = ref.value ();
 
-          if (val.is_defined ())
-            {
-              BEGIN_PROFILER_BLOCK (tree_prefix_expression)
+            END_PROFILER_BLOCK
+              }
+        else
+          {
+            octave_value val = op->rvalue1 ();
 
-              // Attempt to do the operation in-place if it is unshared
-              // (a temporary expression).
-              if (val.get_count () == 1)
-                retval = val.do_non_const_unary_op (etype);
-              else
-                retval = ::do_unary_op (etype, val);
+            if (val.is_defined ())
+              {
+                BEGIN_PROFILER_BLOCK (tree_prefix_expression)
 
-              END_PROFILER_BLOCK
-            }
-        }
-    }
+                  // Attempt to do the operation in-place if it is unshared
+                  // (a temporary expression).
+                  if (val.get_count () == 1)
+                    retval = val.do_non_const_unary_op (etype);
+                  else
+                    retval = ::do_unary_op (etype, val);
 
-  return retval;
-}
+                END_PROFILER_BLOCK
+                  }
+          }
+      }
 
-tree_expression *
-tree_prefix_expression::dup (symbol_table::scope_id scope,
-                             symbol_table::context_id context) const
-{
-  tree_prefix_expression *new_pe
-    = new tree_prefix_expression (op ? op->dup (scope, context) : 0,
-                                  line (), column (), etype);
+    return retval;
+  }
 
-  new_pe->copy_base (*this);
+  tree_expression *
+  tree_prefix_expression::dup (symbol_table::scope_id scope,
+                               symbol_table::context_id context) const
+  {
+    tree_prefix_expression *new_pe
+      = new tree_prefix_expression (op ? op->dup (scope, context) : 0,
+                                    line (), column (), etype);
 
-  return new_pe;
-}
+    new_pe->copy_base (*this);
 
-void
-tree_prefix_expression::accept (tree_walker& tw)
-{
-  tw.visit_prefix_expression (*this);
-}
+    return new_pe;
+  }
 
-// Postfix expressions.
+  void
+  tree_prefix_expression::accept (tree_walker& tw)
+  {
+    tw.visit_prefix_expression (*this);
+  }
 
-octave_value_list
-tree_postfix_expression::rvalue (int nargout)
-{
-  octave_value_list retval;
+  // Postfix expressions.
 
-  if (nargout > 1)
-    error ("postfix operator '%s': invalid number of output arguments",
-           oper ().c_str ());
+  octave_value_list
+  tree_postfix_expression::rvalue (int nargout)
+  {
+    octave_value_list retval;
 
-  retval = rvalue1 (nargout);
+    if (nargout > 1)
+      error ("postfix operator '%s': invalid number of output arguments",
+             oper ().c_str ());
 
-  return retval;
-}
+    retval = rvalue1 (nargout);
+
+    return retval;
+  }
 
-octave_value
-tree_postfix_expression::rvalue1 (int)
-{
-  octave_value retval;
+  octave_value
+  tree_postfix_expression::rvalue1 (int)
+  {
+    octave_value retval;
 
-  if (op)
-    {
-      if (etype == octave_value::op_incr || etype == octave_value::op_decr)
-        {
-          octave_lvalue ref = op->lvalue ();
+    if (op)
+      {
+        if (etype == octave_value::op_incr || etype == octave_value::op_decr)
+          {
+            octave_lvalue ref = op->lvalue ();
 
-          retval = ref.value ();
+            retval = ref.value ();
 
-          BEGIN_PROFILER_BLOCK (tree_postfix_expression)
-
-          ref.do_unary_op (etype);
+            BEGIN_PROFILER_BLOCK (tree_postfix_expression)
 
-          END_PROFILER_BLOCK
-        }
-      else
-        {
-          octave_value val = op->rvalue1 ();
+              ref.do_unary_op (etype);
 
-          if (val.is_defined ())
-            {
-              BEGIN_PROFILER_BLOCK (tree_postfix_expression)
+            END_PROFILER_BLOCK
+              }
+        else
+          {
+            octave_value val = op->rvalue1 ();
 
-              retval = ::do_unary_op (etype, val);
+            if (val.is_defined ())
+              {
+                BEGIN_PROFILER_BLOCK (tree_postfix_expression)
 
-              END_PROFILER_BLOCK
-            }
-        }
-    }
+                  retval = ::do_unary_op (etype, val);
 
-  return retval;
-}
+                END_PROFILER_BLOCK
+                  }
+          }
+      }
 
-tree_expression *
-tree_postfix_expression::dup (symbol_table::scope_id scope,
-                              symbol_table::context_id context) const
-{
-  tree_postfix_expression *new_pe
-    = new tree_postfix_expression (op ? op->dup (scope, context) : 0,
-                                   line (), column (), etype);
+    return retval;
+  }
 
-  new_pe->copy_base (*this);
+  tree_expression *
+  tree_postfix_expression::dup (symbol_table::scope_id scope,
+                                symbol_table::context_id context) const
+  {
+    tree_postfix_expression *new_pe
+      = new tree_postfix_expression (op ? op->dup (scope, context) : 0,
+                                     line (), column (), etype);
 
-  return new_pe;
-}
+    new_pe->copy_base (*this);
+
+    return new_pe;
+  }
 
-void
-tree_postfix_expression::accept (tree_walker& tw)
-{
-  tw.visit_postfix_expression (*this);
+  void
+  tree_postfix_expression::accept (tree_walker& tw)
+  {
+    tw.visit_postfix_expression (*this);
+  }
 }
-
diff --git a/libinterp/parse-tree/pt-unop.h b/libinterp/parse-tree/pt-unop.h
--- a/libinterp/parse-tree/pt-unop.h
+++ b/libinterp/parse-tree/pt-unop.h
@@ -22,137 +22,149 @@ along with Octave; see the file COPYING.
 
 #if ! defined (octave_pt_unop_h)
 #define octave_pt_unop_h 1
 
 #include "octave-config.h"
 
 #include <string>
 
-class tree_walker;
-
 class octave_value;
 class octave_value_list;
 class octave_lvalue;
 
 #include "pt-exp.h"
 #include "symtab.h"
 
-// Unary expressions.
-
-class
-tree_unary_expression : public tree_expression
+namespace octave
 {
-public:
+  class tree_walker;
+
+  // Unary expressions.
 
-  tree_unary_expression (int l = -1, int c = -1,
-                         octave_value::unary_op t
+  class tree_unary_expression : public tree_expression
+  {
+  public:
+
+    tree_unary_expression (int l = -1, int c = -1,
+                           octave_value::unary_op t
                            = octave_value::unknown_unary_op)
-    : tree_expression (l, c), op (0), etype (t)  { }
+      : tree_expression (l, c), op (0), etype (t)  { }
 
-  tree_unary_expression (tree_expression *e, int l = -1, int c = -1,
-                         octave_value::unary_op t
+    tree_unary_expression (tree_expression *e, int l = -1, int c = -1,
+                           octave_value::unary_op t
                            = octave_value::unknown_unary_op)
-    : tree_expression (l, c), op (e), etype (t) { }
+      : tree_expression (l, c), op (e), etype (t) { }
 
-  // No copying!
+    // No copying!
 
-  tree_unary_expression (const tree_unary_expression&) = delete;
+    tree_unary_expression (const tree_unary_expression&) = delete;
 
-  tree_unary_expression& operator = (const tree_unary_expression&) = delete;
+    tree_unary_expression& operator = (const tree_unary_expression&) = delete;
 
-  ~tree_unary_expression (void) { delete op; }
+    ~tree_unary_expression (void) { delete op; }
 
-  bool is_unary_expression (void) const { return true; }
+    bool is_unary_expression (void) const { return true; }
 
-  bool has_magic_end (void) const { return (op && op->has_magic_end ()); }
+    bool has_magic_end (void) const { return (op && op->has_magic_end ()); }
 
-  tree_expression *operand (void) { return op; }
+    tree_expression *operand (void) { return op; }
 
-  std::string oper (void) const;
+    std::string oper (void) const;
 
-  octave_value::unary_op op_type (void) const { return etype; }
+    octave_value::unary_op op_type (void) const { return etype; }
 
-protected:
+  protected:
 
-  // The operand for the expression.
-  tree_expression *op;
+    // The operand for the expression.
+    tree_expression *op;
 
-  // The type of the expression.
-  octave_value::unary_op etype;
-};
+    // The type of the expression.
+    octave_value::unary_op etype;
+  };
 
-// Prefix expressions.
+  // Prefix expressions.
 
-class
-tree_prefix_expression : public tree_unary_expression
-{
-public:
+  class tree_prefix_expression : public tree_unary_expression
+  {
+  public:
+
+    tree_prefix_expression (int l = -1, int c = -1)
+      : tree_unary_expression (l, c, octave_value::unknown_unary_op) { }
 
-  tree_prefix_expression (int l = -1, int c = -1)
-    : tree_unary_expression (l, c, octave_value::unknown_unary_op) { }
+    tree_prefix_expression (tree_expression *e, int l = -1, int c = -1,
+                            octave_value::unary_op t
+                            = octave_value::unknown_unary_op)
+      : tree_unary_expression (e, l, c, t) { }
 
-  tree_prefix_expression (tree_expression *e, int l = -1, int c = -1,
-                          octave_value::unary_op t
-                            = octave_value::unknown_unary_op)
-    : tree_unary_expression (e, l, c, t) { }
+    // No copying!
+
+    tree_prefix_expression (const tree_prefix_expression&) = delete;
 
-  // No copying!
+    tree_prefix_expression& operator = (const tree_prefix_expression&) = delete;
 
-  tree_prefix_expression (const tree_prefix_expression&) = delete;
+    ~tree_prefix_expression (void) = default;
 
-  tree_prefix_expression& operator = (const tree_prefix_expression&) = delete;
+    bool rvalue_ok (void) const { return true; }
 
-  ~tree_prefix_expression (void) = default;
+    octave_value rvalue1 (int nargout = 1);
 
-  bool rvalue_ok (void) const { return true; }
+    octave_value_list rvalue (int nargout);
 
-  octave_value rvalue1 (int nargout = 1);
+    tree_expression *dup (symbol_table::scope_id scope,
+                          symbol_table::context_id context) const;
 
-  octave_value_list rvalue (int nargout);
+    void accept (tree_walker& tw);
 
-  tree_expression *dup (symbol_table::scope_id scope,
-                        symbol_table::context_id context) const;
+    std::string profiler_name (void) const { return "prefix " + oper (); }
+  };
 
-  void accept (tree_walker& tw);
+  // Postfix expressions.
 
-  std::string profiler_name (void) const { return "prefix " + oper (); }
-};
-
-// Postfix expressions.
+  class tree_postfix_expression : public tree_unary_expression
+  {
+  public:
 
-class
-tree_postfix_expression : public tree_unary_expression
-{
-public:
+    tree_postfix_expression (int l = -1, int c = -1)
+      : tree_unary_expression (l, c, octave_value::unknown_unary_op) { }
+
+    tree_postfix_expression (tree_expression *e, int l = -1, int c = -1,
+                             octave_value::unary_op t
+                             = octave_value::unknown_unary_op)
+      : tree_unary_expression (e, l, c, t) { }
 
-  tree_postfix_expression (int l = -1, int c = -1)
-    : tree_unary_expression (l, c, octave_value::unknown_unary_op) { }
+    // No copying!
+
+    tree_postfix_expression (const tree_postfix_expression&) = delete;
+
+    tree_postfix_expression& operator = (const tree_postfix_expression&) = delete;
+
+    ~tree_postfix_expression (void) = default;
 
-  tree_postfix_expression (tree_expression *e, int l = -1, int c = -1,
-                           octave_value::unary_op t
-                             = octave_value::unknown_unary_op)
-    : tree_unary_expression (e, l, c, t) { }
+    bool rvalue_ok (void) const { return true; }
+
+    octave_value rvalue1 (int nargout = 1);
 
-  // No copying!
+    octave_value_list rvalue (int nargout);
 
-  tree_postfix_expression (const tree_postfix_expression&) = delete;
-
-  tree_postfix_expression& operator = (const tree_postfix_expression&) = delete;
+    tree_expression *dup (symbol_table::scope_id scope,
+                          symbol_table::context_id context) const;
 
-  ~tree_postfix_expression (void) = default;
-
-  bool rvalue_ok (void) const { return true; }
+    void accept (tree_walker& tw);
 
-  octave_value rvalue1 (int nargout = 1);
+    std::string profiler_name (void) const { return "postfix " + oper (); }
+  };
+}
 
-  octave_value_list rvalue (int nargout);
+#if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
 
-  tree_expression *dup (symbol_table::scope_id scope,
-                        symbol_table::context_id context) const;
+OCTAVE_DEPRECATED ("use 'octave::tree_unary_expression' instead")
+typedef octave::tree_unary_expression tree_unary_expression;
 
-  void accept (tree_walker& tw);
+OCTAVE_DEPRECATED ("use 'octave::tree_prefix_expression' instead")
+typedef octave::tree_prefix_expression tree_prefix_expression;
 
-  std::string profiler_name (void) const { return "postfix " + oper (); }
-};
+OCTAVE_DEPRECATED ("use 'octave::tree_postfix_expression' instead")
+typedef octave::tree_postfix_expression tree_postfix_expression;
 
 #endif
 
+#endif
diff --git a/libinterp/parse-tree/pt-walk.h b/libinterp/parse-tree/pt-walk.h
--- a/libinterp/parse-tree/pt-walk.h
+++ b/libinterp/parse-tree/pt-walk.h
@@ -20,266 +20,275 @@ along with Octave; see the file COPYING.
 
 */
 
 #if ! defined (octave_pt_walk_h)
 #define octave_pt_walk_h 1
 
 #include "octave-config.h"
 
-class tree_anon_fcn_handle;
-class tree_argument_list;
-class tree_binary_expression;
-class tree_break_command;
-class tree_colon_expression;
-class tree_continue_command;
-class tree_global_command;
-class tree_persistent_command;
-class tree_decl_elt;
-class tree_decl_init_list;
-class tree_simple_for_command;
-class tree_complex_for_command;
 class octave_user_script;
 class octave_user_function;
-class tree_function_def;
-class tree_identifier;
-class tree_if_clause;
-class tree_if_command;
-class tree_if_command_list;
-class tree_switch_case;
-class tree_switch_case_list;
-class tree_switch_command;
-class tree_index_expression;
-class tree_matrix;
-class tree_cell;
-class tree_multi_assignment;
-class tree_no_op_command;
-class tree_constant;
-class tree_fcn_handle;
-class tree_funcall;
-class tree_parameter_list;
-class tree_postfix_expression;
-class tree_prefix_expression;
-class tree_return_command;
-class tree_return_list;
-class tree_simple_assignment;
-class tree_statement;
-class tree_statement_list;
-class tree_try_catch_command;
-class tree_unwind_protect_command;
-class tree_while_command;
-class tree_do_until_command;
 
-class tree_classdef_attribute;
-class tree_classdef_attribute_list;
-class tree_classdef_superclass;
-class tree_classdef_superclass_list;
-class tree_classdef_property;
-class tree_classdef_property_list;
-class tree_classdef_properties_block;
-class tree_classdef_methods_list;
-class tree_classdef_methods_block;
-class tree_classdef_event;
-class tree_classdef_events_list;
-class tree_classdef_events_block;
-class tree_classdef_enum;
-class tree_classdef_enum_list;
-class tree_classdef_enum_block;
-class tree_classdef_body;
-class tree_classdef;
+namespace octave
+{
+  class tree_anon_fcn_handle;
+  class tree_argument_list;
+  class tree_binary_expression;
+  class tree_break_command;
+  class tree_colon_expression;
+  class tree_continue_command;
+  class tree_global_command;
+  class tree_persistent_command;
+  class tree_decl_elt;
+  class tree_decl_init_list;
+  class tree_simple_for_command;
+  class tree_complex_for_command;
+  class tree_function_def;
+  class tree_identifier;
+  class tree_if_clause;
+  class tree_if_command;
+  class tree_if_command_list;
+  class tree_switch_case;
+  class tree_switch_case_list;
+  class tree_switch_command;
+  class tree_index_expression;
+  class tree_matrix;
+  class tree_cell;
+  class tree_multi_assignment;
+  class tree_no_op_command;
+  class tree_constant;
+  class tree_fcn_handle;
+  class tree_funcall;
+  class tree_parameter_list;
+  class tree_postfix_expression;
+  class tree_prefix_expression;
+  class tree_return_command;
+  class tree_return_list;
+  class tree_simple_assignment;
+  class tree_statement;
+  class tree_statement_list;
+  class tree_try_catch_command;
+  class tree_unwind_protect_command;
+  class tree_while_command;
+  class tree_do_until_command;
 
-class
-tree_walker
-{
-protected:
-
-  tree_walker (void) { }
-
-  virtual ~tree_walker (void) = default;
-
-public:
-
-  // No copying!
+  class tree_classdef_attribute;
+  class tree_classdef_attribute_list;
+  class tree_classdef_superclass;
+  class tree_classdef_superclass_list;
+  class tree_classdef_property;
+  class tree_classdef_property_list;
+  class tree_classdef_properties_block;
+  class tree_classdef_methods_list;
+  class tree_classdef_methods_block;
+  class tree_classdef_event;
+  class tree_classdef_events_list;
+  class tree_classdef_events_block;
+  class tree_classdef_enum;
+  class tree_classdef_enum_list;
+  class tree_classdef_enum_block;
+  class tree_classdef_body;
+  class tree_classdef;
 
-  tree_walker (const tree_walker&) = delete;
+  class tree_walker
+  {
+  protected:
 
-  tree_walker& operator = (const tree_walker&) = delete;
+    tree_walker (void) { }
 
-  virtual void
-  visit_anon_fcn_handle (tree_anon_fcn_handle&) = 0;
+    virtual ~tree_walker (void) = default;
+
+  public:
 
-  virtual void
-  visit_argument_list (tree_argument_list&) = 0;
+    // No copying!
 
-  virtual void
-  visit_binary_expression (tree_binary_expression&) = 0;
+    tree_walker (const tree_walker&) = delete;
 
-  virtual void
-  visit_break_command (tree_break_command&) = 0;
+    tree_walker& operator = (const tree_walker&) = delete;
 
-  virtual void
-  visit_colon_expression (tree_colon_expression&) = 0;
+    virtual void
+    visit_anon_fcn_handle (tree_anon_fcn_handle&) = 0;
+
+    virtual void
+    visit_argument_list (tree_argument_list&) = 0;
 
-  virtual void
-  visit_continue_command (tree_continue_command&) = 0;
+    virtual void
+    visit_binary_expression (tree_binary_expression&) = 0;
 
-  virtual void
-  visit_global_command (tree_global_command&) = 0;
+    virtual void
+    visit_break_command (tree_break_command&) = 0;
 
-  virtual void
-  visit_persistent_command (tree_persistent_command&) = 0;
+    virtual void
+    visit_colon_expression (tree_colon_expression&) = 0;
 
-  virtual void
-  visit_decl_elt (tree_decl_elt&) = 0;
+    virtual void
+    visit_continue_command (tree_continue_command&) = 0;
 
-  virtual void
-  visit_decl_init_list (tree_decl_init_list&) = 0;
+    virtual void
+    visit_global_command (tree_global_command&) = 0;
+
+    virtual void
+    visit_persistent_command (tree_persistent_command&) = 0;
 
-  virtual void
-  visit_simple_for_command (tree_simple_for_command&) = 0;
+    virtual void
+    visit_decl_elt (tree_decl_elt&) = 0;
 
-  virtual void
-  visit_complex_for_command (tree_complex_for_command&) = 0;
+    virtual void
+    visit_decl_init_list (tree_decl_init_list&) = 0;
 
-  virtual void
-  visit_octave_user_script (octave_user_script&) = 0;
+    virtual void
+    visit_simple_for_command (tree_simple_for_command&) = 0;
 
-  virtual void
-  visit_octave_user_function (octave_user_function&) = 0;
+    virtual void
+    visit_complex_for_command (tree_complex_for_command&) = 0;
 
-  virtual void
-  visit_function_def (tree_function_def&) = 0;
+    virtual void
+    visit_octave_user_script (octave_user_script&) = 0;
 
-  virtual void
-  visit_identifier (tree_identifier&) = 0;
+    virtual void
+    visit_octave_user_function (octave_user_function&) = 0;
 
-  virtual void
-  visit_if_clause (tree_if_clause&) = 0;
+    virtual void
+    visit_function_def (tree_function_def&) = 0;
 
-  virtual void
-  visit_if_command (tree_if_command&) = 0;
+    virtual void
+    visit_identifier (tree_identifier&) = 0;
 
-  virtual void
-  visit_if_command_list (tree_if_command_list&) = 0;
+    virtual void
+    visit_if_clause (tree_if_clause&) = 0;
 
-  virtual void
-  visit_switch_case (tree_switch_case&) = 0;
+    virtual void
+    visit_if_command (tree_if_command&) = 0;
 
-  virtual void
-  visit_switch_case_list (tree_switch_case_list&) = 0;
+    virtual void
+    visit_if_command_list (tree_if_command_list&) = 0;
 
-  virtual void
-  visit_switch_command (tree_switch_command&) = 0;
+    virtual void
+    visit_switch_case (tree_switch_case&) = 0;
 
-  virtual void
-  visit_index_expression (tree_index_expression&) = 0;
+    virtual void
+    visit_switch_case_list (tree_switch_case_list&) = 0;
 
-  virtual void
-  visit_matrix (tree_matrix&) = 0;
+    virtual void
+    visit_switch_command (tree_switch_command&) = 0;
 
-  virtual void
-  visit_cell (tree_cell&) = 0;
+    virtual void
+    visit_index_expression (tree_index_expression&) = 0;
 
-  virtual void
-  visit_multi_assignment (tree_multi_assignment&) = 0;
+    virtual void
+    visit_matrix (tree_matrix&) = 0;
+
+    virtual void
+    visit_cell (tree_cell&) = 0;
 
-  virtual void
-  visit_no_op_command (tree_no_op_command&) = 0;
+    virtual void
+    visit_multi_assignment (tree_multi_assignment&) = 0;
 
-  virtual void
-  visit_constant (tree_constant&) = 0;
+    virtual void
+    visit_no_op_command (tree_no_op_command&) = 0;
 
-  virtual void
-  visit_fcn_handle (tree_fcn_handle&) = 0;
+    virtual void
+    visit_constant (tree_constant&) = 0;
 
-  virtual void
-  visit_funcall (tree_funcall&) = 0;
+    virtual void
+    visit_fcn_handle (tree_fcn_handle&) = 0;
 
-  virtual void
-  visit_parameter_list (tree_parameter_list&) = 0;
+    virtual void
+    visit_funcall (tree_funcall&) = 0;
 
-  virtual void
-  visit_postfix_expression (tree_postfix_expression&) = 0;
+    virtual void
+    visit_parameter_list (tree_parameter_list&) = 0;
 
-  virtual void
-  visit_prefix_expression (tree_prefix_expression&) = 0;
+    virtual void
+    visit_postfix_expression (tree_postfix_expression&) = 0;
 
-  virtual void
-  visit_return_command (tree_return_command&) = 0;
+    virtual void
+    visit_prefix_expression (tree_prefix_expression&) = 0;
 
-  virtual void
-  visit_return_list (tree_return_list&) = 0;
+    virtual void
+    visit_return_command (tree_return_command&) = 0;
 
-  virtual void
-  visit_simple_assignment (tree_simple_assignment&) = 0;
+    virtual void
+    visit_return_list (tree_return_list&) = 0;
+
+    virtual void
+    visit_simple_assignment (tree_simple_assignment&) = 0;
 
-  virtual void
-  visit_statement (tree_statement&) = 0;
+    virtual void
+    visit_statement (tree_statement&) = 0;
 
-  virtual void
-  visit_statement_list (tree_statement_list&) = 0;
+    virtual void
+    visit_statement_list (tree_statement_list&) = 0;
 
-  virtual void
-  visit_try_catch_command (tree_try_catch_command&) = 0;
+    virtual void
+    visit_try_catch_command (tree_try_catch_command&) = 0;
 
-  virtual void
-  visit_unwind_protect_command (tree_unwind_protect_command&) = 0;
+    virtual void
+    visit_unwind_protect_command (tree_unwind_protect_command&) = 0;
 
-  virtual void
-  visit_while_command (tree_while_command&) = 0;
+    virtual void
+    visit_while_command (tree_while_command&) = 0;
 
-  virtual void
-  visit_do_until_command (tree_do_until_command&) = 0;
+    virtual void
+    visit_do_until_command (tree_do_until_command&) = 0;
 
-  virtual void
-  visit_classdef_attribute (tree_classdef_attribute&) { } /* = 0; */
+    virtual void
+    visit_classdef_attribute (tree_classdef_attribute&) { } /* = 0; */
 
-  virtual void
-  visit_classdef_attribute_list (tree_classdef_attribute_list&) { } // = 0;
+    virtual void
+    visit_classdef_attribute_list (tree_classdef_attribute_list&) { } // = 0;
 
-  virtual void
-  visit_classdef_superclass (tree_classdef_superclass&) { } // = 0;
+    virtual void
+    visit_classdef_superclass (tree_classdef_superclass&) { } // = 0;
 
-  virtual void
-  visit_classdef_superclass_list (tree_classdef_superclass_list&) { } // = 0;
+    virtual void
+    visit_classdef_superclass_list (tree_classdef_superclass_list&) { } // = 0;
+
+    virtual void
+    visit_classdef_property (tree_classdef_property&) { } // = 0;
 
-  virtual void
-  visit_classdef_property (tree_classdef_property&) { } // = 0;
+    virtual void
+    visit_classdef_property_list (tree_classdef_property_list&) { } // = 0;
 
-  virtual void
-  visit_classdef_property_list (tree_classdef_property_list&) { } // = 0;
+    virtual void
+    visit_classdef_properties_block (tree_classdef_properties_block&) { } // = 0;
 
-  virtual void
-  visit_classdef_properties_block (tree_classdef_properties_block&) { } // = 0;
+    virtual void
+    visit_classdef_methods_list (tree_classdef_methods_list&) { } // = 0;
 
-  virtual void
-  visit_classdef_methods_list (tree_classdef_methods_list&) { } // = 0;
+    virtual void
+    visit_classdef_methods_block (tree_classdef_methods_block&) { } // = 0;
 
-  virtual void
-  visit_classdef_methods_block (tree_classdef_methods_block&) { } // = 0;
+    virtual void
+    visit_classdef_event (tree_classdef_event&) { } // = 0;
 
-  virtual void
-  visit_classdef_event (tree_classdef_event&) { } // = 0;
+    virtual void
+    visit_classdef_events_list (tree_classdef_events_list&) { } // = 0;
 
-  virtual void
-  visit_classdef_events_list (tree_classdef_events_list&) { } // = 0;
+    virtual void
+    visit_classdef_events_block (tree_classdef_events_block&) { } // = 0;
 
-  virtual void
-  visit_classdef_events_block (tree_classdef_events_block&) { } // = 0;
+    virtual void
+    visit_classdef_enum (tree_classdef_enum&) { } // = 0;
 
-  virtual void
-  visit_classdef_enum (tree_classdef_enum&) { } // = 0;
+    virtual void
+    visit_classdef_enum_list (tree_classdef_enum_list&) { } // = 0;
 
-  virtual void
-  visit_classdef_enum_list (tree_classdef_enum_list&) { } // = 0;
+    virtual void
+    visit_classdef_enum_block (tree_classdef_enum_block&) { } // = 0;
+
+    virtual void
+    visit_classdef_body (tree_classdef_body&) { } // = 0;
 
-  virtual void
-  visit_classdef_enum_block (tree_classdef_enum_block&) { } // = 0;
+    virtual void
+    visit_classdef (tree_classdef&) { } // = 0;
+  };
+}
 
-  virtual void
-  visit_classdef_body (tree_classdef_body&) { } // = 0;
+#if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
 
-  virtual void
-  visit_classdef (tree_classdef&) { } // = 0;
-};
+OCTAVE_DEPRECATED ("use 'octave::tree_walker' instead")
+typedef octave::tree_walker tree_walker;
 
 #endif
 
+#endif
diff --git a/libinterp/parse-tree/pt.cc b/libinterp/parse-tree/pt.cc
--- a/libinterp/parse-tree/pt.cc
+++ b/libinterp/parse-tree/pt.cc
@@ -28,73 +28,75 @@ along with Octave; see the file COPYING.
 #include <sstream>
 #include <string>
 
 #include "ov-fcn.h"
 #include "pt.h"
 #include "pt-pr-code.h"
 #include "unwind-prot.h"
 
-// Hide the details of the string buffer so that we are less likely to
-// create a memory leak.
-
-std::string
-tree::str_print_code (void)
+namespace octave
 {
-  std::ostringstream buf;
-
-  tree_print_code tpc (buf);
+  // Hide the details of the string buffer so that we are less likely to
+  // create a memory leak.
 
-  accept (tpc);
+  std::string
+  tree::str_print_code (void)
+  {
+    std::ostringstream buf;
 
-  std::string retval = buf.str ();
+    tree_print_code tpc (buf);
+
+    accept (tpc);
+
+    std::string retval = buf.str ();
 
-  return retval;
-}
+    return retval;
+  }
 
-// function from libinterp/parse-tree/oct-parse.cc, not listed in oct-parse.h
-octave_value_list eval_string (const std::string&, bool, int&, int);
-// Is the current breakpoint condition met?
-bool
-tree::meets_bp_condition () const
-{
-  bool retval;
-  if (bp == 0)
-    retval = false;
-  else if (bp->empty ())     // empty condition always met
-    retval = true;
-  else
-    {
-      int parse_status = 0;
+  // function from libinterp/parse-tree/oct-parse.cc, not listed in oct-parse.h
+  octave_value_list eval_string (const std::string&, bool, int&, int);
+  // Is the current breakpoint condition met?
+  bool
+  tree::meets_bp_condition () const
+  {
+    bool retval;
+    if (bp == 0)
+      retval = false;
+    else if (bp->empty ())     // empty condition always met
+      retval = true;
+    else
+      {
+        int parse_status = 0;
 
-      octave::unwind_protect frame;
-      frame.protect_var (buffer_error_messages);
-      frame.protect_var (Vdebug_on_error);
-      frame.protect_var (Vdebug_on_warning);
+        octave::unwind_protect frame;
+        frame.protect_var (buffer_error_messages);
+        frame.protect_var (Vdebug_on_error);
+        frame.protect_var (Vdebug_on_warning);
 
-      buffer_error_messages++;
-      Vdebug_on_error = false;
-      Vdebug_on_warning = false;
+        buffer_error_messages++;
+        Vdebug_on_error = false;
+        Vdebug_on_warning = false;
 
-      retval = true;                // default to stopping if any error
-      try
-        {
-          octave_value_list val = eval_string (*bp, 1, parse_status, 1);
-          if (parse_status == 0)
-            {
-              if (! val(0).is_scalar_type ())
-                warning ("Breakpoint condition must be a scalar, not size %s",
-                         val(0).dims ().str ('x').c_str ());
-              else
-                retval = val(0).bool_value ();
-            }
-          else
-            warning ("Error parsing breakpoint condition");
-        }
-      catch (const octave::execution_exception& e)
-        {
-          warning ("Error evaluating breakpoint condition:\n    %s",
-                   last_error_message ().c_str ());
-        }
-    }
-  return retval;
+        retval = true;                // default to stopping if any error
+        try
+          {
+            octave_value_list val = eval_string (*bp, 1, parse_status, 1);
+            if (parse_status == 0)
+              {
+                if (! val(0).is_scalar_type ())
+                  warning ("Breakpoint condition must be a scalar, not size %s",
+                           val(0).dims ().str ('x').c_str ());
+                else
+                  retval = val(0).bool_value ();
+              }
+            else
+              warning ("Error parsing breakpoint condition");
+          }
+        catch (const octave::execution_exception& e)
+          {
+            warning ("Error evaluating breakpoint condition:\n    %s",
+                     last_error_message ().c_str ());
+          }
+      }
+    return retval;
+  }
 }
-
diff --git a/libinterp/parse-tree/pt.h b/libinterp/parse-tree/pt.h
--- a/libinterp/parse-tree/pt.h
+++ b/libinterp/parse-tree/pt.h
@@ -25,80 +25,88 @@ along with Octave; see the file COPYING.
 
 #include "octave-config.h"
 
 #include <string>
 
 #include <iosfwd>
 
 class octave_function;
-class tree_walker;
-class bp_table;
 
-// Base class for the parse tree.
-
-class
-tree
+namespace octave
 {
-public:
+  class tree_walker;
+
+  // Base class for the parse tree.
 
-  tree (int l = -1, int c = -1)
-    : line_num (l), column_num (c), bp (NULL) { }
+  class tree
+  {
+  public:
 
-  // No copying!
+    tree (int l = -1, int c = -1)
+      : line_num (l), column_num (c), bp (NULL) { }
 
-  tree (const tree&) = delete;
+    // No copying!
+
+    tree (const tree&) = delete;
 
-  tree& operator = (const tree&) = delete;
+    tree& operator = (const tree&) = delete;
 
-  virtual ~tree (void) = default;
+    virtual ~tree (void) = default;
 
-  virtual int line (void) const { return line_num; }
+    virtual int line (void) const { return line_num; }
 
-  virtual int column (void) const { return column_num; }
+    virtual int column (void) const { return column_num; }
 
-  void line (int l) { line_num = l; }
+    void line (int l) { line_num = l; }
 
-  void column (int c) { column_num = c; }
+    void column (int c) { column_num = c; }
 
-  void set_location (int l, int c)
-  {
-    line_num = l;
-    column_num = c;
-  }
+    void set_location (int l, int c)
+    {
+      line_num = l;
+      column_num = c;
+    }
 
-  virtual void set_breakpoint (const std::string& condition)
-  {
-    if (bp)
-      *bp = condition;
-    else
-      bp = new std::string(condition);
-  }
+    virtual void set_breakpoint (const std::string& condition)
+    {
+      if (bp)
+        *bp = condition;
+      else
+        bp = new std::string(condition);
+    }
+
+    virtual void delete_breakpoint (void) { if (bp) delete bp; bp = NULL; }
 
-  virtual void delete_breakpoint (void) { if (bp) delete bp; bp = NULL; }
+    bool meets_bp_condition (void) const;
+
+    bool is_breakpoint (bool check_active = false) const
+    { return bp && (! check_active || meets_bp_condition ()); }
 
-  bool meets_bp_condition (void) const;
-
-  bool is_breakpoint (bool check_active = false) const
-  { return bp && (! check_active || meets_bp_condition ()); }
+    // breakpoint condition, or "0" (i.e., "false") if no breakpoint.
+    // To distinguish "0" from a disabled breakpoint, test "is_breakpoint" too.
+    const std::string bp_cond (void) const
+    { return bp ? *bp : std::string("0"); }
 
-  // breakpoint condition, or "0" (i.e., "false") if no breakpoint.
-  // To distinguish "0" from a disabled breakpoint, test "is_breakpoint" too.
-  const std::string bp_cond (void) const
-  { return bp ? *bp : std::string("0"); }
+    std::string str_print_code (void);
 
-  std::string str_print_code (void);
+    virtual void accept (tree_walker& tw) = 0;
 
-  virtual void accept (tree_walker& tw) = 0;
+  private:
 
-private:
+    // The input line and column where we found the text that was
+    // eventually converted to this tree node.
+    int line_num;
+    int column_num;
 
-  // The input line and column where we found the text that was
-  // eventually converted to this tree node.
-  int line_num;
-  int column_num;
+    // Breakpoint flag: NULL if no breakpoint, or the condition if there is one
+    std::string *bp;
+  };
+}
 
-  // Breakpoint flag: NULL if no breakpoint, or the condition if there is one
-  std::string *bp;
-};
+#if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
+
+OCTAVE_DEPRECATED ("use 'octave::tree' instead")
+typedef octave::tree tree;
 
 #endif
 
+#endif
diff --git a/libinterp/parse-tree/token.h b/libinterp/parse-tree/token.h
--- a/libinterp/parse-tree/token.h
+++ b/libinterp/parse-tree/token.h
@@ -24,120 +24,130 @@ along with Octave; see the file COPYING.
 #define octave_token_h 1
 
 #include "octave-config.h"
 
 #include <string>
 
 #include "symtab.h"
 
-class
-token
+namespace octave
 {
-public:
-
-  enum token_type
-  {
-    generic_token,
-    keyword_token,
-    string_token,
-    double_token,
-    ettype_token,
-    sym_rec_token,
-    scls_name_token,
-  };
-
-  enum end_tok_type
+  class
+  token
   {
-    simple_end,
-    classdef_end,
-    enumeration_end,
-    events_end,
-    for_end,
-    function_end,
-    if_end,
-    methods_end,
-    parfor_end,
-    properties_end,
-    switch_end,
-    try_catch_end,
-    unwind_protect_end,
-    while_end,
-  };
+  public:
+
+    enum token_type
+      {
+        generic_token,
+        keyword_token,
+        string_token,
+        double_token,
+        ettype_token,
+        sym_rec_token,
+        scls_name_token,
+      };
 
-  token (int tv, int l = -1, int c = -1);
-  token (int tv, bool is_keyword, int l = -1, int c = -1);
-  token (int tv, const char *s, int l = -1, int c = -1);
-  token (int tv, const std::string& s, int l = -1, int c = -1);
-  token (int tv, double d, const std::string& s = "",
-         int l = -1, int c = -1);
-  token (int tv, end_tok_type t, int l = -1, int c = -1);
-  token (int tv, symbol_table::symbol_record *s, int l = -1, int c = -1);
-  token (int tv, const std::string& mth, const std::string& cls,
-         int l = -1, int c = -1);
+    enum end_tok_type
+      {
+        simple_end,
+        classdef_end,
+        enumeration_end,
+        events_end,
+        for_end,
+        function_end,
+        if_end,
+        methods_end,
+        parfor_end,
+        properties_end,
+        switch_end,
+        try_catch_end,
+        unwind_protect_end,
+        while_end,
+      };
 
-  // No copying!
-
-  token (const token& tok) = delete;
+    token (int tv, int l = -1, int c = -1);
+    token (int tv, bool is_keyword, int l = -1, int c = -1);
+    token (int tv, const char *s, int l = -1, int c = -1);
+    token (int tv, const std::string& s, int l = -1, int c = -1);
+    token (int tv, double d, const std::string& s = "",
+           int l = -1, int c = -1);
+    token (int tv, end_tok_type t, int l = -1, int c = -1);
+    token (int tv, symbol_table::symbol_record *s, int l = -1, int c = -1);
+    token (int tv, const std::string& mth, const std::string& cls,
+           int l = -1, int c = -1);
 
-  token& operator = (const token& tok) = delete;
+    // No copying!
+
+    token (const token& tok) = delete;
 
-  ~token (void);
+    token& operator = (const token& tok) = delete;
+
+    ~token (void);
+
+    void mark_may_be_command (void) { maybe_cmd = true; }
+    bool may_be_command (void) const { return maybe_cmd; }
 
-  void mark_may_be_command (void) { maybe_cmd = true; }
-  bool may_be_command (void) const { return maybe_cmd; }
+    void mark_trailing_space (void) { tspc = true; }
+    bool space_follows_token (void) const { return tspc; }
+
+    int token_value (void) const { return tok_val; }
+    bool token_value_is (int tv) const { return tv == tok_val; }
 
-  void mark_trailing_space (void) { tspc = true; }
-  bool space_follows_token (void) const { return tspc; }
+    int line (void) const { return line_num; }
+    int column (void) const { return column_num; }
 
-  int token_value (void) const { return tok_val; }
-  bool token_value_is (int tv) const { return tv == tok_val; }
+    bool is_keyword (void) const
+    {
+      return type_tag == keyword_token || type_tag == ettype_token;
+    }
 
-  int line (void) const { return line_num; }
-  int column (void) const { return column_num; }
+    bool is_symbol (void) const
+    {
+      return type_tag == sym_rec_token;
+    }
 
-  bool is_keyword (void) const
-  {
-    return type_tag == keyword_token || type_tag == ettype_token;
-  }
+    std::string text (void) const;
+    std::string symbol_name (void) const;
+    double number (void) const;
+    token_type ttype (void) const;
+    end_tok_type ettype (void) const;
+    symbol_table::symbol_record *sym_rec (void);
 
-  bool is_symbol (void) const
-  {
-    return type_tag == sym_rec_token;
-  }
+    std::string superclass_method_name (void);
+    std::string superclass_class_name (void);
 
-  std::string text (void) const;
-  std::string symbol_name (void) const;
-  double number (void) const;
-  token_type ttype (void) const;
-  end_tok_type ettype (void) const;
-  symbol_table::symbol_record *sym_rec (void);
+    std::string text_rep (void);
 
-  std::string superclass_method_name (void);
-  std::string superclass_class_name (void);
-
-  std::string text_rep (void);
-
-private:
+  private:
 
-  bool maybe_cmd;
-  bool tspc;
-  int line_num;
-  int column_num;
-  int tok_val;
-  token_type type_tag;
-  union
-  {
-    std::string *str;
-    double num;
-    end_tok_type et;
-    symbol_table::symbol_record *sr;
-    struct
+    bool maybe_cmd;
+    bool tspc;
+    int line_num;
+    int column_num;
+    int tok_val;
+    token_type type_tag;
+    union
     {
-      std::string *method_nm;
-      std::string *class_nm;
-    } sc;
+      std::string *str;
+      double num;
+      end_tok_type et;
+      symbol_table::symbol_record *sr;
+      struct
+      {
+        std::string *method_nm;
+        std::string *class_nm;
+      } sc;
+    };
+    std::string orig_text;
   };
-  std::string orig_text;
-};
+}
+
+#if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
+
+OCTAVE_DEPRECATED ("use 'octave::token' instead")
+typedef octave::token token;
 
 #endif
 
+#endif
+
