# HG changeset patch
# User jwe
# Date 1051758029 0
#      Thu May 01 03:00:29 2003 +0000
# Node ID 286a3345aa8efaf578c244e64c4d6ffe76cab416
# Parent  cd8bf2c6797aa8fb0a8e851a7af85dea98a3de53
[project @ 2003-05-01 03:00:28 by jwe]

diff --git a/ChangeLog b/ChangeLog
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,8 +1,12 @@
+2003-04-30  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* configure.in: Don't define WITH_KPATHSEARCH.
+
 2003-04-24  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* configure.in: Look for wsock32 library on MinGW systems.
 
 2003-04-22  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* configure.in (OCTAVE_LOCAL_BUFFER): Always allocate temporary
 	buffer using new.
diff --git a/configure.in b/configure.in
--- a/configure.in
+++ b/configure.in
@@ -17,17 +17,17 @@ dnl Copyright (C) 1996, 1997 John W. Eat
 ### for more details.
 ### 
 ### You should have received a copy of the GNU General Public License
 ### along with Octave; see the file COPYING.  If not, write to the Free
 ### Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ### 02111-1307, USA. 
 
 AC_INIT
-AC_REVISION($Revision: 1.426 $)
+AC_REVISION($Revision: 1.427 $)
 AC_PREREQ(2.52)
 AC_CONFIG_SRCDIR([src/octave.cc])
 AC_CONFIG_HEADER(config.h)
 
 AC_DEFINE(OCTAVE_SOURCE, 1, [Define if this is Octave.])
   
 OCTAVE_HOST_TYPE
 
@@ -1341,18 +1341,16 @@ AH_BOTTOM([
 #define REINTERPRET_CAST(T, E) (T) (E)
 
 #define STATIC_CAST(T, E) (T) (E)
 
 #define X_CAST(T, E) (T) (E)
 
 #define HEAVYWEIGHT_INDEXING 1
 
-#define WITH_KPATHSEARCH 1
-
 #if defined(HAVE_F2C) && !defined(F77_FUNC)
 #  define F77_FUNC(x,X) x ## _
 #  define F77_FUNC_(x,X) x ## __
 #endif
 
 #if !defined(HAVE_DEV_T)
 typedef short dev_t;
 #endif
diff --git a/examples/hello.cc b/examples/hello.cc
--- a/examples/hello.cc
+++ b/examples/hello.cc
@@ -43,17 +43,17 @@
 // The difference between DEFUN_DLD and DEFUN_DLD_BUILTIN is that
 // DEFUN_DLD_BUILTIN can define a built-in function that is not
 // dynamically loaded if the operating system does not support dynamic
 // linking.  To define your own dynamically linked functions you
 // should use DEFUN_DLD.
 
 #include <octave/config.h>
 
-#include <iostream.h>
+#include <iostream>
 
 #include <octave/defun-dld.h>
 #include <octave/error.h>
 #include <octave/oct-obj.h>
 #include <octave/pager.h>
 #include <octave/symtab.h>
 #include <octave/variables.h>
 
diff --git a/liboctave/ChangeLog b/liboctave/ChangeLog
--- a/liboctave/ChangeLog
+++ b/liboctave/ChangeLog
@@ -1,8 +1,24 @@
+2003-04-30  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* pathsearch.cc: Include kpse.cc here.
+
+	* kpse.cc: All functions are now static.  Massive surgery to
+	condense kpathsearch library to a single file of just the
+	essentials for Octave and convert to using C++ strings (no more
+	calls to malloc, very few calls to new, so there should be much
+	less potential for introducing memory leaks now).
+
+	* Makefile.in (EXTRAS): Move kpse.cc here from
+	LIBOCT_PATHSEARCH_CXX_SOURCES.
+
+	* kpse.h, kpse-config.h: Delete.
+	* Makefile.in (INCLUDES): Delete them from the list.
+
 2003-04-26  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* str-vec.cc (string_vector::append (const std::string&),
 	string_vector::append (const string_vector&)): New methods.
 
 2003-04-24  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* kpse.cc, kpse.h: Replace fn_type with std::string.
diff --git a/liboctave/Makefile.in b/liboctave/Makefile.in
--- a/liboctave/Makefile.in
+++ b/liboctave/Makefile.in
@@ -53,17 +53,17 @@ OPTS_INC := $(OPTS_INC_DATA:.in=.h)
 
 INCLUDES := Bounds.h CollocWt.h DAE.h DAEFunc.h DAERT.h \
 	DAERTFunc.h DASPK.h DASRT.h DASSL.h FEGrid.h \
 	LinConst.h LP.h LPsolve.h LSODE.h NLConst.h NLEqn.h \
 	NLFunc.h NLP.h ODE.h ODEFunc.h ODES.h ODESFunc.h \
 	ODESSA.h Objective.h QP.h Quad.h Range.h base-dae.h \
 	base-de.h base-min.h byte-swap.h cmd-edit.h cmd-hist.h \
 	data-conv.h dir-ops.h file-ops.h file-stat.h getopt.h \
-	glob-match.h idx-vector.h kpse.h kpse-config.h kpse-xfns.h \
+	glob-match.h idx-vector.h kpse-xfns.h \
 	lo-ieee.h lo-mappers.h lo-specfun.h lo-sstream.h \
 	lo-sysdep.h lo-utils.h mach-info.h oct-alloc.h oct-cmplx.h \
 	oct-env.h oct-fftw.h oct-getopt.h oct-group.h oct-passwd.h \
 	oct-rand.h oct-rl-edit.h oct-rl-hist.h oct-shlib.h \
 	oct-syscalls.h oct-time.h pathlen.h pathsearch.h \
 	prog-args.h statdefs.h str-vec.h sun-utils.h sysdir.h \
 	systime.h syswait.h \
 	$(OPTS_INC) \
@@ -118,29 +118,29 @@ LIBOCTAVE_C_SOURCES := f2c-main.c filemo
 LIBOCTAVE_SOURCES := $(LIBOCTAVE_CXX_SOURCES) $(LIBOCTAVE_C_SOURCES)
 
 LIBOCT_READLINE_CXX_SOURCES := cmd-edit.cc cmd-hist.cc
 
 LIBOCT_READLINE_C_SOURCES := oct-rl-edit.c oct-rl-hist.c
 
 LIBOCT_READLINE_SOURCES := $(LIBOCT_READLINE_CXX_SOURCES) $(LIBOCT_READLINE_C_SOURCES)
 
-LIBOCT_PATHSEARCH_CXX_SOURCES := pathsearch.cc kpse.cc
+LIBOCT_PATHSEARCH_CXX_SOURCES := pathsearch.cc
 
 LIBOCT_PATHSEARCH_C_SOURCES := kpse-xfns.c
 
 LIBOCT_PATHSEARCH_SOURCES := \
 	$(LIBOCT_PATHSEARCH_C_SOURCES) $(LIBOCT_PATHSEARCH_CXX_SOURCES)
 
 SOURCES := \
 	$(LIBOCTAVE_SOURCES) \
 	$(LIBOCT_READLINE_SOURCES) \
 	$(LIBOCT_PATHSEARCH_SOURCES)
 
-EXTRAS := mx-inlines.cc
+EXTRAS := mx-inlines.cc kpse.cc
 
 INCLUDES_FOR_INSTALL := $(INCLUDES) $(TEMPLATE_SRC) $(EXTRAS)
 
 DISTFILES := Makefile.in ChangeLog $(SOURCES) $(INCLUDES) $(EXTRAS) \
 	$(OPTS_INC_DATA)
 
 ifeq ($(SHARED_LIBS), true)
   BINDISTLIBS = liboctave/liboctave
diff --git a/liboctave/kpse-config.h b/liboctave/kpse-config.h
deleted file mode 100644
--- a/liboctave/kpse-config.h
+++ /dev/null
@@ -1,94 +0,0 @@
-/* config.h: master configuration file, included first by all compilable
-   source files (not headers).
-
-Copyright (C) 1993, 95, 96, 97 Free Software Foundation, Inc.
-
-This library is free software; you can redistribute it and/or
-modify it under the terms of the GNU Library General Public
-License as published by the Free Software Foundation; either
-version 2 of the License, or (at your option) any later version.
-
-This library is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-Library General Public License for more details.
-
-You should have received a copy of the GNU Library General Public
-License along with this library; if not, write to the Free Software
-Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
-
-#ifndef KPATHSEA_CONFIG_H
-#define KPATHSEA_CONFIG_H
-
-#if defined (__cplusplus)
-extern "C" {
-#endif
-
-/* System defines are for non-Unix systems only.  (Testing for all Unix
-   variations should be done in configure.)  Presently the defines used
-   are: DOS OS2 WIN32.  I do not use any of these systems
-   myself; if you do, I'd be grateful for any changes. --kb@mail.tug.org */
-
-/* If we have either DOS or OS2, we are DOSISH.  */
-#if defined (DOS) || defined (OS2) || defined (WIN32) || defined(__MSDOS__)
-#define DOSISH
-#endif
-
-#if defined (DOSISH)
-#define MONOCASE_FILENAMES	/* case-insensitive filename comparisons */
-#endif
-
-#if defined(__MINGW32__)
-#include <windows.h>
-#include <fcntl.h>
-#include <dirent.h>
-#elif defined(WIN32)
-#define __STDC__ 1
-#include "win32lib.h"
-#endif /* not WIN32 */
-
-#ifdef __DJGPP__
-#include <fcntl.h>	/* for long filenames' stuff */
-#include <dir.h>	/* for `getdisk' */
-#include <io.h>		/* for `setmode' */
-#endif
-
-/* Some drivers have partially integrated kpathsea changes.  */
-#ifndef KPATHSEA
-#define KPATHSEA 32
-#endif
- 
-/* System dependencies that are figured out by `configure'.  If we are
-   compiling standalone, we get our c-auto.h.  Otherwise, the package
-   containing us must provide this (unless it can somehow generate ours
-   from c-auto.in).  We use <...> instead of "..." so that the current
-   cpp directory (i.e., kpathsea/) won't be searched. */
-
-/* If you want to find subdirectories in a directory with non-Unix
-   semantics (specifically, if a directory with no subdirectories does
-   not have exactly two links), define this.  */
-#if !defined (DOSISH) || defined(__DJGPP__)
-/* Surprise!  DJGPP returns st_nlink exactly like on Unix.  */
-#define ST_NLINK_TRICK
-#endif /* either not DOSISH or __DJGPP__ */
-
-#ifdef OS2
-#define access ln_access
-#define chmod ln_chmod
-#define creat ln_creat
-#define fopen ln_fopen
-#define freopen ln_freopen
-#define lstat ln_lstat
-#define open ln_open
-#define remove ln_remove
-#define rename ln_rename
-#define sopen ln_sopen
-#define stat ln_stat
-#define unlink ln_unlink
-#endif /* OS2 */
-
-#if defined (__cplusplus)
-}
-#endif
-
-#endif /* not KPATHSEA_CONFIG_H */
diff --git a/liboctave/kpse-xfns.c b/liboctave/kpse-xfns.c
--- a/liboctave/kpse-xfns.c
+++ b/liboctave/kpse-xfns.c
@@ -1,9 +1,9 @@
-/* xfns.c: All the x* functions from kpathsearch in one file.
+/*
 
 Copyright (C) 1992, 93, 94, 95, 96 Free Software Foundation, Inc.
 Copyright (C) 1993, 94, 95, 96, 97, 98 Karl Berry.
 Copyright (C) 1994, 95, 96, 97 Karl Berry & Olaf Weber.
 
 This library is free software; you can redistribute it and/or
 modify it under the terms of the GNU Library General Public
 License as published by the Free Software Foundation; either
@@ -21,17 +21,17 @@ Foundation, Inc., 59 Temple Place - Suit
 #if defined (HAVE_CONFIG_H)
 #include <config.h>
 #endif
 
 #include <string.h>
 
 #include "kpse-xfns.h"
 
-/* basename.c: return the last element in a path.  */
+/* Return the last element in a path.  */
 
 #ifndef HAVE_BASENAME
 
 /* Return NAME with any leading path stripped off.  This returns a
    pointer into NAME.  For example, `basename ("/foo/bar.baz")'
    returns "bar.baz".  */
 
 static const char *
@@ -50,13 +50,13 @@ basename (const char *name)
   if (!base)
     base = name;
   
   return base;
 }
 
 #endif
 
-char *
-xbasename (const char *name)
+const char *
+octave_basename (const char *name)
 {
-  return (char *) basename (name);
+  return (const char *) basename (name);
 }
diff --git a/liboctave/kpse-xfns.h b/liboctave/kpse-xfns.h
--- a/liboctave/kpse-xfns.h
+++ b/liboctave/kpse-xfns.h
@@ -1,9 +1,9 @@
-/* lib.h: declarations for common, low-level routines in kpathsea.
+/*
 
 Copyright (C) 1992, 93, 94, 95, 96, 97 Free Software Foundation, Inc.
 Copyright (C) 1993, 94, 95, 96 Karl Berry.
 Copyright (C) 1997, 1998 Free Software Foundation, Inc.
 
 This library is free software; you can redistribute it and/or
 modify it under the terms of the GNU Library General Public
 License as published by the Free Software Foundation; either
@@ -13,17 +13,20 @@ This library is distributed in the hope 
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 Library General Public License for more details.
 
 You should have received a copy of the GNU Library General Public
 License along with this library; if not, write to the Free Software
 Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
 
-/* c-pathch.h: define the characters which separate components of
+#if !defined (octave_kpse_xfns_h)
+#define octave_kpse_xfns_h 1
+
+/* Define the characters which separate components of
    filenames and environment variable paths.  */
 
 /* What separates filename components?  */
 #ifndef DIR_SEP
 #ifdef DOSISH
 /* Either \'s or 's work.  Wayne Sullivan's web2pc prefers /, so we'll
    go with that.  */
 #define DIR_SEP '/'
@@ -42,8 +45,26 @@ Foundation, Inc., 59 Temple Place - Suit
 #define IS_DIR_SEP(ch) ((ch) == DIR_SEP)
 #endif
 #ifndef IS_DEVICE_SEP /* No `devices' on, e.g., Unix.  */
 #define IS_DEVICE_SEP(ch) 0 
 #endif
 #ifndef NAME_BEGINS_WITH_DEVICE
 #define NAME_BEGINS_WITH_DEVICE(name) 0 
 #endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+extern const char *octave_basename (const char *name);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
+/*
+;;; Local Variables: ***
+;;; mode: C ***
+;;; End: ***
+*/
diff --git a/liboctave/kpse.cc b/liboctave/kpse.cc
--- a/liboctave/kpse.cc
+++ b/liboctave/kpse.cc
@@ -1,13 +1,16 @@
-/* pathsearch.c: look up a filename in a path.
+// This file is not compiled to a separate object file.  It is
+// included in pathsearch.cc.
+
+/* Look up a filename in a path.
 
 Copyright (C) 1993, 94, 95, 96, 97, 98 Karl Berry.
 Copyright (C) 1993, 94, 95, 96, 97 Karl Berry & O. Weber.
-Copyright (C) 1992, 93, 94, 95, 96 Free Software Foundation, Inc.
+Copyright (C) 1992, 93, 94, 95, 96, 97 Free Software Foundation, Inc.
 
 This library is free software; you can redistribute it and/or
 modify it under the terms of the GNU Library General Public
 License as published by the Free Software Foundation; either
 version 2 of the License, or (at your option) any later version.
 
 This library is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
@@ -20,34 +23,87 @@ Foundation, Inc., 59 Temple Place - Suit
 
 #if defined (HAVE_CONFIG_H)
 #include <config.h>
 #endif
 
 #include <map>
 #include <string>
 
-#include "kpse-config.h"
+/* System defines are for non-Unix systems only.  (Testing for all Unix
+   variations should be done in configure.)  Presently the defines used
+   are: DOS OS2 WIN32.  I do not use any of these systems
+   myself; if you do, I'd be grateful for any changes. --kb@mail.tug.org */
+
+/* If we have either DOS or OS2, we are DOSISH.  */
+#if defined (DOS) || defined (OS2) || defined (WIN32) || defined(__MSDOS__)
+#define DOSISH
+#endif
+
+#if defined (DOSISH)
+#define MONOCASE_FILENAMES	/* case-insensitive filename comparisons */
+#endif
+
+extern "C" {
+#if defined(__MINGW32__)
+#include <windows.h>
+#include <fcntl.h>
+#include <dirent.h>
+#elif defined(WIN32)
+#define __STDC__ 1
+#include "win32lib.h"
+#endif /* not WIN32 */
+
+#ifdef __DJGPP__
+#include <fcntl.h>	/* for long filenames' stuff */
+#include <dir.h>	/* for `getdisk' */
+#include <io.h>		/* for `setmode' */
+#endif
+}
+
+/* Some drivers have partially integrated kpathsea changes.  */
+#ifndef KPATHSEA
+#define KPATHSEA 32
+#endif
+ 
+/* System dependencies that are figured out by `configure'.  If we are
+   compiling standalone, we get our c-auto.h.  Otherwise, the package
+   containing us must provide this (unless it can somehow generate ours
+   from c-auto.in).  We use <...> instead of "..." so that the current
+   cpp directory (i.e., kpathsea/) won't be searched. */
+
+/* If you want to find subdirectories in a directory with non-Unix
+   semantics (specifically, if a directory with no subdirectories does
+   not have exactly two links), define this.  */
+#if !defined (DOSISH) || defined(__DJGPP__)
+/* Surprise!  DJGPP returns st_nlink exactly like on Unix.  */
+#define ST_NLINK_TRICK
+#endif /* either not DOSISH or __DJGPP__ */
+
+#ifdef OS2
+#define access ln_access
+#define fopen ln_fopen
+#define rename ln_rename
+#define stat ln_stat
+#endif /* OS2 */
+
 #include "kpse-xfns.h"
-#include "kpse.h"
 
 #include "lo-error.h"
 #include "lo-sstream.h"
 #include "oct-env.h"
 #include "oct-passwd.h"
-
-/* c-std.h: the first header files.  */
+#include "str-vec.h"
 
 /* Header files that essentially all of our sources need, and
    that all implementations have.  We include these first, to help with
    NULL being defined multiple times.  */
 #include <cstdio>
 #include <cstdarg>
 #include <cstdlib>
-#include <cstring>
 #include <climits>
 #include <cerrno>
 #include <cassert>
 
 #ifdef HAVE_UNISTD_H
 #ifdef HAVE_SYS_TYPES_H
 #include <sys/types.h>
 #endif
@@ -66,18 +122,16 @@ Foundation, Inc., 59 Temple Place - Suit
 #ifndef _POSIX_NAME_MAX
 #define _POSIX_NAME_MAX 255
 #endif
 
 #ifndef NAME_MAX
 #define NAME_MAX _POSIX_NAME_MAX
 #endif
 
-/* c-ctype.h: ASCII-safe versions of the <ctype.h> macros.  */
-
 #include <cctype>
 
 /* What separates elements in environment variable path lists?  */
 #ifndef ENV_SEP
 #ifdef DOSISH
 #define ENV_SEP ';'
 #define ENV_SEP_STRING ";"
 #else
@@ -85,37 +139,35 @@ Foundation, Inc., 59 Temple Place - Suit
 #define ENV_SEP_STRING ":"
 #endif /* not DOS */
 #endif /* not ENV_SEP */
 
 #ifndef IS_ENV_SEP
 #define IS_ENV_SEP(ch) ((ch) == ENV_SEP)
 #endif
 
-/* c-pathmx.h: define PATH_MAX, the maximum length of a filename.
-   Since no such limit may exist, it's preferable to dynamically grow
-   filenames as needed.  */
+/* define PATH_MAX, the maximum length of a filename.  Since no such
+   limit may exist, it's preferable to dynamically grow filenames as
+   needed.  */
 
 /* Cheat and define this as a manifest constant no matter what, instead
    of using pathconf.  I forget why we want to do this.  */
 
 #ifndef _POSIX_PATH_MAX
 #define _POSIX_PATH_MAX 255
 #endif
 
 #ifndef PATH_MAX
 #ifdef MAXPATHLEN
 #define PATH_MAX MAXPATHLEN
 #else
 #define PATH_MAX _POSIX_PATH_MAX
 #endif
 #endif /* not PATH_MAX */
 
-/* debug.h: Runtime tracing.  */
-
 /* If NO_DEBUG is defined (not recommended), skip all this.  */
 #ifndef NO_DEBUG
 
 /* OK, we'll have tracing support.  */
 #define KPSE_DEBUG
 
 /* Test if a bit is on.  */
 #define KPSE_DEBUG_P(bit) (kpathsea_debug & (1 << (bit)))
@@ -141,23 +193,27 @@ Foundation, Inc., 59 Temple Place - Suit
   DEBUGF_START (); fprintf (stderr, str, e1, e2); DEBUGF_END ()
 #define DEBUGF3(str, e1, e2, e3)					\
   DEBUGF_START (); fprintf (stderr, str, e1, e2, e3); DEBUGF_END ()
 #define DEBUGF4(str, e1, e2, e3, e4)					\
   DEBUGF_START (); fprintf (stderr, str, e1, e2, e3, e4); DEBUGF_END ()
 
 #undef fopen
 #define fopen kpse_fopen_trace
-extern FILE *fopen (const char *filename, const char *mode);
+static FILE *fopen (const char *filename, const char *mode);
 #undef fclose
 #define fclose kpse_fclose_trace
-extern int fclose (FILE *);
+static int fclose (FILE *);
 
 #endif /* not NO_DEBUG */
 
+#ifdef KPSE_DEBUG
+static unsigned int kpathsea_debug = 0;
+#endif
+
 #if defined (WIN32) && !defined (__MINGW32__)
 
 /* System description file for Windows NT.  */
 
 /*
  *      Define symbols to identify the version of Unix this is.
  *      Define all the symbols that apply correctly.
  */
@@ -170,19 +226,17 @@ extern int fclose (FILE *);
 #define MAXPATHLEN      _MAX_PATH
 #endif
 
 /* These have to be defined because our compilers treat __STDC__ as being
    defined (most of them anyway). */
 
 #define access  _access
 #define stat    _stat
-#define strcasecmp _stricmp
 #define strdup  _strdup
-#define strncasecmp _strnicmp
 
 #define S_IFMT   _S_IFMT
 #define S_IFDIR  _S_IFDIR
 
 /* Define this so that winsock.h definitions don't get included when
    windows.h is...  For this to have proper effect, config.h must
    always be included before windows.h.  */
 #define _WINSOCKAPI_    1
@@ -193,18 +247,16 @@ extern int fclose (FILE *);
 #include <io.h>
 #include <fcntl.h>
 #include <process.h>
 
 /* ============================================================ */
 
 #endif /* WIN32 */
 
-/* lib.h: other stuff.  */
-
 /* Define common sorts of messages.  */
 
 /* This should be called only after a system call fails.  Don't exit
    with status `errno', because that might be 256, which would mean
    success (exit statuses are truncated to eight bits).  */
 #define FATAL_PERROR(str) \
   do \
     { \
@@ -218,92 +270,63 @@ extern int fclose (FILE *);
     { \
       fputs ("pathsearch: fatal: ", stderr); \
       fputs (str, stderr); \
       fputs (".\n", stderr); \
       exit (1); \
     } \
   while (0)
 
-extern "C" char *xbasename (const char *name);
-
 #ifndef WIN32
 static void xclosedir (DIR *d);
 #endif
 
+/* It's a little bizarre to be using the same type for the list and the
+   elements of the list, but no reason not to in this case, I think --
+   we never need a NULL string in the middle of the list, and an extra
+   NULL/NULL element always at the end is inconsequential.  */
+
+struct str_llist_elt
+{
+  std::string str;
+  int moved;
+  struct str_llist_elt *next;
+};
+
+typedef str_llist_elt str_llist_elt_type;
+typedef str_llist_elt *str_llist_type;
+
+#define STR_LLIST(sl) ((sl).str)
+#define STR_LLIST_MOVED(sl) ((sl).moved)
+#define STR_LLIST_NEXT(sl) ((sl).next)
+
 static void str_llist_add (str_llist_type *l, const std::string& str);
 
 static void str_llist_float (str_llist_type *l, str_llist_elt_type *mover);
 
 static std::string kpse_var_expand (const std::string& src);
 
+static str_llist_type *kpse_element_dirs (const std::string& elt);
+
+static std::string kpse_expand (const std::string& s);
+
+static std::string kpse_expand_default (const std::string& path,
+					const std::string& dflt);
+
+static string_vector kpse_db_search (const std::string& name,
+				     const std::string& path_elt, bool all);
+
 #include <ctime> /* for `time' */
 
-bool
+static bool
 kpse_is_env_sep (char c)
 {
   return IS_ENV_SEP (c);
 }
 
-/* xmalloc.c: malloc with error checking.  */
-
-static void *
-xmalloc (unsigned size)
-{
-  void *new_mem = (void *) malloc (size);
-
-  if (! new_mem)
-    {
-      fprintf (stderr, "fatal: memory exhausted (xmalloc of %u bytes).\n",
-               size);
-      /* 1 means success on VMS, so pick a random number (ASCII `K').  */
-      exit (75);
-    }
-
-  return new_mem;
-}
-
-/* xrealloc.c: realloc with error checking.  */
-
-static void *
-xrealloc (void *old_ptr, unsigned size)
-{
-  void *new_mem;
-
-  if (! old_ptr)
-    new_mem = xmalloc (size);
-  else
-    {
-      new_mem = (void *) realloc (old_ptr, size);
-
-      if (! new_mem)
-        {
-          /* We used to print OLD_PTR here using %x, and casting its
-             value to unsigned, but that lost on the Alpha, where
-             pointers and unsigned had different sizes.  Since the info
-             is of little or no value anyway, just don't print it.  */
-          fprintf (stderr, "fatal: memory exhausted (realloc of %u bytes).\n",
-                   size);
-          /* 1 means success on VMS, so pick a random number (ASCII `B').  */
-          exit (66);
-        }
-    }
-
-  return new_mem;
-}
-
-/* Return a copy of S in new storage.  */
-
-static char *
-xstrdup (const char *s)
-{
-  char *new_string = (char *) xmalloc (strlen (s) + 1);
-  return strcpy (new_string, s);
-}
-
 /* These routines just check the return status from standard library
    routines and abort if an error happens.  */
 
 static FILE *
 xfopen (const std::string& filename, const char *mode)
 {
   FILE *f;
 
@@ -482,16 +505,75 @@ hash_print (hash_table_type table, int s
 	   "%u buckets, %u nonempty (%u%%); %u entries, average chain %.1f.\n",
 	   table.size,
 	   total_buckets,
 	   100 * total_buckets / table.size,
 	   total_elements,
 	   total_buckets ? total_elements / (double) total_buckets : 0.0);
 }
 
+/* A way to step through a path, extracting one directory name at a
+   time.  */
+
+class kpse_path_iterator
+{
+public:
+
+  kpse_path_iterator (const std::string& p)
+    : path (p), b (0), e (0), len (path.length ()) { set_end (); }
+
+  kpse_path_iterator (const kpse_path_iterator& pi)
+    : path (pi.path), b (pi.b), e (pi.e), len (pi.len) { }
+
+  kpse_path_iterator operator ++ (int)
+    {
+      kpse_path_iterator retval (*this);
+      next ();
+      return retval;
+    }
+
+  std::string operator * (void) { return path.substr (b, e-b); }
+
+  bool operator != (const size_t sz) { return b != sz; }
+
+private:
+
+  const std::string& path;
+  size_t b;
+  size_t e;
+  size_t len;
+
+  void set_end (void)
+    {
+      e = b + 1;
+
+      if (e >= len)
+	b = e = NPOS;
+      else
+	{
+	  /* Find the next colon not enclosed by braces (or the end of
+	     the path).  */
+
+	  int brace_level = 0;
+	  while (e < len && ! (brace_level == 0 && kpse_is_env_sep (path[e])))
+	    e++;
+	}
+    }
+
+  void next (void)
+    {
+      b = e + 1;
+
+      if (b >= len)
+	b = e = NPOS;
+      else
+	set_end ();
+    }
+};
+
 /* Here's the simple one, when a program just wants a value.  */
 
 static std::string
 kpse_var_value (const std::string& var)
 {
   std::string ret;
 
   std::string tmp = octave_env::getenv (var);
@@ -886,29 +968,50 @@ search (const std::string& path, const s
 	putc ('\n', stderr);
     }
 
   return ret_list;
 }
 
 /* Search PATH for the first NAME.  */
 
-std::string
+/* Call `kpse_expand' on NAME.  If the result is an absolute or
+   explicitly relative filename, check whether it is a readable
+   (regular) file.
+   
+   Otherwise, look in each of the directories specified in PATH (also do
+   tilde and variable expansion on elements in PATH), using a prebuilt
+   db (see db.h) if it's relevant for a given path element.
+   
+   If the prebuilt db doesn't exist, or if MUST_EXIST is true and NAME
+   isn't found in the prebuilt db, look on the filesystem.  (I.e., if
+   MUST_EXIST is false, and NAME isn't found in the db, do *not* look on
+   the filesystem.)
+   
+   The caller must expand PATH. This is because it makes more sense to
+   do this once, in advance, instead of for every search using it.
+   
+   In any case, return the complete filename if found, otherwise NULL.  */
+
+static std::string
 kpse_path_search (const std::string& path, const std::string& name,
 		  bool must_exist)
 {
   string_vector ret_list = search (path, name, must_exist, false);
 
   return ret_list.empty () ? std::string () : ret_list[0];
 }
 
 /* Search all elements of PATH for files named NAME.  Not sure if it's
    right to assert `must_exist' here, but it suffices now.  */
 
-string_vector
+/* Like `kpse_path_search' with MUST_EXIST true, but return a list of
+   all the filenames (or NULL if none), instead of taking the first.  */
+
+static string_vector
 kpse_all_path_search (const std::string& path, const std::string& name)
 {
   return search (path, name, true, true);
 }
 
 /* This is the hard case -- look in each element of PATH for each
    element of NAMES.  If ALL is false, return the first file found.
    Otherwise, search all elements of PATH.  */
@@ -1082,36 +1185,43 @@ find_first_of (const std::string& path, 
     }
 
   return ret_list;
 }
 
 /* Search each element of PATH for each element of NAMES.  Return the
    first one found.  */
 
-std::string
+/* Search each element of PATH for each element in the list of NAMES.
+   Return the first one found.  */
+
+static std::string
 kpse_path_find_first_of (const std::string& path, const string_vector& names,
 			 bool must_exist)
 {
   string_vector ret_list = find_first_of (path, names, must_exist, false);
 
   return ret_list.empty () ? std::string () : ret_list[0];
 }
 
 /* Search each element of PATH for each element of NAMES and return a
    list containing everything found, in the order found.  */
 
-string_vector
+/* Like `kpse_path_find_first_of' with MUST_EXIST true, but return a
+   list of all the filenames (or NULL if none), instead of taking the
+   first.  */
+
+static string_vector
 kpse_all_path_find_first_of (const std::string& path,
 			     const string_vector& names)
 {
   return find_first_of (path, names, true, true);
 }
 
-/* expand.c: general expansion.  Some of this file (the brace-expansion
+/* General expansion.  Some of this file (the brace-expansion
    code from bash) is covered by the GPL; this is the only GPL-covered
    code in kpathsea.  The part of the file that I wrote (the first
    couple of functions) is covered by the LGPL.  */
 
 /* If NAME has a leading ~ or ~user, Unix-style, expand it to the user's
    home directory, and return a new malloced string.  If no ~, or no
    <pwd.h>, just return NAME.  */
 
@@ -1200,17 +1310,20 @@ kpse_tilde_expand (const std::string& na
 #endif /* not HAVE_PWD_H */
 
   return expansion;
 }
 
 /* Do variable expansion first so ~${USER} works.  (Besides, it's what the
    shells do.)  */
 
-std::string
+/* Call kpse_var_expand and kpse_tilde_expand (in that order).  Result
+   is always in fresh memory, even if no expansions were done.  */
+
+static std::string
 kpse_expand (const std::string& s)
 {
   std::string var_expansion = kpse_var_expand (s);
   return kpse_tilde_expand (var_expansion);
 }
 
 /* Forward declarations of functions from the original expand.c  */
 static string_vector brace_expand (const std::string&);
@@ -1283,19 +1396,23 @@ kpse_brace_expand_element (const std::st
       ret += x + ENV_SEP_STRING;
     }
 
   ret.resize (ret.length () - 1);
 
   return ret;
 }
 
-/* Be careful to not waste all the memory we allocate for each element.  */
-
-std::string
+/* Do brace expansion and call `kpse_expand' on each element of the
+   result; return the final expansion (always in fresh memory, even if
+   no expansions were done).  We don't call `kpse_expand_default'
+   because there is a whole sequence of defaults to run through; see
+   `kpse_init_format'.  */
+
+static std::string
 kpse_brace_expand (const std::string& path)
 {
   /* Must do variable expansion first because if we have
        foo = .:~
        TEXINPUTS = $foo
      we want to end up with TEXINPUTS = .:/home/karl.
      Since kpse_path_element is not reentrant, we must get all
      the path elements before we start the loop.  */
@@ -1316,17 +1433,23 @@ kpse_brace_expand (const std::string& pa
   if (len > 0)
     ret.resize (len-1);
 
   return kpse_expand_kpse_dot (ret);
 }
 
 /* Expand all special constructs in a path, and include only the actually
    existing directories in the result. */
-std::string
+
+/* Do brace expansion and call `kpse_expand' on each argument of the
+   result, then expand any `//' constructs.  The final expansion (always
+   in fresh memory) is a path of all the existing directories that match
+   the pattern. */
+
+static std::string
 kpse_path_expand (const std::string& path)
 {
   std::string ret;
   unsigned len;
 
   len = 0;
 
   /* Expand variables and braces first.  */
@@ -1604,41 +1727,41 @@ brace_gobbler (const std::string& text, 
       else if (c == '}' && level)
 	level--;
     }
 
   indx = i;
   return c;
 }
 
-/* db.c: an external database to avoid filesystem lookups.  */
+/* An external database to avoid filesystem lookups.  */
 
 #ifndef DEFAULT_TEXMFDBS
 #define DEFAULT_TEXMFDBS "/usr/local/share/texmf:/var/tmp/texfonts"
 #endif
 
 /* For each file format, we record the following information.  The main
    thing that is not part of this structure is the environment variable
    lists. They are used directly in tex-file.c. We could incorporate
    them here, but it would complicate the code a bit. We could also do
    it via variable expansion, but not now, maybe not ever:
    ${PKFONTS-${TEXFONTS-/usr/local/lib/texmf/fonts//}}.  */
 
-typedef struct
+struct kpse_format_info_type
 {
   std::string type;	     /* Human-readable description.  */
   std::string path;	     /* The search path to use.  */
   std::string raw_path;	     /* Pre-$~ (but post-default) expansion.  */
   std::string path_source;   /* Where the path started from.  */
   std::string override_path; /* From client environment variable.  */
   std::string client_path;   /* E.g., from dvips's config.ps.  */
   std::string cnf_path;	     /* From texmf.cnf.  */
   std::string default_path;  /* If all else fails.  */
   string_vector suffix;	     /* For kpse_find_file to check for/append.  */
-} kpse_format_info_type;
+};
 
 /* The sole variable of that type, indexed by `kpse_file_format_type'.
    Initialized by calls to `kpse_find_file' for `kpse_init_format'.  */
 static kpse_format_info_type kpse_format_info;
 
 #define DB_ENVS "TEXMFDBS"
 
 /* And EXPAND_DEFAULT calls kpse_expand_default on try_path and the
@@ -1832,26 +1955,27 @@ static hash_table_type alias_db;
 
 static string_vector db_dir_list;
 
 /* If DIRNAME contains any element beginning with a `.' (that is more
    than just `./'), return true.  This is to allow ``hidden''
    directories -- ones that don't get searched.  */
 
 static bool
-ignore_dir_p (const std::string& dirname_arg)
+ignore_dir_p (const std::string& dirname)
 {
-  const char *dirname = dirname_arg.c_str ();
-
-  const char *dot_pos = dirname;
-
-  while ((dot_pos = strchr (dot_pos + 1, '.')))
+  size_t dot_pos = 0;
+  size_t len = dirname.length ();
+
+  while ((dot_pos = dirname.find ('.', dot_pos + 1)) != NPOS)
     {
-      /* If / before and no / after, skip it. */
-      if (IS_DIR_SEP (dot_pos[-1]) && dot_pos[1] && !IS_DIR_SEP (dot_pos[1]))
+      /* If / before and no / after, skip it.  But don't skip xxx/../yyy.  */
+      if (IS_DIR_SEP (dirname[dot_pos-1])
+	  && dot_pos + 1 < len
+	  && ! (IS_DIR_SEP (dirname[dot_pos+1]) || dirname[dot_pos+1] == '.'))
 	return true;
     }
 
   return false;
 }
 
 static bool
 read_line (FILE *f, std::string& line)
@@ -1997,30 +2121,30 @@ db_build (hash_table_type *table, const 
 
   return db_file != 0;
 }
 
 /* Insert FNAME into the hash table.  This is for files that get built
    during a run.  We wouldn't want to reread all of ls-R, even if it got
    rebuilt.  */
 
-void
+static void
 kpse_db_insert (const std::string& passed_fname)
 {
   /* We might not have found ls-R, or even had occasion to look for it
      yet, so do nothing if we have no hash table.  */
   if (db.buckets)
     {
-      const char *dir_part;
-      char *fname = xstrdup (passed_fname.c_str ());
-      char *baseptr = xbasename (fname);
-      const char *file_part = xstrdup (baseptr);
-
-      *baseptr = '\0';  /* Chop off the filename.  */
-      dir_part = fname; /* That leaves the dir, with the trailing /.  */
+      const char *fname = passed_fname.c_str ();
+      const char *baseptr = octave_basename (fname);
+
+      size_t len = baseptr - fname;
+
+      std::string file_part = passed_fname.substr (len);
+      std::string dir_part = passed_fname.substr (0, len);
 
       hash_insert (&db, file_part, dir_part);
     }
 }
 
 /* Return true if FILENAME could be in PATH_ELT, i.e., if the directory
    part of FILENAME matches PATH_ELT.  Have to consider // wildcards, but
    $ and ~ expansion have already been done.  */
@@ -2201,19 +2325,20 @@ alias_build (hash_table_type *table, con
 
       xfclose (alias_file, alias_filename);
     }
 
   return alias_file != 0;
 }
 
 /* Initialize the path for ls-R files, and read them all into the hash
-   table `db'.  If no usable ls-R's are found, set db.buckets to NULL.  */
-
-void
+   table `db'.  If no usable ls-R's are found, set db.buckets to NULL.
+   Until this is called, no ls-R matches will be found.  */
+
+static void
 kpse_init_db (void)
 {
   bool ok = false;
   const std::string db_path = kpse_init_format ();
   string_vector db_files = kpse_all_path_search (db_path.c_str (), DB_NAME);
 
   /* Must do this after the path searching (which ends up calling
     kpse_db_search recursively), so db.buckets stays NULL.  */
@@ -2259,17 +2384,23 @@ kpse_init_db (void)
     {
       free (alias_db.buckets);
       alias_db.buckets = 0;
     }
 }
 
 /* Avoid doing anything if this PATH_ELT is irrelevant to the databases. */
 
-string_vector
+/* Return list of matches for NAME in the ls-R file matching PATH_ELT.  If
+   ALL is set, return (null-terminated list) of all matches, else just
+   the first.  If no matches, return a pointer to an empty list.  If no
+   databases can be read, or PATH_ELT is not in any of the databases,
+   return NULL.  */
+
+static string_vector
 kpse_db_search (const std::string& name_arg,
 		const std::string& orig_path_elt, bool all)
 {
   bool done;
   string_vector ret;
   string_vector aliases;
   bool relevant = false;
 
@@ -2381,22 +2512,26 @@ kpse_db_search (const std::string& name_
 		}
 	    }
 	}
     }
 
   return ret;
 }
 
-/* kdefault.c: Expand extra colons.  */
+/* Expand extra colons.  */
 
 /* Check for leading colon first, then trailing, then doubled, since
    that is fastest.  Usually it will be leading or trailing.  */
 
-std::string
+/* Replace a leading or trailing or doubled : in PATH with DFLT.  If
+   no extra colons, return PATH.  Only one extra colon is replaced.
+   DFLT may not be NULL.  */
+
+static std::string
 kpse_expand_default (const std::string& path, const std::string& fallback)
 {
   std::string expansion;
 
   size_t path_len = path.length ();
 
   if (path_len == 0)
     expansion = fallback;
@@ -2435,18 +2570,17 @@ kpse_expand_default (const std::string& 
 	      break;
             }
         }
     }
 
   return expansion;
 }
 
-/* elt-dirs.c: Translate a path element to its corresponding
-   director{y,ies}.  */
+/* Translate a path element to its corresponding director{y,ies}.  */
 
 /* To avoid giving prototypes for all the routines and then their real
    definitions, we give all the subroutines first.  The entry point is
    the last routine in the file.  */
 
 /* Make a copy of DIR (unless it's null) and save it in L.  Ensure that
    DIR ends with a DIR_SEP for the benefit of later searches.  */
 
@@ -2506,17 +2640,17 @@ static unsigned cache_length = 0;
    we always add it to our list.  We copy KEY but not VALUE; not sure
    that's right, but it seems to be all that's needed.  */
 
 static void
 cache (const std::string key, str_llist_type *value)
 {
   cache_entry *new_cache = new cache_entry [cache_length+1];
 
-  for (int i = 0; i < cache_length; i++)
+  for (unsigned i = 0; i < cache_length; i++)
     {
       new_cache[i].key = the_cache[i].key;
       new_cache[i].value = the_cache[i].value;
     }
 
   delete [] the_cache;
 
   the_cache = new_cache;
@@ -2771,17 +2905,26 @@ expand_elt (str_llist_type *str_list_ptr
     }
 
   /* When we reach the end of ELT, it will be a normal filename.  */
   checked_dir_list_add (str_list_ptr, elt);
 }
 
 /* Here is the entry point.  Returns directory list for ELT.  */
 
-str_llist_type *
+/* Given a path element ELT, return a pointer to a NULL-terminated list
+   of the corresponding (existing) directory or directories, with
+   trailing slashes, or NULL.  If ELT is the empty string, check the
+   current working directory.
+   
+   It's up to the caller to expand ELT.  This is because this routine is
+   most likely only useful to be called from `kpse_path_search', which
+   has already assumed expansion has been done.  */
+
+static str_llist_type *
 kpse_element_dirs (const std::string& elt)
 {
   str_llist_type *ret;
 
   /* If given nothing, return nothing.  */
   if (elt.empty ())
     return 0;
 
@@ -2829,52 +2972,50 @@ xclosedir (DIR *d)
   int ret = closedir (d);
 
   if (ret != 0)
     FATAL ("closedir failed");
 #endif
 }
 #endif
 
-/* debug.c: Help the user discover what's going on.  */
+/* Help the user discover what's going on.  */
 
 #ifdef KPSE_DEBUG
 
-unsigned int kpathsea_debug = 0;
-
 /* If the real definitions of fopen or fclose are macros, we lose -- the
    #undef won't restore them. */
 
-FILE *
+static FILE *
 fopen (const char *filename, const char *mode)
 {
 #undef fopen
   FILE *ret = fopen (filename, mode);
 
   if (KPSE_DEBUG_P (KPSE_DEBUG_FOPEN))
     DEBUGF3 ("fopen (%s, %s) => 0x%lx\n", filename, mode, (unsigned long) ret);
 
   return ret;
 }
 
-int
+static int
 fclose (FILE *f)
 {
 #undef fclose
   int ret = fclose (f);
 
   if (KPSE_DEBUG_P (KPSE_DEBUG_FOPEN))
     DEBUGF2 ("fclose (0x%lx) => %d\n", (unsigned long) f, ret);
 
   return ret;
 }
 
 #endif
 
-/* str-llist.c: Implementation of a linked list of strings.  */
+/* Implementation of a linked list of strings.  */
 
 /* Add the new string STR to the end of the list L.  */
 
 void
 str_llist_add (str_llist_type *l, const std::string& str)
 {
   str_llist_elt_type *e;
   str_llist_elt_type *new_elt = new str_llist_elt_type;
@@ -2938,17 +3079,17 @@ str_llist_float (str_llist_type *l, str_
       else
         STR_LLIST_NEXT (*last_moved) = mover;
     }
 
   /* We've moved it.  */
   STR_LLIST_MOVED (*mover) = 1;
 }
 
-/* variable.c: variable expansion.  */
+/* Variable expansion.  */
 
 /* We have to keep track of variables being expanded, otherwise
    constructs like TEXINPUTS = $TEXINPUTS result in an infinite loop.
    (Or indirectly recursive variables, etc.)  Our simple solution is to
    add to a list each time an expansion is started, and check the list
    before expanding.  */
 
 static std::map <std::string, bool> expansions;
@@ -3076,8 +3217,14 @@ kpse_var_expand (const std::string& src)
 	    }
 	}
       else
 	expansion += src[i];
     }
 
   return expansion;
 }
+
+/*
+;;; Local Variables: ***
+;;; mode: C++ ***
+;;; End: ***
+*/
diff --git a/liboctave/kpse.h b/liboctave/kpse.h
deleted file mode 100644
--- a/liboctave/kpse.h
+++ /dev/null
@@ -1,198 +0,0 @@
-/* pathsearch.h: mostly-generic path searching.
-
-Copyright (C) 1993, 94, 96, 97 Karl Berry.
-
-This library is free software; you can redistribute it and/or
-modify it under the terms of the GNU Library General Public
-License as published by the Free Software Foundation; either
-version 2 of the License, or (at your option) any later version.
-
-This library is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-Library General Public License for more details.
-
-You should have received a copy of the GNU Library General Public
-License along with this library; if not, write to the Free Software
-Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
-
-#ifndef KPATHSEA_PATHSEARCH_H
-#define KPATHSEA_PATHSEARCH_H
-
-#include <string>
-#include "str-vec.h"
-
-/* It's a little bizarre to be using the same type for the list and the
-   elements of the list, but no reason not to in this case, I think --
-   we never need a NULL string in the middle of the list, and an extra
-   NULL/NULL element always at the end is inconsequential.  */
-
-struct str_llist_elt
-{
-  std::string str;
-  int moved;
-  struct str_llist_elt *next;
-};
-typedef struct str_llist_elt str_llist_elt_type;
-typedef struct str_llist_elt *str_llist_type;
-
-#define STR_LLIST(sl) ((sl).str)
-#define STR_LLIST_MOVED(sl) ((sl).moved)
-#define STR_LLIST_NEXT(sl) ((sl).next)
-
-extern bool kpse_is_env_sep (char c);
-
-class kpse_path_iterator
-{
-public:
-
-  kpse_path_iterator (const std::string& p)
-    : path (p), b (0), e (0), len (path.length ()) { set_end (); }
-
-  kpse_path_iterator (const kpse_path_iterator& pi)
-    : path (pi.path), b (pi.b), e (pi.e), len (pi.len) { }
-
-  kpse_path_iterator operator ++ (int)
-    {
-      kpse_path_iterator retval (*this);
-      next ();
-      return retval;
-    }
-
-  std::string operator * (void) { return path.substr (b, e-b); }
-
-  bool operator != (const size_t sz) { return b != sz; }
-
-private:
-
-  const std::string& path;
-  size_t b;
-  size_t e;
-  size_t len;
-
-  void set_end (void)
-    {
-      e = b + 1;
-
-      if (e >= len)
-	b = e = NPOS;
-      else
-	{
-	  /* Find the next colon not enclosed by braces (or the end of
-	     the path).  */
-
-	  int brace_level = 0;
-	  while (e < len && ! (brace_level == 0 && kpse_is_env_sep (path[e])))
-	    e++;
-	}
-    }
-
-  void next (void)
-    {
-      b = e + 1;
-
-      if (b >= len)
-	b = e = NPOS;
-      else
-	set_end ();
-    }
-};
-
-/* Given a path element ELT, return a pointer to a NULL-terminated list
-   of the corresponding (existing) directory or directories, with
-   trailing slashes, or NULL.  If ELT is the empty string, check the
-   current working directory.
-   
-   It's up to the caller to expand ELT.  This is because this routine is
-   most likely only useful to be called from `kpse_path_search', which
-   has already assumed expansion has been done.  */
-extern str_llist_type *kpse_element_dirs (const std::string& elt);
-
-/* Call `kpse_expand' on NAME.  If the result is an absolute or
-   explicitly relative filename, check whether it is a readable
-   (regular) file.
-   
-   Otherwise, look in each of the directories specified in PATH (also do
-   tilde and variable expansion on elements in PATH), using a prebuilt
-   db (see db.h) if it's relevant for a given path element.
-   
-   If the prebuilt db doesn't exist, or if MUST_EXIST is true and NAME
-   isn't found in the prebuilt db, look on the filesystem.  (I.e., if
-   MUST_EXIST is false, and NAME isn't found in the db, do *not* look on
-   the filesystem.)
-   
-   The caller must expand PATH. This is because it makes more sense to
-   do this once, in advance, instead of for every search using it.
-   
-   In any case, return the complete filename if found, otherwise NULL.  */
-extern std::string kpse_path_search (const std::string& path,
-				     const std::string& name,
-				     bool must_exist);
-
-/* Like `kpse_path_search' with MUST_EXIST true, but return a list of
-   all the filenames (or NULL if none), instead of taking the first.  */
-extern string_vector kpse_all_path_search (const std::string& path,
-					   const std::string&  name);
-
-/* Search each element of PATH for each element in the list of NAMES.
-   Return the first one found.  */
-extern std::string kpse_path_find_first_of (const std::string& path,
-					    const string_vector& names,
-					    bool must_exist);
-
-/* Like `kpse_path_find_first_of' with MUST_EXIST true, but return a
-   list of all the filenames (or NULL if none), instead of taking the
-   first.  */
-extern string_vector kpse_all_path_find_first_of (const std::string& path,
-						  const string_vector& names);
-
-/* expand.h: general expansion.  */
-
-/* Call kpse_var_expand and kpse_tilde_expand (in that order).  Result
-   is always in fresh memory, even if no expansions were done.  */
-extern std::string kpse_expand (const std::string& s);
-
-/* Do brace expansion and call `kpse_expand' on each element of the
-   result; return the final expansion (always in fresh memory, even if
-   no expansions were done).  We don't call `kpse_expand_default'
-   because there is a whole sequence of defaults to run through; see
-   `kpse_init_format'.  */
-extern std::string kpse_brace_expand (const std::string& path);
-
-/* Do brace expansion and call `kpse_expand' on each argument of the
-   result, then expand any `//' constructs.  The final expansion (always
-   in fresh memory) is a path of all the existing directories that match
-   the pattern. */
-extern std::string kpse_path_expand (const std::string& path);
-
-/* default.h: Declare default path expander.  */
-
-/* Replace a leading or trailing or doubled : in PATH with DFLT.  If
-   no extra colons, return PATH.  Only one extra colon is replaced.
-   DFLT may not be NULL.  */
-
-extern std::string kpse_expand_default (const std::string& path,
-					const std::string& dflt);
-
-/* db.h: lookups in an externally built db file.  */
-
-/* Initialize the database.  Until this is called, no ls-R matches will
-   be found.  */
-extern void kpse_init_db (void);
-
-/* Return list of matches for NAME in the ls-R file matching PATH_ELT.  If
-   ALL is set, return (null-terminated list) of all matches, else just
-   the first.  If no matches, return a pointer to an empty list.  If no
-   databases can be read, or PATH_ELT is not in any of the databases,
-   return NULL.  */
-extern string_vector kpse_db_search (const std::string& name,
-				     const std::string& path_elt, bool all);
-
-/* Insert the filename FNAME into the database.
-   Called by mktexpk et al.  */
-extern void kpse_db_insert (const std::string& fname);
-
-extern unsigned int kpathsea_debug;
-
-#endif /* not KPATHSEA_PATHSEARCH_H */
-
diff --git a/liboctave/pathsearch.cc b/liboctave/pathsearch.cc
--- a/liboctave/pathsearch.cc
+++ b/liboctave/pathsearch.cc
@@ -29,17 +29,17 @@ Software Foundation, 59 Temple Place - S
 #include <string>
 
 #include "lo-utils.h"
 #include "oct-env.h"
 #include "pathsearch.h"
 #include "str-vec.h"
 #include "str-vec.h"
 
-#include "kpse.h"
+#include "kpse.cc"
 
 static bool octave_kpathsea_initialized = false;
 
 string_vector
 dir_path::elements (void)
 {
   return initialized ? pv : string_vector ();
 }
diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,8 +1,18 @@
+2003-04-30  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* octave.cc (initialize_pathsearch): Don't save old and set new
+	value of TEXMFDBS.
+
+	* toplev.cc (restore_texmfdbs_envvar): Delete function.
+	(Fsystem): Don't set and reset TEXMFDBS.
+
+	* toplev.h, toplev.cc (octave_original_texmfdbs): Delete variable.
+
 2003-04-25  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* DLD-FUNCTIONS/getpwent.cc (Fgetpwnam): Delete unnecessary
 	c_str() method.
 
 2003-04-22  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* file-io.cc: Include <memory> for auto_ptr.
diff --git a/src/octave.cc b/src/octave.cc
--- a/src/octave.cc
+++ b/src/octave.cc
@@ -194,20 +194,16 @@ initialize_pathsearch (void)
   // For backward compatibility.
 
   if (odb.empty ())
     odb = octave_env::getenv ("OCTAVE_DB_DIR");
 
   if (odb.empty ())
     odb = Vdata_dir + file_ops::dir_sep_str + "octave:"
       + Vlibexec_dir + file_ops::dir_sep_str + "octave";
-
-  octave_original_texmfdbs = octave_env::getenv ("TEXMFDBS");
-
-  octave_env::putenv ("TEXMFDBS", odb);
 }
 
 // Initialize by reading startup files.
 
 static void
 execute_startup_files (void)
 {
   unwind_protect::begin_frame ("execute_startup_files");
diff --git a/src/toplev.cc b/src/toplev.cc
--- a/src/toplev.cc
+++ b/src/toplev.cc
@@ -90,19 +90,16 @@ bool octave_initialized = false;
 tree_statement_list *global_command = 0;
 
 // Pointer to function that is currently being evaluated.
 octave_user_function *curr_function = 0;
 
 // Pointer to parent function that is currently being evaluated.
 octave_user_function *curr_parent_function = 0;
 
-// Original value of TEXMFDBS environment variable.
-std::string octave_original_texmfdbs;
-
 static void
 recover_from_exception (void)
 {
   unwind_protect::run_all ();
   can_interrupt = true;
   octave_interrupt_immediately = 0;
   octave_interrupt_state = 0;
   octave_allocation_error = 0;
@@ -424,24 +421,16 @@ run_command_and_return_output (const std
       unwind_protect::run ();
     }
   else
     error ("unable to start subprocess for `%s'", cmd_str.c_str ());
 
   return retval;
 }
 
-static void
-restore_texmfdbs_envvar (void *ptr)
-{
-  std::string *s = static_cast<std::string *> (ptr);
-
-  octave_env::putenv ("TEXMFDBS", *s);
-}
-
 DEFUN (system, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} system (@var{string}, @var{return_output}, @var{type})\n\
 Execute a shell command specified by @var{string}.  The second\n\
 argument is optional.  If @var{type} is @code{\"async\"}, the process\n\
 is started in the background and the process id of the child process\n\
 is returned immediately.  Otherwise, the process is started, and\n\
 Octave waits until it exits.  If @var{type} argument is omitted, a\n\
@@ -514,32 +503,16 @@ variable @code{status} to the integer @s
 		error ("system: third argument must be a string");
 	    }
 	}
       else
 	error ("system: expecting std::string as first argument");
 
       if (! error_state)
 	{
-	  // The value of TEXMFDBS that Octave puts in the environment
-	  // will cause trouble if we are asked to run TeX, so we
-	  // should reset it to whatever it was before Octave started.
-	  //
-	  // XXX FIXME XXX -- it would be better to fix the
-	  // kpathsearch library to not always do TeX-specific
-	  // things...
-
-	  static std::string odb;
-
-	  odb = octave_env::getenv ("TEXMFDBS");
-
-	  unwind_protect::add (restore_texmfdbs_envvar, &odb);
-
-	  octave_env::putenv ("TEXMFDBS", octave_original_texmfdbs);
-
 	  if (type == async)
 	    {
 #ifdef HAVE_FORK
 	      pid_t pid = fork ();
 
 	      if (pid < 0) 
 		error ("system: fork failed -- can't create child process");
 	      else if (pid == 0)
diff --git a/src/toplev.h b/src/toplev.h
--- a/src/toplev.h
+++ b/src/toplev.h
@@ -46,19 +46,16 @@ do_octave_atexit (void);
 extern tree_statement_list *global_command;
 
 // Pointer to function that is currently being evaluated.
 extern octave_user_function *curr_function;
 
 // Pointer to parent function that is currently being evaluated.
 extern octave_user_function *curr_parent_function;
 
-// Original value of TEXMFDBS environment variable.
-extern std::string octave_original_texmfdbs;
-
 // TRUE means we are ready to interpret commands, but not everything
 // is ready for interactive use.
 extern bool octave_interpreter_ready;
 
 // TRUE means we've processed all the init code and we are good to go.
 extern bool octave_initialized;
 
 #endif
