# HG changeset patch
# User jwe
# Date 750972720 0
#      Mon Oct 18 19:32:00 1993 +0000
# Node ID e2c950dd96d27d70487f49e5c47b3431c25d5cba
# Parent  b4bdbdf95e05b563eb312b8d219149f6c843e2fb
[project @ 1993-10-18 19:32:00 by jwe]

diff --git a/liboctave/idx-vector.cc b/liboctave/idx-vector.cc
--- a/liboctave/idx-vector.cc
+++ b/liboctave/idx-vector.cc
@@ -20,19 +20,23 @@ along with Octave; see the file COPYING.
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
 #ifdef __GNUG__
 #pragma implementation
 #endif
 
+#include <iostream.h>
+
+#include "Matrix.h"
+#include "Range.h"
 #include "idx-vector.h"
+#include "user-prefs.h"
 #include "error.h"
-#include "user-prefs.h"
 #include "utils.h"
 
 idx_vector::idx_vector (const idx_vector& a)
 {
   len = a.len;
   if (len > 0)
     {
       data = new int [len];
@@ -54,17 +58,18 @@ static inline int
 tree_to_mat_idx (double x)
 {
   if (x > 0)
     return ((int) (x + 0.5) - 1);
   else
     return ((int) (x - 0.5) - 1);
 }
 
-idx_vector::idx_vector (Matrix& m, int do_ftn_idx, char *rc, int z_len = 0)
+idx_vector::idx_vector (const Matrix& m, int do_ftn_idx,
+			const char *rc, int z_len = 0)
 {
   int nr = m.rows ();
   int nc = m.columns ();
 
   if (nr == 0 || nc == 0)
     {
       len = 0;
       data = 0;
@@ -141,17 +146,17 @@ idx_vector::operator = (const idx_vector
 
       max_val = a.max_val;
       min_val = a.min_val;
     }
   return *this;
 }
 
 void
-idx_vector::init_state (char *rc, int z_len = 0)
+idx_vector::init_state (const char *rc, int z_len = 0)
 {
   one_zero = 1;
   num_zeros = 0;
   num_ones = 0;
 
   min_val = max_val = data[0];
 
   int i = 0;
diff --git a/liboctave/idx-vector.h b/liboctave/idx-vector.h
--- a/liboctave/idx-vector.h
+++ b/liboctave/idx-vector.h
@@ -25,30 +25,31 @@ Software Foundation, 675 Mass Ave, Cambr
 #define _idx_vector_h 1
 
 #ifdef __GNUG__
 #pragma interface
 #endif
 
 #include <stdlib.h>
 #include <assert.h>
-#include <iostream.h>
-#include "Matrix.h"
-#include "Range.h"
 
 #define FAIL assert(0) /* XXX FIXME XXX */
 
+class ostream;
+class Matrix;
+class Range;
+
 class idx_vector
 {
 public:
   idx_vector (void);
   idx_vector (const idx_vector& a);
 
-  idx_vector (Matrix& m, int do_ftn_idx, char *rc = (char *) NULL,
-	      int z_len = 0);
+  idx_vector (const Matrix& m, int do_ftn_idx,
+	      const char *rc = (char *) NULL, int z_len = 0);
 
   idx_vector (const Range& r);
 
  ~idx_vector (void);
 
   idx_vector& operator = (const idx_vector& a);
 
   int capacity (void) const;
@@ -76,17 +77,17 @@ private:
   int len;
   int one_zero;
   int num_zeros;
   int num_ones;
   int max_val;
   int min_val;
   int *data;
 
-  void init_state (char *rc = (char *) NULL, int z_len = 0);
+  void init_state (const char *rc = (char *) NULL, int z_len = 0);
   void convert_one_zero_to_idx (void);
 };
 
 inline idx_vector::idx_vector (void)
   {
     len = 0;
     data = 0;
     num_zeros = 0;
diff --git a/src/arith-ops.cc b/src/arith-ops.cc
--- a/src/arith-ops.cc
+++ b/src/arith-ops.cc
@@ -24,16 +24,17 @@ Software Foundation, 675 Mass Ave, Cambr
 
 #ifdef __GNUG__
 #pragma implementation
 #endif
 
 #include <ctype.h>
 #include <setjmp.h>
 #include <math.h>
+#include <Complex.h>
 
 #include "error.h"
 #include "gripes.h"
 #include "utils.h"
 #include "mappers.h"
 #include "user-prefs.h"
 #include "tree-const.h"
 #include "arith-ops.h"
@@ -74,123 +75,123 @@ Matrix_bool_op
   Matrix_AND,
   Matrix_OR, 
 };
 
 /*
  * Check row and column dimensions for binary matrix operations.
  */
 static inline int
-m_add_conform (Matrix& a, Matrix& b, int warn)
+m_add_conform (const Matrix& a, const Matrix& b, int warn)
 {
   int ar = a.rows ();
   int ac = a.columns ();
   int br = b.rows ();
   int bc = b.columns ();
 
   int ok = (ar == br && ac == bc);
 
   if (! ok && warn)
     gripe_nonconformant (ar, ac, br, bc);
 
   return ok;
 }
 
 static inline int
-m_add_conform (Matrix& a, ComplexMatrix& b, int warn)
+m_add_conform (const Matrix& a, const ComplexMatrix& b, int warn)
 {
   int ar = a.rows ();
   int ac = a.columns ();
   int br = b.rows ();
   int bc = b.columns ();
 
   int ok = (ar == br && ac == bc);
 
   if (! ok && warn)
     gripe_nonconformant (ar, ac, br, bc);
 
   return ok;
 }
 
 static inline int
-m_add_conform (ComplexMatrix& a, Matrix& b, int warn)
+m_add_conform (const ComplexMatrix& a, const Matrix& b, int warn)
 {
   int ar = a.rows ();
   int ac = a.columns ();
   int br = b.rows ();
   int bc = b.columns ();
 
   int ok = (ar == br && ac == bc);
 
   if (! ok && warn)
     gripe_nonconformant (ar, ac, br, bc);
 
   return ok;
 }
 
 static inline int
-m_add_conform (ComplexMatrix& a, ComplexMatrix& b, int warn)
+m_add_conform (const ComplexMatrix& a, const ComplexMatrix& b, int warn)
 {
   int ar = a.rows ();
   int ac = a.columns ();
   int br = b.rows ();
   int bc = b.columns ();
 
   int ok = (ar == br && ac == bc);
 
   if (! ok && warn)
     gripe_nonconformant (ar, ac, br, bc);
 
   return ok;
 }
 
 static inline int
-m_mul_conform (Matrix& a, Matrix& b, int warn)
+m_mul_conform (const Matrix& a, const Matrix& b, int warn)
 {
   int ac = a.columns ();
   int br = b.rows ();
 
   int ok = (ac == br);
 
   if (! ok && warn)
     gripe_nonconformant (a.rows (), ac, br, b.columns ());
 
   return ok;
 }
 
 static inline int
-m_mul_conform (Matrix& a, ComplexMatrix& b, int warn)
+m_mul_conform (const Matrix& a, const ComplexMatrix& b, int warn)
 {
   int ac = a.columns ();
   int br = b.rows ();
 
   int ok = (ac == br);
 
   if (! ok && warn)
     gripe_nonconformant (a.rows (), ac, br, b.columns ());
 
   return ok;
 }
 
 static inline int
-m_mul_conform (ComplexMatrix& a, Matrix& b, int warn)
+m_mul_conform (const ComplexMatrix& a, const Matrix& b, int warn)
 {
   int ac = a.columns ();
   int br = b.rows ();
 
   int ok = (ac == br);
 
   if (! ok && warn)
     gripe_nonconformant (a.rows (), ac, br, b.columns ());
 
   return ok;
 }
 
 static inline int
-m_mul_conform (ComplexMatrix& a, ComplexMatrix& b, int warn)
+m_mul_conform (const ComplexMatrix& a, const ComplexMatrix& b, int warn)
 {
   int ac = a.columns ();
   int br = b.rows ();
 
   int ok = (a.columns () == br);
 
   if (! ok && warn)
     gripe_nonconformant (a.rows (), ac, br, b.columns ());
@@ -211,17 +212,17 @@ m_mul_conform (ComplexMatrix& a, Complex
  *   complex_scalar | * | 5 |  * | 11 |
  *                  +---+---+----+----+
  *   complex_matrix | 2 | 6 |  8 | 12 |
  *                  +---+---+----+----+
  */
 
 /* 1 */
 static Matrix
-mx_stupid_bool_op (Matrix_bool_op op, double s, Matrix& a)
+mx_stupid_bool_op (Matrix_bool_op op, double s, const Matrix& a)
 {
   int ar = a.rows ();
   int ac = a.columns ();
 
   Matrix t (ar, ac);
 
   for (int j = 0; j < ac; j++)
     for (int i = 0; i < ar; i++)
@@ -258,17 +259,17 @@ mx_stupid_bool_op (Matrix_bool_op op, do
 	}
     }
 
   return t;
 }
 
 /* 2 */
 static Matrix
-mx_stupid_bool_op (Matrix_bool_op op, double s, ComplexMatrix& a)
+mx_stupid_bool_op (Matrix_bool_op op, double s, const ComplexMatrix& a)
 {
   int ar = a.rows ();
   int ac = a.columns ();
 
   Matrix t (ar, ac);
 
   for (int j = 0; j < ac; j++)
     for (int i = 0; i < ar; i++)
@@ -305,17 +306,17 @@ mx_stupid_bool_op (Matrix_bool_op op, do
 	}
     }
 
   return t;
 }
 
 /* 3 */
 static Matrix
-mx_stupid_bool_op (Matrix_bool_op op, Matrix& a, double s)
+mx_stupid_bool_op (Matrix_bool_op op, const Matrix& a, double s)
 {
   int ar = a.rows ();
   int ac = a.columns ();
 
   Matrix t (ar, ac);
 
   for (int j = 0; j < ac; j++)
     for (int i = 0; i < ar; i++)
@@ -352,17 +353,17 @@ mx_stupid_bool_op (Matrix_bool_op op, Ma
 	}
     }
 
   return t;
 }
 
 /* 4 */
 static Matrix
-mx_stupid_bool_op (Matrix_bool_op op, Matrix& a, Complex& s)
+mx_stupid_bool_op (Matrix_bool_op op, const Matrix& a, const Complex& s)
 {
   int ar = a.rows ();
   int ac = a.columns ();
 
   Matrix t (ar, ac);
 
   for (int j = 0; j < ac; j++)
     for (int i = 0; i < ar; i++)
@@ -399,17 +400,17 @@ mx_stupid_bool_op (Matrix_bool_op op, Ma
 	}
     }
 
   return t;
 }
 
 /* 5 */
 static Matrix
-mx_stupid_bool_op (Matrix_bool_op op, Matrix& a, Matrix& b)
+mx_stupid_bool_op (Matrix_bool_op op, const Matrix& a, const Matrix& b)
 {
   if (! m_add_conform (a, b, 1))
     return Matrix ();
      
   int ar = a.rows ();
   int ac = a.columns ();
 
   Matrix c (ar, ac);
@@ -449,17 +450,17 @@ mx_stupid_bool_op (Matrix_bool_op op, Ma
 	  }
       }
 
   return c;
 }
 
 /* 6 */
 static Matrix
-mx_stupid_bool_op (Matrix_bool_op op, Matrix& a, ComplexMatrix& b)
+mx_stupid_bool_op (Matrix_bool_op op, const Matrix& a, const ComplexMatrix& b)
 {
   if (! m_add_conform (a, b, 1))
     return Matrix ();
      
   int ar = a.rows ();
   int ac = a.columns ();
 
   Matrix c (ar, ac);
@@ -498,17 +499,17 @@ mx_stupid_bool_op (Matrix_bool_op op, Ma
 	    break;
 	  }
       }
   return c;
 }
 
 /* 7 */
 static Matrix
-mx_stupid_bool_op (Matrix_bool_op op, Complex& s, Matrix& a)
+mx_stupid_bool_op (Matrix_bool_op op, const Complex& s, const Matrix& a)
 {
   int ar = a.rows ();
   int ac = a.columns ();
 
   Matrix t (ar, ac);
 
   for (int j = 0; j < ac; j++)
     for (int i = 0; i < ar; i++)
@@ -545,17 +546,17 @@ mx_stupid_bool_op (Matrix_bool_op op, Co
 	}
     }
 
   return t;
 }
 
 /* 8 */
 static Matrix
-mx_stupid_bool_op (Matrix_bool_op op, Complex& s, ComplexMatrix& a)
+mx_stupid_bool_op (Matrix_bool_op op, const Complex& s, const ComplexMatrix& a)
 {
   int ar = a.rows ();
   int ac = a.columns ();
 
   Matrix t (ar, ac);
 
   for (int j = 0; j < ac; j++)
     for (int i = 0; i < ar; i++)
@@ -592,17 +593,17 @@ mx_stupid_bool_op (Matrix_bool_op op, Co
 	}
     }
 
   return t;
 }
 
 /* 9 */
 static Matrix
-mx_stupid_bool_op (Matrix_bool_op op, ComplexMatrix& a, double s)
+mx_stupid_bool_op (Matrix_bool_op op, const ComplexMatrix& a, double s)
 {
   int ar = a.rows ();
   int ac = a.columns ();
 
   Matrix t (ar, ac);
 
   for (int j = 0; j < ac; j++)
     for (int i = 0; i < ar; i++)
@@ -639,17 +640,17 @@ mx_stupid_bool_op (Matrix_bool_op op, Co
 	}
     }
 
   return t;
 }
 
 /* 10 */
 static Matrix
-mx_stupid_bool_op (Matrix_bool_op op, ComplexMatrix& a, Complex& s)
+mx_stupid_bool_op (Matrix_bool_op op, const ComplexMatrix& a, const Complex& s)
 {
   int ar = a.rows ();
   int ac = a.columns ();
 
   Matrix t (ar, ac);
 
   for (int j = 0; j < ac; j++)
     for (int i = 0; i < ar; i++)
@@ -686,17 +687,17 @@ mx_stupid_bool_op (Matrix_bool_op op, Co
 	}
     }
 
   return t;
 }
 
 /* 11 */
 static Matrix
-mx_stupid_bool_op (Matrix_bool_op op, ComplexMatrix& a, Matrix& b)
+mx_stupid_bool_op (Matrix_bool_op op, const ComplexMatrix& a, const Matrix& b)
 {
   if (! m_add_conform (a, b, 1))
     return Matrix ();
      
   int ar = a.rows ();
   int ac = a.columns ();
 
   Matrix c (ar, ac);
@@ -735,17 +736,18 @@ mx_stupid_bool_op (Matrix_bool_op op, Co
 	    break;
 	  }
       }
   return c;
 }
 
 /* 12 */
 static Matrix
-mx_stupid_bool_op (Matrix_bool_op op, ComplexMatrix& a, ComplexMatrix& b)
+mx_stupid_bool_op (Matrix_bool_op op, const ComplexMatrix& a,
+		   const ComplexMatrix& b) 
 {
   if (! m_add_conform (a, b, 1))
     return Matrix ();
      
   int ar = a.rows ();
   int ac = a.columns ();
 
   Matrix c (ar, ac);
@@ -819,17 +821,17 @@ do_unary_op (double d, tree::expression_
       panic_impossible ();
       break;
     }
 
   return tree_constant (result);
 }
 
 tree_constant
-do_unary_op (Matrix& a, tree::expression_type t)
+do_unary_op (const Matrix& a, tree::expression_type t)
 {
   Matrix result;
 
   switch (t)
     {
     case tree::not:
       result = (! a);
       break;
@@ -844,17 +846,17 @@ do_unary_op (Matrix& a, tree::expression
       panic_impossible ();
       break;
     }
 
   return tree_constant (result);
 }
 
 tree_constant
-do_unary_op (Complex& c, tree::expression_type t)
+do_unary_op (const Complex& c, tree::expression_type t)
 {
   Complex result = 0.0;
 
   switch (t)
     {
     case tree::not:
       result = (c == 0.0);
       break;
@@ -871,17 +873,17 @@ do_unary_op (Complex& c, tree::expressio
       panic_impossible ();
       break;
     }
 
   return tree_constant (result);
 }
 
 tree_constant
-do_unary_op (ComplexMatrix& a, tree::expression_type t)
+do_unary_op (const ComplexMatrix& a, tree::expression_type t)
 {
   ComplexMatrix result;
 
   switch (t)
     {
     case tree::not:
       result = (! a);
       break;
@@ -984,17 +986,17 @@ do_binary_op (double a, double b, tree::
   if (error_state)
     return tree_constant ();
 
   return tree_constant (result);
 }
 
 /* 2 */
 tree_constant
-do_binary_op (double a, Matrix& b, tree::expression_type t)
+do_binary_op (double a, const Matrix& b, tree::expression_type t)
 {
   Matrix result;
 
   switch (t)
     {
     case tree::add:
       result = a + b;
       break;
@@ -1055,17 +1057,17 @@ do_binary_op (double a, Matrix& b, tree:
   if (error_state)
     return tree_constant ();
 
   return tree_constant (result);
 }
 
 /* 3 */
 tree_constant
-do_binary_op (double a, Complex& b, tree::expression_type t)
+do_binary_op (double a, const Complex& b, tree::expression_type t)
 {
   enum RT { RT_unknown, RT_real, RT_complex };
   RT result_type = RT_unknown;
 
   double result = 0.0;
   Complex complex_result;
 
   switch (t)
@@ -1146,17 +1148,17 @@ do_binary_op (double a, Complex& b, tree
   if (result_type == RT_real)
     return tree_constant (result);
   else
     return tree_constant (complex_result);
 }
 
 /* 4 */
 tree_constant
-do_binary_op (double a, ComplexMatrix& b, tree::expression_type t)
+do_binary_op (double a, const ComplexMatrix& b, tree::expression_type t)
 {
   enum RT { RT_unknown, RT_real, RT_complex };
   RT result_type = RT_unknown;
 
   Matrix result;
   ComplexMatrix complex_result;
 
   switch (t)
@@ -1237,17 +1239,17 @@ do_binary_op (double a, ComplexMatrix& b
   if (result_type == RT_real)
     return tree_constant (result);
   else
     return tree_constant (complex_result);
 }
 
 /* 5 */
 tree_constant
-do_binary_op (Matrix& a, double b, tree::expression_type t)
+do_binary_op (const Matrix& a, double b, tree::expression_type t)
 {
   Matrix result;
 
   switch (t)
     {
     case tree::add:
       result = a + b;
       break;
@@ -1306,17 +1308,17 @@ do_binary_op (Matrix& a, double b, tree:
   if (error_state)
     return tree_constant ();
 
   return tree_constant (result);
 }
 
 /* 6 */
 tree_constant
-do_binary_op (Matrix& a, Matrix& b, tree::expression_type t)
+do_binary_op (const Matrix& a, const Matrix& b, tree::expression_type t)
 {
   Matrix result;
 
   switch (t)
     {
     case tree::add:
       if (m_add_conform (a, b, 1))
 	result = a + b;
@@ -1394,17 +1396,17 @@ do_binary_op (Matrix& a, Matrix& b, tree
   if (error_state)
     return tree_constant ();
 
   return tree_constant (result);
 }
 
 /* 7 */
 tree_constant
-do_binary_op (Matrix& a, Complex& b, tree::expression_type t)
+do_binary_op (const Matrix& a, const Complex& b, tree::expression_type t)
 {
   enum RT { RT_unknown, RT_real, RT_complex };
   RT result_type = RT_unknown;
 
   Matrix result;
   ComplexMatrix complex_result;
 
   switch (t)
@@ -1484,17 +1486,17 @@ do_binary_op (Matrix& a, Complex& b, tre
   if (result_type == RT_real)
     return tree_constant (result);
   else
     return tree_constant (complex_result);
 }
 
 /* 8 */
 tree_constant
-do_binary_op (Matrix& a, ComplexMatrix& b, tree::expression_type t)
+do_binary_op (const Matrix& a, const ComplexMatrix& b, tree::expression_type t)
 {
   enum RT { RT_unknown, RT_real, RT_complex };
   RT result_type = RT_unknown;
 
   Matrix result;
   ComplexMatrix complex_result;
 
   switch (t)
@@ -1595,17 +1597,17 @@ do_binary_op (Matrix& a, ComplexMatrix& 
   if (result_type == RT_real)
     return tree_constant (result);
   else
     return tree_constant (complex_result);
 }
 
 /* 9 */
 tree_constant
-do_binary_op (Complex& a, double b, tree::expression_type t)
+do_binary_op (const Complex& a, double b, tree::expression_type t)
 {
   enum RT { RT_unknown, RT_real, RT_complex };
   RT result_type = RT_unknown;
 
   double result = 0.0;
   Complex complex_result;
 
   switch (t)
@@ -1686,17 +1688,17 @@ do_binary_op (Complex& a, double b, tree
   if (result_type == RT_real)
     return tree_constant (result);
   else
     return tree_constant (complex_result);
 }
 
 /* 10 */
 tree_constant
-do_binary_op (Complex& a, Matrix& b, tree::expression_type t)
+do_binary_op (const Complex& a, const Matrix& b, tree::expression_type t)
 {
   enum RT { RT_unknown, RT_real, RT_complex };
   RT result_type = RT_unknown;
 
   Matrix result;
   ComplexMatrix complex_result;
 
   switch (t)
@@ -1708,18 +1710,19 @@ do_binary_op (Complex& a, Matrix& b, tre
     case tree::subtract:
       result_type = RT_complex;
       complex_result = a - b;
       break;
     case tree::el_leftdiv:
     case tree::leftdiv:
       if (a == 0.0)
 	DIVIDE_BY_ZERO_ERROR;
-      a = 1.0 / a;
-// fall through...
+      result_type = RT_complex;
+      complex_result = b / a;
+      break;
     case tree::multiply:
     case tree::el_mul:
       result_type = RT_complex;
       complex_result = a * b;
       break;
     case tree::el_div:
       return x_el_div (a, b);
       break;
@@ -1777,17 +1780,17 @@ do_binary_op (Complex& a, Matrix& b, tre
   if (result_type == RT_real)
     return tree_constant (result);
   else
     return tree_constant (complex_result);
 }
 
 /* 11 */
 tree_constant
-do_binary_op (Complex& a, Complex& b, tree::expression_type t)
+do_binary_op (const Complex& a, const Complex& b, tree::expression_type t)
 {
   enum RT { RT_unknown, RT_real, RT_complex };
   RT result_type = RT_unknown;
 
   double result = 0.0;
   Complex complex_result;
 
   switch (t)
@@ -1868,17 +1871,18 @@ do_binary_op (Complex& a, Complex& b, tr
   if (result_type == RT_real)
     return tree_constant (result);
   else
     return tree_constant (complex_result);
 }
 
 /* 12 */
 tree_constant
-do_binary_op (Complex& a, ComplexMatrix& b, tree::expression_type t)
+do_binary_op (const Complex& a, const ComplexMatrix& b,
+	      tree::expression_type t)
 {
   enum RT { RT_unknown, RT_real, RT_complex };
   RT result_type = RT_unknown;
 
   Matrix result;
   ComplexMatrix complex_result;
 
   switch (t)
@@ -1890,18 +1894,19 @@ do_binary_op (Complex& a, ComplexMatrix&
     case tree::subtract:
       result_type = RT_complex;
       complex_result = a - b;
       break;
     case tree::el_leftdiv:
     case tree::leftdiv:
       if (a == 0.0)
 	DIVIDE_BY_ZERO_ERROR;
-      a = 1.0 / a;
-// fall through...
+      result_type = RT_complex;
+      complex_result = b / a;
+      break;
     case tree::multiply:
     case tree::el_mul:
       result_type = RT_complex;
       complex_result = a * b;
       break;
     case tree::el_div:
       return x_el_div (a, b);
       break;
@@ -1959,17 +1964,17 @@ do_binary_op (Complex& a, ComplexMatrix&
   if (result_type == RT_real)
     return tree_constant (result);
   else
     return tree_constant (complex_result);
 }
 
 /* 13 */
 tree_constant
-do_binary_op (ComplexMatrix& a, double b, tree::expression_type t)
+do_binary_op (const ComplexMatrix& a, double b, tree::expression_type t)
 {
   enum RT { RT_unknown, RT_real, RT_complex };
   RT result_type = RT_unknown;
 
   Matrix result;
   ComplexMatrix complex_result;
 
   switch (t)
@@ -2049,17 +2054,17 @@ do_binary_op (ComplexMatrix& a, double b
   if (result_type == RT_real)
     return tree_constant (result);
   else
     return tree_constant (complex_result);
 }
 
 /* 14 */
 tree_constant
-do_binary_op (ComplexMatrix& a, Matrix& b, tree::expression_type t)
+do_binary_op (const ComplexMatrix& a, const Matrix& b, tree::expression_type t)
 {
   enum RT { RT_unknown, RT_real, RT_complex };
   RT result_type = RT_unknown;
 
   Matrix result;
   ComplexMatrix complex_result;
 
   switch (t)
@@ -2160,17 +2165,18 @@ do_binary_op (ComplexMatrix& a, Matrix& 
   if (result_type == RT_real)
     return tree_constant (result);
   else
     return tree_constant (complex_result);
 }
 
 /* 15 */
 tree_constant
-do_binary_op (ComplexMatrix& a, Complex& b, tree::expression_type t)
+do_binary_op (const ComplexMatrix& a, const Complex& b,
+	      tree::expression_type t)
 {
   enum RT { RT_unknown, RT_real, RT_complex };
   RT result_type = RT_unknown;
 
   Matrix result;
   ComplexMatrix complex_result;
 
   switch (t)
@@ -2250,17 +2256,18 @@ do_binary_op (ComplexMatrix& a, Complex&
   if (result_type == RT_real)
     return tree_constant (result);
   else
     return tree_constant (complex_result);
 }
 
 /* 16 */
 tree_constant
-do_binary_op (ComplexMatrix& a, ComplexMatrix& b, tree::expression_type t)
+do_binary_op (const ComplexMatrix& a, const ComplexMatrix& b,
+	      tree::expression_type t)
 {
   enum RT { RT_unknown, RT_real, RT_complex };
   RT result_type = RT_unknown;
 
   Matrix result;
   ComplexMatrix complex_result;
 
   switch (t)
diff --git a/src/arith-ops.h b/src/arith-ops.h
--- a/src/arith-ops.h
+++ b/src/arith-ops.h
@@ -24,77 +24,80 @@ Software Foundation, 675 Mass Ave, Cambr
 
 #if !defined (_arith_ops_h)
 #define _arith_ops_h 1
 
 #ifdef __GNUG__
 #pragma interface
 #endif
 
-#include "tree-const.h"
-
-extern tree_constant
-do_unary_op (double d, tree::expression_type t);
+#include "tree-base.h"
 
-extern tree_constant
-do_unary_op (Matrix& a, tree::expression_type t);
+class Complex;
+class Matrix;
+class ComplexMatrix;
+class tree_constant;
 
-extern tree_constant
-do_unary_op (Complex& c, tree::expression_type t);
+extern tree_constant do_unary_op (double d, tree::expression_type t);
 
-extern tree_constant
-do_unary_op (ComplexMatrix& a, tree::expression_type t);
+extern tree_constant do_unary_op (const Matrix& a, tree::expression_type t);
+
+extern tree_constant do_unary_op (const Complex& c, tree::expression_type t);
 
-extern tree_constant
-do_binary_op (double a, double b, tree::expression_type t);
+extern tree_constant do_unary_op (const ComplexMatrix& a,
+				  tree::expression_type t);
 
-extern tree_constant
-do_binary_op (double a, Matrix& b, tree::expression_type t);
+extern tree_constant do_binary_op (double a, double b,
+				   tree::expression_type t);
+
+extern tree_constant do_binary_op (double a, const Matrix& b,
+				   tree::expression_type t);
 
-extern tree_constant
-do_binary_op (double a, Complex& b, tree::expression_type t);
+extern tree_constant do_binary_op (double a, const Complex& b,
+				   tree::expression_type t);
 
-extern tree_constant
-do_binary_op (double a, ComplexMatrix& b, tree::expression_type t);
+extern tree_constant do_binary_op (double a, const ComplexMatrix& b,
+				   tree::expression_type t);
 
-extern tree_constant
-do_binary_op (Matrix& a, double b, tree::expression_type t);
+extern tree_constant do_binary_op (const Matrix& a, double b,
+				   tree::expression_type t);
 
-extern tree_constant
-do_binary_op (Matrix& a, Matrix& b, tree::expression_type t);
+extern tree_constant do_binary_op (const Matrix& a, const Matrix& b,
+				   tree::expression_type t);
 
-extern tree_constant
-do_binary_op (Matrix& a, Complex& b, tree::expression_type t);
+extern tree_constant do_binary_op (const Matrix& a, const Complex& b,
+				   tree::expression_type t);
 
-extern tree_constant
-do_binary_op (Matrix& a, ComplexMatrix& b, tree::expression_type t);
+extern tree_constant do_binary_op (const Matrix& a, const ComplexMatrix& b,
+				   tree::expression_type t);
 
-extern tree_constant
-do_binary_op (Complex& a, double b, tree::expression_type t);
+extern tree_constant do_binary_op (const Complex& a, double b,
+				   tree::expression_type t);
 
-extern tree_constant
-do_binary_op (Complex& a, Matrix& b, tree::expression_type t);
+extern tree_constant do_binary_op (const Complex& a, const Matrix& b,
+				   tree::expression_type t);
 
-extern tree_constant
-do_binary_op (Complex& a, Complex& b, tree::expression_type t);
+extern tree_constant do_binary_op (const Complex& a, const Complex& b,
+				   tree::expression_type t);
 
-extern tree_constant
-do_binary_op (Complex& a, ComplexMatrix& b, tree::expression_type t);
+extern tree_constant do_binary_op (const Complex& a, const ComplexMatrix& b,
+				   tree::expression_type t);
 
-extern tree_constant
-do_binary_op (ComplexMatrix& a, double b, tree::expression_type t);
+extern tree_constant do_binary_op (const ComplexMatrix& a, double b,
+				   tree::expression_type t);
 
-extern tree_constant
-do_binary_op (ComplexMatrix& a, Matrix& b, tree::expression_type t);
+extern tree_constant do_binary_op (const ComplexMatrix& a, const Matrix& b,
+				   tree::expression_type t); 
 
-extern tree_constant
-do_binary_op (ComplexMatrix& a, Complex& b, tree::expression_type t);
+extern tree_constant do_binary_op (const ComplexMatrix& a, const Complex& b,
+				   tree::expression_type t); 
 
-extern tree_constant
-do_binary_op (ComplexMatrix& a, ComplexMatrix& b, tree::expression_type t);
+extern tree_constant do_binary_op (const ComplexMatrix& a,
+				   const ComplexMatrix& b,
+				   tree::expression_type t); 
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
 ;;; End: ***
diff --git a/src/builtins.cc b/src/builtins.cc
--- a/src/builtins.cc
+++ b/src/builtins.cc
@@ -32,16 +32,17 @@ Software Foundation, 675 Mass Ave, Cambr
 #include "tree-const.h"
 #include "symtab.h"
 #include "t-builtins.h"
 #include "g-builtins.h"
 #include "builtins.h"
 #include "octave.h"
 #include "utils.h"
 #include "tree.h"
+#include "help.h"
 #include "mappers.h"
 #include "user-prefs.h"
 #include "variables.h"
 
 // NOTE: nargin == 1 means that the function takes no arguments (just
 // like C, the first argument is (or should be, anyway) the function
 // name).  Also, -1 is shorthand for infinity.
 
@@ -661,18 +662,18 @@ last computed value\n", },
     "produce warning for commas in global declarations\n", },
 
   { "warn_divide_by_zero", "true", warn_divide_by_zero,
     "on IEEE machines, allow divide by zero errors to be suppressed\n", },
 
   { NULL, NULL, NULL, NULL, },
 };
 
-void
-make_eternal (char *s)
+static void
+make_eternal (const char *s)
 {
   symbol_record *sym_rec = curr_sym_tab->lookup (s, 0, 0);
   if (sym_rec != (symbol_record *) NULL)
     sym_rec->make_eternal ();
 }
 
 void
 install_builtins (void)
@@ -891,17 +892,17 @@ install_builtins (void)
   tmp = new tree_constant (0.0/0.0);
 #endif
   bind_protected_variable ("nan", tmp);
   make_eternal ("nan");
 #endif
 }
 
 int
-is_text_function_name (char *s)
+is_text_function_name (const char *s)
 {
   int retval = 0;
 
   builtin_text_functions *tfptr = text_functions;
   while (tfptr->name != (char *) NULL)
     {
       if (strcmp (tfptr->name, s) == 0)
 	{
diff --git a/src/builtins.h b/src/builtins.h
--- a/src/builtins.h
+++ b/src/builtins.h
@@ -23,19 +23,18 @@ Software Foundation, 675 Mass Ave, Cambr
 
 #if !defined (_builtins_h)
 #define _builtins_h 1
 
 #ifdef __GNUG__
 #pragma interface
 #endif
 
-#include <Complex.h>
-
-#include "help.h"
+class Complex;
+struct help_list;
 
 #ifndef MAPPER_FCN_TYPEDEFS
 #define MAPPER_FCN_TYPEDEFS 1
 
 typedef double (*d_d_Mapper)(double);
 typedef double (*d_c_Mapper)(const Complex&);
 typedef Complex (*c_c_Mapper)(const Complex&);
 
@@ -72,17 +71,17 @@ struct builtin_string_variables
 {
   char *name;
   char *value;
   sv_Function sv_function;
   char *help_string;
 };
 
 extern void install_builtins (void);
-extern int is_text_function_name (char *s);
+extern int is_text_function_name (const char *s);
 
 extern help_list *builtin_mapper_functions_help (void);
 extern help_list *builtin_general_functions_help (void);
 extern help_list *builtin_text_functions_help (void);
 extern help_list *builtin_variables_help (void);
 
 #endif
 
diff --git a/src/dynamic-ld.cc b/src/dynamic-ld.cc
--- a/src/dynamic-ld.cc
+++ b/src/dynamic-ld.cc
@@ -33,27 +33,27 @@ extern "C"
 #include "dynamic-ld.h"
 #include "tree-const.h"
 #include "user-prefs.h"
 #include "octave.h"
 #include "utils.h"
 #include "error.h"
 
 void
-octave_dld_tc2_unlink_by_symbol (char *name, int hard = 1)
+octave_dld_tc2_unlink_by_symbol (const char *name, int hard = 1)
 {
   char *mangled_fcn_name = strconcat (name, "__FP13tree_constantii");
   int status = dld_unlink_by_symbol (mangled_fcn_name, hard);
   if (status != 0)
     dld_perror ("octave_dld_tc2_unlink_by_symbol");
   delete [] mangled_fcn_name;
 }
 
 void
-octave_dld_tc2_unlink_by_file (char *name, int hard = 1)
+octave_dld_tc2_unlink_by_file (const char *name, int hard = 1)
 {
   int status = dld_unlink_by_file (name, hard);
   if (status != 0)
     dld_perror ("octave_dld_tc2_unlink_by_file");
 }
 
 static void
 octave_dld_init (void)
@@ -81,42 +81,42 @@ octave_dld_init (void)
 }
 
 /*
  * Look for object in path.  It should provide a definition for the
  * function we just marked as undefined.  If we find it, we\'ll also
  * try to load the remaining undefined symbols.
  */
 static int
-octave_dld_link (char *object)
+octave_dld_link (const char *object)
 {
   char *file = file_in_path (object, (char *) NULL);
   int status = dld_link (file);
   if (status != 0)
     dld_perror ("octave_dld_link");
     
   delete [] file;
   return status;
 }
 
 int
-octave_dld_tc2_link (char *object)
+octave_dld_tc2_link (const char *object)
 {
   int status = octave_dld_link (object);
   if (status == 0)
     {
       status = octave_dld_link ("liboctave.a");
       if (status == 0)
 	octave_dld_link ("libcruft.a");
     }
   return status;
 }
 
 builtin_fcn_ptr
-octave_dld_tc2 (char *name, char *fcn, char *object)
+octave_dld_tc2 (const char *name, const char *fcn, const char *object)
 {
   builtin_fcn_ptr retval = (builtin_fcn_ptr) NULL;
 
   octave_dld_init ();
 
   char *mangled_fcn_name = strconcat (fcn, "__FP13tree_constantii");
 
 // See if the function has already been loaded.  If not, mark it as
@@ -137,17 +137,17 @@ octave_dld_tc2 (char *name, char *fcn, c
   delete [] mangled_fcn_name;
 
   return retval;
     
 }
 
 tree_constant *
 octave_dld_tc2_and_go (tree_constant *args, int nargin, int nargout,
-		       char *name, char *fcn, char *object)
+		       const char *name, const char *fcn, const char *object)
 {
   tree_constant *retval = NULL_TREE_CONST;
 
   builtin_fcn_ptr fcn_to_call = octave_dld_tc2 (name, fcn, object);
 
   if (fcn_to_call != (builtin_fcn_ptr) NULL)
     retval = (*fcn_to_call) (args, nargin, nargout);
   else
diff --git a/src/dynamic-ld.h b/src/dynamic-ld.h
--- a/src/dynamic-ld.h
+++ b/src/dynamic-ld.h
@@ -27,26 +27,29 @@ Software Foundation, 675 Mass Ave, Cambr
 #ifdef __GNUG__
 #pragma interface
 #endif
 
 class tree_constant;
 
 typedef tree_constant* (*builtin_fcn_ptr) (tree_constant*, int, int);
 
-extern void octave_dld_tc2_unlink_by_symbol (char *name, int hard = 1);
+extern void octave_dld_tc2_unlink_by_symbol (const char *name, int hard = 1);
+
+extern void octave_dld_tc2_unlink_by_file (const char *name, int hard = 1);
 
-extern void octave_dld_tc2_unlink_by_file (char *name, int hard = 1);
-
-extern builtin_fcn_ptr octave_dld_tc2 (char *name, char *fcn, char *object);
+extern builtin_fcn_ptr octave_dld_tc2 (const char *name,
+				       const char *fcn,
+				       const char *object);
 
 extern tree_constant *octave_dld_tc2_and_go (tree_constant *args,
 					     int nargin, int nargout,
-					     char *name, char *fcn,
-					     char *object);
+					     const char *name,
+					     const char *fcn,
+					     const char *object);
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
 ;;; End: ***
diff --git a/src/file-io.cc b/src/file-io.cc
--- a/src/file-io.cc
+++ b/src/file-io.cc
@@ -49,17 +49,17 @@ static int file_count = 0;
 
 // keeps a count of args sent to printf or scanf
 static int fmt_arg_count = 0;
 
 class File_info
 {
  public:
   File_info (void);
-  File_info (int num, char *nm, FILE *t, char *md);
+  File_info (int num, const char *nm, FILE *t, const char *md);
   File_info (const File_info& f);
 
   File_info& operator = (const File_info& f);
 
   ~File_info (void);
 
   int number (void) const;
   char *name (void) const;
@@ -101,17 +101,17 @@ File_info::operator = (const File_info& 
 }
 
 File_info::~File_info (void)
 {
   delete [] _name;
   delete [] _mode;
 }
 
-File_info::File_info (int n, char *nm, FILE *t, char *md)
+File_info::File_info (int n, const char *nm, FILE *t, const char *md)
 {
   _number = n;
   _name = strsave (nm);
   _fptr = t;
   _mode = strsave (md);
 }
 
 int
@@ -138,31 +138,31 @@ File_info::mode (void) const
   return _mode;
 }
 
 
 // double linked list containing relevant information about open files
 static DLList <File_info> file_list;
 
 void
-initialize_file_io ()
+initialize_file_io (void)
 {
   File_info _stdin (0, "stdin", stdin, "r");
   File_info _stdout (1, "stdout", stdout, "w");
   File_info _stderr (2, "stderr", stderr, "w");
 
   file_list.append (_stdin);
   file_list.append (_stdout);
   file_list.append (_stderr);
 
   file_count = 3;
 }
 
 Pix
-return_valid_file (tree_constant& arg)
+return_valid_file (const tree_constant& arg)
 {
   if (arg.is_string_type ())
     {
       Pix p = file_list.first ();
       File_info file;
       for (int i = 0; i < file_count; i++)
 	{
 	  char *file_name = arg.string_value ();
@@ -193,17 +193,17 @@ return_valid_file (tree_constant& arg)
       }
     else
       error ("inapproriate file specifier");
 
   return (Pix) NULL;
 }
 
 static Pix 
-fopen_file_for_user (tree_constant& arg, char *mode)
+fopen_file_for_user (const tree_constant& arg, const char *mode)
 {
   char *file_name = arg.string_value ();
 
   FILE *file_ptr = fopen (file_name, mode);
   if (file_ptr != (FILE *) NULL)
     {
       File_info file (++file_count, file_name, file_ptr, mode);
       file_list.append (file);
@@ -221,17 +221,17 @@ fopen_file_for_user (tree_constant& arg,
     }
 
   error ("problems automatically opening file for user");
   return (Pix) NULL;
 }
 
 
 tree_constant *
-fclose_internal (tree_constant *args)
+fclose_internal (const tree_constant *args)
 {
   tree_constant *retval = NULL_TREE_CONST;
 
   Pix p = return_valid_file (args[1]);
 
   if (p == (Pix) NULL)
     return retval;
 
@@ -255,17 +255,17 @@ fclose_internal (tree_constant *args)
       error ("fclose: error on closing file");
       retval[0] = tree_constant (0.0); // failed
     }
 
   return retval;
 }
 
 tree_constant *
-fflush_internal (tree_constant *args)
+fflush_internal (const tree_constant *args)
 {
   tree_constant *retval = NULL_TREE_CONST;
 
   Pix p = return_valid_file (args[1]);
 
   if (p == (Pix) NULL)
     return retval;
 
@@ -291,32 +291,32 @@ fflush_internal (tree_constant *args)
       error ("fflush: write error");
       retval[0] = tree_constant (0.0); // failed
     }
 
   return retval;
 }
 
 static int
-valid_mode (char *mode)
+valid_mode (const char *mode)
 {
   if (mode != (char *) NULL)
     {
       char m = mode[0];
       if (m == 'r' || m == 'w' || m == 'a')
 	{
 	  m = mode[1];
 	  return (m == '\0' || (m == '+' && mode[2] == '\0'));
 	}
     }
   return 0;
 }
 
 tree_constant *
-fgets_internal (tree_constant *args, int nargout)
+fgets_internal (const tree_constant *args, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
 
   Pix p = return_valid_file (args[1]);
   
   if (p == (Pix) NULL)
     {
       if (args[1].is_string_type ())
@@ -370,17 +370,17 @@ fgets_internal (tree_constant *args, int
     retval = new tree_constant[2];
 
   retval[0] = tree_constant (string);
 
   return retval;
 }
 
 tree_constant *
-fopen_internal (tree_constant *args)
+fopen_internal (const tree_constant *args)
 {
   tree_constant *retval = NULL_TREE_CONST;
   Pix p;
 
   if (! args[1].is_string_type ())
     {
       error ("fopen: file name must be a string");
       return retval;
@@ -435,17 +435,17 @@ fopen_internal (tree_constant *args)
 
   retval = new tree_constant[2];
   retval[0] = tree_constant ((double) number);
 
   return retval;
 }
 
 tree_constant *
-freport_internal ()
+freport_internal (void)
 {
   tree_constant *retval = NULL_TREE_CONST;
   Pix p = file_list.first ();
 
   ostrstream output_buf;
 
   output_buf << "\n number  mode  name\n\n";
   for (int i = 0; i < file_count; i++)
@@ -458,32 +458,32 @@ freport_internal ()
 
   output_buf << "\n" << ends;
   maybe_page_output (output_buf);
 
   return retval;
 }
 
 tree_constant *
-frewind_internal (tree_constant *args)
+frewind_internal (const tree_constant *args)
 {
   tree_constant *retval = NULL_TREE_CONST;
 
   Pix p = return_valid_file (args[1]);
   if (p == (Pix) NULL)
     p = fopen_file_for_user (args[1], "a+");   
 
   File_info file = file_list (p);
   rewind (file.fptr ());
 
   return retval;
 }
 
 tree_constant *
-fseek_internal (tree_constant *args, int nargin)
+fseek_internal (const tree_constant *args, int nargin)
 {
   tree_constant *retval = NULL_TREE_CONST;
 
   Pix p = return_valid_file (args[1]);
 
   if (p == (Pix) NULL)
     p = fopen_file_for_user (args[1], "a+");
 
@@ -527,17 +527,17 @@ fseek_internal (tree_constant *args, int
       error ("fseek: file error");
       retval[0] = tree_constant (0.0); // failed
     }
 
   return retval;
 }
 
 tree_constant *
-ftell_internal (tree_constant *args)
+ftell_internal (const tree_constant *args)
 {
   tree_constant *retval = NULL_TREE_CONST;
   Pix p = return_valid_file (args[1]);
 
   if (p == (Pix) NULL)
     p = fopen_file_for_user (args[1], "a+");
 
   File_info file = file_list (p);
@@ -547,17 +547,17 @@ ftell_internal (tree_constant *args)
 
   if (offset == -1L)
     error ("ftell: write error");
 
   return retval;
 }
 
 void
-close_files ()
+close_files (void)
 {
   Pix p = file_list.first ();
 
   for (int i = 0; i < file_count; i++)
     {
       File_info file = file_list (p);
       if (i > 2)   // do not close stdin, stdout, stderr!
 	{
@@ -565,18 +565,18 @@ close_files ()
 	  if (success != 0)
 	    error ("closing %s", file.name ());
 	}
       file_list.del (p);
     }
 }
 
 static int
-process_printf_format (char *s, tree_constant *args, ostrstream& sb,
-		       char *type, int nargin)
+process_printf_format (const char *s, const tree_constant *args,
+		       ostrstream& sb, const char *type, int nargin)
 {
   ostrstream fmt;
 
   fmt << "%";  // do_printf() already blew past this one...
 
   tree_constant_rep::constant_type arg_type;
 
   int chars_from_fmt_str = 0;
@@ -764,17 +764,18 @@ process_printf_format (char *s, tree_con
 
  invalid_format:
   message (type, "invalid format");
   return -1;
 }
 
 
 tree_constant *
-do_printf (char *type, tree_constant *args, int nargin, int nargout)
+do_printf (const char *type, const tree_constant *args, int nargin,
+	   int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
   fmt_arg_count = 1;
   char *fmt;
   File_info file;
 
   if (strcmp (type, "fprintf") == 0)
     {
@@ -884,19 +885,19 @@ do_printf (char *type, tree_constant *ar
       retval[0] = tree_constant (msg);
       delete [] msg;
     }
 
   return retval;
 }
 
 static int
-process_scanf_format (char *s, tree_constant *args, ostrstream& fmt,
-		      char *type, int nargout, FILE* fptr,
-		      tree_constant *values)
+process_scanf_format (const char *s, const tree_constant *args,
+		      ostrstream& fmt, const char *type, int nargout,
+		      FILE* fptr, tree_constant *values)
 {
   fmt << "%";
 
   tree_constant_rep::constant_type arg_type;
 
   int chars_from_fmt_str = 0;
   int store_value = 1;
   int string_width = -1;
@@ -1045,17 +1046,17 @@ process_scanf_format (char *s, tree_cons
     invalid_format:
       message (type, "invalid format");
     }
 
   return -1;
 }
 
 tree_constant *
-do_scanf (char *type, tree_constant *args, int nargin, int nargout)
+do_scanf (const char *type, const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
   char *scanf_fmt = (char *) NULL;
   char *tmp_file = (char *) NULL;
   int tmp_file_open = 0;
   FILE *fptr = (FILE *) NULL;
   File_info file;
 
diff --git a/src/file-io.h b/src/file-io.h
--- a/src/file-io.h
+++ b/src/file-io.h
@@ -25,47 +25,39 @@ Software Foundation, 675 Mass Ave, Cambr
 
 #if !defined (_files_h)
 #define _files_h 1
 
 #ifdef __GNUG__
 #pragma interface
 #endif
 
-#include "tree-const.h"
-#include "utils.h"
 #include <Pix.h>
-#include <stdio.h>
 
-extern Pix return_valid_file (tree_constant& arg);
-
-extern tree_constant *fclose_internal (tree_constant *args);
+class tree_constant;
 
-extern tree_constant *fflush_internal (tree_constant *args);
-
-extern tree_constant *fgets_internal (tree_constant *args, int nargout);
+extern Pix return_valid_file (const tree_constant& arg);
 
-extern tree_constant *fopen_internal (tree_constant *args);
-
-extern tree_constant *freport_internal ();
-
-extern tree_constant *frewind_internal (tree_constant *args);
-
-extern tree_constant *fseek_internal (tree_constant *args, int nargin);
+extern tree_constant *fclose_internal (const tree_constant *args);
+extern tree_constant *fflush_internal (const tree_constant *args);
+extern tree_constant *fgets_internal (const tree_constant *args, int nargout);
+extern tree_constant *fopen_internal (const tree_constant *args);
+extern tree_constant *freport_internal (void);
+extern tree_constant *frewind_internal (const tree_constant *args);
+extern tree_constant *fseek_internal (const tree_constant *args, int nargin);
+extern tree_constant *ftell_internal (const tree_constant *args);
 
-extern tree_constant *ftell_internal (tree_constant *args);
-
-extern void initialize_file_io ();
+extern void initialize_file_io (void);
 
-extern void close_files ();
+extern void close_files (void);
 
-extern tree_constant *do_printf (char *type, tree_constant *args,
+extern tree_constant *do_printf (const char *type, const tree_constant *args,
 				 int nargin, int nargout);
 
-extern tree_constant *do_scanf (char *type, tree_constant *args,
+extern tree_constant *do_scanf (const char *type, const tree_constant *args,
 				int nargin, int nargout);
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
diff --git a/src/g-builtins.cc b/src/g-builtins.cc
--- a/src/g-builtins.cc
+++ b/src/g-builtins.cc
@@ -122,17 +122,17 @@ static int verbatim_pwd = 1;
 #endif
 
 typedef RETSIGTYPE sig_handler (...);
 
 /*
  * Are all elements of a constant nonzero?
  */
 tree_constant *
-builtin_all (tree_constant *args, int nargin, int nargout)
+builtin_all (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
   if (nargin != 2)
     usage ("all (M)");
   else
     {
       if (args != NULL_TREE_CONST && args[1].is_defined ())
 	{
@@ -142,17 +142,17 @@ builtin_all (tree_constant *args, int na
     }
   return retval;
 }
 
 /*
  * Are any elements of a constant nonzero?
  */
 tree_constant *
-builtin_any (tree_constant *args, int nargin, int nargout)
+builtin_any (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
   if (nargin != 2)
     usage ("any (M)");
   else
     {
       if (args != NULL_TREE_CONST && args[1].is_defined ())
 	{
@@ -162,17 +162,17 @@ builtin_any (tree_constant *args, int na
     }
   return retval;
 }
 
 /*
  * Balancing for eigenvalue problems
  */
 tree_constant *
-builtin_balance (tree_constant *args, int nargin, int nargout)
+builtin_balance (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
   if (nargin <= 1 || nargin > 4 || nargout < 1 || nargout > 4)
     usage ("[{dd,} aa] = balance (a, {opt}) or \n\
 [{cc, dd,} aa, bb] = balance (a, b {,opt}), opt = 'P' or 'S'");
   else
     {
       DLD_BUILTIN (args, nargin, nargout, balance,
@@ -180,29 +180,29 @@ builtin_balance (tree_constant *args, in
     }
   return retval;
 }
 
 /*
  * Clear the screen?
  */
 tree_constant *
-builtin_clc (tree_constant *args, int nargin, int nargout)
+builtin_clc (const tree_constant *args, int nargin, int nargout)
 {
   rl_beg_of_line ();
   rl_kill_line (1);
   rl_clear_screen ();
   return NULL_TREE_CONST;
 }
 
 /*
  * Time in a vector.
  */
 tree_constant *
-builtin_clock (tree_constant *args, int nargin, int nargout)
+builtin_clock (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
 
   time_t now;
   struct tm *tm;
 
   time (&now);
   tm = localtime (&now);
@@ -220,62 +220,62 @@ builtin_clock (tree_constant *args, int 
 
   return retval;
 }
 
 /*
  * Close the stream to the plotter.
  */
 tree_constant *
-builtin_closeplot (tree_constant *args, int nargin, int nargout)
+builtin_closeplot (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
   close_plot_stream ();
   return retval;
 }
 
 /*
  * Collocation roots and weights.
  */
 tree_constant *
-builtin_colloc (tree_constant *args, int nargin, int nargout)
+builtin_colloc (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
 
   if (nargin < 2 || nargin > 4)
     usage ("[r, A, B, q] = colloc (n [, \"left\"] [, \"right\"])");
   else
     DLD_BUILTIN (args, nargin, nargout, colloc,
 		 retval = collocation_weights (args, nargin);)
 
   return retval;
 }
 
 /*
  * Cumulative sums and products.
  */
 tree_constant *
-builtin_cumprod (tree_constant *args, int nargin, int nargout)
+builtin_cumprod (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
   if (nargin != 2)
     usage ("cumprod (M)");
   else
     {
       if (args != NULL_TREE_CONST && args[1].is_defined ())
 	{
 	  retval = new tree_constant [2];
 	  retval[0] = args[1].cumprod ();
 	}
     }
   return retval;
 }
 
 tree_constant *
-builtin_cumsum (tree_constant *args, int nargin, int nargout)
+builtin_cumsum (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
   if (nargin != 2)
     usage ("cumsum (M)");
   else
     {
       if (args != NULL_TREE_CONST && args[1].is_defined ())
 	{
@@ -299,34 +299,34 @@ dassl_usage (void)
        compute the vector of residuals.  It must have the form\n\
 \n\
          res = f (x, xdot, t)\n\
 \n\
        where x, xdot, and res are vectors, and t is a scalar.");
 }
 
 tree_constant *
-builtin_dassl (tree_constant *args, int nargin, int nargout)
+builtin_dassl (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = new tree_constant [2];
 
   if ((nargin == 5 || nargin == 6) && nargout > 0)
     DLD_BUILTIN (args, nargin, nargout, dassl,
 		 retval = dassl (args, nargin, nargout);)
   else
     dassl_usage ();
 
   return retval;
 }
 
 /*
  * Time in a string.
  */
 tree_constant *
-builtin_date (tree_constant *args, int nargin, int nargout)
+builtin_date (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
 
   time_t now;
   struct tm *tm;
 
   time (&now);
   tm = localtime (&now);
@@ -340,17 +340,17 @@ builtin_date (tree_constant *args, int n
 
   return retval;
 }
 
 /*
  * Determinant of a matrix.
  */
 tree_constant *
-builtin_det (tree_constant *args, int nargin, int nargout)
+builtin_det (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
 
   if (nargin == 2)
     DLD_BUILTIN (args, nargin, nargout, det,
 		 {
 		   retval = new tree_constant [2];
 		   retval[0] = determinant (args[1]);
@@ -360,17 +360,17 @@ builtin_det (tree_constant *args, int na
 
   return retval;
 }
 
 /*
  * Diagonal elements of a matrix.
  */
 tree_constant *
-builtin_diag (tree_constant *args, int nargin, int nargout)
+builtin_diag (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
 
   if (nargin == 2)
     {
       retval = new tree_constant [2];
       retval[0] = args[1].diag ();
     }
@@ -400,17 +400,17 @@ builtin_disp (tree_constant *args, int n
 
   return retval;
 }
 
 /*
  * Compute eigenvalues and eigenvectors.
  */
 tree_constant *
-builtin_eig (tree_constant *args, int nargin, int nargout)
+builtin_eig (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
 
   if (nargin == 2 && (nargout == 1 || nargout == 2))
     DLD_BUILTIN (args, nargin, nargout, eig,
 		 retval = eig (args, nargin, nargout);)
   else
     usage ("lambda = eig (A)\n\
@@ -436,17 +436,17 @@ builtin_error (tree_constant *args, int 
 
   return retval;
 }
 
 /*
  * Evaluate text argument as octave source.
  */
 tree_constant *
-builtin_eval (tree_constant *args, int nargin, int nargout)
+builtin_eval (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
   if (nargin == 2)
     {
       int parse_status = 0;
       retval = new tree_constant [2];
       retval[0] = eval_string (args[1], parse_status);
     }
@@ -454,17 +454,17 @@ builtin_eval (tree_constant *args, int n
     usage ("eval (\"string\")");
   return retval;
 }
 
 /*
  * Check if variable or file exists.
  */
 tree_constant *
-builtin_exist (tree_constant *args, int nargin, int nargout)
+builtin_exist (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
   if (nargin == 2 && args[1].is_string_type ())
     {
       int status = identifier_exists (args[1].string_value ());
       retval = new tree_constant [2];
       retval[0] = tree_constant ((double) status);
     }
@@ -472,17 +472,17 @@ builtin_exist (tree_constant *args, int 
     usage ("exist (\"string\")");
   return retval;
 }
 
 /*
  * Matrix exponential.
  */
 tree_constant *
-builtin_expm (tree_constant *args, int nargin, int nargout)
+builtin_expm (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
 
   if (nargin == 2)
     DLD_BUILTIN (args, nargin, nargout, matrix_exp,
 		 {
 		   retval = new tree_constant [2];
 		   retval[0] = matrix_exp (args[1]);
@@ -492,17 +492,17 @@ builtin_expm (tree_constant *args, int n
 
   return retval;
 }
 
 /*
  * Identity matrix.
  */
 tree_constant *
-builtin_eye (tree_constant *args, int nargin, int nargout)
+builtin_eye (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
 
   switch (nargin)
     {
     case 2:
       retval = new tree_constant [2];
       retval[0] = identity_matrix (args[1]);
@@ -518,59 +518,59 @@ builtin_eye (tree_constant *args, int na
   return retval;
 }
 
 
 /*
  * Closing a file
  */
 tree_constant *
-builtin_fclose (tree_constant *args, int nargin, int nargout)
+builtin_fclose (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
   if (nargin != 2)
     usage ("success = fclose (\"filename\" or filenum)");
   else
     retval = fclose_internal (args);
   return retval;
 }
 
 /*
  * Evaluate first argument as a function.
  */
 tree_constant *
-builtin_feval (tree_constant *args, int nargin, int nargout)
+builtin_feval (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
   if (nargin > 1)
     retval = feval (args, nargin, nargout);
   else
     usage ("feval (\"function_name\" [, ...])");
   return retval;
 }
 
 /*
  * Flushing output to a file
  */
 tree_constant *
-builtin_fflush (tree_constant *args, int nargin, int nargout)
+builtin_fflush (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
   if (nargin != 2)
     usage ("success = fflush (\"filename\" or filenum)");
   else
     retval = fflush_internal (args);
   return retval;
 }
 
 /*
  * Fast Fourier Transform
  */
 tree_constant *
-builtin_fft (tree_constant *args, int nargin, int nargout)
+builtin_fft (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
 
   if (nargin == 2)
     DLD_BUILTIN (args, nargin, nargout, fft,
 		 {
 		   retval = new tree_constant [2];
 		   retval[0] = fft (args[1]);
@@ -580,65 +580,65 @@ builtin_fft (tree_constant *args, int na
 
   return retval;
 }
 
 /*
  * get a string from a file
  */
 tree_constant *
-builtin_fgets (tree_constant *args, int nargin, int nargout)
+builtin_fgets (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
   if (nargin != 3  && nargout < 3)
     usage ("string = fgets (\"filename\" or filenum, length)");
   else
     retval = fgets_internal (args, nargout);
   return retval;
 }
 
 /*
  * Find nonzero elements.  This should probably only work if
  * do_fortran_indexing is true...
  */
 tree_constant *
-builtin_find (tree_constant *args, int nargin, int nargout)
+builtin_find (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
   if (nargin == 2)
     {
       retval = new tree_constant [2];
       retval[0] = find_nonzero_elem_idx (args[1]);
     }
   else
     usage ("find (x)");
   return retval;
 }
 
 /*
  * Don\'t really count floating point operations.
  */
 tree_constant *
-builtin_flops (tree_constant *args, int nargin, int nargout)
+builtin_flops (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
   if (nargin > 2)
     usage ("flops\n       flops (0)");
 
   warning ("flops always returns zero");
   retval = new tree_constant [2];
   retval[0] = tree_constant (0.0);
   return retval;
 }
 
 /*
  * Opening a file.
  */
 tree_constant *
-builtin_fopen (tree_constant *args, int nargin, int nargout)
+builtin_fopen (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
   if (nargin != 3)
     {
       usage ("filenum = fopen (\"file\", \"mode\")\n\n\
  Legal values for mode include:\n\n\
    r  : open text file for reading\n\
    w  : open text file for writing; discard previous contents if any\n\
@@ -652,72 +652,72 @@ builtin_fopen (tree_constant *args, int 
     retval = fopen_internal (args);
   return retval;
 }
 
 /*
  * Formatted printing to a file.
  */
 tree_constant *
-builtin_fprintf (tree_constant *args, int nargin, int nargout)
+builtin_fprintf (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
   if (nargin < 3)
     usage ("fprintf (\"filename\" or filenum, \"fmt\" [, ...])");
   else
     retval = do_printf ("fprintf", args, nargin, nargout);
   return retval;
 }
 
 /*
  * rewind a file
  */
 tree_constant *
-builtin_frewind (tree_constant *args, int nargin, int nargout)
+builtin_frewind (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
   if (nargin != 2)
     usage ("success = frewind (\"filename\" or filenum)");
   else
     retval = frewind_internal (args);
   return retval;
 }
 
 /*
  * report on open files
  */
 tree_constant *
-builtin_freport (tree_constant *args, int nargin, int nargout)
+builtin_freport (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
   if (nargin > 1)
     warning ("replot: ignoring extra arguments");
   retval = freport_internal ();
   return retval;
 }
 
 /*
  * Formatted reading from a file.
  */
 tree_constant *
-builtin_fscanf (tree_constant *args, int nargin, int nargout)
+builtin_fscanf (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
   if (nargin != 2 && nargin != 3)
     usage ("[...] = fscanf (\"file\", \"fmt\")");
   else
     retval = do_scanf ("fscanf", args, nargin, nargout);
   return retval;
 }
 
 /*
  * seek a point in a file for reading and/or writing 
  */
 tree_constant *
-builtin_fseek (tree_constant *args, int nargin, int nargout)
+builtin_fseek (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
   if (nargin != 3 && nargin != 4)
     usage ("success = fseek (\"filename\" or filenum, offset [,origin])");
   else
     retval = fseek_internal (args, nargin);
   return retval;
 }
@@ -729,17 +729,17 @@ static void
 fsolve_usage (void)
 {
 //  usage ("[x, status, path] = fsolve (\"f\", x0 [, opts] [, par] [, \"jac\"] [, scale])");
 
   usage ("[x, info] = fsolve (\"f\", x0)");
 }
 
 tree_constant *
-builtin_fsolve (tree_constant *args, int nargin, int nargout)
+builtin_fsolve (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
 
   if (nargin >= 3 && nargin <= 7 && nargout >= 1 && nargout <= 3)
     DLD_BUILTIN (args, nargin, nargout, fsolve,
 		 retval = fsolve (args, nargin, nargout);)
   else
     fsolve_usage ();
@@ -760,17 +760,17 @@ fsqp_usage (void)
 #else
   usage ("[x, phi] = fsqp (x, \"phi\" [, lb, ub] [, lb, A, ub] [, lb, \"g\", ub])\n\n\
   Groups of arguments surrounded in `[]' are optional, but\n\
   must appear in the same relative order shown above.");
 #endif
 }
 
 tree_constant *
-builtin_fsqp (tree_constant *args, int nargin, int nargout)
+builtin_fsqp (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
 
 #if defined (FSQP_MISSING)
   fsqp_usage ();
 #else
   if ((nargin == 3 || nargin == 5 || nargin == 6 || nargin == 8
        || nargin == 9 || nargin == 11)
@@ -783,31 +783,31 @@ builtin_fsqp (tree_constant *args, int n
 
   return retval;
 }
 
 /*
  * tell current position of file
  */
 tree_constant *
-builtin_ftell (tree_constant *args, int nargin, int nargout)
+builtin_ftell (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
   if (nargin != 2)
     usage ("position = ftell (\"filename\" or filenumber)");
   else
     retval = ftell_internal (args);
   return retval;
 }
 
 /*
  * Get the value of an environment variable.
  */
 tree_constant *
-builtin_getenv (tree_constant *args, int nargin, int nargout)
+builtin_getenv (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
   if (nargin == 2 && args[1].is_string_type ())
     {
       retval = new tree_constant [2];
       char *value = getenv (args[1].string_value ());
       if (value != (char *) NULL)
 	retval[0] = tree_constant (value);
@@ -818,17 +818,17 @@ builtin_getenv (tree_constant *args, int
     usage ("getenv (\"string\")");
   return retval;
 }
 
 /*
  * Inverse Fast Fourier Transform
  */
 tree_constant *
-builtin_ifft (tree_constant *args, int nargin, int nargout)
+builtin_ifft (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
 
   if (nargin == 2)
     DLD_BUILTIN (args, nargin, nargout, ifft,
 		 {
 		   retval = new tree_constant [2];
 		   retval[0] = ifft (args[1]);
@@ -838,17 +838,17 @@ builtin_ifft (tree_constant *args, int n
 
   return retval;
 }
 
 /*
  * Inverse of a square matrix.
  */
 tree_constant *
-builtin_inv (tree_constant *args, int nargin, int nargout)
+builtin_inv (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
 
   if (nargin == 2)
     DLD_BUILTIN (args, nargin, nargout, inv,
 		 {
 		   retval = new tree_constant [2];
 		   retval[0] = inverse (args[1]);
@@ -858,17 +858,17 @@ builtin_inv (tree_constant *args, int na
 
   return retval;
 }
 
 /*
  * Prompt user for input.
  */
 tree_constant *
-builtin_input (tree_constant *args, int nargin, int nargout)
+builtin_input (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
 
   if (nargin == 2 || nargin == 3)
     {
       retval = new tree_constant [2];
       retval[0] = get_user_input (args, nargin, nargout);
     }
@@ -877,17 +877,17 @@ builtin_input (tree_constant *args, int 
 
   return retval;
 }
 
 /*
  * Is the argument a string?
  */
 tree_constant *
-builtin_isstr (tree_constant *args, int nargin, int nargout)
+builtin_isstr (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
   if (nargin != 2)
     usage ("isstr (value)");
   else
     {
       if (args != NULL_TREE_CONST && args[1].is_defined ())
 	{
@@ -897,17 +897,17 @@ builtin_isstr (tree_constant *args, int 
     }
   return retval;
 }
 
 /*
  * Maybe help in debugging.
  */
 tree_constant *
-builtin_keyboard (tree_constant *args, int nargin, int nargout)
+builtin_keyboard (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
 
   if (nargin == 1 || nargin == 2)
     {
       retval = new tree_constant [2];
       retval[0] = get_user_input (args, nargin, nargout, 1);
     }
@@ -916,17 +916,17 @@ builtin_keyboard (tree_constant *args, i
 
   return retval;
 }
 
 /*
  * Matrix logarithm.
  */
 tree_constant *
-builtin_logm (tree_constant *args, int nargin, int nargout)
+builtin_logm (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
 
   if (nargin == 2)
     retval = matrix_log (args[1]);
   else
     usage ("logm (A)");
 
@@ -938,17 +938,17 @@ builtin_logm (tree_constant *args, int n
  */
 static void
 lpsolve_usage (void)
 {
   usage ("[x, obj, info] = lpsolve (XXX FIXME XXX)");
 }
 
 tree_constant *
-builtin_lpsolve (tree_constant *args, int nargin, int nargout)
+builtin_lpsolve (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
 
 // Force a bad value of inform, and empty matrices for x and phi.
   retval = new tree_constant [4];
   Matrix m;
   retval[0] = tree_constant (m);
   retval[1] = tree_constant (m);
@@ -976,68 +976,68 @@ lsode_usage (void)
        compute the vector of right hand sides.  It must have the form\n\
 \n\
          xdot = f (x, t)\n\
 \n\
        where xdot and x are vectors and t is a scalar.");
 }
 
 tree_constant *
-builtin_lsode (tree_constant *args, int nargin, int nargout)
+builtin_lsode (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
 
   if ((nargin == 4 || nargin == 5) && nargout == 1)
     DLD_BUILTIN (args, nargin, nargout, lsode,
 		 retval = lsode (args, nargin, nargout);)
   else
     lsode_usage ();
 
   return retval;
 }
 
 /*
  * LU factorization.
  */
 tree_constant *
-builtin_lu (tree_constant *args, int nargin, int nargout)
+builtin_lu (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
 
   if (nargin == 2 && nargout < 4)
     DLD_BUILTIN (args, nargin, nargout, lu,
 		 retval = lu (args[1], nargout);)
   else
     usage ("[L, U, P] = lu (A)");
 
   return retval;
 }
 
 /*
  * Max values.
  */
 tree_constant *
-builtin_max (tree_constant *args, int nargin, int nargout)
+builtin_max (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
 
   if ((nargin == 2 && (nargout == 1 || nargout == 2))
       || (nargin == 3 && nargout == 1))
     retval = column_max (args, nargin, nargout);
   else
     usage ("[X, I] = max (A)\n        X = max (A)\n        X = max (A, B)");
 
   return retval;
 }
 
 /*
  * Min values.
  */
 tree_constant *
-builtin_min (tree_constant *args, int nargin, int nargout)
+builtin_min (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
 
   if ((nargin == 2 && (nargout == 1 || nargout == 2))
       || (nargin == 3 && nargout == 1))
     retval = column_min (args, nargin, nargout);
   else
     usage ("[X, I] = min (A)\n        X = min (A)\n        X = min (A, B)");
@@ -1066,17 +1066,17 @@ npsol_usage (void)
 \n\
     y = phi (x)\n\
 \n\
   where x is a vector and y is a scalar.");
 #endif
 }
 
 tree_constant *
-builtin_npsol (tree_constant *args, int nargin, int nargout)
+builtin_npsol (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
 
 #if defined (NPSOL_MISSING)
 // Force a bad value of inform, and empty matrices for x, phi, and lambda.
   retval = new tree_constant [4];
   Matrix m;
   retval[0] = tree_constant (m);
@@ -1096,17 +1096,17 @@ builtin_npsol (tree_constant *args, int 
 
   return retval;
 }
 
 /*
  * A matrix of ones.
  */
 tree_constant *
-builtin_ones (tree_constant *args, int nargin, int nargout)
+builtin_ones (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
 
   switch (nargin)
     {
     case 2:
       retval = new tree_constant [2];
       retval[0] = fill_matrix (args[1], 1.0, "ones");
@@ -1121,17 +1121,17 @@ builtin_ones (tree_constant *args, int n
     }
   return retval;
 }
 
 /*
  * You guessed it.
  */
 tree_constant *
-builtin_pause (tree_constant *args, int nargin, int nargout)
+builtin_pause (const tree_constant *args, int nargin, int nargout)
 {
   if (! (nargin == 1 || nargin == 2))
     {
       usage ("pause ([delay])");
       return NULL_TREE_CONST;
     }
 
   if (interactive)
@@ -1143,41 +1143,41 @@ builtin_pause (tree_constant *args, int 
     }
   return NULL_TREE_CONST;
 }
 
 /*
  * Delete turds from /tmp.
  */
 tree_constant *
-builtin_purge_tmp_files (tree_constant *, int, int)
+builtin_purge_tmp_files (const tree_constant *, int, int)
 {
   cleanup_tmp_files ();
   return NULL_TREE_CONST;
 }
 
 /*
  * Formatted printing.
  */
 tree_constant *
-builtin_printf (tree_constant *args, int nargin, int nargout)
+builtin_printf (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
   if (nargin < 2)
     usage ("printf (\"fmt\" [, ...])");
   else
     retval = do_printf ("printf", args, nargin, nargout);
   return retval;
 }
 
 /*
  * Product.
  */
 tree_constant *
-builtin_prod (tree_constant *args, int nargin, int nargout)
+builtin_prod (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
   if (nargin != 2)
     usage ("prod (M)");
   else
     {
       if (args != NULL_TREE_CONST && args[1].is_defined ())
 	{
@@ -1187,17 +1187,17 @@ builtin_prod (tree_constant *args, int n
     }
   return retval;
 }
 
 /*
  * Print name of current working directory.
  */
 tree_constant *
-builtin_pwd (tree_constant *args, int nargin, int nargout)
+builtin_pwd (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
   char *directory;
 
   if (verbatim_pwd)
     {
       char *buffer = new char [MAXPATHLEN];
       directory = getcwd (buffer, MAXPATHLEN);
@@ -1237,17 +1237,17 @@ qpsol_usage (void)
   usage ("[x, obj, info, lambda] = qpsol (x, H, c [, lb, ub] [, lb, A, ub])\n\
 \n\
   Groups of arguments surrounded in `[]' are optional, but\n\
   must appear in the same relative order shown above.");
 #endif
 }
 
 tree_constant *
-builtin_qpsol (tree_constant *args, int nargin, int nargout)
+builtin_qpsol (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
 
 #if defined (QPSOL_MISSING)
 // Force a bad value of inform, and empty matrices for x, phi, and lambda.
   retval = new tree_constant [5];
   Matrix m;
   retval[0] = tree_constant (m);
@@ -1266,34 +1266,34 @@ builtin_qpsol (tree_constant *args, int 
 
   return retval;
 }
 
 /*
  * QR factorization.
  */
 tree_constant *
-builtin_qr (tree_constant *args, int nargin, int nargout)
+builtin_qr (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
 
   if (nargin == 2 && nargout < 3)
     DLD_BUILTIN (args, nargin, nargout, qr,
 		 retval = qr (args[1], nargout);)
   else
     usage ("[Q, R] = qr (A)");
 
   return retval;
 }
 
 /*
  * generalized eigenvalues via qz
  */
 tree_constant *
-builtin_qzval (tree_constant *args, int nargin, int nargout)
+builtin_qzval (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
 
   if (nargin == 3 && nargout < 2)
     DLD_BUILTIN (args, nargin, nargout, qzvalue,
 		 retval = qzvalue (args, nargin, nargout);)
   else
     usage ("x = qzval (A,B): compute generalized eigenvalues of \n\
@@ -1301,17 +1301,17 @@ builtin_qzval (tree_constant *args, int 
 
   return retval;
 }
 
 /*
  * Random numbers.
  */
 tree_constant *
-builtin_quad (tree_constant *args, int nargin, int nargout)
+builtin_quad (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
 
   if ((nargin > 3 && nargin < 7) && (nargout > 0 && nargout < 5))
     DLD_BUILTIN (args, nargin, nargout, quad,
 		 retval = do_quad (args, nargin, nargout);)
   else
     usage ("[v, ier, nfun, err] = quad (\"f\", a, b)\n\
@@ -1320,28 +1320,28 @@ builtin_quad (tree_constant *args, int n
 
   return retval;
 }
 
 /*
  * I'm outta here.
  */
 tree_constant *
-builtin_quit (tree_constant *args, int nargin, int nargout)
+builtin_quit (const tree_constant *args, int nargin, int nargout)
 {
   quitting_gracefully = 1;
   clean_up_and_exit (0);
   return NULL_TREE_CONST;
 }
 
 /*
  * Random numbers.
  */
 tree_constant *
-builtin_rand (tree_constant *args, int nargin, int nargout)
+builtin_rand (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
 
   if ((nargin > 0 && nargin < 4) && nargout == 1)
     DLD_BUILTIN (args, nargin, nargout, rand,
 		 retval = rand_internal (args, nargin, nargout);)
   else
     usage ("rand                  -- generate a random value\n\
@@ -1355,33 +1355,33 @@ builtin_rand (tree_constant *args, int n
 
   return retval;
 }
 
 /*
  * Replot current plot.
  */
 tree_constant *
-builtin_replot (tree_constant *args, int nargin, int nargout)
+builtin_replot (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
 
   if (nargin > 1)
     warning ("replot: ignoring extra arguments");
 
   send_to_plot_stream ("replot\n");
 
   return retval;
 }
 
 /*
  * Formatted reading.
  */
 tree_constant *
-builtin_scanf (tree_constant *args, int nargin, int nargout)
+builtin_scanf (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
   if (nargin != 2)
     usage ("[...] = scanf (\"fmt\")");
   else
     retval = do_scanf ("scanf", args, nargin, nargout);
   return retval;
 }
@@ -1404,17 +1404,17 @@ builtin_setstr (tree_constant *args, int
 
   return retval;
 }
 
 /*
  * Execute a shell command.
  */
 tree_constant *
-builtin_shell_command (tree_constant *args, int nargin, int nargout)
+builtin_shell_command (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
 
   if (nargin == 2 || nargin == 3)
     {
       if (args[1].is_string_type ())
 	{
 	  iprocstream cmd (args[1].string_value ());
@@ -1442,17 +1442,17 @@ builtin_shell_command (tree_constant *ar
 
   return retval;
 }
 
 /*
  * Report rows and columns.
  */
 tree_constant *
-builtin_size (tree_constant *args, int nargin, int nargout)
+builtin_size (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
 
   if (nargin != 2)
     usage ("size (x)");
   else
     {
       if (args != NULL_TREE_CONST && args[1].is_defined ())
@@ -1479,77 +1479,77 @@ builtin_size (tree_constant *args, int n
     }
   return retval;
 }
 
 /*
  * Sort columns.
  */
 tree_constant *
-builtin_sort (tree_constant *args, int nargin, int nargout)
+builtin_sort (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
 
   if (nargin == 2)
     retval = sort (args, nargin, nargout);
   else
     usage ("[s, i] = sort (x)");
 
   return retval;
 }
 
 /*
  * Formatted printing to a string.
  */
 tree_constant *
-builtin_sprintf (tree_constant *args, int nargin, int nargout)
+builtin_sprintf (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
   if (nargin < 2)
     usage ("string = sprintf (\"fmt\" [, ...])");
   else
     retval = do_printf ("sprintf", args, nargin, nargout);
   return retval;
 }
 
 /*
  * Matrix sqrt.
  */
 tree_constant *
-builtin_sqrtm (tree_constant *args, int nargin, int nargout)
+builtin_sqrtm (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
 
   if (nargin == 2)
     retval = matrix_sqrt (args[1]);
   else
     usage ("sqrtm (A)");
 
   return retval;
 }
 
 /*
  * Formatted reading from a string.
  */
 tree_constant *
-builtin_sscanf (tree_constant *args, int nargin, int nargout)
+builtin_sscanf (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
   if (nargin != 3)
     usage ("[...] = sscanf (string, \"fmt\")");
   else
     retval = do_scanf ("sscanf", args, nargin, nargout);
   return retval;
 }
 
 /*
  * Sum.
  */
 tree_constant *
-builtin_sum (tree_constant *args, int nargin, int nargout)
+builtin_sum (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
   if (nargin != 2)
     usage ("sum (M)");
   else
     {
       if (args != NULL_TREE_CONST && args[1].is_defined ())
 	{
@@ -1559,17 +1559,17 @@ builtin_sum (tree_constant *args, int na
     }
   return retval;
 }
 
 /*
  * Sum of squares.
  */
 tree_constant *
-builtin_sumsq (tree_constant *args, int nargin, int nargout)
+builtin_sumsq (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
   if (nargin != 2)
     usage ("sumsq (M)");
   else
     {
       if (args != NULL_TREE_CONST && args[1].is_defined ())
 	{
@@ -1579,51 +1579,51 @@ builtin_sumsq (tree_constant *args, int 
     }
   return retval;
 }
 
 /*
  * Singluar value decomposition.
  */
 tree_constant *
-builtin_svd (tree_constant *args, int nargin, int nargout)
+builtin_svd (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
 
   if (nargin == 2 && (nargout == 1 || nargout == 3))
     DLD_BUILTIN (args, nargin, nargout, svd,
 		 retval = svd (args, nargin, nargout);)
   else
     usage ("[U, S, V] = svd (A)\n               S = svd (A)");
 
   return retval;
 }
 
 /*
  * Sylvester equation solver.
  */
 tree_constant *
-builtin_syl (tree_constant *args, int nargin, int nargout)
+builtin_syl (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
 
   if ((nargin == 4) && (nargout == 1))
     DLD_BUILTIN (args, nargin, nargout, syl,
 		 retval = syl (args, nargin, nargout);)
   else
     usage ("X = syl (A,B,C)");
 
   return retval;
 }
 
 /*
  * Schur Decomposition
  */
 tree_constant *
-builtin_schur (tree_constant *args, int nargin, int nargout)
+builtin_schur (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
 
   if ((nargin == 3 || nargin == 2) && (nargout == 1 || nargout == 2))
     DLD_BUILTIN (args, nargin, nargout, hess,
 		 retval = schur (args, nargin, nargout);)
   else
     usage ("[U, S] = schur (A)\n\
@@ -1638,50 +1638,50 @@ builtin_schur (tree_constant *args, int 
 
   return retval;
 }
 
 /*
  * Givens rotation
  */
 tree_constant *
-builtin_givens (tree_constant *args, int nargin, int nargout)
+builtin_givens (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
 
   if (nargin == 3 && (nargout == 1 || nargout == 2 ))
     retval = givens (args, nargin, nargout);
   else
     usage ("[c, s] = givens (x,y)\n            G = givens (x,y)");
 
   return retval;
 }
 
 /*
  * Hessenberg Decomposition
  */
 tree_constant *
-builtin_hess (tree_constant *args, int nargin, int nargout)
+builtin_hess (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
 
   if (nargin == 2 && (nargout == 1 || nargout == 2))
     DLD_BUILTIN (args, nargin, nargout, hess,
 		 retval = hess (args, nargin, nargout);)
   else
     usage ("[P, H] = hess (A)\n            H = hess (A)");
 
   return retval;
 }
 
 /*
  * Copying information.
  */
 tree_constant *
-builtin_warranty (tree_constant *args, int nargin, int nargout)
+builtin_warranty (const tree_constant *args, int nargin, int nargout)
 {
   ostrstream output_buf;
   output_buf << "\n    Octave, version " << version_string
 	     << ".  Copyright (C) 1992, 1993, John W. Eaton\n"
 	     << "\n\
     This program is free software; you can redistribute it and/or modify\n\
     it under the terms of the GNU General Public License as published by\n\
     the Free Software Foundation; either version 2 of the License, or\n\
@@ -1699,17 +1699,17 @@ builtin_warranty (tree_constant *args, i
 
   return NULL_TREE_CONST;
 }
 
 /*
  * A matrix of zeros.
  */
 tree_constant *
-builtin_zeros (tree_constant *args, int nargin, int nargout)
+builtin_zeros (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
 
   switch (nargin)
     {
     case 2:
       retval = new tree_constant [2];
       retval[0] = fill_matrix (args[1], 0.0, "zeros");
diff --git a/src/g-builtins.h b/src/g-builtins.h
--- a/src/g-builtins.h
+++ b/src/g-builtins.h
@@ -34,95 +34,96 @@ struct builtin_general_functions
 {
   char *name;
   int nargin_max;
   int nargout_max;
   General_fcn general_fcn;
   char *help_string;
 };
 
-extern tree_constant *builtin_all (tree_constant *, int, int);
-extern tree_constant *builtin_any (tree_constant *, int, int);
-extern tree_constant *builtin_balance (tree_constant *, int, int);
-extern tree_constant *builtin_clc (tree_constant *, int, int);
-extern tree_constant *builtin_clock (tree_constant *, int, int);
-extern tree_constant *builtin_closeplot (tree_constant *, int, int);
-extern tree_constant *builtin_colloc (tree_constant *, int, int);
-extern tree_constant *builtin_cumprod (tree_constant *, int, int);
-extern tree_constant *builtin_cumsum (tree_constant *, int, int);
-extern tree_constant *builtin_dassl (tree_constant *, int, int);
-extern tree_constant *builtin_date (tree_constant *, int, int);
-extern tree_constant *builtin_det (tree_constant *, int, int);
-extern tree_constant *builtin_diag (tree_constant *, int, int);
+extern tree_constant *builtin_all (const tree_constant *, int, int);
+extern tree_constant *builtin_any (const tree_constant *, int, int);
+extern tree_constant *builtin_balance (const tree_constant *, int, int);
+extern tree_constant *builtin_clc (const tree_constant *, int, int);
+extern tree_constant *builtin_clock (const tree_constant *, int, int);
+extern tree_constant *builtin_closeplot (const tree_constant *, int, int);
+extern tree_constant *builtin_colloc (const tree_constant *, int, int);
+extern tree_constant *builtin_cumprod (const tree_constant *, int, int);
+extern tree_constant *builtin_cumsum (const tree_constant *, int, int);
+extern tree_constant *builtin_dassl (const tree_constant *, int, int);
+extern tree_constant *builtin_date (const tree_constant *, int, int);
+extern tree_constant *builtin_det (const tree_constant *, int, int);
+extern tree_constant *builtin_diag (const tree_constant *, int, int);
 extern tree_constant *builtin_disp (tree_constant *, int, int);
-extern tree_constant *builtin_eig (tree_constant *, int, int);
+extern tree_constant *builtin_eig (const tree_constant *, int, int);
 extern tree_constant *builtin_error (tree_constant *, int, int);
-extern tree_constant *builtin_eval (tree_constant *, int, int);
-extern tree_constant *builtin_exist (tree_constant *, int, int);
-extern tree_constant *builtin_expm (tree_constant *, int, int);
-extern tree_constant *builtin_eye (tree_constant *, int, int);
-extern tree_constant *builtin_fclose (tree_constant *, int, int);
-extern tree_constant *builtin_feval (tree_constant *, int, int);
-extern tree_constant *builtin_fflush (tree_constant *, int, int);
-extern tree_constant *builtin_fft (tree_constant *, int, int);
-extern tree_constant *builtin_fgets (tree_constant *, int, int);
-extern tree_constant *builtin_find (tree_constant *, int, int);
-extern tree_constant *builtin_flops (tree_constant *, int, int);
-extern tree_constant *builtin_fopen (tree_constant *, int, int);
-extern tree_constant *builtin_fprintf (tree_constant *, int, int);
-extern tree_constant *builtin_frewind (tree_constant *, int, int);
-extern tree_constant *builtin_freport (tree_constant *, int, int);
-extern tree_constant *builtin_fscanf (tree_constant *, int, int);
-extern tree_constant *builtin_fseek (tree_constant *, int, int);
-extern tree_constant *builtin_fsolve (tree_constant *, int, int);
-extern tree_constant *builtin_fsqp (tree_constant *, int, int);
-extern tree_constant *builtin_ftell (tree_constant *, int, int);
-extern tree_constant *builtin_getenv (tree_constant *, int, int);
-extern tree_constant *builtin_givens (tree_constant *, int, int);
-extern tree_constant *builtin_hess (tree_constant *, int, int);
-extern tree_constant *builtin_input (tree_constant *, int, int);
-extern tree_constant *builtin_ifft (tree_constant *, int, int);
-extern tree_constant *builtin_inv (tree_constant *, int, int);
-extern tree_constant *builtin_isstr (tree_constant *, int, int);
-extern tree_constant *builtin_keyboard (tree_constant *, int, int);
-extern tree_constant *builtin_logm (tree_constant *, int, int);
-extern tree_constant *builtin_lpsolve (tree_constant *, int, int);
-extern tree_constant *builtin_lsode (tree_constant *, int, int);
-extern tree_constant *builtin_lu (tree_constant *, int, int);
-extern tree_constant *builtin_max (tree_constant *, int, int);
-extern tree_constant *builtin_min (tree_constant *, int, int);
-extern tree_constant *builtin_npsol (tree_constant *, int, int);
-extern tree_constant *builtin_ones (tree_constant *, int, int);
-extern tree_constant *builtin_pause (tree_constant *, int, int);
-extern tree_constant *builtin_purge_tmp_files (tree_constant *, int, int);
-extern tree_constant *builtin_printf (tree_constant *, int, int);
-extern tree_constant *builtin_prod (tree_constant *, int, int);
-extern tree_constant *builtin_pwd (tree_constant *, int, int);
-extern tree_constant *builtin_qpsol (tree_constant *, int, int);
-extern tree_constant *builtin_qr (tree_constant *, int, int);
-extern tree_constant *builtin_quad (tree_constant *, int, int);
-extern tree_constant *builtin_quit (tree_constant *, int, int);
-extern tree_constant *builtin_qzval (tree_constant *, int, int);
-extern tree_constant *builtin_rand (tree_constant *, int, int);
-extern tree_constant *builtin_replot (tree_constant *, int, int);
+extern tree_constant *builtin_eval (const tree_constant *, int, int);
+extern tree_constant *builtin_exist (const tree_constant *, int, int);
+extern tree_constant *builtin_expm (const tree_constant *, int, int);
+extern tree_constant *builtin_eye (const tree_constant *, int, int);
+extern tree_constant *builtin_fclose (const tree_constant *, int, int);
+extern tree_constant *builtin_feval (const tree_constant *, int, int);
+extern tree_constant *builtin_fflush (const tree_constant *, int, int);
+extern tree_constant *builtin_fft (const tree_constant *, int, int);
+extern tree_constant *builtin_fgets (const tree_constant *, int, int);
+extern tree_constant *builtin_find (const tree_constant *, int, int);
+extern tree_constant *builtin_flops (const tree_constant *, int, int);
+extern tree_constant *builtin_fopen (const tree_constant *, int, int);
+extern tree_constant *builtin_fprintf (const tree_constant *, int, int);
+extern tree_constant *builtin_frewind (const tree_constant *, int, int);
+extern tree_constant *builtin_freport (const tree_constant *, int, int);
+extern tree_constant *builtin_fscanf (const tree_constant *, int, int);
+extern tree_constant *builtin_fseek (const tree_constant *, int, int);
+extern tree_constant *builtin_fsolve (const tree_constant *, int, int);
+extern tree_constant *builtin_fsqp (const tree_constant *, int, int);
+extern tree_constant *builtin_ftell (const tree_constant *, int, int);
+extern tree_constant *builtin_getenv (const tree_constant *, int, int);
+extern tree_constant *builtin_givens (const tree_constant *, int, int);
+extern tree_constant *builtin_hess (const tree_constant *, int, int);
+extern tree_constant *builtin_input (const tree_constant *, int, int);
+extern tree_constant *builtin_ifft (const tree_constant *, int, int);
+extern tree_constant *builtin_inv (const tree_constant *, int, int);
+extern tree_constant *builtin_isstr (const tree_constant *, int, int);
+extern tree_constant *builtin_keyboard (const tree_constant *, int, int);
+extern tree_constant *builtin_logm (const tree_constant *, int, int);
+extern tree_constant *builtin_lpsolve (const tree_constant *, int, int);
+extern tree_constant *builtin_lsode (const tree_constant *, int, int);
+extern tree_constant *builtin_lu (const tree_constant *, int, int);
+extern tree_constant *builtin_max (const tree_constant *, int, int);
+extern tree_constant *builtin_min (const tree_constant *, int, int);
+extern tree_constant *builtin_npsol (const tree_constant *, int, int);
+extern tree_constant *builtin_ones (const tree_constant *, int, int);
+extern tree_constant *builtin_pause (const tree_constant *, int, int);
+extern tree_constant *builtin_purge_tmp_files (const tree_constant *,
+					       int, int);
+extern tree_constant *builtin_printf (const tree_constant *, int, int);
+extern tree_constant *builtin_prod (const tree_constant *, int, int);
+extern tree_constant *builtin_pwd (const tree_constant *, int, int);
+extern tree_constant *builtin_qpsol (const tree_constant *, int, int);
+extern tree_constant *builtin_qr (const tree_constant *, int, int);
+extern tree_constant *builtin_quad (const tree_constant *, int, int);
+extern tree_constant *builtin_quit (const tree_constant *, int, int);
+extern tree_constant *builtin_qzval (const tree_constant *, int, int);
+extern tree_constant *builtin_rand (const tree_constant *, int, int);
+extern tree_constant *builtin_replot (const tree_constant *, int, int);
 extern tree_constant *builtin_setstr (tree_constant *, int, int);
-extern tree_constant *builtin_scanf (tree_constant *, int, int);
-extern tree_constant *builtin_schur (tree_constant *, int, int);
-extern tree_constant *builtin_shell_command (tree_constant *, int, int);
-extern tree_constant *builtin_size (tree_constant *, int, int);
-extern tree_constant *builtin_sort (tree_constant *, int, int);
-extern tree_constant *builtin_sprintf (tree_constant *, int, int);
-extern tree_constant *builtin_sqrtm (tree_constant *, int, int);
-extern tree_constant *builtin_sscanf (tree_constant *, int, int);
-extern tree_constant *builtin_sum (tree_constant *, int, int);
-extern tree_constant *builtin_sumsq (tree_constant *, int, int);
-extern tree_constant *builtin_svd (tree_constant *, int, int);
-extern tree_constant *builtin_syl (tree_constant *, int, int);
-extern tree_constant *builtin_warranty (tree_constant *, int, int);
-extern tree_constant *builtin_zeros (tree_constant *, int, int);
+extern tree_constant *builtin_scanf (const tree_constant *, int, int);
+extern tree_constant *builtin_schur (const tree_constant *, int, int);
+extern tree_constant *builtin_shell_command (const tree_constant *, int, int);
+extern tree_constant *builtin_size (const tree_constant *, int, int);
+extern tree_constant *builtin_sort (const tree_constant *, int, int);
+extern tree_constant *builtin_sprintf (const tree_constant *, int, int);
+extern tree_constant *builtin_sqrtm (const tree_constant *, int, int);
+extern tree_constant *builtin_sscanf (const tree_constant *, int, int);
+extern tree_constant *builtin_sum (const tree_constant *, int, int);
+extern tree_constant *builtin_sumsq (const tree_constant *, int, int);
+extern tree_constant *builtin_svd (const tree_constant *, int, int);
+extern tree_constant *builtin_syl (const tree_constant *, int, int);
+extern tree_constant *builtin_warranty (const tree_constant *, int, int);
+extern tree_constant *builtin_zeros (const tree_constant *, int, int);
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
 ;;; End: ***
diff --git a/src/input.cc b/src/input.cc
--- a/src/input.cc
+++ b/src/input.cc
@@ -78,17 +78,17 @@ gnu_readline (char *s)
 #include "symtab.h"
 #include "octave-hist.h"
 #include "sighandlers.h"
 #include "parse.h"
 #include "user-prefs.h"
 #include "builtins.h"
 
 // Global pointer for eval().
-char *current_eval_string = (char *) NULL;
+const char *current_eval_string = (char *) NULL;
 
 // Nonzero means get input from current_eval_string.
 int get_input_from_eval_string = 0;
 
 // Nonzero means we're parsing an M-file.
 int reading_m_file = 0;
 
 // Simple name of M-file we are reading.
diff --git a/src/input.h b/src/input.h
--- a/src/input.h
+++ b/src/input.h
@@ -36,17 +36,17 @@ extern char *octave_gets (void);
 extern int octave_read (char *buf, int max_size);
 extern FILE *get_input_from_file (char *name, int warn = 1);
 extern FILE *get_input_from_stdin (void);
 extern char *command_generator (char *text, int state);
 extern char **command_completer (char *text, int start, int end);
 extern void initialize_readline (void);
 
 // Global pointer for eval().
-extern char *current_eval_string;
+extern const char *current_eval_string;
 
 // Nonzero means get input from current_eval_string.
 extern int get_input_from_eval_string;
 
 // Nonzero means we're parsing an M-file.
 extern int reading_m_file;
 
 // Simple name of M-file we are reading.
diff --git a/src/mappers.cc b/src/mappers.cc
--- a/src/mappers.cc
+++ b/src/mappers.cc
@@ -21,16 +21,17 @@ Software Foundation, 675 Mass Ave, Cambr
 
 */
 
 #ifdef __GNUG__
 #pragma implementation
 #endif
 
 #include <float.h>
+#include <Complex.h>
 
 #include "mappers.h"
 #include "utils.h"
 
 #if defined (_AIX) && defined (__GNUG__)
 #undef finite
 #define finite(x) ((x) < DBL_MAX && (x) > -DBL_MAX)
 #endif
diff --git a/src/mappers.h b/src/mappers.h
--- a/src/mappers.h
+++ b/src/mappers.h
@@ -23,17 +23,17 @@ Software Foundation, 675 Mass Ave, Cambr
 
 #if !defined (_mappers_h)
 #define _mappers_h 1
 
 #ifdef __GNUG__
 #pragma interface
 #endif
 
-#include <Complex.h>
+class Complex;
 
 #include "missing-math.h"
 
 extern double arg (double x);
 extern double conj (double x);
 extern double fix (double x);
 extern double imag (double x);
 extern double real (double x);
diff --git a/src/pr-output.cc b/src/pr-output.cc
--- a/src/pr-output.cc
+++ b/src/pr-output.cc
@@ -134,17 +134,17 @@ abs (const Matrix& a)
   Matrix retval (nr, nc);
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
       retval.elem (i, j) = fabs (a.elem (i, j));
   return retval;
 }
 
 static double
-pr_max_internal (Matrix& m)
+pr_max_internal (const Matrix& m)
 {
   int nr = m.rows ();
   int nc = m.columns ();
 
   double result = DBL_MIN;
 
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
@@ -155,17 +155,17 @@ pr_max_internal (Matrix& m)
 
 	if (val > result)
 	  result = val;
       }
   return result;
 }
 
 static double
-pr_min_internal (Matrix& m)
+pr_min_internal (const Matrix& m)
 {
   int nr = m.rows ();
   int nc = m.columns ();
 
   double result = DBL_MAX;
 
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
@@ -267,17 +267,17 @@ set_format (double d, int& fw)
 static inline void
 set_format (double d)
 {
   int fw;
   set_format (d, fw);
 }
 
 static void
-set_format (Matrix& m, int& fw)
+set_format (const Matrix& m, int& fw)
 {
   curr_real_fmt = (char *) NULL;
   curr_imag_fmt = (char *) NULL;
 
   if (free_format)
     return;
 
   static char fmt_buf[32];
@@ -374,24 +374,24 @@ set_format (Matrix& m, int& fw)
     {
       sprintf (fmt_buf, "%%%d.%df", fw, rd);
     }
 
   curr_real_fmt = &fmt_buf[0];
 }
 
 static inline void
-set_format (Matrix& m)
+set_format (const Matrix& m)
 {
   int fw;
   set_format (m, fw);
 }
 
 static void
-set_format (Complex& c, int& r_fw, int& i_fw)
+set_format (const Complex& c, int& r_fw, int& i_fw)
 {
   curr_real_fmt = (char *) NULL;
   curr_imag_fmt = (char *) NULL;
 
   if (free_format)
     return;
 
   static char r_fmt_buf[32];
@@ -513,24 +513,24 @@ set_format (Complex& c, int& r_fw, int& 
       sprintf (i_fmt_buf, "%%%d.%df", i_fw, rd);
     }
 
   curr_real_fmt = &r_fmt_buf[0];
   curr_imag_fmt = &i_fmt_buf[0];
 }
 
 static inline void
-set_format (Complex& c)
+set_format (const Complex& c)
 {
   int r_fw, i_fw;
   set_format (c, r_fw, i_fw);
 }
 
 static void
-set_format (ComplexMatrix& cm, int& r_fw, int& i_fw)
+set_format (const ComplexMatrix& cm, int& r_fw, int& i_fw)
 {
   curr_real_fmt = (char *) NULL;
   curr_imag_fmt = (char *) NULL;
 
   if (free_format)
     return;
 
   static char r_fmt_buf[32];
@@ -651,36 +651,36 @@ set_format (ComplexMatrix& cm, int& r_fw
       sprintf (i_fmt_buf, "%%%d.%df", i_fw, rd);
     }
 
   curr_real_fmt = &r_fmt_buf[0];
   curr_imag_fmt = &i_fmt_buf[0];
 }
 
 static int
-all_elements_are_ints (Range& r)
+all_elements_are_ints (const Range& r)
 {
 // If the base and increment are ints, the final value in the range
 // will also be an integer, even if the limit is not.
 
   double b = r.base ();
   double i = r.inc ();
 
   return ((double) NINT (b) == b && (double) NINT (i) == i);
 }
 
 static inline void
-set_format (ComplexMatrix& cm)
+set_format (const ComplexMatrix& cm)
 {
   int r_fw, i_fw;
   set_format (cm, r_fw, i_fw);
 }
 
 static void
-set_format (Range& r, int& fw)
+set_format (const Range& r, int& fw)
 {
   curr_real_fmt = (char *) NULL;
   curr_imag_fmt = (char *) NULL;
 
   if (free_format)
     return;
 
   static char fmt_buf[32];
@@ -772,24 +772,24 @@ set_format (Range& r, int& fw)
     {
       sprintf (fmt_buf, "%%%d.%df", fw, rd);
     }
 
   curr_real_fmt = &fmt_buf[0];
 }
 
 static inline void
-set_format (Range& r)
+set_format (const Range& r)
 {
   int fw;
   set_format (r, fw);
 }
 
 static inline void
-pr_any_float (char *fmt, ostrstream& os, double d, int fw = 0)
+pr_any_float (const char *fmt, ostrstream& os, double d, int fw = 0)
 {
   if (d == -0.0)
     d = 0.0;
 
   if (fmt == (char *) NULL)
     os << d;
   else
     {
@@ -826,17 +826,17 @@ pr_float (ostrstream& os, double d, int 
 
 static inline void
 pr_imag_float (ostrstream& os, double d, int fw = 0)
 {
   pr_any_float (curr_imag_fmt, os, d, fw);
 }
 
 static inline void
-pr_complex (ostrstream& os, Complex& c, int r_fw = 0, int i_fw = 0)
+pr_complex (ostrstream& os, const Complex& c, int r_fw = 0, int i_fw = 0)
 {
   double r = c.real ();
   pr_float (os, r, r_fw);
   if (! bank_format)
     {
       double i = c.imag ();
       if (i < 0)
 	{
@@ -870,17 +870,17 @@ octave_print_internal (ostrstream& os, d
 	os << d;
       else
 	pr_float (os, d);
     }
   os << "\n";
 }
 
 void
-octave_print_internal (ostrstream& os, Matrix& m)
+octave_print_internal (ostrstream& os, const Matrix& m)
 {
   int nr = m.rows ();
   int nc = m.columns ();
 
   if (plus_format)
     {
       for (int i = 0; i < nr; i++)
 	{
@@ -948,17 +948,17 @@ octave_print_internal (ostrstream& os, M
 	      os << "\n";
 	    }
 	  col += inc;
 	}
     }
 }
 
 void
-octave_print_internal (ostrstream& os, Complex& c)
+octave_print_internal (ostrstream& os, const Complex& c)
 {
   if (plus_format)
     {
       if (c == 0.0)
 	os << " ";
       else
 	os << "+";
     }
@@ -969,17 +969,17 @@ octave_print_internal (ostrstream& os, C
 	os << c;
       else
 	pr_complex (os, c);
     }
   os << "\n";
 }
 
 void
-octave_print_internal (ostrstream& os, ComplexMatrix& cm)
+octave_print_internal (ostrstream& os, const ComplexMatrix& cm)
 {
   int nr = cm.rows ();
   int nc = cm.columns ();
 
   if (plus_format)
     {
       for (int i = 0; i < nr; i++)
 	{
@@ -1051,17 +1051,17 @@ octave_print_internal (ostrstream& os, C
 	      os << "\n";
 	    }
 	  col += inc;
 	}
     }
 }
 
 void
-octave_print_internal (ostrstream& os, Range& r)
+octave_print_internal (ostrstream& os, const Range& r)
 {
   double b = r.base ();
   double increment = r.inc ();
   int num_elem = r.nelem ();
 
   if (plus_format)
     {
       os << "  ";
diff --git a/src/pr-output.h b/src/pr-output.h
--- a/src/pr-output.h
+++ b/src/pr-output.h
@@ -31,20 +31,20 @@ Software Foundation, 675 Mass Ave, Cambr
 class ostrstream;
 
 class Matrix;
 class Complex;
 class ComplexMatrix;
 class Range;
 
 extern void octave_print_internal (ostrstream& os, double d);
-extern void octave_print_internal (ostrstream& os, Matrix& m);
-extern void octave_print_internal (ostrstream& os, Complex& c);
-extern void octave_print_internal (ostrstream& os, ComplexMatrix& cm);
-extern void octave_print_internal (ostrstream& os, Range& r);
+extern void octave_print_internal (ostrstream& os, const Matrix& m);
+extern void octave_print_internal (ostrstream& os, const Complex& c);
+extern void octave_print_internal (ostrstream& os, const ComplexMatrix& cm);
+extern void octave_print_internal (ostrstream& os, const Range& r);
 
 extern void set_format_style (int argc, char **argv);
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
diff --git a/src/pt-base.h b/src/pt-base.h
--- a/src/pt-base.h
+++ b/src/pt-base.h
@@ -33,16 +33,17 @@ Software Foundation, 675 Mass Ave, Cambr
 
 #ifndef NULL_TREE_CONST
 #define NULL_TREE_CONST (tree_constant *)NULL
 #endif
 
 #include <time.h>
 #include <assert.h>
 
+class ostream;
 class tree_constant;
 class tree_identifier;
 class tree_argument_list;
 
 /*
  * Base class for the parse tree.
  */
 class
@@ -89,29 +90,29 @@ public:
       index,
       increment,
       decrement,
    };
 
   virtual ~tree (void) { }
 
 // Only the finest cheese...
-  virtual int is_identifier (void)
+  virtual int is_identifier (void) const
     { return 0; }
 
-  virtual int is_constant (void)
+  virtual int is_constant (void) const
     { return 0; }
 
-  virtual int is_builtin (void)
+  virtual int is_builtin (void) const
     { return 0; }
 
-  virtual int is_index_expression (void)
+  virtual int is_index_expression (void) const
     { return 0; }
 
-  virtual int is_assignment_expression (void)
+  virtual int is_assignment_expression (void) const
     { return 0; }
 
   virtual tree *def (void)
     { assert (0); return (tree *) NULL; }
   
   virtual char *name (void)
     { assert (0); return (char *) NULL; }
 
@@ -140,25 +141,25 @@ public:
     { assert (0); return 0; }
 
   virtual tree_constant eval (int print) = 0;
 
   virtual tree_constant *eval (int print, int nargout);
 
   virtual tree_constant eval (int argc, char **argv, int print);
 
-  virtual tree_constant *eval (tree_constant *args, int n_in, int nout,
+  virtual tree_constant *eval (const tree_constant *args, int n_in, int nout,
 			       int print)
     { assert (0); return NULL_TREE_CONST; }
 
   virtual int save (ostream& os, int mark_as_global = 0)
     { assert (0); return 0; }
 
-  virtual int line (void) { return line_num; }
-  virtual int column (void) { return column_num; }
+  virtual int line (void) const { return line_num; }
+  virtual int column (void) const { return column_num; }
 
 protected:
   int line_num;
   int column_num;
 };
 
 #endif
 
diff --git a/src/pt-const.cc b/src/pt-const.cc
--- a/src/pt-const.cc
+++ b/src/pt-const.cc
@@ -382,22 +382,16 @@ tree_constant_rep::tree_constant_rep (co
 }
 
 tree_constant_rep::tree_constant_rep (const char *s)
 {
   string = strsave (s);
   type_tag = string_constant;
 }
 
-tree_constant_rep::tree_constant_rep (const String& s)
-{
-  string = strsave (s);
-  type_tag = string_constant;
-}
-
 tree_constant_rep::tree_constant_rep (double b, double l, double i)
 {
   range = new Range (b, l, i);
   int nel = range->nelem ();
   if (nel < 0)
     {
       if (nel == -1)
 	error ("number of elements in range exceeds INT_MAX");
@@ -650,17 +644,17 @@ tree_constant_rep::maybe_resize (int i, 
 	  message ((char *) NULL,
 		   "matrix index = %d exceeds max dimension = ", i, nc);
 	  jump_to_top_level ();
 	}
     }
 }
 
 double
-tree_constant_rep::to_scalar (void)
+tree_constant_rep::to_scalar (void) const
 {
   tree_constant tmp = make_numeric ();
 
   double retval = 0.0;
 
   switch (tmp.const_type ())
     {
     case tree_constant_rep::scalar_constant:
@@ -697,17 +691,17 @@ tree_constant_rep::to_scalar (void)
       break;
     default:
       break;
     }
   return retval;
 }
 
 ColumnVector
-tree_constant_rep::to_vector (void)
+tree_constant_rep::to_vector (void) const
 {
   tree_constant tmp = make_numeric ();
 
   ColumnVector retval;
 
   switch (tmp.const_type ())
     {
     case tree_constant_rep::scalar_constant:
@@ -738,17 +732,17 @@ tree_constant_rep::to_vector (void)
     default:
       panic_impossible ();
       break;
     }
   return retval;
 }
 
 Matrix
-tree_constant_rep::to_matrix (void)
+tree_constant_rep::to_matrix (void) const
 {
   tree_constant tmp = make_numeric ();
 
   Matrix retval;
 
   switch (tmp.const_type ())
     {
     case tree_constant_rep::scalar_constant:
@@ -824,17 +818,17 @@ tree_constant_rep::force_numeric (int fo
     default:
       panic_impossible ();
       break;
     }
   return type_tag;
 }
 
 tree_constant
-tree_constant_rep::make_numeric (int force_str_conv = 0)
+tree_constant_rep::make_numeric (int force_str_conv = 0) const
 {
   tree_constant retval;
   switch (type_tag)
     {
     case scalar_constant:
       retval = tree_constant (scalar);
       break;
     case matrix_constant:
@@ -1243,17 +1237,17 @@ tree_constant_rep::eval (int print)
 	}
 
       output_buf << ends;
       maybe_page_output (output_buf);
     }
 }
 
 tree_constant *
-tree_constant_rep::eval (tree_constant *args, int nargin, int nargout,
+tree_constant_rep::eval (const tree_constant *args, int nargin, int nargout,
 			 int print)
 {
   if (error_state)
     return NULL_TREE_CONST;
 
   tree_constant *retval = new tree_constant [2];
   switch (type_tag)
     {
@@ -1530,17 +1524,17 @@ tree_constant_rep::load (istream& is, tr
     default:
       panic_impossible ();
       break;
     }
   return status;
 }
 
 double
-tree_constant_rep::double_value (void)
+tree_constant_rep::double_value (void) const
 {
   switch (type_tag)
     {
     case scalar_constant:
       return scalar;
     case complex_scalar_constant:
       {
 	int flag = user_pref.ok_to_lose_imaginary_part;
@@ -1555,17 +1549,17 @@ tree_constant_rep::double_value (void)
       }
     default:
       panic_impossible ();
       break;
     }
 }
 
 Matrix
-tree_constant_rep::matrix_value (void)
+tree_constant_rep::matrix_value (void) const
 {
   switch (type_tag)
     {
     case matrix_constant:
       return *matrix;
     case complex_matrix_constant:
       {
 	int flag = user_pref.ok_to_lose_imaginary_part;
@@ -1580,32 +1574,32 @@ tree_constant_rep::matrix_value (void)
       }
     default:
       panic_impossible ();
       break;
     }
 }
 
 Complex
-tree_constant_rep::complex_value (void)
+tree_constant_rep::complex_value (void) const
 {
   switch (type_tag)
     {
     case complex_scalar_constant:
       return *complex_scalar;
     case scalar_constant:
       return Complex (scalar);
     default:
       panic_impossible ();
       break;
     }
 }
 
 ComplexMatrix
-tree_constant_rep::complex_matrix_value (void)
+tree_constant_rep::complex_matrix_value (void) const
 {
   switch (type_tag)
     {
     case scalar_constant:
       {
 	return ComplexMatrix (scalar);
       }
     case complex_scalar_constant:
@@ -1621,31 +1615,31 @@ tree_constant_rep::complex_matrix_value 
       break;
     default:
       panic_impossible ();
       break;
     }
 }
 
 char *
-tree_constant_rep::string_value (void)
+tree_constant_rep::string_value (void) const
 {
   assert (type_tag == string_constant);
   return string;
 }
 
 Range
-tree_constant_rep::range_value (void)
+tree_constant_rep::range_value (void) const
 {
   assert (type_tag == range_constant);
   return *range;
 }
 
 int
-tree_constant_rep::rows (void)
+tree_constant_rep::rows (void) const
 {
   int retval = -1;
   switch (type_tag)
     {
     case scalar_constant:
     case complex_scalar_constant:
     case string_constant:
     case range_constant:
@@ -1666,17 +1660,17 @@ tree_constant_rep::rows (void)
     default:
       panic_impossible ();
       break;
     }
   return retval;
 }
 
 int
-tree_constant_rep::columns (void)
+tree_constant_rep::columns (void) const
 {
   int retval = -1;
   switch (type_tag)
     {
     case scalar_constant:
     case complex_scalar_constant:
       retval = 1;
       break;
@@ -1701,17 +1695,17 @@ tree_constant_rep::columns (void)
     default:
       panic_impossible ();
       break;
     }
   return retval;
 }
 
 tree_constant
-tree_constant_rep::all (void)
+tree_constant_rep::all (void) const
 {
   if (type_tag == string_constant || type_tag == range_constant)
     {
       tree_constant tmp = make_numeric ();
       return tmp.all ();
     }
 
   tree_constant retval;
@@ -1747,17 +1741,17 @@ tree_constant_rep::all (void)
     default:
       panic_impossible ();
       break;
     }
   return retval;
 }
 
 tree_constant
-tree_constant_rep::any (void)
+tree_constant_rep::any (void) const
 {
   if (type_tag == string_constant || type_tag == range_constant)
     {
       tree_constant tmp = make_numeric ();
       return tmp.any ();
     }
 
   tree_constant retval;
@@ -1793,20 +1787,20 @@ tree_constant_rep::any (void)
     default:
       panic_impossible ();
       break;
     }
   return retval;
 }
 
 tree_constant
-tree_constant_rep::isstr (void)
+tree_constant_rep::isstr (void) const
 {
   double status = 0.0;
-  if (const_type () == string_constant)
+  if (type_tag == string_constant)
     status = 1.0;
   tree_constant retval (status);
   return retval;
 }
 
 tree_constant
 tree_constant_rep::convert_to_str (void)
 {
@@ -1874,17 +1868,17 @@ tree_constant_rep::convert_to_str (void)
     default:
       panic_impossible ();
       break;
     }
   return retval;
 }
 
 tree_constant
-tree_constant_rep::cumprod (void)
+tree_constant_rep::cumprod (void) const
 {
   if (type_tag == string_constant || type_tag == range_constant)
     {
       tree_constant tmp = make_numeric ();
       return tmp.cumprod ();
     }
 
   tree_constant retval;
@@ -1914,17 +1908,17 @@ tree_constant_rep::cumprod (void)
     default:
       panic_impossible ();
       break;
     }
   return retval;
 }
 
 tree_constant
-tree_constant_rep::cumsum (void)
+tree_constant_rep::cumsum (void) const
 {
   if (type_tag == string_constant || type_tag == range_constant)
     {
       tree_constant tmp = make_numeric ();
       return tmp.cumsum ();
     }
 
   tree_constant retval;
@@ -1954,17 +1948,17 @@ tree_constant_rep::cumsum (void)
     default:
       panic_impossible ();
       break;
     }
   return retval;
 }
 
 tree_constant
-tree_constant_rep::prod (void)
+tree_constant_rep::prod (void) const
 {
   if (type_tag == string_constant || type_tag == range_constant)
     {
       tree_constant tmp = make_numeric ();
       return tmp.prod ();
     }
 
   tree_constant retval;
@@ -1994,17 +1988,17 @@ tree_constant_rep::prod (void)
     default:
       panic_impossible ();
       break;
     }
   return retval;
 }
 
 tree_constant
-tree_constant_rep::sum (void)
+tree_constant_rep::sum (void) const
 {
   if (type_tag == string_constant || type_tag == range_constant)
     {
       tree_constant tmp = make_numeric ();
       return tmp.sum ();
     }
 
   tree_constant retval;
@@ -2034,17 +2028,17 @@ tree_constant_rep::sum (void)
     default:
       panic_impossible ();
       break;
     }
   return retval;
 }
 
 tree_constant
-tree_constant_rep::sumsq (void)
+tree_constant_rep::sumsq (void) const
 {
   if (type_tag == string_constant || type_tag == range_constant)
     {
       tree_constant tmp = make_numeric ();
       return tmp.sumsq ();
     }
 
   tree_constant retval;
@@ -2077,17 +2071,17 @@ tree_constant_rep::sumsq (void)
     default:
       panic_impossible ();
       break;
     }
   return retval;
 }
 
 static tree_constant
-make_diag (Matrix& v, int k)
+make_diag (const Matrix& v, int k)
 {
   int nr = v.rows ();
   int nc = v.columns ();
   assert (nc == 1 || nr == 1);
 
   tree_constant retval;
 
   int roff = 0;
@@ -2119,17 +2113,17 @@ make_diag (Matrix& v, int k)
 	m.elem (i+roff, i+coff) = v.elem (i, 0);
       retval = tree_constant (m);
     }
 
   return retval;
 }
 
 static tree_constant
-make_diag (ComplexMatrix& v, int k)
+make_diag (const ComplexMatrix& v, int k)
 {
   int nr = v.rows ();
   int nc = v.columns ();
   assert (nc == 1 || nr == 1);
 
   tree_constant retval;
 
   int roff = 0;
@@ -2161,17 +2155,17 @@ make_diag (ComplexMatrix& v, int k)
 	m.elem (i+roff, i+coff) = v.elem (i, 0);
       retval = tree_constant (m);
     }
 
   return retval;
 }
 
 tree_constant
-tree_constant_rep::diag (void)
+tree_constant_rep::diag (void) const
 {
   if (type_tag == string_constant || type_tag == range_constant)
     {
       tree_constant tmp = make_numeric ();
       return tmp.diag ();
     }
 
   tree_constant retval;
@@ -2217,17 +2211,17 @@ tree_constant_rep::diag (void)
     default:
       panic_impossible ();
       break;
     }
   return retval;
 }
 
 tree_constant
-tree_constant_rep::diag (tree_constant& a)
+tree_constant_rep::diag (const tree_constant& a) const
 {
   if (type_tag == string_constant || type_tag == range_constant)
     {
       tree_constant tmp = make_numeric ();
       return tmp.diag (a);
     }
 
   tree_constant tmp_a = a.make_numeric ();
@@ -2331,17 +2325,17 @@ tree_constant_rep::print_if_string (ostr
 {
   if (type_tag == string_constant)
     os << string << "\n";
   else if (warn)
     warning ("expecting string, found numeric constant");
 }
 
 tree_constant
-tree_constant_rep::mapper (Mapper_fcn& m_fcn, int print)
+tree_constant_rep::mapper (Mapper_fcn& m_fcn, int print) const
 {
   tree_constant retval;
 
   if (type_tag == string_constant || type_tag == range_constant)
     {
       tree_constant tmp = make_numeric ();
       return tmp.mapper (m_fcn, print);
     }
@@ -2470,17 +2464,17 @@ tree_constant::operator delete (void *p,
 }
 #endif
 
 /*
  * Construct return vector of empty matrices.  Return empty matrices
  * and/or gripe when appropriate.
  */
 tree_constant *
-vector_of_empties (int nargout, char *fcn_name)
+vector_of_empties (int nargout, const char *fcn_name)
 {
   tree_constant *retval = NULL_TREE_CONST;
 
 // Got an empty argument, check if should gripe/return empty values.
 
   int flag = user_pref.propagate_empty_matrices;
   if (flag != 0)
     {
diff --git a/src/pt-const.h b/src/pt-const.h
--- a/src/pt-const.h
+++ b/src/pt-const.h
@@ -24,23 +24,23 @@ Software Foundation, 675 Mass Ave, Cambr
 #if !defined (_tree_const_h)
 #define _tree_const_h 1
 
 #ifdef __GNUG__
 #pragma interface
 #endif
 
 #include <stdlib.h>
-#include <String.h>
 
-#include "Range.h"
 #include "builtins.h"
-#include "Matrix.h"
-#include "idx-vector.h"
 #include "tree-base.h"
+#include "Matrix.h" // Needed for some inline functions.
+#include "Range.h"  // Ditto.
+
+class idx_vector;
 
 /*
  * How about a few macros?
  */
 
 #ifndef MAX
 #define MAX(a,b) ((a) > (b) ? (a) : (b))
 #endif
@@ -246,17 +246,16 @@ public:
   tree_constant_rep (const ComplexMatrix& m);
   tree_constant_rep (const ComplexDiagMatrix& d);
   tree_constant_rep (const ComplexRowVector& v);
   tree_constant_rep (const ComplexRowVector& v, int pcv);
   tree_constant_rep (const ComplexColumnVector& v);
   tree_constant_rep (const ComplexColumnVector& v, int pcv);
 
   tree_constant_rep (const char *s);
-  tree_constant_rep (const String& s);
 
   tree_constant_rep (double base, double limit, double inc);
   tree_constant_rep (const Range& r);
 
   tree_constant_rep (tree_constant_rep::constant_type t);
 
   tree_constant_rep (const tree_constant_rep& t);
 
@@ -268,64 +267,64 @@ public:
 #endif
 
   void resize (int i, int j);
   void resize (int i, int j, double val);
 
   void maybe_resize (int imax, force_orient fo = no_orient);
   void maybe_resize (int imax, int jmax);
 
-  int valid_as_scalar_index (void);
+  int valid_as_scalar_index (void) const;
 
-  int is_defined (void)
+  int is_defined (void) const
     { return type_tag != tree_constant_rep::unknown_constant; }
 
-  int is_undefined (void)
+  int is_undefined (void) const
     { return type_tag == tree_constant_rep::unknown_constant; }
 
-  int is_string_type (void)
+  int is_string_type (void) const
     { return type_tag == tree_constant_rep::string_constant; }
 
-  int is_scalar_type (void)
+  int is_scalar_type (void) const
     { return type_tag == scalar_constant
              || type_tag == complex_scalar_constant; }
 
-  int is_matrix_type (void)
+  int is_matrix_type (void) const
     { return type_tag == matrix_constant
              || type_tag == complex_matrix_constant; }
 
-  int is_real_type (void)
+  int is_real_type (void) const
     { return type_tag == scalar_constant
              || type_tag == matrix_constant
 	     || type_tag == range_constant; }
 
-  int is_complex_type (void)
+  int is_complex_type (void) const
     { return type_tag == complex_matrix_constant
              || type_tag == complex_scalar_constant; }
 
 
-  int is_numeric_type (void)
+  int is_numeric_type (void) const
     { return type_tag == scalar_constant
              || type_tag == matrix_constant
 	     || type_tag == complex_matrix_constant
              || type_tag == complex_scalar_constant; }
 
-  int is_numeric_or_range_type (void)
+  int is_numeric_or_range_type (void) const
     { return type_tag == scalar_constant
              || type_tag == matrix_constant
 	     || type_tag == complex_matrix_constant
              || type_tag == complex_scalar_constant
 	     || type_tag == range_constant; }
 
-  double to_scalar (void);
-  ColumnVector to_vector (void);
-  Matrix to_matrix (void);
+  double to_scalar (void) const;
+  ColumnVector to_vector (void) const;
+  Matrix to_matrix (void) const;
 
   tree_constant_rep::constant_type force_numeric (int force_str_conv = 0);
-  tree_constant make_numeric (int force_str_conv = 0);
+  tree_constant make_numeric (int force_str_conv = 0) const;
 
   friend tree_constant
     do_binary_op (tree_constant& a, tree_constant& b, tree::expression_type t);
 
   friend tree_constant
     do_unary_op (tree_constant& a, tree::expression_type t);
 
   void assign (tree_constant& rhs, tree_constant *args, int nargs);
@@ -346,17 +345,18 @@ public:
 					tree_constant& i_arg);
 
   void fortran_style_matrix_assignment (tree_constant& rhs, constant_type ci);
 
   void fortran_style_matrix_assignment (tree_constant& rhs, idx_vector& i);
 
   void vector_assignment (tree_constant& rhs, tree_constant& i_arg);
 
-  void check_vector_assign (int rhs_nr, int rhs_nc, int ilen, char *rm);
+  void check_vector_assign (int rhs_nr, int rhs_nc, int ilen,
+			    const char *rm);
 
   void do_vector_assign (tree_constant& rhs, int i);
   void do_vector_assign (tree_constant& rhs, idx_vector& i);
   void do_vector_assign (tree_constant& rhs, Range& i, int imax);
 
   void do_matrix_assignment
     (tree_constant& rhs, int i, tree_constant& j_arg);
   void do_matrix_assignment
@@ -389,121 +389,134 @@ public:
   void do_matrix_assignment (tree_constant& rhs, constant_type i, Range& j);
   void do_matrix_assignment (tree_constant& rhs, constant_type i,
 			     constant_type j);
 
   void bump_value (tree::expression_type);
 
   void eval (int print);
 
-  tree_constant *eval (tree_constant *args, int n_in, int n_out, int print);
-
-  tree_constant do_scalar_index (tree_constant *args, int nargin);
+  tree_constant *eval (const tree_constant *args, int n_in, int n_out,
+		       int print);
 
-  tree_constant do_matrix_index (tree_constant *args, int nargin);
+  tree_constant do_scalar_index (const tree_constant *args,
+				 int nargin) const;
 
-  tree_constant do_matrix_index (tree_constant& i_arg);
+  tree_constant do_matrix_index (const tree_constant *args, int nargin) const;
+
+  tree_constant do_matrix_index (const tree_constant& i_arg) const;
 
-  tree_constant do_matrix_index (tree_constant& i_arg, tree_constant& j_arg);
+  tree_constant do_matrix_index (const tree_constant& i_arg,
+				 const tree_constant& j_arg) const; 
 
-  tree_constant do_matrix_index (constant_type i);
+  tree_constant do_matrix_index (constant_type i) const;
 
-  tree_constant fortran_style_matrix_index (tree_constant& i_arg);
-  tree_constant fortran_style_matrix_index (Matrix& mi);
+  tree_constant fortran_style_matrix_index (const tree_constant& i_arg) const;
+  tree_constant fortran_style_matrix_index (const Matrix& mi) const;
 
-  tree_constant do_vector_index (tree_constant& i_arg);
+  tree_constant do_vector_index (const tree_constant& i_arg) const;
 
-  tree_constant do_matrix_index (int i, tree_constant& i_arg);
-  tree_constant do_matrix_index (idx_vector& i, tree_constant& i_arg);
-  tree_constant do_matrix_index (Range& i, int imax, tree_constant& i_arg);
-  tree_constant do_matrix_index (constant_type i, tree_constant& i_arg);
+  tree_constant do_matrix_index (int i, const tree_constant& i_arg) const;
+  tree_constant do_matrix_index (const idx_vector& i,
+				 const tree_constant& i_arg) const; 
+  tree_constant do_matrix_index (const Range& i, int imax,
+				 const tree_constant& i_arg) const;
+  tree_constant do_matrix_index (constant_type i,
+				 const tree_constant& i_arg) const;
 
-  tree_constant do_matrix_index (int i, int j);
-  tree_constant do_matrix_index (int i, idx_vector& j);
-  tree_constant do_matrix_index (int i, Range& j);
-  tree_constant do_matrix_index (int i, constant_type cj);
+  tree_constant do_matrix_index (int i, int j) const;
+  tree_constant do_matrix_index (int i, const idx_vector& j) const;
+  tree_constant do_matrix_index (int i, const Range& j) const;
+  tree_constant do_matrix_index (int i, constant_type cj) const;
 
-  tree_constant do_matrix_index (idx_vector& i, int j);
-  tree_constant do_matrix_index (idx_vector& i, idx_vector& j);
-  tree_constant do_matrix_index (idx_vector& i, Range& j);
-  tree_constant do_matrix_index (idx_vector& i, constant_type j);
+  tree_constant do_matrix_index (const idx_vector& i, int j) const;
+  tree_constant do_matrix_index (const idx_vector& i,
+				 const idx_vector& j) const;
+  tree_constant do_matrix_index (const idx_vector& i, const Range& j) const;
+  tree_constant do_matrix_index (const idx_vector& i, constant_type j) const;
 
-  tree_constant do_matrix_index (Range& i, int j);
-  tree_constant do_matrix_index (Range& i, idx_vector& j);
-  tree_constant do_matrix_index (Range& i, Range& j);
-  tree_constant do_matrix_index (Range& i, constant_type j);
+  tree_constant do_matrix_index (const Range& i, int j) const;
+  tree_constant do_matrix_index (const Range& i, const idx_vector& j) const;
+  tree_constant do_matrix_index (const Range& i, const Range& j) const;
+  tree_constant do_matrix_index (const Range& i, constant_type j) const;
 
-  tree_constant do_matrix_index (constant_type i, int j);
-  tree_constant do_matrix_index (constant_type i, idx_vector& j);
-  tree_constant do_matrix_index (constant_type i, Range& j);
-  tree_constant do_matrix_index (constant_type i, constant_type j);
+  tree_constant do_matrix_index (constant_type i, int j) const;
+  tree_constant do_matrix_index (constant_type i, const idx_vector& j) const;
+  tree_constant do_matrix_index (constant_type i, const Range& j) const;
+  tree_constant do_matrix_index (constant_type i, constant_type j) const;
 
   int save (ostream& os, int mark_as_global);
   int save_three_d (ostream& os, int parametric);
   int load (istream& is);
   constant_type load (istream& is, constant_type t);
 
-  double double_value (void);
-  Matrix matrix_value (void);
-  Complex complex_value (void);
-  ComplexMatrix complex_matrix_value (void);
-  char *string_value (void);
-  Range range_value (void);
+  double double_value (void) const;
+  Matrix matrix_value (void) const;
+  Complex complex_value (void) const;
+  ComplexMatrix complex_matrix_value (void) const;
+  char *string_value (void) const;
+  Range range_value (void) const;
 
-  int rows (void);
-  int columns (void);
+  int rows (void) const;
+  int columns (void) const;
 
-  tree_constant all (void);
-  tree_constant any (void);
-  tree_constant isstr (void);
+  tree_constant all (void) const;
+  tree_constant any (void) const;
+  tree_constant isstr (void) const;
 
   tree_constant convert_to_str (void);
 
-  tree_constant cumprod (void);
-  tree_constant cumsum (void);
-  tree_constant prod (void);
-  tree_constant sum (void);
-  tree_constant sumsq (void);
+  tree_constant cumprod (void) const;
+  tree_constant cumsum (void) const;
+  tree_constant prod (void) const;
+  tree_constant sum (void) const;
+  tree_constant sumsq (void) const;
 
-  tree_constant diag (void);
-  tree_constant diag (tree_constant& a);
+  tree_constant diag (void) const;
+  tree_constant diag (const tree_constant& a) const;
 
-  friend tree_constant fill_matrix (tree_constant& a, double d,
-				    char *warn_for);
-  friend tree_constant fill_matrix (tree_constant& a, tree_constant& b,
-				    double d, char *warn_for);
+  friend tree_constant fill_matrix (const tree_constant& a,
+				    double d, const char *warn_for);
+  friend tree_constant fill_matrix (const tree_constant& a,
+				    const tree_constant& b,
+				    double d, const char *warn_for);
 
-  friend tree_constant identity_matrix (tree_constant& a);
-  friend tree_constant identity_matrix (tree_constant& a, tree_constant& b);
-
-  friend tree_constant find_nonzero_elem_idx (tree_constant& a);
+  friend tree_constant identity_matrix (const tree_constant& a);
+  friend tree_constant identity_matrix (const tree_constant& a,
+					const tree_constant& b);
 
-  friend tree_constant *matrix_log (tree_constant& a);
-  friend tree_constant *matrix_sqrt (tree_constant& a);
+  friend tree_constant find_nonzero_elem_idx (const tree_constant& a);
 
-  friend tree_constant *column_max (tree_constant *args, int nargin,
+  friend tree_constant *matrix_log (const tree_constant& a);
+  friend tree_constant *matrix_sqrt (const tree_constant& a);
+
+  friend tree_constant *column_max (const tree_constant *args, int nargin,
 				    int nargout);
 
-  friend tree_constant *column_min (tree_constant *args, int nargin,
+  friend tree_constant *column_min (const tree_constant *args, int nargin,
 				    int nargout);
   
-  friend tree_constant *sort (tree_constant *args, int nargin, int nargout);
+  friend tree_constant *sort (const tree_constant *args, int nargin,
+			      int nargout);
  
-  friend tree_constant *feval (tree_constant *args, int nargin, int nargout);
+  friend tree_constant *feval (const tree_constant *args, int nargin,
+			       int nargout);
 
-  friend tree_constant eval_string (tree_constant& arg, int& parse_status);
+  friend tree_constant eval_string (const tree_constant& arg, int&
+				    parse_status);
 
-  friend tree_constant get_user_input (tree_constant *args, int nargin,
-				       int nargout, int debug = 0);
+  friend tree_constant get_user_input (const tree_constant *args,
+				       int nargin, int nargout,
+				       int debug = 0);
 
   void print_if_string (ostream& os, int warn);
 
-  constant_type const_type (void) { return type_tag; }
+  constant_type const_type (void) const { return type_tag; }
 
-  tree_constant mapper (Mapper_fcn& m_fcn, int print);
+  tree_constant mapper (Mapper_fcn& m_fcn, int print) const;
 
 private:
   int count;
   constant_type type_tag;
   union
     {
       double scalar;			// A real scalar constant.
       Matrix *matrix;			// A real matrix constant.
@@ -554,18 +567,16 @@ public:
     { rep = new tree_constant_rep (v, pcv); rep->count = 1; }
   tree_constant (const ComplexColumnVector& v)
     { rep = new tree_constant_rep (v); rep->count = 1; }
   tree_constant (const ComplexColumnVector& v, int pcv)
     { rep = new tree_constant_rep (v, pcv); rep->count = 1; }
 
   tree_constant (const char *s)
     { rep = new tree_constant_rep (s); rep->count = 1; }
-  tree_constant (const String& s)
-    { rep = new tree_constant_rep (s); rep->count = 1; }
 
   tree_constant (double base, double limit, double inc)
     { rep = new tree_constant_rep (base, limit, inc); rep->count = 1; }
   tree_constant (const Range& r)
     { rep = new tree_constant_rep (r); rep->count = 1; }
 
   tree_constant (tree_constant_rep::constant_type t)
     { rep = new tree_constant_rep (t); rep->count = 1; }
@@ -587,70 +598,71 @@ public:
       if (--rep->count <= 0 && rep != a.rep)
 	delete rep;
 
       rep = a.rep;
       rep->count++;
       return *this;  
     }
 
-  int is_constant (void) { return 1; }
+  int is_constant (void) const { return 1; }
 
-  int is_scalar_type (void) { return rep->is_scalar_type (); }
-  int is_matrix_type (void) { return rep->is_matrix_type (); }
+  int is_scalar_type (void) const { return rep->is_scalar_type (); }
+  int is_matrix_type (void) const { return rep->is_matrix_type (); }
 
-  int is_real_type (void) { return rep->is_real_type (); }
-  int is_complex_type (void) { return rep->is_complex_type (); }
+  int is_real_type (void) const { return rep->is_real_type (); }
+  int is_complex_type (void) const { return rep->is_complex_type (); }
 
-  int is_numeric_type (void) { return rep->is_numeric_type (); }
+  int is_numeric_type (void) const { return rep->is_numeric_type (); }
 
-  int is_numeric_or_range_type (void)
+  int is_numeric_or_range_type (void) const
     { return rep->is_numeric_or_range_type (); }
 
-  int is_string_type (void) { return rep->is_string_type (); }
+  int is_string_type (void) const { return rep->is_string_type (); }
 
-  int valid_as_scalar_index (void) { return rep->valid_as_scalar_index (); }
+  int valid_as_scalar_index (void) const
+    { return rep->valid_as_scalar_index (); }
 
-  int is_defined (void) { return rep->is_defined (); }
-  int is_undefined (void) { return rep->is_undefined (); }
+  int is_defined (void) const { return rep->is_defined (); }
+  int is_undefined (void) const { return rep->is_undefined (); }
 
-  double to_scalar (void) { return rep->to_scalar (); }
-  ColumnVector to_vector (void) { return rep->to_vector (); }
-  Matrix to_matrix (void) { return rep->to_matrix (); }
+  double to_scalar (void) const { return rep->to_scalar (); }
+  ColumnVector to_vector (void) const { return rep->to_vector (); }
+  Matrix to_matrix (void) const { return rep->to_matrix (); }
 
   tree_constant_rep::constant_type force_numeric (int force_str_conv = 0)
     { return rep->force_numeric (force_str_conv); }
 
-  tree_constant make_numeric (int force_str_conv = 0)
+  tree_constant make_numeric (int force_str_conv = 0) const
     {
       if (is_numeric_type ())
 	return *this;
       else
 	return rep->make_numeric (force_str_conv);
     }
 
-  tree_constant make_numeric_or_range (void)
+  tree_constant make_numeric_or_range (void) const
     {
       if (is_numeric_type ()
 	  || rep->type_tag == tree_constant_rep::range_constant)
 	return *this;
       else
 	return rep->make_numeric ();
     }
 
-  tree_constant make_numeric_or_magic (void)
+  tree_constant make_numeric_or_magic (void) const
     {
       if (is_numeric_type ()
 	  || rep->type_tag == tree_constant_rep::magic_colon)
 	return *this;
       else
 	return rep->make_numeric ();
     }
 
-  tree_constant make_numeric_or_range_or_magic (void)
+  tree_constant make_numeric_or_range_or_magic (void) const
     {
       if (is_numeric_type ()
 	  || rep->type_tag == tree_constant_rep::magic_colon
 	  || rep->type_tag == tree_constant_rep::range_constant)
 	return *this;
       else
 	return rep->make_numeric ();
     }
@@ -672,51 +684,51 @@ public:
   int save_three_d (ostream& os, int parametric = 0)
     { return rep->save_three_d (os, parametric); }
 
   int load (istream& is) { return rep->load (is); }
   tree_constant_rep::constant_type load
     (istream& is, tree_constant_rep::constant_type t)
       { return rep->load (is, t); }
 
-  double double_value (void) { return rep->double_value (); }
-  Matrix matrix_value (void) { return rep->matrix_value (); }
-  Complex complex_value (void) { return rep->complex_value (); }
-  ComplexMatrix complex_matrix_value (void)
+  double double_value (void) const { return rep->double_value (); }
+  Matrix matrix_value (void) const { return rep->matrix_value (); }
+  Complex complex_value (void) const { return rep->complex_value (); }
+  ComplexMatrix complex_matrix_value (void) const
     { return rep->complex_matrix_value (); }
-  char *string_value (void) { return rep->string_value (); }
-  Range range_value (void) { return rep->range_value (); }
+  char *string_value (void) const { return rep->string_value (); }
+  Range range_value (void) const { return rep->range_value (); }
 
-  int rows (void) { return rep->rows (); }
-  int columns (void) { return rep->columns (); }
+  int rows (void) const { return rep->rows (); }
+  int columns (void) const { return rep->columns (); }
 
-  int is_empty (void) { return (rows () == 0 || columns () == 0); }
+  int is_empty (void) const { return (rows () == 0 || columns () == 0); }
 
-  tree_constant all (void) { return rep->all (); }
-  tree_constant any (void) { return rep->any (); }
-  tree_constant isstr (void) { return rep->isstr (); }
+  tree_constant all (void) const { return rep->all (); }
+  tree_constant any (void) const { return rep->any (); }
+  tree_constant isstr (void) const { return rep->isstr (); }
 
   tree_constant convert_to_str (void) { return rep->convert_to_str (); }
 
-  tree_constant cumprod (void) { return rep->cumprod (); }
-  tree_constant cumsum (void) { return rep->cumsum (); }
-  tree_constant prod (void) { return rep->prod (); }
-  tree_constant sum (void) { return rep->sum (); }
-  tree_constant sumsq (void) { return rep->sumsq (); }
+  tree_constant cumprod (void) const { return rep->cumprod (); }
+  tree_constant cumsum (void) const { return rep->cumsum (); }
+  tree_constant prod (void) const { return rep->prod (); }
+  tree_constant sum (void) const { return rep->sum (); }
+  tree_constant sumsq (void) const { return rep->sumsq (); }
 
-  tree_constant diag (void) { return rep->diag (); }
-  tree_constant diag (tree_constant& a) { return rep->diag (a); }
+  tree_constant diag (void) const { return rep->diag (); }
+  tree_constant diag (const tree_constant& a) const { return rep->diag (a); }
 
   void print_if_string (ostream& os, int warn)
     { rep->print_if_string (os, warn); }
 
-  tree_constant_rep::constant_type const_type (void)
+  tree_constant_rep::constant_type const_type (void) const
     { return rep->const_type (); }
 
-  tree_constant mapper (Mapper_fcn& m_fcn, int print)
+  tree_constant mapper (Mapper_fcn& m_fcn, int print) const
     { return rep->mapper (m_fcn, print); }
 
   void bump_value (tree::expression_type et)
     {
       if (rep->count > 1)
 	{
 	  --rep->count;
 	  rep = new tree_constant_rep (*rep);
@@ -732,29 +744,30 @@ public:
   tree_constant *eval (int print, int nargout)
     {
       rep->eval (print);
       tree_constant *retval = new tree_constant [2];
       retval[0] = *this;
       return retval;
     }
 
-  tree_constant *eval (tree_constant *args, int n_in, int n_out, int print)
+  tree_constant *eval (const tree_constant *args, int n_in, int n_out,
+		       int print)
     { return rep->eval (args, n_in, n_out, print); }
 
 private:
   tree_constant_rep *rep;
 };
 
 /*
  * Here are some extra functions that are related to the tree_constant
  * class but that don't need to be class members or friends.
  */
 
-extern tree_constant *vector_of_empties (int nargout, char *fcn_name);
+extern tree_constant *vector_of_empties (int nargout, const char *fcn_name);
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
 ;;; End: ***
diff --git a/src/symtab.cc b/src/symtab.cc
--- a/src/symtab.cc
+++ b/src/symtab.cc
@@ -96,29 +96,29 @@ symbol_def::define (tree_builtin *t)
 void
 symbol_def::define (tree_function *t)
 {
   definition = t;
   type = user_function;
 }
 
 tree *
-symbol_def::def (void)
+symbol_def::def (void) const
 {
   return definition;
 }
 
 char *
-symbol_def::help (void)
+symbol_def::help (void) const
 {
   return help_string;
 }
 
 void
-symbol_def::document (char *h)
+symbol_def::document (const char *h)
 {
   delete [] help_string;
   help_string = strsave (h);
 }
 
 int
 symbol_def::save (ostream& os, int mark_as_global)
 {
@@ -134,28 +134,28 @@ symbol_record::symbol_record (void)
   formal_param = 0;
   forced_global = 0;
   var = (symbol_def *) NULL;
   fcn = (symbol_def *) NULL;
   sv_fcn = (sv_Function) NULL;
   next_elem = (symbol_record *) NULL;
 }
 
-symbol_record::symbol_record (char *n)
+symbol_record::symbol_record (const char *n)
 {
   nm = strsave (n);
   formal_param = 0;
   forced_global = 0;
   var = (symbol_def *) NULL;
   fcn = (symbol_def *) NULL;
   sv_fcn = (sv_Function) NULL;
   next_elem = (symbol_record *) NULL;
 }
 
-symbol_record::symbol_record (char *n, symbol_record *nxt)
+symbol_record::symbol_record (const char *n, symbol_record *nxt)
 {
   nm = strsave (n);
   formal_param = 0;
   forced_global = 0;
   var = (symbol_def *) NULL;
   fcn = (symbol_def *) NULL;
   sv_fcn = (sv_Function) NULL;
   next_elem = nxt;
@@ -168,57 +168,57 @@ symbol_record::~symbol_record (void)
   if (var != (symbol_def *) NULL && --var->count <= 0)
     delete var;
 
   if (fcn != (symbol_def *) NULL && --fcn->count <= 0)
     delete fcn;
 }
 
 char *
-symbol_record::name (void)
+symbol_record::name (void) const
 {
   return nm;
 }
 
 char *
-symbol_record::help (void)
+symbol_record::help (void) const
 {
   if (var != (symbol_def *) NULL)
     return var->help ();
   else if (fcn != (symbol_def *) NULL)
     return fcn->help ();
   else
     return (char *) NULL;
 }
 
 tree *
-symbol_record::def (void)
+symbol_record::def (void) const
 {
   if (var != (symbol_def *) NULL)
     return var->def ();
   else if (fcn != (symbol_def *) NULL)
     return fcn->def ();
   else
     return (tree *) NULL;
 }
 
 int
-symbol_record::is_function (void)
+symbol_record::is_function (void) const
 {
   return (var == (symbol_def *) NULL && fcn != (symbol_def *) NULL);
 }
 
 int
-symbol_record::is_variable (void)
+symbol_record::is_variable (void) const
 {
   return (var != (symbol_def *) NULL);
 }
 
 int
-symbol_record::is_defined (void)
+symbol_record::is_defined (void) const
 {
   return (var != (symbol_def *) NULL || fcn != (symbol_def *) NULL);
 }
 
 void
 symbol_record::set_sv_function (sv_Function f)
 {
   sv_fcn = f;
@@ -351,17 +351,17 @@ symbol_record::define_as_fcn (tree_const
       fcn = new symbol_def (t);
       fcn->count = 1;
     }
 
   return 1;
 }
 
 void
-symbol_record::document (char *h)
+symbol_record::document (const char *h)
 {
   if (var != (symbol_def *) NULL)
     var->document (h);
   else if (fcn != (symbol_def *) NULL)
     fcn->document (h);
   else
     warning ("couldn't document undefined variable `%s'", nm);
 }
@@ -482,29 +482,29 @@ symbol_record::undefine (void)
 
 void
 symbol_record::mark_as_formal_parameter (void)
 {
   formal_param = 1;
 }
 
 int
-symbol_record::is_formal_parameter (void)
+symbol_record::is_formal_parameter (void) const
 {
   return formal_param;
 }
 
 void
 symbol_record::mark_as_forced_global (void)
 {
   forced_global = 1;
 }
 
 int
-symbol_record::is_forced_global (void)
+symbol_record::is_forced_global (void) const
 {
   return forced_global;
 }
 
 void
 symbol_record::alias (symbol_record *s, int force = 0)
 {
   sv_fcn = s->sv_fcn; // Maybe this should go in the var symbol_def?
@@ -529,31 +529,31 @@ symbol_record::alias (symbol_record *s, 
   else if (s->fcn != (symbol_def *) NULL)
     {
       fcn = s->fcn;
       fcn->count++;
     }
 }
 
 symbol_record *
-symbol_record::next (void)
+symbol_record::next (void) const
 {
   return next_elem;
 }
 
 /*
  * A symbol table.
  */
 
 symbol_table::symbol_table (void)
 {
 }
 
 symbol_record *
-symbol_table::lookup (char *nm, int insert = 0, int warn = 0)
+symbol_table::lookup (const char *nm, int insert = 0, int warn = 0)
 {
   int index = hash (nm) & HASH_MASK;
 
   symbol_record *ptr = table[index].next ();
 
   while (ptr != (symbol_record *) NULL)
     {
       if (strcmp (ptr->name (), nm) == 0)
@@ -600,17 +600,17 @@ symbol_table::clear (void)
 	      curr = curr->next ();
 	      delete tmp;
 	    }
 	}
     }
 }
 
 int
-symbol_table::clear (char *nm)
+symbol_table::clear (const char *nm)
 {
   int index = hash (nm) & HASH_MASK;
 
   symbol_record *prev = &table[index];
   symbol_record *curr = prev->next ();
 
   while (curr != (symbol_record *) NULL)
     {
@@ -686,64 +686,64 @@ symbol_table::save (ostream& os, int mar
 
 	  names++;
 	}
     }
   return status;
 }
 
 int
-symbol_table::save (ostream& os, char *name, int mark_as_global = 0)
+symbol_table::save (ostream& os, const char *name, int mark_as_global = 0)
 {
   int status = 0;
   symbol_record *sr = lookup (name, 0, 0);
   if (sr != (symbol_record *) NULL)
     status = sr->save (os, mark_as_global);
   return status;
 }
 
 int
-symbol_table::size (void)
+symbol_table::size (void) const
 {
   int count = 0;
   for (int i = 0; i < HASH_TABLE_SIZE; i++)
     {
       symbol_record *ptr = table[i].next ();
       while (ptr != (symbol_record *) NULL)
 	{
 	  count++;
 	  ptr = ptr->next ();
 	}
     }
   return count;
 }
 
 char **
-symbol_table::list (void)
+symbol_table::list (void) const
 {
   int count;
   return list (count);
 }
 
 char **
-symbol_table::var_list (void)
+symbol_table::var_list (void) const
 {
   int count;
   return var_list (count);
 }
 
 char **
-symbol_table::fcn_list (void)
+symbol_table::fcn_list (void) const
 {
   int count;
   return fcn_list (count);
 }
 
 char **
-symbol_table::list (int& count)
+symbol_table::list (int& count) const
 {
   count = 0;
   int n = size ();
   if (n == 0)
     return (char **) NULL;
 
   char **symbols = new char * [n+1];
   for (int i = 0; i < HASH_TABLE_SIZE; i++)
@@ -756,17 +756,17 @@ symbol_table::list (int& count)
 	  ptr = ptr->next ();
 	}
     }
   symbols[count] = (char *) NULL;
   return symbols;
 }
 
 char **
-symbol_table::var_list (int& count)
+symbol_table::var_list (int& count) const
 {
   count = 0;
   int n = size ();
   if (n == 0)
     return (char **) NULL;
 
   char **symbols = new char * [n+1];
   for (int i = 0; i < HASH_TABLE_SIZE; i++)
@@ -780,17 +780,17 @@ symbol_table::var_list (int& count)
 	  ptr = ptr->next ();
 	}
     }
   symbols[count] = (char *) NULL;
   return symbols;
 }
 
 char **
-symbol_table::fcn_list (int& count)
+symbol_table::fcn_list (int& count) const
 {
   count = 0;
   int n = size ();
   if (n == 0)
     return (char **) NULL;
 
   char **symbols = new char * [n+1];
   for (int i = 0; i < HASH_TABLE_SIZE; i++)
@@ -810,58 +810,58 @@ symbol_table::fcn_list (int& count)
 
 static inline int
 pstrcmp (char **a, char **b)
 {
   return strcmp (*a, *b);
 }
 
 char **
-symbol_table::sorted_list (void)
+symbol_table::sorted_list (void) const
 {
   int count = 0;
   return sorted_list (count);
 }
 
 char **
-symbol_table::sorted_var_list (void)
+symbol_table::sorted_var_list (void) const
 {
   int count = 0;
   return sorted_var_list (count);
 }
 
 char **
-symbol_table::sorted_fcn_list (void)
+symbol_table::sorted_fcn_list (void) const
 {
   int count = 0;
   return sorted_fcn_list (count);
 }
 
 char **
-symbol_table::sorted_list (int& count)
+symbol_table::sorted_list (int& count) const
 {
   char **symbols = list (count);
   if (symbols != (char **) NULL)
     qsort ((void **) symbols, count, sizeof (char *),
 	   (int (*)(void*, void*)) pstrcmp);
   return symbols;
 }
 
 char **
-symbol_table::sorted_var_list (int& count)
+symbol_table::sorted_var_list (int& count) const
 {
   char **symbols = var_list (count);
   if (symbols != (char **) NULL)
     qsort ((void **) symbols, count, sizeof (char *),
 	   (int (*)(void*, void*)) pstrcmp);
   return symbols;
 }
 
 char **
-symbol_table::sorted_fcn_list (int& count)
+symbol_table::sorted_fcn_list (int& count) const
 {
   char **symbols = fcn_list (count);
   if (symbols != (char **) NULL)
     qsort ((void **) symbols, count, sizeof (char *),
 	   (int (*)(void*, void*)) pstrcmp);
   return symbols;
 }
 
diff --git a/src/symtab.h b/src/symtab.h
--- a/src/symtab.h
+++ b/src/symtab.h
@@ -87,19 +87,19 @@ public:
   symbol_def (tree_function *t);
 
   ~symbol_def (void);
 
   void define (tree_constant *t);
   void define (tree_builtin *t);
   void define (tree_function *t);
 
-  tree *def (void);
-  char *help (void);
-  void document (char *h);
+  tree *def (void) const;
+  char *help (void) const;
+  void document (const char *h);
 
   int save (ostream& os, int mark_as_global);
 
 private:
 
   char *help_string;
   symbol_lifespan lifespan;
   symbol_class sym_class;
@@ -117,61 +117,61 @@ private:
  */
 class
 symbol_record
 {
  friend class symbol_table;
 
 public:
   symbol_record (void);
-  symbol_record (char *n);
-  symbol_record (char *n, symbol_record *nxt);
+  symbol_record (const char *n);
+  symbol_record (const char *n, symbol_record *nxt);
 
  ~symbol_record (void);
 
-  char *name (void);
-  char *help (void); 
-  tree *def (void);
+  char *name (void) const;
+  char *help (void) const; 
+  tree *def (void) const;
 
-  int is_function (void);
-  int is_variable (void);
+  int is_function (void) const;
+  int is_variable (void) const;
 
-  int is_defined (void);
+  int is_defined (void) const;
 
   void set_sv_function (sv_Function f);
 
   int var_read_only (void);
   int read_only (void);
 
   int define (tree_constant *t);
   int define (tree_builtin *t);
   int define (tree_function *t);
   int define_as_fcn (tree_constant *t);
 
-  void document (char *h);
+  void document (const char *h);
 
   void protect (void);
   void unprotect (void);
   void make_eternal (void);
 
   int save (ostream& os, int mark_as_global = 0);
 
   void clear_visible (void);
   void clear_all (void);
   void undefine (void);
 
   void mark_as_formal_parameter (void);
-  int is_formal_parameter (void);
+  int is_formal_parameter (void) const;
 
   void mark_as_forced_global (void);
-  int is_forced_global (void);
+  int is_forced_global (void) const;
 
   void alias (symbol_record *s, int force = 0);
 
-  symbol_record *next (void);
+  symbol_record *next (void) const;
 
 private:
 
   char *nm;
   int formal_param;
   int forced_global;
   symbol_def *var;
   symbol_def *fcn;
@@ -187,44 +187,44 @@ private:
  */
 class
 symbol_table
 {
 public:
 
   symbol_table (void);
 
-  symbol_record *lookup (char *nm, int insert = 0, int warn = 0);
+  symbol_record *lookup (const char *nm, int insert = 0, int warn = 0);
 
   void clear (void);
-  int clear (char *nm);
+  int clear (const char *nm);
   void undefine (void);
 
   void bind_globals (void);
 
   int save (ostream& os, int mark_as_global = 0);
-  int save (ostream& os, char *name, int mark_as_global = 0);
+  int save (ostream& os, const char *name, int mark_as_global = 0);
 
-  int size (void);
+  int size (void) const;
 
-  char **list (void);
-  char **var_list (void);
-  char **fcn_list (void);
+  char **list (void) const;
+  char **var_list (void) const;
+  char **fcn_list (void) const;
 
-  char **list (int& count);
-  char **var_list (int& count);
-  char **fcn_list (int& count);
+  char **list (int& count) const;
+  char **var_list (int& count) const;
+  char **fcn_list (int& count) const;
 
-  char **sorted_list (void);
-  char **sorted_var_list (void);
-  char **sorted_fcn_list (void);
+  char **sorted_list (void) const;
+  char **sorted_var_list (void) const;
+  char **sorted_fcn_list (void) const;
 
-  char **sorted_list (int& count);
-  char **sorted_var_list (int& count);
-  char **sorted_fcn_list (int& count);
+  char **sorted_list (int& count) const;
+  char **sorted_var_list (int& count) const;
+  char **sorted_fcn_list (int& count) const;
 
 private:
 
   unsigned int hash (const char *s);
 
   symbol_record table[HASH_TABLE_SIZE];
 };
 
diff --git a/src/tc-assign.cc b/src/tc-assign.cc
--- a/src/tc-assign.cc
+++ b/src/tc-assign.cc
@@ -20,21 +20,22 @@ along with Octave; see the file COPYING.
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
 #ifdef __GNUG__
 #pragma implementation
 #endif
 
+#include "idx-vector.h"
 #include "user-prefs.h"
-#include "error.h"
+#include "tree-const.h"
+#include "utils.h"
 #include "gripes.h"
-#include "utils.h"
-#include "tree-const.h"
+#include "error.h"
 
 #include "tc-inlines.cc"
 
 void
 tree_constant_rep::assign (tree_constant& rhs, tree_constant *args, int nargs)
 {
   tree_constant rhs_tmp = rhs.make_numeric ();
 
@@ -367,17 +368,17 @@ tree_constant_rep::vector_assignment (tr
     default:
       panic_impossible ();
       break;
     }
 }
 
 void
 tree_constant_rep::check_vector_assign (int rhs_nr, int rhs_nc,
-					int ilen, char *rm)
+					int ilen, const char *rm)
 {
   int nr = rows ();
   int nc = columns ();
 
   if (nr == 1 && nc == 1)  // No orientation to preserve
     {
       if (! ( ilen == rhs_nr || ilen == rhs_nc))
 	error ("A(%s) = X: X and %s must have the same number of\
@@ -432,16 +433,18 @@ tree_constant_rep::do_vector_assign (tre
 
 void
 tree_constant_rep::do_vector_assign (tree_constant& rhs, idx_vector& iv)
 {
   REP_RHS_MATRIX (rhs, rhs_m, rhs_cm, rhs_nr, rhs_nc);
 
   int ilen = iv.capacity ();
   check_vector_assign (rhs_nr, rhs_nc, ilen, "matrix");
+  if (error_state)
+    return;
 
   force_orient f_orient = no_orient;
   if (rhs_nr == 1 && rhs_nc != 1)
     f_orient = row_orient;
   else if (rhs_nc == 1 && rhs_nr != 1)
     f_orient = column_orient;
 
   maybe_resize (iv.max (), f_orient);
@@ -467,16 +470,18 @@ tree_constant_rep::do_vector_assign (tre
 
 void
 tree_constant_rep::do_vector_assign (tree_constant& rhs, Range& ri, int imax)
 {
   REP_RHS_MATRIX (rhs, rhs_m, rhs_cm, rhs_nr, rhs_nc);
 
   int ilen = ri.nelem ();
   check_vector_assign (rhs_nr, rhs_nc, ilen, "range");
+  if (error_state)
+    return;
 
   force_orient f_orient = no_orient;
   if (rhs_nr == 1 && rhs_nc != 1)
     f_orient = row_orient;
   else if (rhs_nc == 1 && rhs_nr != 1)
     f_orient = column_orient;
 
   maybe_resize (imax, f_orient);
diff --git a/src/tc-extras.cc b/src/tc-extras.cc
--- a/src/tc-extras.cc
+++ b/src/tc-extras.cc
@@ -84,17 +84,18 @@ min (const Matrix& a, const Matrix& b)
 	double b_elem = b.elem (i, j);
 	result.elem (i, j) = MIN (a_elem, b_elem);
       }
 
   return result;
 }
 
 static void
-get_dimensions (tree_constant& a, char *warn_for, int& nr, int& nc)
+get_dimensions (const tree_constant& a, const char *warn_for,
+		int& nr, int& nc)
 {
   tree_constant tmpa = a.make_numeric ();
 
   if (tmpa.is_scalar_type ())
     {
       double tmp = tmpa.double_value ();
       nr = nc = NINT (tmp);
     }
@@ -103,63 +104,64 @@ get_dimensions (tree_constant& a, char *
       nr = a.rows ();
       nc = a.columns ();
     }
 
   check_dimensions (nr, nc, warn_for); // May set error_state.
 }
 
 static void
-get_dimensions (tree_constant& a, tree_constant& b, char *warn_for,
-		int& nr, int& nc)
+get_dimensions (const tree_constant& a, const tree_constant& b,
+		const char *warn_for, int& nr, int& nc)
 {
   tree_constant tmpa = a.make_numeric ();
   tree_constant tmpb = b.make_numeric ();
 
   if (tmpa.is_scalar_type () && tmpb.is_scalar_type ())
     {
       nr = NINT (tmpa.double_value ());
       nc = NINT (tmpb.double_value ());
 
       check_dimensions (nr, nc, warn_for); // May set error_state.
     }
   else
     error ("%s: expecting two scalar arguments", warn_for);
 }
 
 tree_constant
-fill_matrix (tree_constant& a, double val, char *warn_for)
+fill_matrix (const tree_constant& a, double val, const char *warn_for)
 {
   int nr, nc;
   get_dimensions (a, warn_for, nr, nc);
 
   if (error_state)
     return  tree_constant ();
 
   Matrix m (nr, nc, val);
 
   return tree_constant (m);
 }
 
 tree_constant
-fill_matrix (tree_constant& a, tree_constant& b, double val, char *warn_for)
+fill_matrix (const tree_constant& a, const tree_constant& b,
+	     double val, const char *warn_for)
 {
   int nr, nc;
   get_dimensions (a, b, warn_for, nr, nc); // May set error_state.
 
   if (error_state)
     return tree_constant ();
 
   Matrix m (nr, nc, val);
 
   return tree_constant (m);
 }
 
 tree_constant
-identity_matrix (tree_constant& a)
+identity_matrix (const tree_constant& a)
 {
   int nr, nc;
   get_dimensions (a, "eye", nr, nc); // May set error_state.
 
   if (error_state)
     return tree_constant ();
 
   Matrix m (nr, nc, 0.0);
@@ -170,17 +172,17 @@ identity_matrix (tree_constant& a)
       for (int i = 0; i < n; i++)
 	m.elem (i, i) = 1.0;
     }
 
   return tree_constant (m);
 }
 
 tree_constant
-identity_matrix (tree_constant& a, tree_constant& b)
+identity_matrix (const tree_constant& a, const tree_constant& b)
 {
   int nr, nc;
   get_dimensions (a, b, "eye", nr, nc);  // May set error_state.
 
   if (error_state)
     return tree_constant ();
 
   Matrix m (nr, nc, 0.0);
@@ -284,17 +286,17 @@ find_nonzero_elem_idx (const ComplexMatr
 		count++;
 	      }
 	}
       return tree_constant (v, 1);  // Always make a column vector.
     }
 }
 
 tree_constant
-find_nonzero_elem_idx (tree_constant& a)
+find_nonzero_elem_idx (const tree_constant& a)
 {
   tree_constant retval;
 
   tree_constant tmp = a.make_numeric ();
 
   Matrix result;
     
   switch (tmp.const_type ())
@@ -334,17 +336,17 @@ find_nonzero_elem_idx (tree_constant& a)
     }
   return retval;
 }
 
 // XXX FIXME XXX -- the next two functions (and expm) should really be just
 // one...
 
 tree_constant *
-matrix_log (tree_constant& a)
+matrix_log (const tree_constant& a)
 {
   tree_constant *retval = new tree_constant [2];
 
   tree_constant tmp = a.make_numeric ();;
     
   if (tmp.rows () == 0 || tmp.columns () == 0)
     {
       int flag = user_pref.propagate_empty_matrices;
@@ -445,17 +447,17 @@ matrix_log (tree_constant& a)
       break;
     default:
       break;
     }
   return retval;
 }
 
 tree_constant *
-matrix_sqrt (tree_constant& a)
+matrix_sqrt (const tree_constant& a)
 {
   tree_constant *retval = new tree_constant [2];
 
   tree_constant tmp = a.make_numeric ();;
     
   if (tmp.rows () == 0 || tmp.columns () == 0)
     {
       int flag = user_pref.propagate_empty_matrices;
@@ -556,17 +558,17 @@ matrix_sqrt (tree_constant& a)
       break;
     default:
       break;
     }
   return retval;
 }
 
 tree_constant *
-column_max (tree_constant *args, int nargin, int nargout)
+column_max (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
 
   tree_constant arg1;
   tree_constant arg2;
   tree_constant_rep::constant_type arg1_type =
     tree_constant_rep::unknown_constant;
   tree_constant_rep::constant_type arg2_type =
@@ -629,17 +631,17 @@ column_max (tree_constant *args, int nar
     }
   else
     panic_impossible ();
 
   return retval;
 }
 
 tree_constant *
-column_min (tree_constant *args, int nargin, int nargout)
+column_min (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
 
   tree_constant arg1;
   tree_constant arg2;
   tree_constant_rep::constant_type arg1_type =
     tree_constant_rep::unknown_constant;
   tree_constant_rep::constant_type arg2_type =
@@ -836,17 +838,17 @@ mx_sort (ComplexRowVector& cv, RowVector
 	      double tmp = idx.elem (k);
 	      idx.elem (k) = idx.elem (k+gap);
 	      idx.elem (k+gap) = tmp;
 	    }
 	}
 }
 
 tree_constant *
-sort (tree_constant *args, int nargin, int nargout)
+sort (const tree_constant *args, int nargin, int nargout)
 {
 // Assumes that we have been given the correct number of arguments.
 
   tree_constant *retval = NULL_TREE_CONST;
 
   int return_idx = nargout > 1;
   if (return_idx)
     retval = new tree_constant [3];
@@ -931,17 +933,17 @@ sort (tree_constant *args, int nargin, i
       panic_impossible ();
       break;
     }
 
   return retval;
 }
 
 tree_constant *
-feval (tree_constant *args, int nargin, int nargout)
+feval (const tree_constant *args, int nargin, int nargout)
 {
 // Assumes that we have been given the correct number of arguments.
 
   tree_constant *retval = NULL_TREE_CONST;
 
   tree *fcn = is_valid_function (args[1], "feval", 1);
   if (fcn != NULL_TREE)
     {
@@ -952,17 +954,17 @@ feval (tree_constant *args, int nargin, 
       else
 	retval = fcn->eval (0, nargout);
     }
 
   return retval;
 }
 
 tree_constant
-eval_string (char *string, int print, int ans_assign,
+eval_string (const char *string, int print, int ans_assign,
 	     int& parse_status)
 {
   begin_unwind_frame ("eval_string");
 
   unwind_protect_int (get_input_from_eval_string);
   unwind_protect_ptr (global_command);
   unwind_protect_ptr (current_eval_string);
 
@@ -999,49 +1001,50 @@ eval_string (char *string, int print, in
       retval = command->eval (print);
       delete command;
     }
 
   return retval;
 }
 
 tree_constant
-eval_string (tree_constant& arg, int& parse_status)
+eval_string (const tree_constant& arg, int& parse_status)
 {
   if (! arg.is_string_type ())
     {
       error ("eval: expecting string argument");
       return -1;
     }
 
   char *string = arg.string_value ();
 
 // Yes Virginia, we always print here...
 
   return eval_string (string, 1, 1, parse_status);
 }
 
 static int
-match_sans_spaces (char *standard, char *test)
+match_sans_spaces (const char *standard, const char *test)
 {
-  char *tp = test;
+  const char *tp = test;
   while (*tp == ' ' || *tp == '\t')
     tp++;
 
-  char *ep = test + strlen (test) - 1;
+  const char *ep = test + strlen (test) - 1;
   while (*ep == ' ' || *ep == '\t')
     ep--;
 
   int len = ep - tp + 1;
 
   return (strncmp (standard, tp, len) == 0);
 }
 
 tree_constant
-get_user_input (tree_constant *args, int nargin, int nargout, int debug = 0)
+get_user_input (const tree_constant *args, int nargin, int nargout,
+		int debug = 0)
 {
   tree_constant retval;
 
   int read_as_string = 0;
   if (nargin == 3)
     {
       if (args[2].is_string_type ()
 	  && strcmp ("s", args[2].string_value ()) == 0)
diff --git a/src/tc-index.cc b/src/tc-index.cc
--- a/src/tc-index.cc
+++ b/src/tc-index.cc
@@ -20,37 +20,39 @@ along with Octave; see the file COPYING.
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
 #ifdef __GNUG__
 #pragma implementation
 #endif
 
+#include "idx-vector.h"
 #include "user-prefs.h"
-#include "error.h"
+#include "tree-const.h"
+#include "utils.h"
 #include "gripes.h"
-#include "utils.h"
-#include "tree-const.h"
+#include "error.h"
 
 #include "tc-inlines.cc"
 
 int
-tree_constant_rep::valid_as_scalar_index (void)
+tree_constant_rep::valid_as_scalar_index (void) const
 {
   int valid = type_tag == magic_colon
     || (type_tag == scalar_constant && NINT (scalar) == 1)
     || (type_tag == range_constant
 	&& range->nelem () == 1 && NINT (range->base ()) == 1);
 
   return valid;
 }
 
 tree_constant
-tree_constant_rep::do_scalar_index (tree_constant *args, int nargs) 
+tree_constant_rep::do_scalar_index (const tree_constant *args,
+				    int nargs) const
 {
   if (valid_scalar_indices (args, nargs))
     {
       if (type_tag == scalar_constant)
 	return tree_constant (scalar);
       else if (type_tag == complex_scalar_constant)
 	return tree_constant (*complex_scalar);
       else
@@ -136,17 +138,18 @@ tree_constant_rep::do_scalar_index (tree
 	}
     }
 
   error ("index invalid or out of range for scalar type");
   return tree_constant ();
 }
 
 tree_constant
-tree_constant_rep::do_matrix_index (tree_constant *args, int nargin)
+tree_constant_rep::do_matrix_index (const tree_constant *args,
+				    int nargin) const
 {
   tree_constant retval;
 
   switch (nargin)
     {
     case 2:
       if (args == NULL_TREE_CONST)
 	error ("matrix index is null");
@@ -169,17 +172,17 @@ tree_constant_rep::do_matrix_index (tree
       error ("too many indices for matrix expression");
       break;
     }
 
   return  retval;
 }
 
 tree_constant
-tree_constant_rep::do_matrix_index (tree_constant& i_arg)
+tree_constant_rep::do_matrix_index (const tree_constant& i_arg) const
 {
   tree_constant retval;
 
   int nr = rows ();
   int nc = columns ();
 
   if (user_pref.do_fortran_indexing)
     retval = fortran_style_matrix_index (i_arg);
@@ -187,17 +190,18 @@ tree_constant_rep::do_matrix_index (tree
     retval = do_vector_index (i_arg);
   else
     error ("single index only valid for row or column vector");
 
   return retval;
 }
 
 tree_constant
-tree_constant_rep::fortran_style_matrix_index (tree_constant& i_arg)
+tree_constant_rep::fortran_style_matrix_index
+  (const tree_constant& i_arg) const
 {
   tree_constant retval;
 
   tree_constant tmp_i = i_arg.make_numeric_or_magic ();
 
   tree_constant_rep::constant_type itype = tmp_i.const_type ();
 
   int nr = rows ();
@@ -247,17 +251,17 @@ tree_constant_rep::fortran_style_matrix_
       panic_impossible ();
       break;
     }
 
   return retval;
 }
 
 tree_constant
-tree_constant_rep::fortran_style_matrix_index (Matrix& mi)
+tree_constant_rep::fortran_style_matrix_index (const Matrix& mi) const
 {
   assert (is_matrix_type ());
 
   tree_constant retval;
 
   int nr = rows ();
   int nc = columns ();
 
@@ -332,17 +336,17 @@ tree_constant_rep::fortran_style_matrix_
 	error ("invalid matrix index");
       return tree_constant ();
     }
 
   return retval;
 }
 
 tree_constant
-tree_constant_rep::do_vector_index (tree_constant& i_arg)
+tree_constant_rep::do_vector_index (const tree_constant& i_arg) const
 {
   tree_constant retval;
 
   tree_constant tmp_i = i_arg.make_numeric_or_range_or_magic ();
 
   tree_constant_rep::constant_type itype = tmp_i.const_type ();
 
   int nr = rows ();
@@ -447,17 +451,18 @@ tree_constant_rep::do_vector_index (tree
       panic_impossible ();
       break;
     }
 
   return retval;
 }
 
 tree_constant
-tree_constant_rep::do_matrix_index (tree_constant& i_arg, tree_constant& j_arg)
+tree_constant_rep::do_matrix_index (const tree_constant& i_arg,
+				    const tree_constant& j_arg) const
 {
   tree_constant retval;
 
   tree_constant tmp_i = i_arg.make_numeric_or_range_or_magic ();
 
   tree_constant_rep::constant_type itype = tmp_i.const_type ();
 
   switch (itype)
@@ -511,17 +516,17 @@ tree_constant_rep::do_matrix_index (tree
       panic_impossible ();
       break;
     }
 
   return retval;
 }
 
 tree_constant
-tree_constant_rep::do_matrix_index (int i, tree_constant& j_arg)
+tree_constant_rep::do_matrix_index (int i, const tree_constant& j_arg) const
 {
   tree_constant retval;
 
   tree_constant tmp_j = j_arg.make_numeric_or_range_or_magic ();
 
   tree_constant_rep::constant_type jtype = tmp_j.const_type ();
 
   int nr = rows ();
@@ -588,17 +593,18 @@ tree_constant_rep::do_matrix_index (int 
       panic_impossible ();
       break;
     }
 
   return retval;
 }
 
 tree_constant
-tree_constant_rep::do_matrix_index (idx_vector& iv, tree_constant& j_arg)
+tree_constant_rep::do_matrix_index (const idx_vector& iv,
+				    const tree_constant& j_arg) const
 {
   tree_constant retval;
 
   tree_constant tmp_j = j_arg.make_numeric_or_range_or_magic ();
 
   tree_constant_rep::constant_type jtype = tmp_j.const_type ();
 
   int nr = rows ();
@@ -665,17 +671,18 @@ tree_constant_rep::do_matrix_index (idx_
       panic_impossible ();
       break;
     }
 
   return retval;
 }
 
 tree_constant
-tree_constant_rep::do_matrix_index (Range& ri, int imax, tree_constant& j_arg)
+tree_constant_rep::do_matrix_index (const Range& ri, int imax,
+				    const tree_constant& j_arg) const
 {
   tree_constant retval;
 
   tree_constant tmp_j = j_arg.make_numeric_or_range_or_magic ();
 
   tree_constant_rep::constant_type jtype = tmp_j.const_type ();
 
   int nr = rows ();
@@ -741,17 +748,17 @@ tree_constant_rep::do_matrix_index (Rang
       break;
     }
 
   return retval;
 }
 
 tree_constant
 tree_constant_rep::do_matrix_index (tree_constant_rep::constant_type mci,
-				    tree_constant& j_arg)
+				    const tree_constant& j_arg) const
 {
   tree_constant retval;
 
   tree_constant tmp_j = j_arg.make_numeric_or_range_or_magic ();
 
   tree_constant_rep::constant_type jtype = tmp_j.const_type ();
 
   int nr = rows ();
@@ -816,30 +823,30 @@ tree_constant_rep::do_matrix_index (tree
       panic_impossible ();
       break;
     }
 
   return retval;
 }
 
 tree_constant
-tree_constant_rep::do_matrix_index (int i, int j)
+tree_constant_rep::do_matrix_index (int i, int j) const
 {
   tree_constant retval;
 
   if (type_tag == matrix_constant)
     retval = tree_constant (matrix->elem (i, j));
   else
     retval = tree_constant (complex_matrix->elem (i, j));
 
   return retval;
 }
 
 tree_constant
-tree_constant_rep::do_matrix_index (int i, idx_vector& jv)
+tree_constant_rep::do_matrix_index (int i, const idx_vector& jv) const
 {
   tree_constant retval;
 
   int jlen = jv.capacity ();
 
   CRMATRIX (m, cm, 1, jlen);
 
   for (int j = 0; j < jlen; j++)
@@ -848,17 +855,17 @@ tree_constant_rep::do_matrix_index (int 
       CRMATRIX_ASSIGN_REP_ELEM (m, cm, 0, j, i, col);
     }
   ASSIGN_CRMATRIX_TO (retval, m, cm);
 
   return retval;
 }
 
 tree_constant
-tree_constant_rep::do_matrix_index (int i, Range& rj)
+tree_constant_rep::do_matrix_index (int i, const Range& rj) const
 {
   tree_constant retval;
 
   int jlen = rj.nelem ();
 
   CRMATRIX (m, cm, 1, jlen);
 
   double b = rj.base ();
@@ -871,18 +878,18 @@ tree_constant_rep::do_matrix_index (int 
     }
 
   ASSIGN_CRMATRIX_TO (retval, m, cm);
 
   return retval;
 }
 
 tree_constant
-tree_constant_rep::do_matrix_index (int i,
-				    tree_constant_rep::constant_type mcj)
+tree_constant_rep::do_matrix_index
+  (int i, tree_constant_rep::constant_type mcj) const
 {
   assert (mcj == magic_colon);
 
   tree_constant retval;
 
   int nc = columns ();
 
   CRMATRIX (m, cm, 1, nc);
@@ -893,17 +900,17 @@ tree_constant_rep::do_matrix_index (int 
     }
 
   ASSIGN_CRMATRIX_TO (retval, m, cm);
 
   return retval;
 }
 
 tree_constant
-tree_constant_rep::do_matrix_index (idx_vector& iv, int j)
+tree_constant_rep::do_matrix_index (const idx_vector& iv, int j) const
 {
   tree_constant retval;
 
   int ilen = iv.capacity ();
 
   CRMATRIX (m, cm, ilen, 1);
 
   for (int i = 0; i < ilen; i++)
@@ -913,17 +920,18 @@ tree_constant_rep::do_matrix_index (idx_
     }
 
   ASSIGN_CRMATRIX_TO (retval, m, cm);
 
   return retval;
 }
 
 tree_constant
-tree_constant_rep::do_matrix_index (idx_vector& iv, idx_vector& jv)
+tree_constant_rep::do_matrix_index (const idx_vector& iv,
+				    const idx_vector& jv) const
 {
   tree_constant retval;
 
   int ilen = iv.capacity ();
   int jlen = jv.capacity ();
 
   CRMATRIX (m, cm, ilen, jlen);
 
@@ -938,17 +946,18 @@ tree_constant_rep::do_matrix_index (idx_
     }
 
   ASSIGN_CRMATRIX_TO (retval, m, cm);
 
   return retval;
 }
 
 tree_constant
-tree_constant_rep::do_matrix_index (idx_vector& iv, Range& rj)
+tree_constant_rep::do_matrix_index (const idx_vector& iv,
+				    const Range& rj) const
 {
   tree_constant retval;
 
   int ilen = iv.capacity ();
   int jlen = rj.nelem ();
 
   CRMATRIX (m, cm, ilen, jlen);
 
@@ -967,18 +976,18 @@ tree_constant_rep::do_matrix_index (idx_
     }
 
   ASSIGN_CRMATRIX_TO (retval, m, cm);
 
   return retval;
 }
 
 tree_constant
-tree_constant_rep::do_matrix_index (idx_vector& iv,
-				    tree_constant_rep::constant_type mcj)
+tree_constant_rep::do_matrix_index
+  (const idx_vector& iv, tree_constant_rep::constant_type mcj) const
 {
   assert (mcj == magic_colon);
 
   tree_constant retval;
 
   int nc = columns ();
   int ilen = iv.capacity ();
 
@@ -994,17 +1003,17 @@ tree_constant_rep::do_matrix_index (idx_
     }
 
   ASSIGN_CRMATRIX_TO (retval, m, cm);
 
   return retval;
 }
 
 tree_constant
-tree_constant_rep::do_matrix_index (Range& ri, int j)
+tree_constant_rep::do_matrix_index (const Range& ri, int j) const
 {
   tree_constant retval;
 
   int ilen = ri.nelem ();
 
   CRMATRIX (m, cm, ilen, 1);
 
   double b = ri.base ();
@@ -1017,17 +1026,18 @@ tree_constant_rep::do_matrix_index (Rang
     }
 
   ASSIGN_CRMATRIX_TO (retval, m, cm);
 
   return retval;
 }
 
 tree_constant
-tree_constant_rep::do_matrix_index (Range& ri, idx_vector& jv)
+tree_constant_rep::do_matrix_index (const Range& ri,
+				    const idx_vector& jv) const
 {
   tree_constant retval;
 
   int ilen = ri.nelem ();
   int jlen = jv.capacity ();
 
   CRMATRIX (m, cm, ilen, jlen);
 
@@ -1045,17 +1055,17 @@ tree_constant_rep::do_matrix_index (Rang
     }
 
   ASSIGN_CRMATRIX_TO (retval, m, cm);
 
   return retval;
 }
 
 tree_constant
-tree_constant_rep::do_matrix_index (Range& ri, Range& rj)
+tree_constant_rep::do_matrix_index (const Range& ri, const Range& rj) const
 {
   tree_constant retval;
 
   int ilen = ri.nelem ();
   int jlen = rj.nelem ();
 
   CRMATRIX (m, cm, ilen, jlen);
 
@@ -1078,18 +1088,18 @@ tree_constant_rep::do_matrix_index (Rang
     }
 
   ASSIGN_CRMATRIX_TO (retval, m, cm);
 
   return retval;
 }
 
 tree_constant
-tree_constant_rep::do_matrix_index (Range& ri,
-				    tree_constant_rep::constant_type mcj)
+tree_constant_rep::do_matrix_index
+  (const Range& ri, tree_constant_rep::constant_type mcj) const
 {
   assert (mcj == magic_colon);
 
   tree_constant retval;
 
   int nc = columns ();
 
   int ilen = ri.nelem ();
@@ -1111,17 +1121,17 @@ tree_constant_rep::do_matrix_index (Rang
 
   ASSIGN_CRMATRIX_TO (retval, m, cm);
 
   return retval;
 }
 
 tree_constant
 tree_constant_rep::do_matrix_index (tree_constant_rep::constant_type mci,
-				    int j)
+				    int j) const
 {
   assert (mci == magic_colon);
 
   tree_constant retval;
 
   int nr = rows ();
 
   CRMATRIX (m, cm, nr, 1);
@@ -1133,17 +1143,17 @@ tree_constant_rep::do_matrix_index (tree
 
   ASSIGN_CRMATRIX_TO (retval, m, cm);
 
   return retval;
 }
 
 tree_constant
 tree_constant_rep::do_matrix_index (tree_constant_rep::constant_type mci,
-				    idx_vector& jv)
+				    const idx_vector& jv) const
 {
   assert (mci == magic_colon);
 
   tree_constant retval;
 
   int nr = rows ();
   int jlen = jv.capacity ();
 
@@ -1160,17 +1170,17 @@ tree_constant_rep::do_matrix_index (tree
 
   ASSIGN_CRMATRIX_TO (retval, m, cm);
 
   return retval;
 }
 
 tree_constant
 tree_constant_rep::do_matrix_index (tree_constant_rep::constant_type mci,
-				    Range& rj)
+				    const Range& rj) const
 {
   assert (mci == magic_colon);
 
   tree_constant retval;
 
   int nr = rows ();
   int jlen = rj.nelem ();
 
@@ -1191,25 +1201,26 @@ tree_constant_rep::do_matrix_index (tree
 
   ASSIGN_CRMATRIX_TO (retval, m, cm);
 
   return retval;
 }
 
 tree_constant
 tree_constant_rep::do_matrix_index (tree_constant_rep::constant_type mci,
-				    tree_constant_rep::constant_type mcj)
+				    tree_constant_rep::constant_type mcj) const
 {
   assert (mci == magic_colon && mcj == magic_colon);
 
   return tree_constant (*this);
 }
 
 tree_constant
-tree_constant_rep::do_matrix_index (tree_constant_rep::constant_type mci)
+tree_constant_rep::do_matrix_index
+  (tree_constant_rep::constant_type mci) const
 {
   assert (mci == magic_colon);
 
   tree_constant retval;
   int nr =  rows ();
   int nc =  columns ();
   int size = nr * nc;
   if (size > 0)
diff --git a/src/tc-inlines.h b/src/tc-inlines.h
--- a/src/tc-inlines.h
+++ b/src/tc-inlines.h
@@ -138,17 +138,17 @@ fortran_column (int i, int nr)
   int c;
   int r;
   r = fortran_row (i, nr);
   c = (i - r) / nr + 1;
   return c;
 }
 
 static inline int
-valid_scalar_indices (tree_constant *args, int nargs)
+valid_scalar_indices (const tree_constant *args, int nargs)
 {
   int valid = args != NULL_TREE_CONST
     && ((nargs == 3 && args[2].valid_as_scalar_index ()
 	 && args[1].valid_as_scalar_index ())
 	|| (nargs == 2 && args[1].valid_as_scalar_index ()));
 
   return valid;
 }
diff --git a/src/tree.h.old b/src/tree.h.old
--- a/src/tree.h.old
+++ b/src/tree.h.old
@@ -41,17 +41,17 @@ class ostrstream;
 
 class symbol_record;
 class symbol_table;
 
 #ifndef TREE_FCN_TYPEDEFS
 #define TREE_FCN_TYPEDEFS 1
 
 typedef tree_constant (*Text_fcn)(int, char **);
-typedef tree_constant* (*General_fcn)(tree_constant *, int, int);
+typedef tree_constant* (*General_fcn)(const tree_constant *, int, int);
 
 #endif
 
 #ifndef NULL_TREE
 #define NULL_TREE (tree *) NULL
 #endif
 
 #ifndef NULL_TREE_CONST
@@ -135,25 +135,26 @@ tree_builtin : public tree
 public:
   tree_builtin (void);
   tree_builtin (int i_max, int o_max, Mapper_fcn& m_fcn, symbol_record *s);
   tree_builtin (int i_max, int o_max, Text_fcn t_fcn, symbol_record *s);
   tree_builtin (int i_max, int o_max, General_fcn t_fcn, symbol_record *s);
 
   ~tree_builtin (void);
 
-  int is_builtin (void);
+  int is_builtin (void) const;
 
   tree_constant eval (int print);
 
   tree_constant *eval (int print, int nargout);
 
   tree_constant eval (int argc, char **argv, int print);
 
-  tree_constant *eval (tree_constant *args, int n_in, int n_out, int print);
+  tree_constant *eval (const tree_constant *args, int n_in, int n_out,
+		       int print);
 
   tree *def (void);
   char *name (void);
 
   int max_expected_args (void);
 
 private:
   int nargin_max;
@@ -175,17 +176,17 @@ tree_identifier : public tree
   friend class tree_index_expression;
 
 public:
   tree_identifier (int l = -1, int c = -1);
   tree_identifier (symbol_record *s, int l = -1, int c = -1);
 
   ~tree_identifier (void);
 
-  int is_identifier (void);
+  int is_identifier (void) const;
 
   tree *def (void);
   char *name (void);
   symbol_record *symrec (void);
 
   tree_identifier *define (tree_constant *t);
   tree_identifier *define (tree_function *t);
 
@@ -205,17 +206,18 @@ public:
   void mark_as_formal_parameter (void);
 
   tree_constant eval (int print);
 
   tree_constant *eval (int print, int nargout);
 
   tree_constant eval (int argc, char **argv, int print);
   
-  tree_constant *eval (tree_constant *args, int n_in, int n_out, int print);
+  tree_constant *eval (const tree_constant *args, int n_in, int n_out,
+		       int print);
 
   void eval_undefined_error (void);
 
 private:
   symbol_record *sym;
 };
 
 /*
@@ -244,17 +246,18 @@ public:
   char *function_name (void);
 
   tree_constant eval (int print);
 
   tree_constant *eval (int print, int nargout);
 
   tree_constant eval (int argc, char **argv, int print);
 
-  tree_constant *eval (tree_constant *args, int n_in, int n_out, int print);
+  tree_constant *eval (const tree_constant *args, int n_in, int n_out,
+		       int print);
 
   int max_expected_args (void);
 
   void traceback_error (void);
 
 private:
   int call_depth;
   tree_parameter_list *param_list;
@@ -378,17 +381,17 @@ public:
   int in_parens;
 
   tree_assignment_expression (void);
 
   ~tree_assignment_expression (void);
 
   tree_constant eval (int print);
 
-  int is_assignment_expression (void);
+  int is_assignment_expression (void) const;
 };
 
 /*
  * Simple assignment expressions.
  */
 class
 tree_simple_assignment_expression : public tree_assignment_expression
 {
@@ -468,17 +471,17 @@ tree_index_expression : public tree_expr
  public:
   tree_index_expression (int l = -1, int c = -1);
   tree_index_expression (tree_identifier *i, int l = -1, int c = -1);
   tree_index_expression (tree_identifier *i, tree_argument_list *lst,
 			 int l = -1, int c = -1);
 
   ~tree_index_expression (void);
 
-  int is_index_expression (void);
+  int is_index_expression (void) const;
 
   tree_identifier *ident (void);
 
   tree_argument_list *arg_list (void);
 
   tree_constant eval (int print);
 
   tree_constant *eval (int print, int nargout);
diff --git a/src/unwind-prot.h b/src/unwind-prot.h
--- a/src/unwind-prot.h
+++ b/src/unwind-prot.h
@@ -23,18 +23,16 @@ Software Foundation, 675 Mass Ave, Cambr
 
 #if !defined (_unwind_prot_h)
 #define _unwind_prot_h 1
 
 #ifdef __GNUG__
 #pragma interface
 #endif
 
-#include <stddef.h>
-
 typedef void (*cleanup_func)(void *ptr);
 
 void add_unwind_protect (cleanup_func fptr, void *ptr);
 void run_unwind_protect (void);
 void discard_unwind_protect (void);
 void begin_unwind_frame (char *tag);
 void run_unwind_frame (char *tag);
 void discard_unwind_frame (char *tag);
diff --git a/src/utils.cc b/src/utils.cc
--- a/src/utils.cc
+++ b/src/utils.cc
@@ -178,17 +178,17 @@ discard_until (istream& stream, char cha
       if (c == EOF || c == character)
 	break;
     }
   if (c != EOF)
     stream.putback ((char) c);
 } 
 
 void
-check_dimensions (int& nr, int& nc, char *warnfor)
+check_dimensions (int& nr, int& nc, const char *warnfor)
 {
   if (nr < 0 || nc < 0)
     {
       if (user_pref.treat_neg_dim_as_zero)
 	nr = nc = 0;
       else
 	error ("%s: can't create a matrix with negative dimensions",
 	       warnfor);
@@ -451,17 +451,17 @@ default_pager (void)
 
   return pager_binary;
 }
 
 /*
  * See if the given file is in the path.
  */
 char *
-file_in_path (char *name, char *suffix)
+file_in_path (const char *name, const char *suffix)
 {
   char *nm = strconcat ("/", name);
   char *tmp = nm;
   if (suffix != (char *) NULL)
     {
       nm = strconcat (tmp, suffix);
       delete [] tmp;
     }
@@ -495,17 +495,17 @@ file_in_path (char *name, char *suffix)
   return (char *) NULL;
 }
 
 /*
  * See if there is an M-file in the path.  If so, return the full path
  * to the file.
  */
 char *
-m_file_in_path (char *name)
+m_file_in_path (const char *name)
 {
   return file_in_path (name, ".m");
 }
 
 /*
  * Return a pretty pathname.  If the first part of the pathname is the
  * same as $HOME, then replace that with `~'.
  */
@@ -524,17 +524,17 @@ polite_directory_format (char *name)
   else
     return name;
 }
 
 /*
  * Return 1 if STRING contains an absolute pathname, else 0.
  */
 int
-absolute_pathname (char *string)
+absolute_pathname (const char *string)
 {
   if (!string || !*string)
     return 0;
 
   if (*string == '/')
     return 1;
 
   if (*string++ == '.')
@@ -550,17 +550,17 @@ absolute_pathname (char *string)
 }
 
 /*
  * Return 1 if STRING is an absolute program name; it is absolute if
  * it contains any slashes.  This is used to decide whether or not to
  * look up through $PATH.
  */
 int
-absolute_program (char *string)
+absolute_program (const char *string)
 {
   return (strchr (string, '/') != (char *)NULL);
 }
 
 /*
  * Return the `basename' of the pathname in STRING (the stuff after
  * the last '/').  If STRING is not a full pathname, simply return it.
  */
@@ -578,17 +578,17 @@ base_pathname (char *string)
     return (string);
 }
 
 /*
  * Return the octal number parsed from STRING, or -1 to indicate that
  * the string contained a bad number.
  */
 int
-read_octal (char *string)
+read_octal (const char *string)
 {
   int result = 0;
   int digits = 0;
 
   while (*string && *string >= '0' && *string < '8')
     {
       digits++;
       result = (result * 8) + *string++ - '0';
@@ -641,17 +641,17 @@ sub_append_string (char *source, char *t
  *	\h	the hostname
  *	\#	the command number of this command
  *	\!	the history number of this command
  *	\$	a $ or a # if you are root
  *	\<octal> character code in octal
  *	\\	a backslash
  */
 char *
-decode_prompt_string (char *string)
+decode_prompt_string (const char *string)
 {
   int result_size = PROMPT_GROWTH;
   int result_index = 0;
   char *result = new char [PROMPT_GROWTH];
   int c;
   char *temp = (char *)NULL;
 
   result[0] = 0;
@@ -844,17 +844,17 @@ decode_prompt_string (char *string)
     }
 #endif
 
   return result;
 }
 
 /*
  * Remove the last N directories from PATH.  Do not PATH blank.
- * PATH must contain enoung space for MAXPATHLEN characters.
+ * PATH must contain enough space for MAXPATHLEN characters.
  */
 void
 pathname_backup (char *path, int n)
 {
   register char *p;
 
   if (!*path)
     return;
@@ -875,17 +875,17 @@ pathname_backup (char *path, int n)
 
 /*
  * Turn STRING (a pathname) into an absolute pathname, assuming that
  * DOT_PATH contains the symbolic location of '.'.  This always
  * returns a new string, even if STRING was an absolute pathname to
  * begin with.
  */
 char *
-make_absolute (char *string, char *dot_path)
+make_absolute (const char *string, const char *dot_path)
 {
   static char current_path[MAXPATHLEN];
   register char *cp;
 
   if (!dot_path || *string == '/')
     return strsave (string);
 
   strcpy (current_path, dot_path);
@@ -937,17 +937,17 @@ make_absolute (char *string, char *dot_p
   return strsave (current_path);
 }
 
 /*
  * Return a consed string which is the current working directory.
  * FOR_WHOM is the name of the caller for error printing.
  */ 
 char *
-get_working_directory (char *for_whom)
+get_working_directory (const char *for_whom)
 {
   if (!follow_symbolic_links)
     {
       if (the_current_working_directory)
 	delete [] the_current_working_directory;
 
       the_current_working_directory = (char *)NULL;
     }
@@ -970,17 +970,17 @@ get_working_directory (char *for_whom)
   return the_current_working_directory;
 }
 
 /*
  * Do the work of changing to the directory NEWDIR.  Handle symbolic
  * link following, etc.
  */ 
 int
-change_to_directory (char *newdir)
+change_to_directory (const char *newdir)
 {
   char *t;
 
   if (follow_symbolic_links)
     {
       if (!the_current_working_directory)
 	get_working_directory ("cd_links");
 
@@ -1026,17 +1026,17 @@ change_to_directory (char *newdir)
  *
  * case:
  *
  *   a newer than t         returns    1
  *   a older than t         returns    0
  *   stat on a fails        returns   -1
  */
 int
-is_newer (char *fa, time_t t)
+is_newer (const char *fa, time_t t)
 {
   struct stat fa_sb;
   register int fa_stat;
   register int status = 0;
 
   fa_stat = stat (fa, &fa_sb);
   if (fa_stat != 0)
     status = -1;
@@ -1183,28 +1183,28 @@ send_to_plot_stream (const char *cmd)
 void
 close_plot_stream (void)
 {
   if (plot_stream.is_open ())
     plot_stream.close ();
 }
 
 int
-almost_match (char *std, char *s, int min_match_len = 1)
+almost_match (const char *std, const char *s, int min_match_len = 1)
 {
   int stdlen = strlen (std);
   int slen = strlen (s);
 
   return (slen <= stdlen
 	  && slen >= min_match_len
 	  && strncmp (std, s, slen) == 0);
 }
 
 char **
-get_m_file_names (int& num, char *dir, int no_suffix)
+get_m_file_names (int& num, const char *dir, int no_suffix)
 {
   static int num_max = 256;
   char **retval = new char * [num_max];
   int i = 0;
 
   DIR *dirp = opendir (dir);
   if (dirp != (DIR *) NULL)
     {
diff --git a/src/utils.h b/src/utils.h
--- a/src/utils.h
+++ b/src/utils.h
@@ -32,47 +32,48 @@ Software Foundation, 675 Mass Ave, Cambr
 
 class istream;
 class ostrstream;
 class tree_constant;
 
 extern char *strsave (const char *);
 extern char *strconcat (const char *, const char *);
 extern void discard_until (istream&, char);
-extern void check_dimensions (int& nr, int& nc, char *warnfor);
+extern void check_dimensions (int& nr, int& nc, const char *warnfor);
 extern void raw_mode (int);
 extern int kbhit (void);
 extern char **pathstring_to_vector (char *);
 extern char *default_path (void);
 extern char *get_site_defaults (void);
 extern char *default_pager (void);
-extern char *file_in_path (char *, char *);
-extern char *m_file_in_path (char *);
-extern char *polite_directory_format (char *);
-extern int absolute_pathname (char *);
-extern int absolute_program (char *);
+extern char *file_in_path (const char *, const char *);
+extern char *m_file_in_path (const char *);
+extern char *polite_directory_format (const char *);
+extern int absolute_pathname (const char *);
+extern int absolute_program (const char *);
 extern char *base_pathname (char *);
-extern int read_octal (char *);
+extern int read_octal (const char *);
 extern char *sub_append_string (char *, char *, int *, int *);
-extern char *decode_prompt_string (char *);
+extern char *decode_prompt_string (const char *);
 extern void pathname_backup (char *, int);
-extern char *make_absolute (char *, char *);
-extern char *get_working_directory (char *);
-extern int change_to_directory (char *);
-extern int is_newer (char *, time_t);
+extern char *make_absolute (const char *, const char *);
+extern char *get_working_directory (const char *);
+extern int change_to_directory (const char *);
+extern int is_newer (const char *, time_t);
 extern void volatile jump_to_top_level (void);
 extern char *s_plural (int);
 extern char *es_plural (int);
-extern char *save_in_tmp_file (tree_constant& t, int nd = 2, int para = 0);
+extern char *save_in_tmp_file (tree_constant& t, int nd = 2, int para = 0); 
 extern void mark_for_deletion (const char *);
 extern void cleanup_tmp_files (void);
 extern int send_to_plot_stream (const char *cmd);
 extern void close_plot_stream (void);
-extern int almost_match (char *std, char *s, int min_match_len = 1);
-extern char **get_m_file_names (int& mfl_len, char *dir, int no_suffix);
+extern int almost_match (const char *std, const char *s,
+			 int min_match_len = 1); 
+extern char **get_m_file_names (int& mfl_len, const char *dir, int no_suffix);
 extern char **get_m_file_names (int& mfl_len, int no_suffix);
 extern int NINT (double x);
 extern double D_NINT (double x);
 
 #endif
 
 /*
 ;;; Local Variables: ***
diff --git a/src/variables.cc b/src/variables.cc
--- a/src/variables.cc
+++ b/src/variables.cc
@@ -34,16 +34,17 @@ Software Foundation, 675 Mass Ave, Cambr
 
 #include "statdefs.h"
 #include "tree-const.h"
 #include "variables.h"
 #include "symtab.h"
 #include "error.h"
 #include "utils.h"
 #include "tree.h"
+#include "help.h"
 
 // Symbol table for symbols at the top level.
 symbol_table *top_level_sym_tab;
 
 // Symbol table for the current scope.
 symbol_table *curr_sym_tab;
 
 // Symbol table for global symbols.
diff --git a/src/xdiv.cc b/src/xdiv.cc
--- a/src/xdiv.cc
+++ b/src/xdiv.cc
@@ -21,18 +21,22 @@ Software Foundation, 675 Mass Ave, Cambr
 
 */
 
 #ifdef __GNUG__
 #pragma implementation
 #endif
 
 #include <assert.h>
+#include <Complex.h>
+
+#include "xdiv.h"
+#include "Matrix.h"
+#include "tree-const.h"
 #include "error.h"
-#include "xdiv.h"
 
 static inline int
 result_ok (int info, double rcond, int warn = 1)
 {
   assert (info != -1);
 
   if (info == -2)
     {
@@ -75,17 +79,17 @@ mx_div_conform (int b_nr, int b_nc, int 
  *   matrix         | 1 |  3 |
  *                  +---+----+
  *   complex_matrix | 2 |  4 |
  *                  +---+----+
  */
 
 /* 1 */
 tree_constant
-xdiv (Matrix& a, Matrix& b)
+xdiv (const Matrix& a, const Matrix& b)
 {
   if (! mx_div_conform (b.rows (), b.columns (), a.columns ()))
     return tree_constant ();
 
   Matrix atmp = a.transpose ();
   Matrix btmp = b.transpose ();
 
   int info;
@@ -100,17 +104,17 @@ xdiv (Matrix& a, Matrix& b)
   int rank;
   Matrix result = btmp.lssolve (atmp, info, rank);
 
   return tree_constant (result.transpose ());
 }
 
 /* 2 */
 tree_constant
-xdiv (Matrix& a, ComplexMatrix& b)
+xdiv (const Matrix& a, const ComplexMatrix& b)
 {
   if (! mx_div_conform (b.rows (), b.columns (), a.columns ()))
     return tree_constant ();
 
   Matrix atmp = a.transpose ();
   ComplexMatrix btmp = b.hermitian ();
 
   int info;
@@ -125,17 +129,17 @@ xdiv (Matrix& a, ComplexMatrix& b)
   int rank;
   ComplexMatrix result = btmp.lssolve (atmp, info, rank);
 
   return tree_constant (result.hermitian ());
 }
 
 /* 3 */
 tree_constant
-xdiv (ComplexMatrix& a, Matrix& b)
+xdiv (const ComplexMatrix& a, const Matrix& b)
 {
   if (! mx_div_conform (b.rows (), b.columns (), a.columns ()))
     return tree_constant ();
 
   ComplexMatrix atmp = a.hermitian ();
   Matrix btmp = b.transpose ();
 
   int info;
@@ -150,17 +154,17 @@ xdiv (ComplexMatrix& a, Matrix& b)
   int rank;
   ComplexMatrix result = btmp.lssolve (atmp, info, rank);
 
   return tree_constant (result.hermitian ());
 }
 
 /* 4 */
 tree_constant
-xdiv (ComplexMatrix& a, ComplexMatrix& b)
+xdiv (const ComplexMatrix& a, const ComplexMatrix& b)
 {
   if (! mx_div_conform (b.rows (), b.columns (), a.columns ()))
     return tree_constant ();
 
   ComplexMatrix atmp = a.hermitian ();
   ComplexMatrix btmp = b.hermitian ();
 
   int info;
@@ -185,62 +189,62 @@ xdiv (ComplexMatrix& a, ComplexMatrix& b
  *            +--   +---+----+
  *   matrix         | 1 |  3 |
  *                  +---+----+
  *   complex_matrix | 2 |  4 |
  *                  +---+----+
  */
 
 tree_constant
-x_el_div (double a, Matrix& b)
+x_el_div (double a, const Matrix& b)
 {
   int nr = b.rows ();
   int nc = b.columns ();
 
   Matrix result (nr, nc);
 
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
       result.elem (i, j) = a / b.elem (i, j);
 
   return tree_constant (result);
 }
 
 tree_constant
-x_el_div (double a, ComplexMatrix& b)
+x_el_div (double a, const ComplexMatrix& b)
 {
   int nr = b.rows ();
   int nc = b.columns ();
 
   ComplexMatrix result (nr, nc);
 
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
       result.elem (i, j) = a / b.elem (i, j);
 
   return tree_constant (result);
 }
 
 tree_constant
-x_el_div (Complex a, Matrix& b)
+x_el_div (const Complex a, const Matrix& b)
 {
   int nr = b.rows ();
   int nc = b.columns ();
 
   ComplexMatrix result (nr, nc);
 
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
       result.elem (i, j) = a / b.elem (i, j);
 
   return tree_constant (result);
 }
 
 tree_constant
-x_el_div (Complex a, ComplexMatrix& b)
+x_el_div (const Complex a, const ComplexMatrix& b)
 {
   int nr = b.rows ();
   int nc = b.columns ();
 
   ComplexMatrix result (nr, nc);
 
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
@@ -257,17 +261,17 @@ x_el_div (Complex a, ComplexMatrix& b)
  *   matrix         | 1 |  3 |
  *                  +---+----+
  *   complex_matrix | 2 |  4 |
  *                  +---+----+
  */
 
 /* 1 */
 tree_constant
-xleftdiv (Matrix& a, Matrix& b)
+xleftdiv (const Matrix& a, const Matrix& b)
 {
   if (! mx_leftdiv_conform (a.rows (), a.columns (), b.rows ()))
     return tree_constant ();
 
   int info;
   if (a.rows () == a.columns ())
     {
       double rcond = 0.0;
@@ -279,17 +283,17 @@ xleftdiv (Matrix& a, Matrix& b)
   int rank;
   Matrix result = a.lssolve (b, info, rank);
 
   return tree_constant (result);
 }
 
 /* 2 */
 tree_constant
-xleftdiv (Matrix& a, ComplexMatrix& b)
+xleftdiv (const Matrix& a, const ComplexMatrix& b)
 {
   if (! mx_leftdiv_conform (a.rows (), a.columns (), b.rows ()))
     return tree_constant ();
 
   int info;
   if (a.rows () == a.columns ())
     {
       double rcond = 0.0;
@@ -301,17 +305,17 @@ xleftdiv (Matrix& a, ComplexMatrix& b)
   int rank;
   ComplexMatrix result = a.lssolve (b, info, rank);
 
   return tree_constant (result);
 }
 
 /* 3 */
 tree_constant
-xleftdiv (ComplexMatrix& a, Matrix& b)
+xleftdiv (const ComplexMatrix& a, const Matrix& b)
 {
   if (! mx_leftdiv_conform (a.rows (), a.columns (), b.rows ()))
     return tree_constant ();
 
   int info;
   if (a.rows () == a.columns ())
     {
       double rcond = 0.0;
@@ -323,17 +327,17 @@ xleftdiv (ComplexMatrix& a, Matrix& b)
   int rank;
   ComplexMatrix result = a.lssolve (b, info, rank);
 
   return tree_constant (result);
 }
 
 /* 4 */
 tree_constant
-xleftdiv (ComplexMatrix& a, ComplexMatrix& b)
+xleftdiv (const ComplexMatrix& a, const ComplexMatrix& b)
 {
   if (! mx_leftdiv_conform (a.rows (), a.columns (), b.rows ()))
     return tree_constant ();
 
   int info;
   if (a.rows () == a.columns ())
     {
       double rcond = 0.0;
diff --git a/src/xdiv.h b/src/xdiv.h
--- a/src/xdiv.h
+++ b/src/xdiv.h
@@ -23,36 +23,35 @@ Software Foundation, 675 Mass Ave, Cambr
 
 #if !defined (_xdiv_h)
 #define _xdiv_h 1
 
 #ifdef __GNUG__
 #pragma interface
 #endif
 
-#include <Complex.h>
+class Complex;
+class Matrix;
+class ComplexMatrix;
+class tree_constant;
 
-#include "Matrix.h"
-
-#include "tree-const.h"
+extern tree_constant xdiv (const Matrix& a, const Matrix& b);
+extern tree_constant xdiv (const Matrix& a, const ComplexMatrix& b);
+extern tree_constant xdiv (const ComplexMatrix& a, const Matrix& b);
+extern tree_constant xdiv (const ComplexMatrix& a, const ComplexMatrix& b);
 
-extern tree_constant xdiv (Matrix& a, Matrix& b);
-extern tree_constant xdiv (Matrix& a, ComplexMatrix& b);
-extern tree_constant xdiv (ComplexMatrix& a, Matrix& b);
-extern tree_constant xdiv (ComplexMatrix& a, ComplexMatrix& b);
+extern tree_constant x_el_div (double a, const Matrix& b);
+extern tree_constant x_el_div (double a, const ComplexMatrix& b);
+extern tree_constant x_el_div (const Complex a, const Matrix& b);
+extern tree_constant x_el_div (const Complex a, const ComplexMatrix& b);
 
-extern tree_constant x_el_div (double a, Matrix& b);
-extern tree_constant x_el_div (double a, ComplexMatrix& b);
-extern tree_constant x_el_div (Complex a, Matrix& b);
-extern tree_constant x_el_div (Complex a, ComplexMatrix& b);
-
-extern tree_constant xleftdiv (Matrix& a, Matrix& b);
-extern tree_constant xleftdiv (Matrix& a, ComplexMatrix& b);
-extern tree_constant xleftdiv (ComplexMatrix& a, Matrix& b);
-extern tree_constant xleftdiv (ComplexMatrix& a, ComplexMatrix& b);
+extern tree_constant xleftdiv (const Matrix& a, const Matrix& b);
+extern tree_constant xleftdiv (const Matrix& a, const ComplexMatrix& b);
+extern tree_constant xleftdiv (const ComplexMatrix& a, const Matrix& b);
+extern tree_constant xleftdiv (const ComplexMatrix& a, const ComplexMatrix& b);
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
 ;;; End: ***
diff --git a/src/xpow.cc b/src/xpow.cc
--- a/src/xpow.cc
+++ b/src/xpow.cc
@@ -21,18 +21,22 @@ Software Foundation, 675 Mass Ave, Cambr
 
 */
 
 #ifdef __GNUG__
 #pragma implementation
 #endif
 
 #include <assert.h>
+#include <Complex.h>
+
+#include "xpow.h"
+#include "Matrix.h"
+#include "tree-const.h"
 #include "error.h"
-#include "xpow.h"
 
 // This function also appears in tree-const.cc.  Maybe it should be a
 // member function of the Matrix class.
 
 static int
 any_element_is_negative (const Matrix& a)
 {
   int nr = a.rows ();
@@ -69,17 +73,17 @@ xpow (double a, double b)
       Complex atmp (a);
       return tree_constant (pow (atmp, b));
     }
   else
     return tree_constant (pow (a, b));
 }
 
 tree_constant
-xpow (double a, Matrix& b)
+xpow (double a, const Matrix& b)
 {
   tree_constant retval;
 
   int nr = b.rows ();
   int nc = b.columns ();
 
   if (nr == 0 || nc == 0 || nr != nc)
     error ("for x^A, A must be square");
@@ -102,26 +106,26 @@ xpow (double a, Matrix& b)
       ComplexMatrix result = Q * D * Q.inverse ();
       retval = tree_constant (result);
     }
 
   return retval;
 }
 
 tree_constant
-xpow (double a, Complex& b)
+xpow (double a, const Complex& b)
 {
   Complex result;
   Complex atmp (a);
   result = pow (atmp, b);
   return tree_constant (result);
 }
 
 tree_constant
-xpow (double a, ComplexMatrix& b)
+xpow (double a, const ComplexMatrix& b)
 {
   tree_constant retval;
 
   int nr = b.rows ();
   int nc = b.columns ();
 
   if (nr == 0 || nc == 0 || nr != nc)
     error ("for x^A, A must be square");
@@ -144,17 +148,17 @@ xpow (double a, ComplexMatrix& b)
       ComplexMatrix result = Q * D * Q.inverse ();
       retval = tree_constant (result);
     }
 
   return retval;
 }
 
 tree_constant
-xpow (Matrix& a, double b)
+xpow (const Matrix& a, double b)
 {
   tree_constant retval;
 
   int nr = a.rows ();
   int nc = a.columns ();
 
   if (nr == 0 || nc == 0 || nr != nc)
     {
@@ -204,17 +208,17 @@ xpow (Matrix& a, double b)
       ComplexMatrix result = Q * D * Q.inverse ();
       retval = tree_constant (result);
     }
 
   return retval;
 }
 
 tree_constant
-xpow (Matrix& a, Complex& b)
+xpow (const Matrix& a, const Complex& b)
 {
   int nr = a.rows ();
   int nc = a.columns ();
 
   if (nr == 0 || nc == 0 || nr != nc)
     {
       error ("for A^b, A must be square");
       return tree_constant ();
@@ -230,25 +234,25 @@ xpow (Matrix& a, Complex& b)
   ComplexDiagMatrix D (lambda);
 
   ComplexMatrix result = Q * D * Q.inverse ();
 
   return tree_constant (result);
 }
 
 tree_constant
-xpow (Complex& a, double b)
+xpow (const Complex& a, double b)
 {
   Complex result;
   result = pow (a, b);
   return tree_constant (result);
 }
 
 tree_constant
-xpow (Complex& a, Matrix& b)
+xpow (const Complex& a, const Matrix& b)
 {
   tree_constant retval;
 
   int nr = b.rows ();
   int nc = b.columns ();
 
   if (nr == 0 || nc == 0 || nr != nc)
     {
@@ -273,25 +277,25 @@ xpow (Complex& a, Matrix& b)
       ComplexMatrix result = Q * D * Q.inverse ();
       retval = tree_constant (result);
     }
 
   return retval;
 }
 
 tree_constant
-xpow (Complex& a, Complex& b)
+xpow (const Complex& a, const Complex& b)
 {
   Complex result;
   result = pow (a, b);
   return tree_constant (result);
 }
 
 tree_constant
-xpow (Complex& a, ComplexMatrix& b)
+xpow (const Complex& a, const ComplexMatrix& b)
 {
   tree_constant retval;
 
   int nr = b.rows ();
   int nc = b.columns ();
 
   if (nr == 0 || nc == 0 || nr != nc)
     error ("for x^A, A must be square");
@@ -314,17 +318,17 @@ xpow (Complex& a, ComplexMatrix& b)
       ComplexMatrix result = Q * D * Q.inverse ();
       retval = tree_constant (result);
     }
 
   return retval;
 }
 
 tree_constant
-xpow (ComplexMatrix& a, double b)
+xpow (const ComplexMatrix& a, double b)
 {
   tree_constant retval;
 
   int nr = a.rows ();
   int nc = a.columns ();
 
   if (nr == 0 || nc == 0 || nr != nc)
     {
@@ -374,17 +378,17 @@ xpow (ComplexMatrix& a, double b)
       ComplexMatrix result = Q * D * Q.inverse ();
       retval = tree_constant (result);
     }
 
   return retval;
 }
 
 tree_constant
-xpow (ComplexMatrix& a, Complex& b)
+xpow (const ComplexMatrix& a, const Complex& b)
 {
   int nr = a.rows ();
   int nc = a.columns ();
 
   if (nr == 0 || nc == 0 || nr != nc)
     {
       error ("for A^b, A must be square");
       return tree_constant ();
@@ -417,17 +421,17 @@ xpow (ComplexMatrix& a, Complex& b)
  *                  +---+---+----+----+
  *   complex_matrix | 2 | 6 |  8 | 12 |
  *                  +---+---+----+----+
  *
  *   * -> not needed.
  */
 
 tree_constant
-elem_xpow (double a, Matrix& b)
+elem_xpow (double a, const Matrix& b)
 {
   tree_constant retval;
 
   int nr = b.rows ();
   int nc = b.columns ();
 
 // For now, assume the worst.
   if (a < 0.0)
@@ -449,31 +453,31 @@ elem_xpow (double a, Matrix& b)
 
       retval = tree_constant (result);
     }
 
   return retval;
 }
 
 tree_constant
-elem_xpow (double a, ComplexMatrix& b)
+elem_xpow (double a, const ComplexMatrix& b)
 {
   int nr = b.rows ();
   int nc = b.columns ();
 
   ComplexMatrix result (nr, nc);
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
       result.elem (i, j) = pow (a, b.elem (i, j));
 
   return tree_constant (result);
 }
 
 tree_constant
-elem_xpow (Matrix& a, double b)
+elem_xpow (const Matrix& a, double b)
 {
   tree_constant retval;
 
   int nr = a.rows ();
   int nc = a.columns ();
 
   if ((int) b != b && any_element_is_negative (a))
     {
@@ -496,17 +500,17 @@ elem_xpow (Matrix& a, double b)
 
       retval = tree_constant (result);
     }
 
   return retval;
 }
 
 tree_constant
-elem_xpow (Matrix& a, Matrix& b)
+elem_xpow (const Matrix& a, const Matrix& b)
 {
   int nr = a.rows ();
   int nc = a.columns ();
 
   assert (nr == b.rows () && nc == b.columns ());
 
   int convert_to_complex = 0;
   int i;
@@ -545,119 +549,119 @@ elem_xpow (Matrix& a, Matrix& b)
 	for (i = 0; i < nr; i++)
 	  result.elem (i, j) = pow (a.elem (i, j), b.elem (i, j));
 
       return tree_constant (result);
     }
 }
 
 tree_constant
-elem_xpow (Matrix& a, Complex& b)
+elem_xpow (const Matrix& a, const Complex& b)
 {
   int nr = a.rows ();
   int nc = a.columns ();
 
   ComplexMatrix result (nr, nc);
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
       result.elem (i, j) = pow (a.elem (i, j), b);
 
   return tree_constant (result);
 }
 
 tree_constant
-elem_xpow (Matrix& a, ComplexMatrix& b)
+elem_xpow (const Matrix& a, const ComplexMatrix& b)
 {
   int nr = a.rows ();
   int nc = a.columns ();
 
   assert (nr == b.rows () && nc == b.columns ());
 
   ComplexMatrix result (nr, nc);
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
       result.elem (i, j) = pow (a.elem (i, j), b.elem (i, j));
 
   return tree_constant (result);
 }
 
 tree_constant
-elem_xpow (Complex& a, Matrix& b)
+elem_xpow (const Complex& a, const Matrix& b)
 {
   int nr = b.rows ();
   int nc = b.columns ();
 
   ComplexMatrix result (nr, nc);
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
       result.elem (i, j) = pow (a, b.elem (i, j));
 
   return tree_constant (result);
 }
 
 tree_constant
-elem_xpow (Complex& a, ComplexMatrix& b)
+elem_xpow (const Complex& a, const ComplexMatrix& b)
 {
   int nr = b.rows ();
   int nc = b.columns ();
 
   ComplexMatrix result (nr, nc);
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
       result.elem (i, j) = pow (a, b.elem (i, j));
 
   return tree_constant (result);
 }
 
 tree_constant
-elem_xpow (ComplexMatrix& a, double b)
+elem_xpow (const ComplexMatrix& a, double b)
 {
   int nr = a.rows ();
   int nc = a.columns ();
 
   ComplexMatrix result (nr, nc);
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
       result.elem (i, j) = pow (a.elem (i, j), b);
 
   return tree_constant (result);
 }
 
 tree_constant
-elem_xpow (ComplexMatrix& a, Matrix& b)
+elem_xpow (const ComplexMatrix& a, const Matrix& b)
 {
   int nr = a.rows ();
   int nc = a.columns ();
 
   assert (nr == b.rows () && nc == b.columns ());
 
   ComplexMatrix result (nr, nc);
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
       result.elem (i, j) = pow (a.elem (i, j), b.elem (i, j));
 
   return tree_constant (result);
 }
 
 tree_constant
-elem_xpow (ComplexMatrix& a, Complex& b)
+elem_xpow (const ComplexMatrix& a, const Complex& b)
 {
   int nr = a.rows ();
   int nc = a.columns ();
 
   ComplexMatrix result (nr, nc);
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
       result.elem (i, j) = pow (a.elem (i, j), b);
 
   return tree_constant (result);
 }
 
 tree_constant
-elem_xpow (ComplexMatrix& a, ComplexMatrix& b)
+elem_xpow (const ComplexMatrix& a, const ComplexMatrix& b)
 {
   int nr = a.rows ();
   int nc = a.columns ();
 
   ComplexMatrix result (nr, nc);
 
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
diff --git a/src/xpow.h b/src/xpow.h
--- a/src/xpow.h
+++ b/src/xpow.h
@@ -23,53 +23,53 @@ Software Foundation, 675 Mass Ave, Cambr
 
 #if !defined (_xpow_h)
 #define _xpow_h 1
 
 #ifdef __GNUG__
 #pragma interface
 #endif
 
-#include <Complex.h>
-
-#include "Matrix.h"
-
-#include "tree-const.h"
+class Complex;
+class Matrix;
+class ComplexMatrix;
+class tree_constant;
 
 extern tree_constant xpow (double a, double b);
-extern tree_constant xpow (double a, Matrix& b);
-extern tree_constant xpow (double a, Complex& b);
-extern tree_constant xpow (double a, ComplexMatrix& b);
+extern tree_constant xpow (double a, const Matrix& b);
+extern tree_constant xpow (double a, const Complex& b);
+extern tree_constant xpow (double a, const ComplexMatrix& b);
 
-extern tree_constant xpow (Matrix& a, double b);
-extern tree_constant xpow (Matrix& a, Complex& b);
+extern tree_constant xpow (const Matrix& a, double b);
+extern tree_constant xpow (const Matrix& a, const Complex& b);
 
-extern tree_constant xpow (Complex& a, double b);
-extern tree_constant xpow (Complex& a, Matrix& b);
-extern tree_constant xpow (Complex& a, Complex& b);
-extern tree_constant xpow (Complex& a, ComplexMatrix& b);
+extern tree_constant xpow (const Complex& a, double b);
+extern tree_constant xpow (const Complex& a, const Matrix& b);
+extern tree_constant xpow (const Complex& a, const Complex& b);
+extern tree_constant xpow (const Complex& a, const ComplexMatrix& b);
 
-extern tree_constant xpow (ComplexMatrix& a, double b);
-extern tree_constant xpow (ComplexMatrix& a, Complex& b);
+extern tree_constant xpow (const ComplexMatrix& a, double b);
+extern tree_constant xpow (const ComplexMatrix& a, const Complex& b);
 
-extern tree_constant elem_xpow (double a, Matrix& b);
-extern tree_constant elem_xpow (double a, ComplexMatrix& b);
+extern tree_constant elem_xpow (double a, const Matrix& b);
+extern tree_constant elem_xpow (double a, const ComplexMatrix& b);
 
-extern tree_constant elem_xpow (Matrix& a, double b);
-extern tree_constant elem_xpow (Matrix& a, Matrix& b);
-extern tree_constant elem_xpow (Matrix& a, Complex& b);
-extern tree_constant elem_xpow (Matrix& a, ComplexMatrix& b);
+extern tree_constant elem_xpow (const Matrix& a, double b);
+extern tree_constant elem_xpow (const Matrix& a, const Matrix& b);
+extern tree_constant elem_xpow (const Matrix& a, const Complex& b);
+extern tree_constant elem_xpow (const Matrix& a, const ComplexMatrix& b);
 
-extern tree_constant elem_xpow (Complex& a, Matrix& b);
-extern tree_constant elem_xpow (Complex& a, ComplexMatrix& b);
+extern tree_constant elem_xpow (const Complex& a, const Matrix& b);
+extern tree_constant elem_xpow (const Complex& a, const ComplexMatrix& b);
 
-extern tree_constant elem_xpow (ComplexMatrix& a, double b);
-extern tree_constant elem_xpow (ComplexMatrix& a, Matrix& b);
-extern tree_constant elem_xpow (ComplexMatrix& a, Complex& b);
-extern tree_constant elem_xpow (ComplexMatrix& a, ComplexMatrix& b);
+extern tree_constant elem_xpow (const ComplexMatrix& a, double b);
+extern tree_constant elem_xpow (const ComplexMatrix& a, const Matrix& b);
+extern tree_constant elem_xpow (const ComplexMatrix& a, const Complex& b);
+extern tree_constant elem_xpow (const ComplexMatrix& a,
+				const ComplexMatrix& b);
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
 ;;; End: ***
