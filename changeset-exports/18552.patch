# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1394215363 18000
#      Fri Mar 07 13:02:43 2014 -0500
# Node ID b83fca22bb4cd4dc052bac915069eed3327800d8
# Parent  2f5685c080e5c5591db55e58ff298a9254ab5ae9
# Parent  de76baa76aa199f6bc1378c86f3996b6168d942f
maint: Periodic merge of gui-release to default.

diff --git a/.hgtags b/.hgtags
--- a/.hgtags
+++ b/.hgtags
@@ -81,8 +81,9 @@ 608e307b49149b32a6d09c2f06493d04d3af9be4
 3a9efb68272df556dccb84c87933dd8238e88902 ss-3-7-6
 cc13924a4266fb0359f59fabdce11071e6051d48 ss-3-7-7
 d734216aa2b1022c190e6b07d7ccdd59fe15678f rc-3-8-0-1
 f1fa148766d623f7f24cf541ea8b88d8c1b63d33 rc-3-8-0-2
 b72bcf5f78cc2231e9bf2735d3b8d92779fc4dff release-3-8-0
 85d31344fb23725791bc687337295d47416b9c17 rc-3-8-1-2
 02ce68d63fba31cd14ac060c087212a032ae3202 rc-3-8-1-3
 dd669c2ae76c167613f54d6f4db0130fa2124cac rc-3-8-1-4
+43cc202335dc4a53a3d8fc9ca90acaa81d2e63d3 release-3-8-1
diff --git a/libgui/src/m-editor/file-editor.cc b/libgui/src/m-editor/file-editor.cc
--- a/libgui/src/m-editor/file-editor.cc
+++ b/libgui/src/m-editor/file-editor.cc
@@ -37,16 +37,17 @@ along with Octave; see the file COPYING.
 #include <QStyle>
 #include <QTextStream>
 #include <QTabBar>
 #include <QProcess>
 #include <QInputDialog>
 
 #include "octave-link.h"
 #include "utils.h"
+#include "main-window.h"
 
 file_editor::file_editor (QWidget *p)
   : file_editor_interface (p)
 {
   // Set current editing directory before construct because loaded
   // files will change ced accordingly.
   ced = QDir::currentPath ();
 
@@ -261,16 +262,33 @@ file_editor::call_custom_editor (const Q
         handle_mru_add_file (QFileInfo (file_name).canonicalFilePath ());
 
       return true;
     }
 
   return false;
 }
 
+bool
+file_editor::is_editor_console_tabbed ()
+{
+  main_window *w = static_cast<main_window *>(main_win ());
+  QList<QDockWidget *> w_list = w->tabifiedDockWidgets (this);
+  QDockWidget *console =
+    static_cast<QDockWidget *> (w->get_dock_widget_list ().at (0));
+
+  for (int i = 0; i < w_list.count (); i++)
+    {
+      if (w_list.at (i) == console)
+        return true;
+    }
+
+  return false;
+}
+
 void
 file_editor::request_open_files (const QStringList& open_file_names)
 {
   for (int i = 0; i < open_file_names.count (); i++)
     request_open_file (open_file_names.at (i));
 }
 
 void
@@ -306,18 +324,21 @@ file_editor::request_open_file (const QS
 
               if (debug_pointer)
                 emit fetab_insert_debugger_pointer (tab, line);
 
               if (breakpoint_marker)
                 emit fetab_do_breakpoint_marker (insert, tab, line);
             }
 
-          emit fetab_set_focus (tab);
-          set_focus ();
+          if (! ((breakpoint_marker || debug_pointer) && is_editor_console_tabbed ()))
+            {
+              emit fetab_set_focus (tab);
+              set_focus ();
+            }
         }
       else
         {
           file_editor_tab *fileEditorTab = new file_editor_tab ();
           if (fileEditorTab)
             {
               QString result = fileEditorTab->load_file (openFileName);
               if (result == "")
@@ -406,19 +427,22 @@ file_editor::request_open_file (const QS
                               file.close ();
                               request_open_file (openFileName);
                             }
                         }
                     }
                 }
             }
 
-          // really show editor and the current editor tab
-          set_focus ();
-          emit file_loaded_signal ();
+          if (! ((breakpoint_marker || debug_pointer) && is_editor_console_tabbed ()))
+            {
+              // really show editor and the current editor tab
+              set_focus ();
+              emit file_loaded_signal ();
+            }
         }
     }
 }
 
 // open a file from the mru list
 void
 file_editor::request_mru_open_file (QAction *action)
 {
diff --git a/libgui/src/m-editor/file-editor.h b/libgui/src/m-editor/file-editor.h
--- a/libgui/src/m-editor/file-editor.h
+++ b/libgui/src/m-editor/file-editor.h
@@ -190,16 +190,17 @@ private slots:
                           bool debug_pointer = false,
                           bool breakpoint_marker = false, bool insert = true);
   void request_preferences (bool);
   void request_styles_preferences (bool);
   void restore_create_file_setting ();
 
 private:
 
+  bool is_editor_console_tabbed ();
   void construct (void);
   void add_file_editor_tab (file_editor_tab *f, const QString& fn);
   void save_file_as (QWidget *fetabID = 0);
   void mru_menu_update (void);
   bool call_custom_editor (const QString& file_name = QString (), int line = -1);
 
   QWidget *find_tab_widget (const QString& openFileName) const;
 
diff --git a/libgui/src/main-window.h b/libgui/src/main-window.h
--- a/libgui/src/main-window.h
+++ b/libgui/src/main-window.h
@@ -193,16 +193,19 @@ public slots:
 
   // setting global shortcuts
   void set_global_shortcuts (bool enable);
 
   // handling the clipboard
   void clipboard_has_changed (QClipboard::Mode);
   void clear_clipboard ();
 
+  // get the dockwidgets
+  QList<octave_dock_widget *> get_dock_widget_list ()
+    { return dock_widget_list (); }
 
 protected:
   void closeEvent (QCloseEvent * closeEvent);
 
 private:
 
   void construct (void);
 
diff --git a/libinterp/dldfcn/__magick_read__.cc b/libinterp/dldfcn/__magick_read__.cc
--- a/libinterp/dldfcn/__magick_read__.cc
+++ b/libinterp/dldfcn/__magick_read__.cc
@@ -411,16 +411,17 @@ read_images (std::vector<Magick::Image>&
 
         default:
           // Do nothing other than silencing warnings about enumeration
           // values not being handled in switch.
           ;
         }
     }
 
+  const octave_idx_type colour_stride = nRows * nCols;
   switch (type)
     {
     case Magick::BilevelType:           // Monochrome bi-level image
     case Magick::GrayscaleType:         // Grayscale image
       {
         img = T (dim_vector (nRows, nCols, 1, nFrames));
         P *img_fvec = img.fortran_vec ();
 
@@ -475,162 +476,168 @@ read_images (std::vector<Magick::Image>&
       }
 
     case Magick::PaletteType:           // Indexed color (palette) image
     case Magick::TrueColorType:         // Truecolor image
       {
         img = T (dim_vector (nRows, nCols, 3, nFrames));
         P *img_fvec = img.fortran_vec ();
 
+        const octave_idx_type frame_stride  = colour_stride * 3;
         for (octave_idx_type frame = 0; frame < nFrames; frame++)
           {
             const Magick::PixelPacket *pix
               = imvec[frameidx(frame)].getConstPixels (col_start, row_start,
                                                        col_cache, row_cache);
 
             octave_idx_type idx = 0;
-            img_fvec += nRows * nCols * frame;
             P *rbuf   = img_fvec;
-            P *gbuf   = img_fvec + nRows * nCols;
-            P *bbuf   = img_fvec + nRows * nCols * 2;
+            P *gbuf   = img_fvec + colour_stride;
+            P *bbuf   = img_fvec + colour_stride * 2;
 
             for (octave_idx_type col = 0; col < nCols; col++)
               {
                 for (octave_idx_type row = 0; row < nRows; row++)
                   {
                     rbuf[idx] = pix->red   / divisor;
                     gbuf[idx] = pix->green / divisor;
                     bbuf[idx] = pix->blue  / divisor;
                     pix += row_shift;
                     idx++;
                   }
                 pix -= col_shift;
               }
+            img_fvec += frame_stride;
           }
         break;
       }
 
     case Magick::PaletteMatteType:    // Indexed color image with opacity
     case Magick::TrueColorMatteType:  // Truecolor image with opacity
       {
         img   = T (dim_vector (nRows, nCols, 3, nFrames));
         T alpha   (dim_vector (nRows, nCols, 1, nFrames));
         P *img_fvec = img.fortran_vec ();
         P *a_fvec   = alpha.fortran_vec ();
 
+        const octave_idx_type frame_stride  = colour_stride * 3;
+
         // Unlike the index for the other channels, this one won't need
         // to be reset on each frame since it's a separate matrix.
         octave_idx_type a_idx = 0;
         for (octave_idx_type frame = 0; frame < nFrames; frame++)
           {
             const Magick::PixelPacket *pix
               = imvec[frameidx(frame)].getConstPixels (col_start, row_start,
                                                        col_cache, row_cache);
 
             octave_idx_type idx = 0;
-            img_fvec += nRows * nCols * frame;
             P *rbuf   = img_fvec;
-            P *gbuf   = img_fvec + nRows * nCols;
-            P *bbuf   = img_fvec + nRows * nCols * 2;
+            P *gbuf   = img_fvec + colour_stride;
+            P *bbuf   = img_fvec + colour_stride * 2;
 
             for (octave_idx_type col = 0; col < nCols; col++)
               {
                 for (octave_idx_type row = 0; row < nRows; row++)
                   {
                     rbuf[idx]     = pix->red     / divisor;
                     gbuf[idx]     = pix->green   / divisor;
                     bbuf[idx]     = pix->blue    / divisor;
                     a_fvec[a_idx++] = (MaxRGB - pix->opacity) / divisor;
                     pix += row_shift;
                     idx++;
                   }
                 pix -= col_shift;
               }
+            img_fvec += frame_stride;
           }
         retval(2) = alpha;
         break;
       }
 
     case Magick::ColorSeparationType:  // Cyan/Magenta/Yellow/Black (CMYK) image
       {
         img   = T (dim_vector (nRows, nCols, 4, nFrames));
         P *img_fvec = img.fortran_vec ();
 
+        const octave_idx_type frame_stride  = colour_stride * 4;
         for (octave_idx_type frame = 0; frame < nFrames; frame++)
           {
             const Magick::PixelPacket *pix
               = imvec[frameidx(frame)].getConstPixels (col_start, row_start,
                                                        col_cache, row_cache);
 
             octave_idx_type idx = 0;
-            img_fvec += nRows * nCols * frame;
             P *cbuf   = img_fvec;
-            P *mbuf   = img_fvec + nRows * nCols;
-            P *ybuf   = img_fvec + nRows * nCols * 2;
-            P *kbuf   = img_fvec + nRows * nCols * 3;
+            P *mbuf   = img_fvec + colour_stride;
+            P *ybuf   = img_fvec + colour_stride * 2;
+            P *kbuf   = img_fvec + colour_stride * 3;
 
             for (octave_idx_type col = 0; col < nCols; col++)
               {
                 for (octave_idx_type row = 0; row < nRows; row++)
                   {
                     cbuf[idx] = pix->red     / divisor;
                     mbuf[idx] = pix->green   / divisor;
                     ybuf[idx] = pix->blue    / divisor;
                     kbuf[idx] = pix->opacity / divisor;
                     pix += row_shift;
                     idx++;
                   }
                 pix -= col_shift;
               }
+            img_fvec += frame_stride;
           }
         break;
       }
 
     // Cyan, magenta, yellow, and black with alpha (opacity) channel
     case Magick::ColorSeparationMatteType:
       {
         img   = T (dim_vector (nRows, nCols, 4, nFrames));
         T alpha   (dim_vector (nRows, nCols, 1, nFrames));
         P *img_fvec = img.fortran_vec ();
         P *a_fvec   = alpha.fortran_vec ();
 
+        const octave_idx_type frame_stride  = colour_stride * 4;
+
         // Unlike the index for the other channels, this one won't need
         // to be reset on each frame since it's a separate matrix.
         octave_idx_type a_idx = 0;
         for (octave_idx_type frame = 0; frame < nFrames; frame++)
           {
             const Magick::PixelPacket *pix
               = imvec[frameidx(frame)].getConstPixels (col_start, row_start,
                                                        col_cache, row_cache);
             // Note that for CMYKColorspace + matte (CMYKA), the opacity is
             // stored in the assocated IndexPacket.
             const Magick::IndexPacket *apix
               = imvec[frameidx(frame)].getConstIndexes ();
 
             octave_idx_type idx = 0;
-            img_fvec += nRows * nCols * frame;
             P *cbuf   = img_fvec;
-            P *mbuf   = img_fvec + nRows * nCols;
-            P *ybuf   = img_fvec + nRows * nCols * 2;
-            P *kbuf   = img_fvec + nRows * nCols * 3;
+            P *mbuf   = img_fvec + colour_stride;
+            P *ybuf   = img_fvec + colour_stride * 2;
+            P *kbuf   = img_fvec + colour_stride * 3;
 
             for (octave_idx_type col = 0; col < nCols; col++)
               {
                 for (octave_idx_type row = 0; row < nRows; row++)
                   {
                     cbuf[idx]     = pix->red     / divisor;
                     mbuf[idx]     = pix->green   / divisor;
                     ybuf[idx]     = pix->blue    / divisor;
                     kbuf[idx]     = pix->opacity / divisor;
                     a_fvec[a_idx++] = (MaxRGB - *apix) / divisor;
                     pix += row_shift;
                     idx++;
                   }
                 pix -= col_shift;
               }
+            img_fvec += frame_stride;
           }
         retval(2) = alpha;
         break;
       }
 
     default:
       error ("__magick_read__: unknown Magick++ image type");
       return retval;
@@ -1057,24 +1064,24 @@ encode_uint_image (std::vector<Magick::I
                          / MaxRGB;
 
   const P *img_fvec = img.fortran_vec ();
   const P *a_fvec   = alpha.fortran_vec ();
   switch (type)
     {
     case Magick::GrayscaleType:
       {
-        octave_idx_type GM_idx = 0;
         for (octave_idx_type frame = 0; frame < nFrames; frame++)
           {
             Magick::Image m_img = init_enconde_image (nCols, nRows, bitdepth,
                                                       type,
                                                       Magick::DirectClass);
 
             Magick::PixelPacket *pix = m_img.getPixels (0, 0, nCols, nRows);
+            octave_idx_type GM_idx = 0;
             for (octave_idx_type col = 0; col < nCols; col++)
               {
                 for (octave_idx_type row = 0; row < nRows; row++)
                   {
                     Magick::Color c;
                     c.redQuantum (double (*img_fvec) / divisor);
                     pix[GM_idx] = c;
                     img_fvec++;
@@ -1086,31 +1093,31 @@ encode_uint_image (std::vector<Magick::I
             m_img.syncPixels ();
             imvec.push_back (m_img);
           }
         break;
       }
 
     case Magick::GrayscaleMatteType:
       {
-        octave_idx_type GM_idx = 0;
         for (octave_idx_type frame = 0; frame < nFrames; frame++)
           {
             Magick::Image m_img = init_enconde_image (nCols, nRows, bitdepth,
                                                       type,
                                                       Magick::DirectClass);
 
             Magick::PixelPacket *pix = m_img.getPixels (0, 0, nCols, nRows);
+            octave_idx_type GM_idx = 0;
             for (octave_idx_type col = 0; col < nCols; col++)
               {
                 for (octave_idx_type row = 0; row < nRows; row++)
                   {
-                    Magick::Color c;
-                    c.redQuantum   (double (*img_fvec) / divisor);
-                    c.alphaQuantum (MaxRGB - (double (*a_fvec) / divisor));
+                    double grey = double (*img_fvec) / divisor;
+                    Magick::Color c (grey, grey, grey,
+                                     MaxRGB - (double (*a_fvec) / divisor));
                     pix[GM_idx] = c;
                     img_fvec++;
                     a_fvec++;
                     GM_idx += nCols;
                   }
                 GM_idx -= nCols * nRows - 1;
               }
             // Save changes to underlying image.
@@ -1120,57 +1127,58 @@ encode_uint_image (std::vector<Magick::I
         break;
       }
 
     case Magick::TrueColorType:
       {
         // The fortran_vec offset for the green and blue channels
         const octave_idx_type G_offset = nCols * nRows;
         const octave_idx_type B_offset = nCols * nRows * 2;
-        octave_idx_type GM_idx = 0;
         for (octave_idx_type frame = 0; frame < nFrames; frame++)
           {
             Magick::Image m_img = init_enconde_image (nCols, nRows, bitdepth,
                                                       type,
                                                       Magick::DirectClass);
 
             Magick::PixelPacket *pix = m_img.getPixels (0, 0, nCols, nRows);
+            octave_idx_type GM_idx = 0;
             for (octave_idx_type col = 0; col < nCols; col++)
               {
                 for (octave_idx_type row = 0; row < nRows; row++)
                   {
                     Magick::Color c (double (*img_fvec)          / divisor,
                                      double (img_fvec[G_offset]) / divisor,
                                      double (img_fvec[B_offset]) / divisor);
                     pix[GM_idx] = c;
                     img_fvec++;
                     GM_idx += nCols;
                   }
                 GM_idx -= nCols * nRows - 1;
               }
             // Save changes to underlying image.
             m_img.syncPixels ();
             imvec.push_back (m_img);
+            img_fvec += B_offset;
           }
         break;
       }
 
     case Magick::TrueColorMatteType:
       {
         // The fortran_vec offset for the green and blue channels
         const octave_idx_type G_offset = nCols * nRows;
         const octave_idx_type B_offset = nCols * nRows * 2;
-        octave_idx_type GM_idx = 0;
         for (octave_idx_type frame = 0; frame < nFrames; frame++)
           {
             Magick::Image m_img = init_enconde_image (nCols, nRows, bitdepth,
                                                       type,
                                                       Magick::DirectClass);
 
             Magick::PixelPacket *pix = m_img.getPixels (0, 0, nCols, nRows);
+            octave_idx_type GM_idx = 0;
             for (octave_idx_type col = 0; col < nCols; col++)
               {
                 for (octave_idx_type row = 0; row < nRows; row++)
                   {
                     Magick::Color c (double (*img_fvec)          / divisor,
                                      double (img_fvec[G_offset]) / divisor,
                                      double (img_fvec[B_offset]) / divisor,
                                      MaxRGB - (double (*a_fvec) / divisor));
@@ -1179,34 +1187,35 @@ encode_uint_image (std::vector<Magick::I
                     a_fvec++;
                     GM_idx += nCols;
                   }
                 GM_idx -= nCols * nRows - 1;
               }
             // Save changes to underlying image.
             m_img.syncPixels ();
             imvec.push_back (m_img);
+            img_fvec += B_offset;
           }
         break;
       }
 
     case Magick::ColorSeparationType:
       {
         // The fortran_vec offset for the Magenta, Yellow, and blacK channels
         const octave_idx_type M_offset = nCols * nRows;
         const octave_idx_type Y_offset = nCols * nRows * 2;
         const octave_idx_type K_offset = nCols * nRows * 3;
-        octave_idx_type GM_idx = 0;
         for (octave_idx_type frame = 0; frame < nFrames; frame++)
           {
             Magick::Image m_img = init_enconde_image (nCols, nRows, bitdepth,
                                                       type,
                                                       Magick::DirectClass);
 
             Magick::PixelPacket *pix = m_img.getPixels (0, 0, nCols, nRows);
+            octave_idx_type GM_idx = 0;
             for (octave_idx_type col = 0; col < nCols; col++)
               {
                 for (octave_idx_type row = 0; row < nRows; row++)
                   {
                     Magick::Color c (double (*img_fvec)          / divisor,
                                      double (img_fvec[M_offset]) / divisor,
                                      double (img_fvec[Y_offset]) / divisor,
                                      double (img_fvec[K_offset]) / divisor);
@@ -1214,35 +1223,36 @@ encode_uint_image (std::vector<Magick::I
                     img_fvec++;
                     GM_idx += nCols;
                   }
                 GM_idx -= nCols * nRows - 1;
               }
             // Save changes to underlying image.
             m_img.syncPixels ();
             imvec.push_back (m_img);
+            img_fvec += K_offset;
           }
         break;
       }
 
     case Magick::ColorSeparationMatteType:
       {
         // The fortran_vec offset for the Magenta, Yellow, and blacK channels
         const octave_idx_type M_offset = nCols * nRows;
         const octave_idx_type Y_offset = nCols * nRows * 2;
         const octave_idx_type K_offset = nCols * nRows * 3;
-        octave_idx_type GM_idx = 0;
         for (octave_idx_type frame = 0; frame < nFrames; frame++)
           {
             Magick::Image m_img = init_enconde_image (nCols, nRows, bitdepth,
                                                       type,
                                                       Magick::DirectClass);
 
             Magick::PixelPacket *pix = m_img.getPixels (0, 0, nCols, nRows);
             Magick::IndexPacket *ind = m_img.getIndexes ();
+            octave_idx_type GM_idx = 0;
             for (octave_idx_type col = 0; col < nCols; col++)
               {
                 for (octave_idx_type row = 0; row < nRows; row++)
                   {
                     Magick::Color c (double (*img_fvec)          / divisor,
                                      double (img_fvec[M_offset]) / divisor,
                                      double (img_fvec[Y_offset]) / divisor,
                                      double (img_fvec[K_offset]) / divisor);
@@ -1252,16 +1262,17 @@ encode_uint_image (std::vector<Magick::I
                     a_fvec++;
                     GM_idx += nCols;
                   }
                 GM_idx -= nCols * nRows - 1;
               }
             // Save changes to underlying image.
             m_img.syncPixels ();
             imvec.push_back (m_img);
+            img_fvec += K_offset;
           }
         break;
       }
 
     default:
       {
         error ("__magick_write__: unrecognized Magick::ImageType");
         return;
diff --git a/scripts/image/imshow.m b/scripts/image/imshow.m
--- a/scripts/image/imshow.m
+++ b/scripts/image/imshow.m
@@ -125,17 +125,17 @@ function h = imshow (im, varargin)
         case "xdata";
           xdata = varargin{narg++};
           if (! isvector (xdata))
             error ("imshow: xdata must be a vector")
           endif
           xdata = [xdata(1) xdata(end)];
         case "ydata";
           ydata = varargin{narg++};
-          if (isvector (xdata))
+          if (! isvector (ydata))
             error ("imshow: expect a vector for ydata")
           endif
           ydata = [ydata(1) ydata(end)];
         case {"truesize", "initialmagnification"}
           warning ("image: zoom argument ignored -- use GUI features");
         otherwise
           warning ("imshow: unrecognized property %s", arg);
           narg++;
diff --git a/scripts/image/imwrite.m b/scripts/image/imwrite.m
--- a/scripts/image/imwrite.m
+++ b/scripts/image/imwrite.m
@@ -109,31 +109,85 @@ function imwrite (varargin)
              ext);
     __imwrite__ (varargin{:});
   else
     fmt.write (varargin{:});
   endif
 
 endfunction
 
-
 %% Test input validation
 %!error imwrite ()                            # Wrong # of args
 %!error imwrite (1)                           # Wrong # of args
 %!error imwrite ({"cell"}, "filename.jpg")    # Wrong class for img
 %!error imwrite (1, [], "filename.jpg")       # Empty image map
 %!error imwrite (1, 2, 3)                     # No filename specified
 %!error imwrite (1, "filename")               # No fmt specified
 %!error imwrite (1, "filename", "junk")       # Invalid fmt specified
 %!error imwrite ([], "filename.jpg")          # Empty img matrix
 %!error imwrite (spones (2), "filename.jpg")  # Invalid sparse img
 
+%!function [r, cmap, a] = write_and_read (varargin)
+%!  filename = [tmpnam() ".tif"];
+%!  unwind_protect
+%!    imwrite (varargin{1}, filename, varargin{2:end});
+%!    [r, cmap, a] = imread (filename, "Index", "all");
+%!  unwind_protect_cleanup
+%!    unlink (filename);
+%!  end_unwind_protect
+%!endfunction
+
+## typical usage with grayscale uint8 images
 %!testif HAVE_MAGICK
-%! imw = randi (255, 100, "uint8");
-%! filename = [tmpnam() ".png"];
-%! unwind_protect
-%!   imwrite (imw, filename);
-%!   imr = imread (filename);
-%! unwind_protect_cleanup
-%!   unlink (filename);
-%! end_unwind_protect
-%! assert (imw, imr)
+%! gray  = randi (255, 10, 10, 1, "uint8");
+%! r  = write_and_read (gray);
+%! assert (r, gray)
+
+## grayscale uint8 images with alpha channel
+%!testif HAVE_MAGICK
+%! gray  = randi (255, 10, 10, 1, "uint8");
+%! alpha = randi (255, 10, 10, 1, "uint8");
+%! [r, ~, a] = write_and_read (gray, "Alpha", alpha);
+%! assert (r, gray)
+%! assert (a, alpha)
+
+## multipage grayscale uint8 images
+%!testif HAVE_MAGICK
+%! gray  = randi (255, 10, 10, 1, 5, "uint8");
+%! r     = write_and_read (gray);
+%! assert (r, gray)
+
+## multipage RGB uint8 images with alpha channel
+%!testif HAVE_MAGICK
+%! gray  = randi (255, 10, 10, 3, 5, "uint8");
+%! alpha = randi (255, 10, 10, 1, 5, "uint8");
+%! [r, ~, a] = write_and_read (gray, "Alpha", alpha);
+%! assert (r, gray)
+%! assert (a, alpha)
 
+## typical usage with RGB uint8 images
+%!testif HAVE_MAGICK
+%! rgb = randi (255, 10, 10, 3, "uint8");
+%! r = write_and_read (rgb);
+%! assert (r, rgb)
+
+## RGB uint8 images with alpha channel
+%!testif HAVE_MAGICK
+%! rgb   = randi (255, 10, 10, 3, "uint8");
+%! alpha = randi (255, 10, 10, 1, "uint8");
+%! [r, ~, a] = write_and_read (rgb, "Alpha", alpha);
+%! assert (r, rgb)
+%! assert (a, alpha)
+
+## multipage RGB uint8 images
+%!testif HAVE_MAGICK
+%! rgb = randi (255, 10, 10, 3, 5, "uint8");
+%! r = write_and_read (rgb);
+%! assert (r, rgb)
+
+## multipage RGB uint8 images with alpha channel
+%!testif HAVE_MAGICK
+%! rgb   = randi (255, 10, 10, 3, 5, "uint8");
+%! alpha = randi (255, 10, 10, 1, 5, "uint8");
+%! [r, ~, a] = write_and_read (rgb, "Alpha", alpha);
+%! assert (r, rgb)
+%! assert (a, alpha)
+
diff --git a/scripts/testfun/assert.m b/scripts/testfun/assert.m
--- a/scripts/testfun/assert.m
+++ b/scripts/testfun/assert.m
@@ -58,323 +58,339 @@ function assert (cond, varargin)
 
   if (nargin == 0)
     print_usage ();
   endif
 
   persistent call_depth = -1;
   persistent errmsg;
 
-  call_depth++;
-
-  if (call_depth == 0)
-    errmsg = "";
-  endif
+  unwind_protect
 
-  if (nargin == 1 || (nargin > 1 && islogical (cond) && ischar (varargin{1})))
-    if ((! isnumeric (cond) && ! islogical (cond)) || ! all (cond(:)))
-      call_depth--;
-      if (nargin == 1)
-        ## Perhaps, say which elements failed?
-        argin = ["(" strjoin(cellstr (argn), ",") ")"];
-        error ("assert %s failed", argin);
-      else
-        error (varargin{:});
-      endif
-    endif
-  else
-    expected = varargin{1};
-    if (nargin < 3)
-      tol = 0;
-    elseif (nargin == 3)
-      tol = varargin{2};
-    else
-      print_usage ();
+    call_depth++;
+
+    if (call_depth == 0)
+      errmsg = "";
     endif
 
-    ## Add to list as the errors accumulate.  If empty at end then no errors.
-    err.index = {};
-    err.observed = {};
-    err.expected = {};
-    err.reason = {};
-
-    if (ischar (expected))
-      if (! ischar (cond))
-        err.index{end+1} = ".";
-        err.expected{end+1} = expected;
-        if (isnumeric (cond))
-          err.observed{end+1} = num2str (cond);
-          err.reason{end+1} = "Expected string, but observed number";
+    if (nargin == 1 || (nargin > 1 && islogical (cond) && ischar (varargin{1})))
+      if ((! isnumeric (cond) && ! islogical (cond)) || ! all (cond(:)))
+        if (nargin == 1)
+          ## Perhaps, say which elements failed?
+          argin = ["(" strjoin(cellstr (argn), ",") ")"];
+          error ("assert %s failed", argin);
         else
-          err.observed{end+1} = "O";
-          err.reason{end+1} = ["Expected string, but observed " class(cond)];
+          error (varargin{:});
         endif
-      elseif (! strcmp (cond, expected))
-        err.index{end+1} = "[]";
-        err.observed{end+1} = cond;
-        err.expected{end+1} = expected;
-        err.reason{end+1} = "Strings don't match";
+      endif
+    else
+      expected = varargin{1};
+      if (nargin < 3)
+        tol = 0;
+      elseif (nargin == 3)
+        tol = varargin{2};
+      else
+        print_usage ();
       endif
 
-    elseif (iscell (expected))
-      if (! iscell (cond))
-        err.index{end+1} = ".";
-        err.observed{end+1} = "O";
-        err.expected{end+1} = "E";
-        err.reason{end+1} = ["Expected cell, but observed " class(cond)];
+      ## Add to list as the errors accumulate.  If empty at end then no errors.
+      err.index = {};
+      err.observed = {};
+      err.expected = {};
+      err.reason = {};
+
+      if (ischar (expected))
+        if (! ischar (cond))
+          err.index{end+1} = ".";
+          err.expected{end+1} = expected;
+          if (isnumeric (cond))
+            err.observed{end+1} = num2str (cond);
+            err.reason{end+1} = "Expected string, but observed number";
+          else
+            err.observed{end+1} = "O";
+            err.reason{end+1} = ["Expected string, but observed " class(cond)];
+          endif
+        elseif (! strcmp (cond, expected))
+          err.index{end+1} = "[]";
+          err.observed{end+1} = cond;
+          err.expected{end+1} = expected;
+          err.reason{end+1} = "Strings don't match";
+        endif
+
+      elseif (iscell (expected))
+        if (! iscell (cond))
+          err.index{end+1} = ".";
+          err.observed{end+1} = "O";
+          err.expected{end+1} = "E";
+          err.reason{end+1} = ["Expected cell, but observed " class(cond)];
+        elseif (ndims (cond) != ndims (expected)
+                || any (size (cond) != size (expected)))
+          err.index{end+1} = ".";
+          err.observed{end+1} = ["O(" sprintf("%dx", size(cond))(1:end-1) ")"];
+          err.expected{end+1} = ["E(" sprintf("%dx", size(expected))(1:end-1) ")"];
+          err.reason{end+1} = "Dimensions don't match";
+        else
+          try
+            ## Recursively compare cell arrays
+            for i = 1:length (expected(:))
+              assert (cond{i}, expected{i}, tol);
+            endfor
+          catch
+            err.index{end+1} = "{}";
+            err.observed{end+1} = "O";
+            err.expected{end+1} = "E";
+            err.reason{end+1} = "Cell configuration error";
+          end_try_catch
+        endif
+
+      elseif (is_function_handle (expected))
+        if (! is_function_handle (cond))
+          err.index{end+1} = "@";
+          err.observed{end+1} = "O";
+          err.expected{end+1} = "E";
+          err.reason{end+1} = ["Expected function handle, but observed " class(cond)];
+        elseif (! isequal (cond, expected))
+          err.index{end+1} = "@";
+          err.observed{end+1} = "O";
+          err.expected{end+1} = "E";
+          err.reason{end+1} = "Function handles don't match";
+        endif
+
+      elseif (isstruct (expected))
+        if (! isstruct (cond))
+          err.index{end+1} = ".";
+          err.observed{end+1} = "O";
+          err.expected{end+1} = "E";
+          err.reason{end+1} = ["Expected struct, but observed " class(cond)];
+        elseif (ndims (cond) != ndims (expected)
+                || any (size (cond) != size (expected))
+                || numfields (cond) != numfields (expected))
+
+          err.index{end+1} = ".";
+          err.observed{end+1} = ["O(" sprintf("%dx", size(cond))(1:end-1) ")"];
+          err.expected{end+1} = ["E(" sprintf("%dx", size(expected))(1:end-1) ")"];
+          err.reason{end+1} = "Structure sizes don't match";
+        else
+          try
+            empty = isempty (cond);
+            normal = (numel (cond) == 1);
+            for [v, k] = cond
+              if (! isfield (expected, k))
+                err.index{end+1} = ".";
+                err.observed{end+1} = "O";
+                err.expected{end+1} = "E";
+                err.reason{end+1} = ["'" k "'" " is not an expected field"];
+              endif
+              if (empty)
+                v = {};
+              elseif (normal)
+                v = {v};
+              else
+                v = v(:)';
+              endif
+              ## Recursively call assert for struct array values
+              assert (v, {expected.(k)}, tol);
+            endfor
+          catch
+            err.index{end+1} = ".";
+            err.observed{end+1} = "O";
+            err.expected{end+1} = "E";
+            err.reason{end+1} = "Structure configuration error";
+          end_try_catch
+        endif
+
       elseif (ndims (cond) != ndims (expected)
               || any (size (cond) != size (expected)))
         err.index{end+1} = ".";
         err.observed{end+1} = ["O(" sprintf("%dx", size(cond))(1:end-1) ")"];
         err.expected{end+1} = ["E(" sprintf("%dx", size(expected))(1:end-1) ")"];
         err.reason{end+1} = "Dimensions don't match";
-      else
-        try
-          ## Recursively compare cell arrays
-          for i = 1:length (expected(:))
-            assert (cond{i}, expected{i}, tol);
-          endfor
-        catch
-          err.index{end+1} = "{}";
-          err.observed{end+1} = "O";
-          err.expected{end+1} = "E";
-          err.reason{end+1} = "Cell configuration error";
-        end_try_catch
-      endif
 
-    elseif (isstruct (expected))
-      if (! isstruct (cond))
-        err.index{end+1} = ".";
-        err.observed{end+1} = "O";
-        err.expected{end+1} = "E";
-        err.reason{end+1} = ["Expected struct, but observed " class(cond)];
-      elseif (ndims (cond) != ndims (expected)
-              || any (size (cond) != size (expected))
-              || numfields (cond) != numfields (expected))
-
-        err.index{end+1} = ".";
-        err.observed{end+1} = ["O(" sprintf("%dx", size(cond))(1:end-1) ")"];
-        err.expected{end+1} = ["E(" sprintf("%dx", size(expected))(1:end-1) ")"];
-        err.reason{end+1} = "Structure sizes don't match";
-      else
-        try
-          empty = isempty (cond);
-          normal = (numel (cond) == 1);
-          for [v, k] = cond
-            if (! isfield (expected, k))
-              err.index{end+1} = ".";
-              err.observed{end+1} = "O";
-              err.expected{end+1} = "E";
-              err.reason{end+1} = ["'" k "'" " is not an expected field"];
-            endif
-            if (empty)
-              v = {};
-            elseif (normal)
-              v = {v};
-            else
-              v = v(:)';
-            endif
-            ## Recursively call assert for struct array values
-            assert (v, {expected.(k)}, tol);
-          endfor
-        catch
-          err.index{end+1} = ".";
-          err.observed{end+1} = "O";
-          err.expected{end+1} = "E";
-          err.reason{end+1} = "Structure configuration error";
-        end_try_catch
-      endif
-
-    elseif (ndims (cond) != ndims (expected)
-            || any (size (cond) != size (expected)))
-      err.index{end+1} = ".";
-      err.observed{end+1} = ["O(" sprintf("%dx", size(cond))(1:end-1) ")"];
-      err.expected{end+1} = ["E(" sprintf("%dx", size(expected))(1:end-1) ")"];
-      err.reason{end+1} = "Dimensions don't match";
-
-    else  # Numeric comparison
-      if (nargin < 3)
-        ## Without explicit tolerance, be more strict.
-        if (! strcmp (class (cond), class (expected)))
-          err.index{end+1} = "()";
-          err.observed{end+1} = "O";
-          err.expected{end+1} = "E";
-          err.reason{end+1} = ["Class " class(cond) " != " class(expected)];
-        elseif (isnumeric (cond))
-          if (issparse (cond) != issparse (expected))
+      else  # Numeric comparison
+        if (nargin < 3)
+          ## Without explicit tolerance, be more strict.
+          if (! strcmp (class (cond), class (expected)))
             err.index{end+1} = "()";
             err.observed{end+1} = "O";
             err.expected{end+1} = "E";
-            if (issparse (cond))
-              err.reason{end+1} = "sparse != non-sparse";
-            else
-              err.reason{end+1} = "non-sparse != sparse";
-            endif
-          elseif (iscomplex (cond) != iscomplex (expected))
-            err.index{end+1} = "()";
-            err.observed{end+1} = "O";
-            err.expected{end+1} = "E";
-           if (iscomplex (cond))
-              err.reason{end+1} = "complex != real";
-            else
-              err.reason{end+1} = "real != complex";
+            err.reason{end+1} = ["Class " class(cond) " != " class(expected)];
+          elseif (isnumeric (cond))
+            if (issparse (cond) != issparse (expected))
+              err.index{end+1} = "()";
+              err.observed{end+1} = "O";
+              err.expected{end+1} = "E";
+              if (issparse (cond))
+                err.reason{end+1} = "sparse != non-sparse";
+              else
+                err.reason{end+1} = "non-sparse != sparse";
+              endif
+            elseif (iscomplex (cond) != iscomplex (expected))
+              err.index{end+1} = "()";
+              err.observed{end+1} = "O";
+              err.expected{end+1} = "E";
+             if (iscomplex (cond))
+                err.reason{end+1} = "complex != real";
+              else
+                err.reason{end+1} = "real != complex";
+              endif
             endif
           endif
         endif
-      endif
 
-      if (isempty (err.index))
-
-        A = cond;
-        B = expected;
-
-        ## Check exceptional values.
-        errvec = (  isna (real (A)) != isna (real (B))
-                  | isna (imag (A)) != isna (imag (B)));
-        erridx = find (errvec);
-        if (! isempty (erridx))
-          err.index(end+1:end+length (erridx)) = ...
-            ind2tuple (size (A), erridx);
-          err.observed(end+1:end+length (erridx)) = ...
-            strtrim (cellstr (num2str (A(erridx) (:))));
-          err.expected(end+1:end+length (erridx)) = ...
-            strtrim (cellstr (num2str (B(erridx) (:))));
-          err.reason(end+1:end+length (erridx)) = ...
-            repmat ({"'NA' mismatch"}, length (erridx), 1);
-        endif
-        errseen = errvec;
-
-        errvec = (  isnan (real (A)) != isnan (real (B))
-                  | isnan (imag (A)) != isnan (imag (B)));
-        erridx = find (errvec & !errseen);
-        if (! isempty (erridx))
-          err.index(end+1:end+length (erridx)) = ...
-            ind2tuple (size (A), erridx);
-          err.observed(end+1:end+length (erridx)) = ...
-            strtrim (cellstr (num2str (A(erridx) (:))));
-          err.expected(end+1:end+length (erridx)) = ...
-            strtrim (cellstr (num2str (B(erridx) (:))));
-          err.reason(end+1:end+length (erridx)) = ...
-            repmat ({"'NaN' mismatch"}, length (erridx), 1);
-        endif
-        errseen |= errvec;
+        if (isempty (err.index))
 
-        errvec =   ((isinf (real (A)) | isinf (real (B))) ...
-                    & (real (A) != real (B)))             ...
-                 | ((isinf (imag (A)) | isinf (imag (B))) ...
-                    & (imag (A) != imag (B)));
-        erridx = find (errvec & !errseen);
-        if (! isempty (erridx))
-          err.index(end+1:end+length (erridx)) = ...
-            ind2tuple (size (A), erridx);
-          err.observed(end+1:end+length (erridx)) = ...
-            strtrim (cellstr (num2str (A(erridx) (:))));
-          err.expected(end+1:end+length (erridx)) = ...
-            strtrim (cellstr (num2str (B(erridx) (:))));
-          err.reason(end+1:end+length (erridx)) = ...
-            repmat ({"'Inf' mismatch"}, length (erridx), 1);
-        endif
-        errseen |= errvec;
+          A = cond;
+          B = expected;
 
-        ## Check normal values.
-        ## Replace exceptional values already checked above by zero.
-        A_null_real = real (A);
-        B_null_real = real (B);
-        exclude = errseen | ! isfinite (A_null_real) & ! isfinite (B_null_real);
-        A_null_real(exclude) = 0;
-        B_null_real(exclude) = 0;
-        A_null_imag = imag (A);
-        B_null_imag = imag (B);
-        exclude = errseen | ! isfinite (A_null_imag) & ! isfinite (B_null_imag);
-        A_null_imag(exclude) = 0;
-        B_null_imag(exclude) = 0;
-        A_null = complex (A_null_real, A_null_imag);
-        B_null = complex (B_null_real, B_null_imag);
-        if (isscalar (tol))
-          mtol = tol * ones (size (A));
-        else
-          mtol = tol;
-        endif
-
-        k = (mtol == 0);
-        erridx = find ((A_null != B_null) & k);
-        if (! isempty (erridx))
-          err.index(end+1:end+length (erridx)) = ...
-            ind2tuple (size (A), erridx);
-          err.observed(end+1:end+length (erridx)) = ...
-            strtrim (cellstr (num2str (A(erridx) (:))));
-          err.expected(end+1:end+length (erridx)) = ...
-            strtrim (cellstr (num2str (B(erridx) (:))));
-          err.reason(end+1:end+length (erridx)) = ...
-            ostrsplit (deblank (sprintf ("Abs err %.5g exceeds tol %.5g\n",...
-            [abs(A_null(erridx) - B_null(erridx))(:) mtol(erridx)(:)]')), "\n");
-        endif
-
-        k = (mtol > 0);
-        erridx = find ((abs (A_null - B_null) > mtol) & k);
-        if (! isempty (erridx))
-          err.index(end+1:end+length (erridx)) = ...
-            ind2tuple (size (A), erridx);
-          err.observed(end+1:end+length (erridx)) = ...
-            strtrim (cellstr (num2str (A(erridx) (:))));
-          err.expected(end+1:end+length (erridx)) = ...
-            strtrim (cellstr (num2str (B(erridx) (:))));
-          err.reason(end+1:end+length (erridx)) = ...
-            ostrsplit (deblank (sprintf ("Abs err %.5g exceeds tol %.5g\n",...
-            [abs(A_null(erridx) - B_null(erridx))(:) mtol(erridx)(:)]')), "\n");
-        endif
-
-        k = (mtol < 0);
-        if (any (k(:)))
-          ## Test for absolute error where relative error can't be calculated.
-          erridx = find ((B_null == 0) & abs (A_null) > abs (mtol) & k);
+          ## Check exceptional values.
+          errvec = (  isna (real (A)) != isna (real (B))
+                    | isna (imag (A)) != isna (imag (B)));
+          erridx = find (errvec);
           if (! isempty (erridx))
             err.index(end+1:end+length (erridx)) = ...
               ind2tuple (size (A), erridx);
             err.observed(end+1:end+length (erridx)) = ...
               strtrim (cellstr (num2str (A(erridx) (:))));
             err.expected(end+1:end+length (erridx)) = ...
               strtrim (cellstr (num2str (B(erridx) (:))));
             err.reason(end+1:end+length (erridx)) = ...
-              ostrsplit (deblank (sprintf ("Abs err %.5g exceeds tol %.5g\n",
-              [abs(A_null(erridx) - B_null(erridx)) -mtol(erridx)]')), "\n");
+              repmat ({"'NA' mismatch"}, length (erridx), 1);
+          endif
+          errseen = errvec;
+
+          errvec = (  isnan (real (A)) != isnan (real (B))
+                    | isnan (imag (A)) != isnan (imag (B)));
+          erridx = find (errvec & !errseen);
+          if (! isempty (erridx))
+            err.index(end+1:end+length (erridx)) = ...
+              ind2tuple (size (A), erridx);
+            err.observed(end+1:end+length (erridx)) = ...
+              strtrim (cellstr (num2str (A(erridx) (:))));
+            err.expected(end+1:end+length (erridx)) = ...
+              strtrim (cellstr (num2str (B(erridx) (:))));
+            err.reason(end+1:end+length (erridx)) = ...
+              repmat ({"'NaN' mismatch"}, length (erridx), 1);
           endif
-          ## Test for relative error
-          Bdiv = Inf (size (B_null));
-          Bdiv(k & (B_null != 0)) = B_null(k & (B_null != 0));
-          relerr = abs ((A_null - B_null) ./ abs (Bdiv));
-          erridx = find ((relerr > abs (mtol)) & k);
+          errseen |= errvec;
+
+          errvec =   ((isinf (real (A)) | isinf (real (B))) ...
+                      & (real (A) != real (B)))             ...
+                   | ((isinf (imag (A)) | isinf (imag (B))) ...
+                      & (imag (A) != imag (B)));
+          erridx = find (errvec & !errseen);
+          if (! isempty (erridx))
+            err.index(end+1:end+length (erridx)) = ...
+              ind2tuple (size (A), erridx);
+            err.observed(end+1:end+length (erridx)) = ...
+              strtrim (cellstr (num2str (A(erridx) (:))));
+            err.expected(end+1:end+length (erridx)) = ...
+              strtrim (cellstr (num2str (B(erridx) (:))));
+            err.reason(end+1:end+length (erridx)) = ...
+              repmat ({"'Inf' mismatch"}, length (erridx), 1);
+          endif
+          errseen |= errvec;
+
+          ## Check normal values.
+          ## Replace exceptional values already checked above by zero.
+          A_null_real = real (A);
+          B_null_real = real (B);
+          exclude = errseen | ! isfinite (A_null_real) & ! isfinite (B_null_real);
+          A_null_real(exclude) = 0;
+          B_null_real(exclude) = 0;
+          A_null_imag = imag (A);
+          B_null_imag = imag (B);
+          exclude = errseen | ! isfinite (A_null_imag) & ! isfinite (B_null_imag);
+          A_null_imag(exclude) = 0;
+          B_null_imag(exclude) = 0;
+          A_null = complex (A_null_real, A_null_imag);
+          B_null = complex (B_null_real, B_null_imag);
+          if (isscalar (tol))
+            mtol = tol * ones (size (A));
+          else
+            mtol = tol;
+          endif
+
+          k = (mtol == 0);
+          erridx = find ((A_null != B_null) & k);
           if (! isempty (erridx))
             err.index(end+1:end+length (erridx)) = ...
               ind2tuple (size (A), erridx);
             err.observed(end+1:end+length (erridx)) = ...
               strtrim (cellstr (num2str (A(erridx) (:))));
             err.expected(end+1:end+length (erridx)) = ...
               strtrim (cellstr (num2str (B(erridx) (:))));
             err.reason(end+1:end+length (erridx)) = ...
-              ostrsplit (deblank (sprintf ("Rel err %.5g exceeds tol %.5g\n",
-              [relerr(erridx)(:) -mtol(erridx)(:)]')), "\n");
+              ostrsplit (deblank (sprintf ("Abs err %.5g exceeds tol %.5g\n",...
+              [abs(A_null(erridx) - B_null(erridx))(:) mtol(erridx)(:)]')), "\n");
+          endif
+
+          k = (mtol > 0);
+          erridx = find ((abs (A_null - B_null) > mtol) & k);
+          if (! isempty (erridx))
+            err.index(end+1:end+length (erridx)) = ...
+              ind2tuple (size (A), erridx);
+            err.observed(end+1:end+length (erridx)) = ...
+              strtrim (cellstr (num2str (A(erridx) (:))));
+            err.expected(end+1:end+length (erridx)) = ...
+              strtrim (cellstr (num2str (B(erridx) (:))));
+            err.reason(end+1:end+length (erridx)) = ...
+              ostrsplit (deblank (sprintf ("Abs err %.5g exceeds tol %.5g\n",...
+              [abs(A_null(erridx) - B_null(erridx))(:) mtol(erridx)(:)]')), "\n");
+          endif
+
+          k = (mtol < 0);
+          if (any (k(:)))
+            ## Test for absolute error where relative error can't be calculated.
+            erridx = find ((B_null == 0) & abs (A_null) > abs (mtol) & k);
+            if (! isempty (erridx))
+              err.index(end+1:end+length (erridx)) = ...
+                ind2tuple (size (A), erridx);
+              err.observed(end+1:end+length (erridx)) = ...
+                strtrim (cellstr (num2str (A(erridx) (:))));
+              err.expected(end+1:end+length (erridx)) = ...
+                strtrim (cellstr (num2str (B(erridx) (:))));
+              err.reason(end+1:end+length (erridx)) = ...
+                ostrsplit (deblank (sprintf ("Abs err %.5g exceeds tol %.5g\n",
+                [abs(A_null(erridx) - B_null(erridx)) -mtol(erridx)]')), "\n");
+            endif
+            ## Test for relative error
+            Bdiv = Inf (size (B_null));
+            Bdiv(k & (B_null != 0)) = B_null(k & (B_null != 0));
+            relerr = abs ((A_null - B_null) ./ abs (Bdiv));
+            erridx = find ((relerr > abs (mtol)) & k);
+            if (! isempty (erridx))
+              err.index(end+1:end+length (erridx)) = ...
+                ind2tuple (size (A), erridx);
+              err.observed(end+1:end+length (erridx)) = ...
+                strtrim (cellstr (num2str (A(erridx) (:))));
+              err.expected(end+1:end+length (erridx)) = ...
+                strtrim (cellstr (num2str (B(erridx) (:))));
+              err.reason(end+1:end+length (erridx)) = ...
+                ostrsplit (deblank (sprintf ("Rel err %.5g exceeds tol %.5g\n",
+                [relerr(erridx)(:) -mtol(erridx)(:)]')), "\n");
+            endif
           endif
         endif
+
+      endif
+
+      ## Print any errors
+      if (! isempty (err.index))
+        argin = ["(" strjoin(cellstr (argn), ",") ")"];
+        if (! isempty (errmsg))
+          errmsg = [errmsg "\n"];
+        endif
+        errmsg = [errmsg, pprint(argin, err)];
       endif
 
     endif
 
-    ## Print any errors
-    if (! isempty (err.index))
-      argin = ["(" strjoin(cellstr (argn), ",") ")"];
-      if (! isempty (errmsg))
-        errmsg = [errmsg "\n"];
-      endif
-      errmsg = [errmsg, pprint(argin, err)];
-    endif
-
-  endif
-
-  call_depth--;
+  unwind_protect_cleanup
+    call_depth--;
+  end_unwind_protect
 
   if (call_depth == -1)
     ## Last time through.  If there were any errors on any pass, raise a flag.
     if (! isempty (errmsg))
       error (errmsg);
     endif
   endif
 
@@ -526,16 +542,22 @@ endfunction
 %!error <Dimensions don't match> assert (cell (1,2,3), cell (3,2,1))
 %!test
 %! x = {{{1}}, 2};  # cell with multiple levels
 %! y = x;
 %! assert (x,y);
 %! y{1}{1}{1} = 3;
 %! fail ("assert (x,y)", "Abs err 2 exceeds tol 0");
 
+## function handles
+%!assert (@sin, @sin)
+%!error <Function handles don't match> assert (@sin, @cos)
+%!error <Expected function handle, but observed double> assert (pi, @cos)
+%!error <Class function_handle != double> assert (@sin, pi)
+
 %!test
 %! x = {[3], [1,2,3]; 100+100*eps, "dog"};
 %! y = x;
 %! assert (x, y);
 %! y = x; y(1,1) = [2];
 %! fail ("assert (x, y)");
 %! y = x; y(1,2) = [0, 2, 3];
 %! fail ("assert (x, y)");
