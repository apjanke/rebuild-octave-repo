# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1444157261 14400
#      Tue Oct 06 14:47:41 2015 -0400
# Node ID bc6daa38ff5031d55b490f02bee31e68d9119854
# Parent  87b557ee8e5d2956db0417bbeb4e4fc2ce32c3e8
eliminate more simple uses of error_state

* graphics.cc: Eliminate simple uses of error_state.

diff --git a/libinterp/corefcn/graphics.cc b/libinterp/corefcn/graphics.cc
--- a/libinterp/corefcn/graphics.cc
+++ b/libinterp/corefcn/graphics.cc
@@ -857,30 +857,28 @@ convert_cdata (const base_properties& pr
 
   graphics_object go = gh_manager::get_object (props.get___myhandle__ ());
   graphics_object fig = go.get_ancestor ("figure");
 
   if (fig.valid_object ())
     {
       Matrix _cmap = fig.get (caseless_str ("colormap")).matrix_value ();
 
-      if (! error_state)
-        cmap = _cmap;
+      cmap = _cmap;
     }
 
   if (is_scaled)
     {
       graphics_object ax = go.get_ancestor ("axes");
 
       if (ax.valid_object ())
         {
           Matrix _clim = ax.get (caseless_str ("clim")).matrix_value ();
 
-          if (! error_state)
-            clim = _clim;
+          clim = _clim;
         }
     }
 
   dv.resize (cdim);
   dv(cdim-1) = 3;
 
   NDArray a (dv);
 
@@ -1088,38 +1086,33 @@ base_property::set (const octave_value& 
       if (id >= 0 && do_notify_toolkit)
         {
           graphics_object go = gh_manager::get_object (parent);
           if (go)
             go.update (id);
         }
 
       // run listeners
-      if (do_run && ! error_state)
+      if (do_run)
         run_listeners (POSTSET);
 
       return true;
     }
 
   return false;
 }
 
 
 void
 base_property::run_listeners (listener_mode mode)
 {
   const octave_value_list& l = listeners[mode];
 
   for (int i = 0; i < l.length (); i++)
-    {
-      gh_manager::execute_listener (parent, l(i));
-
-      if (error_state)
-        break;
-    }
+    gh_manager::execute_listener (parent, l(i));
 }
 
 radio_values::radio_values (const std::string& opt_string)
   : default_val (), possible_vals ()
 {
   size_t beg = 0;
   size_t len = opt_string.length ();
   bool done = len == 0;
@@ -1256,16 +1249,17 @@ color_property::do_set (const octave_val
                   current_val = match;
                   current_type = radio_t;
                   return true;
                 }
             }
           else
             {
               color_values col (s);
+
               if (! error_state)
                 {
                   if (current_type != color_t || col != color_val)
                     {
                       color_val = col;
                       current_type = color_t;
                       return true;
                     }
@@ -1281,24 +1275,22 @@ color_property::do_set (const octave_val
     }
   else if (val.is_numeric_type ())
     {
       Matrix m = val.matrix_value ();
 
       if (m.numel () == 3)
         {
           color_values col (m(0), m(1), m(2));
-          if (! error_state)
-            {
-              if (current_type != color_t || col != color_val)
-                {
-                  color_val = col;
-                  current_type = color_t;
-                  return true;
-                }
+
+          if (current_type != color_t || col != color_val)
+            {
+              color_val = col;
+              current_type = color_t;
+              return true;
             }
         }
       else
         error ("invalid value for color property \"%s\"",
                get_name ().c_str ());
     }
   else
     error ("invalid value for color property \"%s\"",
@@ -1661,18 +1653,17 @@ property::create (const std::string& nam
                   const caseless_str& type, const octave_value_list& args)
 {
   property retval;
 
   if (type.compare ("string"))
     {
       std::string sv = (args.length () > 0 ? args(0).string_value () : "");
 
-      if (! error_state)
-        retval = property (new string_property (name, h, sv));
+      retval = property (new string_property (name, h, sv));
     }
   else if (type.compare ("any"))
     {
       octave_value ov = args.length () > 0 ? args(0)
                                            : octave_value (Matrix ());
 
       retval = property (new any_property (name, h, ov));
     }
@@ -1694,29 +1685,25 @@ property::create (const std::string& nam
           else
             error ("addproperty: invalid argument for radio property, expected a string value");
         }
     }
   else if (type.compare ("double"))
     {
       double dv = (args.length () > 0 ? args(0).double_value () : 0.0);
 
-      if (! error_state)
-        retval = property (new double_property (name, h, dv));
+      retval = property (new double_property (name, h, dv));
     }
   else if (type.compare ("handle"))
     {
       double hv = (args.length () > 0 ? args(0).double_value () : octave_NaN);
 
-      if (! error_state)
-        {
-          graphics_handle gh (hv);
-
-          retval = property (new handle_property (name, h, gh));
-        }
+      graphics_handle gh (hv);
+
+      retval = property (new handle_property (name, h, gh));
     }
   else if (type.compare ("boolean"))
     {
       retval = property (new bool_property (name, h, false));
 
       if (args.length () > 0)
         retval.set (args(0));
     }
@@ -1734,28 +1721,22 @@ property::create (const std::string& nam
   else if (type.compare ("color"))
     {
       color_values cv (0, 0, 0);
       radio_values rv;
 
       if (args.length () > 1)
         rv = radio_values (args(1).string_value ());
 
-      if (! error_state)
-        {
-          retval = property (new color_property (name, h, cv, rv));
-
-          if (! error_state)
-            {
-              if (args.length () > 0 && ! args(0).is_empty ())
-                retval.set (args(0));
-              else
-                retval.set (rv.default_value ());
-            }
-        }
+      retval = property (new color_property (name, h, cv, rv));
+
+      if (args.length () > 0 && ! args(0).is_empty ())
+        retval.set (args(0));
+      else
+        retval.set (rv.default_value ());
     }
   else
     {
       caseless_str go_name, go_rest;
 
       if (lookup_object_name (type, go_name, go_rest))
         {
           graphics_object go;
@@ -1777,26 +1758,23 @@ property::create (const std::string& nam
             }
           else
             go = it->second;
 
           if (go.valid_object ())
             {
               property prop = go.get_properties ().get_property (go_rest);
 
-              if (! error_state)
-                {
-                  retval = prop.clone ();
-
-                  retval.set_parent (h);
-                  retval.set_name (name);
-
-                  if (args.length () > 0)
-                    retval.set (args(0));
-                }
+              retval = prop.clone ();
+
+              retval.set_parent (h);
+              retval.set_name (name);
+
+              if (args.length () > 0)
+                retval.set (args(0));
             }
           else
             error ("addproperty: invalid object type (= %s)",
                    go_name.c_str ());
         }
       else
         error ("addproperty: unsupported type for dynamic property (= %s)",
                type.c_str ());
@@ -1851,70 +1829,67 @@ figure::properties::set_toolkit (const g
     initialize_r (get___myhandle__ ());
 
   mark_modified ();
 }
 
 void
 figure::properties::set___mouse_mode__ (const octave_value& val_arg)
 {
-  if (! error_state)
-    {
-      std::string direction = "in";
-
-      octave_value val = val_arg;
-
-      if (val.is_string ())
-        {
-          std::string modestr = val.string_value ();
-
-          if (modestr == "zoom in")
-            {
-              val = modestr = "zoom";
-              direction = "in";
-            }
-          else if (modestr == "zoom out")
-            {
-              val = modestr = "zoom";
-              direction = "out";
-            }
-
-          if (__mouse_mode__.set (val, true))
-            {
-              std::string mode = __mouse_mode__.current_value ();
-
-              octave_scalar_map pm = get___pan_mode__ ().scalar_map_value ();
-              pm.setfield ("Enable", mode == "pan" ? "on" : "off");
-              set___pan_mode__ (pm);
-
-              octave_scalar_map rm = get___rotate_mode__ ().scalar_map_value ();
-              rm.setfield ("Enable", mode == "rotate" ? "on" : "off");
-              set___rotate_mode__ (rm);
-
-              octave_scalar_map zm = get___zoom_mode__ ().scalar_map_value ();
-              zm.setfield ("Enable", mode == "zoom" ? "on" : "off");
+  std::string direction = "in";
+
+  octave_value val = val_arg;
+
+  if (val.is_string ())
+    {
+      std::string modestr = val.string_value ();
+
+      if (modestr == "zoom in")
+        {
+          val = modestr = "zoom";
+          direction = "in";
+        }
+      else if (modestr == "zoom out")
+        {
+          val = modestr = "zoom";
+          direction = "out";
+        }
+
+      if (__mouse_mode__.set (val, true))
+        {
+          std::string mode = __mouse_mode__.current_value ();
+
+          octave_scalar_map pm = get___pan_mode__ ().scalar_map_value ();
+          pm.setfield ("Enable", mode == "pan" ? "on" : "off");
+          set___pan_mode__ (pm);
+
+          octave_scalar_map rm = get___rotate_mode__ ().scalar_map_value ();
+          rm.setfield ("Enable", mode == "rotate" ? "on" : "off");
+          set___rotate_mode__ (rm);
+
+          octave_scalar_map zm = get___zoom_mode__ ().scalar_map_value ();
+          zm.setfield ("Enable", mode == "zoom" ? "on" : "off");
+          zm.setfield ("Direction", direction);
+          set___zoom_mode__ (zm);
+
+          mark_modified ();
+        }
+      else if (modestr == "zoom")
+        {
+          octave_scalar_map zm = get___zoom_mode__ ().scalar_map_value ();
+          std::string curr_direction
+            = zm.getfield ("Direction").string_value ();
+
+          if (direction != curr_direction)
+            {
               zm.setfield ("Direction", direction);
               set___zoom_mode__ (zm);
 
               mark_modified ();
             }
-          else if (modestr == "zoom")
-            {
-              octave_scalar_map zm = get___zoom_mode__ ().scalar_map_value ();
-              std::string curr_direction
-                = zm.getfield ("Direction").string_value ();
-
-              if (direction != curr_direction)
-                {
-                  zm.setfield ("Direction", direction);
-                  set___zoom_mode__ (zm);
-
-                  mark_modified ();
-                }
-            }
         }
     }
 }
 
 // ---------------------------------------------------------------------
 
 void
 property_list::set (const caseless_str& name, const octave_value& val)
@@ -2044,17 +2019,17 @@ property_list::set (const caseless_str& 
               else
                 pval_map[pname] = val;
             }
           else
             error ("invalid %s property '%s'", pfx.c_str (), pname.c_str ());
         }
     }
 
-  if (! error_state && offset == 0)
+  if (offset == 0)
     error ("invalid default property specification");
 }
 
 octave_value
 property_list::lookup (const caseless_str& name) const
 {
   octave_value retval;
 
@@ -2183,19 +2158,16 @@ graphics_object::set (const octave_value
         {
           caseless_str pname = args(i).string_value ();
 
           if (! error_state)
             {
               octave_value val = args(i+1);
 
               set_value_or_default (pname, val);
-
-              if (error_state)
-                break;
             }
           else
             error ("set: expecting argument %d to be a property name", i);
         }
     }
 }
 
 /*
@@ -2225,19 +2197,16 @@ graphics_object::set (const Array<std::s
   octave_idx_type k = pnames.columns ();
 
   for (octave_idx_type column = 0; column < k; column++)
     {
       caseless_str pname = pnames(column);
       octave_value val  = values(row, column);
 
       set_value_or_default (pname, val);
-
-      if (error_state)
-        break;
     }
 }
 
 /*
 ## test set with cell array arguments
 %!test
 %! hf = figure ("visible", "off");
 %! h = plot (1:10, 10:-1:1);
@@ -2290,19 +2259,16 @@ graphics_object::set (const octave_map& 
     {
       // FIXME: Would it be better to extract all the keys at once rather than
       //        repeatedly call keys() inside a for loop?
       caseless_str pname = m.keys ()[p];
 
       octave_value val = octave_value (m.contents (pname).elem (m.numel () - 1));
 
       set_value_or_default (pname, val);
-
-      if (error_state)
-        break;
     }
 }
 
 /*
 ## test set ticklabels for compatibility
 %!test
 %! hf = figure ("visible", "off");
 %! set (gca (), "xticklabel", [0, 0.2, 0.4, 0.6, 0.8, 1]);
@@ -2393,28 +2359,22 @@ graphics_object::set_value_or_default (c
       std::string sval = val.string_value ();
 
       octave_value default_val;
 
       if (sval.compare ("default") == 0)
         {
           default_val = get_default (pname);
 
-          if (error_state)
-            return;
-
           rep->set (pname, default_val);
         }
       else if (sval.compare ("factory") == 0)
         {
           default_val = get_factory_default (pname);
 
-          if (error_state)
-            return;
-
           rep->set (pname, default_val);
         }
       else
         {
           // Matlab specifically uses "\default" to escape string setting
           if (sval.compare ("\\default") == 0)
             rep->set (pname, "default");
           else if (sval.compare ("\\factory") == 0)
@@ -2789,25 +2749,22 @@ is_handle (const octave_value& val)
   octave_value retval = false;
 
   if (val.is_real_scalar () && is_handle (val.double_value ()))
     retval = true;
   else if (val.is_numeric_type () && val.is_real_type ())
     {
       const NDArray handles = val.array_value ();
 
-      if (! error_state)
-        {
-          boolNDArray result (handles.dims ());
-
-          for (octave_idx_type i = 0; i < handles.numel (); i++)
-            result.xelem (i) = is_handle (handles(i));
-
-          retval = result;
-        }
+      boolNDArray result (handles.dims ());
+
+      for (octave_idx_type i = 0; i < handles.numel (); i++)
+        result.xelem (i) = is_handle (handles(i));
+
+      retval = result;
     }
 
   return retval;
 }
 
 static bool
 is_figure (double val)
 {
@@ -3000,22 +2957,19 @@ base_properties::set_dynamic (const case
   std::map<caseless_str, property, cmp_caseless_str>::iterator it =
     all_props.find (pname);
 
   if (it != all_props.end ())
     it->second.set (val);
   else
     error ("set: unknown property \"%s\"", pname.c_str ());
 
-  if (! error_state)
-    {
-      dynamic_properties.insert (pname);
-
-      mark_modified ();
-    }
+  dynamic_properties.insert (pname);
+
+  mark_modified ();
 }
 
 property
 base_properties::get_property_dynamic (const caseless_str& pname)
 {
   std::map<caseless_str, property, cmp_caseless_str>::const_iterator it =
     all_props.find (pname);
 
@@ -3184,28 +3138,28 @@ base_properties::update_autopos (const s
 
 void
 base_properties::add_listener (const caseless_str& pname,
                                const octave_value& val,
                                listener_mode mode)
 {
   property p = get_property (pname);
 
-  if (! error_state && p.ok ())
+  if (p.ok ())
     p.add_listener (val, mode);
 }
 
 void
 base_properties::delete_listener (const caseless_str& pname,
                                   const octave_value& val,
                                   listener_mode mode)
 {
   property p = get_property (pname);
 
-  if (! error_state && p.ok ())
+  if (p.ok ())
     p.delete_listener (val, mode);
 }
 
 // ---------------------------------------------------------------------
 
 void
 base_graphics_object::update_axis_limits (const std::string& axis_type)
 {
@@ -3243,28 +3197,27 @@ base_graphics_object::remove_all_listene
   for (octave_map::const_iterator pa = m.begin (); pa != m.end (); pa++)
     {
       // FIXME: there has to be a better way.  I think we want to
       // ask whether it is OK to delete the listener for the given
       // property.  How can we know in advance that it will be OK?
 
       unwind_protect frame;
 
-      frame.protect_var (error_state);
       frame.protect_var (discard_error_messages);
       frame.protect_var (Vdebug_on_error);
       frame.protect_var (Vdebug_on_warning);
 
       discard_error_messages = true;
       Vdebug_on_error = false;
       Vdebug_on_warning = false;
 
       property p = get_properties ().get_property (pa->first);
 
-      if (! error_state && p.ok ())
+      if (p.ok ())
         p.delete_listener ();
     }
 }
 
 void
 base_graphics_object::build_user_defaults_map (property_list::pval_map_type &def, const std::string go_name) const
 {
   property_list local_defaults = get_defaults_list ();
@@ -3439,19 +3392,16 @@ graphics_object::get_ancestor (const std
 
 // ---------------------------------------------------------------------
 
 void
 root_figure::properties::set_callbackobject (const octave_value& v)
 {
   graphics_handle val (v);
 
-  if (error_state)
-    return;
-
   if (xisnan (val.value ()))
     {
       if (! cbo_stack.empty ())
         {
           val = cbo_stack.front ();
 
           cbo_stack.pop_front ();
         }
@@ -3469,71 +3419,65 @@ root_figure::properties::set_callbackobj
     gripe_set_invalid ("callbackobject");
 }
 
 void
 root_figure::properties::set_currentfigure (const octave_value& v)
 {
   graphics_handle val (v);
 
-  if (error_state)
-    return;
-
   if (xisnan (val.value ()) || is_handle (val))
     {
       currentfigure = val;
 
       if (val.ok ())
         gh_manager::push_figure (val);
     }
   else
     gripe_set_invalid ("currentfigure");
 }
 
 void
 figure::properties::set_integerhandle (const octave_value& val)
 {
-  if (! error_state)
-    {
-      if (integerhandle.set (val, true))
-        {
-          bool int_fig_handle = integerhandle.is_on ();
-
-          graphics_object this_go = gh_manager::get_object (__myhandle__);
-
-          graphics_handle old_myhandle = __myhandle__;
-
-          __myhandle__ = gh_manager::get_handle (int_fig_handle);
-
-          gh_manager::renumber_figure (old_myhandle, __myhandle__);
-
-          graphics_object parent_go = gh_manager::get_object (get_parent ());
-
-          base_properties& props = parent_go.get_properties ();
-
-          props.renumber_child (old_myhandle, __myhandle__);
-
-          Matrix kids = get_children ();
-
-          for (octave_idx_type i = 0; i < kids.numel (); i++)
-            {
-              graphics_object kid = gh_manager::get_object (kids(i));
-
-              kid.get_properties ().renumber_parent (__myhandle__);
-            }
-
-          graphics_handle cf = gh_manager::current_figure ();
-
-          if (__myhandle__ == cf)
-            xset (0, "currentfigure", __myhandle__.value ());
-
-          this_go.update (integerhandle.get_id ());
-
-          mark_modified ();
-        }
+  if (integerhandle.set (val, true))
+    {
+      bool int_fig_handle = integerhandle.is_on ();
+
+      graphics_object this_go = gh_manager::get_object (__myhandle__);
+
+      graphics_handle old_myhandle = __myhandle__;
+
+      __myhandle__ = gh_manager::get_handle (int_fig_handle);
+
+      gh_manager::renumber_figure (old_myhandle, __myhandle__);
+
+      graphics_object parent_go = gh_manager::get_object (get_parent ());
+
+      base_properties& props = parent_go.get_properties ();
+
+      props.renumber_child (old_myhandle, __myhandle__);
+
+      Matrix kids = get_children ();
+
+      for (octave_idx_type i = 0; i < kids.numel (); i++)
+        {
+          graphics_object kid = gh_manager::get_object (kids(i));
+
+          kid.get_properties ().renumber_parent (__myhandle__);
+        }
+
+      graphics_handle cf = gh_manager::current_figure ();
+
+      if (__myhandle__ == cf)
+        xset (0, "currentfigure", __myhandle__.value ());
+
+      this_go.update (integerhandle.get_id ());
+
+      mark_modified ();
     }
 }
 
 // FIXME: This should update monitorpositions and pointerlocation, but as these
 // properties aren't yet used, it doesn't matter that they aren't set either.
 void
 root_figure::properties::update_units (void)
 {
@@ -3635,19 +3579,16 @@ root_figure::reset_default_properties (v
 
 // ---------------------------------------------------------------------
 
 void
 figure::properties::set_currentaxes (const octave_value& val)
 {
   graphics_handle hax (val);
 
-  if (error_state)
-    return;
-
   if (xisnan (hax.value ()) || is_handle (hax))
     currentaxes = hax;
   else
     gripe_set_invalid ("currentaxes");
 }
 
 void
 figure::properties::remove_child (const graphics_handle& h)
@@ -3709,23 +3650,20 @@ figure::properties::adopt (const graphic
 %! end_unwind_protect
 */
 
 void
 figure::properties::set_visible (const octave_value& val)
 {
   std::string sval = val.string_value ();
 
-  if (! error_state)
-    {
-      if (sval == "on")
-        xset (0, "currentfigure", __myhandle__.value ());
-
-      visible = val;
-    }
+  if (sval == "on")
+    xset (0, "currentfigure", __myhandle__.value ());
+
+  visible = val;
 }
 
 Matrix
 figure::properties::get_boundingbox (bool internal, const Matrix&) const
 {
   Matrix screen_size = screen_size_pixels ();
   Matrix pos = (internal ?
                 get_position ().matrix_value () :
@@ -3791,101 +3729,83 @@ figure::properties::map_to_boundingbox (
 
   return pos;
 }
 
 void
 figure::properties::set_position (const octave_value& v,
                                   bool do_notify_toolkit)
 {
-  if (! error_state)
-    {
-      Matrix old_bb, new_bb;
-      bool modified = false;
-
-      old_bb = get_boundingbox (true);
-      modified = position.set (v, false, do_notify_toolkit);
-      new_bb = get_boundingbox (true);
-
-      if (old_bb != new_bb)
-        {
-          if (old_bb(2) != new_bb(2) || old_bb(3) != new_bb(3))
-            {
-              execute_resizefcn ();
-              update_boundingbox ();
-            }
-        }
-
-      if (modified)
-        {
-          position.run_listeners (POSTSET);
-          mark_modified ();
-        }
-
-      if (paperpositionmode.is ("auto"))
-        paperposition.set (get_auto_paperposition ());
-    }
+  Matrix old_bb, new_bb;
+  bool modified = false;
+
+  old_bb = get_boundingbox (true);
+  modified = position.set (v, false, do_notify_toolkit);
+  new_bb = get_boundingbox (true);
+
+  if (old_bb != new_bb)
+    {
+      if (old_bb(2) != new_bb(2) || old_bb(3) != new_bb(3))
+        {
+          execute_resizefcn ();
+          update_boundingbox ();
+        }
+    }
+
+  if (modified)
+    {
+      position.run_listeners (POSTSET);
+      mark_modified ();
+    }
+
+  if (paperpositionmode.is ("auto"))
+    paperposition.set (get_auto_paperposition ());
 }
 
 void
 figure::properties::set_outerposition (const octave_value& v,
                                        bool do_notify_toolkit)
 {
-  if (! error_state)
-    {
-      if (outerposition.set (v, true, do_notify_toolkit))
-        {
-          mark_modified ();
-        }
-    }
+  if (outerposition.set (v, true, do_notify_toolkit))
+    mark_modified ();
 }
 
 void
 figure::properties::set_paperunits (const octave_value& val)
 {
-  if (! error_state)
-    {
-      caseless_str punits = val.string_value ();
-      caseless_str ptype = get_papertype ();
-      if (! error_state)
-        {
-          if (punits.compare ("normalized") && ptype.compare ("<custom>"))
-            error ("set: can't set paperunits to normalized when papertype is custom");
-          else
-            {
-              caseless_str old_paperunits = get_paperunits ();
-              if (paperunits.set (val, true))
-                {
-                  update_paperunits (old_paperunits);
-                  mark_modified ();
-                }
-            }
+  caseless_str punits = val.string_value ();
+  caseless_str ptype = get_papertype ();
+
+  if (punits.compare ("normalized") && ptype.compare ("<custom>"))
+    error ("set: can't set paperunits to normalized when papertype is custom");
+  else
+    {
+      caseless_str old_paperunits = get_paperunits ();
+      if (paperunits.set (val, true))
+        {
+          update_paperunits (old_paperunits);
+          mark_modified ();
         }
     }
 }
 
 void
 figure::properties::set_papertype (const octave_value& val)
 {
-  if (! error_state)
-    {
-      caseless_str ptype = val.string_value ();
-      caseless_str punits = get_paperunits ();
-      if (! error_state)
-        {
-          if (punits.compare ("normalized") && ptype.compare ("<custom>"))
-            error ("set: can't set paperunits to normalized when papertype is custom");
-          else
-            {
-              if (papertype.set (val, true))
-                {
-                  update_papertype ();
-                  mark_modified ();
-                }
-            }
+  caseless_str ptype = val.string_value ();
+  caseless_str punits = get_paperunits ();
+
+  if (punits.compare ("normalized") && ptype.compare ("<custom>"))
+    error ("set: can't set paperunits to normalized when papertype is custom");
+  else
+    {
+      if (papertype.set (val, true))
+        {
+          update_papertype ();
+          mark_modified ();
         }
     }
 }
 
 static Matrix
 papersize_from_type (const caseless_str punits, const caseless_str ptype)
 {
   Matrix retval (1, 2, 1.0);
@@ -4445,24 +4365,22 @@ figure::properties::update_paperorientat
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
 */
 
 void
 figure::properties::set_units (const octave_value& val)
 {
-  if (! error_state)
-    {
-      caseless_str old_units = get_units ();
-      if (units.set (val, true))
-        {
-          update_units (old_units);
-          mark_modified ();
-        }
+  caseless_str old_units = get_units ();
+
+  if (units.set (val, true))
+    {
+      update_units (old_units);
+      mark_modified ();
     }
 }
 
 void
 figure::properties::update_units (const caseless_str& old_units)
 {
   position.set (convert_position (get_position ().matrix_value (), old_units,
                                   get_units (), screen_size_pixels ()), false);
@@ -4769,28 +4687,25 @@ axes::properties::set_text_child (handle
   else
     {
       std::string cname = v.class_name ();
 
       error ("set: expecting text graphics object or character string for %s property, found %s",
              who.c_str (), cname.c_str ());
     }
 
-  if (! error_state)
-    {
-      xset (val, "handlevisibility", "off");
-
-      gh_manager::free (hp.handle_value ());
-
-      base_properties::remove_child (hp.handle_value ());
-
-      hp = val;
-
-      adopt (hp.handle_value ());
-    }
+  xset (val, "handlevisibility", "off");
+
+  gh_manager::free (hp.handle_value ());
+
+  base_properties::remove_child (hp.handle_value ());
+
+  hp = val;
+
+  adopt (hp.handle_value ());
 }
 
 void
 axes::properties::set_xlabel (const octave_value& v)
 {
   set_text_child (xlabel, "xlabel", v);
   xset (xlabel.handle_value (), "positionmode", "auto");
   xset (xlabel.handle_value (), "rotationmode", "auto");
@@ -6454,65 +6369,56 @@ convert_ticklabel_string (const octave_v
     }
 
   return retval;
 }
 
 void
 axes::properties::set_xticklabel (const octave_value& val)
 {
-  if (! error_state)
-    {
-      if (xticklabel.set (convert_ticklabel_string (val), false))
-        {
-          set_xticklabelmode ("manual");
-          xticklabel.run_listeners (POSTSET);
-          mark_modified ();
-        }
-      else
-        set_xticklabelmode ("manual");
-
-      sync_positions ();
-    }
+  if (xticklabel.set (convert_ticklabel_string (val), false))
+    {
+      set_xticklabelmode ("manual");
+      xticklabel.run_listeners (POSTSET);
+      mark_modified ();
+    }
+  else
+    set_xticklabelmode ("manual");
+
+  sync_positions ();
 }
 
 void
 axes::properties::set_yticklabel (const octave_value& val)
 {
-  if (! error_state)
-    {
-      if (yticklabel.set (convert_ticklabel_string (val), false))
-        {
-          set_yticklabelmode ("manual");
-          yticklabel.run_listeners (POSTSET);
-          mark_modified ();
-        }
-      else
-        set_yticklabelmode ("manual");
-
-      sync_positions ();
-    }
+  if (yticklabel.set (convert_ticklabel_string (val), false))
+    {
+      set_yticklabelmode ("manual");
+      yticklabel.run_listeners (POSTSET);
+      mark_modified ();
+    }
+  else
+    set_yticklabelmode ("manual");
+
+  sync_positions ();
 }
 
 void
 axes::properties::set_zticklabel (const octave_value& val)
 {
-  if (! error_state)
-    {
-      if (zticklabel.set (convert_ticklabel_string (val), false))
-        {
-          set_zticklabelmode ("manual");
-          zticklabel.run_listeners (POSTSET);
-          mark_modified ();
-        }
-      else
-        set_zticklabelmode ("manual");
-
-      sync_positions ();
-    }
+  if (zticklabel.set (convert_ticklabel_string (val), false))
+    {
+      set_zticklabelmode ("manual");
+      zticklabel.run_listeners (POSTSET);
+      mark_modified ();
+    }
+  else
+    set_zticklabelmode ("manual");
+
+  sync_positions ();
 }
 
 // Almost identical to convert_ticklabel_string but it only accepts
 // cellstr or string, not numeric input.
 static octave_value
 convert_linestyleorder_string (const octave_value& val)
 {
   octave_value retval = val;
@@ -6549,33 +6455,28 @@ convert_linestyleorder_string (const oct
     }
 
   return retval;
 }
 
 void
 axes::properties::set_linestyleorder (const octave_value& val)
 {
-  if (! error_state)
-    {
-      linestyleorder.set (convert_linestyleorder_string (val), false);
-    }
+  linestyleorder.set (convert_linestyleorder_string (val), false);
 }
 
 void
 axes::properties::set_units (const octave_value& val)
 {
-  if (! error_state)
-    {
-      caseless_str old_units = get_units ();
-      if (units.set (val, true))
-        {
-          update_units (old_units);
-          mark_modified ();
-        }
+  caseless_str old_units = get_units ();
+
+  if (units.set (val, true))
+    {
+      update_units (old_units);
+      mark_modified ();
     }
 }
 
 void
 axes::properties::update_units (const caseless_str& old_units)
 {
   graphics_object parent_go = gh_manager::get_object (get_parent ());
   Matrix parent_bb
@@ -6597,24 +6498,22 @@ axes::properties::update_units (const ca
                                                 old_units, new_units,
                                                 parent_bb)),
                                                 false);
 }
 
 void
 axes::properties::set_fontunits (const octave_value& val)
 {
-  if (! error_state)
-    {
-      caseless_str old_fontunits = get_fontunits ();
-      if (fontunits.set (val, true))
-        {
-          update_fontunits (old_fontunits);
-          mark_modified ();
-        }
+  caseless_str old_fontunits = get_fontunits ();
+
+  if (fontunits.set (val, true))
+    {
+      update_fontunits (old_fontunits);
+      mark_modified ();
     }
 }
 
 void
 axes::properties::update_fontunits (const caseless_str& old_units)
 {
   caseless_str new_units = get_fontunits ();
   double parent_height = get_boundingbox (true).elem (3);
@@ -6721,17 +6620,17 @@ static void
 check_limit_vals (double& min_val, double& max_val,
                   double& min_pos, double& max_neg,
                   const octave_value& data)
 {
   if (data.is_matrix_type ())
     {
       Matrix m = data.matrix_value ();
 
-      if (! error_state && m.numel () == 4)
+      if (m.numel () == 4)
         {
           double val;
 
           val = m(0);
           if (xfinite (val) && val < min_val)
             min_val = val;
 
           val = m(1);
@@ -8027,24 +7926,22 @@ text::properties::get_extent (void) cons
   m(1) += p(1);
 
   return convert_text_position (m, *this, "pixels", get_units ());
 }
 
 void
 text::properties::set_fontunits (const octave_value& val)
 {
-  if (! error_state)
-    {
-      caseless_str old_fontunits = get_fontunits ();
-      if (fontunits.set (val, true))
-        {
-          update_fontunits (old_fontunits);
-          mark_modified ();
-        }
+  caseless_str old_fontunits = get_fontunits ();
+
+  if (fontunits.set (val, true))
+    {
+      update_fontunits (old_fontunits);
+      mark_modified ();
     }
 }
 
 void
 text::properties::update_fontunits (const caseless_str& old_units)
 {
   caseless_str new_units = get_fontunits ();
   double parent_height = 0;
@@ -8880,24 +8777,22 @@ uicontrol::properties::get_boundingbox (
   pos(1) = parent_size(1) - pos(1) - pos(3);
 
   return pos;
 }
 
 void
 uicontrol::properties::set_fontunits (const octave_value& val)
 {
-  if (! error_state)
-    {
-      caseless_str old_fontunits = get_fontunits ();
-      if (fontunits.set (val, true))
-        {
-          update_fontunits (old_fontunits);
-          mark_modified ();
-        }
+  caseless_str old_fontunits = get_fontunits ();
+
+  if (fontunits.set (val, true))
+    {
+      update_fontunits (old_fontunits);
+      mark_modified ();
     }
 }
 
 void
 uicontrol::properties::update_fontunits (const caseless_str& old_units)
 {
   caseless_str new_units = get_fontunits ();
   double parent_height = get_boundingbox (false).elem (3);
@@ -8989,24 +8884,22 @@ uipanel::properties::get_boundingbox (bo
     }
 
   return pos;
 }
 
 void
 uipanel::properties::set_units (const octave_value& val)
 {
-  if (! error_state)
-    {
-      caseless_str old_units = get_units ();
-      if (units.set (val, true))
-        {
-          update_units (old_units);
-          mark_modified ();
-        }
+  caseless_str old_units = get_units ();
+
+  if (units.set (val, true))
+    {
+      update_units (old_units);
+      mark_modified ();
     }
 }
 
 void
 uipanel::properties::update_units (const caseless_str& old_units)
 {
   Matrix pos = get_position ().matrix_value ();
 
@@ -9016,24 +8909,22 @@ uipanel::properties::update_units (const
 
   pos = convert_position (pos, old_units, get_units (), parent_size);
   set_position (pos);
 }
 
 void
 uipanel::properties::set_fontunits (const octave_value& val)
 {
-  if (! error_state)
-    {
-      caseless_str old_fontunits = get_fontunits ();
-      if (fontunits.set (val, true))
-        {
-          update_fontunits (old_fontunits);
-          mark_modified ();
-        }
+  caseless_str old_fontunits = get_fontunits ();
+
+  if (fontunits.set (val, true))
+    {
+      update_fontunits (old_fontunits);
+      mark_modified ();
     }
 }
 
 void
 uipanel::properties::update_fontunits (const caseless_str& old_units)
 {
   caseless_str new_units = get_fontunits ();
   double parent_height = get_boundingbox (false).elem (3);
@@ -9455,30 +9346,28 @@ gh_manager::do_execute_callback (const g
       else if (cb.is_cell () && cb.length () > 0
                && (cb.rows () == 1 || cb.columns () == 1)
                && (cb.cell_value ()(0).is_function ()
                    || cb.cell_value ()(0).is_function_handle ()))
         {
           Cell c = cb.cell_value ();
 
           fcn = c(0).function_value ();
-          if (! error_state)
-            {
-              for (int i = 1; i < c.numel () ; i++)
-                args(1+i) = c(i);
-            }
+
+          for (int i = 1; i < c.numel () ; i++)
+            args(1+i) = c(i);
         }
       else
         {
           std::string nm = cb.class_name ();
           error ("trying to execute non-executable object (class = %s)",
                  nm.c_str ());
         }
 
-      if (fcn && ! error_state)
+      if (fcn)
         feval (fcn, args);
 
       END_INTERRUPT_WITH_EXCEPTIONS;
     }
 }
 
 void
 gh_manager::do_post_event (const graphics_event& e)
@@ -9699,25 +9588,22 @@ is_handle_visible (const octave_value& v
   octave_value retval = false;
 
   if (val.is_real_scalar () && is_handle_visible (val.double_value ()))
     retval = true;
   else if (val.is_numeric_type () && val.is_real_type ())
     {
       const NDArray handles = val.array_value ();
 
-      if (! error_state)
-        {
-          boolNDArray result (handles.dims ());
-
-          for (octave_idx_type i = 0; i < handles.numel (); i++)
-            result.xelem (i) = is_handle_visible (handles(i));
-
-          retval = result;
-        }
+      boolNDArray result (handles.dims ());
+
+      for (octave_idx_type i = 0; i < handles.numel (); i++)
+        result.xelem (i) = is_handle_visible (handles(i));
+
+      retval = result;
     }
 
   return retval;
 }
 
 DEFUN (__is_handle_visible__, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} __is_handle_visible__ (@var{h})\n\
@@ -9753,25 +9639,21 @@ each individual object will be reset.\n\
 
   if (nargin != 1)
     print_usage ();
   else
     {
       // get vector of graphics handles
       ColumnVector hcv (args(0).vector_value ());
 
-      if (! error_state)
-        {
-          // loop over graphics objects
-          for (octave_idx_type n = 0; n < hcv.numel (); n++)
-            gh_manager::get_object (hcv(n)).reset_default_properties ();
-
-          if (! error_state)
-            Fdrawnow ();
-        }
+      // loop over graphics objects
+      for (octave_idx_type n = 0; n < hcv.numel (); n++)
+        gh_manager::get_object (hcv(n)).reset_default_properties ();
+
+      Fdrawnow ();
     }
 
   return octave_value ();
 }
 
 /*
 
 %!test  # line object
@@ -10021,56 +9903,53 @@ being @qcode{\"portrait\"}.\n\
                                         <<" is read-only" << std::endl;
                       else if (pmap.isfield (property))
                         {
                           if (nargout != 0)
                             retval = pmap.getfield (property)(0);
                           else
                             {
                               std::string s = go.value_as_string (property);
-                              if (! error_state)
-                                octave_stdout << s;
+
+                              octave_stdout << s;
                             }
                         }
                       else
                         {
                           error ("set: unknown property");
                           break;
                         }
                     }
                   else if (nargin == 1)
                     {
                       if (nargout != 0)
                         retval = go.values_as_struct ();
                       else
                         {
                           std::string s = go.values_as_string ();
-                          if (! error_state)
-                            octave_stdout << s;
+
+                          octave_stdout << s;
                         }
                     }
                   else
                     {
                       go.set (args.splice (0, 1));
                       request_drawnow = true;
                     }
                 }
               else
                 {
                   error ("set: invalid handle (= %g)", hcv(n));
                   break;
                 }
 
-              if (error_state)
-                break;
-
               request_drawnow = true;
             }
 
-          if (! error_state && request_drawnow)
+          if (request_drawnow)
             Vdrawnow_requested = true;
         }
       else
         error ("set: expecting graphics handle as first argument");
     }
   else
     print_usage ();
 
@@ -10129,141 +10008,123 @@ lists respectively.\n\
       if (! error_state)
         {
           octave_idx_type len = hcv.numel ();
 
           if (nargin == 1 && len > 1)
             {
               std::string typ0 = get_graphics_object_type (hcv(0));
 
+              for (octave_idx_type n = 1; n < len; n++)
+                {
+                  std::string typ = get_graphics_object_type (hcv(n));
+
+                  if (typ != typ0)
+                    {
+                      error ("get: vector of handles must all have same type");
+                      break;
+                    }
+                }
+            }
+
+          if (nargin > 1 && args(1).is_cellstr ())
+            {
+              Array<std::string> plist = args(1).cellstr_value ();
+
               if (! error_state)
                 {
-                  for (octave_idx_type n = 1; n < len; n++)
+                  octave_idx_type plen = plist.numel ();
+
+                  use_cell_format = true;
+
+                  vals.resize (dim_vector (len, plen));
+
+                  for (octave_idx_type n = 0; n < len; n++)
                     {
-                      std::string typ = get_graphics_object_type (hcv(n));
-
-                      if (error_state)
-                        break;
-
-                      if (typ != typ0)
+                      graphics_object go = gh_manager::get_object (hcv(n));
+
+                      if (go)
                         {
-                          error ("get: vector of handles must all have same type");
+                          for (octave_idx_type m = 0; m < plen; m++)
+                            {
+                              caseless_str property = plist(m);
+
+                              vals(n, m) = go.get (property);
+                            }
+                        }
+                      else
+                        {
+                          error ("get: invalid handle (= %g)", hcv(n));
                           break;
                         }
                     }
-
                 }
-            }
-
-          if (! error_state)
-            {
-              if (nargin > 1 && args(1).is_cellstr ())
+              else
+                error ("get: expecting property name or cell array of property names as second argument");
+            }
+          else
+            {
+              caseless_str property;
+
+              if (nargin > 1)
                 {
-                  Array<std::string> plist = args(1).cellstr_value ();
-
-                  if (! error_state)
+                  property = args(1).string_value ();
+
+                  if (error_state)
+                    error ("get: expecting property name or cell array of property names as second argument");
+                }
+
+              vals.resize (dim_vector (len, 1));
+
+              for (octave_idx_type n = 0; n < len; n++)
+                {
+                  graphics_object go = gh_manager::get_object (hcv(n));
+
+                  if (go)
                     {
-                      octave_idx_type plen = plist.numel ();
-
-                      use_cell_format = true;
-
-                      vals.resize (dim_vector (len, plen));
-
-                      for (octave_idx_type n = 0; ! error_state && n < len; n++)
-                        {
-                          graphics_object go = gh_manager::get_object (hcv(n));
-
-                          if (go)
-                            {
-                              for (octave_idx_type m = 0;
-                                   ! error_state && m < plen;
-                                   m++)
-                                {
-                                  caseless_str property = plist(m);
-
-                                  vals(n, m) = go.get (property);
-                                }
-                            }
-                          else
-                            {
-                              error ("get: invalid handle (= %g)", hcv(n));
-                              break;
-                            }
-                        }
+                      if (nargin == 1)
+                        vals(n) = go.get ();
+                      else
+                        vals(n) = go.get (property);
                     }
                   else
-                    error ("get: expecting property name or cell array of property names as second argument");
-                }
-              else
-                {
-                  caseless_str property;
-
-                  if (nargin > 1)
                     {
-                      property = args(1).string_value ();
-
-                      if (error_state)
-                        error ("get: expecting property name or cell array of property names as second argument");
-                    }
-
-                  vals.resize (dim_vector (len, 1));
-
-                  if (! error_state)
-                    {
-                      for (octave_idx_type n = 0; ! error_state && n < len; n++)
-                        {
-                          graphics_object go = gh_manager::get_object (hcv(n));
-
-                          if (go)
-                            {
-                              if (nargin == 1)
-                                vals(n) = go.get ();
-                              else
-                                vals(n) = go.get (property);
-                            }
-                          else
-                            {
-                              error ("get: invalid handle (= %g)", hcv(n));
-                              break;
-                            }
-                        }
+                      error ("get: invalid handle (= %g)", hcv(n));
+                      break;
                     }
                 }
             }
         }
       else
         error ("get: expecting graphics handle as first argument");
     }
   else
     print_usage ();
 
-  if (! error_state)
-    {
-      if (use_cell_format)
-        retval = vals;
+  if (use_cell_format)
+    retval = vals;
+  else
+    {
+      octave_idx_type len = vals.numel ();
+
+      if (len == 0)
+        retval = Matrix ();
+      else if (len == 1)
+        retval = vals(0);
+      else if (len > 1 && nargin == 1)
+        {
+          OCTAVE_LOCAL_BUFFER (octave_scalar_map, tmp, len);
+
+          for (octave_idx_type n = 0; n < len; n++)
+            tmp[n] = vals(n).scalar_map_value ();
+
+          retval = octave_map::cat (0, len, tmp);
+        }
       else
-        {
-          octave_idx_type len = vals.numel ();
-
-          if (len == 0)
-            retval = Matrix ();
-          else if (len == 1)
-            retval = vals(0);
-          else if (len > 1 && nargin == 1)
-            {
-              OCTAVE_LOCAL_BUFFER (octave_scalar_map, tmp, len);
-
-              for (octave_idx_type n = 0; n < len; n++)
-                tmp[n] = vals(n).scalar_map_value ();
-
-              retval = octave_map::cat (0, len, tmp);
-            }
-          else
-            retval = vals;
-        }
+        retval = vals;
     }
 
   return retval;
 }
 
 /*
 %!assert (get (findobj (0, "Tag", "nonexistenttag"), "nonexistentproperty"), [])
 */
@@ -10310,25 +10171,22 @@ Undocumented internal function.\n\
             }
         }
       else
         error ("get: expecting graphics handle as first argument");
     }
   else
     print_usage ();
 
-  if (! error_state)
-    {
-      octave_idx_type len = vals.numel ();
-
-      if (len > 1)
-        retval = vals;
-      else if (len == 1)
-        retval = vals(0);
-    }
+  octave_idx_type len = vals.numel ();
+
+  if (len > 1)
+    retval = vals;
+  else if (len == 1)
+    retval = vals(0);
 
   return retval;
 }
 
 static octave_value
 make_graphics_object (const std::string& go_name,
                       bool integer_figure_handle,
                       const octave_value_list& args)
@@ -10343,28 +10201,25 @@ make_graphics_object (const std::string&
 
   for (int i = 0; i < xargs.length (); i++)
     if (xargs(i).is_string () && p.compare (xargs(i).string_value ()))
       {
         if (i < (xargs.length () - 1))
           {
             val = xargs(i+1).double_value ();
 
-            if (! error_state)
-              {
-                xargs = xargs.splice (i, 2);
-                break;
-              }
+            xargs = xargs.splice (i, 2);
+            break;
           }
         else
           error ("__go_%s__: missing value for parent property",
                  go_name.c_str ());
       }
 
-  if (! error_state && xisnan (val))
+  if (xisnan (val))
     val = args(0).double_value ();
 
   if (! error_state)
     {
       graphics_handle parent = gh_manager::lookup (val);
 
       if (parent.ok ())
         {
@@ -10378,18 +10233,17 @@ make_graphics_object (const std::string&
               adopt (parent, h);
 
               xset (h, xargs);
               xcreatefcn (h);
               xinitialize (h);
 
               retval = h.value ();
 
-              if (! error_state)
-                Vdrawnow_requested = true;
+              Vdrawnow_requested = true;
             }
           else
             error ("__go%s__: unable to create graphics handle",
                    go_name.c_str ());
         }
       else
         error ("__go_%s__: invalid parent", go_name.c_str ());
     }
@@ -10439,23 +10293,21 @@ Undocumented internal function.\n\
                     {
                       if (xargs(i).is_string ()
                           && pname.compare (xargs(i).string_value ()))
                         {
                           if (i < (xargs.length () - 1))
                             {
                               std::string pval = xargs(i+1).string_value ();
 
-                              if (! error_state)
-                                {
-                                  caseless_str on ("on");
-                                  int_fig_handle = on.compare (pval);
-                                  xargs = xargs.splice (i, 2);
-                                  break;
-                                }
+                              caseless_str on ("on");
+                              int_fig_handle = on.compare (pval);
+                              xargs = xargs.splice (i, 2);
+
+                              break;
                             }
                         }
                     }
 
                   h = gh_manager::make_graphics_handle ("figure", 0,
                                                         int_fig_handle,
                                                         false, false);
 
@@ -10723,18 +10575,17 @@ Undocumented internal function.\n\
 
               if (! h.ok ())
                 {
                   error ("delete: invalid graphics object (= %g)", vals(i));
                   break;
                 }
             }
 
-          if (! error_state)
-            delete_graphics_objects (vals);
+          delete_graphics_objects (vals);
         }
       else
         error ("delete: invalid graphics object");
     }
   else
     print_usage ();
 
   return retval;
@@ -10750,22 +10601,17 @@ Undocumented internal function.\n\
 
   octave_value retval;
 
   int nargin = args.length ();
 
   std::string mode = "";
 
   if (nargin == 2)
-    {
-      mode = args(1).string_value ();
-
-      if (error_state)
-        return retval;
-    }
+    mode = args(1).string_value ();
 
   if (nargin == 1 || nargin == 2)
     {
       graphics_handle h = octave_NaN;
 
       double val = args(0).double_value ();
 
       if (! error_state)
@@ -10937,18 +10783,17 @@ gtk_manager::do_get_toolkit (void) const
           const_available_toolkits_iterator pa = available_toolkits.find (dtk);
 
           if (pa != available_toolkits.end ())
             {
               octave_value_list args;
               args(0) = dtk;
               feval ("graphics_toolkit", args);
 
-              if (! error_state)
-                pl = loaded_toolkits.find (dtk);
+              pl = loaded_toolkits.find (dtk);
 
               if (error_state || pl == loaded_toolkits.end ())
                 error ("failed to load %s graphics toolkit", dtk.c_str ());
               else
                 retval = pl->second;
             }
           else
             error ("default graphics toolkit '%s' is not available!",
@@ -11083,17 +10928,17 @@ undocumented.\n\
   frame.protect_var (drawnow_executing);
 
   if (++drawnow_executing <= 1)
     {
       if (args.length () == 0 || args.length () == 1)
         {
           Matrix hlist = gh_manager::figure_handle_list (true);
 
-          for (int i = 0; ! error_state && i < hlist.numel (); i++)
+          for (int i = 0; i < hlist.numel (); i++)
             {
               graphics_handle h = gh_manager::lookup (hlist(i));
 
               if (h.ok () && h != 0)
                 {
                   graphics_object go = gh_manager::get_object (h);
                   figure::properties& fprops
                     = dynamic_cast <figure::properties&> (go.get_properties ());
@@ -11504,18 +11349,17 @@ addproperty (\"my_style\", gcf, \"lineli
 
                   if (! error_state)
                     {
                       if (! go.get_properties ().has_property (name))
                         {
                           property p = property::create (name, gh, type,
                                                          args.splice (0, 3));
 
-                          if (! error_state)
-                            go.get_properties ().insert_property (name, p);
+                          go.get_properties ().insert_property (name, p);
                         }
                       else
                         error ("addproperty: a '%s' property already exists in the graphics object",
                                name.c_str ());
                     }
                   else
                     error ("addproperty: invalid property TYPE, expected a string value");
                 }
@@ -11559,18 +11403,17 @@ set_property_in_handle (double handle, c
 
   int ret = false;
   graphics_object go = gh_manager::get_object (handle);
 
   if (go)
     {
       go.set (caseless_str (property), arg);
 
-      if (! error_state)
-        ret = true;
+      ret = true;
     }
   else
     error ("%s: invalid handle (= %g)", func.c_str (), handle);
 
   return ret;
 }
 
 static bool
@@ -11578,17 +11421,17 @@ compare_property_values (const octave_va
 {
   octave_value_list args(2);
 
   args(0) = ov1;
   args(1) = ov2;
 
   octave_value_list result = feval ("isequal", args, 1);
 
-  if (! error_state && result.length () > 0)
+  if (result.length () > 0)
     return result(0).bool_value ();
 
   return false;
 }
 
 static std::map<uint32_t, bool> waitfor_results;
 
 static void
@@ -11602,39 +11445,33 @@ do_cleanup_waitfor_listener (const octav
                              listener_mode mode = POSTSET)
 {
   Cell c = listener.cell_value ();
 
   if (c.numel () >= 4)
     {
       double h = c(2).double_value ();
 
-      if (! error_state)
-        {
-          caseless_str pname = c(3).string_value ();
-
-          if (! error_state)
-            {
-              gh_manager::auto_lock guard;
-
-              graphics_handle gh = gh_manager::lookup (h);
-
-              if (gh.ok ())
-                {
-                  graphics_object go = gh_manager::get_object (gh);
-
-                  if (go.get_properties ().has_property (pname))
-                    {
-                      go.get_properties ().delete_listener (pname, listener,
-                                                            mode);
-                      if (mode == POSTSET)
-                        go.get_properties ().delete_listener (pname, listener,
-                                                              PERSISTENT);
-                    }
-                }
+      caseless_str pname = c(3).string_value ();
+
+      gh_manager::auto_lock guard;
+
+      graphics_handle gh = gh_manager::lookup (h);
+
+      if (gh.ok ())
+        {
+          graphics_object go = gh_manager::get_object (gh);
+
+          if (go.get_properties ().has_property (pname))
+            {
+              go.get_properties ().delete_listener (pname, listener, mode);
+
+              if (mode == POSTSET)
+                go.get_properties ().delete_listener (pname, listener,
+                                                      PERSISTENT);
             }
         }
     }
 }
 
 static void
 cleanup_waitfor_postset_listener (const octave_value& listener)
 { do_cleanup_waitfor_listener (listener, POSTSET); }
@@ -11645,60 +11482,50 @@ cleanup_waitfor_predelete_listener (cons
 
 static octave_value_list
 waitfor_listener (const octave_value_list& args, int)
 {
   if (args.length () > 3)
     {
       uint32_t id = args(2).uint32_scalar_value ().value ();
 
-      if (! error_state)
-        {
-          if (args.length () > 5)
-            {
-              double h = args(0).double_value ();
-
-              if (! error_state)
-                {
-                  caseless_str pname = args(4).string_value ();
-
-                  if (! error_state)
-                    {
-                      gh_manager::auto_lock guard;
-
-                      graphics_handle gh = gh_manager::lookup (h);
-
-                      if (gh.ok ())
-                        {
-                          graphics_object go = gh_manager::get_object (gh);
-                          octave_value pvalue = go.get (pname);
-
-                          if (compare_property_values (pvalue, args(5)))
-                            waitfor_results[id] = true;
-                        }
-                    }
-                }
-            }
-          else
-            waitfor_results[id] = true;
-        }
+      if (args.length () > 5)
+        {
+          double h = args(0).double_value ();
+
+          caseless_str pname = args(4).string_value ();
+
+          gh_manager::auto_lock guard;
+
+          graphics_handle gh = gh_manager::lookup (h);
+
+          if (gh.ok ())
+            {
+              graphics_object go = gh_manager::get_object (gh);
+              octave_value pvalue = go.get (pname);
+
+              if (compare_property_values (pvalue, args(5)))
+                waitfor_results[id] = true;
+            }
+        }
+      else
+        waitfor_results[id] = true;
     }
 
   return octave_value_list ();
 }
 
 static octave_value_list
 waitfor_del_listener (const octave_value_list& args, int)
 {
   if (args.length () > 2)
     {
       uint32_t id = args(2).uint32_scalar_value ().value ();
 
-      if (! error_state)
-        waitfor_results[id] = true;
+      waitfor_results[id] = true;
     }
 
   return octave_value_list ();
 }
 
 DEFUN (waitfor, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} waitfor (@var{h})\n\
@@ -11757,16 +11584,17 @@ In all cases, typing CTRL-C stops progra
           int max_arg_index = 0;
           int timeout_index = -1;
 
           int timeout = 0;
 
           if (args.length () > 1)
             {
               pname = args(1).string_value ();
+
               if (! error_state
                   && ! pname.empty () && ! pname.compare ("timeout"))
                 {
                   if (pname.compare ("\\timeout"))
                     pname = "timeout";
 
                   static octave_value wf_listener;
 
@@ -11856,33 +11684,32 @@ In all cases, typing CTRL-C stops progra
                             }
                         }
                     }
                 }
               else if (error_state || pname.empty ())
                 error ("waitfor: invalid property name, expected a non-empty string value");
             }
 
-          if (! error_state
-              && timeout_index < 0 && args.length () > (max_arg_index + 1))
+          if (timeout_index < 0 && args.length () > (max_arg_index + 1))
             {
               caseless_str s = args(max_arg_index + 1).string_value ();
 
               if (! error_state)
                 {
                   if (s.compare ("timeout"))
                     timeout_index = max_arg_index + 1;
                   else
                     error ("waitfor: invalid parameter '%s'", s.c_str ());
                 }
               else
                 error ("waitfor: invalid parameter, expected 'timeout'");
             }
 
-          if (! error_state && timeout_index >= 0)
+          if (timeout_index >= 0)
             {
               if (args.length () > (timeout_index + 1))
                 {
                   timeout = static_cast<int>
                             (args(timeout_index + 1).scalar_value ());
 
                   if (! error_state)
                     {
@@ -11973,19 +11800,16 @@ Undocumented internal function.\n\
   if (nargin != 2 && nargin != 3)
     {
       print_usage ();
       return retval;
     }
 
   double h = args(0).double_value ();
 
-  if (error_state)
-    return retval;
-
   gh_manager::auto_lock guard;
 
   graphics_handle handle = gh_manager::lookup (h);
 
   if (! handle.ok ())
     {
       error ("__zoom__: invalid handle");
       return retval;
@@ -11995,37 +11819,31 @@ Undocumented internal function.\n\
 
   axes::properties& ax_props =
     dynamic_cast<axes::properties&> (ax.get_properties ());
 
   if (nargin == 2)
     {
       std::string opt = args(1).string_value ();
 
-      if (error_state)
-        return retval;
-
       if (opt == "out" || opt == "reset")
         {
           if (opt == "out")
             {
               ax_props.clear_zoom_stack ();
               Vdrawnow_requested = true;
             }
           else
             ax_props.clear_zoom_stack (false);
         }
     }
   else
     {
       std::string mode = args(1).string_value ();
       double factor = args(2).scalar_value ();
 
-      if (error_state)
-        return retval;
-
       ax_props.zoom (mode, factor);
       Vdrawnow_requested = true;
     }
 
   return retval;
 }
 
