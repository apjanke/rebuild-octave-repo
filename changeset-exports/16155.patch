# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1362035064 18000
#      Thu Feb 28 02:04:24 2013 -0500
# Branch classdef
# Node ID 0259254a3ccc4d545dc17ca3cbc0bbccc5ed8248
# Parent  fc3cb570ac4665de689c6cab34fa5ce26e6bf45f
# Parent  aa5e1e8dce6676387964bc7c108c0e8ebbe5c55c
maint: periodic merge of default to classdef

* lex.h, lex.ll, parse.h, oct-parse.yy: Resolve conflicts by adapting
classdef changes to new octave_parser and lexical_feedback classes.

diff --git a/.hgsubstate b/.hgsubstate
--- a/.hgsubstate
+++ b/.hgsubstate
@@ -1,1 +1,1 @@
-0eef0a2a05e22ac8ef2aad06dda200f7def83396 gnulib-hg
+c75939cb6254833830cdbeaf84e666360a34ccf1 gnulib-hg
diff --git a/.hgtags b/.hgtags
--- a/.hgtags
+++ b/.hgtags
@@ -69,8 +69,9 @@ 4460c4fb20e6a5d3b1972fa737d4e00eb921545a
 551566201318bf615b27c60ccf9368f4844008bd release-3-6-2
 a95432e7309ca6fc776c02939264bb6d443f3525 release-3-6-3
 2e8eb9ac43a5f8cfaf0423814a312ed47cb80485 rc-3-6-4-0
 df1aceb8f0bc6b5b5062907931cc663467f57d93 ss-3-7-1
 858cbf6fc2ec1c232f5cf1d75dc344439b39a89c rc-3-6-4-1
 faefa1bea8ddae3cab170afdeab68d3d15c4e623 ss-3-7-2
 0000000000000000000000000000000000000000 ss-3-7-2
 23a7661e529ae9bfc91693618f8c314c31f695ca ss-3-7-2
+cc5a7d1233f3acea85648baeb754fc0e8f225225 rc-3-6-4-2
diff --git a/bootstrap.conf b/bootstrap.conf
--- a/bootstrap.conf
+++ b/bootstrap.conf
@@ -31,16 +31,17 @@ gnulib_modules="
   fcntl
   fflush
   filemode
   float
   floor
   floorf
   fnmatch
   fopen
+  fpucw
   fseek
   ftell
   getcwd
   gethostname
   getopt-gnu
   gettimeofday
   glob
   isatty
diff --git a/build-aux/common.mk b/build-aux/common.mk
--- a/build-aux/common.mk
+++ b/build-aux/common.mk
@@ -1,19 +1,22 @@
 CROSS_TOOL_PREFIX = @CROSS_TOOL_PREFIX@
 
 AWK = @AWK@
 export AWK
 
-SED = @SED@
-export SED
+GREP = @GREP@
+export GREP
 
 FIND = @FIND@
 export FIND
 
+SED = @SED@
+export SED
+
 PERL = @PERL@
 export PERL
 
 PYTHON = @PYTHON@
 
 GNUPLOT = @GNUPLOT@
 
 DESKTOP_FILE_INSTALL = @DESKTOP_FILE_INSTALL@
@@ -108,17 +111,17 @@ AM_CFLAGS = $(XTRA_CFLAGS)
 ALL_CPPFLAGS = $(CPPFLAGS) $(HDF5_CPPFLAGS) $(Z_CPPFLAGS) $(LLVM_CPPFLAGS)
 
 BUILD_CC = @BUILD_CC@
 BUILD_CFLAGS = @BUILD_CFLAGS@
 
 DEPEND_FLAGS = @DEPEND_FLAGS@
 DEPEND_EXTRA_SED_PATTERN = @DEPEND_EXTRA_SED_PATTERN@
 INCLUDE_DEPS = @INCLUDE_DEPS@
-# ifeq ($(INCLUDE_DEPS),false)
+# ifeq ($(INCLUDE_DEPS),no)
 #   omit_deps = true;
 # endif
 
 DEFS = @DEFS@
 UGLY_DEFS = @UGLY_DEFS@
 
 # C++ compiler flags.
 
@@ -273,19 +276,19 @@ SPARSE_XCPPFLAGS = \
 
 SPARSE_XLDFLAGS = \
   $(CHOLMOD_LDFLAGS) $(UMFPACK_LDFLAGS) \
   $(AMD_LDFLAGS) $(CAMD_LDFLAGS) $(COLAMD_LDFLAGS) \
   $(CCOLAMD_LDFLAGS) $(CXSPARSE_LDFLAGS)
 
 ## Order matters, at least on some systems (Cygwin, for example).
 SPARSE_XLIBS = \
-    $(CHOLMOD_LIBS) $(UMFPACK_LIBS) \
-    $(AMD_LIBS) $(CAMD_LIBS) $(COLAMD_LIBS) \
-    $(CCOLAMD_LIBS) $(CXSPARSE_LIBS)
+  $(CHOLMOD_LIBS) $(UMFPACK_LIBS) \
+  $(AMD_LIBS) $(CAMD_LIBS) $(COLAMD_LIBS) \
+  $(CCOLAMD_LIBS) $(CXSPARSE_LIBS)
 
 TERM_LIBS = @TERM_LIBS@
 
 UMFPACK_CPPFLAGS = @UMFPACK_CPPFLAGS@
 UMFPACK_LDFLAGS = @UMFPACK_LDFLAGS@
 UMFPACK_LIBS = @UMFPACK_LIBS@
 
 X11_INCFLAGS = @X11_INCFLAGS@
@@ -691,52 +694,23 @@ echo "making $@ from $<"
 endef
 
 define do_subst_script_vals
 echo "making $@ from $<"
 $(SED) < $< \
   -e "s|%AWK%|${AWK}|g" \
   -e "s|%FIND%|${FIND}|g" \
   -e "s|%SED%|${SED}|g" \
-  -e "s|%library_path_var%|${library_path_var}|g" \
-  -e "s|%liboctinterp%|${SHLPRE}octinterp.${SHLEXT}|g" \
-  -e "s|%liboctave%|${SHLPRE}octave.${SHLEXT}|g" \
-  -e "s|%ldpreloadsep%|${ldpreloadsep}|g" \
-  -e "s|%srcdir%|${srcdir}|" \
-  -e "s|%top_srcdir%|${top_srcdir}|" \
   -e "s|%abs_top_srcdir%|${abs_top_srcdir}|" \
   -e "s|%builddir%|$(shell pwd)|" > $@-t
 $(simple_move_if_change_rule)
 endef
 
-define do_script_install
-$(top_srcdir)/build-aux/mkinstalldirs $(DESTDIR)$(fcnfiledir)/$(script_sub_dir)
-for f in $(FCN_FILES); do \
-  fbase=`basename $$f`; \
-  rm -f $(DESTDIR)$(fcnfiledir)/$(script_sub_dir)/$$fbase; \
-  $(INSTALL_DATA) $$f $(DESTDIR)$(fcnfiledir)/$(script_sub_dir)/$$fbase; \
-done
-$(top_srcdir)/mkpkgadd $(DESTDIR)$(fcnfiledir)/$(script_sub_dir) > $(DESTDIR)$(fcnfiledir)/$(script_sub_dir)/PKG_ADD.t
-if [ -n "`cat $(DESTDIR)$(fcnfiledir)/$(script_sub_dir)/PKG_ADD.t`" ]; then \
-  $(INSTALL_DATA) $(DESTDIR)$(fcnfiledir)/$(script_sub_dir)/PKG_ADD.t $(DESTDIR)$(fcnfiledir)/$(script_sub_dir)/PKG_ADD ; \
-else \
-  rm -f $(DESTDIR)$(fcnfiledir)/$(script_sub_dir)/PKG_ADD.t ; \
-fi
-endef
-
-define do_script_uninstall
-for f in $(FCN_FILES_NO_DIR); \
-  do rm -f $(DESTDIR)$(fcnfiledir)/$(script_sub_dir)/$$f; \
-done
-rm -f $(DESTDIR)$(fcnfiledir)/$(script_sub_dir)/PKG_ADD
--rmdir $(DESTDIR)$(fcnfiledir)/$(script_sub_dir)
-endef
-
 define test-file-commands
-( echo "## DO NOT EDIT!  Generated automatically from $(<F) by Make."; grep '^%!' $< ) > $@-t
+( echo "## DO NOT EDIT!  Generated automatically from $(<F) by Make."; $(GREP) '^%!' $< ) > $@-t
 mv $@-t $@
 endef
 
 %.cc-tst : %.cc
 	$(test-file-commands)
 
 %.yy-tst : %.yy
 	$(test-file-commands)
diff --git a/build-aux/find-files-with-tests.sh b/build-aux/find-files-with-tests.sh
--- a/build-aux/find-files-with-tests.sh
+++ b/build-aux/find-files-with-tests.sh
@@ -1,19 +1,20 @@
 #! /bin/sh
 
 set -e
+GREP=${GREP:-grep}
 SED=${SED:-sed}
 
 srcdir="$1"
 shift
 
 for arg
 do
   if [ -f "$arg" ]; then
     file="$arg"
   else
     file="$srcdir/$arg"
   fi
-  if [ "`grep -l '^%!' $file`" ]; then
+  if [ "`$GREP -l '^%!' $file`" ]; then
     echo "$file" | $SED "s,\\$srcdir/,,";
   fi
 done
diff --git a/configure.ac b/configure.ac
--- a/configure.ac
+++ b/configure.ac
@@ -92,16 +92,17 @@ OCTAVE_SET_DEFAULT([infofile], '$(infodi
 ### Check for programs used in building, installing, and running Octave.
 
 ## Programs used in configuring Octave.
 ## Find pkg-config executable (sets $PKG_CONFIG)
 PKG_PROG_PKG_CONFIG
 
 ## Programs used in Makefiles.
 AC_PROG_AWK
+AC_PROG_GREP
 OCTAVE_PROG_FIND
 OCTAVE_PROG_SED
 OCTAVE_PROG_PERL
 
 ## Programs used to build parts of Octave.
 OCTAVE_PROG_GPERF
 
 OCTAVE_PROG_FLEX
@@ -175,48 +176,48 @@ case $with_shell in
 esac
 AC_DEFINE_UNQUOTED([SHELL_PATH], ["$SHELL_PATH"],
   [Define this to be the path to the shell command interpreter.])
 
 ### Enable bounds checking on element references within Octave's array and
 ### matrix classes.  This slows down some operations a bit, so it is turned off
 ### by default.
 
-BOUNDS_CHECKING=false
+BOUNDS_CHECKING=no
 AC_ARG_ENABLE([bounds-check],
   [AS_HELP_STRING([--enable-bounds-check],
     [enable bounds checking for indexing in internal array classes])],
-  [if test "$enableval" = yes; then BOUNDS_CHECKING=true; fi], [])
-if $BOUNDS_CHECKING; then
+  [if test "$enableval" = yes; then BOUNDS_CHECKING=yes; fi], [])
+if test $BOUNDS_CHECKING = yes; then
   AC_DEFINE(BOUNDS_CHECKING, 1, [Define to 1 to use internal bounds checking.])
 fi
 
 ### Use Octave's built-in memory allocator rather than straightforward malloc.
 ### Disabled by default.
 
-USE_OCTAVE_ALLOCATOR=false
+USE_OCTAVE_ALLOCATOR=no
 AC_ARG_ENABLE([octave-allocator],
   [AS_HELP_STRING([--enable-octave-allocator],
     [use the obsolete octave_allocator class for many of Octave's objects (mostly octave_value types).  You probably do NOT want to enable this feature.])],
-  [if test "$enableval" = yes; then USE_OCTAVE_ALLOCATOR=true; fi], [])
-if $USE_OCTAVE_ALLOCATOR; then
+  [if test "$enableval" = yes; then USE_OCTAVE_ALLOCATOR=yes; fi], [])
+if test $USE_OCTAVE_ALLOCATOR = yes; then
   AC_DEFINE(USE_OCTAVE_ALLOCATOR, 1,
     [Define to 1 to use octave_allocator class.])
 fi
 
 ### Use atomic operations for internal reference counting.  This is required
 ### for thread-safe behavior but incurs a significant slowdown, and is thus
 ### disabled by default.
 
-USE_ATOMIC_REFCOUNT=false
+USE_ATOMIC_REFCOUNT=no
 AC_ARG_ENABLE([atomic-refcount],
   [AS_HELP_STRING([--enable-atomic-refcount],
     [use atomic operations for internal reference counting.  This is required for thread-safe behavior but does not by itself make Octave internals thread safe.])],
-  [if test "$enableval" = yes; then USE_ATOMIC_REFCOUNT=true; fi], [])
-if $USE_ATOMIC_REFCOUNT; then
+  [if test "$enableval" = yes; then USE_ATOMIC_REFCOUNT=yes; fi], [])
+if test $USE_ATOMIC_REFCOUNT = yes; then
   AC_DEFINE(USE_ATOMIC_REFCOUNT, 1,
     [Define to 1 to use atomic operations for reference counting.])
 fi
 
 ### Disable running Make in the doc directory.
 ### This is useful, for example, when building Octave on systems without TeX.
 
 DOCDIR=doc
@@ -227,47 +228,47 @@ AC_ARG_ENABLE([docs],
      warn_docs="building documentation disabled; make dist will fail"
      OCTAVE_CONFIGURE_WARNING([warn_docs])
    fi],
   [])
 AC_SUBST(DOCDIR)
 
 ### If possible, use a 64-bit integer type for array dimensions and indexing.
 
-USE_64_BIT_IDX_T=false
+USE_64_BIT_IDX_T=no
 OCTAVE_IDX_TYPE=int
 AC_ARG_ENABLE(64,
   [AS_HELP_STRING([--enable-64],
     [(EXPERIMENTAL) use 64-bit integers for array dimensions and indexing])],
-  [if test "$enableval" = yes; then USE_64_BIT_IDX_T=true; fi], [])
-if $USE_64_BIT_IDX_T; then
+  [if test "$enableval" = yes; then USE_64_BIT_IDX_T=yes; fi], [])
+if test $USE_64_BIT_IDX_T = yes; then
   AC_CHECK_SIZEOF([void *])
   AC_CHECK_SIZEOF([int])
   AC_CHECK_SIZEOF([long])
   if test $ac_cv_sizeof_void_p -eq 8; then
     if test $ac_cv_sizeof_int -eq 8; then
       OCTAVE_IDX_TYPE=int
     elif test $ac_cv_sizeof_long -eq 8; then
       OCTAVE_IDX_TYPE=long
       AC_DEFINE(IDX_TYPE_LONG, 1, [Define to 1 if octave index type is long.])
     else
       warn_64_bit="no suitable type found for octave_idx_type so disabling 64-bit features"
       OCTAVE_CONFIGURE_WARNING([warn_64_bit])
-      USE_64_BIT_IDX_T=false
+      USE_64_BIT_IDX_T=no
     fi
   else
     warn_64_bit="pointers are not 64-bits wide; disabling 64-bit features"
     OCTAVE_CONFIGURE_WARNING([warn_64_bit])
-    USE_64_BIT_IDX_T=false
+    USE_64_BIT_IDX_T=no
   fi
 fi
 AC_SUBST(OCTAVE_IDX_TYPE)
 AC_DEFINE_UNQUOTED(OCTAVE_IDX_TYPE, [$OCTAVE_IDX_TYPE],
   [Define to the type of octave_idx_type (64 or 32 bit signed integer).])
-if $USE_64_BIT_IDX_T; then
+if test $USE_64_BIT_IDX_T = yes; then
   AC_DEFINE(USE_64_BIT_IDX_T, 1,
     [Define to 1 if using 64-bit integers for array dimensions and indexing.])
 fi
 AC_SUBST(USE_64_BIT_IDX_T)
 
 ### It seems that there are some broken inline assembly functions in
 ### the GNU libc.  Since I'm not sure how to test whether we are using
 ### GNU libc, just disable them for all platforms.
@@ -345,34 +346,34 @@ AC_SUBST(CC_VERSION)
 
 ## FIXME: CC_VERSION is deprecated and should be removed in Octave version 3.12
 CC_VERSION=$gcc_version
 AC_SUBST(GCC_VERSION)
 
 ### Determine the compiler flag necessary to create dependencies
 
 ## Assume GCC.
-INCLUDE_DEPS=true
+INCLUDE_DEPS=yes
 DEPEND_FLAGS="-M"
 DEPEND_EXTRA_SED_PATTERN=""
 if test "$GCC" != yes; then
   case $canonical_host_type in
     sparc-sun-solaris2* | i386-pc-solaris2*)
       DEPEND_FLAGS="-xM1"
       DEPEND_EXTRA_SED_PATTERN="-e '/\/opt\/SUNWspro/d'"
     ;;
     *-*-msdosmsvc)
     ;;
     *-*-mingw*)
       if test $have_msvc = no; then
-        INCLUDE_DEPS=false
+        INCLUDE_DEPS=no
       fi
     ;;
     *)
-      INCLUDE_DEPS=false
+      INCLUDE_DEPS=no
     ;;
   esac
 fi
 AC_SUBST(INCLUDE_DEPS)
 AC_SUBST(DEPEND_FLAGS)
 AC_SUBST(DEPEND_EXTRA_SED_PATTERN)
 
 ### Check for pthread library
@@ -461,22 +462,22 @@ case $canonical_host_type in
 esac
 
 AC_SUBST(XTRA_CFLAGS)
 AC_SUBST(XTRA_CXXFLAGS)
 
 ### Test whether the compiler supports OpenMP.  This is experimental so disable
 ### it by default.  Enable it with the flag --enable-openmp.
 
-USE_OPENMP=false
+USE_OPENMP=no
 AC_ARG_ENABLE([openmp],
   [AS_HELP_STRING([--enable-openmp],
     [(EXPERIMENTAL) use OpenMP SMP multi-threading])],
-  [if test "$enableval" = yes; then USE_OPENMP=true; fi], [])
-if $USE_OPENMP; then
+  [if test "$enableval" = yes; then USE_OPENMP=yes; fi], [])
+if test $USE_OPENMP = yes; then
   case $host_os in
     mingw* | cygwin* | *-gnu*)
       OCTAVE_CHECK_OPENMP(-fopenmp)
     ;;
     msdosmsvc)
       ## FIXME: is this the right flag for MSVC?
       OCTAVE_CHECK_OPENMP(-openmp)
     ;;
@@ -533,28 +534,28 @@ if test x"$FFLAGS" = x""; then
 fi
 
 ## the F77 variable, if set, overrides AC_PROG_F77 automatically
 AC_PROG_F77
 AC_F77_LIBRARY_LDFLAGS
 AC_F77_DUMMY_MAIN
 AC_F77_WRAPPERS
 
-F77_TOLOWER=true
-F77_APPEND_UNDERSCORE=true
-F77_APPEND_EXTRA_UNDERSCORE=true
+F77_TOLOWER=yes
+F77_APPEND_UNDERSCORE=yes
+F77_APPEND_EXTRA_UNDERSCORE=yes
 
 case $ac_cv_f77_mangling in
-  "upper case") F77_TOLOWER=false ;;
+  "upper case") F77_TOLOWER=no ;;
 esac
 case $ac_cv_f77_mangling in
-  "no underscore") F77_APPEND_UNDERSCORE=false ;;
+  "no underscore") F77_APPEND_UNDERSCORE=no ;;
 esac
 case $ac_cv_f77_mangling in
-  "no extra underscore") F77_APPEND_EXTRA_UNDERSCORE=false ;;
+  "no extra underscore") F77_APPEND_EXTRA_UNDERSCORE=no ;;
 esac
 
 case $canonical_host_type in
   i[[3456789]]86-*-*)
     if test $ac_cv_f77_compiler_gnu = yes; then
       OCTAVE_F77_FLAG([-mieee-fp])
     fi
   ;;
@@ -588,17 +589,17 @@ F77_ISNAN_MACRO=
 if test $octave_cv_func_fortran_isnan = no; then
   AC_MSG_NOTICE([substituting ISNAN(X) with X.NE.X in Fortran sources])
   F77_ISNAN_MACRO="s|ISNAN(\(@<:@^)@:>@*\))|(\1.NE.\1)|"
 fi
 AC_SUBST(F77_ISNAN_MACRO)
 
 OCTAVE_CHECK_SIZEOF_FORTRAN_INTEGER
 if test $octave_cv_sizeof_fortran_integer = no; then
-  if $USE_64_BIT_IDX_T; then
+  if test $USE_64_BIT_IDX_T = yes; then
     case $F77 in
       *gfortran*)
         case $F77_INTEGER_8_FLAG in
           *-fdefault-integer-8*)
           ;;
           *)
             case $FFLAGS in
               *-fdefault-integer-8*)
@@ -698,31 +699,31 @@ fi
 ### Check for ZLIB library.
 
 OCTAVE_CHECK_LIB(z, ZLIB,
   [ZLIB library not found.  Octave will not be able to save or load compressed data files or HDF5 files.],
   [zlib.h], [gzclearerr])
 
 ### Check for the LLVM library
 
-build_jit=false
+build_jit=no
 AC_ARG_ENABLE([jit],
   [AS_HELP_STRING([--enable-jit],
     [(EXPERIMENTAL) enable JIT compiler])],
   [if test "$enableval" = yes; then
-     build_jit=true
+     build_jit=yes
    fi],
   [])
 
 LLVM_CXXFLAGS=
 LLVM_CPPFLAGS=
 LLVM_LDFLAGS=
 LLVM_LIBS=
 
-if test $build_jit = true; then
+if test $build_jit = yes; then
 
   ## Find llvm-config program from environment variable or by searching
   AC_ARG_VAR([LLVM_CONFIG], [path to llvm-config utility])
   AC_CHECK_PROG([LLVM_CONFIG], llvm-config, llvm-config, [])
 
   if test -z "$LLVM_CONFIG"; then
     warn_llvm="llvm-config utility not found.  JIT compiler is disabled."
   else
@@ -758,17 +759,17 @@ if test $build_jit = true; then
     AC_LANG_POP(C++)
     CPPFLAGS="$save_CPPFLAGS"
     CXXFLAGS="$save_CXXFLAGS"
   fi
 
   if test -z "$warn_llvm"; then
     AC_DEFINE(HAVE_LLVM, 1, [Define to 1 if LLVM is available.])
   else
-    build_jit=false
+    build_jit=no
     LLVM_CPPFLAGS=
     LLVM_CXXFLAGS=
     LLVM_LDFLAGS=
     LLVM_LIBS=
     OCTAVE_CONFIGURE_WARNING([warn_llvm])
   fi
 dnl FIXME: Re-instate when JIT is enabled by default
 dnl else
@@ -811,26 +812,26 @@ OCTAVE_CHECK_LIB(fftw3, FFTW3,
   [fftw3.h], [fftw_plan_dft_1d])
 
 OCTAVE_CHECK_LIB(fftw3f, FFTW3F,
   [FFTW3F library not found.  The slower FFTPACK library will be used instead.],
   [fftw3.h], [fftwf_plan_dft_1d])
 
 ## Check for the multithreaded FFTW library.
 ## Fallback to singlethreaded if not found or disabled
-build_fftw_threads=true
+build_fftw_threads=yes
 AC_ARG_ENABLE([fftw-threads],
   [AS_HELP_STRING([--disable-fftw-threads],
     [disable Multi-threaded FFTW])],
   [if test "$enableval" = no; then
-     build_fftw_threads=false
+     build_fftw_threads=no
    fi],
   [])
 
-if test $build_fftw_threads = true; then
+if test $build_fftw_threads = yes; then
   OCTAVE_CHECK_FFTW_THREADS(fftw3, fftw_plan_with_nthreads)
   OCTAVE_CHECK_FFTW_THREADS(fftw3f, fftwf_plan_with_nthreads)
 fi
 
 AM_CONDITIONAL([AMCOND_HAVE_FFTW],
   [test -n "$FFTW3_LIBS" && test -n "$FFTW3F_LIBS"])
 
 ## Subdirectory of liboctave/cruft to build if FFTW is not found.
@@ -856,28 +857,28 @@ save_LIBS="$LIBS"
 CPPFLAGS="$Z_CPPFLAGS $CPPFLAGS"
 LIBS="$Z_LDFLAGS $Z_LIBS $LIBS"
 OCTAVE_CHECK_LIB(curl, cURL,
   [cURL library not found.  The ftp objects, urlread and urlwrite functions will be disabled.],
   [curl/curl.h], [curl_easy_escape])
 if test -z "$warn_curl"; then
   ## Additional check on cURL library that was found
   AC_CACHE_CHECK([for CURLOPT_DIRLISTONLY in curl/curl.h],
-    [octave_cv_header_define_curlopt_dirlistonly],
+    [octave_cv_curl_has_curlopt_dirlistonly],
     [AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
       #include <curl/curl.h>
       ]], [[
       curl_easy_setopt ((CURL*)NULL, CURLOPT_DIRLISTONLY, 0);
       ]])],
-      [octave_cv_header_define_curlopt_dirlistonly=no],
-      [octave_cv_header_define_curlopt_dirlistonly=yes])
+      [octave_cv_curl_has_curlopt_dirlistonly=yes],
+      [octave_cv_curl_has_curlopt_dirlistonly=no])
     ])
-  if test $octave_cv_header_define_curlopt_dirlistonly = yes; then
+  if test $octave_cv_curl_has_curlopt_dirlistonly = no; then
     AC_DEFINE(CURLOPT_DIRLISTONLY, CURLOPT_FTPLISTONLY,
-      [Define to the legacy option name if using an older version of cURL.])]
+      [Define to the legacy option name if using an older version of cURL.])
   fi
 fi
 LIBS="$save_LIBS"
 CPPFLAGS="$save_CPPFLAGS"
 
 ### Check for either of Graphics/ImageMagick++ libraries
 
 AC_ARG_WITH([magick],
@@ -972,43 +973,43 @@ if test $have_framework_carbon = yes; th
     [Define to 1 if framework CARBON is available.])
   CARBON_LIBS="-Wl,-framework -Wl,Carbon"
   AC_MSG_NOTICE([adding -Wl,-framework -Wl,Carbon to CARBON_LIBS])
   AC_SUBST(CARBON_LIBS)
 fi
 
 ### Check for list of libraries needed for native graphics renderer.
 
-native_graphics=true
+native_graphics=yes
 warn_freetype=""
 
-check_opengl=false
+check_opengl=no
 AC_ARG_WITH([opengl],
   [AS_HELP_STRING([--without-opengl],
     [don't use OpenGL libraries, disable native graphics])],
   [if test x"$withval" = x"no"; then
-     native_graphics=false
+     native_graphics=no
      warn_opengl="--without-opengl specified.  Native graphics will be disabled."
      OCTAVE_CONFIGURE_WARNING([warn_opengl])
    else
-     check_opengl=true
+     check_opengl=yes
    fi],
-  [check_opengl=true])
+  [check_opengl=yes])
 
 ## Check for OpenGL library
-if $check_opengl; then
+if test $check_opengl = yes; then
   OCTAVE_CHECK_LIB_OPENGL
 fi
 
 GRAPHICS_LIBS=
 GRAPHICS_CFLAGS=
 
 if test -z "$OPENGL_LIBS"; then
-  if $check_opengl; then
-    native_graphics=false
+  if test $check_opengl = yes; then
+    native_graphics=no
     warn_fltk_opengl="OpenGL libs (GL and GLU) not found.  Native graphics will be disabled."
     OCTAVE_CONFIGURE_WARNING([warn_fltk_opengl])
   fi
 fi
 
 if test -n "$OPENGL_LIBS"; then
   AC_DEFINE(HAVE_OPENGL, 1, [Define to 1 if OpenGL is available.])
 
@@ -1025,34 +1026,34 @@ if test -n "$OPENGL_LIBS"; then
       XTRA_CXXFLAGS="$XTRA_CXXFLAGS $FT2_CFLAGS"
     else
       AC_MSG_RESULT(no)
       warn_freetype="FreeType library not found.  Native graphics will be disabled."
     fi])
 
   if test -n "$warn_freetype"; then
     OCTAVE_CONFIGURE_WARNING([warn_freetype])
-    native_graphics=false
+    native_graphics=no
   fi
 
   ## Check for fontconfig library
 
   warn_fontconfig=""
   if test -z "$warn_freetype"; then
     PKG_CHECK_MODULES(FONTCONFIG, [fontconfig],
       [have_fontconfig=yes
        OPENGL_LIBS="$FONTCONFIG_LIBS $OPENGL_LIBS"
        XTRA_CXXFLAGS="$XTRA_CXXFLAGS $FONTCONFIG_CFLAGS"
        AC_DEFINE(HAVE_FONTCONFIG, 1, [Define to 1 if fontconfig is present.])],
       [have_fontconfig=no
        warn_fontconfig="Fontconfig library not found.  Native graphics will be disabled."])
   fi
 
   if test -n "$warn_fontconfig"; then
-    native_graphics=false
+    native_graphics=no
     OCTAVE_CONFIGURE_WARNING([warn_fontconfig])
   fi
 
   ## Check for FLTK (www.fltk.org) library
 
   AC_ARG_WITH([fltk-prefix], [
     AS_HELP_STRING([--with-fltk-prefix=PFX],
       [prefix where FLTK is installed (optional)])],
@@ -1080,17 +1081,17 @@ if test -n "$OPENGL_LIBS"; then
   fi
 
   AC_PATH_PROG([FLTK_CONFIG], [fltk-config], [no])
 
   warn_fltk_config=""
   warn_fltk_opengl=""
 
   if test "$FLTK_CONFIG" = no; then
-    native_graphics=false
+    native_graphics=no
     warn_fltk_config="FLTK config script not found.  Native graphics will be disabled."
     OCTAVE_CONFIGURE_WARNING([warn_fltk_config])
   else
     FLTK_CFLAGS=`$FLTK_CONFIG $fltkconf_args --use-gl --cflags`
     FLTK_LDFLAGS=`$FLTK_CONFIG $fltkconf_args --use-gl --ldflags`
 
     case $host_os in
       mingw*)
@@ -1116,17 +1117,17 @@ if test -n "$OPENGL_LIBS"; then
     else
       AC_DEFINE(HAVE_FLTK, 1, [Define to 1 if FLTK is available.])
     fi 
 
     if test -z "$warn_fltk_opengl"; then
       GRAPHICS_CFLAGS="$FLTK_CFLAGS"
       GRAPHICS_LIBS="$FLTK_LDFLAGS"
     else
-      native_graphics=false
+      native_graphics=no
       OCTAVE_CONFIGURE_WARNING([warn_fltk_opengl])
     fi
   fi
 fi
 
 AC_SUBST(GRAPHICS_CFLAGS)
 AC_SUBST(GRAPHICS_LIBS)
 
@@ -1149,25 +1150,25 @@ ifdef([LT_INIT], [], [
   errprint([error: you must have libtool 2.2.2 or a more recent version
 ])
   m4exit([1])])
 
 LT_PREREQ([2.2.2])
 LT_INIT([disable-static dlopen win32-dll])
 
 if test x"$enable_shared" = x"yes"; then
-  SHARED_LIBS=true
+  SHARED_LIBS=yes
 else
-  SHARED_LIBS=false
+  SHARED_LIBS=no
 fi
 
 if test x"$enable_static" = x"yes"; then
-  STATIC_LIBS=true
+  STATIC_LIBS=yes
 else
-  STATIC_LIBS=false
+  STATIC_LIBS=no
 fi
 
 XTRA_CRUFT_SH_LDFLAGS=
 if test $have_msvc = yes; then
   FLIBS="$FLIBS -lkernel32"
   XTRA_CRUFT_SH_LDFLAGS="-Wl,-def:cruft/cruft.def"
 fi
 AC_SUBST(XTRA_CRUFT_SH_LDFLAGS)
@@ -1239,17 +1240,17 @@ if test $ax_blas_f77_func_ok = no; then
         AC_DEFINE(USE_BLASWRAP, 1,
           [Define to 1 if BLAS functions need to be wrapped (potentially needed for 64-bit OSX only).])
       fi
     ;;
   esac
 fi
 
 if test $ax_blas_f77_func_ok = no; then
-  if $USE_64_BIT_IDX_T && test $ax_blas_integer_size_ok = no; then
+  if test $USE_64_BIT_IDX_T = yes && test $ax_blas_integer_size_ok = no; then
     ## Attempt to be more informative.
     AC_MSG_ERROR([BLAS doesn't seem to support 64-bit integers.  This is incompatible with --enable-64.])
   else
     AC_MSG_ERROR([A BLAS library was detected but found incompatible with your Fortran 77 compiler settings.])
   fi
 fi
 
 if test $ax_blas_ok = no || test $ax_lapack_ok = no; then
@@ -1427,23 +1428,23 @@ OCTAVE_ENABLE_READLINE
 ### --enable-dl is only need if you are only building static libraries
 ### and want to try dynamic linking too (works on some systems, for
 ### example, OS X and Windows).
 
 AC_ARG_ENABLE([dl],
   [AS_HELP_STRING([--disable-dl],
     [disable loading of dynamically linked modules])],
   [case $enableval in
-     yes) ENABLE_DYNAMIC_LINKING=true ;;
-     no) ENABLE_DYNAMIC_LINKING=false ;;
+     yes) ENABLE_DYNAMIC_LINKING=yes ;;
+     no) ENABLE_DYNAMIC_LINKING=no ;;
      *) AC_MSG_ERROR([bad value $enableval for --enable-dl]) ;;
    esac],
-  [ENABLE_DYNAMIC_LINKING=true])
-
-if ! $STATIC_LIBS && ! $SHARED_LIBS; then
+  [ENABLE_DYNAMIC_LINKING=no])
+
+if test $STATIC_LIBS = no && test $SHARED_LIBS = no; then
   AC_MSG_ERROR([You can't disable building both static AND shared libraries!])
 fi
 
 CPICFLAG=-fPIC
 CXXPICFLAG=-fPIC
 FPICFLAG=-fPIC
 SHLEXT=so
 SHLLIB='$(SHLEXT)'
@@ -1467,17 +1468,17 @@ TEMPLATE_AR='$(AR)'
 TEMPLATE_ARFLAGS="$ARFLAGS"
 CRUFT_DLL_DEFS=
 OCTAVE_DLL_DEFS=
 OCTINTERP_DLL_DEFS=
 OCTGUI_DLL_DEFS=
 OCTGRAPHICS_DLL_DEFS=
 library_path_var=LD_LIBRARY_PATH
 ldpreloadsep=" "
-BUILD_COMPILED_AUX_PROGRAMS=false
+BUILD_COMPILED_AUX_PROGRAMS=no
 case $canonical_host_type in
   *-*-386bsd* | *-*-netbsd*)
     SH_LD=ld
     SH_LDFLAGS=-Bshareable
   ;;
   *-*-openbsd*)
     SH_LDFLAGS='-shared -fPIC'
   ;;
@@ -1520,17 +1521,17 @@ case $canonical_host_type in
     SHLLIB=dll.a
     SHLBIN=dll    
     DL_LDFLAGS="-shared -Wl,--export-all-symbols -Wl,--enable-auto-import -Wl,--enable-runtime-pseudo-reloc"
     SH_LDFLAGS="-shared -Wl,--export-all-symbols -Wl,--enable-auto-import -Wl,--enable-auto-image-base"
     SONAME_FLAGS='-Wl,--out-implib=$(patsubst $(SHLPRE)%,$(LIBPRE)%,$@).a'
     ldpreloadsep=":"
   ;;
   *-*-mingw*)
-    BUILD_COMPILED_AUX_PROGRAMS=true
+    BUILD_COMPILED_AUX_PROGRAMS=yes
     if test $have_msvc = yes; then
       DL_LDFLAGS="-shared"
       CPICFLAG=
       CXXPICFLAG=
       FPICFLAG=
       SHLEXT=dll
       SHLLIB=lib
       SHLBIN=dll
@@ -1540,17 +1541,16 @@ case $canonical_host_type in
       SHLBINPRE=
       SH_LDFLAGS="-shared"
       if test -n "`echo $CFLAGS | grep -e '-g'`" || test -n "`echo $CXXFLAGS | grep -e '-g'`"; then
         DL_LDFLAGS="$DL_LDFLAGS -g"
         SH_LDFLAGS="$SH_LDFLAGS -g"
       fi
       NO_OCT_FILE_STRIP=true
       library_path_var=PATH
-      NO_OCT_FILE_STRIP=true
       ## Extra compilation flags.
       CRUFT_DLL_DEFS="-DCRUFT_DLL"
       OCTAVE_DLL_DEFS="-DOCTAVE_DLL"
       OCTINTERP_DLL_DEFS="-DOCTINTERP_DLL"
       OCTGUI_DLL_DEFS="-DOCTGUI_DLL"
       OCTGRAPHICS_DLL_DEFS="-DOCTGRAPHICS_DLL"
     else
       CPICFLAG=
@@ -1562,17 +1562,17 @@ case $canonical_host_type in
       DL_LDFLAGS="-shared -Wl,--export-all-symbols -Wl,--enable-auto-import -Wl,--enable-runtime-pseudo-reloc"
       SH_LDFLAGS="-shared -Wl,--export-all-symbols -Wl,--enable-auto-import -Wl,--enable-auto-image-base"
       SONAME_FLAGS='-Wl,--out-implib=$@.a'
       library_path_var=PATH
     fi
   ;;
 
   *-*-msdosmsvc)
-    BUILD_COMPILED_AUX_PROGRAMS=true
+    BUILD_COMPILED_AUX_PROGRAMS=yes
     DL_LDFLAGS="-shared"
     CPICFLAG=
     CXXPICFLAG=
     FPICFLAG=
     SHLEXT=dll
     SHLLIB=lib
     SHLBIN=dll
     LIBPRE=
@@ -1581,17 +1581,16 @@ case $canonical_host_type in
     SHLBINPRE=
     SH_LDFLAGS="-shared"
     if test -n "`echo $CFLAGS | grep -e '-g'`" || test -n "`echo $CXXFLAGS | grep -e '-g'`"; then
       DL_LDFLAGS="$DL_LDFLAGS -g"
       SH_LDFLAGS="$SH_LDFLAGS -g"
     fi
     NO_OCT_FILE_STRIP=true
     library_path_var=PATH
-    NO_OCT_FILE_STRIP=true
     ## Extra compilation flags.
     CRUFT_DLL_DEFS="-DCRUFT_DLL"
     OCTAVE_DLL_DEFS="-DOCTAVE_DLL"
     OCTGUI_DLL_DEFS="-DOCTGUI_DLL"
     OCTGRAPHICS_DLL_DEFS="-DOCTGRAPHICS_DLL"
   ;;
   *-*-linux* | *-*-gnu*)
     MKOCTFILE_DL_LDFLAGS="-shared -Wl,-Bsymbolic"
@@ -1661,17 +1660,17 @@ case $canonical_host_type in
     if test "$GXX" != yes; then
       TEMPLATE_AR='$(CXX)'
       TEMPLATE_ARFLAGS="-xar -o"
     fi
   ;;
 esac
 
 AM_CONDITIONAL([AMCOND_BUILD_COMPILED_AUX_PROGRAMS],
-  [test x$BUILD_COMPILED_AUX_PROGRAMS = xtrue])
+  [test $BUILD_COMPILED_AUX_PROGRAMS = yes])
 
 AC_MSG_NOTICE([defining FPICFLAG to be $FPICFLAG])
 AC_MSG_NOTICE([defining CPICFLAG to be $CPICFLAG])
 AC_MSG_NOTICE([defining CXXPICFLAG to be $CXXPICFLAG])
 AC_MSG_NOTICE([defining SHLEXT to be $SHLEXT])
 AC_MSG_NOTICE([defining SHLLIB to be $SHLLIB])
 AC_MSG_NOTICE([defining SHLBIN to be $SHLBIN])
 AC_MSG_NOTICE([defining SHLEXT_VER to be $SHLEXT_VER])
@@ -1740,87 +1739,91 @@ AC_ARG_ENABLE([no-undefined],
    esac],
   [NO_UNDEFINED_LDFLAG="-no-undefined"])
 AC_SUBST(NO_UNDEFINED_LDFLAG)
 
 AC_ARG_ENABLE([link-all-dependencies],
   [AS_HELP_STRING([--enable-link-all-dependencies],
     [link Octave and its shared libraries with all dependencies, not just those immediately referenced (should not be needed on most systems)])],
   [case $enableval in
-     yes) link_all_deps=true ;;
-     no)  link_all_deps=false ;;
+     yes) link_all_deps=yes ;;
+     no)  link_all_deps=no ;;
      *) AC_MSG_ERROR([bad value $enableval for --enable-link-all-depenencies])
      ;;
    esac],
-  [link_all_deps=false])
-AM_CONDITIONAL([AMCOND_LINK_ALL_DEPS], [test $link_all_deps = true])
+  [link_all_deps=no])
+AM_CONDITIONAL([AMCOND_LINK_ALL_DEPS], [test $link_all_deps = yes])
 
 ## Dynamic linking is now enabled only if we are building shared
 ## libs and some API for dynamic linking has been detected.
 
 ## FIXME: A lot of the following duplicates the functionality of
 ## code generated by the dlopen option for LT_INIT.
 
 LD_CXX='$(CXX)'
 RDYNAMIC_FLAG=
 DL_API_MSG=""
-dlopen_api=false
-shl_load_api=false
-loadlibrary_api=false
-dyld_api=false
-
-if $SHARED_LIBS || $ENABLE_DYNAMIC_LINKING; then
+dlopen_api=no
+shl_load_api=no
+loadlibrary_api=no
+dyld_api=no
+
+if test $SHARED_LIBS = yes || test $ENABLE_DYNAMIC_LINKING = yes; then
 
   case $lt_cv_dlopen in
     dlopen)
-      dlopen_api=true
+      dlopen_api=yes
       DL_API_MSG="(dlopen)"
       AC_DEFINE(HAVE_DLOPEN_API, 1,
         [Define to 1 if your system has dlopen, dlsym, dlerror, and dlclose for dynamic linking.])
       OCTAVE_CXX_FLAG([-rdynamic], [RDYNAMIC_FLAG=-rdynamic])
     ;;
     shl_load)
-      shl_load_api=true
+      shl_load_api=yes
       DL_API_MSG="(shl_load)"
       AC_DEFINE(HAVE_SHL_LOAD_API, 1,
         [Define to 1 if your system has shl_load and shl_findsym for dynamic linking.])
     ;;
     LoadLibrary)
-      loadlibrary_api=true
+      loadlibrary_api=yes
       DL_API_MSG="(LoadLibrary)"
       AC_DEFINE(HAVE_LOADLIBRARY_API, 1,
         [Define to 1 if your system has LoadLibrary for dynamic linking.])
     ;;
     dyld)
-      dyld_api=true
+      dyld_api=yes
       DL_API_MSG="(dyld)"
       AC_DEFINE(HAVE_DYLD_API, 1,
         [Define to 1 if your system has dyld for dynamic linking.])
     ;;
   esac
 
   DL_LIBS="$lt_cv_dlopen_libs"
   AC_SUBST(DL_LIBS)
 
   ## Disable dynamic linking if capability is not present.
-  if $dlopen_api || $shl_load_api || $loadlibrary_api || $dyld_api; then
-    :  # some form of dynamic linking present
+  if test $dlopen_api = yes \
+      || test $shl_load_api = yes \
+      || test $loadlibrary_api = yes \
+      || test $dyld_api = yes; then
+    # some form of dynamic linking present
+    ENABLE_DYNAMIC_LINKING=yes
   else
-    ENABLE_DYNAMIC_LINKING=false
+    ENABLE_DYNAMIC_LINKING=no
   fi
 fi
 
-if $ENABLE_DYNAMIC_LINKING; then
+if test $ENABLE_DYNAMIC_LINKING = yes; then
   AC_DEFINE(ENABLE_DYNAMIC_LINKING, 1, [Define to 1 if using dynamic linking.])
 fi
 
 AM_CONDITIONAL([AMCOND_ENABLE_DYNAMIC_LINKING],
-  [test x"$ENABLE_DYNAMIC_LINKING" = x"true"])
-
-if $SHARED_LIBS; then
+  [test $ENABLE_DYNAMIC_LINKING = yes])
+
+if test $SHARED_LIBS = yes; then
   LIBOCTINTERP="-loctinterp$SHLLINKEXT"
   LIBOCTAVE="-loctave$SHLLINKEXT"
 else
   LIBOCTINTERP='$(top_builddir)/libinterp/liboctinterp.$(LIBEXT)'
   LIBOCTAVE='$(top_builddir)/liboctave/liboctave.$(LIBEXT)'
 fi
 
 AC_SUBST(LD_CXX)
@@ -1890,18 +1893,18 @@ OCTAVE_CHECK_LIB_TERMLIB
 ### Checks for header files.
 
 AC_HEADER_DIRENT
 AC_HEADER_SYS_WAIT
 
 ## C headers
 
 dnl Use multiple AC_CHECKs to avoid line continuations '\' in list
-AC_CHECK_HEADERS([curses.h direct.h dlfcn.h floatingpoint.h grp.h])
-AC_CHECK_HEADERS([ieeefp.h inttypes.h locale.h memory.h ncurses.h])
+AC_CHECK_HEADERS([curses.h direct.h dlfcn.h floatingpoint.h fpu_control.h])
+AC_CHECK_HEADERS([grp.h ieeefp.h inttypes.h locale.h memory.h ncurses.h])
 AC_CHECK_HEADERS([poll.h pthread.h pwd.h sunmath.h sys/ioctl.h])
 AC_CHECK_HEADERS([sys/param.h sys/poll.h sys/resource.h ])
 AC_CHECK_HEADERS([sys/select.h sys/utsname.h termcap.h])
 
 ## C++ headers
 
 AC_LANG_PUSH(C++)
 
@@ -2206,54 +2209,54 @@ AM_CONDITIONAL([AMCOND_BUILD_DOCS], [tes
 
 ### Maybe add -Wall, -W, and -Wshadow to compiler flags now that we're
 ### done feature testing. 
 
 GCC_EXTRA_FLAGS="-Wall -W -Wshadow -Wformat -Wpointer-arith -Wmissing-prototypes -Wstrict-prototypes -Wwrite-strings -Wcast-align -Wcast-qual"
 
 GXX_EXTRA_FLAGS="-Wall -W -Wshadow -Wold-style-cast -Wformat -Wpointer-arith -Wwrite-strings -Wcast-align -Wcast-qual"
 
-try_extra_warning_flags=true
+try_extra_warning_flags=yes
 
 AC_ARG_ENABLE([extra-warning-flags],
   [AS_HELP_STRING([--disable-extra-warning-flags],
     [don't add -Wall, -W, -Wshadow, and -Wold-style-cast options to CFLAGS and CXXFLAGS])],
   [if test "$enableval" = no; then
-     try_extra_warning_flags=false
+     try_extra_warning_flags=no
    fi],
   [])
 
-if $try_extra_warning_flags; then
+if test $try_extra_warning_flags = yes; then
   for flag in $GCC_EXTRA_FLAGS; do
     OCTAVE_CC_FLAG([$flag], [
       WARN_CFLAGS="$WARN_CFLAGS $flag";
       AC_MSG_RESULT([adding $flag to WARN_CFLAGS])])
   done
   for flag in $GXX_EXTRA_FLAGS; do
     OCTAVE_CXX_FLAG([$flag], [
       WARN_CXXFLAGS="$WARN_CXXFLAGS $flag";
       AC_MSG_RESULT([adding $flag to WARN_CXXFLAGS])])
   done
 fi
 
 GCC_STRICT_FLAGS="-Wconversion"
 
 GXX_STRICT_FLAGS="-Wconversion -Weffc++"
 
-try_strict_warning_flags=false
+try_strict_warning_flags=no
 
 AC_ARG_ENABLE([strict-warning-flags],
   [AS_HELP_STRING([--enable-strict-warning-flags],
     [add extra strict warning options to CFLAGS and CXXFLAGS])],
   [if test "$enableval" = yes; then
-     try_strict_warning_flags=true
+     try_strict_warning_flags=yes
    fi],
   [])
 
-if $try_strict_warning_flags; then
+if test $try_strict_warning_flags = yes; then
   for flag in $GCC_STRICT_FLAGS; do
     OCTAVE_CC_FLAG([$flag], [
       WARN_CFLAGS="$WARN_CFLAGS $flag";
       AC_MSG_RESULT([adding $flag to WARN_CFLAGS])])
   done
   for flag in $GXX_STRICT_FLAGS; do
     OCTAVE_CXX_FLAG([$flag], [
       WARN_CXXFLAGS="$WARN_CXXFLAGS $flag";
@@ -2261,22 +2264,22 @@ if $try_strict_warning_flags; then
   done
 fi
 
 AC_SUBST(WARN_CFLAGS)
 AC_SUBST(WARN_CXXFLAGS)
 
 ### Check for Java.
 
-build_java=true
+build_java=yes
 AC_ARG_ENABLE([java],
   [AS_HELP_STRING([--disable-java],
     [disable Java interface])],
   [if test "$enableval" = no; then
-     build_java=false
+     build_java=no
    fi],
   [])
 
 AC_ARG_WITH([java-homedir],
   [AS_HELP_STRING([--with-java-homedir=DIR],
     [Java JDK directory in DIR])],
   [JAVA_HOMEDIR="$withval"])
 
@@ -2297,20 +2300,20 @@ if test -n "$JAVA_HOMEDIR"; then
   JAVA_HOME=$JAVA_HOMEDIR
 fi
 JAVA=
 JAVAC=
 JAR=
 JAVA_LIBS=
 
 ## Fake loop so that "break" can be used to skip code blocks.
-while test $build_java = true
+while test $build_java = yes
 do
   ## Unset build_java.  Variable is set only if all configuration tests pass.
-  build_java=false
+  build_java=no
 
   ## Warn if JAVA_HOME is unset.  It is *strongly* advised to specify JAVA_HOME.
   if test -z "$JAVA_HOME"; then
     AC_MSG_WARN([JAVA_HOME environment variable not initialized.])
     AC_MSG_WARN([Auto-detection will proceed but is unreliable.])
   fi
 
   ## Search for a viable Java executable.
@@ -2379,25 +2382,25 @@ do
     break
   fi
 
   ## At this point Win32/MSVC systems have enough configuration data.  We
   ## assume that all appropriate variables (e.g. INCLUDE and LIB) already have
   ## the required paths to compile and link against JDK.
   case $host_os in
     msdosmsvc)
-      build_java=true
+      build_java=yes
       JAVA_LIBS=-ladvapi32
       AC_DEFINE(HAVE_JAVA, 1,
         [Define to 1 if Java is available and is at least version 1.5])
       break
     ;;
     mingw*)
       if test $have_msvc = yes; then
-        build_java=true
+        build_java=yes
         JAVA_LIBS=-ladvapi32
         AC_DEFINE(HAVE_JAVA, 1,
           [Define to 1 if Java is available and is at least version 1.5])
         break
       fi
     ;;
   esac
 
@@ -2504,36 +2507,36 @@ do
       else
         JAVA_CPPFLAGS="-I${JAVA_HOME}/include -I${JAVA_HOME}/include/linux"
       fi
     ;;
   esac
 
   ## Verify jni.h include file exists.
   JNI_PATH=`echo $JAVA_CPPFLAGS | sed -e 's/-I//g'`
-  have_jni=false
+  have_jni=no
   for dir in $JNI_PATH; do 
-    if test -f "${dir}/jni.h"; then have_jni=true; break; fi
+    if test -f "${dir}/jni.h"; then have_jni=yes; break; fi
   done
-  if test $have_jni = true; then
+  if test $have_jni = yes; then
     AC_MSG_RESULT([$dir])
   else
     AC_MSG_RESULT([not found])
     AC_MSG_WARN([Include file <jni.h> not found.  Octave will not be able to call Java methods.])
     break
   fi
 
   ## Passed all configuration tests.  A workable Java installation was found.
-  build_java=true
+  build_java=yes
   AC_DEFINE(HAVE_JAVA, 1,
     [Define to 1 if Java is available and is at least version 1.5])
   break
 done
 
-AM_CONDITIONAL([AMCOND_HAVE_JAVA], [test $build_java = true])
+AM_CONDITIONAL([AMCOND_HAVE_JAVA], [test $build_java = yes])
 AC_SUBST(JAVA)
 AC_SUBST(JAVAC)
 AC_SUBST(JAR)
 AC_SUBST(JAVA_CPPFLAGS)
 AC_SUBST(JAVA_LIBS)
 AC_DEFINE_UNQUOTED([JAVA_HOME], ["$JAVA_HOME"], [Java home (top-level installation dir)])
 AC_DEFINE_UNQUOTED([JAVA_LDPATH], ["$JAVA_LDPATH"], [Java library path (libjvm)])
 
@@ -2977,66 +2980,66 @@ Octave is now configured for $canonical_
   Include support for GNU readline:   $USE_READLINE
   64-bit array dims and indexing:     $USE_64_BIT_IDX_T
 ])
 
 warn_msg_printed=false
 
 OCTAVE_CONFIGURE_WARNING_SUMMARY
 
-if $ENABLE_DYNAMIC_LINKING; then
-  if test $SHARED_LIBS = false; then
+if test $ENABLE_DYNAMIC_LINKING = yes; then
+  if test $SHARED_LIBS = no; then
     AC_MSG_WARN([You used --enable-dl but not --enable-shared.])
     AC_MSG_WARN([Are you sure that is what you want to do?])
     warn_msg_printed=true
   fi
 fi
 
-if $USE_64_BIT_IDX_T; then
+if test $USE_64_BIT_IDX_T = yes; then
   AC_MSG_WARN([])
   AC_MSG_WARN([You used the EXPERIMENTAL --enable-64 option.])
   AC_MSG_WARN([Are you sure that is what you want to do?])
   AC_MSG_WARN([])
   AC_MSG_WARN([Your Fortran compiler must have an option to generate])
   AC_MSG_WARN([code with 8 byte signed INTEGER values.  This option])
   AC_MSG_WARN([should be specified in the F77_INTEGER_8_FLAG variable])
   AC_MSG_WARN([Make.  This should work automatically for gfortran.  If])
   AC_MSG_WARN([you use another compiler, you will need to set this])
   AC_MSG_WARN([variable on the configure command line.  You must also])
   AC_MSG_WARN([compile the ARPACK, BLAS, LAPACK, QRUPDATE, and SuiteSparse])
   AC_MSG_WARN([libraries to use 8 byte signed integers for array indexing.])
   AC_MSG_WARN([])
   warn_msg_printed=true
 fi
 
-if $USE_OPENMP; then
+if test $USE_OPENMP = yes; then
   AC_MSG_WARN([])
   AC_MSG_WARN([You used the EXPERIMENTAL --enable-openmp option.])
   AC_MSG_WARN([Are you sure that is what you want to do?])
   AC_MSG_WARN([])
   AC_MSG_WARN([This option enables experimental SMP multithreding])
   AC_MSG_WARN([code that has had very little testing.  There is no])
   AC_MSG_WARN([certainity that the results returned by Octave with])
   AC_MSG_WARN([this option enabled will be correct.])
   AC_MSG_WARN([])
   warn_msg_printed=true
 fi
 
-if test $native_graphics = false; then
+if test $native_graphics != yes; then
   AC_MSG_WARN([])
   AC_MSG_WARN([I didn't find the necessary libraries to compile native])
   AC_MSG_WARN([graphics.  It isn't necessary to have native graphics,])
   AC_MSG_WARN([but you will need to have gnuplot installed or you won't])
   AC_MSG_WARN([be able to use any of Octave's plotting commands])
   AC_MSG_WARN([])
   warn_msg_printed=true
 fi
 
 if test -n "$warn_gnuplot"; then
-  if $native_graphics; then
+  if test $native_graphics = yes; then
     AC_MSG_WARN([])
     AC_MSG_WARN([I didn't find gnuplot.  Plotting commands will use the])
     AC_MSG_WARN([native graphics toolkit.])
   else
     AC_MSG_WARN([I didn't find gnuplot.  It isn't necessary to have gnuplot])
     AC_MSG_WARN([installed, but you won't be able to use any of Octave's])
     AC_MSG_WARN([plotting commands without it.])
   fi
@@ -3050,25 +3053,25 @@ if test -n "$warn_gnuplot"; then
   AC_MSG_WARN([at the Octave prompt.])
   AC_MSG_WARN([])
   AC_MSG_WARN([Setting default value to $GNUPLOT])
   AC_MSG_WARN([])
 
   warn_msg_printed=true
 fi
 
-if $USE_ATOMIC_REFCOUNT; then
+if test $USE_ATOMIC_REFCOUNT = yes; then
   AC_MSG_WARN([])
   AC_MSG_WARN([Using atomic reference counting.])
   AC_MSG_WARN([This feature allows access to Octave data safely from])
   AC_MSG_WARN([another thread, for instance from a GUI.  However this])
   AC_MSG_WARN([results in a small performance penalty in the Octave])
   AC_MSG_WARN([interpreter.])
   AC_MSG_WARN([])
-  if $USE_OCTAVE_ALLOCATOR; then
+  if test $USE_OCTAVE_ALLOCATOR = yes; then
     AC_MSG_WARN([Thread-safe behavior is not guaranteed unless you also])
     AC_MSG_WARN([disable the use of the octave_allocator class.])
     AC_MSG_WARN([])
   fi
   warn_msg_printed=true
 fi
 
 if $warn_msg_printed; then
diff --git a/doc/interpreter/contributors.in b/doc/interpreter/contributors.in
--- a/doc/interpreter/contributors.in
+++ b/doc/interpreter/contributors.in
@@ -5,16 +5,17 @@ Joel Andersson
 Muthiah Annamalai
 Marco Atzeri
 Shai Ayal
 Roger Banks
 Ben Barrowes
 Alexander Barth
 David Bateman
 Heinz Bauschke
+Julien Bect
 Roman Belov
 Karl Berry
 David Billinghurst
 Don Bindner
 Jakub Bogusz
 Moritz Borgmann
 Paul Boven
 Richard Bovey
diff --git a/doc/interpreter/octave.texi b/doc/interpreter/octave.texi
--- a/doc/interpreter/octave.texi
+++ b/doc/interpreter/octave.texi
@@ -85,17 +85,18 @@ modified versions.
 @titlepage
 @title GNU Octave
 @subtitle A high-level interactive language for numerical computations
 @subtitle Edition 3 for Octave version @value{VERSION}
 @subtitle February 2011
 @sp 2
 @multitable @columnfractions 0.4 0.025 0.65
 @item
-@flushright @image{octave_logo,2.1in} @end flushright
+@flushright @image{octave_logo,2.1in}
+@end flushright
 @tab
 @c this is a spacer column
 @tab
 @sp 8
 @titlefont{Free Your Numbers} 
 @end multitable 
 @author John W. Eaton
 @author David Bateman
@@ -492,16 +493,19 @@ Plotting
 
 High-Level Plotting
 
 * Two-Dimensional Plots::       
 * Three-Dimensional Plots::  
 * Plot Annotations::            
 * Multiple Plots on One Page::  
 * Multiple Plot Windows::       
+* Use of axis@comma{} line@comma{} and patch Functions::
+* Manipulation of Plot Windows::
+* Use of the @code{interpreter} Property::
 * Printing and Saving Plots::              
 * Interacting with Plots::      
 * Test Plotting Functions::     
 
 Two-Dimensional Plots
 
 * Axis Configuration::  
 * Two-dimensional Function Plotting::  
diff --git a/doc/interpreter/plot.txi b/doc/interpreter/plot.txi
--- a/doc/interpreter/plot.txi
+++ b/doc/interpreter/plot.txi
@@ -57,16 +57,19 @@ If you need more detailed control, see @
 and @ref{Advanced Plotting}.
 
 @menu
 * Two-Dimensional Plots::       
 * Three-Dimensional Plots::  
 * Plot Annotations::            
 * Multiple Plots on One Page::  
 * Multiple Plot Windows::       
+* Use of axis@comma{} line@comma{} and patch Functions::
+* Manipulation of Plot Windows::
+* Use of the @code{interpreter} Property::
 * Printing and Saving Plots::              
 * Interacting with Plots::      
 * Test Plotting Functions::     
 @end menu
 
 @node Two-Dimensional Plots
 @subsection Two-Dimensional Plots
 
@@ -512,33 +515,34 @@ fplot (@@cos, [-10, 10]);
 @end group
 @end example
 
 @noindent
 creates two figures, with the first displaying a sine wave and
 the second a cosine wave.  Figure numbers must be positive integers.
 
 @DOCSTRING(figure)
-@subsection Use of @code{axis},  @code{line}, and @code{patch} functions
-@cindex use of @code{axis},  @code{line}, and @code{patch} functions
+
+@node Use of axis@comma{} line@comma{} and patch Functions
+@subsection Use of axis@comma{} line@comma{} and patch Functions
 
 You can create axes, line, and patch objects directly using the
 @code{axes}, @code{line}, and @code{patch} functions.  These objects
 become children of the current axes object.
 
 @DOCSTRING(axes)
 @DOCSTRING(line)
 @DOCSTRING(patch)
 
 @DOCSTRING(fill)
 
 @DOCSTRING(surface)
 
-@subsection Manipulation of plot windows
-@cindex manipulation of plot windows
+@node Manipulation of Plot Windows
+@subsection Manipulation of Plot Windows
 
 By default, Octave refreshes the plot window when a prompt is printed,
 or when waiting for input.  The
 @code{drawnow} function is used to cause a plot window to be updated.
 
 @DOCSTRING(drawnow)
 
 Only figures that are modified will be updated.  The @code{refresh}
@@ -586,18 +590,18 @@ figure window, call the @code{close} fun
 @DOCSTRING(shg)
 
 @DOCSTRING(delete)
 
 @DOCSTRING(close)
 
 @DOCSTRING(closereq)
 
+@node Use of the @code{interpreter} Property
 @subsection Use of the @code{interpreter} Property
-@cindex use of the @code{interpreter} property
 
 All text objects, including titles, labels, legends, and text, include
 the property 'interpreter', this property determines the manner in which
 special control sequences in the text are rendered.  If the interpreter
 is set to 'none', then no rendering occurs.  At this point the 'latex'
 option is not implemented and so the 'latex' interpreter also does not
 interpret the text.
 
@@ -2568,25 +2572,25 @@ of 2 is twice as wide as the default, et
 
 Marker styles are specified by the following properties:
 
 @table @code
 @item marker
 A character indicating a plot marker to be place at each data point, or
 @code{"none"}, meaning no markers should be displayed.
 
-@itemx markeredgecolor
+@item markeredgecolor
 The color of the edge around the marker, or @code{"auto"}, meaning that
 the edge color is the same as the face color.  @xref{Colors}.
 
-@itemx markerfacecolor
+@item markerfacecolor
 The color of the marker, or @code{"none"} to indicate that the marker
 should not be filled.  @xref{Colors}.
 
-@itemx markersize
+@item markersize
 A number specifying the size of the marker.  The default is 1.  A value
 of 2 is twice as large as the default, etc.
 @end table
 
 The @code{colstyle} function will parse a @code{plot}-style specification
 and will return the color, line, and marker values that would result.
 
 @DOCSTRING(colstyle)
diff --git a/doc/interpreter/tips.txi b/doc/interpreter/tips.txi
--- a/doc/interpreter/tips.txi
+++ b/doc/interpreter/tips.txi
@@ -291,30 +291,30 @@ that the text is lined up in the source 
 line.  This looks nice in the source code, but looks bizarre when users
 view the documentation.  Remember that the indentation before the
 starting double-quote is not part of the string!
 
 @item
 When choosing variable names try to adhere to the following guidelines.
 
 @table @asis
-@item 
-vectors : x,y,z,t,w
+@item vectors :
+x,y,z,t,w
 
-@item
-matrices : A,B,M
+@item matrices :
+A,B,M
 
-@item
-strings : @nospell{str},s
+@item strings :
+@nospell{str},s
 
-@item
-filenames : @nospell{fname}
+@item filenames :
+@nospell{fname}
 
-@item
-cells,@nospell{cellstrs} : c,@nospell{cstr}
+@item cells,@nospell{cellstrs} :
+c,@nospell{cstr}
 @end table
 
 @item
 The documentation string for a variable that is a yes-or-no flag should
 start with words such as ``Nonzero means@dots{}'', to make it clear that
 all nonzero values are equivalent and indicate explicitly what zero and
 nonzero mean.
 
diff --git a/libgui/src/files-dockwidget.cc b/libgui/src/files-dockwidget.cc
--- a/libgui/src/files-dockwidget.cc
+++ b/libgui/src/files-dockwidget.cc
@@ -31,17 +31,17 @@ along with Octave; see the file COPYING.
 #include <QFileInfo>
 #include <QCompleter>
 #include <QSettings>
 #include <QProcess>
 #include <QDebug>
 #include <QHeaderView>
 
 files_dock_widget::files_dock_widget (QWidget *p)
-  : QDockWidget (p)
+  : octave_dock_widget (p)
 {
   setObjectName ("FilesDockWidget");
   setWindowIcon (QIcon(":/actions/icons/logo.png"));
   setWindowTitle (tr ("Current Directory"));
   setWidget (new QWidget (this));
 
   // Create a toolbar
   _navigation_tool_bar = new QToolBar ("", widget ());
@@ -109,21 +109,16 @@ files_dock_widget::files_dock_widget (QW
 
   connect (_current_directory, SIGNAL (returnPressed ()),
            this, SLOT (handle_directory_entered ()));
 
   QCompleter *
     completer = new QCompleter (_file_system_model, this);
   _current_directory->setCompleter (completer);
 
-  connect (this, SIGNAL (visibilityChanged (bool)),
-           this, SLOT (handle_visibility_changed (bool)));
-  // topLevelChanged is emitted when floating property changes (floating = true)
-  connect (this, SIGNAL (topLevelChanged(bool)), this, SLOT(top_level_changed(bool)));
-
   setFocusProxy (_current_directory);
 }
 
 files_dock_widget::~files_dock_widget ()
 {
   QSettings *settings = resource_manager::get_settings ();
   int sort_column = _file_tree_view->header ()->sortIndicatorSection ();
   Qt::SortOrder sort_order = _file_tree_view->header ()->sortIndicatorOrder ();
@@ -198,33 +193,8 @@ files_dock_widget::notice_settings ()
   _file_tree_view->setColumnHidden (0, !settings->value ("showFilenames").toBool ());
   _file_tree_view->setColumnHidden (1, !settings->value ("showFileSize").toBool ());
   _file_tree_view->setColumnHidden (2, !settings->value ("showFileType").toBool ());
   _file_tree_view->setColumnHidden (3, !settings->value ("showLastModified").toBool ());
   _file_tree_view->setAlternatingRowColors (settings->value ("useAlternatingRowColors").toBool ());
   //if (settings.value ("showHiddenFiles").toBool ())
   // TODO: React on option for hidden files.
 }
-
-void
-files_dock_widget::handle_visibility_changed (bool visible)
-{
-  if (visible)
-    emit active_changed (true);
-}
-
-void
-files_dock_widget::closeEvent (QCloseEvent *e)
-{
-  emit active_changed (false);
-  QDockWidget::closeEvent (e);
-}
-
-// slot for signal that is emitted when floating property changes
-void
-files_dock_widget::top_level_changed (bool floating)
-{
-  if(floating)
-    {
-      setWindowFlags(Qt::Window);  // make a window from the widget when floating
-      show();                      // make it visible again since setWindowFlags hides it
-    }
-}
diff --git a/libgui/src/files-dockwidget.h b/libgui/src/files-dockwidget.h
--- a/libgui/src/files-dockwidget.h
+++ b/libgui/src/files-dockwidget.h
@@ -30,32 +30,33 @@ along with Octave; see the file COPYING.
 #include <QListWidget>
 #include <QFileSystemModel>
 #include <QToolBar>
 #include <QToolButton>
 #include <QVBoxLayout>
 #include <QAction>
 #include <QTreeView>
 
-#include <QDockWidget>
 #include <QLineEdit>
+#include "octave-dock-widget.h"
 
 /**
    \class files_dock_widget
    \brief Dock widget to display files in the current directory.
 */
-class files_dock_widget : public QDockWidget
+class files_dock_widget : public octave_dock_widget
 {
   Q_OBJECT
   public:
   /** Constructs a new files_dock_widget. */
   files_dock_widget (QWidget *parent = 0);
   ~files_dock_widget ();
 
 public slots:
+
   /** Slot for handling a change in directory via double click. */
   void item_double_clicked (const QModelIndex & index);
 
   /** Slot for handling the up-directory button in the toolbar. */
   void do_up_directory ();
 
   /** Sets the current directory being displayed. */
   void set_current_directory (const QString& currentDirectory);
@@ -63,34 +64,24 @@ public slots:
   /** Accepts user input a the line edit for the current directory. */
   void handle_directory_entered ();
 
   void display_directory (const QString& directory);
 
   /** Tells the widget to react on changed settings. */
   void notice_settings ();
 
-  /** Slot to steer changing visibility from outside. */
-  void handle_visibility_changed (bool visible);
-
-  /** Slot when floating property changes */
-  void top_level_changed (bool floating);
-
 signals:
   /** Emitted, whenever the user requested to open a file. */
   void open_file (const QString& fileName);
 
   /** Emitted, whenever the currently displayed directory changed. */
   void displayed_directory_changed (const QString& directory);
 
-  /** Custom signal that tells if a user has clicke away that dock widget. */
-  void active_changed (bool active);
-
 protected:
-  void closeEvent (QCloseEvent *event);
 
 private:
   // TODO: Add toolbar with buttons for navigating the path, creating dirs, etc
 
   QString           _last_current_directory;
 
   /** Toolbar for file and directory manipulation. */
   QToolBar *        _navigation_tool_bar;
diff --git a/libgui/src/history-dockwidget.cc b/libgui/src/history-dockwidget.cc
--- a/libgui/src/history-dockwidget.cc
+++ b/libgui/src/history-dockwidget.cc
@@ -32,17 +32,17 @@ along with Octave; see the file COPYING.
 #include "error.h"
 
 #include "cmd-hist.h"
 
 #include "history-dockwidget.h"
 #include "octave-link.h"
 
 history_dock_widget::history_dock_widget (QWidget * p)
-  : QDockWidget (p)
+  : octave_dock_widget (p)
 {
   setObjectName ("HistoryDockWidget");
   construct ();
 }
 
 void
 history_dock_widget::construct ()
 {
@@ -66,36 +66,25 @@ history_dock_widget::construct ()
   setWidget (new QWidget ());
 
   vbox_layout->addWidget (_history_list_view);
   vbox_layout->addWidget (_filter_line_edit);
   vbox_layout->setMargin (2);
 
   widget ()->setLayout (vbox_layout);
 
-  connect (_filter_line_edit,
-           SIGNAL (textEdited (QString)),
-           &_sort_filter_proxy_model,
-           SLOT (setFilterWildcard (QString)));
-
-  connect (_history_list_view,
-           SIGNAL (doubleClicked (QModelIndex)),
-           this,
-           SLOT (handle_double_click (QModelIndex)));
+  connect (_filter_line_edit, SIGNAL (textEdited (QString)),
+           &_sort_filter_proxy_model, SLOT (setFilterWildcard (QString)));
 
-  connect (this,
-           SIGNAL (visibilityChanged (bool)),
-           this,
-           SLOT (handle_visibility_changed (bool)));
+  connect (_history_list_view, SIGNAL (doubleClicked (QModelIndex)),
+           this, SLOT (handle_double_click (QModelIndex)));
 
-  // topLevelChanged is emitted when floating property changes (floating = true)
-  connect (this, SIGNAL (topLevelChanged(bool)), this, SLOT(top_level_changed(bool)));
-
-  _update_history_model_timer.setInterval (200);
-  _update_history_model_timer.setSingleShot (true);
+  _update_event_enabled = true;
+  _update_history_model_timer.setInterval (500);
+  _update_history_model_timer.setSingleShot (false);
 
   connect (&_update_history_model_timer,
            SIGNAL (timeout ()),
            this,
            SLOT (request_history_model_update ()));
 
   _update_history_model_timer.start ();
 
@@ -137,53 +126,32 @@ void history_dock_widget::handle_context
 
 void
 history_dock_widget::handle_double_click (QModelIndex modelIndex)
 {
   emit command_double_clicked (modelIndex.data().toString()+"\n");
 }
 
 void
-history_dock_widget::handle_visibility_changed (bool visible)
-{
-  if (visible)
-    emit active_changed (true);
-}
-
-void
 history_dock_widget::request_history_model_update ()
 {
-  octave_link::post_event (this, &history_dock_widget::update_history_callback);
+  if (_update_event_enabled)
+    {
+      _update_event_enabled = false;  // no more update until this one is processed
+      octave_link::post_event (this, &history_dock_widget::update_history_callback);
+    }
 }
 
 void
 history_dock_widget::reset_model ()
 {
   _history_model->setStringList (QStringList ());
 }
 
 void
-history_dock_widget::closeEvent (QCloseEvent *e)
-{
-  emit active_changed (false);
-  QDockWidget::closeEvent (e);
-}
-
-// slot for signal that is emitted when floating property changes
-void
-history_dock_widget::top_level_changed (bool floating)
-{
-  if(floating)
-    {
-      setWindowFlags(Qt::Window);  // make a window from the widget when floating
-      show();                      // make it visible again since setWindowFlags hides it
-    }
-}
-
-void
 history_dock_widget::update_history_callback (void)
 {
   static bool scroll_window = false;
 
   // Determine the client's (our) history length and the one of the server.
   int clientHistoryLength = _history_model->rowCount ();
   int serverHistoryLength = command_history::length ();
 
@@ -213,12 +181,12 @@ history_dock_widget::update_history_call
     }
   else if (scroll_window)
     {
       scroll_window = false;
 
       _history_list_view->scrollToBottom ();
     }
 
-  // Post a new update event in a given time. This prevents flooding the
-  // event queue.
-  _update_history_model_timer.start ();
+  // update is processed, re-enable further updates events triggered by timer
+    _update_event_enabled = true;
+
 }
diff --git a/libgui/src/history-dockwidget.h b/libgui/src/history-dockwidget.h
--- a/libgui/src/history-dockwidget.h
+++ b/libgui/src/history-dockwidget.h
@@ -18,46 +18,41 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, see
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifndef HISTORYDOCKWIDGET_H
 #define HISTORYDOCKWIDGET_H
 
-#include <QDockWidget>
 #include <QLineEdit>
 #include <QListView>
 #include <QSortFilterProxyModel>
 #include <QStringListModel>
 #include <QTimer>
+#include "octave-dock-widget.h"
 
-class history_dock_widget : public QDockWidget
+class history_dock_widget : public octave_dock_widget
 {
   Q_OBJECT
   public:
   history_dock_widget (QWidget *parent = 0);
 
 public slots:
-  void handle_visibility_changed (bool visible);
   void request_history_model_update ();
   void reset_model ();
-  /** Slot when floating property changes */
-  void top_level_changed (bool floating);
 
 signals:
   void information (const QString& message);
 
   /** Emitted, whenever the user double-clicked a command in the history. */
   void command_double_clicked (const QString& command);
 
-  /** Custom signal that tells if a user has clicked away that dock widget. */
-  void active_changed (bool active);
 protected:
-  void closeEvent (QCloseEvent *event);
+
 private slots:
   void handle_double_click (QModelIndex modelIndex);
   void handle_contextmenu_copy(bool flag);
   void handle_contextmenu_evaluate(bool flag);
   void ctxMenu(const QPoint &pos);
 
 private:
   void construct ();
@@ -66,11 +61,12 @@ private:
   QSortFilterProxyModel _sort_filter_proxy_model;
 
   /** Stores the current history_model. */
   QStringListModel *_history_model;
 
   QTimer _update_history_model_timer;
 
   void update_history_callback (void);
+  bool _update_event_enabled;
 };
 
 #endif // HISTORYDOCKWIDGET_H
diff --git a/libgui/src/m-editor/file-editor-interface.h b/libgui/src/m-editor/file-editor-interface.h
--- a/libgui/src/m-editor/file-editor-interface.h
+++ b/libgui/src/m-editor/file-editor-interface.h
@@ -18,32 +18,29 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, see
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifndef FILEEDITORINTERFACE_H
 #define FILEEDITORINTERFACE_H
 
-#include <QDockWidget>
 #include <QMenu>
 #include <QToolBar>
+#include "octave-dock-widget.h"
 
-class file_editor_interface : public QDockWidget
+class file_editor_interface : public octave_dock_widget
 {
   Q_OBJECT
 
   public:
   file_editor_interface (QWidget *p)
-    : QDockWidget (p)
+    : octave_dock_widget (p)
   {
     setObjectName ("FileEditor");
-
-    connect (this, SIGNAL (visibilityChanged (bool)), this,
-             SLOT (handle_visibility_changed (bool)));
   }
 
   virtual ~file_editor_interface () { }
 
   virtual QMenu *get_mru_menu ( ) = 0;
   virtual QMenu *debug_menu () = 0;
   virtual QToolBar *toolbar () = 0;
 
@@ -51,27 +48,17 @@ class file_editor_interface : public QDo
   virtual void handle_quit_debug_mode () = 0;
   virtual void set_focus () = 0;
 
 public slots:
   virtual void request_new_file () = 0;
   virtual void request_open_file () = 0;
   virtual void request_open_file (const QString& fileName) = 0;
 
-signals:
-  void active_changed (bool active);
+//signals:
 
-protected:
-  void closeEvent (QCloseEvent *e)
-  {
-    emit active_changed (false);
-    QDockWidget::closeEvent (e);
-  }
+//protected:
 
-protected slots:
-  void handle_visibility_changed (bool visible)
-  {
-    if (visible)
-      emit active_changed (true);
-  }
+//protected slots:
+
 };
 
 #endif // FILEEDITORINTERFACE_H
diff --git a/libgui/src/m-editor/file-editor.cc b/libgui/src/m-editor/file-editor.cc
--- a/libgui/src/m-editor/file-editor.cc
+++ b/libgui/src/m-editor/file-editor.cc
@@ -512,27 +512,16 @@ file_editor::handle_editor_state_changed
 
 void
 file_editor::notice_settings ()
 {
   // Relay signal to file editor tabs.
   emit fetab_settings_changed ();
 }
 
-// slot for signal that is emitted when floating property changes
-void
-file_editor::top_level_changed (bool floating)
-{
-  if(floating)
-    {
-      setWindowFlags(Qt::Window);  // make a window from the widget when floating
-      show();                      // make it visible again since setWindowFlag hides it
-    }
-}
-
 void
 file_editor::construct ()
 {
   QWidget *editor_widget = new QWidget (this);
 
   // FIXME -- what was the intended purpose of this unused variable?
   // QStyle *editor_style = QApplication::style ();
 
@@ -746,18 +735,16 @@ file_editor::construct ()
     {
       connect(_mru_file_actions[i], SIGNAL (triggered ()), this, SLOT (request_mru_open_file ()));
     }
   mru_menu_update ();
   connect (_tab_widget,
            SIGNAL (tabCloseRequested (int)), this, SLOT (handle_tab_close_request (int)));
   connect (_tab_widget,
            SIGNAL (currentChanged(int)), this, SLOT (active_tab_changed (int)));
-  // topLevelChanged is emitted when floating property changes (floating = true)
-  connect (this, SIGNAL (topLevelChanged(bool)), this, SLOT(top_level_changed(bool)));
 
   resize (500, 400);
   setWindowIcon (QIcon(":/actions/icons/logo.png"));
   setWindowTitle ("Editor");
 
   //restore previous session
   if (settings->value ("editor/restoreSession",true).toBool ())
     {
diff --git a/libgui/src/m-editor/file-editor.h b/libgui/src/m-editor/file-editor.h
--- a/libgui/src/m-editor/file-editor.h
+++ b/libgui/src/m-editor/file-editor.h
@@ -118,19 +118,16 @@ public slots:
   void handle_tab_close_request (int index);
   void handle_tab_remove_request ();
   void handle_add_filename_to_list (const QString& fileName);
   void active_tab_changed (int index);
   void handle_editor_state_changed (bool enableCopy, const QString& fileName);
   void handle_mru_add_file (const QString& file_name);
   void check_conflict_save (const QString& fileName, bool remove_on_success);
 
-  /** Slot when floating property changes */
-  void top_level_changed (bool floating);
-
   /** Tells the editor to react on changed settings. */
   void notice_settings ();
 
 private slots:
   void request_open_file (const QString& fileName);
 
 private:
   void construct ();
diff --git a/libgui/src/module.mk b/libgui/src/module.mk
--- a/libgui/src/module.mk
+++ b/libgui/src/module.mk
@@ -68,29 +68,31 @@ octave_gui_MOC = \
   src/moc-octave-qt-event-listener.cc \
   src/moc-settings-dialog.cc \
   src/moc-terminal-dockwidget.cc \
   src/moc-welcome-wizard.cc \
   src/moc-workspace-model.cc \
   src/moc-workspace-view.cc \
   src/octave-adapter/moc-octave-main-thread.cc \
   src/qtinfo/moc-parser.cc \
-  src/qtinfo/moc-webinfo.cc
+  src/qtinfo/moc-webinfo.cc \
+  src/moc-octave-dock-widget.cc
 
 octave_gui_RC = src/qrc-resource.cc
 
 octave_gui_UI = \
   src/settings-dialog.ui \
   src/welcome-wizard.ui
 
 octave_gui_UI_H = $(patsubst src/%.ui, src/ui-%.h, $(octave_gui_UI))
 
 BUILT_SOURCES += $(octave_gui_UI_H)
 
 noinst_HEADERS += \
+  src/octave-dock-widget.h \
   src/documentation-dockwidget.h \
   src/files-dockwidget.h \
   src/history-dockwidget.h \
   src/m-editor/file-editor-interface.h \
   src/m-editor/file-editor-tab.h \
   src/m-editor/file-editor.h \
   src/m-editor/find-dialog.h \
   src/m-editor/lexer-octave-gui.h \
diff --git a/libgui/src/octave-dock-widget.h b/libgui/src/octave-dock-widget.h
new file mode 100644
--- /dev/null
+++ b/libgui/src/octave-dock-widget.h
@@ -0,0 +1,81 @@
+/*
+
+Copyright (C) 2012-2013 Richard Crozier
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 3 of the License, or (at your
+option) any later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, see
+<http://www.gnu.org/licenses/>.
+
+*/
+
+#ifndef OCTAVEDOCKWIDGET_H
+#define OCTAVEDOCKWIDGET_H
+
+#include <QDockWidget>
+//#include <QMenu>
+//#include <QToolBar>
+
+class octave_dock_widget : public QDockWidget
+{
+  Q_OBJECT
+
+  public:
+  octave_dock_widget (QWidget *p)
+    : QDockWidget (p)
+  {
+    connect (this, SIGNAL (visibilityChanged (bool)),
+             this, SLOT (handle_visibility_changed (bool)));
+
+    connect (this, SIGNAL (topLevelChanged(bool)),
+             this, SLOT(top_level_changed(bool)));
+  }
+
+  virtual ~octave_dock_widget () { }
+
+signals:
+  /** Custom signal that tells if a user has clicked away
+   *  that dock widget, i.e the active dock widget has
+   *  changed. */
+  virtual void active_changed (bool active);
+
+protected:
+  virtual void closeEvent (QCloseEvent *e)
+  {
+    emit active_changed (false);
+    QDockWidget::closeEvent (e);
+  }
+
+protected slots:
+
+  /** Slot to steer changing visibility from outside. */
+  virtual void handle_visibility_changed (bool visible)
+  {
+    if (visible)
+      emit active_changed (true);
+  }
+
+  /** Slot when floating property changes */
+  virtual void top_level_changed (bool floating)
+  {
+    if(floating)
+      {
+        setWindowFlags(Qt::Window);  // make a window from the widget when floating
+        show();                      // make it visible again since setWindowFlags hides it
+      }
+  }
+
+};
+
+#endif // OCTAVEDOCKWIDGET_H
diff --git a/libgui/src/terminal-dockwidget.cc b/libgui/src/terminal-dockwidget.cc
--- a/libgui/src/terminal-dockwidget.cc
+++ b/libgui/src/terminal-dockwidget.cc
@@ -22,44 +22,20 @@ along with Octave; see the file COPYING.
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "terminal-dockwidget.h"
 
 terminal_dock_widget::terminal_dock_widget (QTerminal *terminal, QWidget *p)
-  : QDockWidget (p)
+  : octave_dock_widget (p)
 {
   setObjectName ("TerminalDockWidget");
   setWindowIcon (QIcon(":/actions/icons/logo.png"));
   setWindowTitle (tr ("Command Window"));
   setWidget (terminal);
 
   connect (this, SIGNAL (visibilityChanged (bool)), this, SLOT (handle_visibility_changed (bool)));
   // topLevelChanged is emitted when floating property changes (floating = true)
   connect (this, SIGNAL (topLevelChanged(bool)), this, SLOT(top_level_changed(bool)));
 }
 
-void
-terminal_dock_widget::closeEvent (QCloseEvent *e)
-{
-  emit active_changed (false);
-  QDockWidget::closeEvent (e);
-}
-
-void
-terminal_dock_widget::handle_visibility_changed (bool visible)
-{
-  if (visible)
-    emit active_changed (true);
-}
-
-// slot for signal that is emitted when floating property changes
-void
-terminal_dock_widget::top_level_changed (bool floating)
-{
-  if(floating)
-    {
-      setWindowFlags(Qt::Window);  // make a window from the widget when floating
-      show();                      // make it visible again since setWindowFlags hides it
-    }
-}
diff --git a/libgui/src/terminal-dockwidget.h b/libgui/src/terminal-dockwidget.h
--- a/libgui/src/terminal-dockwidget.h
+++ b/libgui/src/terminal-dockwidget.h
@@ -18,31 +18,27 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, see
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifndef TERMINALDOCKWIDGET_H
 #define TERMINALDOCKWIDGET_H
 
-#include <QDockWidget>
 #include "QTerminal.h"
+#include "octave-dock-widget.h"
 
-class terminal_dock_widget : public QDockWidget
+class terminal_dock_widget : public octave_dock_widget
 {
   Q_OBJECT
   public:
   terminal_dock_widget (QTerminal *terminal, QWidget *parent = 0);
 
 signals:
-  void active_changed (bool active);
 
 public slots:
-  void handle_visibility_changed (bool visible);
-  /** Slot when floating property changes */
-  void top_level_changed (bool floating);
 
 protected:
-  void closeEvent (QCloseEvent *event);
+
 };
 
 
 #endif // TERMINALDOCKWIDGET_H
diff --git a/libgui/src/workspace-model.cc b/libgui/src/workspace-model.cc
--- a/libgui/src/workspace-model.cc
+++ b/libgui/src/workspace-model.cc
@@ -1,8 +1,9 @@
+
 /*
 
 Copyright (C) 2011-2012 Jacob Dawid
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
@@ -46,30 +47,35 @@ workspace_model::workspace_model(QObject
   insert_top_level_item(1, new tree_item ("Global"));
   insert_top_level_item(2, new tree_item ("Persistent"));
 
   connect(&_update_workspace_model_timer,
           SIGNAL (timeout ()),
           this,
           SLOT (request_update_workspace()));
 
+  _update_event_enabled = true;
   _update_workspace_model_timer.setInterval (500);
-  _update_workspace_model_timer.setSingleShot (true);
+  _update_workspace_model_timer.setSingleShot (false);
   _update_workspace_model_timer.start ();
 }
 
 workspace_model::~workspace_model()
 {
   delete _rootItem;
 }
 
 void
 workspace_model::request_update_workspace ()
 {
-  octave_link::post_event (this, &workspace_model::update_workspace_callback);
+  if (_update_event_enabled)
+    {
+      _update_event_enabled = false;  // no more update until this one is processed
+      octave_link::post_event (this, &workspace_model::update_workspace_callback);
+    }
 }
 
 QModelIndex
 workspace_model::index(int row, int column, const QModelIndex &p) const
 {
   if (!hasIndex(row, column, p))
     return QModelIndex();
 
@@ -217,13 +223,12 @@ workspace_model::update_workspace_callba
         default:
           break;
         }
     }
 
   endResetModel();
   emit model_changed();
 
-  // Post a new event in a given time.
-  // This prevents flooding the event queue when no events are being processed.
-  _update_workspace_model_timer.start ();
+  // update is processed, re-enable further updates events triggered by timer
+  _update_event_enabled = true;
+
 }
-
diff --git a/libgui/src/workspace-model.h b/libgui/src/workspace-model.h
--- a/libgui/src/workspace-model.h
+++ b/libgui/src/workspace-model.h
@@ -135,16 +135,18 @@ class workspace_model
 public slots:
   void request_update_workspace ();
 
 signals:
   void model_changed ();
 
 private:
 
+  bool _update_event_enabled;
+
   void update_workspace_callback (void);
 
   /** Timer for periodically updating the workspace model from the current
    * symbol information. */
   QTimer _update_workspace_model_timer;
 
   /** Stores the current symbol information. */
   QList <symbol_information> _symbol_information;
diff --git a/libinterp/Makefile.am b/libinterp/Makefile.am
--- a/libinterp/Makefile.am
+++ b/libinterp/Makefile.am
@@ -351,12 +351,14 @@ CLEANFILES = \
   interpfcn/graphics-props.cc \
   parse-tree/oct-parse.output
 
 DISTCLEANFILES = \
   .DOCSTRINGS \
   DOCSTRINGS \
   $(BUILT_NODISTFILES) \
   $(OCT_FILES) \
-  $(OCT_STAMP_FILES)
+  $(OCT_STAMP_FILES) \
+  $(TST_FILES)
 
 MAINTAINERCLEANFILES = \
   $(BUILT_DISTFILES)
+
diff --git a/libinterp/corefcn/mappers.cc b/libinterp/corefcn/mappers.cc
--- a/libinterp/corefcn/mappers.cc
+++ b/libinterp/corefcn/mappers.cc
@@ -1877,27 +1877,31 @@ whether zero is signed, use the @code{si
 
 %!error sign ()
 %!error sign (1, 2)
 */
 
 DEFUNX ("signbit", Fsignbit, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} signbit (@var{x})\n\
-Return a nonzero value if the value of @var{x} has its sign bit set.\n\
+Return logical true if the value of @var{x} has its sign bit set.\n\
+Otherwise return logical false.  This behavior is consistent with the other\n\
+logical functions. See@ref{Logical Values}.  The behavior differs from the\n\
+C language function which returns non-zero if the sign bit is set.\n\
 \n\
 This is not the same as @code{x < 0.0}, because IEEE 754 floating point\n\
 allows zero to be signed.  The comparison @code{-0.0 < 0.0} is false,\n\
 but @code{signbit (-0.0)} will return a nonzero value.\n\
 @seealso{sign}\n\
 @end deftypefn")
 {
   octave_value retval;
-  if (args.length () == 1)
+  if (args.length () == 1) {
     retval = args(0).xsignbit ();
+    retval = (retval != 0); }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 %!assert (signbit (1) == 0)
diff --git a/libinterp/interp-core/dynamic-ld.cc b/libinterp/interp-core/dynamic-ld.cc
--- a/libinterp/interp-core/dynamic-ld.cc
+++ b/libinterp/interp-core/dynamic-ld.cc
@@ -192,119 +192,16 @@ octave_shlib_list::find_file (const std:
 
 void
 octave_shlib_list::display (void)
 {
   if (instance_ok ())
     instance->do_display ();
 }
 
-class
-octave_mex_file_list
-{
-public:
-
-  typedef std::list<octave_shlib>::iterator iterator;
-  typedef std::list<octave_shlib>::const_iterator const_iterator;
-
-  static void append (const octave_shlib& shl);
-
-  static void remove (octave_shlib& shl, octave_shlib::close_hook cl_hook = 0);
-
-private:
-
-  octave_mex_file_list (void) : file_list () { }
-
-  ~octave_mex_file_list (void) { }
-
-  void do_append (const octave_shlib& shl);
-
-  void do_remove (octave_shlib& shl, octave_shlib::close_hook cl_hook = 0);
-
-  static octave_mex_file_list *instance;
-
-  static void cleanup_instance (void) { delete instance; instance = 0; }
-
-  static bool instance_ok (void);
-
-  // List of libraries we have loaded.
-  std::list<octave_shlib> file_list;
-
-  // No copying!
-
-  octave_mex_file_list (const octave_mex_file_list&);
-
-  octave_mex_file_list& operator = (const octave_mex_file_list&);
-};
-
-octave_mex_file_list *octave_mex_file_list::instance = 0;
-
-void
-octave_mex_file_list::do_append (const octave_shlib& shl)
-{
-  file_list.push_back (shl);
-}
-
-void
-octave_mex_file_list::do_remove (octave_shlib& shl,
-                                 octave_shlib::close_hook cl_hook)
-{
-  for (iterator p = file_list.begin (); p != file_list.end (); p++)
-    {
-      if (*p == shl)
-        {
-          // Erase first to avoid potentially invalidating the pointer by the
-          // following hooks.
-          file_list.erase (p);
-
-          shl.close (cl_hook);
-
-          break;
-        }
-    }
-}
-
-bool
-octave_mex_file_list::instance_ok (void)
-{
-  bool retval = true;
-
-  if (! instance)
-    {
-      instance = new octave_mex_file_list ();
-
-      if (instance)
-        singleton_cleanup_list::add (cleanup_instance);
-    }
-
-  if (! instance)
-    {
-      ::error ("unable to create shared library list object!");
-
-      retval = false;
-    }
-
-  return retval;
-}
-
-void
-octave_mex_file_list::append (const octave_shlib& shl)
-{
-  if (instance_ok ())
-    instance->do_append (shl);
-}
-
-void
-octave_mex_file_list::remove (octave_shlib& shl,
-                              octave_shlib::close_hook cl_hook)
-{
-  if (instance_ok ())
-    instance->do_remove (shl, cl_hook);
-}
-
 octave_dynamic_loader *octave_dynamic_loader::instance = 0;
 
 bool octave_dynamic_loader::doing_load = false;
 
 bool
 octave_dynamic_loader::instance_ok (void)
 {
   bool retval = true;
@@ -439,18 +336,16 @@ octave_dynamic_loader::do_load_mex (cons
   if (! error_state)
     {
       if (mex_file)
         {
           void *function = 0;
 
           bool have_fmex = false;
 
-          octave_mex_file_list::append (mex_file);
-
           function = mex_file.search (fcn_name, mex_mangler);
 
           if (! function)
             {
               // FIXME -- can we determine this C mangling scheme
               // automatically at run time or configure time?
 
               function = mex_file.search (fcn_name, mex_uscore_mangler);
@@ -508,17 +403,17 @@ octave_dynamic_loader::do_remove_mex (co
   // We don't need to do anything if this is called because we are in
   // the process of reloading a .oct file that has changed.
 
   if (! doing_load)
     {
       retval = shl.remove (fcn_name);
 
       if (shl.number_of_functions_loaded () == 0)
-        octave_mex_file_list::remove (shl);
+        octave_shlib_list::remove (shl);
     }
 
   return retval;
 }
 
 octave_function *
 octave_dynamic_loader::load_oct (const std::string& fcn_name,
                                   const std::string& file_name,
diff --git a/libinterp/interp-core/oct-stream.h b/libinterp/interp-core/oct-stream.h
--- a/libinterp/interp-core/oct-stream.h
+++ b/libinterp/interp-core/oct-stream.h
@@ -366,22 +366,16 @@ public:
   virtual std::istream *input_stream (void) { return 0; }
 
   // If the derived class provides this function and it returns a
   // pointer to a valid ostream, flush(), write(), and printf() will
   // automatically work for this stream.
 
   virtual std::ostream *output_stream (void) { return 0; }
 
-  // If the derived class is locale-aware, it must implement this function 
-  // in order to set a new locale. By default, this function avoids messing 
-  // with locales and ignores its input argument.
-  virtual std::locale imbue ( const std::locale &)
-    { return std::locale::classic (); }
-
   // Return TRUE if this stream is open.
 
   bool is_open (void) const { return open_state; }
 
   virtual void do_close (void) { }
 
   void close (void)
     {
@@ -614,33 +608,17 @@ public:
   {
     return rep ? rep->input_stream () : 0;
   }
 
   std::ostream *output_stream (void)
   {
     return rep ? rep->output_stream () : 0;
   }
-  
-  std::locale imbue (const std::locale & loc )
-    {
-      if (!rep) return std::locale::classic ();
-      
-      std::istream *is = rep->input_stream ();
-      std::ostream *os = rep->output_stream ();
-      
-      if (os) 
-        {
-          if (is)
-            (void) is->imbue (loc);
-          return os->imbue (loc);
-        }
-      return is ? is->imbue (loc) : std::locale::classic ();
-    }
-  
+
   void clearerr (void) { if (rep) rep->clearerr (); }
 
 private:
 
   // The actual representation of this stream.
   octave_base_stream *rep;
 
   bool stream_ok (bool clear = true) const
diff --git a/libinterp/interp-core/pt-jit.cc b/libinterp/interp-core/pt-jit.cc
--- a/libinterp/interp-core/pt-jit.cc
+++ b/libinterp/interp-core/pt-jit.cc
@@ -31,22 +31,22 @@ along with Octave; see the file COPYING.
 #include "defun.h"
 #include "ov.h"
 #include "pt-all.h"
 #include "pt-jit.h"
 #include "sighandlers.h"
 #include "symtab.h"
 #include "variables.h"
 
+#ifdef HAVE_LLVM
+
 static bool Venable_jit_debugging = false;
 
 static bool Venable_jit_compiler = true;
 
-#ifdef HAVE_LLVM
-
 #include <llvm/Analysis/CallGraph.h>
 #include <llvm/Analysis/Passes.h>
 #include <llvm/Analysis/Verifier.h>
 #include <llvm/Bitcode/ReaderWriter.h>
 #include <llvm/LLVMContext.h>
 #include <llvm/ExecutionEngine/ExecutionEngine.h>
 #include <llvm/ExecutionEngine/JIT.h>
 #include <llvm/Module.h>
diff --git a/libinterp/interpfcn/data.cc b/libinterp/interpfcn/data.cc
--- a/libinterp/interpfcn/data.cc
+++ b/libinterp/interpfcn/data.cc
@@ -4724,17 +4724,27 @@ if fewer than two values are requested.\
 
   if (nargin != 2 && nargin != 3)
     {
       print_usage ();
       return retval;
     }
 
   if (nargin == 3)
-    npoints = args(2).idx_type_value ();
+    {
+      // Apparently undocumented Matlab.  If the third arg is an empty
+      // numeric value, the number of points defaults to 1.
+
+      octave_value arg_3 = args(2);
+
+      if (arg_3.is_numeric_type () && arg_3.is_empty ())
+        npoints = 1;
+      else
+        npoints = arg_3.idx_type_value ();
+    }
 
   if (! error_state)
     {
       octave_value arg_1 = args(0);
       octave_value arg_2 = args(1);
 
       if (arg_1.is_single_type () || arg_2.is_single_type ())
         {
@@ -4765,16 +4775,18 @@ if fewer than two values are requested.\
 %! x2 = linspace (1, 2, 10);
 %! x3 = linspace (1, -2, 10);
 %! assert (size (x1) == [1, 100] && x1(1) == 1 && x1(100) == 2);
 %! assert (size (x2) == [1, 10] && x2(1) == 1 && x2(10) == 2);
 %! assert (size (x3) == [1, 10] && x3(1) == 1 && x3(10) == -2);
 
 %assert (linspace ([1, 2; 3, 4], 5, 6), linspace (1, 5, 6))
 
+%assert (linspace (0, 1, []), 1)
+
 %!error linspace ()
 %!error linspace (1, 2, 3, 4)
 */
 
 // FIXME -- should accept dimensions as separate args for N-d
 // arrays as well as 1-d and 2-d arrays.
 
 DEFUN (resize, args, ,
diff --git a/libinterp/interpfcn/dirfns.cc b/libinterp/interpfcn/dirfns.cc
--- a/libinterp/interpfcn/dirfns.cc
+++ b/libinterp/interpfcn/dirfns.cc
@@ -551,19 +551,19 @@ DEFUN (glob, args, ,
 @deftypefn {Built-in Function} {} glob (@var{pattern})\n\
 Given an array of pattern strings (as a char array or a cell array) in\n\
 @var{pattern}, return a cell array of file names that match any of\n\
 them, or an empty cell array if no patterns match.  The pattern strings are\n\
 interpreted as filename globbing patterns (as they are used by Unix shells).\n\
 Within a pattern\n\
 \n\
 @table @code\n\
-@itemx *\n\
+@item *\n\
 matches any string, including the null string,\n\
-@itemx ?\n\
+@item ?\n\
 matches any single character, and\n\
 \n\
 @item [@dots{}]\n\
 matches any of the enclosed characters.\n\
 @end table\n\
 \n\
 Tilde expansion\n\
 is performed on each of the patterns before looking for matching file\n\
diff --git a/libinterp/interpfcn/file-io.cc b/libinterp/interpfcn/file-io.cc
--- a/libinterp/interpfcn/file-io.cc
+++ b/libinterp/interpfcn/file-io.cc
@@ -38,19 +38,17 @@ along with Octave; see the file COPYING.
 #include <config.h>
 #endif
 
 #include <cerrno>
 #include <cstdio>
 
 #include <iostream>
 #include <limits>
-#include <locale>
 #include <stack>
-#include <stdexcept>
 #include <vector>
 
 #include <fcntl.h>
 #include <sys/types.h>
 #include <unistd.h>
 
 #ifdef HAVE_ZLIB_H
 #include <zlib.h>
@@ -641,33 +639,33 @@ specified is binary mode.\n\
 \n\
 Additionally, you may append a \"z\" to the mode string to open a\n\
 gzipped file for reading or writing.  For this to be successful, you\n\
 must also open the file in binary mode.\n\
 \n\
 The parameter @var{arch} is a string specifying the default data format\n\
 for the file.  Valid values for @var{arch} are:\n\
 \n\
-@table @asis\n\
-@samp{native}\n\
+@table @samp\n\
+@item native\n\
 The format of the current machine (this is the default).\n\
 \n\
-@samp{ieee-be}\n\
+@item ieee-be\n\
 IEEE big endian format.\n\
 \n\
-@samp{ieee-le}\n\
+@item ieee-le\n\
 IEEE little endian format.\n\
 \n\
-@samp{vaxd}\n\
+@item vaxd\n\
 VAX D floating format.\n\
 \n\
-@samp{vaxg}\n\
+@item vaxg\n\
 VAX G floating format.\n\
 \n\
-@samp{cray}\n\
+@item cray\n\
 Cray floating format.\n\
 @end table\n\
 \n\
 @noindent\n\
 however, conversions are currently only supported for @samp{native}\n\
 @samp{ieee-be}, and @samp{ieee-le} formats.\n\
 @seealso{fclose, fgets, fgetl, fscanf, fread, fputs, fdisp, fprintf, fwrite, fskipl, fseek, frewind, ftell, feof, ferror, fclear, fflush, freport}\n\
 @end deftypefn")
@@ -1082,17 +1080,17 @@ converted.\n\
     print_usage ();
 
   return retval;
 }
 
 DEFUN (fscanf, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {[@var{val}, @var{count}, @var{errmsg}] =} fscanf (@var{fid}, @var{template}, @var{size})\n\
-@deftypefnx {Built-in Function} {[@var{v1}, @var{v2}, @dots{}, @var{count}] =} fscanf (@var{fid}, @var{template}, @var{locale})\n\
+@deftypefnx {Built-in Function} {[@var{v1}, @var{v2}, @dots{}, @var{count}, @var{errmsg}] =} fscanf (@var{fid}, @var{template}, \"C\")\n\
 In the first form, read from @var{fid} according to @var{template},\n\
 returning the result in the matrix @var{val}.\n\
 \n\
 The optional argument @var{size} specifies the amount of data to read\n\
 and may be one of\n\
 \n\
 @table @code\n\
 @item Inf\n\
@@ -1121,20 +1119,17 @@ conversions.\n\
 The number of items successfully read is returned in @var{count}.\n\
 \n\
 If an error occurs, @var{errmsg} contains a system-dependent error message.\n\
 \n\
 In the second form, read from @var{fid} according to @var{template},\n\
 with each conversion specifier in @var{template} corresponding to a\n\
 single scalar return value.  This form is more `C-like', and also\n\
 compatible with previous versions of Octave.  The number of successful\n\
-conversions is returned in @var{count}.  It permits to explicitly\n\
-specify a locale to take into account language specific features, \n\
-such as decimal separator.  This operation restores the previous locales\n\
-setting at the end of the conversion.\n\
+conversions is returned in @var{count}\n\
 @ifclear OCTAVE_MANUAL\n\
 \n\
 See the Formatted Input section of the GNU Octave manual for a\n\
 complete description of the syntax of the template string.\n\
 @end ifclear\n\
 @seealso{fgets, fgetl, fread, scanf, sscanf, fopen}\n\
 @end deftypefn")
 {
@@ -1146,35 +1141,17 @@ complete description of the syntax of th
 
   if (nargin == 3 && args(2).is_string ())
     {
       octave_stream os = octave_stream_list::lookup (args(0), who);
 
       if (! error_state)
         {
           if (args(1).is_string ())
-            {
-              std::locale oldloc;
-              try
-                {
-                  // Use args(2) val as the new locale setting. Keep
-                  // old val for restoring afterwards.
-                  oldloc = 
-                    os.imbue (std::locale (args(2).string_value ().c_str ()));
-
-                }
-              catch (std::runtime_error)
-                {
-                  // Display a warning if the specified locale is unknown
-                  warning ("fscanf: invalid locale. Try 'locale -a' for a list of supported values.");
-                  oldloc = std::locale::classic ();
-                }
-              retval = os.oscanf (args(1), who);
-              os.imbue (oldloc);
-            }
+            retval = os.oscanf (args(1), who);
           else
             ::error ("%s: format TEMPLATE must be a string", who.c_str ());
         }
     }
   else
     {
       retval(2) = "unknown error";
       retval(1) = 0.0;
@@ -1232,17 +1209,17 @@ get_sscanf_data (const octave_value& val
     ::error ("sscanf: argument STRING must be a string");
 
   return retval;
 }
 
 DEFUN (sscanf, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {[@var{val}, @var{count}, @var{errmsg}, @var{pos}] =} sscanf (@var{string}, @var{template}, @var{size})\n\
-@deftypefnx {Built-in Function} {[@var{v1}, @var{v2}, @dots{}, @var{count}] =} sscanf (@var{string}, @var{template}, @var{locale})\n\
+@deftypefnx {Built-in Function} {[@var{v1}, @var{v2}, @dots{}, @var{count}, @var{errmsg}] =} sscanf (@var{string}, @var{template}, \"C\")\n\
 This is like @code{fscanf}, except that the characters are taken from the\n\
 string @var{string} instead of from a stream.  Reaching the end of the\n\
 string is treated as an end-of-file condition.  In addition to the values\n\
 returned by @code{fscanf}, the index of the next character to be read\n\
 is returned in @var{pos}.\n\
 @seealso{fscanf, scanf, sprintf}\n\
 @end deftypefn")
 {
@@ -1257,32 +1234,18 @@ is returned in @var{pos}.\n\
       std::string data = get_sscanf_data (args(0));
 
       if (! error_state)
         {
           octave_stream os = octave_istrstream::create (data);
 
           if (os.is_valid ())
             {
-              if (args(1).is_string ()) 
-                {
-                  // Use args(2) val as the new locale setting. As the os
-                  // object is short lived, we don't need to restore
-                  // locale afterwards.
-                  try
-                    {  
-                      os.imbue (std::locale (args(2).string_value ().c_str ()));
-                    }
-                  catch (std::runtime_error)
-                    {
-                      // Display a warning if the specified locale is unknown
-                      warning ("sscanf: invalid locale. Try 'locale -a' for a list of supported values.");
-                    }
-                  retval = os.oscanf (args(1), who);
-                }              
+              if (args(1).is_string ())
+                retval = os.oscanf (args(1), who);
               else
                 ::error ("%s: format TEMPLATE must be a string", who.c_str ());
             }
           else
             ::error ("%s: unable to create temporary input buffer",
                      who.c_str ());
         }
       else
@@ -1340,26 +1303,20 @@ is returned in @var{pos}.\n\
         }
       else
         print_usage ();
     }
 
   return retval;
 }
 
-/*
-%!test
-%! assert (sscanf ("1,2", "%f", "C"), 1)
-%! assert (sscanf ("1,2", "%f", "fr_FR"), 1.2)
-*/
-
 DEFUN (scanf, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {[@var{val}, @var{count}, @var{errmsg}] =} scanf (@var{template}, @var{size})\n\
-@deftypefnx {Built-in Function} {[@var{v1}, @var{v2}, @dots{}, @var{count}] =} scanf (@var{template}, @var{locale})\n\
+@deftypefnx {Built-in Function} {[@var{v1}, @var{v2}, @dots{}, @var{count}, @var{errmsg}]] =} scanf (@var{template}, \"C\")\n\
 This is equivalent to calling @code{fscanf} with @var{fid} = @code{stdin}.\n\
 \n\
 It is currently not useful to call @code{scanf} in interactive\n\
 programs.\n\
 @seealso{fscanf, sscanf, printf}\n\
 @end deftypefn")
 {
   int nargin = args.length ();
diff --git a/libinterp/interpfcn/input.cc b/libinterp/interpfcn/input.cc
--- a/libinterp/interpfcn/input.cc
+++ b/libinterp/interpfcn/input.cc
@@ -95,20 +95,16 @@ octave_time Vlast_prompt_time = 0.0;
 static char Vcompletion_append_char = ' ';
 
 // Global pointer for eval().
 std::string current_eval_string;
 
 // TRUE means get input from current_eval_string.
 bool get_input_from_eval_string = false;
 
-// TRUE means we haven't been asked for the input from
-// current_eval_string yet.
-bool input_from_eval_string_pending = false;
-
 // TRUE means that input is coming from a file that was named on
 // the command line.
 bool input_from_command_line_file = false;
 
 // TRUE means that stdin is a terminal, not a pipe or redirected file.
 bool stdin_is_tty = false;
 
 // TRUE means we're parsing a function file.
@@ -186,26 +182,26 @@ do_input_echo (const std::string& input_
 
           if (input_string[input_string.length () - 1] != '\n')
             octave_stdout << "\n";
         }
     }
 }
 
 std::string
-gnu_readline (const std::string& s, bool force_readline)
+gnu_readline (const std::string& s, bool& eof, bool force_readline)
 {
   octave_quit ();
 
+  eof = false;
+
   std::string retval;
 
   if (line_editing || force_readline)
     {
-      bool eof;
-
       retval = command_editor::readline (s, eof);
 
       if (! eof && retval.empty ())
         retval = "\n";
     }
   else
     {
       if (! s.empty () && (interactive || forced_interactive))
@@ -216,24 +212,32 @@ gnu_readline (const std::string& s, bool
           gnulib::fflush (stream);
         }
 
       FILE *curr_stream = command_editor::get_input_stream ();
 
       if (reading_fcn_file || reading_script_file || reading_classdef_file)
         curr_stream = ff_instream;
 
-      retval = octave_fgets (curr_stream);
+      retval = octave_fgets (curr_stream, eof);
     }
 
   return retval;
 }
 
+extern std::string
+gnu_readline (const std::string& s, bool force_readline)
+{
+  bool eof = false;
+
+  return gnu_readline (s, eof, force_readline);
+}
+
 static inline std::string
-interactive_input (const std::string& s, bool force_readline = false)
+interactive_input (const std::string& s, bool& eof, bool force_readline)
 {
   Vlast_prompt_time.stamp ();
 
   if (Vdrawnow_requested && (interactive || forced_interactive))
     {
       feval ("drawnow");
 
       flush_octave_stdout ();
@@ -242,24 +246,34 @@ interactive_input (const std::string& s,
       // in drawnow so that the error doesn't reappear at every prompt.
 
       Vdrawnow_requested = false;
 
       if (error_state)
         return "\n";
     }
 
-  return gnu_readline (s, force_readline);
+  return gnu_readline (s, eof, force_readline);
+}
+
+static inline std::string
+interactive_input (const std::string& s, bool force_readline = false)
+{
+  bool eof = false;
+
+  return interactive_input (s, eof, force_readline);
 }
 
 static std::string
-octave_gets (void)
+octave_gets (bool& eof)
 {
   octave_quit ();
 
+  eof = false;
+
   std::string retval;
 
   bool history_skip_auto_repeated_debugging_command = false;
 
   if ((interactive || forced_interactive)
       && (! (reading_fcn_file
              || reading_classdef_file
              || reading_script_file
@@ -275,17 +289,17 @@ octave_gets (void)
 
       flush_octave_stdout ();
 
       octave_pager_stream::reset ();
       octave_diary_stream::reset ();
 
       octave_diary << prompt;
 
-      retval = interactive_input (prompt);
+      retval = interactive_input (prompt, eof, false);
 
       // There is no need to update the load_path cache if there is no
       // user input.
       if (! retval.empty ()
           && retval.find_first_not_of (" \t\n\r") != std::string::npos)
         {
           load_path::update ();
 
@@ -296,17 +310,17 @@ octave_gets (void)
         }
       else if (Vdebugging)
         {
           retval = last_debugging_command;
           history_skip_auto_repeated_debugging_command = true;
         }
     }
   else
-    retval = gnu_readline ("");
+    retval = gnu_readline ("", eof, false);
 
   current_input_line = retval;
 
   if (! current_input_line.empty ())
     {
       if (! (input_from_startup_file || input_from_command_line_file
              || history_skip_auto_repeated_debugging_command))
         command_history::add (current_input_line);
@@ -324,109 +338,45 @@ octave_gets (void)
   else if (! (reading_fcn_file || reading_script_file || reading_classdef_file))
     octave_diary << "\n";
 
   return retval;
 }
 
 // Read a line from the input stream.
 
-static std::string
-get_user_input (void)
+std::string
+get_user_input (bool& eof)
 {
   octave_quit ();
 
+  eof = false;
+
   std::string retval;
 
   if (get_input_from_eval_string)
     {
-      if (input_from_eval_string_pending)
-        {
-          input_from_eval_string_pending = false;
+      retval = current_eval_string;
 
-          retval = current_eval_string;
+      size_t len = retval.length ();
 
-          size_t len = retval.length ();
+      // Clear the global eval string so that the next call will return
+      // an empty character string with EOF = true.
+      current_eval_string = "";
 
-          if (len > 0 && retval[len-1] != '\n')
-            retval.append ("\n");
-        }
+      eof = true;
     }
   else
-    retval = octave_gets ();
+    retval = octave_gets (eof);
 
   current_input_line = retval;
 
   return retval;
 }
 
-int
-octave_read (char *buf, unsigned max_size)
-{
-  // FIXME -- is this a safe way to buffer the input?
-
-  static const char * const eol = "\n";
-  static std::string input_buf;
-  static const char *pos = 0;
-  static size_t chars_left = 0;
-
-  int status = 0;
-  if (chars_left == 0)
-    {
-      pos = 0;
-
-      input_buf = get_user_input ();
-
-      chars_left = input_buf.length ();
-
-      pos = input_buf.c_str ();
-    }
-
-  if (chars_left > 0)
-    {
-      size_t len = max_size > chars_left ? chars_left : max_size;
-      assert (len > 0);
-
-      memcpy (buf, pos, len);
-
-      chars_left -= len;
-      pos += len;
-
-      // Make sure input ends with a new line character.
-      if (chars_left == 0 && buf[len-1] != '\n')
-        {
-          if (len < max_size)
-            {
-              // There is enough room to plug the newline character in
-              // the buffer.
-              buf[len++] = '\n';
-            }
-          else
-            {
-              // There isn't enough room to plug the newline character
-              // in the buffer so make sure it is returned on the next
-              // octave_read call.
-              pos = eol;
-              chars_left = 1;
-            }
-        }
-
-      status = len;
-
-    }
-  else if (chars_left == 0)
-    {
-      status = 0;
-    }
-  else
-    status = -1;
-
-  return status;
-}
-
 // Fix things up so that input can come from file 'name', printing a
 // warning if the file doesn't exist.
 
 FILE *
 get_input_from_file (const std::string& name, int warn)
 {
   FILE *instream = 0;
 
@@ -712,45 +662,43 @@ get_debug_input (const std::string& prom
       frame.protect_var (input_from_startup_file);
       input_from_startup_file = false;
 
       frame.protect_var (input_from_command_line_file);
       input_from_command_line_file = false;
 
       frame.protect_var (get_input_from_eval_string);
       get_input_from_eval_string = false;
-
-      YY_BUFFER_STATE old_buf = current_buffer ();
-      YY_BUFFER_STATE new_buf = create_buffer (get_input_from_stdin ());
+    }
 
-      // FIXME: are these safe?
-      frame.add_fcn (switch_to_buffer, old_buf);
-      frame.add_fcn (delete_buffer, new_buf);
+  // octave_parser constructor sets this for us.
+  frame.protect_var (CURR_LEXER);
 
-      switch_to_buffer (new_buf);
-    }
+  octave_parser *curr_parser = new octave_parser ();
+  frame.add_fcn (octave_parser::cleanup, curr_parser);
 
   while (Vdebugging)
     {
+      unwind_protect middle_frame;
+
       reset_error_handler ();
 
-      reset_parser ();
+      curr_parser->reset ();
 
       // Save current value of global_command.
-      frame.protect_var (global_command);
+      middle_frame.protect_var (global_command);
 
       global_command = 0;
 
       // Do this with an unwind-protect cleanup function so that the
       // forced variables will be unmarked in the event of an interrupt.
       symbol_table::scope_id scope = symbol_table::top_scope ();
-      frame.add_fcn (symbol_table::unmark_forced_variables, scope);
+      middle_frame.add_fcn (symbol_table::unmark_forced_variables, scope);
 
-      // This is the same as yyparse in parse.y.
-      int retval = octave_parse ();
+      int retval = curr_parser->run ();
 
       if (retval == 0 && global_command)
         {
           unwind_protect inner_frame;
 
           // Use an unwind-protect cleanup function so that the
           // global_command list will be deleted in the event of an
           // interrupt.
@@ -758,20 +706,16 @@ get_debug_input (const std::string& prom
           inner_frame.add_fcn (cleanup_statement_list, &global_command);
 
           global_command->accept (*current_evaluator);
 
           if (octave_completion_matches_called)
             octave_completion_matches_called = false;
         }
 
-      // Unmark forced variables.
-      // Restore previous value of global_command.
-      frame.run (2);
-
       octave_quit ();
     }
 }
 
 // If the user simply hits return, this will produce an empty matrix.
 
 static octave_value_list
 get_user_input (const octave_value_list& args, int nargout)
@@ -838,18 +782,18 @@ get_user_input (const octave_value_list&
   else
     error ("input: reading user-input failed!");
 
   return retval;
 }
 
 DEFUN (input, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} input (@var{prompt})\n\
-@deftypefnx {Built-in Function} {} input (@var{prompt}, \"s\")\n\
+@deftypefn  {Built-in Function} {@var{ans} =} input (@var{prompt})\n\
+@deftypefnx {Built-in Function} {@var{ans} =} input (@var{prompt}, \"s\")\n\
 Print a prompt and wait for user input.  For example,\n\
 \n\
 @example\n\
 input (\"Pick a number, any number! \")\n\
 @end example\n\
 \n\
 @noindent\n\
 prints the prompt\n\
@@ -869,17 +813,18 @@ of values produced by the evaluation of 
 If you are only interested in getting a literal string value, you can\n\
 call @code{input} with the character string @code{\"s\"} as the second\n\
 argument.  This tells Octave to return the string entered by the user\n\
 directly, without evaluating it first.\n\
 \n\
 Because there may be output waiting to be displayed by the pager, it is\n\
 a good idea to always call @code{fflush (stdout)} before calling\n\
 @code{input}.  This will ensure that all pending output is written to\n\
-the screen before your prompt.  @xref{Input and Output}.\n\
+the screen before your prompt.\n\
+@seealso{yes_or_no, kbhit}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin == 1 || nargin == 2)
     retval = get_user_input (args, nargout);
@@ -904,22 +849,24 @@ octave_yes_or_no (const std::string& pro
         return false;
       else
         message (0, "Please answer yes or no.");
     }
 }
 
 DEFUN (yes_or_no, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} yes_or_no (@var{prompt})\n\
-Ask the user a yes-or-no question.  Return 1 if the answer is yes.\n\
-Takes one argument, which is the string to display to ask the\n\
-question.  It should end in a space; @samp{yes-or-no-p} adds\n\
-@samp{(yes or no) } to it.  The user must confirm the answer with\n\
-RET and can edit it until it has been confirmed.\n\
+@deftypefn {Built-in Function} {@var{ans} =} yes_or_no (\"@var{prompt}\")\n\
+Ask the user a yes-or-no question.  Return logical true if the answer is yes\n\
+or false if the answer is no.  Takes one argument, @var{prompt}, which is\n\
+the string to display when asking the question.  @var{prompt} should end in\n\
+a space; @code{yes-or-no} adds the string @samp{(yes or no) } to it.  The\n\
+user must confirm the answer with @key{RET} and can edit it until it has\n\
+been confirmed.\n\
+@seealso{input}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 0 || nargin == 1)
     {
@@ -981,17 +928,17 @@ do_keyboard (const octave_value_list& ar
     get_debug_input (prompt);
 
   return retval;
 }
 
 DEFUN (keyboard, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} keyboard ()\n\
-@deftypefnx {Built-in Function} {} keyboard (@var{prompt})\n\
+@deftypefnx {Built-in Function} {} keyboard (\"@var{prompt}\")\n\
 This function is normally used for simple debugging.  When the\n\
 @code{keyboard} function is executed, Octave prints a prompt and waits\n\
 for user input.  The input strings are then evaluated and the results\n\
 are printed.  This makes it possible to examine the values of variables\n\
 within a function, and to assign new values if necessary.  To leave the\n\
 prompt and return to normal execution type @samp{return} or @samp{dbcont}.\n\
 The @code{keyboard} function does not return an exit status.\n\
 \n\
@@ -1236,41 +1183,38 @@ for details.\n\
 
 typedef std::map<std::string, octave_value> hook_fcn_map_type;
 
 static hook_fcn_map_type hook_fcn_map;
 
 static int
 input_event_hook (void)
 {
-  if (! lexer_flags.defining_func)
-    {
-      hook_fcn_map_type::iterator p = hook_fcn_map.begin ();
+  hook_fcn_map_type::iterator p = hook_fcn_map.begin ();
 
-      while (p != hook_fcn_map.end ())
-        {
-          std::string hook_fcn = p->first;
-          octave_value user_data = p->second;
+  while (p != hook_fcn_map.end ())
+    {
+      std::string hook_fcn = p->first;
+      octave_value user_data = p->second;
 
-          hook_fcn_map_type::iterator q = p++;
+      hook_fcn_map_type::iterator q = p++;
 
-          if (is_valid_function (hook_fcn))
-            {
-              if (user_data.is_defined ())
-                feval (hook_fcn, user_data, 0);
-              else
-                feval (hook_fcn, octave_value_list (), 0);
-            }
+      if (is_valid_function (hook_fcn))
+        {
+          if (user_data.is_defined ())
+            feval (hook_fcn, user_data, 0);
           else
-            hook_fcn_map.erase (q);
+            feval (hook_fcn, octave_value_list (), 0);
         }
+      else
+        hook_fcn_map.erase (q);
+    }
 
-      if (hook_fcn_map.empty ())
-        command_editor::remove_event_hook (input_event_hook);
-    }
+  if (hook_fcn_map.empty ())
+    command_editor::remove_event_hook (input_event_hook);
 
   return 0;
 }
 
 DEFUN (add_input_event_hook, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} add_input_event_hook (@var{fcn})\n\
 @deftypefnx {Built-in Function} {} add_input_event_hook (@var{fcn}, @var{data})\n\
diff --git a/libinterp/interpfcn/input.h b/libinterp/interpfcn/input.h
--- a/libinterp/interpfcn/input.h
+++ b/libinterp/interpfcn/input.h
@@ -30,30 +30,29 @@ along with Octave; see the file COPYING.
 #include <string>
 
 #include "oct-time.h"
 #include "oct-obj.h"
 #include "pager.h"
 
 class octave_value;
 
-extern OCTINTERP_API int octave_read (char *buf, unsigned max_size);
-extern OCTINTERP_API FILE *get_input_from_file (const std::string& name, int warn = 1);
+extern OCTINTERP_API std::string get_user_input (bool& eof);
+
+extern OCTINTERP_API FILE *get_input_from_file (const std::string& name,
+                                                int warn = 1);
+
 extern OCTINTERP_API FILE *get_input_from_stdin (void);
 
 // Global pointer for eval().
 extern std::string current_eval_string;
 
 // TRUE means get input from current_eval_string.
 extern bool get_input_from_eval_string;
 
-// TRUE means we haven't been asked for the input from
-// current_eval_string yet.
-extern bool input_from_eval_string_pending;
-
 // TRUE means that input is coming from a file that was named on
 // the command line.
 extern bool input_from_command_line_file;
 
 // TRUE means that stdin is a terminal, not a pipe or redirected file.
 extern bool stdin_is_tty;
 
 // TRUE means we're parsing a function file.
diff --git a/libinterp/interpfcn/oct-hist.cc b/libinterp/interpfcn/oct-hist.cc
--- a/libinterp/interpfcn/oct-hist.cc
+++ b/libinterp/interpfcn/oct-hist.cc
@@ -372,17 +372,19 @@ mk_tmp_hist_file (const octave_value_lis
 {
   std::string retval;
 
   string_vector hlist = command_history::list ();
 
   int hist_count = hlist.length () - 1;  // switch to zero-based indexing
 
   // The current command line is already part of the history list by
-  // the time we get to this point.  Delete it from the list.
+  // the time we get to this point.  Delete the cmd from the list when
+  // executing 'edit_history' so that it doesn't show up in the history
+  // but the actual commands performed will.
 
   if (! insert_curr)
     command_history::remove (hist_count);
 
   hist_count--;  // skip last entry in history list
 
   // If no numbers have been specified, the default is to edit the
   // last command in the history list.
@@ -516,23 +518,25 @@ do_edit_history (const octave_value_list
       // Skip blank lines.
 
       if (line[0] == '\n')
         {
           delete [] line;
           continue;
         }
 
-      if (first)
-        {
-          first = 0;
-          edit_history_repl_hist (line);
-        }
-      else
-        edit_history_add_hist (line);
+      // Command 'edit history' has already been removed in
+      // mk_tmp_hist_file ()
+      //if (first)
+      //  {
+      //    first = 0;
+      //    edit_history_repl_hist (line);
+      //  }
+      //else
+      edit_history_add_hist (line);
 
       delete [] line;
     }
 
   file.close ();
 
   // Turn on command echo, so the output from this will make better
   // sense.
@@ -633,37 +637,40 @@ omitted, the previous command in the his
 
   do_edit_history (args);
 
   return retval;
 }
 
 DEFUN (history, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Command} history options\n\
-@deftypefnx {Built-in Function} {@var{h} = } history (@var{opt1}, @var{opt2}, @dots{})\n\
+@deftypefn  {Command} {} history\n\
+@deftypefnx {Command} {} history @var{opt1} @dots{}\n\
+@deftypefnx {Built-in Function} {@var{h} =} history ()\n\
+@deftypefnx {Built-in Function} {@var{h} =} history (@var{opt1}, @dots{})\n\
 If invoked with no arguments, @code{history} displays a list of commands\n\
 that you have executed.  Valid options are:\n\
 \n\
 @table @code\n\
-@item -w @var{file}\n\
-Write the current history to the file @var{file}.  If the name is\n\
-omitted, use the default history file (normally @file{~/.octave_hist}).\n\
+@item   @var{n}\n\
+@itemx -@var{n}\n\
+Display only the most recent @var{n} lines of history.\n\
+\n\
+@item -q\n\
+Don't number the displayed lines of history.  This is useful for cutting\n\
+and pasting commands using the X Window System.\n\
 \n\
 @item -r @var{file}\n\
 Read the file @var{file}, appending its contents to the current\n\
 history list.  If the name is omitted, use the default history file\n\
 (normally @file{~/.octave_hist}).\n\
 \n\
-@item @var{n}\n\
-Display only the most recent @var{n} lines of history.\n\
-\n\
-@item -q\n\
-Don't number the displayed lines of history.  This is useful for cutting\n\
-and pasting commands using the X Window System.\n\
+@item -w @var{file}\n\
+Write the current history to the file @var{file}.  If the name is\n\
+omitted, use the default history file (normally @file{~/.octave_hist}).\n\
 @end table\n\
 \n\
 For example, to display the five most recent commands that you have\n\
 typed without displaying line numbers, use the command\n\
 @kbd{history -q 5}.\n\
 \n\
 If invoked with a single output argument, the history will be saved to that\n\
 argument as a cell string and will not be output to screen.\n\
diff --git a/libinterp/interpfcn/symtab.cc b/libinterp/interpfcn/symtab.cc
--- a/libinterp/interpfcn/symtab.cc
+++ b/libinterp/interpfcn/symtab.cc
@@ -1044,65 +1044,51 @@ symbol_table::fcn_info::fcn_info_rep::fi
 // Insert INF_CLASS in the set of class names that are considered
 // inferior to SUP_CLASS.  Return FALSE if INF_CLASS is currently
 // marked as superior to  SUP_CLASS.
 
 bool
 symbol_table::set_class_relationship (const std::string& sup_class,
                                       const std::string& inf_class)
 {
-  class_precedence_table_const_iterator p
-    = class_precedence_table.find (inf_class);
-
-  if (p != class_precedence_table.end ())
-    {
-      const std::set<std::string>& inferior_classes = p->second;
+  if (is_superiorto (inf_class, sup_class))
+    return false;
 
-      std::set<std::string>::const_iterator q
-        = inferior_classes.find (sup_class);
-
-      if (q != inferior_classes.end ())
-        return false;
-    }
-
+  // If sup_class doesn't have an entry in the precedence table,
+  // this will automatically create it, and associate to it a
+  // singleton set {inf_class} of inferior classes.
   class_precedence_table[sup_class].insert (inf_class);
 
   return true;
 }
 
 // Has class A been marked as superior to class B?  Also returns
 // TRUE if B has been marked as inferior to A, since we only keep
-// one table, and convert inferiort information to a superiorto
+// one table, and convert inferiorto information to a superiorto
 // relationship.  Two calls are required to determine whether there
 // is no relationship between two classes:
 //
 //  if (symbol_table::is_superiorto (a, b))
 //    // A is superior to B, or B has been marked inferior to A.
 //  else if (symbol_table::is_superiorto (b, a))
 //    // B is superior to A, or A has been marked inferior to B.
 //  else
 //    // No relation.
 
 bool
 symbol_table::is_superiorto (const std::string& a, const std::string& b)
 {
-  bool retval = false;
-
   class_precedence_table_const_iterator p = class_precedence_table.find (a);
+  // If a has no entry in the precedence table, return false
+  if (p == class_precedence_table.end ())
+    return false;
 
-  if (p != class_precedence_table.end ())
-    {
-      const std::set<std::string>& inferior_classes = p->second;
-      std::set<std::string>::const_iterator q = inferior_classes.find (b);
-
-      if (q != inferior_classes.end ())
-        retval = true;
-    }
-
-  return retval;
+  const std::set<std::string>& inferior_classes = p->second;
+  std::set<std::string>::const_iterator q = inferior_classes.find (b);
+  return (q != inferior_classes.end ());
 }
 
 static std::string
 fcn_file_name (const octave_value& fcn)
 {
   const octave_function *f = fcn.function_value ();
 
   return f ? f->fcn_file_name () : std::string ();
@@ -1511,17 +1497,17 @@ symbol_table::do_update_nest (void)
         {
           symbol_record &ours = ti->second;
           symbol_record parents;
           if (! ours.is_formal ()
               && nest_parent->look_nonlocal (ti->first, parents))
             {
               if (ours.is_global () || ours.is_persistent ())
                 ::error ("global and persistent may only be used in the topmost level in which a nested variable is used");
-                
+
               if (! ours.is_formal ())
                 {
                   ours.invalidate ();
                   ti->second = parents;
                 }
             }
           else
             ours.set_curr_fcn (curr_fcn);
diff --git a/libinterp/interpfcn/sysdep.cc b/libinterp/interpfcn/sysdep.cc
--- a/libinterp/interpfcn/sysdep.cc
+++ b/libinterp/interpfcn/sysdep.cc
@@ -614,51 +614,53 @@ DEFALIAS (setenv, putenv);
 %! setenv ("dummy_variable_that_cannot_matter", "foobar");
 %! assert (getenv ("dummy_variable_that_cannot_matter"), "foobar");
 */
 
 // FIXME -- perhaps kbhit should also be able to print a prompt?
 
 DEFUN (kbhit, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} kbhit ()\n\
-Read a single keystroke from the keyboard.  If called with one\n\
+@deftypefn  {Built-in Function} {} kbhit ()\n\
+@deftypefnx {Built-in Function} {} kbhit (1)\n\
+Read a single keystroke from the keyboard.  If called with an\n\
 argument, don't wait for a keypress.  For example,\n\
 \n\
 @example\n\
 x = kbhit ();\n\
 @end example\n\
 \n\
 @noindent\n\
 will set @var{x} to the next character typed at the keyboard as soon as\n\
 it is typed.\n\
 \n\
 @example\n\
 x = kbhit (1);\n\
 @end example\n\
 \n\
 @noindent\n\
-identical to the above example, but don't wait for a keypress,\n\
+is identical to the above example, but doesn't wait for a keypress,\n\
 returning the empty string if no key is available.\n\
+@seealso{input}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   // FIXME -- add timeout and default value args?
 
   if (interactive || forced_interactive)
     {
       Fdrawnow ();
 
       int c = octave_kbhit (args.length () == 0);
 
       if (c == -1)
         c = 0;
 
-      char s[2] = {c, '\0'};
+      char s[2] = { static_cast<char> (c), '\0' };
 
       retval = s;
     }
 
   return retval;
 }
 
 DEFUN (pause, args, ,
diff --git a/libinterp/interpfcn/sysdep.h b/libinterp/interpfcn/sysdep.h
--- a/libinterp/interpfcn/sysdep.h
+++ b/libinterp/interpfcn/sysdep.h
@@ -25,19 +25,19 @@ along with Octave; see the file COPYING.
 
 #include <cstdio>
 
 #include <string>
 
 #include "lo-ieee.h"
 #include "lo-sysdep.h"
 
-extern void sysdep_init (void);
+extern OCTINTERP_API void sysdep_init (void);
 
-extern void sysdep_cleanup (void);
+extern OCTINTERP_API void sysdep_cleanup (void);
 
 extern OCTINTERP_API void raw_mode (bool, bool wait = true);
 
 extern OCTINTERP_API FILE *octave_popen (const char *command, const char *mode);
 extern OCTINTERP_API int octave_pclose (FILE *f);
 
 extern OCTINTERP_API int octave_kbhit (bool wait = true);
 
diff --git a/libinterp/interpfcn/toplev.cc b/libinterp/interpfcn/toplev.cc
--- a/libinterp/interpfcn/toplev.cc
+++ b/libinterp/interpfcn/toplev.cc
@@ -554,42 +554,49 @@ main_loop (void)
   octave_bad_alloc_hook = 0;
 
   octave_catch_interrupts ();
 
   octave_initialized = true;
 
   // The big loop.
 
+  unwind_protect frame;
+
+  // octave_parser constructor sets this for us.
+  frame.protect_var (CURR_LEXER);
+
+  octave_parser *curr_parser = new octave_parser ();
+  frame.add_fcn (octave_parser::cleanup, curr_parser);
+
   int retval = 0;
   do
     {
       try
         {
-          unwind_protect frame;
+          unwind_protect inner_frame;
 
           reset_error_handler ();
 
-          reset_parser ();
+          curr_parser->reset ();
 
           if (symbol_table::at_top_level ())
             tree_evaluator::reset_debug_state ();
 
           // Do this with an unwind-protect cleanup function so that
           // the forced variables will be unmarked in the event of an
           // interrupt.
           symbol_table::scope_id scope = symbol_table::top_scope ();
-          frame.add_fcn (symbol_table::unmark_forced_variables, scope);
+          inner_frame.add_fcn (symbol_table::unmark_forced_variables, scope);
 
-          frame.protect_var (global_command);
+          inner_frame.protect_var (global_command);
 
           global_command = 0;
 
-          // This is the same as yyparse in parse.y.
-          retval = octave_parse ();
+          retval = curr_parser->run ();
 
           if (retval == 0)
             {
               if (global_command)
                 {
                   // Use an unwind-protect cleanup function so that the
                   // global_command list will be deleted in the event of
                   // an interrupt.
@@ -627,17 +634,17 @@ main_loop (void)
                   else
                     {
                       if (octave_completion_matches_called)
                         octave_completion_matches_called = false;
                       else
                         command_editor::increment_current_command_number ();
                     }
                 }
-              else if (parser_end_of_input)
+              else if (curr_parser->end_of_input)
                 break;
             }
         }
       catch (octave_interrupt_exception)
         {
           recover_from_exception ();
           octave_stdout << "\n";
           if (quitting_gracefully)
diff --git a/libinterp/octave-value/ov-base-diag.cc b/libinterp/octave-value/ov-base-diag.cc
--- a/libinterp/octave-value/ov-base-diag.cc
+++ b/libinterp/octave-value/ov-base-diag.cc
@@ -104,17 +104,17 @@ octave_base_diag<DMT, MT>::do_index_op (
 
   if (idx.length () == 2 && ! resize_ok)
     {
       idx_vector idx0 = idx(0).index_vector ();
       idx_vector idx1 = idx(1).index_vector ();
 
       if (idx0.is_scalar () && idx1.is_scalar ())
         {
-          retval = matrix.elem (idx0(0), idx1(0));
+          retval = matrix.checkelem (idx0(0), idx1(0));
         }
       else
         {
           octave_idx_type m = idx0.length (matrix.rows ());
           octave_idx_type n = idx1.length (matrix.columns ());
           if (idx0.is_colon_equiv (m) && idx1.is_colon_equiv (n)
               && m <= matrix.rows () && n <= matrix.rows ())
             {
diff --git a/libinterp/octave-value/ov-cell.cc b/libinterp/octave-value/ov-cell.cc
--- a/libinterp/octave-value/ov-cell.cc
+++ b/libinterp/octave-value/ov-cell.cc
@@ -131,17 +131,18 @@ static void
 gripe_failed_assignment (void)
 {
   error ("assignment to cell array failed");
 }
 
 octave_value_list
 octave_cell::subsref (const std::string& type,
                       const std::list<octave_value_list>& idx,
-                      int nargout)
+                      int nargout,
+                      const std::list<octave_lvalue> *lvalue_list)
 {
   octave_value_list retval;
 
   switch (type[0])
     {
     case '(':
       retval(0) = do_index_op (idx.front ());
       break;
@@ -173,17 +174,19 @@ octave_cell::subsref (const std::string&
       panic_impossible ();
     }
 
   // FIXME -- perhaps there should be an
   // octave_value_list::next_subsref member function?  See also
   // octave_user_function::subsref.
 
   if (idx.size () > 1)
-    retval = retval(0).next_subsref (nargout, type, idx);
+    retval = (lvalue_list
+              ? retval(0).next_subsref (nargout, type, idx, lvalue_list)
+              : retval(0).next_subsref (nargout, type, idx));
 
   return retval;
 }
 
 octave_value
 octave_cell::subsref (const std::string& type,
                       const std::list<octave_value_list>& idx,
                       bool auto_add)
diff --git a/libinterp/octave-value/ov-cell.h b/libinterp/octave-value/ov-cell.h
--- a/libinterp/octave-value/ov-cell.h
+++ b/libinterp/octave-value/ov-cell.h
@@ -74,17 +74,26 @@ public:
   octave_value subsref (const std::string& type,
                         const std::list<octave_value_list>& idx)
     {
       octave_value_list tmp = subsref (type, idx, 1);
       return tmp.length () > 0 ? tmp(0) : octave_value ();
     }
 
   octave_value_list subsref (const std::string& type,
-                             const std::list<octave_value_list>& idx, int);
+                             const std::list<octave_value_list>& idx,
+                             int nargout)
+  {
+    return subsref (type, idx, nargout, 0);
+  }
+
+  octave_value_list subsref (const std::string& type,
+                             const std::list<octave_value_list>& idx,
+                             int nargout,
+                             const std::list<octave_lvalue> *lvalue_list);
 
   octave_value subsref (const std::string& type,
                         const std::list<octave_value_list>& idx,
                         bool auto_add);
 
   octave_value subsasgn (const std::string& type,
                          const std::list<octave_value_list>& idx,
                          const octave_value& rhs);
diff --git a/libinterp/octave-value/ov-class.cc b/libinterp/octave-value/ov-class.cc
--- a/libinterp/octave-value/ov-class.cc
+++ b/libinterp/octave-value/ov-class.cc
@@ -2186,102 +2186,85 @@ When called from a class constructor, ma
 constructed as having a higher precedence than @var{class_name}.\n\
 More that one such class can be specified in a single call.\n\
 This function may only be called from a class constructor.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   octave_function *fcn = octave_call_stack::caller ();
-
-  if (fcn && fcn->is_class_constructor ())
+  if ((! fcn) || (! fcn->is_class_constructor ()))
     {
-      for (int i = 0; i < args.length (); i++)
-        {
-          std::string class_name = args(i).string_value ();
-
-          if (! error_state)
-            {
-              if (! is_built_in_class (class_name))
-                {
-                  std::string this_class_name = fcn->name ();
+      error ("superiorto: invalid call from outside class constructor");
+      return retval;
+    }
 
-                  if (! symbol_table::set_class_relationship (this_class_name,
-                                                              class_name))
-                    {
-                      error ("superiorto: precedence already set for %s and %s",
-                             this_class_name.c_str (), class_name.c_str ());
-                      break;
-                    }
-                }
-              else
-                {
-                  // User defined classes always have higher precedence
-                  // than built-in classes.
-                }
-            }
-          else
-            {
+  for (int i = 0; i < args.length (); i++)
+    {
+      std::string inf_class = args(i).string_value ();
+      if (error_state)
+        {
               error ("superiorto: expecting argument to be class name");
               break;
-            }
+        }
+
+      // User defined classes always have higher precedence
+      // than built-in classes
+      if (is_built_in_class (inf_class))
+        break;
+
+      std::string sup_class = fcn->name ();
+      if (! symbol_table::set_class_relationship (sup_class, inf_class))
+        {
+          error ("superiorto: opposite precedence already set for %s and %s",
+                 sup_class.c_str (), inf_class.c_str ());
+          break;
         }
     }
-  else
-    error ("superiorto: invalid call from outside class constructor");
 
   return retval;
 }
 
 DEFUN (inferiorto, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} inferiorto (@var{class_name}, @dots{})\n\
 When called from a class constructor, mark the object currently\n\
 constructed as having a lower precedence than @var{class_name}.\n\
 More that one such class can be specified in a single call.\n\
 This function may only be called from a class constructor.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   octave_function *fcn = octave_call_stack::caller ();
-
-  if (fcn && fcn->is_class_constructor ())
+  if ((! fcn) || (! fcn->is_class_constructor ()))
     {
-      for (int i = 0; i < args.length (); i++)
-        {
-          std::string class_name = args(i).string_value ();
-
-          if (! error_state)
-            {
-              if (! is_built_in_class (class_name))
-                {
-                  std::string this_class_name = fcn->name ();
-
-                  symbol_table::set_class_relationship (class_name,
-                                                        this_class_name);
+      error ("inferiorto: invalid call from outside class constructor");
+      return retval;
+    }
 
-                  if (! symbol_table::set_class_relationship (this_class_name,
-                                                              class_name))
-                    {
-                      error ("inferiorto: precedence already set for %s and %s",
-                             this_class_name.c_str (), class_name.c_str ());
-                      break;
-                    }
-                }
-              else
-                {
-                  error ("inferiorto: cannot give user-defined class lower precedence than built-in class");
-                  break;
-                }
-            }
-          else
-            {
-              error ("inferiorto: expecting argument to be class name");
-              break;
-            }
+  for (int i = 0; i < args.length (); i++)
+    {
+      std::string sup_class = args(i).string_value ();
+      if (error_state)
+        {
+          error ("inferiorto: expecting argument to be class name");
+          break;
+        }
+
+      if (is_built_in_class (sup_class))
+        {
+          error ("inferiorto: cannot give user-defined class lower "
+                 "precedence than built-in class");
+          break;
+        }
+
+      std::string inf_class = fcn->name ();
+      if (! symbol_table::set_class_relationship (sup_class, inf_class))
+        {
+          error ("inferiorto: opposite precedence already set for %s and %s",
+                 inf_class.c_str (), sup_class.c_str ());
+          break;
         }
     }
-  else
-    error ("inferiorto: invalid call from outside class constructor");
 
   return retval;
 }
diff --git a/libinterp/octave-value/ov-java.cc b/libinterp/octave-value/ov-java.cc
--- a/libinterp/octave-value/ov-java.cc
+++ b/libinterp/octave-value/ov-java.cc
@@ -21,16 +21,21 @@ along with Octave; see the file COPYING.
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "defun.h"
 #include "error.h"
+#include "fpucw.h"
+
+#if HAVE_FPU_CONTROL_H
+#include <fpu_control.h>
+#endif
 
 #if defined HAVE_JAVA
 
 #if defined (HAVE_WINDOWS_H)
 #include <windows.h>
 #endif
 
 #include <algorithm>
@@ -387,16 +392,32 @@ initial_class_path (void)
         throw std::string ("octave.jar does not exist: ") + jar_file;
     }
   else
     throw std::string ("initial java dir is empty");
 
   return retval;
 }
 
+#ifndef _FPU_DEFAULT
+#if defined __i386__ || defined __x86_64__
+#define _FPU_DEFAULT 0x037f
+#else
+#define _FPU_DEFAULT 0
+#endif
+#endif
+
+static void
+restore_fpu_state (void)
+{
+  fpucw_t cw = GET_FPUCW ();
+  if (cw != _FPU_DEFAULT)
+    SET_FPUCW (_FPU_DEFAULT);
+}
+
 static void
 initialize_jvm (void)
 {
   // Most of the time JVM already exists and has been initialized.
   if (jvm)
     return;
 
   JNIEnv *current_env;
@@ -578,16 +599,18 @@ terminate_jvm (void)
       else
         jvm->DestroyJavaVM ();
 
       jvm = 0;
       jvm_attached = false;
 
       if (jvm_lib)
         jvm_lib.close ();
+
+      restore_fpu_state ();
     }
 }
 
 std::string
 jstring_to_string (JNIEnv* jni_env, jstring s)
 {
   std::string retval;
 
@@ -737,16 +760,18 @@ compute_array_dimensions (JNIEnv* jni_en
       if (idx >= dv.length ())
         dv.resize (idx+1);
       dv(idx) = len;
       jcls = reinterpret_cast<jclass> (jni_env->CallObjectMethod (jcls, getComponentType_ID));
       jobj = (len > 0 ? reinterpret_cast<jobjectArray> (jni_env->GetObjectArrayElement (jobj, 0)) : 0);
       idx++;
     }
 
+  restore_fpu_state ();
+
   return dv;
 }
 
 static jobject
 make_java_index (JNIEnv* jni_env, const octave_value_list& idx)
 {
   jclass_ref ocls (jni_env, jni_env->FindClass ("[I"));
   jobjectArray retval = jni_env->NewObjectArray (idx.length (), ocls, 0);
@@ -793,16 +818,18 @@ get_array_elements (JNIEnv* jni_env, job
       resObj = jni_env->CallStaticObjectMethod (helperClass, mID, jobj, jobject (java_idx));
     }
 
   if (resObj)
     retval = box (jni_env, resObj);
   else
     retval = check_exception (jni_env);
 
+  restore_fpu_state ();
+
   return retval;
 }
 
 static octave_value
 set_array_elements (JNIEnv* jni_env, jobject jobj,
                     const octave_value_list& idx, const octave_value& rhs)
 {
   octave_value retval;
@@ -821,16 +848,18 @@ set_array_elements (JNIEnv* jni_env, job
           jobj, jobject (java_idx), jobject (rhsObj));
     }
 
   if (resObj)
     retval = box (jni_env, resObj);
   else
     retval = check_exception (jni_env);
 
+  restore_fpu_state ();
+
   return retval;
 }
 
 static string_vector
 get_invoke_list (JNIEnv* jni_env, jobject jobj)
 {
   std::list<std::string> name_list;
 
@@ -857,16 +886,18 @@ get_invoke_list (JNIEnv* jni_env, jobjec
         }
 
       for (int i = 0; i < fLen; i++)
         {
           jobject_ref field (jni_env, jni_env->GetObjectArrayElement (fList, i));
           jstring_ref fieldName (jni_env, reinterpret_cast<jstring> (jni_env->CallObjectMethod (field, f_getName_ID)));
           name_list.push_back (jstring_to_string (jni_env, fieldName));
         }
+
+      restore_fpu_state ();
     }
 
   string_vector v (name_list);
 
   return v.sort (true);
 }
 
 static octave_value
@@ -916,16 +947,18 @@ convert_to_string (JNIEnv *jni_env, jobj
               if (js)
                 retval = octave_value (jstring_to_string (jni_env, js), type);
               else
                 retval = check_exception (jni_env);
             }
         }
       else
         error ("unable to convert Java object to string");
+
+      restore_fpu_state ();
     }
 
   return retval;
 }
 
 #define TO_JAVA(obj) dynamic_cast<octave_java*> ((obj).internal_rep ())
 
 octave_value
@@ -1150,16 +1183,18 @@ box_more (JNIEnv* jni_env, jobject jobj,
               retval = m;
             }
         }
     }
 
   if (retval.is_undefined ())
     retval = octave_value (new octave_java (jobj, jcls));
 
+  restore_fpu_state ();
+
   return retval;
 }
 
 int
 unbox (JNIEnv* jni_env, const octave_value& val, jobject_ref& jobj,
        jclass_ref& jcls)
 {
   int found = 1;
@@ -1376,16 +1411,18 @@ java_event_hook (void)
 {
   JNIEnv *current_env = octave_java::thread_jni_env ();
 
   if (current_env)
     {
       jclass_ref cls (current_env, find_octave_class (current_env, "org/octave/Octave"));
       jmethodID mID = current_env->GetStaticMethodID (cls, "checkPendingAction", "()V");
       current_env->CallStaticVoidMethod (cls, mID);
+
+      restore_fpu_state ();
     }
 
   return 0;
 }
 
 static void
 initialize_java (void)
 {
@@ -1401,16 +1438,18 @@ initialize_java (void)
 
           octave_thread_ID = get_current_thread_ID (current_env);
           //printf ("octave thread ID=%ld\n", octave_thread_ID);
         }
       catch (std::string msg)
         {
           error (msg.c_str ());
         }
+
+      restore_fpu_state ();
     }
 }
 
 JNIEXPORT jboolean JNICALL
 Java_org_octave_Octave_call (JNIEnv *env, jclass, jstring funcName,
                              jobjectArray argin, jobjectArray argout)
 {
   std::string fname = jstring_to_string (env, funcName);
@@ -1733,16 +1772,18 @@ octave_java::do_javaMethod (JNIEnv* jni_
           jstring_ref methName (jni_env, jni_env->NewStringUTF (name.c_str ()));
           jobjectArray_ref resObj (jni_env, reinterpret_cast<jobjectArray> (jni_env->CallStaticObjectMethod (helperClass, mID,
                                                                                                              to_java (), jstring (methName), jobjectArray (arg_objs), jobjectArray (arg_types))));
           if (resObj)
             retval = box (jni_env, resObj);
           else
             retval = check_exception (jni_env);
         }
+
+      restore_fpu_state ();
     }
 
   return retval;
 }
 
 octave_value
 octave_java:: do_javaMethod (JNIEnv* jni_env,
                               const std::string& class_name,
@@ -1763,16 +1804,18 @@ octave_java:: do_javaMethod (JNIEnv* jni
           jstring_ref clsName (jni_env, jni_env->NewStringUTF (class_name.c_str ()));
           jobject_ref resObj (jni_env, jni_env->CallStaticObjectMethod (helperClass, mID,
                                                                         jstring (clsName), jstring (methName), jobjectArray (arg_objs), jobjectArray (arg_types)));
           if (resObj)
             retval = box (jni_env, resObj);
           else
             retval = check_exception (jni_env);
         }
+
+      restore_fpu_state ();
     }
 
   return retval;
 }
 
 octave_value
 octave_java::do_javaObject (JNIEnv* jni_env, const std::string& name,
                              const octave_value_list& args)
@@ -1792,16 +1835,18 @@ octave_java::do_javaObject (JNIEnv* jni_
           jobject_ref resObj (jni_env, jni_env->CallStaticObjectMethod (helperClass, mID,
                                                                         jstring (clsName), jobjectArray (arg_objs), jobjectArray (arg_types)));
 
           if (resObj)
             retval = octave_value (new octave_java (resObj, 0));
           else
             check_exception (jni_env);
         }
+
+      restore_fpu_state ();
     }
 
   return retval;
 }
 
 octave_value
 octave_java::do_java_get (JNIEnv* jni_env, const std::string& name)
 {
@@ -1815,16 +1860,18 @@ octave_java::do_java_get (JNIEnv* jni_en
       jstring_ref fName (jni_env, jni_env->NewStringUTF (name.c_str ()));
       jobject_ref resObj (jni_env, jni_env->CallStaticObjectMethod (helperClass, mID,
           to_java (), jstring (fName)));
 
       if (resObj)
         retval = box (jni_env, resObj);
       else
         retval = check_exception (jni_env);
+
+      restore_fpu_state ();
     }
 
   return retval;
 }
 
 octave_value
 octave_java::do_java_get (JNIEnv* jni_env, const std::string& class_name,
                           const std::string& name)
@@ -1839,16 +1886,18 @@ octave_java::do_java_get (JNIEnv* jni_en
       jstring_ref cName (jni_env, jni_env->NewStringUTF (class_name.c_str ()));
       jstring_ref fName (jni_env, jni_env->NewStringUTF (name.c_str ()));
       jobject_ref resObj (jni_env, jni_env->CallStaticObjectMethod (helperClass, mID,
           jstring (cName), jstring (fName)));
       if (resObj)
         retval = box (jni_env, resObj);
       else
         retval = check_exception (jni_env);
+
+      restore_fpu_state ();
     }
 
   return retval;
 }
 
 octave_value
 octave_java::do_java_set (JNIEnv* jni_env, const std::string& name,
                           const octave_value& val)
@@ -1864,16 +1913,18 @@ octave_java::do_java_set (JNIEnv* jni_en
         {
           jclass_ref helperClass (jni_env, find_octave_class (jni_env, "org/octave/ClassHelper"));
           jmethodID mID = jni_env->GetStaticMethodID (helperClass, "setField",
                                                       "(Ljava/lang/Object;Ljava/lang/String;Ljava/lang/Object;)V");
           jstring_ref fName (jni_env, jni_env->NewStringUTF (name.c_str ()));
           jni_env->CallStaticObjectMethod (helperClass, mID, to_java (), jstring (fName), jobject (jobj));
           check_exception (jni_env);
         }
+
+      restore_fpu_state ();
     }
 
   return retval;
 }
 
 octave_value
 octave_java::do_java_set (JNIEnv* jni_env, const std::string& class_name,
                           const std::string& name, const octave_value& val)
@@ -1890,16 +1941,18 @@ octave_java::do_java_set (JNIEnv* jni_en
           jclass_ref helperClass (jni_env, find_octave_class (jni_env, "org/octave/ClassHelper"));
           jmethodID mID = jni_env->GetStaticMethodID (helperClass, "setStaticField",
                                                       "(Ljava/lang/String;Ljava/lang/String;Ljava/lang/Object;)V");
           jstring_ref cName (jni_env, jni_env->NewStringUTF (class_name.c_str ()));
           jstring_ref fName (jni_env, jni_env->NewStringUTF (name.c_str ()));
           jni_env->CallStaticObjectMethod (helperClass, mID, jstring (cName), jstring (fName), jobject (jobj));
           check_exception (jni_env);
         }
+
+      restore_fpu_state ();
     }
 
   return retval;
 }
 
 #endif  // endif on HAVE_JAVA
 
 // DEFUN blocks below must be outside of HAVE_JAVA block so that
diff --git a/libinterp/octave-value/ov-usr-fcn.cc b/libinterp/octave-value/ov-usr-fcn.cc
--- a/libinterp/octave-value/ov-usr-fcn.cc
+++ b/libinterp/octave-value/ov-usr-fcn.cc
@@ -512,17 +512,19 @@ octave_user_function::do_multi_index_op 
 
   BEGIN_PROFILER_BLOCK (profiler_name ())
 
   if (is_special_expr ())
     {
       tree_expression *expr = special_expr ();
 
       if (expr)
-        retval = expr->rvalue (nargout);
+        retval = (lvalue_list
+                  ? expr->rvalue (nargout, lvalue_list)
+                  : expr->rvalue (nargout));
     }
   else
     cmd_list->accept (*current_evaluator);
 
   END_PROFILER_BLOCK
 
   if (echo_commands)
     print_code_function_trailer ();
@@ -1037,9 +1039,29 @@ element-by-element and a logical array i
 %! assert (y, -2);
 %!
 %!error [~, ~] = try_isargout ();
 %!
 %% Check to see that isargout isn't sticky:
 %!test
 %! [x, y] = try_isargout ();
 %! assert ([x, y], [1, 2]);
+%!
+%% It should work without ():
+%!test
+%! [~, y] = try_isargout;
+%! assert (y, -2);
+%!
+%% It should work in function handles, anonymous functions, and cell
+%% arrays of handles or anonymous functions.
+%!test
+%! fh = @try_isargout;
+%! af = @() try_isargout;
+%! c = {fh, af};
+%! [~, y] = fh ();
+%! assert (y, -2);
+%! [~, y] = af ();
+%! assert (y, -2);
+%! [~, y] = c{1}();
+%! assert (y, -2);
+%! [~, y] = c{2}();
+%! assert (y, -2);
 */
diff --git a/libinterp/octave-value/ov.cc b/libinterp/octave-value/ov.cc
--- a/libinterp/octave-value/ov.cc
+++ b/libinterp/octave-value/ov.cc
@@ -1308,16 +1308,33 @@ octave_value::next_subsref (int nargout,
       for (size_t i = 0; i < skip; i++)
         new_idx.erase (new_idx.begin ());
       return subsref (type.substr (skip), new_idx, nargout);
     }
   else
     return *this;
 }
 
+octave_value_list
+octave_value::next_subsref (int nargout, const std::string& type,
+                            const std::list<octave_value_list>& idx,
+                            const std::list<octave_lvalue> *lvalue_list,
+                            size_t skip)
+{
+  if (! error_state && idx.size () > skip)
+    {
+      std::list<octave_value_list> new_idx (idx);
+      for (size_t i = 0; i < skip; i++)
+        new_idx.erase (new_idx.begin ());
+      return subsref (type.substr (skip), new_idx, nargout, lvalue_list);
+    }
+  else
+    return *this;
+}
+
 octave_value
 octave_value::next_subsref (bool auto_add, const std::string& type,
                             const std::list<octave_value_list>& idx,
                             size_t skip)
 {
   if (! error_state && idx.size () > skip)
     {
       std::list<octave_value_list> new_idx (idx);
diff --git a/libinterp/octave-value/ov.h b/libinterp/octave-value/ov.h
--- a/libinterp/octave-value/ov.h
+++ b/libinterp/octave-value/ov.h
@@ -414,16 +414,22 @@ public:
                              std::list<octave_value_list>& idx,
                              size_t skip = 1);
 
   octave_value_list next_subsref (int nargout,
                                   const std::string& type, const
                                   std::list<octave_value_list>& idx,
                                   size_t skip = 1);
 
+  octave_value_list next_subsref (int nargout,
+                                  const std::string& type, const
+                                  std::list<octave_value_list>& idx,
+                                  const std::list<octave_lvalue> *lvalue_list,
+                                  size_t skip = 1);
+
   octave_value next_subsref (bool auto_add, const std::string& type, const
                              std::list<octave_value_list>& idx,
                              size_t skip = 1);
 
   octave_value do_index_op (const octave_value_list& idx,
                             bool resize_ok = false)
     { return rep->do_index_op (idx, resize_ok); }
 
diff --git a/libinterp/octave.cc b/libinterp/octave.cc
--- a/libinterp/octave.cc
+++ b/libinterp/octave.cc
@@ -995,19 +995,16 @@ octave_execute_interpreter (void)
 
   // Avoid counting commands executed from startup files.
 
   command_editor::reset_current_command_number (1);
 
   // Now argv should have the full set of args.
   intern_argv (octave_cmdline_argc, octave_cmdline_argv);
 
-  if (! octave_embedded)
-    switch_to_buffer (create_buffer (get_input_from_stdin ()));
-
   // Force input to be echoed if not really interactive, but the user
   // has forced interactive behavior.
 
   if (! interactive && forced_interactive)
     {
       command_editor::blink_matching_paren (false);
 
       // FIXME -- is this the right thing to do?
diff --git a/libinterp/parse-tree/lex.h b/libinterp/parse-tree/lex.h
--- a/libinterp/parse-tree/lex.h
+++ b/libinterp/parse-tree/lex.h
@@ -19,100 +19,280 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #if !defined (octave_lex_h)
 #define octave_lex_h 1
 
 #include <list>
+#include <set>
 #include <stack>
 
-// FIXME -- these input buffer things should be members of a
-// parser input stream class.
-
-typedef struct yy_buffer_state *YY_BUFFER_STATE;
-
-// Associate a buffer with a new file to read.
-extern OCTINTERP_API YY_BUFFER_STATE create_buffer (FILE *f);
-
-// Report the current buffer.
-extern OCTINTERP_API YY_BUFFER_STATE current_buffer (void);
-
-// Connect to new buffer buffer.
-extern OCTINTERP_API void switch_to_buffer (YY_BUFFER_STATE buf);
-
-// Delete a buffer.
-extern OCTINTERP_API void delete_buffer (YY_BUFFER_STATE buf);
-
-extern OCTINTERP_API void clear_all_buffers (void);
-
 extern OCTINTERP_API void cleanup_parser (void);
 
 // Is the given string a keyword?
 extern bool is_keyword (const std::string& s);
 
-extern void prep_lexer_for_script_file (void);
-extern void prep_lexer_for_function_file (void);
-extern void prep_lexer_for_classdef_file (void);
+class
+stream_reader
+{
+public:
+  virtual int getc (void) = 0;
+  virtual int ungetc (int c) = 0;
+
+protected:
+  stream_reader (void) { }
+  ~stream_reader (void) { }
+
+private:
+
+  // No copying!
+  stream_reader (const stream_reader&);
+  stream_reader& operator = (const stream_reader&);
+};
+
+// Forward decl for lexical_feedback::token_stack.
+class token;
 
 // For communication between the lexer and parser.
 
 class
 lexical_feedback
 {
 public:
 
-  lexical_feedback (void)
+  // Did eat_whitespace or eat_continuation eat a space or tab, or a
+  // newline, or both?
+  //
+  // Functions that return this type will return a logical OR of the
+  // following values:
+  //
+  //  NO_WHITESPACE  no spaces to eat
+  //  SPACE_OR_TAB   space or tab in input
+  //  NEWLINE        bare new line in input
+
+  enum whitespace_type
+    {
+      NO_WHITESPACE = 1,
+      SPACE_OR_TAB = 2,
+      NEWLINE = 4
+    };
+
+  // Track nesting of square brackets, curly braces, and parentheses.
+
+  class bbp_nesting_level
+  {
+  private:
 
-    : bracketflag (0), braceflag (0), looping (0),
-      convert_spaces_to_comma (true), at_beginning_of_statement (true),
-      defining_func (0), looking_at_function_handle (0),
-      looking_at_anon_fcn_args (true),
-      looking_at_return_list (false), looking_at_parameter_list (false),
-      looking_at_decl_list (false), looking_at_initializer_expression (false),
-      looking_at_matrix_or_assign_lhs (false), looking_at_object_index (),
-      looking_for_object_index (false), do_comma_insert (false),
-      looking_at_indirect_ref (false), parsed_function_name (),
-      parsing_class_method (false), maybe_classdef_get_set_method (false),
-      parsing_classdef (false), parsing_classdef_get_method (false),
-      parsing_classdef_set_method (false), quote_is_transpose (false),
-      pending_local_variables ()
+    enum bracket_type
+      {
+        BRACKET = 1,
+        BRACE = 2,
+        PAREN = 3
+      };
+
+  public:
+
+    bbp_nesting_level (void) : context () { }
+
+    bbp_nesting_level (const bbp_nesting_level& nl) : context (nl.context) { }
 
+    bbp_nesting_level& operator = (const bbp_nesting_level& nl)
     {
-      init ();
+      if (&nl != this)
+        context = nl.context;
+
+      return *this;
+    }
+
+    ~bbp_nesting_level (void) { }
+
+    void bracket (void) { context.push (BRACKET); }
+
+    bool is_bracket (void)
+    {
+      return ! context.empty () && context.top () == BRACKET;
     }
 
-  ~lexical_feedback (void) { }
+    void brace (void) { context.push (BRACE); }
+
+    bool is_brace (void)
+    {
+      return ! context.empty () && context.top () == BRACE;
+    }
+
+    void paren (void) { context.push (PAREN); }
+
+    bool is_paren (void)
+    {
+      return ! context.empty () && context.top () == PAREN;
+    }
+
+    bool is_bracket_or_brace (void)
+    {
+      return (! context.empty ()
+              && (context.top () == BRACKET || context.top () == BRACE));
+    }
+
+    bool none (void) { return context.empty (); }
+
+    void remove (void)
+    {
+      if (! context.empty ())
+        context.pop ();
+    }
+
+    void clear (void)
+    {
+      while (! context.empty ())
+        context.pop ();
+    }
+
+  private:
+
+    std::stack<int> context;
+  };
+
+  lexical_feedback (void)
+    : scanner (0), convert_spaces_to_comma (true),
+      do_comma_insert (false), at_beginning_of_statement (true),
+      looking_at_anon_fcn_args (false), looking_at_return_list (false),
+      looking_at_parameter_list (false), looking_at_decl_list (false),
+      looking_at_initializer_expression (false),
+      looking_at_matrix_or_assign_lhs (false),
+      looking_for_object_index (false), 
+      looking_at_indirect_ref (false), parsing_class_method (false),
+      maybe_classdef_get_set_method (false), parsing_classdef (false),
+      quote_is_transpose (false),
+      input_line_number (1), current_input_column (1),
+      bracketflag (0), braceflag (0),
+      looping (0), defining_func (0), looking_at_function_handle (0),
+      block_comment_nesting_level (0),
+      looking_at_object_index (), parsed_function_name (),
+      pending_local_variables (), nesting_level ()
+  {
+    init ();
+  }
+
+  ~lexical_feedback (void);
 
   void init (void);
 
-  // Square bracket level count.
-  int bracketflag;
+  void reset (void);
+
+  void prep_for_script_file (void);
+
+  void prep_for_function_file (void);
+
+  void prep_for_classdef_file (void);
+
+  int octave_read (char *buf, unsigned int max_size);
+
+  char *flex_yytext (void);
+
+  int flex_yyleng (void);
+
+  void do_comma_insert_check (void);
+
+  int text_yyinput (void);
+
+  void xunput (char c, char *buf);
+
+  void xunput (char c);
+
+  void fixup_column_count (char *s);
+
+  bool inside_any_object_index (void);
+
+  int is_keyword_token (const std::string& s);
+
+  bool is_variable (const std::string& name);
+
+  std::string grab_block_comment (stream_reader& reader, bool& eof);
+
+  std::string grab_comment_block (stream_reader& reader, bool at_bol,
+                                  bool& eof);
+
+  int process_comment (bool start_in_block, bool& eof);
+
+  bool next_token_is_sep_op (void);
+
+  bool next_token_is_postfix_unary_op (bool spc_prev);
+
+  bool next_token_is_bin_op (bool spc_prev);
+
+  void scan_for_comments (const char *text);
+
+  int eat_whitespace (void);
+
+  void handle_number (void);
 
-  // Curly brace level count.
-  int braceflag;
+  bool have_continuation (bool trailing_comments_ok = true);
+
+  bool have_ellipsis_continuation (bool trailing_comments_ok = true);
+
+  int eat_continuation (void);
+
+  int handle_string (char delim);
+
+  bool next_token_is_assign_op (void);
+
+  bool next_token_is_index_op (void);
+
+  int handle_close_bracket (bool spc_gobbled, int bracket_type);
+
+  void maybe_unput_comma (int spc_gobbled);
+
+  bool next_token_can_follow_bin_op (void);
+
+  bool looks_like_command_arg (void);
+
+  int handle_superclass_identifier (void);
+
+  int handle_meta_identifier (void);
 
-  // TRUE means we're in the middle of defining a loop.
-  int looping;
+  int handle_identifier (void);
+
+  void maybe_warn_separator_insert (char sep);
+
+  void gripe_single_quote_string (void);
+
+  void gripe_matlab_incompatible (const std::string& msg);
+
+  void maybe_gripe_matlab_incompatible_comment (char c);
+
+  void gripe_matlab_incompatible_continuation (void);
+
+  void gripe_matlab_incompatible_operator (const std::string& op);
+
+  void push_token (token *);
+
+  token *current_token (void);
+
+  void display_token (int tok);
+
+  void fatal_error (const char *msg);
+
+  void lexer_debug (const char *pattern, const char *text);
+
+  // Internal state of the flex-generated lexer.
+  void *scanner;
 
   // TRUE means that we should convert spaces to a comma inside a
   // matrix definition.
   bool convert_spaces_to_comma;
 
+  // GAG.  Stupid kludge so that [[1,2][3,4]] will work.
+  bool do_comma_insert;
+
   // TRUE means we are at the beginning of a statement, where a
   // command name is possible.
   bool at_beginning_of_statement;
 
-  // Nonzero means we're in the middle of defining a function.
-  int defining_func;
-
-  // Nonzero means we are parsing a function handle.
-  int looking_at_function_handle;
-
   // TRUE means we are parsing an anonymous function argument list.
   bool looking_at_anon_fcn_args;
 
   // TRUE means we're parsing the return list for a function.
   bool looking_at_return_list;
 
   // TRUE means we're parsing the parameter list for a function.
   bool looking_at_parameter_list;
@@ -124,35 +304,23 @@ public:
   // TRUE means we are looking at the initializer expression for a
   // parameter list element.
   bool looking_at_initializer_expression;
 
   // TRUE means we're parsing a matrix or the left hand side of
   // multi-value assignment statement.
   bool looking_at_matrix_or_assign_lhs;
 
-  // If the front of the list is TRUE, the closest paren, brace, or
-  // bracket nesting is an index for an object.
-  std::list<bool> looking_at_object_index;
-
   // Object index not possible until we've seen something.
   bool looking_for_object_index;
 
-  // GAG.  Stupid kludge so that [[1,2][3,4]] will work.
-  bool do_comma_insert;
-
   // TRUE means we're looking at an indirect reference to a
   // structure element.
   bool looking_at_indirect_ref;
 
-  // If the top of the stack is TRUE, then we've already seen the name
-  // of the current function.  Should only matter if
-  // current_function_level > 0
-  std::stack<bool> parsed_function_name;
-
   // TRUE means we are parsing a class method in function or classdef file.
   bool parsing_class_method;
 
   // TRUE means we are parsing a class method declaration line in a
   // classdef file and can accept a property get or set method name.
   // For example, "get.PropertyName" is recognized as a function name.
   bool maybe_classdef_get_set_method;
 
@@ -163,46 +331,66 @@ public:
   bool parsing_classdef_get_method;
 
   // TRUE means we are parsing a classdef set.method.
   bool parsing_classdef_set_method;
 
   // Return transpose or start a string?
   bool quote_is_transpose;
 
+  // The current input line number.
+  int input_line_number;
+
+  // The column of the current token.
+  int current_input_column;
+
+  // Square bracket level count.
+  int bracketflag;
+
+  // Curly brace level count.
+  int braceflag;
+
+  // TRUE means we're in the middle of defining a loop.
+  int looping;
+
+  // Nonzero means we're in the middle of defining a function.
+  int defining_func;
+
+  // Nonzero means we are parsing a function handle.
+  int looking_at_function_handle;
+
+  // Nestng level for blcok comments.
+  int block_comment_nesting_level;
+
+  // If the front of the list is TRUE, the closest paren, brace, or
+  // bracket nesting is an index for an object.
+  std::list<bool> looking_at_object_index;
+
+  // If the top of the stack is TRUE, then we've already seen the name
+  // of the current function.  Should only matter if
+  // current_function_level > 0
+  std::stack<bool> parsed_function_name;
+
   // Set of identifiers that might be local variable names.
   std::set<std::string> pending_local_variables;
 
+  // Is the closest nesting level a square bracket, squiggly brace or
+  // a paren?
+  bbp_nesting_level nesting_level;
+
+  // For unwind protect.
+  static void cleanup (lexical_feedback *lexer) { delete lexer; }
+
 private:
 
+  // Stack to hold tokens so that we can delete them when the parser is
+  // reset and avoid growing forever just because we are stashing some
+  // information.
+  std::stack <token*> token_stack;
+
+  // No copying!
+
   lexical_feedback (const lexical_feedback&);
 
   lexical_feedback& operator = (const lexical_feedback&);
 };
 
-class
-stream_reader
-{
-public:
-  virtual int getc (void) = 0;
-  virtual int ungetc (int c) = 0;
-
-protected:
-  stream_reader (void) { }
-  ~stream_reader (void) { }
-
-private:
-
-  // No copying!
-  stream_reader (const stream_reader&);
-  stream_reader& operator = (const stream_reader&);
-};
-
-extern std::string
-grab_comment_block (stream_reader& reader, bool at_bol, bool& eof);
-
-// TRUE means that we have encountered EOF on the input stream.
-extern bool parser_end_of_input;
-
-// Flags that need to be shared between the lexer and parser.
-extern lexical_feedback lexer_flags;
-
 #endif
diff --git a/libinterp/parse-tree/lex.ll b/libinterp/parse-tree/lex.ll
--- a/libinterp/parse-tree/lex.ll
+++ b/libinterp/parse-tree/lex.ll
@@ -15,17 +15,31 @@ FITNESS FOR A PARTICULAR PURPOSE.  See t
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, see
 <http://www.gnu.org/licenses/>.
 
 */
 
+/*
+We are using the pure parser interface and the reentrant lexer
+interface but the Octave parser and lexer are NOT properly
+reentrant because both still use many global variables.  It should be
+safe to create a parser object and call it while anotehr parser
+object is active (to parse a callback function while the main
+interactive parser is waiting for input, for example) if you take
+care to properly save and restore (typically with an unwind_protect
+object) relevant global values before and after the nested call.
+*/
+
 %option prefix = "octave_"
+%option noyywrap
+%option reentrant
+%option bison-bridge
 
 %top {
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 }
 
@@ -49,19 +63,19 @@ along with Octave; see the file COPYING.
 
 #include <sys/types.h>
 #include <unistd.h>
 
 #include "cmd-edit.h"
 #include "quit.h"
 #include "lo-mappers.h"
 
-// These would be alphabetical, but y.tab.h must be included before
-// oct-gperf.h and y.tab.h must be included after token.h and the tree
-// class declarations.  We can't include y.tab.h in oct-gperf.h
+// These would be alphabetical, but oct-parse.h must be included before
+// oct-gperf.h and oct-parse.h must be included after token.h and the tree
+// class declarations.  We can't include oct-parse.h in oct-gperf.h
 // because it may not be protected to allow it to be included multiple
 // times.
 
 #include "Cell.h"
 #include "comment-list.h"
 #include "defun.h"
 #include "error.h"
 #include "gripes.h"
@@ -91,53 +105,45 @@ along with Octave; see the file COPYING.
 #endif
 
 #if ! (defined (FLEX_SCANNER) \
        && defined (YY_FLEX_MAJOR_VERSION) && YY_FLEX_MAJOR_VERSION >= 2 \
        && defined (YY_FLEX_MINOR_VERSION) && YY_FLEX_MINOR_VERSION >= 5)
 #error lex.l requires flex version 2.5.4 or later
 #endif
 
-#define yylval octave_lval
+#define YY_EXTRA_TYPE lexical_feedback *
+#define curr_lexer yyextra
 
 // Arrange to get input via readline.
 
 #ifdef YY_INPUT
 #undef YY_INPUT
 #endif
 #define YY_INPUT(buf, result, max_size) \
-  if ((result = octave_read (buf, max_size)) < 0) \
-    YY_FATAL_ERROR ("octave_read () in flex scanner failed");
+  result = curr_lexer->octave_read (buf, max_size)
 
 // Try to avoid crashing out completely on fatal scanner errors.
-// The call to yy_fatal_error should never happen, but it avoids a
-// 'static function defined but not used' warning from gcc.
 
 #ifdef YY_FATAL_ERROR
 #undef YY_FATAL_ERROR
 #endif
 #define YY_FATAL_ERROR(msg) \
-  do \
-    { \
-      error (msg); \
-      OCTAVE_QUIT; \
-      yy_fatal_error (msg); \
-    } \
-  while (0)
+  (yyget_extra (yyscanner))->fatal_error (msg)
 
 #define DISPLAY_TOK_AND_RETURN(tok) \
   do \
     { \
       int tok_val = tok; \
       if (Vdisplay_tokens) \
-        display_token (tok_val); \
+        curr_lexer->display_token (tok_val); \
       if (lexer_debug_flag) \
         { \
           std::cerr << "R: "; \
-          display_token (tok_val); \
+          curr_lexer->display_token (tok_val); \
           std::cerr << std::endl;  \
         } \
       return tok_val; \
     } \
   while (0)
 
 #define COUNT_TOK_AND_RETURN(tok) \
   do \
@@ -145,197 +151,90 @@ along with Octave; see the file COPYING.
       Vtoken_count++; \
       DISPLAY_TOK_AND_RETURN (tok); \
     } \
   while (0)
 
 #define TOK_RETURN(tok) \
   do \
     { \
-      current_input_column += yyleng; \
-      lexer_flags.quote_is_transpose = false; \
-      lexer_flags.convert_spaces_to_comma = true; \
+      curr_lexer->current_input_column += yyleng; \
+      curr_lexer->quote_is_transpose = false; \
+      curr_lexer->convert_spaces_to_comma = true; \
       COUNT_TOK_AND_RETURN (tok); \
     } \
   while (0)
 
 #define TOK_PUSH_AND_RETURN(name, tok) \
   do \
     { \
-      yylval.tok_val = new token (name, input_line_number, \
-                                  current_input_column); \
-      token_stack.push (yylval.tok_val); \
+      curr_lexer->push_token \
+        (new token (name, curr_lexer->input_line_number, \
+         curr_lexer->current_input_column)); \
       TOK_RETURN (tok); \
     } \
   while (0)
 
 #define BIN_OP_RETURN_INTERNAL(tok, convert, bos, qit) \
   do \
     { \
-      yylval.tok_val = new token (input_line_number, current_input_column); \
-      token_stack.push (yylval.tok_val); \
-      current_input_column += yyleng; \
-      lexer_flags.quote_is_transpose = qit; \
-      lexer_flags.convert_spaces_to_comma = convert; \
-      lexer_flags.looking_for_object_index = false; \
-      lexer_flags.at_beginning_of_statement = bos; \
+      curr_lexer->push_token \
+        (new token (curr_lexer->input_line_number, \
+         curr_lexer->current_input_column)); \
+      curr_lexer->current_input_column += yyleng; \
+      curr_lexer->quote_is_transpose = qit; \
+      curr_lexer->convert_spaces_to_comma = convert; \
+      curr_lexer->looking_for_object_index = false; \
+      curr_lexer->at_beginning_of_statement = bos; \
       COUNT_TOK_AND_RETURN (tok); \
     } \
   while (0)
 
 #define XBIN_OP_RETURN_INTERNAL(tok, convert, bos, qit) \
   do \
     { \
-      gripe_matlab_incompatible_operator (yytext); \
+      curr_lexer->gripe_matlab_incompatible_operator (yytext); \
       BIN_OP_RETURN_INTERNAL (tok, convert, bos, qit); \
     } \
   while (0)
 
 #define BIN_OP_RETURN(tok, convert, bos) \
   do \
     { \
       BIN_OP_RETURN_INTERNAL (tok, convert, bos, false); \
     } \
   while (0)
 
 #define XBIN_OP_RETURN(tok, convert, bos) \
   do \
     { \
-      gripe_matlab_incompatible_operator (yytext); \
+      curr_lexer->gripe_matlab_incompatible_operator (yytext); \
       BIN_OP_RETURN (tok, convert, bos); \
     } \
   while (0)
 
 #define LEXER_DEBUG(pattern) \
   do \
     { \
       if (lexer_debug_flag) \
-        lexer_debug (pattern, yytext); \
+        curr_lexer->lexer_debug (pattern, yytext); \
     } \
   while (0)
 
-// TRUE means that we have encountered EOF on the input stream.
-bool parser_end_of_input = false;
-
-// Flags that need to be shared between the lexer and parser.
-lexical_feedback lexer_flags;
-
-// Stack to hold tokens so that we can delete them when the parser is
-// reset and avoid growing forever just because we are stashing some
-// information.  This has to appear before lex.h is included, because
-// one of the macros defined there uses token_stack.
-//
-// FIXME -- this should really be static, but that causes
-// problems on some systems.
-std::stack <token*> token_stack;
-
-// Did eat_whitespace() eat a space or tab, or a newline, or both?
-
-typedef int yum_yum;
-
-const yum_yum ATE_NOTHING = 0;
-const yum_yum ATE_SPACE_OR_TAB = 1;
-const yum_yum ATE_NEWLINE = 2;
-
-// Is the closest nesting level a square bracket, squiggly brace or a paren?
-
-class bracket_brace_paren_nesting_level
-{
-public:
-
-  bracket_brace_paren_nesting_level (void) : context () { }
-
-  ~bracket_brace_paren_nesting_level (void) { }
-
-  void bracket (void) { context.push (BRACKET); }
-  bool is_bracket (void)
-    { return ! context.empty () && context.top () == BRACKET; }
-
-  void brace (void) {  context.push (BRACE); }
-  bool is_brace (void)
-    { return ! context.empty () && context.top () == BRACE; }
-
-  void paren (void) {  context.push (PAREN); }
-  bool is_paren (void)
-    { return ! context.empty () && context.top () == PAREN; }
-
-  bool is_bracket_or_brace (void)
-    { return (! context.empty ()
-              && (context.top () == BRACKET || context.top () == BRACE)); }
-
-  bool none (void) { return context.empty (); }
-
-  void remove (void) { if (! context.empty ()) context.pop (); }
-
-  void clear (void) { while (! context.empty ()) context.pop (); }
-
-private:
-
-  std::stack<int> context;
-
-  static const int BRACKET;
-  static const int BRACE;
-  static const int PAREN;
-
-  bracket_brace_paren_nesting_level (const bracket_brace_paren_nesting_level&);
-
-  bracket_brace_paren_nesting_level&
-  operator = (const bracket_brace_paren_nesting_level&);
-};
-
-const int bracket_brace_paren_nesting_level::BRACKET = 1;
-const int bracket_brace_paren_nesting_level::BRACE = 2;
-const int bracket_brace_paren_nesting_level::PAREN = 3;
-
-static bracket_brace_paren_nesting_level nesting_level;
-
 static bool Vdisplay_tokens = false;
 
 static unsigned int Vtoken_count = 0;
 
-// The start state that was in effect when the beginning of a block
-// comment was noticed.
-static int block_comment_nesting_level = 0;
-
 // Internal variable for lexer debugging state.
 static bool lexer_debug_flag = false;
 
 // Forward declarations for functions defined at the bottom of this
-// file.
-
-static int text_yyinput (void);
-static void xunput (char c, char *buf);
-static void fixup_column_count (char *s);
-static void do_comma_insert_check (void);
-static int is_keyword_token (const std::string& s);
-static int process_comment (bool start_in_block, bool& eof);
-static bool match_any (char c, const char *s);
-static bool next_token_is_sep_op (void);
-static bool next_token_is_bin_op (bool spc_prev);
-static bool next_token_is_postfix_unary_op (bool spc_prev);
+// file that are needed inside the lexer actions.
+
 static std::string strip_trailing_whitespace (char *s);
-static void handle_number (void);
-static int handle_string (char delim);
-static int handle_close_bracket (bool spc_gobbled, int bracket_type);
-static int handle_superclass_identifier (void);
-static int handle_meta_identifier (void);
-static int handle_identifier (void);
-static bool have_continuation (bool trailing_comments_ok = true);
-static bool have_ellipsis_continuation (bool trailing_comments_ok = true);
-static void scan_for_comments (const char *);
-static yum_yum eat_whitespace (void);
-static yum_yum eat_continuation (void);
-static void maybe_warn_separator_insert (char sep);
-static void gripe_single_quote_string (void);
-static void gripe_matlab_incompatible (const std::string& msg);
-static void maybe_gripe_matlab_incompatible_comment (char c);
-static void gripe_matlab_incompatible_continuation (void);
-static void gripe_matlab_incompatible_operator (const std::string& op);
-static void display_token (int tok);
-static void lexer_debug (const char *pattern, const char *text);
 
 %}
 
 D       [0-9]
 S       [ \t]
 NL      ((\n)|(\r)|(\r\n))
 SNL     ({S}|{NL})
 EL      (\.\.\.)
@@ -357,87 +256,87 @@ NUMBER  (({D}+\.?{D}*{EXPON}?)|(\.{D}+{E
 // Make script and function files start with a bogus token. This makes
 // the parser go down a special path.
 %}
 
 <SCRIPT_FILE_BEGIN>. {
     LEXER_DEBUG ("<SCRIPT_FILE_BEGIN>.");
 
     BEGIN (INITIAL);
-    xunput (yytext[0], yytext);
+    curr_lexer->xunput (yytext[0]);
     COUNT_TOK_AND_RETURN (SCRIPT_FILE);
   }
 
 <FUNCTION_FILE_BEGIN>. {
     LEXER_DEBUG ("<FUNCTION_FILE_BEGIN>.");
 
     BEGIN (INITIAL);
-    xunput (yytext[0], yytext);
+    curr_lexer->xunput (yytext[0]);
     COUNT_TOK_AND_RETURN (FUNCTION_FILE);
   }
 
 <CLASSDEF_FILE_BEGIN>. {
     LEXER_DEBUG ("<CLASSDEF_FILE_BEGIN>.");
 
     BEGIN (INITIAL);
-    xunput (yytext[0], yytext);
+    curr_lexer->xunput (yytext[0], yytext);
     COUNT_TOK_AND_RETURN (CLASSDEF_FILE);
   }
 
 %{
 // Help and other command-style functions.
 %}
 
 <COMMAND_START>{NL} {
     LEXER_DEBUG ("<COMMAND_START>{NL}");
 
     BEGIN (INITIAL);
-    input_line_number++;
-    current_input_column = 1;
-
-    lexer_flags.quote_is_transpose = false;
-    lexer_flags.convert_spaces_to_comma = true;
-    lexer_flags.looking_for_object_index = false;
-    lexer_flags.at_beginning_of_statement = true;
+    curr_lexer->input_line_number++;
+    curr_lexer->current_input_column = 1;
+
+    curr_lexer->quote_is_transpose = false;
+    curr_lexer->convert_spaces_to_comma = true;
+    curr_lexer->looking_for_object_index = false;
+    curr_lexer->at_beginning_of_statement = true;
 
     COUNT_TOK_AND_RETURN ('\n');
   }
 
 <COMMAND_START>[\;\,] {
     LEXER_DEBUG ("<COMMAND_START>[\\;\\,]");
 
-    lexer_flags.looking_for_object_index = false;
-    lexer_flags.at_beginning_of_statement = true;
+    curr_lexer->looking_for_object_index = false;
+    curr_lexer->at_beginning_of_statement = true;
 
     BEGIN (INITIAL);
 
     if (strcmp (yytext, ",") == 0)
       TOK_RETURN (',');
     else
       TOK_RETURN (';');
   }
 
 <COMMAND_START>[\"\'] {
     LEXER_DEBUG ("<COMMAND_START>[\\\"\\']");
 
-    lexer_flags.at_beginning_of_statement = false;
-
-    current_input_column++;
-    int tok = handle_string (yytext[0]);
+    curr_lexer->at_beginning_of_statement = false;
+
+    curr_lexer->current_input_column++;
+    int tok = curr_lexer->handle_string (yytext[0]);
 
     COUNT_TOK_AND_RETURN (tok);
   }
 
 <COMMAND_START>[^#% \t\r\n\;\,\"\'][^ \t\r\n\;\,]*{S}* {
     LEXER_DEBUG ("<COMMAND_START>[^#% \\t\\r\\n\\;\\,\\\"\\'][^ \\t\\r\\n\\;\\,]*{S}*");
 
     std::string tok = strip_trailing_whitespace (yytext);
 
-    lexer_flags.looking_for_object_index = false;
-    lexer_flags.at_beginning_of_statement = false;
+    curr_lexer->looking_for_object_index = false;
+    curr_lexer->at_beginning_of_statement = false;
 
     TOK_PUSH_AND_RETURN (tok, SQ_STRING);
   }
 
 %{
 // For this and the next two rules, we're looking at ']', and we
 // need to know if the next token is '=' or '=='.
 //
@@ -449,130 +348,130 @@ NUMBER  (({D}+\.?{D}*{EXPON}?)|(\.{D}+{E
 // after seeing a ']' character...
 
 // FIXME -- we need to handle block comments here.
 %}
 
 <MATRIX_START>{SNLCMT}*\]{S}* {
     LEXER_DEBUG ("<MATRIX_START>{SNLCMT}*\\]{S}*");
 
-    scan_for_comments (yytext);
-    fixup_column_count (yytext);
-
-    lexer_flags.looking_at_object_index.pop_front ();
-
-    lexer_flags.looking_for_object_index = true;
-    lexer_flags.at_beginning_of_statement = false;
+    curr_lexer->scan_for_comments (yytext);
+    curr_lexer->fixup_column_count (yytext);
+
+    curr_lexer->looking_at_object_index.pop_front ();
+
+    curr_lexer->looking_for_object_index = true;
+    curr_lexer->at_beginning_of_statement = false;
 
     int c = yytext[yyleng-1];
-    int cont_is_spc = eat_continuation ();
+    bool cont_is_spc = (curr_lexer->eat_continuation () != lexical_feedback::NO_WHITESPACE);
     bool spc_gobbled = (cont_is_spc || c == ' ' || c == '\t');
-    int tok_to_return = handle_close_bracket (spc_gobbled, ']');
+    int tok_to_return = curr_lexer->handle_close_bracket (spc_gobbled, ']');
 
     if (spc_gobbled)
-      xunput (' ', yytext);
+      curr_lexer->xunput (' ');
 
     COUNT_TOK_AND_RETURN (tok_to_return);
   }
 
 %{
 // FIXME -- we need to handle block comments here.
 %}
 
 <MATRIX_START>{SNLCMT}*\}{S}* {
     LEXER_DEBUG ("<MATRIX_START>{SNLCMT}*\\}{S}*");
 
-    scan_for_comments (yytext);
-    fixup_column_count (yytext);
-
-    lexer_flags.looking_at_object_index.pop_front ();
-
-    lexer_flags.looking_for_object_index = true;
-    lexer_flags.at_beginning_of_statement = false;
+    curr_lexer->scan_for_comments (yytext);
+    curr_lexer->fixup_column_count (yytext);
+
+    curr_lexer->looking_at_object_index.pop_front ();
+
+    curr_lexer->looking_for_object_index = true;
+    curr_lexer->at_beginning_of_statement = false;
 
     int c = yytext[yyleng-1];
-    int cont_is_spc = eat_continuation ();
+    bool cont_is_spc = (curr_lexer->eat_continuation () != lexical_feedback::NO_WHITESPACE);
     bool spc_gobbled = (cont_is_spc || c == ' ' || c == '\t');
-    int tok_to_return = handle_close_bracket (spc_gobbled, '}');
+    int tok_to_return = curr_lexer->handle_close_bracket (spc_gobbled, '}');
 
     if (spc_gobbled)
-      xunput (' ', yytext);
+      curr_lexer->xunput (' ');
 
     COUNT_TOK_AND_RETURN (tok_to_return);
   }
 
 %{
 // Commas are element separators in matrix constants.  If we don't
 // check for continuations here we can end up inserting too many
 // commas.
 %}
 
 <MATRIX_START>{S}*\,{S}* {
     LEXER_DEBUG ("<MATRIX_START>{S}*\\,{S}*");
 
-    current_input_column += yyleng;
-
-    int tmp = eat_continuation ();
-
-    lexer_flags.quote_is_transpose = false;
-    lexer_flags.convert_spaces_to_comma = true;
-    lexer_flags.looking_for_object_index = false;
-    lexer_flags.at_beginning_of_statement = false;
-
-    if (! lexer_flags.looking_at_object_index.front ())
+    curr_lexer->current_input_column += yyleng;
+
+    int tmp = curr_lexer->eat_continuation ();
+
+    curr_lexer->quote_is_transpose = false;
+    curr_lexer->convert_spaces_to_comma = true;
+    curr_lexer->looking_for_object_index = false;
+    curr_lexer->at_beginning_of_statement = false;
+
+    if (! curr_lexer->looking_at_object_index.front ())
       {
-        if ((tmp & ATE_NEWLINE) == ATE_NEWLINE)
+        if ((tmp & lexical_feedback::NEWLINE) == lexical_feedback::NEWLINE)
           {
-            maybe_warn_separator_insert (';');
-
-            xunput (';', yytext);
+            curr_lexer->maybe_warn_separator_insert (';');
+
+            curr_lexer->xunput (';');
           }
       }
 
     COUNT_TOK_AND_RETURN (',');
   }
 
 %{
 // In some cases, spaces in matrix constants can turn into commas.
 // If commas are required, spaces are not important in matrix
 // constants so we just eat them.  If we don't check for continuations
 // here we can end up inserting too many commas.
 %}
 
 <MATRIX_START>{S}+ {
     LEXER_DEBUG ("<MATRIX_START>{S}+");
 
-    current_input_column += yyleng;
-
-    lexer_flags.at_beginning_of_statement = false;
-
-    int tmp = eat_continuation ();
-
-    if (! lexer_flags.looking_at_object_index.front ())
+    curr_lexer->current_input_column += yyleng;
+
+    curr_lexer->at_beginning_of_statement = false;
+
+    int tmp = curr_lexer->eat_continuation ();
+
+    if (! curr_lexer->looking_at_object_index.front ())
       {
-        bool bin_op = next_token_is_bin_op (true);
-        bool postfix_un_op = next_token_is_postfix_unary_op (true);
-        bool sep_op = next_token_is_sep_op ();
+        bool bin_op = curr_lexer->next_token_is_bin_op (true);
+        bool postfix_un_op = curr_lexer->next_token_is_postfix_unary_op (true);
+        bool sep_op = curr_lexer->next_token_is_sep_op ();
 
         if (! (postfix_un_op || bin_op || sep_op)
-            && nesting_level.is_bracket_or_brace ()
-            && lexer_flags.convert_spaces_to_comma)
+            && curr_lexer->nesting_level.is_bracket_or_brace ()
+            && curr_lexer->convert_spaces_to_comma)
           {
-            if ((tmp & ATE_NEWLINE) == ATE_NEWLINE)
+            if ((tmp & lexical_feedback::NEWLINE) == lexical_feedback::NEWLINE)
               {
-                maybe_warn_separator_insert (';');
-
-                xunput (';', yytext);
+                curr_lexer->maybe_warn_separator_insert (';');
+
+                curr_lexer->xunput (';');
               }
 
-            lexer_flags.quote_is_transpose = false;
-            lexer_flags.convert_spaces_to_comma = true;
-            lexer_flags.looking_for_object_index = false;
-
-            maybe_warn_separator_insert (',');
+            curr_lexer->quote_is_transpose = false;
+            curr_lexer->convert_spaces_to_comma = true;
+            curr_lexer->looking_for_object_index = false;
+
+            curr_lexer->maybe_warn_separator_insert (',');
 
             COUNT_TOK_AND_RETURN (',');
           }
       }
   }
 
 %{
 // Semicolons are handled as row seprators in matrix constants.  If we
@@ -580,372 +479,372 @@ NUMBER  (({D}+\.?{D}*{EXPON}?)|(\.{D}+{E
 // semicolons.
 
 // FIXME -- we need to handle block comments here.
 %}
 
 <MATRIX_START>{SNLCMT}*;{SNLCMT}* {
     LEXER_DEBUG ("<MATRIX_START>{SNLCMT}*;{SNLCMT}*");
 
-    scan_for_comments (yytext);
-    fixup_column_count (yytext);
-    eat_whitespace ();
-
-    lexer_flags.quote_is_transpose = false;
-    lexer_flags.convert_spaces_to_comma = true;
-    lexer_flags.looking_for_object_index = false;
-    lexer_flags.at_beginning_of_statement = false;
+    curr_lexer->scan_for_comments (yytext);
+    curr_lexer->fixup_column_count (yytext);
+    curr_lexer->eat_whitespace ();
+
+    curr_lexer->quote_is_transpose = false;
+    curr_lexer->convert_spaces_to_comma = true;
+    curr_lexer->looking_for_object_index = false;
+    curr_lexer->at_beginning_of_statement = false;
 
     COUNT_TOK_AND_RETURN (';');
   }
 
 %{
 // In some cases, new lines can also become row separators.  If we
 // don't eat whitespace here we can end up inserting too many
 // semicolons.
 
 // FIXME -- we need to handle block comments here.
 %}
 
 <MATRIX_START>{S}*{COMMENT}{SNLCMT}* |
 <MATRIX_START>{S}*{NL}{SNLCMT}* {
     LEXER_DEBUG ("<MATRIX_START>{S}*{COMMENT}{SNLCMT}*|<MATRIX_START>{S}*{NL}{SNLCMT}*");
 
-    scan_for_comments (yytext);
-    fixup_column_count (yytext);
-    eat_whitespace ();
-
-    lexer_flags.quote_is_transpose = false;
-    lexer_flags.convert_spaces_to_comma = true;
-    lexer_flags.at_beginning_of_statement = false;
-
-    if (nesting_level.none ())
+    curr_lexer->scan_for_comments (yytext);
+    curr_lexer->fixup_column_count (yytext);
+    curr_lexer->eat_whitespace ();
+
+    curr_lexer->quote_is_transpose = false;
+    curr_lexer->convert_spaces_to_comma = true;
+    curr_lexer->at_beginning_of_statement = false;
+
+    if (curr_lexer->nesting_level.none ())
       return LEXICAL_ERROR;
 
-    if (! lexer_flags.looking_at_object_index.front ()
-        && nesting_level.is_bracket_or_brace ())
+    if (! curr_lexer->looking_at_object_index.front ()
+        && curr_lexer->nesting_level.is_bracket_or_brace ())
       {
-        maybe_warn_separator_insert (';');
+        curr_lexer->maybe_warn_separator_insert (';');
 
         COUNT_TOK_AND_RETURN (';');
       }
   }
 
 \[{S}* {
     LEXER_DEBUG ("\\[{S}*");
 
-    nesting_level.bracket ();
-
-    lexer_flags.looking_at_object_index.push_front (false);
-
-    current_input_column += yyleng;
-    lexer_flags.quote_is_transpose = false;
-    lexer_flags.convert_spaces_to_comma = true;
-    lexer_flags.looking_for_object_index = false;
-    lexer_flags.at_beginning_of_statement = false;
-
-    if (lexer_flags.defining_func
-        && ! lexer_flags.parsed_function_name.top ())
-      lexer_flags.looking_at_return_list = true;
+    curr_lexer->nesting_level.bracket ();
+
+    curr_lexer->looking_at_object_index.push_front (false);
+
+    curr_lexer->current_input_column += yyleng;
+    curr_lexer->quote_is_transpose = false;
+    curr_lexer->convert_spaces_to_comma = true;
+    curr_lexer->looking_for_object_index = false;
+    curr_lexer->at_beginning_of_statement = false;
+
+    if (curr_lexer->defining_func
+        && ! curr_lexer->parsed_function_name.top ())
+      curr_lexer->looking_at_return_list = true;
     else
-      lexer_flags.looking_at_matrix_or_assign_lhs = true;
+      curr_lexer->looking_at_matrix_or_assign_lhs = true;
 
     promptflag--;
-    eat_whitespace ();
-
-    lexer_flags.bracketflag++;
+    curr_lexer->eat_whitespace ();
+
+    curr_lexer->bracketflag++;
     BEGIN (MATRIX_START);
     COUNT_TOK_AND_RETURN ('[');
   }
 
 \] {
     LEXER_DEBUG ("\\]");
 
-    nesting_level.remove ();
-
-    lexer_flags.looking_at_object_index.pop_front ();
-
-    lexer_flags.looking_for_object_index = true;
-    lexer_flags.at_beginning_of_statement = false;
+    curr_lexer->nesting_level.remove ();
+
+    curr_lexer->looking_at_object_index.pop_front ();
+
+    curr_lexer->looking_for_object_index = true;
+    curr_lexer->at_beginning_of_statement = false;
 
     TOK_RETURN (']');
   }
 
 %{
 // Imaginary numbers.
 %}
 
 {NUMBER}{Im} {
     LEXER_DEBUG ("{NUMBER}{Im}");
 
-    handle_number ();
+    curr_lexer->handle_number ();
     COUNT_TOK_AND_RETURN (IMAG_NUM);
   }
 
 %{
 // Real numbers.  Don't grab the '.' part of a dot operator as part of
 // the constant.
 %}
 
 {D}+/\.[\*/\\^\'] |
 {NUMBER} {
     LEXER_DEBUG ("{D}+/\\.[\\*/\\^\\']|{NUMBER}");
-    handle_number ();
+    curr_lexer->handle_number ();
     COUNT_TOK_AND_RETURN (NUM);
   }
 
 %{
 // Eat whitespace.  Whitespace inside matrix constants is handled by
 // the <MATRIX_START> start state code above.
 %}
 
 {S}* {
-    current_input_column += yyleng;
+    curr_lexer->current_input_column += yyleng;
   }
 
 %{
 // Continuation lines.  Allow comments after continuations.
 %}
 
 {CONT}{S}*{NL} |
 {CONT}{S}*{COMMENT} {
     LEXER_DEBUG ("{CONT}{S}*{NL}|{CONT}{S}*{COMMENT}");
 
     if (yytext[0] == '\\')
-      gripe_matlab_incompatible_continuation ();
-    scan_for_comments (yytext);
+      curr_lexer->gripe_matlab_incompatible_continuation ();
+    curr_lexer->scan_for_comments (yytext);
     promptflag--;
-    input_line_number++;
-    current_input_column = 1;
+    curr_lexer->input_line_number++;
+    curr_lexer->current_input_column = 1;
   }
 
 %{
 // End of file.
 %}
 
 <<EOF>> {
     LEXER_DEBUG ("<<EOF>>");
 
-    if (block_comment_nesting_level != 0)
+    if (curr_lexer->block_comment_nesting_level != 0)
       {
         warning ("block comment open at end of input");
 
         if ((reading_fcn_file || reading_script_file || reading_classdef_file)
             && ! curr_fcn_file_name.empty ())
           warning ("near line %d of file '%s.m'",
-                   input_line_number, curr_fcn_file_name.c_str ());
+                   curr_lexer->input_line_number, curr_fcn_file_name.c_str ());
       }
 
     TOK_RETURN (END_OF_INPUT);
   }
 
 %{
 // Identifiers.  Truncate the token at the first space or tab but
 // don't write directly on yytext.
 %}
 
 {IDENT}{S}* {
     LEXER_DEBUG ("{IDENT}{S}*");
 
-    int id_tok = handle_identifier ();
+    int id_tok = curr_lexer->handle_identifier ();
 
     if (id_tok >= 0)
       COUNT_TOK_AND_RETURN (id_tok);
   }
 
 %{
 // Superclass method identifiers.
 %}
 
 {IDENT}@{IDENT}{S}* |
 {IDENT}@{IDENT}.{IDENT}{S}* {
     LEXER_DEBUG ("{IDENT}@{IDENT}{S}*|{IDENT}@{IDENT}.{IDENT}{S}*");
 
-    int id_tok = handle_superclass_identifier ();
+    int id_tok = curr_lexer->handle_superclass_identifier ();
 
     if (id_tok >= 0)
       {
-        lexer_flags.looking_for_object_index = true;
+        curr_lexer->looking_for_object_index = true;
 
         COUNT_TOK_AND_RETURN (id_tok);
       }
   }
 
 %{
 // Metaclass query
 %}
 
 \?{IDENT}{S}* |
 \?{IDENT}\.{IDENT}{S}* {
     LEXER_DEBUG ("\\?{IDENT}{S}*|\\?{IDENT}\\.{IDENT}{S}*");
 
-    int id_tok = handle_meta_identifier ();
+    int id_tok = curr_lexer->handle_meta_identifier ();
 
     if (id_tok >= 0)
       {
-        lexer_flags.looking_for_object_index = true;
+        curr_lexer->looking_for_object_index = true;
 
         COUNT_TOK_AND_RETURN (id_tok);
       }
   }
 
 %{
 // Function handles and superclass references
 %}
 
 "@" {
     LEXER_DEBUG ("@");
 
-    current_input_column++;
-
-    lexer_flags.quote_is_transpose = false;
-    lexer_flags.convert_spaces_to_comma = false;
-    lexer_flags.looking_at_function_handle++;
-    lexer_flags.looking_for_object_index = false;
-    lexer_flags.at_beginning_of_statement = false;
+    curr_lexer->current_input_column++;
+
+    curr_lexer->quote_is_transpose = false;
+    curr_lexer->convert_spaces_to_comma = false;
+    curr_lexer->looking_at_function_handle++;
+    curr_lexer->looking_for_object_index = false;
+    curr_lexer->at_beginning_of_statement = false;
 
     COUNT_TOK_AND_RETURN ('@');
 
   }
 
 %{
 // A new line character.  New line characters inside matrix constants
 // are handled by the <MATRIX_START> start state code above.  If closest
 // nesting is inside parentheses, don't return a row separator.
 %}
 
 {NL} {
     LEXER_DEBUG ("{NL}");
 
-    input_line_number++;
-    current_input_column = 1;
-
-    lexer_flags.quote_is_transpose = false;
-    lexer_flags.convert_spaces_to_comma = true;
-
-    if (nesting_level.none ())
+    curr_lexer->input_line_number++;
+    curr_lexer->current_input_column = 1;
+
+    curr_lexer->quote_is_transpose = false;
+    curr_lexer->convert_spaces_to_comma = true;
+
+    if (curr_lexer->nesting_level.none ())
       {
-        lexer_flags.at_beginning_of_statement = true;
+        curr_lexer->at_beginning_of_statement = true;
         COUNT_TOK_AND_RETURN ('\n');
       }
-    else if (nesting_level.is_paren ())
+    else if (curr_lexer->nesting_level.is_paren ())
       {
-        lexer_flags.at_beginning_of_statement = false;
-        gripe_matlab_incompatible ("bare newline inside parentheses");
+        curr_lexer->at_beginning_of_statement = false;
+        curr_lexer->gripe_matlab_incompatible ("bare newline inside parentheses");
       }
-    else if (nesting_level.is_bracket_or_brace ())
+    else if (curr_lexer->nesting_level.is_bracket_or_brace ())
       return LEXICAL_ERROR;
   }
 
 %{
 // Single quote can either be the beginning of a string or a transpose
 // operator.
 %}
 
 "'" {
     LEXER_DEBUG ("'");
 
-    current_input_column++;
-    lexer_flags.convert_spaces_to_comma = true;
-
-    if (lexer_flags.quote_is_transpose)
+    curr_lexer->current_input_column++;
+    curr_lexer->convert_spaces_to_comma = true;
+
+    if (curr_lexer->quote_is_transpose)
       {
-        do_comma_insert_check ();
+        curr_lexer->do_comma_insert_check ();
         COUNT_TOK_AND_RETURN (QUOTE);
       }
     else
       {
-        int tok = handle_string ('\'');
+        int tok = curr_lexer->handle_string ('\'');
         COUNT_TOK_AND_RETURN (tok);
       }
   }
 
 %{
 // Double quotes always begin strings.
 %}
 
 \" {
     LEXER_DEBUG ("\"");
 
-    current_input_column++;
-    int tok = handle_string ('"');
+    curr_lexer->current_input_column++;
+    int tok = curr_lexer->handle_string ('"');
 
     COUNT_TOK_AND_RETURN (tok);
 }
 
 %{
 // Gobble comments.
 %}
 
 {CCHAR} {
     LEXER_DEBUG ("{CCHAR}");
 
-    lexer_flags.looking_for_object_index = false;
-
-    xunput (yytext[0], yytext);
+    curr_lexer->looking_for_object_index = false;
+
+    curr_lexer->xunput (yytext[0]);
 
     bool eof = false;
-    int tok = process_comment (false, eof);
+    int tok = curr_lexer->process_comment (false, eof);
 
     if (eof)
       TOK_RETURN (END_OF_INPUT);
     else if (tok > 0)
       COUNT_TOK_AND_RETURN (tok);
   }
 
 %{
 // Block comments.
 %}
 
 ^{S}*{CCHAR}\{{S}*{NL} {
     LEXER_DEBUG ("^{S}*{CCHAR}\\{{S}*{NL}");
 
-    lexer_flags.looking_for_object_index = false;
-
-    input_line_number++;
-    current_input_column = 1;
-    block_comment_nesting_level++;
+    curr_lexer->looking_for_object_index = false;
+
+    curr_lexer->input_line_number++;
+    curr_lexer->current_input_column = 1;
+    curr_lexer->block_comment_nesting_level++;
     promptflag--;
 
     bool eof = false;
-    process_comment (true, eof);
+    curr_lexer->process_comment (true, eof);
   }
 
 %{
 // Other operators.
 %}
 
 ":"     { LEXER_DEBUG (":"); BIN_OP_RETURN (':', false, false); }
 
 ".+"    { LEXER_DEBUG (".+"); XBIN_OP_RETURN (EPLUS, false, false); }
 ".-"    { LEXER_DEBUG (".-"); XBIN_OP_RETURN (EMINUS, false, false); }
 ".*"    { LEXER_DEBUG (".*"); BIN_OP_RETURN (EMUL, false, false); }
 "./"    { LEXER_DEBUG ("./"); BIN_OP_RETURN (EDIV, false, false); }
 ".\\"   { LEXER_DEBUG (".\\"); BIN_OP_RETURN (ELEFTDIV, false, false); }
 ".^"    { LEXER_DEBUG (".^"); BIN_OP_RETURN (EPOW, false, false); }
 ".**"   { LEXER_DEBUG (".**"); XBIN_OP_RETURN (EPOW, false, false); }
-".'"    { LEXER_DEBUG (".'"); do_comma_insert_check (); BIN_OP_RETURN (TRANSPOSE, true, false); }
-"++"    { LEXER_DEBUG ("++"); do_comma_insert_check (); XBIN_OP_RETURN_INTERNAL (PLUS_PLUS, true, false, true); }
-"--"    { LEXER_DEBUG ("--"); do_comma_insert_check (); XBIN_OP_RETURN_INTERNAL (MINUS_MINUS, true, false, true); }
+".'"    { LEXER_DEBUG (".'"); curr_lexer->do_comma_insert_check (); BIN_OP_RETURN (TRANSPOSE, true, false); }
+"++"    { LEXER_DEBUG ("++"); curr_lexer->do_comma_insert_check (); XBIN_OP_RETURN_INTERNAL (PLUS_PLUS, true, false, true); }
+"--"    { LEXER_DEBUG ("--"); curr_lexer->do_comma_insert_check (); XBIN_OP_RETURN_INTERNAL (MINUS_MINUS, true, false, true); }
 "<="    { LEXER_DEBUG ("<="); BIN_OP_RETURN (EXPR_LE, false, false); }
 "=="    { LEXER_DEBUG ("=="); BIN_OP_RETURN (EXPR_EQ, false, false); }
 "~="    { LEXER_DEBUG ("~="); BIN_OP_RETURN (EXPR_NE, false, false); }
 "!="    { LEXER_DEBUG ("!="); XBIN_OP_RETURN (EXPR_NE, false, false); }
 ">="    { LEXER_DEBUG (">="); BIN_OP_RETURN (EXPR_GE, false, false); }
 "&"     { LEXER_DEBUG ("&"); BIN_OP_RETURN (EXPR_AND, false, false); }
 "|"     { LEXER_DEBUG ("|"); BIN_OP_RETURN (EXPR_OR, false, false); }
 "<"     { LEXER_DEBUG ("<"); BIN_OP_RETURN (EXPR_LT, false, false); }
 ">"     { LEXER_DEBUG (">"); BIN_OP_RETURN (EXPR_GT, false, false); }
 "+"     { LEXER_DEBUG ("+"); BIN_OP_RETURN ('+', false, false); }
 "-"     { LEXER_DEBUG ("-"); BIN_OP_RETURN ('-', false, false); }
 "*"     { LEXER_DEBUG ("*"); BIN_OP_RETURN ('*', false, false); }
 "/"     { LEXER_DEBUG ("/"); BIN_OP_RETURN ('/', false, false); }
 "\\"    { LEXER_DEBUG ("\\"); BIN_OP_RETURN (LEFTDIV, false, false); }
 ";"     { LEXER_DEBUG (";"); BIN_OP_RETURN (';', true, true); }
-","     { LEXER_DEBUG (","); BIN_OP_RETURN (',', true, ! lexer_flags.looking_at_object_index.front ()); }
+","     { LEXER_DEBUG (","); BIN_OP_RETURN (',', true, ! curr_lexer->looking_at_object_index.front ()); }
 "^"     { LEXER_DEBUG ("^"); BIN_OP_RETURN (POW, false, false); }
 "**"    { LEXER_DEBUG ("**"); XBIN_OP_RETURN (POW, false, false); }
 "="     { LEXER_DEBUG ("="); BIN_OP_RETURN ('=', true, false); }
 "&&"    { LEXER_DEBUG ("&&"); BIN_OP_RETURN (EXPR_AND_AND, false, false); }
 "||"    { LEXER_DEBUG ("||"); BIN_OP_RETURN (EXPR_OR_OR, false, false); }
 "<<"    { LEXER_DEBUG ("<<"); XBIN_OP_RETURN (LSHIFT, false, false); }
 ">>"    { LEXER_DEBUG (">>"); XBIN_OP_RETURN (RSHIFT, false, false); }
 
@@ -961,57 +860,57 @@ NUMBER  (({D}+\.?{D}*{EXPON}?)|(\.{D}+{E
 "(" {
     LEXER_DEBUG ("(");
 
     // If we are looking for an object index, then push TRUE for
     // looking_at_object_index.  Otherwise, just push whatever state
     // is current (so that we can pop it off the stack when we find
     // the matching close paren).
 
-    lexer_flags.looking_at_object_index.push_front
-      (lexer_flags.looking_for_object_index);
-
-    lexer_flags.looking_at_indirect_ref = false;
-    lexer_flags.looking_for_object_index = false;
-    lexer_flags.at_beginning_of_statement = false;
-
-    nesting_level.paren ();
+    curr_lexer->looking_at_object_index.push_front
+      (curr_lexer->looking_for_object_index);
+
+    curr_lexer->looking_at_indirect_ref = false;
+    curr_lexer->looking_for_object_index = false;
+    curr_lexer->at_beginning_of_statement = false;
+
+    curr_lexer->nesting_level.paren ();
     promptflag--;
 
     TOK_RETURN ('(');
   }
 
 ")" {
     LEXER_DEBUG (")");
 
-    nesting_level.remove ();
-    current_input_column++;
-
-    lexer_flags.looking_at_object_index.pop_front ();
-
-    lexer_flags.quote_is_transpose = true;
-    lexer_flags.convert_spaces_to_comma
-      = (nesting_level.is_bracket_or_brace ()
-         && ! lexer_flags.looking_at_anon_fcn_args);
-    lexer_flags.looking_for_object_index = true;
-    lexer_flags.at_beginning_of_statement = false;
-
-    if (lexer_flags.looking_at_anon_fcn_args)
-      lexer_flags.looking_at_anon_fcn_args = false;
-
-    do_comma_insert_check ();
+    curr_lexer->nesting_level.remove ();
+    curr_lexer->current_input_column++;
+
+    curr_lexer->looking_at_object_index.pop_front ();
+
+    curr_lexer->quote_is_transpose = true;
+    curr_lexer->convert_spaces_to_comma
+      = (curr_lexer->nesting_level.is_bracket_or_brace ()
+         && ! curr_lexer->looking_at_anon_fcn_args);
+    curr_lexer->looking_for_object_index = true;
+    curr_lexer->at_beginning_of_statement = false;
+
+    if (curr_lexer->looking_at_anon_fcn_args)
+      curr_lexer->looking_at_anon_fcn_args = false;
+
+    curr_lexer->do_comma_insert_check ();
 
     COUNT_TOK_AND_RETURN (')');
   }
 
 "." {
     LEXER_DEBUG (".");
 
-    lexer_flags.looking_for_object_index = false;
-    lexer_flags.at_beginning_of_statement = false;
+    curr_lexer->looking_for_object_index = false;
+    curr_lexer->at_beginning_of_statement = false;
 
     TOK_RETURN ('.');
   }
 
 "+="    { LEXER_DEBUG ("+="); XBIN_OP_RETURN (ADD_EQ, false, false); }
 "-="    { LEXER_DEBUG ("-="); XBIN_OP_RETURN (SUB_EQ, false, false); }
 "*="    { LEXER_DEBUG ("*="); XBIN_OP_RETURN (MUL_EQ, false, false); }
 "/="    { LEXER_DEBUG ("/="); XBIN_OP_RETURN (DIV_EQ, false, false); }
@@ -1026,154 +925,75 @@ NUMBER  (({D}+\.?{D}*{EXPON}?)|(\.{D}+{E
 "&="    { LEXER_DEBUG ("&="); XBIN_OP_RETURN (AND_EQ, false, false); }
 "|="    { LEXER_DEBUG ("|="); XBIN_OP_RETURN (OR_EQ, false, false); }
 "<<="   { LEXER_DEBUG ("<<="); XBIN_OP_RETURN (LSHIFT_EQ, false, false); }
 ">>="   { LEXER_DEBUG (">>="); XBIN_OP_RETURN (RSHIFT_EQ, false, false); }
 
 \{{S}* {
     LEXER_DEBUG ("\\{{S}*");
 
-    nesting_level.brace ();
-
-    lexer_flags.looking_at_object_index.push_front
-      (lexer_flags.looking_for_object_index);
-
-    current_input_column += yyleng;
-    lexer_flags.quote_is_transpose = false;
-    lexer_flags.convert_spaces_to_comma = true;
-    lexer_flags.looking_for_object_index = false;
-    lexer_flags.at_beginning_of_statement = false;
+    curr_lexer->nesting_level.brace ();
+
+    curr_lexer->looking_at_object_index.push_front
+      (curr_lexer->looking_for_object_index);
+
+    curr_lexer->current_input_column += yyleng;
+    curr_lexer->quote_is_transpose = false;
+    curr_lexer->convert_spaces_to_comma = true;
+    curr_lexer->looking_for_object_index = false;
+    curr_lexer->at_beginning_of_statement = false;
 
     promptflag--;
-    eat_whitespace ();
-
-    lexer_flags.braceflag++;
+    curr_lexer->eat_whitespace ();
+
+    curr_lexer->braceflag++;
     BEGIN (MATRIX_START);
     COUNT_TOK_AND_RETURN ('{');
   }
 
 "}" {
     LEXER_DEBUG ("}");
 
-    lexer_flags.looking_at_object_index.pop_front ();
-
-    lexer_flags.looking_for_object_index = true;
-    lexer_flags.at_beginning_of_statement = false;
-
-    nesting_level.remove ();
+    curr_lexer->looking_at_object_index.pop_front ();
+
+    curr_lexer->looking_for_object_index = true;
+    curr_lexer->at_beginning_of_statement = false;
+
+    curr_lexer->nesting_level.remove ();
 
     TOK_RETURN ('}');
   }
 
 %{
 // Unrecognized input is a lexical error.
 %}
 
 . {
     LEXER_DEBUG (".");
 
-    xunput (yytext[0], yytext);
-
-    int c = text_yyinput ();
+    curr_lexer->xunput (yytext[0]);
+
+    int c = curr_lexer->text_yyinput ();
 
     if (c != EOF)
       {
-        current_input_column++;
+        curr_lexer->current_input_column++;
 
         error ("invalid character '%s' (ASCII %d) near line %d, column %d",
                undo_string_escape (static_cast<char> (c)), c,
-               input_line_number, current_input_column);
+               curr_lexer->input_line_number, curr_lexer->current_input_column);
 
         return LEXICAL_ERROR;
       }
     else
       TOK_RETURN (END_OF_INPUT);
   }
 
 %%
 
-// GAG.
-//
-// If we're reading a matrix and the next character is '[', make sure
-// that we insert a comma ahead of it.
-
-void
-do_comma_insert_check (void)
-{
-  int spc_gobbled = eat_continuation ();
-
-  int c = text_yyinput ();
-
-  xunput (c, yytext);
-
-  if (spc_gobbled)
-    xunput (' ', yytext);
-
-  lexer_flags.do_comma_insert = (! lexer_flags.looking_at_object_index.front ()
-                                 && lexer_flags.bracketflag && c == '[');
-}
-
-// Fix things up for errors or interrupts.  The parser is never called
-// recursively, so it is always safe to reinitialize its state before
-// doing any parsing.
-
-void
-reset_parser (void)
-{
-  // Start off on the right foot.
-  BEGIN (INITIAL);
-
-  parser_end_of_input = false;
-
-  parser_symtab_context.clear ();
-
-  // We do want a prompt by default.
-  promptflag = 1;
-
-  // We are not in a block comment.
-  block_comment_nesting_level = 0;
-
-  // Error may have occurred inside some brackets, braces, or parentheses.
-  nesting_level.clear ();
-
-  // Clear out the stack of token info used to track line and column
-  // numbers.
-  while (! token_stack.empty ())
-    {
-      delete token_stack.top ();
-      token_stack.pop ();
-    }
-
-  // Can be reset by defining a function.
-  if (! (reading_script_file || reading_fcn_file || reading_classdef_file))
-    {
-      current_input_column = 1;
-      input_line_number = command_editor::current_command_number ();
-    }
-
-  // Only ask for input from stdin if we are expecting interactive
-  // input.
-
-  if (! quitting_gracefully
-      && (interactive || forced_interactive)
-      && ! (reading_fcn_file
-            || reading_classdef_file
-            || reading_script_file
-            || get_input_from_eval_string
-            || input_from_startup_file))
-    yyrestart (stdin);
-
-  // Clear the buffer for help text.
-  while (! help_buf.empty ())
-    help_buf.pop ();
-
-  // Reset other flags.
-  lexer_flags.init ();
-}
-
 static void
 display_character (char c)
 {
   if (isgraph (c))
     std::cerr << c;
   else
     switch (c)
       {
@@ -1310,209 +1130,507 @@ display_character (char c)
         break;
 
       case 127:
         std::cerr << "DEL";
         break;
       }
 }
 
-static int
-text_yyinput (void)
+void
+cleanup_parser (void)
+{
+}
+
+// Return 1 if the given character matches any character in the given
+// string.
+
+static bool
+match_any (char c, const char *s)
+{
+  char tmp;
+  while ((tmp = *s++) != '\0')
+    {
+      if (c == tmp)
+        return true;
+    }
+  return false;
+}
+
+// Given information about the spacing surrounding an operator,
+// return 1 if it looks like it should be treated as a binary
+// operator.  For example,
+//
+//   [ 1 + 2 ]  or  [ 1+ 2]  or  [ 1+2 ]  ==>  binary
+//
+//   [ 1 +2 ]  ==>  unary
+
+static bool
+looks_like_bin_op (bool spc_prev, int next_char)
+{
+  bool spc_next = (next_char == ' ' || next_char == '\t');
+
+  return ((spc_prev && spc_next) || ! spc_prev);
+}
+
+bool
+is_keyword (const std::string& s)
+{
+  // Parsing function names like "set.property_name" inside
+  // classdef-style class definitions is simplified by handling the
+  // "set" and "get" portions of the names using the same mechanism as
+  // is used for keywords.  However, they are not really keywords in
+  // the language, so omit them from the list of possible keywords.
+
+  return (octave_kw_hash::in_word_set (s.c_str (), s.length ()) != 0
+          && ! (s == "set" || s == "get"));
+}
+
+DEFUN (iskeyword, args, ,
+  "-*- texinfo -*-\n\
+@deftypefn  {Built-in Function} {} iskeyword ()\n\
+@deftypefnx {Built-in Function} {} iskeyword (@var{name})\n\
+Return true if @var{name} is an Octave keyword.  If @var{name}\n\
+is omitted, return a list of keywords.\n\
+@seealso{isvarname, exist}\n\
+@end deftypefn")
+{
+  octave_value retval;
+
+  int argc = args.length () + 1;
+
+  string_vector argv = args.make_argv ("iskeyword");
+
+  if (error_state)
+    return retval;
+
+  if (argc == 1)
+    {
+      // Neither set and get are keywords.  See the note in the
+      // is_keyword function for additional details.
+
+      string_vector lst (TOTAL_KEYWORDS);
+
+      int j = 0;
+
+      for (int i = 0; i < TOTAL_KEYWORDS; i++)
+        {
+          std::string tmp = wordlist[i].name;
+
+          if (! (tmp == "set" || tmp == "get"))
+            lst[j++] = tmp;
+        }
+
+      lst.resize (j);
+
+      retval = Cell (lst.sort ());
+    }
+  else if (argc == 2)
+    {
+      retval = is_keyword (argv[1]);
+    }
+  else
+    print_usage ();
+
+  return retval;
+}
+
+/*
+
+%!assert (iskeyword ("for"))
+%!assert (iskeyword ("fort"), false)
+%!assert (iskeyword ("fft"), false)
+
+*/
+
+// Used to delete trailing white space from tokens.
+
+static std::string
+strip_trailing_whitespace (char *s)
+{
+  std::string retval = s;
+
+  size_t pos = retval.find_first_of (" \t");
+
+  if (pos != std::string::npos)
+    retval.resize (pos);
+
+  return retval;
+}
+
+DEFUN (__display_tokens__, args, nargout,
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {} __display_tokens__ ()\n\
+Query or set the internal variable that determines whether Octave's\n\
+lexer displays tokens as they are read.\n\
+@end deftypefn")
+{
+  return SET_INTERNAL_VARIABLE (display_tokens);
+}
+
+DEFUN (__token_count__, , ,
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {} __token_count__ ()\n\
+Number of language tokens processed since Octave startup.\n\
+@end deftypefn")
+{
+  return octave_value (Vtoken_count);
+}
+
+DEFUN (__lexer_debug_flag__, args, nargout,
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {@var{old_val} =} __lexer_debug_flag__ (@var{new_val}))\n\
+Undocumented internal function.\n\
+@end deftypefn")
+{
+  octave_value retval;
+
+  retval = set_internal_variable (lexer_debug_flag, args, nargout,
+                                  "__lexer_debug_flag__");
+
+  return retval;
+}
+
+class
+flex_stream_reader : public stream_reader
+{
+public:
+  flex_stream_reader (lexical_feedback *l, char *buf_arg)
+    : stream_reader (), lexer (l), buf (buf_arg)
+  { }
+
+  int getc (void) { return lexer->text_yyinput (); }
+  int ungetc (int c) { lexer->xunput (c, buf); return 0; }
+
+private:
+
+  // No copying!
+
+  flex_stream_reader (const flex_stream_reader&);
+
+  flex_stream_reader& operator = (const flex_stream_reader&);
+
+  lexical_feedback *lexer;
+
+  char *buf;
+};
+
+lexical_feedback::~lexical_feedback (void)
 {
-  int c = yyinput ();
+  // Clear out the stack of token info used to track line and
+  // column numbers.
+
+  while (! token_stack.empty ())
+    {
+      delete token_stack.top ();
+      token_stack.pop ();
+    }
+
+  yylex_destroy (scanner);
+}
+
+void
+lexical_feedback::init (void)
+{
+  // The closest paren, brace, or bracket nesting is not an object
+  // index.
+  looking_at_object_index.push_front (false);
+
+  yylex_init (&scanner);
+
+  // Make lexical_feedback object available through yyextra in
+  // flex-generated lexer.
+  yyset_extra (this, scanner);
+}
+
+// Inside Flex-generated functions, yyg is the scanner cast to its real
+// type.  The BEGIN macro uses yyg and we want to use that in
+// lexical_feedback member functions.  If we could set the start state
+// by calling a function instead of using the BEGIN macro, we could
+// eliminate the OCTAVE_YYG macro.
+
+#define OCTAVE_YYG \
+  struct yyguts_t *yyg = static_cast<struct yyguts_t*> (scanner)
+
+void
+lexical_feedback::reset (void)
+{
+  OCTAVE_YYG;
+
+  // Start off on the right foot.
+  BEGIN (INITIAL);
+
+  parser_symtab_context.clear ();
+
+  // We do want a prompt by default.
+  promptflag = 1;
+
+  // Only ask for input from stdin if we are expecting interactive
+  // input.
+
+  if (! quitting_gracefully
+      && (interactive || forced_interactive)
+      && ! (reading_fcn_file
+            || reading_classdef_file
+            || reading_script_file
+            || get_input_from_eval_string
+            || input_from_startup_file))
+    yyrestart (stdin, scanner);
+
+  // Clear the buffer for help text.
+  while (! help_buf.empty ())
+    help_buf.pop ();
+}
+
+void
+lexical_feedback::prep_for_script_file (void)
+{
+  OCTAVE_YYG;
+
+  BEGIN (SCRIPT_FILE_BEGIN);
+}
+
+void
+lexical_feedback::prep_for_function_file (void)
+{
+  OCTAVE_YYG;
+
+  BEGIN (FUNCTION_FILE_BEGIN);
+}
+
+void
+lexical_feedback::prep_for_classdef_file (void)
+{
+  OCTAVE_YYG;
+
+  BEGIN (CLASSDEF_FILE_BEGIN);
+}
+
+int
+lexical_feedback::octave_read (char *buf, unsigned max_size)
+{
+  static const char * const eol = "\n";
+  static std::string input_buf;
+  static const char *pos = 0;
+  static size_t chars_left = 0;
+  static bool eof = false;
+
+  int status = 0;
+
+  if (chars_left == 0)
+    {
+      pos = 0;
+
+      input_buf = get_user_input (eof);
+
+      chars_left = input_buf.length ();
+
+      pos = input_buf.c_str ();
+    }
+
+  if (chars_left > 0)
+    {
+      size_t len = max_size > chars_left ? chars_left : max_size;
+      assert (len > 0);
+
+      memcpy (buf, pos, len);
+
+      chars_left -= len;
+      pos += len;
+
+      // Make sure input ends with a new line character.
+      if (chars_left == 0 && buf[len-1] != '\n')
+        {
+          if (len < max_size)
+            {
+              // There is enough room to plug the newline character in
+              // the buffer.
+              buf[len++] = '\n';
+            }
+          else
+            {
+              // There isn't enough room to plug the newline character
+              // in the buffer so make sure it is returned on the next
+              // octave_read call.
+              pos = eol;
+              chars_left = 1;
+            }
+        }
+
+      status = len;
+    }
+  else
+    {
+      status = YY_NULL;
+
+      if (! eof)
+        fatal_error ("octave_read () in flex scanner failed");
+    }
+
+  return status;
+}
+
+char *
+lexical_feedback::flex_yytext (void)
+{
+  return yyget_text (scanner);
+}
+
+int
+lexical_feedback::flex_yyleng (void)
+{
+  return yyget_leng (scanner);
+}
+
+// GAG.
+//
+// If we're reading a matrix and the next character is '[', make sure
+// that we insert a comma ahead of it.
+
+void
+lexical_feedback::do_comma_insert_check (void)
+{
+  bool spc_gobbled = (eat_continuation () != lexical_feedback::NO_WHITESPACE);
+
+  int c = text_yyinput ();
+
+  xunput (c);
+
+  if (spc_gobbled)
+    xunput (' ');
+
+  do_comma_insert = (! looking_at_object_index.front ()
+                     && bracketflag && c == '[');
+}
+
+int
+lexical_feedback::text_yyinput (void)
+{
+  int c = yyinput (scanner);
 
   if (lexer_debug_flag)
     {
       std::cerr << "I: ";
       display_character (c);
       std::cerr << std::endl;
     }
 
   // Convert CRLF into just LF and single CR into LF.
 
   if (c == '\r')
     {
-      c = yyinput ();
+      c = yyinput (scanner);
 
       if (lexer_debug_flag)
         {
           std::cerr << "I: ";
           display_character (c);
           std::cerr << std::endl;
         }
 
       if (c != '\n')
         {
-          xunput (c, yytext);
+          xunput (c);
           c = '\n';
         }
     }
 
   if (c == '\n')
     input_line_number++;
 
   return c;
 }
 
-static void
-xunput (char c, char *buf)
+void
+lexical_feedback::xunput (char c, char *buf)
 {
   if (lexer_debug_flag)
     {
       std::cerr << "U: ";
       display_character (c);
       std::cerr << std::endl;
     }
 
   if (c == '\n')
     input_line_number--;
 
-  yyunput (c, buf);
+  yyunput (c, buf, scanner);
+}
+
+void
+lexical_feedback::xunput (char c)
+{
+  char *yytxt = flex_yytext ();
+
+  xunput (c, yytxt);
 }
 
 // If we read some newlines, we need figure out what column we're
 // really looking at.
 
-static void
-fixup_column_count (char *s)
+void
+lexical_feedback::fixup_column_count (char *s)
 {
   char c;
   while ((c = *s++) != '\0')
     {
       if (c == '\n')
         {
           input_line_number++;
           current_input_column = 1;
         }
       else
         current_input_column++;
     }
 }
 
-// Include these so that we don't have to link to libfl.a.
-
-int
-yywrap (void)
-{
-  return 1;
-}
-
-// Tell us all what the current buffer is.
-
-YY_BUFFER_STATE
-current_buffer (void)
-{
-  return YY_CURRENT_BUFFER;
-}
-
-// Create a new buffer.
-
-YY_BUFFER_STATE
-create_buffer (FILE *f)
-{
-  return yy_create_buffer (f, YY_BUF_SIZE);
-}
-
-// Start reading a new buffer.
-
-void
-switch_to_buffer (YY_BUFFER_STATE buf)
-{
-  yy_switch_to_buffer (buf);
-}
-
-// Delete a buffer.
-
-void
-delete_buffer (YY_BUFFER_STATE buf)
-{
-  yy_delete_buffer (buf);
-
-  // Prevent invalid yyin from being used by yyrestart.
-  if (! current_buffer ())
-    yyin = 0; 
-}
-
-// Delete all buffers from the stack.
-void
-clear_all_buffers (void)
-{                 
-  while (current_buffer ())
-    octave_pop_buffer_state ();
-}
-
-void
-cleanup_parser (void)
-{
-  reset_parser ();
-
-  clear_all_buffers ();
-}
-
-// Restore a buffer (for unwind-prot).
-
-void
-restore_input_buffer (void *buf)
-{
-  switch_to_buffer (static_cast<YY_BUFFER_STATE> (buf));
-}
-
-// Delete a buffer (for unwind-prot).
-
-void
-delete_input_buffer (void *buf)
-{
-  delete_buffer (static_cast<YY_BUFFER_STATE> (buf));
-}
-
-static bool
-inside_any_object_index (void)
+bool
+lexical_feedback::inside_any_object_index (void)
 {
   bool retval = false;
 
-  for (std::list<bool>::const_iterator i = lexer_flags.looking_at_object_index.begin ();
-       i != lexer_flags.looking_at_object_index.end (); i++)
+  for (std::list<bool>::const_iterator i = looking_at_object_index.begin ();
+       i != looking_at_object_index.end (); i++)
     {
       if (*i)
         {
           retval = true;
           break;
         }
     }
 
   return retval;
 }
 
 // Handle keywords.  Return -1 if the keyword should be ignored.
 
-static int
-is_keyword_token (const std::string& s)
+int
+lexical_feedback::is_keyword_token (const std::string& s)
 {
   int l = input_line_number;
   int c = current_input_column;
 
   int len = s.length ();
 
   const octave_kw *kw = octave_kw_hash::in_word_set (s.c_str (), len);
 
   if (kw)
     {
-      yylval.tok_val = 0;
+      token *tok_val = 0;
 
       switch (kw->kw_id)
         {
         case break_kw:
         case catch_kw:
         case continue_kw:
         case else_kw:
         case otherwise_kw:
         case return_kw:
         case unwind_protect_cleanup_kw:
-          lexer_flags.at_beginning_of_statement = true;
+          at_beginning_of_statement = true;
           break;
 
         case static_kw:
           if ((reading_fcn_file || reading_script_file
                || reading_classdef_file)
               && ! curr_fcn_file_full_name.empty ())
             warning_with_id ("Octave:deprecated-keyword",
                              "the 'static' keyword is obsolete and will be removed from a future version of Octave; please use 'persistent' instead; near line %d of file '%s'",
@@ -1531,189 +1649,189 @@ is_keyword_token (const std::string& s)
         case elseif_kw:
         case global_kw:
         case until_kw:
           break;
 
         case end_kw:
           if (inside_any_object_index ()
               || (! reading_classdef_file
-                  && (lexer_flags.defining_func
-                      && ! (lexer_flags.looking_at_return_list
-                            || lexer_flags.parsed_function_name.top ()))))
+                  && (defining_func
+                      && ! (looking_at_return_list
+                            || parsed_function_name.top ()))))
             return 0;
 
-          yylval.tok_val = new token (token::simple_end, l, c);
-          lexer_flags.at_beginning_of_statement = true;
+          tok_val = new token (token::simple_end, l, c);
+          at_beginning_of_statement = true;
           break;
 
         case end_try_catch_kw:
-          yylval.tok_val = new token (token::try_catch_end, l, c);
-          lexer_flags.at_beginning_of_statement = true;
+          tok_val = new token (token::try_catch_end, l, c);
+          at_beginning_of_statement = true;
           break;
 
         case end_unwind_protect_kw:
-          yylval.tok_val = new token (token::unwind_protect_end, l, c);
-          lexer_flags.at_beginning_of_statement = true;
+          tok_val = new token (token::unwind_protect_end, l, c);
+          at_beginning_of_statement = true;
           break;
 
         case endfor_kw:
-          yylval.tok_val = new token (token::for_end, l, c);
-          lexer_flags.at_beginning_of_statement = true;
+          tok_val = new token (token::for_end, l, c);
+          at_beginning_of_statement = true;
           break;
 
         case endfunction_kw:
-          yylval.tok_val = new token (token::function_end, l, c);
-          lexer_flags.at_beginning_of_statement = true;
+          tok_val = new token (token::function_end, l, c);
+          at_beginning_of_statement = true;
           break;
 
         case endif_kw:
-          yylval.tok_val = new token (token::if_end, l, c);
-          lexer_flags.at_beginning_of_statement = true;
+          tok_val = new token (token::if_end, l, c);
+          at_beginning_of_statement = true;
           break;
 
         case endparfor_kw:
-          yylval.tok_val = new token (token::parfor_end, l, c);
-          lexer_flags.at_beginning_of_statement = true;
+          tok_val = new token (token::parfor_end, l, c);
+          at_beginning_of_statement = true;
           break;
 
         case endswitch_kw:
-          yylval.tok_val = new token (token::switch_end, l, c);
-          lexer_flags.at_beginning_of_statement = true;
+          tok_val = new token (token::switch_end, l, c);
+          at_beginning_of_statement = true;
           break;
 
         case endwhile_kw:
-          yylval.tok_val = new token (token::while_end, l, c);
-          lexer_flags.at_beginning_of_statement = true;
+          tok_val = new token (token::while_end, l, c);
+          at_beginning_of_statement = true;
           break;
 
         case endclassdef_kw:
-          yylval.tok_val = new token (token::classdef_end, l, c);
-          lexer_flags.at_beginning_of_statement = true;
+          tok_val = new token (token::classdef_end, l, c);
+          at_beginning_of_statement = true;
           break;
 
         case endenumeration_kw:
-          yylval.tok_val = new token (token::enumeration_end, l, c);
-          lexer_flags.at_beginning_of_statement = true;
+          tok_val = new token (token::enumeration_end, l, c);
+          at_beginning_of_statement = true;
           break;
 
         case endevents_kw:
-          yylval.tok_val = new token (token::events_end, l, c);
-          lexer_flags.at_beginning_of_statement = true;
+          tok_val = new token (token::events_end, l, c);
+          at_beginning_of_statement = true;
           break;
 
         case endmethods_kw:
-          yylval.tok_val = new token (token::methods_end, l, c);
-          lexer_flags.at_beginning_of_statement = true;
+          tok_val = new token (token::methods_end, l, c);
+          at_beginning_of_statement = true;
           break;
 
         case endproperties_kw:
-          yylval.tok_val = new token (token::properties_end, l, c);
-          lexer_flags.at_beginning_of_statement = true;
+          tok_val = new token (token::properties_end, l, c);
+          at_beginning_of_statement = true;
           break;
 
 
         case for_kw:
         case parfor_kw:
         case while_kw:
           promptflag--;
-          lexer_flags.looping++;
+          looping++;
           break;
 
         case do_kw:
-          lexer_flags.at_beginning_of_statement = true;
+          at_beginning_of_statement = true;
           promptflag--;
-          lexer_flags.looping++;
+          looping++;
           break;
 
         case try_kw:
         case unwind_protect_kw:
-          lexer_flags.at_beginning_of_statement = true;
+          at_beginning_of_statement = true;
           promptflag--;
           break;
 
         case if_kw:
         case switch_kw:
           promptflag--;
           break;
 
         case get_kw:
         case set_kw:
           // 'get' and 'set' are keywords in classdef method
           // declarations.
-          if (! lexer_flags.maybe_classdef_get_set_method)
+          if (! maybe_classdef_get_set_method)
             return 0;
           break;
 
         case enumeration_kw:
         case events_kw:
         case methods_kw:
         case properties_kw:
           // 'properties', 'methods' and 'events' are keywords for
           // classdef blocks.
-          if (! lexer_flags.parsing_classdef)
+          if (! parsing_classdef)
             return 0;
           // fall through ...
 
         case classdef_kw:
           // 'classdef' is always a keyword.
           promptflag--;
           break;
 
         case function_kw:
           promptflag--;
 
-          lexer_flags.defining_func++;
-          lexer_flags.parsed_function_name.push (false);
+          defining_func++;
+          parsed_function_name.push (false);
 
           if (! (reading_fcn_file || reading_script_file
                  || reading_classdef_file))
             input_line_number = 1;
           break;
 
         case magic_file_kw:
           {
             if ((reading_fcn_file || reading_script_file
                  || reading_classdef_file)
                 && ! curr_fcn_file_full_name.empty ())
-              yylval.tok_val = new token (curr_fcn_file_full_name, l, c);
+              tok_val = new token (curr_fcn_file_full_name, l, c);
             else
-              yylval.tok_val = new token ("stdin", l, c);
+              tok_val = new token ("stdin", l, c);
           }
           break;
 
         case magic_line_kw:
-          yylval.tok_val = new token (static_cast<double> (l), "", l, c);
+          tok_val = new token (static_cast<double> (l), "", l, c);
           break;
 
         default:
           panic_impossible ();
         }
 
-      if (! yylval.tok_val)
-        yylval.tok_val = new token (l, c);
-
-      token_stack.push (yylval.tok_val);
+      if (! tok_val)
+        tok_val = new token (l, c);
+
+      push_token (tok_val);
 
       return kw->tok;
     }
 
   return 0;
 }
 
-static bool
-is_variable (const std::string& name)
+bool
+lexical_feedback::is_variable (const std::string& name)
 {
   return (symbol_table::is_variable (name)
-          || (lexer_flags.pending_local_variables.find (name)
-              != lexer_flags.pending_local_variables.end ()));
+          || (pending_local_variables.find (name)
+              != pending_local_variables.end ()));
 }
 
-static std::string
-grab_block_comment (stream_reader& reader, bool& eof)
+std::string
+lexical_feedback::grab_block_comment (stream_reader& reader, bool& eof)
 {
   std::string buf;
 
   bool at_bol = true;
   bool look_for_marker = false;
 
   bool warned_incompatible = false;
 
@@ -1809,18 +1927,18 @@ grab_block_comment (stream_reader& reade
 
   if (c == EOF)
     eof = true;
 
   return buf;
 }
 
 std::string
-grab_comment_block (stream_reader& reader, bool at_bol,
-                    bool& eof)
+lexical_feedback::grab_comment_block (stream_reader& reader, bool at_bol,
+                                      bool& eof)
 {
   std::string buf;
 
   // TRUE means we are at the beginning of a comment block.
   bool begin_comment = false;
 
   // TRUE means we are currently reading a comment block.
   bool in_comment = false;
@@ -1948,47 +2066,30 @@ grab_comment_block (stream_reader& reade
  done:
 
   if (c == EOF)
     eof = true;
 
   return buf;
 }
 
-class
-flex_stream_reader : public stream_reader
+int
+lexical_feedback::process_comment (bool start_in_block, bool& eof)
 {
-public:
-  flex_stream_reader (char *buf_arg) : stream_reader (), buf (buf_arg) { }
-
-  int getc (void) { return ::text_yyinput (); }
-  int ungetc (int c) { ::xunput (c, buf); return 0; }
-
-private:
-
-  // No copying!
-
-  flex_stream_reader (const flex_stream_reader&);
-
-  flex_stream_reader& operator = (const flex_stream_reader&);
-
-  char *buf;
-};
-
-static int
-process_comment (bool start_in_block, bool& eof)
-{
+  OCTAVE_YYG;
+
   eof = false;
 
   std::string help_txt;
 
   if (! help_buf.empty ())
     help_txt = help_buf.top ();
 
-  flex_stream_reader flex_reader (yytext);
+  char *yytxt = flex_yytext ();
+  flex_stream_reader flex_reader (this, yytxt);
 
   // process_comment is only supposed to be called when we are not
   // initially looking at a block comment.
 
   std::string txt = start_in_block
     ? grab_block_comment (flex_reader, eof)
     : grab_comment_block (flex_reader, false, eof);
 
@@ -2001,131 +2102,100 @@ process_comment (bool start_in_block, bo
         help_buf.pop ();
 
       help_buf.push (txt);
     }
 
   octave_comment_buffer::append (txt);
 
   current_input_column = 1;
-  lexer_flags.quote_is_transpose = false;
-  lexer_flags.convert_spaces_to_comma = true;
-  lexer_flags.at_beginning_of_statement = true;
+  quote_is_transpose = false;
+  convert_spaces_to_comma = true;
+  at_beginning_of_statement = true;
 
   if (YY_START == COMMAND_START)
     BEGIN (INITIAL);
 
   if (nesting_level.none ())
     return '\n';
   else if (nesting_level.is_bracket_or_brace ())
     return ';';
   else
     return 0;
 }
 
-// Return 1 if the given character matches any character in the given
-// string.
-
-static bool
-match_any (char c, const char *s)
-{
-  char tmp;
-  while ((tmp = *s++) != '\0')
-    {
-      if (c == tmp)
-        return true;
-    }
-  return false;
-}
-
-// Given information about the spacing surrounding an operator,
-// return 1 if it looks like it should be treated as a binary
-// operator.  For example,
-//
-//   [ 1 + 2 ]  or  [ 1+ 2]  or  [ 1+2 ]  ==>  binary
-//
-//   [ 1 +2 ]  ==>  unary
-
-static bool
-looks_like_bin_op (bool spc_prev, int next_char)
-{
-  bool spc_next = (next_char == ' ' || next_char == '\t');
-
-  return ((spc_prev && spc_next) || ! spc_prev);
-}
-
 // Recognize separators.  If the separator is a CRLF pair, it is
 // replaced by a single LF.
 
-static bool
-next_token_is_sep_op (void)
+bool
+lexical_feedback::next_token_is_sep_op (void)
 {
   bool retval = false;
 
   int c = text_yyinput ();
 
   retval = match_any (c, ",;\n]");
 
-  xunput (c, yytext);
+  xunput (c);
 
   return retval;
 }
 
 // Try to determine if the next token should be treated as a postfix
 // unary operator.  This is ugly, but it seems to do the right thing.
 
-static bool
-next_token_is_postfix_unary_op (bool spc_prev)
+bool
+lexical_feedback::next_token_is_postfix_unary_op (bool spc_prev)
 {
   bool un_op = false;
 
   int c0 = text_yyinput ();
 
   if (c0 == '\'' && ! spc_prev)
     {
       un_op = true;
     }
   else if (c0 == '.')
     {
       int c1 = text_yyinput ();
       un_op = (c1 == '\'');
-      xunput (c1, yytext);
+      xunput (c1);
     }
   else if (c0 == '+')
     {
       int c1 = text_yyinput ();
       un_op = (c1 == '+');
-      xunput (c1, yytext);
+      xunput (c1);
     }
   else if (c0 == '-')
     {
       int c1 = text_yyinput ();
       un_op = (c1 == '-');
-      xunput (c1, yytext);
+      xunput (c1);
     }
 
-  xunput (c0, yytext);
+  xunput (c0);
 
   return un_op;
 }
 
 // Try to determine if the next token should be treated as a binary
 // operator.
 //
 // This kluge exists because whitespace is not always ignored inside
 // the square brackets that are used to create matrix objects (though
 // spacing only really matters in the cases that can be interpreted
 // either as binary ops or prefix unary ops: currently just +, -).
 //
 // Note that a line continuation directly following a + or - operator
 // (e.g., the characters '[' 'a' ' ' '+' '\' LFD 'b' ']') will be
 // parsed as a binary operator.
 
-static bool
-next_token_is_bin_op (bool spc_prev)
+bool
+lexical_feedback::next_token_is_bin_op (bool spc_prev)
 {
   bool bin_op = false;
 
   int c0 = text_yyinput ();
 
   switch (c0)
     {
     case '+':
@@ -2146,17 +2216,17 @@ next_token_is_bin_op (bool spc_prev)
             break;
 
           default:
             // Could be either, spacing matters.
             bin_op = looks_like_bin_op (spc_prev, c1);
             break;
           }
 
-        xunput (c1, yytext);
+        xunput (c1);
       }
       break;
 
     case ':':
     case '/':
     case '\\':
     case '^':
       // Always a binary op (may also include /=, \=, and ^=).
@@ -2170,17 +2240,17 @@ next_token_is_bin_op (bool spc_prev)
 
         if (match_any (c1, "+-/\\^*"))
           // Always a binary op (may also include .+=, .-=, ./=, ...).
           bin_op = true;
         else if (! isdigit (c1) && c1 != ' ' && c1 != '\t' && c1 != '.')
           // A structure element reference is a binary op.
           bin_op = true;
 
-        xunput (c1, yytext);
+        xunput (c1);
       }
       break;
 
     // = == & && | || * **
     case '=':
     case '&':
     case '|':
     case '*':
@@ -2200,48 +2270,33 @@ next_token_is_bin_op (bool spc_prev)
     case '!':
       {
         int c1 = text_yyinput ();
 
         // ~ and ! can be unary ops, so require following =.
         if (c1 == '=')
           bin_op = true;
 
-        xunput (c1, yytext);
+        xunput (c1);
       }
       break;
 
     default:
       break;
     }
 
-  xunput (c0, yytext);
+  xunput (c0);
 
   return bin_op;
 }
 
-// Used to delete trailing white space from tokens.
-
-static std::string
-strip_trailing_whitespace (char *s)
-{
-  std::string retval = s;
-
-  size_t pos = retval.find_first_of (" \t");
-
-  if (pos != std::string::npos)
-    retval.resize (pos);
-
-  return retval;
-}
-
 // FIXME -- we need to handle block comments here.
 
-static void
-scan_for_comments (const char *text)
+void
+lexical_feedback::scan_for_comments (const char *text)
 {
   std::string comment_buf;
 
   bool in_comment = false;
   bool beginning_of_comment = false;
 
   int len = strlen (text);
   int i = 0;
@@ -2288,29 +2343,23 @@ scan_for_comments (const char *text)
         }
     }
 
   if (! comment_buf.empty ())
     octave_comment_buffer::append (comment_buf);
 }
 
 // Discard whitespace, including comments and continuations.
-//
-// Return value is logical OR of the following values:
-//
-//  ATE_NOTHING      : no spaces to eat
-//  ATE_SPACE_OR_TAB : space or tab in input
-//  ATE_NEWLINE      : bare new line in input
 
 // FIXME -- we need to handle block comments here.
 
-static yum_yum
-eat_whitespace (void)
+int
+lexical_feedback::eat_whitespace (void)
 {
-  yum_yum retval = ATE_NOTHING;
+  int retval = lexical_feedback::NO_WHITESPACE;
 
   std::string comment_buf;
 
   bool in_comment = false;
   bool beginning_of_comment = false;
 
   int c = 0;
 
@@ -2322,21 +2371,21 @@ eat_whitespace (void)
         {
         case ' ':
         case '\t':
           if (in_comment)
             {
               comment_buf += static_cast<char> (c);
               beginning_of_comment = false;
             }
-          retval |= ATE_SPACE_OR_TAB;
+          retval |= lexical_feedback::SPACE_OR_TAB;
           break;
 
         case '\n':
-          retval |= ATE_NEWLINE;
+          retval |= lexical_feedback::NEWLINE;
           if (in_comment)
             {
               comment_buf += static_cast<char> (c);
               octave_comment_buffer::append (comment_buf);
               comment_buf.resize (0);
               in_comment = false;
               beginning_of_comment = false;
             }
@@ -2399,87 +2448,87 @@ eat_whitespace (void)
             goto done;
         }
     }
 
   if (! comment_buf.empty ())
     octave_comment_buffer::append (comment_buf);
 
  done:
-  xunput (c, yytext);
+  xunput (c);
   current_input_column--;
   return retval;
 }
 
 static inline bool
 looks_like_hex (const char *s, int len)
 {
   return (len > 2 && s[0] == '0' && (s[1] == 'x' || s[1] == 'X'));
 }
 
-static void
-handle_number (void)
+void
+lexical_feedback::handle_number (void)
 {
   double value = 0.0;
   int nread = 0;
 
-  if (looks_like_hex (yytext, strlen (yytext)))
+  char *yytxt = flex_yytext ();
+
+  if (looks_like_hex (yytxt, strlen (yytxt)))
     {
       unsigned long ival;
 
-      nread = sscanf (yytext, "%lx", &ival);
+      nread = sscanf (yytxt, "%lx", &ival);
 
       value = static_cast<double> (ival);
     }
   else
     {
-      char *tmp = strsave (yytext);
+      char *tmp = strsave (yytxt);
 
       char *idx = strpbrk (tmp, "Dd");
 
       if (idx)
         *idx = 'e';
 
       nread = sscanf (tmp, "%lf", &value);
 
       delete [] tmp;
     }
 
   // If yytext doesn't contain a valid number, we are in deep doo doo.
 
   assert (nread == 1);
 
-  lexer_flags.quote_is_transpose = true;
-  lexer_flags.convert_spaces_to_comma = true;
-  lexer_flags.looking_for_object_index = false;
-  lexer_flags.at_beginning_of_statement = false;
-
-  yylval.tok_val = new token (value, yytext, input_line_number,
-                              current_input_column);
-
-  token_stack.push (yylval.tok_val);
-
-  current_input_column += yyleng;
+  quote_is_transpose = true;
+  convert_spaces_to_comma = true;
+  looking_for_object_index = false;
+  at_beginning_of_statement = false;
+
+  push_token (new token (value, yytxt, input_line_number,
+                         current_input_column));
+
+  current_input_column += flex_yyleng ();
 
   do_comma_insert_check ();
 }
 
 // We have seen a backslash and need to find out if it should be
 // treated as a continuation character.  If so, this eats it, up to
 // and including the new line character.
 //
 // Match whitespace only, followed by a comment character or newline.
 // Once a comment character is found, discard all input until newline.
 // If non-whitespace characters are found before comment
 // characters, return 0.  Otherwise, return 1.
 
 // FIXME -- we need to handle block comments here.
 
-static bool
-have_continuation (bool trailing_comments_ok)
+bool
+lexical_feedback::have_continuation (bool trailing_comments_ok)
 {
   std::ostringstream buf;
 
   std::string comment_buf;
 
   bool in_comment = false;
   bool beginning_of_comment = false;
 
@@ -2538,78 +2587,76 @@ have_continuation (bool trailing_comment
               beginning_of_comment = false;
             }
           else
             goto cleanup;
           break;
         }
     }
 
-  xunput (c, yytext);
+  xunput (c);
   return false;
 
 cleanup:
 
   std::string s = buf.str ();
 
   int len = s.length ();
   while (len--)
-    xunput (s[len], yytext);
+    xunput (s[len]);
 
   return false;
 }
 
 // We have seen a '.' and need to see if it is the start of a
 // continuation.  If so, this eats it, up to and including the new
 // line character.
 
-static bool
-have_ellipsis_continuation (bool trailing_comments_ok)
+bool
+lexical_feedback::have_ellipsis_continuation (bool trailing_comments_ok)
 {
   char c1 = text_yyinput ();
   if (c1 == '.')
     {
       char c2 = text_yyinput ();
       if (c2 == '.' && have_continuation (trailing_comments_ok))
         return true;
       else
         {
-          xunput (c2, yytext);
-          xunput (c1, yytext);
+          xunput (c2);
+          xunput (c1);
         }
     }
   else
-    xunput (c1, yytext);
+    xunput (c1);
 
   return false;
 }
 
 // See if we have a continuation line.  If so, eat it and the leading
 // whitespace on the next line.
-//
-// Return value is the same as described for eat_whitespace().
-
-static yum_yum
-eat_continuation (void)
+
+int
+lexical_feedback::eat_continuation (void)
 {
-  int retval = ATE_NOTHING;
+  int retval = lexical_feedback::NO_WHITESPACE;
 
   int c = text_yyinput ();
 
   if ((c == '.' && have_ellipsis_continuation ())
       || (c == '\\' && have_continuation ()))
     retval = eat_whitespace ();
   else
-    xunput (c, yytext);
+    xunput (c);
 
   return retval;
 }
 
-static int
-handle_string (char delim)
+int
+lexical_feedback::handle_string (char delim)
 {
   std::ostringstream buf;
 
   int bos_line = input_line_number;
   int bos_col = current_input_column;
 
   int c;
   int escape_pending = 0;
@@ -2656,175 +2703,176 @@ handle_string (char delim)
               c = text_yyinput ();
               if (c == delim)
                 {
                   buf << static_cast<char> (c);
                 }
               else
                 {
                   std::string s;
-                  xunput (c, yytext);
+                  xunput (c);
 
                   if (delim == '\'')
                     s = buf.str ();
                   else
                     s = do_string_escapes (buf.str ());
 
-                  lexer_flags.quote_is_transpose = true;
-                  lexer_flags.convert_spaces_to_comma = true;
-
-                  yylval.tok_val = new token (s, bos_line, bos_col);
-                  token_stack.push (yylval.tok_val);
+                  quote_is_transpose = true;
+                  convert_spaces_to_comma = true;
+
+                  push_token (new token (s, bos_line, bos_col));
 
                   if (delim == '"')
                     gripe_matlab_incompatible ("\" used as string delimiter");
                   else if (delim == '\'')
                     gripe_single_quote_string ();
 
-                  lexer_flags.looking_for_object_index = true;
-                  lexer_flags.at_beginning_of_statement = false;
+                  looking_for_object_index = true;
+                  at_beginning_of_statement = false;
 
                   return delim == '"' ? DQ_STRING : SQ_STRING;
                 }
             }
         }
       else
         {
           buf << static_cast<char> (c);
         }
 
       escape_pending = 0;
     }
 
   return LEXICAL_ERROR;
 }
 
-static bool
-next_token_is_assign_op (void)
+bool
+lexical_feedback::next_token_is_assign_op (void)
 {
   bool retval = false;
 
   int c0 = text_yyinput ();
 
   switch (c0)
     {
     case '=':
       {
         int c1 = text_yyinput ();
-        xunput (c1, yytext);
+        xunput (c1);
         if (c1 != '=')
           retval = true;
       }
       break;
 
     case '+':
     case '-':
     case '*':
     case '/':
     case '\\':
     case '&':
     case '|':
       {
         int c1 = text_yyinput ();
-        xunput (c1, yytext);
+        xunput (c1);
         if (c1 == '=')
           retval = true;
       }
       break;
 
     case '.':
       {
         int c1 = text_yyinput ();
         if (match_any (c1, "+-*/\\"))
           {
             int c2 = text_yyinput ();
-            xunput (c2, yytext);
+            xunput (c2);
             if (c2 == '=')
               retval = true;
           }
-        xunput (c1, yytext);
+        xunput (c1);
       }
       break;
 
     case '>':
       {
         int c1 = text_yyinput ();
         if (c1 == '>')
           {
             int c2 = text_yyinput ();
-            xunput (c2, yytext);
+            xunput (c2);
             if (c2 == '=')
               retval = true;
           }
-        xunput (c1, yytext);
+        xunput (c1);
       }
       break;
 
     case '<':
       {
         int c1 = text_yyinput ();
         if (c1 == '<')
           {
             int c2 = text_yyinput ();
-            xunput (c2, yytext);
+            xunput (c2);
             if (c2 == '=')
               retval = true;
           }
-        xunput (c1, yytext);
+        xunput (c1);
       }
       break;
 
     default:
       break;
     }
 
-  xunput (c0, yytext);
+  xunput (c0);
 
   return retval;
 }
 
-static bool
-next_token_is_index_op (void)
+bool
+lexical_feedback::next_token_is_index_op (void)
 {
   int c = text_yyinput ();
-  xunput (c, yytext);
+  xunput (c);
   return c == '(' || c == '{';
 }
 
-static int
-handle_close_bracket (bool spc_gobbled, int bracket_type)
+int
+lexical_feedback::handle_close_bracket (bool spc_gobbled, int bracket_type)
 {
+  OCTAVE_YYG;
+
   int retval = bracket_type;
 
   if (! nesting_level.none ())
     {
       nesting_level.remove ();
 
       if (bracket_type == ']')
-        lexer_flags.bracketflag--;
+        bracketflag--;
       else if (bracket_type == '}')
-        lexer_flags.braceflag--;
+        braceflag--;
       else
         panic_impossible ();
     }
 
-  if (lexer_flags.bracketflag == 0 && lexer_flags.braceflag == 0)
+  if (bracketflag == 0 && braceflag == 0)
     BEGIN (INITIAL);
 
   if (bracket_type == ']'
       && next_token_is_assign_op ()
-      && ! lexer_flags.looking_at_return_list)
+      && ! looking_at_return_list)
     {
       retval = CLOSE_BRACE;
     }
-  else if ((lexer_flags.bracketflag || lexer_flags.braceflag)
-           && lexer_flags.convert_spaces_to_comma
+  else if ((bracketflag || braceflag)
+           && convert_spaces_to_comma
            && (nesting_level.is_bracket ()
                || (nesting_level.is_brace ()
-                   && ! lexer_flags.looking_at_object_index.front ())))
+                   && ! looking_at_object_index.front ())))
     {
       bool index_op = next_token_is_index_op ();
 
       // Don't insert comma if we are looking at something like
       //
       //   [x{i}{j}] or [x{i}(j)]
       //
       // but do if we are looking at
@@ -2838,44 +2886,44 @@ handle_close_bracket (bool spc_gobbled, 
           bool postfix_un_op = next_token_is_postfix_unary_op (spc_gobbled);
 
           bool sep_op = next_token_is_sep_op ();
 
           if (! (postfix_un_op || bin_op || sep_op))
             {
               maybe_warn_separator_insert (',');
 
-              xunput (',', yytext);
+              xunput (',');
               return retval;
             }
         }
     }
 
-  lexer_flags.quote_is_transpose = true;
-  lexer_flags.convert_spaces_to_comma = true;
+  quote_is_transpose = true;
+  convert_spaces_to_comma = true;
 
   return retval;
 }
 
-static void
-maybe_unput_comma (int spc_gobbled)
+void
+lexical_feedback::maybe_unput_comma (int spc_gobbled)
 {
   if (nesting_level.is_bracket ()
       || (nesting_level.is_brace ()
-          && ! lexer_flags.looking_at_object_index.front ()))
+          && ! looking_at_object_index.front ()))
     {
       int bin_op = next_token_is_bin_op (spc_gobbled);
 
       int postfix_un_op = next_token_is_postfix_unary_op (spc_gobbled);
 
       int c1 = text_yyinput ();
       int c2 = text_yyinput ();
 
-      xunput (c2, yytext);
-      xunput (c1, yytext);
+      xunput (c2);
+      xunput (c1);
 
       int sep_op = next_token_is_sep_op ();
 
       int dot_op = (c1 == '.'
                     && (isalpha (c2) || isspace (c2) || c2 == '_'));
 
       if (postfix_un_op || bin_op || sep_op || dot_op)
         return;
@@ -2885,22 +2933,22 @@ maybe_unput_comma (int spc_gobbled)
       // If there is no space before the indexing op, we don't insert
       // a comma.
 
       if (index_op && ! spc_gobbled)
         return;
 
       maybe_warn_separator_insert (',');
 
-      xunput (',', yytext);
+      xunput (',');
     }
 }
 
-static bool
-next_token_can_follow_bin_op (void)
+bool
+lexical_feedback::next_token_can_follow_bin_op (void)
 {
   std::stack<char> buf;
 
   int c = EOF;
 
   // Skip whitespace in current statement on current line
   while (true)
     {
@@ -2910,17 +2958,17 @@ next_token_can_follow_bin_op (void)
 
       if (match_any (c, ",;\n") || (c != ' ' && c != '\t'))
         break;
     }
 
   // Restore input.
   while (! buf.empty ())
     {
-      xunput (buf.top (), yytext);
+      xunput (buf.top ());
 
       buf.pop ();
     }
 
   return (isalnum (c) || match_any (c, "!\"'(-[_{~"));
 }
 
 static bool
@@ -2931,18 +2979,18 @@ can_be_command (const std::string& tok)
 
   return ! (tok == "e"
             || tok == "I" || tok == "i"
             || tok == "J" || tok == "j"
             || tok == "Inf" || tok == "inf"
             || tok == "NaN" || tok == "nan");
 }
 
-static bool
-looks_like_command_arg (void)
+bool
+lexical_feedback::looks_like_command_arg (void)
 {
   bool retval = true;
 
   int c0 = text_yyinput ();
 
   switch (c0)
     {
     // = ==
@@ -2953,22 +3001,22 @@ looks_like_command_arg (void)
         if (c1 == '=')
           {
             int c2 = text_yyinput ();
 
             if (! match_any (c2, ",;\n") && (c2 == ' ' || c2 == '\t')
                 && next_token_can_follow_bin_op ())
               retval = false;
 
-            xunput (c2, yytext);
+            xunput (c2);
           }
         else
           retval = false;
 
-        xunput (c1, yytext);
+        xunput (c1);
       }
       break;
 
     case '(':
     case '{':
       // Indexing.
       retval = false;
       break;
@@ -3008,37 +3056,37 @@ looks_like_command_arg (void)
           case '=':
             {
               int c2 = text_yyinput ();
 
               if (! match_any (c2, ",;\n") && (c2 == ' ' || c2 == '\t')
                   && next_token_can_follow_bin_op ())
                 retval = false;
 
-              xunput (c2, yytext);
+              xunput (c2);
             }
             break;
           }
 
-        xunput (c1, yytext);
+        xunput (c1);
       }
       break;
 
     case ':':
     case '/':
     case '\\':
     case '^':
       {
         int c1 = text_yyinput ();
 
         if (! match_any (c1, ",;\n") && (c1 == ' ' || c1 == '\t')
             && next_token_can_follow_bin_op ())
           retval = false;
 
-        xunput (c1, yytext);
+        xunput (c1);
       }
       break;
 
     // .+ .- ./ .\ .^ .* .**
     case '.':
       {
         int c1 = text_yyinput ();
 
@@ -3049,34 +3097,34 @@ looks_like_command_arg (void)
             if (c2 == '=')
               {
                 int c3 = text_yyinput ();
 
                 if (! match_any (c3, ",;\n") && (c3 == ' ' || c3 == '\t')
                     && next_token_can_follow_bin_op ())
                   retval = false;
 
-                xunput (c3, yytext);
+                xunput (c3);
               }
             else if (! match_any (c2, ",;\n") && (c2 == ' ' || c2 == '\t')
                      && next_token_can_follow_bin_op ())
               retval = false;
 
-            xunput (c2, yytext);
+            xunput (c2);
           }
         else if (! match_any (c1, ",;\n")
                  && (! isdigit (c1) && c1 != ' ' && c1 != '\t'
                      && c1 != '.'))
           {
             // Structure reference.  FIXME -- is this a complete check?
 
             retval = false;
           }
 
-        xunput (c1, yytext);
+        xunput (c1);
       }
       break;
 
     // & && | || * **
     case '&':
     case '|':
     case '*':
       {
@@ -3085,23 +3133,23 @@ looks_like_command_arg (void)
         if (c1 == c0)
           {
             int c2 = text_yyinput ();
 
             if (! match_any (c2, ",;\n") && (c2 == ' ' || c2 == '\t')
                 && next_token_can_follow_bin_op ())
               retval = false;
 
-            xunput (c2, yytext);
+            xunput (c2);
           }
         else if (! match_any (c1, ",;\n") && (c1 == ' ' || c1 == '\t')
                  && next_token_can_follow_bin_op ())
           retval = false;
 
-        xunput (c1, yytext);
+        xunput (c1);
       }
       break;
 
     // < <= > >=
     case '<':
     case '>':
       {
         int c1 = text_yyinput ();
@@ -3109,23 +3157,23 @@ looks_like_command_arg (void)
         if (c1 == '=')
           {
             int c2 = text_yyinput ();
 
             if (! match_any (c2, ",;\n") && (c2 == ' ' || c2 == '\t')
                 && next_token_can_follow_bin_op ())
               retval = false;
 
-            xunput (c2, yytext);
+            xunput (c2);
           }
         else if (! match_any (c1, ",;\n") && (c1 == ' ' || c1 == '\t')
                  && next_token_can_follow_bin_op ())
           retval = false;
 
-        xunput (c1, yytext);
+        xunput (c1);
       }
       break;
 
     // ~= !=
     case '~':
     case '!':
       {
         int c1 = text_yyinput ();
@@ -3134,41 +3182,42 @@ looks_like_command_arg (void)
         if (c1 == '=')
           {
             int c2 = text_yyinput ();
 
             if (! match_any (c2, ",;\n") && (c2 == ' ' || c2 == '\t')
                 && next_token_can_follow_bin_op ())
               retval = false;
 
-            xunput (c2, yytext);
+            xunput (c2);
           }
         else if (! match_any (c1, ",;\n") && (c1 == ' ' || c1 == '\t')
                  && next_token_can_follow_bin_op ())
           retval = false;
 
-        xunput (c1, yytext);
+        xunput (c1);
       }
       break;
 
     default:
       break;
     }
 
-  xunput (c0, yytext);
+  xunput (c0);
 
   return retval;
 }
 
-static int
-handle_superclass_identifier (void)
+int
+lexical_feedback::handle_superclass_identifier (void)
 {
-  int c = yytext[yyleng-1];
-
-  std::string meth = strip_trailing_whitespace (yytext);
+  char *yytxt = flex_yytext ();
+  int c = yytxt[flex_yyleng()-1];
+
+  std::string meth = strip_trailing_whitespace (yytxt);
 
   int cont_is_spc = eat_continuation ();
 
   int spc_gobbled = (cont_is_spc || c == ' ' || c == '\t');
 
   size_t pos = meth.find ("@");
   std::string cls = meth.substr (pos + 1);
   meth = meth.substr (0, pos);
@@ -3184,33 +3233,33 @@ handle_superclass_identifier (void)
   int kw_token = (is_keyword_token (meth) || is_keyword_token (cls)
                   || is_keyword_token (pkg));
   if (kw_token)
     {
       error ("method, class, and package names may not be keywords");
       return LEXICAL_ERROR;
     }
 
-  yylval.tok_val = new token (meth, pkg, cls, input_line_number,
-                              current_input_column);
-  token_stack.push (yylval.tok_val);
+  push_token (new token (meth, pkg, cls, input_line_number,
+                         current_input_column));
 
   do_comma_insert_check ();
   maybe_unput_comma (spc_gobbled);
-  current_input_column += yyleng;
+  current_input_column += flex_yyleng ();
 
   return SUPERCLASSREF;
 }
 
-static int
-handle_meta_identifier (void)
+int
+lexical_feedback::handle_meta_identifier (void)
 {
-  int c = yytext[yyleng-1];
-
-  std::string cls = strip_trailing_whitespace (yytext).substr (1);
+  char *yytxt = flex_yytext ();
+  int c = yytxt[flex_yyleng()-1];
+
+  std::string cls = strip_trailing_whitespace (yytxt).substr (1);
 
   int cont_is_spc = eat_continuation ();
 
   int spc_gobbled = (cont_is_spc || c == ' ' || c == '\t');
 
   std::string pkg;
   size_t pos = cls.find (".");
   if (pos != std::string::npos)
@@ -3221,137 +3270,136 @@ handle_meta_identifier (void)
 
   int kw_token = is_keyword_token (cls) || is_keyword_token (pkg);
   if (kw_token)
     {
       error ("class and package names may not be keywords");
       return LEXICAL_ERROR;
     }
 
-  yylval.tok_val = new token (pkg, cls, input_line_number,
-                              current_input_column);
-  token_stack.push (yylval.tok_val);
+  push_token (new token (pkg, cls, input_line_number,
+                         current_input_column));
 
   do_comma_insert_check ();
   maybe_unput_comma (spc_gobbled);
-  current_input_column += yyleng;
+  current_input_column += flex_yyleng ();
 
   return METAQUERY;
 }
 
 // Figure out exactly what kind of token to return when we have seen
 // an identifier.  Handles keywords.  Return -1 if the identifier
 // should be ignored.
 
-static int
-handle_identifier (void)
+int
+lexical_feedback::handle_identifier (void)
 {
-  bool at_bos = lexer_flags.at_beginning_of_statement;
-
-  std::string tok = strip_trailing_whitespace (yytext);
-
-  int c = yytext[yyleng-1];
-
-  int cont_is_spc = eat_continuation ();
+  OCTAVE_YYG;
+
+  bool at_bos = at_beginning_of_statement;
+
+  char *yytxt = flex_yytext ();
+
+  std::string tok = strip_trailing_whitespace (yytxt);
+
+  int c = yytxt[flex_yyleng()-1];
+
+  bool cont_is_spc = (eat_continuation () != lexical_feedback::NO_WHITESPACE);
 
   int spc_gobbled = (cont_is_spc || c == ' ' || c == '\t');
 
   // If we are expecting a structure element, avoid recognizing
   // keywords and other special names and return STRUCT_ELT, which is
   // a string that is also a valid identifier.  But first, we have to
   // decide whether to insert a comma.
 
-  if (lexer_flags.looking_at_indirect_ref)
+  if (looking_at_indirect_ref)
     {
       do_comma_insert_check ();
 
       maybe_unput_comma (spc_gobbled);
 
-      yylval.tok_val = new token (tok, input_line_number,
-                                  current_input_column);
-
-      token_stack.push (yylval.tok_val);
-
-      lexer_flags.quote_is_transpose = true;
-      lexer_flags.convert_spaces_to_comma = true;
-      lexer_flags.looking_for_object_index = true;
-
-      current_input_column += yyleng;
+      push_token (new token (tok, input_line_number,
+                             current_input_column));
+
+      quote_is_transpose = true;
+      convert_spaces_to_comma = true;
+      looking_for_object_index = true;
+
+      current_input_column += flex_yyleng ();
 
       return STRUCT_ELT;
     }
 
-  lexer_flags.at_beginning_of_statement = false;
+  at_beginning_of_statement = false;
 
   // The is_keyword_token may reset
-  // lexer_flags.at_beginning_of_statement.  For example, if it sees
+  // at_beginning_of_statement.  For example, if it sees
   // an else token, then the next token is at the beginning of a
   // statement.
 
   int kw_token = is_keyword_token (tok);
 
   // If we found a keyword token, then the beginning_of_statement flag
   // is already set.  Otherwise, we won't be at the beginning of a
   // statement.
 
-  if (lexer_flags.looking_at_function_handle)
+  if (looking_at_function_handle)
     {
       if (kw_token)
         {
           error ("function handles may not refer to keywords");
 
           return LEXICAL_ERROR;
         }
       else
         {
-          yylval.tok_val = new token (tok, input_line_number,
-                                      current_input_column);
-
-          token_stack.push (yylval.tok_val);
-
-          current_input_column += yyleng;
-          lexer_flags.quote_is_transpose = false;
-          lexer_flags.convert_spaces_to_comma = true;
-          lexer_flags.looking_for_object_index = true;
+          push_token (new token (tok, input_line_number,
+                                 current_input_column));
+
+          current_input_column += flex_yyleng ();
+          quote_is_transpose = false;
+          convert_spaces_to_comma = true;
+          looking_for_object_index = true;
 
           return FCN_HANDLE;
         }
     }
 
   // If we have a regular keyword, return it.
   // Keywords can be followed by identifiers.
 
   if (kw_token)
     {
       if (kw_token >= 0)
         {
-          current_input_column += yyleng;
-          lexer_flags.quote_is_transpose = false;
-          lexer_flags.convert_spaces_to_comma = true;
-          lexer_flags.looking_for_object_index = false;
+          current_input_column += flex_yyleng ();
+          quote_is_transpose = false;
+          convert_spaces_to_comma = true;
+          looking_for_object_index = false;
         }
 
       return kw_token;
     }
 
   // See if we have a plot keyword (title, using, with, or clear).
 
   int c1 = text_yyinput ();
 
   bool next_tok_is_eq = false;
   if (c1 == '=')
     {
       int c2 = text_yyinput ();
-      xunput (c2, yytext);
+      xunput (c2);
 
       if (c2 != '=')
         next_tok_is_eq = true;
     }
 
-  xunput (c1, yytext);
+  xunput (c1);
 
   // Kluge alert.
   //
   // If we are looking at a text style function, set up to gobble its
   // arguments.
   //
   // If the following token is '=', or if we are parsing a function
   // return list or function parameter list, or if we are looking at
@@ -3361,292 +3409,145 @@ handle_identifier (void)
   if (! is_variable (tok))
     {
       if (at_bos && spc_gobbled && can_be_command (tok)
           && looks_like_command_arg ())
         {
           BEGIN (COMMAND_START);
         }
       else if (next_tok_is_eq
-               || lexer_flags.looking_at_decl_list
-               || lexer_flags.looking_at_return_list
-               || (lexer_flags.looking_at_parameter_list
-                   && ! lexer_flags.looking_at_initializer_expression))
+               || looking_at_decl_list
+               || looking_at_return_list
+               || (looking_at_parameter_list
+                   && ! looking_at_initializer_expression))
         {
           symbol_table::force_variable (tok);
         }
-      else if (lexer_flags.looking_at_matrix_or_assign_lhs)
+      else if (looking_at_matrix_or_assign_lhs)
         {
-          lexer_flags.pending_local_variables.insert (tok);
+          pending_local_variables.insert (tok);
         }
     }
 
   // Find the token in the symbol table.  Beware the magic
   // transformation of the end keyword...
 
   if (tok == "end")
     tok = "__end__";
 
-  yylval.tok_val = new token (&(symbol_table::insert (tok)),
-                              input_line_number, current_input_column);
-
-  token_stack.push (yylval.tok_val);
+  push_token (new token (&(symbol_table::insert (tok)),
+                         input_line_number, current_input_column));
 
   // After seeing an identifer, it is ok to convert spaces to a comma
   // (if needed).
 
-  lexer_flags.convert_spaces_to_comma = true;
+  convert_spaces_to_comma = true;
 
   if (! (next_tok_is_eq || YY_START == COMMAND_START))
     {
-      lexer_flags.quote_is_transpose = true;
+      quote_is_transpose = true;
 
       do_comma_insert_check ();
 
       maybe_unput_comma (spc_gobbled);
     }
 
-  current_input_column += yyleng;
+  current_input_column += flex_yyleng ();
 
   if (tok != "__end__")
-    lexer_flags.looking_for_object_index = true;
+    looking_for_object_index = true;
 
   return NAME;
 }
 
 void
-lexical_feedback::init (void)
-{
-  // Not initially defining a matrix list.
-  bracketflag = 0;
-
-  // Not initially defining a cell array list.
-  braceflag = 0;
-
-  // Not initially inside a loop or if statement.
-  looping = 0;
-
-  // Not initially defining a function.
-  defining_func = 0;
-
-  // Not parsing an object index.
-  while (! parsed_function_name.empty ())
-    parsed_function_name.pop ();
-
-  parsing_class_method = false;
-
-  // Not initially defining a class with classdef.
-  maybe_classdef_get_set_method = false;
-  parsing_classdef = false;
-  parsing_classdef_get_method = false;
-  parsing_classdef_set_method = false;
-
-  // Not initiallly looking at a function handle.
-  looking_at_function_handle = 0;
-
-  // Not initiallly looking at an anonymous function argument list.
-  looking_at_anon_fcn_args = 0;
-
-  // Not parsing a function return, parameter, or declaration list.
-  looking_at_return_list = false;
-  looking_at_parameter_list = false;
-  looking_at_decl_list = false;
-
-  // Not looking at an argument list initializer expression.
-  looking_at_initializer_expression = false;
-
-  // Not parsing a matrix or the left hand side of multi-value
-  // assignment statement.
-  looking_at_matrix_or_assign_lhs = false;
-
-  // Not parsing an object index.
-  while (! looking_at_object_index.empty ())
-    looking_at_object_index.pop_front ();
-
-  looking_at_object_index.push_front (false);
-
-  // Object index not possible until we've seen something.
-  looking_for_object_index = false;
-
-  // Yes, we are at the beginning of a statement.
-  at_beginning_of_statement = true;
-
-  // No need to do comma insert or convert spaces to comma at
-  // beginning of input.
-  convert_spaces_to_comma = true;
-  do_comma_insert = false;
-
-  // Not initially looking at indirect references.
-  looking_at_indirect_ref = false;
-
-  // Quote marks strings intially.
-  quote_is_transpose = false;
-
-  // Set of identifiers that might be local variable names is empty.
-  pending_local_variables.clear ();
-}
-
-bool
-is_keyword (const std::string& s)
-{
-  // Parsing function names like "set.property_name" inside
-  // classdef-style class definitions is simplified by handling the
-  // "set" and "get" portions of the names using the same mechanism as
-  // is used for keywords.  However, they are not really keywords in
-  // the language, so omit them from the list of possible keywords.
-
-  return (octave_kw_hash::in_word_set (s.c_str (), s.length ()) != 0
-          && ! (s == "set" || s == "get"));
-}
-
-DEFUN (iskeyword, args, ,
-  "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} iskeyword ()\n\
-@deftypefnx {Built-in Function} {} iskeyword (@var{name})\n\
-Return true if @var{name} is an Octave keyword.  If @var{name}\n\
-is omitted, return a list of keywords.\n\
-@seealso{isvarname, exist}\n\
-@end deftypefn")
-{
-  octave_value retval;
-
-  int argc = args.length () + 1;
-
-  string_vector argv = args.make_argv ("iskeyword");
-
-  if (error_state)
-    return retval;
-
-  if (argc == 1)
-    {
-      // Neither set and get are keywords.  See the note in the
-      // is_keyword function for additional details.
-
-      string_vector lst (TOTAL_KEYWORDS);
-
-      int j = 0;
-
-      for (int i = 0; i < TOTAL_KEYWORDS; i++)
-        {
-          std::string tmp = wordlist[i].name;
-
-          if (! (tmp == "set" || tmp == "get"))
-            lst[j++] = tmp;
-        }
-
-      lst.resize (j);
-
-      retval = Cell (lst.sort ());
-    }
-  else if (argc == 2)
-    {
-      retval = is_keyword (argv[1]);
-    }
-  else
-    print_usage ();
-
-  return retval;
-}
-
-/*
-
-%!assert (iskeyword ("for"))
-%!assert (iskeyword ("fort"), false)
-%!assert (iskeyword ("fft"), false)
-
-*/
-
-void
-prep_lexer_for_script_file (void)
-{
-  BEGIN (SCRIPT_FILE_BEGIN);
-}
-
-void
-prep_lexer_for_function_file (void)
-{
-  BEGIN (FUNCTION_FILE_BEGIN);
-}
-
-void
-prep_lexer_for_classdef_file (void)
-{
-  BEGIN (CLASSDEF_FILE_BEGIN);
-}
-
-static void
-maybe_warn_separator_insert (char sep)
+lexical_feedback::maybe_warn_separator_insert (char sep)
 {
   std::string nm = curr_fcn_file_full_name;
 
   if (nm.empty ())
     warning_with_id ("Octave:separator-insert",
                      "potential auto-insertion of '%c' near line %d",
                      sep, input_line_number);
   else
     warning_with_id ("Octave:separator-insert",
                      "potential auto-insertion of '%c' near line %d of file %s",
                      sep, input_line_number, nm.c_str ());
 }
 
-static void
-gripe_single_quote_string (void)
+void
+lexical_feedback::gripe_single_quote_string (void)
 {
   std::string nm = curr_fcn_file_full_name;
 
   if (nm.empty ())
     warning_with_id ("Octave:single-quote-string",
                      "single quote delimited string near line %d",
                      input_line_number);
   else
     warning_with_id ("Octave:single-quote-string",
                      "single quote delimited string near line %d of file %s",
                      input_line_number, nm.c_str ());
 }
 
-static void
-gripe_matlab_incompatible (const std::string& msg)
+void
+lexical_feedback::gripe_matlab_incompatible (const std::string& msg)
 {
   std::string nm = curr_fcn_file_full_name;
 
   if (nm.empty ())
     warning_with_id ("Octave:matlab-incompatible",
                      "potential Matlab compatibility problem: %s",
                      msg.c_str ());
   else
     warning_with_id ("Octave:matlab-incompatible",
                      "potential Matlab compatibility problem: %s near line %d offile %s",
                      msg.c_str (), input_line_number, nm.c_str ());
 }
 
-static void
-maybe_gripe_matlab_incompatible_comment (char c)
+void
+lexical_feedback::maybe_gripe_matlab_incompatible_comment (char c)
 {
   if (c == '#')
     gripe_matlab_incompatible ("# used as comment character");
 }
 
-static void
-gripe_matlab_incompatible_continuation (void)
+void
+lexical_feedback::gripe_matlab_incompatible_continuation (void)
 {
   gripe_matlab_incompatible ("\\ used as line continuation marker");
 }
 
-static void
-gripe_matlab_incompatible_operator (const std::string& op)
+void
+lexical_feedback::gripe_matlab_incompatible_operator (const std::string& op)
 {
   std::string t = op;
   int n = t.length ();
   if (t[n-1] == '\n')
     t.resize (n-1);
   gripe_matlab_incompatible (t + " used as operator");
 }
 
-static void
-display_token (int tok)
+void
+lexical_feedback::push_token (token *tok)
+{
+  YYSTYPE *lval = yyget_lval (scanner);
+  lval->tok_val = tok;
+  token_stack.push (tok);
+}
+
+token *
+lexical_feedback::current_token (void)
+{
+  YYSTYPE *lval = yyget_lval (scanner);
+  return lval->tok_val;
+}
+
+void
+lexical_feedback::display_token (int tok)
 {
   switch (tok)
     {
     case '=': std::cerr << "'='\n"; break;
     case ':': std::cerr << "':'\n"; break;
     case '-': std::cerr << "'-'\n"; break;
     case '+': std::cerr << "'+'\n"; break;
     case '*': std::cerr << "'*'\n"; break;
@@ -3688,39 +3589,51 @@ display_token (int tok)
     case TRANSPOSE: std::cerr << "TRANSPOSE\n"; break;
     case PLUS_PLUS: std::cerr << "PLUS_PLUS\n"; break;
     case MINUS_MINUS: std::cerr << "MINUS_MINUS\n"; break;
     case POW: std::cerr << "POW\n"; break;
     case EPOW: std::cerr << "EPOW\n"; break;
 
     case NUM:
     case IMAG_NUM:
-      std::cerr << (tok == NUM ? "NUM" : "IMAG_NUM")
-                << " [" << yylval.tok_val->number () << "]\n";
+      {
+        token *tok_val = current_token ();
+        std::cerr << (tok == NUM ? "NUM" : "IMAG_NUM")
+                  << " [" << tok_val->number () << "]\n";
+      }
       break;
 
     case STRUCT_ELT:
-      std::cerr << "STRUCT_ELT [" << yylval.tok_val->text () << "]\n"; break;
+      {
+        token *tok_val = current_token ();
+        std::cerr << "STRUCT_ELT [" << tok_val->text () << "]\n";
+      }
+      break;
 
     case NAME:
       {
-        symbol_table::symbol_record *sr = yylval.tok_val->sym_rec ();
+        token *tok_val = current_token ();
+        symbol_table::symbol_record *sr = tok_val->sym_rec ();
         std::cerr << "NAME";
         if (sr)
           std::cerr << " [" << sr->name () << "]";
         std::cerr << "\n";
       }
       break;
 
     case END: std::cerr << "END\n"; break;
 
     case DQ_STRING:
     case SQ_STRING:
-      std::cerr << (tok == DQ_STRING ? "DQ_STRING" : "SQ_STRING")
-                << " [" << yylval.tok_val->text () << "]\n";
+      {
+        token *tok_val = current_token ();
+
+        std::cerr << (tok == DQ_STRING ? "DQ_STRING" : "SQ_STRING")
+                  << " [" << tok_val->text () << "]\n";
+      }
       break;
 
     case FOR: std::cerr << "FOR\n"; break;
     case WHILE: std::cerr << "WHILE\n"; break;
     case DO: std::cerr << "DO\n"; break;
     case UNTIL: std::cerr << "UNTIL\n"; break;
     case IF: std::cerr << "IF\n"; break;
     case ELSEIF: std::cerr << "ELSEIF\n"; break;
@@ -3763,21 +3676,21 @@ display_token (int tok)
         else
           std::cerr << "UNKNOWN(" << tok << ")\n";
       }
       break;
     }
 }
 
 static void
-display_state (void)
+display_state (int state)
 {
   std::cerr << "S: ";
 
-  switch (YY_START)
+  switch (state)
     {
     case INITIAL:
       std::cerr << "INITIAL" << std::endl;
       break;
 
     case COMMAND_START:
       std::cerr << "COMMAND_START" << std::endl;
       break;
@@ -3799,51 +3712,30 @@ display_state (void)
       break;
 
     default:
       std::cerr << "UNKNOWN START STATE!" << std::endl;
       break;
     }
 }
 
-static void
-lexer_debug (const char *pattern, const char *text)
+void
+lexical_feedback::fatal_error (const char *msg)
 {
+  error (msg);
+
+  OCTAVE_QUIT;
+
+  yy_fatal_error (msg, scanner);
+}
+
+void
+lexical_feedback::lexer_debug (const char *pattern, const char *text)
+{
+  OCTAVE_YYG;
+
   std::cerr << std::endl;
 
-  display_state ();
+  display_state (YY_START);
 
   std::cerr << "P: " << pattern << std::endl;
   std::cerr << "T: " << text << std::endl;
 }
-
-DEFUN (__display_tokens__, args, nargout,
-  "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} __display_tokens__ ()\n\
-Query or set the internal variable that determines whether Octave's\n\
-lexer displays tokens as they are read.\n\
-@end deftypefn")
-{
-  return SET_INTERNAL_VARIABLE (display_tokens);
-}
-
-DEFUN (__token_count__, , ,
-  "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} __token_count__ ()\n\
-Number of language tokens processed since Octave startup.\n\
-@end deftypefn")
-{
-  return octave_value (Vtoken_count);
-}
-
-DEFUN (__lexer_debug_flag__, args, nargout,
-  "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {@var{old_val} =} __lexer_debug_flag__ (@var{new_val}))\n\
-Undocumented internal function.\n\
-@end deftypefn")
-{
-  octave_value retval;
-
-  retval = set_internal_variable (lexer_debug_flag, args, nargout,
-                                  "__lexer_debug_flag__");
-
-  return retval;
-}
diff --git a/libinterp/parse-tree/oct-parse.yy b/libinterp/parse-tree/oct-parse.yy
--- a/libinterp/parse-tree/oct-parse.yy
+++ b/libinterp/parse-tree/oct-parse.yy
@@ -74,338 +74,57 @@ along with Octave; see the file COPYING.
 #include "pt-eval.h"
 #include "pt-funcall.h"
 #include "symtab.h"
 #include "token.h"
 #include "unwind-prot.h"
 #include "utils.h"
 #include "variables.h"
 
+// oct-parse.h must be included after pt-all.h
+#include <oct-parse.h>
+
+extern int octave_lex (YYSTYPE *, void *);
+
+// Global access to currently active lexer.
+// FIXME -- to be removed after more parser+lexer refactoring.
+lexical_feedback *CURR_LEXER = 0;
+
 #if defined (GNULIB_NAMESPACE)
 // Calls to the following functions appear in the generated output from
 // Bison without the namespace tag.  Redefine them so we will use them
 // via the gnulib namespace.
 #define fclose GNULIB_NAMESPACE::fclose
 #define fprintf GNULIB_NAMESPACE::fprintf
 #define malloc GNULIB_NAMESPACE::malloc
 #endif
 
-// The current input line number.
-int input_line_number = 1;
-
-// The column of the current token.
-int current_input_column = 1;
-
 // Buffer for help text snagged from function files.
 std::stack<std::string> help_buf;
 
-// Buffer for comments appearing before a function statement.
-static std::string fcn_comment_header;
-
 // TRUE means we are using readline.
 // (--no-line-editing)
 bool line_editing = true;
 
 // TRUE means we printed messages about reading startup files.
 bool reading_startup_message_printed = false;
 
 // TRUE means input is coming from startup file.
 bool input_from_startup_file = false;
 
-// = 0 currently outside any function.
-// = 1 inside the primary function or a subfunction.
-// > 1 means we are looking at a function definition that seems to be
-//     inside a function. Note that the function still might not be a
-//     nested function.
-static int current_function_depth = 0;
-
-// A stack holding the nested function scopes being parsed.
-// We don't use std::stack, because we want the clear method. Also, we
-// must access one from the top
-static std::vector<symbol_table::scope_id> function_scopes;
-
-// Maximum function depth detected. Just here to determine whether
-// we have nested functions or just implicitly ended subfunctions.
-static int max_function_depth = 0;
-
-// FALSE if we are still at the primary function. Subfunctions can
-// only be declared inside function files.
-static int parsing_subfunctions = false;
-
-// Have we found an explicit end to a function?
-static bool endfunction_found = false;
-
 // Keep track of symbol table information when parsing functions.
 symtab_context parser_symtab_context;
 
-// Name of the current class when we are parsing class methods or
-// constructors.
-std::string current_class_name;
-
-// TRUE means we are in the process of autoloading a function.
-static bool autoloading = false;
-
-// TRUE means the current function file was found in a relative path
-// element.
-static bool fcn_file_from_relative_lookup = false;
-
-// Pointer to the primary user function or user script function.
-static octave_function *primary_fcn_ptr = 0;
-
-// Scope where we install all subfunctions and nested functions. Only
-// used while reading function files.
-static symbol_table::scope_id primary_fcn_scope;
-
-// Pointer to the classdef object we just parsed, if any.
-static tree_classdef *classdef_object = 0;
-
 // List of autoloads (function -> file mapping).
 static std::map<std::string, std::string> autoload_map;
 
 // Forward declarations for some functions defined at the bottom of
 // the file.
 
-// Generic error messages.
-static void
-yyerror (const char *s);
-
-// Error mesages for mismatched end tokens.
-static void
-end_error (const char *type, token::end_tok_type ettype, int l, int c);
-
-// Check to see that end tokens are properly matched.
-static bool
-end_token_ok (token *tok, token::end_tok_type expected);
-
-// Maybe print a warning if an assignment expression is used as the
-// test in a logical expression.
-static void
-maybe_warn_assign_as_truth_value (tree_expression *expr);
-
-// Maybe print a warning about switch labels that aren't constants.
-static void
-maybe_warn_variable_switch_label (tree_expression *expr);
-
-// Finish building a range.
-static tree_expression *
-finish_colon_expression (tree_colon_expression *e);
-
-// Build a constant.
-static tree_constant *
-make_constant (int op, token *tok_val);
-
-// Build a function handle.
-static tree_fcn_handle *
-make_fcn_handle (token *tok_val);
-
-// Build an anonymous function handle.
-static tree_anon_fcn_handle *
-make_anon_fcn_handle (tree_parameter_list *param_list, tree_statement *stmt);
-
-// Build a binary expression.
-static tree_expression *
-make_binary_op (int op, tree_expression *op1, token *tok_val,
-                tree_expression *op2);
-
-// Build a boolean expression.
-static tree_expression *
-make_boolean_op (int op, tree_expression *op1, token *tok_val,
-                 tree_expression *op2);
-
-// Build a prefix expression.
-static tree_expression *
-make_prefix_op (int op, tree_expression *op1, token *tok_val);
-
-// Build a postfix expression.
-static tree_expression *
-make_postfix_op (int op, tree_expression *op1, token *tok_val);
-
-// Build an unwind-protect command.
-static tree_command *
-make_unwind_command (token *unwind_tok, tree_statement_list *body,
-                     tree_statement_list *cleanup, token *end_tok,
-                     octave_comment_list *lc, octave_comment_list *mc);
-
-// Build a try-catch command.
-static tree_command *
-make_try_command (token *try_tok, tree_statement_list *body,
-                  tree_statement_list *cleanup, token *end_tok,
-                  octave_comment_list *lc, octave_comment_list *mc);
-
-// Build a while command.
-static tree_command *
-make_while_command (token *while_tok, tree_expression *expr,
-                    tree_statement_list *body, token *end_tok,
-                    octave_comment_list *lc);
-
-// Build a do-until command.
-static tree_command *
-make_do_until_command (token *until_tok, tree_statement_list *body,
-                       tree_expression *expr, octave_comment_list *lc);
-
-// Build a for command.
-static tree_command *
-make_for_command (int tok_id, token *for_tok, tree_argument_list *lhs,
-                  tree_expression *expr, tree_expression *maxproc,
-                  tree_statement_list *body, token *end_tok,
-                  octave_comment_list *lc);
-
-// Build a break command.
-static tree_command *
-make_break_command (token *break_tok);
-
-// Build a continue command.
-static tree_command *
-make_continue_command (token *continue_tok);
-
-// Build a return command.
-static tree_command *
-make_return_command (token *return_tok);
-
-// Start an if command.
-static tree_if_command_list *
-start_if_command (tree_expression *expr, tree_statement_list *list);
-
-// Finish an if command.
-static tree_if_command *
-finish_if_command (token *if_tok, tree_if_command_list *list,
-                   token *end_tok, octave_comment_list *lc);
-
-// Build an elseif clause.
-static tree_if_clause *
-make_elseif_clause (token *elseif_tok, tree_expression *expr,
-                    tree_statement_list *list, octave_comment_list *lc);
-
-// Finish a switch command.
-static tree_switch_command *
-finish_switch_command (token *switch_tok, tree_expression *expr,
-                       tree_switch_case_list *list, token *end_tok,
-                       octave_comment_list *lc);
-
-// Build a switch case.
-static tree_switch_case *
-make_switch_case (token *case_tok, tree_expression *expr,
-                  tree_statement_list *list, octave_comment_list *lc);
-
-// Build an assignment to a variable.
-static tree_expression *
-make_assign_op (int op, tree_argument_list *lhs, token *eq_tok,
-                tree_expression *rhs);
-
-// Define a script.
-static void
-make_script (tree_statement_list *cmds, tree_statement *end_script);
-
-// Begin defining a function.
-static octave_user_function *
-start_function (tree_parameter_list *param_list, tree_statement_list *body,
-                tree_statement *end_function);
-
-// Create a no-op statement for end_function.
-static tree_statement *
-make_end (const std::string& type, int l, int c);
-
-// Do most of the work for defining a function.
-static octave_user_function *
-frob_function (const std::string& fname, octave_user_function *fcn);
-
-// Finish defining a function.
-static tree_function_def *
-finish_function (tree_parameter_list *ret_list,
-                 octave_user_function *fcn, octave_comment_list *lc);
-
-// Reset state after parsing function.
-static void
-recover_from_parsing_function (void);
-
-// Make an index expression.
-static tree_index_expression *
-make_index_expression (tree_expression *expr,
-                       tree_argument_list *args, char type);
-
-// Make an indirect reference expression.
-static tree_index_expression *
-make_indirect_ref (tree_expression *expr, const std::string&);
-
-// Make an indirect reference expression with dynamic field name.
-static tree_index_expression *
-make_indirect_ref (tree_expression *expr, tree_expression *field);
-
-// Make a declaration command.
-static tree_decl_command *
-make_decl_command (int tok, token *tok_val, tree_decl_init_list *lst);
-
-// Validate argument list forming a matrix or cell row.
-static tree_argument_list *
-validate_matrix_row (tree_argument_list *row);
-
-// Finish building a matrix list.
-static tree_expression *
-finish_matrix (tree_matrix *m);
-
-// Finish building a cell list.
-static tree_expression *
-finish_cell (tree_cell *c);
-
-// Maybe print a warning.  Duh.
-static void
-maybe_warn_missing_semi (tree_statement_list *);
-
-// Set the print flag for a statement based on the separator type.
-static tree_statement_list *
-set_stmt_print_flag (tree_statement_list *, char, bool);
-
-// Create a statement list.
-static tree_statement_list *make_statement_list (tree_statement *stmt);
-
-// Append a statement to an existing statement list.
-static tree_statement_list *
-append_statement_list (tree_statement_list *list, char sep,
-                       tree_statement *stmt, bool warn_missing_semi);
-
-static tree_funcall *
-make_superclass_ref (const std::string& method_nm,
-                     const std::string& package_nm,
-                     const std::string& class_nm,
-                     int l, int c);
-
-static tree_funcall *
-make_meta_class_query (const std::string& package_nm,
-                       const std::string& class_nm,
-                       int l, int c);
-
-static tree_classdef *
-make_classdef (token *tok_val, tree_classdef_attribute_list *a,
-               tree_identifier *id, tree_classdef_superclass_list *sc,
-               tree_classdef_body *body, token *end_tok,
-               octave_comment_list *lc);
-
-static tree_classdef_properties_block *
-make_classdef_properties_block (token *tok_val,
-                                tree_classdef_attribute_list *a,
-                                tree_classdef_property_list *plist,
-                                token *end_tok, octave_comment_list *lc);
-
-static tree_classdef_methods_block *
-make_classdef_methods_block (token *tok_val,
-                             tree_classdef_attribute_list *a,
-                             tree_classdef_methods_list *mlist,
-                             token *end_tok, octave_comment_list *lc);
-
-static tree_classdef_events_block *
-make_classdef_events_block (token *tok_val,
-                            tree_classdef_attribute_list *a,
-                            tree_classdef_events_list *elist,
-                            token *end_tok, octave_comment_list *lc);
-
-static tree_classdef_enum_block *
-make_classdef_enum_block (token *tok_val,
-                          tree_classdef_attribute_list *a,
-                          tree_classdef_enum_list *elist,
-                          token *end_tok, octave_comment_list *lc);
+static void yyerror (octave_parser *curr_parser, const char *s);
 
 // Finish building a statement.
 template <class T>
 static tree_statement *
 make_statement (T *arg)
 {
   octave_comment_list *comment = octave_comment_buffer::get_comment ();
 
@@ -422,25 +141,41 @@ make_statement (T *arg)
       if ((interactive || forced_interactive)   \
           && ! get_input_from_eval_string)      \
         YYACCEPT; \
       else \
         YYABORT; \
     } \
   while (0)
 
+#define curr_lexer curr_parser->curr_lexer
+#define scanner curr_lexer->scanner
+
 %}
 
 // Bison declarations.
 
 // Don't add spaces around the = here; it causes some versions of
 // bison to fail to properly recognize the directive.
 
 %name-prefix="octave_"
 
+// We are using the pure parser interface and the reentrant lexer
+// interface but the Octave parser and lexer are NOT properly
+// reentrant because both still use many global variables.  It should be
+// safe to create a parser object and call it while anotehr parser
+// object is active (to parse a callback function while the main
+// interactive parser is waiting for input, for example) if you take
+// care to properly save and restore (typically with an unwind_protect
+// object) relevant global values before and after the nested call.
+
+%define api.pure
+%parse-param { octave_parser *curr_parser }
+%lex-param { void *scanner }
+
 %union
 {
   // The type of the basic tokens returned by the lexer.
   token *tok_val;
 
   // Comment strings that we need to deal with mid-rule.
   octave_comment_list *comment_type;
 
@@ -628,51 +363,51 @@ input           : input1
                 | parse_error
                   { ABORT_PARSE; }
                 ;
 
 input1          : '\n'
                   { $$ = 0; }
                 | END_OF_INPUT
                   {
-                    parser_end_of_input = 1;
+                    curr_parser->end_of_input = true;
                     $$ = 0;
                   }
                 | simple_list
                   { $$ = $1; }
                 | simple_list '\n'
                   { $$ = $1; }
                 | simple_list END_OF_INPUT
                   { $$ = $1; }
                 ;
 
 simple_list     : simple_list1 opt_sep_no_nl
-                  { $$ = set_stmt_print_flag ($1, $2, false); }
+                  { $$ = curr_parser->set_stmt_print_flag ($1, $2, false); }
                 ;
 
 simple_list1    : statement
-                  { $$ = make_statement_list ($1); }
+                  { $$ = curr_parser->make_statement_list ($1); }
                 | simple_list1 sep_no_nl statement
-                  { $$ = append_statement_list ($1, $2, $3, false); }
+                  { $$ = curr_parser->append_statement_list ($1, $2, $3, false); }
                 ;
 
 opt_list        : // empty
                   { $$ = new tree_statement_list (); }
                 | list
                   { $$ = $1; }
                 ;
 
 list            : list1 opt_sep
-                  { $$ = set_stmt_print_flag ($1, $2, true); }
+                  { $$ = curr_parser->set_stmt_print_flag ($1, $2, true); }
                 ;
 
 list1           : statement
-                  { $$ = make_statement_list ($1); }
+                  { $$ = curr_parser->make_statement_list ($1); }
                 | list1 sep statement
-                  { $$ = append_statement_list ($1, $2, $3, true); }
+                  { $$ = curr_parser->append_statement_list ($1, $2, $3, true); }
                 ;
 
 statement       : expression
                   { $$ = make_statement ($1); }
                 | command
                   { $$ = make_statement ($1); }
                 | word_list_cmd
                   { $$ = make_statement ($1); }
@@ -682,17 +417,17 @@ statement       : expression
 // Word-list command
 // =================
 
 // These are not really like expressions since they can't appear on
 // the RHS of an assignment.  But they are also not like commands (IF,
 // WHILE, etc.
 
 word_list_cmd   : identifier word_list
-                  { $$ = make_index_expression ($1, $2, '('); }
+                  { $$ = curr_parser->make_index_expression ($1, $2, '('); }
                 ;
 
 word_list       : string
                   { $$ = new tree_argument_list ($1); }
                 | word_list string
                   {
                     $1->append ($2);
                     $$ = $1;
@@ -712,68 +447,70 @@ identifier      : NAME
 
 superclass_identifier
                 : SUPERCLASSREF
                   {
                     std::string method_nm = $1->superclass_method_name ();
                     std::string package_nm = $1->superclass_package_name ();
                     std::string class_nm = $1->superclass_class_name ();
 
-                    $$ = make_superclass_ref (method_nm, package_nm, class_nm,
-                                              $1->line (), $1->column ());
+                    $$ = curr_parser->make_superclass_ref
+                                        (method_nm, package_nm, class_nm,
+                                         $1->line (), $1->column ());
                   }
                 ;
 
 meta_identifier : METAQUERY
                   {
                     std::string package_nm = $1->meta_package_name ();
                     std::string class_nm = $1->meta_class_name ();
 
-                    $$ = make_meta_class_query (package_nm, class_nm,
-                                                $1->line (), $1->column ());
+                    $$ = curr_parser->make_meta_class_query
+                                        (package_nm, class_nm,
+                                         $1->line (), $1->column ());
                   }
                 ;
 
 string          : DQ_STRING
-                  { $$ = make_constant (DQ_STRING, $1); }
+                  { $$ = curr_parser->make_constant (DQ_STRING, $1); }
                 | SQ_STRING
-                  { $$ = make_constant (SQ_STRING, $1); }
+                  { $$ = curr_parser->make_constant (SQ_STRING, $1); }
                 ;
 
 constant        : NUM
-                  { $$ = make_constant (NUM, $1); }
+                  { $$ = curr_parser->make_constant (NUM, $1); }
                 | IMAG_NUM
-                  { $$ = make_constant (IMAG_NUM, $1); }
+                  { $$ = curr_parser->make_constant (IMAG_NUM, $1); }
                 | string
                   { $$ = $1; }
                 ;
 
 matrix          : '[' ']'
                   {
                     $$ = new tree_constant (octave_null_matrix::instance);
-                    lexer_flags.looking_at_matrix_or_assign_lhs = false;
-                    lexer_flags.pending_local_variables.clear ();
+                    curr_lexer->looking_at_matrix_or_assign_lhs = false;
+                    curr_lexer->pending_local_variables.clear ();
                   }
                 | '[' ';' ']'
                   {
                     $$ = new tree_constant (octave_null_matrix::instance);
-                    lexer_flags.looking_at_matrix_or_assign_lhs = false;
-                    lexer_flags.pending_local_variables.clear ();
+                    curr_lexer->looking_at_matrix_or_assign_lhs = false;
+                    curr_lexer->pending_local_variables.clear ();
                   }
                 | '[' ',' ']'
                   {
                     $$ = new tree_constant (octave_null_matrix::instance);
-                    lexer_flags.looking_at_matrix_or_assign_lhs = false;
-                    lexer_flags.pending_local_variables.clear ();
+                    curr_lexer->looking_at_matrix_or_assign_lhs = false;
+                    curr_lexer->pending_local_variables.clear ();
                   }
                 | '[' matrix_rows ']'
                   {
-                    $$ = finish_matrix ($2);
-                    lexer_flags.looking_at_matrix_or_assign_lhs = false;
-                    lexer_flags.pending_local_variables.clear ();
+                    $$ = curr_parser->finish_matrix ($2);
+                    curr_lexer->looking_at_matrix_or_assign_lhs = false;
+                    curr_lexer->pending_local_variables.clear ();
                   }
                 ;
 
 matrix_rows     : matrix_rows1
                   { $$ = $1; }
                 | matrix_rows1 ';'      // Ignore trailing semicolon.
                   { $$ = $1; }
                 ;
@@ -787,17 +524,17 @@ matrix_rows1    : cell_or_matrix_row
                   }
                 ;
 
 cell            : '{' '}'
                   { $$ = new tree_constant (octave_value (Cell ())); }
                 | '{' ';' '}'
                   { $$ = new tree_constant (octave_value (Cell ())); }
                 | '{' cell_rows '}'
-                  { $$ = finish_cell ($2); }
+                  { $$ = curr_parser->finish_cell ($2); }
                 ;
 
 cell_rows       : cell_rows1
                   { $$ = $1; }
                 | cell_rows1 ';'        // Ignore trailing semicolon.
                   { $$ = $1; }
                 ;
 
@@ -807,32 +544,32 @@ cell_rows1      : cell_or_matrix_row
                   {
                     $1->append ($3);
                     $$ = $1;
                   }
                 ;
 
 cell_or_matrix_row
                 : arg_list
-                  { $$ = validate_matrix_row ($1); }
+                  { $$ = curr_parser->validate_matrix_row ($1); }
                 | arg_list ','  // Ignore trailing comma.
-                  { $$ = validate_matrix_row ($1); }
+                  { $$ = curr_parser->validate_matrix_row ($1); }
                 ;
 
 fcn_handle      : '@' FCN_HANDLE
                   {
-                    $$ = make_fcn_handle ($2);
-                    lexer_flags.looking_at_function_handle--;
+                    $$ = curr_parser->make_fcn_handle ($2);
+                    curr_lexer->looking_at_function_handle--;
                   }
                 ;
 
 anon_fcn_handle : '@' param_list statement
                   {
-                    lexer_flags.quote_is_transpose = false;
-                    $$ = make_anon_fcn_handle ($2, $3);
+                    curr_lexer->quote_is_transpose = false;
+                    $$ = curr_parser->make_anon_fcn_handle ($2, $3);
                   }
                 ;
 
 primary_expr    : identifier
                   { $$ = $1; }
                 | constant
                   { $$ = $1; }
                 | fcn_handle
@@ -881,170 +618,170 @@ arg_list        : expression
                 | arg_list ',' expression
                   {
                     $1->append ($3);
                     $$ = $1;
                   }
                 ;
 
 indirect_ref_op : '.'
-                  { lexer_flags.looking_at_indirect_ref = true; }
+                  { curr_lexer->looking_at_indirect_ref = true; }
                 ;
 
 oper_expr       : primary_expr
                   { $$ = $1; }
                 | oper_expr PLUS_PLUS
-                  { $$ = make_postfix_op (PLUS_PLUS, $1, $2); }
+                  { $$ = curr_parser->make_postfix_op (PLUS_PLUS, $1, $2); }
                 | oper_expr MINUS_MINUS
-                  { $$ = make_postfix_op (MINUS_MINUS, $1, $2); }
+                  { $$ = curr_parser->make_postfix_op (MINUS_MINUS, $1, $2); }
                 | oper_expr '(' ')'
-                  { $$ = make_index_expression ($1, 0, '('); }
+                  { $$ = curr_parser->make_index_expression ($1, 0, '('); }
                 | oper_expr '(' arg_list ')'
-                  { $$ = make_index_expression ($1, $3, '('); }
+                  { $$ = curr_parser->make_index_expression ($1, $3, '('); }
                 | oper_expr '{' '}'
-                  { $$ = make_index_expression ($1, 0, '{'); }
+                  { $$ = curr_parser->make_index_expression ($1, 0, '{'); }
                 | oper_expr '{' arg_list '}'
-                  { $$ = make_index_expression ($1, $3, '{'); }
+                  { $$ = curr_parser->make_index_expression ($1, $3, '{'); }
                 | oper_expr QUOTE
-                  { $$ = make_postfix_op (QUOTE, $1, $2); }
+                  { $$ = curr_parser->make_postfix_op (QUOTE, $1, $2); }
                 | oper_expr TRANSPOSE
-                  { $$ = make_postfix_op (TRANSPOSE, $1, $2); }
+                  { $$ = curr_parser->make_postfix_op (TRANSPOSE, $1, $2); }
                 | oper_expr indirect_ref_op STRUCT_ELT
-                  { $$ = make_indirect_ref ($1, $3->text ()); }
+                  { $$ = curr_parser->make_indirect_ref ($1, $3->text ()); }
                 | oper_expr indirect_ref_op '(' expression ')'
-                  { $$ = make_indirect_ref ($1, $4); }
+                  { $$ = curr_parser->make_indirect_ref ($1, $4); }
                 | PLUS_PLUS oper_expr %prec UNARY
-                  { $$ = make_prefix_op (PLUS_PLUS, $2, $1); }
+                  { $$ = curr_parser->make_prefix_op (PLUS_PLUS, $2, $1); }
                 | MINUS_MINUS oper_expr %prec UNARY
-                  { $$ = make_prefix_op (MINUS_MINUS, $2, $1); }
+                  { $$ = curr_parser->make_prefix_op (MINUS_MINUS, $2, $1); }
                 | EXPR_NOT oper_expr %prec UNARY
-                  { $$ = make_prefix_op (EXPR_NOT, $2, $1); }
+                  { $$ = curr_parser->make_prefix_op (EXPR_NOT, $2, $1); }
                 | '+' oper_expr %prec UNARY
-                  { $$ = make_prefix_op ('+', $2, $1); }
+                  { $$ = curr_parser->make_prefix_op ('+', $2, $1); }
                 | '-' oper_expr %prec UNARY
-                  { $$ = make_prefix_op ('-', $2, $1); }
+                  { $$ = curr_parser->make_prefix_op ('-', $2, $1); }
                 | oper_expr POW oper_expr
-                  { $$ = make_binary_op (POW, $1, $2, $3); }
+                  { $$ = curr_parser->make_binary_op (POW, $1, $2, $3); }
                 | oper_expr EPOW oper_expr
-                  { $$ = make_binary_op (EPOW, $1, $2, $3); }
+                  { $$ = curr_parser->make_binary_op (EPOW, $1, $2, $3); }
                 | oper_expr '+' oper_expr
-                  { $$ = make_binary_op ('+', $1, $2, $3); }
+                  { $$ = curr_parser->make_binary_op ('+', $1, $2, $3); }
                 | oper_expr '-' oper_expr
-                  { $$ = make_binary_op ('-', $1, $2, $3); }
+                  { $$ = curr_parser->make_binary_op ('-', $1, $2, $3); }
                 | oper_expr '*' oper_expr
-                  { $$ = make_binary_op ('*', $1, $2, $3); }
+                  { $$ = curr_parser->make_binary_op ('*', $1, $2, $3); }
                 | oper_expr '/' oper_expr
-                  { $$ = make_binary_op ('/', $1, $2, $3); }
+                  { $$ = curr_parser->make_binary_op ('/', $1, $2, $3); }
                 | oper_expr EPLUS oper_expr
-                  { $$ = make_binary_op ('+', $1, $2, $3); }
+                  { $$ = curr_parser->make_binary_op ('+', $1, $2, $3); }
                 | oper_expr EMINUS oper_expr
-                  { $$ = make_binary_op ('-', $1, $2, $3); }
+                  { $$ = curr_parser->make_binary_op ('-', $1, $2, $3); }
                 | oper_expr EMUL oper_expr
-                  { $$ = make_binary_op (EMUL, $1, $2, $3); }
+                  { $$ = curr_parser->make_binary_op (EMUL, $1, $2, $3); }
                 | oper_expr EDIV oper_expr
-                  { $$ = make_binary_op (EDIV, $1, $2, $3); }
+                  { $$ = curr_parser->make_binary_op (EDIV, $1, $2, $3); }
                 | oper_expr LEFTDIV oper_expr
-                  { $$ = make_binary_op (LEFTDIV, $1, $2, $3); }
+                  { $$ = curr_parser->make_binary_op (LEFTDIV, $1, $2, $3); }
                 | oper_expr ELEFTDIV oper_expr
-                  { $$ = make_binary_op (ELEFTDIV, $1, $2, $3); }
+                  { $$ = curr_parser->make_binary_op (ELEFTDIV, $1, $2, $3); }
                 ;
 
 colon_expr      : colon_expr1
-                  { $$ = finish_colon_expression ($1); }
+                  { $$ = curr_parser->finish_colon_expression ($1); }
                 ;
 
 colon_expr1     : oper_expr
                   { $$ = new tree_colon_expression ($1); }
                 | colon_expr1 ':' oper_expr
                   {
                     if (! ($$ = $1->append ($3)))
                       ABORT_PARSE;
                   }
                 ;
 
 simple_expr     : colon_expr
                   { $$ = $1; }
                 | simple_expr LSHIFT simple_expr
-                  { $$ = make_binary_op (LSHIFT, $1, $2, $3); }
+                  { $$ = curr_parser->make_binary_op (LSHIFT, $1, $2, $3); }
                 | simple_expr RSHIFT simple_expr
-                  { $$ = make_binary_op (RSHIFT, $1, $2, $3); }
+                  { $$ = curr_parser->make_binary_op (RSHIFT, $1, $2, $3); }
                 | simple_expr EXPR_LT simple_expr
-                  { $$ = make_binary_op (EXPR_LT, $1, $2, $3); }
+                  { $$ = curr_parser->make_binary_op (EXPR_LT, $1, $2, $3); }
                 | simple_expr EXPR_LE simple_expr
-                  { $$ = make_binary_op (EXPR_LE, $1, $2, $3); }
+                  { $$ = curr_parser->make_binary_op (EXPR_LE, $1, $2, $3); }
                 | simple_expr EXPR_EQ simple_expr
-                  { $$ = make_binary_op (EXPR_EQ, $1, $2, $3); }
+                  { $$ = curr_parser->make_binary_op (EXPR_EQ, $1, $2, $3); }
                 | simple_expr EXPR_GE simple_expr
-                  { $$ = make_binary_op (EXPR_GE, $1, $2, $3); }
+                  { $$ = curr_parser->make_binary_op (EXPR_GE, $1, $2, $3); }
                 | simple_expr EXPR_GT simple_expr
-                  { $$ = make_binary_op (EXPR_GT, $1, $2, $3); }
+                  { $$ = curr_parser->make_binary_op (EXPR_GT, $1, $2, $3); }
                 | simple_expr EXPR_NE simple_expr
-                  { $$ = make_binary_op (EXPR_NE, $1, $2, $3); }
+                  { $$ = curr_parser->make_binary_op (EXPR_NE, $1, $2, $3); }
                 | simple_expr EXPR_AND simple_expr
-                  { $$ = make_binary_op (EXPR_AND, $1, $2, $3); }
+                  { $$ = curr_parser->make_binary_op (EXPR_AND, $1, $2, $3); }
                 | simple_expr EXPR_OR simple_expr
-                  { $$ = make_binary_op (EXPR_OR, $1, $2, $3); }
+                  { $$ = curr_parser->make_binary_op (EXPR_OR, $1, $2, $3); }
                 | simple_expr EXPR_AND_AND simple_expr
-                  { $$ = make_boolean_op (EXPR_AND_AND, $1, $2, $3); }
+                  { $$ = curr_parser->make_boolean_op (EXPR_AND_AND, $1, $2, $3); }
                 | simple_expr EXPR_OR_OR simple_expr
-                  { $$ = make_boolean_op (EXPR_OR_OR, $1, $2, $3); }
+                  { $$ = curr_parser->make_boolean_op (EXPR_OR_OR, $1, $2, $3); }
                 ;
 
 // Arrange for the lexer to return CLOSE_BRACE for ']' by looking ahead
 // one token for an assignment op.
 
 assign_lhs      : simple_expr
                   {
                     $$ = new tree_argument_list ($1);
                     $$->mark_as_simple_assign_lhs ();
                   }
                 | '[' arg_list opt_comma CLOSE_BRACE
                   {
                     $$ = $2;
-                    lexer_flags.looking_at_matrix_or_assign_lhs = false;
-                    for (std::set<std::string>::const_iterator p = lexer_flags.pending_local_variables.begin ();
-                         p != lexer_flags.pending_local_variables.end ();
+                    curr_lexer->looking_at_matrix_or_assign_lhs = false;
+                    for (std::set<std::string>::const_iterator p = curr_lexer->pending_local_variables.begin ();
+                         p != curr_lexer->pending_local_variables.end ();
                          p++)
                       {
                         symbol_table::force_variable (*p);
                       }
-                    lexer_flags.pending_local_variables.clear ();
+                    curr_lexer->pending_local_variables.clear ();
                   }
                 ;
 
 assign_expr     : assign_lhs '=' expression
-                  { $$ = make_assign_op ('=', $1, $2, $3); }
+                  { $$ = curr_parser->make_assign_op ('=', $1, $2, $3); }
                 | assign_lhs ADD_EQ expression
-                  { $$ = make_assign_op (ADD_EQ, $1, $2, $3); }
+                  { $$ = curr_parser->make_assign_op (ADD_EQ, $1, $2, $3); }
                 | assign_lhs SUB_EQ expression
-                  { $$ = make_assign_op (SUB_EQ, $1, $2, $3); }
+                  { $$ = curr_parser->make_assign_op (SUB_EQ, $1, $2, $3); }
                 | assign_lhs MUL_EQ expression
-                  { $$ = make_assign_op (MUL_EQ, $1, $2, $3); }
+                  { $$ = curr_parser->make_assign_op (MUL_EQ, $1, $2, $3); }
                 | assign_lhs DIV_EQ expression
-                  { $$ = make_assign_op (DIV_EQ, $1, $2, $3); }
+                  { $$ = curr_parser->make_assign_op (DIV_EQ, $1, $2, $3); }
                 | assign_lhs LEFTDIV_EQ expression
-                  { $$ = make_assign_op (LEFTDIV_EQ, $1, $2, $3); }
+                  { $$ = curr_parser->make_assign_op (LEFTDIV_EQ, $1, $2, $3); }
                 | assign_lhs POW_EQ expression
-                  { $$ = make_assign_op (POW_EQ, $1, $2, $3); }
+                  { $$ = curr_parser->make_assign_op (POW_EQ, $1, $2, $3); }
                 | assign_lhs LSHIFT_EQ expression
-                  { $$ = make_assign_op (LSHIFT_EQ, $1, $2, $3); }
+                  { $$ = curr_parser->make_assign_op (LSHIFT_EQ, $1, $2, $3); }
                 | assign_lhs RSHIFT_EQ expression
-                  { $$ = make_assign_op (RSHIFT_EQ, $1, $2, $3); }
+                  { $$ = curr_parser->make_assign_op (RSHIFT_EQ, $1, $2, $3); }
                 | assign_lhs EMUL_EQ expression
-                  { $$ = make_assign_op (EMUL_EQ, $1, $2, $3); }
+                  { $$ = curr_parser->make_assign_op (EMUL_EQ, $1, $2, $3); }
                 | assign_lhs EDIV_EQ expression
-                  { $$ = make_assign_op (EDIV_EQ, $1, $2, $3); }
+                  { $$ = curr_parser->make_assign_op (EDIV_EQ, $1, $2, $3); }
                 | assign_lhs ELEFTDIV_EQ expression
-                  { $$ = make_assign_op (ELEFTDIV_EQ, $1, $2, $3); }
+                  { $$ = curr_parser->make_assign_op (ELEFTDIV_EQ, $1, $2, $3); }
                 | assign_lhs EPOW_EQ expression
-                  { $$ = make_assign_op (EPOW_EQ, $1, $2, $3); }
+                  { $$ = curr_parser->make_assign_op (EPOW_EQ, $1, $2, $3); }
                 | assign_lhs AND_EQ expression
-                  { $$ = make_assign_op (AND_EQ, $1, $2, $3); }
+                  { $$ = curr_parser->make_assign_op (AND_EQ, $1, $2, $3); }
                 | assign_lhs OR_EQ expression
-                  { $$ = make_assign_op (OR_EQ, $1, $2, $3); }
+                  { $$ = curr_parser->make_assign_op (OR_EQ, $1, $2, $3); }
                 ;
 
 expression      : simple_expr
                   { $$ = $1; }
                 | assign_expr
                   { $$ = $1; }
                 | anon_fcn_handle
                   { $$ = $1; }
@@ -1071,47 +808,47 @@ command         : declaration
                 ;
 
 // =====================
 // Declaration statemnts
 // =====================
 
 parsing_decl_list
                 : // empty
-                  { lexer_flags.looking_at_decl_list = true; }
+                  { curr_lexer->looking_at_decl_list = true; }
 
 declaration     : GLOBAL parsing_decl_list decl1
                   {
-                    $$ = make_decl_command (GLOBAL, $1, $3);
-                    lexer_flags.looking_at_decl_list = false;
+                    $$ = curr_parser->make_decl_command (GLOBAL, $1, $3);
+                    curr_lexer->looking_at_decl_list = false;
                   }
                 | PERSISTENT parsing_decl_list decl1
                   {
-                    $$ = make_decl_command (PERSISTENT, $1, $3);
-                    lexer_flags.looking_at_decl_list = false;
+                    $$ = curr_parser->make_decl_command (PERSISTENT, $1, $3);
+                    curr_lexer->looking_at_decl_list = false;
                   }
                 ;
 
 decl1           : decl2
                   { $$ = new tree_decl_init_list ($1); }
                 | decl1 decl2
                   {
                     $1->append ($2);
                     $$ = $1;
                   }
                 ;
 
 decl_param_init : // empty
-                { lexer_flags.looking_at_initializer_expression = true; }
+                { curr_lexer->looking_at_initializer_expression = true; }
 
 decl2           : identifier
                   { $$ = new tree_decl_elt ($1); }
                 | identifier '=' decl_param_init expression
                   {
-                    lexer_flags.looking_at_initializer_expression = false;
+                    curr_lexer->looking_at_initializer_expression = false;
                     $$ = new tree_decl_elt ($1, $4);
                   }
                 | magic_tilde
                   {
                     $$ = new tree_decl_elt ($1);
                   }
                 ;
 
@@ -1126,17 +863,17 @@ select_command  : if_command
                 ;
 
 // ============
 // If statement
 // ============
 
 if_command      : IF stash_comment if_cmd_list END
                   {
-                    if (! ($$ = finish_if_command ($1, $3, $4, $2)))
+                    if (! ($$ = curr_parser->finish_if_command ($1, $3, $4, $2)))
                       ABORT_PARSE;
                   }
                 ;
 
 if_cmd_list     : if_cmd_list1
                   { $$ = $1; }
                 | if_cmd_list1 else_clause
                   {
@@ -1144,44 +881,44 @@ if_cmd_list     : if_cmd_list1
                     $$ = $1;
                   }
                 ;
 
 if_cmd_list1    : expression opt_sep opt_list
                   {
                     $1->mark_braindead_shortcircuit (curr_fcn_file_full_name);
 
-                    $$ = start_if_command ($1, $3);
+                    $$ = curr_parser->start_if_command ($1, $3);
                   }
                 | if_cmd_list1 elseif_clause
                   {
                     $1->append ($2);
                     $$ = $1;
                   }
                 ;
 
 elseif_clause   : ELSEIF stash_comment opt_sep expression opt_sep opt_list
                   {
                     $4->mark_braindead_shortcircuit (curr_fcn_file_full_name);
 
-                    $$ = make_elseif_clause ($1, $4, $6, $2);
+                    $$ = curr_parser->make_elseif_clause ($1, $4, $6, $2);
                   }
                 ;
 
 else_clause     : ELSE stash_comment opt_sep opt_list
                   { $$ = new tree_if_clause ($4, $2); }
                 ;
 
 // ================
 // Switch statement
 // ================
 
 switch_command  : SWITCH stash_comment expression opt_sep case_list END
                   {
-                    if (! ($$ = finish_switch_command ($1, $3, $5, $6, $2)))
+                    if (! ($$ = curr_parser->finish_switch_command ($1, $3, $5, $6, $2)))
                       ABORT_PARSE;
                   }
                 ;
 
 case_list       : // empty
                   { $$ = new tree_switch_case_list (); }
                 | default_case
                   { $$ = new tree_switch_case_list ($1); }
@@ -1199,170 +936,170 @@ case_list1      : switch_case
                 | case_list1 switch_case
                   {
                     $1->append ($2);
                     $$ = $1;
                   }
                 ;
 
 switch_case     : CASE stash_comment opt_sep expression opt_sep opt_list
-                  { $$ = make_switch_case ($1, $4, $6, $2); }
+                  { $$ = curr_parser->make_switch_case ($1, $4, $6, $2); }
                 ;
 
 default_case    : OTHERWISE stash_comment opt_sep opt_list
                   {
                     $$ = new tree_switch_case ($4, $2);
                   }
                 ;
 
 // =======
 // Looping
 // =======
 
 loop_command    : WHILE stash_comment expression opt_sep opt_list END
                   {
                     $3->mark_braindead_shortcircuit (curr_fcn_file_full_name);
 
-                    if (! ($$ = make_while_command ($1, $3, $5, $6, $2)))
+                    if (! ($$ = curr_parser->make_while_command ($1, $3, $5, $6, $2)))
                       ABORT_PARSE;
                   }
                 | DO stash_comment opt_sep opt_list UNTIL expression
                   {
-                    if (! ($$ = make_do_until_command ($5, $4, $6, $2)))
+                    if (! ($$ = curr_parser->make_do_until_command ($5, $4, $6, $2)))
                       ABORT_PARSE;
                   }
                 | FOR stash_comment assign_lhs '=' expression opt_sep opt_list END
                   {
-                    if (! ($$ = make_for_command (FOR, $1, $3, $5, 0,
+                    if (! ($$ = curr_parser->make_for_command (FOR, $1, $3, $5, 0,
                                                   $7, $8, $2)))
                       ABORT_PARSE;
                   }
                 | FOR stash_comment '(' assign_lhs '=' expression ')' opt_sep opt_list END
                   {
-                    if (! ($$ = make_for_command (FOR, $1, $4, $6, 0,
+                    if (! ($$ = curr_parser->make_for_command (FOR, $1, $4, $6, 0,
                                                   $9, $10, $2)))
                       ABORT_PARSE;
                   }
                 | PARFOR stash_comment assign_lhs '=' expression opt_sep opt_list END
                   {
-                    if (! ($$ = make_for_command (PARFOR, $1, $3, $5,
+                    if (! ($$ = curr_parser->make_for_command (PARFOR, $1, $3, $5,
                                                   0, $7, $8, $2)))
                       ABORT_PARSE;
                   }
                 | PARFOR stash_comment '(' assign_lhs '=' expression ',' expression ')' opt_sep opt_list END
                   {
-                    if (! ($$ = make_for_command (PARFOR, $1, $4, $6,
+                    if (! ($$ = curr_parser->make_for_command (PARFOR, $1, $4, $6,
                                                   $8, $11, $12, $2)))
                       ABORT_PARSE;
                   }
                 ;
 
 // =======
 // Jumping
 // =======
 
 jump_command    : BREAK
                   {
-                    if (! ($$ = make_break_command ($1)))
+                    if (! ($$ = curr_parser->make_break_command ($1)))
                       ABORT_PARSE;
                   }
                 | CONTINUE
                   {
-                    if (! ($$ = make_continue_command ($1)))
+                    if (! ($$ = curr_parser->make_continue_command ($1)))
                       ABORT_PARSE;
                   }
                 | FUNC_RET
                   {
-                    if (! ($$ = make_return_command ($1)))
+                    if (! ($$ = curr_parser->make_return_command ($1)))
                       ABORT_PARSE;
                   }
                 ;
 
 // ==========
 // Exceptions
 // ==========
 
 except_command  : UNWIND stash_comment opt_sep opt_list CLEANUP
                   stash_comment opt_sep opt_list END
                   {
-                    if (! ($$ = make_unwind_command ($1, $4, $8, $9, $2, $6)))
+                    if (! ($$ = curr_parser->make_unwind_command ($1, $4, $8, $9, $2, $6)))
                       ABORT_PARSE;
                   }
                 | TRY stash_comment opt_sep opt_list CATCH
                   stash_comment opt_sep opt_list END
                   {
-                    if (! ($$ = make_try_command ($1, $4, $8, $9, $2, $6)))
+                    if (! ($$ = curr_parser->make_try_command ($1, $4, $8, $9, $2, $6)))
                       ABORT_PARSE;
                   }
                 | TRY stash_comment opt_sep opt_list END
                   {
-                    if (! ($$ = make_try_command ($1, $4, 0, $5, $2, 0)))
+                    if (! ($$ = curr_parser->make_try_command ($1, $4, 0, $5, $2, 0)))
                       ABORT_PARSE;
                   }
                 ;
 
 // ===========================================
 // Some 'subroutines' for function definitions
 // ===========================================
 
 push_fcn_symtab : // empty
                   {
-                    current_function_depth++;
-
-                    if (max_function_depth < current_function_depth)
-                      max_function_depth = current_function_depth;
+                    curr_parser->curr_fcn_depth++;
+
+                    if (curr_parser->max_fcn_depth < curr_parser->curr_fcn_depth)
+                      curr_parser->max_fcn_depth = curr_parser->curr_fcn_depth;
 
                     parser_symtab_context.push ();
 
                     symbol_table::set_scope (symbol_table::alloc_scope ());
 
-                    function_scopes.push_back (symbol_table::current_scope ());
-
-                    if (! reading_script_file && current_function_depth == 1
-                        && ! parsing_subfunctions)
-                      primary_fcn_scope = symbol_table::current_scope ();
-
-                    if (reading_script_file && current_function_depth > 1)
-                      yyerror ("nested functions not implemented in this context");
+                    curr_parser->function_scopes.push_back (symbol_table::current_scope ());
+
+                    if (! reading_script_file && curr_parser->curr_fcn_depth == 1
+                        && ! curr_parser->parsing_subfunctions)
+                      curr_parser->primary_fcn_scope = symbol_table::current_scope ();
+
+                    if (reading_script_file && curr_parser->curr_fcn_depth > 1)
+                      curr_parser->bison_error ("nested functions not implemented in this context");
                   }
                 ;
 
 // ===========================
 // List of function parameters
 // ===========================
 
 param_list_beg  : '('
                   {
-                    lexer_flags.looking_at_parameter_list = true;
-
-                    if (lexer_flags.looking_at_function_handle)
+                    curr_lexer->looking_at_parameter_list = true;
+
+                    if (curr_lexer->looking_at_function_handle)
                       {
                         parser_symtab_context.push ();
                         symbol_table::set_scope (symbol_table::alloc_scope ());
-                        lexer_flags.looking_at_function_handle--;
-                        lexer_flags.looking_at_anon_fcn_args = true;
+                        curr_lexer->looking_at_function_handle--;
+                        curr_lexer->looking_at_anon_fcn_args = true;
                       }
                   }
                 ;
 
 param_list_end  : ')'
                   {
-                    lexer_flags.looking_at_parameter_list = false;
-                    lexer_flags.looking_for_object_index = false;
+                    curr_lexer->looking_at_parameter_list = false;
+                    curr_lexer->looking_for_object_index = false;
                   }
                 ;
 
 param_list      : param_list_beg param_list1 param_list_end
                   {
-                    lexer_flags.quote_is_transpose = false;
+                    curr_lexer->quote_is_transpose = false;
                     $$ = $2;
                   }
                 | param_list_beg error
                   {
-                    yyerror ("invalid parameter list");
+                    curr_parser->bison_error ("invalid parameter list");
                     $$ = 0;
                     ABORT_PARSE;
                   }
                 ;
 
 param_list1     : // empty
                   { $$ = 0; }
                 | param_list2
@@ -1385,30 +1122,30 @@ param_list2     : decl2
                 ;
 
 // ===================================
 // List of function return value names
 // ===================================
 
 return_list     : '[' ']'
                   {
-                    lexer_flags.looking_at_return_list = false;
+                    curr_lexer->looking_at_return_list = false;
                     $$ = new tree_parameter_list ();
                   }
                 | return_list1
                   {
-                    lexer_flags.looking_at_return_list = false;
+                    curr_lexer->looking_at_return_list = false;
                     if ($1->validate (tree_parameter_list::out))
                       $$ = $1;
                     else
                       ABORT_PARSE;
                   }
                 | '[' return_list1 ']'
                   {
-                    lexer_flags.looking_at_return_list = false;
+                    curr_lexer->looking_at_return_list = false;
                     if ($2->validate (tree_parameter_list::out))
                       $$ = $2;
                     else
                       ABORT_PARSE;
                   }
                 ;
 
 return_list1    : identifier
@@ -1422,20 +1159,21 @@ return_list1    : identifier
 
 // ===========
 // Script file
 // ===========
 
 script_file     : SCRIPT_FILE opt_list END_OF_INPUT
                   {
                     tree_statement *end_of_script
-                      = make_end ("endscript", input_line_number,
-                                  current_input_column);
-
-                    make_script ($2, end_of_script);
+                      = curr_parser->make_end ("endscript",
+                                               curr_lexer->input_line_number,
+                                               curr_lexer->current_input_column);
+
+                    curr_parser->make_script ($2, end_of_script);
 
                     $$ = 0;
                   }
                 ;
 
 // =============
 // Function file
 // =============
@@ -1451,150 +1189,151 @@ function_list   : function
 // ===================
 // Function definition
 // ===================
 
 function_beg    : push_fcn_symtab FCN stash_comment
                   {
                     $$ = $3;
 
-                    if (reading_classdef_file || lexer_flags.parsing_classdef)
-                      lexer_flags.maybe_classdef_get_set_method = true;
+                    if (reading_classdef_file || curr_lexer->parsing_classdef)
+                      curr_lexer->maybe_classdef_get_set_method = true;
                   }
                 ;
 
 function        : function_beg function1
                   {
-                    $$ = finish_function (0, $2, $1);
-                    recover_from_parsing_function ();
+                    $$ = curr_parser->finish_function (0, $2, $1);
+                    curr_parser->recover_from_parsing_function ();
                   }
                 | function_beg return_list '=' function1
                   {
-                    $$ = finish_function ($2, $4, $1);
-                    recover_from_parsing_function ();
+                    $$ = curr_parser->finish_function ($2, $4, $1);
+                    curr_parser->recover_from_parsing_function ();
                   }
                 ;
 
 fcn_name        : identifier
                   {
                     std::string id_name = $1->name ();
 
-                    lexer_flags.parsed_function_name.top () = true;
-                    lexer_flags.maybe_classdef_get_set_method = false;
+                    curr_lexer->parsed_function_name.top () = true;
+                    curr_lexer->maybe_classdef_get_set_method = false;
 
                     $$ = $1;
                   }
                 | GET '.' identifier
                   {
-                    lexer_flags.parsed_function_name.top () = true;
-                    lexer_flags.maybe_classdef_get_set_method = false;
-                    lexer_flags.parsing_classdef_get_method = true;
+                    curr_lexer->parsed_function_name.top () = true;
+                    curr_lexer->maybe_classdef_get_set_method = false;
+                    curr_lexer->parsing_classdef_get_method = true;
                     $$ = $3;
                   }
                 | SET '.' identifier
                   {
-                    lexer_flags.parsed_function_name.top () = true;
-                    lexer_flags.maybe_classdef_get_set_method = false;
-                    lexer_flags.parsing_classdef_set_method = true;
+                    curr_lexer->parsed_function_name.top () = true;
+                    curr_lexer->maybe_classdef_get_set_method = false;
+                    curr_lexer->parsing_classdef_set_method = true;
                     $$ = $3;
                   }
                 ;
 
 function1       : fcn_name function2
                   {
                     std::string fname = $1->name ();
 
                     delete $1;
 
-                    if (! ($$ = frob_function (fname, $2)))
+                    if (! ($$ = curr_parser->frob_function (fname, $2)))
                       ABORT_PARSE;
                   }
                 ;
 
 function2       : param_list opt_sep opt_list function_end
-                  { $$ = start_function ($1, $3, $4); }
+                  { $$ = curr_parser->start_function ($1, $3, $4); }
                 | opt_sep opt_list function_end
-                  { $$ = start_function (0, $2, $3); }
+                  { $$ = curr_parser->start_function (0, $2, $3); }
                 ;
 
 function_end    : END
                   {
-                    endfunction_found = true;
-                    if (end_token_ok ($1, token::function_end))
-                      $$ = make_end ("endfunction", $1->line (), $1->column ());
+                    curr_parser->endfunction_found = true;
+                    if (curr_parser->end_token_ok ($1, token::function_end))
+                      $$ = curr_parser->make_end ("endfunction", $1->line (), $1->column ());
                     else
                       ABORT_PARSE;
                   }
                 | END_OF_INPUT
                   {
 // A lot of tests are based on the assumption that this is OK
 //                  if (reading_script_file)
 //                    {
-//                      yyerror ("function body open at end of script");
+//                      curr_parser->bison_error ("function body open at end of script");
 //                      YYABORT;
 //                    }
 
-                    if (endfunction_found)
+                    if (curr_parser->endfunction_found)
                       {
-                        yyerror ("inconsistent function endings -- "
+                        curr_parser->bison_error ("inconsistent function endings -- "
                                  "if one function is explicitly ended, "
                                  "so must all the others");
                         YYABORT;
                       }
 
                     if (! (reading_fcn_file || reading_script_file
                            || get_input_from_eval_string))
                       {
-                        yyerror ("function body open at end of input");
+                        curr_parser->bison_error ("function body open at end of input");
                         YYABORT;
                       }
 
                     if (reading_classdef_file)
                       {
-                        yyerror ("classdef body open at end of input");
+                        curr_parser->bison_error ("classdef body open at end of input");
                         YYABORT;
                       }
 
-                    $$ = make_end ("endfunction", input_line_number,
-                                   current_input_column);
+                    $$ = curr_parser->make_end ("endfunction",
+                                                curr_lexer->input_line_number,
+                                                curr_lexer->current_input_column);
                   }
                 ;
 
 // =============
 // Classdef file
 // =============
 
 classdef_file   : CLASSDEF_FILE classdef opt_sep END_OF_INPUT
                   {
-                    classdef_object = $2;
+                    curr_parser->classdef_object = $2;
                     $$ = 0;
                   }
                 ;
 
 // ========
 // Classdef
 // ========
 
 classdef_beg    : CLASSDEF
                   {
                     if (! reading_classdef_file)
                       {
-                        yyerror ("classdef must appear inside a file containing only a class definition");
+                        curr_parser->bison_error ("classdef must appear inside a file containing only a class definition");
                         YYABORT;
                       }
 
-                    lexer_flags.parsing_classdef = true;
+                    curr_lexer->parsing_classdef = true;
                     $$ = $1;
                   }
                 ;
 
 classdef        : classdef_beg stash_comment opt_attr_list identifier opt_superclass_list opt_sep class_body opt_sep END
                   {
-                    lexer_flags.parsing_classdef = false;
-                    if (! ($$ = make_classdef ($1, $3, $4, $5, $7, $9, $2)))
+                    curr_lexer->parsing_classdef = false;
+                    if (! ($$ = curr_parser->make_classdef ($1, $3, $4, $5, $7, $9, $2)))
                       ABORT_PARSE;
                   }
                 ;
 
 opt_attr_list   : // empty
                   { $$ = 0; }
                 | '(' attr_list ')'
                   { $$ = $2; }
@@ -1608,17 +1347,17 @@ attr_list       : attr
                     $$ = $1;
                   }
                 ;
 
 attr            : identifier
                   { $$ = new tree_classdef_attribute ($1); }
                 | identifier '=' decl_param_init expression
                   {
-                    lexer_flags.looking_at_initializer_expression = false;
+                    curr_lexer->looking_at_initializer_expression = false;
                     $$ = new tree_classdef_attribute ($1, $4);
                   }
                 | EXPR_NOT identifier
                   { $$ = new tree_classdef_attribute ($2, false); }
                 ;
 
 opt_superclass_list
                 : // empty
@@ -1670,17 +1409,18 @@ class_body      : properties_block
                     $1->append ($3);
                     $$ = $1;
                   }
                 ;
 
 properties_block
                 : PROPERTIES stash_comment opt_attr_list opt_sep property_list opt_sep END
                   {
-                    if (! ($$ = make_classdef_properties_block ($1, $3, $5, $7, $2)))
+                    if (! ($$ = curr_parser->make_classdef_properties_block
+                                               ($1, $3, $5, $7, $2)))
                       ABORT_PARSE;
                   }
                 ;
 
 property_list
                 : class_property
                   { $$ = new tree_classdef_property_list ($1); }
                 | property_list opt_sep class_property
@@ -1689,24 +1429,25 @@ property_list
                     $$ = $1;
                   }
                 ;
 
 class_property  : identifier
                   { $$ = new tree_classdef_property ($1); }
                 | identifier '=' decl_param_init expression ';'
                   {
-                    lexer_flags.looking_at_initializer_expression = false;
+                    curr_lexer->looking_at_initializer_expression = false;
                     $$ = new tree_classdef_property ($1, $4);
                   }
                 ;
 
 methods_block   : METHODS stash_comment opt_attr_list opt_sep methods_list opt_sep END
                   {
-                    if (! ($$ = make_classdef_methods_block ($1, $3, $5, $7, $2)))
+                    if (! ($$ = curr_parser->make_classdef_methods_block
+                                               ($1, $3, $5, $7, $2)))
                       ABORT_PARSE;
                   }
                 ;
 
 methods_list    : function
                   {
                     octave_value fcn;
                     if ($1)
@@ -1723,17 +1464,18 @@ methods_list    : function
 
                     $1->append (fcn);
                     $$ = $1;
                   }
                 ;
 
 events_block    : EVENTS stash_comment opt_attr_list opt_sep events_list opt_sep END
                   {
-                    if (! ($$ = make_classdef_events_block ($1, $3, $5, $7, $2)))
+                    if (! ($$ = curr_parser->make_classdef_events_block
+                                               ($1, $3, $5, $7, $2)))
                       ABORT_PARSE;
                   }
                 ;
 
 events_list     : class_event
                   { $$ = new tree_classdef_events_list ($1); }
                 | events_list opt_sep class_event
                   {
@@ -1743,17 +1485,18 @@ events_list     : class_event
                 ;
 
 class_event     : identifier
                   { $$ = new tree_classdef_event ($1); }
                 ;
 
 enum_block      : ENUMERATION stash_comment opt_attr_list opt_sep enum_list opt_sep END
                   {
-                    if (! ($$ = make_classdef_enum_block ($1, $3, $5, $7, $2)))
+                    if (! ($$ = curr_parser->make_classdef_enum_block
+                                               ($1, $3, $5, $7, $2)))
                       ABORT_PARSE;
                   }
                 ;
 
 enum_list       : class_enum
                   { $$ = new tree_classdef_enum_list ($1); }
                 | enum_list opt_sep class_enum
                   {
@@ -1770,17 +1513,17 @@ class_enum      : identifier '(' express
 // Miscellaneous
 // =============
 
 stash_comment   : // empty
                   { $$ = octave_comment_buffer::get_comment (); }
                 ;
 
 parse_error     : LEXICAL_ERROR
-                  { yyerror ("parse error"); }
+                  { curr_parser->bison_error ("parse error"); }
                 | error
                 ;
 
 sep_no_nl       : ','
                   { $$ = ','; }
                 | ';'
                   { $$ = ';'; }
                 | sep_no_nl ','
@@ -1820,65 +1563,35 @@ opt_comma       : // empty
                 | ','
                   { $$ = ','; }
                 ;
 
 %%
 
 // Generic error messages.
 
+#undef curr_lexer
+
 static void
-yyerror (const char *s)
+yyerror (octave_parser *curr_parser, const char *s)
 {
-  int err_col = current_input_column - 1;
-
-  std::ostringstream output_buf;
-
-  if (reading_fcn_file || reading_script_file || reading_classdef_file)
-    output_buf << "parse error near line " << input_line_number
-               << " of file " << curr_fcn_file_full_name;
-  else
-    output_buf << "parse error:";
-
-  if (s && strcmp (s, "parse error") != 0)
-    output_buf << "\n\n  " << s;
-
-  output_buf << "\n\n";
-
-  if (! current_input_line.empty ())
-    {
-      size_t len = current_input_line.length ();
-
-      if (current_input_line[len-1] == '\n')
-        current_input_line.resize (len-1);
-
-      // Print the line, maybe with a pointer near the error token.
-
-      output_buf << ">>> " << current_input_line << "\n";
-
-      if (err_col == 0)
-        err_col = len;
-
-      for (int i = 0; i < err_col + 3; i++)
-        output_buf << " ";
-
-      output_buf << "^";
-    }
-
-  output_buf << "\n";
-
-  std::string msg = output_buf.str ();
-
-  parse_error ("%s", msg.c_str ());
+  curr_parser->bison_error (s);
+}
+
+int
+octave_parser::run (void)
+{
+  return octave_parse (this);
 }
 
 // Error mesages for mismatched end tokens.
 
-static void
-end_error (const char *type, token::end_tok_type ettype, int l, int c)
+void
+octave_parser::end_error (const char *type, token::end_tok_type ettype,
+                          int l, int c)
 {
   static const char *fmt
     = "'%s' command matched by '%s' near line %d column %d";
 
   switch (ettype)
     {
     case token::simple_end:
       error (fmt, type, "end", l, c);
@@ -1919,28 +1632,28 @@ end_error (const char *type, token::end_
     default:
       panic_impossible ();
       break;
     }
 }
 
 // Check to see that end tokens are properly matched.
 
-static bool
-end_token_ok (token *tok, token::end_tok_type expected)
+bool
+octave_parser::end_token_ok (token *tok, token::end_tok_type expected)
 {
   bool retval = true;
 
   token::end_tok_type ettype = tok->ettype ();
 
   if (ettype != expected && ettype != token::simple_end)
     {
       retval = false;
 
-      yyerror ("parse error");
+      bison_error ("parse error");
 
       int l = tok->line ();
       int c = tok->column ();
 
       switch (expected)
         {
         case token::classdef_end:
           end_error ("classdef", ettype, l, c);
@@ -1989,18 +1702,18 @@ end_token_ok (token *tok, token::end_tok
     }
 
   return retval;
 }
 
 // Maybe print a warning if an assignment expression is used as the
 // test in a logical expression.
 
-static void
-maybe_warn_assign_as_truth_value (tree_expression *expr)
+void
+octave_parser::maybe_warn_assign_as_truth_value (tree_expression *expr)
 {
   if (expr->is_assignment_expression ()
       && expr->paren_count () < 2)
     {
       if (curr_fcn_file_full_name.empty ())
         warning_with_id
           ("Octave:assign-as-truth-value",
            "suggest parenthesis around assignment used as truth value");
@@ -2009,18 +1722,18 @@ maybe_warn_assign_as_truth_value (tree_e
           ("Octave:assign-as-truth-value",
            "suggest parenthesis around assignment used as truth value near line %d, column %d in file '%s'",
            expr->line (), expr->column (), curr_fcn_file_full_name.c_str ());
     }
 }
 
 // Maybe print a warning about switch labels that aren't constants.
 
-static void
-maybe_warn_variable_switch_label (tree_expression *expr)
+void
+octave_parser::maybe_warn_variable_switch_label (tree_expression *expr)
 {
   if (! expr->is_constant ())
     {
       if (curr_fcn_file_full_name.empty ())
         warning_with_id ("Octave:variable-switch-label",
                          "variable switch label");
       else
         warning_with_id
@@ -2116,18 +1829,18 @@ fold (tree_unary_expression *e)
         }
     }
 
   return retval;
 }
 
 // Finish building a range.
 
-static tree_expression *
-finish_colon_expression (tree_colon_expression *e)
+tree_expression *
+octave_parser::finish_colon_expression (tree_colon_expression *e)
 {
   tree_expression *retval = e;
 
   unwind_protect frame;
 
   frame.protect_var (error_state);
   frame.protect_var (warning_state);
 
@@ -2180,18 +1893,18 @@ finish_colon_expression (tree_colon_expr
         }
     }
 
   return retval;
 }
 
 // Make a constant.
 
-static tree_constant *
-make_constant (int op, token *tok_val)
+tree_constant *
+octave_parser::make_constant (int op, token *tok_val)
 {
   int l = tok_val->line ();
   int c = tok_val->column ();
 
   tree_constant *retval = 0;
 
   switch (op)
     {
@@ -2243,35 +1956,36 @@ make_constant (int op, token *tok_val)
       break;
     }
 
   return retval;
 }
 
 // Make a function handle.
 
-static tree_fcn_handle *
-make_fcn_handle (token *tok_val)
+tree_fcn_handle *
+octave_parser::make_fcn_handle (token *tok_val)
 {
   int l = tok_val->line ();
   int c = tok_val->column ();
 
   tree_fcn_handle *retval = new tree_fcn_handle (tok_val->text (), l, c);
 
   return retval;
 }
 
 // Make an anonymous function handle.
 
-static tree_anon_fcn_handle *
-make_anon_fcn_handle (tree_parameter_list *param_list, tree_statement *stmt)
+tree_anon_fcn_handle *
+octave_parser::make_anon_fcn_handle (tree_parameter_list *param_list,
+                                     tree_statement *stmt)
 {
   // FIXME -- need to get these from the location of the @ symbol.
-  int l = input_line_number;
-  int c = current_input_column;
+  int l = curr_lexer->input_line_number;
+  int c = curr_lexer->current_input_column;
 
   tree_parameter_list *ret_list = 0;
 
   symbol_table::scope_id fcn_scope = symbol_table::current_scope ();
 
   if (parser_symtab_context.empty ())
     panic_impossible ();
 
@@ -2289,19 +2003,19 @@ make_anon_fcn_handle (tree_parameter_lis
   // errors when executed.
   //retval->stash_file_name (curr_fcn_file_name);
 
   return retval;
 }
 
 // Build a binary expression.
 
-static tree_expression *
-make_binary_op (int op, tree_expression *op1, token *tok_val,
-                tree_expression *op2)
+tree_expression *
+octave_parser::make_binary_op (int op, tree_expression *op1, token *tok_val,
+                               tree_expression *op2)
 {
   octave_value::binary_op t = octave_value::unknown_binary_op;
 
   switch (op)
     {
     case POW:
       t = octave_value::op_pow;
       break;
@@ -2393,19 +2107,19 @@ make_binary_op (int op, tree_expression 
   tree_binary_expression *e
     = maybe_compound_binary_expression (op1, op2, l, c, t);
 
   return fold (e);
 }
 
 // Build a boolean expression.
 
-static tree_expression *
-make_boolean_op (int op, tree_expression *op1, token *tok_val,
-                 tree_expression *op2)
+tree_expression *
+octave_parser::make_boolean_op (int op, tree_expression *op1, token *tok_val,
+                                tree_expression *op2)
 {
   tree_boolean_expression::type t;
 
   switch (op)
     {
     case EXPR_AND_AND:
       t = tree_boolean_expression::bool_and;
       break;
@@ -2425,18 +2139,18 @@ make_boolean_op (int op, tree_expression
   tree_boolean_expression *e
     = new tree_boolean_expression (op1, op2, l, c, t);
 
   return fold (e);
 }
 
 // Build a prefix expression.
 
-static tree_expression *
-make_prefix_op (int op, tree_expression *op1, token *tok_val)
+tree_expression *
+octave_parser::make_prefix_op (int op, tree_expression *op1, token *tok_val)
 {
   octave_value::unary_op t = octave_value::unknown_unary_op;
 
   switch (op)
     {
     case EXPR_NOT:
       t = octave_value::op_not;
       break;
@@ -2468,18 +2182,18 @@ make_prefix_op (int op, tree_expression 
   tree_prefix_expression *e
     = new tree_prefix_expression (op1, l, c, t);
 
   return fold (e);
 }
 
 // Build a postfix expression.
 
-static tree_expression *
-make_postfix_op (int op, tree_expression *op1, token *tok_val)
+tree_expression *
+octave_parser::make_postfix_op (int op, tree_expression *op1, token *tok_val)
 {
   octave_value::unary_op t = octave_value::unknown_unary_op;
 
   switch (op)
     {
     case QUOTE:
       t = octave_value::op_hermitian;
       break;
@@ -2507,213 +2221,223 @@ make_postfix_op (int op, tree_expression
   tree_postfix_expression *e
     = new tree_postfix_expression (op1, l, c, t);
 
   return fold (e);
 }
 
 // Build an unwind-protect command.
 
-static tree_command *
-make_unwind_command (token *unwind_tok, tree_statement_list *body,
-                     tree_statement_list *cleanup, token *end_tok,
-                     octave_comment_list *lc, octave_comment_list *mc)
+tree_command *
+octave_parser::make_unwind_command (token *unwind_tok,
+                                    tree_statement_list *body,
+                                    tree_statement_list *cleanup_stmts,
+                                    token *end_tok,
+                                    octave_comment_list *lc,
+                                    octave_comment_list *mc)
 {
   tree_command *retval = 0;
 
   if (end_token_ok (end_tok, token::unwind_protect_end))
     {
       octave_comment_list *tc = octave_comment_buffer::get_comment ();
 
       int l = unwind_tok->line ();
       int c = unwind_tok->column ();
 
-      retval = new tree_unwind_protect_command (body, cleanup,
+      retval = new tree_unwind_protect_command (body, cleanup_stmts,
                                                 lc, mc, tc, l, c);
     }
 
   return retval;
 }
 
 // Build a try-catch command.
 
-static tree_command *
-make_try_command (token *try_tok, tree_statement_list *body,
-                  tree_statement_list *cleanup, token *end_tok,
-                  octave_comment_list *lc, octave_comment_list *mc)
+tree_command *
+octave_parser::make_try_command (token *try_tok, tree_statement_list *body,
+                                 tree_statement_list *cleanup_stmts,
+                                 token *end_tok,
+                                 octave_comment_list *lc,
+                                 octave_comment_list *mc)
 {
   tree_command *retval = 0;
 
   if (end_token_ok (end_tok, token::try_catch_end))
     {
       octave_comment_list *tc = octave_comment_buffer::get_comment ();
 
       int l = try_tok->line ();
       int c = try_tok->column ();
 
-      retval = new tree_try_catch_command (body, cleanup,
+      retval = new tree_try_catch_command (body, cleanup_stmts,
                                            lc, mc, tc, l, c);
     }
 
   return retval;
 }
 
 // Build a while command.
 
-static tree_command *
-make_while_command (token *while_tok, tree_expression *expr,
-                    tree_statement_list *body, token *end_tok,
-                    octave_comment_list *lc)
+tree_command *
+octave_parser::make_while_command (token *while_tok, tree_expression *expr,
+                                   tree_statement_list *body, token *end_tok,
+                                   octave_comment_list *lc)
 {
   tree_command *retval = 0;
 
   maybe_warn_assign_as_truth_value (expr);
 
   if (end_token_ok (end_tok, token::while_end))
     {
       octave_comment_list *tc = octave_comment_buffer::get_comment ();
 
-      lexer_flags.looping--;
+      curr_lexer->looping--;
 
       int l = while_tok->line ();
       int c = while_tok->column ();
 
       retval = new tree_while_command (expr, body, lc, tc, l, c);
     }
 
   return retval;
 }
 
 // Build a do-until command.
 
-static tree_command *
-make_do_until_command (token *until_tok, tree_statement_list *body,
-                       tree_expression *expr, octave_comment_list *lc)
+tree_command *
+octave_parser::make_do_until_command (token *until_tok,
+                                      tree_statement_list *body,
+                                      tree_expression *expr,
+                                      octave_comment_list *lc)
 {
   tree_command *retval = 0;
 
   maybe_warn_assign_as_truth_value (expr);
 
   octave_comment_list *tc = octave_comment_buffer::get_comment ();
 
-  lexer_flags.looping--;
+  curr_lexer->looping--;
 
   int l = until_tok->line ();
   int c = until_tok->column ();
 
   retval = new tree_do_until_command (expr, body, lc, tc, l, c);
 
   return retval;
 }
 
 // Build a for command.
 
-static tree_command *
-make_for_command (int tok_id, token *for_tok, tree_argument_list *lhs,
-                  tree_expression *expr, tree_expression *maxproc,
-                  tree_statement_list *body, token *end_tok,
-                  octave_comment_list *lc)
+tree_command *
+octave_parser::make_for_command (int tok_id, token *for_tok,
+                                 tree_argument_list *lhs,
+                                 tree_expression *expr,
+                                 tree_expression *maxproc,
+                                 tree_statement_list *body, token *end_tok,
+                                 octave_comment_list *lc)
 {
   tree_command *retval = 0;
 
   bool parfor = tok_id == PARFOR;
 
   if (end_token_ok (end_tok, parfor ? token::parfor_end : token::for_end))
     {
       octave_comment_list *tc = octave_comment_buffer::get_comment ();
 
-      lexer_flags.looping--;
+      curr_lexer->looping--;
 
       int l = for_tok->line ();
       int c = for_tok->column ();
 
       if (lhs->length () == 1)
         {
           tree_expression *tmp = lhs->remove_front ();
 
           retval = new tree_simple_for_command (parfor, tmp, expr, maxproc,
                                                 body, lc, tc, l, c);
 
           delete lhs;
         }
       else
         {
           if (parfor)
-            yyerror ("invalid syntax for parfor statement");
+            bison_error ("invalid syntax for parfor statement");
           else
             retval = new tree_complex_for_command (lhs, expr, body,
                                                    lc, tc, l, c);
         }
     }
 
   return retval;
 }
 
 // Build a break command.
 
-static tree_command *
-make_break_command (token *break_tok)
+tree_command *
+octave_parser::make_break_command (token *break_tok)
 {
   tree_command *retval = 0;
 
   int l = break_tok->line ();
   int c = break_tok->column ();
 
   retval = new tree_break_command (l, c);
 
   return retval;
 }
 
 // Build a continue command.
 
-static tree_command *
-make_continue_command (token *continue_tok)
+tree_command *
+octave_parser::make_continue_command (token *continue_tok)
 {
   tree_command *retval = 0;
 
   int l = continue_tok->line ();
   int c = continue_tok->column ();
 
   retval = new tree_continue_command (l, c);
 
   return retval;
 }
 
 // Build a return command.
 
-static tree_command *
-make_return_command (token *return_tok)
+tree_command *
+octave_parser::make_return_command (token *return_tok)
 {
   tree_command *retval = 0;
 
   int l = return_tok->line ();
   int c = return_tok->column ();
 
   retval = new tree_return_command (l, c);
 
   return retval;
 }
 
 // Start an if command.
 
-static tree_if_command_list *
-start_if_command (tree_expression *expr, tree_statement_list *list)
+tree_if_command_list *
+octave_parser::start_if_command (tree_expression *expr,
+                                 tree_statement_list *list)
 {
   maybe_warn_assign_as_truth_value (expr);
 
   tree_if_clause *t = new tree_if_clause (expr, list);
 
   return new tree_if_command_list (t);
 }
 
 // Finish an if command.
 
-static tree_if_command *
-finish_if_command (token *if_tok, tree_if_command_list *list,
-                   token *end_tok, octave_comment_list *lc)
+tree_if_command *
+octave_parser::finish_if_command (token *if_tok, tree_if_command_list *list,
+                                  token *end_tok, octave_comment_list *lc)
 {
   tree_if_command *retval = 0;
 
   if (end_token_ok (end_tok, token::if_end))
     {
       octave_comment_list *tc = octave_comment_buffer::get_comment ();
 
       int l = if_tok->line ();
@@ -2733,34 +2457,35 @@ finish_if_command (token *if_tok, tree_i
       retval = new tree_if_command (list, lc, tc, l, c);
     }
 
   return retval;
 }
 
 // Build an elseif clause.
 
-static tree_if_clause *
-make_elseif_clause (token *elseif_tok, tree_expression *expr,
-                    tree_statement_list *list, octave_comment_list *lc)
+tree_if_clause *
+octave_parser::make_elseif_clause (token *elseif_tok, tree_expression *expr,
+                                   tree_statement_list *list,
+                                   octave_comment_list *lc)
 {
   maybe_warn_assign_as_truth_value (expr);
 
   int l = elseif_tok->line ();
   int c = elseif_tok->column ();
 
   return new tree_if_clause (expr, list, lc, l, c);
 }
 
 // Finish a switch command.
 
-static tree_switch_command *
-finish_switch_command (token *switch_tok, tree_expression *expr,
-                       tree_switch_case_list *list, token *end_tok,
-                       octave_comment_list *lc)
+tree_switch_command *
+octave_parser::finish_switch_command (token *switch_tok, tree_expression *expr,
+                                      tree_switch_case_list *list,
+                                      token *end_tok, octave_comment_list *lc)
 {
   tree_switch_command *retval = 0;
 
   if (end_token_ok (end_tok, token::switch_end))
     {
       octave_comment_list *tc = octave_comment_buffer::get_comment ();
 
       int l = switch_tok->line ();
@@ -2780,33 +2505,34 @@ finish_switch_command (token *switch_tok
       retval = new tree_switch_command (expr, list, lc, tc, l, c);
     }
 
   return retval;
 }
 
 // Build a switch case.
 
-static tree_switch_case *
-make_switch_case (token *case_tok, tree_expression *expr,
-                  tree_statement_list *list, octave_comment_list *lc)
+tree_switch_case *
+octave_parser::make_switch_case (token *case_tok, tree_expression *expr,
+                                 tree_statement_list *list,
+                                 octave_comment_list *lc)
 {
   maybe_warn_variable_switch_label (expr);
 
   int l = case_tok->line ();
   int c = case_tok->column ();
 
   return new tree_switch_case (expr, list, lc, l, c);
 }
 
 // Build an assignment to a variable.
 
-static tree_expression *
-make_assign_op (int op, tree_argument_list *lhs, token *eq_tok,
-                tree_expression *rhs)
+tree_expression *
+octave_parser::make_assign_op (int op, tree_argument_list *lhs, token *eq_tok,
+                               tree_expression *rhs)
 {
   tree_expression *retval = 0;
 
   octave_value::assign_op t = octave_value::unknown_assign_op;
 
   switch (op)
     {
     case '=':
@@ -2883,25 +2609,26 @@ make_assign_op (int op, tree_argument_li
 
       retval = new tree_simple_assignment (tmp, rhs, false, l, c, t);
 
       delete lhs;
     }
   else if (t == octave_value::op_asn_eq)
     return new tree_multi_assignment (lhs, rhs, false, l, c);
   else
-    yyerror ("computed multiple assignment not allowed");
+    bison_error ("computed multiple assignment not allowed");
 
   return retval;
 }
 
 // Define a script.
 
-static void
-make_script (tree_statement_list *cmds, tree_statement *end_script)
+void
+octave_parser::make_script (tree_statement_list *cmds,
+                            tree_statement *end_script)
 {
   std::string doc_string;
 
   if (! help_buf.empty ())
     {
       doc_string = help_buf.top ();
       help_buf.pop ();
     }
@@ -2924,19 +2651,20 @@ make_script (tree_statement_list *cmds, 
   // Unmark any symbols that may have been tagged as local variables
   // while parsing (for example, by force_local_variable in lex.l).
 
   symbol_table::unmark_forced_variables ();
 }
 
 // Begin defining a function.
 
-static octave_user_function *
-start_function (tree_parameter_list *param_list, tree_statement_list *body,
-                tree_statement *end_fcn_stmt)
+octave_user_function *
+octave_parser::start_function (tree_parameter_list *param_list,
+                               tree_statement_list *body,
+                               tree_statement *end_fcn_stmt)
 {
   // We'll fill in the return list later.
 
   if (! body)
     body = new tree_statement_list ();
 
   body->append (end_fcn_stmt);
 
@@ -2949,35 +2677,36 @@ start_function (tree_parameter_list *par
       octave_comment_list *tc = octave_comment_buffer::get_comment ();
 
       fcn->stash_trailing_comment (tc);
     }
 
   return fcn;
 }
 
-static tree_statement *
-make_end (const std::string& type, int l, int c)
+tree_statement *
+octave_parser::make_end (const std::string& type, int l, int c)
 {
   return make_statement (new tree_no_op_command (type, l, c));
 }
 
 // Do most of the work for defining a function.
 
-static octave_user_function *
-frob_function (const std::string& fname, octave_user_function *fcn)
+octave_user_function *
+octave_parser::frob_function (const std::string& fname,
+                              octave_user_function *fcn)
 {
   std::string id_name = fname;
 
   // If input is coming from a file, issue a warning if the name of
   // the file does not match the name of the function stated in the
   // file.  Matlab doesn't provide a diagnostic (it ignores the stated
   // name).
   if (! autoloading && reading_fcn_file
-      && current_function_depth == 1 && ! parsing_subfunctions)
+      && curr_fcn_depth == 1 && ! parsing_subfunctions)
   {
     // FIXME -- should curr_fcn_file_name already be
     // preprocessed when we get here?  It seems to only be a
     // problem with relative file names.
 
     std::string nm = curr_fcn_file_name;
 
     size_t pos = nm.find_last_of (file_ops::dir_sep_chars ());
@@ -3002,34 +2731,34 @@ frob_function (const std::string& fname,
 
       fcn->stash_fcn_file_name (curr_fcn_file_full_name);
       fcn->stash_fcn_file_time (now);
       fcn->mark_as_system_fcn_file ();
 
       if (fcn_file_from_relative_lookup)
         fcn->mark_relative ();
 
-      if (current_function_depth > 1 || parsing_subfunctions)
+      if (curr_fcn_depth > 1 || parsing_subfunctions)
         {
           fcn->stash_parent_fcn_name (curr_fcn_file_name);
 
-          if (current_function_depth > 1)
+          if (curr_fcn_depth > 1)
             fcn->stash_parent_fcn_scope (function_scopes[function_scopes.size ()-2]);
           else
             fcn->stash_parent_fcn_scope (primary_fcn_scope);
         }
 
-      if (lexer_flags.parsing_class_method)
+      if (curr_lexer->parsing_class_method)
         {
-          if (current_class_name == id_name)
+          if (curr_class_name == id_name)
             fcn->mark_as_class_constructor ();
           else
             fcn->mark_as_class_method ();
 
-          fcn->stash_dispatch_class (current_class_name);
+          fcn->stash_dispatch_class (curr_class_name);
         }
 
       std::string nm = fcn->fcn_file_name ();
 
       file_stat fs (nm);
 
       if (fs && fs.is_newer (now))
         warning_with_id ("Octave:future-time-stamp",
@@ -3039,36 +2768,38 @@ frob_function (const std::string& fname,
            && reading_script_file
            && curr_fcn_file_name == id_name)
     {
       warning ("function '%s' defined within script file '%s'",
                id_name.c_str (), curr_fcn_file_full_name.c_str ());
     }
 
   fcn->stash_function_name (id_name);
-  fcn->stash_fcn_location (input_line_number, current_input_column);
-
-  if (! help_buf.empty () && current_function_depth == 1
+  fcn->stash_fcn_location (curr_lexer->input_line_number,
+                           curr_lexer->current_input_column);
+
+  if (! help_buf.empty () && curr_fcn_depth == 1
       && ! parsing_subfunctions)
     {
       fcn->document (help_buf.top ());
 
       help_buf.pop ();
     }
 
-  if (reading_fcn_file && current_function_depth == 1
+  if (reading_fcn_file && curr_fcn_depth == 1
       && ! parsing_subfunctions)
     primary_fcn_ptr = fcn;
 
   return fcn;
 }
 
-static tree_function_def *
-finish_function (tree_parameter_list *ret_list,
-                 octave_user_function *fcn, octave_comment_list *lc)
+tree_function_def *
+octave_parser::finish_function (tree_parameter_list *ret_list,
+                                octave_user_function *fcn,
+                                octave_comment_list *lc)
 {
   tree_function_def *retval = 0;
 
   if (ret_list)
     ret_list->mark_as_formal_parameters ();
 
   if (fcn)
     {
@@ -3081,37 +2812,37 @@ finish_function (tree_parameter_list *re
 
       symbol_table::cache_name (fcn->scope (), tmp);
 
       if (lc)
         fcn->stash_leading_comment (lc);
 
       fcn->define_ret_list (ret_list);
 
-      if (current_function_depth > 1 || parsing_subfunctions)
+      if (curr_fcn_depth > 1 || parsing_subfunctions)
         {
           fcn->mark_as_subfunction ();
 
           if (endfunction_found && function_scopes.size () > 1)
             {
               symbol_table::scope_id pscope
                 = function_scopes[function_scopes.size ()-2];
 
               symbol_table::install_nestfunction (nm, octave_value (fcn),
                                                   pscope);
             }
           else
             symbol_table::install_subfunction (nm, octave_value (fcn),
                                                primary_fcn_scope);
         }
 
-      if (current_function_depth == 1 && fcn)
+      if (curr_fcn_depth == 1 && fcn)
         symbol_table::update_nest (fcn->scope ());
 
-      if (! reading_fcn_file && current_function_depth == 1)
+      if (! reading_fcn_file && curr_fcn_depth == 1)
         {
           // We are either reading a script file or defining a function
           // at the command line, so this definition creates a
           // tree_function object that is placed in the parse tree.
           // Otherwise, it is just inserted in the symbol table,
           // either as a subfunction or nested function (see above),
           // or as the primary function for the file, via
           // primary_fcn_ptr (see also load_fcn_from_file,,
@@ -3126,48 +2857,214 @@ finish_function (tree_parameter_list *re
       // in lex.l).
 
       symbol_table::unmark_forced_variables (fcn->scope ());
     }
 
   return retval;
 }
 
-static void
-recover_from_parsing_function (void)
+void
+octave_parser::recover_from_parsing_function (void)
 {
   if (parser_symtab_context.empty ())
     panic_impossible ();
 
   parser_symtab_context.pop ();
 
-  if (reading_fcn_file && current_function_depth == 1
+  if (reading_fcn_file && curr_fcn_depth == 1
       && ! parsing_subfunctions)
     parsing_subfunctions = true;
 
-  current_function_depth--;
+  curr_fcn_depth--;
   function_scopes.pop_back ();
 
-  lexer_flags.defining_func--;
-  lexer_flags.parsed_function_name.pop ();
-  lexer_flags.looking_at_return_list = false;
-  lexer_flags.looking_at_parameter_list = false;
+  curr_lexer->defining_func--;
+  curr_lexer->parsed_function_name.pop ();
+  curr_lexer->looking_at_return_list = false;
+  curr_lexer->looking_at_parameter_list = false;
+}
+
+tree_funcall *
+octave_parser::make_superclass_ref (const std::string& method_nm,
+                                    const std::string& package_nm,
+                                    const std::string& class_nm,
+                                    int l, int c)
+{
+  octave_value_list args;
+
+  args(2) = class_nm;
+  args(1) = package_nm;
+  args(0) = method_nm;
+
+  octave_value fcn
+    = symbol_table::find_built_in_function ("__superclass_reference__");
+
+  return new tree_funcall (fcn, args);
+}
+
+tree_funcall *
+octave_parser::make_meta_class_query (const std::string& package_nm,
+                                      const std::string& class_nm,
+                                      int l, int c)
+{
+  octave_value_list args;
+
+  args(1) = class_nm;
+  args(0) = package_nm;
+
+  octave_value fcn
+    = symbol_table::find_built_in_function ("__meta_class_query__");
+
+  return new tree_funcall (fcn, args);
+}
+
+// A CLASSDEF block defines a class that has a constructor and other
+// methods, but it is not an executable command.  Parsing the block
+// makes some changes in the symbol table (inserting the constructor
+// and methods, and adding to the list of known objects) and creates
+// a parse tree containing meta information about the class.
+
+tree_classdef *
+octave_parser::make_classdef (token *tok_val,
+                              tree_classdef_attribute_list *a,
+                              tree_identifier *id,
+                              tree_classdef_superclass_list *sc,
+                              tree_classdef_body *body, token *end_tok,
+                              octave_comment_list *lc)
+{
+  tree_classdef *retval = 0;
+
+  std::string cls_name = id->name ();
+
+  std::string nm = curr_fcn_file_name;
+
+  size_t pos = nm.find_last_of (file_ops::dir_sep_chars ());
+
+  if (pos != std::string::npos)
+    nm = curr_fcn_file_name.substr (pos+1);
+
+  if (nm != cls_name)
+    {
+      bison_error ("invalid classdef definition, the class name must match the file name");
+      return retval;
+    }
+
+  if (end_token_ok (end_tok, token::classdef_end))
+    {
+      octave_comment_list *tc = octave_comment_buffer::get_comment ();
+
+      int l = tok_val->line ();
+      int c = tok_val->column ();
+
+      retval = new tree_classdef (a, id, sc, body, lc, tc, l, c);
+    }
+
+  return retval;
+}
+
+tree_classdef_properties_block *
+octave_parser::make_classdef_properties_block (token *tok_val,
+                                               tree_classdef_attribute_list *a,
+                                               tree_classdef_property_list *plist,
+                                               token *end_tok,
+                                               octave_comment_list *lc)
+{
+  tree_classdef_properties_block *retval = 0;
+
+  if (end_token_ok (end_tok, token::properties_end))
+    {
+      octave_comment_list *tc = octave_comment_buffer::get_comment ();
+
+      int l = tok_val->line ();
+      int c = tok_val->column ();
+
+      retval = new tree_classdef_properties_block (a, plist, lc, tc, l, c);
+    }
+
+  return retval;
+}
+
+tree_classdef_methods_block *
+octave_parser::make_classdef_methods_block (token *tok_val,
+                                            tree_classdef_attribute_list *a,
+                                            tree_classdef_methods_list *mlist,
+                                            token *end_tok,
+                                            octave_comment_list *lc)
+{
+  tree_classdef_methods_block *retval = 0;
+
+  if (end_token_ok (end_tok, token::methods_end))
+    {
+      octave_comment_list *tc = octave_comment_buffer::get_comment ();
+
+      int l = tok_val->line ();
+      int c = tok_val->column ();
+
+      retval = new tree_classdef_methods_block (a, mlist, lc, tc, l, c);
+    }
+
+  return retval;
+}
+
+tree_classdef_events_block *
+octave_parser::make_classdef_events_block (token *tok_val,
+                                           tree_classdef_attribute_list *a,
+                                           tree_classdef_events_list *elist,
+                                           token *end_tok,
+                                           octave_comment_list *lc)
+{
+  tree_classdef_events_block *retval = 0;
+
+  if (end_token_ok (end_tok, token::events_end))
+    {
+      octave_comment_list *tc = octave_comment_buffer::get_comment ();
+
+      int l = tok_val->line ();
+      int c = tok_val->column ();
+
+      retval = new tree_classdef_events_block (a, elist, lc, tc, l, c);
+    }
+
+  return retval;
+}
+
+tree_classdef_enum_block *
+octave_parser::make_classdef_enum_block (token *tok_val,
+                                         tree_classdef_attribute_list *a,
+                                         tree_classdef_enum_list *elist,
+                                         token *end_tok,
+                                         octave_comment_list *lc)
+{
+  tree_classdef_enum_block *retval = 0;
+
+  if (end_token_ok (end_tok, token::enumeration_end))
+    {
+      octave_comment_list *tc = octave_comment_buffer::get_comment ();
+
+      int l = tok_val->line ();
+      int c = tok_val->column ();
+
+      retval = new tree_classdef_enum_block (a, elist, lc, tc, l, c);
+    }
+
+  return retval;
 }
 
 // Make an index expression.
 
-static tree_index_expression *
-make_index_expression (tree_expression *expr, tree_argument_list *args,
-                       char type)
+tree_index_expression *
+octave_parser::make_index_expression (tree_expression *expr,
+                                      tree_argument_list *args, char type)
 {
   tree_index_expression *retval = 0;
 
   if (args && args->has_magic_tilde ())
     {
-      yyerror ("invalid use of empty argument (~) in index expression");
+      bison_error ("invalid use of empty argument (~) in index expression");
       return retval;
     }
 
   int l = expr->line ();
   int c = expr->column ();
 
   if (! expr->is_postfix_indexed ()) 
     expr->set_postfix_index (type);
@@ -3183,18 +3080,19 @@ make_index_expression (tree_expression *
   else
     retval = new tree_index_expression (expr, args, l, c, type);
 
   return retval;
 }
 
 // Make an indirect reference expression.
 
-static tree_index_expression *
-make_indirect_ref (tree_expression *expr, const std::string& elt)
+tree_index_expression *
+octave_parser::make_indirect_ref (tree_expression *expr,
+                                  const std::string& elt)
 {
   tree_index_expression *retval = 0;
 
   int l = expr->line ();
   int c = expr->column ();
 
   if (! expr->is_postfix_indexed ()) 
     expr->set_postfix_index ('.');
@@ -3205,25 +3103,25 @@ make_indirect_ref (tree_expression *expr
 
       tmp->append (elt);
 
       retval = tmp;
     }
   else
     retval = new tree_index_expression (expr, elt, l, c);
 
-  lexer_flags.looking_at_indirect_ref = false;
+  curr_lexer->looking_at_indirect_ref = false;
 
   return retval;
 }
 
 // Make an indirect reference expression with dynamic field name.
 
-static tree_index_expression *
-make_indirect_ref (tree_expression *expr, tree_expression *elt)
+tree_index_expression *
+octave_parser::make_indirect_ref (tree_expression *expr, tree_expression *elt)
 {
   tree_index_expression *retval = 0;
 
   int l = expr->line ();
   int c = expr->column ();
 
   if (! expr->is_postfix_indexed ()) 
     expr->set_postfix_index ('.');
@@ -3234,39 +3132,40 @@ make_indirect_ref (tree_expression *expr
 
       tmp->append (elt);
 
       retval = tmp;
     }
   else
     retval = new tree_index_expression (expr, elt, l, c);
 
-  lexer_flags.looking_at_indirect_ref = false;
+  curr_lexer->looking_at_indirect_ref = false;
 
   return retval;
 }
 
 // Make a declaration command.
 
-static tree_decl_command *
-make_decl_command (int tok, token *tok_val, tree_decl_init_list *lst)
+tree_decl_command *
+octave_parser::make_decl_command (int tok, token *tok_val,
+                                  tree_decl_init_list *lst)
 {
   tree_decl_command *retval = 0;
 
   int l = tok_val->line ();
   int c = tok_val->column ();
 
   switch (tok)
     {
     case GLOBAL:
       retval = new tree_global_command (lst, l, c);
       break;
 
     case PERSISTENT:
-      if (current_function_depth > 0)
+      if (curr_fcn_depth > 0)
         retval = new tree_persistent_command (lst, l, c);
       else
         {
           if (reading_script_file)
             warning ("ignoring persistent declaration near line %d of file '%s'",
                      l, curr_fcn_file_full_name.c_str ());
           else
             warning ("ignoring persistent declaration near line %d", l);
@@ -3276,28 +3175,28 @@ make_decl_command (int tok, token *tok_v
     default:
       panic_impossible ();
       break;
     }
 
   return retval;
 }
 
-static tree_argument_list *
-validate_matrix_row (tree_argument_list *row)
+tree_argument_list *
+octave_parser::validate_matrix_row (tree_argument_list *row)
 {
   if (row && row->has_magic_tilde ())
-    yyerror ("invalid use of tilde (~) in matrix expression");
+    bison_error ("invalid use of tilde (~) in matrix expression");
   return row;
 }
 
 // Finish building a matrix list.
 
-static tree_expression *
-finish_matrix (tree_matrix *m)
+tree_expression *
+octave_parser::finish_matrix (tree_matrix *m)
 {
   tree_expression *retval = m;
 
   unwind_protect frame;
 
   frame.protect_var (error_state);
   frame.protect_var (warning_state);
 
@@ -3330,40 +3229,40 @@ finish_matrix (tree_matrix *m)
         }
     }
 
   return retval;
 }
 
 // Finish building a cell list.
 
-static tree_expression *
-finish_cell (tree_cell *c)
+tree_expression *
+octave_parser::finish_cell (tree_cell *c)
 {
   return finish_matrix (c);
 }
 
-static void
-maybe_warn_missing_semi (tree_statement_list *t)
+void
+octave_parser::maybe_warn_missing_semi (tree_statement_list *t)
 {
-  if (current_function_depth > 0)
+  if (curr_fcn_depth > 0)
     {
       tree_statement *tmp = t->back ();
 
       if (tmp->is_expression ())
         warning_with_id
           ("Octave:missing-semicolon",
            "missing semicolon near line %d, column %d in file '%s'",
             tmp->line (), tmp->column (), curr_fcn_file_full_name.c_str ());
     }
 }
 
-static tree_statement_list *
-set_stmt_print_flag (tree_statement_list *list, char sep,
-                     bool warn_missing_semi)
+tree_statement_list *
+octave_parser::set_stmt_print_flag (tree_statement_list *list, char sep,
+                                    bool warn_missing_semi)
 {
   tree_statement *tmp = list->back ();
 
   switch (sep)
     {
     case ';':
       tmp->set_print_flag (false);
       break;
@@ -3388,191 +3287,78 @@ set_stmt_print_flag (tree_statement_list
     {
       list->pop_back ();
       delete tmp;
     }
 
   return list;
 }
 
-static tree_statement_list *
-make_statement_list (tree_statement *stmt)
+tree_statement_list *
+octave_parser::make_statement_list (tree_statement *stmt)
 {
   return new tree_statement_list (stmt);
 }
 
-static tree_statement_list *
-append_statement_list (tree_statement_list *list, char sep,
-                       tree_statement *stmt, bool warn_missing_semi)
+tree_statement_list *
+octave_parser::append_statement_list (tree_statement_list *list, char sep,
+                                      tree_statement *stmt,
+                                      bool warn_missing_semi)
 {
   set_stmt_print_flag (list, sep, warn_missing_semi);
 
   list->append (stmt);
 
   return list;
 }
 
-static tree_funcall *
-make_superclass_ref (const std::string& method_nm,
-                     const std::string& package_nm,
-                     const std::string& class_nm,
-                     int l, int c)
-{
-  octave_value_list args;
-
-  args(2) = class_nm;
-  args(1) = package_nm;
-  args(0) = method_nm;
-
-  octave_value fcn
-    = symbol_table::find_built_in_function ("__superclass_reference__");
-
-  return new tree_funcall (fcn, args);
-}
-
-static tree_funcall *
-make_meta_class_query (const std::string& package_nm,
-                       const std::string& class_nm,
-                       int l, int c)
+void
+octave_parser::bison_error (const char *s)
+
 {
-  octave_value_list args;
-
-  args(1) = class_nm;
-  args(0) = package_nm;
-
-  octave_value fcn
-    = symbol_table::find_built_in_function ("__meta_class_query__");
-
-  return new tree_funcall (fcn, args);
-}
-
-// A CLASSDEF block defines a class that has a constructor and other
-// methods, but it is not an executable command.  Parsing the block
-// makes some changes in the symbol table (inserting the constructor
-// and methods, and adding to the list of known objects) and creates
-// a parse tree containing meta information about the class.
-
-static tree_classdef *
-make_classdef (token *tok_val, tree_classdef_attribute_list *a,
-               tree_identifier *id, tree_classdef_superclass_list *sc,
-               tree_classdef_body *body, token *end_tok,
-               octave_comment_list *lc)
-{
-  tree_classdef *retval = 0;
-
-  std::string cls_name = id->name ();
-
-  std::string nm = curr_fcn_file_name;
-
-  size_t pos = nm.find_last_of (file_ops::dir_sep_chars ());
-
-  if (pos != std::string::npos)
-    nm = curr_fcn_file_name.substr (pos+1);
-
-  if (nm != cls_name)
+  int err_col = curr_lexer->current_input_column - 1;
+
+  std::ostringstream output_buf;
+
+  if (reading_fcn_file || reading_script_file || reading_classdef_file)
+    output_buf << "parse error near line " << curr_lexer->input_line_number
+               << " of file " << curr_fcn_file_full_name;
+  else
+    output_buf << "parse error:";
+
+  if (s && strcmp (s, "parse error") != 0)
+    output_buf << "\n\n  " << s;
+
+  output_buf << "\n\n";
+
+  if (! current_input_line.empty ())
     {
-      yyerror ("invalid classdef definition, the class name must match the file name");
-      return retval;
-    }
-
-  if (end_token_ok (end_tok, token::classdef_end))
-    {
-      octave_comment_list *tc = octave_comment_buffer::get_comment ();
-
-      int l = tok_val->line ();
-      int c = tok_val->column ();
-
-      retval = new tree_classdef (a, id, sc, body, lc, tc, l, c);
+      size_t len = current_input_line.length ();
+
+      if (current_input_line[len-1] == '\n')
+        current_input_line.resize (len-1);
+
+      // Print the line, maybe with a pointer near the error token.
+
+      output_buf << ">>> " << current_input_line << "\n";
+
+      if (err_col == 0)
+        err_col = len;
+
+      for (int i = 0; i < err_col + 3; i++)
+        output_buf << " ";
+
+      output_buf << "^";
     }
 
-  return retval;
-}
-
-static tree_classdef_properties_block *
-make_classdef_properties_block (token *tok_val,
-                                tree_classdef_attribute_list *a,
-                                tree_classdef_property_list *plist,
-                                token *end_tok, octave_comment_list *lc)
-{
-  tree_classdef_properties_block *retval = 0;
-
-  if (end_token_ok (end_tok, token::properties_end))
-    {
-      octave_comment_list *tc = octave_comment_buffer::get_comment ();
-
-      int l = tok_val->line ();
-      int c = tok_val->column ();
-
-      retval = new tree_classdef_properties_block (a, plist, lc, tc, l, c);
-    }
-
-  return retval;
-}
-
-static tree_classdef_methods_block *
-make_classdef_methods_block (token *tok_val,
-                             tree_classdef_attribute_list *a,
-                             tree_classdef_methods_list *mlist,
-                             token *end_tok, octave_comment_list *lc)
-{
-  tree_classdef_methods_block *retval = 0;
-
-  if (end_token_ok (end_tok, token::methods_end))
-    {
-      octave_comment_list *tc = octave_comment_buffer::get_comment ();
-
-      int l = tok_val->line ();
-      int c = tok_val->column ();
-
-      retval = new tree_classdef_methods_block (a, mlist, lc, tc, l, c);
-    }
-
-  return retval;
-}
-
-static tree_classdef_events_block *
-make_classdef_events_block (token *tok_val,
-                            tree_classdef_attribute_list *a,
-                            tree_classdef_events_list *elist,
-                            token *end_tok, octave_comment_list *lc)
-{
-  tree_classdef_events_block *retval = 0;
-
-  if (end_token_ok (end_tok, token::events_end))
-    {
-      octave_comment_list *tc = octave_comment_buffer::get_comment ();
-
-      int l = tok_val->line ();
-      int c = tok_val->column ();
-
-      retval = new tree_classdef_events_block (a, elist, lc, tc, l, c);
-    }
-
-  return retval;
-}
-
-static tree_classdef_enum_block *
-make_classdef_enum_block (token *tok_val,
-                          tree_classdef_attribute_list *a,
-                          tree_classdef_enum_list *elist,
-                          token *end_tok, octave_comment_list *lc)
-{
-  tree_classdef_enum_block *retval = 0;
-
-  if (end_token_ok (end_tok, token::enumeration_end))
-    {
-      octave_comment_list *tc = octave_comment_buffer::get_comment ();
-
-      int l = tok_val->line ();
-      int c = tok_val->column ();
-
-      retval = new tree_classdef_enum_block (a, elist, lc, tc, l, c);
-    }
-
-  return retval;
+  output_buf << "\n";
+
+  std::string msg = output_buf.str ();
+
+  parse_error ("%s", msg.c_str ());
 }
 
 static void
 safe_fclose (FILE *f)
 {
   // FIXME -- comments at the end of an input file are
   // discarded (otherwise, they would be appended to the next
   // statement, possibly from the command line or another file, which
@@ -3614,40 +3400,70 @@ text_getc (FILE *f)
 
       if (c != '\n')
         {
           ungetc (c, f);
           c = '\n';
         }
     }
 
-  if (c == '\n')
-    input_line_number++;
-
   return c;
 }
 
 class
 stdio_stream_reader : public stream_reader
 {
 public:
-  stdio_stream_reader (FILE *f_arg) : stream_reader (), f (f_arg) { }
-
-  int getc (void) { return ::text_getc (f); }
+
+  stdio_stream_reader (FILE *f_arg, int& l, int& c)
+    : stream_reader (), f (f_arg), line_num (l), column_num (c)
+  { }
+
+  int getc (void)
+  {
+    char c = ::text_getc (f);
+
+    if (c == '\n')
+      {
+        line_num++;
+        column_num = 0;
+      }
+    else
+      {
+        // FIXME -- try to be smarter about tabs?
+        column_num++;
+      }
+        
+    return c;
+  }
+
   int ungetc (int c)
   {
     if (c == '\n')
-      input_line_number--;
+      {   
+        line_num--;
+        column_num = 0;
+      }
+    else
+      {
+        // FIXME -- try to be smarter about tabs?
+        column_num--;
+      }
 
     return ::ungetc (c, f);
   }
 
 private:
+
   FILE *f;
 
+  int& line_num;
+
+  int& column_num;
+
   // No copying!
 
   stdio_stream_reader (const  stdio_stream_reader&);
 
   stdio_stream_reader & operator = (const  stdio_stream_reader&);
 };
 
 static bool
@@ -3656,21 +3472,17 @@ skip_white_space (stream_reader& reader)
   int c = 0;
 
   while ((c = reader.getc ()) != EOF)
     {
       switch (c)
         {
         case ' ':
         case '\t':
-          current_input_column++;
-          break;
-
         case '\n':
-          current_input_column = 1;
           break;
 
         default:
           reader.ungetc (c);
           goto done;
         }
     }
 
@@ -3694,37 +3506,38 @@ looking_at_classdef_keyword (FILE *ffile
     status = true;
 
   gnulib::fseek (ffile, pos, SEEK_SET);
 
   return status;
  }
 
 static std::string
-gobble_leading_white_space (FILE *ffile, bool& eof)
+gobble_leading_white_space (FILE *ffile, bool& eof, int& line_num,
+                            int& column_num)
 {
   std::string help_txt;
 
   eof = false;
 
   // TRUE means we have already cached the help text.
   bool have_help_text = false;
 
   std::string txt;
 
-  stdio_stream_reader stdio_reader (ffile);
+  stdio_stream_reader stdio_reader (ffile, line_num, column_num);
 
   while (true)
     {
       eof = skip_white_space (stdio_reader);
 
       if (eof)
         break;
 
-      txt = grab_comment_block (stdio_reader, true, eof);
+      txt = CURR_LEXER->grab_comment_block (stdio_reader, true, eof);
 
       if (txt.empty ())
         break;
 
       if (! (have_help_text || looks_like_copyright (txt)))
         {
           help_txt = txt;
           have_help_text = true;
@@ -3734,16 +3547,25 @@ gobble_leading_white_space (FILE *ffile,
 
       if (eof)
         break;
     }
 
   return help_txt;
 }
 
+static std::string
+gobble_leading_white_space (FILE *ffile, bool& eof)
+{
+  int line_num = 1;
+  int column_num = 1;
+
+  return gobble_leading_white_space (ffile, eof, line_num, column_num);
+}
+
 static bool
 looking_at_function_keyword (FILE *ffile)
 {
   bool status = false;
 
   long pos = gnulib::ftell (ffile);
 
   char buf [10];
@@ -3755,85 +3577,80 @@ looking_at_function_keyword (FILE *ffile
 
   gnulib::fseek (ffile, pos, SEEK_SET);
 
   return status;
 }
 
 static octave_function *
 parse_fcn_file (const std::string& ff, const std::string& dispatch_type,
-                bool force_script = false, bool require_file = true,
-                const std::string& warn_for = std::string ())
+                bool require_file, bool force_script, bool autoload,    
+                bool relative_lookup, const std::string& warn_for)
 {
   unwind_protect frame;
 
   octave_function *fcn_ptr = 0;
 
   // Open function file and parse.
 
   FILE *in_stream = command_editor::get_input_stream ();
 
   frame.add_fcn (command_editor::set_input_stream, in_stream);
 
   frame.protect_var (ff_instream);
 
-  frame.protect_var (input_line_number);
-  frame.protect_var (current_input_column);
   frame.protect_var (reading_fcn_file);
   frame.protect_var (line_editing);
-  frame.protect_var (current_class_name);
-  frame.protect_var (current_function_depth);
-  frame.protect_var (function_scopes);
-  frame.protect_var (max_function_depth);
-  frame.protect_var (parsing_subfunctions);
-  frame.protect_var (endfunction_found);
-
-  input_line_number = 1;
-  current_input_column = 1;
+
   reading_fcn_file = true;
   line_editing = false;
-  current_class_name = dispatch_type;
-  current_function_depth = 0;
-  function_scopes.clear ();
-  max_function_depth = 0;
-  parsing_subfunctions = false;
-  endfunction_found = false;
 
   frame.add_fcn (command_history::ignore_entries,
                  command_history::ignoring_entries ());
 
   command_history::ignore_entries ();
 
   FILE *ffile = get_input_from_file (ff, 0);
 
   frame.add_fcn (safe_fclose, ffile);
 
   if (ffile)
     {
       bool eof;
 
-      std::string help_txt = gobble_leading_white_space (ffile, eof);
+      // octave_parser constructor sets this for us.
+      frame.protect_var (CURR_LEXER);
+
+      octave_parser *curr_parser = new octave_parser ();
+      frame.add_fcn (octave_parser::cleanup, curr_parser);
+
+      curr_parser->curr_class_name = dispatch_type;
+      curr_parser->autoloading = autoload;
+      curr_parser->fcn_file_from_relative_lookup = relative_lookup;
+
+      std::string help_txt
+        = gobble_leading_white_space
+            (ffile, eof,
+             curr_parser->curr_lexer->input_line_number,
+             curr_parser->curr_lexer->current_input_column);
 
       if (! help_txt.empty ())
         help_buf.push (help_txt);
 
       if (! eof)
         {
           std::string file_type;
 
           frame.protect_var (get_input_from_eval_string);
-          frame.protect_var (parser_end_of_input);
           frame.protect_var (reading_fcn_file);
           frame.protect_var (reading_script_file);
           frame.protect_var (reading_classdef_file);
           frame.protect_var (Vecho_executing_commands);
 
-
           get_input_from_eval_string = false;
-          parser_end_of_input = false;
 
           if (! force_script && looking_at_function_keyword (ffile))
             {
               file_type = "function";
 
               Vecho_executing_commands = ECHO_OFF;
 
               reading_classdef_file = false;
@@ -3856,92 +3673,79 @@ parse_fcn_file (const std::string& ff, c
 
               Vecho_executing_commands = ECHO_OFF;
 
               reading_classdef_file = false;
               reading_fcn_file = false;
               reading_script_file = true;
             }
 
-          YY_BUFFER_STATE old_buf = current_buffer ();
-          YY_BUFFER_STATE new_buf = create_buffer (ffile);
-
-          frame.add_fcn (switch_to_buffer, old_buf);
-          frame.add_fcn (delete_buffer, new_buf);
-
-          switch_to_buffer (new_buf);
-
-          frame.protect_var (primary_fcn_ptr);
-          primary_fcn_ptr = 0;
-
-          frame.protect_var (classdef_object);
-          classdef_object = 0;
-
-          reset_parser ();
-
           // Do this with an unwind-protect cleanup function so that
           // the forced variables will be unmarked in the event of an
           // interrupt.
           symbol_table::scope_id scope = symbol_table::top_scope ();
           frame.add_fcn (symbol_table::unmark_forced_variables, scope);
 
           if (! help_txt.empty ())
             help_buf.push (help_txt);
 
           if (reading_script_file)
-            prep_lexer_for_script_file ();
+            curr_parser->curr_lexer->prep_for_script_file ();
           else if (reading_classdef_file)
-            prep_lexer_for_classdef_file ();
+            curr_parser->curr_lexer->prep_for_classdef_file ();
           else
-            prep_lexer_for_function_file ();
-
-          lexer_flags.parsing_class_method = ! dispatch_type.empty ();
+            curr_parser->curr_lexer->prep_for_function_file ();
+
+          curr_parser->curr_lexer->parsing_class_method = ! dispatch_type.empty ();
 
           frame.protect_var (global_command);
 
           global_command = 0;
 
-          int status = yyparse ();
+          int status = curr_parser->run ();
 
           // Use an unwind-protect cleanup function so that the
           // global_command list will be deleted in the event of an
           // interrupt.
 
           frame.add_fcn (cleanup_statement_list, &global_command);
 
-          fcn_ptr = primary_fcn_ptr;
+          fcn_ptr = curr_parser->primary_fcn_ptr;
 
           if (status == 0)
             {
-              if (reading_classdef_file && classdef_object)
+              if (reading_classdef_file && curr_parser->classdef_object)
                 {
                   // Convert parse tree for classdef object to
                   // meta.class info (and stash it in the symbol
                   // table?).  Return pointer to constructor?
 
                   if (fcn_ptr)
                     panic_impossible ();
 
-                  fcn_ptr = classdef_object->make_meta_class ();
+                  fcn_ptr = curr_parser->classdef_object->make_meta_class ();
                 }
             }
           else
             {
               error ("parse error while reading %s file %s",
                      file_type.c_str(), ff.c_str ());
             }
         }
       else
         {
+          int l = curr_parser->curr_lexer->input_line_number;
+          int c = curr_parser->curr_lexer->current_input_column;
+
           tree_statement *end_of_script
-            = make_end ("endscript", input_line_number, current_input_column);
-
-          make_script (0, end_of_script);
-
-          fcn_ptr = primary_fcn_ptr;
+            = curr_parser->make_end ("endscript", l, c);
+
+          curr_parser->make_script (0, end_of_script);
+
+          fcn_ptr = curr_parser->primary_fcn_ptr;
         }
     }
   else if (require_file)
     error ("no such file, '%s'", ff.c_str ());
   else if (! warn_for.empty ())
     error ("%s: unable to open file '%s'", warn_for.c_str (), ff.c_str ());
 
   return fcn_ptr;
@@ -3966,17 +3770,19 @@ get_help_from_file (const std::string& n
           unwind_protect frame;
           frame.add_fcn (safe_fclose, fptr);
 
           bool eof;
           retval = gobble_leading_white_space (fptr, eof);
 
           if (retval.empty ())
             {
-              octave_function *fcn = parse_fcn_file (file, "");
+              octave_function *fcn = parse_fcn_file (file, "", true,
+                                                     false, false,
+                                                     false, "");
 
               if (fcn)
                 {
                   retval = fcn->doc_string ();
 
                   delete fcn;
                 }
             }
@@ -4044,84 +3850,78 @@ load_fcn_from_file (const std::string& f
   unwind_protect frame;
 
   std::string nm = file_name;
 
   size_t nm_len = nm.length ();
 
   std::string file;
 
-  frame.protect_var (fcn_file_from_relative_lookup);
-
-  fcn_file_from_relative_lookup = false;
+  bool relative_lookup = false;
 
   file = nm;
 
   if ((nm_len > 4 && nm.substr (nm_len-4) == ".oct")
       || (nm_len > 4 && nm.substr (nm_len-4) == ".mex")
       || (nm_len > 2 && nm.substr (nm_len-2) == ".m"))
     {
       nm = octave_env::base_pathname (file);
       nm = nm.substr (0, nm.find_last_of ('.'));
 
       size_t pos = nm.find_last_of (file_ops::dir_sep_str ());
       if (pos != std::string::npos)
         nm = nm.substr (pos+1);
     }
 
-  if (autoload)
-    {
-      frame.protect_var (autoloading);
-      autoloading = true;
-    }
-
-  fcn_file_from_relative_lookup = ! octave_env::absolute_pathname (file);
+  relative_lookup = ! octave_env::absolute_pathname (file);
 
   file = octave_env::make_absolute (file);
 
   int len = file.length ();
 
   if (len > 4 && file.substr (len-4, len-1) == ".oct")
     {
       if (autoload && ! fcn_name.empty ())
         nm = fcn_name;
 
-      retval = octave_dynamic_loader::load_oct (nm, file, fcn_file_from_relative_lookup);
+      retval = octave_dynamic_loader::load_oct (nm, file, relative_lookup);
     }
   else if (len > 4 && file.substr (len-4, len-1) == ".mex")
     {
       // Temporarily load m-file version of mex-file, if it exists,
       // to get the help-string to use.
       frame.protect_var (curr_fcn_file_name);
       frame.protect_var (curr_fcn_file_full_name);
 
       curr_fcn_file_name = nm;
       curr_fcn_file_full_name = file.substr (0, len - 2);
 
       octave_function *tmpfcn = parse_fcn_file (file.substr (0, len - 2),
-                                                dispatch_type, autoloading,
-                                                false);
-
-      retval = octave_dynamic_loader::load_mex (nm, file, fcn_file_from_relative_lookup);
+                                                dispatch_type, false,
+                                                autoload, autoload,
+                                                relative_lookup, "");
+
+      retval = octave_dynamic_loader::load_mex (nm, file, relative_lookup);
 
       if (tmpfcn)
         retval->document (tmpfcn->doc_string ());
       delete tmpfcn;
     }
   else if (len > 2)
     {
       // These are needed by yyparse.
 
       frame.protect_var (curr_fcn_file_name);
       frame.protect_var (curr_fcn_file_full_name);
 
       curr_fcn_file_name = nm;
       curr_fcn_file_full_name = file;
 
-      retval = parse_fcn_file (file, dispatch_type, autoloading);
+      retval = parse_fcn_file (file, dispatch_type, true, autoload,
+                               autoload, relative_lookup, "");
     }
 
   if (retval)
     {
       retval->stash_dir_name (dir_name);
 
       if (retval->is_user_function ())
         {
@@ -4314,18 +4114,19 @@ source_file (const std::string& file_nam
         error ("source: context must be \"caller\" or \"base\"");
 
       if (! error_state)
         frame.add_fcn (octave_call_stack::pop);
     }
 
   if (! error_state)
     {
-      octave_function *fcn = parse_fcn_file (file_full_name, "", true,
-                                             require_file, warn_for);
+      octave_function *fcn = parse_fcn_file (file_full_name, "",
+                                             require_file, true, false,
+                                             false, warn_for);
 
       if (! error_state)
         {
           if (fcn && fcn->is_user_script ())
             {
               octave_value_list args;
 
               if (verbose)
@@ -4626,72 +4427,52 @@ another function for the given type sign
 
 octave_value_list
 eval_string (const std::string& s, bool silent, int& parse_status, int nargout)
 {
   octave_value_list retval;
 
   unwind_protect frame;
 
-  frame.protect_var (input_line_number);
-  frame.protect_var (current_input_column);
+  // octave_parser constructor sets this for us.
+  frame.protect_var (CURR_LEXER);
+
+  octave_parser *curr_parser = new octave_parser ();
+  frame.add_fcn (octave_parser::cleanup, curr_parser);
+
   frame.protect_var (get_input_from_eval_string);
-  frame.protect_var (input_from_eval_string_pending);
-  frame.protect_var (parser_end_of_input);
   frame.protect_var (line_editing);
   frame.protect_var (current_eval_string);
-  frame.protect_var (current_function_depth);
-  frame.protect_var (function_scopes);
-  frame.protect_var (max_function_depth);
-  frame.protect_var (parsing_subfunctions);
-  frame.protect_var (endfunction_found);
   frame.protect_var (reading_fcn_file);
   frame.protect_var (reading_script_file);
   frame.protect_var (reading_classdef_file);
 
-  input_line_number = 1;
-  current_input_column = 1;
   get_input_from_eval_string = true;
-  input_from_eval_string_pending = true;
-  parser_end_of_input = false;
   line_editing = false;
-  current_function_depth = 0;
-  function_scopes.clear ();
-  max_function_depth = 0;
-  parsing_subfunctions = false;
-  endfunction_found = false;
   reading_fcn_file = false;
   reading_script_file = false;
   reading_classdef_file = false;
 
   current_eval_string = s;
 
-  YY_BUFFER_STATE old_buf = current_buffer ();
-  YY_BUFFER_STATE new_buf = create_buffer (0);
-
-  frame.add_fcn (switch_to_buffer, old_buf);
-  frame.add_fcn (delete_buffer, new_buf);
-
-  switch_to_buffer (new_buf);
-
   do
     {
-      reset_parser ();
+      curr_parser->reset ();
 
       frame.protect_var (global_command);
 
       global_command = 0;
 
       // Do this with an unwind-protect cleanup function so that the
       // forced variables will be unmarked in the event of an
       // interrupt.
       symbol_table::scope_id scope = symbol_table::top_scope ();
       frame.add_fcn (symbol_table::unmark_forced_variables, scope);
 
-      parse_status = yyparse ();
+      parse_status = curr_parser->run ();
 
       tree_statement_list *command_list = global_command;
 
       // Unmark forced variables.
       // Restore previous value of global_command.
       frame.run (2);
 
       if (parse_status == 0)
@@ -4743,17 +4524,17 @@ eval_string (const std::string& s, bool 
                 error ("eval: invalid use of statement list");
 
               if (error_state
                   || tree_return_command::returning
                   || tree_break_command::breaking
                   || tree_continue_command::continuing)
                 break;
             }
-          else if (parser_end_of_input)
+          else if (curr_parser->end_of_input)
             break;
         }
     }
   while (parse_status == 0);
 
   return retval;
 }
 
diff --git a/libinterp/parse-tree/parse.h b/libinterp/parse-tree/parse.h
--- a/libinterp/parse-tree/parse.h
+++ b/libinterp/parse-tree/parse.h
@@ -23,54 +23,83 @@ along with Octave; see the file COPYING.
 #if !defined (octave_parse_h)
 #define octave_parse_h 1
 
 #include <cstdio>
 
 #include <string>
 
 #include <stack>
+#include <vector>
+#include <map>
 
-extern void reset_parser (void);
-extern int octave_lex (void);
-extern int octave_parse (void);
+#include "lex.h"
+#include "symtab.h"
+#include "token.h"
 
+class octave_comment_list;
+class octave_function;
+class octave_user_function;
 class tree;
-class tree_matrix;
+class tree_anon_fcn_handle;
+class tree_argument_list;
+class tree_cell;
+class tree_classdef;
+class tree_classdef_attribute_list;
+class tree_classdef_body;
+class tree_classdef_enum_block;
+class tree_classdef_enum_list;
+class tree_classdef_events_block;
+class tree_classdef_events_list;
+class tree_classdef_methods_block;
+class tree_classdef_methods_list;
+class tree_classdef_properties_block;
+class tree_classdef_property_list;
+class tree_classdef_superclass_list;
+class tree_colon_expression;
+class tree_command;
+class tree_constant;
+class tree_decl_command;
+class tree_decl_init_list;
+class tree_expression;
+class tree_fcn_handle;
+class tree_funcall;
+class tree_function_def;
 class tree_identifier;
+class tree_if_clause;
+class tree_if_command;
+class tree_if_command_list;
+class tree_index_expression;
+class tree_matrix;
+class tree_matrix;
+class tree_parameter_list;
+class tree_statement;
 class tree_statement_list;
-class octave_function;
+class tree_statement_listtree_statement;
+class tree_switch_case;
+class tree_switch_case_list;
+class tree_switch_command;
 
 #include "oct-obj.h"
 
 // Nonzero means print parser debugging info (-d).
 extern int octave_debug;
 
-// The current input line number.
-extern int input_line_number;
-
-// The column of the current token.
-extern int current_input_column;
-
 // Buffer for help text snagged from function files.
 extern std::stack<std::string> help_buf;
 
 // TRUE means we are using readline.
 extern bool line_editing;
 
 // TRUE means we printed messages about reading startup files.
 extern bool reading_startup_message_printed;
 
 // TRUE means input is coming from startup file.
 extern bool input_from_startup_file;
 
-// Name of the current class when we are parsing class methods or
-// constructors.
-extern std::string current_class_name;
-
 extern OCTINTERP_API std::string
 get_help_from_file (const std::string& nm, bool& symbol_found,
                     std::string& file);
 
 extern OCTINTERP_API std::string
 get_help_from_file (const std::string& nm, bool& symbol_found);
 
 extern OCTINTERP_API std::string lookup_autoload (const std::string& nm);
@@ -108,9 +137,325 @@ feval (const octave_value_list& args, in
 extern OCTINTERP_API octave_value_list
 eval_string (const std::string&, bool silent, int& parse_status, int hargout);
 
 extern OCTINTERP_API octave_value
 eval_string (const std::string&, bool silent, int& parse_status);
 
 extern OCTINTERP_API void cleanup_statement_list (tree_statement_list **lst);
 
+// Global access to currently active lexer.
+// FIXME -- to be removed after more parser+lexer refactoring.
+extern lexical_feedback *CURR_LEXER;
+
+class
+octave_parser
+{
+public:
+
+  octave_parser (void)
+    : end_of_input (false), endfunction_found (false),
+      autoloading (false), fcn_file_from_relative_lookup (false),
+      parsing_subfunctions (false), max_fcn_depth (0),
+      curr_fcn_depth (0), primary_fcn_scope (-1),
+      curr_class_name (), function_scopes (), primary_fcn_ptr (0),
+      classdef_object (0), curr_lexer (new lexical_feedback ())
+  {
+    CURR_LEXER = curr_lexer;
+  }
+
+  ~octave_parser (void)
+  {
+    delete curr_lexer;
+  }
+
+  void reset (void)
+  {
+    curr_lexer->reset ();
+  }
+
+  int run (void);
+
+  // Error mesages for mismatched end tokens.
+  void end_error (const char *type, token::end_tok_type ettype, int l, int c);
+
+  // Check to see that end tokens are properly matched.
+  bool end_token_ok (token *tok, token::end_tok_type expected);
+
+  // Maybe print a warning if an assignment expression is used as the
+  // test in a logical expression.
+  void maybe_warn_assign_as_truth_value (tree_expression *expr);
+
+  // Maybe print a warning about switch labels that aren't constants.
+  void maybe_warn_variable_switch_label (tree_expression *expr);
+
+  // Finish building a range.
+  tree_expression *finish_colon_expression (tree_colon_expression *e);
+
+  // Build a constant.
+  tree_constant *make_constant (int op, token *tok_val);
+
+  // Build a function handle.
+  tree_fcn_handle *make_fcn_handle (token *tok_val);
+
+  // Build an anonymous function handle.
+  tree_anon_fcn_handle *
+  make_anon_fcn_handle (tree_parameter_list *param_list, tree_statement *stmt);
+
+  // Build a binary expression.
+  tree_expression *
+  make_binary_op (int op, tree_expression *op1, token *tok_val,
+                  tree_expression *op2);
+
+  // Build a boolean expression.
+  tree_expression *
+  make_boolean_op (int op, tree_expression *op1, token *tok_val,
+                   tree_expression *op2);
+
+  // Build a prefix expression.
+  tree_expression *
+  make_prefix_op (int op, tree_expression *op1, token *tok_val);
+
+  // Build a postfix expression.
+  tree_expression *
+  make_postfix_op (int op, tree_expression *op1, token *tok_val);
+
+  // Build an unwind-protect command.
+  tree_command *
+  make_unwind_command (token *unwind_tok, tree_statement_list *body,
+                       tree_statement_list *cleanup, token *end_tok,
+                       octave_comment_list *lc, octave_comment_list *mc);
+
+  // Build a try-catch command.
+  tree_command *
+  make_try_command (token *try_tok, tree_statement_list *body,
+                    tree_statement_list *cleanup, token *end_tok,
+                    octave_comment_list *lc, octave_comment_list *mc);
+
+  // Build a while command.
+  tree_command *
+  make_while_command (token *while_tok, tree_expression *expr,
+                      tree_statement_list *body, token *end_tok,
+                      octave_comment_list *lc);
+
+  // Build a do-until command.
+  tree_command *
+  make_do_until_command (token *until_tok, tree_statement_list *body,
+                         tree_expression *expr, octave_comment_list *lc);
+
+  // Build a for command.
+  tree_command *
+  make_for_command (int tok_id, token *for_tok, tree_argument_list *lhs,
+                    tree_expression *expr, tree_expression *maxproc,
+                    tree_statement_list *body, token *end_tok,
+                    octave_comment_list *lc);
+
+  // Build a break command.
+  tree_command *make_break_command (token *break_tok);
+
+  // Build a continue command.
+  tree_command *make_continue_command (token *continue_tok);
+
+  // Build a return command.
+  tree_command *make_return_command (token *return_tok);
+
+  // Start an if command.
+  tree_if_command_list *
+  start_if_command (tree_expression *expr, tree_statement_list *list);
+
+  // Finish an if command.
+  tree_if_command *
+  finish_if_command (token *if_tok, tree_if_command_list *list,
+                     token *end_tok, octave_comment_list *lc);
+
+  // Build an elseif clause.
+  tree_if_clause *
+  make_elseif_clause (token *elseif_tok, tree_expression *expr,
+                      tree_statement_list *list, octave_comment_list *lc);
+
+  // Finish a switch command.
+  tree_switch_command *
+  finish_switch_command (token *switch_tok, tree_expression *expr,
+                         tree_switch_case_list *list, token *end_tok,
+                         octave_comment_list *lc);
+
+  // Build a switch case.
+  tree_switch_case *
+  make_switch_case (token *case_tok, tree_expression *expr,
+                    tree_statement_list *list, octave_comment_list *lc);
+
+  // Build an assignment to a variable.
+  tree_expression *
+  make_assign_op (int op, tree_argument_list *lhs, token *eq_tok,
+                  tree_expression *rhs);
+
+  // Define a script.
+  void make_script (tree_statement_list *cmds, tree_statement *end_script);
+
+  // Begin defining a function.
+  octave_user_function *
+  start_function (tree_parameter_list *param_list, tree_statement_list *body,
+                  tree_statement *end_function);
+
+  // Create a no-op statement for end_function.
+  tree_statement *make_end (const std::string& type, int l, int c);
+
+  // Do most of the work for defining a function.
+  octave_user_function *
+  frob_function (const std::string& fname, octave_user_function *fcn);
+
+  // Finish defining a function.
+  tree_function_def *
+  finish_function (tree_parameter_list *ret_list,
+                   octave_user_function *fcn, octave_comment_list *lc);
+
+  // Reset state after parsing function.
+  void
+  recover_from_parsing_function (void);
+
+  tree_funcall *
+  make_superclass_ref (const std::string& method_nm,
+                       const std::string& package_nm,
+                       const std::string& class_nm,
+                       int l, int c);
+
+  tree_funcall *
+  make_meta_class_query (const std::string& package_nm,
+                         const std::string& class_nm,
+                         int l, int c);
+
+  tree_classdef *
+  make_classdef (token *tok_val, tree_classdef_attribute_list *a,
+                 tree_identifier *id, tree_classdef_superclass_list *sc,
+                 tree_classdef_body *body, token *end_tok,
+                 octave_comment_list *lc);
+
+  tree_classdef_properties_block *
+  make_classdef_properties_block (token *tok_val,
+                                  tree_classdef_attribute_list *a,
+                                  tree_classdef_property_list *plist,
+                                  token *end_tok, octave_comment_list *lc);
+
+  tree_classdef_methods_block *
+  make_classdef_methods_block (token *tok_val,
+                               tree_classdef_attribute_list *a,
+                               tree_classdef_methods_list *mlist,
+                               token *end_tok, octave_comment_list *lc);
+
+  tree_classdef_events_block *
+  make_classdef_events_block (token *tok_val,
+                              tree_classdef_attribute_list *a,
+                              tree_classdef_events_list *elist,
+                              token *end_tok, octave_comment_list *lc);
+
+  tree_classdef_enum_block *
+  make_classdef_enum_block (token *tok_val,
+                            tree_classdef_attribute_list *a,
+                            tree_classdef_enum_list *elist,
+                            token *end_tok, octave_comment_list *lc);
+
+  // Make an index expression.
+  tree_index_expression *
+  make_index_expression (tree_expression *expr,
+                         tree_argument_list *args, char type);
+
+  // Make an indirect reference expression.
+  tree_index_expression *
+  make_indirect_ref (tree_expression *expr, const std::string&);
+
+  // Make an indirect reference expression with dynamic field name.
+  tree_index_expression *
+  make_indirect_ref (tree_expression *expr, tree_expression *field);
+
+  // Make a declaration command.
+  tree_decl_command *
+  make_decl_command (int tok, token *tok_val, tree_decl_init_list *lst);
+
+  // Validate argument list forming a matrix or cell row.
+  tree_argument_list *validate_matrix_row (tree_argument_list *row);
+
+  // Finish building a matrix list.
+  tree_expression *finish_matrix (tree_matrix *m);
+
+  // Finish building a cell list.
+  tree_expression *finish_cell (tree_cell *c);
+
+  // Maybe print a warning.  Duh.
+  void maybe_warn_missing_semi (tree_statement_list *);
+
+  // Set the print flag for a statement based on the separator type.
+  tree_statement_list *
+  set_stmt_print_flag (tree_statement_list *, char, bool);
+
+  // Create a statement list.
+  tree_statement_list *make_statement_list (tree_statement *stmt);
+
+  // Append a statement to an existing statement list.
+  tree_statement_list *
+  append_statement_list (tree_statement_list *list, char sep,
+                         tree_statement *stmt, bool warn_missing_semi);
+
+  // Generic error messages.
+  void bison_error (const char *s);
+
+  // TRUE means that we have encountered EOF on the input stream.
+  bool end_of_input;
+
+  // Have we found an explicit end to a function?
+  bool endfunction_found;
+
+  // TRUE means we are in the process of autoloading a function.
+  bool autoloading;
+
+  // TRUE means the current function file was found in a relative path
+  // element.
+  bool fcn_file_from_relative_lookup;
+
+  // FALSE if we are still at the primary function. Subfunctions can
+  // only be declared inside function files.
+  bool parsing_subfunctions;
+
+  // Maximum function depth detected.  Used to determine whether
+  // we have nested functions or just implicitly ended subfunctions.
+  int max_fcn_depth;
+
+  // = 0 currently outside any function.
+  // = 1 inside the primary function or a subfunction.
+  // > 1 means we are looking at a function definition that seems to be
+  //     inside a function. Note that the function still might not be a
+  //     nested function.
+  int curr_fcn_depth;
+
+  // Scope where we install all subfunctions and nested functions. Only
+  // used while reading function files.
+  symbol_table::scope_id primary_fcn_scope;
+
+  // Name of the current class when we are parsing class methods or
+  // constructors.
+  std::string curr_class_name;
+
+  // A stack holding the nested function scopes being parsed.
+  // We don't use std::stack, because we want the clear method. Also, we
+  // must access one from the top
+  std::vector<symbol_table::scope_id> function_scopes;
+
+  // Pointer to the primary user function or user script function.
+  octave_function *primary_fcn_ptr;
+
+  // Pointer to the classdef object we just parsed, if any.
+  tree_classdef *classdef_object;
+
+  // State of the lexer.
+  lexical_feedback *curr_lexer;
+
+  // For unwind protect.
+  static void cleanup (octave_parser *parser) { delete parser; }
+
+private:
+
+  // No copying!
+
+  octave_parser (const octave_parser&);
+
+  octave_parser& operator = (const octave_parser&);
+};
+
 #endif
diff --git a/libinterp/parse-tree/pt-id.cc b/libinterp/parse-tree/pt-id.cc
--- a/libinterp/parse-tree/pt-id.cc
+++ b/libinterp/parse-tree/pt-id.cc
@@ -54,17 +54,18 @@ tree_identifier::eval_undefined_error (v
                      "'%s' undefined", name ().c_str ());
   else
     ::error_with_id ("Octave:undefined-function",
                      "'%s' undefined near line %d column %d",
                      name ().c_str (), l, c);
 }
 
 octave_value_list
-tree_identifier::rvalue (int nargout)
+tree_identifier::rvalue (int nargout,
+                         const std::list<octave_lvalue> *lvalue_list)
 {
   octave_value_list retval;
 
   if (error_state)
     return retval;
 
   octave_value val = sym->find ();
 
@@ -86,17 +87,19 @@ tree_identifier::rvalue (int nargout)
       if (val.is_function ())
         fcn = val.function_value (true);
 
       if (fcn && ! (is_postfix_indexed ()
                     && fcn->is_postfix_index_handled (postfix_index ())))
         {
           octave_value_list tmp_args;
 
-          retval = val.do_multi_index_op (nargout, tmp_args);
+          retval = (lvalue_list
+                    ? val.do_multi_index_op (nargout, tmp_args, lvalue_list)
+                    : val.do_multi_index_op (nargout, tmp_args));
         }
       else
         {
           if (print_result () && nargout == 0
               && tree_evaluator::statement_printing_enabled ())
             val.print_with_name (octave_stdout, name ());
 
           retval = val;
diff --git a/libinterp/parse-tree/pt-id.h b/libinterp/parse-tree/pt-id.h
--- a/libinterp/parse-tree/pt-id.h
+++ b/libinterp/parse-tree/pt-id.h
@@ -99,17 +99,23 @@ public:
 
   // We really need to know whether this symbol referst to a variable
   // or a function, but we may not know that yet.
 
   bool lvalue_ok (void) const { return true; }
 
   octave_value rvalue1 (int nargout = 1);
 
-  octave_value_list rvalue (int nargout);
+  octave_value_list rvalue (int nargout)
+  {
+    return rvalue (nargout, 0);
+  }
+
+  octave_value_list rvalue (int nargout,
+                            const std::list<octave_lvalue> *lvalue_list);
 
   octave_lvalue lvalue (void);
 
   void eval_undefined_error (void);
 
   void static_workspace_error (void)
   {
     ::error ("can not add variable \"%s\" to a static workspace",
diff --git a/libinterp/parse-tree/pt-mat.cc b/libinterp/parse-tree/pt-mat.cc
--- a/libinterp/parse-tree/pt-mat.cc
+++ b/libinterp/parse-tree/pt-mat.cc
@@ -397,17 +397,17 @@ tm_row_const::tm_row_const_rep::init (co
         {
           all_mt = false;
 
           if (first_elem)
             {
               first_elem = false;
               dv = this_elt_dv;
             }
-          else if (! dv.hvcat (this_elt_dv, 1))
+          else if ((! any_class) && (! dv.hvcat (this_elt_dv, 1)))
             {
               eval_error ("horizontal dimensions mismatch", dv, this_elt_dv);
               break;
             }
         }
     }
 
   ok = ! error_state;
@@ -639,17 +639,17 @@ tm_const::init (const tree_matrix& tm)
                    && this_elt_dv.length () == 2)
             {
               // FIXME: this is Octave's specialty. Character matrices allow
               // rows of unequal length.
               if (this_elt_nc > cols ())
                 dv(1) = this_elt_nc;
               dv(0) += this_elt_nr;
             }
-          else if (! dv.hvcat (this_elt_dv, 0))
+          else if ((!any_class) && (!dv.hvcat (this_elt_dv, 0)))
             {
               eval_error ("vertical dimensions mismatch", dv, this_elt_dv);
               return;
             }
         }
     }
 
   ok = ! error_state;
diff --git a/libinterp/parse-tree/token.h b/libinterp/parse-tree/token.h
--- a/libinterp/parse-tree/token.h
+++ b/libinterp/parse-tree/token.h
@@ -20,16 +20,18 @@ along with Octave; see the file COPYING.
 
 */
 
 #if !defined (octave_token_h)
 #define octave_token_h 1
 
 #include <string>
 
+#include "symtab.h"
+
 class
 token
 {
 public:
 
   enum token_type
     {
       generic_token,
diff --git a/liboctave/Makefile.am b/liboctave/Makefile.am
--- a/liboctave/Makefile.am
+++ b/liboctave/Makefile.am
@@ -130,10 +130,12 @@ LIBOCTAVE_TST_SRC = \
 TST_FILES_SRC := $(shell $(top_srcdir)/build-aux/find-files-with-tests.sh "$(srcdir)" $(LIBOCTAVE_TST_SRC))
 
 TST_FILES := $(addsuffix -tst,$(TST_FILES_SRC))
 
 liboctavetestsdir := $(octtestsdir)/liboctave
 
 nobase_liboctavetests_DATA = $(TST_FILES)
 
-DISTCLEANFILES += $(BUILT_INCS)
+DISTCLEANFILES += \
+  $(BUILT_INCS) \
+  $(TST_FILES)
 
diff --git a/liboctave/cruft/mkf77def.in b/liboctave/cruft/mkf77def.in
--- a/liboctave/cruft/mkf77def.in
+++ b/liboctave/cruft/mkf77def.in
@@ -20,29 +20,29 @@
 
 SED=${SED:-'sed'}
 AWK=${AWK:-'awk'}
 
 F77_TOLOWER="@F77_APPEND_UNDERSCORE@"
 F77_APPEND_UNDERSCORE="@F77_APPEND_UNDERSCORE@"
 F77_APPEND_EXTRA_UNDERSCORE="@F77_APPEND_EXTRA_UNDERSCORE@"
 
-if $F77_TOLOWER; then
+if test x$F77_TOLOWER = xyes; then
   case_cmd="tolower";
 else
   case_cmd="toupper";
 fi
 
-if $F77_APPEND_UNDERSCORE; then
+if test x$F77_APPEND_UNDERSCORE = xyes; then
   uscore="_";
 else
   uscore="";
 fi
 
-if $F77_APPEND_EXTRA_UNDERSCORE; then
+if test x$F77_APPEND_EXTRA_UNDERSCORE = xyes; then
   awkcmd="$AWK '{ if (\$0 ~ /_/) extra = \"_\"; else extra = \"\"; printf (\"%s%s%s\n\", $case_cmd (\$0), \"$uscore\", extra); }'"
 else
   awkcmd="$AWK '{ printf (\"%s%s\n\", tolower (\$0), \"$uscore\"); }'"
 fi
 
 if [ $# -gt 1 ]; then
   srcdir="$1"
   shift
diff --git a/liboctave/util/data-conv.cc b/liboctave/util/data-conv.cc
--- a/liboctave/util/data-conv.cc
+++ b/liboctave/util/data-conv.cc
@@ -482,17 +482,18 @@ oct_data_conv::data_type_as_string (oct_
 }
 
 #define LS_DO_READ(TYPE, swap, data, size, len, stream) \
   do \
     { \
       if (len > 0) \
         { \
           OCTAVE_LOCAL_BUFFER (TYPE, ptr, len); \
-          stream.read (reinterpret_cast<char *>  (ptr), size * len); \
+          std::streamsize n_bytes = size * len; \
+          stream.read (reinterpret_cast<char *> (ptr), n_bytes); \
           if (swap) \
             swap_bytes< size > (ptr, len); \
           for (octave_idx_type i = 0; i < len; i++) \
             data[i] = ptr[i]; \
         } \
     } \
   while (0)
 
@@ -504,17 +505,18 @@ oct_data_conv::data_type_as_string (oct_
     { \
       if (len > 0) \
         { \
           char tmp_type = type; \
           stream.write (&tmp_type, 1); \
           OCTAVE_LOCAL_BUFFER (TYPE, ptr, len); \
           for (octave_idx_type i = 0; i < len; i++) \
             ptr[i] = static_cast <TYPE> (data[i]);         \
-          stream.write (reinterpret_cast<char *> (ptr), size * len); \
+          std::streamsize n_bytes = size * len; \
+          stream.write (reinterpret_cast<char *> (ptr), n_bytes); \
         } \
     } \
   while (0)
 
 // Loading variables from files.
 
 static void
 gripe_unrecognized_float_fmt (void)
@@ -1003,17 +1005,16 @@ do_float_format_conversion (void *data, 
     default:
       (*current_liboctave_error_handler)
         ("impossible state reached in file '%s' at line %d",
          __FILE__, __LINE__);
       break;
     }
 }
 
-
 void
 read_doubles (std::istream& is, double *data, save_type type,
               octave_idx_type len, bool swap,
               oct_mach_info::float_format fmt)
 {
   switch (type)
     {
     case LS_U_CHAR:
@@ -1038,26 +1039,28 @@ read_doubles (std::istream& is, double *
 
     case LS_INT:
       LS_DO_READ (int32_t, swap, data, 4, len, is);
       break;
 
     case LS_FLOAT:
       {
         OCTAVE_LOCAL_BUFFER (float, ptr, len);
-        is.read (reinterpret_cast<char *> (ptr), 4 * len);
+        std::streamsize n_bytes = 4 * len;
+        is.read (reinterpret_cast<char *> (ptr), n_bytes);
         do_float_format_conversion (ptr, len, fmt);
         for (octave_idx_type i = 0; i < len; i++)
           data[i] = ptr[i];
       }
       break;
 
     case LS_DOUBLE: // No conversion necessary.
       {
-        is.read (reinterpret_cast<char *> (data), 8 * len);
+        std::streamsize n_bytes = 8 * static_cast<std::streamsize> (len);
+        is.read (reinterpret_cast<char *> (data), n_bytes);
         do_double_format_conversion (data, len, fmt);
 
         for (int i = 0; i < len; i++)
           data[i] = __lo_ieee_replace_old_NA (data[i]);
       }
       break;
 
     default:
@@ -1093,24 +1096,28 @@ read_floats (std::istream& is, float *da
       LS_DO_READ (int16_t, swap, data, 2, len, is);
       break;
 
     case LS_INT:
       LS_DO_READ (int32_t, swap, data, 4, len, is);
       break;
 
     case LS_FLOAT: // No conversion necessary.
-      is.read (reinterpret_cast<char *> (data), 4 * len);
-      do_float_format_conversion (data, len, fmt);
+      {
+        std::streamsize n_bytes = 4 * len;
+        is.read (reinterpret_cast<char *> (data), n_bytes);
+        do_float_format_conversion (data, len, fmt);
+      }
       break;
 
     case LS_DOUBLE:
       {
         OCTAVE_LOCAL_BUFFER (double, ptr, len);
-        is.read (reinterpret_cast<char *> (ptr), 8 * len);
+        std::streamsize n_bytes = 8 * len;
+        is.read (reinterpret_cast<char *> (ptr), n_bytes);
         do_double_format_conversion (ptr, len, fmt);
         for (octave_idx_type i = 0; i < len; i++)
           data[i] = ptr[i];
       }
       break;
 
     default:
       is.clear (std::ios::failbit|is.rdstate ());
@@ -1151,17 +1158,18 @@ write_doubles (std::ostream& os, const d
     case LS_FLOAT:
       LS_DO_WRITE (float, data, 4, len, os);
       break;
 
     case LS_DOUBLE: // No conversion necessary.
       {
         char tmp_type = static_cast<char> (type);
         os.write (&tmp_type, 1);
-        os.write (reinterpret_cast <const char *> (data), 8 * len);
+        std::streamsize n_bytes = 8 * static_cast<std::streamsize> (len);
+        os.write (reinterpret_cast <const char *> (data), n_bytes);
       }
       break;
 
     default:
       (*current_liboctave_error_handler)
         ("unrecognized data format requested");
       break;
     }
@@ -1196,17 +1204,18 @@ write_floats (std::ostream& os, const fl
     case LS_INT:
       LS_DO_WRITE (int32_t, data, 4, len, os);
       break;
 
     case LS_FLOAT: // No conversion necessary.
       {
         char tmp_type = static_cast<char> (type);
         os.write (&tmp_type, 1);
-        os.write (reinterpret_cast <const char *> (data), 4 * len);
+        std::streamsize n_bytes = 4 * len;
+        os.write (reinterpret_cast <const char *> (data), n_bytes);
       }
       break;
 
     case LS_DOUBLE:
       LS_DO_WRITE (double, data, 8, len, os);
       break;
 
     default:
diff --git a/m4/acinclude.m4 b/m4/acinclude.m4
--- a/m4/acinclude.m4
+++ b/m4/acinclude.m4
@@ -365,20 +365,20 @@ AC_DEFUN([OCTAVE_CHECK_LIB], [
   if test -n "$m4_toupper([$1])_LIBS"; then
     ac_octave_save_CPPFLAGS="$CPPFLAGS"
     ac_octave_save_LDFLAGS="$LDFLAGS"
     ac_octave_save_LIBS="$LIBS"
     CPPFLAGS="$m4_toupper([$1])_CPPFLAGS $CPPFLAGS"
     LDFLAGS="$m4_toupper([$1])_LDFLAGS $LDFLAGS"
     LIBS="$m4_toupper([$1])_LIBS $LIBS"
     m4_ifnblank([$6], [AC_LANG_PUSH($6)])
-    ac_octave_$1_check_for_lib=false
-    m4_ifblank([$4], [ac_octave_$1_check_for_lib=true],
-               [AC_CHECK_HEADERS([$4], [ac_octave_$1_check_for_lib=true; break])])
-    if $ac_octave_$1_check_for_lib; then
+    ac_octave_$1_check_for_lib=no
+    m4_ifblank([$4], [ac_octave_$1_check_for_lib=yes],
+               [AC_CHECK_HEADERS([$4], [ac_octave_$1_check_for_lib=yes; break])])
+    if test $ac_octave_$1_check_for_lib = yes; then
       AC_CACHE_CHECK([for $5 in $m4_toupper([$1])_LIBS],
         [octave_cv_lib_$1],
         [AC_LINK_IFELSE([AC_LANG_CALL([], [$5])],
           [octave_cv_lib_$1=yes], [octave_cv_lib_$1=no])
       ])
       if test "$octave_cv_lib_$1" = yes; then
         m4_ifblank([$8], [
           warn_$1=
@@ -1154,26 +1154,26 @@ AC_DEFUN([OCTAVE_CXX_PLACEMENT_DELETE], 
       [Define to 1 if C++ supports operator delete(void *, void *).])
   fi
 ])
 dnl
 dnl Allow the user disable support for command line editing using GNU
 dnl readline.
 dnl
 AC_DEFUN([OCTAVE_ENABLE_READLINE], [
-  USE_READLINE=true
+  USE_READLINE=yes
   READLINE_LIBS=
   AC_ARG_ENABLE([readline],
     [AS_HELP_STRING([--disable-readline],
       [use readline library])],
     [if test "$enableval" = no; then
-       USE_READLINE=false
+       USE_READLINE=no
        warn_readline="command editing and history features require GNU Readline"
      fi])
-  if $USE_READLINE; then
+  if test $USE_READLINE = yes; then
     dnl RHEL 5 and older systems require termlib set before enabling readline
     AC_REQUIRE([OCTAVE_CHECK_LIB_TERMLIB])
     ac_octave_save_LIBS="$LIBS"
     LIBS="$TERM_LIBS"
     AC_CHECK_LIB([readline], [rl_set_keyboard_input_timeout],
       [READLINE_LIBS="-lreadline"
       AC_DEFINE(USE_READLINE, 1, [Define to 1 to use the readline library.])
       ],
@@ -1667,25 +1667,25 @@ reconstruct the DVI version of the manua
 ])
 dnl
 dnl Check for texi2pdf.
 dnl
 AC_DEFUN([OCTAVE_PROG_TEXI2PDF], [
   AC_REQUIRE([OCTAVE_PROG_TEXI2DVI])
   AC_CHECK_PROG(TEXI2PDF, texi2pdf, texi2pdf, [])
   if test -z "$TEXI2PDF"; then
-    ac_octave_missing=true;
+    ac_octave_texi2pdf_missing=yes;
     if test -n "$TEXI2DVI"; then
       TEXI2PDF="$TEXI2DVI --pdf"
-      ac_octave_missing=false;
+      ac_octave_texi2pdf_missing=no;
     fi
   else
-    ac_octave_missing=false;
+    ac_octave_texi2pdf_missing=no;
   fi
-  if $ac_octave_missing; then
+  if test $ac_octave_texi2pdf_missing = yes; then
     TEXI2PDF='$(top_srcdir)/build-aux/missing texi2pdf'
     warn_texi2pdf="
 
 I didn't find texi2pdf, but it's only a problem if you need to
 reconstruct the PDF version of the manual
 "
     OCTAVE_CONFIGURE_WARNING([warn_texi2pdf])
   fi
diff --git a/scripts/io/strread.m b/scripts/io/strread.m
--- a/scripts/io/strread.m
+++ b/scripts/io/strread.m
@@ -34,17 +34,17 @@
 ## The string @var{format} describes how the words in @var{str} should be
 ## parsed.
 ## It may contain any combination of the following specifiers:
 ##
 ## @table @code
 ## @item %s
 ## The word is parsed as a string.
 ##
-## @itemx %f
+## @item  %f
 ## @itemx %n
 ## The word is parsed as a number and converted to double.
 ##
 ## @item  %d
 ## @itemx %u
 ## The word is parsed as a number and converted to int32.
 ##
 ## @item %*', '%*f', '%*s
diff --git a/scripts/io/textread.m b/scripts/io/textread.m
--- a/scripts/io/textread.m
+++ b/scripts/io/textread.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2009-2012 Eric Chassande-Mottin, CNRS (France)
+## Copyright (C) 2009-2013 Eric Chassande-Mottin, CNRS (France)
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -74,36 +74,48 @@ function varargout = textread (filename,
   ## Read file
   fid = fopen (filename, "r");
   if (fid == -1)
     error ("textread: could not open '%s' for reading", filename);
   endif
 
   ## Skip header lines if requested
   headerlines = find (strcmpi (varargin, "headerlines"), 1);
-  ## Beware of zero valued headerline, fskipl would skip to EOF
-  if (! isempty (headerlines) && (varargin{headerlines + 1} > 0))
-    fskipl (fid, varargin{headerlines + 1});
-    varargin(headerlines:headerlines+1) = [];
+  if (! isempty (headerlines))
+    ## Beware of missing or wrong headerline value
+    if (headerlines  == numel (varargin)
+       || ! isnumeric (varargin{headerlines + 1}))
+      error ("missing or illegal value for 'headerlines'" );
+    endif
+    ## Avoid conveying floats to fskipl
+    varargin{headerlines + 1} = round (varargin{headerlines + 1});
+    ## Beware of zero valued headerline, fskipl would skip to EOF
+    if (varargin{headerlines + 1} > 0)
+      fskipl (fid, varargin{headerlines + 1});
+      varargin(headerlines:headerlines+1) = [];
+      nargin = nargin - 2;
+    elseif (varargin{headerlines + 1} < 0)
+      warning ("textread: negative headerline value ignored");
+    endif
   endif
   st_pos = ftell (fid);
 
   ## Read a first file chunk. Rest follows after endofline processing
   [str, count] = fscanf (fid, "%c", BUFLENGTH);
   if (isempty (str) || count < 1)
     warning ("textread: empty file");
     varargout = cell (1, nargout);
     return;
   endif
 
   endofline = find (strcmpi (varargin, "endofline"), 1);
   if (! isempty (endofline))
     ## 'endofline' option set by user.
     if (! ischar (varargin{endofline + 1}));
-      error ("textread: character value required for EndOfLine");
+      error ("character value required for EndOfLine");
     endif
   else
     ## Determine EOL from file.  Search for EOL candidates in first BUFLENGTH chars
     eol_srch_len = min (length (str), BUFLENGTH);
     ## First try DOS (CRLF)
     if (! isempty (strfind ("\r\n", str(1 : eol_srch_len))))
       eol_char = "\r\n";
     ## Perhaps old Macintosh? (CR)
@@ -183,9 +195,11 @@ endfunction
 %! unlink (f);
 %! assert (a, d(2:7, 1), 1e-2);
 
 %% Test input validation
 %!error textread ()
 %!error textread (1)
 %!error <arguments must be strings> textread (1, "%f")
 %!error <arguments must be strings> textread ("fname", 1)
-
+%!error <missing or illegal value for> textread (file_in_loadpath ("textread.m"), "", "headerlines")
+%!error <missing or illegal value for> textread (file_in_loadpath ("textread.m"), "", "headerlines", 'hh')
+%!error <character value required for> textread (file_in_loadpath ("textread.m"), "%s", "endofline", true)
diff --git a/scripts/io/textscan.m b/scripts/io/textscan.m
--- a/scripts/io/textscan.m
+++ b/scripts/io/textscan.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2010-2012 Ben Abbott <bpabbott@mac.com>
+## Copyright (C) 2010-2013 Ben Abbott <bpabbott@mac.com>
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -162,24 +162,33 @@ function [C, position] = textscan (fid, 
     if (nargout == 2)
       error ("textscan: cannot provide position information for character input");
     endif
     str = fid;
   else
     st_pos = ftell (fid);
     ## Skip header lines if requested
     headerlines = find (strcmpi (args, "headerlines"), 1);
-    ## Beware of zero valued headerline, fskipl would skip to EOF
-    if (! isempty (headerlines) && (args{headerlines + 1} > 0))
-      fskipl (fid, args{headerlines + 1});
-      args(headerlines:headerlines+1) = [];
-      st_pos = ftell (fid);
+    if (! isempty (headerlines))
+      ## Beware of missing or wrong headerline value
+      if (headerlines  == numel (args)
+         || ! isnumeric (args{headerlines + 1}))
+        error ("Missing or illegal value for 'headerlines'" );
+      endif
+      ## Avoid conveying floats to fskipl
+      args{headerlines + 1} = round (args{headerlines + 1});
+      if (args{headerlines + 1} > 0)
+        ## Beware of zero valued headerline, fskipl would skip to EOF
+        fskipl (fid, args{headerlines + 1});
+        args(headerlines:headerlines+1) = [];
+        st_pos = ftell (fid);
+      elseif (args{headerlines + 1} < 0)
+        warning ("textscan.m: negative headerline value ignored");
+      endif
     endif
-    ## Read a first file chunk. Rest follows after endofline processing
-    [str, count] = fscanf (fid, "%c", BUFLENGTH);
   endif
 
   ## Check for empty result
   if (isempty (str))
     warning ("textscan: no data read");
     return;
   endif
 
@@ -492,8 +501,12 @@ endfunction
 %! c = textscan (string, "%s", "delimiter", ";", "whitespace", " ");
 %! for k = 1:numel (c{1})
 %!   lh = c{1}{k};
 %!   rh = tc{k};
 %!   rh(rh == ";") = "";
 %!   rh = strtrim (rh);
 %!   assert (strcmp (lh, rh));
 %! end
+
+%!error <missing or illegal value for> textread (file_in_loadpath ("textscan.m"), "", "headerlines")
+%!error <missing or illegal value for> textread (file_in_loadpath ("textscan.m"), "", "headerlines", 'hh')
+%!error <character value required for> textread (file_in_loadpath ("textscan.m"), "", "endofline", true)
diff --git a/scripts/plot/__gnuplot_drawnow__.m b/scripts/plot/__gnuplot_drawnow__.m
--- a/scripts/plot/__gnuplot_drawnow__.m
+++ b/scripts/plot/__gnuplot_drawnow__.m
@@ -18,41 +18,41 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} __gnuplot_drawnow__ (@var{h}, @var{term}, @var{file}, @var{mono}, @var{debug_file})
 ## Undocumented internal function.
 ## @end deftypefn
 
 ## Author: jwe
 
-function __gnuplot_drawnow__ (h, term, file, mono, debug_file)
+function __gnuplot_drawnow__ (h, term, file, mono = false, debug_file)
 
-  if (nargin < 4)
-    mono = false;
+  if (nargin < 1 || nargin > 5 || nargin == 2)
+    print_usage ();
   endif
 
   if (nargin >= 3 && nargin <= 5)
     ## Produce various output formats, or redirect gnuplot stream to a
     ## debug file.
     plot_stream = [];
     fid = [];
     default_plot_stream = get (h, "__plot_stream__");
     unwind_protect
       plot_stream = __gnuplot_open_stream__ (2, h);
       gnuplot_supports_term = __gnuplot_has_terminal__ (term, plot_stream);
       if (gnuplot_supports_term)
-        enhanced = gnuplot_set_term (plot_stream (1), true, h, term, file);
+        enhanced = gnuplot_set_term (plot_stream(1), true, h, term, file);
         __go_draw_figure__ (h, plot_stream(1), enhanced, mono);
         if (nargin == 5)
           fid = fopen (debug_file, "wb");
           enhanced = gnuplot_set_term (fid, true, h, term, file);
           __go_draw_figure__ (h, fid, enhanced, mono);
         endif
       else
-        error ("__gnuplot_drawnow__: the gnuplot terminal, \"%s\", is not available",
+        error ('__gnuplot_drawnow__: the gnuplot terminal, "%s", is not available',
                gnuplot_trim_term (term));
       endif
     unwind_protect_cleanup
       set (h, "__plot_stream__", default_plot_stream);
       if (! isempty (plot_stream))
         pclose (plot_stream(1));
         if (numel (plot_stream) > 1)
           pclose (plot_stream(2));
@@ -60,71 +60,67 @@ function __gnuplot_drawnow__ (h, term, f
         if (numel (plot_stream) > 2)
           waitpid (plot_stream(3));
         endif
       endif
       if (! isempty (fid))
         fclose (fid);
       endif
     end_unwind_protect
-  elseif (nargin == 1)
+  else  # nargin == 1
     ##  Graphics terminal for display.
     plot_stream = get (h, "__plot_stream__");
     if (isempty (plot_stream))
       plot_stream = __gnuplot_open_stream__ (2, h);
       new_stream = true;
     else
       new_stream = false;
     endif
     term = gnuplot_default_term (plot_stream);
     if (strcmp (term, "dumb"))
       ## popen2 eats stdout of gnuplot, use temporary file instead
       dumb_tmp_file = tmpnam ();
-      enhanced = gnuplot_set_term (plot_stream (1), new_stream, h, ...
+      enhanced = gnuplot_set_term (plot_stream(1), new_stream, h,
                                    term, dumb_tmp_file);
     else
-      enhanced = gnuplot_set_term (plot_stream (1), new_stream, h, term);
+      enhanced = gnuplot_set_term (plot_stream(1), new_stream, h, term);
     endif
-    __go_draw_figure__ (h, plot_stream (1), enhanced, mono);
-    fflush (plot_stream (1));
+    __go_draw_figure__ (h, plot_stream(1), enhanced, mono);
+    fflush (plot_stream(1));
     if (strcmp (term, "dumb"))
       fid = -1;
       while (fid < 0)
         pause (0.1);
         fid = fopen (dumb_tmp_file, 'r');
       endwhile
       ## reprint the plot on screen
       [a, count] = fscanf (fid, '%c', Inf);
       fclose (fid);
-      if (count>0)
-        if (a(1)==12)
-          ## avoid ^L at the beginning
-          a = a(2:end);
+      if (count > 0)
+        if (a(1) == 12)
+          a = a(2:end);  # avoid ^L at the beginning
         endif
         puts (a);
       endif
       unlink (dumb_tmp_file);
     endif
-  else
-    print_usage ();
   endif
 
 endfunction
 
 function enhanced = gnuplot_set_term (plot_stream, new_stream, h, term, file)
   ## Generate the gnuplot "set terminal <term> ..." command.
   ## When "term" originates from print.m, it may include other options.
   if (nargin < 4)
     ## This supports the gnuplot graphics toolkit.
     term = gnuplot_default_term (plot_stream);
     opts_str = "";
   else
-    ## Get the one word terminal id and save the remaining as options to
-    ## be passed on to gnuplot.  The terminal may respect the graphics
-    ## toolkit.
+    ## Get the one word terminal id and save the remaining as options to be
+    ## passed on to gnuplot.  The terminal may respect the graphics toolkit.
     [term, opts_str] = gnuplot_trim_term (term);
     term = lower (term);
     if (strcmp (term, "lua"))
       ## Replace "lua tikz" with just "tikz"
       term = "tikz";
       opts_str = strrep (opts_str, "tikz", "");
     endif
   endif
@@ -144,33 +140,33 @@ function enhanced = gnuplot_set_term (pl
       enh_str = "";
     endif
 
     if (! isempty (h) && isfigure (h))
 
       ## Generate gnuplot title string for plot windows.
       if (output_to_screen (term) && ! strcmp (term, "dumb"))
         fig.numbertitle = get (h, "numbertitle");
-        fig.name = strrep (get (h, "name"), "\"", "\\\"");
+        fig.name = strrep (get (h, "name"), '"', '\"');
         if (strcmp (get (h, "numbertitle"), "on"))
           title_str = sprintf ("Figure %d", h);
         else
           title_str = "";
         endif
         if (! isempty (fig.name) && ! isempty (title_str))
           title_str = sprintf ("%s: %s", title_str, fig.name);
         elseif (! isempty (fig.name) && isempty (title_str))
           title_str = fig.name;
         endif
         if (! isempty (title_str))
-          title_str = sprintf ("title \"%s\"", title_str);
+          title_str = sprintf ('title "%s"', title_str);
         endif
         if (strcmp (term, "aqua"))
           ## Adjust axes-label and tick-label spacing.
-          opts_str = sprintf ("%s font \"%s,%d\"", opts_str,
+          opts_str = sprintf ('%s font "%s,%d"', opts_str,
                               get (0, "defaultaxesfontname"),
                               get (0, "defaultaxesfontsize") / 1.5);
         endif
       else
         title_str = "";
       endif
 
       if (! (any (strfind (opts_str, " size ") > 0)
@@ -190,49 +186,49 @@ function enhanced = gnuplot_set_term (pl
                                       "pbm", "png", "pngcairo", "svg"}))))
           ## Convert to inches
           gnuplot_pos = gnuplot_pos / 72;
           gnuplot_size = gnuplot_size / 72;
         endif
         if (all (gnuplot_size > 0))
           terminals_with_size = {"canvas", "emf", "epslatex", "fig", ...
                                  "gif", "jpeg", "latex", "pbm", "pdf", ...
-                                 "pdfcairo", "postscript", "png", "pngcairo", ...
-                                 "pstex", "pslatex", "svg", "tikz"};
+                                 "pdfcairo", "postscript", "png", ...
+                                 "pngcairo", "pstex", "pslatex", "svg", "tikz"};
           if (__gnuplot_has_feature__ ("windows_figure_position"))
             terminals_with_size{end+1} = "windows";
           endif
           if (__gnuplot_has_feature__ ("x11_figure_position"))
             terminals_with_size{end+1} = "x11";
           endif
           if (__gnuplot_has_feature__ ("wxt_figure_size"))
             terminals_with_size{end+1} = "wxt";
           endif
           switch (term)
-          case terminals_with_size
-            size_str = sprintf ("size %.12g,%.12g", gnuplot_size);
-          case "tikz"
-            size_str = sprintf ("size %gin,%gin", gnuplot_size);
-          case "dumb"
-            new_stream = 1;
-            if (! isempty (getenv ("COLUMNS")) && ! isempty (getenv ("LINES")))
-              ## Let dumb use full text screen size (minus prompt lines).
-              n = sprintf ("%i", -2 - length (find (sprintf ("%s", PS1) == "\n")));
-              ## n = the number of times \n appears in PS1
-              size_str = ["size ", getenv("COLUMNS"), ",", getenv("LINES"), n];
-            else
-              ## Use the gnuplot default.
+            case terminals_with_size
+              size_str = sprintf ("size %.12g,%.12g", gnuplot_size);
+            case "tikz"
+              size_str = sprintf ("size %gin,%gin", gnuplot_size);
+            case "dumb"
+              new_stream = 1;
+              if (! isempty (getenv ("COLUMNS")) && ! isempty (getenv ("LINES")))
+                ## Let dumb use full text screen size (minus prompt lines).
+                n = sprintf ("%i", -2 - length (find (sprintf ("%s", PS1) == "\n")));
+                ## n = the number of times \n appears in PS1
+                size_str = ["size ", getenv("COLUMNS"), ",", getenv("LINES"), n];
+              else
+                ## Use the gnuplot default.
+                size_str = "";
+              endif
+            case {"aqua", "fig", "corel"}
+              size_str = sprintf ("size %g %g", gnuplot_size);
+            case "dxf"
               size_str = "";
-            endif
-          case {"aqua", "fig", "corel"}
-            size_str = sprintf ("size %g %g", gnuplot_size);
-          case "dxf"
-            size_str = "";
-          otherwise
-            size_str = "";
+            otherwise
+              size_str = "";
           endswitch
           if ((strncmpi (term, "x11", 3)
                && __gnuplot_has_feature__ ("x11_figure_position"))
               || (strcmpi (term, "windows")
                   && __gnuplot_has_feature__ ("windows_figure_position")))
             ## X11/Windows allows the window to be positioned as well.
             units = get (0, "units");
             unwind_protect
@@ -264,44 +260,54 @@ function enhanced = gnuplot_set_term (pl
       elseif (! isfigure (h))
         disp ("gnuplot_set_term: not a figure handle");
       endif
       title_str = "";
       size_str = "";
     endif
 
     ## Set the gnuplot terminal (type, enhanced, title, options & size).
-    term_str = sprintf ("set terminal %s", term);
+    term_str = ["set terminal " term];
     if (! isempty (enh_str))
-      term_str = sprintf ("%s %s", term_str, enh_str);
+      term_str = [term_str " " enh_str];
     endif
     if (! isempty (title_str))
-      term_str = sprintf ("%s %s", term_str, title_str);
+      term_str = [term_str " " title_str];
     endif
     if (isempty (strfind (term, "corel")))
       if (! isempty (size_str) && new_stream)
         ## size_str comes after other options to permit specification of
         ## the canvas size for terminals cdr/corel.
-        term_str = sprintf ("%s %s", term_str, size_str);
+        term_str = [term_str " " size_str];
       endif
       if (nargin > 3 && ischar (opts_str))
         ## Options must go last.
-        term_str = sprintf ("%s %s", term_str, opts_str);
+        term_str = [term_str " " opts_str];
       endif
     else
       if (nargin > 3 && ischar (opts_str))
         ## Options must go last.
-        term_str = sprintf ("%s %s", term_str, opts_str);
+        term_str = [term_str " " opts_str];
       endif
       if (! isempty (size_str) && new_stream)
         ## size_str comes after other options to permit specification of
         ## the canvas size for terminals cdr/corel.
-        term_str = sprintf ("%s %s", term_str, size_str);
+        term_str = [term_str " " size_str];
       endif
     endif
+    if (! __gnuplot_has_feature__ ("has_termoption_dashed"))
+      ## If "set termoption dashed" isn't available add "dashed" option
+      ## to the "set terminal ..." command, if it is supported.
+      if (any (strcmpi (term, {"aqua", "cgm", "eepic", "emf", "epslatex", \
+                               "fig", "pcl5", "mp", "next", "openstep", "pdf", \
+                               "pdfcairo", "pngcairo", "postscript", \
+                               "pslatex", "pstext", "svg", "tgif", "x11"})))
+        term_str = [term_str " dashed"];
+      endif
+    end
 
     ## Work around the gnuplot feature of growing the x11 window and
     ## flickering window (x11, windows, & wxt) when the mouse and
     ## multiplot are set in gnuplot.
     fputs (plot_stream, "unset multiplot;\n");
     flickering_terms = {"x11", "windows", "wxt", "dumb"};
     if (! any (strcmp (term, flickering_terms))
         || have_non_legend_axes (h)
@@ -316,27 +322,29 @@ function enhanced = gnuplot_set_term (pl
     elseif (any (strcmp (term, flickering_terms)))
       fprintf (plot_stream, "%s\n", term_str);
       if (nargin == 5)
         if (! isempty (file))
           fprintf (plot_stream, "set output '%s';\n", file);
         endif
       endif
     endif
-    fprintf (plot_stream, "set termoption dashed\n")
+    if (__gnuplot_has_feature__ ("has_termoption_dashed"))
+      fprintf (plot_stream, "set termoption dashed\n")
+    endif
   else
     ## gnuplot will pick up the GNUTERM environment variable itself
     ## so no need to set the terminal type if not also setting the
     ## figure title, enhanced mode, or position.
   endif
 
 endfunction
 
 function term = gnuplot_default_term (plot_stream)
-  term = getenv ("GNUTERM");
+  term = lower (getenv ("GNUTERM"));
   ## If not specified, guess the terminal type.
   if (isempty (term) || ! __gnuplot_has_terminal__ (term, plot_stream))
     if (isguirunning () && __gnuplot_has_terminal__ ("qt", plot_stream))
       term = "qt";
     elseif (ismac ())
       term = "aqua";
     elseif (! isunix ())
       term = "windows";
@@ -345,45 +353,41 @@ function term = gnuplot_default_term (pl
     else
       term = "dumb";
     endif
   endif
 endfunction
 
 function [term, opts] = gnuplot_trim_term (string)
   ## Extract the terminal type and terminal options (from print.m)
-  string = deblank (string);
-  n = strfind (string, ' ');
-  if (isempty (n))
-    term = string;
-    opts = "";
-  else
-    term = string(1:(n-1));
-    opts = string((n+1):end);
+  string = strtrim (string);
+  [term, opts] = strtok (string, ' ');
+  if (! isempty (opts))
+    opts(1) = "";  # trim extra space from strtok
   endif
 endfunction
 
 function have_enhanced = gnuplot_is_enhanced_term (plot_stream, term)
-  persistent enhanced_terminals;
-  if (isempty (enhanced_terminals))
-    ## Don't include pstex, pslatex or epslatex here as the TeX commands
-    ## should not be interpreted in that case.
-    enhanced_terminals = {"aqua", "canvas", "dumb", "emf", "gif", "jpeg", ...
-                          "pdf", "pdfcairo", "pm", "png", "pngcairo", ...
-                          "postscript", "qt", "svg", "windows", "wxt", "x11"};
-  endif
+  ## Don't include pstex, pslatex or epslatex here as the TeX commands
+  ## should not be interpreted in that case.
+  persistent enhanced_terminals = {"aqua", "canvas", "dumb", "emf", "gif", ...
+                                   "jpeg", "pdf", "pdfcairo", "pm", "png", ...
+                                   "pngcairo", "postscript", "qt", "svg",  ...
+                                   "windows", "wxt", "x11"};
+
   if (nargin < 2)
     ## Determine the default gnuplot terminal.
     term = gnuplot_default_term (plot_stream);
   endif
-  have_enhanced = any (strncmp (enhanced_terminals, term, min (numel (term), 3)));
+  have_enhanced = any (strcmp (term, enhanced_terminals));
 endfunction
 
 function ret = output_to_screen (term)
-  ret = any (strcmpi ({"aqua", "dumb", "pm", "qt", "windows", "wxt", "x11"}, term));
+  ret = any (strcmpi (term, 
+                     {"aqua", "dumb", "pm", "qt", "windows", "wxt", "x11"}));
 endfunction
 
 function retval = have_non_legend_axes (h)
   retval = false;
   all_axes = findall (h, "type", "axes");
   if (! isempty (all_axes))
     n_all_axes = numel (all_axes);
     all_axes_tags = get (all_axes, "tag");
diff --git a/scripts/plot/gnuplot_binary.in b/scripts/plot/gnuplot_binary.in
--- a/scripts/plot/gnuplot_binary.in
+++ b/scripts/plot/gnuplot_binary.in
@@ -17,45 +17,49 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Loadable Function} {[@var{prog}, @var{args}] =} gnuplot_binary ()
 ## @deftypefnx {Loadable Function} {[@var{old_prog}, @var{old_args}] =} gnuplot_binary (@var{new_prog}, @var{arg1}, @dots{})
 ## Query or set the name of the program invoked by the plot command
 ## when the graphics toolkit is set to "gnuplot".  Additional arguments to
 ## pass to the external plotting program may also be given.
-## The default value is @code{"gnuplot"} without additional arguments.
+## The default value is @code{"gnuplot"} with no additional arguments.
 ## @xref{Installation}.
+## @seealso{graphics_toolkit}
 ## @end deftypefn
 
 ## Author: jwe
 
 function [prog, args] = gnuplot_binary (new_prog, varargin)
 
   persistent gp_binary = %OCTAVE_CONF_GNUPLOT%;
   persistent gp_args = {};
 
   if (nargout > 0 || nargin == 0)
     prog = gp_binary;
     args = gp_args;
   endif
 
   if (nargin == 1)
-    if (ischar (new_prog))
-      if (! isempty (new_prog))
-	gp_binary = new_prog;
-      else
-	error ("gnuplot_binary: value must not be empty");
-      endif
-    else
-      error ("gnuplot_binary: expecting program to be a character string");
+    if (! ischar (new_prog) || isempty (new_prog))
+      error ("gnuplot_binary: NEW_PROG must be a non-empty string");
     endif
+    gp_binary = new_prog;
   endif
 
   if (nargin > 1)
-    if (iscellstr (varargin))
-      gp_args = varargin;
-    else
-      error ("gnuplot_binary: expecting arguments to be character strings");
+    if (! iscellstr (varargin))
+      error ("gnuplot_binary: arguments must be character strings");
     endif
+    gp_args = varargin;
   endif
 
 endfunction
+
+
+%!test
+%! orig_val = gnuplot_binary ();
+%! old_val = gnuplot_binary ("X");
+%! assert (orig_val, old_val);
+%! assert (gnuplot_binary (), "X");
+%! gnuplot_binary (orig_val);
+%! assert (gnuplot_binary (), orig_val);
diff --git a/scripts/plot/legend.m b/scripts/plot/legend.m
--- a/scripts/plot/legend.m
+++ b/scripts/plot/legend.m
@@ -82,32 +82,32 @@
 ##
 ## @table @asis
 ## @item "show"
 ##   Show legend on the plot
 ##
 ## @item "hide"
 ##   Hide legend on the plot
 ##
-## @itemx "toggle"
+## @item "toggle"
 ##   Toggles between "hide" and "show"
 ##
 ## @item "boxon"
 ##   Show a box around legend
 ##
 ## @item "boxoff"
 ##   Hide the box around legend
 ##
 ## @item "left"
 ##   Place label text to the left of the keys
 ##
 ## @item "right"
 ##   Place label text to the right of the keys
 ##
-## @itemx "off"
+## @item  "off"
 ##   Delete the legend object
 ## @end table
 ##
 ## The optional output values are
 ##
 ## @table @var
 ## @item hleg
 ##   The graphics handle of the legend object.
diff --git a/scripts/plot/newplot.m b/scripts/plot/newplot.m
--- a/scripts/plot/newplot.m
+++ b/scripts/plot/newplot.m
@@ -12,23 +12,27 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} newplot ()
+## @deftypefn  {Function File} {} newplot ()
+## @deftypefnx {Function File} {@var{h} =} newplot ()
 ## Prepare graphics engine to produce a new plot.  This function is
 ## called at the beginning of all high-level plotting functions.
 ## It is not normally required in user programs.
+##
+## The optional return value @var{h} is a graphics handle to the created
+## axes (not figure).
 ## @end deftypefn
 
-function newplot ()
+function h = newplot ()
 
   if (nargin == 0)
     cf = gcf ();
     fnp = get (cf, "nextplot");
     switch (fnp)
       ## FIXME -- probably we should do more than validate the nextplot
       ## property value...
       case "new"
@@ -54,25 +58,29 @@ function newplot ()
       case "replacechildren"
         delete (get (ca, "children"));
       case "replace"
         __go_axes_init__ (ca, "replace");
         __request_drawnow__ ();
       otherwise
         error ("newplot: unrecognized nextplot property for current axes");
     endswitch
+    if (nargout > 0)
+      h = ca;
+    endif
   else
     print_usage ();
   endif
 
 endfunction
 
 
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   p = plot ([0, 1]);
-%!   newplot;
+%!   ha = newplot ();
+%!   assert (ha, gca);
 %!   assert (isempty (get (gca, "children")));
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
 
diff --git a/scripts/plot/plotmatrix.m b/scripts/plot/plotmatrix.m
--- a/scripts/plot/plotmatrix.m
+++ b/scripts/plot/plotmatrix.m
@@ -159,19 +159,19 @@ function [h, ax, p, pax, need_usage] = _
 
   xsize = 0.9 / m;
   ysize = 0.9 / n;
   xoff = 0.05;
   yoff = 0.05;
   border = [0.130, 0.110, 0.225, 0.185] .* [xsize, ysize, xsize, ysize];
   border(3:4) = - border(3:4) - border(1:2);
 
-  for i = 1 : n
-    for j = 1 : m
-      pos = [xsize * (j - 1) + xoff, ysize * (n - i) + yoff, xsize, ysize];
+  for i = 1 : m
+    for j = 1 : n
+      pos = [xsize * (i - 1) + xoff, ysize * (n - j) + yoff, xsize, ysize];
       tmp = axes ("outerposition", pos, "position", pos + border,
                   "parent", parent);
       if (i == j && have_hist)
         pax = [pax ; tmp];
         [nn, xx] = hist (X(:, i));
         tmp = bar (xx, nn, 1.0);
         p = [p; tmp];
       else
diff --git a/scripts/plot/print.m b/scripts/plot/print.m
--- a/scripts/plot/print.m
+++ b/scripts/plot/print.m
@@ -202,21 +202,20 @@
 ##   For a complete list, type `system ("gs -h")' to see what formats
 ## and devices are available.
 ##
 ##   When Ghostscript output is sent to a printer the size is determined
 ## by the figure's "papersize" property.  When the output
 ## is sent to a file the size is determined by the plot box defined by
 ## the figure's "paperposition" property.
 ##
-## @itemx -append
-##   Append Postscript or PDF output to a pre-existing file of the
-## same type.
+## @item -append
+##   Append Postscript or PDF output to a pre-existing file of the same type.
 ##
-## @itemx -r@var{NUM}
+## @item -r@var{NUM}
 ##   Resolution of bitmaps in pixels per inch.  For both metafiles and
 ## SVG the default is the screen resolution; for other formats it is 150 dpi.
 ## To specify screen resolution, use "-r0".
 ##
 ## @item -tight
 ##   Force a tight bounding box for eps files.
 ##
 ## @item -@var{preview}
diff --git a/scripts/plot/private/__gnuplot_get_var__.m b/scripts/plot/private/__gnuplot_get_var__.m
--- a/scripts/plot/private/__gnuplot_get_var__.m
+++ b/scripts/plot/private/__gnuplot_get_var__.m
@@ -19,27 +19,21 @@
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{value} =} __gnuplot_get_var__ (@var{h}, @var{name}, @var{fmt})
 ## Undocumented internal function.
 ## @end deftypefn
 
 ## Author: Ben Abbott <bpabbott@mac.com>
 ## Created: 2009-02-07
 
-function gp_var_value = __gnuplot_get_var__ (h, gp_var_name, fmt)
+function gp_var_value = __gnuplot_get_var__ (h, gp_var_name, fmt = "")
 
-  if (nargin == 0)
-    h = gcf ();
-  endif
   if (nargin < 2)
     print_usage ();
   endif
-  if (nargin < 3)
-    fmt = '';
-  endif
 
   if (numel (h) == 1 && isfigure (h))
     if (isempty (get (gcf, "__plot_stream__")))
       ostream = __gnuplot_open_stream__ (2, h);
     else
       ostream = get (h, "__plot_stream__");
     endif
   else
@@ -60,42 +54,42 @@ function gp_var_value = __gnuplot_get_va
   endif
 
   if (use_mkfifo)
     gpin_name = tmpnam ();
 
     ## Mode: 6*8*8 ==  0600
     [err, msg] = mkfifo (gpin_name, 6*8*8);
 
-    if (err != 0)
-      error ("__gnuplot_get_var__: Can not make fifo (%s)", msg);
+    if (err)
+      error ("__gnuplot_get_var__: Can not make FIFO (%s)", msg);
     endif
   endif
 
   gp_var_name = strtrim (gp_var_name);
   n = min (strfind (gp_var_name, " "), strfind (gp_var_name, ",")) - 1;
   if (isempty (n))
     n = numel (gp_var_name);
   endif
 
   unwind_protect
 
     ## Notes: Variables may be undefined if user closes gnuplot by "q"
-    ## or Alt-F4. Further, this abrupt close also requires the leading
+    ## or Alt-F4.  Further, this abrupt close also requires the leading
     ## "\n" on the next line.
     if (use_mkfifo)
       fprintf (ostream, "\nset print \"%s\";\n", gpin_name);
       fflush (ostream);
       [gpin, err] = fopen (gpin_name, "r");
-      if (err != 0)
+      if (err)
         ## Try a second time, and then give an error.
         [gpin, err] = fopen (gpin_name, "r");
       endif
-      if (err != 0)
-        error ("__gnuplot_get_var__: can not open fifo");
+      if (err)
+        error ("__gnuplot_get_var__: can not open FIFO");
       endif
       gp_cmd = sprintf ("\nif (exists(\"%s\")) print %s; else print NaN\n",
                         gp_var_name(1:n), gp_var_name);
       fputs (ostream, gp_cmd);
 
       ## Close output file, to force it to be flushed
       fputs (ostream, "set print;\n");
       fflush (ostream);
@@ -121,30 +115,29 @@ function gp_var_value = __gnuplot_get_va
       fputs (ostream, gp_cmd);
       fflush (ostream);
       ## Direct gnuplot to print to <STDERR>
       fputs (ostream, "set print;\n");
       fflush (ostream);
 
       str = {};
       while (isempty (str))
-        str = char (fread (istream)');
+        str = fread (istream, "*char")';
         if (isempty (str))
           sleep (0.05);
         else
           str = regexp (str, 'OCTAVE:.*', "match");
           str = str{end}(8:end);
         endif
         fclear (istream);
       endwhile
     endif
 
     ## Strip out EOLs and the continuation character "|"
-    str(str=="\n") = "";
-    str(str=="\r") = "";
+    str(str=="\n" | str=="\r") = "";
     n_continue = strfind (str, " \\ ");
     if (! isempty (n_continue))
       str(n_continue+1) = "";
     endif
 
     if (isempty (fmt))
       gp_var_value = strtrim (str);
     else
diff --git a/scripts/plot/private/__gnuplot_ginput__.m b/scripts/plot/private/__gnuplot_ginput__.m
--- a/scripts/plot/private/__gnuplot_ginput__.m
+++ b/scripts/plot/private/__gnuplot_ginput__.m
@@ -26,52 +26,52 @@
 
 ## This file initially bore the copyright statement
 ## Petr Mikulik
 ## History: June 2006; August 2005; June 2004; April 2004
 ## License: public domain
 
 function [x, y, button] = __gnuplot_ginput__ (f, n)
 
+  if (compare_versions (__gnuplot_version__ (), "4.0", "<="))
+    error ("ginput: version %s of gnuplot not supported", gnuplot_version ());
+  endif
+
   ostream = get (f, "__plot_stream__");
   if (numel (ostream) < 1)
     error ("ginput: stream to gnuplot not open");
   elseif (ispc ())
     if (numel (ostream) == 1)
       error ("ginput: Need mkfifo that is not implemented under Windows");
     endif
     use_mkfifo = false;
     istream = ostream(2);
     ostream = ostream(1);
   else
     use_mkfifo = true;
     ostream = ostream(1);
   endif
 
-  if (compare_versions (__gnuplot_version__ (), "4.0", "<="))
-    error ("ginput: version %s of gnuplot not supported", gnuplot_version ());
-  endif
-
   if (nargin == 1)
     x = zeros (100, 1);
     y = zeros (100, 1);
     button = zeros (100, 1);
   else
     x = zeros (n, 1);
     y = zeros (n, 1);
     button = zeros (n, 1);
   endif
 
   if (use_mkfifo)
     gpin_name = tmpnam ();
 
     ##Mode: 6*8*8 ==  0600
     [err, msg] = mkfifo (gpin_name, 6*8*8);
 
-    if (err != 0)
+    if (err)
       error ("ginput: Can not open fifo (%s)", msg);
     endif
   endif
 
   unwind_protect
 
     k = 0;
     while (true)
@@ -79,42 +79,42 @@ function [x, y, button] = __gnuplot_ginp
 
       ## Notes: MOUSE_* can be undefined if user closes gnuplot by "q"
       ## or Alt-F4. Further, this abrupt close also requires the leading
       ## "\n" on the next line.
       if (use_mkfifo)
         fprintf (ostream, "set print \"%s\";\n", gpin_name);
         fflush (ostream);
         [gpin, err] = fopen (gpin_name, "r");
-        if (err != 0)
-          error ("ginput: Can not open fifo (%s)", msg);
+        if (err)
+          error ("ginput: Can not open FIFO (%s)", msg);
         endif
         fputs (ostream, "pause mouse any;\n\n");
         fputs (ostream, "\nif (exists(\"MOUSE_KEY\") && exists(\"MOUSE_X\")) print MOUSE_X, MOUSE_Y, MOUSE_KEY; else print \"0 0 -1\"\n");
 
         ## Close output file, to force it to be flushed
         fputs (ostream, "set print;\n");
         fflush (ostream);
 
         ## Now read from fifo.
         [x(k), y(k), button(k), count] = fscanf (gpin, "%f %f %d", "C");
         fclose (gpin);
       else
-        fprintf (ostream, "set print \"-\";\n");
+        fputs (ostream, "set print \"-\";\n");
         fflush (ostream);
         fputs (ostream, "pause mouse any;\n\n");
         fputs (ostream, "\nif (exists(\"MOUSE_KEY\") && exists(\"MOUSE_X\")) print \"OCTAVE: \", MOUSE_X, MOUSE_Y, MOUSE_KEY; else print \"0 0 -1\"\n");
 
         ## Close output file, to force it to be flushed
         fputs (ostream, "set print;\n");
         fflush (ostream);
 
         str = {};
         while (isempty (str))
-          str = char (fread (istream)');
+          str = fread (istream, "*char")';
           if (isempty (str))
             sleep (0.05);
           else
             str = regexp (str, 'OCTAVE:\s+[-+.\d]+\s+[-+.\d]+\s+\d*', 'match');
           endif
           fclear (istream);
         endwhile
         [x(k), y(k), button(k), count] = sscanf (str{end}(8:end), "%f %f %d", "C");
diff --git a/scripts/plot/private/__gnuplot_has_feature__.m b/scripts/plot/private/__gnuplot_has_feature__.m
--- a/scripts/plot/private/__gnuplot_has_feature__.m
+++ b/scripts/plot/private/__gnuplot_has_feature__.m
@@ -20,43 +20,45 @@
 ## @deftypefn {Function File} {@var{has_feature} =} __gnuplot_has_feature__ (@var{feature})
 ## Undocumented internal function.
 ## @end deftypefn
 
 ## Author: Ben Abbott <bpabbott@mac.com>
 ## Created: 2009-01-27
 
 function res = __gnuplot_has_feature__ (feature)
-  persistent features has_features
-  features = {"x11_figure_position",
-              "wxt_figure_size",
-              "transparent_patches",
-              "transparent_surface",
-              "epslatex_implies_eps_filesuffix",
-              "epslatexstandalone_terminal",
-              "screen_coordinates_for_{lrtb}margin",
-              "variable_GPVAL_TERMINALS",
-              "key_has_font_properties",
-              "windows_figure_position"};
+  persistent features = {"x11_figure_position",
+                         "wxt_figure_size",
+                         "transparent_patches",
+                         "transparent_surface",
+                         "epslatex_implies_eps_filesuffix",
+                         "epslatexstandalone_terminal",
+                         "screen_coordinates_for_{lrtb}margin",
+                         "variable_GPVAL_TERMINALS",
+                         "key_has_font_properties",
+                         "windows_figure_position",
+                         "has_termoption_dashed"};
+  persistent has_features;
 
   if (isempty (has_features))
     try
       gnuplot_version = __gnuplot_version__ ();
     catch
       ## Don't throw an error if gnuplot isn't installed
       gnuplot_version = "0.0.0";
     end_try_catch
-    versions = {"4.2.5", "4.4", "4.4", "4.4", "4.2", "4.2", "4.4", "4.4", "4.4", "4.4"};
-    operators = {">=", ">=", ">=", ">=", ">=", ">=", ">=", ">=", ">=", ">="};
-    have_features = logical (zeros (size (features)));
+    versions = {"4.2.5", "4.4", "4.4", "4.4", "4.2", "4.2", "4.4", "4.4", "4.4", "4.4", "4.3"};
+    operators = {">=", ">=", ">=", ">=", ">=", ">=", ">=", ">=", ">=", ">=", ">="};
+    have_features = false (size (features));
     for n = 1 : numel (have_features)
       has_features(n) = compare_versions (gnuplot_version, versions{n}, operators{n});
     endfor
   endif
 
   n = find (strcmpi (feature, features));
   if (isempty (n))
     res = NaN;
   else
     res = has_features(n);
   endif
+
 endfunction
 
diff --git a/scripts/plot/private/__gnuplot_has_terminal__.m b/scripts/plot/private/__gnuplot_has_terminal__.m
--- a/scripts/plot/private/__gnuplot_has_terminal__.m
+++ b/scripts/plot/private/__gnuplot_has_terminal__.m
@@ -20,21 +20,20 @@
 ## @deftypefn {Function File} {@var{has_terminal} =} __gnuplot_has_terminal__ (@var{terminal})
 ## Undocumented internal function.
 ## @end deftypefn
 
 ## Author: Ben Abbott <bpabbott@mac.com>
 ## Created: 2010-09-13
 
 function gnuplot_supports_term = __gnuplot_has_terminal__ (term, plot_stream)
-  term = deblank (term);
-  n = find (term == " ", 1);
-  if (! isempty (n))
-    term = term(1:n-1);
-  endif
+
+  term = strtrim (term);
+  term = lower (strtok (term, " "));
+
   if (__gnuplot_has_feature__ ("variable_GPVAL_TERMINALS"))
     if (nargin < 2)
       plot_stream = __gnuplot_open_stream__ (2);
     endif
     available_terminals = __gnuplot_get_var__ (plot_stream, "GPVAL_TERMINALS");
     available_terminals = regexp (available_terminals, '\w+', "match");
     if (nargin < 2 && ! isempty (plot_stream))
       pclose (plot_stream(1));
@@ -54,11 +53,13 @@ function gnuplot_supports_term = __gnupl
                            "gpic", "hp2623A", "hp2648", "hp500c", ...
                            "hpgl", "hpljii", "hppj", "imagen", "jpeg", ...
                            "latex", "mf", "mif", "mp", "pbm", "pdf", ...
                            "pm", "png", "postscript", "pslatex", ...
                            "pstex", "pstricks", "qms", "regis", "rgip", ...
                            "svg", "texdraw", "tgif", "tkcanvas", ...
                            "tpic", "windows", "x11", "xlib", "xterm"};
   endif
-  gnuplot_supports_term = any (strcmpi (available_terminals, term));
+
+  gnuplot_supports_term = any (strcmp (term, available_terminals));
+
 endfunction
 
diff --git a/scripts/plot/private/__gnuplot_print__.m b/scripts/plot/private/__gnuplot_print__.m
--- a/scripts/plot/private/__gnuplot_print__.m
+++ b/scripts/plot/private/__gnuplot_print__.m
@@ -46,25 +46,25 @@ function opts = __gnuplot_print__ (opts)
   ## the font spec given in "set terminal ..."
   gp_opts = font_spec (opts);
 
   pipeline = "";
 
   switch (lower (opts.devopt))
   case {"eps", "eps2", "epsc", "epsc2"}
     if (any (strcmp (opts.devopt, {"eps", "epsc"})))
-      gp_opts = sprintf ("%s level1", gp_opts);
+      gp_opts = [gp_opts " level1"];
     endif
     if (opts.tight_flag || ! isempty (opts.preview))
       tmp_file = strcat (tmpnam (), ".eps");
       eps_drawnow (opts, tmp_file, gp_opts);
       if (dos_shell)
-        cleanup = sprintf (" & del %s", strrep (tmp_file, '/', '\'));
+        cleanup = [" & del " strrep(tmp_file, '/', '\')];
       else
-        cleanup = sprintf (" ; rm %s", tmp_file);
+        cleanup = [" ; rm " tmp_file];
       endif
       pipeline = {sprintf("%s %s",
                           opts.epstool_cmd (opts, tmp_file, opts.name),
                           cleanup)};
     else
       eps_drawnow (opts, opts.name, gp_opts);
     endif
   case {"epslatex", "pslatex", "pstex", "epslatexstandalone"}
@@ -84,65 +84,65 @@ function opts = __gnuplot_print__ (opts)
       term = sprintf ("%s ",
                       strrep (opts.devopt, "standalone", " standalone"));
     else
       term = sprintf ("%s ", opts.devopt);
     endif
     if (__gnuplot_has_feature__ ("epslatex_implies_eps_filesuffix"))
       suffix = "tex";
     else
-      %% Gnuplot 4.0 wants a ".eps" suffix.
+      ## Gnuplot 4.0 wants a ".eps" suffix.
       suffix = "eps";
     endif
-    local_drawnow (sprintf ("%s %s", term, gp_opts),
+    local_drawnow ([term " " gp_opts],
                    strcat (name, ".", suffix), opts);
   case "tikz"
     if (__gnuplot_has_terminal__ ("tikz"))
-      local_drawnow (sprintf ("lua tikz %s", gp_opts), opts.name, opts);
+      local_drawnow (["lua tikz " gp_opts], opts.name, opts);
     else
       error (sprintf ("print:no%soutput", opts.devopt),
              "print.m: '%s' output is not available for gnuplot-%s",
              upper (opts.devopt), __gnuplot_version__ ());
     endif
   case "svg"
-    local_drawnow (sprintf ("svg dynamic %s", gp_opts), opts.name, opts);
+    local_drawnow (["svg dynamic " gp_opts], opts.name, opts);
   case {"aifm", "corel", "eepic", "emf", "fig"}
-    local_drawnow (sprintf ("%s %s", opts.devopt, gp_opts), opts.name, opts);
+    local_drawnow ([opts.devopt " " gp_opts], opts.name, opts);
   case {"pdfcairo", "pngcairo"}
     if (__gnuplot_has_terminal__ (opts.devopt))
-      local_drawnow (sprintf ("%s %s", opts.devopt, gp_opts), opts.name, opts);
+      local_drawnow ([opts.devopt " " gp_opts], opts.name, opts);
     else
       error (sprintf ("print:no%soutput", opts.devopt),
              "print.m: '%s' output is not available for gnuplot-%s",
              upper (opts.devopt), __gnuplot_version__ ());
     endif
   case {"canvas", "dxf", "hpgl", "mf", "gif", "pstricks", "texdraw"}
-    local_drawnow (sprintf ("%s %s", opts.devopt, gp_opts), opts.name, opts);
+    local_drawnow ([opts.devopt " " gp_opts], opts.name, opts);
   case opts.ghostscript.device
     gp_opts = font_spec (opts, "devopt", "eps");
     opts.ghostscript.output = opts.name;
     opts.ghostscript.source = strcat (tmpnam (), ".eps");
     eps_drawnow (opts, opts.ghostscript.source, gp_opts);
     [cmd_gs, cmd_cleanup] = __ghostscript__ (opts.ghostscript);
     if (opts.send_to_printer || isempty (opts.name))
       cmd_lpr = opts.lpr_cmd (opts);
-      cmd = sprintf ("%s | %s", cmd_gs, cmd_lpr);
+      cmd = [cmd_gs " | " cmd_lpr];
     else
-      cmd = sprintf ("%s", cmd_gs);
+      cmd = cmd_gs;
     endif
     if (dos_shell)
       cmd = sprintf ("%s & del %s", cmd, strrep (opts.ghostscript.source, '/', '\'));
     else
       cmd = sprintf ("%s ; rm %s", cmd, opts.ghostscript.source);
     endif
     if (! isempty (cmd_cleanup))
       if (dos_shell)
-        pipeline = {sprintf("%s & %s", cmd, cmd_cleanup)};
+        pipeline = {[cmd " & " cmd_cleanup]};
       else
-        pipeline = {sprintf("%s ; %s", cmd, cmd_cleanup)};
+        pipeline = {[cmd " ; " cmd_cleanup]};
       endif
     else
       pipeline = {cmd};
     endif
   otherwise
     error (sprintf ("print:no%soutput", opts.devopt),
            "print.m: %s output is not available for the Gnuplot graphics toolkit",
            upper (opts.devopt));
@@ -165,24 +165,21 @@ function opts = __gnuplot_print__ (opts)
     endif
   endfor
 
 endfunction
 
 function eps_drawnow (opts, epsfile, gp_opts)
   [h, fontsize] = get_figure_text_objs (opts);
   unwind_protect
-    for n = 1:numel (h)
-      set (h(n), "fontsize", 2 * fontsize{n});
-    endfor
-    local_drawnow (sprintf ("postscript eps %s", gp_opts), epsfile, opts);
+    fontsize_2x = cellfun (@(x) 2*x, fontsize, "uniformoutput", false);
+    set (h, {"fontsize"}, fontsize_2x);
+    local_drawnow (["postscript eps " gp_opts], epsfile, opts);
   unwind_protect_cleanup
-    for n = 1:numel (h)
-      set (h(n), "fontsize", fontsize{n});
-    endfor
+    set (h, {"fontsize"}, fontsize);
   end_unwind_protect
 endfunction
 
 function local_drawnow (term, file, opts)
   if (opts.use_color < 0)
     mono = true;
   else
     mono = false;
@@ -198,81 +195,81 @@ endfunction
 function f = font_spec (opts, varargin)
   for n = 1:2:numel (varargin)
     opts.(varargin{n}) = varargin{n+1};
   endfor
   f = "";
   switch (opts.devopt)
   case "cgm"
     if (! isempty (opts.font) && ! isempty (opts.fontsize))
-      f = sprintf ("font ""%s,%d""", opts.font, opts.fontsize);
+      f = sprintf ('font "%s,%d"', opts.font, opts.fontsize);
     elseif (! isempty (opts.font))
-      f = sprintf ("font ""%s""", opts.font);
+      f = sprintf ('font "%s"', opts.font);
     elseif (! isempty (opts.fontsize))
       f = sprintf ("%d", opts.fontsize);
     endif
   case {"eps", "eps2", "epsc", "epsc2"}
     ## Gnuplot renders fonts as half their specification, which
     ## results in a tight spacing for the axes-labels and tick-labels.
     ## Compensate for the half scale. This will produce the proper
     ## spacing for the requested fontsize.
     if (! isempty (opts.font) && ! isempty (opts.fontsize))
-      f = sprintf ("font ""%s,%d""", opts.font, 2 * opts.fontsize);
+      f = sprintf ('font "%s,%d"', opts.font, 2 * opts.fontsize);
     elseif (! isempty (opts.font))
-      f = sprintf ("font ""%s""", opts.font);
+      f = sprintf ('font "%s"', opts.font);
     elseif (! isempty (opts.fontsize))
       f = sprintf ("%d", 2 * opts.fontsize);
     endif
   case "svg"
     if (! isempty (opts.font) && ! isempty (opts.fontsize))
       fontsize = round (opts.fontsize * 0.75);
-      f = sprintf ("fname ""%s"" fsize %d", opts.font, fontsize);
+      f = sprintf ('fname "%s" fsize %d', opts.font, fontsize);
     elseif (! isempty (opts.font))
-      f = sprintf ("fname ""%s""", opts.font);
+      f = sprintf ('fname "%s"', opts.font);
     elseif (! isempty (opts.fontsize))
       fontsize = round (opts.fontsize * 0.75);
       f = sprintf ("%s fsize %d", f, fontsize);
     endif
   case "pdf"
     if (! isempty (opts.font) && ! isempty (opts.fontsize))
-      f = sprintf ("font ""%s,%d""", opts.font, opts.fontsize);
+      f = sprintf ('font "%s,%d"', opts.font, opts.fontsize);
     elseif (! isempty (opts.font))
-      f = sprintf ("font ""%s""", opts.font);
+      f = sprintf ('font "%s"', opts.font);
     elseif (! isempty (opts.fontsize))
       f = sprintf ("fsize %d", f, opts.fontsize);
     endif
   case {"pdfcairo", "pngcairo"}
     if (! isempty (opts.font))
-      f = sprintf ("font ""%s""", opts.font);
+      f = sprintf ('font "%s"', opts.font);
     endif
   case {"epslatex", "epslatexstandalone"}
     if (! isempty (opts.font) && ! isempty (opts.fontsize))
-      f = sprintf ("font ""%s,%d""", opts.font, opts.fontsize);
+      f = sprintf ('font "%s,%d"', opts.font, opts.fontsize);
     elseif (! isempty (opts.font))
-      f = sprintf ("font ""%s""", opts.font);
+      f = sprintf ('font "%s"', opts.font);
     elseif (! isempty (opts.fontsize))
       f = sprintf ("%d", opts.fontsize);
     endif
   case "pslatex"
     if (! isempty (opts.fontsize))
       f = sprintf ("%d", opts.fontsize);
     endif
   case {"gif", "jpeg", "png"}
     if (! isempty (opts.font) && ! isempty (opts.fontsize))
-      f = sprintf ("font ""%s ,%d""", opts.font, opts.fontsize);
+      f = sprintf ('font "%s ,%d"', opts.font, opts.fontsize);
     elseif (! isempty (opts.font))
-      f = sprintf ("font ""%s""", opts.font);
+      f = sprintf ('font "%s"', opts.font);
     elseif (! isempty (opts.fontsize))
-      f = sprintf ("font ""%d""", opts.fontsize);
+      f = sprintf ('font "%d"', opts.fontsize);
     endif
   case "emf"
     if (! isempty (opts.font) && ! isempty (opts.fontsize))
-      f = sprintf ("""%s"" %d", opts.font, opts.fontsize);
+      f = sprintf ('"%s" %d', opts.font, opts.fontsize);
     elseif (! isempty (opts.font))
-      f = sprintf ("""%s""", opts.font);
+      f = sprintf ('"%s"', opts.font);
     elseif (! isempty (opts.fontsize))
       f = sprintf ("%d", opts.fontsize);
     endif
   case "canvas"
     if (! isempty (opts.fontsize))
       f = sprintf ("fsize %d", opts.fontsize);
     endif
   case {"aifm", "corel"}
diff --git a/scripts/plot/private/__gnuplot_version__.m b/scripts/plot/private/__gnuplot_version__.m
--- a/scripts/plot/private/__gnuplot_version__.m
+++ b/scripts/plot/private/__gnuplot_version__.m
@@ -25,22 +25,22 @@
 ## attempt to handle the case of the user switching to different
 ## versions of gnuplot during the same session.
 
 function version = __gnuplot_version__ ()
 
   persistent __version__ = "";
 
   if (isempty (__version__))
-    [status, output] = system (sprintf ("\"%s\" --version", gnuplot_binary ()));
+    [status, output] = system (sprintf ('"%s" --version', gnuplot_binary ()));
     if (status != 0)
       ## This message ends in a newline so that the traceback messages
       ## are skipped and people might actually see the message, read it,
-      ## comprehend it, actually take the advice it gives, and stop
-      ## asking us why plotting fails when gnuplot is not found.
+      ## comprehend it, take the advice it gives, and stop asking us
+      ## why plotting fails when gnuplot is not found.
       error ("you must have gnuplot installed to display graphics; if you have gnuplot installed in a non-standard location, see the 'gnuplot_binary' function\n");
     endif
     output = strrep (output, "gnuplot", "");
     output = strrep (output, "patchlevel", ".");
     output = strrep (output, "\n", "");
     output = strrep (output, "\r", "");
     __version__ = strrep (output, " ", "");
   endif
diff --git a/scripts/plot/stemleaf.m b/scripts/plot/stemleaf.m
--- a/scripts/plot/stemleaf.m
+++ b/scripts/plot/stemleaf.m
@@ -198,17 +198,17 @@ function varargout = stemleaf (x, stem_u
   for kx = 2:nstems
     line_out = "";
     steml    = "";
     ## Build a string of leaf digits for stem(kx) if stem(kx) <= 0, or
     ## stem(kx-1) if stem(kx) > 0
 
     ## stems -+ 0 have to be handled as special cases.
     for xi = 1:nx
-      if(signbit(stems(kx)) == 1)
+      if(signbit(stems(kx)) != 0)
         t1 = ((x(xi) <= stems(kx)*10) && (x(xi) > (stems(kx-1)*10)));
       else
         t1 = ((x(xi) < stems(kx)*10) && (x(xi) >= (stems(kx-1)*10)));
       endif
       ## Special tests for stem -+ 0
       if ((stems(kx) == 0) && signbit(stems(kx)) && (x(xi) == 0)) && !signbit(x(xi))
         t1 = 0;
       endif
diff --git a/scripts/statistics/distributions/binopdf.m b/scripts/statistics/distributions/binopdf.m
--- a/scripts/statistics/distributions/binopdf.m
+++ b/scripts/statistics/distributions/binopdf.m
@@ -59,16 +59,22 @@ function pdf = binopdf (x, n, p)
   if (isscalar (n) && isscalar (p))
     pdf(k) = exp (gammaln (n+1) - gammaln (x(k)+1) - gammaln (n-x(k)+1)
                   + x(k)*log (p) + (n-x(k))*log (1-p));
   else
     pdf(k) = exp (gammaln (n(k)+1) - gammaln (x(k)+1) - gammaln (n(k)-x(k)+1)
                   + x(k).*log (p(k)) + (n(k)-x(k)).*log (1-p(k)));
   endif
 
+  ## Special case inputs
+  ksp = k & (p == 0) & (x == 0);
+  pdf(ksp) = 1; 
+  ksp = k & (p == 1) & (x == n);
+  pdf(ksp) = 1; 
+
 endfunction
 
 
 %!shared x,y,tol
 %! if (ismac ())
 %!   tol = eps ();
 %! else
 %!   tol = 0;
@@ -77,16 +83,21 @@ endfunction
 %! y = [0 1/4 1/2 1/4 0];
 %!assert (binopdf (x, 2*ones (1,5), 0.5*ones (1,5)), y, tol)
 %!assert (binopdf (x, 2, 0.5*ones (1,5)), y, tol)
 %!assert (binopdf (x, 2*ones (1,5), 0.5), y, tol)
 %!assert (binopdf (x, 2*[0 -1 NaN 1.1 1], 0.5), [0 NaN NaN NaN 0])
 %!assert (binopdf (x, 2, 0.5*[0 -1 NaN 3 1]), [0 NaN NaN NaN 0])
 %!assert (binopdf ([x, NaN], 2, 0.5), [y, NaN], tol)
 
+## Test Special input values
+%!assert (binopdf (0, 3, 0), 1);
+%!assert (binopdf (2, 2, 1), 1);
+%!assert (binopdf (1, 2, 1), 0);
+
 %% Test class of input preserved
 %!assert (binopdf (single ([x, NaN]), 2, 0.5), single ([y, NaN]))
 %!assert (binopdf ([x, NaN], single (2), 0.5), single ([y, NaN]))
 %!assert (binopdf ([x, NaN], 2, single (0.5)), single ([y, NaN]))
 
 %% Test input validation
 %!error binopdf ()
 %!error binopdf (1)
diff --git a/scripts/time/datetick.m b/scripts/time/datetick.m
--- a/scripts/time/datetick.m
+++ b/scripts/time/datetick.m
@@ -17,23 +17,22 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} datetick ()
 ## @deftypefnx {Function File} {} datetick (@var{form})
 ## @deftypefnx {Function File} {} datetick (@var{axis}, @var{form})
 ## @deftypefnx {Function File} {} datetick (@dots{}, "keeplimits")
 ## @deftypefnx {Function File} {} datetick (@dots{}, "keepticks")
-## @deftypefnx {Function File} {} datetick (@dots{ax}, @dots{})
-## Add date formatted tick labels to an axis.  The axis the apply the
-## ticks to is determined by @var{axis} that can take the values "x",
-## "y" or "z".  The default value is "x".  The formatting of the labels is
-## determined by the variable @var{form}, that can either be a string in
-## the format needed by @code{dateform}, or a positive integer that can
-## be accepted by @code{datestr}.
+## @deftypefnx {Function File} {} datetick (@var{hax}, @dots{})
+## Add date formatted tick labels to an axis.  The axis to apply the
+## ticks to is determined by @var{axis} which can take the values "x",
+## "y", or "z".  The default value is "x".  The formatting of the labels is
+## determined by the variable @var{form}, which can either be a string or
+## positive integer that @code{datestr} accepts.
 ## @seealso{datenum, datestr}
 ## @end deftypefn
 
 function datetick (varargin)
 
   [h, varargin, nargin] = __plt_get_axis_arg__ ("datetick", varargin{:});
 
   oldh = gca ();
diff --git a/test/classes/@CPrecedenceTester1/CPrecedenceTester1.m b/test/classes/@CPrecedenceTester1/CPrecedenceTester1.m
new file mode 100644
--- /dev/null
+++ b/test/classes/@CPrecedenceTester1/CPrecedenceTester1.m
@@ -0,0 +1,8 @@
+function x = CPrecedenceTester1()
+
+  x = struct('useless_data', pi);
+  x = class(x, 'CPrecedenceTester1');
+
+  % don't change anything as far as precedence is concerned
+
+end
diff --git a/test/classes/@CPrecedenceTester1/tattack.m b/test/classes/@CPrecedenceTester1/tattack.m
new file mode 100644
--- /dev/null
+++ b/test/classes/@CPrecedenceTester1/tattack.m
@@ -0,0 +1,5 @@
+function s = tattack(x, y)
+  
+  s = 'CPrecedenceTester1';
+  
+end
diff --git a/test/classes/@CPrecedenceTester2/CPrecedenceTester2.m b/test/classes/@CPrecedenceTester2/CPrecedenceTester2.m
new file mode 100644
--- /dev/null
+++ b/test/classes/@CPrecedenceTester2/CPrecedenceTester2.m
@@ -0,0 +1,15 @@
+function x = CPrecedenceTester2(flag)
+
+  x = struct('useless_data', pi^2);
+  x = class(x, 'CPrecedenceTester2');
+
+  switch flag,
+    case 1, % CPrecedencetester2 > Snork
+      superiorto('Snork');
+    case 2, % CPrecedencetester2 < Snork
+      inferiorto('Snork');
+    otherwise,
+      error('Incorrect value for argument flag: %d', flag);
+  end
+
+end
diff --git a/test/classes/@CPrecedenceTester2/tattack.m b/test/classes/@CPrecedenceTester2/tattack.m
new file mode 100644
--- /dev/null
+++ b/test/classes/@CPrecedenceTester2/tattack.m
@@ -0,0 +1,5 @@
+function s = tattack(x, y)
+  
+  s = 'CPrecedenceTester2';
+  
+end
diff --git a/test/classes/@CPrecedenceTester3/CPrecedenceTester3.m b/test/classes/@CPrecedenceTester3/CPrecedenceTester3.m
new file mode 100644
--- /dev/null
+++ b/test/classes/@CPrecedenceTester3/CPrecedenceTester3.m
@@ -0,0 +1,15 @@
+function x = CPrecedenceTester3(flag)
+
+  x = struct('useless_data', pi^3);
+  x = class(x, 'CPrecedenceTester3');
+
+  switch flag,
+    case 1, % CPrecedencetester3 > Snork
+      superiorto('Snork');
+    case 2, % CPrecedencetester3 < Snork
+      inferiorto('Snork');
+    otherwise,
+      error('Incorrect value for argument flag: %d', flag);
+  end
+
+end
diff --git a/test/classes/@CPrecedenceTester3/tattack.m b/test/classes/@CPrecedenceTester3/tattack.m
new file mode 100644
--- /dev/null
+++ b/test/classes/@CPrecedenceTester3/tattack.m
@@ -0,0 +1,5 @@
+function s = tattack(x, y)
+  
+  s = 'CPrecedenceTester3';
+  
+end
diff --git a/test/classes/@Snork/tattack.m b/test/classes/@Snork/tattack.m
new file mode 100644
--- /dev/null
+++ b/test/classes/@Snork/tattack.m
@@ -0,0 +1,5 @@
+function s = tattack(x, y)
+  
+  s = 'Snork';
+  
+end
diff --git a/test/classes/classes.tst b/test/classes/classes.tst
--- a/test/classes/classes.tst
+++ b/test/classes/classes.tst
@@ -299,20 +299,64 @@
 %!assert (s1 <= (x1 + 1))
 %!assert (x1 <= (s1 + 1))
 
 %% Test overloaded gt (>=) for the Snork class
 %!assert (s1 >= (s1 - 1))
 %!assert (s1 >= (x1 - 1))
 %!assert (x1 >= (s1 - 1))
 
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+%% Testing horizontal & vertical concatenation %%
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+
 %% Test overloaded vertcat() for the Snork class
 %% See bug #38170 (http://savannah.gnu.org/bugs/?38170)
 %!test   s = [s1; s2];  assert (isa (s, 'Snork') && isequal (s.gick, [x1; x2]));
 %!xtest  s = [s1; x2];  assert (isa (s, 'Snork') && isequal (s.gick, [x1; x2]));
 %!xtest  s = [x1; s2];  assert (isa (s, 'Snork') && isequal (s.gick, [x1; x2]));
 
 %% Test overloaded horzcat() for the Snork class
 %% See bug #38170 (http://savannah.gnu.org/bugs/?38170)
 %!test   s = [s1 s2];  assert (isa (s, 'Snork') && isequal (s.gick, [x1 x2]));
 %!xtest  s = [s1 x2];  assert (isa (s, 'Snork') && isequal (s.gick, [x1 x2]));
 %!xtest  s = [x1 s2];  assert (isa (s, 'Snork') && isequal (s.gick, [x1 x2]));
 
+%% Test with the Blork class, where neither vertcat() nor horzcat() is overloaded
+%!shared x1, x2, x3
+%!test x1 = Blork();
+%!test x2 = [x1 x1];
+%!assert (isa (x2, 'Blork') && isequal (size (x2), [1 2]));
+%!test x2 = [x1 51];
+%!assert (isa (x2, 'Blork') && isequal (size (x2), [1 2]));
+%!test x3 = [x2; x2];
+%!assert (isa (x3, 'Blork') && isequal (size (x3), [2 2]));
+%!test x3 = [x2; [51 x1]];
+%!assert (isa (x3, 'Blork') && isequal (size (x3), [2 2]));
+%!error <dimension mismatch> x4 = [x1  x3];
+%!error <dimension mismatch> x4 = [x1; x3];
+
+%%%%%%%%%%%%%%%%%%%%%%%%
+%% Testing precedence %%
+%%%%%%%%%%%%%%%%%%%%%%%%
+
+%% default: leftmost object wins
+%!shared A, B
+%!test A = Snork(rand(2));
+%!test B = CPrecedenceTester1();  % no call to inferiorto/superiorto
+%!assert (isequal (tattack (A, B), 'Snork'))
+%!assert (isequal (tattack (B, A), 'CPrecedenceTester1'))  % idem
+
+%!shared A, B
+%!test A = Snork(rand(2));
+%!test B = CPrecedenceTester2(1);  % CPrecedenceTester2 > Snork
+%!assert (isequal (tattack (A, B), 'CPrecedenceTester2'))
+%!assert (isequal (tattack (B, A), 'CPrecedenceTester2'))
+%% Trying to change to CPrecendenceTester < Snork
+%!error D = CPrecedenceTester2(2);
+
+%!shared A, B
+%!test A = Snork(rand(2));
+%!test B = CPrecedenceTester3(2);  % CPrecedenceTester3 < Snork
+%!assert (isequal (tattack (A, B), 'Snork'))
+%!assert (isequal (tattack (B, A), 'Snork'))
+%% Trying to change to CPrecendenceTester3 > Snork
+%!error D = CPrecedenceTester3(1);
diff --git a/test/classes/module.mk b/test/classes/module.mk
--- a/test/classes/module.mk
+++ b/test/classes/module.mk
@@ -1,44 +1,56 @@
-classes_FCN_FILES = \
+class_Blork_FCN_FILES = \
   classes/@Blork/Blork.m \
   classes/@Blork/bleek.m \
   classes/@Blork/display.m \
   classes/@Blork/get.m \
-  classes/@Blork/set.m \
+  classes/@Blork/set.m
+
+class_Cork_FCN_FILES = \
   classes/@Cork/Cork.m \
   classes/@Cork/click.m \
   classes/@Cork/display.m \
   classes/@Cork/get.m \
-  classes/@Cork/set.m \
+  classes/@Cork/set.m
+
+class_Dork_FCN_FILES = \
   classes/@Dork/Dork.m \
   classes/@Dork/bling.m \
   classes/@Dork/display.m \
   classes/@Dork/gack.m \
   classes/@Dork/get.m \
   classes/@Dork/getStash.m \
   classes/@Dork/private/myStash.m \
-  classes/@Dork/set.m \
+  classes/@Dork/set.m
+
+class_Gork_FCN_FILES = \
   classes/@Gork/Gork.m \
   classes/@Gork/cork.m \
   classes/@Gork/display.m \
   classes/@Gork/gark.m \
   classes/@Gork/get.m \
   classes/@Gork/set.m \
   classes/@Gork/subsasgn.m \
-  classes/@Gork/subsref.m \
+  classes/@Gork/subsref.m
+
+class_Pork_FCN_FILES = \
   classes/@Pork/Pork.m \
   classes/@Pork/bling.m \
   classes/@Pork/display.m \
   classes/@Pork/get.m \
   classes/@Pork/gurk.m \
   classes/@Pork/private/myStash.m \
-  classes/@Pork/set.m \
+  classes/@Pork/set.m
+
+class_Sneetch_FCN_FILES = \
   classes/@Sneetch/Sneetch.m \
-  classes/@Sneetch/display.m \
+  classes/@Sneetch/display.m
+
+class_Snork_FCN_FILES = \
   classes/@Snork/Snork.m \
   classes/@Snork/cack.m \
   classes/@Snork/display.m \
   classes/@Snork/double.m \
   classes/@Snork/end.m \
   classes/@Snork/eq.m \
   classes/@Snork/ge.m \
   classes/@Snork/get.m \
@@ -63,22 +75,49 @@ classes_FCN_FILES = \
   classes/@Snork/saveobj.m \
   classes/@Snork/set.m \
   classes/@Snork/subsasgn.m \
   classes/@Snork/subsindex.m \
   classes/@Snork/subsref.m \
   classes/@Snork/times.m \
   classes/@Snork/uminus.m \
   classes/@Snork/uplus.m \
-  classes/@Snork/vertcat.m \
+  classes/@Snork/vertcat.m
+
+class_Spork_FCN_FILES = \
   classes/@Spork/Spork.m \
   classes/@Spork/cack.m \
   classes/@Spork/display.m \
   classes/@Spork/geek.m \
   classes/@Spork/get.m \
   classes/@Spork/getStash.m \
   classes/@Spork/loadobj.m \
   classes/@Spork/private/myStash.m \
   classes/@Spork/saveobj.m \
-  classes/@Spork/set.m \
+  classes/@Spork/set.m
+
+class_CPrecedenceTester1_FCN_FILES = \
+  classes/@CPrecedenceTester1/CPrecedenceTester1.m \
+  classes/@CPrecedenceTester1/tattack.m
+
+class_CPrecedenceTester2_FCN_FILES = \
+  classes/@CPrecedenceTester2/CPrecedenceTester2.m \
+  classes/@CPrecedenceTester2/tattack.m
+
+class_CPrecedenceTester3_FCN_FILES = \
+  classes/@CPrecedenceTester3/CPrecedenceTester3.m \
+  classes/@CPrecedenceTester3/tattack.m
+
+classes_FCN_FILES = \
+  $(class_Blork_FCN_FILES) \
+  $(class_Cork_FCN_FILES) \
+  $(class_Dork_FCN_FILES) \
+  $(class_Gork_FCN_FILES) \
+  $(class_Pork_FCN_FILES) \
+  $(class_Sneetch_FCN_FILES) \
+  $(class_Snork_FCN_FILES) \
+  $(class_Spork_FCN_FILES) \
+  $(class_CPrecedenceTester1_FCN_FILES) \
+  $(class_CPrecedenceTester2_FCN_FILES) \
+  $(class_CPrecedenceTester3_FCN_FILES) \
   classes/classes.tst
 
 FCN_FILES += $(classes_FCN_FILES)
diff --git a/test/index.tst b/test/index.tst
--- a/test/index.tst
+++ b/test/index.tst
@@ -205,8 +205,25 @@
 
 %!error (a(1:2,1:2) = 1:4)
 
 %!shared x
 %! x = 1:5;
 %!error <attempted to use a complex scalar as an index> x(i)
 %!error <attempted to use a complex scalar as an index> x(j)
 %!error <attempted to use a complex scalar as an index> x(1+i)
+
+## bug #38357
+%!shared d, dd
+%! d = diag ([1, 2, 3]);
+%! dd = diag ([1, 2, 3], 6, 3);
+%!assert (d(1), 1);
+%!assert (dd(1), 1);
+%!assert (d(3, 3), 3);
+%!assert (dd(3, 3), 3);
+%!assert (d(2), 0);
+%!assert (dd(2), 0);
+%!assert (dd(6,1), 0);
+%!error d(6,6);
+%!error dd(6,6);
+%!error d(3,6);
+%!error dd(3,6);
+
