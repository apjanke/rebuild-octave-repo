# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1449162938 18000
#      Thu Dec 03 12:15:38 2015 -0500
# Node ID c2d9556d51d067599694c1e39cd42c4b8a0df65b
# Parent  4c15057e1bc66beb1dd5882d50354ff704c743dd
eliminate return statements after calls to print_usage

* __delaunayn__.cc, __eigs__.cc, __glpk__.cc, __magick_read__.cc,
__osmesa_print__.cc, __voronoi__.cc, amd.cc, audiodevinfo.cc,
audioread.cc, chol.cc, colamd.cc, convhulln.cc, dmperm.cc, fftw.cc,
qr.cc, symbfact.cc, symrcm.cc:
Eliminate return statements after calls to print_usage.

diff --git a/libinterp/dldfcn/__delaunayn__.cc b/libinterp/dldfcn/__delaunayn__.cc
--- a/libinterp/dldfcn/__delaunayn__.cc
+++ b/libinterp/dldfcn/__delaunayn__.cc
@@ -94,20 +94,17 @@ Undocumented internal function.\n\
   octave_value_list retval;
 
 #if defined (HAVE_QHULL)
 
   retval(0) = 0.0;
 
   int nargin = args.length ();
   if (nargin < 1 || nargin > 2)
-    {
-      print_usage ();
-      return retval;
-    }
+    print_usage ();
 
   Matrix p (args(0).matrix_value ());
   const octave_idx_type dim = p.columns ();
   const octave_idx_type n = p.rows ();
 
   if (! octave_qhull_dims_ok (dim, n, "__delaynayn__"))
     return retval;
 
diff --git a/libinterp/dldfcn/__eigs__.cc b/libinterp/dldfcn/__eigs__.cc
--- a/libinterp/dldfcn/__eigs__.cc
+++ b/libinterp/dldfcn/__eigs__.cc
@@ -191,18 +191,19 @@ Undocumented internal function.\n\
       error ("eigs: invalid recursive call");
       if (fcn_name.length ())
         clear_function (fcn_name);
       return retval;
     }
 
   if (nargin == 0)
     print_usage ();
-  else if (args(0).is_function_handle () || args(0).is_inline_function ()
-           || args(0).is_string ())
+
+  if (args(0).is_function_handle () || args(0).is_inline_function ()
+      || args(0).is_string ())
     {
       if (args(0).is_string ())
         {
           std::string name = args(0).string_value ();
           std::string fname = "function y = ";
           fcn_name = unique_symbol_name ("__eigs_fcn__");
           fname.append (fcn_name);
           fname.append ("(x) y = ");
diff --git a/libinterp/dldfcn/__glpk__.cc b/libinterp/dldfcn/__glpk__.cc
--- a/libinterp/dldfcn/__glpk__.cc
+++ b/libinterp/dldfcn/__glpk__.cc
@@ -344,20 +344,17 @@ Undocumented internal function.\n\
   // The list of values to return.  See the declaration in oct-obj.h
   octave_value_list retval;
 
 #if defined (HAVE_GLPK)
 
   int nrhs = args.length ();
 
   if (nrhs != 9)
-    {
-      print_usage ();
-      return retval;
-    }
+    print_usage ();
 
   //-- 1nd Input. A column array containing the objective function
   //--            coefficients.
   volatile int mrowsc = args(0).rows ();
 
   Matrix C = args(0).xmatrix_value ("__glpk__: invalid value of C");
 
   double *c = C.fortran_vec ();
diff --git a/libinterp/dldfcn/__magick_read__.cc b/libinterp/dldfcn/__magick_read__.cc
--- a/libinterp/dldfcn/__magick_read__.cc
+++ b/libinterp/dldfcn/__magick_read__.cc
@@ -757,20 +757,17 @@ Use @code{imread} instead.\n\
 
 #ifndef HAVE_MAGICK
   gripe_disabled_feature ("imread", "Image IO");
 #else
 
   maybe_initialize_magick ();
 
   if (args.length () != 2 || ! args(0).is_string ())
-    {
-      print_usage ();
-      return output;
-    }
+    print_usage ();
 
   const octave_scalar_map options = args(1).xscalar_map_value ("__magick_read__: OPTIONS must be a struct");
 
   std::vector<Magick::Image> imvec;
   read_file (args(0).string_value (), imvec);
 
   // Prepare an Array with the indexes for the requested frames.
   const octave_idx_type nFrames = imvec.size ();
@@ -1409,20 +1406,18 @@ Use @code{imwrite} instead.\n\
 
 #ifndef HAVE_MAGICK
   gripe_disabled_feature ("imwrite", "Image IO");
 #else
 
   maybe_initialize_magick ();
 
   if (args.length () != 5 || ! args(0).is_string () || ! args(1).is_string ())
-    {
-      print_usage ();
-      return retval;
-    }
+    print_usage ();
+
   const std::string filename = args(0).string_value ();
   const std::string ext = args(1).string_value ();
 
   const octave_scalar_map options = args(4).xscalar_map_value ("__magick_write__: OPTIONS must be a struct");
 
   const octave_value img  = args(2);
   const Matrix cmap = args(3).xmatrix_value ("__magick_write__: invalid MAP");
 
@@ -1590,20 +1585,18 @@ This is a private internal function not 
 {
   octave_value retval;
 #ifndef HAVE_MAGICK
   gripe_disabled_feature ("imfinfo", "Image IO");
 #else
   maybe_initialize_magick ();
 
   if (args.length () < 1 || ! args(0).is_string ())
-    {
-      print_usage ();
-      return retval;
-    }
+    print_usage ();
+
   const std::string filename = args(0).string_value ();
   int idx;
   if (args.length () > 1)
     idx = args(1).int_value () -1;
   else
     idx = 0;
 
   Magick::Image img;
@@ -1813,20 +1806,18 @@ Use @code{imfinfo} instead.\n\
   octave_value retval;
 
 #ifndef HAVE_MAGICK
   gripe_disabled_feature ("imfinfo", "Image IO");
 #else
   maybe_initialize_magick ();
 
   if (args.length () < 1 || ! args(0).is_string ())
-    {
-      print_usage ();
-      return retval;
-    }
+    print_usage ();
+
   const std::string filename = args(0).string_value ();
 
   std::vector<Magick::Image> imvec;
   read_file (filename, imvec);
 
   const octave_idx_type nFrames = imvec.size ();
   const std::string format = imvec[0].magick ();
 
@@ -2262,20 +2253,18 @@ Fill formats info with GraphicsMagick Co
 @seealso{imfinfo, imformats, imread, imwrite}\n\
 @end deftypefn")
 {
   octave_value retval;
 #ifndef HAVE_MAGICK
   gripe_disabled_feature ("imformats", "Image IO");
 #else
   if (args.length () != 1 || ! args(0).is_map ())
-    {
-      print_usage ();
-      return retval;
-    }
+    print_usage ();
+
   octave_map formats = args(0).map_value ();
 
   maybe_initialize_magick ();
   for (octave_idx_type idx = 0; idx < formats.numel (); idx++)
     {
       try
         {
           octave_scalar_map fmt = formats.checkelem (idx);
diff --git a/libinterp/dldfcn/__osmesa_print__.cc b/libinterp/dldfcn/__osmesa_print__.cc
--- a/libinterp/dldfcn/__osmesa_print__.cc
+++ b/libinterp/dldfcn/__osmesa_print__.cc
@@ -91,20 +91,17 @@ instead.\n\
 
 #if ! defined (HAVE_OSMESA)
   gripe_disabled_feature ("__osmesa_print__", "offscreen rendering");
 #else
 
   int nargin = args.length ();
 
   if (! (nargin == 1 || nargin == 3))
-    {
-      print_usage ();
-      return retval;
-    }
+    print_usage ();
 
   if (nargin == 3)
     {
       if (! (args(1).is_string () && args(2).is_string ()))
         {
           error ("__osmesa_print__: FILE and TERM must be strings");
           return retval;
         }
diff --git a/libinterp/dldfcn/__voronoi__.cc b/libinterp/dldfcn/__voronoi__.cc
--- a/libinterp/dldfcn/__voronoi__.cc
+++ b/libinterp/dldfcn/__voronoi__.cc
@@ -90,20 +90,17 @@ Undocumented internal function.\n\
   std::string caller = args(0).xstring_value ("__voronoi__: CALLER must be a string");
 
 #if defined (HAVE_QHULL)
 
   retval(0) = 0.0;
 
   int nargin = args.length ();
   if (nargin < 2 || nargin > 3)
-    {
-      print_usage ();
-      return retval;
-    }
+    print_usage ();
 
   Matrix points = args(1).matrix_value ();
   const octave_idx_type dim = points.columns ();
   const octave_idx_type num_points = points.rows ();
 
   if (! octave_qhull_dims_ok (dim, num_points, "__voronoi__"))
     return retval;
 
diff --git a/libinterp/dldfcn/amd.cc b/libinterp/dldfcn/amd.cc
--- a/libinterp/dldfcn/amd.cc
+++ b/libinterp/dldfcn/amd.cc
@@ -86,112 +86,110 @@ The author of the code itself is Timothy
 {
   octave_value_list retval;
 
 #ifdef HAVE_AMD
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
-  else
+
+  octave_idx_type n_row, n_col;
+  const octave_idx_type *ridx, *cidx;
+  SparseMatrix sm;
+  SparseComplexMatrix scm;
+
+  if (args(0).is_sparse_type ())
     {
-      octave_idx_type n_row, n_col;
-      const octave_idx_type *ridx, *cidx;
-      SparseMatrix sm;
-      SparseComplexMatrix scm;
-
-      if (args(0).is_sparse_type ())
+      if (args(0).is_complex_type ())
         {
-          if (args(0).is_complex_type ())
-            {
-              scm = args(0).sparse_complex_matrix_value ();
-              n_row = scm.rows ();
-              n_col = scm.cols ();
-              ridx = scm.xridx ();
-              cidx = scm.xcidx ();
-            }
-          else
-            {
-              sm = args(0).sparse_matrix_value ();
-              n_row = sm.rows ();
-              n_col = sm.cols ();
-              ridx = sm.xridx ();
-              cidx = sm.xcidx ();
-            }
+          scm = args(0).sparse_complex_matrix_value ();
+          n_row = scm.rows ();
+          n_col = scm.cols ();
+          ridx = scm.xridx ();
+          cidx = scm.xcidx ();
         }
       else
         {
-          if (args(0).is_complex_type ())
-            sm = SparseMatrix (real (args(0).complex_matrix_value ()));
-          else
-            sm = SparseMatrix (args(0).matrix_value ());
-
+          sm = args(0).sparse_matrix_value ();
           n_row = sm.rows ();
           n_col = sm.cols ();
           ridx = sm.xridx ();
           cidx = sm.xcidx ();
         }
-
-      if (n_row != n_col)
-        error ("amd: matrix S must be square");
+    }
+  else
+    {
+      if (args(0).is_complex_type ())
+        sm = SparseMatrix (real (args(0).complex_matrix_value ()));
+      else
+        sm = SparseMatrix (args(0).matrix_value ());
 
-      OCTAVE_LOCAL_BUFFER (double, Control, AMD_CONTROL);
-      AMD_NAME (_defaults) (Control) ;
-      if (nargin > 1)
-        {
-          octave_scalar_map arg1 = args(1).xscalar_map_value ("amd: OPTS argument must be a scalar structure");
+      n_row = sm.rows ();
+      n_col = sm.cols ();
+      ridx = sm.xridx ();
+      cidx = sm.xcidx ();
+    }
 
-          octave_value tmp;
+  if (n_row != n_col)
+    error ("amd: matrix S must be square");
 
-          tmp = arg1.getfield ("dense");
-          if (tmp.is_defined ())
-            Control[AMD_DENSE] = tmp.double_value ();
+  OCTAVE_LOCAL_BUFFER (double, Control, AMD_CONTROL);
+  AMD_NAME (_defaults) (Control) ;
+  if (nargin > 1)
+    {
+      octave_scalar_map arg1 = args(1).xscalar_map_value ("amd: OPTS argument must be a scalar structure");
+
+      octave_value tmp;
 
-          tmp = arg1.getfield ("aggressive");
-          if (tmp.is_defined ())
-            Control[AMD_AGGRESSIVE] = tmp.double_value ();
-        }
+      tmp = arg1.getfield ("dense");
+      if (tmp.is_defined ())
+        Control[AMD_DENSE] = tmp.double_value ();
 
-      OCTAVE_LOCAL_BUFFER (octave_idx_type, P, n_col);
-      Matrix xinfo (AMD_INFO, 1);
-      double *Info = xinfo.fortran_vec ();
+      tmp = arg1.getfield ("aggressive");
+      if (tmp.is_defined ())
+        Control[AMD_AGGRESSIVE] = tmp.double_value ();
+    }
 
-      // FIXME: how can we manage the memory allocation of amd
-      //        in a cleaner manner?
-      SUITESPARSE_ASSIGN_FPTR (malloc_func, amd_malloc, malloc);
-      SUITESPARSE_ASSIGN_FPTR (free_func, amd_free, free);
-      SUITESPARSE_ASSIGN_FPTR (calloc_func, amd_calloc, calloc);
-      SUITESPARSE_ASSIGN_FPTR (realloc_func, amd_realloc, realloc);
-      SUITESPARSE_ASSIGN_FPTR (printf_func, amd_printf, printf);
+  OCTAVE_LOCAL_BUFFER (octave_idx_type, P, n_col);
+  Matrix xinfo (AMD_INFO, 1);
+  double *Info = xinfo.fortran_vec ();
 
-      octave_idx_type result = AMD_NAME (_order) (n_col, cidx, ridx, P,
-                                                  Control, Info);
+  // FIXME: how can we manage the memory allocation of amd
+  //        in a cleaner manner?
+  SUITESPARSE_ASSIGN_FPTR (malloc_func, amd_malloc, malloc);
+  SUITESPARSE_ASSIGN_FPTR (free_func, amd_free, free);
+  SUITESPARSE_ASSIGN_FPTR (calloc_func, amd_calloc, calloc);
+  SUITESPARSE_ASSIGN_FPTR (realloc_func, amd_realloc, realloc);
+  SUITESPARSE_ASSIGN_FPTR (printf_func, amd_printf, printf);
 
-      switch (result)
-        {
-        case AMD_OUT_OF_MEMORY:
-          error ("amd: out of memory");
-          break;
+  octave_idx_type result = AMD_NAME (_order) (n_col, cidx, ridx, P,
+                                              Control, Info);
 
-        case AMD_INVALID:
-          error ("amd: matrix S is corrupted");
-          break;
+  switch (result)
+    {
+    case AMD_OUT_OF_MEMORY:
+      error ("amd: out of memory");
+      break;
+
+    case AMD_INVALID:
+      error ("amd: matrix S is corrupted");
+      break;
 
-        default:
-          {
-            if (nargout > 1)
-              retval(1) = xinfo;
+    default:
+      {
+        if (nargout > 1)
+          retval(1) = xinfo;
 
-            Matrix Pout (1, n_col);
-            for (octave_idx_type i = 0; i < n_col; i++)
-              Pout.xelem (i) = P[i] + 1;
+        Matrix Pout (1, n_col);
+        for (octave_idx_type i = 0; i < n_col; i++)
+          Pout.xelem (i) = P[i] + 1;
 
-            retval(0) = Pout;
-          }
-        }
+        retval(0) = Pout;
+      }
     }
 #else
 
   error ("amd: not available in this version of Octave");
 
 #endif
 
   return retval;
diff --git a/libinterp/dldfcn/audiodevinfo.cc b/libinterp/dldfcn/audiodevinfo.cc
--- a/libinterp/dldfcn/audiodevinfo.cc
+++ b/libinterp/dldfcn/audiodevinfo.cc
@@ -2002,20 +2002,17 @@ Undocumented internal function.\n\
 {
   octave_value retval;
 
 #ifdef HAVE_PORTAUDIO
 
   audiorecorder *recorder = get_recorder (args(0));
 
   if (! recorder)
-    {
-      print_usage ();
-      return retval;
-    }
+    print_usage ();
 
   retval = recorder->getaudiodata ();
 
 #else
 
   error ("portaudio not found on your system and thus audio functionality is not present");
 
 #endif
@@ -2033,20 +2030,17 @@ Undocumented internal function.\n\
 
 #ifdef HAVE_PORTAUDIO
 
   if (args.length () == 1)
     {
       audiorecorder *recorder = get_recorder (args(0));
 
       if (! recorder)
-        {
-          print_usage ();
-          return retval;
-        }
+        print_usage ();
 
       retval = recorder->get_channels ();
     }
 
 #else
 
   error ("portaudio not found on your system and thus audio functionality is not present");
 
@@ -2065,20 +2059,17 @@ Undocumented internal function.\n\
 
 #ifdef HAVE_PORTAUDIO
 
   if (args.length () == 1)
     {
       audiorecorder *recorder = get_recorder (args(0));
 
       if (! recorder)
-        {
-          print_usage ();
-          return retval;
-        }
+        print_usage ();
 
       retval = recorder->get_fs ();
     }
 
 #else
 
   error ("portaudio not found on your system and thus audio functionality is not present");
 
@@ -2097,20 +2088,17 @@ Undocumented internal function.\n\
 
 #ifdef HAVE_PORTAUDIO
 
   if (args.length () == 1)
     {
       audiorecorder *recorder = get_recorder (args(0));
 
       if (! recorder)
-        {
-          print_usage ();
-          return retval;
-        }
+        print_usage ();
 
       retval = recorder->get_id ();
     }
 
 #else
 
   error ("portaudio not found on your system and thus audio functionality is not present");
 
@@ -2129,20 +2117,17 @@ Undocumented internal function.\n\
 
 #ifdef HAVE_PORTAUDIO
 
   if (args.length () == 1)
     {
       audiorecorder *recorder = get_recorder (args(0));
 
       if (! recorder)
-        {
-          print_usage ();
-          return retval;
-        }
+        print_usage ();
 
       retval = recorder->get_nbits ();
     }
 
 #else
 
   error ("portaudio not found on your system and thus audio functionality is not present");
 
@@ -2161,20 +2146,17 @@ Undocumented internal function.\n\
 
 #ifdef HAVE_PORTAUDIO
 
   if (args.length () == 1)
     {
       audiorecorder *recorder = get_recorder (args(0));
 
       if (! recorder)
-        {
-          print_usage ();
-          return retval;
-        }
+        print_usage ();
 
       retval = recorder->get_sample_number ();
     }
 
 #else
 
   error ("portaudio not found on your system and thus audio functionality is not present");
 
@@ -2193,20 +2175,17 @@ Undocumented internal function.\n\
 
 #ifdef HAVE_PORTAUDIO
 
   if (args.length () == 1)
     {
       audiorecorder *recorder = get_recorder (args(0));
 
       if (! recorder)
-        {
-          print_usage ();
-          return retval;
-        }
+        print_usage ();
 
       retval = recorder->get_tag ();
     }
 
 #else
 
   error ("portaudio not found on your system and thus audio functionality is not present");
 
@@ -2225,20 +2204,17 @@ Undocumented internal function.\n\
 
 #ifdef HAVE_PORTAUDIO
 
   if (args.length () == 1)
     {
       audiorecorder *recorder = get_recorder (args(0));
 
       if (! recorder)
-        {
-          print_usage ();
-          return retval;
-        }
+        print_usage ();
 
       retval = recorder->get_total_samples ();
     }
 
 #else
 
   error ("portaudio not found on your system and thus audio functionality is not present");
 
@@ -2257,20 +2233,17 @@ Undocumented internal function.\n\
 
 #ifdef HAVE_PORTAUDIO
 
   if (args.length () == 1)
     {
       audiorecorder *recorder = get_recorder (args(0));
 
       if (! recorder)
-        {
-          print_usage ();
-          return retval;
-        }
+        print_usage ();
 
       retval = recorder->get_userdata ();
     }
 
 #else
 
   error ("portaudio not found on your system and thus audio functionality is not present");
 
@@ -2289,20 +2262,17 @@ Undocumented internal function.\n\
 
 #ifdef HAVE_PORTAUDIO
 
   if (args.length () == 1)
     {
       audiorecorder *recorder = get_recorder (args(0));
 
       if (! recorder)
-        {
-          print_usage ();
-          return retval;
-        }
+        print_usage ();
 
       retval = recorder->isrecording () ? true : false;
     }
 
 #else
 
   error ("portaudio not found on your system and thus audio functionality is not present");
 
@@ -2321,20 +2291,17 @@ Undocumented internal function.\n\
 
 #ifdef HAVE_PORTAUDIO
 
   if (args.length () == 1)
     {
       audiorecorder *recorder = get_recorder (args(0));
 
       if (! recorder)
-        {
-          print_usage ();
-          return retval;
-        }
+        print_usage ();
 
       recorder->pause ();
     }
 
 #else
 
   error ("portaudio not found on your system and thus audio functionality is not present");
 
@@ -2351,20 +2318,17 @@ Undocumented internal function.\n\
 {
   octave_value retval;
 
 #ifdef HAVE_PORTAUDIO
 
   audiorecorder *recorder = get_recorder (args(0));
 
   if (! recorder)
-    {
-      print_usage ();
-      return retval;
-    }
+    print_usage ();
 
   recorder->recordblocking (args(1).float_value ());
 
 #else
 
   error ("portaudio not found on your system and thus audio functionality is not present");
 
 #endif
@@ -2381,20 +2345,17 @@ Undocumented internal function.\n\
 {
   octave_value retval;
 
 #ifdef HAVE_PORTAUDIO
 
   audiorecorder *recorder = get_recorder (args(0));
 
   if (! recorder)
-    {
       print_usage ();
-      return retval;
-    }
 
   if (args.length () == 1)
     recorder->record ();
   else if (args.length () == 2)
     {
       recorder->set_end_sample (args(1).int_value () * recorder->get_fs ());
       recorder->record ();
     }
@@ -2420,20 +2381,17 @@ Undocumented internal function.\n\
 
 #ifdef HAVE_PORTAUDIO
 
   if (args.length () == 1)
     {
       audiorecorder *recorder = get_recorder (args(0));
 
       if (! recorder)
-        {
-          print_usage ();
-          return retval;
-        }
+        print_usage ();
 
       recorder->resume ();
     }
 
 #else
 
   error ("portaudio not found on your system and thus audio functionality is not present");
 
@@ -2452,20 +2410,17 @@ Undocumented internal function.\n\
 
 #ifdef HAVE_PORTAUDIO
 
   if (args.length () == 2)
     {
       audiorecorder *recorder = get_recorder (args(0));
 
       if (! recorder)
-        {
-          print_usage ();
-          return retval;
-        }
+        print_usage ();
 
       recorder->set_fs (args(1).int_value ());
     }
 
 #else
 
   error ("portaudio not found on your system and thus audio functionality is not present");
 
@@ -2484,20 +2439,17 @@ Undocumented internal function.\n\
 
 #ifdef HAVE_PORTAUDIO
 
   if (args.length () == 2)
     {
       audiorecorder *recorder = get_recorder (args(0));
 
       if (! recorder)
-        {
-          print_usage ();
-          return retval;
-        }
+        print_usage ();
 
       recorder->set_tag (args(1).char_matrix_value ());
     }
 
 #else
 
   error ("portaudio not found on your system and thus audio functionality is not present");
 
@@ -2516,20 +2468,17 @@ Undocumented internal function.\n\
 
 #ifdef HAVE_PORTAUDIO
 
   if (args.length () == 2)
     {
       audiorecorder *recorder = get_recorder (args(0));
 
       if (! recorder)
-        {
-          print_usage ();
-          return retval;
-        }
+        print_usage ();
 
       recorder->set_userdata (args(1));
     }
 
 #else
 
   error ("portaudio not found on your system and thus audio functionality is not present");
 
@@ -2546,20 +2495,17 @@ Undocumented internal function.\n\
 {
   octave_value retval;
 
 #ifdef HAVE_PORTAUDIO
 
   audiorecorder *recorder = get_recorder (args(0));
 
   if (! recorder)
-    {
-      print_usage ();
-      return retval;
-    }
+    print_usage ();
 
   recorder->stop ();
 
 #else
 
   error ("portaudio not found on your system and thus audio functionality is not present");
 
 #endif
@@ -2577,28 +2523,22 @@ Undocumented internal function.\n\
 {
   octave_value retval;
 
 #ifdef HAVE_PORTAUDIO
 
   int nargin = args.length ();
 
   if (nargin < 2 || nargin > 4)
-    {
-      print_usage ();
-      return retval;
-    }
+    print_usage ();
 
   audioplayer* recorder = new audioplayer ();
 
   if (! recorder)
-    {
-      print_usage ();
-      return retval;
-    }
+    print_usage ();
 
   bool is_function = (args(0).is_string () || args(0).is_function_handle ()
                       || args(0).is_inline_function ());
 
   if (is_function)
     {
       error ("audioplayer: callbacks not yet implemented");
       return retval;
@@ -2662,20 +2602,17 @@ Undocumented internal function.\n\
 
 #ifdef HAVE_PORTAUDIO
 
   if (args.length () == 1)
     {
       audioplayer *player = get_player (args(0));
 
       if (! player)
-        {
-          print_usage ();
-          return retval;
-        }
+        print_usage ();
 
       retval = player->get_channels ();
     }
 
 #else
 
   error ("portaudio not found on your system and thus audio functionality is not present");
 
@@ -2694,20 +2631,17 @@ Undocumented internal function.\n\
 
 #ifdef HAVE_PORTAUDIO
 
   if (args.length () == 1)
     {
       audioplayer *player = get_player (args(0));
 
       if (! player)
-        {
-          print_usage ();
-          return retval;
-        }
+        print_usage ();
 
       retval = player->get_fs ();
     }
 
 #else
 
   error ("portaudio not found on your system and thus audio functionality is not present");
 
@@ -2726,20 +2660,17 @@ Undocumented internal function.\n\
 
 #ifdef HAVE_PORTAUDIO
 
   if (args.length () == 1)
     {
       audioplayer *player = get_player (args(0));
 
       if (! player)
-        {
-          print_usage ();
-          return retval;
-        }
+        print_usage ();
 
       retval = player->get_id ();
     }
 
 #else
 
   error ("portaudio not found on your system and thus audio functionality is not present");
 
@@ -2758,20 +2689,17 @@ Undocumented internal function.\n\
 
 #ifdef HAVE_PORTAUDIO
 
   if (args.length () == 1)
     {
       audioplayer *player = get_player (args(0));
 
       if (! player)
-        {
-          print_usage ();
-          return retval;
-        }
+        print_usage ();
 
       retval = player->get_nbits ();
     }
 
 #else
 
   error ("portaudio not found on your system and thus audio functionality is not present");
 
@@ -2790,20 +2718,17 @@ Undocumented internal function.\n\
 
 #ifdef HAVE_PORTAUDIO
 
   if (args.length () == 1)
     {
       audioplayer *player = get_player (args(0));
 
       if (! player)
-        {
-          print_usage ();
-          return retval;
-        }
+        print_usage ();
 
       retval = player->get_sample_number ();
     }
 
 #else
 
   error ("portaudio not found on your system and thus audio functionality is not present");
 
@@ -2822,20 +2747,17 @@ Undocumented internal function.\n\
 
 #ifdef HAVE_PORTAUDIO
 
   if (args.length () == 1)
     {
       audioplayer *player = get_player (args(0));
 
       if (! player)
-        {
-          print_usage ();
-          return retval;
-        }
+        print_usage ();
 
       retval = player->get_tag ();
     }
 
 #else
 
   error ("portaudio not found on your system and thus audio functionality is not present");
 
@@ -2854,20 +2776,17 @@ Undocumented internal function.\n\
 
 #ifdef HAVE_PORTAUDIO
 
   if (args.length () == 1)
     {
       audioplayer *player = get_player (args(0));
 
       if (! player)
-        {
-          print_usage ();
-          return retval;
-        }
+        print_usage ();
 
       retval = player->get_total_samples ();
     }
 
 #else
 
   error ("portaudio not found on your system and thus audio functionality is not present");
 
@@ -2886,20 +2805,17 @@ Undocumented internal function.\n\
 
 #ifdef HAVE_PORTAUDIO
 
   if (args.length () == 1)
     {
       audioplayer *player = get_player (args(0));
 
       if (! player)
-        {
-          print_usage ();
-          return retval;
-        }
+        print_usage ();
 
       retval = player->get_userdata ();
     }
 
 #else
 
   error ("portaudio not found on your system and thus audio functionality is not present");
 
@@ -2918,20 +2834,17 @@ Undocumented internal function.\n\
 
 #ifdef HAVE_PORTAUDIO
 
   if (args.length () == 1)
     {
       audioplayer *player = get_player (args(0));
 
       if (! player)
-        {
-          print_usage ();
-          return retval;
-        }
+        print_usage ();
 
       retval = player->isplaying () ? true : false;
     }
 
 #else
 
   error ("portaudio not found on your system and thus audio functionality is not present");
 
@@ -2950,20 +2863,17 @@ Undocumented internal function.\n\
 
 #ifdef HAVE_PORTAUDIO
 
   if (args.length () == 1)
     {
       audioplayer *player = get_player (args(0));
 
       if (! player)
-        {
-          print_usage ();
-          return retval;
-        }
+        print_usage ();
 
       player->pause ();
     }
 
 #else
 
   error ("portaudio not found on your system and thus audio functionality is not present");
 
@@ -2982,20 +2892,17 @@ Undocumented internal function.\n\
 {
   octave_value retval;
 
 #ifdef HAVE_PORTAUDIO
 
   audioplayer *player = get_player (args(0));
 
   if (! player)
-    {
-      print_usage ();
-      return retval;
-    }
+    print_usage ();
 
   if (args.length () == 1)
     player->playblocking ();
   else
     {
       if (args(1).is_matrix_type ())
         {
           RowVector range = args(1).row_vector_value ();
@@ -3050,20 +2957,17 @@ Undocumented internal function.\n\
 
 #ifdef HAVE_PORTAUDIO
 
   if (args.length () == 1)
     {
       audioplayer *player = get_player (args(0));
 
       if (! player)
-        {
-          print_usage ();
-          return retval;
-        }
+        print_usage ();
 
       player->play ();
     }
   else
     {
       audioplayer *player = get_player (args(0));
 
       if (args(1).is_matrix_type ())
@@ -3118,20 +3022,17 @@ Undocumented internal function.\n\
 
 #ifdef HAVE_PORTAUDIO
 
   if (args.length () == 1)
     {
       audioplayer *player = get_player (args(0));
 
       if (! player)
-        {
-          print_usage ();
-          return retval;
-        }
+        print_usage ();
 
       player->resume ();
     }
 
 #else
 
   error ("portaudio not found on your system and thus audio functionality is not present");
 
@@ -3150,20 +3051,17 @@ Undocumented internal function.\n\
 
 #ifdef HAVE_PORTAUDIO
 
   if (args.length () == 2)
     {
       audioplayer *player = get_player (args(0));
 
       if (! player)
-        {
-          print_usage ();
-          return retval;
-        }
+        print_usage ();
 
       player->set_fs (args(1).int_value ());
     }
 
 #else
 
   error ("portaudio not found on your system and thus audio functionality is not present");
 
@@ -3182,20 +3080,17 @@ Undocumented internal function.\n\
 
 #ifdef HAVE_PORTAUDIO
 
   if (args.length () == 2)
     {
       audioplayer *player = get_player (args(0));
 
       if (! player)
-        {
-          print_usage ();
-          return retval;
-        }
+        print_usage ();
 
       player->set_tag (args(1).char_matrix_value ());
     }
 
 #else
 
   error ("portaudio not found on your system and thus audio functionality is not present");
 
@@ -3214,20 +3109,17 @@ Undocumented internal function.\n\
 
 #ifdef HAVE_PORTAUDIO
 
   if (args.length () == 2)
     {
       audioplayer *player = get_player (args(0));
 
       if (! player)
-        {
-          print_usage ();
-          return retval;
-        }
+        print_usage ();
 
       player->set_userdata (args(1));
     }
 
 #else
 
   error ("portaudio not found on your system and thus audio functionality is not present");
 
@@ -3246,20 +3138,17 @@ Undocumented internal function.\n\
 
 #ifdef HAVE_PORTAUDIO
 
   if (args.length () == 1)
     {
       audioplayer *player = get_player (args (0));
 
       if (! player)
-        {
-          print_usage ();
-          return retval;
-        }
+        print_usage ();
 
       player->stop ();
     }
 
 #else
 
   error ("portaudio not found on your system and thus audio functionality is not present");
 
diff --git a/libinterp/dldfcn/audioread.cc b/libinterp/dldfcn/audioread.cc
--- a/libinterp/dldfcn/audioread.cc
+++ b/libinterp/dldfcn/audioread.cc
@@ -72,20 +72,17 @@ is stored in the audio file.\n\
 {
   octave_value_list retval;
 
 #ifdef HAVE_SNDFILE
 
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 3)
-    {
-      print_usage ();
-      return retval;
-    }
+    print_usage ();
 
   std::string filename = args(0).string_value ();
 
   SF_INFO info;
   info.format = 0;
   SNDFILE *file = sf_open (filename.c_str (), SFM_READ, &info);
 
   if (! file)
@@ -280,20 +277,17 @@ Comment.\n\
 
   octave_value retval;
 
 #ifdef HAVE_SNDFILE
 
   int nargin = args.length ();
 
   if (nargin < 3)
-    {
-      print_usage ();
-      return retval;
-    }
+    print_usage ();
 
   std::string filename = args(0).string_value ();
 
   Matrix audio = args(1).matrix_value ();
 
   double bias = 0.0;
   double scale = 1.0;
 
@@ -468,20 +462,17 @@ DEFUN_DLD (audioinfo, args, ,
 Return information about an audio file specified by @var{filename}.\n\
 @end deftypefn")
 {
   octave_value retval;
 
 #ifdef HAVE_SNDFILE
 
   if (args.length () != 1)
-    {
-      print_usage ();
-      return retval;
-    }
+    print_usage ();
 
   std::string filename = args(0).string_value ();
 
   SF_INFO info;
   info.format = 0;
   SNDFILE *file = sf_open (filename.c_str (), SFM_READ, &info);
 
   if (! file)
diff --git a/libinterp/dldfcn/chol.cc b/libinterp/dldfcn/chol.cc
--- a/libinterp/dldfcn/chol.cc
+++ b/libinterp/dldfcn/chol.cc
@@ -149,20 +149,17 @@ sparse matrices.\n\
 {
   octave_value_list retval;
   int nargin = args.length ();
   bool LLt = false;
   bool vecout = false;
 
   if (nargin < 1 || nargin > 3 || nargout > 3
       || (! args(0).is_sparse_type () && nargout > 2))
-    {
-      print_usage ();
-      return retval;
-    }
+    print_usage ();
 
   int n = 1;
   while (n < nargin)
     {
       std::string tmp = args(n++).xstring_value ("chol: optional arguments must be strings");
 
       if (tmp == "vector")
         vecout = true;
@@ -350,114 +347,112 @@ Compute the inverse of the symmetric pos
 the Cholesky@tie{}factorization.\n\
 @seealso{chol, chol2inv, inv}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
-  if (nargin == 1)
+  if (nargin != 1)
+    print_usage ();
+
+  octave_value arg = args(0);
+
+  octave_idx_type nr = arg.rows ();
+  octave_idx_type nc = arg.columns ();
+
+  if (nr == 0 || nc == 0)
+    retval = Matrix ();
+  else
     {
-      octave_value arg = args(0);
+      if (arg.is_sparse_type ())
+        {
+          octave_idx_type info;
+
+          if (arg.is_real_type ())
+            {
+              SparseMatrix m = arg.sparse_matrix_value ();
+
+              SparseCHOL chol (m, info);
+
+              if (info == 0)
+                retval = chol.inverse ();
+              else
+                error ("cholinv: A must be positive definite");
+            }
+          else if (arg.is_complex_type ())
+            {
+              SparseComplexMatrix m = arg.sparse_complex_matrix_value ();
+
+              SparseComplexCHOL chol (m, info);
 
-      octave_idx_type nr = arg.rows ();
-      octave_idx_type nc = arg.columns ();
+              if (info == 0)
+                retval = chol.inverse ();
+              else
+                error ("cholinv: A must be positive definite");
+            }
+          else
+            gripe_wrong_type_arg ("cholinv", arg);
+        }
+      else if (arg.is_single_type ())
+        {
+          if (arg.is_real_type ())
+            {
+              FloatMatrix m = arg.float_matrix_value ();
 
-      if (nr == 0 || nc == 0)
-        retval = Matrix ();
+              octave_idx_type info;
+              FloatCHOL chol (m, info);
+              if (info == 0)
+                retval = chol.inverse ();
+              else
+                error ("cholinv: A must be positive definite");
+            }
+          else if (arg.is_complex_type ())
+            {
+              FloatComplexMatrix m = arg.float_complex_matrix_value ();
+
+              octave_idx_type info;
+              FloatComplexCHOL chol (m, info);
+              if (info == 0)
+                retval = chol.inverse ();
+              else
+                error ("cholinv: A must be positive definite");
+            }
+          else
+            gripe_wrong_type_arg ("chol", arg);
+        }
       else
         {
-          if (arg.is_sparse_type ())
+          if (arg.is_real_type ())
             {
-              octave_idx_type info;
-
-              if (arg.is_real_type ())
-                {
-                  SparseMatrix m = arg.sparse_matrix_value ();
-
-                  SparseCHOL chol (m, info);
+              Matrix m = arg.matrix_value ();
 
-                  if (info == 0)
-                    retval = chol.inverse ();
-                  else
-                    error ("cholinv: A must be positive definite");
-                }
-              else if (arg.is_complex_type ())
-                {
-                  SparseComplexMatrix m = arg.sparse_complex_matrix_value ();
-
-                  SparseComplexCHOL chol (m, info);
-
-                  if (info == 0)
-                    retval = chol.inverse ();
-                  else
-                    error ("cholinv: A must be positive definite");
-                }
+              octave_idx_type info;
+              CHOL chol (m, info);
+              if (info == 0)
+                retval = chol.inverse ();
               else
-                gripe_wrong_type_arg ("cholinv", arg);
+                error ("cholinv: A must be positive definite");
             }
-          else if (arg.is_single_type ())
+          else if (arg.is_complex_type ())
             {
-              if (arg.is_real_type ())
-                {
-                  FloatMatrix m = arg.float_matrix_value ();
+              ComplexMatrix m = arg.complex_matrix_value ();
 
-                  octave_idx_type info;
-                  FloatCHOL chol (m, info);
-                  if (info == 0)
-                    retval = chol.inverse ();
-                  else
-                    error ("cholinv: A must be positive definite");
-                }
-              else if (arg.is_complex_type ())
-                {
-                  FloatComplexMatrix m = arg.float_complex_matrix_value ();
-
-                  octave_idx_type info;
-                  FloatComplexCHOL chol (m, info);
-                  if (info == 0)
-                    retval = chol.inverse ();
-                  else
-                    error ("cholinv: A must be positive definite");
-                }
+              octave_idx_type info;
+              ComplexCHOL chol (m, info);
+              if (info == 0)
+                retval = chol.inverse ();
               else
-                gripe_wrong_type_arg ("chol", arg);
+                error ("cholinv: A must be positive definite");
             }
           else
-            {
-              if (arg.is_real_type ())
-                {
-                  Matrix m = arg.matrix_value ();
-
-                  octave_idx_type info;
-                  CHOL chol (m, info);
-                  if (info == 0)
-                    retval = chol.inverse ();
-                  else
-                    error ("cholinv: A must be positive definite");
-                }
-              else if (arg.is_complex_type ())
-                {
-                  ComplexMatrix m = arg.complex_matrix_value ();
-
-                  octave_idx_type info;
-                  ComplexCHOL chol (m, info);
-                  if (info == 0)
-                    retval = chol.inverse ();
-                  else
-                    error ("cholinv: A must be positive definite");
-                }
-              else
-                gripe_wrong_type_arg ("chol", arg);
-            }
+            gripe_wrong_type_arg ("chol", arg);
         }
     }
-  else
-    print_usage ();
 
   return retval;
 }
 
 /*
 %!shared A, Ainv
 %! A = [2,0.2;0.2,1];
 %! Ainv = inv (A);
@@ -483,83 +478,81 @@ diagonal elements.  @code{chol2inv (@var
 @code{inv (@var{U}'*@var{U})} but it is much faster than using @code{inv}.\n\
 @seealso{chol, cholinv, inv}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
-  if (nargin == 1)
+  if (nargin != 1)
+    print_usage ();
+
+  octave_value arg = args(0);
+
+  octave_idx_type nr = arg.rows ();
+  octave_idx_type nc = arg.columns ();
+
+  if (nr == 0 || nc == 0)
+    retval = Matrix ();
+  else
     {
-      octave_value arg = args(0);
+      if (arg.is_sparse_type ())
+        {
+          if (arg.is_real_type ())
+            {
+              SparseMatrix r = arg.sparse_matrix_value ();
+
+              retval = chol2inv (r);
+            }
+          else if (arg.is_complex_type ())
+            {
+              SparseComplexMatrix r = arg.sparse_complex_matrix_value ();
 
-      octave_idx_type nr = arg.rows ();
-      octave_idx_type nc = arg.columns ();
+              retval = chol2inv (r);
+            }
+          else
+            gripe_wrong_type_arg ("chol2inv", arg);
+        }
+      else if (arg.is_single_type ())
+        {
+          if (arg.is_real_type ())
+            {
+              FloatMatrix r = arg.float_matrix_value ();
 
-      if (nr == 0 || nc == 0)
-        retval = Matrix ();
+              retval = chol2inv (r);
+            }
+          else if (arg.is_complex_type ())
+            {
+              FloatComplexMatrix r = arg.float_complex_matrix_value ();
+
+              retval = chol2inv (r);
+            }
+          else
+            gripe_wrong_type_arg ("chol2inv", arg);
+
+        }
       else
         {
-          if (arg.is_sparse_type ())
+          if (arg.is_real_type ())
             {
-              if (arg.is_real_type ())
-                {
-                  SparseMatrix r = arg.sparse_matrix_value ();
+              Matrix r = arg.matrix_value ();
 
-                  retval = chol2inv (r);
-                }
-              else if (arg.is_complex_type ())
-                {
-                  SparseComplexMatrix r = arg.sparse_complex_matrix_value ();
-
-                  retval = chol2inv (r);
-                }
-              else
-                gripe_wrong_type_arg ("chol2inv", arg);
+              retval = chol2inv (r);
             }
-          else if (arg.is_single_type ())
+          else if (arg.is_complex_type ())
             {
-              if (arg.is_real_type ())
-                {
-                  FloatMatrix r = arg.float_matrix_value ();
+              ComplexMatrix r = arg.complex_matrix_value ();
 
-                  retval = chol2inv (r);
-                }
-              else if (arg.is_complex_type ())
-                {
-                  FloatComplexMatrix r = arg.float_complex_matrix_value ();
-
-                  retval = chol2inv (r);
-                }
-              else
-                gripe_wrong_type_arg ("chol2inv", arg);
-
+              retval = chol2inv (r);
             }
           else
-            {
-              if (arg.is_real_type ())
-                {
-                  Matrix r = arg.matrix_value ();
-
-                  retval = chol2inv (r);
-                }
-              else if (arg.is_complex_type ())
-                {
-                  ComplexMatrix r = arg.complex_matrix_value ();
-
-                  retval = chol2inv (r);
-                }
-              else
-                gripe_wrong_type_arg ("chol2inv", arg);
-            }
+            gripe_wrong_type_arg ("chol2inv", arg);
         }
     }
-  else
-    print_usage ();
 
   return retval;
 }
 
 DEFUN_DLD (cholupdate, args, nargout,
            "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {[@var{R1}, @var{info}] =} cholupdate (@var{R}, @var{u}, @var{op})\n\
 Update or downdate a Cholesky@tie{}factorization.\n\
@@ -591,20 +584,17 @@ If @var{info} is not present, an error m
 @seealso{chol, cholinsert, choldelete, cholshift}\n\
 @end deftypefn")
 {
   octave_idx_type nargin = args.length ();
 
   octave_value_list retval;
 
   if (nargin > 3 || nargin < 2)
-    {
-      print_usage ();
-      return retval;
-    }
+    print_usage ();
 
   octave_value argr = args(0);
   octave_value argu = args(1);
 
   if (argr.is_numeric_type () && argu.is_numeric_type ()
       && (nargin < 3 || args(2).is_string ()))
     {
       octave_idx_type n = argr.rows ();
@@ -793,20 +783,17 @@ If @var{info} is not present, an error m
 @seealso{chol, cholupdate, choldelete, cholshift}\n\
 @end deftypefn")
 {
   octave_idx_type nargin = args.length ();
 
   octave_value_list retval;
 
   if (nargin != 3)
-    {
-      print_usage ();
-      return retval;
-    }
+    print_usage ();
 
   octave_value argr = args(0);
   octave_value argj = args(1);
   octave_value argu = args(2);
 
   if (argr.is_numeric_type () && argu.is_numeric_type ()
       && argj.is_real_scalar ())
     {
@@ -1043,20 +1030,17 @@ triangular, return the Cholesky@tie{}fac
 @seealso{chol, cholupdate, cholinsert, cholshift}\n\
 @end deftypefn")
 {
   octave_idx_type nargin = args.length ();
 
   octave_value_list retval;
 
   if (nargin != 2)
-    {
-      print_usage ();
-      return retval;
-    }
+    print_usage ();
 
   octave_value argr = args(0);
   octave_value argj = args(1);
 
   if (argr.is_numeric_type () && argj.is_real_scalar ())
     {
       octave_idx_type n = argr.rows ();
       octave_idx_type j = argj.scalar_value ();
@@ -1180,20 +1164,17 @@ triangular, return the Cholesky@tie{}fac
 @seealso{chol, cholupdate, cholinsert, choldelete}\n\
 @end deftypefn")
 {
   octave_idx_type nargin = args.length ();
 
   octave_value_list retval;
 
   if (nargin != 3)
-    {
-      print_usage ();
-      return retval;
-    }
+    print_usage ();
 
   octave_value argr = args(0);
   octave_value argi = args(1);
   octave_value argj = args(2);
 
   if (argr.is_numeric_type ()
       && argi.is_real_scalar () && argj.is_real_scalar ())
     {
diff --git a/libinterp/dldfcn/colamd.cc b/libinterp/dldfcn/colamd.cc
--- a/libinterp/dldfcn/colamd.cc
+++ b/libinterp/dldfcn/colamd.cc
@@ -282,168 +282,166 @@ Xerox PARC, and @nospell{Esmond Ng}, Oak
 
 #ifdef HAVE_COLAMD
 
   int nargin = args.length ();
   int spumoni = 0;
 
   if (nargout > 2 || nargin < 1 || nargin > 2)
     print_usage ();
-  else
-    {
-      // Get knobs
-      OCTAVE_LOCAL_BUFFER (double, knobs, COLAMD_KNOBS);
-      COLAMD_NAME (_set_defaults) (knobs);
+
+  // Get knobs
+  OCTAVE_LOCAL_BUFFER (double, knobs, COLAMD_KNOBS);
+  COLAMD_NAME (_set_defaults) (knobs);
 
-      // Check for user-passed knobs
-      if (nargin == 2)
-        {
-          NDArray User_knobs = args(1).array_value ();
-          int nel_User_knobs = User_knobs.numel ();
+  // Check for user-passed knobs
+  if (nargin == 2)
+    {
+      NDArray User_knobs = args(1).array_value ();
+      int nel_User_knobs = User_knobs.numel ();
 
-          if (nel_User_knobs > 0)
-            knobs[COLAMD_DENSE_ROW] = User_knobs(0);
-          if (nel_User_knobs > 1)
-            knobs[COLAMD_DENSE_COL] = User_knobs(1) ;
-          if (nel_User_knobs > 2)
-            spumoni = static_cast<int> (User_knobs(2));
-
-          // print knob settings if spumoni is set
-          if (spumoni)
-            {
+      if (nel_User_knobs > 0)
+        knobs[COLAMD_DENSE_ROW] = User_knobs(0);
+      if (nel_User_knobs > 1)
+        knobs[COLAMD_DENSE_COL] = User_knobs(1) ;
+      if (nel_User_knobs > 2)
+        spumoni = static_cast<int> (User_knobs(2));
 
-              octave_stdout << "\ncolamd version " << COLAMD_MAIN_VERSION
-                            << "." <<  COLAMD_SUB_VERSION
-                            << ", " << COLAMD_DATE << ":\n";
+      // print knob settings if spumoni is set
+      if (spumoni)
+        {
 
-              if (knobs[COLAMD_DENSE_ROW] >= 0)
-                octave_stdout << "knobs(1): " << User_knobs (0)
-                              << ", rows with > max (16,"
-                              << knobs[COLAMD_DENSE_ROW] << "*sqrt (size(A,2)))"
-                              << " entries removed\n";
-              else
-                octave_stdout << "knobs(1): " << User_knobs (0)
-                              << ", only completely dense rows removed\n";
+          octave_stdout << "\ncolamd version " << COLAMD_MAIN_VERSION
+                        << "." <<  COLAMD_SUB_VERSION
+                        << ", " << COLAMD_DATE << ":\n";
 
-              if (knobs[COLAMD_DENSE_COL] >= 0)
-                octave_stdout << "knobs(2): " << User_knobs (1)
-                              << ", cols with > max (16,"
-                              << knobs[COLAMD_DENSE_COL] << "*sqrt (size(A)))"
-                              << " entries removed\n";
-              else
-                octave_stdout << "knobs(2): " << User_knobs (1)
-                              << ", only completely dense columns removed\n";
+          if (knobs[COLAMD_DENSE_ROW] >= 0)
+            octave_stdout << "knobs(1): " << User_knobs (0)
+                          << ", rows with > max (16,"
+                          << knobs[COLAMD_DENSE_ROW] << "*sqrt (size(A,2)))"
+                          << " entries removed\n";
+          else
+            octave_stdout << "knobs(1): " << User_knobs (0)
+                          << ", only completely dense rows removed\n";
 
-              octave_stdout << "knobs(3): " << User_knobs (2)
-                            << ", statistics and knobs printed\n";
-
-            }
-        }
-
-      octave_idx_type n_row, n_col, nnz;
-      octave_idx_type *ridx, *cidx;
-      SparseComplexMatrix scm;
-      SparseMatrix sm;
+          if (knobs[COLAMD_DENSE_COL] >= 0)
+            octave_stdout << "knobs(2): " << User_knobs (1)
+                          << ", cols with > max (16,"
+                          << knobs[COLAMD_DENSE_COL] << "*sqrt (size(A)))"
+                          << " entries removed\n";
+          else
+            octave_stdout << "knobs(2): " << User_knobs (1)
+                          << ", only completely dense columns removed\n";
 
-      if (args(0).is_sparse_type ())
+          octave_stdout << "knobs(3): " << User_knobs (2)
+                        << ", statistics and knobs printed\n";
+
+        }
+    }
+
+  octave_idx_type n_row, n_col, nnz;
+  octave_idx_type *ridx, *cidx;
+  SparseComplexMatrix scm;
+  SparseMatrix sm;
+
+  if (args(0).is_sparse_type ())
+    {
+      if (args(0).is_complex_type ())
         {
-          if (args(0).is_complex_type ())
-            {
-              scm = args(0). sparse_complex_matrix_value ();
-              n_row = scm.rows ();
-              n_col = scm.cols ();
-              nnz = scm.nnz ();
-              ridx = scm.xridx ();
-              cidx = scm.xcidx ();
-            }
-          else
-            {
-              sm = args(0).sparse_matrix_value ();
-
-              n_row = sm.rows ();
-              n_col = sm.cols ();
-              nnz = sm.nnz ();
-              ridx = sm.xridx ();
-              cidx = sm.xcidx ();
-            }
+          scm = args(0). sparse_complex_matrix_value ();
+          n_row = scm.rows ();
+          n_col = scm.cols ();
+          nnz = scm.nnz ();
+          ridx = scm.xridx ();
+          cidx = scm.xcidx ();
         }
       else
         {
-          if (args(0).is_complex_type ())
-            sm = SparseMatrix (real (args(0).complex_matrix_value ()));
-          else
-            sm = SparseMatrix (args(0).matrix_value ());
+          sm = args(0).sparse_matrix_value ();
 
           n_row = sm.rows ();
           n_col = sm.cols ();
           nnz = sm.nnz ();
           ridx = sm.xridx ();
           cidx = sm.xcidx ();
         }
+    }
+  else
+    {
+      if (args(0).is_complex_type ())
+        sm = SparseMatrix (real (args(0).complex_matrix_value ()));
+      else
+        sm = SparseMatrix (args(0).matrix_value ());
 
-      // Allocate workspace for colamd
-      OCTAVE_LOCAL_BUFFER (octave_idx_type, p, n_col+1);
-      for (octave_idx_type i = 0; i < n_col+1; i++)
-        p[i] = cidx[i];
-
-      octave_idx_type Alen = COLAMD_NAME (_recommended) (nnz, n_row, n_col);
-      OCTAVE_LOCAL_BUFFER (octave_idx_type, A, Alen);
-      for (octave_idx_type i = 0; i < nnz; i++)
-        A[i] = ridx[i];
+      n_row = sm.rows ();
+      n_col = sm.cols ();
+      nnz = sm.nnz ();
+      ridx = sm.xridx ();
+      cidx = sm.xcidx ();
+    }
 
-      // Order the columns (destroys A)
-      OCTAVE_LOCAL_BUFFER (octave_idx_type, stats, COLAMD_STATS);
-      if (! COLAMD_NAME () (n_row, n_col, Alen, A, p, knobs, stats))
-        {
-          COLAMD_NAME (_report) (stats) ;
-          error ("colamd: internal error!");
-          return retval;
-        }
+  // Allocate workspace for colamd
+  OCTAVE_LOCAL_BUFFER (octave_idx_type, p, n_col+1);
+  for (octave_idx_type i = 0; i < n_col+1; i++)
+    p[i] = cidx[i];
 
-      // column elimination tree post-ordering (reuse variables)
-      OCTAVE_LOCAL_BUFFER (octave_idx_type, colbeg, n_col + 1);
-      OCTAVE_LOCAL_BUFFER (octave_idx_type, colend, n_col + 1);
-      OCTAVE_LOCAL_BUFFER (octave_idx_type, etree, n_col + 1);
+  octave_idx_type Alen = COLAMD_NAME (_recommended) (nnz, n_row, n_col);
+  OCTAVE_LOCAL_BUFFER (octave_idx_type, A, Alen);
+  for (octave_idx_type i = 0; i < nnz; i++)
+    A[i] = ridx[i];
 
-      for (octave_idx_type i = 0; i < n_col; i++)
-        {
-          colbeg[i] = cidx[p[i]];
-          colend[i] = cidx[p[i]+1];
-        }
+  // Order the columns (destroys A)
+  OCTAVE_LOCAL_BUFFER (octave_idx_type, stats, COLAMD_STATS);
+  if (! COLAMD_NAME () (n_row, n_col, Alen, A, p, knobs, stats))
+    {
+      COLAMD_NAME (_report) (stats) ;
+      error ("colamd: internal error!");
+      return retval;
+    }
 
-      coletree (ridx, colbeg, colend, etree, n_row, n_col);
-
-      // Calculate the tree post-ordering
-      tree_postorder (n_col, etree, colbeg);
+  // column elimination tree post-ordering (reuse variables)
+  OCTAVE_LOCAL_BUFFER (octave_idx_type, colbeg, n_col + 1);
+  OCTAVE_LOCAL_BUFFER (octave_idx_type, colend, n_col + 1);
+  OCTAVE_LOCAL_BUFFER (octave_idx_type, etree, n_col + 1);
 
-      // return the permutation vector
-      NDArray out_perm (dim_vector (1, n_col));
-      for (octave_idx_type i = 0; i < n_col; i++)
-        out_perm(i) = p[colbeg[i]] + 1;
+  for (octave_idx_type i = 0; i < n_col; i++)
+    {
+      colbeg[i] = cidx[p[i]];
+      colend[i] = cidx[p[i]+1];
+    }
 
-      retval(0) = out_perm;
+  coletree (ridx, colbeg, colend, etree, n_row, n_col);
+
+  // Calculate the tree post-ordering
+  tree_postorder (n_col, etree, colbeg);
 
-      // print stats if spumoni > 0
-      if (spumoni > 0)
-        COLAMD_NAME (_report) (stats) ;
+  // return the permutation vector
+  NDArray out_perm (dim_vector (1, n_col));
+  for (octave_idx_type i = 0; i < n_col; i++)
+    out_perm(i) = p[colbeg[i]] + 1;
+
+  retval(0) = out_perm;
+
+  // print stats if spumoni > 0
+  if (spumoni > 0)
+    COLAMD_NAME (_report) (stats) ;
 
-      // Return the stats vector
-      if (nargout == 2)
-        {
-          NDArray out_stats (dim_vector (1, COLAMD_STATS));
-          for (octave_idx_type i = 0 ; i < COLAMD_STATS ; i++)
-            out_stats(i) = stats[i] ;
-          retval(1) = out_stats;
+  // Return the stats vector
+  if (nargout == 2)
+    {
+      NDArray out_stats (dim_vector (1, COLAMD_STATS));
+      for (octave_idx_type i = 0 ; i < COLAMD_STATS ; i++)
+        out_stats(i) = stats[i] ;
+      retval(1) = out_stats;
 
-          // fix stats (5) and (6), for 1-based information on
-          // jumbled matrix.  note that this correction doesn't
-          // occur if symamd returns FALSE
-          out_stats (COLAMD_INFO1) ++ ;
-          out_stats (COLAMD_INFO2) ++ ;
-        }
+      // fix stats (5) and (6), for 1-based information on
+      // jumbled matrix.  note that this correction doesn't
+      // occur if symamd returns FALSE
+      out_stats (COLAMD_INFO1) ++ ;
+      out_stats (COLAMD_INFO2) ++ ;
     }
 
 #else
 
   error ("colamd: not available in this version of Octave");
 
 #endif
 
@@ -519,126 +517,124 @@ Xerox PARC, and @nospell{Esmond Ng}, Oak
 
 #ifdef HAVE_COLAMD
 
   int nargin = args.length ();
   int spumoni = 0;
 
   if (nargout > 2 || nargin < 1 || nargin > 2)
     print_usage ();
-  else
-    {
-      // Get knobs
-      OCTAVE_LOCAL_BUFFER (double, knobs, COLAMD_KNOBS);
-      COLAMD_NAME (_set_defaults) (knobs);
+
+  // Get knobs
+  OCTAVE_LOCAL_BUFFER (double, knobs, COLAMD_KNOBS);
+  COLAMD_NAME (_set_defaults) (knobs);
 
-      // Check for user-passed knobs
-      if (nargin == 2)
-        {
-          NDArray User_knobs = args(1).array_value ();
-          int nel_User_knobs = User_knobs.numel ();
+  // Check for user-passed knobs
+  if (nargin == 2)
+    {
+      NDArray User_knobs = args(1).array_value ();
+      int nel_User_knobs = User_knobs.numel ();
 
-          if (nel_User_knobs > 0)
-            knobs[COLAMD_DENSE_ROW] = User_knobs(COLAMD_DENSE_ROW);
-          if (nel_User_knobs > 1)
-            spumoni = static_cast<int> (User_knobs (1));
-        }
-
-      // print knob settings if spumoni is set
-      if (spumoni > 0)
-        octave_stdout << "symamd: dense row/col fraction: "
-                      << knobs[COLAMD_DENSE_ROW] << std::endl;
+      if (nel_User_knobs > 0)
+        knobs[COLAMD_DENSE_ROW] = User_knobs(COLAMD_DENSE_ROW);
+      if (nel_User_knobs > 1)
+        spumoni = static_cast<int> (User_knobs (1));
+    }
 
-      octave_idx_type n_row, n_col;
-      octave_idx_type *ridx, *cidx;
-      SparseMatrix sm;
-      SparseComplexMatrix scm;
+  // print knob settings if spumoni is set
+  if (spumoni > 0)
+    octave_stdout << "symamd: dense row/col fraction: "
+                  << knobs[COLAMD_DENSE_ROW] << std::endl;
 
-      if (args(0).is_sparse_type ())
+  octave_idx_type n_row, n_col;
+  octave_idx_type *ridx, *cidx;
+  SparseMatrix sm;
+  SparseComplexMatrix scm;
+
+  if (args(0).is_sparse_type ())
+    {
+      if (args(0).is_complex_type ())
         {
-          if (args(0).is_complex_type ())
-            {
-              scm = args(0).sparse_complex_matrix_value ();
-              n_row = scm.rows ();
-              n_col = scm.cols ();
-              ridx = scm.xridx ();
-              cidx = scm.xcidx ();
-            }
-          else
-            {
-              sm = args(0).sparse_matrix_value ();
-              n_row = sm.rows ();
-              n_col = sm.cols ();
-              ridx = sm.xridx ();
-              cidx = sm.xcidx ();
-            }
+          scm = args(0).sparse_complex_matrix_value ();
+          n_row = scm.rows ();
+          n_col = scm.cols ();
+          ridx = scm.xridx ();
+          cidx = scm.xcidx ();
         }
       else
         {
-          if (args(0).is_complex_type ())
-            sm = SparseMatrix (real (args(0).complex_matrix_value ()));
-          else
-            sm = SparseMatrix (args(0).matrix_value ());
-
+          sm = args(0).sparse_matrix_value ();
           n_row = sm.rows ();
           n_col = sm.cols ();
           ridx = sm.xridx ();
           cidx = sm.xcidx ();
         }
+    }
+  else
+    {
+      if (args(0).is_complex_type ())
+        sm = SparseMatrix (real (args(0).complex_matrix_value ()));
+      else
+        sm = SparseMatrix (args(0).matrix_value ());
 
-      if (n_row != n_col)
-        {
-          error ("symamd: matrix S must be square");
-          return retval;
-        }
+      n_row = sm.rows ();
+      n_col = sm.cols ();
+      ridx = sm.xridx ();
+      cidx = sm.xcidx ();
+    }
 
-      // Allocate workspace for symamd
-      OCTAVE_LOCAL_BUFFER (octave_idx_type, perm, n_col+1);
-      OCTAVE_LOCAL_BUFFER (octave_idx_type, stats, COLAMD_STATS);
-      if (!SYMAMD_NAME () (n_col, ridx, cidx, perm,
-                           knobs, stats, &calloc, &free))
-        {
-          SYMAMD_NAME (_report) (stats) ;
-          error ("symamd: internal error!") ;
-          return retval;
-        }
+  if (n_row != n_col)
+    {
+      error ("symamd: matrix S must be square");
+      return retval;
+    }
 
-      // column elimination tree post-ordering
-      OCTAVE_LOCAL_BUFFER (octave_idx_type, etree, n_col + 1);
-      symetree (ridx, cidx, etree, perm, n_col);
-
-      // Calculate the tree post-ordering
-      OCTAVE_LOCAL_BUFFER (octave_idx_type, post, n_col + 1);
-      tree_postorder (n_col, etree, post);
+  // Allocate workspace for symamd
+  OCTAVE_LOCAL_BUFFER (octave_idx_type, perm, n_col+1);
+  OCTAVE_LOCAL_BUFFER (octave_idx_type, stats, COLAMD_STATS);
+  if (!SYMAMD_NAME () (n_col, ridx, cidx, perm,
+                       knobs, stats, &calloc, &free))
+    {
+      SYMAMD_NAME (_report) (stats) ;
+      error ("symamd: internal error!") ;
+      return retval;
+    }
 
-      // return the permutation vector
-      NDArray out_perm (dim_vector (1, n_col));
-      for (octave_idx_type i = 0; i < n_col; i++)
-        out_perm(i) = perm[post[i]] + 1;
+  // column elimination tree post-ordering
+  OCTAVE_LOCAL_BUFFER (octave_idx_type, etree, n_col + 1);
+  symetree (ridx, cidx, etree, perm, n_col);
 
-      retval(0) = out_perm;
+  // Calculate the tree post-ordering
+  OCTAVE_LOCAL_BUFFER (octave_idx_type, post, n_col + 1);
+  tree_postorder (n_col, etree, post);
 
-      // print stats if spumoni > 0
-      if (spumoni > 0)
-        SYMAMD_NAME (_report) (stats) ;
+  // return the permutation vector
+  NDArray out_perm (dim_vector (1, n_col));
+  for (octave_idx_type i = 0; i < n_col; i++)
+    out_perm(i) = perm[post[i]] + 1;
+
+  retval(0) = out_perm;
 
-      // Return the stats vector
-      if (nargout == 2)
-        {
-          NDArray out_stats (dim_vector (1, COLAMD_STATS));
-          for (octave_idx_type i = 0 ; i < COLAMD_STATS ; i++)
-            out_stats(i) = stats[i] ;
-          retval(1) = out_stats;
+  // print stats if spumoni > 0
+  if (spumoni > 0)
+    SYMAMD_NAME (_report) (stats) ;
 
-          // fix stats (5) and (6), for 1-based information on
-          // jumbled matrix.  note that this correction doesn't
-          // occur if symamd returns FALSE
-          out_stats (COLAMD_INFO1) ++ ;
-          out_stats (COLAMD_INFO2) ++ ;
-        }
+  // Return the stats vector
+  if (nargout == 2)
+    {
+      NDArray out_stats (dim_vector (1, COLAMD_STATS));
+      for (octave_idx_type i = 0 ; i < COLAMD_STATS ; i++)
+        out_stats(i) = stats[i] ;
+      retval(1) = out_stats;
+
+      // fix stats (5) and (6), for 1-based information on
+      // jumbled matrix.  note that this correction doesn't
+      // occur if symamd returns FALSE
+      out_stats (COLAMD_INFO1) ++ ;
+      out_stats (COLAMD_INFO2) ++ ;
     }
 
 #else
 
   error ("symamd: not available in this version of Octave");
 
 #endif
 
@@ -664,103 +660,101 @@ permutations on the tree.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargout > 2 || nargin < 1 || nargin > 2)
     print_usage ();
-  else
+
+  octave_idx_type n_row, n_col;
+  octave_idx_type *ridx, *cidx;
+  bool is_sym = true;
+  SparseMatrix sm;
+  SparseComplexMatrix scm;
+
+  if (args(0).is_sparse_type ())
     {
-      octave_idx_type n_row, n_col;
-      octave_idx_type *ridx, *cidx;
-      bool is_sym = true;
-      SparseMatrix sm;
-      SparseComplexMatrix scm;
-
-      if (args(0).is_sparse_type ())
+      if (args(0).is_complex_type ())
         {
-          if (args(0).is_complex_type ())
-            {
-              scm = args(0).sparse_complex_matrix_value ();
-              n_row = scm.rows ();
-              n_col = scm.cols ();
-              ridx = scm.xridx ();
-              cidx = scm.xcidx ();
-            }
-          else
-            {
-              sm = args(0).sparse_matrix_value ();
-              n_row = sm.rows ();
-              n_col = sm.cols ();
-              ridx = sm.xridx ();
-              cidx = sm.xcidx ();
-            }
-
+          scm = args(0).sparse_complex_matrix_value ();
+          n_row = scm.rows ();
+          n_col = scm.cols ();
+          ridx = scm.xridx ();
+          cidx = scm.xcidx ();
         }
       else
         {
-          error ("etree: S must be a sparse matrix");
+          sm = args(0).sparse_matrix_value ();
+          n_row = sm.rows ();
+          n_col = sm.cols ();
+          ridx = sm.xridx ();
+          cidx = sm.xcidx ();
+        }
+
+    }
+  else
+    {
+      error ("etree: S must be a sparse matrix");
+      return retval;
+    }
+
+  if (nargin == 2)
+    {
+      std::string str = args(1).xstring_value ("etree: TYP must be a string");
+      if (str.find ("C") == 0 || str.find ("c") == 0)
+        is_sym = false;
+    }
+
+  // column elimination tree post-ordering (reuse variables)
+  OCTAVE_LOCAL_BUFFER (octave_idx_type, etree, n_col + 1);
+
+  if (is_sym)
+    {
+      if (n_row != n_col)
+        {
+          error ("etree: S is marked as symmetric, but is not square");
           return retval;
         }
 
-      if (nargin == 2)
+      symetree (ridx, cidx, etree, 0, n_col);
+    }
+  else
+    {
+      OCTAVE_LOCAL_BUFFER (octave_idx_type, colbeg, n_col);
+      OCTAVE_LOCAL_BUFFER (octave_idx_type, colend, n_col);
+
+      for (octave_idx_type i = 0; i < n_col; i++)
         {
-          std::string str = args(1).xstring_value ("etree: TYP must be a string");
-          if (str.find ("C") == 0 || str.find ("c") == 0)
-            is_sym = false;
+          colbeg[i] = cidx[i];
+          colend[i] = cidx[i+1];
         }
 
-      // column elimination tree post-ordering (reuse variables)
-      OCTAVE_LOCAL_BUFFER (octave_idx_type, etree, n_col + 1);
-
-      if (is_sym)
-        {
-          if (n_row != n_col)
-            {
-              error ("etree: S is marked as symmetric, but is not square");
-              return retval;
-            }
+      coletree (ridx, colbeg, colend, etree, n_row, n_col);
+    }
 
-          symetree (ridx, cidx, etree, 0, n_col);
-        }
-      else
-        {
-          OCTAVE_LOCAL_BUFFER (octave_idx_type, colbeg, n_col);
-          OCTAVE_LOCAL_BUFFER (octave_idx_type, colend, n_col);
-
-          for (octave_idx_type i = 0; i < n_col; i++)
-            {
-              colbeg[i] = cidx[i];
-              colend[i] = cidx[i+1];
-            }
+  NDArray tree (dim_vector (1, n_col));
+  for (octave_idx_type i = 0; i < n_col; i++)
+    // We flag a root with n_col while Matlab does it with zero
+    // Convert for matlab compatiable output
+    if (etree[i] == n_col)
+      tree(i) = 0;
+    else
+      tree(i) = etree[i] + 1;
 
-          coletree (ridx, colbeg, colend, etree, n_row, n_col);
-        }
-
-      NDArray tree (dim_vector (1, n_col));
-      for (octave_idx_type i = 0; i < n_col; i++)
-        // We flag a root with n_col while Matlab does it with zero
-        // Convert for matlab compatiable output
-        if (etree[i] == n_col)
-          tree(i) = 0;
-        else
-          tree(i) = etree[i] + 1;
+  retval(0) = tree;
 
-      retval(0) = tree;
+  if (nargout == 2)
+    {
+      // Calculate the tree post-ordering
+      OCTAVE_LOCAL_BUFFER (octave_idx_type, post, n_col + 1);
+      tree_postorder (n_col, etree, post);
 
-      if (nargout == 2)
-        {
-          // Calculate the tree post-ordering
-          OCTAVE_LOCAL_BUFFER (octave_idx_type, post, n_col + 1);
-          tree_postorder (n_col, etree, post);
+      NDArray postorder (dim_vector (1, n_col));
+      for (octave_idx_type i = 0; i < n_col; i++)
+        postorder(i) = post[i] + 1;
 
-          NDArray postorder (dim_vector (1, n_col));
-          for (octave_idx_type i = 0; i < n_col; i++)
-            postorder(i) = post[i] + 1;
-
-          retval(1) = postorder;
-        }
+      retval(1) = postorder;
     }
 
   return retval;
 }
diff --git a/libinterp/dldfcn/convhulln.cc b/libinterp/dldfcn/convhulln.cc
--- a/libinterp/dldfcn/convhulln.cc
+++ b/libinterp/dldfcn/convhulln.cc
@@ -108,20 +108,17 @@ convex hull is calculated.\n\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
 #if defined (HAVE_QHULL)
 
   int nargin = args.length ();
   if (nargin < 1 || nargin > 2)
-    {
-      print_usage ();
-      return retval;
-    }
+    print_usage ();
 
   Matrix points (args(0).matrix_value ());
   const octave_idx_type dim = points.columns ();
   const octave_idx_type num_points = points.rows ();
 
   if (! octave_qhull_dims_ok (dim, num_points, "convhulln"))
     return retval;
 
diff --git a/libinterp/dldfcn/dmperm.cc b/libinterp/dldfcn/dmperm.cc
--- a/libinterp/dldfcn/dmperm.cc
+++ b/libinterp/dldfcn/dmperm.cc
@@ -152,20 +152,17 @@ The method used is described in: @nospel
 ACM Trans. Math. Software, 16(4):303-324, 1990.\n\
 @seealso{colamd, ccolamd}\n\
 @end deftypefn")
 {
   int nargin = args.length ();
   octave_value_list retval;
 
   if (nargin != 1)
-    {
-      print_usage ();
-      return retval;
-    }
+    print_usage ();
 
 #if HAVE_CXSPARSE
   retval = dmperm_internal (false, args(0), nargout);
 #else
   error ("dmperm: not available in this version of Octave");
 #endif
 
   return retval;
@@ -201,20 +198,17 @@ such the numerical rank of the matrix @v
 @code{sprank (@var{S}) == rank (@var{S})}.\n\
 @seealso{dmperm}\n\
 @end deftypefn")
 {
   int nargin = args.length ();
   octave_value_list retval;
 
   if (nargin != 1)
-    {
-      print_usage ();
-      return retval;
-    }
+    print_usage ();
 
 #if HAVE_CXSPARSE
   retval = dmperm_internal (true, args(0), nargout);
 #else
   error ("sprank: not available in this version of Octave");
 #endif
 
   return retval;
diff --git a/libinterp/dldfcn/fftw.cc b/libinterp/dldfcn/fftw.cc
--- a/libinterp/dldfcn/fftw.cc
+++ b/libinterp/dldfcn/fftw.cc
@@ -132,20 +132,17 @@ used per default.\n\
 @seealso{fft, ifft, fft2, ifft2, fftn, ifftn}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 2)
-    {
-      print_usage ();
-      return retval;
-    }
+    print_usage ();
 
 #if defined (HAVE_FFTW)
   std::string arg0 = args(0).xstring_value ("fftw: first argument must be a string");
 
   if (arg0 == "planner")
     {
       if (nargin == 2)  //planner setter
         {
diff --git a/libinterp/dldfcn/qr.cc b/libinterp/dldfcn/qr.cc
--- a/libinterp/dldfcn/qr.cc
+++ b/libinterp/dldfcn/qr.cc
@@ -199,20 +199,17 @@ x = @var{R} \\ @var{C}\n\
 @seealso{chol, hess, lu, qz, schur, svd, qrupdate, qrinsert, qrdelete, qrshift}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > (args(0).is_sparse_type () ? 3 : 2))
-    {
-      print_usage ();
-      return retval;
-    }
+    print_usage ();
 
   octave_value arg = args(0);
 
   int arg_is_empty = empty_arg ("qr", arg.rows (), arg.columns ());
 
   if (arg_is_empty < 0)
     return retval;
 
@@ -758,20 +755,17 @@ economized (R is square).\n\
 \n\
 @seealso{qr, qrinsert, qrdelete, qrshift}\n\
 @end deftypefn")
 {
   octave_idx_type nargin = args.length ();
   octave_value_list retval;
 
   if (nargin != 4)
-    {
-      print_usage ();
-      return retval;
-    }
+    print_usage ();
 
   octave_value argq = args(0);
   octave_value argr = args(1);
   octave_value argu = args(2);
   octave_value argv = args(3);
 
   if (argq.is_numeric_type () && argr.is_numeric_type ()
       && argu.is_numeric_type () && argv.is_numeric_type ())
@@ -946,20 +940,17 @@ be either full (Q is square) or economiz
 If @var{orient} is @qcode{\"row\"}, full factorization is needed.\n\
 @seealso{qr, qrupdate, qrdelete, qrshift}\n\
 @end deftypefn")
 {
   octave_idx_type nargin = args.length ();
   octave_value_list retval;
 
   if (nargin < 4 || nargin > 5)
-    {
-      print_usage ();
-      return retval;
-    }
+    print_usage ();
 
   octave_value argq = args(0);
   octave_value argr = args(1);
   octave_value argj = args(2);
   octave_value argx = args(3);
 
   if (argq.is_numeric_type () && argr.is_numeric_type ()
       && argx.is_numeric_type ()
@@ -1165,20 +1156,17 @@ be either full (Q is square) or economiz
 If @var{orient} is @qcode{\"row\"}, full factorization is needed.\n\
 @seealso{qr, qrupdate, qrinsert, qrshift}\n\
 @end deftypefn")
 {
   octave_idx_type nargin = args.length ();
   octave_value_list retval;
 
   if (nargin < 3 || nargin > 4)
-    {
-      print_usage ();
-      return retval;
-    }
+    print_usage ();
 
   octave_value argq = args(0);
   octave_value argr = args(1);
   octave_value argj = args(2);
 
   if (argq.is_numeric_type () && argr.is_numeric_type ()
       && (nargin < 4 || args(3).is_string ()))
     {
@@ -1417,20 +1405,17 @@ of @w{@var{A}(:,p)}, where @w{p} is the 
 \n\
 @seealso{qr, qrupdate, qrinsert, qrdelete}\n\
 @end deftypefn")
 {
   octave_idx_type nargin = args.length ();
   octave_value_list retval;
 
   if (nargin != 4)
-    {
-      print_usage ();
-      return retval;
-    }
+    print_usage ();
 
   octave_value argq = args(0);
   octave_value argr = args(1);
   octave_value argi = args(2);
   octave_value argj = args(3);
 
   if (argq.is_numeric_type () && argr.is_numeric_type ())
     {
diff --git a/libinterp/dldfcn/symbfact.cc b/libinterp/dldfcn/symbfact.cc
--- a/libinterp/dldfcn/symbfact.cc
+++ b/libinterp/dldfcn/symbfact.cc
@@ -95,20 +95,17 @@ A sparse boolean matrix whose structure 
 factorization as determined by @var{typ}.\n\
 @end table\n\
 @end deftypefn")
 {
   octave_value_list retval;
   int nargin = args.length ();
 
   if (nargin < 1  || nargin > 3 || nargout > 5)
-    {
-      print_usage ();
-      return retval;
-    }
+    print_usage ();
 
 #ifdef HAVE_CHOLMOD
 
   cholmod_common Common;
   cholmod_common *cm = &Common;
   CHOLMOD_NAME(start) (cm);
 
   double spu = octave_sparse_params::get_key ("spumoni");
diff --git a/libinterp/dldfcn/symrcm.cc b/libinterp/dldfcn/symrcm.cc
--- a/libinterp/dldfcn/symrcm.cc
+++ b/libinterp/dldfcn/symrcm.cc
@@ -436,20 +436,17 @@ Mathematics, ISBN 0-13-165274-5, 1981.\n
 \n\
 @seealso{colperm, colamd, symamd}\n\
 @end deftypefn")
 {
   octave_value retval;
   int nargin = args.length ();
 
   if (nargin != 1)
-    {
-      print_usage ();
-      return retval;
-    }
+    print_usage ();
 
   octave_value arg = args(0);
 
   // the parameter of the matrix is converted into a sparse matrix
   //(if necessary)
   octave_idx_type *cidx;
   octave_idx_type *ridx;
   SparseMatrix Ar;
