# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1454097320 18000
#      Fri Jan 29 14:55:20 2016 -0500
# Node ID 8ad3907b8fad29630286e25357cd4a90d1c6a68e
# Parent  bfd5e48c41a192cef3204d9e3649c88826a6a307
require CXSparse 2.2 or later

* oct-sparse.h: Require CXSparse 2.2 or later.
* dmperm.cc, SparseCmplxQR.cc, SparseQR.cc, sparse-dmsolve.cc:
Assume CXSparse 2.2 or later.

diff --git a/libinterp/dldfcn/dmperm.cc b/libinterp/dldfcn/dmperm.cc
--- a/libinterp/dldfcn/dmperm.cc
+++ b/libinterp/dldfcn/dmperm.cc
@@ -79,50 +79,38 @@ dmperm_internal (bool rank, const octave
       cm = arg.sparse_complex_matrix_value ();
       csm.nzmax = cm.nnz ();
       csm.p = cm.xcidx ();
       csm.i = cm.xridx ();
     }
 
   if (nargout <= 1 || rank)
     {
-#if defined (CS_VER) && (CS_VER >= 2)
       octave_idx_type *jmatch = CXSPARSE_NAME (_maxtrans) (&csm, 0);
-#else
-      octave_idx_type *jmatch = CXSPARSE_NAME (_maxtrans) (&csm);
-#endif
       if (rank)
         {
           octave_idx_type r = 0;
           for (octave_idx_type i = 0; i < nc; i++)
             if (jmatch[nr+i] >= 0)
               r++;
           retval(0) = static_cast<double>(r);
         }
       else
         retval(0) = put_int (jmatch + nr, nc);
       CXSPARSE_NAME (_free) (jmatch);
     }
   else
     {
-#if defined (CS_VER) && (CS_VER >= 2)
       CXSPARSE_NAME (d) *dm = CXSPARSE_NAME(_dmperm) (&csm, 0);
-#else
-      CXSPARSE_NAME (d) *dm = CXSPARSE_NAME(_dmperm) (&csm);
-#endif
 
       //retval(5) = put_int (dm->rr, 5);
       //retval(4) = put_int (dm->cc, 5);
-#if defined (CS_VER) && (CS_VER >= 2)
       retval = ovl (put_int (dm->p, nr), put_int (dm->q, nc),
                     put_int (dm->r, dm->nb+1), put_int (dm->s, dm->nb+1));
-#else
-      retval = ovl (put_int (dm->P, nr), put_int (dm->Q, nc),
-                    put_int (dm->R, dm->nb+1), put_int (dm->S, dm->nb+1));
-#endif
+
       CXSPARSE_NAME (_dfree) (dm);
     }
 
   return retval;
 }
 #endif
 
 DEFUN_DLD (dmperm, args, nargout,
diff --git a/liboctave/numeric/SparseCmplxQR.cc b/liboctave/numeric/SparseCmplxQR.cc
--- a/liboctave/numeric/SparseCmplxQR.cc
+++ b/liboctave/numeric/SparseCmplxQR.cc
@@ -24,35 +24,16 @@ along with Octave; see the file COPYING.
 #include <config.h>
 #endif
 #include <vector>
 
 #include "lo-error.h"
 #include "SparseCmplxQR.h"
 #include "oct-locbuf.h"
 
-#if defined (CS_VER) && (((CS_VER == 2) && (CS_SUBVER < 2)) || (CS_VER < 2))
-typedef double _Complex cs_complex_t;
-
-// Why did g++ 4.x stl_vector.h make
-//   OCTAVE_LOCAL_BUFFER (cs_complex_t, buf, n)
-// an error ?
-#define OCTAVE_C99_COMPLEX(buf, n) \
-  OCTAVE_LOCAL_BUFFER (double, buf ## tmp, (2 * (n))); \
-  cs_complex_t *buf = reinterpret_cast<cs_complex_t *> (buf ## tmp);
-
-#define OCTAVE_C99_ZERO (0. + 0.iF)
-#define OCTAVE_C99_ONE (1. + 0.iF)
-#else
-#define OCTAVE_C99_COMPLEX(buf, n) \
-  OCTAVE_LOCAL_BUFFER (cs_complex_t, buf, (n));
-#define OCTAVE_C99_ZERO cs_complex_t(0., 0.);
-#define OCTAVE_C99_ONE cs_complex_t(1., 0.);
-#endif
-
 SparseComplexQR::SparseComplexQR_rep::SparseComplexQR_rep
   (OCTAVE_UNUSED const SparseComplexMatrix& a, OCTAVE_UNUSED int order)
   : count (1), nrows (0)
 #ifdef HAVE_CXSPARSE
     , S (0), N (0)
 #endif
 {
 #ifdef HAVE_CXSPARSE
@@ -64,21 +45,17 @@ SparseComplexQR::SparseComplexQR_rep::Sp
   // Cast away const on A, with full knowledge that CSparse won't touch it
   // Prevents the methods below making a copy of the data.
   A.p = const_cast<octave_idx_type *>(a.cidx ());
   A.i = const_cast<octave_idx_type *>(a.ridx ());
   A.x = const_cast<cs_complex_t *>(reinterpret_cast<const cs_complex_t *>
                                    (a.data ()));
   A.nz = -1;
   BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined (CS_VER) && (CS_VER >= 2)
   S = CXSPARSE_ZNAME (_sqr) (order, &A, 1);
-#else
-  S = CXSPARSE_ZNAME (_sqr) (&A, order - 1, 1);
-#endif
   N = CXSPARSE_ZNAME (_qr) (&A, S);
   END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
   if (! N)
     (*current_liboctave_error_handler)
       ("SparseComplexQR: sparse matrix QR factorization filled");
 
   count = 1;
 
@@ -127,38 +104,30 @@ SparseComplexQR::SparseComplexQR_rep::V 
 }
 
 ColumnVector
 SparseComplexQR::SparseComplexQR_rep::Pinv (void) const
 {
 #ifdef HAVE_CXSPARSE
   ColumnVector ret(N->L->m);
   for (octave_idx_type i = 0; i < N->L->m; i++)
-#if defined (CS_VER) && (CS_VER >= 2)
     ret.xelem (i) = S->pinv[i];
-#else
-    ret.xelem (i) = S->Pinv[i];
-#endif
   return ret;
 #else
   return ColumnVector ();
 #endif
 }
 
 ColumnVector
 SparseComplexQR::SparseComplexQR_rep::P (void) const
 {
 #ifdef HAVE_CXSPARSE
   ColumnVector ret(N->L->m);
   for (octave_idx_type i = 0; i < N->L->m; i++)
-#if defined (CS_VER) && (CS_VER >= 2)
     ret.xelem (S->pinv[i]) = i;
-#else
-    ret.xelem (S->Pinv[i]) = i;
-#endif
   return ret;
 #else
   return ColumnVector ();
 #endif
 }
 
 SparseComplexMatrix
 SparseComplexQR::SparseComplexQR_rep::R (const bool econ) const
@@ -210,23 +179,18 @@ SparseComplexQR::SparseComplexQR_rep::C 
   else
     {
       OCTAVE_LOCAL_BUFFER (Complex, buf, S->m2);
       for (volatile octave_idx_type j = 0, idx = 0; j < b_nc; j++, idx+=b_nr)
         {
           octave_quit ();
           volatile octave_idx_type nm = (nr < nc ? nr : nc);
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_ZNAME (_ipvec)
             (S->pinv, bvec + idx, reinterpret_cast<cs_complex_t *>(buf), b_nr);
-#else
-          CXSPARSE_ZNAME (_ipvec)
-            (b_nr, S->Pinv, bvec + idx, reinterpret_cast<cs_complex_t *>(buf));
-#endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type i = 0; i < nm; i++)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               CXSPARSE_ZNAME (_happly)
                 (N->L, i, N->B[i], reinterpret_cast<cs_complex_t *>(buf));
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
@@ -251,45 +215,40 @@ SparseComplexQR::SparseComplexQR_rep::Q 
   Complex *vec = ret.fortran_vec ();
   if (nr < 0 || nc < 0)
     (*current_liboctave_error_handler) ("matrix dimension mismatch");
 
   if (nr == 0 || nc == 0)
     ret = ComplexMatrix (nc, nr, Complex (0.0, 0.0));
   else
     {
-      OCTAVE_C99_COMPLEX (bvec, nr);
+      OCTAVE_LOCAL_BUFFER (cs_complex_t, bvec, nr);
       for (octave_idx_type i = 0; i < nr; i++)
-        bvec[i] = OCTAVE_C99_ZERO;
+        bvec[i] = cs_complex_t (0.0, 0.0);
       OCTAVE_LOCAL_BUFFER (Complex, buf, S->m2);
       for (volatile octave_idx_type j = 0, idx = 0; j < nr; j++, idx+=nr)
         {
           octave_quit ();
-          bvec[j] = OCTAVE_C99_ONE;
+          bvec[j] = cs_complex_t (1.0, 0.0);
           volatile octave_idx_type nm = (nr < nc ? nr : nc);
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_ZNAME (_ipvec)
             (S->pinv, bvec, reinterpret_cast<cs_complex_t *>(buf), nr);
-#else
-          CXSPARSE_ZNAME (_ipvec)
-            (nr, S->Pinv, bvec, reinterpret_cast<cs_complex_t *>(buf));
-#endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type i = 0; i < nm; i++)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               CXSPARSE_ZNAME (_happly)
                 (N->L, i, N->B[i], reinterpret_cast<cs_complex_t *>(buf));
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
           for (octave_idx_type i = 0; i < nr; i++)
             vec[i+idx] = buf[i];
-          bvec[j] = OCTAVE_C99_ZERO;
+          bvec[j] = cs_complex_t (0.0, 0.0);
         }
     }
   return ret.hermitian ();
 #else
   return ComplexMatrix ();
 #endif
 }
 
@@ -312,108 +271,78 @@ qrsolve (const SparseComplexMatrix&a, co
     x = ComplexMatrix (nc, b_nc, Complex (0.0, 0.0));
   else if (nr >= nc)
     {
       SparseComplexQR q (a, 2);
       if (! q.ok ())
         return ComplexMatrix ();
       x.resize (nc, b_nc);
       cs_complex_t *vec = reinterpret_cast<cs_complex_t *> (x.fortran_vec ());
-      OCTAVE_C99_COMPLEX (buf, q.S ()->m2);
+      OCTAVE_LOCAL_BUFFER (cs_complex_t, buf, q.S ()->m2);
       OCTAVE_LOCAL_BUFFER (Complex, Xx, b_nr);
       for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
         {
           octave_quit ();
           for (octave_idx_type j = 0; j < b_nr; j++)
             Xx[j] = b.xelem (j,i);
           for (octave_idx_type j = nr; j < q.S ()->m2; j++)
-            buf[j] = OCTAVE_C99_ZERO;
+            buf[j] = cs_complex_t (0.0, 0.0);
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_ZNAME (_ipvec)
             (q.S ()->pinv, reinterpret_cast<cs_complex_t *>(Xx), buf, nr);
-#else
-          CXSPARSE_ZNAME (_ipvec)
-            (nr, q.S ()->Pinv, reinterpret_cast<cs_complex_t *>(Xx), buf);
-#endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type j = 0; j < nc; j++)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               CXSPARSE_ZNAME (_happly) (q.N ()->L, j, q.N ()->B[j], buf);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           CXSPARSE_ZNAME (_usolve) (q.N ()->U, buf);
-#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_ZNAME (_ipvec) (q.S ()->q, buf, vec + idx, nc);
-#else
-          CXSPARSE_ZNAME (_ipvec) (nc, q.S ()->Q, buf, vec + idx);
-#endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
         }
       info = 0;
     }
   else
     {
       SparseComplexMatrix at = a.hermitian ();
       SparseComplexQR q (at, 2);
       if (! q.ok ())
         return ComplexMatrix ();
       x.resize (nc, b_nc);
       cs_complex_t *vec = reinterpret_cast<cs_complex_t *> (x.fortran_vec ());
       volatile octave_idx_type nbuf = (nc > q.S ()->m2 ? nc : q.S ()->m2);
-      OCTAVE_C99_COMPLEX (buf, nbuf);
+      OCTAVE_LOCAL_BUFFER (cs_complex_t, buf, nbuf);
       OCTAVE_LOCAL_BUFFER (Complex, Xx, b_nr);
-#if defined (CS_VER) && (((CS_VER == 2) && (CS_SUBVER >= 2)) || (CS_VER > 2))
       OCTAVE_LOCAL_BUFFER (double, B, nr);
       for (octave_idx_type i = 0; i < nr; i++)
         B[i] = q.N ()->B[i];
-#else
-      OCTAVE_LOCAL_BUFFER (Complex, B, nr);
-      for (octave_idx_type i = 0; i < nr; i++)
-        B[i] = conj (reinterpret_cast<Complex *>(q.N ()->B)[i]);
-#endif
       for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
         {
           octave_quit ();
           for (octave_idx_type j = 0; j < b_nr; j++)
             Xx[j] = b.xelem (j,i);
           for (octave_idx_type j = nr; j < nbuf; j++)
-            buf[j] = OCTAVE_C99_ZERO;
+            buf[j] = cs_complex_t (0.0, 0.0);
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_ZNAME (_pvec)
             (q.S ()->q, reinterpret_cast<cs_complex_t *>(Xx), buf, nr);
-#else
-          CXSPARSE_ZNAME (_pvec)
-            (nr, q.S ()->Q, reinterpret_cast<cs_complex_t *>(Xx), buf);
-#endif
           CXSPARSE_ZNAME (_utsolve) (q.N ()->U, buf);
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type j = nr-1; j >= 0; j--)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-
-#if defined (CS_VER) && (((CS_VER == 2) && (CS_SUBVER >= 2)) || (CS_VER > 2))
               CXSPARSE_ZNAME (_happly) (q.N ()->L, j, B[j], buf);
-#else
-              CXSPARSE_ZNAME (_happly)
-                (q.N ()->L, j, reinterpret_cast<cs_complex_t *>(B)[j], buf);
-#endif
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_ZNAME (_pvec) (q.S ()->pinv, buf, vec + idx, nc);
-#else
-          CXSPARSE_ZNAME (_pvec) (nc, q.S ()->Pinv, buf, vec + idx);
-#endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
         }
       info = 0;
     }
 
   return x;
 #else
   return ComplexMatrix ();
@@ -444,49 +373,39 @@ qrsolve (const SparseComplexMatrix&a, co
       SparseComplexQR q (a, 2);
       if (! q.ok ())
         return SparseComplexMatrix ();
       x = SparseComplexMatrix (nc, b_nc, b.nnz ());
       x.xcidx (0) = 0;
       x_nz = b.nnz ();
       ii = 0;
       OCTAVE_LOCAL_BUFFER (Complex, Xx, (b_nr > nc ? b_nr : nc));
-      OCTAVE_C99_COMPLEX (buf, q.S ()->m2);
+      OCTAVE_LOCAL_BUFFER (cs_complex_t, buf, q.S ()->m2);
       for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
         {
           octave_quit ();
           for (octave_idx_type j = 0; j < b_nr; j++)
             Xx[j] = b.xelem (j,i);
           for (octave_idx_type j = nr; j < q.S ()->m2; j++)
-            buf[j] = OCTAVE_C99_ZERO;
+            buf[j] = cs_complex_t (0.0, 0.0);
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_ZNAME (_ipvec)
             (q.S ()->pinv, reinterpret_cast<cs_complex_t *>(Xx), buf, nr);
-#else
-          CXSPARSE_ZNAME (_ipvec)
-            (nr, q.S ()->Pinv, reinterpret_cast<cs_complex_t *>(Xx), buf);
-#endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type j = 0; j < nc; j++)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               CXSPARSE_ZNAME (_happly) (q.N ()->L, j, q.N ()->B[j], buf);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           CXSPARSE_ZNAME (_usolve) (q.N ()->U, buf);
-#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_ZNAME (_ipvec)
             (q.S ()->q, buf, reinterpret_cast<cs_complex_t *>(Xx), nc);
-#else
-          CXSPARSE_ZNAME (_ipvec)
-            (nc, q.S ()->Q, buf, reinterpret_cast<cs_complex_t *>(Xx));
-#endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
           for (octave_idx_type j = 0; j < nc; j++)
             {
               Complex tmp = Xx[j];
               if (tmp != 0.0)
                 {
                   if (ii == x_nz)
@@ -512,64 +431,44 @@ qrsolve (const SparseComplexMatrix&a, co
       if (! q.ok ())
         return SparseComplexMatrix ();
       x = SparseComplexMatrix (nc, b_nc, b.nnz ());
       x.xcidx (0) = 0;
       x_nz = b.nnz ();
       ii = 0;
       volatile octave_idx_type nbuf = (nc > q.S ()->m2 ? nc : q.S ()->m2);
       OCTAVE_LOCAL_BUFFER (Complex, Xx, (b_nr > nc ? b_nr : nc));
-      OCTAVE_C99_COMPLEX (buf, nbuf);
+      OCTAVE_LOCAL_BUFFER (cs_complex_t, buf, nbuf);
 
-#if defined (CS_VER) && (((CS_VER == 2) && (CS_SUBVER >= 2)) || (CS_VER > 2))
       OCTAVE_LOCAL_BUFFER (double, B, nr);
       for (octave_idx_type i = 0; i < nr; i++)
         B[i] = q.N ()->B[i];
-#else
-      OCTAVE_LOCAL_BUFFER (Complex, B, nr);
-      for (octave_idx_type i = 0; i < nr; i++)
-        B[i] = conj (reinterpret_cast<Complex *>(q.N ()->B)[i]);
-#endif
+
       for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
         {
           octave_quit ();
           for (octave_idx_type j = 0; j < b_nr; j++)
             Xx[j] = b.xelem (j,i);
           for (octave_idx_type j = nr; j < nbuf; j++)
-            buf[j] = OCTAVE_C99_ZERO;
+            buf[j] = cs_complex_t (0.0, 0.0);
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_ZNAME (_pvec)
             (q.S ()->q, reinterpret_cast<cs_complex_t *>(Xx), buf, nr);
-#else
-          CXSPARSE_ZNAME (_pvec)
-            (nr, q.S ()->Q, reinterpret_cast<cs_complex_t *>(Xx), buf);
-#endif
           CXSPARSE_ZNAME (_utsolve) (q.N ()->U, buf);
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type j = nr-1; j >= 0; j--)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined (CS_VER) && (((CS_VER == 2) && (CS_SUBVER >= 2)) || (CS_VER > 2))
               CXSPARSE_ZNAME (_happly) (q.N ()->L, j, B[j], buf);
-#else
-              CXSPARSE_ZNAME (_happly)
-                (q.N ()->L, j, reinterpret_cast<cs_complex_t *>(B)[j], buf);
-#endif
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_ZNAME (_pvec)
             (q.S ()->pinv, buf, reinterpret_cast<cs_complex_t *>(Xx), nc);
-#else
-          CXSPARSE_ZNAME (_pvec)
-            (nc, q.S ()->Pinv, buf, reinterpret_cast<cs_complex_t *>(Xx));
-#endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
           for (octave_idx_type j = 0; j < nc; j++)
             {
               Complex tmp = Xx[j];
               if (tmp != 0.0)
                 {
                   if (ii == x_nz)
@@ -619,99 +518,72 @@ qrsolve (const SparseComplexMatrix&a, co
   else if (nr >= nc)
     {
       SparseComplexQR q (a, 2);
       if (! q.ok ())
         return ComplexMatrix ();
       x.resize (nc, b_nc);
       cs_complex_t *vec = reinterpret_cast<cs_complex_t *>
                           (x.fortran_vec ());
-      OCTAVE_C99_COMPLEX (buf, q.S ()->m2);
+      OCTAVE_LOCAL_BUFFER (cs_complex_t, buf, q.S ()->m2);
       for (volatile octave_idx_type i = 0, idx = 0, bidx = 0; i < b_nc;
            i++, idx+=nc, bidx+=b_nr)
         {
           octave_quit ();
           for (octave_idx_type j = nr; j < q.S ()->m2; j++)
-            buf[j] = OCTAVE_C99_ZERO;
+            buf[j] = cs_complex_t (0.0, 0.0);
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_ZNAME (_ipvec) (q.S ()->pinv, bvec + bidx, buf, nr);
-#else
-          CXSPARSE_ZNAME (_ipvec) (nr, q.S ()->Pinv, bvec + bidx, buf);
-#endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type j = 0; j < nc; j++)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               CXSPARSE_ZNAME (_happly) (q.N ()->L, j, q.N ()->B[j], buf);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           CXSPARSE_ZNAME (_usolve) (q.N ()->U, buf);
-#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_ZNAME (_ipvec) (q.S ()->q, buf, vec + idx, nc);
-#else
-          CXSPARSE_ZNAME (_ipvec) (nc, q.S ()->Q, buf, vec + idx);
-#endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
         }
       info = 0;
     }
   else
     {
       SparseComplexMatrix at = a.hermitian ();
       SparseComplexQR q (at, 2);
       if (! q.ok ())
         return ComplexMatrix ();
       x.resize (nc, b_nc);
       cs_complex_t *vec = reinterpret_cast<cs_complex_t *> (x.fortran_vec ());
       volatile octave_idx_type nbuf = (nc > q.S ()->m2 ? nc : q.S ()->m2);
-      OCTAVE_C99_COMPLEX (buf, nbuf);
-#if defined (CS_VER) && (((CS_VER == 2) && (CS_SUBVER >= 2)) || (CS_VER > 2))
+      OCTAVE_LOCAL_BUFFER (cs_complex_t, buf, nbuf);
       OCTAVE_LOCAL_BUFFER (double, B, nr);
       for (octave_idx_type i = 0; i < nr; i++)
         B[i] = q.N ()->B[i];
-#else
-      OCTAVE_LOCAL_BUFFER (Complex, B, nr);
-      for (octave_idx_type i = 0; i < nr; i++)
-        B[i] = conj (reinterpret_cast<Complex *>(q.N ()->B)[i]);
-#endif
       for (volatile octave_idx_type i = 0, idx = 0, bidx = 0; i < b_nc;
            i++, idx+=nc, bidx+=b_nr)
         {
           octave_quit ();
           for (octave_idx_type j = nr; j < nbuf; j++)
-            buf[j] = OCTAVE_C99_ZERO;
+            buf[j] = cs_complex_t (0.0, 0.0);
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_ZNAME (_pvec) (q.S ()->q, bvec + bidx, buf, nr);
-#else
-          CXSPARSE_ZNAME (_pvec) (nr, q.S ()->Q, bvec + bidx, buf);
-#endif
           CXSPARSE_ZNAME (_utsolve) (q.N ()->U, buf);
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type j = nr-1; j >= 0; j--)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined (CS_VER) && (((CS_VER == 2) && (CS_SUBVER >= 2)) || (CS_VER > 2))
               CXSPARSE_ZNAME (_happly) (q.N ()->L, j, B[j], buf);
-#else
-              CXSPARSE_ZNAME (_happly)
-                (q.N ()->L, j, reinterpret_cast<cs_complex_t *>(B)[j], buf);
-#endif
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_ZNAME (_pvec) (q.S ()->pinv, buf, vec + idx, nc);
-#else
-          CXSPARSE_ZNAME (_pvec) (nc, q.S ()->Pinv, buf, vec + idx);
-#endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
         }
       info = 0;
     }
 
   return x;
 #else
   return ComplexMatrix ();
@@ -742,49 +614,39 @@ qrsolve (const SparseComplexMatrix&a, co
       SparseComplexQR q (a, 2);
       if (! q.ok ())
         return SparseComplexMatrix ();
       x = SparseComplexMatrix (nc, b_nc, b.nnz ());
       x.xcidx (0) = 0;
       x_nz = b.nnz ();
       ii = 0;
       OCTAVE_LOCAL_BUFFER (Complex, Xx, (b_nr > nc ? b_nr : nc));
-      OCTAVE_C99_COMPLEX (buf, q.S ()->m2);
+      OCTAVE_LOCAL_BUFFER (cs_complex_t, buf, q.S ()->m2);
       for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
         {
           octave_quit ();
           for (octave_idx_type j = 0; j < b_nr; j++)
             Xx[j] = b.xelem (j,i);
           for (octave_idx_type j = nr; j < q.S ()->m2; j++)
-            buf[j] = OCTAVE_C99_ZERO;
+            buf[j] = cs_complex_t (0.0, 0.0);
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_ZNAME (_ipvec)
             (q.S ()->pinv, reinterpret_cast<cs_complex_t *>(Xx), buf, nr);
-#else
-          CXSPARSE_ZNAME (_ipvec)
-            (nr, q.S ()->Pinv, reinterpret_cast<cs_complex_t *>(Xx), buf);
-#endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type j = 0; j < nc; j++)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               CXSPARSE_ZNAME (_happly) (q.N ()->L, j, q.N ()->B[j], buf);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           CXSPARSE_ZNAME (_usolve) (q.N ()->U, buf);
-#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_ZNAME (_ipvec)
             (q.S ()->q, buf, reinterpret_cast<cs_complex_t *>(Xx), nc);
-#else
-          CXSPARSE_ZNAME (_ipvec)
-            (nc, q.S ()->Q, buf, reinterpret_cast<cs_complex_t *>(Xx));
-#endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
           for (octave_idx_type j = 0; j < nc; j++)
             {
               Complex tmp = Xx[j];
               if (tmp != 0.0)
                 {
                   if (ii == x_nz)
@@ -810,63 +672,42 @@ qrsolve (const SparseComplexMatrix&a, co
       if (! q.ok ())
         return SparseComplexMatrix ();
       x = SparseComplexMatrix (nc, b_nc, b.nnz ());
       x.xcidx (0) = 0;
       x_nz = b.nnz ();
       ii = 0;
       volatile octave_idx_type nbuf = (nc > q.S ()->m2 ? nc : q.S ()->m2);
       OCTAVE_LOCAL_BUFFER (Complex, Xx, (b_nr > nc ? b_nr : nc));
-      OCTAVE_C99_COMPLEX (buf, nbuf);
-#if defined (CS_VER) && (((CS_VER == 2) && (CS_SUBVER >= 2)) || (CS_VER > 2))
+      OCTAVE_LOCAL_BUFFER (cs_complex_t, buf, nbuf);
       OCTAVE_LOCAL_BUFFER (double, B, nr);
       for (octave_idx_type i = 0; i < nr; i++)
         B[i] = q.N ()->B[i];
-#else
-      OCTAVE_LOCAL_BUFFER (Complex, B, nr);
-      for (octave_idx_type i = 0; i < nr; i++)
-        B[i] = conj (reinterpret_cast<Complex *>(q.N ()->B)[i]);
-#endif
       for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
         {
           octave_quit ();
           for (octave_idx_type j = 0; j < b_nr; j++)
             Xx[j] = b.xelem (j,i);
           for (octave_idx_type j = nr; j < nbuf; j++)
-            buf[j] = OCTAVE_C99_ZERO;
+            buf[j] = cs_complex_t (0.0, 0.0);
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_ZNAME (_pvec)
             (q.S ()->q, reinterpret_cast<cs_complex_t *>(Xx), buf, nr);
-#else
-          CXSPARSE_ZNAME (_pvec)
-            (nr, q.S ()->Q, reinterpret_cast<cs_complex_t *>(Xx), buf);
-#endif
           CXSPARSE_ZNAME (_utsolve) (q.N ()->U, buf);
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type j = nr-1; j >= 0; j--)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined (CS_VER) && (((CS_VER == 2) && (CS_SUBVER >= 2)) || (CS_VER > 2))
               CXSPARSE_ZNAME (_happly) (q.N ()->L, j, B[j], buf);
-#else
-              CXSPARSE_ZNAME (_happly)
-                (q.N ()->L, j, reinterpret_cast<cs_complex_t *>(B)[j], buf);
-#endif
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_ZNAME (_pvec)
             (q.S ()->pinv, buf, reinterpret_cast<cs_complex_t *>(Xx), nc);
-#else
-          CXSPARSE_ZNAME (_pvec)
-            (nc, q.S ()->Pinv, buf, reinterpret_cast<cs_complex_t *>(Xx));
-#endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
           for (octave_idx_type j = 0; j < nc; j++)
             {
               Complex tmp = Xx[j];
               if (tmp != 0.0)
                 {
                   if (ii == x_nz)
diff --git a/liboctave/numeric/SparseQR.cc b/liboctave/numeric/SparseQR.cc
--- a/liboctave/numeric/SparseQR.cc
+++ b/liboctave/numeric/SparseQR.cc
@@ -43,21 +43,17 @@ SparseQR::SparseQR_rep::SparseQR_rep (co
   nrows = A.m;
   // Cast away const on A, with full knowledge that CSparse won't touch it
   // Prevents the methods below making a copy of the data.
   A.p = const_cast<octave_idx_type *>(a.cidx ());
   A.i = const_cast<octave_idx_type *>(a.ridx ());
   A.x = const_cast<double *>(a.data ());
   A.nz = -1;
   BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined (CS_VER) && (CS_VER >= 2)
   S = CXSPARSE_DNAME (_sqr) (order, &A, 1);
-#else
-  S = CXSPARSE_DNAME (_sqr) (&A, order - 1, 1);
-#endif
 
   N = CXSPARSE_DNAME (_qr) (&A, S);
   END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
   if (! N)
     (*current_liboctave_error_handler)
       ("SparseQR: sparse matrix QR factorization filled");
 
   count = 1;
@@ -107,38 +103,30 @@ SparseQR::SparseQR_rep::V (void) const
 }
 
 ColumnVector
 SparseQR::SparseQR_rep::Pinv (void) const
 {
 #ifdef HAVE_CXSPARSE
   ColumnVector ret(N->L->m);
   for (octave_idx_type i = 0; i < N->L->m; i++)
-#if defined (CS_VER) && (CS_VER >= 2)
     ret.xelem (i) = S->pinv[i];
-#else
-    ret.xelem (i) = S->Pinv[i];
-#endif
   return ret;
 #else
   return ColumnVector ();
 #endif
 }
 
 ColumnVector
 SparseQR::SparseQR_rep::P (void) const
 {
 #ifdef HAVE_CXSPARSE
   ColumnVector ret(N->L->m);
   for (octave_idx_type i = 0; i < N->L->m; i++)
-#if defined (CS_VER) && (CS_VER >= 2)
     ret.xelem (S->pinv[i]) = i;
-#else
-    ret.xelem (S->Pinv[i]) = i;
-#endif
   return ret;
 #else
   return ColumnVector ();
 #endif
 }
 
 SparseMatrix
 SparseQR::SparseQR_rep::R (const bool econ) const
@@ -193,21 +181,17 @@ SparseQR::SparseQR_rep::C (const Matrix 
       OCTAVE_LOCAL_BUFFER (double, buf, S->m2);
       for (volatile octave_idx_type j = 0, idx = 0; j < b_nc; j++, idx+=b_nr)
         {
           octave_quit ();
           for (octave_idx_type i = nr; i < S->m2; i++)
             buf[i] = 0.;
           volatile octave_idx_type nm = (nr < nc ? nr : nc);
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_DNAME (_ipvec) (S->pinv, bvec + idx, buf, b_nr);
-#else
-          CXSPARSE_DNAME (_ipvec) (b_nr, S->Pinv, bvec + idx, buf);
-#endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
           for (volatile octave_idx_type i = 0; i < nm; i++)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               CXSPARSE_DNAME (_happly) (N->L, i, N->B[i], buf);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
@@ -244,21 +228,17 @@ SparseQR::SparseQR_rep::Q (void) const
       for (volatile octave_idx_type j = 0, idx = 0; j < nr; j++, idx+=nr)
         {
           octave_quit ();
           bvec[j] = 1.0;
           for (octave_idx_type i = nr; i < S->m2; i++)
             buf[i] = 0.;
           volatile octave_idx_type nm = (nr < nc ? nr : nc);
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_DNAME (_ipvec) (S->pinv, bvec, buf, nr);
-#else
-          CXSPARSE_DNAME (_ipvec) (nr, S->Pinv, bvec, buf);
-#endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
           for (volatile octave_idx_type i = 0; i < nm; i++)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               CXSPARSE_DNAME (_happly) (N->L, i, N->B[i], buf);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
@@ -302,36 +282,28 @@ qrsolve (const SparseMatrix&a, const Mat
       OCTAVE_LOCAL_BUFFER (double, buf, q.S ()->m2);
       for (volatile octave_idx_type i = 0, idx = 0, bidx = 0; i < b_nc;
            i++, idx+=nc, bidx+=b_nr)
         {
           octave_quit ();
           for (octave_idx_type j = nr; j < q.S ()->m2; j++)
             buf[j] = 0.;
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_DNAME (_ipvec) (q.S ()->pinv, bvec + bidx, buf, nr);
-#else
-          CXSPARSE_DNAME (_ipvec) (nr, q.S ()->Pinv, bvec + bidx, buf);
-#endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type j = 0; j < nc; j++)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               CXSPARSE_DNAME (_happly) (q.N ()->L, j, q.N ()->B[j], buf);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           CXSPARSE_DNAME (_usolve) (q.N ()->U, buf);
-#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_DNAME (_ipvec) (q.S ()->q, buf, vec + idx, nc);
-#else
-          CXSPARSE_DNAME (_ipvec) (nc, q.S ()->Q, buf, vec + idx);
-#endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
         }
       info = 0;
     }
   else
     {
       SparseMatrix at = a.hermitian ();
       SparseQR q (at, 3);
@@ -343,36 +315,28 @@ qrsolve (const SparseMatrix&a, const Mat
       OCTAVE_LOCAL_BUFFER (double, buf, nbuf);
       for (volatile octave_idx_type i = 0, idx = 0, bidx = 0; i < b_nc;
            i++, idx+=nc, bidx+=b_nr)
         {
           octave_quit ();
           for (octave_idx_type j = nr; j < nbuf; j++)
             buf[j] = 0.;
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_DNAME (_pvec) (q.S ()->q, bvec + bidx, buf, nr);
-#else
-          CXSPARSE_DNAME (_pvec) (nr, q.S ()->Q, bvec + bidx, buf);
-#endif
           CXSPARSE_DNAME (_utsolve) (q.N ()->U, buf);
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type j = nr-1; j >= 0; j--)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               CXSPARSE_DNAME (_happly) (q.N ()->L, j, q.N ()->B[j], buf);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_DNAME (_pvec) (q.S ()->pinv, buf, vec + idx, nc);
-#else
-          CXSPARSE_DNAME (_pvec) (nc, q.S ()->Pinv, buf, vec + idx);
-#endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
         }
       info = 0;
     }
 
   return x;
 #else
   return Matrix ();
@@ -411,36 +375,28 @@ qrsolve (const SparseMatrix&a, const Spa
       for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
         {
           octave_quit ();
           for (octave_idx_type j = 0; j < b_nr; j++)
             Xx[j] = b.xelem (j,i);
           for (octave_idx_type j = nr; j < q.S ()->m2; j++)
             buf[j] = 0.;
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_DNAME (_ipvec) (q.S ()->pinv, Xx, buf, nr);
-#else
-          CXSPARSE_DNAME (_ipvec) (nr, q.S ()->Pinv, Xx, buf);
-#endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type j = 0; j < nc; j++)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               CXSPARSE_DNAME (_happly) (q.N ()->L, j, q.N ()->B[j], buf);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           CXSPARSE_DNAME (_usolve) (q.N ()->U, buf);
-#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_DNAME (_ipvec) (q.S ()->q, buf, Xx, nc);
-#else
-          CXSPARSE_DNAME (_ipvec) (nc, q.S ()->Q, buf, Xx);
-#endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
           for (octave_idx_type j = 0; j < nc; j++)
             {
               double tmp = Xx[j];
               if (tmp != 0.0)
                 {
                   if (ii == x_nz)
@@ -475,36 +431,28 @@ qrsolve (const SparseMatrix&a, const Spa
       for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
         {
           octave_quit ();
           for (octave_idx_type j = 0; j < b_nr; j++)
             Xx[j] = b.xelem (j,i);
           for (octave_idx_type j = nr; j < nbuf; j++)
             buf[j] = 0.;
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_DNAME (_pvec) (q.S ()->q, Xx, buf, nr);
-#else
-          CXSPARSE_DNAME (_pvec) (nr, q.S ()->Q, Xx, buf);
-#endif
           CXSPARSE_DNAME (_utsolve) (q.N ()->U, buf);
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type j = nr-1; j >= 0; j--)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               CXSPARSE_DNAME (_happly) (q.N ()->L, j, q.N ()->B[j], buf);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_DNAME (_pvec) (q.S ()->pinv, buf, Xx, nc);
-#else
-          CXSPARSE_DNAME (_pvec) (nc, q.S ()->Pinv, buf, Xx);
-#endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
           for (octave_idx_type j = 0; j < nc; j++)
             {
               double tmp = Xx[j];
               if (tmp != 0.0)
                 {
                   if (ii == x_nz)
@@ -565,58 +513,42 @@ qrsolve (const SparseMatrix&a, const Com
             {
               Complex c = b.xelem (j,i);
               Xx[j] = std::real (c);
               Xz[j] = std::imag (c);
             }
           for (octave_idx_type j = nr; j < q.S ()->m2; j++)
             buf[j] = 0.;
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_DNAME (_ipvec) (q.S ()->pinv, Xx, buf, nr);
-#else
-          CXSPARSE_DNAME (_ipvec) (nr, q.S ()->Pinv, Xx, buf);
-#endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type j = 0; j < nc; j++)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               CXSPARSE_DNAME (_happly) (q.N ()->L, j, q.N ()->B[j], buf);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           CXSPARSE_DNAME (_usolve) (q.N ()->U, buf);
-#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_DNAME (_ipvec) (q.S ()->q, buf, Xx, nc);
-#else
-          CXSPARSE_DNAME (_ipvec) (nc, q.S ()->Q, buf, Xx);
-#endif
           for (octave_idx_type j = nr; j < q.S ()->m2; j++)
             buf[j] = 0.;
-#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_DNAME (_ipvec) (q.S ()->pinv, Xz, buf, nr);
-#else
-          CXSPARSE_DNAME (_ipvec) (nr, q.S ()->Pinv, Xz, buf);
-#endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type j = 0; j < nc; j++)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               CXSPARSE_DNAME (_happly) (q.N ()->L, j, q.N ()->B[j], buf);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           CXSPARSE_DNAME (_usolve) (q.N ()->U, buf);
-#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_DNAME (_ipvec) (q.S ()->q, buf, Xz, nc);
-#else
-          CXSPARSE_DNAME (_ipvec) (nc, q.S ()->Q, buf, Xz);
-#endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (octave_idx_type j = 0; j < nc; j++)
             vec[j+idx] = Complex (Xx[j], Xz[j]);
         }
       info = 0;
     }
   else
     {
@@ -637,60 +569,44 @@ qrsolve (const SparseMatrix&a, const Com
             {
               Complex c = b.xelem (j,i);
               Xx[j] = std::real (c);
               Xz[j] = std::imag (c);
             }
           for (octave_idx_type j = nr; j < nbuf; j++)
             buf[j] = 0.;
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_DNAME (_pvec) (q.S ()->q, Xx, buf, nr);
-#else
-          CXSPARSE_DNAME (_pvec) (nr, q.S ()->Q, Xx, buf);
-#endif
           CXSPARSE_DNAME (_utsolve) (q.N ()->U, buf);
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type j = nr-1; j >= 0; j--)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               CXSPARSE_DNAME (_happly) (q.N ()->L, j, q.N ()->B[j], buf);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_DNAME (_pvec) (q.S ()->pinv, buf, Xx, nc);
-#else
-          CXSPARSE_DNAME (_pvec) (nc, q.S ()->Pinv, buf, Xx);
-#endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (octave_idx_type j = nr; j < nbuf; j++)
             buf[j] = 0.;
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_DNAME (_pvec) (q.S ()->q, Xz, buf, nr);
-#else
-          CXSPARSE_DNAME (_pvec) (nr, q.S ()->Q, Xz, buf);
-#endif
           CXSPARSE_DNAME (_utsolve) (q.N ()->U, buf);
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type j = nr-1; j >= 0; j--)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               CXSPARSE_DNAME (_happly) (q.N ()->L, j, q.N ()->B[j], buf);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_DNAME (_pvec) (q.S ()->pinv, buf, Xz, nc);
-#else
-          CXSPARSE_DNAME (_pvec) (nc, q.S ()->Pinv, buf, Xz);
-#endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (octave_idx_type j = 0; j < nc; j++)
             vec[j+idx] = Complex (Xx[j], Xz[j]);
         }
       info = 0;
     }
 
   return x;
@@ -737,60 +653,44 @@ qrsolve (const SparseMatrix&a, const Spa
             {
               Complex c = b.xelem (j,i);
               Xx[j] = std::real (c);
               Xz[j] = std::imag (c);
             }
           for (octave_idx_type j = nr; j < q.S ()->m2; j++)
             buf[j] = 0.;
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_DNAME (_ipvec) (q.S ()->pinv, Xx, buf, nr);
-#else
-          CXSPARSE_DNAME (_ipvec) (nr, q.S ()->Pinv, Xx, buf);
-#endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type j = 0; j < nc; j++)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               CXSPARSE_DNAME (_happly) (q.N ()->L, j, q.N ()->B[j], buf);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           CXSPARSE_DNAME (_usolve) (q.N ()->U, buf);
-#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_DNAME (_ipvec) (q.S ()->q, buf, Xx, nc);
-#else
-          CXSPARSE_DNAME (_ipvec) (nc, q.S ()->Q, buf, Xx);
-#endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (octave_idx_type j = nr; j < q.S ()->m2; j++)
             buf[j] = 0.;
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_DNAME (_ipvec) (q.S ()->pinv, Xz, buf, nr);
-#else
-          CXSPARSE_DNAME (_ipvec) (nr, q.S ()->Pinv, Xz, buf);
-#endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type j = 0; j < nc; j++)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               CXSPARSE_DNAME (_happly) (q.N ()->L, j, q.N ()->B[j], buf);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           CXSPARSE_DNAME (_usolve) (q.N ()->U, buf);
-#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_DNAME (_ipvec) (q.S ()->q, buf, Xz, nc);
-#else
-          CXSPARSE_DNAME (_ipvec) (nc, q.S ()->Q, buf, Xz);
-#endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
           for (octave_idx_type j = 0; j < nc; j++)
             {
               Complex tmp = Complex (Xx[j], Xz[j]);
               if (tmp != 0.0)
                 {
                   if (ii == x_nz)
@@ -830,60 +730,44 @@ qrsolve (const SparseMatrix&a, const Spa
             {
               Complex c = b.xelem (j,i);
               Xx[j] = std::real (c);
               Xz[j] = std::imag (c);
             }
           for (octave_idx_type j = nr; j < nbuf; j++)
             buf[j] = 0.;
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_DNAME (_pvec) (q.S ()->q, Xx, buf, nr);
-#else
-          CXSPARSE_DNAME (_pvec) (nr, q.S ()->Q, Xx, buf);
-#endif
           CXSPARSE_DNAME (_utsolve) (q.N ()->U, buf);
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type j = nr-1; j >= 0; j--)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               CXSPARSE_DNAME (_happly) (q.N ()->L, j, q.N ()->B[j], buf);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_DNAME (_pvec) (q.S ()->pinv, buf, Xx, nc);
-#else
-          CXSPARSE_DNAME (_pvec) (nc, q.S ()->Pinv, buf, Xx);
-#endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (octave_idx_type j = nr; j < nbuf; j++)
             buf[j] = 0.;
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_DNAME (_pvec) (q.S ()->q, Xz, buf, nr);
-#else
-          CXSPARSE_DNAME (_pvec) (nr, q.S ()->Q, Xz, buf);
-#endif
           CXSPARSE_DNAME (_utsolve) (q.N ()->U, buf);
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type j = nr-1; j >= 0; j--)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               CXSPARSE_DNAME (_happly) (q.N ()->L, j, q.N ()->B[j], buf);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_DNAME (_pvec) (q.S ()->pinv, buf, Xz, nc);
-#else
-          CXSPARSE_DNAME (_pvec) (nc, q.S ()->Pinv, buf, Xz);
-#endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
           for (octave_idx_type j = 0; j < nc; j++)
             {
               Complex tmp = Complex (Xx[j], Xz[j]);
               if (tmp != 0.0)
                 {
                   if (ii == x_nz)
diff --git a/liboctave/numeric/sparse-dmsolve.cc b/liboctave/numeric/sparse-dmsolve.cc
--- a/liboctave/numeric/sparse-dmsolve.cc
+++ b/liboctave/numeric/sparse-dmsolve.cc
@@ -317,25 +317,20 @@ dmsolve (const ST &a, const T &b, octave
       csm.x = 0;
       csm.nz = -1;
       csm.nzmax = a.nnz ();
       // Cast away const on A, with full knowledge that CSparse won't touch it.
       // Prevents the methods below making a copy of the data.
       csm.p = const_cast<octave_idx_type *>(a.cidx ());
       csm.i = const_cast<octave_idx_type *>(a.ridx ());
 
-#if defined (CS_VER) && (CS_VER >= 2)
       CXSPARSE_DNAME (d) *dm = CXSPARSE_DNAME(_dmperm) (&csm, 0);
       octave_idx_type *p = dm->p;
       octave_idx_type *q = dm->q;
-#else
-      CXSPARSE_DNAME (d) *dm = CXSPARSE_DNAME(_dmperm) (&csm);
-      octave_idx_type *p = dm->P;
-      octave_idx_type *q = dm->Q;
-#endif
+
       OCTAVE_LOCAL_BUFFER (octave_idx_type, pinv, nr);
       for (octave_idx_type i = 0; i < nr; i++)
         pinv[p[i]] = i;
       RT btmp;
       dmsolve_permute (btmp, b, pinv);
       info = 0;
       retval.resize (nc, b_nc);
 
diff --git a/liboctave/util/oct-sparse.h b/liboctave/util/oct-sparse.h
--- a/liboctave/util/oct-sparse.h
+++ b/liboctave/util/oct-sparse.h
@@ -78,16 +78,28 @@ along with Octave; see the file COPYING.
 #elif defined (HAVE_UFSPARSE_CS_H)
 #include <ufsparse/cs.h>
 #elif defined (HAVE_CXSPARSE_CS_H)
 #include <cxsparse/cs.h>
 #elif defined (HAVE_CS_H)
 #include <cs.h>
 #endif
 
+// Yes, it would be better to use a configure script check for
+// required CXSparse features, but that seems more trouble than it is
+// worth in this case.
+
+#if (defined (HAVE_CXSPARSE)                    \
+     && (! defined (CS_VER) \
+         || CS_VER < 2 \
+         || (CS_VER == 2 && CS_SUBVER < 2)))
+#error "Octave requires CXSparse version 2.2 or later"
+#error "Upgrade CXSparse (SuiteSparse) or configure Octave with --disable-cxsparse"
+#endif
+
 #if (defined (HAVE_SUITESPARSE_CHOLMOD_H) \
      || defined (HAVE_UFSPARSE_CHOLMOD_H) \
      || defined (HAVE_CHOLMOD_CHOLMOD_H) \
      || defined (HAVE_CHOLMOD_H))
 #if defined (ENABLE_64)
 #define CHOLMOD_NAME(name) cholmod_l_ ## name
 #else
 #define CHOLMOD_NAME(name) cholmod_ ## name
