# HG changeset patch
# User David Bateman <dbateman@free.fr>
# Date 1212418665 -7200
#      Mon Jun 02 16:57:45 2008 +0200
# Node ID 87865ed7405f5b6f63c8475ec53382c12eaa70a4
# Parent  12a68443191cb98fdace024862cfcabd29934889
Second set of single precision test code and fix of resulting bugs

diff --git a/liboctave/ChangeLog b/liboctave/ChangeLog
--- a/liboctave/ChangeLog
+++ b/liboctave/ChangeLog
@@ -1,8 +1,25 @@
+2008-06-02  David Bateman  <dbateman@free.fr>
+
+	* fCmplxDET.cc (FloatComplexDET::value_will_overflow,
+	FloatComplexDET:value_will_underflow): Replace DBL_MIN and DBL_MAX
+	with FLT_MIN and FLT_MAX.
+	* floatDET.cc ((FloatDET::value_will_overflow,
+	FloatDET:value_will_underflow): Ditto.
+	* lo-cieee.c (__lo_ieee_float_is_NA): Check only a sngle word for
+	float NA value.
+	(lo_ieee_float_inf_value): Return correct float Infinity value.
+	(lo_ieee_float_NA_value): Return correct float NA value.
+	(lo_ieee_float_NaN_value): Return correct float NaN value.
+	* lo-ieee.cc (octave_ieee_init): Set float NA value correctly.
+	* lo-ieee.h (lo_ieee_float): value of union is of type float.
+	(LO_IEEE_NA_FLOAT): Make NA value a valid float NaN.
+	(LO_IEEE_NA_FLOAT_LW): Delete.
+
 2008-06-02  David Bateman  <dbateman@free.fr>
 
 	* fCmplxLU.cc (class FloatComplexLU): Correct error in instantiation.
 	* floatLU.cc (class FloatLU): ditto.
 	* floatLU.h (class FloatLU): ditto.
 	
 	* floatAEPBAL.cc (octave_idx_type FloatAEPBALANCE::init (const
 	FloatMatrix&, const std::string&)): Use FloatMatrix to initialize
diff --git a/liboctave/fCmplxDET.cc b/liboctave/fCmplxDET.cc
--- a/liboctave/fCmplxDET.cc
+++ b/liboctave/fCmplxDET.cc
@@ -32,26 +32,26 @@ along with Octave; see the file COPYING.
 #include "lo-mappers.h"
 #include "lo-math.h"
 #include "oct-cmplx.h"
 
 bool
 FloatComplexDET::value_will_overflow (void) const
 {
   return base2
-    ? (e2 + 1 > xlog2 (DBL_MAX) ? 1 : 0)
-    : (e10 + 1 > log10 (DBL_MAX) ? 1 : 0);
+    ? (e2 + 1 > xlog2 (FLT_MAX) ? 1 : 0)
+    : (e10 + 1 > log10 (FLT_MAX) ? 1 : 0);
 }
 
 bool
 FloatComplexDET::value_will_underflow (void) const
 {
   return base2
-    ? (e2 - 1 < xlog2 (DBL_MIN) ? 1 : 0)
-    : (e10 - 1 < log10 (DBL_MIN) ? 1 : 0);
+    ? (e2 - 1 < xlog2 (FLT_MIN) ? 1 : 0)
+    : (e10 - 1 < log10 (FLT_MIN) ? 1 : 0);
 }
 
 void
 FloatComplexDET::initialize10 (void)
 {
   if (c2 != static_cast<float> (0.0))
     {
       float etmp = e2 / xlog2 (static_cast<float>(10));
diff --git a/liboctave/floatDET.cc b/liboctave/floatDET.cc
--- a/liboctave/floatDET.cc
+++ b/liboctave/floatDET.cc
@@ -30,37 +30,37 @@ along with Octave; see the file COPYING.
 #include "floatDET.h"
 #include "lo-mappers.h"
 #include "lo-math.h"
 
 bool
 FloatDET::value_will_overflow (void) const
 {
   return base2
-    ? (e2 + 1 > xlog2 (DBL_MAX) ? 1 : 0)
-    : (e10 + 1 > log10 (DBL_MAX) ? 1 : 0);
+    ? (e2 + 1 > xlog2 (FLT_MAX) ? 1 : 0)
+    : (e10 + 1 > log10 (FLT_MAX) ? 1 : 0);
 }
 
 bool
 FloatDET::value_will_underflow (void) const
 {
   return base2
-    ? (e2 - 1 < xlog2 (DBL_MIN) ? 1 : 0)
-    : (e10 - 1 < log10 (DBL_MIN) ? 1 : 0);
+    ? (e2 - 1 < xlog2 (FLT_MIN) ? 1 : 0)
+    : (e10 - 1 < log10 (FLT_MIN) ? 1 : 0);
 }
 
 void
 FloatDET::initialize10 (void)
 {
   if (c2 != 0.0)
     {
       float etmp = e2 / xlog2 (static_cast<float>(10));
       e10 = static_cast<int> (xround (etmp));
       etmp -= e10;
-      c10 = c2 * pow (10.0, etmp);
+      c10 = c2 * powf (10.0, etmp);
     }
 }
 
 void
 FloatDET::initialize2 (void)
 {
   if (c10 != 0.0)
     {
@@ -69,16 +69,16 @@ FloatDET::initialize2 (void)
       etmp -= e2;
       c2 = c10 * xexp2 (etmp);
     }
 }
 
 float
 FloatDET::value (void) const
 {
-  return base2 ? c2 * xexp2 (static_cast<float>(e2)) : c10 * pow (10.0, e10);
+  return base2 ? c2 * xexp2 (static_cast<float>(e2)) : c10 * powf (10.0, e10);
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/lo-cieee.c b/liboctave/lo-cieee.c
--- a/liboctave/lo-cieee.c
+++ b/liboctave/lo-cieee.c
@@ -239,44 +239,44 @@ int
 }
 
 int
 __lo_ieee_float_is_NA (float x)
 {
 #if defined (HAVE_ISNAN)
   lo_ieee_float t;
   t.value = x;
-  return (isnan (x) && (t.word & 0xFFFF) == LO_IEEE_NA_FLOAT_LW) ? 1 : 0;
+  return (isnan (x) && (t.word == LO_IEEE_NA_FLOAT)) ? 1 : 0;
 #else
   return 0;
 #endif
 }
 
 int
 __lo_ieee_float_is_NaN_or_NA (float x)
 {
   return __lo_ieee_float_isnan (x);
 }
 
 float
 lo_ieee_float_inf_value (void)
 {
-  return octave_Inf;
+  return octave_Float_Inf;
 }
 
 float
 lo_ieee_float_na_value (void)
 {
-  return octave_NA;
+  return octave_Float_NA;
 }
 
 float
 lo_ieee_float_nan_value (void)
 {
-  return octave_NaN;
+  return octave_Float_NaN;
 }
 
 #if ! (defined (signbit) || defined (HAVE_DECL_SIGNBIT)) && defined (HAVE_SIGNBIT)
 extern int signbit (float);
 #endif
 
 int
 __lo_ieee_float_signbit (float x)
diff --git a/liboctave/lo-ieee.cc b/liboctave/lo-ieee.cc
--- a/liboctave/lo-ieee.cc
+++ b/liboctave/lo-ieee.cc
@@ -132,17 +132,20 @@ octave_ieee_init (void)
 	    if (float_tmp_inf == float_tmp)
 	      break;
 	    float_tmp = float_tmp_inf;
 	  }
 #endif
 
 	octave_Float_NaN = float_tmp_inf / float_tmp_inf;
 	octave_Float_Inf = float_tmp_inf;
-	octave_Float_NA = LO_IEEE_NA_FLOAT;
+
+	lo_ieee_float tf;
+	tf.word = LO_IEEE_NA_FLOAT;
+	octave_Float_NA = tf.value;
       }
       break;
 
     case oct_mach_info::flt_fmt_cray:
     case oct_mach_info::flt_fmt_vax_d:
     case oct_mach_info::flt_fmt_vax_g:
       break;
 
diff --git a/liboctave/lo-ieee.h b/liboctave/lo-ieee.h
--- a/liboctave/lo-ieee.h
+++ b/liboctave/lo-ieee.h
@@ -55,24 +55,23 @@ extern OCTAVE_API int lo_ieee_lw;
 typedef union
 {
   double value;
   unsigned int word[2];
 } lo_ieee_double;
 
 typedef union
 {
-  double value;
+  float value;
   unsigned int word;
 } lo_ieee_float;
 
 #define LO_IEEE_NA_HW 0x7ff00000
 #define LO_IEEE_NA_LW 1954
-#define LO_IEEE_NA_FLOAT 0x7ff007a2
-#define LO_IEEE_NA_FLOAT_LW 0x07a2
+#define LO_IEEE_NA_FLOAT   0x7f8207a2
 
 extern OCTAVE_API void octave_ieee_init (void);
 
 #if defined (SCO)
 extern int __isnan (double);
 extern int __isinf (double);
 extern int __isnanf (float);
 extern int __isinff (float);
diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,8 +1,59 @@
+2008-06-02  David Bateman  <dbateman@free.fr>
+
+	* chol.cc (Fcholinv, Fchol2inv, Fcholupdate, Fcholinsert,
+	Fcholdelete, Fcholshift): Allow single precision arguments.
+	(Fchol): Move test code here. Add test code for single precision.
+	(Fcholupdate, Fcholinsert, Fcholdelete, Fcholshift): Add test code
+	for single precision.
+	* conv2.cc (Fconv2): Add single precision test code.
+	* det.cc (Fdet): For single values or empty matrices, return
+	single precision arg for single precion input. Move test code
+	here. Add single precision test code.
+	* fft.cc (do_fft): For empty single precision arguments return a
+	single precision value. Add single precision test code. Remove
+	fft2 test code.
+	* fft2.cc (do_fft2): For empty single precision arguments return a
+	single precision value. Add single precision test code. Move fft2
+	test code here.
+	* fftn.cc (do_fftn): For empty single precision arguments return a
+	single precision value.
+	* eig.cc (Feig):  Move test code here. Add single precision test
+	code.
+	* expm.cc (Fexpm): Ditto.
+	* find.cc (Ffind): Ditto.
+	* hess.cc (Fhess): Ditto.
+	* inv.cc (Finc): Ditto.
+	* lu.cc (Flu): Ditto.
+	* qr.cc (Fqr): Ditto.
+	* schur.cc (Fschur): Ditto.
+	* svd.cc (Fsvd): Ditto.
+	* syl.cc (Fsyl): Ditto.
+	
+	* op-fcm-fcm.cc, op-fcm-fcs.cc, op-fcm-fm.cc, op-fcm-fs.cc, 
+	op-fcs-fcm.cc, op-fcs-fcs.cc, op-fcs-fm.cc, op-fcs-fs.cc, 
+	op-fm-fcm.cc, op-fm-fcs.cc, op-fm-fm.cc, op-fm-fs.cc, 
+	op-fs-fcm.cc, op-fs-fcs.cc, op-fs-fm.cc, op-fs-fs.cc: Add mixed
+	double, single precision concatenation operators.
+
+	* data.cc (Fall, Fany, Fdiag, Fcat, Fismatrix, Fones, Fzeros,
+	Finf, FNaN, FNA, Feye, Flinspace, Freshape, Ftranspose,
+	Fctranspose, Fsort). Move tests here. Add single precision tests.
+	* mappers.cc (Ffinite, Fisinf, Fisna, Fisnan): Ditto.
+	* ov-float.cc (octave_float_scalar:resize): single precision
+	return value.
+	* ov.cc (octave_value::octave_value (const
+	FloatComplexDiagMatrix&)): Ditto.
+	* data.cc (Fnorm): Add single precision.
+	(do_cat): Disable fast return and skipping empty matrices, as they
+	play a part in determining the return type.
+	* ov.cc (octave_value do_cat_op (const octave_value&, const
+	octave_value&, const Array<octave_idx_type>&)): ditto.
+
 2008-06-02  Jaroslav Hajek <highegg@gmail.com>
 
 	* ov-cell.cc (Fcellstr): For compatibility with Matlab, return {''}
 	when given ''.
 
 2008-05-21  David Bateman  <dbateman@free.fr>
 
 	* DLD-FUNCTIONS/quad.cc (quad_float_user_function): New function.
diff --git a/src/DLD-FUNCTIONS/chol.cc b/src/DLD-FUNCTIONS/chol.cc
--- a/src/DLD-FUNCTIONS/chol.cc
+++ b/src/DLD-FUNCTIONS/chol.cc
@@ -318,16 +318,28 @@ sparse matrices.\n\
 	  else
 	    gripe_wrong_type_arg ("chol", arg);
 	}
     }
 
   return retval;
 }
 
+/*
+
+%!assert(chol ([2, 1; 1, 1]), [sqrt(2), 1/sqrt(2); 0, 1/sqrt(2)], sqrt (eps));
+%!assert(chol (single([2, 1; 1, 1])), single([sqrt(2), 1/sqrt(2); 0, 1/sqrt(2)]), sqrt (eps('single')));
+
+%!error chol ([1, 2; 3, 4]);
+%!error chol ([1, 2; 3, 4; 5, 6]);
+%!error <Invalid call to chol.*> chol ();
+%!error <unexpected second or third input.*> chol (1, 2);
+
+ */
+
 DEFUN_DLD (cholinv, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} cholinv (@var{a})\n\
 Use the Cholesky factorization to compute the inverse of the\n\
 symmetric positive definite matrix @var{a}.\n\
 @seealso{chol, chol2inv}\n\
 @end deftypefn")
 {
@@ -374,16 +386,49 @@ symmetric positive definite matrix @var{
 			retval = chol.inverse ();
 		      else
 			error ("cholinv: matrix not positive definite");
 		    }
 		}
 	      else
 		gripe_wrong_type_arg ("cholinv", arg);
 	    }
+	  else if (arg.is_single_type ())
+	    {
+	      if (arg.is_real_type ())
+		{
+		  FloatMatrix m = arg.float_matrix_value ();
+
+		  if (! error_state)
+		    {
+		      octave_idx_type info;
+		      FloatCHOL chol (m, info);
+		      if (info == 0)
+			retval = chol.inverse ();
+		      else
+			error ("cholinv: matrix not positive definite");
+		    }
+		}
+	      else if (arg.is_complex_type ())
+		{
+		  FloatComplexMatrix m = arg.float_complex_matrix_value ();
+
+		  if (! error_state)
+		    {
+		      octave_idx_type info;
+		      FloatComplexCHOL chol (m, info);
+		      if (info == 0)
+			retval = chol.inverse ();
+		      else
+			error ("cholinv: matrix not positive definite");
+		    }
+		}
+	      else
+		gripe_wrong_type_arg ("chol", arg);
+	    }
 	  else
 	    {
 	      if (arg.is_real_type ())
 		{
 		  Matrix m = arg.matrix_value ();
 
 		  if (! error_state)
 		    {
@@ -460,16 +505,36 @@ using @code{inv}.\n\
 		  SparseComplexMatrix r = arg.sparse_complex_matrix_value ();
 
 		  if (! error_state)
 		    retval = chol2inv (r);
 		}
 	      else
 		gripe_wrong_type_arg ("chol2inv", arg);
 	    }
+	  else if (arg.is_single_type ())
+	    {
+	      if (arg.is_real_type ())
+		{
+		  FloatMatrix r = arg.float_matrix_value ();
+
+		  if (! error_state)
+		    retval = chol2inv (r);
+		}
+	      else if (arg.is_complex_type ())
+		{
+		  FloatComplexMatrix r = arg.float_complex_matrix_value ();
+
+		  if (! error_state)
+		    retval = chol2inv (r);
+		}
+	      else
+		gripe_wrong_type_arg ("chol2inv", arg);
+
+	    }
 	  else
 	    {
 	      if (arg.is_real_type ())
 		{
 		  Matrix r = arg.matrix_value ();
 
 		  if (! error_state)
 		    retval = chol2inv (r);
@@ -538,118 +603,196 @@ If @var{info} is not present, an error m
 
       std::string op = (nargin < 3) ? "+" : args(2).string_value ();
 
       bool down = op == "-";
 
       if (down || op == "+")
         if (argr.columns () == n && argu.rows () == n && argu.columns () == 1)
           {
-            if (argr.is_real_matrix () && argu.is_real_matrix ())
-              {
-                // real case
-                Matrix R = argr.matrix_value ();
-                Matrix u = argu.matrix_value ();
+	    if (argr.is_single_type () || argu.is_single_type ())
+	      {
+		if (argr.is_real_matrix () && argu.is_real_matrix ())
+		  {
+		    // real case
+		    FloatMatrix R = argr.float_matrix_value ();
+		    FloatMatrix u = argu.float_matrix_value ();
 
-                CHOL fact;
-                fact.set (R);
-                int err = 0;
+		    FloatCHOL fact;
+		    fact.set (R);
+		    int err = 0;
+
+		    if (down)
+		      err = fact.downdate (u);
+		    else
+		      fact.update (u);
+
+		    if (nargout > 1)
+		      retval(1) = err;
+		    else if (err)
+		      error ("cholupdate: downdate violates positiveness");
 
-                if (down)
-                  err = fact.downdate (u);
-                else
-                  fact.update (u);
+		    retval(0) = fact.chol_matrix ();
+		  }
+		else
+		  {
+		    // complex case
+		    FloatComplexMatrix R = argr.float_complex_matrix_value ();
+		    FloatComplexMatrix u = argu.float_complex_matrix_value ();
 
-                if (nargout > 1)
-                  retval(1) = err;
-                else if (err)
-                  error ("cholupdate: downdate violates positiveness");
+		    FloatComplexCHOL fact;
+		    fact.set (R);
+		    int err = 0;
+
+		    if (down)
+		      err = fact.downdate (u);
+		    else
+		      fact.update (u);
+
+		    if (nargout > 1)
+		      retval(1) = err;
+		    else if (err)
+		      error ("cholupdate: downdate violates positiveness");
 
-                retval(0) = fact.chol_matrix ();
-              }
-            else
-              {
-                // complex case
-                ComplexMatrix R = argr.complex_matrix_value ();
-                ComplexMatrix u = argu.complex_matrix_value ();
+		    retval(0) = fact.chol_matrix ();
+		  }
+	      }
+	    else
+	      {
+		if (argr.is_real_matrix () && argu.is_real_matrix ())
+		  {
+		    // real case
+		    Matrix R = argr.matrix_value ();
+		    Matrix u = argu.matrix_value ();
 
-                ComplexCHOL fact;
-                fact.set (R);
-                int err = 0;
+		    CHOL fact;
+		    fact.set (R);
+		    int err = 0;
+
+		    if (down)
+		      err = fact.downdate (u);
+		    else
+		      fact.update (u);
+
+		    if (nargout > 1)
+		      retval(1) = err;
+		    else if (err)
+		      error ("cholupdate: downdate violates positiveness");
 
-                if (down)
-                  err = fact.downdate (u);
-                else
-                  fact.update (u);
+		    retval(0) = fact.chol_matrix ();
+		  }
+		else
+		  {
+		    // complex case
+		    ComplexMatrix R = argr.complex_matrix_value ();
+		    ComplexMatrix u = argu.complex_matrix_value ();
+
+		    ComplexCHOL fact;
+		    fact.set (R);
+		    int err = 0;
 
-                if (nargout > 1)
-                  retval(1) = err;
-                else if (err)
-                  error ("cholupdate: downdate violates positiveness");
+		    if (down)
+		      err = fact.downdate (u);
+		    else
+		      fact.update (u);
 
-                retval(0) = fact.chol_matrix ();
-              }
+		    if (nargout > 1)
+		      retval(1) = err;
+		    else if (err)
+		      error ("cholupdate: downdate violates positiveness");
+
+		    retval(0) = fact.chol_matrix ();
+		  }
+	      }
           }
         else
           error ("cholupdate: dimension mismatch");
       else
         error ("cholupdate: op must be \"+\" or \"-\"");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-%!test
+%!shared A, u, Ac, uc
 %! A = [  0.436997  -0.131721   0.124120  -0.061673 ;
 %!       -0.131721   0.738529   0.019851  -0.140295 ;
 %!        0.124120   0.019851   0.354879  -0.059472 ;
 %!       -0.061673  -0.140295  -0.059472   0.600939 ];
 %! 
 %! u = [  0.98950 ;
 %!        0.39844 ;
 %!        0.63484 ;
 %!        0.13351 ];
+%! Ac = [  0.5585528 + 0.0000000i  -0.1662088 - 0.0315341i   0.0107873 + 0.0236411i  -0.0276775 - 0.0186073i ;
+%!        -0.1662088 + 0.0315341i   0.6760061 + 0.0000000i   0.0011452 - 0.0475528i   0.0145967 + 0.0247641i ;
+%!         0.0107873 - 0.0236411i   0.0011452 + 0.0475528i   0.6263149 - 0.0000000i  -0.1585837 - 0.0719763i ;
+%!        -0.0276775 + 0.0186073i   0.0145967 - 0.0247641i  -0.1585837 + 0.0719763i   0.6034234 - 0.0000000i ];
 %! 
+%! uc = [ 0.54267 + 0.91519i ;
+%!        0.99647 + 0.43141i ;
+%!        0.83760 + 0.68977i ;
+%!        0.39160 + 0.90378i ];
+
+
+
+%!test
 %! R = chol(A);
 %! 
 %! R1 = cholupdate(R,u);
 %! 
 %! assert(norm(triu(R1)-R1,Inf) == 0)
 %! assert(norm(R1'*R1 - R'*R - u*u',Inf) < 1e1*eps)
 %! 
 %! R1 = cholupdate(R1,u,"-");
 %! 
 %! assert(norm(triu(R1)-R1,Inf) == 0)
 %! assert(norm(R1 - R,Inf) < 1e1*eps)
 %! 
 %!test
-%! A = [  0.5585528 + 0.0000000i  -0.1662088 - 0.0315341i   0.0107873 + 0.0236411i  -0.0276775 - 0.0186073i ;
-%!       -0.1662088 + 0.0315341i   0.6760061 + 0.0000000i   0.0011452 - 0.0475528i   0.0145967 + 0.0247641i ;
-%!        0.0107873 - 0.0236411i   0.0011452 + 0.0475528i   0.6263149 - 0.0000000i  -0.1585837 - 0.0719763i ;
-%!       -0.0276775 + 0.0186073i   0.0145967 - 0.0247641i  -0.1585837 + 0.0719763i   0.6034234 - 0.0000000i ];
+%! R = chol(Ac);
 %! 
-%! u = [ 0.54267 + 0.91519i ;
-%!       0.99647 + 0.43141i ;
-%!       0.83760 + 0.68977i ;
-%!       0.39160 + 0.90378i ];
-%! 
-%! R = chol(A);
-%! 
-%! R1 = cholupdate(R,u);
+%! R1 = cholupdate(R,uc);
 %! 
 %! assert(norm(triu(R1)-R1,Inf) == 0)
-%! assert(norm(R1'*R1 - R'*R - u*u',Inf) < 1e1*eps)
+%! assert(norm(R1'*R1 - R'*R - uc*uc',Inf) < 1e1*eps)
 %! 
-%! R1 = cholupdate(R1,u,"-");
+%! R1 = cholupdate(R1,uc,"-");
 %! 
 %! assert(norm(triu(R1)-R1,Inf) == 0)
 %! assert(norm(R1 - R,Inf) < 1e1*eps)
+
+%!test
+%! R = chol(single(A));
+%! 
+%! R1 = cholupdate(R,single(u));
+%! 
+%! assert(norm(triu(R1)-R1,Inf) == 0)
+%! assert(norm(R1'*R1 - R'*R - single(u*u'),Inf) < 1e1*eps('single'))
+%! 
+%! R1 = cholupdate(R1,single(u),"-");
+%! 
+%! assert(norm(triu(R1)-R1,Inf) == 0)
+%! assert(norm(R1 - R,Inf) < 1e1*eps('single'))
+%! 
+%!test
+%! R = chol(single(Ac));
+%! 
+%! R1 = cholupdate(R,single(uc));
+%! 
+%! assert(norm(triu(R1)-R1,Inf) == 0)
+%! assert(norm(R1'*R1 - R'*R - single(uc*uc'),Inf) < 1e1*eps('single'))
+%! 
+%! R1 = cholupdate(R1,single(uc),"-");
+%! 
+%! assert(norm(triu(R1)-R1,Inf) == 0)
+%! assert(norm(R1 - R,Inf) < 1e1*eps('single'))
 */
 
 DEFUN_DLD (cholinsert, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {[@var{R1}, @var{info}] =} cholinsert (@var{R}, @var{j}, @var{u})\n\
 Given a Cholesky@tie{}factorization of a real symmetric or complex hermitian\n\
 positive definite matrix @w{@var{A} = @var{R}'*@var{R}}, @var{R}@tie{}upper triangular,\n\
 return the QR@tie{}factorization of\n\
@@ -685,103 +828,164 @@ If @var{info} is not present, an error m
     {
       octave_idx_type n = argr.rows ();
       octave_idx_type j = argj.scalar_value ();
 
       if (argr.columns () == n && argu.rows () == n+1 && argu.columns () == 1)
         {
           if (j > 0 && j <= n+1)
             {
-              if (argr.is_real_matrix () && argu.is_real_matrix ())
-                {
-                  // real case
-                  Matrix R = argr.matrix_value ();
-                  Matrix u = argu.matrix_value ();
+	      if (argr.is_single_type () || argu.is_single_type ())
+		{
+		  if (argr.is_real_matrix () && argu.is_real_matrix ())
+		    {
+		      // real case
+		      FloatMatrix R = argr.float_matrix_value ();
+		      FloatMatrix u = argu.float_matrix_value ();
+
+		      FloatCHOL fact;
+		      fact.set (R);
+		      int err = fact.insert_sym (u, j-1);
+
+		      if (nargout > 1)
+			retval(1) = err;
+		      else if (err)
+			error ("cholinsert: insertion violates positiveness");
 
-                  CHOL fact;
-                  fact.set (R);
-                  int err = fact.insert_sym (u, j-1);
+		      retval(0) = fact.chol_matrix ();
+		    }
+		  else
+		    {
+		      // complex case
+		      FloatComplexMatrix R = argr.float_complex_matrix_value ();
+		      FloatComplexMatrix u = argu.float_complex_matrix_value ();
 
-                  if (nargout > 1)
-                    retval(1) = err;
-                  else if (err)
-                    error ("cholinsert: insertion violates positiveness");
+		      FloatComplexCHOL fact;
+		      fact.set (R);
+		      int err = fact.insert_sym (u, j-1);
+
+		      if (nargout > 1)
+			retval(1) = err;
+		      else if (err)
+			error ("cholinsert: insertion violates positiveness");
 
-                  retval(0) = fact.chol_matrix ();
-                }
-              else
-                {
-                  // complex case
-                  ComplexMatrix R = argr.complex_matrix_value ();
-                  ComplexMatrix u = argu.complex_matrix_value ();
+		      retval(0) = fact.chol_matrix ();
+		    }
+		}
+	      else
+		{
+		  if (argr.is_real_matrix () && argu.is_real_matrix ())
+		    {
+		      // real case
+		      Matrix R = argr.matrix_value ();
+		      Matrix u = argu.matrix_value ();
+
+		      CHOL fact;
+		      fact.set (R);
+		      int err = fact.insert_sym (u, j-1);
+
+		      if (nargout > 1)
+			retval(1) = err;
+		      else if (err)
+			error ("cholinsert: insertion violates positiveness");
 
-                  ComplexCHOL fact;
-                  fact.set (R);
-                  int err = fact.insert_sym (u, j-1);
+		      retval(0) = fact.chol_matrix ();
+		    }
+		  else
+		    {
+		      // complex case
+		      ComplexMatrix R = argr.complex_matrix_value ();
+		      ComplexMatrix u = argu.complex_matrix_value ();
 
-                  if (nargout > 1)
-                    retval(1) = err;
-                  else if (err)
-                    error ("cholinsert: insertion violates positiveness");
+		      ComplexCHOL fact;
+		      fact.set (R);
+		      int err = fact.insert_sym (u, j-1);
 
-                  retval(0) = fact.chol_matrix ();
-                }
+		      if (nargout > 1)
+			retval(1) = err;
+		      else if (err)
+			error ("cholinsert: insertion violates positiveness");
+
+		      retval(0) = fact.chol_matrix ();
+		    }
+		}
             }
           else
             error ("cholinsert: index out of range");
         }
       else
         error ("cholinsert: dimension mismatch");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 %!test
-%! A = [  0.436997  -0.131721   0.124120  -0.061673 ;
-%!       -0.131721   0.738529   0.019851  -0.140295 ;
-%!        0.124120   0.019851   0.354879  -0.059472 ;
-%!       -0.061673  -0.140295  -0.059472   0.600939 ];
-%! 
-%! u = [  0.35080 ;
-%!        0.63930 ;
-%!        3.31057 ;
-%!       -0.13825 ;
-%!        0.45266 ];
+%! u2 = [  0.35080 ;
+%!         0.63930 ;
+%!         3.31057 ;
+%!        -0.13825 ;
+%!         0.45266 ];
 %!
 %! R = chol(A);
 %! 
 %! j = 3; p = [1:j-1, j+1:5];
-%! R1 = cholinsert(R,j,u); A1 = R1'*R1;
+%! R1 = cholinsert(R,j,u2); A1 = R1'*R1;
 %! 
 %! assert(norm(triu(R1)-R1,Inf) == 0)
 %! assert(norm(A1(p,p) - A,Inf) < 1e1*eps)
 %! 
 %!test
-%! A = [  0.5585528 + 0.0000000i  -0.1662088 - 0.0315341i   0.0107873 + 0.0236411i  -0.0276775 - 0.0186073i ;
-%!       -0.1662088 + 0.0315341i   0.6760061 + 0.0000000i   0.0011452 - 0.0475528i   0.0145967 + 0.0247641i ;
-%!        0.0107873 - 0.0236411i   0.0011452 + 0.0475528i   0.6263149 - 0.0000000i  -0.1585837 - 0.0719763i ;
-%!       -0.0276775 + 0.0186073i   0.0145967 - 0.0247641i  -0.1585837 + 0.0719763i   0.6034234 - 0.0000000i ];
-%! 
-%! u = [  0.35080  + 0.04298i;
-%!        0.63930  + 0.23778i;
-%!        3.31057  + 0.00000i;
-%!       -0.13825  + 0.19879i;
-%!        0.45266  + 0.50020i];
+%! u2 = [  0.35080  + 0.04298i;
+%!         0.63930  + 0.23778i;
+%!         3.31057  + 0.00000i;
+%!        -0.13825  + 0.19879i;
+%!         0.45266  + 0.50020i];
 %!
-%! R = chol(A);
+%! R = chol(Ac);
 %! 
 %! j = 3; p = [1:j-1, j+1:5];
-%! R1 = cholinsert(R,j,u); A1 = R1'*R1;
+%! R1 = cholinsert(R,j,u2); A1 = R1'*R1;
 %! 
 %! assert(norm(triu(R1)-R1,Inf) == 0)
-%! assert(norm(A1(p,p) - A,Inf) < 1e1*eps)
+%! assert(norm(A1(p,p) - Ac,Inf) < 1e1*eps)
+%! 
+
+%!test
+%! u2 = single ([  0.35080 ;
+%!                 0.63930 ;
+%!                 3.31057 ;
+%!                -0.13825 ;
+%!                 0.45266 ]);
+%!
+%! R = chol(single(A));
+%! 
+%! j = 3; p = [1:j-1, j+1:5];
+%! R1 = cholinsert(R,j,u2); A1 = R1'*R1;
+%! 
+%! assert(norm(triu(R1)-R1,Inf) == 0)
+%! assert(norm(A1(p,p) - A,Inf) < 1e1*eps('single'))
+%! 
+%!test
+%! u2 = single ([  0.35080  + 0.04298i;
+%!                 0.63930  + 0.23778i;
+%!                 3.31057  + 0.00000i;
+%!                -0.13825  + 0.19879i;
+%!                 0.45266  + 0.50020i]);
+%!
+%! R = chol(single(Ac));
+%! 
+%! j = 3; p = [1:j-1, j+1:5];
+%! R1 = cholinsert(R,j,u2); A1 = R1'*R1;
+%! 
+%! assert(norm(triu(R1)-R1,Inf) == 0)
+%! assert(norm(A1(p,p) - single(Ac),Inf) < 1e1*eps('single'))
 %! 
 */
 
 DEFUN_DLD (choldelete, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{R1} =} choldelete (@var{R}, @var{j})\n\
 Given a Cholesky@tie{}factorization of a real symmetric or complex hermitian\n\
 positive definite matrix @w{@var{A} = @var{R}'*@var{R}}, @var{R}@tie{}upper triangular,\n\
@@ -806,79 +1010,115 @@ return the QR@tie{}factorization of @w{A
     {
       octave_idx_type n = argr.rows ();
       octave_idx_type j = argj.scalar_value ();
 
       if (argr.columns () == n)
         {
           if (j > 0 && j <= n)
             {
-              if (argr.is_real_matrix ())
-                {
-                  // real case
-                  Matrix R = argr.matrix_value ();
+	      if (argr.is_single_type ())
+		{
+		  if (argr.is_real_matrix ())
+		    {
+		      // real case
+		      FloatMatrix R = argr.float_matrix_value ();
+
+		      FloatCHOL fact;
+		      fact.set (R);
+		      fact.delete_sym (j-1);
 
-                  CHOL fact;
-                  fact.set (R);
-                  fact.delete_sym (j-1);
+		      retval(0) = fact.chol_matrix ();
+		    }
+		  else
+		    {
+		      // complex case
+		      FloatComplexMatrix R = argr.float_complex_matrix_value ();
+
+		      FloatComplexCHOL fact;
+		      fact.set (R);
+		      fact.delete_sym (j-1);
 
-                  retval(0) = fact.chol_matrix ();
-                }
-              else
-                {
-                  // complex case
-                  ComplexMatrix R = argr.complex_matrix_value ();
+		      retval(0) = fact.chol_matrix ();
+		    }
+		}
+	      else
+		{
+		  if (argr.is_real_matrix ())
+		    {
+		      // real case
+		      Matrix R = argr.matrix_value ();
+
+		      CHOL fact;
+		      fact.set (R);
+		      fact.delete_sym (j-1);
 
-                  ComplexCHOL fact;
-                  fact.set (R);
-                  fact.delete_sym (j-1);
+		      retval(0) = fact.chol_matrix ();
+		    }
+		  else
+		    {
+		      // complex case
+		      ComplexMatrix R = argr.complex_matrix_value ();
 
-                  retval(0) = fact.chol_matrix ();
-                }
+		      ComplexCHOL fact;
+		      fact.set (R);
+		      fact.delete_sym (j-1);
+
+		      retval(0) = fact.chol_matrix ();
+		    }
+		}
             }
           else
             error ("choldelete: index out of range");
         }
       else
         error ("choldelete: dimension mismatch");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 %!test
-%! A = [  0.436997  -0.131721   0.124120  -0.061673 ;
-%!       -0.131721   0.738529   0.019851  -0.140295 ;
-%!        0.124120   0.019851   0.354879  -0.059472 ;
-%!       -0.061673  -0.140295  -0.059472   0.600939 ];
-%! 
 %! R = chol(A);
 %! 
 %! j = 3; p = [1:j-1,j+1:4];
 %! R1 = choldelete(R,j);
 %! 
 %! assert(norm(triu(R1)-R1,Inf) == 0)
 %! assert(norm(R1'*R1 - A(p,p),Inf) < 1e1*eps)
 %! 
 %!test
-%! A = [  0.5585528 + 0.0000000i  -0.1662088 - 0.0315341i   0.0107873 + 0.0236411i  -0.0276775 - 0.0186073i ;
-%!       -0.1662088 + 0.0315341i   0.6760061 + 0.0000000i   0.0011452 - 0.0475528i   0.0145967 + 0.0247641i ;
-%!        0.0107873 - 0.0236411i   0.0011452 + 0.0475528i   0.6263149 - 0.0000000i  -0.1585837 - 0.0719763i ;
-%!       -0.0276775 + 0.0186073i   0.0145967 - 0.0247641i  -0.1585837 + 0.0719763i   0.6034234 - 0.0000000i ];
-%! 
-%! R = chol(A);
+%! R = chol(Ac);
 %! 
 %! j = 3; p = [1:j-1,j+1:4];
 %! R1 = choldelete(R,j);
 %! 
 %! assert(norm(triu(R1)-R1,Inf) == 0)
-%! assert(norm(R1'*R1 - A(p,p),Inf) < 1e1*eps)
+%! assert(norm(R1'*R1 - Ac(p,p),Inf) < 1e1*eps)
+
+%!test
+%! R = chol(single(A));
+%! 
+%! j = 3; p = [1:j-1,j+1:4];
+%! R1 = choldelete(R,j);
+%! 
+%! assert(norm(triu(R1)-R1,Inf) == 0)
+%! assert(norm(R1'*R1 - single(A(p,p)),Inf) < 1e1*eps('single'))
+%! 
+%!test
+%! R = chol(single(Ac));
+%! 
+%! j = 3; p = [1:j-1,j+1:4];
+%! R1 = choldelete(R,j);
+%! 
+%! assert(norm(triu(R1)-R1,Inf) == 0)
+%! assert(norm(R1'*R1 - single(Ac(p,p)),Inf) < 1e1*eps('single'))
 */
 
 DEFUN_DLD (cholshift, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{R1} =} cholshift (@var{R}, @var{i}, @var{j})\n\
 Given a Cholesky@tie{}factorization of a real symmetric or complex hermitian\n\
 positive definite matrix @w{@var{A} = @var{R}'*@var{R}}, @var{R}@tie{}upper triangular,\n\
 return the QR@tie{}factorization of\n\
@@ -909,91 +1149,141 @@ return the QR@tie{}factorization of\n\
       octave_idx_type n = argr.rows ();
       octave_idx_type i = argi.scalar_value ();
       octave_idx_type j = argj.scalar_value ();
 
       if (argr.columns () == n)
         {
           if (j > 0 && j <= n+1 && i > 0 && i <= n+1)
             {
-              if (argr.is_real_matrix ())
-                {
-                  // real case
-                  Matrix R = argr.matrix_value ();
+
+	      if (argr.is_single_type () && argi.is_single_type () && 
+		  argj.is_single_type ())
+		{
+		  if (argr.is_real_matrix ())
+		    {
+		      // real case
+		      FloatMatrix R = argr.float_matrix_value ();
 
-                  CHOL fact;
-                  fact.set (R);
-                  fact.shift_sym (i-1, j-1);
+		      FloatCHOL fact;
+		      fact.set (R);
+		      fact.shift_sym (i-1, j-1);
+
+		      retval(0) = fact.chol_matrix ();
+		    }
+		  else
+		    {
+		      // complex case
+		      FloatComplexMatrix R = argr.float_complex_matrix_value ();
+
+		      FloatComplexCHOL fact;
+		      fact.set (R);
+		      fact.shift_sym (i-1, j-1);
 
-                  retval(0) = fact.chol_matrix ();
-                }
-              else
-                {
-                  // complex case
-                  ComplexMatrix R = argr.complex_matrix_value ();
+		      retval(0) = fact.chol_matrix ();
+		    }
+		}
+	      else
+		{
+		  if (argr.is_real_matrix ())
+		    {
+		      // real case
+		      Matrix R = argr.matrix_value ();
+
+		      CHOL fact;
+		      fact.set (R);
+		      fact.shift_sym (i-1, j-1);
 
-                  ComplexCHOL fact;
-                  fact.set (R);
-                  fact.shift_sym (i-1, j-1);
+		      retval(0) = fact.chol_matrix ();
+		    }
+		  else
+		    {
+		      // complex case
+		      ComplexMatrix R = argr.complex_matrix_value ();
 
-                  retval(0) = fact.chol_matrix ();
-                }
+		      ComplexCHOL fact;
+		      fact.set (R);
+		      fact.shift_sym (i-1, j-1);
+
+		      retval(0) = fact.chol_matrix ();
+		    }
+		}
             }
           else
             error ("cholshift: index out of range");
         }
       else
         error ("cholshift: dimension mismatch");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 %!test
-%! A = [  0.436997  -0.131721   0.124120  -0.061673 ;
-%!       -0.131721   0.738529   0.019851  -0.140295 ;
-%!        0.124120   0.019851   0.354879  -0.059472 ;
-%!       -0.061673  -0.140295  -0.059472   0.600939 ];
-%! 
 %! R = chol(A);
 %! 
 %! i = 1; j = 3; p = [1:i-1, shift(i:j,-1), j+1:4];
 %! R1 = cholshift(R,i,j);
 %! 
 %! assert(norm(triu(R1)-R1,Inf) == 0)
 %! assert(norm(R1'*R1 - A(p,p),Inf) < 1e1*eps)
 %! 
 %! j = 1; i = 3; p = [1:j-1, shift(j:i,+1), i+1:4];
 %! R1 = cholshift(R,i,j);
 %! 
 %! assert(norm(triu(R1)-R1,Inf) == 0)
 %! assert(norm(R1'*R1 - A(p,p),Inf) < 1e1*eps)
 %! 
 %!test
-%! A = [  0.5585528 + 0.0000000i  -0.1662088 - 0.0315341i   0.0107873 + 0.0236411i  -0.0276775 - 0.0186073i ;
-%!       -0.1662088 + 0.0315341i   0.6760061 + 0.0000000i   0.0011452 - 0.0475528i   0.0145967 + 0.0247641i ;
-%!        0.0107873 - 0.0236411i   0.0011452 + 0.0475528i   0.6263149 - 0.0000000i  -0.1585837 - 0.0719763i ;
-%!       -0.0276775 + 0.0186073i   0.0145967 - 0.0247641i  -0.1585837 + 0.0719763i   0.6034234 - 0.0000000i ];
+%! R = chol(Ac);
+%! 
+%! i = 1; j = 3; p = [1:i-1, shift(i:j,-1), j+1:4];
+%! R1 = cholshift(R,i,j);
+%! 
+%! assert(norm(triu(R1)-R1,Inf) == 0)
+%! assert(norm(R1'*R1 - Ac(p,p),Inf) < 1e1*eps)
 %! 
-%! R = chol(A);
+%! j = 1; i = 3; p = [1:j-1, shift(j:i,+1), i+1:4];
+%! R1 = cholshift(R,i,j);
+%! 
+%! assert(norm(triu(R1)-R1,Inf) == 0)
+%! assert(norm(R1'*R1 - Ac(p,p),Inf) < 1e1*eps)
+
+%!test
+%! R = chol(single(A));
 %! 
 %! i = 1; j = 3; p = [1:i-1, shift(i:j,-1), j+1:4];
 %! R1 = cholshift(R,i,j);
 %! 
 %! assert(norm(triu(R1)-R1,Inf) == 0)
-%! assert(norm(R1'*R1 - A(p,p),Inf) < 1e1*eps)
+%! assert(norm(R1'*R1 - single(A(p,p)),Inf) < 1e1*eps('single'))
 %! 
 %! j = 1; i = 3; p = [1:j-1, shift(j:i,+1), i+1:4];
 %! R1 = cholshift(R,i,j);
 %! 
 %! assert(norm(triu(R1)-R1,Inf) == 0)
-%! assert(norm(R1'*R1 - A(p,p),Inf) < 1e1*eps)
+%! assert(norm(R1'*R1 - single(A(p,p)),Inf) < 1e1*eps('single'))
+%! 
+%!test
+%! R = chol(single(Ac));
+%! 
+%! i = 1; j = 3; p = [1:i-1, shift(i:j,-1), j+1:4];
+%! R1 = cholshift(R,i,j);
+%! 
+%! assert(norm(triu(R1)-R1,Inf) == 0)
+%! assert(norm(R1'*R1 - single(Ac(p,p)),Inf) < 1e1*eps('single'))
+%! 
+%! j = 1; i = 3; p = [1:j-1, shift(j:i,+1), i+1:4];
+%! R1 = cholshift(R,i,j);
+%! 
+%! assert(norm(triu(R1)-R1,Inf) == 0)
+%! assert(norm(R1'*R1 - single(Ac(p,p)),Inf) < 1e1*eps('single'))
 */
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
 
diff --git a/src/DLD-FUNCTIONS/conv2.cc b/src/DLD-FUNCTIONS/conv2.cc
--- a/src/DLD-FUNCTIONS/conv2.cc
+++ b/src/DLD-FUNCTIONS/conv2.cc
@@ -238,16 +238,20 @@ conv2 (MArray2<T>&A, MArray2<T>&B, Shape
 
   return O;
 }
 
 /*
 %!test
 %! b = [0,1,2,3;1,8,12,12;4,20,24,21;7,22,25,18];
 %! assert(conv2([0,1;1,2],[1,2,3;4,5,6;7,8,9]),b);
+
+%!test
+%! b = single([0,1,2,3;1,8,12,12;4,20,24,21;7,22,25,18]);
+%! assert(conv2(single([0,1;1,2]),single([1,2,3;4,5,6;7,8,9])),b);
 */
 
 DEFUN_DLD (conv2, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {y =} conv2 (@var{a}, @var{b}, @var{shape})\n\
 @deftypefnx {Loadable Function} {y =} conv2 (@var{v1}, @var{v2}, @var{M}, @var{shape})\n\
 \n\
 Returns 2D convolution of @var{a} and @var{b} where the size\n\
diff --git a/src/DLD-FUNCTIONS/det.cc b/src/DLD-FUNCTIONS/det.cc
--- a/src/DLD-FUNCTIONS/det.cc
+++ b/src/DLD-FUNCTIONS/det.cc
@@ -88,34 +88,34 @@ if requested.\n\
 	  // singular matrices.
 	  FloatMatrix m = arg.float_matrix_value ();
 	  if (! error_state)
 	    {
 	      FloatDET det = m.determinant (info, rcond);
 	      retval(1) = rcond;
 	      volatile float xrcond = rcond;
 	      xrcond += 1.0;
-	      retval(0) = ((info == -1 || xrcond == 1.0) ? 0.0 : det.value ());
+	      retval(0) = ((info == -1 || xrcond == 1.0) ? static_cast<float>(0.0) : det.value ());
 	    }
 	}
       else if (arg.is_complex_type ())
 	{
 	  octave_idx_type info;
 	  float rcond = 0.0;
 	  // Always compute rcond, so we can detect numerically
 	  // singular matrices.
 	  FloatComplexMatrix m = arg.float_complex_matrix_value ();
 	  if (! error_state)
 	    {
 	      FloatComplexDET det = m.determinant (info, rcond);
 	      retval(1) = rcond;
 	      volatile float xrcond = rcond;
 	      xrcond += 1.0;
 	      retval(0) = ((info == -1 || xrcond == 1.0) 
-			   ? Complex (0.0) : det.value ());
+			   ? FloatComplex (0.0) : det.value ());
 	      
 	    }
 	}
     }
   else
     {
       if (arg.is_real_type ())
 	{
@@ -184,12 +184,22 @@ if requested.\n\
 	}
       else
 	gripe_wrong_type_arg ("det", arg);
     }
   return retval;
 }
 
 /*
+
+%!assert(det ([1, 2; 3, 4]), -2, 10 * eps);
+%!assert(det (single([1, 2; 3, 4])), single(-2), 10 * eps ('single'));
+%!error <Invalid call to det.*> det ();
+%!error <Invalid call to det.*> det (1, 2);
+%!error det ([1, 2; 3, 4; 5, 6]);
+
+*/
+
+/*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/DLD-FUNCTIONS/eig.cc b/src/DLD-FUNCTIONS/eig.cc
--- a/src/DLD-FUNCTIONS/eig.cc
+++ b/src/DLD-FUNCTIONS/eig.cc
@@ -164,12 +164,36 @@ The eigenvalues returned by @code{eig} a
 	    }
 	}
     }
 
   return retval;
 }
 
 /*
+
+%!assert(eig ([1, 2; 2, 1]), [-1; 3], sqrt (eps));
+
+%!test
+%! [v, d] = eig ([1, 2; 2, 1]);
+%! x = 1 / sqrt (2);
+%! assert(d, [-1, 0; 0, 3], sqrt (eps));
+%! assert(v, [-x, x; x, x], sqrt (eps));
+
+%!assert(eig (single ([1, 2; 2, 1])), single([-1; 3]), sqrt (eps('single')));
+
+%!test
+%! [v, d] = eig (single([1, 2; 2, 1]));
+%! x = single(1 / sqrt (2));
+%! assert(d, single([-1, 0; 0, 3]), sqrt (eps('single')));
+%! assert(v, [-x, x; x, x], sqrt (eps('single')));
+
+%!error <Invalid call to eig.*> eig ();
+%!error <Invalid call to eig.*> eig ([1, 2; 3, 4], 2);
+%!error eig ([1, 2; 3, 4; 5, 6]);
+
+ */
+
+/*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/DLD-FUNCTIONS/expm.cc b/src/DLD-FUNCTIONS/expm.cc
--- a/src/DLD-FUNCTIONS/expm.cc
+++ b/src/DLD-FUNCTIONS/expm.cc
@@ -197,12 +197,49 @@ is ill-conditioned.\n\
 	  gripe_wrong_type_arg ("expm", arg);
 	}
     }
 
   return retval;
 }
 
 /*
+
+%!assert(expm ([-49, 24; -64, 31]), [-0.735758758144742, 0.551819099658089;
+%!       -1.471517599088239, 1.103638240715556], 128*eps);
+
+%!assert(expm ([1, 1; 0, 1]), [2.718281828459045, 2.718281828459045;
+%!       0.000000000000000, 2.718281828459045],4 * eps);
+
+%!test
+%! arg = diag ([6, 6, 6], 1);
+%! result = [1, 6, 18, 36;
+%! 0, 1,  6, 18;
+%! 0, 0,  1,  6;
+%! 0, 0,  0,  1];
+%! assert(expm (arg), result);
+
+%!assert(expm (single([-49, 24; -64, 31])), single([-0.735758758144742, ...
+%!       0.551819099658089; -1.471517599088239, 1.103638240715556]), ...
+%!       512*eps('single'));
+
+%!assert(expm (single([1, 1; 0, 1])), single([2.718281828459045, ...
+%!       2.718281828459045; 0.000000000000000, 2.718281828459045]), ...
+%!       4 * eps('single'));
+
+%!test
+%! arg = single(diag ([6, 6, 6], 1));
+%! result = single([1, 6, 18, 36;
+%! 0, 1,  6, 18;
+%! 0, 0,  1,  6;
+%! 0, 0,  0,  1]);
+%! assert(expm (arg), result);
+
+%!error <Invalid call to expm.*> expm();
+%!error <Invalid call to expm.*> expm(1,2);
+
+*/
+
+/*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/DLD-FUNCTIONS/fft.cc b/src/DLD-FUNCTIONS/fft.cc
--- a/src/DLD-FUNCTIONS/fft.cc
+++ b/src/DLD-FUNCTIONS/fft.cc
@@ -110,17 +110,20 @@ do_fft (const octave_value_list &args, c
     }
 
   if (n_points < 0)
     n_points = dims (dim);
   else
     dims (dim) = n_points;
 
   if (dims.any_zero () || n_points == 0)
-    return octave_value (NDArray (dims));
+    if (arg.is_single_type ())
+      return octave_value (FloatNDArray (dims));
+    else
+      return octave_value (NDArray (dims));
 
   if (arg.is_single_type ())
     {
       if (arg.is_real_type ())
 	{
 	  FloatNDArray nda = arg.float_array_value ();
 
 	  if (! error_state)
@@ -174,20 +177,27 @@ do_fft (const octave_value_list &args, c
 /*
 
 %!error(fft())
 %!assert(fft([]), [])
 %!assert(fft(zeros(10,0)), zeros(10,0))
 %!assert(fft(zeros(0,10)), zeros(0,10))
 %!assert(fft(0), 0)
 %!assert(fft(1), 1)
-%!assert(fft(1), 1)
 %!assert(fft(ones(2,2)), [2,2; 0,0])
 %!assert(fft(eye(2,2)), [1,1; 1,-1])
 
+%!assert(fft(single([])), single([]))
+%!assert(fft(zeros(10,0,'single')), zeros(10,0,'single'))
+%!assert(fft(zeros(0,10,'single')), zeros(0,10,'single'))
+%!assert(fft(single(0)), single(0))
+%!assert(fft(single(1)), single(1))
+%!assert(fft(ones(2,2,'single')), single([2,2; 0,0]))
+%!assert(fft(eye(2,2,'single')), single([1,1; 1,-1]))
+
 */
 
 
 DEFUN_DLD (fft, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} fft (@var{a}, @var{n}, @var{dim})\n\
 Compute the FFT of @var{a} using subroutines from\n"
 FFTSRC
@@ -234,95 +244,77 @@ dimension of the matrix along which the 
 @seealso{fft, ifft2, ifftn, fftw}\n\
 @end deftypefn")
 {
   return do_fft (args, "ifft", 1);
 }
 
 /*
 
-%% fft-1.m
-%%
 %% Author: David Billinghurst (David.Billinghurst@riotinto.com.au)
 %%         Comalco Research and Technology
 %%         02 May 2000
 %!test
 %! N=64;
 %! n=4;
 %! t = 2*pi*(0:1:N-1)/N;
 %! s = cos(n*t);
 %! S = fft(s);
 %! 
-%! answer = 0*t;
+%! answer = zeros (size(t));
 %! answer(n+1) = N/2;
 %! answer(N-n+1) = N/2;
 %! 
-%! assert(all( abs(S-answer) < 4*N*eps ));
+%! assert(S, answer, 4*N*eps);
 
-%% ifft-1.m
-%%
 %% Author: David Billinghurst (David.Billinghurst@riotinto.com.au)
 %%         Comalco Research and Technology
 %%         02 May 2000
 %!test
 %! N=64;
 %! n=7;
 %! t = 2*pi*(0:1:N-1)/N;
 %! s = cos(n*t);
 %! 
-%! S = 0*t;
+%! S = zeros (size(t));
 %! S(n+1) = N/2;
 %! S(N-n+1) = N/2;
 %! 
-%! assert(all( abs(ifft(S)-s) < 4*N*eps ));
+%! assert(ifft(S), s, 4*N*eps);
 
-%% fft2-1.m
-%%
 %% Author: David Billinghurst (David.Billinghurst@riotinto.com.au)
 %%         Comalco Research and Technology
 %%         02 May 2000
 %!test
-%! M=16;
-%! N=8;
-%! 
-%! m=5;
-%! n=3;
+%! N=64;
+%! n=4;
+%! t = single (2*pi*(0:1:N-1)/N);
+%! s = cos(n*t);
+%! S = fft(s);
 %! 
-%! x = 2*pi*(0:1:M-1)/M;
-%! y = 2*pi*(0:1:N-1)/N;
-%! sx = cos(m*x);
-%! sy = sin(n*y);
-%! s=kron(sx',sy);
-%! S = fft2(s);
-%! answer = kron(fft(sx)',fft(sy));
-%! assert(all( all( abs(S-answer) < 4*M*N*eps ) ));
+%! answer = zeros (size(t),'single');
+%! answer(n+1) = N/2;
+%! answer(N-n+1) = N/2;
+%! 
+%! assert(S, answer, 4*N*eps('single'));
 
-%% ifft2-1.m
-%%
 %% Author: David Billinghurst (David.Billinghurst@riotinto.com.au)
 %%         Comalco Research and Technology
 %%         02 May 2000
 %!test
-%! M=12;
-%! N=7;
-%! 
-%! m=3;
-%! n=2;
-%! 
-%! x = 2*pi*(0:1:M-1)/M;
-%! y = 2*pi*(0:1:N-1)/N;
+%! N=64;
+%! n=7;
+%! t = 2*pi*(0:1:N-1)/N;
+%! s = cos(n*t);
 %! 
-%! sx = cos(m*x);
-%! sy = cos(n*y);
+%! S = zeros (size(t),'single');
+%! S(n+1) = N/2;
+%! S(N-n+1) = N/2;
 %! 
-%! S = kron(fft(sx)',fft(sy));
-%! answer=kron(sx',sy);
-%! s = ifft2(S);
-%! 
-%! assert(all( all( abs(s-answer) < 30*eps ) ));
+%! assert(ifft(S), s, 4*N*eps('single'));
 
 */
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/DLD-FUNCTIONS/fft2.cc b/src/DLD-FUNCTIONS/fft2.cc
--- a/src/DLD-FUNCTIONS/fft2.cc
+++ b/src/DLD-FUNCTIONS/fft2.cc
@@ -101,17 +101,20 @@ do_fft2 (const octave_value_list &args, 
     dims (0) = n_rows;
 
   if (n_cols < 0)
     n_cols = dims (1);
   else
     dims (1) = n_cols;
 
   if (dims.all_zero () || n_rows == 0 || n_cols == 0)
-    return octave_value (Matrix ());
+    if (arg.is_single_type ())
+      return octave_value (FloatMatrix ());
+    else
+      return octave_value (Matrix ());
 
   if (arg.is_single_type ())
     {
       if (arg.is_real_type ())
 	{
 	  FloatNDArray nda = arg.float_array_value ();
 
 	  if (! error_state)
@@ -195,12 +198,99 @@ If @var{a} is a multi-dimensional matrix
 of @var{a} is treated separately\n\
 @seealso {fft2, ifft, ifftn, fftw}\n\
 @end deftypefn")
 {
   return do_fft2 (args, "ifft2", 1);
 }
 
 /*
+
+%% Author: David Billinghurst (David.Billinghurst@riotinto.com.au)
+%%         Comalco Research and Technology
+%%         02 May 2000
+%!test
+%! M=16;
+%! N=8;
+%! 
+%! m=5;
+%! n=3;
+%! 
+%! x = 2*pi*(0:1:M-1)/M;
+%! y = 2*pi*(0:1:N-1)/N;
+%! sx = cos(m*x);
+%! sy = sin(n*y);
+%! s=kron(sx',sy);
+%! S = fft2(s);
+%! answer = kron(fft(sx)',fft(sy));
+%! assert(S, answer, 4*M*N*eps);
+
+%% Author: David Billinghurst (David.Billinghurst@riotinto.com.au)
+%%         Comalco Research and Technology
+%%         02 May 2000
+%!test
+%! M=12;
+%! N=7;
+%! 
+%! m=3;
+%! n=2;
+%! 
+%! x = 2*pi*(0:1:M-1)/M;
+%! y = 2*pi*(0:1:N-1)/N;
+%! 
+%! sx = cos(m*x);
+%! sy = cos(n*y);
+%! 
+%! S = kron(fft(sx)',fft(sy));
+%! answer=kron(sx',sy);
+%! s = ifft2(S);
+%! 
+%! assert(s, answer, 30*eps);
+
+
+%% Author: David Billinghurst (David.Billinghurst@riotinto.com.au)
+%%         Comalco Research and Technology
+%%         02 May 2000
+%!test
+%! M=16;
+%! N=8;
+%! 
+%! m=5;
+%! n=3;
+%! 
+%! x = 2*pi*(0:1:M-1)/M;
+%! y = 2*pi*(0:1:N-1)/N;
+%! sx = single(cos(m*x));
+%! sy = single(sin(n*y));
+%! s=kron(sx',sy);
+%! S = fft2(s);
+%! answer = kron(fft(sx)',fft(sy));
+%! assert(S, answer, 4*M*N*eps('single'));
+
+%% Author: David Billinghurst (David.Billinghurst@riotinto.com.au)
+%%         Comalco Research and Technology
+%%         02 May 2000
+%!test
+%! M=12;
+%! N=7;
+%! 
+%! m=3;
+%! n=2;
+%! 
+%! x = single(2*pi*(0:1:M-1)/M);
+%! y = single(2*pi*(0:1:N-1)/N);
+%! 
+%! sx = cos(m*x);
+%! sy = cos(n*y);
+%! 
+%! S = kron(fft(sx)',fft(sy));
+%! answer=kron(sx',sy);
+%! s = ifft2(S);
+%! 
+%! assert(s, answer, 30*eps('single'));
+
+*/
+
+/*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/DLD-FUNCTIONS/fftn.cc b/src/DLD-FUNCTIONS/fftn.cc
--- a/src/DLD-FUNCTIONS/fftn.cc
+++ b/src/DLD-FUNCTIONS/fftn.cc
@@ -83,17 +83,20 @@ do_fftn (const octave_value_list &args, 
 	    }
 	}
     }
 
   if (error_state)
     return retval;
 
   if (dims.all_zero ())
-    return octave_value (Matrix ());
+    if (arg.is_single_type ())
+      return octave_value (FloatMatrix ());
+    else
+      return octave_value (Matrix ());
 
   if (arg.is_single_type ())
     {
       if (arg.is_real_type ())
 	{
 	  FloatNDArray nda = arg.float_array_value ();
 
 	  if (! error_state)
diff --git a/src/DLD-FUNCTIONS/find.cc b/src/DLD-FUNCTIONS/find.cc
--- a/src/DLD-FUNCTIONS/find.cc
+++ b/src/DLD-FUNCTIONS/find.cc
@@ -515,12 +515,39 @@ b = sparse(i, j, v, sz(1), sz(2));\n\
 	    }
 	}
     }
 
   return retval;
 }
 
 /*
+%!assert(find ([1, 0, 1, 0, 1]), [1, 3, 5]);
+%!assert(find ([1; 0; 3; 0; 1]), [1; 3; 5]);
+%!assert(find ([0, 0, 2; 0, 3, 0; -1, 0, 0]), [3; 5; 7]);
+
+%!test
+%! [i, j, v] = find ([0, 0, 2; 0, 3, 0; -1, 0, 0]);
+%! 
+%! assert(i, [3; 2; 1]);
+%! assert(j, [1; 2; 3]);
+%! assert(v, [-1; 3; 2]);
+
+%!assert(find (single([1, 0, 1, 0, 1])), [1, 3, 5]);
+%!assert(find (single([1; 0; 3; 0; 1])), [1; 3; 5]);
+%!assert(find (single([0, 0, 2; 0, 3, 0; -1, 0, 0])), [3; 5; 7]);
+
+%!test
+%! [i, j, v] = find (single([0, 0, 2; 0, 3, 0; -1, 0, 0]));
+%! 
+%! assert(i, [3; 2; 1]);
+%! assert(j, [1; 2; 3]);
+%! assert(v, single([-1; 3; 2]));
+
+%!error <Invalid call to find.*> find ();
+
+ */
+
+/*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/DLD-FUNCTIONS/hess.cc b/src/DLD-FUNCTIONS/hess.cc
--- a/src/DLD-FUNCTIONS/hess.cc
+++ b/src/DLD-FUNCTIONS/hess.cc
@@ -149,12 +149,30 @@ is upper Hessenberg (@code{i >= j+1 => h
 	  gripe_wrong_type_arg ("hess", arg);
 	}
     }
 
   return retval;
 }
 
 /*
+
+%!test
+%! a = [1, 2, 3; 5, 4, 6; 8, 7, 9];
+%! [p, h] = hess (a);
+%! assert(p * h * p', a, sqrt(eps));
+
+%!test
+%! a = single([1, 2, 3; 5, 4, 6; 8, 7, 9]);
+%! [p, h] = hess (a);
+%! assert(p * h * p', a, sqrt(eps ('single')));
+
+%!error <Invalid call to hess.*> hess ();
+%!error <Invalid call to hess.*> hess ([1, 2; 3, 4], 2);
+%!error hess ([1, 2; 3, 4; 5, 6]);
+
+*/
+
+/*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/DLD-FUNCTIONS/inv.cc b/src/DLD-FUNCTIONS/inv.cc
--- a/src/DLD-FUNCTIONS/inv.cc
+++ b/src/DLD-FUNCTIONS/inv.cc
@@ -170,16 +170,27 @@ be avoided. It is significantly more acc
       if (nargout < 2 && (info == -1 || xrcond == 1.0))
 	warning ("inverse: matrix singular to machine precision, rcond = %g", 
 		 rcond);
     }
 
   return retval;
 }
 
+/*
+
+%!assert(inv ([1, 2; 3, 4]), [-2, 1; 1.5, -0.5], sqrt (eps))
+%!assert(inv (single([1, 2; 3, 4])), single([-2, 1; 1.5, -0.5]), sqrt (eps ('single')))
+
+%!error <Invalid call to inv.*> inv ();
+%!error <Invalid call to inv.*> inv ([1, 2; 3, 4], 2);
+%!error inv ([1, 2; 3, 4; 5, 6]);
+
+ */
+
 // FIXME -- this should really be done with an alias, but
 // alias_builtin() won't do the right thing if we are actually using
 // dynamic linking.
 
 DEFUN_DLD (inverse, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} inverse (@var{a})\n\
 See inv.\n\
diff --git a/src/DLD-FUNCTIONS/lu.cc b/src/DLD-FUNCTIONS/lu.cc
--- a/src/DLD-FUNCTIONS/lu.cc
+++ b/src/DLD-FUNCTIONS/lu.cc
@@ -498,12 +498,69 @@ information.\n\
       else
 	gripe_wrong_type_arg ("lu", arg);
     }
 
   return retval;
 }
 
 /*
+
+%!assert(lu ([1, 2; 3, 4]), [3, 4; 1/3, 2/3], eps);
+
+%!test
+%! [l, u] = lu ([1, 2; 3, 4]);
+%! assert(l, [1/3, 1; 1, 0], sqrt (eps));
+%! assert(u, [3, 4; 0, 2/3], sqrt (eps));
+
+%!test
+%! [l, u, p] = lu ([1, 2; 3, 4]);
+%! assert(l, [1, 0; 1/3, 1], sqrt (eps));
+%! assert(u, [3, 4; 0, 2/3], sqrt (eps));
+%! assert(p, [0, 1; 1, 0], sqrt (eps));
+
+%!test
+%! [l, u, p] = lu ([1, 2; 3, 4],'vector');
+%! assert(l, [1, 0; 1/3, 1], sqrt (eps));
+%! assert(u, [3, 4; 0, 2/3], sqrt (eps));
+%! assert(p, [2;1], sqrt (eps));
+
+%!test
+%! [l u p] = lu ([1, 2; 3, 4; 5, 6]);
+%! assert(l, [1, 0; 1/5, 1; 3/5, 1/2], sqrt (eps));
+%! assert(u, [5, 6; 0, 4/5], sqrt (eps));
+%! assert(p, [0, 0, 1; 1, 0, 0; 0 1 0], sqrt (eps));
+
+%!assert(lu (single([1, 2; 3, 4])), single([3, 4; 1/3, 2/3]), eps('single'));
+
+%!test
+%! [l, u] = lu (single([1, 2; 3, 4]));
+%! assert(l, single([1/3, 1; 1, 0]), sqrt (eps('single')));
+%! assert(u, single([3, 4; 0, 2/3]), sqrt (eps('single')));
+
+%!test
+%! [l, u, p] = lu (single([1, 2; 3, 4]));
+%! assert(l, single([1, 0; 1/3, 1]), sqrt (eps('single')));
+%! assert(u, single([3, 4; 0, 2/3]), sqrt (eps('single')));
+%! assert(p, single([0, 1; 1, 0]), sqrt (eps('single')));
+
+%!test
+%! [l, u, p] = lu (single([1, 2; 3, 4]),'vector');
+%! assert(l, single([1, 0; 1/3, 1]), sqrt (eps('single')));
+%! assert(u, single([3, 4; 0, 2/3]), sqrt (eps('single')));
+%! assert(p, single([2;1]), sqrt (eps('single')));
+
+%!test
+%! [l u p] = lu (single([1, 2; 3, 4; 5, 6]));
+%! assert(l, single([1, 0; 1/5, 1; 3/5, 1/2]), sqrt (eps('single')));
+%! assert(u, single([5, 6; 0, 4/5]), sqrt (eps('single')));
+%! assert(p, single([0, 0, 1; 1, 0, 0; 0 1 0]), sqrt (eps('single')));
+
+%!error <Invalid call to lu.*> lu ();
+%!error lu ([1, 2; 3, 4], 2);
+
+ */
+
+/*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/DLD-FUNCTIONS/qr.cc b/src/DLD-FUNCTIONS/qr.cc
--- a/src/DLD-FUNCTIONS/qr.cc
+++ b/src/DLD-FUNCTIONS/qr.cc
@@ -429,18 +429,236 @@ as\n\
 	}
     }
 
   return retval;
 }
 
 /*
 
-The deactivated tests below can't be tested till rectangular back-subs is
-implemented for sparse matrices.
+%!test
+%! a = [0, 2, 1; 2, 1, 2];
+%! 
+%! [q, r] = qr (a);
+%! 
+%! [qe, re] = qr (a, 0);
+%! 
+%! assert (q * r, a, sqrt (eps));
+%! assert (qe * re, a, sqrt (eps));
+
+%!test
+%! a = [0, 2, 1; 2, 1, 2];
+%! 
+%! [q, r, p] = qr (a);  # not giving right dimensions. FIXME
+%! 
+%! [qe, re, pe] = qr (a, 0);
+%! 
+%! assert (q * r, a * p, sqrt (eps));
+%! assert (qe * re, a(:, pe), sqrt (eps));
+
+%!test
+%! a = [0, 2; 2, 1; 1, 2];
+%! 
+%! [q, r] = qr (a);
+%! 
+%! [qe, re] = qr (a, 0);
+%! 
+%! assert (q * r, a, sqrt (eps));
+%! assert (qe * re, a, sqrt (eps));
+
+%!test
+%! a = [0, 2; 2, 1; 1, 2];
+%! 
+%! [q, r, p] = qr (a);
+%! 
+%! [qe, re, pe] = qr (a, 0);
+%! 
+%! assert (q * r, a * p, sqrt (eps));
+%! assert (qe * re, a(:, pe), sqrt (eps));
+
+%!error <Invalid call to qr.*> qr ();
+%!error <Invalid call to qr.*> qr ([1, 2; 3, 4], 0, 2);
+
+%!function retval = testqr (q, r, a, p)
+%!  tol = 100*eps (class(q));
+%!  retval = 0;
+%!  if (nargin == 3)
+%!    n1 = norm (q*r-a);
+%!    n2 = norm (q'*q-eye(columns(q)));
+%!    retval = (n1 < tol && n2 < tol);
+%!  else
+%!    n1 = norm (q'*q-eye(columns(q)));
+%!    retval = (n1 < tol);
+%!    if (isvector (p))
+%!      n2 = norm (q*r-a(:,p));
+%!      retval = (retval && n2 < tol);
+%!    else
+%!      n2 = norm (q*r - a*p);
+%!      retval = (retval && n2 < tol);
+%!    endif
+%!  endif
+%!test
+%! 
+%! t = ones (24, 1);
+%! j = 1;
+%! 
+%! if false # eliminate big matrix tests
+%!   a = rand(5000,20);
+%!   [q,r]=qr(a,0); t(j++) = testqr(q,r,a);
+%!   [q,r]=qr(a',0); t(j++) = testqr(q,r,a');
+%!   [q,r,p]=qr(a,0); t(j++) = testqr(q,r,a,p);
+%!   [q,r,p]=qr(a',0); t(j++) = testqr(q,r,a',p);
+%! 
+%!   a = a+1i*eps;
+%!   [q,r]=qr(a,0); t(j++) = testqr(q,r,a);
+%!   [q,r]=qr(a',0); t(j++) = testqr(q,r,a');
+%!   [q,r,p]=qr(a,0); t(j++) = testqr(q,r,a,p);
+%!   [q,r,p]=qr(a',0); t(j++) = testqr(q,r,a',p);
+%! endif
+%! 
+%! a = [ ones(1,15); sqrt(eps)*eye(15) ];
+%! [q,r]=qr(a); t(j++) = testqr(q,r,a);
+%! [q,r]=qr(a'); t(j++) = testqr(q,r,a');
+%! [q,r,p]=qr(a); t(j++) = testqr(q,r,a,p);
+%! [q,r,p]=qr(a'); t(j++) = testqr(q,r,a',p);
+%! 
+%! a = a+1i*eps;
+%! [q,r]=qr(a); t(j++) = testqr(q,r,a);
+%! [q,r]=qr(a'); t(j++) = testqr(q,r,a');
+%! [q,r,p]=qr(a); t(j++) = testqr(q,r,a,p);
+%! [q,r,p]=qr(a'); t(j++) = testqr(q,r,a',p);
+%! 
+%! a = [ ones(1,15); sqrt(eps)*eye(15) ];
+%! [q,r]=qr(a,0); t(j++) = testqr(q,r,a);
+%! [q,r]=qr(a',0); t(j++) = testqr(q,r,a');
+%! [q,r,p]=qr(a,0); t(j++) = testqr(q,r,a,p);
+%! [q,r,p]=qr(a',0); t(j++) = testqr(q,r,a',p);
+%! 
+%! a = a+1i*eps;
+%! [q,r]=qr(a,0); t(j++) = testqr(q,r,a);
+%! [q,r]=qr(a',0); t(j++) = testqr(q,r,a');
+%! [q,r,p]=qr(a,0); t(j++) = testqr(q,r,a,p);
+%! [q,r,p]=qr(a',0); t(j++) = testqr(q,r,a',p);
+%! 
+%! a = [
+%! 611   196  -192   407    -8   -52   -49    29
+%! 196   899   113  -192   -71   -43    -8   -44
+%! -192   113   899   196    61    49     8    52
+%! 407  -192   196   611     8    44    59   -23
+%! -8   -71    61     8   411  -599   208   208
+%! -52   -43    49    44  -599   411   208   208
+%! -49    -8     8    59   208   208    99  -911
+%! 29   -44    52   -23   208   208  -911    99
+%! ];
+%! [q,r] = qr(a);
+%! 
+%! assert(all (t) && norm(q*r-a) < 5000*eps);
+
+%!test
+%! a = single ([0, 2, 1; 2, 1, 2]);
+%! 
+%! [q, r] = qr (a);
+%! 
+%! [qe, re] = qr (a, 0);
+%! 
+%! assert (q * r, a, sqrt (eps ('single')));
+%! assert (qe * re, a, sqrt (eps ('single')));
+
+%!test
+%! a = single([0, 2, 1; 2, 1, 2]);
+%! 
+%! [q, r, p] = qr (a);  # not giving right dimensions. FIXME
+%! 
+%! [qe, re, pe] = qr (a, 0);
+%! 
+%! assert (q * r, a * p, sqrt (eps('single')));
+%! assert (qe * re, a(:, pe), sqrt (eps('single')));
+
+%!test
+%! a = single([0, 2; 2, 1; 1, 2]);
+%! 
+%! [q, r] = qr (a);
+%! 
+%! [qe, re] = qr (a, 0);
+%! 
+%! assert (q * r, a, sqrt (eps('single')));
+%! assert (qe * re, a, sqrt (eps('single')));
+
+%!test
+%! a = single([0, 2; 2, 1; 1, 2]);
+%! 
+%! [q, r, p] = qr (a);
+%! 
+%! [qe, re, pe] = qr (a, 0);
+%! 
+%! assert (q * r, a * p, sqrt (eps('single')));
+%! assert (qe * re, a(:, pe), sqrt (eps('single')));
+
+%!error <Invalid call to qr.*> qr ();
+%!error <Invalid call to qr.*> qr ([1, 2; 3, 4], 0, 2);
+
+%!test
+%! 
+%! t = ones (24, 1);
+%! j = 1;
+%! 
+%! if false # eliminate big matrix tests
+%!   a = rand(5000,20);
+%!   [q,r]=qr(a,0); t(j++) = testqr(q,r,a);
+%!   [q,r]=qr(a',0); t(j++) = testqr(q,r,a');
+%!   [q,r,p]=qr(a,0); t(j++) = testqr(q,r,a,p);
+%!   [q,r,p]=qr(a',0); t(j++) = testqr(q,r,a',p);
+%! 
+%!   a = a+1i*eps('single');
+%!   [q,r]=qr(a,0); t(j++) = testqr(q,r,a);
+%!   [q,r]=qr(a',0); t(j++) = testqr(q,r,a');
+%!   [q,r,p]=qr(a,0); t(j++) = testqr(q,r,a,p);
+%!   [q,r,p]=qr(a',0); t(j++) = testqr(q,r,a',p);
+%! endif
+%! 
+%! a = [ ones(1,15); sqrt(eps('single'))*eye(15) ];
+%! [q,r]=qr(a); t(j++) = testqr(q,r,a);
+%! [q,r]=qr(a'); t(j++) = testqr(q,r,a');
+%! [q,r,p]=qr(a); t(j++) = testqr(q,r,a,p);
+%! [q,r,p]=qr(a'); t(j++) = testqr(q,r,a',p);
+%! 
+%! a = a+1i*eps('single');
+%! [q,r]=qr(a); t(j++) = testqr(q,r,a);
+%! [q,r]=qr(a'); t(j++) = testqr(q,r,a');
+%! [q,r,p]=qr(a); t(j++) = testqr(q,r,a,p);
+%! [q,r,p]=qr(a'); t(j++) = testqr(q,r,a',p);
+%! 
+%! a = [ ones(1,15); sqrt(eps('single'))*eye(15) ];
+%! [q,r]=qr(a,0); t(j++) = testqr(q,r,a);
+%! [q,r]=qr(a',0); t(j++) = testqr(q,r,a');
+%! [q,r,p]=qr(a,0); t(j++) = testqr(q,r,a,p);
+%! [q,r,p]=qr(a',0); t(j++) = testqr(q,r,a',p);
+%! 
+%! a = a+1i*eps('single');
+%! [q,r]=qr(a,0); t(j++) = testqr(q,r,a);
+%! [q,r]=qr(a',0); t(j++) = testqr(q,r,a');
+%! [q,r,p]=qr(a,0); t(j++) = testqr(q,r,a,p);
+%! [q,r,p]=qr(a',0); t(j++) = testqr(q,r,a',p);
+%! 
+%! a = [
+%! 611   196  -192   407    -8   -52   -49    29
+%! 196   899   113  -192   -71   -43    -8   -44
+%! -192   113   899   196    61    49     8    52
+%! 407  -192   196   611     8    44    59   -23
+%! -8   -71    61     8   411  -599   208   208
+%! -52   -43    49    44  -599   411   208   208
+%! -49    -8     8    59   208   208    99  -911
+%! 29   -44    52   -23   208   208  -911    99
+%! ];
+%! [q,r] = qr(a);
+%! 
+%! assert(all (t) && norm(q*r-a) < 5000*eps('single'));
+
+%% The deactivated tests below can't be tested till rectangular back-subs is
+%% implemented for sparse matrices.
 
 %!testif HAVE_CXSPARSE
 %! n = 20; d= 0.2;
 %! a = sprandn(n,n,d)+speye(n,n);
 %! r = qr(a);
 %! assert(r'*r,a'*a,1e-10)
 
 %!testif HAVE_CXSPARSE
diff --git a/src/DLD-FUNCTIONS/schur.cc b/src/DLD-FUNCTIONS/schur.cc
--- a/src/DLD-FUNCTIONS/schur.cc
+++ b/src/DLD-FUNCTIONS/schur.cc
@@ -385,12 +385,33 @@ leading eigenvalues of\n\
 	  gripe_wrong_type_arg ("schur", arg);
 	}
     }
  
   return retval; 
 }
 
 /*
+
+%!test
+%! a = [1, 2, 3; 4, 5, 9; 7, 8, 6];
+%! [u, s] = schur (a);
+%! assert(u' * a * u, s, sqrt (eps));
+
+%!test
+%! a = single([1, 2, 3; 4, 5, 9; 7, 8, 6]);
+%! [u, s] = schur (a);
+%! assert(u' * a * u, s, sqrt (eps('single')));
+
+%!test
+%! fail("schur ([1, 2; 3, 4], 2)","warning");
+
+%!error <Invalid call to schur.*> schur ();
+%!error schur ([1, 2, 3; 4, 5, 6]);
+
+ */
+
+
+/*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/DLD-FUNCTIONS/svd.cc b/src/DLD-FUNCTIONS/svd.cc
--- a/src/DLD-FUNCTIONS/svd.cc
+++ b/src/DLD-FUNCTIONS/svd.cc
@@ -291,12 +291,78 @@ decomposition, eliminating the unnecessa
 	    }
 	}
     }
 
   return retval;
 }
 
 /*
+
+%!assert(svd ([1, 2; 2, 1]), [3; 1], sqrt (eps));
+
+%!test
+%! [u, s, v] = svd ([1, 2; 2, 1]);
+%! x = 1 / sqrt (2);
+%! assert (u, [-x, -x; -x, x], sqrt (eps));
+%! assert (s, [3, 0; 0, 1], sqrt (eps));
+%! assert (v, [-x, x; -x, -x], sqrt (eps));
+
+%!test
+%! a = [1, 2, 3; 4, 5, 6];
+%! [u, s, v] = svd (a);
+%! assert (u * s * v', a, sqrt (eps));
+
+%!test
+%! a = [1, 2; 3, 4; 5, 6];
+%! [u, s, v] = svd (a);
+%! assert (u * s * v', a, sqrt (eps));
+
+%!test
+%! a = [1, 2, 3; 4, 5, 6];
+%! [u, s, v] = svd (a, 1);
+%! assert (u * s * v', a, sqrt (eps));
+
+%!test
+%! a = [1, 2; 3, 4; 5, 6];
+%! [u, s, v] = svd (a, 1);
+%! assert (u * s * v', a, sqrt (eps));
+
+%!assert(svd (single([1, 2; 2, 1])), single([3; 1]), sqrt (eps('single')));
+
+%!test
+%! [u, s, v] = svd (single([1, 2; 2, 1]));
+%! x = single (1 / sqrt (2));
+%! assert (u, [-x, -x; -x, x], sqrt (eps('single')));
+%! assert (s, single([3, 0; 0, 1]), sqrt (eps('single')));
+%! assert (v, [-x, x; -x, -x], sqrt (eps('single')));
+
+%!test
+%! a = single([1, 2, 3; 4, 5, 6]);
+%! [u, s, v] = svd (a);
+%! assert (u * s * v', a, sqrt (eps('single')));
+
+%!test
+%! a = single([1, 2; 3, 4; 5, 6]);
+%! [u, s, v] = svd (a);
+%! assert (u * s * v', a, sqrt (eps('single')));
+
+%!test
+%! a = single([1, 2, 3; 4, 5, 6]);
+%! [u, s, v] = svd (a, 1);
+%! assert (u * s * v', a, sqrt (eps('single')));
+
+%!test
+%! a = single([1, 2; 3, 4; 5, 6]);
+%! [u, s, v] = svd (a, 1);
+%! assert (u * s * v', a, sqrt (eps('single')));
+
+%!error <Invalid call to svd.*> svd ();
+%!error <Invalid call to svd.*> svd ([1, 2; 4, 5], 2, 3);
+%!error <Invalid call to svd.*> [u, v] = svd ([1, 2; 3, 4]);
+
+ */
+
+/*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/DLD-FUNCTIONS/syl.cc b/src/DLD-FUNCTIONS/syl.cc
--- a/src/DLD-FUNCTIONS/syl.cc
+++ b/src/DLD-FUNCTIONS/syl.cc
@@ -206,12 +206,23 @@ syl ([1, 2; 3, 4], [5, 6; 7, 8], [9, 10;
 	  retval = Sylvester (ca, cb, cc);
 	}
     }
 
   return retval;
 }
 
 /*
+
+%!assert(syl ([1, 2; 3, 4], [5, 6; 7, 8], [9, 10; 11, 12]), [-1/2, -2/3; -2/3, -1/2], sqrt (eps));
+%!assert(syl (single([1, 2; 3, 4]), single([5, 6; 7, 8]), single([9, 10; 11, 12])), single([-1/2, -2/3; -2/3, -1/2]), sqrt (eps('single')));
+
+%!error <Invalid call to syl.*> syl ();
+%!error <Invalid call to syl.*> syl (1, 2, 3, 4);
+%!error syl ([1, 2; 3, 4], [1, 2, 3; 4, 5, 6], [4, 3]);
+
+ */
+
+/*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/OPERATORS/op-fcm-fcm.cc b/src/OPERATORS/op-fcm-fcm.cc
--- a/src/OPERATORS/op-fcm-fcm.cc
+++ b/src/OPERATORS/op-fcm-fcm.cc
@@ -170,16 +170,22 @@ DEFBINOP (el_ldiv, float_complex_matrix,
 DEFNDBINOP_FN (el_and, float_complex_matrix, float_complex_matrix, 
 	       float_complex_array, float_complex_array, mx_el_and)
 DEFNDBINOP_FN (el_or,  float_complex_matrix, float_complex_matrix, 
 	       float_complex_array, float_complex_array, mx_el_or)
 
 DEFNDCATOP_FN (fcm_fcm, float_complex_matrix, float_complex_matrix, 
 	       float_complex_array, float_complex_array, concat)
 
+DEFNDCATOP_FN (cm_fcm, complex_matrix, float_complex_matrix, 
+	       float_complex_array, float_complex_array, concat)
+
+DEFNDCATOP_FN (fcm_cm, float_complex_matrix, complex_matrix, 
+	       float_complex_array, float_complex_array, concat)
+
 DEFNDASSIGNOP_FN (assign, float_complex_matrix, float_complex_matrix, 
 		  float_complex_array, assign)
 DEFNDASSIGNOP_FN (dbl_assign, complex_matrix, float_complex_matrix, 
 		  complex_array, assign)
 
 CONVDECL (float_complex_matrix_to_complex_matrix)
 {
   CAST_CONV_ARG (const octave_float_complex_matrix&);
@@ -241,16 +247,20 @@ install_fcm_fcm_ops (void)
 		 octave_float_complex_matrix, el_ldiv);
   INSTALL_BINOP (op_el_and, octave_float_complex_matrix, 
 		 octave_float_complex_matrix, el_and);
   INSTALL_BINOP (op_el_or, octave_float_complex_matrix, 
 		 octave_float_complex_matrix, el_or);
 
   INSTALL_CATOP (octave_float_complex_matrix, 
 		 octave_float_complex_matrix, fcm_fcm);
+  INSTALL_CATOP (octave_complex_matrix, 
+		 octave_float_complex_matrix, cm_fcm);
+  INSTALL_CATOP (octave_float_complex_matrix, 
+		 octave_complex_matrix, fcm_cm);
 
   INSTALL_ASSIGNOP (op_asn_eq, octave_float_complex_matrix, 
 		    octave_float_complex_matrix, assign);
   INSTALL_ASSIGNOP (op_asn_eq, octave_float_complex_matrix, 
 		    octave_complex_matrix, dbl_assign);
 
   INSTALL_CONVOP (octave_float_complex_matrix, octave_complex_matrix, 
 		  float_complex_matrix_to_complex_matrix);
diff --git a/src/OPERATORS/op-fcm-fcs.cc b/src/OPERATORS/op-fcm-fcs.cc
--- a/src/OPERATORS/op-fcm-fcs.cc
+++ b/src/OPERATORS/op-fcm-fcs.cc
@@ -26,16 +26,17 @@ along with Octave; see the file COPYING.
 #endif
 
 #include "gripes.h"
 #include "oct-obj.h"
 #include "ov.h"
 #include "ov-cx-mat.h"
 #include "ov-flt-cx-mat.h"
 #include "ov-flt-complex.h"
+#include "ov-complex.h"
 #include "ov-typeinfo.h"
 #include "ops.h"
 #include "xdiv.h"
 #include "xpow.h"
 
 // complex matrix by complex scalar ops.
 
 DEFNDBINOP_OP (add, float_complex_matrix, float_complex, 
@@ -117,16 +118,22 @@ DEFBINOP (el_ldiv, float_complex_matrix,
 DEFNDBINOP_FN (el_and, float_complex_matrix, float_complex, 
 	       float_complex_array, float_complex, mx_el_and)
 DEFNDBINOP_FN (el_or,  float_complex_matrix, float_complex, 
 	       float_complex_array, float_complex, mx_el_or)
 
 DEFNDCATOP_FN (fcm_fcs, float_complex_matrix, float_complex, 
 	       float_complex_array, float_complex_array, concat)
 
+DEFNDCATOP_FN (cm_fcs, complex_matrix, float_complex, 
+	       float_complex_array, float_complex_array, concat)
+
+DEFNDCATOP_FN (fcm_cs, float_complex_matrix, complex, 
+	       float_complex_array, float_complex_array, concat)
+
 DEFNDASSIGNOP_FN (assign, float_complex_matrix, float_complex, 
 		  float_complex_array, assign)
 DEFNDASSIGNOP_FN (dbl_assign, complex_matrix, float_complex, 
 		  complex_array, assign)
 
 void
 install_fcm_fcs_ops (void)
 {
@@ -157,16 +164,18 @@ install_fcm_fcs_ops (void)
   INSTALL_BINOP (op_el_ldiv, octave_float_complex_matrix, 
 		 octave_float_complex, el_ldiv);
   INSTALL_BINOP (op_el_and, octave_float_complex_matrix, 
 		 octave_float_complex, el_and);
   INSTALL_BINOP (op_el_or, octave_float_complex_matrix, 
 		 octave_float_complex, el_or);
 
   INSTALL_CATOP (octave_float_complex_matrix, octave_float_complex, fcm_fcs);
+  INSTALL_CATOP (octave_complex_matrix, octave_float_complex, cm_fcs);
+  INSTALL_CATOP (octave_float_complex_matrix, octave_complex, fcm_cs);
 
   INSTALL_ASSIGNOP (op_asn_eq, octave_float_complex_matrix, 
 		    octave_float_complex, assign);
   INSTALL_ASSIGNOP (op_asn_eq, octave_complex_matrix, 
 		    octave_float_complex, dbl_assign);
 }
 
 /*
diff --git a/src/OPERATORS/op-fcm-fm.cc b/src/OPERATORS/op-fcm-fm.cc
--- a/src/OPERATORS/op-fcm-fm.cc
+++ b/src/OPERATORS/op-fcm-fm.cc
@@ -31,16 +31,17 @@ along with Octave; see the file COPYING.
 #include "mx-fnda-fcnda.h"
 
 #include "gripes.h"
 #include "oct-obj.h"
 #include "ov.h"
 #include "ov-cx-mat.h"
 #include "ov-flt-cx-mat.h"
 #include "ov-flt-re-mat.h"
+#include "ov-re-mat.h"
 #include "ov-typeinfo.h"
 #include "ops.h"
 #include "xdiv.h"
 #include "xpow.h"
 
 // complex matrix by matrix ops.
 
 DEFNDBINOP_OP (add, float_complex_matrix, float_matrix, float_complex_array, float_array, +)
@@ -112,16 +113,22 @@ DEFBINOP (el_ldiv, float_complex_matrix,
 DEFNDBINOP_FN (el_and, float_complex_matrix, float_matrix, 
 	       float_complex_array, float_array, mx_el_and)
 DEFNDBINOP_FN (el_or,  float_complex_matrix, float_matrix, 
 	       float_complex_array, float_array, mx_el_or)
 
 DEFNDCATOP_FN (fcm_fm, float_complex_matrix, float_matrix, 
 	       float_complex_array, float_array, concat)
 
+DEFNDCATOP_FN (cm_fm, complex_matrix, float_matrix, 
+	       float_complex_array, float_array, concat)
+
+DEFNDCATOP_FN (fcm_m, float_complex_matrix, matrix, 
+	       float_complex_array, float_array, concat)
+
 DEFNDASSIGNOP_FN (assign, float_complex_matrix, float_matrix, 
 		  float_complex_array, assign)
 DEFNDASSIGNOP_FN (dbl_assign, complex_matrix, float_matrix, 
 		  complex_array, assign)
 
 void
 install_fcm_fm_ops (void)
 {
@@ -147,16 +154,18 @@ install_fcm_fm_ops (void)
   INSTALL_BINOP (op_el_ldiv, octave_float_complex_matrix, 
 		 octave_float_matrix, el_ldiv);
   INSTALL_BINOP (op_el_and, octave_float_complex_matrix, 
 		 octave_float_matrix, el_and);
   INSTALL_BINOP (op_el_or, octave_float_complex_matrix, 
 		 octave_float_matrix, el_or);
 
   INSTALL_CATOP (octave_float_complex_matrix, octave_float_matrix, fcm_fm);
+  INSTALL_CATOP (octave_complex_matrix, octave_float_matrix, cm_fm);
+  INSTALL_CATOP (octave_float_complex_matrix, octave_matrix, fcm_m);
 
   INSTALL_ASSIGNOP (op_asn_eq, octave_float_complex_matrix, 
 		    octave_float_matrix, assign);
   INSTALL_ASSIGNOP (op_asn_eq, octave_complex_matrix, 
 		    octave_float_matrix, dbl_assign);
 }
 
 /*
diff --git a/src/OPERATORS/op-fcm-fs.cc b/src/OPERATORS/op-fcm-fs.cc
--- a/src/OPERATORS/op-fcm-fs.cc
+++ b/src/OPERATORS/op-fcm-fs.cc
@@ -30,16 +30,17 @@ along with Octave; see the file COPYING.
 
 #include "gripes.h"
 #include "oct-obj.h"
 #include "ov.h"
 #include "ov-cx-mat.h"
 #include "ov-flt-cx-mat.h"
 #include "ov-flt-re-mat.h"
 #include "ov-float.h"
+#include "ov-scalar.h"
 #include "ov-typeinfo.h"
 #include "ops.h"
 #include "xdiv.h"
 #include "xpow.h"
 
 // complex matrix by scalar ops.
 
 DEFNDBINOP_OP (add, float_complex_matrix, float_scalar, float_complex_array, float_scalar, +)
@@ -115,16 +116,22 @@ DEFBINOP (el_ldiv, float_complex_matrix,
 DEFNDBINOP_FN (el_and, float_complex_matrix, float_scalar, float_complex_array, 
 	       float_scalar, mx_el_and)
 DEFNDBINOP_FN (el_or,  float_complex_matrix, float_scalar, float_complex_array, 
 	       float_scalar, mx_el_or)
 
 DEFNDCATOP_FN (fcm_fs, float_complex_matrix, float_scalar, float_complex_array, 
 	       float_array, concat)
 
+DEFNDCATOP_FN (cm_fs, complex_matrix, float_scalar, float_complex_array, 
+	       float_array, concat)
+
+DEFNDCATOP_FN (fcm_s, float_complex_matrix, scalar, float_complex_array, 
+	       float_array, concat)
+
 DEFNDASSIGNOP_FN (assign, float_complex_matrix, float_scalar, float_complex_array, assign)
 DEFNDASSIGNOP_FN (dbl_assign, complex_matrix, float_scalar, complex_array, assign)
 
 void
 install_fcm_fs_ops (void)
 {
   INSTALL_BINOP (op_add, octave_float_complex_matrix, octave_float_scalar, add);
   INSTALL_BINOP (op_sub, octave_float_complex_matrix, octave_float_scalar, sub);
@@ -141,16 +148,18 @@ install_fcm_fs_ops (void)
   INSTALL_BINOP (op_el_mul, octave_float_complex_matrix, octave_float_scalar, el_mul);
   INSTALL_BINOP (op_el_div, octave_float_complex_matrix, octave_float_scalar, el_div);
   INSTALL_BINOP (op_el_pow, octave_float_complex_matrix, octave_float_scalar, el_pow);
   INSTALL_BINOP (op_el_ldiv, octave_float_complex_matrix, octave_float_scalar, el_ldiv);
   INSTALL_BINOP (op_el_and, octave_float_complex_matrix, octave_float_scalar, el_and);
   INSTALL_BINOP (op_el_or, octave_float_complex_matrix, octave_float_scalar, el_or);
 
   INSTALL_CATOP (octave_float_complex_matrix, octave_float_scalar, fcm_fs);
+  INSTALL_CATOP (octave_complex_matrix, octave_float_scalar, cm_fs);
+  INSTALL_CATOP (octave_float_complex_matrix, octave_scalar, fcm_s);
 
   INSTALL_ASSIGNOP (op_asn_eq, octave_float_complex_matrix, 
 		    octave_float_scalar, assign);
   INSTALL_ASSIGNOP (op_asn_eq, octave_complex_matrix, 
 		    octave_float_scalar, dbl_assign);
 }
 
 /*
diff --git a/src/OPERATORS/op-fcs-fcm.cc b/src/OPERATORS/op-fcs-fcm.cc
--- a/src/OPERATORS/op-fcs-fcm.cc
+++ b/src/OPERATORS/op-fcs-fcm.cc
@@ -103,16 +103,20 @@ DEFBINOP (el_ldiv, float_complex, float_
   return octave_value (v2.float_complex_array_value () / d);
 }
 
 DEFNDBINOP_FN (el_and, float_complex, float_complex_matrix, float_complex, float_complex_array, mx_el_and)
 DEFNDBINOP_FN (el_or,  float_complex, float_complex_matrix, float_complex, float_complex_array, mx_el_or)
 
 DEFNDCATOP_FN (fcs_fcm, float_complex, float_complex_matrix, float_complex_array, float_complex_array, concat)
 
+DEFNDCATOP_FN (cs_fcm, complex, float_complex_matrix, float_complex_array, float_complex_array, concat)
+
+DEFNDCATOP_FN (fcs_cm, float_complex, complex_matrix, float_complex_array, float_complex_array, concat)
+
 DEFCONV (float_complex_matrix_conv, float_complex, float_complex_matrix)
 {
   CAST_CONV_ARG (const octave_float_complex&);
 
   return new octave_float_complex_matrix (v.float_complex_matrix_value ());
 }
 
 void
@@ -133,16 +137,18 @@ install_fcs_fcm_ops (void)
   INSTALL_BINOP (op_el_mul, octave_float_complex, octave_float_complex_matrix, el_mul);
   INSTALL_BINOP (op_el_div, octave_float_complex, octave_float_complex_matrix, el_div);
   INSTALL_BINOP (op_el_pow, octave_float_complex, octave_float_complex_matrix, el_pow);
   INSTALL_BINOP (op_el_ldiv, octave_float_complex, octave_float_complex_matrix, el_ldiv);
   INSTALL_BINOP (op_el_and, octave_float_complex, octave_float_complex_matrix, el_and);
   INSTALL_BINOP (op_el_or, octave_float_complex, octave_float_complex_matrix, el_or);
 
   INSTALL_CATOP (octave_float_complex, octave_float_complex_matrix, fcs_fcm);
+  INSTALL_CATOP (octave_complex, octave_float_complex_matrix, cs_fcm);
+  INSTALL_CATOP (octave_float_complex, octave_complex_matrix, fcs_cm);
 
   INSTALL_ASSIGNCONV (octave_float_complex, octave_float_complex_matrix, octave_float_complex_matrix);
 
   INSTALL_ASSIGNCONV (octave_complex, octave_float_complex_matrix, octave_complex_matrix);
 
   INSTALL_WIDENOP (octave_float_complex, octave_float_complex_matrix, float_complex_matrix_conv);
 }
 
diff --git a/src/OPERATORS/op-fcs-fcs.cc b/src/OPERATORS/op-fcs-fcs.cc
--- a/src/OPERATORS/op-fcs-fcs.cc
+++ b/src/OPERATORS/op-fcs-fcs.cc
@@ -175,16 +175,22 @@ DEFBINOP (el_or, float_complex, float_co
 
   return (v1.float_complex_value () != static_cast<float>(0.0) || 
 	  v2.float_complex_value () != static_cast<float>(0.0));
 }
 
 DEFNDCATOP_FN (fcs_fcs, float_complex, float_complex, float_complex_array, 
 	       float_complex_array, concat)
 
+DEFNDCATOP_FN (cs_fcs, complex, float_complex, float_complex_array, 
+	       float_complex_array, concat)
+
+DEFNDCATOP_FN (fcs_cs, float_complex, complex, float_complex_array, 
+	       float_complex_array, concat)
+
 CONVDECL (float_complex_to_complex)
 {
   CAST_CONV_ARG (const octave_float_complex&);
 
   return new octave_complex_matrix (ComplexMatrix (1, 1, static_cast<Complex>(v.float_complex_value ())));
 }
 
 void
@@ -214,16 +220,18 @@ install_fcs_fcs_ops (void)
   INSTALL_BINOP (op_el_mul, octave_float_complex, octave_float_complex, el_mul);
   INSTALL_BINOP (op_el_div, octave_float_complex, octave_float_complex, el_div);
   INSTALL_BINOP (op_el_pow, octave_float_complex, octave_float_complex, el_pow);
   INSTALL_BINOP (op_el_ldiv, octave_float_complex, octave_float_complex, el_ldiv);
   INSTALL_BINOP (op_el_and, octave_float_complex, octave_float_complex, el_and);
   INSTALL_BINOP (op_el_or, octave_float_complex, octave_float_complex, el_or);
 
   INSTALL_CATOP (octave_float_complex, octave_float_complex, fcs_fcs);
+  INSTALL_CATOP (octave_complex, octave_float_complex, cs_fcs);
+  INSTALL_CATOP (octave_float_complex, octave_complex, fcs_cs);
 
   INSTALL_ASSIGNCONV (octave_float_complex, octave_float_complex, octave_float_complex_matrix);
 
   INSTALL_ASSIGNCONV (octave_complex, octave_float_complex, octave_complex_matrix);
 
   INSTALL_CONVOP (octave_float_complex, octave_complex_matrix, 
 		  float_complex_to_complex);
 }
diff --git a/src/OPERATORS/op-fcs-fm.cc b/src/OPERATORS/op-fcs-fm.cc
--- a/src/OPERATORS/op-fcs-fm.cc
+++ b/src/OPERATORS/op-fcs-fm.cc
@@ -33,16 +33,17 @@ along with Octave; see the file COPYING.
 #include "gripes.h"
 #include "oct-obj.h"
 #include "ov.h"
 #include "ov-complex.h"
 #include "ov-flt-complex.h"
 #include "ov-cx-mat.h"
 #include "ov-flt-cx-mat.h"
 #include "ov-flt-re-mat.h"
+#include "ov-re-mat.h"
 #include "ov-typeinfo.h"
 #include "ops.h"
 #include "xdiv.h"
 #include "xpow.h"
 
 // complex scalar by matrix ops.
 
 DEFNDBINOP_OP (add, float_complex, float_matrix, float_complex, float_array, +)
@@ -112,16 +113,22 @@ DEFBINOP (el_ldiv, float_complex, float_
 DEFNDBINOP_FN (el_and, float_complex, float_matrix, float_complex, 
 	       float_array, mx_el_and)
 DEFNDBINOP_FN (el_or,  float_complex, float_matrix, float_complex, 
 	       float_array, mx_el_or)
 
 DEFNDCATOP_FN (fcs_fm, float_complex, float_matrix, float_complex_array, 
 	       float_array, concat)
 
+DEFNDCATOP_FN (cs_fm, complex, float_matrix, float_complex_array, 
+	       float_array, concat)
+
+DEFNDCATOP_FN (fcs_m, float_complex, matrix, float_complex_array, 
+	       float_array, concat)
+
 void
 install_fcs_fm_ops (void)
 {
   INSTALL_BINOP (op_add, octave_float_complex, octave_float_matrix, add);
   INSTALL_BINOP (op_sub, octave_float_complex, octave_float_matrix, sub);
   INSTALL_BINOP (op_mul, octave_float_complex, octave_float_matrix, mul);
   INSTALL_BINOP (op_div, octave_float_complex, octave_float_matrix, div);
   INSTALL_BINOP (op_pow, octave_float_complex, octave_float_matrix, pow);
@@ -135,16 +142,18 @@ install_fcs_fm_ops (void)
   INSTALL_BINOP (op_el_mul, octave_float_complex, octave_float_matrix, el_mul);
   INSTALL_BINOP (op_el_div, octave_float_complex, octave_float_matrix, el_div);
   INSTALL_BINOP (op_el_pow, octave_float_complex, octave_float_matrix, el_pow);
   INSTALL_BINOP (op_el_ldiv, octave_float_complex, octave_float_matrix, el_ldiv);
   INSTALL_BINOP (op_el_and, octave_float_complex, octave_float_matrix, el_and);
   INSTALL_BINOP (op_el_or, octave_float_complex, octave_float_matrix, el_or);
 
   INSTALL_CATOP (octave_float_complex, octave_float_matrix, fcs_fm);
+  INSTALL_CATOP (octave_complex, octave_float_matrix, cs_fm);
+  INSTALL_CATOP (octave_float_complex, octave_matrix, fcs_m);
 
   INSTALL_ASSIGNCONV (octave_float_complex, octave_float_matrix, 
 		      octave_float_complex_matrix);
   INSTALL_ASSIGNCONV (octave_complex, octave_float_matrix, 
 		      octave_complex_matrix);
 }
 
 /*
diff --git a/src/OPERATORS/op-fcs-fs.cc b/src/OPERATORS/op-fcs-fs.cc
--- a/src/OPERATORS/op-fcs-fs.cc
+++ b/src/OPERATORS/op-fcs-fs.cc
@@ -28,16 +28,17 @@ along with Octave; see the file COPYING.
 #include "gripes.h"
 #include "oct-obj.h"
 #include "ov.h"
 #include "ov-complex.h"
 #include "ov-flt-complex.h"
 #include "ov-cx-mat.h"
 #include "ov-flt-cx-mat.h"
 #include "ov-float.h"
+#include "ov-scalar.h"
 #include "ov-typeinfo.h"
 #include "ops.h"
 #include "xdiv.h"
 #include "xpow.h"
 
 // complex scalar by scalar ops.
 
 DEFBINOP_OP (add, float_complex, float_scalar, +)
@@ -154,16 +155,22 @@ DEFBINOP (el_or, float_complex, float)
 
   return (v1.float_complex_value () != static_cast<float>(0.0) || 
 	  v2.float_value ());
 }
 
 DEFNDCATOP_FN (fcs_fs, float_complex, float_scalar, float_complex_array, 
 	       float_array, concat)
 
+DEFNDCATOP_FN (cs_fs, complex, float_scalar, float_complex_array, 
+	       float_array, concat)
+
+DEFNDCATOP_FN (fcs_s, float_complex, scalar, float_complex_array, 
+	       float_array, concat)
+
 void
 install_fcs_fs_ops (void)
 {
   INSTALL_BINOP (op_add, octave_float_complex, octave_float_scalar, add);
   INSTALL_BINOP (op_sub, octave_float_complex, octave_float_scalar, sub);
   INSTALL_BINOP (op_mul, octave_float_complex, octave_float_scalar, mul);
   INSTALL_BINOP (op_div, octave_float_complex, octave_float_scalar, div);
   INSTALL_BINOP (op_pow, octave_float_complex, octave_float_scalar, pow);
@@ -177,16 +184,18 @@ install_fcs_fs_ops (void)
   INSTALL_BINOP (op_el_mul, octave_float_complex, octave_float_scalar, el_mul);
   INSTALL_BINOP (op_el_div, octave_float_complex, octave_float_scalar, el_div);
   INSTALL_BINOP (op_el_pow, octave_float_complex, octave_float_scalar, el_pow);
   INSTALL_BINOP (op_el_ldiv, octave_float_complex, octave_float_scalar, el_ldiv);
   INSTALL_BINOP (op_el_and, octave_float_complex, octave_float_scalar, el_and);
   INSTALL_BINOP (op_el_or, octave_float_complex, octave_float_scalar, el_or);
 
   INSTALL_CATOP (octave_float_complex, octave_float_scalar, fcs_fs);
+  INSTALL_CATOP (octave_complex, octave_float_scalar, cs_fs);
+  INSTALL_CATOP (octave_float_complex, octave_scalar, fcs_s);
 
   INSTALL_ASSIGNCONV (octave_float_complex, octave_float_scalar, 
 		      octave_float_complex_matrix);
   INSTALL_ASSIGNCONV (octave_complex, octave_float_scalar, 
 		      octave_complex_matrix);
 }
 
 /*
diff --git a/src/OPERATORS/op-fm-fcm.cc b/src/OPERATORS/op-fm-fcm.cc
--- a/src/OPERATORS/op-fm-fcm.cc
+++ b/src/OPERATORS/op-fm-fcm.cc
@@ -114,16 +114,22 @@ DEFBINOP (el_ldiv, float_matrix, float_c
 DEFNDBINOP_FN (el_and, float_matrix, float_complex_matrix, float_array, 
 	       float_complex_array, mx_el_and)
 DEFNDBINOP_FN (el_or,  float_matrix, float_complex_matrix, float_array, 
 	       float_complex_array, mx_el_or)
 
 DEFNDCATOP_FN (fm_fcm, float_matrix, float_complex_matrix, float_array, 
 	       float_complex_array, concat)
 
+DEFNDCATOP_FN (m_fcm, matrix, float_complex_matrix, float_array, 
+	       float_complex_array, concat)
+
+DEFNDCATOP_FN (fm_cm, float_matrix, complex_matrix, float_array, 
+	       float_complex_array, concat)
+
 DEFCONV (float_complex_matrix_conv, float_matrix, float_complex_matrix)
 {
   CAST_CONV_ARG (const octave_float_matrix&);
 
   return new octave_float_complex_matrix (FloatComplexNDArray (v.float_array_value ()));
 }
 
 void
@@ -151,16 +157,18 @@ install_fm_fcm_ops (void)
   INSTALL_BINOP (op_el_ldiv, octave_float_matrix, 
 		 octave_float_complex_matrix, el_ldiv);
   INSTALL_BINOP (op_el_and, octave_float_matrix, 
 		 octave_float_complex_matrix, el_and);
   INSTALL_BINOP (op_el_or, octave_float_matrix, 
 		 octave_float_complex_matrix, el_or);
 
   INSTALL_CATOP (octave_float_matrix, octave_float_complex_matrix, fm_fcm);
+  INSTALL_CATOP (octave_matrix, octave_float_complex_matrix, m_fcm);
+  INSTALL_CATOP (octave_float_matrix, octave_complex_matrix, fm_cm);
 
   INSTALL_ASSIGNCONV (octave_float_matrix, octave_float_complex_matrix, 
 		      octave_float_complex_matrix);
   INSTALL_ASSIGNCONV (octave_matrix, octave_float_complex_matrix, 
 		      octave_complex_matrix);
 
   INSTALL_WIDENOP (octave_float_matrix, octave_float_complex_matrix, 
 		   float_complex_matrix_conv);
diff --git a/src/OPERATORS/op-fm-fcs.cc b/src/OPERATORS/op-fm-fcs.cc
--- a/src/OPERATORS/op-fm-fcs.cc
+++ b/src/OPERATORS/op-fm-fcs.cc
@@ -33,16 +33,17 @@ along with Octave; see the file COPYING.
 #include "gripes.h"
 #include "oct-obj.h"
 #include "ov.h"
 #include "ov-re-mat.h"
 #include "ov-flt-re-mat.h"
 #include "ov-cx-mat.h"
 #include "ov-flt-cx-mat.h"
 #include "ov-flt-complex.h"
+#include "ov-complex.h"
 #include "ov-typeinfo.h"
 #include "ops.h"
 #include "xdiv.h"
 #include "xpow.h"
 
 // matrix by complex scalar ops.
 
 DEFNDBINOP_OP (add, float_matrix, float_complex, float_array, float_complex, +)
@@ -118,16 +119,22 @@ DEFBINOP (el_ldiv, float_matrix, flaot_c
 DEFNDBINOP_FN (el_and, float_matrix, float_complex, float_array, 
 	       float_complex, mx_el_and)
 DEFNDBINOP_FN (el_or, float_matrix, float_complex, float_array, 
 	       float_complex, mx_el_or)
 
 DEFNDCATOP_FN (fm_fcs, float_matrix, float_complex, float_array, 
 	       float_complex_array, concat)
 
+DEFNDCATOP_FN (m_fcs, matrix, float_complex, float_array, 
+	       float_complex_array, concat)
+
+DEFNDCATOP_FN (fm_cs, float_matrix, complex, float_array, 
+	       float_complex_array, concat)
+
 void
 install_fm_fcs_ops (void)
 {
   INSTALL_BINOP (op_add, octave_float_matrix, octave_float_complex, add);
   INSTALL_BINOP (op_sub, octave_float_matrix, octave_float_complex, sub);
   INSTALL_BINOP (op_mul, octave_float_matrix, octave_float_complex, mul);
   INSTALL_BINOP (op_div, octave_float_matrix, octave_float_complex, div);
   INSTALL_BINOP (op_pow, octave_float_matrix, octave_float_complex, pow);
@@ -141,16 +148,18 @@ install_fm_fcs_ops (void)
   INSTALL_BINOP (op_el_mul, octave_float_matrix, octave_float_complex, el_mul);
   INSTALL_BINOP (op_el_div, octave_float_matrix, octave_float_complex, el_div);
   INSTALL_BINOP (op_el_pow, octave_float_matrix, octave_float_complex, el_pow);
   INSTALL_BINOP (op_el_ldiv, octave_float_matrix, octave_float_complex, el_ldiv);
   INSTALL_BINOP (op_el_and, octave_float_matrix, octave_float_complex, el_and);
   INSTALL_BINOP (op_el_or, octave_float_matrix, octave_float_complex, el_or);
 
   INSTALL_CATOP (octave_float_matrix, octave_float_complex, fm_fcs);
+  INSTALL_CATOP (octave_matrix, octave_float_complex, m_fcs);
+  INSTALL_CATOP (octave_float_matrix, octave_complex, fm_cs);
 
   INSTALL_ASSIGNCONV (octave_float_matrix, octave_float_complex, 
 		      octave_float_complex_matrix);
   INSTALL_ASSIGNCONV (octave_matrix, octave_float_complex, 
 		      octave_complex_matrix);
 }
 
 /*
diff --git a/src/OPERATORS/op-fm-fm.cc b/src/OPERATORS/op-fm-fm.cc
--- a/src/OPERATORS/op-fm-fm.cc
+++ b/src/OPERATORS/op-fm-fm.cc
@@ -139,16 +139,20 @@ DEFBINOP (el_ldiv, float_matrix, float_m
 DEFNDBINOP_FN (el_and, float_matrix, float_matrix, float_array, 
 	       float_array, mx_el_and)
 DEFNDBINOP_FN (el_or,  float_matrix, float_matrix, float_array, 
 	       float_array, mx_el_or)
 
 DEFNDCATOP_FN (fm_fm, float_matrix, float_matrix, float_array, 
 	       float_array, concat)
 
+DEFNDCATOP_FN (m_fm, matrix, float_matrix, float_array, float_array, concat)
+
+DEFNDCATOP_FN (fm_m, float_matrix, matrix, float_array, float_array, concat)
+
 DEFNDASSIGNOP_FN (assign, float_matrix, float_matrix, float_array, assign)
 
 DEFNDASSIGNOP_FN (dbl_assign, matrix, float_matrix, array, assign)
 
 CONVDECL (float_matrix_to_matrix)
 {
   CAST_CONV_ARG (const octave_float_matrix&);
 
@@ -186,16 +190,18 @@ install_fm_fm_ops (void)
   INSTALL_BINOP (op_el_and, octave_float_matrix, octave_float_matrix, el_and);
   INSTALL_BINOP (op_el_or, octave_float_matrix, octave_float_matrix, el_or);
   INSTALL_BINOP (op_trans_mul, octave_float_matrix, octave_float_matrix, trans_mul);
   INSTALL_BINOP (op_mul_trans, octave_float_matrix, octave_float_matrix, mul_trans);
   INSTALL_BINOP (op_herm_mul, octave_float_matrix, octave_float_matrix, trans_mul);
   INSTALL_BINOP (op_mul_herm, octave_float_matrix, octave_float_matrix, mul_trans);
 
   INSTALL_CATOP (octave_float_matrix, octave_float_matrix, fm_fm);
+  INSTALL_CATOP (octave_matrix, octave_float_matrix, m_fm);
+  INSTALL_CATOP (octave_float_matrix, octave_matrix, fm_m);
 
   INSTALL_ASSIGNOP (op_asn_eq, octave_float_matrix, 
 		    octave_float_matrix, assign);
   INSTALL_ASSIGNOP (op_asn_eq, octave_matrix, 
 		    octave_float_matrix, dbl_assign);
 
   INSTALL_CONVOP (octave_float_matrix, octave_matrix, float_matrix_to_matrix);
 }
diff --git a/src/OPERATORS/op-fm-fs.cc b/src/OPERATORS/op-fm-fs.cc
--- a/src/OPERATORS/op-fm-fs.cc
+++ b/src/OPERATORS/op-fm-fs.cc
@@ -25,16 +25,17 @@ along with Octave; see the file COPYING.
 #include <config.h>
 #endif
 
 #include "gripes.h"
 #include "oct-obj.h"
 #include "ov.h"
 #include "ov-flt-re-mat.h"
 #include "ov-float.h"
+#include "ov-scalar.h"
 #include "ov-typeinfo.h"
 #include "ops.h"
 #include "xdiv.h"
 #include "xpow.h"
 
 // matrix by scalar ops.
 
 DEFNDBINOP_OP (add, float_matrix, float_scalar, float_array, float_scalar, +)
@@ -109,16 +110,20 @@ DEFBINOP (el_ldiv, float_matrix, float)
 DEFNDBINOP_FN (el_and, float_matrix, float_scalar, float_array, 
 	       float_scalar, mx_el_and)
 DEFNDBINOP_FN (el_or, float_matrix, float_scalar, float_array, 
 	       float_scalar, mx_el_or)
 
 DEFNDCATOP_FN (fm_fs, float_matrix, float_scalar, float_array, 
 	       float_array, concat)
 
+DEFNDCATOP_FN (m_fs, matrix, float_scalar, float_array, float_array, concat)
+
+DEFNDCATOP_FN (fm_s, float_matrix, scalar, float_array, float_array, concat)
+
 DEFNDASSIGNOP_FN (assign, float_matrix, float_scalar, float_array, assign)
 DEFNDASSIGNOP_FN (dbl_assign, matrix, float_scalar, array, assign)
 
 void
 install_fm_fs_ops (void)
 {
   INSTALL_BINOP (op_add, octave_float_matrix, octave_float_scalar, add);
   INSTALL_BINOP (op_sub, octave_float_matrix, octave_float_scalar, sub);
@@ -135,16 +140,18 @@ install_fm_fs_ops (void)
   INSTALL_BINOP (op_el_mul, octave_float_matrix, octave_float_scalar, el_mul);
   INSTALL_BINOP (op_el_div, octave_float_matrix, octave_float_scalar, el_div);
   INSTALL_BINOP (op_el_pow, octave_float_matrix, octave_float_scalar, el_pow);
   INSTALL_BINOP (op_el_ldiv, octave_float_matrix, octave_float_scalar, el_ldiv);
   INSTALL_BINOP (op_el_and, octave_float_matrix, octave_float_scalar, el_and);
   INSTALL_BINOP (op_el_or, octave_float_matrix, octave_float_scalar, el_or);
 
   INSTALL_CATOP (octave_float_matrix, octave_float_scalar, fm_fs);
+  INSTALL_CATOP (octave_matrix, octave_float_scalar, m_fs);
+  INSTALL_CATOP (octave_float_matrix, octave_scalar, fm_s);
 
   INSTALL_ASSIGNOP (op_asn_eq, octave_float_matrix, octave_float_scalar, assign);
   INSTALL_ASSIGNOP (op_asn_eq, octave_matrix, octave_float_scalar, dbl_assign);
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
diff --git a/src/OPERATORS/op-fs-fcm.cc b/src/OPERATORS/op-fs-fcm.cc
--- a/src/OPERATORS/op-fs-fcm.cc
+++ b/src/OPERATORS/op-fs-fcm.cc
@@ -118,16 +118,22 @@ DEFBINOP (el_ldiv, float_scalar, float_c
 DEFNDBINOP_FN (el_and, float_scalar, float_complex_matrix, float_scalar, 
 	       float_complex_array, mx_el_and)
 DEFNDBINOP_FN (el_or,  float_scalar, float_complex_matrix, float_scalar, 
 	       float_complex_array, mx_el_or)
 
 DEFNDCATOP_FN (fs_fcm, float_scalar, float_complex_matrix, float_array, 
 	       float_complex_array, concat)
 
+DEFNDCATOP_FN (s_fcm, scalar, float_complex_matrix, float_array, 
+	       float_complex_array, concat)
+
+DEFNDCATOP_FN (fs_cm, float_scalar, complex_matrix, float_array, 
+	       float_complex_array, concat)
+
 DEFCONV (float_complex_matrix_conv, float_scalar, float_complex_matrix)
 {
   CAST_CONV_ARG (const octave_float_scalar&);
 
   return new octave_float_complex_matrix (FloatComplexMatrix (v.float_matrix_value ()));
 }
 
 void
@@ -155,16 +161,18 @@ install_fs_fcm_ops (void)
   INSTALL_BINOP (op_el_ldiv, octave_float_scalar, 
 		 octave_float_complex_matrix, el_ldiv);
   INSTALL_BINOP (op_el_and, octave_float_scalar, 
 		 octave_float_complex_matrix, el_and);
   INSTALL_BINOP (op_el_or, octave_float_scalar, 
 		 octave_float_complex_matrix, el_or);
 
   INSTALL_CATOP (octave_float_scalar, octave_float_complex_matrix, fs_fcm);
+  INSTALL_CATOP (octave_scalar, octave_float_complex_matrix, s_fcm);
+  INSTALL_CATOP (octave_float_scalar, octave_complex_matrix, fs_cm);
 
   INSTALL_ASSIGNCONV (octave_float_scalar, octave_float_complex_matrix, 
 		      octave_float_complex_matrix);
   INSTALL_ASSIGNCONV (octave_scalar, octave_float_complex_matrix, 
 		      octave_complex_matrix);
 
   INSTALL_WIDENOP (octave_float_scalar, octave_float_complex_matrix, 
 		   float_complex_matrix_conv);
diff --git a/src/OPERATORS/op-fs-fcs.cc b/src/OPERATORS/op-fs-fcs.cc
--- a/src/OPERATORS/op-fs-fcs.cc
+++ b/src/OPERATORS/op-fs-fcs.cc
@@ -26,16 +26,17 @@ along with Octave; see the file COPYING.
 #endif
 
 #include "gripes.h"
 #include "oct-obj.h"
 #include "ov.h"
 #include "ov-scalar.h"
 #include "ov-float.h"
 #include "ov-flt-complex.h"
+#include "ov-complex.h"
 #include "ov-cx-mat.h"
 #include "ov-flt-cx-mat.h"
 #include "ov-typeinfo.h"
 #include "ops.h"
 #include "xdiv.h"
 #include "xpow.h"
 
 // scalar by complex scalar ops.
@@ -152,16 +153,22 @@ DEFBINOP (el_or, float_scalar, float_com
   CAST_BINOP_ARGS (const octave_float_scalar&, const octave_float_complex&);
 
   return octave_value (v1.float_scalar_value () || (v2.float_complex_value () != static_cast<float>(0.0)));
 }
 
 DEFNDCATOP_FN (fs_fcs, float_scalar, float_complex, float_array, 
 	       float_complex_array, concat)
 
+DEFNDCATOP_FN (s_fcs, scalar, float_complex, float_array, 
+	       float_complex_array, concat)
+
+DEFNDCATOP_FN (fs_cs, float_scalar, complex, float_array, 
+	       float_complex_array, concat)
+
 void
 install_fs_fcs_ops (void)
 {
   INSTALL_BINOP (op_add, octave_float_scalar, octave_float_complex, add);
   INSTALL_BINOP (op_sub, octave_float_scalar, octave_float_complex, sub);
   INSTALL_BINOP (op_mul, octave_float_scalar, octave_float_complex, mul);
   INSTALL_BINOP (op_div, octave_float_scalar, octave_float_complex, div);
   INSTALL_BINOP (op_pow, octave_float_scalar, octave_float_complex, pow);
@@ -175,16 +182,18 @@ install_fs_fcs_ops (void)
   INSTALL_BINOP (op_el_mul, octave_float_scalar, octave_float_complex, el_mul);
   INSTALL_BINOP (op_el_div, octave_float_scalar, octave_float_complex, el_div);
   INSTALL_BINOP (op_el_pow, octave_float_scalar, octave_float_complex, el_pow);
   INSTALL_BINOP (op_el_ldiv, octave_float_scalar, octave_float_complex, el_ldiv);
   INSTALL_BINOP (op_el_and, octave_float_scalar, octave_float_complex, el_and);
   INSTALL_BINOP (op_el_or, octave_float_scalar, octave_float_complex, el_or);
 
   INSTALL_CATOP (octave_float_scalar, octave_float_complex, fs_fcs);
+  INSTALL_CATOP (octave_scalar, octave_float_complex, s_fcs);
+  INSTALL_CATOP (octave_float_scalar, octave_complex, fs_cs);
 
   INSTALL_ASSIGNCONV (octave_float_scalar, octave_float_complex, 
 		      octave_float_complex_matrix);
   INSTALL_ASSIGNCONV (octave_scalar, octave_float_complex, 
 		      octave_complex_matrix);
 }
 
 /*
diff --git a/src/OPERATORS/op-fs-fm.cc b/src/OPERATORS/op-fs-fm.cc
--- a/src/OPERATORS/op-fs-fm.cc
+++ b/src/OPERATORS/op-fs-fm.cc
@@ -106,16 +106,20 @@ DEFBINOP (el_ldiv, float_scalar, float_m
 DEFNDBINOP_FN (el_and, float_scalar, float_matrix, float_scalar, 
 	       float_array, mx_el_and)
 DEFNDBINOP_FN (el_or,  float_scalar, float_matrix, float_scalar, 
 	       float_array, mx_el_or)
 
 DEFNDCATOP_FN (fs_fm, float_scalar, float_matrix, float_array, 
 	       float_array, concat)
 
+DEFNDCATOP_FN (s_fm, scalar, float_matrix, float_array, float_array, concat)
+
+DEFNDCATOP_FN (fs_m, float_scalar, matrix, float_array, float_array, concat)
+
 DEFCONV (matrix_conv, float_scalar, float_matrix)
 {
   CAST_CONV_ARG (const octave_float_scalar&);
 
   return new octave_float_matrix (v.float_matrix_value ());
 }
 
 void
@@ -136,16 +140,18 @@ install_fs_fm_ops (void)
   INSTALL_BINOP (op_el_mul, octave_float_scalar, octave_float_matrix, el_mul);
   INSTALL_BINOP (op_el_div, octave_float_scalar, octave_float_matrix, el_div);
   INSTALL_BINOP (op_el_pow, octave_float_scalar, octave_float_matrix, el_pow);
   INSTALL_BINOP (op_el_ldiv, octave_float_scalar, octave_float_matrix, el_ldiv);
   INSTALL_BINOP (op_el_and, octave_float_scalar, octave_float_matrix, el_and);
   INSTALL_BINOP (op_el_or, octave_float_scalar, octave_float_matrix, el_or);
 
   INSTALL_CATOP (octave_float_scalar, octave_float_matrix, fs_fm);
+  INSTALL_CATOP (octave_scalar, octave_float_matrix, s_fm);
+  INSTALL_CATOP (octave_float_scalar, octave_matrix, fs_m);
 
   INSTALL_ASSIGNCONV (octave_float_scalar, octave_float_matrix, octave_float_matrix);
   INSTALL_ASSIGNCONV (octave_scalar, octave_float_matrix, octave_matrix);
 
   INSTALL_WIDENOP (octave_float_scalar, octave_float_matrix, matrix_conv);
 }
 
 /*
diff --git a/src/OPERATORS/op-fs-fs.cc b/src/OPERATORS/op-fs-fs.cc
--- a/src/OPERATORS/op-fs-fs.cc
+++ b/src/OPERATORS/op-fs-fs.cc
@@ -113,16 +113,18 @@ DEFBINOP (el_ldiv, float_scalar, float_s
 
   return octave_value (v2.float_value () / d);
 }
 
 DEFBINOP_OP (el_and, float_scalar, float_scalar, &&)
 DEFBINOP_OP (el_or, float_scalar, float_scalar, ||)
 
 DEFNDCATOP_FN (fs_fs, float_scalar, float_scalar, float_array, float_array, concat)
+DEFNDCATOP_FN (s_fs, scalar, float_scalar, float_array, float_array, concat)
+DEFNDCATOP_FN (fs_s, float_scalar, scalar, float_array, float_array, concat)
 
 CONVDECL (float_to_scalar)
 {
   CAST_CONV_ARG (const octave_float_scalar&);
 
   return new octave_matrix (Matrix (1, 1, static_cast<double>(v.float_value ())));
 }
 
@@ -153,16 +155,18 @@ install_fs_fs_ops (void)
   INSTALL_BINOP (op_el_mul, octave_float_scalar, octave_float_scalar, el_mul);
   INSTALL_BINOP (op_el_div, octave_float_scalar, octave_float_scalar, el_div);
   INSTALL_BINOP (op_el_pow, octave_float_scalar, octave_float_scalar, el_pow);
   INSTALL_BINOP (op_el_ldiv, octave_float_scalar, octave_float_scalar, el_ldiv);
   INSTALL_BINOP (op_el_and, octave_float_scalar, octave_float_scalar, el_and);
   INSTALL_BINOP (op_el_or, octave_float_scalar, octave_float_scalar, el_or);
 
   INSTALL_CATOP (octave_float_scalar, octave_float_scalar, fs_fs);
+  INSTALL_CATOP (octave_scalar, octave_float_scalar, s_fs);
+  INSTALL_CATOP (octave_float_scalar, octave_scalar, fs_s);
 
   INSTALL_ASSIGNCONV (octave_float_scalar, octave_float_scalar, octave_float_matrix);
   INSTALL_ASSIGNCONV (octave_scalar, octave_float_scalar, octave_matrix);
 
   INSTALL_CONVOP (octave_float_scalar, octave_matrix, float_to_scalar);
 }
 
 /*
diff --git a/src/data.cc b/src/data.cc
--- a/src/data.cc
+++ b/src/data.cc
@@ -94,16 +94,39 @@ DEFUN (all, args, ,
 The function @code{all} behaves like the function @code{any}, except\n\
 that it returns true only if all the elements of a vector, or all the\n\
 elements along dimension @var{dim} of a matrix, are nonzero.\n\
 @end deftypefn")
 {
   ANY_ALL (all);
 }
 
+/*
+
+%!test
+%! x = ones (3);
+%! x(1,1) = 0;
+%! assert((all (all (rand (3) + 1) == [1, 1, 1]) == 1
+%! && all (all (x) == [0, 1, 1]) == 1
+%! && all (x, 1) == [0, 1, 1]
+%! && all (x, 2) == [0; 1; 1]));
+
+%!test
+%! x = ones (3, 'single');
+%! x(1,1) = 0;
+%! assert((all (all (single (rand (3) + 1)) == [1, 1, 1]) == 1
+%! && all (all (x) == [0, 1, 1]) == 1
+%! && all (x, 1) == [0, 1, 1]
+%! && all (x, 2) == [0; 1; 1]));
+
+%!error <Invalid call to all.*> all ();
+%!error <Invalid call to all.*> all (1, 2, 3);
+
+ */
+
 DEFUN (any, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} any (@var{x}, @var{dim})\n\
 For a vector argument, return 1 if any element of the vector is\n\
 nonzero.\n\
 \n\
 For a matrix argument, return a row vector of ones and\n\
 zeros with each element indicating whether any of the elements of the\n\
@@ -125,16 +148,39 @@ any (eye (2, 4), 2)\n\
      @result{} [ 1; 1 ]\n\
 @end group\n\
 @end example\n\
 @end deftypefn")
 {
   ANY_ALL (any);
 }
 
+/*
+
+%!test
+%! x = zeros (3);
+%! x(3,3) = 1;
+%! assert((all (any (x) == [0, 0, 1]) == 1
+%! && all (any (ones (3)) == [1, 1, 1]) == 1
+%! && any (x, 1) == [0, 0, 1]
+%! && any (x, 2) == [0; 0; 1]));
+
+%!test
+%! x = zeros (3,'single');
+%! x(3,3) = 1;
+%! assert((all (any (x) == [0, 0, 1]) == 1
+%! && all (any (ones (3, 'single')) == [1, 1, 1]) == 1
+%! && any (x, 1) == [0, 0, 1]
+%! && any (x, 2) == [0; 0; 1]));
+
+%!error <Invalid call to any.*> any ();
+%!error <Invalid call to any.*> any (1, 2, 3);
+
+ */
+
 // These mapping functions may also be useful in other places, eh?
 
 typedef double (*d_dd_fcn) (double, double);
 typedef float (*f_ff_fcn) (float, float);
 
 static NDArray
 map_d_m (d_dd_fcn f, double x, const NDArray& y)
 {
@@ -1497,16 +1543,53 @@ Given a matrix argument, instead of a ve
 	retval = args(0).diag(k);
     }
   else
     print_usage ();
 
   return retval;
 }
 
+/*
+
+%!assert(diag ([1; 2; 3]), [1, 0, 0; 0, 2, 0; 0, 0, 3]);
+%!assert(diag ([1; 2; 3], 1), [0, 1, 0, 0; 0, 0, 2, 0; 0, 0, 0, 3; 0, 0, 0, 0]);
+%!assert(diag ([1; 2; 3], 2), [0, 0, 1, 0, 0; 0, 0, 0, 2, 0; 0, 0, 0, 0, 3; 0, 0, 0, 0, 0; 0, 0, 0, 0, 0]);
+%!assert(diag ([1; 2; 3],-1), [0, 0, 0, 0; 1, 0, 0, 0; 0, 2, 0, 0; 0, 0, 3, 0]);
+%!assert(diag ([1; 2; 3],-2), [0, 0, 0, 0, 0; 0, 0, 0, 0, 0; 1, 0, 0, 0, 0; 0, 2, 0, 0, 0; 0, 0, 3, 0, 0]);
+
+%!assert(diag ([1, 0, 0; 0, 2, 0; 0, 0, 3]), [1; 2; 3]);
+%!assert(diag ([0, 1, 0, 0; 0, 0, 2, 0; 0, 0, 0, 3; 0, 0, 0, 0], 1), [1; 2; 3]);
+%!assert(diag ([0, 0, 0, 0; 1, 0, 0, 0; 0, 2, 0, 0; 0, 0, 3, 0], -1), [1; 2; 3]);
+
+%!assert(diag (single([1; 2; 3])), single([1, 0, 0; 0, 2, 0; 0, 0, 3]));
+%!assert(diag (single([1; 2; 3]), 1), single([0, 1, 0, 0; 0, 0, 2, 0; 0, 0, 0, 3; 0, 0, 0, 0]));
+%!assert(diag (single([1; 2; 3]), 2), single([0, 0, 1, 0, 0; 0, 0, 0, 2, 0; 0, 0, 0, 0, 3; 0, 0, 0, 0, 0; 0, 0, 0, 0, 0]));
+%!assert(diag (single([1; 2; 3]),-1), single([0, 0, 0, 0; 1, 0, 0, 0; 0, 2, 0, 0; 0, 0, 3, 0]));
+%!assert(diag (single([1; 2; 3]),-2), single([0, 0, 0, 0, 0; 0, 0, 0, 0, 0; 1, 0, 0, 0, 0; 0, 2, 0, 0, 0; 0, 0, 3, 0, 0]));
+
+%!assert(diag (single([1, 0, 0; 0, 2, 0; 0, 0, 3])), single([1; 2; 3]));
+%!assert(diag (single([0, 1, 0, 0; 0, 0, 2, 0; 0, 0, 0, 3; 0, 0, 0, 0]), 1), single([1; 2; 3]));
+%!assert(diag (single([0, 0, 0, 0; 1, 0, 0, 0; 0, 2, 0, 0; 0, 0, 3, 0]), -1), single([1; 2; 3]));
+
+%!assert(diag (int8([1; 2; 3])), int8([1, 0, 0; 0, 2, 0; 0, 0, 3]));
+%!assert(diag (int8([1; 2; 3]), 1), int8([0, 1, 0, 0; 0, 0, 2, 0; 0, 0, 0, 3; 0, 0, 0, 0]));
+%!assert(diag (int8([1; 2; 3]), 2), int8([0, 0, 1, 0, 0; 0, 0, 0, 2, 0; 0, 0, 0, 0, 3; 0, 0, 0, 0, 0; 0, 0, 0, 0, 0]));
+%!assert(diag (int8([1; 2; 3]),-1), int8([0, 0, 0, 0; 1, 0, 0, 0; 0, 2, 0, 0; 0, 0, 3, 0]));
+%!assert(diag (int8([1; 2; 3]),-2), int8([0, 0, 0, 0, 0; 0, 0, 0, 0, 0; 1, 0, 0, 0, 0; 0, 2, 0, 0, 0; 0, 0, 3, 0, 0]));
+
+%!assert(diag (int8([1, 0, 0; 0, 2, 0; 0, 0, 3])), int8([1; 2; 3]));
+%!assert(diag (int8([0, 1, 0, 0; 0, 0, 2, 0; 0, 0, 0, 3; 0, 0, 0, 0]), 1), int8([1; 2; 3]));
+%!assert(diag (int8([0, 0, 0, 0; 1, 0, 0, 0; 0, 2, 0, 0; 0, 0, 3, 0]), -1), int8([1; 2; 3]));
+
+%!error <Invalid call to diag.*> diag ();
+%!error <Invalid call to diag.*> diag (1, 2, 3);
+
+ */
+
 DEFUN (prod, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} prod (@var{x}, @var{dim})\n\
 Product of elements along dimension @var{dim}.  If @var{dim} is\n\
 omitted, it defaults to 1 (column-wise products).\n\
 \n\
 As a special case, if @var{x} is a vector and @var{dim} is omitted,\n\
 return the product of the elements.\n\
@@ -1562,75 +1645,60 @@ do_cat (const octave_value_list& args, s
 	  // slower than the do_cat_op function, so it makes sense to have an
 	  // empty matrix and copy all data.
 	  //
 	  // We might also start with a empty octave_value using
 	  //   tmp = octave_value_typeinfo::lookup_type (args(1).type_name());
 	  // and then directly resize. However, for some types there might be
 	  // some additional setup needed, and so this should be avoided.
 
-	  octave_value tmp;
-
-	  int i;
-          for (i = 1; i < n_args; i++)
+	  octave_value tmp = args (1);
+	  tmp = tmp.resize (dim_vector (0,0)).resize (dv);
+
+	  if (error_state)
+	    return retval;
+
+	  int dv_len = dv.length ();
+	  Array<octave_idx_type> ra_idx (dv_len, 0);
+
+	  for (int j = 1; j < n_args; j++)
 	    {
-	      if (! args (i).all_zero_dims ())
-		{
-		  tmp = args (i);
-		  break;
-		}
-	    }
-
-	  if (i == n_args)
-	    retval = Matrix ();
-	  else
-	    {
-	      tmp = tmp.resize (dim_vector (0,0)).resize (dv);
+	      // Can't fast return here to skip empty matrices as something
+	      // like cat(1,[],single([])) must return an empty matrix of
+	      // the right type.
+	      tmp = do_cat_op (tmp, args (j), ra_idx);
 
 	      if (error_state)
 		return retval;
 
-	      int dv_len = dv.length ();
-	      Array<octave_idx_type> ra_idx (dv_len, 0);
-
-	      for (int j = i; j < n_args; j++)
+	      dim_vector dv_tmp = args (j).dims ();
+
+	      if (dim >= dv_len)
 		{
-		  if (args (j). dims (). any_zero ())
-		    continue;
-
-		  tmp = do_cat_op (tmp, args (j), ra_idx);
-
-		  if (error_state)
-		    return retval;
-
-		  dim_vector dv_tmp = args (j).dims ();
-
-		  if (dim >= dv_len)
-		    {
-		      if (j > i)
-			error ("%s: indexing error", fname.c_str ());
-		      break;
-		    }
-		  else
-		    ra_idx (dim) += (dim < dv_tmp.length () ? 
-				     dv_tmp (dim) : 1);
+		  if (j > 1)
+		    error ("%s: indexing error", fname.c_str ());
+		  break;
 		}
-
-	      retval = tmp;
+	      else
+		ra_idx (dim) += (dim < dv_tmp.length () ? 
+				 dv_tmp (dim) : 1);
 	    }
+
+	  retval = tmp;
 	}
       else
 	error ("%s: invalid dimension argument", fname.c_str ());
     }
   else
     print_usage ();
  
   return retval;
 }
 
+
 DEFUN (horzcat, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} horzcat (@var{array1}, @var{array2}, @dots{}, @var{arrayN})\n\
 Return the horizontal concatenation of N-d array objects, @var{array1},\n\
 @var{array2}, @dots{}, @var{arrayN} along dimension 2.\n\
 @seealso{cat, vertcat}\n\
 @end deftypefn")
 {
@@ -1710,16 +1778,145 @@ cat (4, ones(2, 2), zeros (2, 2))\n\
 @end group\n\
 @end example\n\
 @seealso{horzcat, vertcat}\n\
 @end deftypefn")
 {
   return do_cat (args, "cat");
 }
 
+/*
+
+%!function ret = testcat (t1, t2, tr, cmplx)
+%! assert (cat (1, cast ([], t1), cast([], t2)), cast ([], tr));
+%!
+%! assert (cat (1, cast (1, t1), cast (2, t2)), cast ([1; 2], tr));
+%! assert (cat (1, cast (1, t1), cast ([2; 3], t2)), cast ([1; 2; 3], tr));
+%! assert (cat (1, cast ([1; 2], t1), cast (3, t2)), cast ([1; 2; 3], tr));
+%! assert (cat (1, cast ([1; 2], t1), cast ([3; 4], t2)), cast ([1; 2; 3; 4], tr));
+%! assert (cat (2, cast (1, t1), cast (2, t2)), cast ([1, 2], tr));
+%! assert (cat (2, cast (1, t1), cast ([2, 3], t2)), cast ([1, 2, 3], tr));
+%! assert (cat (2, cast ([1, 2], t1), cast (3, t2)), cast ([1, 2, 3], tr));
+%! assert (cat (2, cast ([1, 2], t1), cast ([3, 4], t2)), cast ([1, 2, 3, 4], tr));
+%! 
+%! assert ([cast(1, t1); cast(2, t2)], cast ([1; 2], tr));
+%! assert ([cast(1, t1); cast([2; 3], t2)], cast ([1; 2; 3], tr));
+%! assert ([cast([1; 2], t1); cast(3, t2)], cast ([1; 2; 3], tr));
+%! assert ([cast([1; 2], t1); cast([3; 4], t2)], cast ([1; 2; 3; 4], tr));
+%! assert ([cast(1, t1), cast(2, t2)], cast ([1, 2], tr));
+%! assert ([cast(1, t1), cast([2, 3], t2)], cast ([1, 2, 3], tr));
+%! assert ([cast([1, 2], t1), cast(3, t2)], cast ([1, 2, 3], tr));
+%! assert ([cast([1, 2], t1), cast([3, 4], t2)], cast ([1, 2, 3, 4], tr));
+%!
+%! if (nargin == 3 || cmplx)
+%!   assert (cat (1, cast (1i, t1), cast (2, t2)), cast ([1i; 2], tr));
+%!   assert (cat (1, cast (1i, t1), cast ([2; 3], t2)), cast ([1i; 2; 3], tr));
+%!   assert (cat (1, cast ([1i; 2], t1), cast (3, t2)), cast ([1i; 2; 3], tr));
+%!   assert (cat (1, cast ([1i; 2], t1), cast ([3; 4], t2)), cast ([1i; 2; 3; 4], tr));
+%!   assert (cat (2, cast (1i, t1), cast (2, t2)), cast ([1i, 2], tr));
+%!   assert (cat (2, cast (1i, t1), cast ([2, 3], t2)), cast ([1i, 2, 3], tr));
+%!   assert (cat (2, cast ([1i, 2], t1), cast (3, t2)), cast ([1i, 2, 3], tr));
+%!   assert (cat (2, cast ([1i, 2], t1), cast ([3, 4], t2)), cast ([1i, 2, 3, 4], tr));
+%! 
+%!   assert ([cast(1i, t1); cast(2, t2)], cast ([1i; 2], tr));
+%!   assert ([cast(1i, t1); cast([2; 3], t2)], cast ([1i; 2; 3], tr));
+%!   assert ([cast([1i; 2], t1); cast(3, t2)], cast ([1i; 2; 3], tr));
+%!   assert ([cast([1i; 2], t1); cast([3; 4], t2)], cast ([1i; 2; 3; 4], tr));
+%!   assert ([cast(1i, t1), cast(2, t2)], cast ([1i, 2], tr));
+%!   assert ([cast(1i, t1), cast([2, 3], t2)], cast ([1i, 2, 3], tr));
+%!   assert ([cast([1i, 2], t1), cast(3, t2)], cast ([1i, 2, 3], tr));
+%!   assert ([cast([1i, 2], t1), cast([3, 4], t2)], cast ([1i, 2, 3, 4], tr));
+%!
+%!   assert (cat (1, cast (1, t1), cast (2i, t2)), cast ([1; 2i], tr));
+%!   assert (cat (1, cast (1, t1), cast ([2i; 3], t2)), cast ([1; 2i; 3], tr));
+%!   assert (cat (1, cast ([1; 2], t1), cast (3i, t2)), cast ([1; 2; 3i], tr));
+%!   assert (cat (1, cast ([1; 2], t1), cast ([3i; 4], t2)), cast ([1; 2; 3i; 4], tr));
+%!   assert (cat (2, cast (1, t1), cast (2i, t2)), cast ([1, 2i], tr));
+%!   assert (cat (2, cast (1, t1), cast ([2i, 3], t2)), cast ([1, 2i, 3], tr));
+%!   assert (cat (2, cast ([1, 2], t1), cast (3i, t2)), cast ([1, 2, 3i], tr));
+%!   assert (cat (2, cast ([1, 2], t1), cast ([3i, 4], t2)), cast ([1, 2, 3i, 4], tr));
+%! 
+%!   assert ([cast(1, t1); cast(2i, t2)], cast ([1; 2i], tr));
+%!   assert ([cast(1, t1); cast([2i; 3], t2)], cast ([1; 2i; 3], tr));
+%!   assert ([cast([1; 2], t1); cast(3i, t2)], cast ([1; 2; 3i], tr));
+%!   assert ([cast([1; 2], t1); cast([3i; 4], t2)], cast ([1; 2; 3i; 4], tr));
+%!   assert ([cast(1, t1), cast(2i, t2)], cast ([1, 2i], tr));
+%!   assert ([cast(1, t1), cast([2i, 3], t2)], cast ([1, 2i, 3], tr));
+%!   assert ([cast([1, 2], t1), cast(3i, t2)], cast ([1, 2, 3i], tr));
+%!   assert ([cast([1, 2], t1), cast([3i, 4], t2)], cast ([1, 2, 3i, 4], tr));
+%!
+%!   assert (cat (1, cast (1i, t1), cast (2i, t2)), cast ([1i; 2i], tr));
+%!   assert (cat (1, cast (1i, t1), cast ([2i; 3], t2)), cast ([1i; 2i; 3], tr));
+%!   assert (cat (1, cast ([1i; 2], t1), cast (3i, t2)), cast ([1i; 2; 3i], tr));
+%!   assert (cat (1, cast ([1i; 2], t1), cast ([3i; 4], t2)), cast ([1i; 2; 3i; 4], tr));
+%!   assert (cat (2, cast (1i, t1), cast (2i, t2)), cast ([1i, 2i], tr));
+%!   assert (cat (2, cast (1i, t1), cast ([2i, 3], t2)), cast ([1i, 2i, 3], tr));
+%!   assert (cat (2, cast ([1i, 2], t1), cast (3i, t2)), cast ([1i, 2, 3i], tr));
+%!   assert (cat (2, cast ([1i, 2], t1), cast ([3i, 4], t2)), cast ([1i, 2, 3i, 4], tr));
+%! 
+%!   assert ([cast(1i, t1); cast(2i, t2)], cast ([1i; 2i], tr));
+%!   assert ([cast(1i, t1); cast([2i; 3], t2)], cast ([1i; 2i; 3], tr));
+%!   assert ([cast([1i; 2], t1); cast(3i, t2)], cast ([1i; 2; 3i], tr));
+%!   assert ([cast([1i; 2], t1); cast([3i; 4], t2)], cast ([1i; 2; 3i; 4], tr));
+%!   assert ([cast(1i, t1), cast(2i, t2)], cast ([1i, 2i], tr));
+%!   assert ([cast(1i, t1), cast([2i, 3], t2)], cast ([1i, 2i, 3], tr));
+%!   assert ([cast([1i, 2], t1), cast(3i, t2)], cast ([1i, 2, 3i], tr));
+%!   assert ([cast([1i, 2], t1), cast([3i, 4], t2)], cast ([1i, 2, 3i, 4], tr));
+%! endif
+%! ret = true;
+
+%!assert (testcat('double', 'double', 'double'));
+%!assert (testcat('single', 'double', 'single'));
+%!assert (testcat('double', 'single', 'single'));
+%!assert (testcat('single', 'single', 'single'));
+
+%!assert (testcat('double', 'int8', 'int8', false));
+%!assert (testcat('int8', 'double', 'int8', false));
+%!assert (testcat('single', 'int8', 'int8', false));
+%!assert (testcat('int8', 'single', 'int8', false));
+%!assert (testcat('int8', 'int8', 'int8', false));
+%!assert (testcat('double', 'int16', 'int16', false));
+%!assert (testcat('int16', 'double', 'int16', false));
+%!assert (testcat('single', 'int16', 'int16', false));
+%!assert (testcat('int16', 'single', 'int16', false));
+%!assert (testcat('int16', 'int16', 'int16', false));
+%!assert (testcat('double', 'int32', 'int32', false));
+%!assert (testcat('int32', 'double', 'int32', false));
+%!assert (testcat('single', 'int32', 'int32', false));
+%!assert (testcat('int32', 'single', 'int32', false));
+%!assert (testcat('int32', 'int32', 'int32', false));
+%!assert (testcat('double', 'int64', 'int64', false));
+%!assert (testcat('int64', 'double', 'int64', false));
+%!assert (testcat('single', 'int64', 'int64', false));
+%!assert (testcat('int64', 'single', 'int64', false));
+%!assert (testcat('int64', 'int64', 'int64', false));
+
+%!assert (testcat('double', 'uint8', 'uint8', false));
+%!assert (testcat('uint8', 'double', 'uint8', false));
+%!assert (testcat('single', 'uint8', 'uint8', false));
+%!assert (testcat('uint8', 'single', 'uint8', false));
+%!assert (testcat('uint8', 'uint8', 'uint8', false));
+%!assert (testcat('double', 'uint16', 'uint16', false));
+%!assert (testcat('uint16', 'double', 'uint16', false));
+%!assert (testcat('single', 'uint16', 'uint16', false));
+%!assert (testcat('uint16', 'single', 'uint16', false));
+%!assert (testcat('uint16', 'uint16', 'uint16', false));
+%!assert (testcat('double', 'uint32', 'uint32', false));
+%!assert (testcat('uint32', 'double', 'uint32', false));
+%!assert (testcat('single', 'uint32', 'uint32', false));
+%!assert (testcat('uint32', 'single', 'uint32', false));
+%!assert (testcat('uint32', 'uint32', 'uint32', false));
+%!assert (testcat('double', 'uint64', 'uint64', false));
+%!assert (testcat('uint64', 'double', 'uint64', false));
+%!assert (testcat('single', 'uint64', 'uint64', false));
+%!assert (testcat('uint64', 'single', 'uint64', false));
+%!assert (testcat('uint64', 'uint64', 'uint64', false));
+
+*/
+
 static octave_value
 do_permute (const octave_value_list& args, bool inv)
 {
   octave_value retval;
 
   if (args.length () == 2 && args(1).length () >= args(1).ndims ())
     {
       Array<int> vec = args(1).int_vector_value ();
@@ -2536,16 +2733,45 @@ Return 1 if @var{a} is a matrix.  Otherw
 	retval = (arg.rows () >= 1 && arg.columns () >= 1);
     }
   else
     print_usage ();
 
   return retval;
 }
 
+/*
+
+%!assert(ismatrix (1));
+%!assert(ismatrix ([1, 2, 3]));
+%!assert(ismatrix ([1, 2; 3, 4]));
+
+%% Yes, this is right, ismatrix() checks for non-empty matrices.
+%!assert(ismatrix ([]), false);
+
+%!assert(ismatrix (single(1)));
+%!assert(ismatrix (single([1, 2, 3])));
+%!assert(ismatrix (single([1, 2; 3, 4])));
+
+%% Yes, this is right, ismatrix() checks for non-empty matrices.
+%!assert(ismatrix (single([])), false);
+
+%!assert(ismatrix ("t"), false);
+%!assert(ismatrix ("test"), false);
+%!assert(ismatrix (["test"; "ing"]), false);
+
+%!test
+%! s.a = 1;
+%! assert(ismatrix (s), false);
+
+%!error <Invalid call to ismatrix.*> ismatrix ();
+%!error <Invalid call to ismatrix.*> ismatrix ([1, 2; 3, 4], 2);
+
+ */
+
 static octave_value
 fill_matrix (const octave_value_list& args, int val, const char *fcn)
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   oct_data_conv::data_type dt = oct_data_conv::dt_double;
@@ -2977,16 +3203,35 @@ the specified type, for example\n\
 @example\n\
 val = ones (n,m, \"uint8\")\n\
 @end example\n\
 @end deftypefn")
 {
   return fill_matrix (args, 1, "ones");
 }
 
+/*
+
+%!assert(ones (3), [1, 1, 1; 1, 1, 1; 1, 1, 1]);
+%!assert(ones (2, 3), [1, 1, 1; 1, 1, 1]);
+%!assert(ones (3, 2), [1, 1; 1, 1; 1, 1]);
+%!assert(size (ones (3, 4, 5)),  [3, 4, 5]);
+
+%!assert(ones (3,'single'), single([1, 1, 1; 1, 1, 1; 1, 1, 1]));
+%!assert(ones (2, 3,'single'), single([1, 1, 1; 1, 1, 1]));
+%!assert(ones (3, 2,'single'), single([1, 1; 1, 1; 1, 1]));
+%!assert(size (ones (3, 4, 5, 'single')),  [3, 4, 5]);
+
+%!assert(ones (3,'int8'), int8([1, 1, 1; 1, 1, 1; 1, 1, 1]));
+%!assert(ones (2, 3,'int8'), int8([1, 1, 1; 1, 1, 1]));
+%!assert(ones (3, 2,'int8'), int8([1, 1; 1, 1; 1, 1]));
+%!assert(size (ones (3, 4, 5, 'int8')),  [3, 4, 5]);
+
+ */
+
 DEFUN (zeros, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} zeros (@var{x})\n\
 @deftypefnx {Built-in Function} {} zeros (@var{n}, @var{m})\n\
 @deftypefnx {Built-in Function} {} zeros (@var{n}, @var{m}, @var{k}, @dots{})\n\
 @deftypefnx {Built-in Function} {} zeros (@dots{}, @var{class})\n\
 Return a matrix or N-dimensional array whose elements are all 0.\n\
 The arguments are handled the same as the arguments for @code{eye}.\n\
@@ -2997,16 +3242,35 @@ the specified type, for example\n\
 @example\n\
 val = zeros (n,m, \"uint8\")\n\
 @end example\n\
 @end deftypefn")
 {
   return fill_matrix (args, 0, "zeros");
 }
 
+/*
+
+%!assert(zeros (3), [0, 0, 0; 0, 0, 0; 0, 0, 0]);
+%!assert(zeros (2, 3), [0, 0, 0; 0, 0, 0]);
+%!assert(zeros (3, 2), [0, 0; 0, 0; 0, 0]);
+%!assert(size (zeros (3, 4, 5)),  [3, 4, 5]);
+
+%!assert(zeros (3,'single'), single([0, 0, 0; 0, 0, 0; 0, 0, 0]));
+%!assert(zeros (2, 3,'single'), single([0, 0, 0; 0, 0, 0]));
+%!assert(zeros (3, 2,'single'), single([0, 0; 0, 0; 0, 0]));
+%!assert(size (zeros (3, 4, 5, 'single')),  [3, 4, 5]);
+
+%!assert(zeros (3,'int8'), int8([0, 0, 0; 0, 0, 0; 0, 0, 0]));
+%!assert(zeros (2, 3,'int8'), int8([0, 0, 0; 0, 0, 0]));
+%!assert(zeros (3, 2,'int8'), int8([0, 0; 0, 0; 0, 0]));
+%!assert(size (zeros (3, 4, 5, 'int8')),  [3, 4, 5]);
+
+ */
+
 DEFUN (Inf, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} Inf (@var{x})\n\
 @deftypefnx {Built-in Function} {} Inf (@var{n}, @var{m})\n\
 @deftypefnx {Built-in Function} {} Inf (@var{n}, @var{m}, @var{k}, @dots{})\n\
 @deftypefnx {Built-in Function} {} Inf (@dots{}, @var{class})\n\
 Return a matrix or N-dimensional array whose elements are all Infinity.\n\
 The arguments are handled the same as the arguments for @code{eye}.\n\
@@ -3015,16 +3279,35 @@ The optional argument @var{class} may be
 @end deftypefn")
 {
   return fill_matrix (args, lo_ieee_inf_value (), 
 		      lo_ieee_float_inf_value (), "Inf");
 }
 
 DEFALIAS (inf, Inf);
 
+/*
+
+%!assert(inf (3), [Inf, Inf, Inf; Inf, Inf, Inf; Inf, Inf, Inf]);
+%!assert(inf (2, 3), [Inf, Inf, Inf; Inf, Inf, Inf]);
+%!assert(inf (3, 2), [Inf, Inf; Inf, Inf; Inf, Inf]);
+%!assert(size (inf (3, 4, 5)),  [3, 4, 5]);
+
+%!assert(inf (3,'single'), single([Inf, Inf, Inf; Inf, Inf, Inf; Inf, Inf, Inf]));
+%!assert(inf (2, 3,'single'), single([Inf, Inf, Inf; Inf, Inf, Inf]));
+%!assert(inf (3, 2,'single'), single([Inf, Inf; Inf, Inf; Inf, Inf]));
+%!assert(size (inf (3, 4, 5, 'single')),  [3, 4, 5]);
+
+%!error(inf (3,'int8'));
+%!error(inf (2, 3,'int8'));
+%!error(inf (3, 2,'int8'));
+%!error(inf (3, 4, 5, 'int8'));
+
+ */
+
 DEFUN (NaN, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} NaN (@var{x})\n\
 @deftypefnx {Built-in Function} {} NaN (@var{n}, @var{m})\n\
 @deftypefnx {Built-in Function} {} NaN (@var{n}, @var{m}, @var{k}, @dots{})\n\
 @deftypefnx {Built-in Function} {} NaN (@dots{}, @var{class})\n\
 Return a matrix or N-dimensional array whose elements are all NaN\n\
 (Not a Number).  The value NaN is the result of an operation like\n\
@@ -3048,16 +3331,34 @@ The optional argument @var{class} may be
 @end deftypefn")
 {
   return fill_matrix (args, lo_ieee_nan_value (), 
 		      lo_ieee_float_nan_value (), "NaN");
 }
 
 DEFALIAS (nan, NaN);
 
+/* 
+%!assert(NaN (3), [NaN, NaN, NaN; NaN, NaN, NaN; NaN, NaN, NaN]);
+%!assert(NaN (2, 3), [NaN, NaN, NaN; NaN, NaN, NaN]);
+%!assert(NaN (3, 2), [NaN, NaN; NaN, NaN; NaN, NaN]);
+%!assert(size (NaN (3, 4, 5)),  [3, 4, 5]);
+
+%!assert(NaN (3,'single'), single([NaN, NaN, NaN; NaN, NaN, NaN; NaN, NaN, NaN]));
+%!assert(NaN (2, 3,'single'), single([NaN, NaN, NaN; NaN, NaN, NaN]));
+%!assert(NaN (3, 2,'single'), single([NaN, NaN; NaN, NaN; NaN, NaN]));
+%!assert(size (NaN (3, 4, 5, 'single')),  [3, 4, 5]);
+
+%!error(NaN (3,'int8'));
+%!error(NaN (2, 3,'int8'));
+%!error(NaN (3, 2,'int8'));
+%!error(NaN (3, 4, 5, 'int8'));
+
+ */
+
 DEFUN (e, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} e (@var{x})\n\
 @deftypefnx {Built-in Function} {} e (@var{n}, @var{m})\n\
 @deftypefnx {Built-in Function} {} e (@var{n}, @var{m}, @var{k}, @dots{})\n\
 @deftypefnx {Built-in Function} {} e (@dots{}, @var{class})\n\
 Return a matrix or N-dimensional array whose elements are all equal\n\
 to the base of natural logarithms.  The constant\n\
@@ -3549,16 +3850,32 @@ with @sc{Matlab}.\n\
     default:
       print_usage ();
       break;
     }
 
   return retval;
 }
 
+
+/*
+
+%!assert (eye(3), [1, 0, 0; 0, 1, 0; 0, 0, 1]);
+%!assert (eye(2, 3), [1, 0, 0; 0, 1, 0]);
+
+%!assert (eye(3,'single'), single([1, 0, 0; 0, 1, 0; 0, 0, 1]));
+%!assert (eye(2, 3,'single'), single([1, 0, 0; 0, 1, 0]));
+
+%!assert (eye(3,'int8'), int8([1, 0, 0; 0, 1, 0; 0, 0, 1]));
+%!assert (eye(2, 3,'int8'), int8([1, 0, 0; 0, 1, 0]));
+
+%!error <Invalid call to eye.*> eye (1, 2, 3);
+
+ */
+
 DEFUN (linspace, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} linspace (@var{base}, @var{limit}, @var{n})\n\
 Return a row vector with @var{n} linearly spaced elements between\n\
 @var{base} and @var{limit}.  If the number of elements is greater than one,\n\
 then the @var{base} and @var{limit} are always included in\n\
 the range.  If @var{base} is greater than @var{limit}, the elements are\n\
 stored in decreasing order.  If the number of points is not specified, a\n\
@@ -3650,16 +3967,38 @@ fewer than two values are requested.\n\
 	}
     }
   else
     error ("linspace: expecting third argument to be an integer");
 
   return retval;
 }
 
+
+/*
+
+%!test
+%! x1 = linspace (1, 2);
+%! x2 = linspace (1, 2, 10);
+%! x3 = linspace (1, -2, 10);
+%! assert((size (x1) == [1, 100] && x1(1) == 1 && x1(100) == 2
+%! && size (x2) == [1, 10] && x2(1) == 1 && x2(10) == 2
+%! && size (x3) == [1, 10] && x3(1) == 1 && x3(10) == -2));
+
+
+% assert(linspace ([1, 2; 3, 4], 5, 6), linspace (1, 5, 6));
+
+%!error <Invalid call to linspace.*> linspace ();
+%!error <Invalid call to linspace.*> linspace (1, 2, 3, 4);
+
+%!test
+%! fail("linspace ([1, 2; 3, 4], 5, 6)","warning");
+
+*/
+
 // FIXME -- should accept dimensions as separate args for N-d
 // arrays as well as 1-d and 2-d arrays.
 
 DEFUN (resize, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} resize (@var{x}, @var{m})\n\
 @deftypefnx {Built-in Function} {} resize (@var{x}, @var{m}, @var{n})\n\
 Destructively resize @var{x}.\n\
@@ -3842,16 +4181,37 @@ by an empty argument.\n\
   if (new_dims.numel () == arg.numel ())
     retval = (new_dims == arg.dims ()) ? arg : arg.reshape (new_dims);
   else
     error ("reshape: size mismatch");
 
   return retval;
 }
 
+/*
+
+%!assert(size (reshape (ones (4, 4), 2, 8)), [2, 8])
+%!assert(size (reshape (ones (4, 4), 8, 2)), [8, 2])
+%!assert(size (reshape (ones (15, 4), 1, 60)), [1, 60])
+%!assert(size (reshape (ones (15, 4), 60, 1)), [60, 1])
+
+%!assert(size (reshape (ones (4, 4, 'single'), 2, 8)), [2, 8])
+%!assert(size (reshape (ones (4, 4, 'single'), 8, 2)), [8, 2])
+%!assert(size (reshape (ones (15, 4, 'single'), 1, 60)), [1, 60])
+%!assert(size (reshape (ones (15, 4, 'single'), 60, 1)), [60, 1])
+
+%!test
+%! s.a = 1;
+%! fail("reshape (s, 2, 3)");
+
+%!error <Invalid call to reshape.*> reshape ();
+%!error reshape (1, 2, 3, 4);
+
+ */
+
 DEFUN (squeeze, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} squeeze (@var{x})\n\
 Remove singleton dimensions from @var{x} and return the result.\n\
 Note that for compatibility with @sc{Matlab}, all objects have\n\
 a minimum of two dimensions and row vectors are left unchanged.\n\
 @end deftypefn")
 {
@@ -3860,43 +4220,16 @@ a minimum of two dimensions and row vect
   if (args.length () == 1)
     retval = args(0).squeeze ();
   else
     print_usage ();    
 
   return retval;
 }
 
-/*
-%!shared x
-%! x = [1, -3, 4, 5, -7];
-%!assert(norm(x,1), 20);
-%!assert(norm(x,2), 10);
-%!assert(norm(x,3), 8.24257059961711, -4*eps);
-%!assert(norm(x,Inf), 7);
-%!assert(norm(x,-Inf), 1);
-%!assert(norm(x,"inf"), 7);
-%!assert(norm(x,"fro"), 10, -eps);
-%!assert(norm(x), 10);
-%!assert(norm([1e200, 1]), 1e200);
-%!assert(norm([3+4i, 3-4i, sqrt(31)]), 9, -4*eps);
-%!shared m
-%! m = magic (4);
-%!assert(norm(m,1), 34);
-%!assert(norm(m,2), 34, -eps);
-%!assert(norm(m,Inf), 34);
-%!assert(norm(m,"inf"), 34);
-%!shared m2, flo, fhi
-%! m2 = [1,2;3,4];
-%! flo = 1e-300;
-%! fhi = 1e+300;
-%!assert (norm(flo*m2,"fro"), sqrt(30)*flo, -eps)
-%!assert (norm(fhi*m2,"fro"), sqrt(30)*fhi, -eps)
-*/
-
 // Compute various norms of the vector X.
 
 DEFUN (norm, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Function File} {} norm (@var{a}, @var{p})\n\
 Compute the p-norm of the matrix @var{a}.  If the second argument is\n\
 missing, @code{p = 2} is assumed.\n\
 \n\
@@ -3943,17 +4276,22 @@ p-norm of @var{a}, @code{(sum (abs (@var
 
   int nargin = args.length ();
 
   if (nargin == 1 || nargin == 2)
     {
       octave_value x_arg = args(0);
 
       if (x_arg.is_empty ())
-	retval(0) = 0.0;
+	{
+	  if (x_arg.is_single_type ())
+	    retval(0) = static_cast<float>(0.0);
+	  else
+	    retval(0) = 0.0;
+	}
       else if (x_arg.ndims () == 2)
 	{
 	  if ((x_arg.rows () == 1 || x_arg.columns () == 1)
 	      && ! (x_arg.is_sparse_type () || x_arg.is_integer_type ()))
 	    {
 	      double p_val = 2;
 
 	      if (nargin == 2)
@@ -3975,35 +4313,62 @@ p-norm of @var{a}, @code{(sum (abs (@var
 		    {
 		      p_val = p_arg.double_value ();
 
 		      if (error_state)
 			error ("norm: unrecognized norm value");
 		    }
 		}
 
-	      if (! error_state)
+	      if (x_arg.is_single_type ())
 		{
-		  if (x_arg.is_real_type ())
+		  if (! error_state)
 		    {
-		      MArray<double> x (x_arg.array_value ());
-
-		      if (! error_state)
-			retval(0) = x.norm (p_val);
+		      if (x_arg.is_real_type ())
+			{
+			  MArray<float> x (x_arg.float_array_value ());
+
+			  if (! error_state)
+			    retval(0) = x.norm (static_cast<float>(p_val));
+			  else
+			    error ("norm: expecting real vector");
+			}
 		      else
-			error ("norm: expecting real vector");
+			{
+			  MArray<FloatComplex> x (x_arg.float_complex_array_value ());
+
+			  if (! error_state)
+			    retval(0) = x.norm (static_cast<float>(p_val));
+			  else
+			    error ("norm: expecting complex vector");
+			}
 		    }
-		  else
+		}
+	      else
+		{
+		  if (! error_state)
 		    {
-		      MArray<Complex> x (x_arg.complex_array_value ());
-
-		      if (! error_state)
-			retval(0) = x.norm (p_val);
+		      if (x_arg.is_real_type ())
+			{
+			  MArray<double> x (x_arg.array_value ());
+
+			  if (! error_state)
+			    retval(0) = x.norm (p_val);
+			  else
+			    error ("norm: expecting real vector");
+			}
 		      else
-			error ("norm: expecting complex vector");
+			{
+			  MArray<Complex> x (x_arg.complex_array_value ());
+
+			  if (! error_state)
+			    retval(0) = x.norm (p_val);
+			  else
+			    error ("norm: expecting complex vector");
+			}
 		    }
 		}
 	    }
 	  else
 	    retval = feval ("__norm__", args);
 	}
       else
 	error ("norm: only valid for 2-D objects");
@@ -4020,16 +4385,68 @@ p-norm of @var{a}, @code{(sum (abs (@var
 	retval(0) = retval(0).complex_matrix_value ();
       else if (retval(0).type_name () == "sparse bool matrix")
 	retval(0) = retval(0).bool_matrix_value ();
     }
 
   return retval;
 }
 
+/*
+%!shared x
+%! x = [1, -3, 4, 5, -7];
+%!assert(norm(x,1), 20);
+%!assert(norm(x,2), 10);
+%!assert(norm(x,3), 8.24257059961711, -4*eps);
+%!assert(norm(x,Inf), 7);
+%!assert(norm(x,-Inf), 1);
+%!assert(norm(x,"inf"), 7);
+%!assert(norm(x,"fro"), 10, -eps);
+%!assert(norm(x), 10);
+%!assert(norm([1e200, 1]), 1e200);
+%!assert(norm([3+4i, 3-4i, sqrt(31)]), 9, -4*eps);
+%!shared m
+%! m = magic (4);
+%!assert(norm(m,1), 34);
+%!assert(norm(m,2), 34, -eps);
+%!assert(norm(m,Inf), 34);
+%!assert(norm(m,"inf"), 34);
+%!shared m2, flo, fhi
+%! m2 = [1,2;3,4];
+%! flo = 1e-300;
+%! fhi = 1e+300;
+%!assert (norm(flo*m2,"fro"), sqrt(30)*flo, -eps)
+%!assert (norm(fhi*m2,"fro"), sqrt(30)*fhi, -eps)
+
+%!shared x
+%! x = single([1, -3, 4, 5, -7]);
+%!assert(norm(x,1), single(20));
+%!assert(norm(x,2), single(10));
+%!assert(norm(x,3), single(8.24257059961711), -4*eps('single'));
+%!assert(norm(x,Inf), single(7));
+%!assert(norm(x,-Inf), single(1));
+%!assert(norm(x,"inf"), single(7));
+%!assert(norm(x,"fro"), single(10), -eps('single'));
+%!assert(norm(x), single(10));
+%!assert(norm(single([1e200, 1])), single(1e200));
+%!assert(norm(single([3+4i, 3-4i, sqrt(31)])), single(9), -4*eps('single'));
+%!shared m
+%! m = single(magic (4));
+%!assert(norm(m,1), single(34));
+%!assert(norm(m,2), single(34), -eps('single'));
+%!assert(norm(m,Inf), single(34));
+%!assert(norm(m,"inf"), single(34));
+%!shared m2, flo, fhi
+%! m2 = single([1,2;3,4]);
+%! flo = single(1e-300);
+%! fhi = single(1e+300);
+%!assert (norm(flo*m2,"fro"), single(sqrt(30)*flo), -eps('single'))
+%!assert (norm(fhi*m2,"fro"), single(sqrt(30)*fhi), -eps('single'))
+*/
+
 #define UNARY_OP_DEFUN_BODY(F) \
  \
   octave_value retval; \
  \
   if (args.length () == 1) \
     retval = F (args(0)); \
   else \
     print_usage (); \
@@ -4067,25 +4484,69 @@ DEFUN (transpose, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} transpose (@var{x})\n\
 This function is equivalent to @code{x.'}.\n\
 @end deftypefn")
 {
   UNARY_OP_DEFUN_BODY (op_transpose);
 }
 
+/*
+
+%!assert (2.', 2);
+%!assert (2i.',2i);
+%!assert ([1:4].',[1;2;3;4]);
+%!assert ([1;2;3;4].',[1:4]);
+%!assert ([1,2;3,4].',[1,3;2,4]);
+%!assert ([1,2i;3,4].',[1,3;2i,4]);
+
+%!assert (transpose ([1,2;3,4]),[1,3;2,4]);
+
+%!assert (single(2).', single(2));
+%!assert (single(2i).',single(2i));
+%!assert (single([1:4]).',single([1;2;3;4]));
+%!assert (single([1;2;3;4]).',single([1:4]));
+%!assert (single([1,2;3,4]).',single([1,3;2,4]));
+%!assert (single([1,2i;3,4]).',single([1,3;2i,4]));
+
+%!assert (transpose (single([1,2;3,4])),single([1,3;2,4]));
+
+*/
+
 DEFUN (ctranspose, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} ctranspose (@var{x})\n\
 This function is equivalent to @code{x'}.\n\
 @end deftypefn")
 {
   UNARY_OP_DEFUN_BODY (op_hermitian);
 }
 
+/*
+
+%!assert (2', 2);
+%!assert (2i',-2i);
+%!assert ([1:4]',[1;2;3;4]);
+%!assert ([1;2;3;4]',[1:4]);
+%!assert ([1,2;3,4]',[1,3;2,4]);
+%!assert ([1,2i;3,4]',[1,3;-2i,4]);
+
+%!assert (ctranspose ([1,2i;3,4]),[1,3;-2i,4]);
+
+%!assert (single(2)', single(2));
+%!assert (single(2i)',single(-2i));
+%!assert (single([1:4])',single([1;2;3;4]));
+%!assert (single([1;2;3;4])',single([1:4]));
+%!assert (single([1,2;3,4])',single([1,3;2,4]));
+%!assert (single([1,2i;3,4])',single([1,3;-2i,4]));
+
+%!assert (ctranspose (single([1,2i;3,4])),single([1,3;-2i,4]));
+
+*/
+
 #define BINARY_OP_DEFUN_BODY(F) \
  \
   octave_value retval; \
  \
   if (args.length () == 2) \
     retval = F (args(0), args(1)); \
   else \
     print_usage (); \
@@ -4633,16 +5094,54 @@ ordered lists.\n\
 %!assert (sort ([3, 1i, 7, 5; 8, 2, 6, 4], 2), [1i, 3, 5, 7; 2, 4, 6, 8])
 %!assert (sort (1i), 1i)
 
 %!test
 %! [v, i] = sort ([NaN, 1i, -1, Inf, 1, 1i]);
 %! assert (v, [1, 1i, 1i, -1, Inf, NaN])
 %! assert (i, [5, 2, 6, 3, 4, 1])
 
+%% Single
+%!assert (sort (single([NaN, 1, -1, 2, Inf])), single([-1, 1, 2, Inf, NaN]))
+%!assert (sort (single([NaN, 1, -1, 2, Inf]), 1), single([NaN, 1, -1, 2, Inf]))
+%!assert (sort (single([NaN, 1, -1, 2, Inf]), 2), single([-1, 1, 2, Inf, NaN]))
+%!error (sort (single([NaN, 1, -1, 2, Inf]), 3))
+%!assert (sort (single([NaN, 1, -1, 2, Inf]), "ascend"), single([-1, 1, 2, Inf, NaN]))
+%!assert (sort (single([NaN, 1, -1, 2, Inf]), 2, "ascend"), single([-1, 1, 2, Inf, NaN]))
+%!assert (sort (single([NaN, 1, -1, 2, Inf]), "descend"), single([NaN, Inf, 2, 1, -1]))
+%!assert (sort (single([NaN, 1, -1, 2, Inf]), 2, "descend"), single([NaN, Inf, 2, 1, -1]))
+%!assert (sort (single([3, 1, 7, 5; 8, 2, 6, 4])), single([3, 1, 6, 4; 8, 2, 7, 5]))
+%!assert (sort (single([3, 1, 7, 5; 8, 2, 6, 4]), 1), single([3, 1, 6, 4; 8, 2, 7, 5]))
+%!assert (sort (single([3, 1, 7, 5; 8, 2, 6, 4]), 2), single([1, 3, 5, 7; 2, 4, 6, 8]))
+%!assert (sort (single(1)), single(1))
+
+%!test
+%! [v, i] = sort (single([NaN, 1, -1, Inf, 1]));
+%! assert (v, single([-1, 1, 1, Inf, NaN]))
+%! assert (i, [3, 2, 5, 4, 1])
+
+%% Single Complex
+%!assert (sort (single([NaN, 1i, -1, 2, Inf])), single([1i, -1, 2, Inf, NaN]))
+%!assert (sort (single([NaN, 1i, -1, 2, Inf]), 1), single([NaN, 1i, -1, 2, Inf]))
+%!assert (sort (single([NaN, 1i, -1, 2, Inf]), 2), single([1i, -1, 2, Inf, NaN]))
+%!error (sort (single([NaN, 1i, -1, 2, Inf]), 3))
+%!assert (sort (single([NaN, 1i, -1, 2, Inf]), "ascend"), single([1i, -1, 2, Inf, NaN]))
+%!assert (sort (single([NaN, 1i, -1, 2, Inf]), 2, "ascend"), single([1i, -1, 2, Inf, NaN]))
+%!assert (sort (single([NaN, 1i, -1, 2, Inf]), "descend"), single([NaN, Inf, 2, -1, 1i]))
+%!assert (sort (single([NaN, 1i, -1, 2, Inf]), 2, "descend"), single([NaN, Inf, 2, -1, 1i]))
+%!assert (sort (single([3, 1i, 7, 5; 8, 2, 6, 4])), single([3, 1i, 6, 4; 8, 2, 7, 5]))
+%!assert (sort (single([3, 1i, 7, 5; 8, 2, 6, 4]), 1), single([3, 1i, 6, 4; 8, 2, 7, 5]))
+%!assert (sort (single([3, 1i, 7, 5; 8, 2, 6, 4]), 2), single([1i, 3, 5, 7; 2, 4, 6, 8]))
+%!assert (sort (single(1i)),single( 1i))
+
+%!test
+%! [v, i] = sort (single([NaN, 1i, -1, Inf, 1, 1i]));
+%! assert (v, single([1, 1i, 1i, -1, Inf, NaN]))
+%! assert (i, [5, 2, 6, 3, 4, 1])
+
 %% Bool
 %!assert (sort ([true, false, true, false]), [false, false, true, true])
 %!assert (sort ([true, false, true, false], 1), [true, false, true, false])
 %!assert (sort ([true, false, true, false], 2), [false, false, true, true])
 %!error (sort ([true, false, true, false], 3))
 %!assert (sort ([true, false, true, false], "ascend"), [false, false, true, true])
 %!assert (sort ([true, false, true, false], 2, "ascend"), [false, false, true, true])
 %!assert (sort ([true, false, true, false], "descend"), [true, true, false, false])
@@ -4727,15 +5226,18 @@ ordered lists.\n\
 %!assert (sort (a, 2, "ascend"), b)
 %!assert (sort (a, "descend"), c)
 %!assert (sort (a, 2, "descend"), c)
 
 %!test
 %! [v, i] = sort (a);
 %! assert (i, [1, 4, 2, 5, 3])
 
+%!error <Invalid call to sort.*> sort ();
+%!error <Invalid call to sort.*> sort (1, 2, 3, 4);
+
 */
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/mappers.cc b/src/mappers.cc
--- a/src/mappers.cc
+++ b/src/mappers.cc
@@ -412,16 +412,28 @@ finite ([13, Inf, NA, NaN])\n\
   if (args.length () == 1)
     retval = args(0).finite ();
   else
     print_usage ();
 
   return retval;
 }
 
+/*
+
+%!assert(!(finite (Inf)));
+%!assert(!(finite (NaN)));
+%!assert(finite (rand(1,10)));
+
+%!assert(!(finite (single(Inf))));
+%!assert(!(finite (single(NaN))));
+%!assert(finite (single(rand(1,10))));
+
+ */
+
 DEFUN (fix, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} fix (@var{x})\n\
 Truncate @var{x} toward zero.  If @var{x} is complex, return\n\
 @code{fix (real (@var{x})) + fix (imag (@var{x})) * I}.\n\
 @end deftypefn")
 {
   octave_value retval;
@@ -603,16 +615,32 @@ isinf ([13, Inf, NA, NaN])\n\
   if (args.length () == 1)
     retval = args(0).isinf ();
   else
     print_usage ();
 
   return retval;
 }
 
+/*
+
+%!assert(isinf (Inf));
+%!assert(!isinf (NaN));
+%!assert(!(isinf (NA)));
+%!assert(isinf (rand(1,10)), false(1,10));
+%!assert(isinf([NaN -Inf -1 0 1 Inf NA]), [false, true, false, false, false, true, false]);
+
+%!assert(isinf (single(Inf)));
+%!assert(!(isinf (single(NaN))));
+%!assert(!(isinf (single(NA))));
+%!assert(isinf (single(rand(1,10))), false(1,10));
+%!assert(isinf(single([NaN -Inf -1 0 1 Inf NA])), [false, true, false, false, false, true, false]);
+
+ */
+
 DEFUNX ("isgraph", Fisgraph, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} isgraph (@var{s})\n\
 Return 1 for printable characters (but not the space character).\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
@@ -656,16 +684,32 @@ isna ([13, Inf, NA, NaN])\n\
   if (args.length () == 1)
     retval = args(0).isna ();
   else
     print_usage ();
 
   return retval;
 }
 
+/*
+
+%!assert(!(isna (Inf)));
+%!assert(!isna (NaN));
+%!assert(isna (NA));
+%!assert(isna (rand(1,10)), false(1,10));
+%!assert(isna([NaN -Inf -1 0 1 Inf NA]), [false, false, false, false, false, false, true]);
+
+%!assert(!(isna (single(Inf))));
+%!assert(!isna (single(NaN)));
+%!assert(isna (single(NA)));
+%!assert(isna (single(rand(1,10))), false(1,10));
+%!assert(isna(single([NaN -Inf -1 0 1 Inf NA])), [false, false, false, false, false, false, true]);
+
+ */
+
 DEFUN (isnan, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} isnan (@var{x})\n\
 Return 1 for elements of @var{x} that are NaN values and zero\n\
 otherwise.  NA values are also considered NaN values.  For example,\n\
 \n\
 @example\n\
 @group\n\
@@ -679,16 +723,32 @@ isnan ([13, Inf, NA, NaN])\n\
   if (args.length () == 1)
     retval = args(0).isnan ();
   else
     print_usage ();
 
   return retval;
 }
 
+/*
+
+%!assert(!(isnan (Inf)));
+%!assert(isnan (NaN));
+%!assert(isnan (NA));
+%!assert(isnan (rand(1,10)), false(1,10));
+%!assert(isnan([NaN -Inf -1 0 1 Inf NA]), [true, false, false, false, false, false, true]);
+
+%!assert(!(isnan (single(Inf))));
+%!assert(isnan (single(NaN)));
+%!assert(isnan (single(NA)));
+%!assert(isnan (single(rand(1,10))), false(1,10));
+%!assert(isnan(single([NaN -Inf -1 0 1 Inf NA])), [true, false, false, false, false, false, true]);
+
+ */
+
 DEFUNX ("isprint", Fisprint, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} isprint (@var{s})\n\
 Return 1 for printable characters (including the space character).\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
diff --git a/src/ov-float.cc b/src/ov-float.cc
--- a/src/ov-float.cc
+++ b/src/ov-float.cc
@@ -110,26 +110,26 @@ octave_float_scalar::streamoff_array_val
   return retval;
 }
 
 octave_value 
 octave_float_scalar::resize (const dim_vector& dv, bool fill) const
 {
   if (fill)
     {
-      NDArray retval (dv, NDArray::resize_fill_value());
+      FloatNDArray retval (dv, NDArray::resize_fill_value());
 
       if (dv.numel ())
 	retval(0) = scalar;
 
       return retval;
     }
   else
     {
-      NDArray retval (dv);
+      FloatNDArray retval (dv);
 
       if (dv.numel ())
 	retval(0) = scalar;
 
       return retval;
     }
 }
 
diff --git a/src/ov.cc b/src/ov.cc
--- a/src/ov.cc
+++ b/src/ov.cc
@@ -653,17 +653,17 @@ octave_value::octave_value (const ArrayN
 
 octave_value::octave_value (const ComplexDiagMatrix& d)
   : rep (new octave_complex_matrix (d))
 {
   maybe_mutate ();
 }
 
 octave_value::octave_value (const FloatComplexDiagMatrix& d)
-  : rep (new octave_complex_matrix (d))
+  : rep (new octave_float_complex_matrix (d))
 {
   maybe_mutate ();
 }
 
 octave_value::octave_value (const ComplexRowVector& v)
   : rep (new octave_complex_matrix (v))
 {
   maybe_mutate ();
@@ -2209,22 +2209,18 @@ gripe_cat_op_conv (void)
 }
 
 octave_value
 do_cat_op (const octave_value& v1, const octave_value& v2, 
 	   const Array<octave_idx_type>& ra_idx)
 {
   octave_value retval;
 
-  // Rapid return for concatenation with an empty object. Dimension
-  // checking handled elsewhere.
-  if (v1.all_zero_dims ())
-    return v2;
-  if (v2.all_zero_dims ())
-    return v1;
+  // Can't rapid return for concatenation with an empty object here as
+  // something like cat(1,[],single([]) must return the correct type.
 
   int t1 = v1.type_id ();
   int t2 = v2.type_id ();
 
   octave_value_typeinfo::cat_op_fcn f
     = octave_value_typeinfo::lookup_cat_op (t1, t2);
 
   if (f)
diff --git a/test/ChangeLog b/test/ChangeLog
--- a/test/ChangeLog
+++ b/test/ChangeLog
@@ -1,8 +1,14 @@
+2008-06-02  David Bateman  <dbateman@free.fr>
+
+	* test_infnan.m, test_linalg.m, test_matrix.m, test_number.m):
+	Delet and move tests close to function definitions.
+	* test_range.m: Also test single precision examples.
+
 2008-05-19  Bill Denney  <bill@denney.ws>
 
 	* test_args.m: Update format to allow running "test test_args" 
 	and add default argument tests.
 
 2008-05-09  Rafael Laboissiere <rafael@debian.org>
 
 	* test_io.m, test_system.m: Use ischar instead of deprecated isstr.
diff --git a/test/test_infnan.m b/test/test_infnan.m
deleted file mode 100644
--- a/test/test_infnan.m
+++ /dev/null
@@ -1,65 +0,0 @@
-## Copyright (C) 2006, 2007 John W. Eaton
-##
-## This file is part of Octave.
-##
-## Octave is free software; you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation; either version 3 of the License, or (at
-## your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <http://www.gnu.org/licenses/>.
-
-%% Automatically generated from DejaGNU files
-
-%% test/octave.test/infnan/infnan-1.m
-%!test
-%! a = Inf;
-%! assert(!(finite (a)));
-
-%% test/octave.test/infnan/infnan-2.m
-%!test
-%! a = Inf;
-%! assert(isinf (a));
-
-%% test/octave.test/infnan/infnan-3.m
-%!test
-%! a = Inf;
-%! assert(!(isnan (a)));
-
-%% test/octave.test/infnan/infnan-4.m
-%!test
-%! b = NaN;
-%! assert(!(finite (b)));
-
-%% test/octave.test/infnan/infnan-5.m
-%!test
-%! b = NaN;
-%! assert(!(isinf (b)));
-
-%% test/octave.test/infnan/infnan-6.m
-%!test
-%! b = NaN;
-%! assert(isnan (b));
-
-%% test/octave.test/infnan/infnan-7.m
-%!test
-%! c = rand ();
-%! assert(finite (c));
-
-%% test/octave.test/infnan/infnan-8.m
-%!test
-%! c = rand ();
-%! assert(!(isinf (c)));
-
-%% test/octave.test/infnan/infnan-9.m
-%!test
-%! c = rand ();
-%! assert(!(isnan (c)));
-
diff --git a/test/test_linalg.m b/test/test_linalg.m
deleted file mode 100644
--- a/test/test_linalg.m
+++ /dev/null
@@ -1,373 +0,0 @@
-## Copyright (C) 2006, 2007 John W. Eaton
-##
-## This file is part of Octave.
-##
-## Octave is free software; you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation; either version 3 of the License, or (at
-## your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <http://www.gnu.org/licenses/>.
-
-%% Automatically generated from DejaGNU files
-
-%% test/octave.test/linalg/det-1.m
-%!assert(det ([1, 2; 3, 4]) == -2);
-
-%% test/octave.test/linalg/det-2.m
-%!error <Invalid call to det.*> det ();
-
-%% test/octave.test/linalg/det-3.m
-%!error <Invalid call to det.*> det (1, 2);
-
-%% test/octave.test/linalg/det-4.m
-%!error det ([1, 2; 3, 4; 5, 6]);
-
-%% test/octave.test/linalg/eig-1.m
-%!assert(all (abs (eig ([1, 2; 2, 1]) - [-1; 3]) < sqrt (eps)));
-
-%% test/octave.test/linalg/eig-2.m
-%!test
-%! [v, d] = eig ([1, 2; 2, 1]);
-%! x = 1 / sqrt (2);
-%! assert(((abs (d - [-1, 0; 0, 3]) < sqrt (eps))
-%! && (abs (v - [-x, x; x, x]) < sqrt (eps))));
-
-%% test/octave.test/linalg/eig-3.m
-%!error <Invalid call to eig.*> eig ();
-
-%% test/octave.test/linalg/eig-4.m
-%!error <Invalid call to eig.*> eig ([1, 2; 3, 4], 2);
-
-%% test/octave.test/linalg/eig-5.m
-%!error eig ([1, 2; 3, 4; 5, 6]);
-
-%% test/octave.test/linalg/expm-1.m
-%!test
-%! arg = [-49, 24; -64, 31];
-%! result = [-0.735758758144742, 0.551819099658089;
-%! -1.471517599088239, 1.103638240715556];
-%! assert(all (all (abs (expm (arg) - result) < 128*eps)));
-
-%% test/octave.test/linalg/expm-2.m
-%!test
-%! arg = [1, 1; 0, 1];
-%! result = [2.718281828459045, 2.718281828459045;
-%! 0.000000000000000, 2.718281828459045];
-%! assert(all (all (abs (expm (arg) - result) < 4*eps)));
-
-%% test/octave.test/linalg/expm-3.m
-%!test
-%! arg = diag ([6, 6, 6], 1);
-%! result = [1, 6, 18, 36;
-%! 0, 1,  6, 18;
-%! 0, 0,  1,  6;
-%! 0, 0,  0,  1];
-%! assert(all (all (expm (arg) == result)));
-
-%% test/octave.test/linalg/expm-4.m
-%!error <Invalid call to expm.*> expm();
-
-%% test/octave.test/linalg/expm-5.m
-%!error <Invalid call to expm.*> expm(1,2);
-
-%% test/octave.test/linalg/expm-6.m
-%% test/octave.test/linalg/inv-1.m
-%!assert(all (all (abs (inv ([1, 2; 3, 4]) - [-2, 1; 1.5, -0.5]) < sqrt (eps))));
-
-%% test/octave.test/linalg/inv-2.m
-%!error <Invalid call to inv.*> inv ();
-
-%% test/octave.test/linalg/inv-3.m
-%!error <Invalid call to inv.*> inv ([1, 2; 3, 4], 2);
-
-%% test/octave.test/linalg/inv-4.m
-%!error inv ([1, 2; 3, 4; 5, 6]);
-
-%% test/octave.test/linalg/chol-1.m
-%!test
-%! rt2 = sqrt (2);
-%! assert(all (all (abs (chol ([2, 1; 1, 1]) - [rt2, 1/rt2; 0, 1/rt2]) < sqrt (eps))));
-
-%% test/octave.test/linalg/chol-2.m
-%!error chol ([1, 2; 3, 4]);
-
-%% test/octave.test/linalg/chol-3.m
-%!error chol ([1, 2; 3, 4; 5, 6]);
-
-%% test/octave.test/linalg/chol-4.m
-%!error <Invalid call to chol.*> chol ();
-
-%% test/octave.test/linalg/chol-5.m
-%!error <unexpected second or third input.*> chol (1, 2);
-
-%% test/octave.test/linalg/hess-1.m
-%!test
-%! a = [1, 2, 3; 5, 4, 6; 8, 7, 9];
-%! [p, h] = hess (a);
-%! assert(size (p) == [3, 3] && size (h) == [3, 3] && abs (a - p * h * p') < sqrt (eps));
-
-%% test/octave.test/linalg/hess-2.m
-%!error <Invalid call to hess.*> hess ();
-
-%% test/octave.test/linalg/hess-3.m
-%!error <Invalid call to hess.*> hess ([1, 2; 3, 4], 2);
-
-%% test/octave.test/linalg/hess-4.m
-%!error hess ([1, 2; 3, 4; 5, 6]);
-
-%% test/octave.test/linalg/lu-1.m
-%!assert(all (all (lu ([1, 2; 3, 4]) - [3, 4; 1/3, 2/3] < eps)));
-
-%% test/octave.test/linalg/lu-2.m
-%!test
-%! [l, u] = lu ([1, 2; 3, 4]);
-%! assert(((abs (l - [1/3, 1; 1, 0]) < sqrt (eps))
-%! && abs (u - [3, 4; 0, 2/3]) < sqrt (eps)));
-
-%% test/octave.test/linalg/lu-3.m
-%!test
-%! [l, u, p] = lu ([1, 2; 3, 4]);
-%! assert((abs (l - [1, 0; 1/3, 1]) < sqrt (eps)
-%! && abs (u - [3, 4; 0, 2/3]) < sqrt (eps)
-%! && abs (p - [0, 1; 1, 0]) < sqrt (eps)));
-
-%!test
-%! [l, u, p] = lu ([1, 2; 3, 4],'vector');
-%! assert((abs (l - [1, 0; 1/3, 1]) < sqrt (eps)
-%! && abs (u - [3, 4; 0, 2/3]) < sqrt (eps)
-%! && abs (p - [2;1]) < sqrt (eps)));
-
-%% test/octave.test/linalg/lu-4.m
-%!error <Invalid call to lu.*> lu ();
-
-%% test/octave.test/linalg/lu-5.m
-%!error lu ([1, 2; 3, 4], 2);
-
-%% test/octave.test/linalg/lu-6.m
-%!test
-%! [l u p] = lu ([1, 2; 3, 4; 5, 6]);
-%! assert((abs (l - [1, 0; 1/5, 1; 3/5, 1/2]) < sqrt (eps)
-%! && abs (u - [5, 6; 0, 4/5]) < sqrt (eps)
-%! && abs (p - [0, 0, 1; 1, 0, 0; 0 1 0]) < sqrt (eps)));
-
-%% test/octave.test/linalg/qr-1.m
-%!test
-%! a = [0, 2, 1; 2, 1, 2];
-%! 
-%! [q, r] = qr (a);
-%! 
-%! [qe, re] = qr (a, 0);
-%! 
-%! assert((size (q) == [2, 2] && size (r) == [2, 3]
-%! && abs (q * r - a) < sqrt (eps)
-%! && size (qe) == [2, 2] && size (re) == [2, 3]
-%! && abs (qe * re - a) < sqrt (eps)));
-
-%% test/octave.test/linalg/qr-2.m
-%!test
-%! a = [0, 2, 1; 2, 1, 2];
-%! 
-%! [q, r, p] = qr (a);  # not giving right dimensions. FIXME
-%! 
-%! [qe, re, pe] = qr (a, 0);
-%! 
-%! assert((size (q) == [2, 2] && size (r) == [2, 3] && size (p) == [3, 3]
-%! && abs (q * r - a * p) < sqrt (eps)
-%! && size (qe) == [2, 2] && size (re) == [2, 3] && size (pe) == [1, 3]
-%! && abs (qe * re - a(:,pe)) < sqrt (eps)));
-
-%% test/octave.test/linalg/qr-3.m
-%!test
-%! a = [0, 2; 2, 1; 1, 2];
-%! 
-%! [q, r] = qr (a);
-%! 
-%! [qe, re] = qr (a, 0);
-%! 
-%! assert((size (q) == [3, 3] && size (r) == [3, 2]
-%! && abs (a - q * r) < sqrt (eps)
-%! && size (qe) == [3, 2] && size (re) == [2, 2]
-%! && abs (a - qe * re) < sqrt (eps)));
-
-%% test/octave.test/linalg/qr-4.m
-%!test
-%! a = [0, 2; 2, 1; 1, 2];
-%! 
-%! [q, r, p] = qr (a);
-%! 
-%! [qe, re, pe] = qr (a, 0);
-%! 
-%! assert((size (q) == [3, 3] && size (r) == [3, 2] && size (p) == [2, 2]
-%! && abs (a * p - q * r) < sqrt (eps)
-%! && size (qe) == [3, 2] && size (re) == [2, 2] && size (pe) == [1, 2]
-%! && abs (a(:,pe) - qe * re) < sqrt (eps)));
-
-%% test/octave.test/linalg/qr-5.m
-%!error <Invalid call to qr.*> qr ();
-
-%% test/octave.test/linalg/qr-6.m
-%!error <Invalid call to qr.*> qr ([1, 2; 3, 4], 0, 2);
-
-%% test/octave.test/linalg/qr-7.m
-%!function retval = testqr (q, r, a, p)
-%!  tol = 100*eps;
-%!  retval = 0;
-%!  if (nargin == 3)
-%!    n1 = norm (q*r-a);
-%!    n2 = norm (q'*q-eye(columns(q)));
-%!    retval = (n1 < tol && n2 < tol);
-%!  else
-%!    n1 = norm (q'*q-eye(columns(q)));
-%!    retval = (n1 < tol);
-%!    if (isvector (p))
-%!      n2 = norm (q*r-a(:,p));
-%!      retval = (retval && n2 < tol);
-%!    else
-%!      n2 = norm (q*r - a*p);
-%!      retval = (retval && n2 < tol);
-%!    endif
-%!  endif
-%!test
-%! 
-%! t = ones (24, 1);
-%! j = 1;
-%! 
-%! if 0 # eliminate big matrix tests
-%! a = rand(5000,20);
-%! [q,r]=qr(a,0); t(j++) = testqr(q,r,a);
-%! [q,r]=qr(a',0); t(j++) = testqr(q,r,a');
-%! [q,r,p]=qr(a,0); t(j++) = testqr(q,r,a,p);
-%! [q,r,p]=qr(a',0); t(j++) = testqr(q,r,a',p);
-%! 
-%! a = a+1i*eps;
-%! [q,r]=qr(a,0); t(j++) = testqr(q,r,a);
-%! [q,r]=qr(a',0); t(j++) = testqr(q,r,a');
-%! [q,r,p]=qr(a,0); t(j++) = testqr(q,r,a,p);
-%! [q,r,p]=qr(a',0); t(j++) = testqr(q,r,a',p);
-%! endif
-%! 
-%! a = [ ones(1,15); sqrt(eps)*eye(15) ];
-%! [q,r]=qr(a); t(j++) = testqr(q,r,a);
-%! [q,r]=qr(a'); t(j++) = testqr(q,r,a');
-%! [q,r,p]=qr(a); t(j++) = testqr(q,r,a,p);
-%! [q,r,p]=qr(a'); t(j++) = testqr(q,r,a',p);
-%! 
-%! a = a+1i*eps;
-%! [q,r]=qr(a); t(j++) = testqr(q,r,a);
-%! [q,r]=qr(a'); t(j++) = testqr(q,r,a');
-%! [q,r,p]=qr(a); t(j++) = testqr(q,r,a,p);
-%! [q,r,p]=qr(a'); t(j++) = testqr(q,r,a',p);
-%! 
-%! a = [ ones(1,15); sqrt(eps)*eye(15) ];
-%! [q,r]=qr(a,0); t(j++) = testqr(q,r,a);
-%! [q,r]=qr(a',0); t(j++) = testqr(q,r,a');
-%! [q,r,p]=qr(a,0); t(j++) = testqr(q,r,a,p);
-%! [q,r,p]=qr(a',0); t(j++) = testqr(q,r,a',p);
-%! 
-%! a = a+1i*eps;
-%! [q,r]=qr(a,0); t(j++) = testqr(q,r,a);
-%! [q,r]=qr(a',0); t(j++) = testqr(q,r,a');
-%! [q,r,p]=qr(a,0); t(j++) = testqr(q,r,a,p);
-%! [q,r,p]=qr(a',0); t(j++) = testqr(q,r,a',p);
-%! 
-%! a = [
-%! 611   196  -192   407    -8   -52   -49    29
-%! 196   899   113  -192   -71   -43    -8   -44
-%! -192   113   899   196    61    49     8    52
-%! 407  -192   196   611     8    44    59   -23
-%! -8   -71    61     8   411  -599   208   208
-%! -52   -43    49    44  -599   411   208   208
-%! -49    -8     8    59   208   208    99  -911
-%! 29   -44    52   -23   208   208  -911    99
-%! ];
-%! [q,r] = qr(a);
-%! 
-%! assert(all (t) && norm(q*r-a) < 5000*eps);
-
-%% test/octave.test/linalg/schur-1.m
-%!test
-%! a = [1, 2, 3; 4, 5, 9; 7, 8, 6];
-%! [u, s] = schur (a);
-%! assert(size (u) == [3, 3] && size (s) == [3, 3] && abs (s - u' * a * u) < sqrt (eps));
-
-%% test/octave.test/linalg/schur-2.m
-%!error <Invalid call to schur.*> schur ();
-
-%% test/octave.test/linalg/schur-3.m
-%!test
-%! warn_num_to_str = 1;
-%! fail("schur ([1, 2; 3, 4], 2)","warning");
-
-%% test/octave.test/linalg/schur-4.m
-%!error schur ([1, 2, 3; 4, 5, 6]);
-
-%% test/octave.test/linalg/svd-1.m
-%!assert(all (abs (svd ([1, 2; 2, 1]) - [3; 1]) < sqrt (eps)));
-
-%% test/octave.test/linalg/svd-2.m
-%!test
-%! [u, s, v] = svd ([1, 2; 2, 1]);
-%! x = 1 / sqrt (2);
-%! assert(((abs (u - [-x, -x; -x, x]) < sqrt (eps))
-%! && (abs (s - [3, 0; 0, 1]) < sqrt (eps))
-%! && (abs (v - [-x, x; -x, -x]) < sqrt (eps))));
-
-%% test/octave.test/linalg/svd-3.m
-%!test
-%! a = [1, 2, 3; 4, 5, 6];
-%! [u, s, v] = svd (a);
-%! assert((size (u) == [2, 2] && size (s) == [2, 3] && size (v) == [3, 3]
-%! && abs (a - u * s * v') < sqrt (eps)));
-
-%% test/octave.test/linalg/svd-4.m
-%!test
-%! a = [1, 2; 3, 4; 5, 6];
-%! [u, s, v] = svd (a);
-%! assert((size (u) == [3, 3] && size (s) == [3, 2] && size (v) == [2, 2]
-%! && abs (a - u * s * v') < sqrt (eps)));
-
-%% test/octave.test/linalg/svd-5.m
-%!test
-%! a = [1, 2, 3; 4, 5, 6];
-%! [u, s, v] = svd (a, 1);
-%! assert((size (u) == [2, 2] && size (s) == [2, 2] && size (v) == [3, 2]
-%! && abs (a - u * s * v') < sqrt (eps)));
-
-%% test/octave.test/linalg/svd-6.m
-%!test
-%! a = [1, 2; 3, 4; 5, 6];
-%! [u, s, v] = svd (a, 1);
-%! assert((size (u) == [3, 2] && size (s) == [2, 2] && size (v) == [2, 2]
-%! && abs (a - u * s * v') < sqrt (eps)));
-
-%% test/octave.test/linalg/svd-7.m
-%!error <Invalid call to svd.*> svd ();
-
-%% test/octave.test/linalg/svd-8.m
-%!error <Invalid call to svd.*> svd ([1, 2; 4, 5], 2, 3);
-
-%% test/octave.test/linalg/svd-9.m
-%!error <Invalid call to svd.*> [u, v] = svd ([1, 2; 3, 4]);
-
-%% test/octave.test/linalg/syl-1.m
-%!test
-%! x = syl ([1, 2; 3, 4], [5, 6; 7, 8], [9, 10; 11, 12]);
-%! assert(all (all (abs (x - [-1/2, -2/3; -2/3, -1/2]) < sqrt (eps))));
-
-%% test/octave.test/linalg/syl-2.m
-%!error <Invalid call to syl.*> syl ();
-
-%% test/octave.test/linalg/syl-3.m
-%!error <Invalid call to syl.*> syl (1, 2, 3, 4);
-
-%% test/octave.test/linalg/syl-4.m
-%!error syl ([1, 2; 3, 4], [1, 2, 3; 4, 5, 6], [4, 3]);
-
diff --git a/test/test_matrix.m b/test/test_matrix.m
deleted file mode 100644
--- a/test/test_matrix.m
+++ /dev/null
@@ -1,214 +0,0 @@
-## Copyright (C) 2006, 2007 John W. Eaton
-##
-## This file is part of Octave.
-##
-## Octave is free software; you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation; either version 3 of the License, or (at
-## your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <http://www.gnu.org/licenses/>.
-
-%% Automatically generated from DejaGNU files
-
-%% test/octave.test/matrix/all-1.m
-%!test
-%! x = ones (3);
-%! x(1,1) = 0;
-%! assert((all (all (rand (3) + 1) == [1, 1, 1]) == 1
-%! && all (all (x) == [0, 1, 1]) == 1
-%! && all (x, 1) == [0, 1, 1]
-%! && all (x, 2) == [0; 1; 1]));
-
-%% test/octave.test/matrix/all-2.m
-%!error <Invalid call to all.*> all ();
-
-%% test/octave.test/matrix/all-3.m
-%!error <Invalid call to all.*> all (1, 2, 3);
-
-%% test/octave.test/matrix/any-1.m
-%!test
-%! x = zeros (3);
-%! x(3,3) = 1;
-%! assert((all (any (x) == [0, 0, 1]) == 1
-%! && all (any (ones (3)) == [1, 1, 1]) == 1
-%! && any (x, 1) == [0, 0, 1]
-%! && any (x, 2) == [0; 0; 1]));
-
-%% test/octave.test/matrix/any-2.m
-%!error <Invalid call to any.*> any ();
-
-%% test/octave.test/matrix/any-3.m
-%!error <Invalid call to any.*> any (1, 2, 3);
-
-%% test/octave.test/matrix/find-1.m
-%!assert((find ([1, 0, 1, 0, 1]) == [1, 3, 5]
-%! && find ([1; 0; 3; 0; 1]) == [1; 3; 5]
-%! && find ([0, 0, 2; 0, 3, 0; -1, 0, 0]) == [3; 5; 7]));
-
-%% test/octave.test/matrix/find-2.m
-%!test
-%! [i, j, v] = find ([0, 0, 2; 0, 3, 0; -1, 0, 0]);
-%! 
-%! assert(i == [3; 2; 1] && j == [1; 2; 3] && v == [-1; 3; 2]);
-
-%% test/octave.test/matrix/find-3.m
-%!error <Invalid call to find.*> find ();
-
-%% test/octave.test/matrix/reshape-1.m
-%!assert((size (reshape (rand (4, 4), 2, 8)) == [2, 8]
-%! && size (reshape (rand (4, 4), 8, 2)) == [8, 2]
-%! && size (reshape (rand (15, 4), 1, 60)) == [1, 60]
-%! && size (reshape (rand (15, 4), 60, 1)) == [60, 1]));
-
-%% test/octave.test/matrix/reshape-2.m
-%!test
-%! s.a = 1;
-%! fail("reshape (s, 2, 3)");
-
-%% test/octave.test/matrix/reshape-3.m
-%!error <Invalid call to reshape.*> reshape ();
-
-%% test/octave.test/matrix/reshape-4.m
-%!error reshape (1, 2, 3, 4);
-
-%% test/octave.test/matrix/sort-1.m
-%!test
-%! a = [1, 2; 2, 3; 3, 1];
-%! s = [1, 1; 2, 2; 3, 3];
-%! i = [1, 3; 2, 1; 3, 2];
-%! [xs, xi] = sort (a);
-%! assert(sort (a) == s && xs == s && xi == i);
-
-%% test/octave.test/matrix/sort-2.m
-%!error <Invalid call to sort.*> sort ();
-
-%% test/octave.test/matrix/sort-3.m
-%!error <Invalid call to sort.*> sort (1, 2, 3, 4);
-
-
-
-%% test/octave.test/matrix/eye-1.m
-%!test
-%! i33 = [1, 0, 0; 0, 1, 0; 0, 0, 1];
-%! i23 = [1, 0, 0; 0, 1, 0];
-%! assert((eye (3) == i33 && eye (size (i33)) == i33 && eye (3, 3) == i33
-%! && eye (2, 3) == i23 && eye (3, 2) == i23'));
-
-%% test/octave.test/matrix/eye-2.m
-%!error <Invalid call to eye.*> eye (1, 2, 3);
-
-%% test/octave.test/matrix/ones-1.m
-%!test
-%! x33 = [1, 1, 1; 1, 1, 1; 1, 1, 1];
-%! x23 = [1, 1, 1; 1, 1, 1];
-%! assert((ones (3) == x33 && ones (size (x33)) == x33 && ones (3, 3) == x33
-%! && ones (2, 3) == x23 && ones (3, 2) == x23'));
-
-%% test/octave.test/matrix/ones-2.m
-%!assert(all (size (ones (3, 4, 5)) == [3, 4, 5]));
-
-%% test/octave.test/matrix/zeros-1.m
-%!test
-%! x33 = [0, 0, 0; 0, 0, 0; 0, 0, 0];
-%! x23 = [0, 0, 0; 0, 0, 0];
-%! assert((zeros (3) == x33 && zeros (size (x33)) == x33 && zeros (3, 3) == x33
-%! && zeros (2, 3) == x23 && zeros (3, 2) == x23'));
-
-%% test/octave.test/matrix/zeros-2.m
-%!assert(all (size (zeros (3, 4, 5)) == [3, 4, 5]));
-
-%% test/octave.test/matrix/rand-1.m
-%!test
-%! rand ("seed", 0.5);
-%! r1 = rand (100);
-%! rand ("seed", 0.5);
-%! r2 = rand (100);
-%! assert(rand (100) < 1 && rand (100) > 0 && r1 == r2);
-
-%% test/octave.test/matrix/rand-2.m
-%!assert(all (size (rand (1, 2, 3)) == [1, 2, 3]));
-
-%% test/octave.test/matrix/randn-1.m
-%!test
-%! randn ("seed", 0.5);
-%! r1 = randn (100);
-%! randn ("seed", 0.5);
-%! r2 = randn (100);
-%! assert(all (all (r1 == r2)));
-
-%% test/octave.test/matrix/randn-2.m
-%!assert(all (size (randn (1, 2, 3)) == [1, 2, 3]));
-
-%% test/octave.test/matrix/diag-1.m
-%!test
-%! d = [1; 2; 3];
-%! 
-%! d0 = [1, 0, 0;
-%! 0, 2, 0;
-%! 0, 0, 3];
-%! 
-%! d1 = [0, 1, 0, 0;
-%! 0, 0, 2, 0;
-%! 0, 0, 0, 3;
-%! 0, 0, 0, 0];
-%! 
-%! d2 = [0, 0, 1, 0, 0;
-%! 0, 0, 0, 2, 0;
-%! 0, 0, 0, 0, 3;
-%! 0, 0, 0, 0, 0;
-%! 0, 0, 0, 0, 0];
-%! 
-%! dm1 = [0, 0, 0, 0;
-%! 1, 0, 0, 0;
-%! 0, 2, 0, 0;
-%! 0, 0, 3, 0];
-%! 
-%! dm2 = [0, 0, 0, 0, 0;
-%! 0, 0, 0, 0, 0;
-%! 1, 0, 0, 0, 0;
-%! 0, 2, 0, 0, 0;
-%! 0, 0, 3, 0, 0];
-%! 
-%! assert((diag (d) == d0 && diag (d, 1) == d1 && diag (d, 2) == d2
-%! && diag (d, -1) == dm1 && diag (d, -2) == dm2
-%! && diag (d0) == d && diag (d1, 1) == d && diag (dm1, -1) == d));
-
-%% test/octave.test/matrix/diag-2.m
-%!error <Invalid call to diag.*> diag ();
-
-%% test/octave.test/matrix/diag-3.m
-%!error <Invalid call to diag.*> diag (1, 2, 3);
-
-%% test/octave.test/matrix/linspace-1.m
-%!test
-%! x1 = linspace (1, 2);
-%! x2 = linspace (1, 2, 10);
-%! x3 = linspace (1, -2, 10);
-%! assert((size (x1) == [1, 100] && x1(1) == 1 && x1(100) == 2
-%! && size (x2) == [1, 10] && x2(1) == 1 && x2(10) == 2
-%! && size (x3) == [1, 10] && x3(1) == 1 && x3(10) == -2));
-
-%% test/octave.test/matrix/linspace-2.m
-%!test
-%! warn_fortran_indexing = 0;
-%! assert(all (linspace ([1, 2; 3, 4], 5, 6) == linspace (1, 5, 6)));
-
-%% test/octave.test/matrix/linspace-3.m
-%!error <Invalid call to linspace.*> linspace ();
-
-%% test/octave.test/matrix/linspace-4.m
-%!error <Invalid call to linspace.*> linspace (1, 2, 3, 4);
-
-%% test/octave.test/matrix/linspace-5.m
-%!test
-%! warn_fortran_indexing = 1;
-%! fail("linspace ([1, 2; 3, 4], 5, 6)","warning");
-
diff --git a/test/test_number.m b/test/test_number.m
deleted file mode 100644
--- a/test/test_number.m
+++ /dev/null
@@ -1,60 +0,0 @@
-## Copyright (C) 2006, 2007 John W. Eaton
-##
-## This file is part of Octave.
-##
-## Octave is free software; you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation; either version 3 of the License, or (at
-## your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <http://www.gnu.org/licenses/>.
-
-%% Automatically generated from DejaGNU files
-
-%% test/octave.test/number/ismatrix-1.m
-%!assert(ismatrix (1));
-
-%% test/octave.test/number/ismatrix-2.m
-%!assert(ismatrix ([1, 2, 3]));
-
-%% test/octave.test/number/ismatrix-3.m
-%% Yes, this is right, ismatrix() checks for non-empty matrices.
-%!assert(
-%! ismatrix ([]) == 0);
-
-%% test/octave.test/number/ismatrix-4.m
-%!assert(ismatrix ([1, 2; 3, 4]));
-
-%% test/octave.test/number/ismatrix-5.m
-%!test
-%! warn_str_to_num = 0;
-%! assert(!(ismatrix ("t")));
-
-%% test/octave.test/number/ismatrix-6.m
-%!test
-%! warn_str_to_num = 0;
-%! assert(!(ismatrix ("test")));
-
-%% test/octave.test/number/ismatrix-7.m
-%!test
-%! warn_str_to_num = 0;
-%! assert(!(ismatrix (["test"; "ing"])));
-
-%% test/octave.test/number/ismatrix-8.m
-%!test
-%! s.a = 1;
-%! assert(!(ismatrix (s)));
-
-%% test/octave.test/number/ismatrix-9.m
-%!error <Invalid call to ismatrix.*> ismatrix ();
-
-%% test/octave.test/number/ismatrix-10.m
-%!error <Invalid call to ismatrix.*> ismatrix ([1, 2; 3, 4], 2);
-
diff --git a/test/test_range.m b/test/test_range.m
--- a/test/test_range.m
+++ b/test/test_range.m
@@ -29,16 +29,17 @@
 
 %!shared expect, r, z
 %! expect = [ 1 2 3 4 5 6 7 8 9
 %!            0 0 0 0 0 0 0 0 0 ];
 %! z = zeros(1,9);
 %! r = 1:9;
 
 %!assert([ r ; z                  ], expect)
+%!assert([ r ; single(z)          ], single (expect))
 %!assert([ r ; logical(z)         ], expect)
 %!assert([ r ; sparse(z)          ], sparse (expect))
 %!assert([ r ; sparse(logical(z)) ], sparse (expect))
 
 %!assert([ r ; int8(z)            ], int8(expect))
 %!assert([ r ; int16(z)           ], int16(expect))
 %!assert([ r ; int32(z)           ], int32(expect))
 %!assert([ r ; int64(z)           ], int64(expect))
@@ -52,16 +53,17 @@
 
 %!shared expect, r, z
 %! expect = [ 1.0 1.4 1.8 2.2 2.6 3.0
 %!            0   0   0   0   0   0   ];
 %! z = zeros(1,6);
 %! r = 1:0.4:3;
 
 %!assert([ r ; z                  ], expect)
+%!assert([ r ; single(z)          ], single (expect))
 %!assert([ r ; logical(z)         ], expect)
 %!assert([ r ; sparse(z)          ], sparse (expect))
 %!assert([ r ; sparse(logical(z)) ], sparse (expect))
 
 %!assert([ r ; int8(z)            ], int8(expect))
 %!assert([ r ; int16(z)           ], int16(expect))
 %!assert([ r ; int32(z)           ], int32(expect))
 %!assert([ r ; int64(z)           ], int64(expect))
