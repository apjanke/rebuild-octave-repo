# HG changeset patch
# User Rik <rik@octave.org>
# Date 1493079637 25200
#      Mon Apr 24 17:20:37 2017 -0700
# Node ID c9fab0bc983e7a51f89448f1a055d937e67a987f
# Parent  e35a5c1233d0486969da6bee04a93a9978b7941e
maint: Use convention 'int& x' for naming references.

* ButtonGroup.cc, Canvas.cc, Canvas.h, annotation-dialog.cc,
annotation-dialog.h, dialog.h, documentation-dock-widget.cc,
files-dock-widget.cc, files-dock-widget.h, find-files-dialog.cc,
find-files-dialog.h, find-files-model.cc, find-files-model.h,
history-dock-widget.cc, history-dock-widget.h, file-editor-tab.cc,
file-editor-tab.h, file-editor.cc, file-editor.h, main-window.cc,
main-window.h, octave-qt-link.h, parser.cc, parser.h, webinfo.cc, webinfo.h,
settings-dialog.cc, bsxfun.cc, call-stack.cc, call-stack.h, fft.cc, fft2.cc,
fftn.cc, gl-render.cc, graphics.cc, graphics.in.h, input.cc, load-save.cc,
ls-hdf5.cc, ls-hdf5.h, octave-link.h, pr-output.cc, regexp.cc, sparse-xdiv.cc,
sparse-xdiv.h, symtab.cc, xdiv.cc, xdiv.h, zfstream.h, __eigs__.cc,
__ode15__.cc, ov-base.h, ov-builtin.cc, ov-cx-sparse.h, ov-fcn-handle.cc,
ov-fcn-handle.h, ov.cc, ov.h, jit-ir.h, jit-typeinfo.cc, jit-typeinfo.h,
pt-jit.cc, pt-jit.h, CMatrix.cc, CMatrix.h, CSparse.cc, CSparse.h,
MatrixType.cc, MatrixType.h, dDiagMatrix.cc, dMatrix.cc, dMatrix.h, dSparse.cc,
dSparse.h, fCMatrix.cc, fCMatrix.h, fDiagMatrix.cc, fMatrix.cc, fMatrix.h,
eigs-base.cc, oct-fftw.cc, oct-rand.h, sparse-dmsolve.cc, kpse.cc, lo-regexp.h:
Use convention 'int& x' for naming references.

diff --git a/libgui/graphics/ButtonGroup.cc b/libgui/graphics/ButtonGroup.cc
--- a/libgui/graphics/ButtonGroup.cc
+++ b/libgui/graphics/ButtonGroup.cc
@@ -60,17 +60,17 @@ namespace QtHandles
       return (QFrame::Panel | QFrame::Sunken);
     else if (pp.bordertype_is ("beveledout"))
       return (QFrame::Panel | QFrame::Raised);
     else
       return (QFrame::Panel | QFrame::Plain);
   }
 
   static void
-  setupPalette (const uibuttongroup::properties& pp, QPalette &p)
+  setupPalette (const uibuttongroup::properties& pp, QPalette& p)
   {
     p.setColor (QPalette::Window,
                 Utils::fromRgb (pp.get_backgroundcolor_rgb ()));
     p.setColor (QPalette::WindowText,
                 Utils::fromRgb (pp.get_foregroundcolor_rgb ()));
     p.setColor (QPalette::Light,
                 Utils::fromRgb (pp.get_highlightcolor_rgb ()));
     p.setColor (QPalette::Dark,
diff --git a/libgui/graphics/Canvas.cc b/libgui/graphics/Canvas.cc
--- a/libgui/graphics/Canvas.cc
+++ b/libgui/graphics/Canvas.cc
@@ -368,17 +368,17 @@ namespace QtHandles
 
     octave_scalar_map zm = ov_zm.scalar_map_value ();
 
     return zm.contents ("Motion").string_value ();
   }
 
   void
   Canvas::select_object (graphics_object obj, QMouseEvent* event,
-                         graphics_object &currentObj, graphics_object &axesObj,
+                         graphics_object& currentObj, graphics_object& axesObj,
                          bool axes_only, std::vector<std::string> omit)
   {
     QList<graphics_object> axesList;
     Matrix children = obj.get_properties ().get_all_children ();
     octave_idx_type num_children = children.numel ();
 
     for (int i = 0; i < num_children; i++)
       {
diff --git a/libgui/graphics/Canvas.h b/libgui/graphics/Canvas.h
--- a/libgui/graphics/Canvas.h
+++ b/libgui/graphics/Canvas.h
@@ -102,17 +102,17 @@ namespace QtHandles
 
     void updateCurrentPoint (const graphics_object& fig,
                              const graphics_object& obj, QMouseEvent *event);
     void updateCurrentPoint (const graphics_object& fig,
                              const graphics_object& obj);
 
     void annotation_callback (const octave_value_list& args);
     void select_object (graphics_object obj, QMouseEvent* event,
-                        graphics_object &currentObj, graphics_object &axesObj,
+                        graphics_object& currentObj, graphics_object& axesObj,
                         bool axes_only = false,
                         std::vector<std::string> omit = std::vector<std::string> ());
 
   private:
     graphics_handle m_handle;
     bool m_redrawBlocked;
     MouseMode m_mouseMode;
     bool m_clickMode;              // True: ZoomIn, False: ZoomOut
diff --git a/libgui/graphics/annotation-dialog.cc b/libgui/graphics/annotation-dialog.cc
--- a/libgui/graphics/annotation-dialog.cc
+++ b/libgui/graphics/annotation-dialog.cc
@@ -32,17 +32,17 @@ along with Octave; see the file COPYING.
 #include "resource-manager.h"
 
 #include <QColorDialog>
 #include <QPushButton>
 #include <QPalette>
 
 using namespace QtHandles;
 
-annotation_dialog::annotation_dialog (QWidget *p, const octave_value_list &pr):
+annotation_dialog::annotation_dialog (QWidget *p, const octave_value_list& pr):
   QDialog (p), ui (new Ui::annotation_dialog)
 {
   props = pr;
 
   init ();
 }
 
 void
@@ -252,17 +252,17 @@ annotation_dialog::set_gui_props ()
         }
 
     }
 
   edit_string_changed (ui->edit_string->text ());
 }
 
 void
-annotation_dialog::edit_string_changed (const QString &str)
+annotation_dialog::edit_string_changed (const QString& str)
 {
   ui->button_box->button (QDialogButtonBox::Ok)->setEnabled (str.length () > 0);
 }
 
 void
 annotation_dialog::prompt_for_color ()
 {
   QWidget *widg = dynamic_cast<QWidget*> (sender ());
diff --git a/libgui/graphics/annotation-dialog.h b/libgui/graphics/annotation-dialog.h
--- a/libgui/graphics/annotation-dialog.h
+++ b/libgui/graphics/annotation-dialog.h
@@ -33,25 +33,25 @@ namespace Ui
 {
   class annotation_dialog;
 }
 
 class annotation_dialog : public QDialog
 {
   Q_OBJECT
 public:
-  explicit annotation_dialog (QWidget * parent, const octave_value_list &pr);
+  explicit annotation_dialog (QWidget *parent, const octave_value_list& pr);
   ~annotation_dialog ();
 
   octave_value_list get_properties () const;
 
 private slots:
   // slots for dialog's buttons
   void button_clicked (QAbstractButton *button);
-  void edit_string_changed (const QString &str);
+  void edit_string_changed (const QString& str);
   void prompt_for_color ();
 
 private:
   void init ();
 
   void get_gui_props ();
   void set_gui_props ();
 
diff --git a/libgui/src/dialog.h b/libgui/src/dialog.h
--- a/libgui/src/dialog.h
+++ b/libgui/src/dialog.h
@@ -101,17 +101,17 @@ public:
 
     return true;
   };
 
   const QStringList *get_string_list (void) { return string_list; }
 
   bool signal_filedialog (const QStringList& filters, const QString& title,
                           const QString& filename, const QString& dirname,
-                          const QString &multimode)
+                          const QString& multimode)
   {
     emit create_filedialog (filters, title, filename, dirname, multimode);
     return true;
   }
 
   const QString *get_dialog_path (void) { return path_name; }
 
   // GUI objects cannot be accessed in the non-GUI thread.  However,
diff --git a/libgui/src/documentation-dock-widget.cc b/libgui/src/documentation-dock-widget.cc
--- a/libgui/src/documentation-dock-widget.cc
+++ b/libgui/src/documentation-dock-widget.cc
@@ -54,17 +54,17 @@ documentation_dock_widget::pasteClipboar
 }
 void
 documentation_dock_widget::selectAll ()
 {
   _webinfo->selectAll ();
 }
 
 void
-documentation_dock_widget::showDoc (const QString &name)
+documentation_dock_widget::showDoc (const QString& name)
 {
   // show the doc pane without focus for carrying on typing in the console
   if (! isVisible ())
     setVisible (true);
   raise ();
 
   _webinfo->load_ref (name);
 
diff --git a/libgui/src/files-dock-widget.cc b/libgui/src/files-dock-widget.cc
--- a/libgui/src/files-dock-widget.cc
+++ b/libgui/src/files-dock-widget.cc
@@ -866,17 +866,17 @@ files_dock_widget::popdownmenu_newdir (b
 
 void
 files_dock_widget::popdownmenu_newfile (bool)
 {
   process_new_file (_file_system_model->rootPath ());
 }
 
 void
-files_dock_widget::process_new_file (const QString &parent_dir)
+files_dock_widget::process_new_file (const QString& parent_dir)
 {
   bool ok;
 
   QString name = QInputDialog::getText (this, tr ("Create File"),
        tr ("Create file in\n","String ends with \\n!") + parent_dir,
        QLineEdit::Normal, tr ("New File.txt"), &ok);
   if (ok && name.length () > 0)
     {
@@ -884,17 +884,17 @@ files_dock_widget::process_new_file (con
 
       QFile file (name);
       file.open (QIODevice::WriteOnly);
       _file_system_model->revert ();
     }
 }
 
 void
-files_dock_widget::process_new_dir (const QString &parent_dir)
+files_dock_widget::process_new_dir (const QString& parent_dir)
 {
   bool ok;
 
   QString name = QInputDialog::getText (this, tr ("Create Directory"),
                 tr ("Create folder in\n","String ends with \\n!") + parent_dir,
                 QLineEdit::Normal, tr ("New Directory"), &ok);
   if (ok && name.length () > 0)
     {
diff --git a/libgui/src/files-dock-widget.h b/libgui/src/files-dock-widget.h
--- a/libgui/src/files-dock-widget.h
+++ b/libgui/src/files-dock-widget.h
@@ -125,23 +125,23 @@ signals:
 
   /** Emitted, whenever the user requested to load a file. */
   void load_file_signal (const QString& fileName);
 
   /** Emitted, whenever the user requested to run a file. */
   void run_file_signal (const QFileInfo& info);
 
   /** Emitted, whenever wants to search for a file . */
-  void find_files_signal (const QString &startdir);
+  void find_files_signal (const QString& startdir);
 
 private:
-  void process_new_file (const QString &parent_name);
-  void process_new_dir (const QString &parent_name);
-  void process_set_current_dir (const QString &parent_name);
-  void process_find_files (const QString &dir_name);
+  void process_new_file (const QString& parent_name);
+  void process_new_dir (const QString& parent_name);
+  void process_set_current_dir (const QString& parent_name);
+  void process_find_files (const QString& dir_name);
 
   /** set a new directory or open a file **/
   void display_directory (const QString& dir, bool set_octave_dir = true);
 
   void open_item_in_app (const QModelIndex& index);
 
   /** Variables for the actions **/
   QToolBar *        _navigation_tool_bar;
diff --git a/libgui/src/find-files-dialog.cc b/libgui/src/find-files-dialog.cc
--- a/libgui/src/find-files-dialog.cc
+++ b/libgui/src/find-files-dialog.cc
@@ -41,17 +41,17 @@ along with Octave; see the file COPYING.
 #include <QDirIterator>
 #include <QTextStream>
 #include <QGroupBox>
 
 #include "find-files-dialog.h"
 #include "find-files-model.h"
 #include "resource-manager.h"
 
-find_files_dialog::find_files_dialog (QWidget * p)
+find_files_dialog::find_files_dialog (QWidget *p)
   : QDialog (p)
 {
   setWindowTitle (tr ("Find Files"));
   setWindowIcon (resource_manager::icon ("edit-find"));
 
   _dir_iterator = 0;
 
   _timer = new QTimer (this);
@@ -242,17 +242,17 @@ find_files_dialog::~find_files_dialog ()
 }
 
 void find_files_dialog::handle_done (int)
 {
   // make sure we stopped processing
   stop_find ();
 }
 
-void find_files_dialog::set_search_dir (const QString &dir)
+void find_files_dialog::set_search_dir (const QString& dir)
 {
   stop_find ();
   _start_dir_edit->setText (dir);
 }
 
 void
 find_files_dialog::start_find ()
 {
@@ -328,17 +328,17 @@ find_files_dialog::browse_folders ()
 
   if (! dir.isEmpty ())
     {
       _start_dir_edit->setText (dir);
     }
 }
 
 void
-find_files_dialog::item_double_clicked (const QModelIndex &idx)
+find_files_dialog::item_double_clicked (const QModelIndex& idx)
 {
   find_files_model *m = static_cast<find_files_model *> (_file_list->model ());
 
   QFileInfo info = m->fileInfo (idx);
 
   if (idx.column () == 1)
     {
       // clicked in directory part
@@ -368,17 +368,17 @@ find_files_dialog::look_for_files ()
         m->addFile (info);
     }
   else
     {
       stop_find ();
     }
 }
 
-bool find_files_dialog::is_match (const QFileInfo &info)
+bool find_files_dialog::is_match (const QFileInfo& info)
 {
   bool match = true;
   if (info.isDir ())
     {
       if (! _include_dirs_check->isChecked ()) match = false;
       if (_contains_text_check->isChecked ()) match = false;
     }
   else
diff --git a/libgui/src/find-files-dialog.h b/libgui/src/find-files-dialog.h
--- a/libgui/src/find-files-dialog.h
+++ b/libgui/src/find-files-dialog.h
@@ -38,31 +38,31 @@ class find_files_dialog : public QDialog
 {
   Q_OBJECT
 public:
   find_files_dialog (QWidget *parent = 0);
   virtual ~find_files_dialog ();
   void save_settings (void);
 
 signals:
-  void file_selected (const QString &fileName);
-  void dir_selected (const QString &fileName);
+  void file_selected (const QString& fileName);
+  void dir_selected (const QString& fileName);
 
 public slots:
-  void set_search_dir (const QString &dir);
+  void set_search_dir (const QString& dir);
 
 private slots:
   void start_find ();
   void stop_find ();
   void browse_folders ();
   void look_for_files ();
   void item_double_clicked (const QModelIndex&);
   void handle_done (int);
 private:
-  bool is_match (const QFileInfo &info);
+  bool is_match (const QFileInfo& info);
   QLineEdit   *_start_dir_edit;
   QLineEdit   *_file_name_edit;
   QPushButton *_stop_button;
   QPushButton *_find_button;
   QPushButton *_close_button;
   QPushButton *_browse_button;
   QTableView  *_file_list;
   QTimer      *_timer;
diff --git a/libgui/src/find-files-model.cc b/libgui/src/find-files-model.cc
--- a/libgui/src/find-files-model.cc
+++ b/libgui/src/find-files-model.cc
@@ -31,17 +31,17 @@ along with Octave; see the file COPYING.
 
 class find_file_less_than
 {
 public:
   find_file_less_than (int ord)
   {
     _sortorder = ord;
   }
-  QVariant getValue (const QFileInfo &f) const
+  QVariant getValue (const QFileInfo& f) const
   {
     QVariant val;
     int col = (_sortorder > 0) ? _sortorder : -_sortorder;
 
     switch (col-1)
       {
       case 0:
         val = QVariant (f.fileName ());
@@ -51,22 +51,22 @@ public:
         val = QVariant (f.absolutePath ());
         break;
 
       default:
         break;
       }
     return val;
   }
-  bool lessThan (const QVariant &left, const QVariant &right) const
+  bool lessThan (const QVariant& left, const QVariant& right) const
   {
     return
       left.toString ().compare (right.toString (), Qt::CaseInsensitive) < 0;
   }
-  bool operator () (const QFileInfo &left, const QFileInfo &right) const
+  bool operator () (const QFileInfo& left, const QFileInfo& right) const
   {
     QVariant leftval = getValue (left);
     QVariant rightval = getValue (right);
 
     if (_sortorder > 0)
       return lessThan (leftval, rightval);
     else
       return ! lessThan (leftval, rightval);
@@ -94,17 +94,17 @@ find_files_model::clear ()
   beginResetModel ();
 
   _files.clear ();
 
   endResetModel ();
 }
 
 void
-find_files_model::addFile (const QFileInfo &info)
+find_files_model::addFile (const QFileInfo& info)
 {
   beginInsertRows (QModelIndex (), _files.size (), _files.size ());
 
   QList<QFileInfo>::Iterator it;
   find_file_less_than less_than (_sortorder);
 
   for (it=_files.begin (); it!=_files.end (); it++)
     {
@@ -203,17 +203,17 @@ find_files_model::fileInfo (const QModel
   if (p.isValid ())
     {
       return _files[p.row ()];
     }
   return QFileInfo ();
 }
 
 QIcon
-find_files_model::fileIcon (const QModelIndex &p) const
+find_files_model::fileIcon (const QModelIndex& p) const
 {
   QFileIconProvider icon_provider;
   if (p.isValid ())
     {
       return icon_provider.icon (_files[p.row ()]);
     }
   return QIcon ();
 }
diff --git a/libgui/src/find-files-model.h b/libgui/src/find-files-model.h
--- a/libgui/src/find-files-model.h
+++ b/libgui/src/find-files-model.h
@@ -34,30 +34,30 @@ class find_files_model : public QAbstrac
   Q_OBJECT
 
 public:
   find_files_model (QObject *p=0);
   ~find_files_model ();
 
   void clear ();
 
-  void addFile (const QFileInfo &info);
+  void addFile (const QFileInfo& info);
 
-  int rowCount (const QModelIndex & p=QModelIndex ()) const;
+  int rowCount (const QModelIndex& p = QModelIndex ()) const;
 
-  int columnCount (const QModelIndex & p=QModelIndex ()) const;
+  int columnCount (const QModelIndex& p = QModelIndex ()) const;
 
   QVariant data (const QModelIndex& idx, int role) const;
 
   QVariant headerData (int section, Qt::Orientation orientation,
                        int role = Qt::DisplayRole) const;
 
-  void sort (int column, Qt::SortOrder order=Qt::AscendingOrder);
+  void sort (int column, Qt::SortOrder order = Qt::AscendingOrder);
 
-  QFileInfo fileInfo (const QModelIndex & p) const;
-  QIcon     fileIcon (const QModelIndex &p) const;
+  QFileInfo fileInfo (const QModelIndex& p) const;
+  QIcon     fileIcon (const QModelIndex& p) const;
 private:
   QList<QFileInfo> _files;
   QStringList _columnNames;
   int _sortorder;
 };
 
 #endif
diff --git a/libgui/src/history-dock-widget.cc b/libgui/src/history-dock-widget.cc
--- a/libgui/src/history-dock-widget.cc
+++ b/libgui/src/history-dock-widget.cc
@@ -186,17 +186,17 @@ history_dock_widget::update_filter_histo
 
   if (index > -1)
     _filter->removeItem (index);    // remove if already existing
 
   _filter->insertItem (0, text);    // (re)insert at beginning
   _filter->setCurrentIndex (0);
 }
 
-void history_dock_widget::ctxMenu (const QPoint &xpos)
+void history_dock_widget::ctxMenu (const QPoint& xpos)
 {
   QMenu menu (this);
 
   QModelIndex index = _history_list_view->indexAt (xpos);
 
   if (index.isValid () && index.column () == 0)
     {
       menu.addAction (resource_manager::icon ("edit-copy"),
diff --git a/libgui/src/history-dock-widget.h b/libgui/src/history-dock-widget.h
--- a/libgui/src/history-dock-widget.h
+++ b/libgui/src/history-dock-widget.h
@@ -64,17 +64,17 @@ private slots:
   void update_filter_history ();
   void filter_activate (bool enable);
 
   void handle_double_click (QModelIndex modelIndex);
   void handle_contextmenu_copy (bool flag);
   void handle_contextmenu_evaluate (bool flag);
   void handle_contextmenu_create_script (bool flag);
   void handle_contextmenu_filter (void);
-  void ctxMenu (const QPoint &pos);
+  void ctxMenu (const QPoint& pos);
 
   void copyClipboard ();
   void pasteClipboard ();
   void selectAll ();
 
   virtual void handle_visibility (bool visible);
 
 private:
diff --git a/libgui/src/m-editor/file-editor-tab.cc b/libgui/src/m-editor/file-editor-tab.cc
--- a/libgui/src/m-editor/file-editor-tab.cc
+++ b/libgui/src/m-editor/file-editor-tab.cc
@@ -1733,17 +1733,17 @@ result =
     line
 */
           // Check for results that match "file".
         }
     }
 }
 
 void
-file_editor_tab::new_file (const QString &commands)
+file_editor_tab::new_file (const QString& commands)
 {
   update_window_title (false); // window title (no modification)
 
   QSettings *settings = resource_manager::get_settings ();
 
   // set the eol mode from the settings or depending on the OS if the entry is
   // missing in the settings
 #if defined (Q_OS_WIN32)
diff --git a/libgui/src/m-editor/file-editor-tab.h b/libgui/src/m-editor/file-editor-tab.h
--- a/libgui/src/m-editor/file-editor-tab.h
+++ b/libgui/src/m-editor/file-editor-tab.h
@@ -140,17 +140,17 @@ public slots:
 
   void handle_context_menu_edit (const QString&);
   void handle_context_menu_break_condition (int linenr);
 
   void handle_request_add_breakpoint (int line, const QString& cond);
   void handle_request_remove_breakpoint (int line);
 
   void handle_octave_result (QObject *requester, QString& command,
-                             octave_value_list &result);
+                             octave_value_list& result);
 
 signals:
 
   void file_name_changed (const QString& fileName, const QString& toolTip);
   void editor_state_changed (bool copy_available, bool is_octave_file);
   void set_focus_editor_signal (QWidget *);
   void tab_remove_request ();
   void add_filename_to_list (const QString&, const QString&, QWidget *);
diff --git a/libgui/src/m-editor/file-editor.cc b/libgui/src/m-editor/file-editor.cc
--- a/libgui/src/m-editor/file-editor.cc
+++ b/libgui/src/m-editor/file-editor.cc
@@ -1262,17 +1262,17 @@ file_editor::insert_global_actions (QLis
   _edit_menu->insertSeparator (_selectall_action);
   _paste_action->setEnabled (false);
   // find files
   _find_files_action = shared_actions.at (FIND_FILES_ACTION);
   _edit_menu->insertAction (_find_action, _find_files_action);
 }
 
 QAction*
-file_editor::add_action (QMenu *menu, const QIcon &icon, const QString &text,
+file_editor::add_action (QMenu *menu, const QIcon& icon, const QString& text,
                          const char *member)
 {
   QAction *a;
 
   if (menu)
     a = menu->addAction (icon, text, this, member);
   else
     {
diff --git a/libgui/src/m-editor/file-editor.h b/libgui/src/m-editor/file-editor.h
--- a/libgui/src/m-editor/file-editor.h
+++ b/libgui/src/m-editor/file-editor.h
@@ -103,17 +103,17 @@ public:
 
   // struct that allows to sort with respect to the tab index
   struct session_data
   {
     QString index;
     QString file_name;
     QString encoding;
 
-    bool operator < (const session_data &other) const
+    bool operator < (const session_data& other) const
     {
       return index < other.index;
     }
   };
 
   file_editor (QWidget *p);
   ~file_editor (void);
 
@@ -345,17 +345,17 @@ private:
 
   void switch_tab (int direction, bool movetab = false);
 
   void restore_session (QSettings *settings);
 
   bool editor_tab_has_focus ();
 
   QWidget *find_tab_widget (const QString& openFileName) const;
-  QAction *add_action (QMenu *menu, const QIcon &icon, const QString &text,
+  QAction *add_action (QMenu *menu, const QIcon& icon, const QString& text,
                        const char *member);
 
   QMenu* m_add_menu (QMenuBar *p, QString text);
 
   std::map<QString, tab_info> editor_tab_map;
   QHash<QMenu*, QStringList> _hash_menu_text;
 
   QString ced;
diff --git a/libgui/src/main-window.cc b/libgui/src/main-window.cc
--- a/libgui/src/main-window.cc
+++ b/libgui/src/main-window.cc
@@ -1958,17 +1958,17 @@ main_window::construct_menu_bar (void)
                  << _copy_action
                  << _paste_action
                  <<_select_all_action;
   editor_window->insert_global_actions (shared_actions);
 #endif
 }
 
 QAction*
-main_window::add_action (QMenu *menu, const QIcon &icon, const QString &text,
+main_window::add_action (QMenu *menu, const QIcon& icon, const QString& text,
                          const char *member, const QWidget *receiver)
 {
   QAction *a;
 
   if (receiver)
     a = menu->addAction (icon, text, receiver, member);
   else
     a = menu->addAction (icon, text, this, member);
@@ -2469,17 +2469,17 @@ main_window::new_figure_callback (void)
 void
 main_window::change_directory_callback (const std::string& directory)
 {
   Fcd (ovl (directory));
   _octave_qt_link->update_directory ();
 }
 
 void
-main_window::find_files (const QString &start_dir)
+main_window::find_files (const QString& start_dir)
 {
 
   if (! find_files_dlg)
     {
       find_files_dlg = new find_files_dialog (this);
 
       connect (find_files_dlg, SIGNAL (finished (int)),
                this, SLOT (find_files_finished (int)));
diff --git a/libgui/src/main-window.h b/libgui/src/main-window.h
--- a/libgui/src/main-window.h
+++ b/libgui/src/main-window.h
@@ -232,27 +232,27 @@ public slots:
                                const QStringList& prompt,
                                const QString& ok_string,
                                const QString& cancel_string);
 
   void handle_create_inputlayout (const QStringList&, const QString&,
                                   const QFloatList&, const QFloatList&,
                                   const QStringList&);
 
-  void handle_create_filedialog (const QStringList &filters,
+  void handle_create_filedialog (const QStringList& filters,
                                  const QString& title, const QString& filename,
-                                 const QString &dirname,
+                                 const QString& dirname,
                                  const QString& multimode);
 
-  void handle_show_doc (const QString &file);
+  void handle_show_doc (const QString& file);
 
   void handle_octave_ready ();
 
   // find files dialog
-  void find_files (const QString &startdir=QDir::currentPath ());
+  void find_files (const QString& startdir = QDir::currentPath ());
   void find_files_finished (int);
 
   // setting global shortcuts
   void set_global_shortcuts (bool enable);
 
   void set_screen_size (int ht, int wd);
 
   // handling the clipboard
@@ -276,17 +276,17 @@ protected:
   void closeEvent (QCloseEvent *closeEvent);
 
 private:
 
   void construct (void);
 
   void construct_octave_qt_link (void);
 
-  QAction *add_action (QMenu *menu, const QIcon &icon, const QString &text,
+  QAction *add_action (QMenu *menu, const QIcon& icon, const QString& text,
                        const char *member, const QWidget *receiver = 0);
 
   QMenu* m_add_menu (QMenuBar *p, QString text);
   void construct_menu_bar (void);
   void construct_file_menu (QMenuBar *p);
   void construct_new_menu (QMenu *p);
   void construct_edit_menu (QMenuBar *p);
   QAction *construct_debug_menu_item (const char *icon, const QString& item,
diff --git a/libgui/src/octave-qt-link.h b/libgui/src/octave-qt-link.h
--- a/libgui/src/octave-qt-link.h
+++ b/libgui/src/octave-qt-link.h
@@ -87,17 +87,17 @@ public:
   do_input_dialog (const std::list<std::string>& prompt,
                    const std::string& title,
                    const std::list<float>& nr,
                    const std::list<float>& nc,
                    const std::list<std::string>& defaults);
 
   std::list<std::string>
   do_file_dialog (const filter_list& filter, const std::string& title,
-                  const std::string &filename, const std::string &pathname,
+                  const std::string& filename, const std::string& pathname,
                   const std::string& multimode);
 
   int
   do_debug_cd_or_addpath_error (const std::string& file,
                                 const std::string& dir,
                                 bool addpath_option);
 
   void do_change_directory (const std::string& dir);
@@ -185,14 +185,14 @@ signals:
   void update_breakpoint_marker_signal (bool insert, const QString& file,
                                         int line, const QString& cond);
 
   void insert_debugger_pointer_signal (const QString&, int);
   void delete_debugger_pointer_signal (const QString&, int);
 
   void show_preferences_signal (void);
 
-  void show_doc_signal (const QString &file);
+  void show_doc_signal (const QString& file);
 
   void confirm_shutdown_signal (void);
 };
 
 #endif
diff --git a/libgui/src/qtinfo/parser.cc b/libgui/src/qtinfo/parser.cc
--- a/libgui/src/qtinfo/parser.cc
+++ b/libgui/src/qtinfo/parser.cc
@@ -640,17 +640,17 @@ parser::global_search (const QString& te
       delete io;
     }
 
   results.append ("</body></html>");
   return results;
 }
 
 QString
-parser::find_ref (const QString &ref_name)
+parser::find_ref (const QString& ref_name)
 {
   QString text = "";
 
   QHash<QString, node_position>::iterator it;
   for (it = _ref_map.begin (); it != _ref_map.end (); ++it)
     {
       QString k = it.key ();
       node_position p = it.value ();
diff --git a/libgui/src/qtinfo/parser.h b/libgui/src/qtinfo/parser.h
--- a/libgui/src/qtinfo/parser.h
+++ b/libgui/src/qtinfo/parser.h
@@ -56,17 +56,17 @@ class parser
 
 public:
   parser (QObject *parent = 0);
   bool set_info_path (const QString& _info_path);
   QString get_info_path ();
   QString search_node (const QString& node);
   QString global_search (const QString& text, int maxFounds);
 
-  QString find_ref (const QString &name);
+  QString find_ref (const QString& name);
 
   /** Checks if this node is reference. If node is reference, it will be
    *  returned its position in text, else it will be returned -1.
     */
   int is_ref (const QString& node);
 
   /** Translates text of node to Html. If anchorPos is not -1, then anchor is
    *  inserted in that position.
diff --git a/libgui/src/qtinfo/webinfo.cc b/libgui/src/qtinfo/webinfo.cc
--- a/libgui/src/qtinfo/webinfo.cc
+++ b/libgui/src/qtinfo/webinfo.cc
@@ -119,17 +119,17 @@ webinfo::webinfo (QWidget *p)
           arg (tr ("The info file<p>%1<p>or compressed versions do not exist").
           arg (QString::fromStdString (Vinfo_file)));
       msg->setHtml (msg_text);
     }
 }
 
 // Add an action to a menu or the widget itself
 QAction*
-webinfo::add_action (QMenu *menu, const QIcon &icon, const QString &text,
+webinfo::add_action (QMenu *menu, const QIcon& icon, const QString& text,
                          const char *member)
 {
   QAction *a;
 
   if (menu)
     a = menu->addAction (icon, text, this, member);
   else
     {
@@ -282,17 +282,17 @@ webinfo::close_tab (int index)
 
       _tab_bar->removeTab (index);
     }
 
   tab_state_changed ();
 }
 
 void
-webinfo::load_ref (const QString &ref_name)
+webinfo::load_ref (const QString& ref_name)
 {
   QString text = _parser.find_ref (ref_name);
   if (text.length () > 0)
     {
       load_node (text);
     }
   else
     {
diff --git a/libgui/src/qtinfo/webinfo.h b/libgui/src/qtinfo/webinfo.h
--- a/libgui/src/qtinfo/webinfo.h
+++ b/libgui/src/qtinfo/webinfo.h
@@ -69,17 +69,17 @@ class webinfo : public QWidget
 {
   Q_OBJECT
 
 public:
 
   webinfo (QWidget *parent = 0);
   bool set_info_path (const QString& info_path);
   void load_node (const QString& node_name);
-  void load_ref (const QString &ref_name);
+  void load_ref (const QString& ref_name);
   void notice_settings (const QSettings *settings);
 
 public slots:
 
   void link_clicked (const QUrl& link);
   void current_tab_changed (int index);
   void close_tab (int index);
   void search ();
@@ -90,17 +90,17 @@ public slots:
   void pasteClipboard ();
   void selectAll ();
 
   void request_close_tab (bool);
   void request_close_other_tabs (bool);
 
 private:
 
-  QAction *add_action (QMenu *menu, const QIcon &icon, const QString &text,
+  QAction *add_action (QMenu *menu, const QIcon& icon, const QString& text,
                        const char *member);
   void tab_state_changed (void);
 
   QTextBrowser        *_text_browser;
   webinfo_tab_bar     *_tab_bar;
   QStackedWidget      *_stacked_widget;
   QLineEdit           *_search_line_edit;
   QCheckBox           *_search_check_box;
diff --git a/libgui/src/settings-dialog.cc b/libgui/src/settings-dialog.cc
--- a/libgui/src/settings-dialog.cc
+++ b/libgui/src/settings-dialog.cc
@@ -72,17 +72,17 @@ get_valid_lexer_styles (QsciLexer *lexer
       if ((lexer->description (actual_style)) != "")  // valid style
         styles[max_style++] = actual_style;
       actual_style++;
     }
   return max_style;
 }
 
 static void
-read_lexer_settings (Ui::settings_dialog * ui, QsciLexer *lexer,
+read_lexer_settings (Ui::settings_dialog *ui, QsciLexer *lexer,
                      QSettings *settings)
 {
   lexer->readSettings (*settings);
   int styles[MaxLexerStyles];  // array for saving valid styles
                                // (enum is not continuous)
   int max_style = get_valid_lexer_styles (lexer, styles);
   QGridLayout *style_grid = new QGridLayout ();
   QVector<QLabel*> description (max_style);
@@ -167,17 +167,17 @@ read_lexer_settings (Ui::settings_dialog
   scroll_area->setWidget (scroll_area_contents);
   ui->tabs_editor_lexers->addTab (scroll_area,lexer->language ());
 
   ui->tabs_editor_lexers->setCurrentIndex (
     settings->value ("settings/last_editor_styles_tab",0).toInt ());
 }
 
 static void
-write_lexer_settings (Ui::settings_dialog * ui, QsciLexer *lexer,
+write_lexer_settings (Ui::settings_dialog *ui, QsciLexer *lexer,
                       QSettings *settings)
 {
   QWidget *tab = ui->tabs_editor_lexers->
                  findChild <QWidget *>(QString (lexer->language ())+"_styles");
   int styles[MaxLexerStyles];  // array for saving valid styles
                                // (enum is not continuous)
   int max_style = get_valid_lexer_styles (lexer, styles);
   QFontComboBox *select_font;
diff --git a/libinterp/corefcn/bsxfun.cc b/libinterp/corefcn/bsxfun.cc
--- a/libinterp/corefcn/bsxfun.cc
+++ b/libinterp/corefcn/bsxfun.cc
@@ -225,17 +225,17 @@ maybe_optimized_builtin (const std::stri
     }
 
   return retval;
 }
 
 static bool
 maybe_update_column (octave_value& Ac, const octave_value& A,
                      const dim_vector& dva, const dim_vector& dvc,
-                     octave_idx_type i, octave_value_list &idx)
+                     octave_idx_type i, octave_value_list& idx)
 {
   octave_idx_type nd = dva.ndims ();
 
   if (i == 0)
     {
       idx(0) = octave_value (':');
       for (octave_idx_type j = 1; j < nd; j++)
         {
diff --git a/libinterp/corefcn/call-stack.cc b/libinterp/corefcn/call-stack.cc
--- a/libinterp/corefcn/call-stack.cc
+++ b/libinterp/corefcn/call-stack.cc
@@ -68,17 +68,17 @@ namespace octave
       }
     else
       retval = "<unknown>";
 
     return retval;
   }
 
   bool
-  call_stack::stack_frame::operator == (const call_stack::stack_frame &rhs) const
+  call_stack::stack_frame::operator == (const call_stack::stack_frame& rhs) const
   {
     if (this->line () != rhs.line ())
       return false;
     else if (this->column () != rhs.column ())
       return false;
     else if (this->fcn_file_name () != rhs.fcn_file_name ())
       return false;
     else if (this->fcn_name () != rhs.fcn_name ())
diff --git a/libinterp/corefcn/call-stack.h b/libinterp/corefcn/call-stack.h
--- a/libinterp/corefcn/call-stack.h
+++ b/libinterp/corefcn/call-stack.h
@@ -68,17 +68,17 @@ namespace octave
       int line (void) const { return m_line; }
 
       int column (void) const { return m_column; }
 
       std::string fcn_file_name (void) const;
 
       std::string fcn_name (bool print_subfn = true) const;
 
-      bool operator == (const stack_frame &rhs) const;
+      bool operator == (const stack_frame& rhs) const;
 
     private:
 
       octave_function *m_fcn;
       int m_line;
       int m_column;
       symbol_table::scope_id m_scope;
       symbol_table::context_id m_context;
diff --git a/libinterp/corefcn/fft.cc b/libinterp/corefcn/fft.cc
--- a/libinterp/corefcn/fft.cc
+++ b/libinterp/corefcn/fft.cc
@@ -35,17 +35,17 @@ along with Octave; see the file COPYING.
 
 #if defined (HAVE_FFTW)
 #  define FFTSRC "@sc{fftw}"
 #else
 #  define FFTSRC "@sc{fftpack}"
 #endif
 
 static octave_value
-do_fft (const octave_value_list &args, const char *fcn, int type)
+do_fft (const octave_value_list& args, const char *fcn, int type)
 {
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 3)
     print_usage ();
 
   octave_value retval;
   octave_value arg = args(0);
diff --git a/libinterp/corefcn/fft2.cc b/libinterp/corefcn/fft2.cc
--- a/libinterp/corefcn/fft2.cc
+++ b/libinterp/corefcn/fft2.cc
@@ -37,17 +37,17 @@ along with Octave; see the file COPYING.
 
 #if defined (HAVE_FFTW)
 #  define FFTSRC "@sc{fftw}"
 #else
 #  define FFTSRC "@sc{fftpack}"
 #endif
 
 static octave_value
-do_fft2 (const octave_value_list &args, const char *fcn, int type)
+do_fft2 (const octave_value_list& args, const char *fcn, int type)
 {
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 3)
     print_usage ();
 
   octave_value retval;
   octave_value arg = args(0);
diff --git a/libinterp/corefcn/fftn.cc b/libinterp/corefcn/fftn.cc
--- a/libinterp/corefcn/fftn.cc
+++ b/libinterp/corefcn/fftn.cc
@@ -36,17 +36,17 @@ along with Octave; see the file COPYING.
 
 #if defined (HAVE_FFTW)
 #  define FFTSRC "@sc{fftw}"
 #else
 #  define FFTSRC "@sc{fftpack}"
 #endif
 
 static octave_value
-do_fftn (const octave_value_list &args, const char *fcn, int type)
+do_fftn (const octave_value_list& args, const char *fcn, int type)
 {
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
 
   octave_value retval;
   octave_value arg = args(0);
diff --git a/libinterp/corefcn/gl-render.cc b/libinterp/corefcn/gl-render.cc
--- a/libinterp/corefcn/gl-render.cc
+++ b/libinterp/corefcn/gl-render.cc
@@ -2827,17 +2827,17 @@ namespace octave
     panic_impossible ();
 
 #endif
   }
 
   // FIXME: global optimization (rendering, data structures...),
   // there is probably a smarter/faster/less-memory-consuming way to do this.
   void
-  opengl_renderer::draw_patch (const patch::properties &props)
+  opengl_renderer::draw_patch (const patch::properties& props)
   {
 #if defined (HAVE_OPENGL)
 
     // Do not render if the patch has incoherent data
     std::string msg;
     if (props.has_bad_data (msg))
       {
         warning ("opengl_renderer: %s.  Not rendering.", msg.c_str ());
@@ -3297,17 +3297,17 @@ namespace octave
     // objects is supposed to be impossible if OpenGL is not available.
 
     panic_impossible ();
 
 #endif
   }
 
   void
-  opengl_renderer::draw_light (const light::properties &props)
+  opengl_renderer::draw_light (const light::properties& props)
   {
 #if defined (HAVE_OPENGL)
 
     // enable light source
     glEnable (current_light);
 
     // light position
     float pos[4] = { 0, 0, 0, 0 }; // X,Y,Z,infinite/local
@@ -3334,17 +3334,17 @@ namespace octave
     // objects is supposed to be impossible if OpenGL is not available.
 
     panic_impossible ();
 
 #endif
   }
 
   void
-  opengl_renderer::draw_hggroup (const hggroup::properties &props)
+  opengl_renderer::draw_hggroup (const hggroup::properties& props)
   {
     draw (props.get_children ());
   }
 
   void
   opengl_renderer::draw_text (const text::properties& props)
   {
 #if defined (HAVE_OPENGL)
diff --git a/libinterp/corefcn/graphics.cc b/libinterp/corefcn/graphics.cc
--- a/libinterp/corefcn/graphics.cc
+++ b/libinterp/corefcn/graphics.cc
@@ -3344,17 +3344,17 @@ base_graphics_object::remove_all_listene
       catch (const octave::execution_exception&)
         {
           octave::interpreter::recover_from_exception ();
         }
     }
 }
 
 void
-base_graphics_object::build_user_defaults_map (property_list::pval_map_type &def, const std::string go_name) const
+base_graphics_object::build_user_defaults_map (property_list::pval_map_type& def, const std::string go_name) const
 {
   property_list local_defaults = get_defaults_list ();
   const auto it = local_defaults.find (go_name);
 
   if (it != local_defaults.end ())
     {
       property_list::pval_map_type pval_lst = it->second;
       for (const auto& prop_val : pval_lst)
diff --git a/libinterp/corefcn/graphics.in.h b/libinterp/corefcn/graphics.in.h
--- a/libinterp/corefcn/graphics.in.h
+++ b/libinterp/corefcn/graphics.in.h
@@ -2779,17 +2779,17 @@ public:
 
   virtual void override_defaults (base_graphics_object& obj)
   {
     if (! valid_object ())
       error ("base_graphics_object::override_defaults: invalid graphics object");
     get_properties ().override_defaults (obj);
   }
 
-  void build_user_defaults_map (property_list::pval_map_type &def,
+  void build_user_defaults_map (property_list::pval_map_type& def,
                                 const std::string go_name) const;
 
   virtual void set_from_list (property_list& plist)
   {
     if (! valid_object ())
       error ("base_graphics_object::set_from_list: invalid graphics object");
 
     get_properties ().set_from_list (*this, plist);
@@ -3044,17 +3044,17 @@ public:
     rep->override_defaults (obj);
   }
 
   void override_defaults (void)
   {
     rep->override_defaults (*rep);
   }
 
-  void build_user_defaults_map (property_list::pval_map_type &def,
+  void build_user_defaults_map (property_list::pval_map_type& def,
                                 const std::string go_name) const
   {
     rep->build_user_defaults_map (def, go_name);
   }
 
   void set_from_list (property_list& plist) { rep->set_from_list (plist); }
 
   void set (const caseless_str& name, const octave_value& val)
@@ -5130,17 +5130,17 @@ class OCTINTERP_API patch : public base_
 public:
   class OCTINTERP_API properties : public base_properties
   {
   public:
     octave_value get_color_data (void) const;
 
     // Matlab allows incoherent data to be stored into patch properties.
     // The patch should then be ignored by the renderer.
-    bool has_bad_data (std::string &msg) const
+    bool has_bad_data (std::string& msg) const
     {
       msg = bad_data_msg;
       return ! msg.empty ();
     }
 
     bool is_aliminclude (void) const
     { return (aliminclude.is_on () && alphadatamapping.is ("scaled")); }
     std::string get_aliminclude (void) const
diff --git a/libinterp/corefcn/input.cc b/libinterp/corefcn/input.cc
--- a/libinterp/corefcn/input.cc
+++ b/libinterp/corefcn/input.cc
@@ -494,17 +494,17 @@ generate_completion (const std::string& 
             }
         }
     }
 
   return retval;
 }
 
 static std::string
-quoting_filename (const std::string &text, int, char quote)
+quoting_filename (const std::string& text, int, char quote)
 {
   if (quote)
     return text;
   else
     return (std::string ("'") + text);
 }
 
 // Try to parse a partial command line in reverse, excluding trailing TEXT.
diff --git a/libinterp/corefcn/load-save.cc b/libinterp/corefcn/load-save.cc
--- a/libinterp/corefcn/load-save.cc
+++ b/libinterp/corefcn/load-save.cc
@@ -291,17 +291,17 @@ get_file_format (std::istream& file, con
         }
     }
 
   return retval;
 }
 
 static load_save_format
 get_file_format (const std::string& fname, const std::string& orig_fname,
-                 bool &use_zlib, bool quiet = false)
+                 bool& use_zlib, bool quiet = false)
 {
   load_save_format retval = LS_UNKNOWN;
 
 #if defined (HAVE_HDF5)
   // check this before we open the file
   if (H5Fis_hdf5 (fname.c_str ()) > 0)
     return LS_HDF5;
 #endif
@@ -1011,19 +1011,19 @@ save_vars (std::ostream& os, const std::
 
       saved++;
     }
 
   return saved;
 }
 
 static string_vector
-parse_save_options (const string_vector &argv,
-                    load_save_format &format, bool &append,
-                    bool &save_as_floats, bool &use_zlib)
+parse_save_options (const string_vector& argv,
+                    load_save_format& format, bool& append,
+                    bool& save_as_floats, bool& use_zlib)
 {
 #if ! defined (HAVE_ZLIB)
   octave_unused_parameter (use_zlib);
 #endif
 
   string_vector retval;
   int argc = argv.numel ();
 
@@ -1129,18 +1129,18 @@ parse_save_options (const string_vector 
       else
         warning ("save: \"-tabs\" option only has an effect with \"-ascii\"");
     }
 
   return retval;
 }
 
 static string_vector
-parse_save_options (const std::string &arg, load_save_format &format,
-                    bool &append, bool &save_as_floats, bool &use_zlib)
+parse_save_options (const std::string& arg, load_save_format& format,
+                    bool& append, bool& save_as_floats, bool& use_zlib)
 {
   std::istringstream is (arg);
   std::string str;
   string_vector argv;
 
   while (! is.eof ())
     {
       is >> str;
diff --git a/libinterp/corefcn/ls-hdf5.cc b/libinterp/corefcn/ls-hdf5.cc
--- a/libinterp/corefcn/ls-hdf5.cc
+++ b/libinterp/corefcn/ls-hdf5.cc
@@ -945,17 +945,17 @@ save_hdf5_empty (octave_hdf5_id loc_id, 
 #endif
 }
 
 // Load an empty matrix, if needed.  Returns
 //    > 0  loaded empty matrix, dimensions returned
 //    = 0  Not an empty matrix; did nothing
 //    < 0  Error condition
 int
-load_hdf5_empty (octave_hdf5_id loc_id, const char *name, dim_vector &d)
+load_hdf5_empty (octave_hdf5_id loc_id, const char *name, dim_vector& d)
 {
 #if defined (HAVE_HDF5)
 
   if (! hdf5_check_attr (loc_id, "OCTAVE_EMPTY_MATRIX"))
     return 0;
 
   hsize_t hdims, maxdims;
 #if defined (HAVE_HDF5_18)
diff --git a/libinterp/corefcn/ls-hdf5.h b/libinterp/corefcn/ls-hdf5.h
--- a/libinterp/corefcn/ls-hdf5.h
+++ b/libinterp/corefcn/ls-hdf5.h
@@ -130,17 +130,17 @@ extern OCTINTERP_API bool
 add_hdf5_data (octave_hdf5_id loc_id, const octave_value& tc,
                const std::string& name, const std::string& doc,
                bool mark_as_global, bool save_as_floats);
 
 extern OCTINTERP_API int
 save_hdf5_empty (octave_hdf5_id loc_id, const char *name, const dim_vector d);
 
 extern OCTINTERP_API int
-load_hdf5_empty (octave_hdf5_id loc_id, const char *name, dim_vector &d);
+load_hdf5_empty (octave_hdf5_id loc_id, const char *name, dim_vector& d);
 
 extern OCTINTERP_API std::string
 read_hdf5_data (std::istream& is,  const std::string& filename, bool& global,
                 octave_value& tc, std::string& doc,
                 const string_vector& argv, int argv_idx, int argc);
 
 extern OCTINTERP_API bool
 save_hdf5_data (std::ostream& os, const octave_value& tc,
diff --git a/libinterp/corefcn/octave-link.h b/libinterp/corefcn/octave-link.h
--- a/libinterp/corefcn/octave-link.h
+++ b/libinterp/corefcn/octave-link.h
@@ -501,12 +501,12 @@ protected:
                                      const std::string& file, int line,
                                      const std::string& cond) = 0;
 
   virtual void do_set_default_prompts (std::string& ps1, std::string& ps2,
                                        std::string& ps4) = 0;
 
   virtual void do_show_preferences (void) = 0;
 
-  virtual void do_show_doc (const std::string &file) = 0;
+  virtual void do_show_doc (const std::string& file) = 0;
 };
 
 #endif
diff --git a/libinterp/corefcn/pr-output.cc b/libinterp/corefcn/pr-output.cc
--- a/libinterp/corefcn/pr-output.cc
+++ b/libinterp/corefcn/pr-output.cc
@@ -553,17 +553,17 @@ pr_min_internal (const Matrix& m)
     result = 0.0;
 
   return result;
 }
 
 // FIXME: it would be nice to share more code among these functions,..
 
 static void
-set_real_format (int digits, bool inf_or_nan, bool int_only, int &fw)
+set_real_format (int digits, bool inf_or_nan, bool int_only, int& fw)
 {
   static float_format fmt;
 
   int prec = Voutput_precision;
 
   int ld, rd;
 
   if (rat_format)
diff --git a/libinterp/corefcn/regexp.cc b/libinterp/corefcn/regexp.cc
--- a/libinterp/corefcn/regexp.cc
+++ b/libinterp/corefcn/regexp.cc
@@ -325,18 +325,18 @@ parse_options (octave::regexp::opts& opt
                || str.find ("split", 0) == 0)
         extra_args = true;
       else
         error ("%s: unrecognized option", who.c_str ());
     }
 }
 
 static octave_value_list
-octregexp (const octave_value_list &args, int nargout,
-           const std::string &who, bool case_insensitive = false)
+octregexp (const octave_value_list& args, int nargout,
+           const std::string& who, bool case_insensitive = false)
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   // Make sure we have string, pattern
   const std::string buffer = args(0).string_value ();
 
@@ -511,18 +511,18 @@ octregexp (const octave_value_list &args
 
       retval = new_retval;
     }
 
   return retval;
 }
 
 static octave_value_list
-octcellregexp (const octave_value_list &args, int nargout,
-               const std::string &who, bool case_insensitive = false)
+octcellregexp (const octave_value_list& args, int nargout,
+               const std::string& who, bool case_insensitive = false)
 {
   octave_value_list retval;
 
   if (args(0).is_cell ())
     {
       OCTAVE_LOCAL_BUFFER (Cell, newretval, nargout);
       octave_value_list new_args = args;
       Cell cellstr = args(0).cell_value ();
@@ -1276,17 +1276,17 @@ for details on the syntax of the search 
 %!assert (regexpi ({'asdfg-dfd';'-dfd-dfd-';'qasfdfdaq'}, {'-';'f';'q'}), {6;[3,7];[1,9]})
 %!assert (regexpi ('Strings', {'t', 's'}), {2, [1, 7]})
 
 %!assert (regexpi ("\n", '\n'), 1)
 %!assert (regexpi ("\n", "\n"), 1)
 */
 
 static octave_value
-octregexprep (const octave_value_list &args, const std::string &who)
+octregexprep (const octave_value_list& args, const std::string& who)
 {
   int nargin = args.length ();
 
   // Make sure we have string, pattern, replacement
   const std::string buffer = args(0).string_value ();
 
   std::string pattern = args(1).string_value ();
 
diff --git a/libinterp/corefcn/sparse-xdiv.cc b/libinterp/corefcn/sparse-xdiv.cc
--- a/libinterp/corefcn/sparse-xdiv.cc
+++ b/libinterp/corefcn/sparse-xdiv.cc
@@ -125,17 +125,17 @@ INSTANTIATE_MX_DIV_CONFORM (SparseComple
 //                         +---+----+----+----+
 //   diagonal matrix                |  9 | 11 |
 //                                  +----+----+
 //   complex diag. matrix           | 10 | 12 |
 //                                  +----+----+
 
 // -*- 1 -*-
 Matrix
-xdiv (const Matrix& a, const SparseMatrix& b, MatrixType &typ)
+xdiv (const Matrix& a, const SparseMatrix& b, MatrixType& typ)
 {
   if (! mx_div_conform (a, b))
     return Matrix ();
 
   Matrix atmp = a.transpose ();
   SparseMatrix btmp = b.transpose ();
   MatrixType btyp = typ.transpose ();
 
@@ -145,17 +145,17 @@ xdiv (const Matrix& a, const SparseMatri
                               solve_singularity_warning);
 
   typ = btyp.transpose ();
   return result.transpose ();
 }
 
 // -*- 2 -*-
 ComplexMatrix
-xdiv (const Matrix& a, const SparseComplexMatrix& b, MatrixType &typ)
+xdiv (const Matrix& a, const SparseComplexMatrix& b, MatrixType& typ)
 {
   if (! mx_div_conform (a, b))
     return ComplexMatrix ();
 
   Matrix atmp = a.transpose ();
   SparseComplexMatrix btmp = b.hermitian ();
   MatrixType btyp = typ.transpose ();
 
@@ -165,17 +165,17 @@ xdiv (const Matrix& a, const SparseCompl
     = btmp.solve (btyp, atmp, info, rcond, solve_singularity_warning);
 
   typ = btyp.transpose ();
   return result.hermitian ();
 }
 
 // -*- 3 -*-
 ComplexMatrix
-xdiv (const ComplexMatrix& a, const SparseMatrix& b, MatrixType &typ)
+xdiv (const ComplexMatrix& a, const SparseMatrix& b, MatrixType& typ)
 {
   if (! mx_div_conform (a, b))
     return ComplexMatrix ();
 
   ComplexMatrix atmp = a.hermitian ();
   SparseMatrix btmp = b.transpose ();
   MatrixType btyp = typ.transpose ();
 
@@ -185,17 +185,17 @@ xdiv (const ComplexMatrix& a, const Spar
     = btmp.solve (btyp, atmp, info, rcond, solve_singularity_warning);
 
   typ = btyp.transpose ();
   return result.hermitian ();
 }
 
 // -*- 4 -*-
 ComplexMatrix
-xdiv (const ComplexMatrix& a, const SparseComplexMatrix& b, MatrixType &typ)
+xdiv (const ComplexMatrix& a, const SparseComplexMatrix& b, MatrixType& typ)
 {
   if (! mx_div_conform (a, b))
     return ComplexMatrix ();
 
   ComplexMatrix atmp = a.hermitian ();
   SparseComplexMatrix btmp = b.hermitian ();
   MatrixType btyp = typ.transpose ();
 
@@ -205,17 +205,17 @@ xdiv (const ComplexMatrix& a, const Spar
     = btmp.solve (btyp, atmp, info, rcond, solve_singularity_warning);
 
   typ = btyp.transpose ();
   return result.hermitian ();
 }
 
 // -*- 5 -*-
 SparseMatrix
-xdiv (const SparseMatrix& a, const SparseMatrix& b, MatrixType &typ)
+xdiv (const SparseMatrix& a, const SparseMatrix& b, MatrixType& typ)
 {
   if (! mx_div_conform (a, b))
     return SparseMatrix ();
 
   SparseMatrix atmp = a.transpose ();
   SparseMatrix btmp = b.transpose ();
   MatrixType btyp = typ.transpose ();
 
@@ -225,17 +225,17 @@ xdiv (const SparseMatrix& a, const Spars
                                     solve_singularity_warning);
 
   typ = btyp.transpose ();
   return result.transpose ();
 }
 
 // -*- 6 -*-
 SparseComplexMatrix
-xdiv (const SparseMatrix& a, const SparseComplexMatrix& b, MatrixType &typ)
+xdiv (const SparseMatrix& a, const SparseComplexMatrix& b, MatrixType& typ)
 {
   if (! mx_div_conform (a, b))
     return SparseComplexMatrix ();
 
   SparseMatrix atmp = a.transpose ();
   SparseComplexMatrix btmp = b.hermitian ();
   MatrixType btyp = typ.transpose ();
 
@@ -245,17 +245,17 @@ xdiv (const SparseMatrix& a, const Spars
     = btmp.solve (btyp, atmp, info, rcond, solve_singularity_warning);
 
   typ = btyp.transpose ();
   return result.hermitian ();
 }
 
 // -*- 7 -*-
 SparseComplexMatrix
-xdiv (const SparseComplexMatrix& a, const SparseMatrix& b, MatrixType &typ)
+xdiv (const SparseComplexMatrix& a, const SparseMatrix& b, MatrixType& typ)
 {
   if (! mx_div_conform (a, b))
     return SparseComplexMatrix ();
 
   SparseComplexMatrix atmp = a.hermitian ();
   SparseMatrix btmp = b.transpose ();
   MatrixType btyp = typ.transpose ();
 
@@ -266,17 +266,17 @@ xdiv (const SparseComplexMatrix& a, cons
 
   typ = btyp.transpose ();
   return result.hermitian ();
 }
 
 // -*- 8 -*-
 SparseComplexMatrix
 xdiv (const SparseComplexMatrix& a, const SparseComplexMatrix& b,
-      MatrixType &typ)
+      MatrixType& typ)
 {
   if (! mx_div_conform (a, b))
     return SparseComplexMatrix ();
 
   SparseComplexMatrix atmp = a.hermitian ();
   SparseComplexMatrix btmp = b.hermitian ();
   MatrixType btyp = typ.transpose ();
 
@@ -456,102 +456,102 @@ x_el_div (const Complex a, const SparseC
 //                         +---+----+----+----+
 //   sparse matrix         | 3 |  7 |  9 | 11 |
 //                         +---+----+----+----+
 //   sparse complex_matrix | 4 |  8 | 10 | 12 |
 //                         +---+----+----+----+
 
 // -*- 1 -*-
 Matrix
-xleftdiv (const SparseMatrix& a, const Matrix& b, MatrixType &typ)
+xleftdiv (const SparseMatrix& a, const Matrix& b, MatrixType& typ)
 {
   if (! mx_leftdiv_conform (a, b))
     return Matrix ();
 
   octave_idx_type info;
   double rcond = 0.0;
   return a.solve (typ, b, info, rcond, solve_singularity_warning);
 }
 
 // -*- 2 -*-
 ComplexMatrix
-xleftdiv (const SparseMatrix& a, const ComplexMatrix& b, MatrixType &typ)
+xleftdiv (const SparseMatrix& a, const ComplexMatrix& b, MatrixType& typ)
 {
   if (! mx_leftdiv_conform (a, b))
     return ComplexMatrix ();
 
   octave_idx_type info;
   double rcond = 0.0;
   return a.solve (typ, b, info, rcond, solve_singularity_warning);
 }
 
 // -*- 3 -*-
 SparseMatrix
-xleftdiv (const SparseMatrix& a, const SparseMatrix& b, MatrixType &typ)
+xleftdiv (const SparseMatrix& a, const SparseMatrix& b, MatrixType& typ)
 {
   if (! mx_leftdiv_conform (a, b))
     return SparseMatrix ();
 
   octave_idx_type info;
   double rcond = 0.0;
   return a.solve (typ, b, info, rcond, solve_singularity_warning);
 }
 
 // -*- 4 -*-
 SparseComplexMatrix
-xleftdiv (const SparseMatrix& a, const SparseComplexMatrix& b, MatrixType &typ)
+xleftdiv (const SparseMatrix& a, const SparseComplexMatrix& b, MatrixType& typ)
 {
   if (! mx_leftdiv_conform (a, b))
     return SparseComplexMatrix ();
 
   octave_idx_type info;
   double rcond = 0.0;
   return a.solve (typ, b, info, rcond, solve_singularity_warning);
 }
 
 // -*- 5 -*-
 ComplexMatrix
-xleftdiv (const SparseComplexMatrix& a, const Matrix& b, MatrixType &typ)
+xleftdiv (const SparseComplexMatrix& a, const Matrix& b, MatrixType& typ)
 {
   if (! mx_leftdiv_conform (a, b))
     return ComplexMatrix ();
 
   octave_idx_type info;
   double rcond = 0.0;
   return a.solve (typ, b, info, rcond, solve_singularity_warning);
 }
 
 // -*- 6 -*-
 ComplexMatrix
-xleftdiv (const SparseComplexMatrix& a, const ComplexMatrix& b, MatrixType &typ)
+xleftdiv (const SparseComplexMatrix& a, const ComplexMatrix& b, MatrixType& typ)
 {
   if (! mx_leftdiv_conform (a, b))
     return ComplexMatrix ();
 
   octave_idx_type info;
   double rcond = 0.0;
   return a.solve (typ, b, info, rcond, solve_singularity_warning);
 }
 
 // -*- 7 -*-
 SparseComplexMatrix
-xleftdiv (const SparseComplexMatrix& a, const SparseMatrix& b, MatrixType &typ)
+xleftdiv (const SparseComplexMatrix& a, const SparseMatrix& b, MatrixType& typ)
 {
   if (! mx_leftdiv_conform (a, b))
     return SparseComplexMatrix ();
 
   octave_idx_type info;
   double rcond = 0.0;
   return a.solve (typ, b, info, rcond, solve_singularity_warning);
 }
 
 // -*- 8 -*-
 SparseComplexMatrix
 xleftdiv (const SparseComplexMatrix& a, const SparseComplexMatrix& b,
-          MatrixType &typ)
+          MatrixType& typ)
 {
   if (! mx_leftdiv_conform (a, b))
     return SparseComplexMatrix ();
 
   octave_idx_type info;
   double rcond = 0.0;
   return a.solve (typ, b, info, rcond, solve_singularity_warning);
 }
diff --git a/libinterp/corefcn/sparse-xdiv.h b/libinterp/corefcn/sparse-xdiv.h
--- a/libinterp/corefcn/sparse-xdiv.h
+++ b/libinterp/corefcn/sparse-xdiv.h
@@ -29,67 +29,67 @@ along with Octave; see the file COPYING.
 #include "oct-cmplx.h"
 #include "MatrixType.h"
 
 class DiagMatrix;
 class ComplexDiagMatrix;
 class SparseMatrix;
 class SparseComplexMatrix;
 
-extern Matrix xdiv (const Matrix& a, const SparseMatrix& b, MatrixType &typ);
+extern Matrix xdiv (const Matrix& a, const SparseMatrix& b, MatrixType& typ);
 extern ComplexMatrix xdiv (const Matrix& a, const SparseComplexMatrix& b,
-                           MatrixType &typ);
+                           MatrixType& typ);
 extern ComplexMatrix xdiv (const ComplexMatrix& a, const SparseMatrix& b,
-                           MatrixType &typ);
+                           MatrixType& typ);
 extern ComplexMatrix xdiv (const ComplexMatrix& a,
-                           const SparseComplexMatrix& b, MatrixType &typ);
+                           const SparseComplexMatrix& b, MatrixType& typ);
 
 extern SparseMatrix xdiv (const SparseMatrix& a, const SparseMatrix& b,
-                          MatrixType &typ);
+                          MatrixType& typ);
 extern SparseComplexMatrix xdiv (const SparseMatrix& a,
-                                 const SparseComplexMatrix& b, MatrixType &typ);
+                                 const SparseComplexMatrix& b, MatrixType& typ);
 extern SparseComplexMatrix xdiv (const SparseComplexMatrix& a,
-                                 const SparseMatrix& b, MatrixType &typ);
+                                 const SparseMatrix& b, MatrixType& typ);
 extern SparseComplexMatrix xdiv (const SparseComplexMatrix& a,
-                                 const SparseComplexMatrix& b, MatrixType &typ);
+                                 const SparseComplexMatrix& b, MatrixType& typ);
 
 extern SparseMatrix xdiv (const SparseMatrix& a,
-                          const DiagMatrix& b, MatrixType &typ);
+                          const DiagMatrix& b, MatrixType& typ);
 extern SparseComplexMatrix xdiv (const SparseMatrix& a,
-                                 const ComplexDiagMatrix& b, MatrixType &typ);
+                                 const ComplexDiagMatrix& b, MatrixType& typ);
 extern SparseComplexMatrix xdiv (const SparseComplexMatrix& a,
-                                 const DiagMatrix& b, MatrixType &typ);
+                                 const DiagMatrix& b, MatrixType& typ);
 extern SparseComplexMatrix xdiv (const SparseComplexMatrix& a,
-                                 const ComplexDiagMatrix& b, MatrixType &typ);
+                                 const ComplexDiagMatrix& b, MatrixType& typ);
 
 extern Matrix x_el_div (double a, const SparseMatrix& b);
 extern ComplexMatrix x_el_div (double a, const SparseComplexMatrix& b);
 extern ComplexMatrix x_el_div (const Complex a, const SparseMatrix& b);
 extern ComplexMatrix x_el_div (const Complex a,
                                const SparseComplexMatrix& b);
 
 extern Matrix xleftdiv (const SparseMatrix& a, const Matrix& b,
                         MatrixType& typ);
 extern ComplexMatrix xleftdiv (const SparseMatrix& a, const ComplexMatrix& b,
-                               MatrixType &typ);
+                               MatrixType& typ);
 extern ComplexMatrix xleftdiv (const SparseComplexMatrix& a, const Matrix& b,
-                               MatrixType &typ);
+                               MatrixType& typ);
 extern ComplexMatrix xleftdiv (const SparseComplexMatrix& a,
-                               const ComplexMatrix& b, MatrixType &typ);
+                               const ComplexMatrix& b, MatrixType& typ);
 
 extern SparseMatrix xleftdiv (const SparseMatrix& a, const SparseMatrix& b,
-                              MatrixType &typ);
+                              MatrixType& typ);
 extern SparseComplexMatrix xleftdiv (const SparseMatrix& a,
                                      const SparseComplexMatrix& b,
-                                     MatrixType &typ);
+                                     MatrixType& typ);
 extern SparseComplexMatrix xleftdiv (const SparseComplexMatrix& a,
-                                     const SparseMatrix& b, MatrixType &typ);
+                                     const SparseMatrix& b, MatrixType& typ);
 extern SparseComplexMatrix xleftdiv (const SparseComplexMatrix& a,
                                      const SparseComplexMatrix& b,
-                                     MatrixType &typ);
+                                     MatrixType& typ);
 
 extern SparseMatrix xleftdiv (const DiagMatrix&, const SparseMatrix&,
                               MatrixType&);
 extern SparseComplexMatrix xleftdiv (const ComplexDiagMatrix&,
                                      const SparseMatrix&,
                                      MatrixType&);
 extern SparseComplexMatrix xleftdiv (const DiagMatrix&,
                                      const SparseComplexMatrix&,
diff --git a/libinterp/corefcn/symtab.cc b/libinterp/corefcn/symtab.cc
--- a/libinterp/corefcn/symtab.cc
+++ b/libinterp/corefcn/symtab.cc
@@ -1670,17 +1670,17 @@ symbol_table::do_update_nest (void)
   if (nest_parent || nest_children.size ())
     curr_fcn->mark_as_nested_function ();
 
   if (nest_parent)
     {
       // fix bad symbol_records
       for (auto& nm_sr : table)
         {
-          symbol_record &ours = nm_sr.second;
+          symbol_record& ours = nm_sr.second;
           symbol_record parents;
           if (! ours.is_formal ()
               && nest_parent->look_nonlocal (nm_sr.first, parents))
             {
               if (ours.is_global () || ours.is_persistent ())
                 error ("global and persistent may only be used in the topmost level in which a nested variable is used");
 
               if (! ours.is_formal ())
diff --git a/libinterp/corefcn/xdiv.cc b/libinterp/corefcn/xdiv.cc
--- a/libinterp/corefcn/xdiv.cc
+++ b/libinterp/corefcn/xdiv.cc
@@ -113,68 +113,68 @@ INSTANTIATE_MX_DIV_CONFORM (ComplexMatri
 //            +--   +---+----+
 //   matrix         | 1 |  3 |
 //                  +---+----+
 //   complex_matrix | 2 |  4 |
 //                  +---+----+
 
 // -*- 1 -*-
 Matrix
-xdiv (const Matrix& a, const Matrix& b, MatrixType &typ)
+xdiv (const Matrix& a, const Matrix& b, MatrixType& typ)
 {
   if (! mx_div_conform (a, b))
     return Matrix ();
 
   octave_idx_type info;
   double rcond = 0.0;
 
   Matrix result
     = b.solve (typ, a.transpose (), info, rcond,
                solve_singularity_warning, true, blas_trans);
 
   return result.transpose ();
 }
 
 // -*- 2 -*-
 ComplexMatrix
-xdiv (const Matrix& a, const ComplexMatrix& b, MatrixType &typ)
+xdiv (const Matrix& a, const ComplexMatrix& b, MatrixType& typ)
 {
   if (! mx_div_conform (a, b))
     return ComplexMatrix ();
 
   octave_idx_type info;
   double rcond = 0.0;
 
   ComplexMatrix result
     = b.solve (typ, a.transpose (), info, rcond,
                solve_singularity_warning, true, blas_trans);
 
   return result.transpose ();
 }
 
 // -*- 3 -*-
 ComplexMatrix
-xdiv (const ComplexMatrix& a, const Matrix& b, MatrixType &typ)
+xdiv (const ComplexMatrix& a, const Matrix& b, MatrixType& typ)
 {
   if (! mx_div_conform (a, b))
     return ComplexMatrix ();
 
   octave_idx_type info;
   double rcond = 0.0;
 
   ComplexMatrix result
     = b.solve (typ, a.transpose (), info, rcond,
                solve_singularity_warning, true, blas_trans);
 
   return result.transpose ();
 }
 
 // -*- 4 -*-
 ComplexMatrix
-xdiv (const ComplexMatrix& a, const ComplexMatrix& b, MatrixType &typ)
+xdiv (const ComplexMatrix& a, const ComplexMatrix& b, MatrixType& typ)
 {
   if (! mx_div_conform (a, b))
     return ComplexMatrix ();
 
   octave_idx_type info;
   double rcond = 0.0;
 
   ComplexMatrix result
@@ -336,57 +336,57 @@ x_el_div (const Complex a, const Complex
 //            +--   +---+----+
 //   matrix         | 1 |  3 |
 //                  +---+----+
 //   complex_matrix | 2 |  4 |
 //                  +---+----+
 
 // -*- 1 -*-
 Matrix
-xleftdiv (const Matrix& a, const Matrix& b, MatrixType &typ,
+xleftdiv (const Matrix& a, const Matrix& b, MatrixType& typ,
           blas_trans_type transt)
 {
   if (! mx_leftdiv_conform (a, b, transt))
     return Matrix ();
 
   octave_idx_type info;
   double rcond = 0.0;
   return a.solve (typ, b, info, rcond, solve_singularity_warning, true, transt);
 }
 
 // -*- 2 -*-
 ComplexMatrix
-xleftdiv (const Matrix& a, const ComplexMatrix& b, MatrixType &typ,
+xleftdiv (const Matrix& a, const ComplexMatrix& b, MatrixType& typ,
           blas_trans_type transt)
 {
   if (! mx_leftdiv_conform (a, b, transt))
     return ComplexMatrix ();
 
   octave_idx_type info;
   double rcond = 0.0;
 
   return a.solve (typ, b, info, rcond, solve_singularity_warning, true, transt);
 }
 
 // -*- 3 -*-
 ComplexMatrix
-xleftdiv (const ComplexMatrix& a, const Matrix& b, MatrixType &typ,
+xleftdiv (const ComplexMatrix& a, const Matrix& b, MatrixType& typ,
           blas_trans_type transt)
 {
   if (! mx_leftdiv_conform (a, b, transt))
     return ComplexMatrix ();
 
   octave_idx_type info;
   double rcond = 0.0;
   return a.solve (typ, b, info, rcond, solve_singularity_warning, true, transt);
 }
 
 // -*- 4 -*-
 ComplexMatrix
-xleftdiv (const ComplexMatrix& a, const ComplexMatrix& b, MatrixType &typ,
+xleftdiv (const ComplexMatrix& a, const ComplexMatrix& b, MatrixType& typ,
           blas_trans_type transt)
 {
   if (! mx_leftdiv_conform (a, b, transt))
     return ComplexMatrix ();
 
   octave_idx_type info;
   double rcond = 0.0;
   return a.solve (typ, b, info, rcond, solve_singularity_warning, true, transt);
@@ -414,68 +414,68 @@ INSTANTIATE_MX_DIV_CONFORM (FloatComplex
 //            +--   +---+----+
 //   matrix         | 1 |  3 |
 //                  +---+----+
 //   complex_matrix | 2 |  4 |
 //                  +---+----+
 
 // -*- 1 -*-
 FloatMatrix
-xdiv (const FloatMatrix& a, const FloatMatrix& b, MatrixType &typ)
+xdiv (const FloatMatrix& a, const FloatMatrix& b, MatrixType& typ)
 {
   if (! mx_div_conform (a, b))
     return FloatMatrix ();
 
   octave_idx_type info;
   float rcond = 0.0;
 
   FloatMatrix result
     = b.solve (typ, a.transpose (), info, rcond,
                solve_singularity_warning, true, blas_trans);
 
   return result.transpose ();
 }
 
 // -*- 2 -*-
 FloatComplexMatrix
-xdiv (const FloatMatrix& a, const FloatComplexMatrix& b, MatrixType &typ)
+xdiv (const FloatMatrix& a, const FloatComplexMatrix& b, MatrixType& typ)
 {
   if (! mx_div_conform (a, b))
     return FloatComplexMatrix ();
 
   octave_idx_type info;
   float rcond = 0.0;
 
   FloatComplexMatrix result
     = b.solve (typ, a.transpose (), info, rcond,
                solve_singularity_warning, true, blas_trans);
 
   return result.transpose ();
 }
 
 // -*- 3 -*-
 FloatComplexMatrix
-xdiv (const FloatComplexMatrix& a, const FloatMatrix& b, MatrixType &typ)
+xdiv (const FloatComplexMatrix& a, const FloatMatrix& b, MatrixType& typ)
 {
   if (! mx_div_conform (a, b))
     return FloatComplexMatrix ();
 
   octave_idx_type info;
   float rcond = 0.0;
 
   FloatComplexMatrix result
     = b.solve (typ, a.transpose (), info, rcond,
                solve_singularity_warning, true, blas_trans);
 
   return result.transpose ();
 }
 
 // -*- 4 -*-
 FloatComplexMatrix
-xdiv (const FloatComplexMatrix& a, const FloatComplexMatrix& b, MatrixType &typ)
+xdiv (const FloatComplexMatrix& a, const FloatComplexMatrix& b, MatrixType& typ)
 {
   if (! mx_div_conform (a, b))
     return FloatComplexMatrix ();
 
   octave_idx_type info;
   float rcond = 0.0;
 
   FloatComplexMatrix result
@@ -637,58 +637,58 @@ x_el_div (const FloatComplex a, const Fl
 //            +--   +---+----+
 //   matrix         | 1 |  3 |
 //                  +---+----+
 //   complex_matrix | 2 |  4 |
 //                  +---+----+
 
 // -*- 1 -*-
 FloatMatrix
-xleftdiv (const FloatMatrix& a, const FloatMatrix& b, MatrixType &typ,
+xleftdiv (const FloatMatrix& a, const FloatMatrix& b, MatrixType& typ,
           blas_trans_type transt)
 {
   if (! mx_leftdiv_conform (a, b, transt))
     return FloatMatrix ();
 
   octave_idx_type info;
   float rcond = 0.0;
   return a.solve (typ, b, info, rcond, solve_singularity_warning, true, transt);
 }
 
 // -*- 2 -*-
 FloatComplexMatrix
-xleftdiv (const FloatMatrix& a, const FloatComplexMatrix& b, MatrixType &typ,
+xleftdiv (const FloatMatrix& a, const FloatComplexMatrix& b, MatrixType& typ,
           blas_trans_type transt)
 {
   if (! mx_leftdiv_conform (a, b, transt))
     return FloatComplexMatrix ();
 
   octave_idx_type info;
   float rcond = 0.0;
 
   return a.solve (typ, b, info, rcond, solve_singularity_warning, true, transt);
 }
 
 // -*- 3 -*-
 FloatComplexMatrix
-xleftdiv (const FloatComplexMatrix& a, const FloatMatrix& b, MatrixType &typ,
+xleftdiv (const FloatComplexMatrix& a, const FloatMatrix& b, MatrixType& typ,
           blas_trans_type transt)
 {
   if (! mx_leftdiv_conform (a, b, transt))
     return FloatComplexMatrix ();
 
   octave_idx_type info;
   float rcond = 0.0;
   return a.solve (typ, b, info, rcond, solve_singularity_warning, true, transt);
 }
 
 // -*- 4 -*-
 FloatComplexMatrix
 xleftdiv (const FloatComplexMatrix& a, const FloatComplexMatrix& b,
-          MatrixType &typ, blas_trans_type transt)
+          MatrixType& typ, blas_trans_type transt)
 {
   if (! mx_leftdiv_conform (a, b, transt))
     return FloatComplexMatrix ();
 
   octave_idx_type info;
   float rcond = 0.0;
   return a.solve (typ, b, info, rcond, solve_singularity_warning, true, transt);
 }
diff --git a/libinterp/corefcn/xdiv.h b/libinterp/corefcn/xdiv.h
--- a/libinterp/corefcn/xdiv.h
+++ b/libinterp/corefcn/xdiv.h
@@ -24,85 +24,85 @@ along with Octave; see the file COPYING.
 #if ! defined (octave_xdiv_h)
 #define octave_xdiv_h 1
 
 #include "octave-config.h"
 
 #include "mx-defs.h"
 #include "MatrixType.h"
 
-extern Matrix xdiv (const Matrix& a, const Matrix& b, MatrixType &typ);
+extern Matrix xdiv (const Matrix& a, const Matrix& b, MatrixType& typ);
 extern ComplexMatrix xdiv (const Matrix& a, const ComplexMatrix& b,
-                           MatrixType &typ);
+                           MatrixType& typ);
 extern ComplexMatrix xdiv (const ComplexMatrix& a, const Matrix& b,
-                           MatrixType &typ);
+                           MatrixType& typ);
 extern ComplexMatrix xdiv (const ComplexMatrix& a, const ComplexMatrix& b,
-                           MatrixType &typ);
+                           MatrixType& typ);
 
 extern Matrix x_el_div (double a, const Matrix& b);
 extern ComplexMatrix x_el_div (double a, const ComplexMatrix& b);
 extern ComplexMatrix x_el_div (const Complex a, const Matrix& b);
 extern ComplexMatrix x_el_div (const Complex a, const ComplexMatrix& b);
 
 extern NDArray x_el_div (double a, const NDArray& b);
 extern ComplexNDArray x_el_div (double a, const ComplexNDArray& b);
 extern ComplexNDArray x_el_div (const Complex a, const NDArray& b);
 extern ComplexNDArray x_el_div (const Complex a, const ComplexNDArray& b);
 
-extern Matrix xleftdiv (const Matrix& a, const Matrix& b, MatrixType &typ,
+extern Matrix xleftdiv (const Matrix& a, const Matrix& b, MatrixType& typ,
                         blas_trans_type transt = blas_no_trans);
 extern ComplexMatrix xleftdiv (const Matrix& a, const ComplexMatrix& b,
-                               MatrixType &typ,
+                               MatrixType& typ,
                                blas_trans_type transt = blas_no_trans);
 extern ComplexMatrix xleftdiv (const ComplexMatrix& a, const Matrix& b,
-                               MatrixType &typ,
+                               MatrixType& typ,
                                blas_trans_type transt = blas_no_trans);
 extern ComplexMatrix xleftdiv (const ComplexMatrix& a, const ComplexMatrix& b,
-                               MatrixType &typ,
+                               MatrixType& typ,
                                blas_trans_type transt = blas_no_trans);
 
 extern FloatMatrix xdiv (const FloatMatrix& a, const FloatMatrix& b,
-                         MatrixType &typ);
+                         MatrixType& typ);
 extern FloatComplexMatrix xdiv (const FloatMatrix& a,
                                 const FloatComplexMatrix& b,
-                                MatrixType &typ);
+                                MatrixType& typ);
 extern FloatComplexMatrix xdiv (const FloatComplexMatrix& a,
                                 const FloatMatrix& b,
-                                MatrixType &typ);
+                                MatrixType& typ);
 extern FloatComplexMatrix xdiv (const FloatComplexMatrix& a,
                                 const FloatComplexMatrix& b,
-                                MatrixType &typ);
+                                MatrixType& typ);
 
 extern FloatMatrix x_el_div (float a, const FloatMatrix& b);
 extern FloatComplexMatrix x_el_div (float a, const FloatComplexMatrix& b);
 extern FloatComplexMatrix x_el_div (const FloatComplex a, const FloatMatrix& b);
 extern FloatComplexMatrix x_el_div (const FloatComplex a,
                                     const FloatComplexMatrix& b);
 
 extern FloatNDArray x_el_div (float a, const FloatNDArray& b);
 extern FloatComplexNDArray x_el_div (float a, const FloatComplexNDArray& b);
 extern FloatComplexNDArray x_el_div (const FloatComplex a,
                                      const FloatNDArray& b);
 extern FloatComplexNDArray x_el_div (const FloatComplex a,
                                      const FloatComplexNDArray& b);
 
 extern FloatMatrix xleftdiv (const FloatMatrix& a, const FloatMatrix& b,
-                             MatrixType &typ,
+                             MatrixType& typ,
                              blas_trans_type transt = blas_no_trans);
 extern FloatComplexMatrix xleftdiv (const FloatMatrix& a,
                                     const FloatComplexMatrix& b,
-                                    MatrixType &typ,
+                                    MatrixType& typ,
                                     blas_trans_type transt = blas_no_trans);
 extern FloatComplexMatrix xleftdiv (const FloatComplexMatrix& a,
                                     const FloatMatrix& b,
-                                    MatrixType &typ,
+                                    MatrixType& typ,
                                     blas_trans_type transt = blas_no_trans);
 extern FloatComplexMatrix xleftdiv (const FloatComplexMatrix& a,
                                     const FloatComplexMatrix& b,
-                                    MatrixType &typ,
+                                    MatrixType& typ,
                                     blas_trans_type transt = blas_no_trans);
 
 extern Matrix xdiv (const Matrix& a, const DiagMatrix& b);
 extern ComplexMatrix xdiv (const ComplexMatrix& a, const DiagMatrix& b);
 extern ComplexMatrix xdiv (const ComplexMatrix& a, const ComplexDiagMatrix& b);
 
 extern DiagMatrix xdiv (const DiagMatrix& a, const DiagMatrix& b);
 extern ComplexDiagMatrix xdiv (const ComplexDiagMatrix& a, const DiagMatrix& b);
diff --git a/libinterp/corefcn/zfstream.h b/libinterp/corefcn/zfstream.h
--- a/libinterp/corefcn/zfstream.h
+++ b/libinterp/corefcn/zfstream.h
@@ -470,17 +470,17 @@ private:
 
   // Arguments for manipulator function
   T1 val1;
   T2 val2;
 };
 
 // Manipulator function thunks through to stream buffer
 inline gzofstream&
-setcompression (gzofstream &gzs, int l, int s = Z_DEFAULT_STRATEGY)
+setcompression (gzofstream& gzs, int l, int s = Z_DEFAULT_STRATEGY)
 {
   (gzs.rdbuf ())->setcompression (l, s);
   return gzs;
 }
 
 // Manipulator constructor stores arguments
 template <typename T1, typename T2>
 inline
diff --git a/libinterp/dldfcn/__eigs__.cc b/libinterp/dldfcn/__eigs__.cc
--- a/libinterp/dldfcn/__eigs__.cc
+++ b/libinterp/dldfcn/__eigs__.cc
@@ -47,17 +47,17 @@ static octave_function *eigs_fcn = 0;
 
 // Have we warned about imaginary values returned from user function?
 static bool warned_imaginary = false;
 
 // Is this a recursive call?
 static int call_depth = 0;
 
 ColumnVector
-eigs_func (const ColumnVector &x, int &eigs_error)
+eigs_func (const ColumnVector& x, int& eigs_error)
 {
   ColumnVector retval;
   octave_value_list args;
   args(0) = x;
 
   if (eigs_fcn)
     {
       octave_value_list tmp;
@@ -87,17 +87,17 @@ eigs_func (const ColumnVector &x, int &e
           err_user_supplied_eval ("eigs");
         }
     }
 
   return retval;
 }
 
 ComplexColumnVector
-eigs_complex_func (const ComplexColumnVector &x, int &eigs_error)
+eigs_complex_func (const ComplexColumnVector& x, int& eigs_error)
 {
   ComplexColumnVector retval;
   octave_value_list args;
   args(0) = x;
 
   if (eigs_fcn)
     {
       octave_value_list tmp;
diff --git a/libinterp/dldfcn/__ode15__.cc b/libinterp/dldfcn/__ode15__.cc
--- a/libinterp/dldfcn/__ode15__.cc
+++ b/libinterp/dldfcn/__ode15__.cc
@@ -411,17 +411,17 @@ namespace octave
 
     for (octave_idx_type i = 0; i < n; i++)
       data(i) = punt[i];
 
     return data;
   }
 
   N_Vector
-  IDA::ColToNVec (const ColumnVector &data, long int n)
+  IDA::ColToNVec (const ColumnVector& data, long int n)
   {
     N_Vector v = N_VNew_Serial (n);
 
     realtype *punt = nv_data_s (v);
 
     for (octave_idx_type i = 0; i < n; i++)
       punt[i] = data(i);
 
@@ -958,22 +958,22 @@ namespace octave
   ida_sparse_cell_jac (SparseMatrix *spdfdy, SparseMatrix *spdfdyp,
                        double cj)
   {
     return (*spdfdy) + cj * (*spdfdyp);
   }
 
   octave_value_list
   do_ode15 (octave_function *ida_fcn,
-            const ColumnVector &tspan,
+            const ColumnVector& tspan,
             const int numt,
             const realtype t0,
-            const ColumnVector &y0,
-            const ColumnVector &yp0,
-            const octave_scalar_map &options)
+            const ColumnVector& y0,
+            const ColumnVector& yp0,
+            const octave_scalar_map& options)
   {
     octave_value_list retval;
 
     // Create object
     IDA dae (t0, y0, yp0, ida_fcn, ida_user_function);
 
     // Set Jacobian
     bool havejac = options.getfield ("havejac").bool_value ();
diff --git a/libinterp/octave-value/ov-base.h b/libinterp/octave-value/ov-base.h
--- a/libinterp/octave-value/ov-base.h
+++ b/libinterp/octave-value/ov-base.h
@@ -191,17 +191,17 @@ public:
   class type_conv_info
   {
   public:
     type_conv_info (type_conv_fcn f = 0, int t = -1)
       : _fcn (f), _type_id (t) { }
 
     operator type_conv_fcn (void) const { return _fcn; }
 
-    octave_base_value * operator () (const octave_base_value &v) const
+    octave_base_value * operator () (const octave_base_value& v) const
     { return (*_fcn) (v); }
 
     int type_id (void) const { return _type_id; }
 
   private:
     type_conv_fcn _fcn;
     int _type_id;
   };
diff --git a/libinterp/octave-value/ov-builtin.cc b/libinterp/octave-value/ov-builtin.cc
--- a/libinterp/octave-value/ov-builtin.cc
+++ b/libinterp/octave-value/ov-builtin.cc
@@ -143,17 +143,17 @@ octave_builtin::do_multi_index_op (int n
 
 jit_type *
 octave_builtin::to_jit (void) const
 {
   return jtype;
 }
 
 void
-octave_builtin::stash_jit (jit_type &type)
+octave_builtin::stash_jit (jit_type& type)
 {
   jtype = &type;
 }
 
 octave_builtin::fcn
 octave_builtin::function (void) const
 {
   return f;
diff --git a/libinterp/octave-value/ov-cx-sparse.h b/libinterp/octave-value/ov-cx-sparse.h
--- a/libinterp/octave-value/ov-cx-sparse.h
+++ b/libinterp/octave-value/ov-cx-sparse.h
@@ -59,28 +59,28 @@ public:
 
   octave_sparse_complex_matrix (const ComplexMatrix& m)
     : octave_base_sparse<SparseComplexMatrix> (SparseComplexMatrix (m)) { }
 
   octave_sparse_complex_matrix (const SparseComplexMatrix& m)
     : octave_base_sparse<SparseComplexMatrix> (m) { }
 
   octave_sparse_complex_matrix (const SparseComplexMatrix& m,
-                                const MatrixType &t)
+                                const MatrixType& t)
     : octave_base_sparse<SparseComplexMatrix> (m, t) { }
 
   octave_sparse_complex_matrix (const MSparse<Complex>& m)
     : octave_base_sparse<SparseComplexMatrix> (m) { }
 
   octave_sparse_complex_matrix (const MSparse<Complex>& m,
-                                const MatrixType &t)
+                                const MatrixType& t)
     : octave_base_sparse<SparseComplexMatrix> (m, t) { }
 
   octave_sparse_complex_matrix (const Sparse<Complex>& m,
-                                const MatrixType &t)
+                                const MatrixType& t)
     : octave_base_sparse<SparseComplexMatrix> (SparseComplexMatrix (m), t) { }
 
   octave_sparse_complex_matrix (const Sparse<Complex>& m)
     : octave_base_sparse<SparseComplexMatrix> (SparseComplexMatrix (m)) { }
 
   octave_sparse_complex_matrix (const octave_sparse_complex_matrix& cm)
     : octave_base_sparse<SparseComplexMatrix> (cm) { }
 
diff --git a/libinterp/octave-value/ov-fcn-handle.cc b/libinterp/octave-value/ov-fcn-handle.cc
--- a/libinterp/octave-value/ov-fcn-handle.cc
+++ b/libinterp/octave-value/ov-fcn-handle.cc
@@ -254,17 +254,17 @@ octave_fcn_handle::is_equal_to (const oc
         retval = (iter->first == hiter->first)
                  && (iter->second.is_copy_of (hiter->second));
     }
 
   return retval;
 }
 
 bool
-octave_fcn_handle::set_fcn (const std::string &octaveroot,
+octave_fcn_handle::set_fcn (const std::string& octaveroot,
                             const std::string& fpath)
 {
   if (octaveroot.length () != 0
       && fpath.length () >= octaveroot.length ()
       && fpath.substr (0, octaveroot.length ()) == octaveroot
       && OCTAVE_EXEC_PREFIX != octaveroot)
     {
       // First check if just replacing matlabroot is enough
diff --git a/libinterp/octave-value/ov-fcn-handle.h b/libinterp/octave-value/ov-fcn-handle.h
--- a/libinterp/octave-value/ov-fcn-handle.h
+++ b/libinterp/octave-value/ov-fcn-handle.h
@@ -155,17 +155,17 @@ public:
 
   void print_raw (std::ostream& os, bool pr_as_read_syntax = false) const;
 
   // Simple function handles are printed without a newline.
   bool print_as_scalar (void) const { return nm != anonymous; }
 
 private:
 
-  bool set_fcn (const std::string &octaveroot, const std::string& fpath);
+  bool set_fcn (const std::string& octaveroot, const std::string& fpath);
 
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 
 protected:
 
   // The function we are handling.
   octave_value fcn;
 
diff --git a/libinterp/octave-value/ov.cc b/libinterp/octave-value/ov.cc
--- a/libinterp/octave-value/ov.cc
+++ b/libinterp/octave-value/ov.cc
@@ -832,47 +832,47 @@ octave_value::octave_value (const charND
 octave_value::octave_value (const Array<char>& chm, bool, char type)
   : rep (type == '"'
          ? new octave_char_matrix_dq_str (chm)
          : new octave_char_matrix_sq_str (chm))
 {
   maybe_mutate ();
 }
 
-octave_value::octave_value (const SparseMatrix& m, const MatrixType &t)
+octave_value::octave_value (const SparseMatrix& m, const MatrixType& t)
   : rep (new octave_sparse_matrix (m, t))
 {
   maybe_mutate ();
 }
 
-octave_value::octave_value (const Sparse<double>& m, const MatrixType &t)
+octave_value::octave_value (const Sparse<double>& m, const MatrixType& t)
   : rep (new octave_sparse_matrix (m, t))
 {
   maybe_mutate ();
 }
 
-octave_value::octave_value (const SparseComplexMatrix& m, const MatrixType &t)
+octave_value::octave_value (const SparseComplexMatrix& m, const MatrixType& t)
   : rep (new octave_sparse_complex_matrix (m, t))
 {
   maybe_mutate ();
 }
 
-octave_value::octave_value (const Sparse<Complex>& m, const MatrixType &t)
+octave_value::octave_value (const Sparse<Complex>& m, const MatrixType& t)
   : rep (new octave_sparse_complex_matrix (m, t))
 {
   maybe_mutate ();
 }
 
-octave_value::octave_value (const SparseBoolMatrix& bm, const MatrixType &t)
+octave_value::octave_value (const SparseBoolMatrix& bm, const MatrixType& t)
   : rep (new octave_sparse_bool_matrix (bm, t))
 {
   maybe_mutate ();
 }
 
-octave_value::octave_value (const Sparse<bool>& bm, const MatrixType &t)
+octave_value::octave_value (const Sparse<bool>& bm, const MatrixType& t)
   : rep (new octave_sparse_bool_matrix (bm, t))
 {
   maybe_mutate ();
 }
 
 octave_value::octave_value (const octave_int8& i)
   : rep (new octave_int8_scalar (i))
 {
diff --git a/libinterp/octave-value/ov.h b/libinterp/octave-value/ov.h
--- a/libinterp/octave-value/ov.h
+++ b/libinterp/octave-value/ov.h
@@ -1268,17 +1268,17 @@ public:
 
   friend OCTINTERP_API octave_value do_colon_op (const octave_value& base,
                                                  const octave_value& increment,
                                                  const octave_value& limit,
                                                  bool is_for_cmd_expr);
 
   const octave_base_value& get_rep (void) const { return *rep; }
 
-  bool is_copy_of (const octave_value &val) const { return rep == val.rep; }
+  bool is_copy_of (const octave_value& val) const { return rep == val.rep; }
 
   void print_info (std::ostream& os,
                    const std::string& prefix = "") const;
 
   bool save_ascii (std::ostream& os) { return rep->save_ascii (os); }
 
   bool load_ascii (std::istream& is) { return rep->load_ascii (is); }
 
diff --git a/libinterp/parse-tree/jit-ir.h b/libinterp/parse-tree/jit-ir.h
--- a/libinterp/parse-tree/jit-ir.h
+++ b/libinterp/parse-tree/jit-ir.h
@@ -808,17 +808,17 @@ private:
 
 // A non-ssa variable
 class
 jit_variable : public jit_value
 {
 public:
   jit_variable (const std::string& aname) : mname (aname), mlast_use (0) { }
 
-  const std::string &name (void) const { return mname; }
+  const std::string& name (void) const { return mname; }
 
   // manipulate the value_stack, for use during SSA construction.  The top of
   // the value stack represents the current value for this variable
   bool has_top (void) const
   {
     return ! value_stack.empty ();
   }
 
diff --git a/libinterp/parse-tree/jit-typeinfo.cc b/libinterp/parse-tree/jit-typeinfo.cc
--- a/libinterp/parse-tree/jit-typeinfo.cc
+++ b/libinterp/parse-tree/jit-typeinfo.cc
@@ -922,17 +922,17 @@ jit_index_operation::generate (const sig
       return generate_matrix (types);
     }
 
   return 0;
 }
 
 llvm::Value *
 jit_index_operation::create_arg_array (llvm::IRBuilderD& builder,
-                                       const jit_function &fn, size_t start_idx,
+                                       const jit_function& fn, size_t start_idx,
                                        size_t end_idx) const
 {
   size_t n = end_idx - start_idx;
   llvm::Type *scalar_t = jit_typeinfo::get_scalar_llvm ();
   llvm::ArrayType *array_t = llvm::ArrayType::get (scalar_t, n);
   llvm::Value *array = llvm::UndefValue::get (array_t);
   for (size_t i = start_idx; i < end_idx; ++i)
     {
@@ -2198,17 +2198,17 @@ jit_typeinfo::intN (size_t nbits) const
   std::map<size_t, jit_type *>::const_iterator iter = ints.find (nbits);
   if (iter != ints.end ())
     return iter->second;
 
   throw jit_fail_exception ("No such integer type");
 }
 
 jit_type *
-jit_typeinfo::do_type_of (const octave_value &ov) const
+jit_typeinfo::do_type_of (const octave_value& ov) const
 {
   if (ov.is_function ())
     {
       // FIXME: This is ugly, we need to finalize how we want to do this, then
       // have octave_value fully support the needed functionality
       octave_builtin *builtin
         = dynamic_cast<octave_builtin *> (ov.internal_rep ());
       return builtin && builtin->to_jit () ? builtin->to_jit ()
diff --git a/libinterp/parse-tree/jit-typeinfo.h b/libinterp/parse-tree/jit-typeinfo.h
--- a/libinterp/parse-tree/jit-typeinfo.h
+++ b/libinterp/parse-tree/jit-typeinfo.h
@@ -402,17 +402,17 @@ protected:
 
   virtual jit_function *generate_matrix (const signature_vec& types) const = 0;
 
   virtual void do_initialize (void) = 0;
 
   // helper functions
   // [start_idx, end_idx).
   llvm::Value *create_arg_array (llvm::IRBuilderD& builder,
-                                 const jit_function &fn, size_t start_idx,
+                                 const jit_function& fn, size_t start_idx,
                                  size_t end_idx) const;
 
   llvm::Module *module;
   llvm::ExecutionEngine *engine;
 };
 
 class
 jit_paren_subsref : public jit_index_operation
@@ -629,17 +629,17 @@ private:
   }
 
   jit_type *do_difference (jit_type *lhs, jit_type *)
   {
     // FIXME: Maybe we can do something smarter?
     return lhs;
   }
 
-  jit_type *do_type_of (const octave_value &ov) const;
+  jit_type *do_type_of (const octave_value& ov) const;
 
   const jit_operation& do_binary_op (int op) const
   {
     assert (static_cast<size_t>(op) < binary_ops.size ());
     return binary_ops[op];
   }
 
   const jit_operation& do_unary_op (int op) const
diff --git a/libinterp/parse-tree/pt-jit.cc b/libinterp/parse-tree/pt-jit.cc
--- a/libinterp/parse-tree/pt-jit.cc
+++ b/libinterp/parse-tree/pt-jit.cc
@@ -110,17 +110,17 @@ static llvm::LLVMContext& context = llvm
 
 // jit_break is thrown whenever a branch we are converting has only breaks or
 // continues.  This is because all code that follows a break or continue
 // is dead.
 class jit_break_exception : public std::exception
 { };
 
 // -------------------- jit_convert --------------------
-jit_convert::jit_convert (tree &tee, jit_type *for_bounds)
+jit_convert::jit_convert (tree& tee, jit_type *for_bounds)
   : converting_function (false)
 {
   initialize (symbol_table::current_scope ());
 
   if (for_bounds)
     create_variable (next_for_bounds (false), for_bounds);
 
   try
diff --git a/libinterp/parse-tree/pt-jit.h b/libinterp/parse-tree/pt-jit.h
--- a/libinterp/parse-tree/pt-jit.h
+++ b/libinterp/parse-tree/pt-jit.h
@@ -39,17 +39,17 @@ class octave_value_list;
 class
 jit_convert : public tree_walker
 {
 public:
   typedef std::pair<jit_type *, std::string> type_bound;
   typedef std::vector<type_bound> type_bound_vector;
   typedef std::map<std::string, jit_variable *> variable_map;
 
-  jit_convert (tree &tee, jit_type *for_bounds = 0);
+  jit_convert (tree& tee, jit_type *for_bounds = 0);
 
   jit_convert (octave_user_function& fcn, const std::vector<jit_type *>& args);
 
 #define DECL_ARG(n) const ARG ## n& arg ## n
 #define JIT_CREATE_CHECKED(N)                                           \
   template <OCT_MAKE_DECL_LIST (typename, ARG, N)>                      \
   jit_call *create_checked (OCT_MAKE_LIST (DECL_ARG, N))                \
   {                                                                     \
@@ -68,17 +68,17 @@ public:
   jit_block_list& get_blocks (void) { return blocks; }
 
   const type_bound_vector& get_bounds (void) const { return bounds; }
 
   jit_factory& get_factory (void) { return factory; }
 
   llvm::Function *get_function (void) const { return function; }
 
-  const variable_map &get_variable_map (void) const { return vmap; }
+  const variable_map& get_variable_map (void) const { return vmap; }
 
   void visit_anon_fcn_handle (tree_anon_fcn_handle&);
 
   void visit_argument_list (tree_argument_list&);
 
   void visit_binary_expression (tree_binary_expression&);
 
   void visit_boolean_expression (tree_boolean_expression&);
@@ -293,17 +293,17 @@ private:
 
   void finish_phi (jit_phi *phi);
 
   void visit (jit_value *jvalue)
   {
     return visit (*jvalue);
   }
 
-  void visit (jit_value &jvalue)
+  void visit (jit_value& jvalue)
   {
     jvalue.accept (*this);
   }
 };
 
 // type inference and SSA construction on the low level Octave IR
 class
 jit_infer
diff --git a/liboctave/array/CMatrix.cc b/liboctave/array/CMatrix.cc
--- a/liboctave/array/CMatrix.cc
+++ b/liboctave/array/CMatrix.cc
@@ -734,32 +734,32 @@ ComplexMatrix
 ComplexMatrix::inverse (octave_idx_type& info, double& rcon, bool force,
                         bool calc_cond) const
 {
   MatrixType mattype (*this);
   return inverse (mattype, info, rcon, force, calc_cond);
 }
 
 ComplexMatrix
-ComplexMatrix::inverse (MatrixType &mattype) const
+ComplexMatrix::inverse (MatrixType& mattype) const
 {
   octave_idx_type info;
   double rcon;
   return inverse (mattype, info, rcon, 0, 0);
 }
 
 ComplexMatrix
-ComplexMatrix::inverse (MatrixType &mattype, octave_idx_type& info) const
+ComplexMatrix::inverse (MatrixType& mattype, octave_idx_type& info) const
 {
   double rcon;
   return inverse (mattype, info, rcon, 0, 0);
 }
 
 ComplexMatrix
-ComplexMatrix::tinverse (MatrixType &mattype, octave_idx_type& info,
+ComplexMatrix::tinverse (MatrixType& mattype, octave_idx_type& info,
                          double& rcon, bool force, bool calc_cond) const
 {
   ComplexMatrix retval;
 
   F77_INT nr = octave::to_f77_int (rows ());
   F77_INT nc = octave::to_f77_int (cols ());
 
   if (nr != nc || nr == 0 || nc == 0)
@@ -808,17 +808,17 @@ ComplexMatrix::tinverse (MatrixType &mat
 
   if (info == -1 && ! force)
     retval = *this; // Restore matrix contents.
 
   return retval;
 }
 
 ComplexMatrix
-ComplexMatrix::finverse (MatrixType &mattype, octave_idx_type& info,
+ComplexMatrix::finverse (MatrixType& mattype, octave_idx_type& info,
                          double& rcon, bool force, bool calc_cond) const
 {
   ComplexMatrix retval;
 
   F77_INT nr = octave::to_f77_int (rows ());
   F77_INT nc = octave::to_f77_int (cols ());
 
   if (nr != nc)
@@ -902,17 +902,17 @@ ComplexMatrix::finverse (MatrixType &mat
 
   if (info != 0)
     mattype.mark_as_rectangular ();
 
   return retval;
 }
 
 ComplexMatrix
-ComplexMatrix::inverse (MatrixType &mattype, octave_idx_type& info,
+ComplexMatrix::inverse (MatrixType& mattype, octave_idx_type& info,
                         double& rcon, bool force, bool calc_cond) const
 {
   int typ = mattype.type (false);
   ComplexMatrix ret;
 
   if (typ == MatrixType::Unknown)
     typ = mattype.type (*this);
 
@@ -1493,17 +1493,17 @@ ComplexMatrix::determinant (MatrixType& 
 double
 ComplexMatrix::rcond (void) const
 {
   MatrixType mattype (*this);
   return rcond (mattype);
 }
 
 double
-ComplexMatrix::rcond (MatrixType &mattype) const
+ComplexMatrix::rcond (MatrixType& mattype) const
 {
   double rcon = octave::numeric_limits<double>::NaN ();
   F77_INT nr = octave::to_f77_int (rows ());
   F77_INT nc = octave::to_f77_int (cols ());
 
   if (nr != nc)
     (*current_liboctave_error_handler) ("matrix must be square");
 
@@ -1663,17 +1663,17 @@ ComplexMatrix::rcond (MatrixType &mattyp
       else
         rcon = 0.0;
     }
 
   return rcon;
 }
 
 ComplexMatrix
-ComplexMatrix::utsolve (MatrixType &mattype, const ComplexMatrix& b,
+ComplexMatrix::utsolve (MatrixType& mattype, const ComplexMatrix& b,
                         octave_idx_type& info, double& rcon,
                         solve_singularity_handler sing_handler,
                         bool calc_cond, blas_trans_type transt) const
 {
   ComplexMatrix retval;
 
   F77_INT nr = octave::to_f77_int (rows ());
   F77_INT nc = octave::to_f77_int (cols ());
@@ -1761,17 +1761,17 @@ ComplexMatrix::utsolve (MatrixType &matt
             }
         }
     }
 
   return retval;
 }
 
 ComplexMatrix
-ComplexMatrix::ltsolve (MatrixType &mattype, const ComplexMatrix& b,
+ComplexMatrix::ltsolve (MatrixType& mattype, const ComplexMatrix& b,
                         octave_idx_type& info, double& rcon,
                         solve_singularity_handler sing_handler,
                         bool calc_cond, blas_trans_type transt) const
 {
   ComplexMatrix retval;
 
   F77_INT nr = octave::to_f77_int (rows ());
   F77_INT nc = octave::to_f77_int (cols ());
@@ -1859,17 +1859,17 @@ ComplexMatrix::ltsolve (MatrixType &matt
             }
         }
     }
 
   return retval;
 }
 
 ComplexMatrix
-ComplexMatrix::fsolve (MatrixType &mattype, const ComplexMatrix& b,
+ComplexMatrix::fsolve (MatrixType& mattype, const ComplexMatrix& b,
                        octave_idx_type& info, double& rcon,
                        solve_singularity_handler sing_handler,
                        bool calc_cond) const
 {
   ComplexMatrix retval;
 
   F77_INT nr = octave::to_f77_int (rows ());
   F77_INT nc = octave::to_f77_int (cols ());
@@ -2070,72 +2070,74 @@ ComplexMatrix::fsolve (MatrixType &matty
           mattype.mark_as_full ();
         }
     }
 
   return retval;
 }
 
 ComplexMatrix
-ComplexMatrix::solve (MatrixType &typ, const Matrix& b) const
+ComplexMatrix::solve (MatrixType& mattype, const Matrix& b) const
 {
   octave_idx_type info;
   double rcon;
-  return solve (typ, b, info, rcon, 0);
+  return solve (mattype, b, info, rcon, 0);
 }
 
 ComplexMatrix
-ComplexMatrix::solve (MatrixType &typ, const Matrix& b,
+ComplexMatrix::solve (MatrixType& mattype, const Matrix& b,
                       octave_idx_type& info) const
 {
   double rcon;
-  return solve (typ, b, info, rcon, 0);
+  return solve (mattype, b, info, rcon, 0);
 }
 
 ComplexMatrix
-ComplexMatrix::solve (MatrixType &typ, const Matrix& b, octave_idx_type& info,
-                      double& rcon) const
+ComplexMatrix::solve (MatrixType& mattype, const Matrix& b,
+                      octave_idx_type& info, double& rcon) const
 {
-  return solve (typ, b, info, rcon, 0);
+  return solve (mattype, b, info, rcon, 0);
 }
 
 ComplexMatrix
-ComplexMatrix::solve (MatrixType &typ, const Matrix& b, octave_idx_type& info,
-                      double& rcon, solve_singularity_handler sing_handler,
+ComplexMatrix::solve (MatrixType& mattype, const Matrix& b,
+                      octave_idx_type& info, double& rcon,
+                      solve_singularity_handler sing_handler,
                       bool singular_fallback, blas_trans_type transt) const
 {
   ComplexMatrix tmp (b);
-  return solve (typ, tmp, info, rcon, sing_handler, singular_fallback, transt);
+  return solve (mattype, tmp, info, rcon, sing_handler, singular_fallback,
+                transt);
 }
 
 ComplexMatrix
-ComplexMatrix::solve (MatrixType &typ, const ComplexMatrix& b) const
+ComplexMatrix::solve (MatrixType& mattype, const ComplexMatrix& b) const
 {
   octave_idx_type info;
   double rcon;
-  return solve (typ, b, info, rcon, 0);
+  return solve (mattype, b, info, rcon, 0);
 }
 
 ComplexMatrix
-ComplexMatrix::solve (MatrixType &typ, const ComplexMatrix& b,
+ComplexMatrix::solve (MatrixType& mattype, const ComplexMatrix& b,
                       octave_idx_type& info) const
 {
   double rcon;
-  return solve (typ, b, info, rcon, 0);
+  return solve (mattype, b, info, rcon, 0);
 }
 
 ComplexMatrix
-ComplexMatrix::solve (MatrixType &typ, const ComplexMatrix& b,
+ComplexMatrix::solve (MatrixType& mattype, const ComplexMatrix& b,
                       octave_idx_type& info, double& rcon) const
 {
-  return solve (typ, b, info, rcon, 0);
+  return solve (mattype, b, info, rcon, 0);
 }
 
 ComplexMatrix
-ComplexMatrix::solve (MatrixType &mattype, const ComplexMatrix& b,
+ComplexMatrix::solve (MatrixType& mattype, const ComplexMatrix& b,
                       octave_idx_type& info, double& rcon,
                       solve_singularity_handler sing_handler,
                       bool singular_fallback, blas_trans_type transt) const
 {
   ComplexMatrix retval;
   int typ = mattype.type ();
 
   if (typ == MatrixType::Unknown)
@@ -2163,79 +2165,80 @@ ComplexMatrix::solve (MatrixType &mattyp
       octave_idx_type rank;
       retval = lssolve (b, info, rank, rcon);
     }
 
   return retval;
 }
 
 ComplexColumnVector
-ComplexMatrix::solve (MatrixType &typ, const ColumnVector& b) const
+ComplexMatrix::solve (MatrixType& mattype, const ColumnVector& b) const
 {
   octave_idx_type info;
   double rcon;
-  return solve (typ, ComplexColumnVector (b), info, rcon, 0);
+  return solve (mattype, ComplexColumnVector (b), info, rcon, 0);
 }
 
 ComplexColumnVector
-ComplexMatrix::solve (MatrixType &typ, const ColumnVector& b,
+ComplexMatrix::solve (MatrixType& mattype, const ColumnVector& b,
                       octave_idx_type& info) const
 {
   double rcon;
-  return solve (typ, ComplexColumnVector (b), info, rcon, 0);
+  return solve (mattype, ComplexColumnVector (b), info, rcon, 0);
 }
 
 ComplexColumnVector
-ComplexMatrix::solve (MatrixType &typ, const ColumnVector& b,
+ComplexMatrix::solve (MatrixType& mattype, const ColumnVector& b,
                       octave_idx_type& info, double& rcon) const
 {
-  return solve (typ, ComplexColumnVector (b), info, rcon, 0);
+  return solve (mattype, ComplexColumnVector (b), info, rcon, 0);
 }
 
 ComplexColumnVector
-ComplexMatrix::solve (MatrixType &typ, const ColumnVector& b,
+ComplexMatrix::solve (MatrixType& mattype, const ColumnVector& b,
                       octave_idx_type& info, double& rcon,
                       solve_singularity_handler sing_handler,
                       blas_trans_type transt) const
 {
-  return solve (typ, ComplexColumnVector (b), info, rcon, sing_handler, transt);
+  return solve (mattype, ComplexColumnVector (b), info, rcon, sing_handler,
+                transt);
 }
 
 ComplexColumnVector
-ComplexMatrix::solve (MatrixType &typ, const ComplexColumnVector& b) const
+ComplexMatrix::solve (MatrixType& mattype, const ComplexColumnVector& b) const
 {
   octave_idx_type info;
   double rcon;
-  return solve (typ, b, info, rcon, 0);
+  return solve (mattype, b, info, rcon, 0);
 }
 
 ComplexColumnVector
-ComplexMatrix::solve (MatrixType &typ, const ComplexColumnVector& b,
+ComplexMatrix::solve (MatrixType& mattype, const ComplexColumnVector& b,
                       octave_idx_type& info) const
 {
   double rcon;
-  return solve (typ, b, info, rcon, 0);
+  return solve (mattype, b, info, rcon, 0);
 }
 
 ComplexColumnVector
-ComplexMatrix::solve (MatrixType &typ, const ComplexColumnVector& b,
+ComplexMatrix::solve (MatrixType& mattype, const ComplexColumnVector& b,
                       octave_idx_type& info, double& rcon) const
 {
-  return solve (typ, b, info, rcon, 0);
+  return solve (mattype, b, info, rcon, 0);
 }
 
 ComplexColumnVector
-ComplexMatrix::solve (MatrixType &typ, const ComplexColumnVector& b,
+ComplexMatrix::solve (MatrixType& mattype, const ComplexColumnVector& b,
                       octave_idx_type& info, double& rcon,
                       solve_singularity_handler sing_handler,
                       blas_trans_type transt) const
 {
 
   ComplexMatrix tmp (b);
-  tmp = solve (typ, tmp, info, rcon, sing_handler, true, transt);
+  tmp = solve (mattype, tmp, info, rcon, sing_handler, true, transt);
   return tmp.column (static_cast<octave_idx_type> (0));
 }
 
 ComplexMatrix
 ComplexMatrix::solve (const Matrix& b) const
 {
   octave_idx_type info;
   double rcon;
diff --git a/liboctave/array/CMatrix.h b/liboctave/array/CMatrix.h
--- a/liboctave/array/CMatrix.h
+++ b/liboctave/array/CMatrix.h
@@ -183,113 +183,113 @@ public:
 
   void resize (octave_idx_type nr, octave_idx_type nc,
                const Complex& rfv = Complex (0))
   {
     MArray<Complex>::resize (dim_vector (nr, nc), rfv);
   }
 
 private:
-  ComplexMatrix tinverse (MatrixType &mattype, octave_idx_type& info,
+  ComplexMatrix tinverse (MatrixType& mattype, octave_idx_type& info,
                           double& rcon, bool force, bool calc_cond) const;
 
-  ComplexMatrix finverse (MatrixType &mattype, octave_idx_type& info,
+  ComplexMatrix finverse (MatrixType& mattype, octave_idx_type& info,
                           double& rcon, bool force, bool calc_cond) const;
 
 public:
   ComplexMatrix inverse (void) const;
   ComplexMatrix inverse (octave_idx_type& info) const;
   ComplexMatrix inverse (octave_idx_type& info, double& rcon,
                          bool force = false, bool calc_cond = true) const;
 
-  ComplexMatrix inverse (MatrixType &mattype) const;
-  ComplexMatrix inverse (MatrixType &mattype, octave_idx_type& info) const;
-  ComplexMatrix inverse (MatrixType &mattype, octave_idx_type& info,
+  ComplexMatrix inverse (MatrixType& mattype) const;
+  ComplexMatrix inverse (MatrixType& mattype, octave_idx_type& info) const;
+  ComplexMatrix inverse (MatrixType& mattype, octave_idx_type& info,
                          double& rcon, bool force = false,
                          bool calc_cond = true) const;
 
   ComplexMatrix pseudo_inverse (double tol = 0.0) const;
 
   ComplexMatrix fourier (void) const;
   ComplexMatrix ifourier (void) const;
 
   ComplexMatrix fourier2d (void) const;
   ComplexMatrix ifourier2d (void) const;
 
   ComplexDET determinant (void) const;
   ComplexDET determinant (octave_idx_type& info) const;
   ComplexDET determinant (octave_idx_type& info, double& rcon,
                           bool calc_cond = true) const;
-  ComplexDET determinant (MatrixType &mattype, octave_idx_type& info,
+  ComplexDET determinant (MatrixType& mattype, octave_idx_type& info,
                           double& rcon, bool calc_cond = true) const;
 
   double rcond (void) const;
-  double rcond (MatrixType &mattype) const;
+  double rcond (MatrixType& mattype) const;
 
 private:
   // Upper triangular matrix solvers
-  ComplexMatrix utsolve (MatrixType &typ, const ComplexMatrix& b,
+  ComplexMatrix utsolve (MatrixType& mattype, const ComplexMatrix& b,
                          octave_idx_type& info, double& rcon,
                          solve_singularity_handler sing_handler,
                          bool calc_cond = false,
                          blas_trans_type transt = blas_no_trans) const;
 
   // Lower triangular matrix solvers
-  ComplexMatrix ltsolve (MatrixType &typ, const ComplexMatrix& b,
+  ComplexMatrix ltsolve (MatrixType& mattype, const ComplexMatrix& b,
                          octave_idx_type& info, double& rcon,
                          solve_singularity_handler sing_handler,
                          bool calc_cond = false,
                          blas_trans_type transt = blas_no_trans) const;
 
   // Full matrix solvers (umfpack/cholesky)
-  ComplexMatrix fsolve (MatrixType &typ, const ComplexMatrix& b,
+  ComplexMatrix fsolve (MatrixType& mattype, const ComplexMatrix& b,
                         octave_idx_type& info, double& rcon,
                         solve_singularity_handler sing_handler,
                         bool calc_cond = false) const;
 
 public:
   // Generic interface to solver with no probing of type
-  ComplexMatrix solve (MatrixType &typ, const Matrix& b) const;
-  ComplexMatrix solve (MatrixType &typ, const Matrix& b,
+  ComplexMatrix solve (MatrixType& mattype, const Matrix& b) const;
+  ComplexMatrix solve (MatrixType& mattype, const Matrix& b,
                        octave_idx_type& info) const;
-  ComplexMatrix solve (MatrixType &typ, const Matrix& b,
+  ComplexMatrix solve (MatrixType& mattype, const Matrix& b,
                        octave_idx_type& info, double& rcon) const;
-  ComplexMatrix solve (MatrixType &typ, const Matrix& b, octave_idx_type& info,
+  ComplexMatrix solve (MatrixType& mattype, const Matrix& b, octave_idx_type& info,
                        double& rcon, solve_singularity_handler sing_handler,
                        bool singular_fallback = true,
                        blas_trans_type transt = blas_no_trans) const;
 
-  ComplexMatrix solve (MatrixType &typ, const ComplexMatrix& b) const;
-  ComplexMatrix solve (MatrixType &typ, const ComplexMatrix& b,
+  ComplexMatrix solve (MatrixType& mattype, const ComplexMatrix& b) const;
+  ComplexMatrix solve (MatrixType& mattype, const ComplexMatrix& b,
                        octave_idx_type& info) const;
-  ComplexMatrix solve (MatrixType &typ, const ComplexMatrix& b,
+  ComplexMatrix solve (MatrixType& mattype, const ComplexMatrix& b,
                        octave_idx_type& info, double& rcon) const;
-  ComplexMatrix solve (MatrixType &typ, const ComplexMatrix& b,
+  ComplexMatrix solve (MatrixType& mattype, const ComplexMatrix& b,
                        octave_idx_type& info, double& rcon,
                        solve_singularity_handler sing_handler,
                        bool singular_fallback = true,
                        blas_trans_type transt = blas_no_trans) const;
 
-  ComplexColumnVector solve (MatrixType &typ, const ColumnVector& b) const;
-  ComplexColumnVector solve (MatrixType &typ, const ColumnVector& b,
+  ComplexColumnVector solve (MatrixType& mattype, const ColumnVector& b) const;
+  ComplexColumnVector solve (MatrixType& mattype, const ColumnVector& b,
                              octave_idx_type& info) const;
-  ComplexColumnVector solve (MatrixType &typ, const ColumnVector& b,
+  ComplexColumnVector solve (MatrixType& mattype, const ColumnVector& b,
                              octave_idx_type& info, double& rcon) const;
-  ComplexColumnVector solve (MatrixType &typ, const ColumnVector& b,
+  ComplexColumnVector solve (MatrixType& mattype, const ColumnVector& b,
                              octave_idx_type& info, double& rcon,
                              solve_singularity_handler sing_handler,
                              blas_trans_type transt = blas_no_trans) const;
 
-  ComplexColumnVector solve (MatrixType &typ,
+  ComplexColumnVector solve (MatrixType& mattype,
                              const ComplexColumnVector& b) const;
-  ComplexColumnVector solve (MatrixType &typ, const ComplexColumnVector& b,
+  ComplexColumnVector solve (MatrixType& mattype, const ComplexColumnVector& b,
                              octave_idx_type& info) const;
-  ComplexColumnVector solve (MatrixType &typ, const ComplexColumnVector& b,
+  ComplexColumnVector solve (MatrixType& mattype, const ComplexColumnVector& b,
                              octave_idx_type& info, double& rcon) const;
-  ComplexColumnVector solve (MatrixType &typ, const ComplexColumnVector& b,
+  ComplexColumnVector solve (MatrixType& mattype, const ComplexColumnVector& b,
                              octave_idx_type& info, double& rcon,
                              solve_singularity_handler sing_handler,
                              blas_trans_type transt = blas_no_trans) const;
 
   // Generic interface to solver with probing of type
   ComplexMatrix solve (const Matrix& b) const;
   ComplexMatrix solve (const Matrix& b, octave_idx_type& info) const;
   ComplexMatrix solve (const Matrix& b, octave_idx_type& info,
diff --git a/liboctave/array/CSparse.cc b/liboctave/array/CSparse.cc
--- a/liboctave/array/CSparse.cc
+++ b/liboctave/array/CSparse.cc
@@ -677,32 +677,32 @@ SparseComplexMatrix::inverse (MatrixType
 SparseComplexMatrix
 SparseComplexMatrix::inverse (MatrixType& mattype, octave_idx_type& info) const
 {
   double rcond;
   return inverse (mattype, info, rcond, 0, 0);
 }
 
 SparseComplexMatrix
-SparseComplexMatrix::dinverse (MatrixType &mattyp, octave_idx_type& info,
+SparseComplexMatrix::dinverse (MatrixType& mattype, octave_idx_type& info,
                                double& rcond, const bool,
                                const bool calccond) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   info = 0;
 
   if (nr == 0 || nc == 0 || nr != nc)
     (*current_liboctave_error_handler) ("inverse requires square matrix");
 
   // Print spparms("spumoni") info if requested
-  int typ = mattyp.type ();
-  mattyp.info ();
+  int typ = mattype.type ();
+  mattype.info ();
 
   if (typ != MatrixType::Diagonal && typ != MatrixType::Permuted_Diagonal)
     (*current_liboctave_error_handler) ("incorrect matrix type");
 
   if (typ == MatrixType::Permuted_Diagonal)
     retval = transpose ();
   else
     retval = *this;
@@ -727,32 +727,32 @@ SparseComplexMatrix::dinverse (MatrixTyp
 
   for (octave_idx_type i = 0; i < nr; i++)
     v[i] = 1.0 / v[i];
 
   return retval;
 }
 
 SparseComplexMatrix
-SparseComplexMatrix::tinverse (MatrixType &mattyp, octave_idx_type& info,
+SparseComplexMatrix::tinverse (MatrixType& mattype, octave_idx_type& info,
                                double& rcond, const bool,
                                const bool calccond) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   info = 0;
 
   if (nr == 0 || nc == 0 || nr != nc)
     (*current_liboctave_error_handler) ("inverse requires square matrix");
 
   // Print spparms("spumoni") info if requested
-  int typ = mattyp.type ();
-  mattyp.info ();
+  int typ = mattype.type ();
+  mattype.info ();
 
   if (typ != MatrixType::Upper && typ != MatrixType::Permuted_Upper
       && typ != MatrixType::Lower && typ != MatrixType::Permuted_Lower)
     (*current_liboctave_error_handler) ("incorrect matrix type");
 
   double anorm = 0.;
   double ainvnorm = 0.;
 
@@ -869,17 +869,17 @@ SparseComplexMatrix::tinverse (MatrixTyp
       octave_idx_type nz = nnz ();
       octave_idx_type cx = 0;
       octave_idx_type nz2 = nz;
       retval = SparseComplexMatrix (nr, nc, nz2);
 
       OCTAVE_LOCAL_BUFFER (Complex, work, nr);
       OCTAVE_LOCAL_BUFFER (octave_idx_type, rperm, nr);
 
-      octave_idx_type *perm = mattyp.triangular_perm ();
+      octave_idx_type *perm = mattype.triangular_perm ();
       if (typ == MatrixType::Permuted_Upper)
         {
           for (octave_idx_type i = 0; i < nr; i++)
             rperm[perm[i]] = i;
         }
       else
         {
           for (octave_idx_type i = 0; i < nr; i++)
@@ -1197,17 +1197,17 @@ SparseComplexMatrix::determinant (octave
     ("support for UMFPACK was unavailable or disabled when liboctave was built");
 
 #endif
 
   return retval;
 }
 
 ComplexMatrix
-SparseComplexMatrix::dsolve (MatrixType &mattype, const Matrix& b,
+SparseComplexMatrix::dsolve (MatrixType& mattype, const Matrix& b,
                              octave_idx_type& err, double& rcond,
                              solve_singularity_handler, bool calc_cond) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc < nr ? nc : nr);
@@ -1256,17 +1256,17 @@ SparseComplexMatrix::dsolve (MatrixType 
       else
         rcond = 1.0;
     }
 
   return retval;
 }
 
 SparseComplexMatrix
-SparseComplexMatrix::dsolve (MatrixType &mattype, const SparseMatrix& b,
+SparseComplexMatrix::dsolve (MatrixType& mattype, const SparseMatrix& b,
                              octave_idx_type& err, double& rcond,
                              solve_singularity_handler,
                              bool calc_cond) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
@@ -1346,17 +1346,17 @@ SparseComplexMatrix::dsolve (MatrixType 
       else
         rcond = 1.0;
     }
 
   return retval;
 }
 
 ComplexMatrix
-SparseComplexMatrix::dsolve (MatrixType &mattype, const ComplexMatrix& b,
+SparseComplexMatrix::dsolve (MatrixType& mattype, const ComplexMatrix& b,
                              octave_idx_type& err, double& rcond,
                              solve_singularity_handler,
                              bool calc_cond) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
@@ -1406,17 +1406,17 @@ SparseComplexMatrix::dsolve (MatrixType 
       else
         rcond = 1.0;
     }
 
   return retval;
 }
 
 SparseComplexMatrix
-SparseComplexMatrix::dsolve (MatrixType &mattype, const SparseComplexMatrix& b,
+SparseComplexMatrix::dsolve (MatrixType& mattype, const SparseComplexMatrix& b,
                              octave_idx_type& err, double& rcond,
                              solve_singularity_handler,
                              bool calc_cond) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
@@ -1496,17 +1496,17 @@ SparseComplexMatrix::dsolve (MatrixType 
       else
         rcond = 1.0;
     }
 
   return retval;
 }
 
 ComplexMatrix
-SparseComplexMatrix::utsolve (MatrixType &mattype, const Matrix& b,
+SparseComplexMatrix::utsolve (MatrixType& mattype, const Matrix& b,
                               octave_idx_type& err, double& rcond,
                               solve_singularity_handler sing_handler,
                               bool calc_cond) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
@@ -1726,17 +1726,17 @@ SparseComplexMatrix::utsolve (MatrixType
             octave::warn_singular_matrix (rcond);
         }
     }
 
   return retval;
 }
 
 SparseComplexMatrix
-SparseComplexMatrix::utsolve (MatrixType &mattype, const SparseMatrix& b,
+SparseComplexMatrix::utsolve (MatrixType& mattype, const SparseMatrix& b,
                               octave_idx_type& err, double& rcond,
                               solve_singularity_handler sing_handler,
                               bool calc_cond) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
@@ -2007,17 +2007,17 @@ SparseComplexMatrix::utsolve (MatrixType
           else
             octave::warn_singular_matrix (rcond);
         }
     }
   return retval;
 }
 
 ComplexMatrix
-SparseComplexMatrix::utsolve (MatrixType &mattype, const ComplexMatrix& b,
+SparseComplexMatrix::utsolve (MatrixType& mattype, const ComplexMatrix& b,
                               octave_idx_type& err, double& rcond,
                               solve_singularity_handler sing_handler,
                               bool calc_cond) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
@@ -2237,17 +2237,17 @@ SparseComplexMatrix::utsolve (MatrixType
             octave::warn_singular_matrix (rcond);
         }
     }
 
   return retval;
 }
 
 SparseComplexMatrix
-SparseComplexMatrix::utsolve (MatrixType &mattype, const SparseComplexMatrix& b,
+SparseComplexMatrix::utsolve (MatrixType& mattype, const SparseComplexMatrix& b,
                               octave_idx_type& err, double& rcond,
                               solve_singularity_handler sing_handler,
                               bool calc_cond) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
@@ -2519,17 +2519,17 @@ SparseComplexMatrix::utsolve (MatrixType
             octave::warn_singular_matrix (rcond);
         }
     }
 
   return retval;
 }
 
 ComplexMatrix
-SparseComplexMatrix::ltsolve (MatrixType &mattype, const Matrix& b,
+SparseComplexMatrix::ltsolve (MatrixType& mattype, const Matrix& b,
                               octave_idx_type& err, double& rcond,
                               solve_singularity_handler sing_handler,
                               bool calc_cond) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
@@ -2768,17 +2768,17 @@ SparseComplexMatrix::ltsolve (MatrixType
             octave::warn_singular_matrix (rcond);
         }
     }
 
   return retval;
 }
 
 SparseComplexMatrix
-SparseComplexMatrix::ltsolve (MatrixType &mattype, const SparseMatrix& b,
+SparseComplexMatrix::ltsolve (MatrixType& mattype, const SparseMatrix& b,
                               octave_idx_type& err, double& rcond,
                               solve_singularity_handler sing_handler,
                               bool calc_cond) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
@@ -3069,17 +3069,17 @@ SparseComplexMatrix::ltsolve (MatrixType
             octave::warn_singular_matrix (rcond);
         }
     }
 
   return retval;
 }
 
 ComplexMatrix
-SparseComplexMatrix::ltsolve (MatrixType &mattype, const ComplexMatrix& b,
+SparseComplexMatrix::ltsolve (MatrixType& mattype, const ComplexMatrix& b,
                               octave_idx_type& err, double& rcond,
                               solve_singularity_handler sing_handler,
                               bool calc_cond) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
@@ -3321,17 +3321,17 @@ SparseComplexMatrix::ltsolve (MatrixType
             octave::warn_singular_matrix (rcond);
         }
     }
 
   return retval;
 }
 
 SparseComplexMatrix
-SparseComplexMatrix::ltsolve (MatrixType &mattype, const SparseComplexMatrix& b,
+SparseComplexMatrix::ltsolve (MatrixType& mattype, const SparseComplexMatrix& b,
                               octave_idx_type& err, double& rcond,
                               solve_singularity_handler sing_handler,
                               bool calc_cond) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
@@ -3621,17 +3621,17 @@ SparseComplexMatrix::ltsolve (MatrixType
             octave::warn_singular_matrix (rcond);
         }
     }
 
   return retval;
 }
 
 ComplexMatrix
-SparseComplexMatrix::trisolve (MatrixType &mattype, const Matrix& b,
+SparseComplexMatrix::trisolve (MatrixType& mattype, const Matrix& b,
                                octave_idx_type& err, double& rcond,
                                solve_singularity_handler sing_handler,
                                bool calc_cond) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
@@ -3790,17 +3790,17 @@ SparseComplexMatrix::trisolve (MatrixTyp
       else if (typ != MatrixType::Tridiagonal_Hermitian)
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseComplexMatrix
-SparseComplexMatrix::trisolve (MatrixType &mattype, const SparseMatrix& b,
+SparseComplexMatrix::trisolve (MatrixType& mattype, const SparseMatrix& b,
                                octave_idx_type& err, double& rcond,
                                solve_singularity_handler sing_handler,
                                bool calc_cond) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
@@ -3947,17 +3947,17 @@ SparseComplexMatrix::trisolve (MatrixTyp
       else if (typ != MatrixType::Tridiagonal_Hermitian)
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 ComplexMatrix
-SparseComplexMatrix::trisolve (MatrixType &mattype, const ComplexMatrix& b,
+SparseComplexMatrix::trisolve (MatrixType& mattype, const ComplexMatrix& b,
                                octave_idx_type& err, double& rcond,
                                solve_singularity_handler sing_handler,
                                bool calc_cond) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
@@ -4115,17 +4115,17 @@ SparseComplexMatrix::trisolve (MatrixTyp
       else if (typ != MatrixType::Tridiagonal_Hermitian)
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseComplexMatrix
-SparseComplexMatrix::trisolve (MatrixType &mattype,
+SparseComplexMatrix::trisolve (MatrixType& mattype,
                                const SparseComplexMatrix& b,
                                octave_idx_type& err, double& rcond,
                                solve_singularity_handler sing_handler,
                                bool calc_cond) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
@@ -4286,17 +4286,17 @@ SparseComplexMatrix::trisolve (MatrixTyp
       else if (typ != MatrixType::Tridiagonal_Hermitian)
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 ComplexMatrix
-SparseComplexMatrix::bsolve (MatrixType &mattype, const Matrix& b,
+SparseComplexMatrix::bsolve (MatrixType& mattype, const Matrix& b,
                              octave_idx_type& err, double& rcond,
                              solve_singularity_handler sing_handler,
                              bool calc_cond) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
@@ -4556,17 +4556,17 @@ SparseComplexMatrix::bsolve (MatrixType 
       else if (typ != MatrixType::Banded_Hermitian)
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseComplexMatrix
-SparseComplexMatrix::bsolve (MatrixType &mattype, const SparseMatrix& b,
+SparseComplexMatrix::bsolve (MatrixType& mattype, const SparseMatrix& b,
                              octave_idx_type& err, double& rcond,
                              solve_singularity_handler sing_handler,
                              bool calc_cond) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
@@ -4894,17 +4894,17 @@ SparseComplexMatrix::bsolve (MatrixType 
       else if (typ != MatrixType::Banded_Hermitian)
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 ComplexMatrix
-SparseComplexMatrix::bsolve (MatrixType &mattype, const ComplexMatrix& b,
+SparseComplexMatrix::bsolve (MatrixType& mattype, const ComplexMatrix& b,
                              octave_idx_type& err, double& rcond,
                              solve_singularity_handler sing_handler,
                              bool calc_cond) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
@@ -5161,17 +5161,17 @@ SparseComplexMatrix::bsolve (MatrixType 
       else if (typ != MatrixType::Banded_Hermitian)
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseComplexMatrix
-SparseComplexMatrix::bsolve (MatrixType &mattype, const SparseComplexMatrix& b,
+SparseComplexMatrix::bsolve (MatrixType& mattype, const SparseComplexMatrix& b,
                              octave_idx_type& err, double& rcond,
                              solve_singularity_handler sing_handler,
                              bool calc_cond) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
@@ -5508,18 +5508,18 @@ SparseComplexMatrix::bsolve (MatrixType 
       else if (typ != MatrixType::Banded_Hermitian)
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 void *
-SparseComplexMatrix::factorize (octave_idx_type& err, double &rcond,
-                                Matrix &Control, Matrix &Info,
+SparseComplexMatrix::factorize (octave_idx_type& err, double& rcond,
+                                Matrix& Control, Matrix& Info,
                                 solve_singularity_handler sing_handler,
                                 bool calc_cond) const
 {
   // The return values
   void *Numeric = 0;
   err = 0;
 
 #if defined (HAVE_UMFPACK)
@@ -5639,17 +5639,17 @@ SparseComplexMatrix::factorize (octave_i
     ("support for UMFPACK was unavailable or disabled when liboctave was built");
 
 #endif
 
   return Numeric;
 }
 
 ComplexMatrix
-SparseComplexMatrix::fsolve (MatrixType &mattype, const Matrix& b,
+SparseComplexMatrix::fsolve (MatrixType& mattype, const Matrix& b,
                              octave_idx_type& err, double& rcond,
                              solve_singularity_handler sing_handler,
                              bool calc_cond) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
@@ -5891,17 +5891,17 @@ SparseComplexMatrix::fsolve (MatrixType 
       else if (typ != MatrixType::Hermitian)
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseComplexMatrix
-SparseComplexMatrix::fsolve (MatrixType &mattype, const SparseMatrix& b,
+SparseComplexMatrix::fsolve (MatrixType& mattype, const SparseMatrix& b,
                              octave_idx_type& err, double& rcond,
                              solve_singularity_handler sing_handler,
                              bool calc_cond) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
@@ -6192,17 +6192,17 @@ SparseComplexMatrix::fsolve (MatrixType 
       else if (typ != MatrixType::Hermitian)
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 ComplexMatrix
-SparseComplexMatrix::fsolve (MatrixType &mattype, const ComplexMatrix& b,
+SparseComplexMatrix::fsolve (MatrixType& mattype, const ComplexMatrix& b,
                              octave_idx_type& err, double& rcond,
                              solve_singularity_handler sing_handler,
                              bool calc_cond) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
@@ -6423,17 +6423,17 @@ SparseComplexMatrix::fsolve (MatrixType 
       else if (typ != MatrixType::Hermitian)
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseComplexMatrix
-SparseComplexMatrix::fsolve (MatrixType &mattype, const SparseComplexMatrix& b,
+SparseComplexMatrix::fsolve (MatrixType& mattype, const SparseComplexMatrix& b,
                              octave_idx_type& err, double& rcond,
                              solve_singularity_handler sing_handler,
                              bool calc_cond) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
@@ -6714,40 +6714,40 @@ SparseComplexMatrix::fsolve (MatrixType 
       else if (typ != MatrixType::Hermitian)
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 ComplexMatrix
-SparseComplexMatrix::solve (MatrixType &mattype, const Matrix& b) const
+SparseComplexMatrix::solve (MatrixType& mattype, const Matrix& b) const
 {
   octave_idx_type info;
   double rcond;
   return solve (mattype, b, info, rcond, 0);
 }
 
 ComplexMatrix
-SparseComplexMatrix::solve (MatrixType &mattype, const Matrix& b,
+SparseComplexMatrix::solve (MatrixType& mattype, const Matrix& b,
                             octave_idx_type& info) const
 {
   double rcond;
   return solve (mattype, b, info, rcond, 0);
 }
 
 ComplexMatrix
-SparseComplexMatrix::solve (MatrixType &mattype, const Matrix& b,
+SparseComplexMatrix::solve (MatrixType& mattype, const Matrix& b,
                             octave_idx_type& info, double& rcond) const
 {
   return solve (mattype, b, info, rcond, 0);
 }
 
 ComplexMatrix
-SparseComplexMatrix::solve (MatrixType &mattype, const Matrix& b,
+SparseComplexMatrix::solve (MatrixType& mattype, const Matrix& b,
                             octave_idx_type& err, double& rcond,
                             solve_singularity_handler sing_handler,
                             bool singular_fallback) const
 {
   ComplexMatrix retval;
   int typ = mattype.type (false);
 
   if (typ == MatrixType::Unknown)
@@ -6779,40 +6779,40 @@ SparseComplexMatrix::solve (MatrixType &
                (*this, b, err);
 #endif
     }
 
   return retval;
 }
 
 SparseComplexMatrix
-SparseComplexMatrix::solve (MatrixType &mattype, const SparseMatrix& b) const
+SparseComplexMatrix::solve (MatrixType& mattype, const SparseMatrix& b) const
 {
   octave_idx_type info;
   double rcond;
   return solve (mattype, b, info, rcond, 0);
 }
 
 SparseComplexMatrix
-SparseComplexMatrix::solve (MatrixType &mattype, const SparseMatrix& b,
+SparseComplexMatrix::solve (MatrixType& mattype, const SparseMatrix& b,
                             octave_idx_type& info) const
 {
   double rcond;
   return solve (mattype, b, info, rcond, 0);
 }
 
 SparseComplexMatrix
-SparseComplexMatrix::solve (MatrixType &mattype, const SparseMatrix& b,
+SparseComplexMatrix::solve (MatrixType& mattype, const SparseMatrix& b,
                             octave_idx_type& info, double& rcond) const
 {
   return solve (mattype, b, info, rcond, 0);
 }
 
 SparseComplexMatrix
-SparseComplexMatrix::solve (MatrixType &mattype, const SparseMatrix& b,
+SparseComplexMatrix::solve (MatrixType& mattype, const SparseMatrix& b,
                             octave_idx_type& err, double& rcond,
                             solve_singularity_handler sing_handler,
                             bool singular_fallback) const
 {
   SparseComplexMatrix retval;
   int typ = mattype.type (false);
 
   if (typ == MatrixType::Unknown)
@@ -6844,40 +6844,40 @@ SparseComplexMatrix::solve (MatrixType &
                (*this, b, err);
 #endif
     }
 
   return retval;
 }
 
 ComplexMatrix
-SparseComplexMatrix::solve (MatrixType &mattype, const ComplexMatrix& b) const
+SparseComplexMatrix::solve (MatrixType& mattype, const ComplexMatrix& b) const
 {
   octave_idx_type info;
   double rcond;
   return solve (mattype, b, info, rcond, 0);
 }
 
 ComplexMatrix
-SparseComplexMatrix::solve (MatrixType &mattype, const ComplexMatrix& b,
+SparseComplexMatrix::solve (MatrixType& mattype, const ComplexMatrix& b,
                             octave_idx_type& info) const
 {
   double rcond;
   return solve (mattype, b, info, rcond, 0);
 }
 
 ComplexMatrix
-SparseComplexMatrix::solve (MatrixType &mattype, const ComplexMatrix& b,
+SparseComplexMatrix::solve (MatrixType& mattype, const ComplexMatrix& b,
                             octave_idx_type& info, double& rcond) const
 {
   return solve (mattype, b, info, rcond, 0);
 }
 
 ComplexMatrix
-SparseComplexMatrix::solve (MatrixType &mattype, const ComplexMatrix& b,
+SparseComplexMatrix::solve (MatrixType& mattype, const ComplexMatrix& b,
                             octave_idx_type& err, double& rcond,
                             solve_singularity_handler sing_handler,
                             bool singular_fallback) const
 {
   ComplexMatrix retval;
   int typ = mattype.type (false);
 
   if (typ == MatrixType::Unknown)
@@ -6909,41 +6909,41 @@ SparseComplexMatrix::solve (MatrixType &
                (*this, b, err);
 #endif
     }
 
   return retval;
 }
 
 SparseComplexMatrix
-SparseComplexMatrix::solve (MatrixType &mattype,
+SparseComplexMatrix::solve (MatrixType& mattype,
                             const SparseComplexMatrix& b) const
 {
   octave_idx_type info;
   double rcond;
   return solve (mattype, b, info, rcond, 0);
 }
 
 SparseComplexMatrix
-SparseComplexMatrix::solve (MatrixType &mattype, const SparseComplexMatrix& b,
+SparseComplexMatrix::solve (MatrixType& mattype, const SparseComplexMatrix& b,
                             octave_idx_type& info) const
 {
   double rcond;
   return solve (mattype, b, info, rcond, 0);
 }
 
 SparseComplexMatrix
-SparseComplexMatrix::solve (MatrixType &mattype, const SparseComplexMatrix& b,
+SparseComplexMatrix::solve (MatrixType& mattype, const SparseComplexMatrix& b,
                             octave_idx_type& info, double& rcond) const
 {
   return solve (mattype, b, info, rcond, 0);
 }
 
 SparseComplexMatrix
-SparseComplexMatrix::solve (MatrixType &mattype, const SparseComplexMatrix& b,
+SparseComplexMatrix::solve (MatrixType& mattype, const SparseComplexMatrix& b,
                             octave_idx_type& err, double& rcond,
                             solve_singularity_handler sing_handler,
                             bool singular_fallback) const
 {
   SparseComplexMatrix retval;
   int typ = mattype.type (false);
 
   if (typ == MatrixType::Unknown)
@@ -6975,73 +6975,73 @@ SparseComplexMatrix::solve (MatrixType &
       SparseComplexMatrix> (*this, b, err);
 #endif
     }
 
   return retval;
 }
 
 ComplexColumnVector
-SparseComplexMatrix::solve (MatrixType &mattype, const ColumnVector& b) const
+SparseComplexMatrix::solve (MatrixType& mattype, const ColumnVector& b) const
 {
   octave_idx_type info; double rcond;
   return solve (mattype, b, info, rcond);
 }
 
 ComplexColumnVector
-SparseComplexMatrix::solve (MatrixType &mattype, const ColumnVector& b,
+SparseComplexMatrix::solve (MatrixType& mattype, const ColumnVector& b,
                             octave_idx_type& info) const
 {
   double rcond;
   return solve (mattype, b, info, rcond);
 }
 
 ComplexColumnVector
-SparseComplexMatrix::solve (MatrixType &mattype, const ColumnVector& b,
+SparseComplexMatrix::solve (MatrixType& mattype, const ColumnVector& b,
                             octave_idx_type& info, double& rcond) const
 {
   return solve (mattype, b, info, rcond, 0);
 }
 
 ComplexColumnVector
-SparseComplexMatrix::solve (MatrixType &mattype, const ColumnVector& b,
+SparseComplexMatrix::solve (MatrixType& mattype, const ColumnVector& b,
                             octave_idx_type& info, double& rcond,
                             solve_singularity_handler sing_handler) const
 {
   Matrix tmp (b);
   return solve (mattype, tmp, info, rcond,
                 sing_handler).column (static_cast<octave_idx_type> (0));
 }
 
 ComplexColumnVector
-SparseComplexMatrix::solve (MatrixType &mattype,
+SparseComplexMatrix::solve (MatrixType& mattype,
                             const ComplexColumnVector& b) const
 {
   octave_idx_type info;
   double rcond;
   return solve (mattype, b, info, rcond, 0);
 }
 
 ComplexColumnVector
-SparseComplexMatrix::solve (MatrixType &mattype, const ComplexColumnVector& b,
+SparseComplexMatrix::solve (MatrixType& mattype, const ComplexColumnVector& b,
                             octave_idx_type& info) const
 {
   double rcond;
   return solve (mattype, b, info, rcond, 0);
 }
 
 ComplexColumnVector
-SparseComplexMatrix::solve (MatrixType &mattype, const ComplexColumnVector& b,
+SparseComplexMatrix::solve (MatrixType& mattype, const ComplexColumnVector& b,
                             octave_idx_type& info, double& rcond) const
 {
   return solve (mattype, b, info, rcond, 0);
 }
 
 ComplexColumnVector
-SparseComplexMatrix::solve (MatrixType &mattype, const ComplexColumnVector& b,
+SparseComplexMatrix::solve (MatrixType& mattype, const ComplexColumnVector& b,
                             octave_idx_type& info, double& rcond,
                             solve_singularity_handler sing_handler) const
 {
   ComplexMatrix tmp (b);
   return solve (mattype, tmp, info, rcond,
                 sing_handler).column (static_cast<octave_idx_type> (0));
 }
 
diff --git a/liboctave/array/CSparse.h b/liboctave/array/CSparse.h
--- a/liboctave/array/CSparse.h
+++ b/liboctave/array/CSparse.h
@@ -145,21 +145,21 @@ public:
 
   // extract row or column i.
 
   ComplexRowVector row (octave_idx_type i) const;
 
   ComplexColumnVector column (octave_idx_type i) const;
 
 private:
-  SparseComplexMatrix dinverse (MatrixType &mattyp, octave_idx_type& info,
+  SparseComplexMatrix dinverse (MatrixType& mattype, octave_idx_type& info,
                                 double& rcond, const bool force = false,
                                 const bool calccond = true) const;
 
-  SparseComplexMatrix tinverse (MatrixType &mattyp, octave_idx_type& info,
+  SparseComplexMatrix tinverse (MatrixType& mattype, octave_idx_type& info,
                                 double& rcond, const bool force = false,
                                 const bool calccond = true) const;
 
 public:
   SparseComplexMatrix inverse (void) const;
   SparseComplexMatrix inverse (MatrixType& mattype) const;
   SparseComplexMatrix inverse (MatrixType& mattype,
                                octave_idx_type& info) const;
@@ -169,202 +169,202 @@ public:
 
   ComplexDET determinant (void) const;
   ComplexDET determinant (octave_idx_type& info) const;
   ComplexDET determinant (octave_idx_type& info, double& rcond,
                           bool calc_cond = true) const;
 
 private:
   // Diagonal matrix solvers
-  ComplexMatrix dsolve (MatrixType &typ, const Matrix& b, octave_idx_type& info,
+  ComplexMatrix dsolve (MatrixType& mattype, const Matrix& b, octave_idx_type& info,
                         double& rcond, solve_singularity_handler sing_handler,
                         bool calc_cond = false) const;
 
-  ComplexMatrix dsolve (MatrixType &typ, const ComplexMatrix& b,
+  ComplexMatrix dsolve (MatrixType& mattype, const ComplexMatrix& b,
                         octave_idx_type& info, double& rcond,
                         solve_singularity_handler sing_handler,
                         bool calc_cond = false) const;
 
-  SparseComplexMatrix dsolve (MatrixType &typ, const SparseMatrix& b,
+  SparseComplexMatrix dsolve (MatrixType& mattype, const SparseMatrix& b,
                               octave_idx_type& info, double& rcond,
                               solve_singularity_handler sing_handler,
                               bool calc_cond = false) const;
 
-  SparseComplexMatrix dsolve (MatrixType &typ, const SparseComplexMatrix& b,
+  SparseComplexMatrix dsolve (MatrixType& mattype, const SparseComplexMatrix& b,
                               octave_idx_type& info, double& rcond,
                               solve_singularity_handler sing_handler,
                               bool calc_cond = false) const;
 
   // Upper triangular matrix solvers
-  ComplexMatrix utsolve (MatrixType &typ, const Matrix& b,
+  ComplexMatrix utsolve (MatrixType& mattype, const Matrix& b,
                          octave_idx_type& info, double& rcond,
                          solve_singularity_handler sing_handler,
                          bool calc_cond = false) const;
 
-  ComplexMatrix utsolve (MatrixType &typ, const ComplexMatrix& b,
+  ComplexMatrix utsolve (MatrixType& mattype, const ComplexMatrix& b,
                          octave_idx_type& info, double& rcond,
                          solve_singularity_handler sing_handler,
                          bool calc_cond = false) const;
 
-  SparseComplexMatrix utsolve (MatrixType &typ, const SparseMatrix& b,
+  SparseComplexMatrix utsolve (MatrixType& mattype, const SparseMatrix& b,
                                octave_idx_type& info, double& rcond,
                                solve_singularity_handler sing_handler,
                                bool calc_cond = false) const;
 
-  SparseComplexMatrix utsolve (MatrixType &typ, const SparseComplexMatrix& b,
+  SparseComplexMatrix utsolve (MatrixType& mattype, const SparseComplexMatrix& b,
                                octave_idx_type& info, double& rcond,
                                solve_singularity_handler sing_handler,
                                bool calc_cond = false) const;
 
   // Lower triangular matrix solvers
-  ComplexMatrix ltsolve (MatrixType &typ, const Matrix& b,
+  ComplexMatrix ltsolve (MatrixType& mattype, const Matrix& b,
                          octave_idx_type& info, double& rcond,
                          solve_singularity_handler sing_handler,
                          bool calc_cond = false) const;
 
-  ComplexMatrix ltsolve (MatrixType &typ, const ComplexMatrix& b,
+  ComplexMatrix ltsolve (MatrixType& mattype, const ComplexMatrix& b,
                          octave_idx_type& info, double& rcond,
                          solve_singularity_handler sing_handler,
                          bool calc_cond = false) const;
 
-  SparseComplexMatrix ltsolve (MatrixType &typ, const SparseMatrix& b,
+  SparseComplexMatrix ltsolve (MatrixType& mattype, const SparseMatrix& b,
                                octave_idx_type& info, double& rcond,
                                solve_singularity_handler sing_handler,
                                bool calc_cond = false) const;
 
-  SparseComplexMatrix ltsolve (MatrixType &typ, const SparseComplexMatrix& b,
+  SparseComplexMatrix ltsolve (MatrixType& mattype, const SparseComplexMatrix& b,
                                octave_idx_type& info, double& rcond,
                                solve_singularity_handler sing_handler,
                                bool calc_cond = false) const;
 
   // Tridiagonal matrix solvers
-  ComplexMatrix trisolve (MatrixType &typ, const Matrix& b,
+  ComplexMatrix trisolve (MatrixType& mattype, const Matrix& b,
                           octave_idx_type& info, double& rcond,
                           solve_singularity_handler sing_handler,
                           bool calc_cond = false) const;
 
-  ComplexMatrix trisolve (MatrixType &typ, const ComplexMatrix& b,
+  ComplexMatrix trisolve (MatrixType& mattype, const ComplexMatrix& b,
                           octave_idx_type& info, double& rcond,
                           solve_singularity_handler sing_handler,
                           bool calc_cond = false) const;
 
-  SparseComplexMatrix trisolve (MatrixType &typ, const SparseMatrix& b,
+  SparseComplexMatrix trisolve (MatrixType& mattype, const SparseMatrix& b,
                                 octave_idx_type& info, double& rcond,
                                 solve_singularity_handler sing_handler,
                                 bool calc_cond = false) const;
 
-  SparseComplexMatrix trisolve (MatrixType &typ, const SparseComplexMatrix& b,
+  SparseComplexMatrix trisolve (MatrixType& mattype, const SparseComplexMatrix& b,
                                 octave_idx_type& info, double& rcond,
                                 solve_singularity_handler sing_handler,
                                 bool calc_cond = false) const;
 
   // Banded matrix solvers (umfpack/cholesky)
-  ComplexMatrix bsolve (MatrixType &typ, const Matrix& b,
+  ComplexMatrix bsolve (MatrixType& mattype, const Matrix& b,
                         octave_idx_type& info, double& rcond,
                         solve_singularity_handler sing_handler,
                         bool calc_cond = false) const;
 
-  ComplexMatrix bsolve (MatrixType &typ, const ComplexMatrix& b,
+  ComplexMatrix bsolve (MatrixType& mattype, const ComplexMatrix& b,
                         octave_idx_type& info, double& rcond,
                         solve_singularity_handler sing_handler,
                         bool calc_cond = false) const;
 
-  SparseComplexMatrix bsolve (MatrixType &typ, const SparseMatrix& b,
+  SparseComplexMatrix bsolve (MatrixType& mattype, const SparseMatrix& b,
                               octave_idx_type& info, double& rcond,
                               solve_singularity_handler sing_handler,
                               bool calc_cond = false) const;
 
-  SparseComplexMatrix bsolve (MatrixType &typ, const SparseComplexMatrix& b,
+  SparseComplexMatrix bsolve (MatrixType& mattype, const SparseComplexMatrix& b,
                               octave_idx_type& info, double& rcond,
                               solve_singularity_handler sing_handler,
                               bool calc_cond = false) const;
 
   // Full matrix solvers (umfpack/cholesky)
-  void * factorize (octave_idx_type& err, double &rcond, Matrix &Control,
-                    Matrix &Info, solve_singularity_handler sing_handler,
+  void * factorize (octave_idx_type& err, double& rcond, Matrix& Control,
+                    Matrix& Info, solve_singularity_handler sing_handler,
                     bool calc_cond) const;
 
-  ComplexMatrix fsolve (MatrixType &typ, const Matrix& b,
+  ComplexMatrix fsolve (MatrixType& mattype, const Matrix& b,
                         octave_idx_type& info, double& rcond,
                         solve_singularity_handler sing_handler,
                         bool calc_cond = false) const;
 
-  ComplexMatrix fsolve (MatrixType &typ, const ComplexMatrix& b,
+  ComplexMatrix fsolve (MatrixType& mattype, const ComplexMatrix& b,
                         octave_idx_type& info, double& rcond,
                         solve_singularity_handler sing_handler,
                         bool calc_cond = false) const;
 
-  SparseComplexMatrix fsolve (MatrixType &typ, const SparseMatrix& b,
+  SparseComplexMatrix fsolve (MatrixType& mattype, const SparseMatrix& b,
                               octave_idx_type& info, double& rcond,
                               solve_singularity_handler sing_handler,
                               bool calc_cond = false) const;
 
-  SparseComplexMatrix fsolve (MatrixType &typ, const SparseComplexMatrix& b,
+  SparseComplexMatrix fsolve (MatrixType& mattype, const SparseComplexMatrix& b,
                               octave_idx_type& info, double& rcond,
                               solve_singularity_handler sing_handler,
                               bool calc_cond = false) const;
 
 public:
   // Generic interface to solver with no probing of type
-  ComplexMatrix solve (MatrixType &typ, const Matrix& b) const;
-  ComplexMatrix solve (MatrixType &typ, const Matrix& b,
+  ComplexMatrix solve (MatrixType& mattype, const Matrix& b) const;
+  ComplexMatrix solve (MatrixType& mattype, const Matrix& b,
                        octave_idx_type& info) const;
-  ComplexMatrix solve (MatrixType &typ, const Matrix& b, octave_idx_type& info,
+  ComplexMatrix solve (MatrixType& mattype, const Matrix& b, octave_idx_type& info,
                        double& rcond) const;
-  ComplexMatrix solve (MatrixType &typ, const Matrix& b, octave_idx_type& info,
+  ComplexMatrix solve (MatrixType& mattype, const Matrix& b, octave_idx_type& info,
                        double& rcond, solve_singularity_handler sing_handler,
                        bool singular_fallback = true) const;
 
-  ComplexMatrix solve (MatrixType &typ, const ComplexMatrix& b) const;
-  ComplexMatrix solve (MatrixType &typ, const ComplexMatrix& b,
+  ComplexMatrix solve (MatrixType& mattype, const ComplexMatrix& b) const;
+  ComplexMatrix solve (MatrixType& mattype, const ComplexMatrix& b,
                        octave_idx_type& info) const;
-  ComplexMatrix solve (MatrixType &typ, const ComplexMatrix& b,
+  ComplexMatrix solve (MatrixType& mattype, const ComplexMatrix& b,
                        octave_idx_type& info, double& rcond) const;
-  ComplexMatrix solve (MatrixType &typ, const ComplexMatrix& b,
+  ComplexMatrix solve (MatrixType& mattype, const ComplexMatrix& b,
                        octave_idx_type& info, double& rcond,
                        solve_singularity_handler sing_handler,
                        bool singular_fallback = true) const;
 
-  SparseComplexMatrix solve (MatrixType &typ, const SparseMatrix& b) const;
-  SparseComplexMatrix solve (MatrixType &typ, const SparseMatrix& b,
+  SparseComplexMatrix solve (MatrixType& mattype, const SparseMatrix& b) const;
+  SparseComplexMatrix solve (MatrixType& mattype, const SparseMatrix& b,
                              octave_idx_type& info) const;
-  SparseComplexMatrix solve (MatrixType &typ, const SparseMatrix& b,
+  SparseComplexMatrix solve (MatrixType& mattype, const SparseMatrix& b,
                              octave_idx_type& info, double& rcond) const;
-  SparseComplexMatrix solve (MatrixType &typ, const SparseMatrix& b,
+  SparseComplexMatrix solve (MatrixType& mattype, const SparseMatrix& b,
                              octave_idx_type& info, double& rcond,
                              solve_singularity_handler sing_handler,
                              bool singular_fallback = true) const;
 
-  SparseComplexMatrix solve (MatrixType &typ,
+  SparseComplexMatrix solve (MatrixType& mattype,
                              const SparseComplexMatrix& b) const;
-  SparseComplexMatrix solve (MatrixType &typ, const SparseComplexMatrix& b,
+  SparseComplexMatrix solve (MatrixType& mattype, const SparseComplexMatrix& b,
                              octave_idx_type& info) const;
-  SparseComplexMatrix solve (MatrixType &typ, const SparseComplexMatrix& b,
+  SparseComplexMatrix solve (MatrixType& mattype, const SparseComplexMatrix& b,
                              octave_idx_type& info, double& rcond) const;
-  SparseComplexMatrix solve (MatrixType &typ, const SparseComplexMatrix& b,
+  SparseComplexMatrix solve (MatrixType& mattype, const SparseComplexMatrix& b,
                              octave_idx_type& info, double& rcond,
                              solve_singularity_handler sing_handler,
                              bool singular_fallback = true) const;
 
-  ComplexColumnVector solve (MatrixType &typ, const ColumnVector& b) const;
-  ComplexColumnVector solve (MatrixType &typ, const ColumnVector& b,
+  ComplexColumnVector solve (MatrixType& mattype, const ColumnVector& b) const;
+  ComplexColumnVector solve (MatrixType& mattype, const ColumnVector& b,
                              octave_idx_type& info) const;
-  ComplexColumnVector solve (MatrixType &typ, const ColumnVector& b,
+  ComplexColumnVector solve (MatrixType& mattype, const ColumnVector& b,
                              octave_idx_type& info, double& rcond) const;
-  ComplexColumnVector solve (MatrixType &typ, const ColumnVector& b,
+  ComplexColumnVector solve (MatrixType& mattype, const ColumnVector& b,
                              octave_idx_type& info, double& rcond,
                              solve_singularity_handler sing_handler) const;
 
-  ComplexColumnVector solve (MatrixType &typ,
+  ComplexColumnVector solve (MatrixType& mattype,
                              const ComplexColumnVector& b) const;
-  ComplexColumnVector solve (MatrixType &typ, const ComplexColumnVector& b,
+  ComplexColumnVector solve (MatrixType& mattype, const ComplexColumnVector& b,
                              octave_idx_type& info) const;
-  ComplexColumnVector solve (MatrixType &typ, const ComplexColumnVector& b,
+  ComplexColumnVector solve (MatrixType& mattype, const ComplexColumnVector& b,
                              octave_idx_type& info, double& rcond) const;
-  ComplexColumnVector solve (MatrixType &typ, const ComplexColumnVector& b,
+  ComplexColumnVector solve (MatrixType& mattype, const ComplexColumnVector& b,
                              octave_idx_type& info, double& rcond,
                              solve_singularity_handler sing_handler) const;
 
   // Generic interface to solver with probing of type
   ComplexMatrix solve (const Matrix& b) const;
   ComplexMatrix solve (const Matrix& b, octave_idx_type& info) const;
   ComplexMatrix solve (const Matrix& b, octave_idx_type& info,
                        double& rcond) const;
diff --git a/liboctave/array/MatrixType.cc b/liboctave/array/MatrixType.cc
--- a/liboctave/array/MatrixType.cc
+++ b/liboctave/array/MatrixType.cc
@@ -62,17 +62,17 @@ warn_calculating_sparse_type (void)
 // FIXME: There is a large code duplication here
 
 MatrixType::MatrixType (void)
   : typ (MatrixType::Unknown),
     sp_bandden (octave_sparse_params::get_bandden ()),
     bandden (0), upper_band (0),
     lower_band (0), dense (false), full (false), nperm (0), perm (0) { }
 
-MatrixType::MatrixType (const MatrixType &a)
+MatrixType::MatrixType (const MatrixType& a)
   : typ (a.typ), sp_bandden (a.sp_bandden), bandden (a.bandden),
     upper_band (a.upper_band), lower_band (a.lower_band),
     dense (a.dense), full (a.full), nperm (a.nperm), perm (0)
 {
   if (nperm != 0)
     {
       perm = new octave_idx_type [nperm];
       for (octave_idx_type i = 0; i < nperm; i++)
@@ -192,41 +192,41 @@ matrix_complex_probe (const MArray<std::
         typ = MatrixType::Full;
     }
   else
     typ = MatrixType::Rectangular;
 
   return typ;
 }
 
-MatrixType::MatrixType (const Matrix &a)
+MatrixType::MatrixType (const Matrix& a)
   : typ (MatrixType::Unknown),
     sp_bandden (0), bandden (0), upper_band (0), lower_band (0),
     dense (false), full (true), nperm (0), perm (0)
 {
   typ = matrix_real_probe (a);
 }
 
-MatrixType::MatrixType (const ComplexMatrix &a)
+MatrixType::MatrixType (const ComplexMatrix& a)
   : typ (MatrixType::Unknown),
     sp_bandden (0), bandden (0), upper_band (0), lower_band (0),
     dense (false), full (true), nperm (0), perm (0)
 {
   typ = matrix_complex_probe (a);
 }
 
-MatrixType::MatrixType (const FloatMatrix &a)
+MatrixType::MatrixType (const FloatMatrix& a)
   : typ (MatrixType::Unknown),
     sp_bandden (0), bandden (0), upper_band (0), lower_band (0),
     dense (false), full (true), nperm (0), perm (0)
 {
   typ = matrix_real_probe (a);
 }
 
-MatrixType::MatrixType (const FloatComplexMatrix &a)
+MatrixType::MatrixType (const FloatComplexMatrix& a)
   : typ (MatrixType::Unknown),
     sp_bandden (0), bandden (0), upper_band (0), lower_band (0),
     dense (false), full (true), nperm (0), perm (0)
 {
   typ = matrix_complex_probe (a);
 }
 
 
@@ -664,17 +664,17 @@ MatrixType::type (bool quiet)
       ("Octave:matrix-type-info", "invalidating matrix type");
 
   typ = MatrixType::Unknown;
 
   return typ;
 }
 
 int
-MatrixType::type (const SparseMatrix &a)
+MatrixType::type (const SparseMatrix& a)
 {
   if (typ != MatrixType::Unknown
       && (full || sp_bandden == octave_sparse_params::get_bandden ()))
     {
       if (octave_sparse_params::get_key ("spumoni") != 0.)
         warn_cached ();
 
       return typ;
@@ -696,17 +696,17 @@ MatrixType::type (const SparseMatrix &a)
       for (octave_idx_type i = 0; i < nperm; i++)
         perm[i] = tmp_typ.perm[i];
     }
 
   return typ;
 }
 
 int
-MatrixType::type (const SparseComplexMatrix &a)
+MatrixType::type (const SparseComplexMatrix& a)
 {
   if (typ != MatrixType::Unknown
       && (full || sp_bandden == octave_sparse_params::get_bandden ()))
     {
       if (octave_sparse_params::get_key ("spumoni") != 0.)
         warn_cached ();
 
       return typ;
@@ -728,17 +728,17 @@ MatrixType::type (const SparseComplexMat
       for (octave_idx_type i = 0; i < nperm; i++)
         perm[i] = tmp_typ.perm[i];
     }
 
   return typ;
 }
 
 int
-MatrixType::type (const Matrix &a)
+MatrixType::type (const Matrix& a)
 {
   if (typ != MatrixType::Unknown)
     {
       if (octave_sparse_params::get_key ("spumoni") != 0.)
         warn_cached ();
 
       return typ;
     }
@@ -754,17 +754,17 @@ MatrixType::type (const Matrix &a)
       for (octave_idx_type i = 0; i < nperm; i++)
         perm[i] = tmp_typ.perm[i];
     }
 
   return typ;
 }
 
 int
-MatrixType::type (const ComplexMatrix &a)
+MatrixType::type (const ComplexMatrix& a)
 {
   if (typ != MatrixType::Unknown)
     {
       if (octave_sparse_params::get_key ("spumoni") != 0.)
         warn_cached ();
 
       return typ;
     }
@@ -780,17 +780,17 @@ MatrixType::type (const ComplexMatrix &a
       for (octave_idx_type i = 0; i < nperm; i++)
         perm[i] = tmp_typ.perm[i];
     }
 
   return typ;
 }
 
 int
-MatrixType::type (const FloatMatrix &a)
+MatrixType::type (const FloatMatrix& a)
 {
   if (typ != MatrixType::Unknown)
     {
       if (octave_sparse_params::get_key ("spumoni") != 0.)
         warn_cached ();
 
       return typ;
     }
@@ -806,17 +806,17 @@ MatrixType::type (const FloatMatrix &a)
       for (octave_idx_type i = 0; i < nperm; i++)
         perm[i] = tmp_typ.perm[i];
     }
 
   return typ;
 }
 
 int
-MatrixType::type (const FloatComplexMatrix &a)
+MatrixType::type (const FloatComplexMatrix& a)
 {
   if (typ != MatrixType::Unknown)
     {
       if (octave_sparse_params::get_key ("spumoni") != 0.)
         warn_cached ();
 
       return typ;
     }
diff --git a/liboctave/array/MatrixType.h b/liboctave/array/MatrixType.h
--- a/liboctave/array/MatrixType.h
+++ b/liboctave/array/MatrixType.h
@@ -55,25 +55,25 @@ public:
     Banded_Hermitian,
     Tridiagonal,
     Tridiagonal_Hermitian,
     Rectangular
   };
 
   MatrixType (void);
 
-  MatrixType (const MatrixType &a);
+  MatrixType (const MatrixType& a);
 
-  MatrixType (const Matrix &a);
+  MatrixType (const Matrix& a);
 
-  MatrixType (const ComplexMatrix &a);
+  MatrixType (const ComplexMatrix& a);
 
-  MatrixType (const FloatMatrix &a);
+  MatrixType (const FloatMatrix& a);
 
-  MatrixType (const FloatComplexMatrix &a);
+  MatrixType (const FloatComplexMatrix& a);
 
   template <typename T>
   MatrixType (const MSparse<T> &a);
 
   MatrixType (const matrix_type t, bool _full = false);
 
   MatrixType (const matrix_type t, const octave_idx_type np,
               const octave_idx_type *p, bool _full = false);
@@ -82,27 +82,27 @@ public:
               const octave_idx_type kl, bool _full = false);
 
   ~MatrixType (void);
 
   MatrixType& operator = (const MatrixType& a);
 
   int type (bool quiet = true);
 
-  int type (const Matrix &a);
+  int type (const Matrix& a);
 
-  int type (const ComplexMatrix &a);
+  int type (const ComplexMatrix& a);
 
-  int type (const FloatMatrix &a);
+  int type (const FloatMatrix& a);
 
-  int type (const FloatComplexMatrix &a);
+  int type (const FloatComplexMatrix& a);
 
-  int type (const SparseMatrix &a);
+  int type (const SparseMatrix& a);
 
-  int type (const SparseComplexMatrix &a);
+  int type (const SparseComplexMatrix& a);
 
   double band_density (void) const { return bandden; }
 
   int nupper (void) const { return upper_band; }
 
   int nlower (void) const { return lower_band; }
 
   bool is_dense (void) const { return dense; }
diff --git a/liboctave/array/dDiagMatrix.cc b/liboctave/array/dDiagMatrix.cc
--- a/liboctave/array/dDiagMatrix.cc
+++ b/liboctave/array/dDiagMatrix.cc
@@ -225,17 +225,17 @@ DiagMatrix::column (char *s) const
 DiagMatrix
 DiagMatrix::inverse (void) const
 {
   octave_idx_type info;
   return inverse (info);
 }
 
 DiagMatrix
-DiagMatrix::inverse (octave_idx_type &info) const
+DiagMatrix::inverse (octave_idx_type& info) const
 {
   octave_idx_type r = rows ();
   octave_idx_type c = cols ();
   octave_idx_type len = length ();
   if (r != c)
     (*current_liboctave_error_handler) ("inverse requires square matrix");
 
   DiagMatrix retval (r, c);
diff --git a/liboctave/array/dMatrix.cc b/liboctave/array/dMatrix.cc
--- a/liboctave/array/dMatrix.cc
+++ b/liboctave/array/dMatrix.cc
@@ -454,24 +454,24 @@ Matrix
 Matrix::inverse (MatrixType& mattype) const
 {
   octave_idx_type info;
   double rcon;
   return inverse (mattype, info, rcon, 0, 0);
 }
 
 Matrix
-Matrix::inverse (MatrixType &mattype, octave_idx_type& info) const
+Matrix::inverse (MatrixType& mattype, octave_idx_type& info) const
 {
   double rcon;
   return inverse (mattype, info, rcon, 0, 0);
 }
 
 Matrix
-Matrix::tinverse (MatrixType &mattype, octave_idx_type& info, double& rcon,
+Matrix::tinverse (MatrixType& mattype, octave_idx_type& info, double& rcon,
                   bool force, bool calc_cond) const
 {
   Matrix retval;
 
   F77_INT nr = octave::to_f77_int (rows ());
   F77_INT nc = octave::to_f77_int (cols ());
 
   if (nr != nc || nr == 0 || nc == 0)
@@ -520,17 +520,17 @@ Matrix::tinverse (MatrixType &mattype, o
 
   if (info == -1 && ! force)
     retval = *this; // Restore matrix contents.
 
   return retval;
 }
 
 Matrix
-Matrix::finverse (MatrixType &mattype, octave_idx_type& info, double& rcon,
+Matrix::finverse (MatrixType& mattype, octave_idx_type& info, double& rcon,
                   bool force, bool calc_cond) const
 {
   Matrix retval;
 
   F77_INT nr = octave::to_f77_int (rows ());
   F77_INT nc = octave::to_f77_int (cols ());
 
   if (nr != nc || nr == 0 || nc == 0)
@@ -605,17 +605,17 @@ Matrix::finverse (MatrixType &mattype, o
 
   if (info != 0)
     mattype.mark_as_rectangular ();
 
   return retval;
 }
 
 Matrix
-Matrix::inverse (MatrixType &mattype, octave_idx_type& info, double& rcon,
+Matrix::inverse (MatrixType& mattype, octave_idx_type& info, double& rcon,
                  bool force, bool calc_cond) const
 {
   int typ = mattype.type (false);
   Matrix ret;
 
   if (typ == MatrixType::Unknown)
     typ = mattype.type (*this);
 
@@ -1177,17 +1177,17 @@ Matrix::determinant (MatrixType& mattype
 double
 Matrix::rcond (void) const
 {
   MatrixType mattype (*this);
   return rcond (mattype);
 }
 
 double
-Matrix::rcond (MatrixType &mattype) const
+Matrix::rcond (MatrixType& mattype) const
 {
   double rcon = octave::numeric_limits<double>::NaN ();
   F77_INT nr = octave::to_f77_int (rows ());
   F77_INT nc = octave::to_f77_int (cols ());
 
   if (nr != nc)
     (*current_liboctave_error_handler) ("matrix must be square");
 
@@ -1341,17 +1341,17 @@ Matrix::rcond (MatrixType &mattype) cons
       else
         rcon = 0.0;
     }
 
   return rcon;
 }
 
 Matrix
-Matrix::utsolve (MatrixType &mattype, const Matrix& b, octave_idx_type& info,
+Matrix::utsolve (MatrixType& mattype, const Matrix& b, octave_idx_type& info,
                  double& rcon, solve_singularity_handler sing_handler,
                  bool calc_cond, blas_trans_type transt) const
 {
   Matrix retval;
 
   F77_INT nr = octave::to_f77_int (rows ());
   F77_INT nc = octave::to_f77_int (cols ());
 
@@ -1438,17 +1438,17 @@ Matrix::utsolve (MatrixType &mattype, co
             }
         }
     }
 
   return retval;
 }
 
 Matrix
-Matrix::ltsolve (MatrixType &mattype, const Matrix& b, octave_idx_type& info,
+Matrix::ltsolve (MatrixType& mattype, const Matrix& b, octave_idx_type& info,
                  double& rcon, solve_singularity_handler sing_handler,
                  bool calc_cond, blas_trans_type transt) const
 {
   Matrix retval;
 
   F77_INT nr = octave::to_f77_int (rows ());
   F77_INT nc = octave::to_f77_int (cols ());
 
@@ -1535,17 +1535,17 @@ Matrix::ltsolve (MatrixType &mattype, co
             }
         }
     }
 
   return retval;
 }
 
 Matrix
-Matrix::fsolve (MatrixType &mattype, const Matrix& b, octave_idx_type& info,
+Matrix::fsolve (MatrixType& mattype, const Matrix& b, octave_idx_type& info,
                 double& rcon, solve_singularity_handler sing_handler,
                 bool calc_cond) const
 {
   Matrix retval;
 
   F77_INT nr = octave::to_f77_int (rows ());
   F77_INT nc = octave::to_f77_int (cols ());
 
@@ -1734,39 +1734,40 @@ Matrix::fsolve (MatrixType &mattype, con
       else if (typ != MatrixType::Hermitian)
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 Matrix
-Matrix::solve (MatrixType &typ, const Matrix& b) const
+Matrix::solve (MatrixType& mattype, const Matrix& b) const
 {
   octave_idx_type info;
   double rcon;
-  return solve (typ, b, info, rcon, 0);
+  return solve (mattype, b, info, rcon, 0);
 }
 
 Matrix
-Matrix::solve (MatrixType &typ, const Matrix& b, octave_idx_type& info) const
+Matrix::solve (MatrixType& mattype, const Matrix& b,
+               octave_idx_type& info) const
 {
   double rcon;
-  return solve (typ, b, info, rcon, 0);
+  return solve (mattype, b, info, rcon, 0);
 }
 
 Matrix
-Matrix::solve (MatrixType &typ, const Matrix& b, octave_idx_type& info,
+Matrix::solve (MatrixType& mattype, const Matrix& b, octave_idx_type& info,
                double& rcon) const
 {
-  return solve (typ, b, info, rcon, 0);
+  return solve (mattype, b, info, rcon, 0);
 }
 
 Matrix
-Matrix::solve (MatrixType &mattype, const Matrix& b, octave_idx_type& info,
+Matrix::solve (MatrixType& mattype, const Matrix& b, octave_idx_type& info,
                double& rcon, solve_singularity_handler sing_handler,
                bool singular_fallback, blas_trans_type transt) const
 {
   Matrix retval;
   int typ = mattype.type ();
 
   if (typ == MatrixType::Unknown)
     typ = mattype.type (*this);
@@ -1790,36 +1791,36 @@ Matrix::solve (MatrixType &mattype, cons
       octave_idx_type rank;
       retval = lssolve (b, info, rank, rcon);
     }
 
   return retval;
 }
 
 ComplexMatrix
-Matrix::solve (MatrixType &typ, const ComplexMatrix& b) const
+Matrix::solve (MatrixType& mattype, const ComplexMatrix& b) const
 {
   octave_idx_type info;
   double rcon;
-  return solve (typ, b, info, rcon, 0);
+  return solve (mattype, b, info, rcon, 0);
 }
 
 ComplexMatrix
-Matrix::solve (MatrixType &typ, const ComplexMatrix& b,
+Matrix::solve (MatrixType& mattype, const ComplexMatrix& b,
                octave_idx_type& info) const
 {
   double rcon;
-  return solve (typ, b, info, rcon, 0);
+  return solve (mattype, b, info, rcon, 0);
 }
 
 ComplexMatrix
-Matrix::solve (MatrixType &typ, const ComplexMatrix& b, octave_idx_type& info,
-               double& rcon) const
+Matrix::solve (MatrixType& mattype, const ComplexMatrix& b,
+               octave_idx_type& info, double& rcon) const
 {
-  return solve (typ, b, info, rcon, 0);
+  return solve (mattype, b, info, rcon, 0);
 }
 
 static Matrix
 stack_complex_matrix (const ComplexMatrix& cm)
 {
   octave_idx_type m = cm.rows ();
   octave_idx_type n = cm.cols ();
   octave_idx_type nel = m*n;
@@ -1844,88 +1845,91 @@ unstack_complex_matrix (const Matrix& sm
   const double *smd = sm.data ();
   Complex *rd = retval.fortran_vec ();
   for (octave_idx_type i = 0; i < nel; i++)
     rd[i] = Complex (smd[i], smd[nel+i]);
   return retval;
 }
 
 ComplexMatrix
-Matrix::solve (MatrixType &typ, const ComplexMatrix& b, octave_idx_type& info,
-               double& rcon, solve_singularity_handler sing_handler,
+Matrix::solve (MatrixType& mattype, const ComplexMatrix& b,
+               octave_idx_type& info, double& rcon,
+               solve_singularity_handler sing_handler,
                bool singular_fallback, blas_trans_type transt) const
 {
   Matrix tmp = stack_complex_matrix (b);
-  tmp = solve (typ, tmp, info, rcon, sing_handler, singular_fallback, transt);
+  tmp = solve (mattype, tmp, info, rcon, sing_handler, singular_fallback,
+               transt);
   return unstack_complex_matrix (tmp);
 }
 
 ColumnVector
-Matrix::solve (MatrixType &typ, const ColumnVector& b) const
+Matrix::solve (MatrixType& mattype, const ColumnVector& b) const
 {
   octave_idx_type info; double rcon;
-  return solve (typ, b, info, rcon);
+  return solve (mattype, b, info, rcon);
 }
 
 ColumnVector
-Matrix::solve (MatrixType &typ, const ColumnVector& b,
+Matrix::solve (MatrixType& mattype, const ColumnVector& b,
                octave_idx_type& info) const
 {
   double rcon;
-  return solve (typ, b, info, rcon);
+  return solve (mattype, b, info, rcon);
 }
 
 ColumnVector
-Matrix::solve (MatrixType &typ, const ColumnVector& b, octave_idx_type& info,
-               double& rcon) const
+Matrix::solve (MatrixType& mattype, const ColumnVector& b,
+               octave_idx_type& info, double& rcon) const
 {
-  return solve (typ, b, info, rcon, 0);
+  return solve (mattype, b, info, rcon, 0);
 }
 
 ColumnVector
-Matrix::solve (MatrixType &typ, const ColumnVector& b, octave_idx_type& info,
-               double& rcon, solve_singularity_handler sing_handler,
+Matrix::solve (MatrixType& mattype, const ColumnVector& b,
+               octave_idx_type& info, double& rcon,
+               solve_singularity_handler sing_handler,
                blas_trans_type transt) const
 {
   Matrix tmp (b);
-  tmp = solve (typ, tmp, info, rcon, sing_handler, true, transt);
+  tmp = solve (mattype, tmp, info, rcon, sing_handler, true, transt);
   return tmp.column (static_cast<octave_idx_type> (0));
 }
 
 ComplexColumnVector
-Matrix::solve (MatrixType &typ, const ComplexColumnVector& b) const
+Matrix::solve (MatrixType& mattype, const ComplexColumnVector& b) const
 {
   ComplexMatrix tmp (*this);
-  return tmp.solve (typ, b);
+  return tmp.solve (mattype, b);
 }
 
 ComplexColumnVector
-Matrix::solve (MatrixType &typ, const ComplexColumnVector& b,
+Matrix::solve (MatrixType& mattype, const ComplexColumnVector& b,
                octave_idx_type& info) const
 {
   ComplexMatrix tmp (*this);
-  return tmp.solve (typ, b, info);
+  return tmp.solve (mattype, b, info);
 }
 
 ComplexColumnVector
-Matrix::solve (MatrixType &typ, const ComplexColumnVector& b,
+Matrix::solve (MatrixType& mattype, const ComplexColumnVector& b,
                octave_idx_type& info, double& rcon) const
 {
   ComplexMatrix tmp (*this);
-  return tmp.solve (typ, b, info, rcon);
+  return tmp.solve (mattype, b, info, rcon);
 }
 
 ComplexColumnVector
-Matrix::solve (MatrixType &typ, const ComplexColumnVector& b,
+Matrix::solve (MatrixType& mattype, const ComplexColumnVector& b,
                octave_idx_type& info, double& rcon,
                solve_singularity_handler sing_handler,
                blas_trans_type transt) const
 {
   ComplexMatrix tmp (*this);
-  return tmp.solve (typ, b, info, rcon, sing_handler, transt);
+  return tmp.solve (mattype, b, info, rcon, sing_handler, transt);
 }
 
 Matrix
 Matrix::solve (const Matrix& b) const
 {
   octave_idx_type info;
   double rcon;
   return solve (b, info, rcon, 0);
@@ -2067,17 +2071,17 @@ Matrix::lssolve (const Matrix& b, octave
                  octave_idx_type& rank) const
 {
   double rcon;
   return lssolve (b, info, rank, rcon);
 }
 
 Matrix
 Matrix::lssolve (const Matrix& b, octave_idx_type& info,
-                 octave_idx_type& rank, double &rcon) const
+                 octave_idx_type& rank, double& rcon) const
 {
   Matrix retval;
 
   F77_INT nrhs = octave::to_f77_int (b.cols ());
 
   F77_INT m = octave::to_f77_int (rows ());
   F77_INT n = octave::to_f77_int (cols ());
 
@@ -2287,17 +2291,17 @@ Matrix::lssolve (const ColumnVector& b, 
                  octave_idx_type& rank) const
 {
   double rcon;
   return lssolve (b, info, rank, rcon);
 }
 
 ColumnVector
 Matrix::lssolve (const ColumnVector& b, octave_idx_type& info,
-                 octave_idx_type& rank, double &rcon) const
+                 octave_idx_type& rank, double& rcon) const
 {
   ColumnVector retval;
 
   F77_INT nrhs = 1;
 
   F77_INT m = octave::to_f77_int (rows ());
   F77_INT n = octave::to_f77_int (cols ());
 
@@ -2420,17 +2424,17 @@ Matrix::lssolve (const ComplexColumnVect
 {
   ComplexMatrix tmp (*this);
   double rcon;
   return tmp.lssolve (b, info, rank, rcon);
 }
 
 ComplexColumnVector
 Matrix::lssolve (const ComplexColumnVector& b, octave_idx_type& info,
-                 octave_idx_type& rank, double &rcon) const
+                 octave_idx_type& rank, double& rcon) const
 {
   ComplexMatrix tmp (*this);
   return tmp.lssolve (b, info, rank, rcon);
 }
 
 Matrix&
 Matrix::operator += (const DiagMatrix& a)
 {
diff --git a/liboctave/array/dMatrix.h b/liboctave/array/dMatrix.h
--- a/liboctave/array/dMatrix.h
+++ b/liboctave/array/dMatrix.h
@@ -143,108 +143,108 @@ public:
   ColumnVector column (octave_idx_type i) const;
 
   void resize (octave_idx_type nr, octave_idx_type nc, double rfv = 0)
   {
     MArray<double>::resize (dim_vector (nr, nc), rfv);
   }
 
 private:
-  Matrix tinverse (MatrixType &mattype, octave_idx_type& info, double& rcon,
+  Matrix tinverse (MatrixType& mattype, octave_idx_type& info, double& rcon,
                    bool force, bool calc_cond) const;
 
-  Matrix finverse (MatrixType &mattype, octave_idx_type& info, double& rcon,
+  Matrix finverse (MatrixType& mattype, octave_idx_type& info, double& rcon,
                    bool force, bool calc_cond) const;
 
 public:
   Matrix inverse (void) const;
   Matrix inverse (octave_idx_type& info) const;
   Matrix inverse (octave_idx_type& info, double& rcon, bool force = false,
                   bool calc_cond = true) const;
 
-  Matrix inverse (MatrixType &mattype) const;
-  Matrix inverse (MatrixType &mattype, octave_idx_type& info) const;
-  Matrix inverse (MatrixType &mattype, octave_idx_type& info, double& rcon,
+  Matrix inverse (MatrixType& mattype) const;
+  Matrix inverse (MatrixType& mattype, octave_idx_type& info) const;
+  Matrix inverse (MatrixType& mattype, octave_idx_type& info, double& rcon,
                   bool force = false, bool calc_cond = true) const;
 
   Matrix pseudo_inverse (double tol = 0.0) const;
 
   ComplexMatrix fourier (void) const;
   ComplexMatrix ifourier (void) const;
 
   ComplexMatrix fourier2d (void) const;
   ComplexMatrix ifourier2d (void) const;
 
   DET determinant (void) const;
   DET determinant (octave_idx_type& info) const;
   DET determinant (octave_idx_type& info, double& rcon,
                    bool calc_cond = true) const;
-  DET determinant (MatrixType &mattype, octave_idx_type& info,
+  DET determinant (MatrixType& mattype, octave_idx_type& info,
                    double& rcon, bool calc_cond = true) const;
 
   double rcond (void) const;
-  double rcond (MatrixType &mattype) const;
+  double rcond (MatrixType& mattype) const;
 
 private:
   // Upper triangular matrix solvers
-  Matrix utsolve (MatrixType &typ, const Matrix& b, octave_idx_type& info,
+  Matrix utsolve (MatrixType& mattype, const Matrix& b, octave_idx_type& info,
                   double& rcon, solve_singularity_handler sing_handler,
                   bool calc_cond = false,
                   blas_trans_type transt = blas_no_trans) const;
 
   // Lower triangular matrix solvers
-  Matrix ltsolve (MatrixType &typ, const Matrix& b, octave_idx_type& info,
+  Matrix ltsolve (MatrixType& mattype, const Matrix& b, octave_idx_type& info,
                   double& rcon, solve_singularity_handler sing_handler,
                   bool calc_cond = false,
                   blas_trans_type transt = blas_no_trans) const;
 
   // Full matrix solvers (lu/cholesky)
-  Matrix fsolve (MatrixType &typ, const Matrix& b, octave_idx_type& info,
+  Matrix fsolve (MatrixType& mattype, const Matrix& b, octave_idx_type& info,
                  double& rcon, solve_singularity_handler sing_handler,
                  bool calc_cond = false) const;
 
 public:
   // Generic interface to solver with no probing of type
-  Matrix solve (MatrixType &typ, const Matrix& b) const;
-  Matrix solve (MatrixType &typ, const Matrix& b, octave_idx_type& info) const;
-  Matrix solve (MatrixType &typ, const Matrix& b, octave_idx_type& info,
+  Matrix solve (MatrixType& mattype, const Matrix& b) const;
+  Matrix solve (MatrixType& mattype, const Matrix& b, octave_idx_type& info) const;
+  Matrix solve (MatrixType& mattype, const Matrix& b, octave_idx_type& info,
                 double& rcon) const;
-  Matrix solve (MatrixType &typ, const Matrix& b, octave_idx_type& info,
+  Matrix solve (MatrixType& mattype, const Matrix& b, octave_idx_type& info,
                 double& rcon, solve_singularity_handler sing_handler,
                 bool singular_fallback = true,
                 blas_trans_type transt = blas_no_trans) const;
 
-  ComplexMatrix solve (MatrixType &typ, const ComplexMatrix& b) const;
-  ComplexMatrix solve (MatrixType &typ, const ComplexMatrix& b,
+  ComplexMatrix solve (MatrixType& mattype, const ComplexMatrix& b) const;
+  ComplexMatrix solve (MatrixType& mattype, const ComplexMatrix& b,
                        octave_idx_type& info) const;
-  ComplexMatrix solve (MatrixType &typ, const ComplexMatrix& b,
+  ComplexMatrix solve (MatrixType& mattype, const ComplexMatrix& b,
                        octave_idx_type& info, double& rcon) const;
-  ComplexMatrix solve (MatrixType &typ, const ComplexMatrix& b,
+  ComplexMatrix solve (MatrixType& mattype, const ComplexMatrix& b,
                        octave_idx_type& info, double& rcon,
                        solve_singularity_handler sing_handler,
                        bool singular_fallback = true,
                        blas_trans_type transt = blas_no_trans) const;
 
-  ColumnVector solve (MatrixType &typ, const ColumnVector& b) const;
-  ColumnVector solve (MatrixType &typ, const ColumnVector& b,
+  ColumnVector solve (MatrixType& mattype, const ColumnVector& b) const;
+  ColumnVector solve (MatrixType& mattype, const ColumnVector& b,
                       octave_idx_type& info) const;
-  ColumnVector solve (MatrixType &typ, const ColumnVector& b,
+  ColumnVector solve (MatrixType& mattype, const ColumnVector& b,
                       octave_idx_type& info, double& rcon) const;
-  ColumnVector solve (MatrixType &typ, const ColumnVector& b,
+  ColumnVector solve (MatrixType& mattype, const ColumnVector& b,
                       octave_idx_type& info, double& rcon,
                       solve_singularity_handler sing_handler,
                       blas_trans_type transt = blas_no_trans) const;
 
-  ComplexColumnVector solve (MatrixType &typ,
+  ComplexColumnVector solve (MatrixType& mattype,
                              const ComplexColumnVector& b) const;
-  ComplexColumnVector solve (MatrixType &typ, const ComplexColumnVector& b,
+  ComplexColumnVector solve (MatrixType& mattype, const ComplexColumnVector& b,
                              octave_idx_type& info) const;
-  ComplexColumnVector solve (MatrixType &typ, const ComplexColumnVector& b,
+  ComplexColumnVector solve (MatrixType& mattype, const ComplexColumnVector& b,
                              octave_idx_type& info, double& rcon) const;
-  ComplexColumnVector solve (MatrixType &typ, const ComplexColumnVector& b,
+  ComplexColumnVector solve (MatrixType& mattype, const ComplexColumnVector& b,
                              octave_idx_type& info, double& rcon,
                              solve_singularity_handler sing_handler,
                              blas_trans_type transt = blas_no_trans) const;
 
   // Generic interface to solver with probing of type
   Matrix solve (const Matrix& b) const;
   Matrix solve (const Matrix& b, octave_idx_type& info) const;
   Matrix solve (const Matrix& b, octave_idx_type& info, double& rcon) const;
@@ -288,17 +288,17 @@ public:
   Matrix lssolve (const Matrix& b, octave_idx_type& info,
                   octave_idx_type& rank, double& rcon) const;
 
   ComplexMatrix lssolve (const ComplexMatrix& b) const;
   ComplexMatrix lssolve (const ComplexMatrix& b, octave_idx_type& info) const;
   ComplexMatrix lssolve (const ComplexMatrix& b, octave_idx_type& info,
                          octave_idx_type& rank) const;
   ComplexMatrix lssolve (const ComplexMatrix& b, octave_idx_type& info,
-                         octave_idx_type& rank, double &rcon) const;
+                         octave_idx_type& rank, double& rcon) const;
 
   ColumnVector lssolve (const ColumnVector& b) const;
   ColumnVector lssolve (const ColumnVector& b, octave_idx_type& info) const;
   ColumnVector lssolve (const ColumnVector& b, octave_idx_type& info,
                         octave_idx_type& rank) const;
   ColumnVector lssolve (const ColumnVector& b, octave_idx_type& info,
                         octave_idx_type& rank, double& rcon) const;
 
diff --git a/liboctave/array/dSparse.cc b/liboctave/array/dSparse.cc
--- a/liboctave/array/dSparse.cc
+++ b/liboctave/array/dSparse.cc
@@ -60,17 +60,17 @@ along with Octave; see the file COPYING.
 
 // Define whether to use a basic QR solver or one that uses a Dulmange
 // Mendelsohn factorization to seperate the problem into under-determined,
 // well-determined and over-determined parts and solves them seperately
 #if ! defined (USE_QRSOLVE)
 #  include "sparse-dmsolve.h"
 #endif
 
-SparseMatrix::SparseMatrix (const SparseBoolMatrix &a)
+SparseMatrix::SparseMatrix (const SparseBoolMatrix& a)
   : MSparse<double> (a.rows (), a.cols (), a.nnz ())
 {
   octave_idx_type nc = cols ();
   octave_idx_type nz = a.nnz ();
 
   for (octave_idx_type i = 0; i < nc + 1; i++)
     cidx (i) = a.cidx (i);
 
@@ -757,32 +757,32 @@ SparseMatrix::inverse (MatrixType& matty
 SparseMatrix
 SparseMatrix::inverse (MatrixType& mattype, octave_idx_type& info) const
 {
   double rcond;
   return inverse (mattype, info, rcond, 0, 0);
 }
 
 SparseMatrix
-SparseMatrix::dinverse (MatrixType &mattyp, octave_idx_type& info,
+SparseMatrix::dinverse (MatrixType& mattype, octave_idx_type& info,
                         double& rcond, const bool,
                         const bool calccond) const
 {
   SparseMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   info = 0;
 
   if (nr == 0 || nc == 0 || nr != nc)
     (*current_liboctave_error_handler) ("inverse requires square matrix");
 
   // Print spparms("spumoni") info if requested
-  int typ = mattyp.type ();
-  mattyp.info ();
+  int typ = mattype.type ();
+  mattype.info ();
 
   if (typ != MatrixType::Diagonal && typ != MatrixType::Permuted_Diagonal)
     (*current_liboctave_error_handler) ("incorrect matrix type");
 
   if (typ == MatrixType::Permuted_Diagonal)
     retval = transpose ();
   else
     retval = *this;
@@ -807,32 +807,32 @@ SparseMatrix::dinverse (MatrixType &matt
 
   for (octave_idx_type i = 0; i < nr; i++)
     v[i] = 1.0 / v[i];
 
   return retval;
 }
 
 SparseMatrix
-SparseMatrix::tinverse (MatrixType &mattyp, octave_idx_type& info,
+SparseMatrix::tinverse (MatrixType& mattype, octave_idx_type& info,
                         double& rcond, const bool,
                         const bool calccond) const
 {
   SparseMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   info = 0;
 
   if (nr == 0 || nc == 0 || nr != nc)
     (*current_liboctave_error_handler) ("inverse requires square matrix");
 
   // Print spparms("spumoni") info if requested
-  int typ = mattyp.type ();
-  mattyp.info ();
+  int typ = mattype.type ();
+  mattype.info ();
 
   if (typ != MatrixType::Upper && typ != MatrixType::Permuted_Upper
       && typ != MatrixType::Lower && typ != MatrixType::Permuted_Lower)
     (*current_liboctave_error_handler) ("incorrect matrix type");
 
   double anorm = 0.;
   double ainvnorm = 0.;
 
@@ -949,17 +949,17 @@ SparseMatrix::tinverse (MatrixType &matt
       octave_idx_type nz = nnz ();
       octave_idx_type cx = 0;
       octave_idx_type nz2 = nz;
       retval = SparseMatrix (nr, nc, nz2);
 
       OCTAVE_LOCAL_BUFFER (double, work, nr);
       OCTAVE_LOCAL_BUFFER (octave_idx_type, rperm, nr);
 
-      octave_idx_type *perm = mattyp.triangular_perm ();
+      octave_idx_type *perm = mattype.triangular_perm ();
       if (typ == MatrixType::Permuted_Upper)
         {
           for (octave_idx_type i = 0; i < nr; i++)
             rperm[perm[i]] = i;
         }
       else
         {
           for (octave_idx_type i = 0; i < nr; i++)
@@ -1058,17 +1058,17 @@ SparseMatrix::tinverse (MatrixType &matt
 
       rcond = 1. / ainvnorm / anorm;
     }
 
   return retval;
 }
 
 SparseMatrix
-SparseMatrix::inverse (MatrixType &mattype, octave_idx_type& info,
+SparseMatrix::inverse (MatrixType& mattype, octave_idx_type& info,
                        double& rcond, bool, bool calc_cond) const
 {
   int typ = mattype.type (false);
   SparseMatrix ret;
 
   if (typ == MatrixType::Unknown)
     typ = mattype.type (*this);
 
@@ -1270,17 +1270,17 @@ SparseMatrix::determinant (octave_idx_ty
      "when liboctave was built");
 
 #endif
 
   return retval;
 }
 
 Matrix
-SparseMatrix::dsolve (MatrixType &mattype, const Matrix& b,
+SparseMatrix::dsolve (MatrixType& mattype, const Matrix& b,
                       octave_idx_type& err,
                       double& rcond, solve_singularity_handler,
                       bool calc_cond) const
 {
   Matrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
@@ -1330,17 +1330,17 @@ SparseMatrix::dsolve (MatrixType &mattyp
       else
         rcond = 1.;
     }
 
   return retval;
 }
 
 SparseMatrix
-SparseMatrix::dsolve (MatrixType &mattype, const SparseMatrix& b,
+SparseMatrix::dsolve (MatrixType& mattype, const SparseMatrix& b,
                       octave_idx_type& err, double& rcond,
                       solve_singularity_handler, bool calc_cond) const
 {
   SparseMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc < nr ? nc : nr);
@@ -1419,17 +1419,17 @@ SparseMatrix::dsolve (MatrixType &mattyp
       else
         rcond = 1.;
     }
 
   return retval;
 }
 
 ComplexMatrix
-SparseMatrix::dsolve (MatrixType &mattype, const ComplexMatrix& b,
+SparseMatrix::dsolve (MatrixType& mattype, const ComplexMatrix& b,
                       octave_idx_type& err, double& rcond,
                       solve_singularity_handler, bool calc_cond) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc < nr ? nc : nr);
@@ -1478,17 +1478,17 @@ SparseMatrix::dsolve (MatrixType &mattyp
       else
         rcond = 1.;
     }
 
   return retval;
 }
 
 SparseComplexMatrix
-SparseMatrix::dsolve (MatrixType &mattype, const SparseComplexMatrix& b,
+SparseMatrix::dsolve (MatrixType& mattype, const SparseComplexMatrix& b,
                       octave_idx_type& err, double& rcond,
                       solve_singularity_handler, bool calc_cond) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc < nr ? nc : nr);
@@ -1567,17 +1567,17 @@ SparseMatrix::dsolve (MatrixType &mattyp
       else
         rcond = 1.;
     }
 
   return retval;
 }
 
 Matrix
-SparseMatrix::utsolve (MatrixType &mattype, const Matrix& b,
+SparseMatrix::utsolve (MatrixType& mattype, const Matrix& b,
                        octave_idx_type& err, double& rcond,
                        solve_singularity_handler sing_handler,
                        bool calc_cond) const
 {
   Matrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
@@ -1796,17 +1796,17 @@ SparseMatrix::utsolve (MatrixType &matty
             octave::warn_singular_matrix (rcond);
         }
     }
 
   return retval;
 }
 
 SparseMatrix
-SparseMatrix::utsolve (MatrixType &mattype, const SparseMatrix& b,
+SparseMatrix::utsolve (MatrixType& mattype, const SparseMatrix& b,
                        octave_idx_type& err, double& rcond,
                        solve_singularity_handler sing_handler,
                        bool calc_cond) const
 {
   SparseMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
@@ -2077,17 +2077,17 @@ SparseMatrix::utsolve (MatrixType &matty
           else
             octave::warn_singular_matrix (rcond);
         }
     }
   return retval;
 }
 
 ComplexMatrix
-SparseMatrix::utsolve (MatrixType &mattype, const ComplexMatrix& b,
+SparseMatrix::utsolve (MatrixType& mattype, const ComplexMatrix& b,
                        octave_idx_type& err, double& rcond,
                        solve_singularity_handler sing_handler,
                        bool calc_cond) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
@@ -2309,17 +2309,17 @@ SparseMatrix::utsolve (MatrixType &matty
             octave::warn_singular_matrix (rcond);
         }
     }
 
   return retval;
 }
 
 SparseComplexMatrix
-SparseMatrix::utsolve (MatrixType &mattype, const SparseComplexMatrix& b,
+SparseMatrix::utsolve (MatrixType& mattype, const SparseComplexMatrix& b,
                        octave_idx_type& err, double& rcond,
                        solve_singularity_handler sing_handler,
                        bool calc_cond) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
@@ -2593,17 +2593,17 @@ SparseMatrix::utsolve (MatrixType &matty
             octave::warn_singular_matrix (rcond);
         }
     }
 
   return retval;
 }
 
 Matrix
-SparseMatrix::ltsolve (MatrixType &mattype, const Matrix& b,
+SparseMatrix::ltsolve (MatrixType& mattype, const Matrix& b,
                        octave_idx_type& err, double& rcond,
                        solve_singularity_handler sing_handler,
                        bool calc_cond) const
 {
   Matrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
@@ -2846,17 +2846,17 @@ SparseMatrix::ltsolve (MatrixType &matty
             octave::warn_singular_matrix (rcond);
         }
     }
 
   return retval;
 }
 
 SparseMatrix
-SparseMatrix::ltsolve (MatrixType &mattype, const SparseMatrix& b,
+SparseMatrix::ltsolve (MatrixType& mattype, const SparseMatrix& b,
                        octave_idx_type& err, double& rcond,
                        solve_singularity_handler sing_handler,
                        bool calc_cond) const
 {
   SparseMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
@@ -3146,17 +3146,17 @@ SparseMatrix::ltsolve (MatrixType &matty
             octave::warn_singular_matrix (rcond);
         }
     }
 
   return retval;
 }
 
 ComplexMatrix
-SparseMatrix::ltsolve (MatrixType &mattype, const ComplexMatrix& b,
+SparseMatrix::ltsolve (MatrixType& mattype, const ComplexMatrix& b,
                        octave_idx_type& err, double& rcond,
                        solve_singularity_handler sing_handler,
                        bool calc_cond) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
@@ -3400,17 +3400,17 @@ SparseMatrix::ltsolve (MatrixType &matty
             octave::warn_singular_matrix (rcond);
         }
     }
 
   return retval;
 }
 
 SparseComplexMatrix
-SparseMatrix::ltsolve (MatrixType &mattype, const SparseComplexMatrix& b,
+SparseMatrix::ltsolve (MatrixType& mattype, const SparseComplexMatrix& b,
                        octave_idx_type& err, double& rcond,
                        solve_singularity_handler sing_handler,
                        bool calc_cond) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
@@ -3702,17 +3702,17 @@ SparseMatrix::ltsolve (MatrixType &matty
             octave::warn_singular_matrix (rcond);
         }
     }
 
   return retval;
 }
 
 Matrix
-SparseMatrix::trisolve (MatrixType &mattype, const Matrix& b,
+SparseMatrix::trisolve (MatrixType& mattype, const Matrix& b,
                         octave_idx_type& err, double& rcond,
                         solve_singularity_handler sing_handler,
                         bool calc_cond) const
 {
   Matrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
@@ -3868,17 +3868,17 @@ SparseMatrix::trisolve (MatrixType &matt
       else if (typ != MatrixType::Tridiagonal_Hermitian)
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseMatrix
-SparseMatrix::trisolve (MatrixType &mattype, const SparseMatrix& b,
+SparseMatrix::trisolve (MatrixType& mattype, const SparseMatrix& b,
                         octave_idx_type& err, double& rcond,
                         solve_singularity_handler sing_handler,
                         bool calc_cond) const
 {
   SparseMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
@@ -4022,17 +4022,17 @@ SparseMatrix::trisolve (MatrixType &matt
       else if (typ != MatrixType::Tridiagonal_Hermitian)
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 ComplexMatrix
-SparseMatrix::trisolve (MatrixType &mattype, const ComplexMatrix& b,
+SparseMatrix::trisolve (MatrixType& mattype, const ComplexMatrix& b,
                         octave_idx_type& err, double& rcond,
                         solve_singularity_handler sing_handler,
                         bool calc_cond) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
@@ -4192,17 +4192,17 @@ SparseMatrix::trisolve (MatrixType &matt
       else if (typ != MatrixType::Tridiagonal_Hermitian)
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseComplexMatrix
-SparseMatrix::trisolve (MatrixType &mattype, const SparseComplexMatrix& b,
+SparseMatrix::trisolve (MatrixType& mattype, const SparseComplexMatrix& b,
                         octave_idx_type& err, double& rcond,
                         solve_singularity_handler sing_handler,
                         bool calc_cond) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
@@ -4383,17 +4383,17 @@ SparseMatrix::trisolve (MatrixType &matt
       else if (typ != MatrixType::Tridiagonal_Hermitian)
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 Matrix
-SparseMatrix::bsolve (MatrixType &mattype, const Matrix& b,
+SparseMatrix::bsolve (MatrixType& mattype, const Matrix& b,
                       octave_idx_type& err, double& rcond,
                       solve_singularity_handler sing_handler,
                       bool calc_cond) const
 {
   Matrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
@@ -4652,17 +4652,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
       else if (typ != MatrixType::Banded_Hermitian)
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseMatrix
-SparseMatrix::bsolve (MatrixType &mattype, const SparseMatrix& b,
+SparseMatrix::bsolve (MatrixType& mattype, const SparseMatrix& b,
                       octave_idx_type& err, double& rcond,
                       solve_singularity_handler sing_handler,
                       bool calc_cond) const
 {
   SparseMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
@@ -4990,17 +4990,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
       else if (typ != MatrixType::Banded_Hermitian)
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 ComplexMatrix
-SparseMatrix::bsolve (MatrixType &mattype, const ComplexMatrix& b,
+SparseMatrix::bsolve (MatrixType& mattype, const ComplexMatrix& b,
                       octave_idx_type& err, double& rcond,
                       solve_singularity_handler sing_handler,
                       bool calc_cond) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
@@ -5313,17 +5313,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
       else if (typ != MatrixType::Banded_Hermitian)
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseComplexMatrix
-SparseMatrix::bsolve (MatrixType &mattype, const SparseComplexMatrix& b,
+SparseMatrix::bsolve (MatrixType& mattype, const SparseComplexMatrix& b,
                       octave_idx_type& err, double& rcond,
                       solve_singularity_handler sing_handler,
                       bool calc_cond) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
@@ -5699,18 +5699,18 @@ SparseMatrix::bsolve (MatrixType &mattyp
       else if (typ != MatrixType::Banded_Hermitian)
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 void *
-SparseMatrix::factorize (octave_idx_type& err, double &rcond, Matrix &Control,
-                         Matrix &Info, solve_singularity_handler sing_handler,
+SparseMatrix::factorize (octave_idx_type& err, double& rcond, Matrix& Control,
+                         Matrix& Info, solve_singularity_handler sing_handler,
                          bool calc_cond) const
 {
   // The return values
   void *Numeric = 0;
   err = 0;
 
 #if defined (HAVE_UMFPACK)
 
@@ -5827,17 +5827,17 @@ SparseMatrix::factorize (octave_idx_type
      "when liboctave was built");
 
 #endif
 
   return Numeric;
 }
 
 Matrix
-SparseMatrix::fsolve (MatrixType &mattype, const Matrix& b,
+SparseMatrix::fsolve (MatrixType& mattype, const Matrix& b,
                       octave_idx_type& err, double& rcond,
                       solve_singularity_handler sing_handler,
                       bool calc_cond) const
 {
   Matrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
@@ -6052,17 +6052,17 @@ SparseMatrix::fsolve (MatrixType &mattyp
       else if (typ != MatrixType::Hermitian)
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseMatrix
-SparseMatrix::fsolve (MatrixType &mattype, const SparseMatrix& b,
+SparseMatrix::fsolve (MatrixType& mattype, const SparseMatrix& b,
                       octave_idx_type& err, double& rcond,
                       solve_singularity_handler sing_handler,
                       bool calc_cond) const
 {
   SparseMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
@@ -6323,17 +6323,17 @@ SparseMatrix::fsolve (MatrixType &mattyp
       else if (typ != MatrixType::Hermitian)
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 ComplexMatrix
-SparseMatrix::fsolve (MatrixType &mattype, const ComplexMatrix& b,
+SparseMatrix::fsolve (MatrixType& mattype, const ComplexMatrix& b,
                       octave_idx_type& err, double& rcond,
                       solve_singularity_handler sing_handler,
                       bool calc_cond) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
@@ -6568,17 +6568,17 @@ SparseMatrix::fsolve (MatrixType &mattyp
       else if (typ != MatrixType::Hermitian)
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseComplexMatrix
-SparseMatrix::fsolve (MatrixType &mattype, const SparseComplexMatrix& b,
+SparseMatrix::fsolve (MatrixType& mattype, const SparseComplexMatrix& b,
                       octave_idx_type& err, double& rcond,
                       solve_singularity_handler sing_handler,
                       bool calc_cond) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
@@ -6851,40 +6851,40 @@ SparseMatrix::fsolve (MatrixType &mattyp
       else if (typ != MatrixType::Hermitian)
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 Matrix
-SparseMatrix::solve (MatrixType &mattype, const Matrix& b) const
+SparseMatrix::solve (MatrixType& mattype, const Matrix& b) const
 {
   octave_idx_type info;
   double rcond;
   return solve (mattype, b, info, rcond, 0);
 }
 
 Matrix
-SparseMatrix::solve (MatrixType &mattype, const Matrix& b,
+SparseMatrix::solve (MatrixType& mattype, const Matrix& b,
                      octave_idx_type& info) const
 {
   double rcond;
   return solve (mattype, b, info, rcond, 0);
 }
 
 Matrix
-SparseMatrix::solve (MatrixType &mattype, const Matrix& b,
+SparseMatrix::solve (MatrixType& mattype, const Matrix& b,
                      octave_idx_type& info, double& rcond) const
 {
   return solve (mattype, b, info, rcond, 0);
 }
 
 Matrix
-SparseMatrix::solve (MatrixType &mattype, const Matrix& b, octave_idx_type& err,
+SparseMatrix::solve (MatrixType& mattype, const Matrix& b, octave_idx_type& err,
                      double& rcond, solve_singularity_handler sing_handler,
                      bool singular_fallback) const
 {
   Matrix retval;
   int typ = mattype.type (false);
 
   if (typ == MatrixType::Unknown)
     typ = mattype.type (*this);
@@ -6916,40 +6916,40 @@ SparseMatrix::solve (MatrixType &mattype
       retval = dmsolve<Matrix, SparseMatrix, Matrix> (*this, b, err);
 #endif
     }
 
   return retval;
 }
 
 SparseMatrix
-SparseMatrix::solve (MatrixType &mattype, const SparseMatrix& b) const
+SparseMatrix::solve (MatrixType& mattype, const SparseMatrix& b) const
 {
   octave_idx_type info;
   double rcond;
   return solve (mattype, b, info, rcond, 0);
 }
 
 SparseMatrix
-SparseMatrix::solve (MatrixType &mattype, const SparseMatrix& b,
+SparseMatrix::solve (MatrixType& mattype, const SparseMatrix& b,
                      octave_idx_type& info) const
 {
   double rcond;
   return solve (mattype, b, info, rcond, 0);
 }
 
 SparseMatrix
-SparseMatrix::solve (MatrixType &mattype, const SparseMatrix& b,
+SparseMatrix::solve (MatrixType& mattype, const SparseMatrix& b,
                      octave_idx_type& info, double& rcond) const
 {
   return solve (mattype, b, info, rcond, 0);
 }
 
 SparseMatrix
-SparseMatrix::solve (MatrixType &mattype, const SparseMatrix& b,
+SparseMatrix::solve (MatrixType& mattype, const SparseMatrix& b,
                      octave_idx_type& err, double& rcond,
                      solve_singularity_handler sing_handler,
                      bool singular_fallback) const
 {
   SparseMatrix retval;
   int typ = mattype.type (false);
 
   if (typ == MatrixType::Unknown)
@@ -6981,40 +6981,40 @@ SparseMatrix::solve (MatrixType &mattype
                (*this, b, err);
 #endif
     }
 
   return retval;
 }
 
 ComplexMatrix
-SparseMatrix::solve (MatrixType &mattype, const ComplexMatrix& b) const
+SparseMatrix::solve (MatrixType& mattype, const ComplexMatrix& b) const
 {
   octave_idx_type info;
   double rcond;
   return solve (mattype, b, info, rcond, 0);
 }
 
 ComplexMatrix
-SparseMatrix::solve (MatrixType &mattype, const ComplexMatrix& b,
+SparseMatrix::solve (MatrixType& mattype, const ComplexMatrix& b,
                      octave_idx_type& info) const
 {
   double rcond;
   return solve (mattype, b, info, rcond, 0);
 }
 
 ComplexMatrix
-SparseMatrix::solve (MatrixType &mattype, const ComplexMatrix& b,
+SparseMatrix::solve (MatrixType& mattype, const ComplexMatrix& b,
                      octave_idx_type& info, double& rcond) const
 {
   return solve (mattype, b, info, rcond, 0);
 }
 
 ComplexMatrix
-SparseMatrix::solve (MatrixType &mattype, const ComplexMatrix& b,
+SparseMatrix::solve (MatrixType& mattype, const ComplexMatrix& b,
                      octave_idx_type& err, double& rcond,
                      solve_singularity_handler sing_handler,
                      bool singular_fallback) const
 {
   ComplexMatrix retval;
   int typ = mattype.type (false);
 
   if (typ == MatrixType::Unknown)
@@ -7046,40 +7046,40 @@ SparseMatrix::solve (MatrixType &mattype
                (*this, b, err);
 #endif
     }
 
   return retval;
 }
 
 SparseComplexMatrix
-SparseMatrix::solve (MatrixType &mattype, const SparseComplexMatrix& b) const
+SparseMatrix::solve (MatrixType& mattype, const SparseComplexMatrix& b) const
 {
   octave_idx_type info;
   double rcond;
   return solve (mattype, b, info, rcond, 0);
 }
 
 SparseComplexMatrix
-SparseMatrix::solve (MatrixType &mattype, const SparseComplexMatrix& b,
+SparseMatrix::solve (MatrixType& mattype, const SparseComplexMatrix& b,
                      octave_idx_type& info) const
 {
   double rcond;
   return solve (mattype, b, info, rcond, 0);
 }
 
 SparseComplexMatrix
-SparseMatrix::solve (MatrixType &mattype, const SparseComplexMatrix& b,
+SparseMatrix::solve (MatrixType& mattype, const SparseComplexMatrix& b,
                      octave_idx_type& info, double& rcond) const
 {
   return solve (mattype, b, info, rcond, 0);
 }
 
 SparseComplexMatrix
-SparseMatrix::solve (MatrixType &mattype, const SparseComplexMatrix& b,
+SparseMatrix::solve (MatrixType& mattype, const SparseComplexMatrix& b,
                      octave_idx_type& err, double& rcond,
                      solve_singularity_handler sing_handler,
                      bool singular_fallback) const
 {
   SparseComplexMatrix retval;
   int typ = mattype.type (false);
 
   if (typ == MatrixType::Unknown)
@@ -7111,73 +7111,73 @@ SparseMatrix::solve (MatrixType &mattype
                (*this, b, err);
 #endif
     }
 
   return retval;
 }
 
 ColumnVector
-SparseMatrix::solve (MatrixType &mattype, const ColumnVector& b) const
+SparseMatrix::solve (MatrixType& mattype, const ColumnVector& b) const
 {
   octave_idx_type info; double rcond;
   return solve (mattype, b, info, rcond);
 }
 
 ColumnVector
-SparseMatrix::solve (MatrixType &mattype, const ColumnVector& b,
+SparseMatrix::solve (MatrixType& mattype, const ColumnVector& b,
                      octave_idx_type& info) const
 {
   double rcond;
   return solve (mattype, b, info, rcond);
 }
 
 ColumnVector
-SparseMatrix::solve (MatrixType &mattype, const ColumnVector& b,
+SparseMatrix::solve (MatrixType& mattype, const ColumnVector& b,
                      octave_idx_type& info, double& rcond) const
 {
   return solve (mattype, b, info, rcond, 0);
 }
 
 ColumnVector
-SparseMatrix::solve (MatrixType &mattype, const ColumnVector& b,
+SparseMatrix::solve (MatrixType& mattype, const ColumnVector& b,
                      octave_idx_type& info, double& rcond,
                      solve_singularity_handler sing_handler) const
 {
   Matrix tmp (b);
   return solve (mattype, tmp, info, rcond,
                 sing_handler).column (static_cast<octave_idx_type> (0));
 }
 
 ComplexColumnVector
-SparseMatrix::solve (MatrixType &mattype, const ComplexColumnVector& b) const
+SparseMatrix::solve (MatrixType& mattype, const ComplexColumnVector& b) const
 {
   octave_idx_type info;
   double rcond;
   return solve (mattype, b, info, rcond, 0);
 }
 
 ComplexColumnVector
-SparseMatrix::solve (MatrixType &mattype, const ComplexColumnVector& b,
+SparseMatrix::solve (MatrixType& mattype, const ComplexColumnVector& b,
                      octave_idx_type& info) const
 {
   double rcond;
   return solve (mattype, b, info, rcond, 0);
 }
 
 ComplexColumnVector
-SparseMatrix::solve (MatrixType &mattype, const ComplexColumnVector& b,
+SparseMatrix::solve (MatrixType& mattype, const ComplexColumnVector& b,
                      octave_idx_type& info,
                      double& rcond) const
 {
   return solve (mattype, b, info, rcond, 0);
 }
 
 ComplexColumnVector
-SparseMatrix::solve (MatrixType &mattype, const ComplexColumnVector& b,
+SparseMatrix::solve (MatrixType& mattype, const ComplexColumnVector& b,
                      octave_idx_type& info, double& rcond,
                      solve_singularity_handler sing_handler) const
 {
   ComplexMatrix tmp (b);
   return solve (mattype, tmp, info, rcond,
                 sing_handler).column (static_cast<octave_idx_type> (0));
 }
 
diff --git a/liboctave/array/dSparse.h b/liboctave/array/dSparse.h
--- a/liboctave/array/dSparse.h
+++ b/liboctave/array/dSparse.h
@@ -146,21 +146,21 @@ public:
 
   // extract row or column i.
 
   RowVector row (octave_idx_type i) const;
 
   ColumnVector column (octave_idx_type i) const;
 
 private:
-  SparseMatrix dinverse (MatrixType &mattyp, octave_idx_type& info,
+  SparseMatrix dinverse (MatrixType& mattype, octave_idx_type& info,
                          double& rcond, const bool force = false,
                          const bool calccond = true) const;
 
-  SparseMatrix tinverse (MatrixType &mattyp, octave_idx_type& info,
+  SparseMatrix tinverse (MatrixType& mattype, octave_idx_type& info,
                          double& rcond, const bool force = false,
                          const bool calccond = true) const;
 
 public:
   SparseMatrix inverse (void) const;
   SparseMatrix inverse (MatrixType& mattype) const;
   SparseMatrix inverse (MatrixType& mattype, octave_idx_type& info) const;
   SparseMatrix inverse (MatrixType& mattype, octave_idx_type& info,
@@ -169,196 +169,196 @@ public:
 
   DET determinant (void) const;
   DET determinant (octave_idx_type& info) const;
   DET determinant (octave_idx_type& info, double& rcond,
                    bool calc_cond = true) const;
 
 private:
   // Diagonal matrix solvers
-  Matrix dsolve (MatrixType &typ, const Matrix& b, octave_idx_type& info,
+  Matrix dsolve (MatrixType& typ, const Matrix& b, octave_idx_type& info,
                  double& rcond, solve_singularity_handler sing_handler,
                  bool calc_cond = false) const;
 
-  ComplexMatrix dsolve (MatrixType &typ, const ComplexMatrix& b,
+  ComplexMatrix dsolve (MatrixType& typ, const ComplexMatrix& b,
                         octave_idx_type& info, double& rcond,
                         solve_singularity_handler sing_handler,
                         bool calc_cond = false) const;
 
-  SparseMatrix dsolve (MatrixType &typ, const SparseMatrix& b,
+  SparseMatrix dsolve (MatrixType& typ, const SparseMatrix& b,
                        octave_idx_type& info, double& rcond,
                        solve_singularity_handler sing_handler,
                        bool calc_cond = false) const;
 
-  SparseComplexMatrix dsolve (MatrixType &typ, const SparseComplexMatrix& b,
+  SparseComplexMatrix dsolve (MatrixType& typ, const SparseComplexMatrix& b,
                               octave_idx_type& info, double& rcond,
                               solve_singularity_handler sing_handler,
                               bool calc_cond = false) const;
 
   // Upper triangular matrix solvers
-  Matrix utsolve (MatrixType &typ, const Matrix& b, octave_idx_type& info,
+  Matrix utsolve (MatrixType& typ, const Matrix& b, octave_idx_type& info,
                   double& rcond, solve_singularity_handler sing_handler,
                   bool calc_cond = false) const;
 
-  ComplexMatrix utsolve (MatrixType &typ, const ComplexMatrix& b,
+  ComplexMatrix utsolve (MatrixType& typ, const ComplexMatrix& b,
                          octave_idx_type& info, double& rcond,
                          solve_singularity_handler sing_handler,
                          bool calc_cond = false) const;
 
-  SparseMatrix utsolve (MatrixType &typ, const SparseMatrix& b,
+  SparseMatrix utsolve (MatrixType& typ, const SparseMatrix& b,
                         octave_idx_type& info, double& rcond,
                         solve_singularity_handler sing_handler,
                         bool calc_cond = false) const;
 
-  SparseComplexMatrix utsolve (MatrixType &typ, const SparseComplexMatrix& b,
+  SparseComplexMatrix utsolve (MatrixType& typ, const SparseComplexMatrix& b,
                                octave_idx_type& info, double& rcond,
                                solve_singularity_handler sing_handler,
                                bool calc_cond = false) const;
 
   // Lower triangular matrix solvers
-  Matrix ltsolve (MatrixType &typ, const Matrix& b, octave_idx_type& info,
+  Matrix ltsolve (MatrixType& typ, const Matrix& b, octave_idx_type& info,
                   double& rcond, solve_singularity_handler sing_handler,
                   bool calc_cond = false) const;
 
-  ComplexMatrix ltsolve (MatrixType &typ, const ComplexMatrix& b,
+  ComplexMatrix ltsolve (MatrixType& typ, const ComplexMatrix& b,
                          octave_idx_type& info, double& rcond,
                          solve_singularity_handler sing_handler,
                          bool calc_cond = false) const;
 
-  SparseMatrix ltsolve (MatrixType &typ, const SparseMatrix& b,
+  SparseMatrix ltsolve (MatrixType& typ, const SparseMatrix& b,
                         octave_idx_type& info, double& rcond,
                         solve_singularity_handler sing_handler,
                         bool calc_cond = false) const;
 
-  SparseComplexMatrix ltsolve (MatrixType &typ, const SparseComplexMatrix& b,
+  SparseComplexMatrix ltsolve (MatrixType& typ, const SparseComplexMatrix& b,
                                octave_idx_type& info, double& rcond,
                                solve_singularity_handler sing_handler,
                                bool calc_cond = false) const;
 
   // Tridiagonal matrix solvers
-  Matrix trisolve (MatrixType &typ, const Matrix& b, octave_idx_type& info,
+  Matrix trisolve (MatrixType& typ, const Matrix& b, octave_idx_type& info,
                    double& rcond, solve_singularity_handler sing_handler,
                    bool calc_cond = false) const;
 
-  ComplexMatrix trisolve (MatrixType &typ, const ComplexMatrix& b,
+  ComplexMatrix trisolve (MatrixType& typ, const ComplexMatrix& b,
                           octave_idx_type& info, double& rcond,
                           solve_singularity_handler sing_handler,
                           bool calc_cond = false) const;
 
-  SparseMatrix trisolve (MatrixType &typ, const SparseMatrix& b,
+  SparseMatrix trisolve (MatrixType& typ, const SparseMatrix& b,
                          octave_idx_type& info, double& rcond,
                          solve_singularity_handler sing_handler,
                          bool calc_cond = false) const;
 
-  SparseComplexMatrix trisolve (MatrixType &typ, const SparseComplexMatrix& b,
+  SparseComplexMatrix trisolve (MatrixType& typ, const SparseComplexMatrix& b,
                                 octave_idx_type& info, double& rcond,
                                 solve_singularity_handler sing_handler,
                                 bool calc_cond = false) const;
 
   // Banded matrix solvers (umfpack/cholesky)
-  Matrix bsolve (MatrixType &typ, const Matrix& b, octave_idx_type& info,
+  Matrix bsolve (MatrixType& typ, const Matrix& b, octave_idx_type& info,
                  double& rcond, solve_singularity_handler sing_handler,
                  bool calc_cond = false) const;
 
-  ComplexMatrix bsolve (MatrixType &typ, const ComplexMatrix& b,
+  ComplexMatrix bsolve (MatrixType& typ, const ComplexMatrix& b,
                         octave_idx_type& info, double& rcond,
                         solve_singularity_handler sing_handler,
                         bool calc_cond = false) const;
 
-  SparseMatrix bsolve (MatrixType &typ, const SparseMatrix& b,
+  SparseMatrix bsolve (MatrixType& typ, const SparseMatrix& b,
                        octave_idx_type& info, double& rcond,
                        solve_singularity_handler sing_handler,
                        bool calc_cond = false) const;
 
-  SparseComplexMatrix bsolve (MatrixType &typ, const SparseComplexMatrix& b,
+  SparseComplexMatrix bsolve (MatrixType& typ, const SparseComplexMatrix& b,
                               octave_idx_type& info, double& rcond,
                               solve_singularity_handler sing_handler,
                               bool calc_cond = false) const;
 
   // Full matrix solvers (umfpack/cholesky)
-  void * factorize (octave_idx_type& err, double &rcond, Matrix &Control,
-                    Matrix &Info, solve_singularity_handler sing_handler,
+  void * factorize (octave_idx_type& err, double& rcond, Matrix& Control,
+                    Matrix& Info, solve_singularity_handler sing_handler,
                     bool calc_cond = false) const;
 
-  Matrix fsolve (MatrixType &typ, const Matrix& b, octave_idx_type& info,
+  Matrix fsolve (MatrixType& typ, const Matrix& b, octave_idx_type& info,
                  double& rcond, solve_singularity_handler sing_handler,
                  bool calc_cond = false) const;
 
-  ComplexMatrix fsolve (MatrixType &typ, const ComplexMatrix& b,
+  ComplexMatrix fsolve (MatrixType& typ, const ComplexMatrix& b,
                         octave_idx_type& info, double& rcond,
                         solve_singularity_handler sing_handler,
                         bool calc_cond = false) const;
 
-  SparseMatrix fsolve (MatrixType &typ, const SparseMatrix& b,
+  SparseMatrix fsolve (MatrixType& typ, const SparseMatrix& b,
                        octave_idx_type& info, double& rcond,
                        solve_singularity_handler sing_handler,
                        bool calc_cond = false) const;
 
-  SparseComplexMatrix fsolve (MatrixType &typ, const SparseComplexMatrix& b,
+  SparseComplexMatrix fsolve (MatrixType& typ, const SparseComplexMatrix& b,
                               octave_idx_type& info, double& rcond,
                               solve_singularity_handler sing_handler,
                               bool calc_cond = false) const;
 
 public:
   // Generic interface to solver with no probing of type
-  Matrix solve (MatrixType &typ, const Matrix& b) const;
-  Matrix solve (MatrixType &typ, const Matrix& b, octave_idx_type& info) const;
-  Matrix solve (MatrixType &typ, const Matrix& b, octave_idx_type& info,
+  Matrix solve (MatrixType& typ, const Matrix& b) const;
+  Matrix solve (MatrixType& typ, const Matrix& b, octave_idx_type& info) const;
+  Matrix solve (MatrixType& typ, const Matrix& b, octave_idx_type& info,
                 double& rcond) const;
-  Matrix solve (MatrixType &typ, const Matrix& b, octave_idx_type& info,
+  Matrix solve (MatrixType& typ, const Matrix& b, octave_idx_type& info,
                 double& rcond, solve_singularity_handler sing_handler,
                 bool singular_fallback = true) const;
 
-  ComplexMatrix solve (MatrixType &typ, const ComplexMatrix& b) const;
-  ComplexMatrix solve (MatrixType &typ, const ComplexMatrix& b,
+  ComplexMatrix solve (MatrixType& typ, const ComplexMatrix& b) const;
+  ComplexMatrix solve (MatrixType& typ, const ComplexMatrix& b,
                        octave_idx_type& info) const;
-  ComplexMatrix solve (MatrixType &typ, const ComplexMatrix& b,
+  ComplexMatrix solve (MatrixType& typ, const ComplexMatrix& b,
                        octave_idx_type& info, double& rcond) const;
-  ComplexMatrix solve (MatrixType &typ, const ComplexMatrix& b,
+  ComplexMatrix solve (MatrixType& typ, const ComplexMatrix& b,
                        octave_idx_type& info, double& rcond,
                        solve_singularity_handler sing_handler,
                        bool singular_fallback = true) const;
 
-  SparseMatrix solve (MatrixType &typ, const SparseMatrix& b) const;
-  SparseMatrix solve (MatrixType &typ, const SparseMatrix& b,
+  SparseMatrix solve (MatrixType& typ, const SparseMatrix& b) const;
+  SparseMatrix solve (MatrixType& typ, const SparseMatrix& b,
                       octave_idx_type& info) const;
-  SparseMatrix solve (MatrixType &typ, const SparseMatrix& b,
+  SparseMatrix solve (MatrixType& typ, const SparseMatrix& b,
                       octave_idx_type& info, double& rcond) const;
-  SparseMatrix solve (MatrixType &typ, const SparseMatrix& b,
+  SparseMatrix solve (MatrixType& typ, const SparseMatrix& b,
                       octave_idx_type& info, double& rcond,
                       solve_singularity_handler sing_handler,
                       bool singular_fallback = true) const;
 
-  SparseComplexMatrix solve (MatrixType &typ,
+  SparseComplexMatrix solve (MatrixType& typ,
                              const SparseComplexMatrix& b) const;
-  SparseComplexMatrix solve (MatrixType &typ, const SparseComplexMatrix& b,
+  SparseComplexMatrix solve (MatrixType& typ, const SparseComplexMatrix& b,
                              octave_idx_type& info) const;
-  SparseComplexMatrix solve (MatrixType &typ, const SparseComplexMatrix& b,
+  SparseComplexMatrix solve (MatrixType& typ, const SparseComplexMatrix& b,
                              octave_idx_type& info, double& rcond) const;
-  SparseComplexMatrix solve (MatrixType &typ, const SparseComplexMatrix& b,
+  SparseComplexMatrix solve (MatrixType& typ, const SparseComplexMatrix& b,
                              octave_idx_type& info, double& rcond,
                              solve_singularity_handler sing_handler,
                              bool singular_fallabck = true) const;
 
-  ColumnVector solve (MatrixType &typ, const ColumnVector& b) const;
-  ColumnVector solve (MatrixType &typ, const ColumnVector& b,
+  ColumnVector solve (MatrixType& typ, const ColumnVector& b) const;
+  ColumnVector solve (MatrixType& typ, const ColumnVector& b,
                       octave_idx_type& info) const;
-  ColumnVector solve (MatrixType &typ, const ColumnVector& b,
+  ColumnVector solve (MatrixType& typ, const ColumnVector& b,
                       octave_idx_type& info, double& rcond) const;
-  ColumnVector solve (MatrixType &typ, const ColumnVector& b,
+  ColumnVector solve (MatrixType& typ, const ColumnVector& b,
                       octave_idx_type& info, double& rcond,
                       solve_singularity_handler sing_handler) const;
 
-  ComplexColumnVector solve (MatrixType &typ,
+  ComplexColumnVector solve (MatrixType& typ,
                              const ComplexColumnVector& b) const;
-  ComplexColumnVector solve (MatrixType &typ, const ComplexColumnVector& b,
+  ComplexColumnVector solve (MatrixType& typ, const ComplexColumnVector& b,
                              octave_idx_type& info) const;
-  ComplexColumnVector solve (MatrixType &typ, const ComplexColumnVector& b,
+  ComplexColumnVector solve (MatrixType& typ, const ComplexColumnVector& b,
                              octave_idx_type& info, double& rcond) const;
-  ComplexColumnVector solve (MatrixType &typ, const ComplexColumnVector& b,
+  ComplexColumnVector solve (MatrixType& typ, const ComplexColumnVector& b,
                              octave_idx_type& info, double& rcond,
                              solve_singularity_handler sing_handler) const;
 
   // Generic interface to solver with probing of type
   Matrix solve (const Matrix& b) const;
   Matrix solve (const Matrix& b, octave_idx_type& info) const;
   Matrix solve (const Matrix& b, octave_idx_type& info, double& rcond) const;
   Matrix solve (const Matrix& b, octave_idx_type& info, double& rcond,
diff --git a/liboctave/array/fCMatrix.cc b/liboctave/array/fCMatrix.cc
--- a/liboctave/array/fCMatrix.cc
+++ b/liboctave/array/fCMatrix.cc
@@ -737,32 +737,32 @@ FloatComplexMatrix
 FloatComplexMatrix::inverse (octave_idx_type& info, float& rcon, bool force,
                              bool calc_cond) const
 {
   MatrixType mattype (*this);
   return inverse (mattype, info, rcon, force, calc_cond);
 }
 
 FloatComplexMatrix
-FloatComplexMatrix::inverse (MatrixType &mattype) const
+FloatComplexMatrix::inverse (MatrixType& mattype) const
 {
   octave_idx_type info;
   float rcon;
   return inverse (mattype, info, rcon, 0, 0);
 }
 
 FloatComplexMatrix
-FloatComplexMatrix::inverse (MatrixType &mattype, octave_idx_type& info) const
+FloatComplexMatrix::inverse (MatrixType& mattype, octave_idx_type& info) const
 {
   float rcon;
   return inverse (mattype, info, rcon, 0, 0);
 }
 
 FloatComplexMatrix
-FloatComplexMatrix::tinverse (MatrixType &mattype, octave_idx_type& info,
+FloatComplexMatrix::tinverse (MatrixType& mattype, octave_idx_type& info,
                               float& rcon, bool force, bool calc_cond) const
 {
   FloatComplexMatrix retval;
 
   F77_INT nr = octave::to_f77_int (rows ());
   F77_INT nc = octave::to_f77_int (cols ());
 
   if (nr != nc || nr == 0 || nc == 0)
@@ -811,17 +811,17 @@ FloatComplexMatrix::tinverse (MatrixType
 
   if (info == -1 && ! force)
     retval = *this; // Restore matrix contents.
 
   return retval;
 }
 
 FloatComplexMatrix
-FloatComplexMatrix::finverse (MatrixType &mattype, octave_idx_type& info,
+FloatComplexMatrix::finverse (MatrixType& mattype, octave_idx_type& info,
                               float& rcon, bool force, bool calc_cond) const
 {
   FloatComplexMatrix retval;
 
   F77_INT nr = octave::to_f77_int (rows ());
   F77_INT nc = octave::to_f77_int (cols ());
 
   if (nr != nc)
@@ -904,17 +904,17 @@ FloatComplexMatrix::finverse (MatrixType
 
   if (info != 0)
     mattype.mark_as_rectangular ();
 
   return retval;
 }
 
 FloatComplexMatrix
-FloatComplexMatrix::inverse (MatrixType &mattype, octave_idx_type& info,
+FloatComplexMatrix::inverse (MatrixType& mattype, octave_idx_type& info,
                              float& rcon, bool force, bool calc_cond) const
 {
   int typ = mattype.type (false);
   FloatComplexMatrix ret;
 
   if (typ == MatrixType::Unknown)
     typ = mattype.type (*this);
 
@@ -1492,17 +1492,17 @@ FloatComplexMatrix::determinant (MatrixT
 float
 FloatComplexMatrix::rcond (void) const
 {
   MatrixType mattype (*this);
   return rcond (mattype);
 }
 
 float
-FloatComplexMatrix::rcond (MatrixType &mattype) const
+FloatComplexMatrix::rcond (MatrixType& mattype) const
 {
   float rcon = octave::numeric_limits<float>::NaN ();
   F77_INT nr = octave::to_f77_int (rows ());
   F77_INT nc = octave::to_f77_int (cols ());
 
   if (nr != nc)
     (*current_liboctave_error_handler) ("matrix must be square");
 
@@ -1661,17 +1661,17 @@ FloatComplexMatrix::rcond (MatrixType &m
       else
         rcon = 0.0;
     }
 
   return rcon;
 }
 
 FloatComplexMatrix
-FloatComplexMatrix::utsolve (MatrixType &mattype, const FloatComplexMatrix& b,
+FloatComplexMatrix::utsolve (MatrixType& mattype, const FloatComplexMatrix& b,
                              octave_idx_type& info, float& rcon,
                              solve_singularity_handler sing_handler,
                              bool calc_cond, blas_trans_type transt) const
 {
   FloatComplexMatrix retval;
 
   F77_INT nr = octave::to_f77_int (rows ());
   F77_INT nc = octave::to_f77_int (cols ());
@@ -1763,17 +1763,17 @@ FloatComplexMatrix::utsolve (MatrixType 
       else
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 FloatComplexMatrix
-FloatComplexMatrix::ltsolve (MatrixType &mattype, const FloatComplexMatrix& b,
+FloatComplexMatrix::ltsolve (MatrixType& mattype, const FloatComplexMatrix& b,
                              octave_idx_type& info, float& rcon,
                              solve_singularity_handler sing_handler,
                              bool calc_cond, blas_trans_type transt) const
 {
   FloatComplexMatrix retval;
 
   F77_INT nr = octave::to_f77_int (rows ());
   F77_INT nc = octave::to_f77_int (cols ());
@@ -1865,17 +1865,17 @@ FloatComplexMatrix::ltsolve (MatrixType 
       else
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 FloatComplexMatrix
-FloatComplexMatrix::fsolve (MatrixType &mattype, const FloatComplexMatrix& b,
+FloatComplexMatrix::fsolve (MatrixType& mattype, const FloatComplexMatrix& b,
                             octave_idx_type& info, float& rcon,
                             solve_singularity_handler sing_handler,
                             bool calc_cond) const
 {
   FloatComplexMatrix retval;
 
   F77_INT nr = octave::to_f77_int (rows ());
   F77_INT nc = octave::to_f77_int (cols ());
@@ -2076,88 +2076,91 @@ FloatComplexMatrix::fsolve (MatrixType &
           mattype.mark_as_full ();
         }
     }
 
   return retval;
 }
 
 FloatComplexMatrix
-FloatComplexMatrix::solve (MatrixType &typ, const FloatMatrix& b) const
+FloatComplexMatrix::solve (MatrixType& mattype, const FloatMatrix& b) const
 {
   octave_idx_type info;
   float rcon;
-  return solve (typ, b, info, rcon, 0);
+  return solve (mattype, b, info, rcon, 0);
 }
 
 FloatComplexMatrix
-FloatComplexMatrix::solve (MatrixType &typ, const FloatMatrix& b,
+FloatComplexMatrix::solve (MatrixType& mattype, const FloatMatrix& b,
                            octave_idx_type& info) const
 {
   float rcon;
-  return solve (typ, b, info, rcon, 0);
+  return solve (mattype, b, info, rcon, 0);
 }
 
 FloatComplexMatrix
-FloatComplexMatrix::solve (MatrixType &typ, const FloatMatrix& b,
-                           octave_idx_type& info,
-                           float& rcon) const
+FloatComplexMatrix::solve (MatrixType& mattype, const FloatMatrix& b,
+                           octave_idx_type& info, float& rcon) const
 {
-  return solve (typ, b, info, rcon, 0);
+  return solve (mattype, b, info, rcon, 0);
 }
 
 FloatComplexMatrix
-FloatComplexMatrix::solve (MatrixType &typ, const FloatMatrix& b,
-                           octave_idx_type& info,
-                           float& rcon, solve_singularity_handler sing_handler,
+FloatComplexMatrix::solve (MatrixType& mattype, const FloatMatrix& b,
+                           octave_idx_type& info, float& rcon,
+                           solve_singularity_handler sing_handler,
                            bool singular_fallback, blas_trans_type transt) const
 {
   FloatComplexMatrix tmp (b);
-  return solve (typ, tmp, info, rcon, sing_handler, singular_fallback, transt);
+  return solve (mattype, tmp, info, rcon, sing_handler, singular_fallback,
+                transt);
 }
 
 FloatComplexMatrix
-FloatComplexMatrix::solve (MatrixType &typ, const FloatComplexMatrix& b) const
+FloatComplexMatrix::solve (MatrixType& mattype,
+                           const FloatComplexMatrix& b) const
 {
   octave_idx_type info;
   float rcon;
-  return solve (typ, b, info, rcon, 0);
+  return solve (mattype, b, info, rcon, 0);
 }
 
 FloatComplexMatrix
-FloatComplexMatrix::solve (MatrixType &typ, const FloatComplexMatrix& b,
+FloatComplexMatrix::solve (MatrixType& mattype, const FloatComplexMatrix& b,
                            octave_idx_type& info) const
 {
   float rcon;
-  return solve (typ, b, info, rcon, 0);
+  return solve (mattype, b, info, rcon, 0);
 }
 
 FloatComplexMatrix
-FloatComplexMatrix::solve (MatrixType &typ, const FloatComplexMatrix& b,
+FloatComplexMatrix::solve (MatrixType& mattype, const FloatComplexMatrix& b,
                            octave_idx_type& info, float& rcon) const
 {
-  return solve (typ, b, info, rcon, 0);
+  return solve (mattype, b, info, rcon, 0);
 }
 
 FloatComplexMatrix
-FloatComplexMatrix::solve (MatrixType &mattype, const FloatComplexMatrix& b,
+FloatComplexMatrix::solve (MatrixType& mattype, const FloatComplexMatrix& b,
                            octave_idx_type& info, float& rcon,
                            solve_singularity_handler sing_handler,
-                           bool singular_fallback, blas_trans_type transt) const
+                           bool singular_fallback,
+                           blas_trans_type transt) const
 {
   FloatComplexMatrix retval;
   int typ = mattype.type ();
 
   if (typ == MatrixType::Unknown)
     typ = mattype.type (*this);
 
   // Only calculate the condition number for LU/Cholesky
   if (typ == MatrixType::Upper || typ == MatrixType::Permuted_Upper)
     retval = utsolve (mattype, b, info, rcon, sing_handler, true, transt);
-  else if (typ == MatrixType::Lower || typ == MatrixType::Permuted_Lower)
+  else if (typ == MatrixType::Lower
+           || typ == MatrixType::Permuted_Lower)
     retval = ltsolve (mattype, b, info, rcon, sing_handler, true, transt);
   else if (transt == blas_trans)
     return transpose ().solve (mattype, b, info, rcon, sing_handler,
                                singular_fallback);
   else if (transt == blas_conj_trans)
     retval = hermitian ().solve (mattype, b, info, rcon, sing_handler,
                                  singular_fallback);
   else if (typ == MatrixType::Full || typ == MatrixType::Hermitian)
@@ -2171,81 +2174,85 @@ FloatComplexMatrix::solve (MatrixType &m
       octave_idx_type rank;
       retval = lssolve (b, info, rank, rcon);
     }
 
   return retval;
 }
 
 FloatComplexColumnVector
-FloatComplexMatrix::solve (MatrixType &typ, const FloatColumnVector& b) const
+FloatComplexMatrix::solve (MatrixType& mattype,
+                           const FloatColumnVector& b) const
 {
   octave_idx_type info;
   float rcon;
-  return solve (typ, FloatComplexColumnVector (b), info, rcon, 0);
+  return solve (mattype, FloatComplexColumnVector (b), info, rcon, 0);
 }
 
 FloatComplexColumnVector
-FloatComplexMatrix::solve (MatrixType &typ, const FloatColumnVector& b,
+FloatComplexMatrix::solve (MatrixType& mattype, const FloatColumnVector& b,
                            octave_idx_type& info) const
 {
   float rcon;
-  return solve (typ, FloatComplexColumnVector (b), info, rcon, 0);
+  return solve (mattype, FloatComplexColumnVector (b), info, rcon, 0);
 }
 
 FloatComplexColumnVector
-FloatComplexMatrix::solve (MatrixType &typ, const FloatColumnVector& b,
+FloatComplexMatrix::solve (MatrixType& mattype, const FloatColumnVector& b,
                            octave_idx_type& info, float& rcon) const
 {
-  return solve (typ, FloatComplexColumnVector (b), info, rcon, 0);
+  return solve (mattype, FloatComplexColumnVector (b), info, rcon, 0);
 }
 
 FloatComplexColumnVector
-FloatComplexMatrix::solve (MatrixType &typ, const FloatColumnVector& b,
+FloatComplexMatrix::solve (MatrixType& mattype, const FloatColumnVector& b,
                            octave_idx_type& info, float& rcon,
                            solve_singularity_handler sing_handler,
                            blas_trans_type transt) const
 {
-  return solve (typ, FloatComplexColumnVector (b), info, rcon, sing_handler,
-                transt);
+  return solve (mattype, FloatComplexColumnVector (b), info, rcon,
+                sing_handler, transt);
 }
 
 FloatComplexColumnVector
-FloatComplexMatrix::solve (MatrixType &typ,
+FloatComplexMatrix::solve (MatrixType& mattype,
                            const FloatComplexColumnVector& b) const
 {
   octave_idx_type info;
   float rcon;
-  return solve (typ, b, info, rcon, 0);
+  return solve (mattype, b, info, rcon, 0);
 }
 
 FloatComplexColumnVector
-FloatComplexMatrix::solve (MatrixType &typ, const FloatComplexColumnVector& b,
+FloatComplexMatrix::solve (MatrixType& mattype,
+                           const FloatComplexColumnVector& b,
                            octave_idx_type& info) const
 {
   float rcon;
-  return solve (typ, b, info, rcon, 0);
+  return solve (mattype, b, info, rcon, 0);
 }
 
 FloatComplexColumnVector
-FloatComplexMatrix::solve (MatrixType &typ, const FloatComplexColumnVector& b,
+FloatComplexMatrix::solve (MatrixType& mattype,
+                           const FloatComplexColumnVector& b,
                            octave_idx_type& info, float& rcon) const
 {
-  return solve (typ, b, info, rcon, 0);
+  return solve (mattype, b, info, rcon, 0);
 }
 
 FloatComplexColumnVector
-FloatComplexMatrix::solve (MatrixType &typ, const FloatComplexColumnVector& b,
+FloatComplexMatrix::solve (MatrixType& mattype,
+                           const FloatComplexColumnVector& b,
                            octave_idx_type& info, float& rcon,
                            solve_singularity_handler sing_handler,
                            blas_trans_type transt) const
 {
 
   FloatComplexMatrix tmp (b);
-  tmp = solve (typ, tmp, info, rcon, sing_handler, true, transt);
+  tmp = solve (mattype, tmp, info, rcon, sing_handler, true, transt);
   return tmp.column (static_cast<octave_idx_type> (0));
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::solve (const FloatMatrix& b) const
 {
   octave_idx_type info;
   float rcon;
diff --git a/liboctave/array/fCMatrix.h b/liboctave/array/fCMatrix.h
--- a/liboctave/array/fCMatrix.h
+++ b/liboctave/array/fCMatrix.h
@@ -188,117 +188,117 @@ public:
 
   void resize (octave_idx_type nr, octave_idx_type nc,
                const FloatComplex& rfv = FloatComplex (0))
   {
     MArray<FloatComplex>::resize (dim_vector (nr, nc), rfv);
   }
 
 private:
-  FloatComplexMatrix tinverse (MatrixType &mattype, octave_idx_type& info,
+  FloatComplexMatrix tinverse (MatrixType& mattype, octave_idx_type& info,
                                float& rcon, bool force, bool calc_cond) const;
 
-  FloatComplexMatrix finverse (MatrixType &mattype, octave_idx_type& info,
+  FloatComplexMatrix finverse (MatrixType& mattype, octave_idx_type& info,
                                float& rcon, bool force, bool calc_cond) const;
 
 public:
   FloatComplexMatrix inverse (void) const;
   FloatComplexMatrix inverse (octave_idx_type& info) const;
   FloatComplexMatrix inverse (octave_idx_type& info, float& rcon,
                               bool force = false, bool calc_cond = true) const;
 
-  FloatComplexMatrix inverse (MatrixType &mattype) const;
-  FloatComplexMatrix inverse (MatrixType &mattype, octave_idx_type& info) const;
-  FloatComplexMatrix inverse (MatrixType &mattype, octave_idx_type& info,
+  FloatComplexMatrix inverse (MatrixType& mattype) const;
+  FloatComplexMatrix inverse (MatrixType& mattype, octave_idx_type& info) const;
+  FloatComplexMatrix inverse (MatrixType& mattype, octave_idx_type& info,
                               float& rcon, bool force = false,
                               bool calc_cond = true) const;
 
   FloatComplexMatrix pseudo_inverse (float tol = 0.0) const;
 
   FloatComplexMatrix fourier (void) const;
   FloatComplexMatrix ifourier (void) const;
 
   FloatComplexMatrix fourier2d (void) const;
   FloatComplexMatrix ifourier2d (void) const;
 
   FloatComplexDET determinant (void) const;
   FloatComplexDET determinant (octave_idx_type& info) const;
   FloatComplexDET determinant (octave_idx_type& info, float& rcon,
                                bool calc_cond = true) const;
-  FloatComplexDET determinant (MatrixType &mattype, octave_idx_type& info,
+  FloatComplexDET determinant (MatrixType& mattype, octave_idx_type& info,
                                float& rcon, bool calc_cond = true) const;
 
   float rcond (void) const;
-  float rcond (MatrixType &mattype) const;
+  float rcond (MatrixType& mattype) const;
 
 private:
   // Upper triangular matrix solvers
-  FloatComplexMatrix utsolve (MatrixType &typ, const FloatComplexMatrix& b,
+  FloatComplexMatrix utsolve (MatrixType& mattype, const FloatComplexMatrix& b,
                               octave_idx_type& info, float& rcon,
                               solve_singularity_handler sing_handler,
                               bool calc_cond = false,
                               blas_trans_type transt = blas_no_trans) const;
 
   // Lower triangular matrix solvers
-  FloatComplexMatrix ltsolve (MatrixType &typ, const FloatComplexMatrix& b,
+  FloatComplexMatrix ltsolve (MatrixType& mattype, const FloatComplexMatrix& b,
                               octave_idx_type& info, float& rcon,
                               solve_singularity_handler sing_handler,
                               bool calc_cond = false,
                               blas_trans_type transt = blas_no_trans) const;
 
   // Full matrix solvers (umfpack/cholesky)
-  FloatComplexMatrix fsolve (MatrixType &typ, const FloatComplexMatrix& b,
+  FloatComplexMatrix fsolve (MatrixType& mattype, const FloatComplexMatrix& b,
                              octave_idx_type& info, float& rcon,
                              solve_singularity_handler sing_handler,
                              bool calc_cond = false) const;
 
 public:
   // Generic interface to solver with no probing of type
-  FloatComplexMatrix solve (MatrixType &typ, const FloatMatrix& b) const;
-  FloatComplexMatrix solve (MatrixType &typ, const FloatMatrix& b,
+  FloatComplexMatrix solve (MatrixType& mattype, const FloatMatrix& b) const;
+  FloatComplexMatrix solve (MatrixType& mattype, const FloatMatrix& b,
                             octave_idx_type& info) const;
-  FloatComplexMatrix solve (MatrixType &typ, const FloatMatrix& b,
+  FloatComplexMatrix solve (MatrixType& mattype, const FloatMatrix& b,
                             octave_idx_type& info, float& rcon) const;
-  FloatComplexMatrix solve (MatrixType &typ, const FloatMatrix& b,
+  FloatComplexMatrix solve (MatrixType& mattype, const FloatMatrix& b,
                             octave_idx_type& info,
                             float& rcon, solve_singularity_handler sing_handler,
                             bool singular_fallback = true,
                             blas_trans_type transt = blas_no_trans) const;
 
-  FloatComplexMatrix solve (MatrixType &typ, const FloatComplexMatrix& b) const;
-  FloatComplexMatrix solve (MatrixType &typ, const FloatComplexMatrix& b,
+  FloatComplexMatrix solve (MatrixType& mattype, const FloatComplexMatrix& b) const;
+  FloatComplexMatrix solve (MatrixType& mattype, const FloatComplexMatrix& b,
                             octave_idx_type& info) const;
-  FloatComplexMatrix solve (MatrixType &typ, const FloatComplexMatrix& b,
+  FloatComplexMatrix solve (MatrixType& mattype, const FloatComplexMatrix& b,
                             octave_idx_type& info, float& rcon) const;
-  FloatComplexMatrix solve (MatrixType &typ, const FloatComplexMatrix& b,
+  FloatComplexMatrix solve (MatrixType& mattype, const FloatComplexMatrix& b,
                             octave_idx_type& info, float& rcon,
                             solve_singularity_handler sing_handler,
                             bool singular_fallback = true,
                             blas_trans_type transt = blas_no_trans) const;
 
-  FloatComplexColumnVector solve (MatrixType &typ,
+  FloatComplexColumnVector solve (MatrixType& mattype,
                                   const FloatColumnVector& b) const;
-  FloatComplexColumnVector solve (MatrixType &typ, const FloatColumnVector& b,
+  FloatComplexColumnVector solve (MatrixType& mattype, const FloatColumnVector& b,
                                   octave_idx_type& info) const;
-  FloatComplexColumnVector solve (MatrixType &typ, const FloatColumnVector& b,
+  FloatComplexColumnVector solve (MatrixType& mattype, const FloatColumnVector& b,
                                   octave_idx_type& info, float& rcon) const;
-  FloatComplexColumnVector solve (MatrixType &typ, const FloatColumnVector& b,
+  FloatComplexColumnVector solve (MatrixType& mattype, const FloatColumnVector& b,
                                   octave_idx_type& info, float& rcon,
                                   solve_singularity_handler sing_handler,
                                   blas_trans_type transt = blas_no_trans) const;
 
-  FloatComplexColumnVector solve (MatrixType &typ,
+  FloatComplexColumnVector solve (MatrixType& mattype,
                                   const FloatComplexColumnVector& b) const;
-  FloatComplexColumnVector solve (MatrixType &typ,
+  FloatComplexColumnVector solve (MatrixType& mattype,
                                   const FloatComplexColumnVector& b,
                                   octave_idx_type& info) const;
-  FloatComplexColumnVector solve (MatrixType &typ,
+  FloatComplexColumnVector solve (MatrixType& mattype,
                                   const FloatComplexColumnVector& b,
                                   octave_idx_type& info, float& rcon) const;
-  FloatComplexColumnVector solve (MatrixType &typ,
+  FloatComplexColumnVector solve (MatrixType& mattype,
                                   const FloatComplexColumnVector& b,
                                   octave_idx_type& info, float& rcon,
                                   solve_singularity_handler sing_handler,
                                   blas_trans_type transt = blas_no_trans) const;
 
   // Generic interface to solver with probing of type
   FloatComplexMatrix solve (const FloatMatrix& b) const;
   FloatComplexMatrix solve (const FloatMatrix& b, octave_idx_type& info) const;
diff --git a/liboctave/array/fDiagMatrix.cc b/liboctave/array/fDiagMatrix.cc
--- a/liboctave/array/fDiagMatrix.cc
+++ b/liboctave/array/fDiagMatrix.cc
@@ -225,17 +225,17 @@ FloatDiagMatrix::column (char *s) const
 FloatDiagMatrix
 FloatDiagMatrix::inverse (void) const
 {
   octave_idx_type info;
   return inverse (info);
 }
 
 FloatDiagMatrix
-FloatDiagMatrix::inverse (octave_idx_type &info) const
+FloatDiagMatrix::inverse (octave_idx_type& info) const
 {
   octave_idx_type r = rows ();
   octave_idx_type c = cols ();
   octave_idx_type len = length ();
   if (r != c)
     (*current_liboctave_error_handler) ("inverse requires square matrix");
 
   FloatDiagMatrix retval (r, c);
diff --git a/liboctave/array/fMatrix.cc b/liboctave/array/fMatrix.cc
--- a/liboctave/array/fMatrix.cc
+++ b/liboctave/array/fMatrix.cc
@@ -460,24 +460,24 @@ FloatMatrix
 FloatMatrix::inverse (MatrixType& mattype) const
 {
   octave_idx_type info;
   float rcon;
   return inverse (mattype, info, rcon, 0, 0);
 }
 
 FloatMatrix
-FloatMatrix::inverse (MatrixType &mattype, octave_idx_type& info) const
+FloatMatrix::inverse (MatrixType& mattype, octave_idx_type& info) const
 {
   float rcon;
   return inverse (mattype, info, rcon, 0, 0);
 }
 
 FloatMatrix
-FloatMatrix::tinverse (MatrixType &mattype, octave_idx_type& info, float& rcon,
+FloatMatrix::tinverse (MatrixType& mattype, octave_idx_type& info, float& rcon,
                        bool force, bool calc_cond) const
 {
   FloatMatrix retval;
 
   F77_INT nr = octave::to_f77_int (rows ());
   F77_INT nc = octave::to_f77_int (cols ());
 
   if (nr != nc || nr == 0 || nc == 0)
@@ -526,17 +526,17 @@ FloatMatrix::tinverse (MatrixType &matty
 
   if (info == -1 && ! force)
     retval = *this; // Restore matrix contents.
 
   return retval;
 }
 
 FloatMatrix
-FloatMatrix::finverse (MatrixType &mattype, octave_idx_type& info, float& rcon,
+FloatMatrix::finverse (MatrixType& mattype, octave_idx_type& info, float& rcon,
                        bool force, bool calc_cond) const
 {
   FloatMatrix retval;
 
   F77_INT nr = octave::to_f77_int (rows ());
   F77_INT nc = octave::to_f77_int (cols ());
 
   if (nr != nc || nr == 0 || nc == 0)
@@ -612,17 +612,17 @@ FloatMatrix::finverse (MatrixType &matty
 
   if (info != 0)
     mattype.mark_as_rectangular ();
 
   return retval;
 }
 
 FloatMatrix
-FloatMatrix::inverse (MatrixType &mattype, octave_idx_type& info, float& rcon,
+FloatMatrix::inverse (MatrixType& mattype, octave_idx_type& info, float& rcon,
                       bool force, bool calc_cond) const
 {
   int typ = mattype.type (false);
   FloatMatrix ret;
 
   if (typ == MatrixType::Unknown)
     typ = mattype.type (*this);
 
@@ -1184,17 +1184,17 @@ FloatMatrix::determinant (MatrixType& ma
 float
 FloatMatrix::rcond (void) const
 {
   MatrixType mattype (*this);
   return rcond (mattype);
 }
 
 float
-FloatMatrix::rcond (MatrixType &mattype) const
+FloatMatrix::rcond (MatrixType& mattype) const
 {
   float rcon = octave::numeric_limits<float>::NaN ();
   F77_INT nr = octave::to_f77_int (rows ());
   F77_INT nc = octave::to_f77_int (cols ());
 
   if (nr != nc)
     (*current_liboctave_error_handler) ("matrix must be square");
 
@@ -1348,17 +1348,17 @@ FloatMatrix::rcond (MatrixType &mattype)
       else
         rcon = 0.0;
     }
 
   return rcon;
 }
 
 FloatMatrix
-FloatMatrix::utsolve (MatrixType &mattype, const FloatMatrix& b,
+FloatMatrix::utsolve (MatrixType& mattype, const FloatMatrix& b,
                       octave_idx_type& info,
                       float& rcon, solve_singularity_handler sing_handler,
                       bool calc_cond, blas_trans_type transt) const
 {
   FloatMatrix retval;
 
   F77_INT nr = octave::to_f77_int (rows ());
   F77_INT nc = octave::to_f77_int (cols ());
@@ -1451,17 +1451,17 @@ FloatMatrix::utsolve (MatrixType &mattyp
       else
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 FloatMatrix
-FloatMatrix::ltsolve (MatrixType &mattype, const FloatMatrix& b,
+FloatMatrix::ltsolve (MatrixType& mattype, const FloatMatrix& b,
                       octave_idx_type& info,
                       float& rcon, solve_singularity_handler sing_handler,
                       bool calc_cond, blas_trans_type transt) const
 {
   FloatMatrix retval;
 
   F77_INT nr = octave::to_f77_int (rows ());
   F77_INT nc = octave::to_f77_int (cols ());
@@ -1553,17 +1553,17 @@ FloatMatrix::ltsolve (MatrixType &mattyp
       else
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 FloatMatrix
-FloatMatrix::fsolve (MatrixType &mattype, const FloatMatrix& b,
+FloatMatrix::fsolve (MatrixType& mattype, const FloatMatrix& b,
                      octave_idx_type& info,
                      float& rcon, solve_singularity_handler sing_handler,
                      bool calc_cond) const
 {
   FloatMatrix retval;
 
   F77_INT nr = octave::to_f77_int (rows ());
   F77_INT nc = octave::to_f77_int (cols ());
@@ -1750,40 +1750,40 @@ FloatMatrix::fsolve (MatrixType &mattype
       else if (typ != MatrixType::Hermitian)
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 FloatMatrix
-FloatMatrix::solve (MatrixType &typ, const FloatMatrix& b) const
+FloatMatrix::solve (MatrixType& mattype, const FloatMatrix& b) const
 {
   octave_idx_type info;
   float rcon;
-  return solve (typ, b, info, rcon, 0);
+  return solve (mattype, b, info, rcon, 0);
 }
 
 FloatMatrix
-FloatMatrix::solve (MatrixType &typ, const FloatMatrix& b,
+FloatMatrix::solve (MatrixType& mattype, const FloatMatrix& b,
                     octave_idx_type& info) const
 {
   float rcon;
-  return solve (typ, b, info, rcon, 0);
+  return solve (mattype, b, info, rcon, 0);
 }
 
 FloatMatrix
-FloatMatrix::solve (MatrixType &typ, const FloatMatrix& b,
+FloatMatrix::solve (MatrixType& mattype, const FloatMatrix& b,
                     octave_idx_type& info, float& rcon) const
 {
-  return solve (typ, b, info, rcon, 0);
+  return solve (mattype, b, info, rcon, 0);
 }
 
 FloatMatrix
-FloatMatrix::solve (MatrixType &mattype, const FloatMatrix& b,
+FloatMatrix::solve (MatrixType& mattype, const FloatMatrix& b,
                     octave_idx_type& info,
                     float& rcon, solve_singularity_handler sing_handler,
                     bool singular_fallback, blas_trans_type transt) const
 {
   FloatMatrix retval;
   int typ = mattype.type ();
 
   if (typ == MatrixType::Unknown)
@@ -1808,37 +1808,37 @@ FloatMatrix::solve (MatrixType &mattype,
       octave_idx_type rank;
       retval = lssolve (b, info, rank, rcon);
     }
 
   return retval;
 }
 
 FloatComplexMatrix
-FloatMatrix::solve (MatrixType &typ, const FloatComplexMatrix& b) const
+FloatMatrix::solve (MatrixType& mattype, const FloatComplexMatrix& b) const
 {
   octave_idx_type info;
   float rcon;
-  return solve (typ, b, info, rcon, 0);
+  return solve (mattype, b, info, rcon, 0);
 }
 
 FloatComplexMatrix
-FloatMatrix::solve (MatrixType &typ, const FloatComplexMatrix& b,
+FloatMatrix::solve (MatrixType& mattype, const FloatComplexMatrix& b,
                     octave_idx_type& info) const
 {
   float rcon;
-  return solve (typ, b, info, rcon, 0);
+  return solve (mattype, b, info, rcon, 0);
 }
 
 FloatComplexMatrix
-FloatMatrix::solve (MatrixType &typ, const FloatComplexMatrix& b,
+FloatMatrix::solve (MatrixType& mattype, const FloatComplexMatrix& b,
                     octave_idx_type& info,
                     float& rcon) const
 {
-  return solve (typ, b, info, rcon, 0);
+  return solve (mattype, b, info, rcon, 0);
 }
 
 static FloatMatrix
 stack_complex_matrix (const FloatComplexMatrix& cm)
 {
   octave_idx_type m = cm.rows ();
   octave_idx_type n = cm.cols ();
   octave_idx_type nel = m*n;
@@ -1863,91 +1863,94 @@ unstack_complex_matrix (const FloatMatri
   const float *smd = sm.data ();
   FloatComplex *rd = retval.fortran_vec ();
   for (octave_idx_type i = 0; i < nel; i++)
     rd[i] = FloatComplex (smd[i], smd[nel+i]);
   return retval;
 }
 
 FloatComplexMatrix
-FloatMatrix::solve (MatrixType &typ, const FloatComplexMatrix& b,
+FloatMatrix::solve (MatrixType& mattype, const FloatComplexMatrix& b,
                     octave_idx_type& info,
                     float& rcon, solve_singularity_handler sing_handler,
                     bool singular_fallback, blas_trans_type transt) const
 {
   FloatMatrix tmp = stack_complex_matrix (b);
-  tmp = solve (typ, tmp, info, rcon, sing_handler, singular_fallback, transt);
+  tmp = solve (mattype, tmp, info, rcon, sing_handler, singular_fallback,
+               transt);
   return unstack_complex_matrix (tmp);
 }
 
 FloatColumnVector
-FloatMatrix::solve (MatrixType &typ, const FloatColumnVector& b) const
+FloatMatrix::solve (MatrixType& mattype, const FloatColumnVector& b) const
 {
-  octave_idx_type info; float rcon;
-  return solve (typ, b, info, rcon);
+  octave_idx_type info;
+  float rcon;
+  return solve (mattype, b, info, rcon);
 }
 
 FloatColumnVector
-FloatMatrix::solve (MatrixType &typ, const FloatColumnVector& b,
+FloatMatrix::solve (MatrixType& mattype, const FloatColumnVector& b,
                     octave_idx_type& info) const
 {
   float rcon;
-  return solve (typ, b, info, rcon);
+  return solve (mattype, b, info, rcon);
 }
 
 FloatColumnVector
-FloatMatrix::solve (MatrixType &typ, const FloatColumnVector& b,
+FloatMatrix::solve (MatrixType& mattype, const FloatColumnVector& b,
                     octave_idx_type& info,
                     float& rcon) const
 {
-  return solve (typ, b, info, rcon, 0);
+  return solve (mattype, b, info, rcon, 0);
 }
 
 FloatColumnVector
-FloatMatrix::solve (MatrixType &typ, const FloatColumnVector& b,
+FloatMatrix::solve (MatrixType& mattype, const FloatColumnVector& b,
                     octave_idx_type& info,
                     float& rcon, solve_singularity_handler sing_handler,
                     blas_trans_type transt) const
 {
   FloatMatrix tmp (b);
-  tmp = solve (typ, tmp, info, rcon, sing_handler, true, transt);
+  tmp = solve (mattype, tmp, info, rcon, sing_handler, true, transt);
   return tmp.column (static_cast<octave_idx_type> (0));
 }
 
 FloatComplexColumnVector
-FloatMatrix::solve (MatrixType &typ, const FloatComplexColumnVector& b) const
+FloatMatrix::solve (MatrixType& mattype,
+                    const FloatComplexColumnVector& b) const
 {
   FloatComplexMatrix tmp (*this);
-  return tmp.solve (typ, b);
+  return tmp.solve (mattype, b);
 }
 
 FloatComplexColumnVector
-FloatMatrix::solve (MatrixType &typ, const FloatComplexColumnVector& b,
+FloatMatrix::solve (MatrixType& mattype, const FloatComplexColumnVector& b,
                     octave_idx_type& info) const
 {
   FloatComplexMatrix tmp (*this);
-  return tmp.solve (typ, b, info);
+  return tmp.solve (mattype, b, info);
 }
 
 FloatComplexColumnVector
-FloatMatrix::solve (MatrixType &typ, const FloatComplexColumnVector& b,
+FloatMatrix::solve (MatrixType& mattype, const FloatComplexColumnVector& b,
                     octave_idx_type& info, float& rcon) const
 {
   FloatComplexMatrix tmp (*this);
-  return tmp.solve (typ, b, info, rcon);
+  return tmp.solve (mattype, b, info, rcon);
 }
 
 FloatComplexColumnVector
-FloatMatrix::solve (MatrixType &typ, const FloatComplexColumnVector& b,
+FloatMatrix::solve (MatrixType& mattype, const FloatComplexColumnVector& b,
                     octave_idx_type& info, float& rcon,
                     solve_singularity_handler sing_handler,
                     blas_trans_type transt) const
 {
   FloatComplexMatrix tmp (*this);
-  return tmp.solve (typ, b, info, rcon, sing_handler, transt);
+  return tmp.solve (mattype, b, info, rcon, sing_handler, transt);
 }
 
 FloatMatrix
 FloatMatrix::solve (const FloatMatrix& b) const
 {
   octave_idx_type info;
   float rcon;
   return solve (b, info, rcon, 0);
@@ -2092,17 +2095,17 @@ FloatMatrix::lssolve (const FloatMatrix&
                       octave_idx_type& rank) const
 {
   float rcon;
   return lssolve (b, info, rank, rcon);
 }
 
 FloatMatrix
 FloatMatrix::lssolve (const FloatMatrix& b, octave_idx_type& info,
-                      octave_idx_type& rank, float &rcon) const
+                      octave_idx_type& rank, float& rcon) const
 {
   FloatMatrix retval;
 
   F77_INT nrhs = octave::to_f77_int (b.cols ());
 
   F77_INT m = octave::to_f77_int (rows ());
   F77_INT n = octave::to_f77_int (cols ());
 
@@ -2312,17 +2315,17 @@ FloatMatrix::lssolve (const FloatColumnV
                       octave_idx_type& rank) const
 {
   float rcon;
   return lssolve (b, info, rank, rcon);
 }
 
 FloatColumnVector
 FloatMatrix::lssolve (const FloatColumnVector& b, octave_idx_type& info,
-                      octave_idx_type& rank, float &rcon) const
+                      octave_idx_type& rank, float& rcon) const
 {
   FloatColumnVector retval;
 
   F77_INT nrhs = 1;
 
   F77_INT m = octave::to_f77_int (rows ());
   F77_INT n = octave::to_f77_int (cols ());
 
@@ -2444,17 +2447,17 @@ FloatMatrix::lssolve (const FloatComplex
 {
   FloatComplexMatrix tmp (*this);
   float rcon;
   return tmp.lssolve (b, info, rank, rcon);
 }
 
 FloatComplexColumnVector
 FloatMatrix::lssolve (const FloatComplexColumnVector& b, octave_idx_type& info,
-                      octave_idx_type& rank, float &rcon) const
+                      octave_idx_type& rank, float& rcon) const
 {
   FloatComplexMatrix tmp (*this);
   return tmp.lssolve (b, info, rank, rcon);
 }
 
 FloatMatrix&
 FloatMatrix::operator += (const FloatDiagMatrix& a)
 {
diff --git a/liboctave/array/fMatrix.h b/liboctave/array/fMatrix.h
--- a/liboctave/array/fMatrix.h
+++ b/liboctave/array/fMatrix.h
@@ -147,115 +147,115 @@ public:
   FloatColumnVector column (octave_idx_type i) const;
 
   void resize (octave_idx_type nr, octave_idx_type nc, float rfv = 0)
   {
     MArray<float>::resize (dim_vector (nr, nc), rfv);
   }
 
 private:
-  FloatMatrix tinverse (MatrixType &mattype, octave_idx_type& info,
+  FloatMatrix tinverse (MatrixType& mattype, octave_idx_type& info,
                         float& rcon, bool force, bool calc_cond) const;
 
-  FloatMatrix finverse (MatrixType &mattype, octave_idx_type& info,
+  FloatMatrix finverse (MatrixType& mattype, octave_idx_type& info,
                         float& rcon, bool force, bool calc_cond) const;
 
 public:
   FloatMatrix inverse (void) const;
   FloatMatrix inverse (octave_idx_type& info) const;
   FloatMatrix inverse (octave_idx_type& info, float& rcon, bool force = false,
                        bool calc_cond = true) const;
 
-  FloatMatrix inverse (MatrixType &mattype) const;
-  FloatMatrix inverse (MatrixType &mattype, octave_idx_type& info) const;
-  FloatMatrix inverse (MatrixType &mattype, octave_idx_type& info, float& rcon,
+  FloatMatrix inverse (MatrixType& mattype) const;
+  FloatMatrix inverse (MatrixType& mattype, octave_idx_type& info) const;
+  FloatMatrix inverse (MatrixType& mattype, octave_idx_type& info, float& rcon,
                        bool force = false, bool calc_cond = true) const;
 
   FloatMatrix pseudo_inverse (float tol = 0.0) const;
 
   FloatComplexMatrix fourier (void) const;
   FloatComplexMatrix ifourier (void) const;
 
   FloatComplexMatrix fourier2d (void) const;
   FloatComplexMatrix ifourier2d (void) const;
 
   FloatDET determinant (void) const;
   FloatDET determinant (octave_idx_type& info) const;
   FloatDET determinant (octave_idx_type& info, float& rcon,
                         bool calc_cond = true) const;
-  FloatDET determinant (MatrixType &mattype, octave_idx_type& info,
+  FloatDET determinant (MatrixType& mattype, octave_idx_type& info,
                         float& rcon, bool calc_cond = true) const;
 
   float rcond (void) const;
-  float rcond (MatrixType &mattype) const;
+  float rcond (MatrixType& mattype) const;
 
 private:
   // Upper triangular matrix solvers
-  FloatMatrix utsolve (MatrixType &typ, const FloatMatrix& b,
+  FloatMatrix utsolve (MatrixType& mattype, const FloatMatrix& b,
                        octave_idx_type& info,
                        float& rcon, solve_singularity_handler sing_handler,
                        bool calc_cond = false,
                        blas_trans_type transt = blas_no_trans) const;
 
   // Lower triangular matrix solvers
-  FloatMatrix ltsolve (MatrixType &typ, const FloatMatrix& b,
+  FloatMatrix ltsolve (MatrixType& mattype, const FloatMatrix& b,
                        octave_idx_type& info,
                        float& rcon, solve_singularity_handler sing_handler,
                        bool calc_cond = false,
                        blas_trans_type transt = blas_no_trans) const;
 
   // Full matrix solvers (lu/cholesky)
-  FloatMatrix fsolve (MatrixType &typ, const FloatMatrix& b,
+  FloatMatrix fsolve (MatrixType& mattype, const FloatMatrix& b,
                       octave_idx_type& info,
                       float& rcon, solve_singularity_handler sing_handler,
                       bool calc_cond = false) const;
 
 public:
   // Generic interface to solver with no probing of type
-  FloatMatrix solve (MatrixType &typ, const FloatMatrix& b) const;
-  FloatMatrix solve (MatrixType &typ, const FloatMatrix& b,
+  FloatMatrix solve (MatrixType& mattype, const FloatMatrix& b) const;
+  FloatMatrix solve (MatrixType& mattype, const FloatMatrix& b,
                      octave_idx_type& info) const;
-  FloatMatrix solve (MatrixType &typ, const FloatMatrix& b,
+  FloatMatrix solve (MatrixType& mattype, const FloatMatrix& b,
                      octave_idx_type& info, float& rcon) const;
-  FloatMatrix solve (MatrixType &typ, const FloatMatrix& b,
+  FloatMatrix solve (MatrixType& mattype, const FloatMatrix& b,
                      octave_idx_type& info, float& rcon,
                      solve_singularity_handler sing_handler,
                      bool singular_fallback = true,
                      blas_trans_type transt = blas_no_trans) const;
 
-  FloatComplexMatrix solve (MatrixType &typ, const FloatComplexMatrix& b) const;
-  FloatComplexMatrix solve (MatrixType &typ, const FloatComplexMatrix& b,
+  FloatComplexMatrix solve (MatrixType& mattype, const FloatComplexMatrix& b) const;
+  FloatComplexMatrix solve (MatrixType& mattype, const FloatComplexMatrix& b,
                             octave_idx_type& info) const;
-  FloatComplexMatrix solve (MatrixType &typ, const FloatComplexMatrix& b,
+  FloatComplexMatrix solve (MatrixType& mattype, const FloatComplexMatrix& b,
                             octave_idx_type& info, float& rcon) const;
-  FloatComplexMatrix solve (MatrixType &typ, const FloatComplexMatrix& b,
+  FloatComplexMatrix solve (MatrixType& mattype, const FloatComplexMatrix& b,
                             octave_idx_type& info, float& rcon,
                             solve_singularity_handler sing_handler,
                             bool singular_fallback = true,
                             blas_trans_type transt = blas_no_trans) const;
 
-  FloatColumnVector solve (MatrixType &typ, const FloatColumnVector& b) const;
-  FloatColumnVector solve (MatrixType &typ, const FloatColumnVector& b,
+  FloatColumnVector solve (MatrixType& mattype, const FloatColumnVector& b) const;
+  FloatColumnVector solve (MatrixType& mattype, const FloatColumnVector& b,
                            octave_idx_type& info) const;
-  FloatColumnVector solve (MatrixType &typ, const FloatColumnVector& b,
+  FloatColumnVector solve (MatrixType& mattype, const FloatColumnVector& b,
                            octave_idx_type& info, float& rcon) const;
-  FloatColumnVector solve (MatrixType &typ, const FloatColumnVector& b,
+  FloatColumnVector solve (MatrixType& mattype, const FloatColumnVector& b,
                            octave_idx_type& info, float& rcon,
                            solve_singularity_handler sing_handler,
                            blas_trans_type transt = blas_no_trans) const;
 
-  FloatComplexColumnVector solve (MatrixType &typ,
+  FloatComplexColumnVector solve (MatrixType& mattype,
                                   const FloatComplexColumnVector& b) const;
-  FloatComplexColumnVector solve (MatrixType &typ,
+  FloatComplexColumnVector solve (MatrixType& mattype,
                                   const FloatComplexColumnVector& b,
                                   octave_idx_type& info) const;
-  FloatComplexColumnVector solve (MatrixType &typ,
+  FloatComplexColumnVector solve (MatrixType& mattype,
                                   const FloatComplexColumnVector& b,
                                   octave_idx_type& info, float& rcon) const;
-  FloatComplexColumnVector solve (MatrixType &typ,
+  FloatComplexColumnVector solve (MatrixType& mattype,
                                   const FloatComplexColumnVector& b,
                                   octave_idx_type& info, float& rcon,
                                   solve_singularity_handler sing_handler,
                                   blas_trans_type transt = blas_no_trans) const;
 
   // Generic interface to solver with probing of type
   FloatMatrix solve (const FloatMatrix& b) const;
   FloatMatrix solve (const FloatMatrix& b, octave_idx_type& info) const;
@@ -308,17 +308,17 @@ public:
   FloatComplexMatrix lssolve (const FloatComplexMatrix& b) const;
   FloatComplexMatrix lssolve (const FloatComplexMatrix& b,
                               octave_idx_type& info) const;
   FloatComplexMatrix lssolve (const FloatComplexMatrix& b,
                               octave_idx_type& info,
                               octave_idx_type& rank) const;
   FloatComplexMatrix lssolve (const FloatComplexMatrix& b,
                               octave_idx_type& info, octave_idx_type& rank,
-                              float &rcon) const;
+                              float& rcon) const;
 
   FloatColumnVector lssolve (const FloatColumnVector& b) const;
   FloatColumnVector lssolve (const FloatColumnVector& b,
                              octave_idx_type& info) const;
   FloatColumnVector lssolve (const FloatColumnVector& b, octave_idx_type& info,
                              octave_idx_type& rank) const;
   FloatColumnVector lssolve (const FloatColumnVector& b, octave_idx_type& info,
                              octave_idx_type& rank, float& rcon) const;
diff --git a/liboctave/numeric/eigs-base.cc b/liboctave/numeric/eigs-base.cc
--- a/liboctave/numeric/eigs-base.cc
+++ b/liboctave/numeric/eigs-base.cc
@@ -260,19 +260,19 @@ make_cholb (SparseComplexMatrix& b, Spar
       b = fact.L (); // lower triangular
       bt = b.hermitian ();
       permB = fact.perm () - 1.0;
       return true;
     }
 }
 
 static bool
-LuAminusSigmaB (const SparseMatrix &m, const SparseMatrix &b,
+LuAminusSigmaB (const SparseMatrix& m, const SparseMatrix& b,
                 bool cholB, const ColumnVector& permB, double sigma,
-                SparseMatrix &L, SparseMatrix &U, octave_idx_type *P,
+                SparseMatrix& L, SparseMatrix& U, octave_idx_type *P,
                 octave_idx_type *Q)
 {
   bool have_b = ! b.is_empty ();
   octave_idx_type n = m.rows ();
 
   // Caclulate LU decomposition of 'A - sigma * B'
   SparseMatrix AminusSigmaB (m);
 
@@ -352,19 +352,19 @@ LuAminusSigmaB (const SparseMatrix &m, c
 
   if (rcond_plus_one == 1.0 || octave::math::isnan (rcond))
     warn_convergence ();
 
   return true;
 }
 
 static bool
-LuAminusSigmaB (const Matrix &m, const Matrix &b,
+LuAminusSigmaB (const Matrix& m, const Matrix& b,
                 bool cholB, const ColumnVector& permB, double sigma,
-                Matrix &L, Matrix &U, octave_idx_type *P,
+                Matrix& L, Matrix& U, octave_idx_type *P,
                 octave_idx_type *Q)
 {
   bool have_b = ! b.is_empty ();
   octave_idx_type n = m.cols ();
 
   // Caclulate LU decomposition of 'A - sigma * B'
   Matrix AminusSigmaB (m);
 
@@ -424,19 +424,19 @@ LuAminusSigmaB (const Matrix &m, const M
 
   if (rcond_plus_one == 1.0 || octave::math::isnan (rcond))
     warn_convergence ();
 
   return true;
 }
 
 static bool
-LuAminusSigmaB (const SparseComplexMatrix &m, const SparseComplexMatrix &b,
+LuAminusSigmaB (const SparseComplexMatrix& m, const SparseComplexMatrix& b,
                 bool cholB, const ColumnVector& permB, Complex sigma,
-                SparseComplexMatrix &L, SparseComplexMatrix &U,
+                SparseComplexMatrix& L, SparseComplexMatrix& U,
                 octave_idx_type *P, octave_idx_type *Q)
 {
   bool have_b = ! b.is_empty ();
   octave_idx_type n = m.rows ();
 
   // Caclulate LU decomposition of 'A - sigma * B'
   SparseComplexMatrix AminusSigmaB (m);
 
@@ -516,19 +516,19 @@ LuAminusSigmaB (const SparseComplexMatri
 
   if (rcond_plus_one == 1.0 || octave::math::isnan (rcond))
     warn_convergence ();
 
   return true;
 }
 
 static bool
-LuAminusSigmaB (const ComplexMatrix &m, const ComplexMatrix &b,
+LuAminusSigmaB (const ComplexMatrix& m, const ComplexMatrix& b,
                 bool cholB, const ColumnVector& permB, Complex sigma,
-                ComplexMatrix &L, ComplexMatrix &U, octave_idx_type *P,
+                ComplexMatrix& L, ComplexMatrix& U, octave_idx_type *P,
                 octave_idx_type *Q)
 {
   bool have_b = ! b.is_empty ();
   octave_idx_type n = m.cols ();
 
   // Caclulate LU decomposition of 'A - sigma * B'
   ComplexMatrix AminusSigmaB (m);
 
@@ -591,19 +591,19 @@ LuAminusSigmaB (const ComplexMatrix &m, 
 
   return true;
 }
 
 template <typename M>
 octave_idx_type
 EigsRealSymmetricMatrix (const M& m, const std::string typ,
                          octave_idx_type k_arg, octave_idx_type p_arg,
-                         octave_idx_type &info, Matrix &eig_vec,
-                         ColumnVector &eig_val, const M& _b,
-                         ColumnVector &permB, ColumnVector &resid,
+                         octave_idx_type& info, Matrix& eig_vec,
+                         ColumnVector& eig_val, const M& _b,
+                         ColumnVector& permB, ColumnVector& resid,
                          std::ostream& os, double tol, bool rvec,
                          bool cholB, int disp, int maxit)
 {
   F77_INT k = octave::to_f77_int (k_arg);
   F77_INT p = octave::to_f77_int (p_arg);
   M b(_b);
   F77_INT n = octave::to_f77_int (m.cols ());
   F77_INT mode = 1;
@@ -869,19 +869,19 @@ EigsRealSymmetricMatrix (const M& m, con
 
   return ip(4);
 }
 
 template <typename M>
 octave_idx_type
 EigsRealSymmetricMatrixShift (const M& m, double sigma,
                               octave_idx_type k_arg, octave_idx_type p_arg,
-                              octave_idx_type &info, Matrix &eig_vec,
-                              ColumnVector &eig_val, const M& _b,
-                              ColumnVector &permB, ColumnVector &resid,
+                              octave_idx_type& info, Matrix& eig_vec,
+                              ColumnVector& eig_val, const M& _b,
+                              ColumnVector& permB, ColumnVector& resid,
                               std::ostream& os, double tol, bool rvec,
                               bool cholB, int disp, int maxit)
 {
   F77_INT k = octave::to_f77_int (k_arg);
   F77_INT p = octave::to_f77_int (p_arg);
   M b(_b);
   F77_INT n = octave::to_f77_int (m.cols ());
   F77_INT mode = 3;
@@ -1163,20 +1163,20 @@ EigsRealSymmetricMatrixShift (const M& m
   else
     (*current_liboctave_error_handler) ("eigs: error %d in dseupd", info2);
 
   return ip(4);
 }
 
 octave_idx_type
 EigsRealSymmetricFunc (EigsFunc fun, octave_idx_type n_arg,
-                       const std::string &_typ, double sigma,
+                       const std::string& _typ, double sigma,
                        octave_idx_type k_arg, octave_idx_type p_arg,
-                       octave_idx_type &info, Matrix &eig_vec,
-                       ColumnVector &eig_val, ColumnVector &resid,
+                       octave_idx_type& info, Matrix& eig_vec,
+                       ColumnVector& eig_val, ColumnVector& resid,
                        std::ostream& os, double tol, bool rvec,
                        bool /* cholB */, int disp, int maxit)
 {
   F77_INT n = octave::to_f77_int (n_arg);
   F77_INT k = octave::to_f77_int (k_arg);
   F77_INT p = octave::to_f77_int (p_arg);
   std::string typ (_typ);
   bool have_sigma = (sigma ? true : false);
@@ -1408,19 +1408,19 @@ EigsRealSymmetricFunc (EigsFunc fun, oct
 
   return ip(4);
 }
 
 template <typename M>
 octave_idx_type
 EigsRealNonSymmetricMatrix (const M& m, const std::string typ,
                             octave_idx_type k_arg, octave_idx_type p_arg,
-                            octave_idx_type &info, ComplexMatrix &eig_vec,
-                            ComplexColumnVector &eig_val, const M& _b,
-                            ColumnVector &permB, ColumnVector &resid,
+                            octave_idx_type& info, ComplexMatrix& eig_vec,
+                            ComplexColumnVector& eig_val, const M& _b,
+                            ColumnVector& permB, ColumnVector& resid,
                             std::ostream& os, double tol, bool rvec,
                             bool cholB, int disp, int maxit)
 {
   F77_INT k = octave::to_f77_int (k_arg);
   F77_INT p = octave::to_f77_int (p_arg);
   M b(_b);
   F77_INT n = octave::to_f77_int (m.cols ());
   F77_INT mode = 1;
@@ -1734,20 +1734,20 @@ EigsRealNonSymmetricMatrix (const M& m, 
 
   return ip(4);
 }
 
 template <typename M>
 octave_idx_type
 EigsRealNonSymmetricMatrixShift (const M& m, double sigmar,
                                  octave_idx_type k_arg, octave_idx_type p_arg,
-                                 octave_idx_type &info,
-                                 ComplexMatrix &eig_vec,
-                                 ComplexColumnVector &eig_val, const M& _b,
-                                 ColumnVector &permB, ColumnVector &resid,
+                                 octave_idx_type& info,
+                                 ComplexMatrix& eig_vec,
+                                 ComplexColumnVector& eig_val, const M& _b,
+                                 ColumnVector& permB, ColumnVector& resid,
                                  std::ostream& os, double tol, bool rvec,
                                  bool cholB, int disp, int maxit)
 {
   F77_INT k = octave::to_f77_int (k_arg);
   F77_INT p = octave::to_f77_int (p_arg);
   M b(_b);
   F77_INT n = octave::to_f77_int (m.cols ());
   F77_INT mode = 3;
@@ -2083,20 +2083,20 @@ EigsRealNonSymmetricMatrixShift (const M
   else
     (*current_liboctave_error_handler) ("eigs: error %d in dneupd", info2);
 
   return ip(4);
 }
 
 octave_idx_type
 EigsRealNonSymmetricFunc (EigsFunc fun, octave_idx_type n_arg,
-                          const std::string &_typ, double sigmar,
+                          const std::string& _typ, double sigmar,
                           octave_idx_type k_arg, octave_idx_type p_arg,
-                          octave_idx_type &info, ComplexMatrix &eig_vec,
-                          ComplexColumnVector &eig_val, ColumnVector &resid,
+                          octave_idx_type& info, ComplexMatrix& eig_vec,
+                          ComplexColumnVector& eig_val, ColumnVector& resid,
                           std::ostream& os, double tol, bool rvec,
                           bool /* cholB */, int disp, int maxit)
 {
   F77_INT n = octave::to_f77_int (n_arg);
   F77_INT k = octave::to_f77_int (k_arg);
   F77_INT p = octave::to_f77_int (p_arg);
   std::string typ (_typ);
   bool have_sigma = (sigmar ? true : false);
@@ -2376,20 +2376,20 @@ EigsRealNonSymmetricFunc (EigsFunc fun, 
 
   return ip(4);
 }
 
 template <typename M>
 octave_idx_type
 EigsComplexNonSymmetricMatrix (const M& m, const std::string typ,
                                octave_idx_type k_arg, octave_idx_type p_arg,
-                               octave_idx_type &info, ComplexMatrix &eig_vec,
-                               ComplexColumnVector &eig_val, const M& _b,
-                               ColumnVector &permB,
-                               ComplexColumnVector &cresid,
+                               octave_idx_type& info, ComplexMatrix& eig_vec,
+                               ComplexColumnVector& eig_val, const M& _b,
+                               ColumnVector& permB,
+                               ComplexColumnVector& cresid,
                                std::ostream& os, double tol, bool rvec,
                                bool cholB, int disp, int maxit)
 {
   F77_INT k = octave::to_f77_int (k_arg);
   F77_INT p = octave::to_f77_int (p_arg);
   M b(_b);
   F77_INT n = octave::to_f77_int (m.cols ());
   F77_INT mode = 1;
@@ -2661,21 +2661,21 @@ EigsComplexNonSymmetricMatrix (const M& 
 
   return ip(4);
 }
 
 template <typename M>
 octave_idx_type
 EigsComplexNonSymmetricMatrixShift (const M& m, Complex sigma,
                                     octave_idx_type k_arg, octave_idx_type p_arg,
-                                    octave_idx_type &info,
-                                    ComplexMatrix &eig_vec,
-                                    ComplexColumnVector &eig_val, const M& _b,
-                                    ColumnVector &permB,
-                                    ComplexColumnVector &cresid,
+                                    octave_idx_type& info,
+                                    ComplexMatrix& eig_vec,
+                                    ComplexColumnVector& eig_val, const M& _b,
+                                    ColumnVector& permB,
+                                    ComplexColumnVector& cresid,
                                     std::ostream& os, double tol, bool rvec,
                                     bool cholB, int disp, int maxit)
 {
   F77_INT k = octave::to_f77_int (k_arg);
   F77_INT p = octave::to_f77_int (p_arg);
   M b(_b);
   F77_INT n = octave::to_f77_int (m.cols ());
   F77_INT mode = 3;
@@ -2972,21 +2972,21 @@ EigsComplexNonSymmetricMatrixShift (cons
     (*current_liboctave_error_handler)
       ("eigs: error %d in zneupd", info2);
 
   return ip(4);
 }
 
 octave_idx_type
 EigsComplexNonSymmetricFunc (EigsComplexFunc fun, octave_idx_type n_arg,
-                             const std::string &_typ, Complex sigma,
+                             const std::string& _typ, Complex sigma,
                              octave_idx_type k_arg, octave_idx_type p_arg,
-                             octave_idx_type &info, ComplexMatrix &eig_vec,
-                             ComplexColumnVector &eig_val,
-                             ComplexColumnVector &cresid, std::ostream& os,
+                             octave_idx_type& info, ComplexMatrix& eig_vec,
+                             ComplexColumnVector& eig_val,
+                             ComplexColumnVector& cresid, std::ostream& os,
                              double tol, bool rvec, bool /* cholB */,
                              int disp, int maxit)
 {
   F77_INT n = octave::to_f77_int (n_arg);
   F77_INT k = octave::to_f77_int (k_arg);
   F77_INT p = octave::to_f77_int (p_arg);
   std::string typ (_typ);
   bool have_sigma = (std::abs (sigma) ? true : false);
diff --git a/liboctave/numeric/oct-fftw.cc b/liboctave/numeric/oct-fftw.cc
--- a/liboctave/numeric/oct-fftw.cc
+++ b/liboctave/numeric/oct-fftw.cc
@@ -791,17 +791,17 @@ namespace octave
       for (size_t j = nc/2+1; j < nc; j++)
         out[j*stride + i*dist] = conj (out[(nc - j)*stride + i*dist]);
 
     octave_quit ();
   }
 
   template <typename T>
   static inline void
-  convert_packcomplex_Nd (T *out, const dim_vector &dv)
+  convert_packcomplex_Nd (T *out, const dim_vector& dv)
   {
     size_t nc = dv(0);
     size_t nr = dv(1);
     size_t np = (dv.ndims () > 2 ? dv.numel () / nc / nr : 1);
     size_t nrp = nr * np;
     T *ptr1, *ptr2;
 
     octave_quit ();
@@ -918,17 +918,17 @@ namespace octave
       for (size_t i = 0; i < npts; i++)
         out[i*stride + j*dist] /= scale;
 
     return 0;
   }
 
   int
   fftw::fftNd (const double *in, Complex *out, const int rank,
-                      const dim_vector &dv)
+                      const dim_vector& dv)
   {
     octave_idx_type dist = 1;
     for (int i = 0; i < rank; i++)
       dist *= dv(i);
 
     // Fool with the position of the start of the output matrix, so that
     // creating other half of the matrix won't cause cache problems.
 
@@ -945,17 +945,17 @@ namespace octave
 
     convert_packcomplex_Nd (out, dv);
 
     return 0;
   }
 
   int
   fftw::fftNd (const Complex *in, Complex *out, const int rank,
-                      const dim_vector &dv)
+                      const dim_vector& dv)
   {
     octave_idx_type dist = 1;
     for (int i = 0; i < rank; i++)
       dist *= dv(i);
 
     void *vplan = fftw_planner::create_plan (FFTW_FORWARD, rank, dv,
                                              1, 1, dist, in, out);
     fftw_plan plan = reinterpret_cast<fftw_plan> (vplan);
@@ -964,17 +964,17 @@ namespace octave
                       reinterpret_cast<fftw_complex *> (const_cast<Complex *>(in)),
                       reinterpret_cast<fftw_complex *> (out));
 
     return 0;
   }
 
   int
   fftw::ifftNd (const Complex *in, Complex *out, const int rank,
-                       const dim_vector &dv)
+                       const dim_vector& dv)
   {
     octave_idx_type dist = 1;
     for (int i = 0; i < rank; i++)
       dist *= dv(i);
 
     void *vplan = fftw_planner::create_plan (FFTW_BACKWARD, rank, dv,
                                              1, 1, dist, in, out);
     fftw_plan plan = reinterpret_cast<fftw_plan> (vplan);
@@ -1053,17 +1053,17 @@ namespace octave
       for (size_t i = 0; i < npts; i++)
         out[i*stride + j*dist] /= scale;
 
     return 0;
   }
 
   int
   fftw::fftNd (const float *in, FloatComplex *out, const int rank,
-                      const dim_vector &dv)
+                      const dim_vector& dv)
   {
     octave_idx_type dist = 1;
     for (int i = 0; i < rank; i++)
       dist *= dv(i);
 
     // Fool with the position of the start of the output matrix, so that
     // creating other half of the matrix won't cause cache problems.
 
@@ -1080,17 +1080,17 @@ namespace octave
 
     convert_packcomplex_Nd (out, dv);
 
     return 0;
   }
 
   int
   fftw::fftNd (const FloatComplex *in, FloatComplex *out, const int rank,
-                      const dim_vector &dv)
+                      const dim_vector& dv)
   {
     octave_idx_type dist = 1;
     for (int i = 0; i < rank; i++)
       dist *= dv(i);
 
     void *vplan = float_fftw_planner::create_plan (FFTW_FORWARD, rank, dv,
                                                    1, 1, dist, in, out);
     fftwf_plan plan = reinterpret_cast<fftwf_plan> (vplan);
@@ -1099,17 +1099,17 @@ namespace octave
                        reinterpret_cast<fftwf_complex *> (const_cast<FloatComplex *>(in)),
                        reinterpret_cast<fftwf_complex *> (out));
 
     return 0;
   }
 
   int
   fftw::ifftNd (const FloatComplex *in, FloatComplex *out, const int rank,
-                       const dim_vector &dv)
+                       const dim_vector& dv)
   {
     octave_idx_type dist = 1;
     for (int i = 0; i < rank; i++)
       dist *= dv(i);
 
     void *vplan = float_fftw_planner::create_plan (FFTW_BACKWARD, rank, dv,
                                                    1, 1, dist, in, out);
     fftwf_plan plan = reinterpret_cast<fftwf_plan> (vplan);
diff --git a/liboctave/numeric/oct-rand.h b/liboctave/numeric/oct-rand.h
--- a/liboctave/numeric/oct-rand.h
+++ b/liboctave/numeric/oct-rand.h
@@ -70,17 +70,17 @@ public:
 
   // Return the current state.
   static ColumnVector state (const std::string& d = "")
   {
     return instance_ok () ? instance->do_state (d) : ColumnVector ();
   }
 
   // Set the current state/
-  static void state (const ColumnVector &s,
+  static void state (const ColumnVector& s,
                      const std::string& d = "")
   {
     if (instance_ok ())
       instance->do_state (s, d);
   }
 
   // Reset the current state/
   static void reset (const std::string& d)
@@ -208,17 +208,17 @@ private:
 
   // Reset the seed.
   void do_reset ();
 
   // Return the current state.
   ColumnVector do_state (const std::string& d);
 
   // Set the current state/
-  void do_state (const ColumnVector &s, const std::string& d);
+  void do_state (const ColumnVector& s, const std::string& d);
 
   // Reset the current state/
   void do_reset (const std::string& d);
 
   // Return the current distribution.
   std::string do_distribution (void);
 
   // Set the current distribution.  May be either "uniform" (the
diff --git a/liboctave/numeric/sparse-dmsolve.cc b/liboctave/numeric/sparse-dmsolve.cc
--- a/liboctave/numeric/sparse-dmsolve.cc
+++ b/liboctave/numeric/sparse-dmsolve.cc
@@ -352,17 +352,17 @@ solve_singularity_warning (double)
   // Dummy singularity handler so that LU solver doesn't flag
   // an error for numerically rank defficient matrices
 }
 
 #endif
 
 template <typename RT, typename ST, typename T>
 RT
-dmsolve (const ST &a, const T &b, octave_idx_type &info)
+dmsolve (const ST& a, const T& b, octave_idx_type& info)
 {
   RT retval;
 
 #if defined (HAVE_CXSPARSE)
 
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
 
diff --git a/liboctave/util/kpse.cc b/liboctave/util/kpse.cc
--- a/liboctave/util/kpse.cc
+++ b/liboctave/util/kpse.cc
@@ -258,17 +258,17 @@ static bool first_search = true;
 
 /* This function is called after every search.  */
 
 static void
 log_search (const std::list<std::string>& filenames)
 {
   if (KPSE_DEBUG_P (KPSE_DEBUG_SEARCH))
     {
-      for (const auto &filename : filenames)
+      for (const auto& filename : filenames)
         {
           octave::sys::time now;
           std::cerr << now.unix_time () << " " << filename << std::endl;
         }
     }
 }
 
 /* Concatenate each element in DIRS with NAME (assume each ends with a
@@ -560,17 +560,17 @@ find_first_of (const std::string& path, 
             std::cerr << *p;
           else
             std::cerr << ", " << *p;
         }
 
       std::cerr << "), path=" << path << "." << std::endl;
     }
 
-  for (const auto &name : names)
+  for (const auto& name : names)
     {
       if (kpse_absolute_p (name, true))
         {
           /* If the name is absolute or explicitly relative, no need
              to consider PATH at all.  If we find something, then we
              are done.  */
 
           ret_list = absolute_search (name);
@@ -796,17 +796,17 @@ kpse_expand_kpse_dot (const std::string&
 
 static std::string
 kpse_brace_expand_element (const std::string& elt)
 {
   std::string ret;
 
   std::list<std::string> expansions = brace_expand (elt);
 
-  for (const auto &expanded_elt : expansions)
+  for (const auto& expanded_elt : expansions)
     {
       /* Do $ and ~ expansion on each element.  */
       std::string x = kpse_expand (expanded_elt);
 
       if (x != elt)
         {
           /* If we did any expansions, do brace expansion again.  Since
              recursive variable definitions are not allowed, this recursion
@@ -958,18 +958,18 @@ array_concat (const std::list<std::strin
   std::list<std::string> result;
 
   if (arr1.empty ())
     result = arr2;
   else if (arr2.empty ())
     result = arr1;
   else
     {
-      for (const auto &elt_2 : arr2)
-        for (const auto &elt_1 : arr1)
+      for (const auto& elt_2 : arr2)
+        for (const auto& elt_1 : arr1)
           result.push_back (elt_1 + elt_2);
     }
 
   return result;
 }
 
 static int brace_gobbler (const std::string&, int&, int);
 static std::list<std::string> expand_amble (const std::string&);
@@ -1247,17 +1247,17 @@ expanding_p (const std::string& var)
   return (expansions.find (var) != expansions.end ()) ? expansions[var] : false;
 }
 
 /* Append the result of value of 'var' to EXPANSION, where 'var' begins
    at START and ends at END.  If 'var' is not set, do not complain.
    This is a subroutine for the more complicated expansion function.  */
 
 static void
-expand (std::string &expansion, const std::string& var)
+expand (std::string& expansion, const std::string& var)
 {
   if (expanding_p (var))
     {
       (*current_liboctave_warning_with_id_handler)
         ("Octave:pathsearch-syntax",
          "pathsearch: variable '%s' references itself (eventually)",
          var.c_str ());
     }
diff --git a/liboctave/util/lo-regexp.h b/liboctave/util/lo-regexp.h
--- a/liboctave/util/lo-regexp.h
+++ b/liboctave/util/lo-regexp.h
@@ -199,17 +199,17 @@ namespace octave
 
       match_element (const string_vector& nt, const string_vector& t,
                      const std::string& ms, const Matrix& te,
                      double s, double e)
         : x_match_string (ms), x_named_tokens (nt), x_tokens (t),
           x_token_extents (te), x_start (s), x_end (e)
       { }
 
-      match_element (const match_element &a)
+      match_element (const match_element& a)
         : x_match_string (a.x_match_string),
           x_named_tokens (a.x_named_tokens), x_tokens (a.x_tokens),
           x_token_extents (a.x_token_extents),
           x_start (a.x_start), x_end (a.x_end)
       { }
 
       std::string match_string (void) const { return x_match_string; }
       string_vector named_tokens (void) const { return x_named_tokens; }
