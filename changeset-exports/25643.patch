# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1532021331 14400
#      Thu Jul 19 13:28:51 2018 -0400
# Node ID afb5288a25adef3f852da77037340efef7e47768
# Parent  3b214399f3231aadf5c6f79e4152b8b8d131fe48
move text engine classes inside octave namespace

* text-engine.cc: Rename from txt-eng.cc.
* text-engine.h: Rename from txt-eng.h.  Change all uses.
* txt-eng.h: Provide for backward-compatibility.
* libinterp/corefcn/module.mk: Update.

* text-engine.cc, text-engine.h: Move classes inside octave
namespace.  Change all uses.

diff --git a/libinterp/corefcn/base-text-renderer.h b/libinterp/corefcn/base-text-renderer.h
--- a/libinterp/corefcn/base-text-renderer.h
+++ b/libinterp/corefcn/base-text-renderer.h
@@ -27,18 +27,18 @@ along with Octave; see the file COPYING.
 #include "octave-config.h"
 
 #include <list>
 #include <string>
 
 #include "dMatrix.h"
 #include "uint8NDArray.h"
 
+#include "text-engine.h"
 #include "text-renderer.h"
-#include "txt-eng.h"
 
 namespace octave
 {
   class
   base_text_renderer : public text_processor
   {
   public:
 
diff --git a/libinterp/corefcn/graphics.cc b/libinterp/corefcn/graphics.cc
--- a/libinterp/corefcn/graphics.cc
+++ b/libinterp/corefcn/graphics.cc
@@ -54,16 +54,17 @@ along with Octave; see the file COPYING.
 #include "interpreter-private.h"
 #include "interpreter.h"
 #include "ov.h"
 #include "ovl.h"
 #include "oct-map.h"
 #include "ov-fcn-handle.h"
 #include "pager.h"
 #include "parse.h"
+#include "text-engine.h"
 #include "text-renderer.h"
 #include "unwind-prot.h"
 #include "utils.h"
 #include "octave-default-image.h"
 
 // forward declarations
 static octave_value xget (const graphics_handle& h, const caseless_str& name);
 
@@ -9916,24 +9917,24 @@ uicontrol::properties::get_extent (void)
   Matrix parent_size = parent_bbox.extract_n (0, 2, 1, 2);
 
   return convert_position (m, "pixels", get_units (), parent_size);
 }
 
 void
 uicontrol::properties::update_text_extent (void)
 {
-  text_element *elt;
+  octave::text_element *elt;
   octave::text_renderer txt_renderer;
   Matrix box;
 
   // FIXME: parsed content should be cached for efficiency
   // FIXME: support multiline text
 
-  elt = text_parser::parse (get_string_string (), "none");
+  elt = octave::text_parser::parse (get_string_string (), "none");
 
   gh_manager::auto_lock guard;
   txt_renderer.set_font (get_fontname (), get_fontweight (),
                          get_fontangle (), get_fontsize ());
 
   box = txt_renderer.get_extent (elt, 0);
 
   delete elt;
diff --git a/libinterp/corefcn/module.mk b/libinterp/corefcn/module.mk
--- a/libinterp/corefcn/module.mk
+++ b/libinterp/corefcn/module.mk
@@ -81,16 +81,17 @@ COREFCN_INC = \
   %reldir%/settings.h \
   %reldir%/sighandlers.h \
   %reldir%/sparse-xdiv.h \
   %reldir%/sparse-xpow.h \
   %reldir%/symrec.h \
   %reldir%/symscope.h \
   %reldir%/symtab.h \
   %reldir%/sysdep.h \
+  %reldir%/text-engine.h \
   %reldir%/text-renderer.h \
   %reldir%/toplev.h \
   %reldir%/txt-eng.h \
   %reldir%/url-handle-manager.h \
   %reldir%/utils.h \
   %reldir%/variables.h \
   %reldir%/xdiv.h \
   %reldir%/xnorm.h \
@@ -237,21 +238,21 @@ COREFCN_SRC = \
   %reldir%/svd.cc \
   %reldir%/sylvester.cc \
   %reldir%/symrec.cc \
   %reldir%/symscope.cc \
   %reldir%/symtab.cc \
   %reldir%/syscalls.cc \
   %reldir%/sysdep.cc \
   %reldir%/time.cc \
+  %reldir%/text-engine.cc \
   %reldir%/text-renderer.cc \
   %reldir%/toplev.cc \
   %reldir%/tril.cc \
   %reldir%/tsearch.cc \
-  %reldir%/txt-eng.cc \
   %reldir%/typecast.cc \
   %reldir%/urlwrite.cc \
   %reldir%/url-handle-manager.cc \
   %reldir%/utils.cc \
   %reldir%/variables.cc \
   %reldir%/xdiv.cc \
   %reldir%/xnorm.cc \
   %reldir%/xpow.cc \
diff --git a/libinterp/corefcn/oct-tex-lexer.in.ll b/libinterp/corefcn/oct-tex-lexer.in.ll
--- a/libinterp/corefcn/oct-tex-lexer.in.ll
+++ b/libinterp/corefcn/oct-tex-lexer.in.ll
@@ -57,17 +57,19 @@ along with Octave; see the file COPYING.
 
 %x NUM_MODE
 %x MAYBE_NUM_MODE
 
 %{
 
 #include "unistd-wrappers.h"
 
-#include "txt-eng.h"
+#include "text-engine.h"
+
+// oct-tex-parser.h must be included after text-engine.h
 #include "oct-tex-parser.h"
 
 // FIXME: with bison 3.x, OCTAVE_TEX_STYPE appears in the generated
 // oct-parse.h file, but there is no definition for YYSTYPE, which is
 // needed by the code that is generated by flex.  I can't seem to find
 // a way to tell flex to use OCTAVE_TEX_STYPE instead of YYSTYPE in
 // the code it generates, or to tell bison to provide the definition
 // of YYSTYPE in the generated oct-parse.h file.
@@ -195,54 +197,55 @@ void *
 octave_tex_alloc (yy_size_t size, yyscan_t)
 {
   return malloc (size);
 }
 
 void *
 octave_tex_realloc (void *ptr, yy_size_t size, yyscan_t)
 {
-  return realloc (ptr, size);
+return realloc (ptr, size);
 }
 
 void
 octave_tex_free (void *ptr, yyscan_t)
 {
   free (ptr);
 }
 
-bool
-text_parser_tex::init_lexer (const std::string& s)
+namespace octave
 {
-  if (! scanner)
-    octave_tex_lex_init (&scanner);
+  bool text_parser_tex::init_lexer (const std::string& s)
+  {
+    if (! scanner)
+      octave_tex_lex_init (&scanner);
 
-  if (scanner)
-    {
-      if (buffer_state)
-        {
-          octave_tex__delete_buffer (reinterpret_cast<YY_BUFFER_STATE> (buffer_state),
-                                     scanner);
-          buffer_state = nullptr;
-        }
+    if (scanner)
+      {
+        if (buffer_state)
+          {
+            octave_tex__delete_buffer (reinterpret_cast<YY_BUFFER_STATE> (buffer_state),
+                                       scanner);
+            buffer_state = nullptr;
+          }
 
-      buffer_state = octave_tex__scan_bytes (s.data (), s.length (), scanner);
-    }
+        buffer_state = octave_tex__scan_bytes (s.data (), s.length (), scanner);
+      }
 
-  return (scanner && buffer_state);
-}
+    return (scanner && buffer_state);
+  }
 
-void
-text_parser_tex::destroy_lexer (void)
-{
-  if (buffer_state)
-    {
-      octave_tex__delete_buffer (reinterpret_cast<YY_BUFFER_STATE> (buffer_state),
-                                 scanner);
-      buffer_state = nullptr;
-    }
+  void text_parser_tex::destroy_lexer (void)
+  {
+    if (buffer_state)
+      {
+        octave_tex__delete_buffer (reinterpret_cast<YY_BUFFER_STATE> (buffer_state),
+                                   scanner);
+        buffer_state = nullptr;
+      }
 
-  if (scanner)
-    {
-      octave_tex_lex_destroy (scanner);
-      scanner = nullptr;
-    }
+    if (scanner)
+      {
+        octave_tex_lex_destroy (scanner);
+        scanner = nullptr;
+      }
+  }
 }
diff --git a/libinterp/corefcn/oct-tex-parser.yy b/libinterp/corefcn/oct-tex-parser.yy
--- a/libinterp/corefcn/oct-tex-parser.yy
+++ b/libinterp/corefcn/oct-tex-parser.yy
@@ -23,21 +23,23 @@ along with Octave; see the file COPYING.
 %{
 
 #define YYDEBUG 1
 
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
-#include "txt-eng.h"
+#include "text-engine.h"
+
+// oct-tex-parser.h must be included after text-engine.h
 #include "oct-tex-parser.h"
 
 extern int octave_tex_lex (YYSTYPE *, void *);
-static void yyerror (text_parser_tex& parser, const char *s);
+ static void yyerror (octave::text_parser_tex& parser, const char *s);
 
 #define scanner parser.get_scanner ()
 #define yyalloc octave_tex_yyalloc
 
 #if defined (HAVE_PRAGMA_GCC_DIAGNOSTIC)
    // Disable this warning for code that is generated by Bison,
    // including grammar rules.  Push the current state so we can
    // restore the warning state prior to functions we define at
@@ -46,34 +48,34 @@ static void yyerror (text_parser_tex& pa
 #  pragma GCC diagnostic ignored "-Wold-style-cast"
 #endif
 
 %}
 
 %define api.pure
 // No spaces inside the braces for the prefix definition!
 %define api.prefix {octave_tex_}
-%parse-param { text_parser_tex& parser }
+%parse-param { octave::text_parser_tex& parser }
 %lex-param { void *scanner }
 
 %code requires {#include <string>}
 
 %union
 {
   // Leaf symbols produced by the scanner.
-  char                       ch;
-  double                     num;
-  int                        sym;
+  char ch;
+  double num;
+  int sym;
 
   // Used for string buffering.
-  std::string*               str;
+  std::string *str;
 
   // Objects produced by the parser.
-  text_element*              e_base;
-  text_element_list*         e_list;
+  octave::text_element *e_base;
+  octave::text_element_list *e_list;
 }
 
 %token BF IT SL RM
 %token FONTNAME FONTSIZE
 %token COLOR COLOR_RGB
 %token START END SUPER SUB
 %token<ch> CH
 %token<num> NUM
@@ -95,135 +97,139 @@ static void yyerror (text_parser_tex& pa
 
 %nonassoc STR
 %nonassoc CH
 
 %start string
 
 %%
 
-simple_string                   : CH
-                                  { $$ = new std::string (1, $1); }
-                                | simple_string CH
-                                  { $1->append (1, $2); $$ = $1; }
-                                ;
+simple_string           : CH
+                          { $$ = new std::string (1, $1); }
+                        | simple_string CH
+                          { $1->append (1, $2); $$ = $1; }
+                        ;
 
-symbol_element                  : SYM
-                                  { $$ = new text_element_symbol ($1); }
-                                ;
+symbol_element          : SYM
+                          { $$ = new octave::text_element_symbol ($1); }
+                        ;
 
-font_modifier_element           : BF
-                                  { $$ = new text_element_fontstyle (text_element_fontstyle::bold); }
-                                | IT
-                                  { $$ = new text_element_fontstyle (text_element_fontstyle::italic); }
-                                | SL
-                                  { $$ = new text_element_fontstyle (text_element_fontstyle::oblique); }
-                                | RM
-                                  { $$ = new text_element_fontstyle (text_element_fontstyle::normal); }
-                                ;
+font_modifier_element   : BF
+                          { $$ = new octave::text_element_fontstyle (octave::text_element_fontstyle::bold); }
+                        | IT
+                          { $$ = new octave::text_element_fontstyle (octave::text_element_fontstyle::italic); }
+                        | SL
+                          { $$ = new octave::text_element_fontstyle (octave::text_element_fontstyle::oblique); }
+                        | RM
+                          { $$ = new octave::text_element_fontstyle (octave::text_element_fontstyle::normal); }
+                        ;
 
-fontsize_element                : FONTSIZE START NUM END
-                                  { $$ = new text_element_fontsize ($3); }
-                                ;
+fontsize_element        : FONTSIZE START NUM END
+                          { $$ = new octave::text_element_fontsize ($3); }
+                        ;
 
-fontname_element                : FONTNAME START simple_string END
-                                  {
-                                    $$ = new text_element_fontname (*$3);
-                                    delete $3;
-                                  }
-                                ;
+fontname_element        : FONTNAME START simple_string END
+                          {
+                            $$ = new octave::text_element_fontname (*$3);
+                            delete $3;
+                          }
+                        ;
 
-color_element                   : COLOR START simple_string END
-                                  {
-                                    $$ = new text_element_color (*$3);
-                                    delete $3;
-                                  }
-                                | COLOR_RGB START NUM NUM NUM END
-                                  {
-                                    $$ = new text_element_color ($3, $4, $5);
-                                  }
-                                ;
+color_element           : COLOR START simple_string END
+                          {
+                            $$ = new octave::text_element_color (*$3);
+                            delete $3;
+                          }
+                        | COLOR_RGB START NUM NUM NUM END
+                          {
+                            $$ = new octave::text_element_color ($3, $4, $5);
+                          }
+                        ;
 
-string_element                  : simple_string %prec STR
-                                  {
-                                    $$ = new text_element_string (*$1);
-                                    delete $1;
-                                  }
-                                | scoped_string_element_list
-                                  { $$ = $1; }
-                                | symbol_element
-                                | font_modifier_element
-                                | fontsize_element
-                                | fontname_element
-                                | color_element
-                                | superscript_element %prec SCRIPT
-                                | subscript_element %prec SCRIPT
-                                | combined_script_element
-                                ;
+string_element          : simple_string %prec STR
+                          {
+                            $$ = new octave::text_element_string (*$1);
+                            delete $1;
+                          }
+                        | scoped_string_element_list
+                          { $$ = $1; }
+                        | symbol_element
+                        | font_modifier_element
+                        | fontsize_element
+                        | fontname_element
+                        | color_element
+                        | superscript_element %prec SCRIPT
+                        | subscript_element %prec SCRIPT
+                        | combined_script_element
+                        ;
 
-superscript_element             : SUPER CH
-                                  { $$ = new text_element_superscript ($2); }
-                                | SUPER scoped_string_element_list
-                                  { $$ = new text_element_superscript ($2); }
-                                | SUPER symbol_element
-                                  { $$ = new text_element_superscript ($2); }
-                                ;
+superscript_element     : SUPER CH
+                          { $$ = new octave::text_element_superscript ($2); }
+                        | SUPER scoped_string_element_list
+                          { $$ = new octave::text_element_superscript ($2); }
+                        | SUPER symbol_element
+                          { $$ = new octave::text_element_superscript ($2); }
+                        ;
 
-subscript_element               : SUB CH
-                                  { $$ = new text_element_subscript ($2); }
-                                | SUB scoped_string_element_list
-                                  { $$ = new text_element_subscript ($2); }
-                                | SUB symbol_element
-                                  { $$ = new text_element_subscript ($2); }
-                                ;
+subscript_element       : SUB CH
+                          { $$ = new octave::text_element_subscript ($2); }
+                        | SUB scoped_string_element_list
+                          { $$ = new octave::text_element_subscript ($2); }
+                        | SUB symbol_element
+                          { $$ = new octave::text_element_subscript ($2); }
+                        ;
 
-combined_script_element         : subscript_element superscript_element
-                                  { $$ = new text_element_combined ($1, $2); }
-                                | superscript_element subscript_element
-                                  { $$ = new text_element_combined ($1, $2); }
-                                ;
+combined_script_element : subscript_element superscript_element
+                          { $$ = new octave::text_element_combined ($1, $2); }
+                        | superscript_element subscript_element
+                          { $$ = new octave::text_element_combined ($1, $2); }
+                        ;
 
-string_element_list             : string_element
-                                  { $$ = new text_element_list ($1); }
-                                | string_element_list string_element
-                                  { $1->push_back ($2); $$ = $1; }
-                                ;
+string_element_list     : string_element
+                          { $$ = new octave::text_element_list ($1); }
+                        | string_element_list string_element
+                          { $1->push_back ($2); $$ = $1; }
+                        ;
 
-scoped_string_element_list      : START string_element_list END
-                                  { $$ = $2; }
-                                | START END
-                                  { $$ = new text_element_list (); }
-                                ;
+scoped_string_element_list
+                        : START string_element_list END
+                          { $$ = $2; }
+                        | START END
+                          { $$ = new octave::text_element_list (); }
+                        ;
 
-string                          : // empty
-                                  { parser.set_parse_result (new text_element_string ("")); }
-                                | string_element_list
-                                  { parser.set_parse_result ($1); }
-                                ;
+string                  : // empty
+                          { parser.set_parse_result (new octave::text_element_string ("")); }
+                        | string_element_list
+                          { parser.set_parse_result ($1); }
+                        ;
 
 %%
 
 #if defined (HAVE_PRAGMA_GCC_DIAGNOSTIC)
    // Restore prevailing warning state for remainder of the file.
 #  pragma GCC diagnostic pop
 #endif
 
-text_element*
-text_parser_tex::parse (const std::string& s)
+namespace octave
 {
-  octave_tex_debug = 0;
+  text_element*
+  text_parser_tex::parse (const std::string& s)
+  {
+    octave_tex_debug = 0;
 
-  if (init_lexer (s))
-    {
-      result = nullptr;
+    if (init_lexer (s))
+      {
+        result = nullptr;
 
-      if (octave_tex_parse (*this) == 0)
-        return result;
-    }
+        if (octave_tex_parse (*this) == 0)
+          return result;
+      }
 
-  return new text_element_string (s);
+    return new text_element_string (s);
+  }
 }
 
 static void
-yyerror (text_parser_tex&, const char *s)
+yyerror (octave::text_parser_tex&, const char *s)
 {
   fprintf (stderr, "TeX parse error: %s\n", s);
 }
diff --git a/libinterp/corefcn/txt-eng.cc b/libinterp/corefcn/text-engine.cc
rename from libinterp/corefcn/txt-eng.cc
rename to libinterp/corefcn/text-engine.cc
--- a/libinterp/corefcn/txt-eng.cc
+++ b/libinterp/corefcn/text-engine.cc
@@ -19,21 +19,24 @@ along with Octave; see the file COPYING.
 <https://www.gnu.org/licenses/>.
 
 */
 
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
-#include "txt-eng.h"
+#include "text-engine.h"
 #include "oct-tex-symbols.cc"
 
-uint32_t
-text_element_symbol::get_symbol_code (void) const
+namespace octave
 {
-  uint32_t code = invalid_code;
+  uint32_t
+  text_element_symbol::get_symbol_code (void) const
+  {
+    uint32_t code = invalid_code;
 
-  if (0 <= symbol && symbol < num_symbol_codes)
-    code = symbol_codes[symbol][0];
+    if (0 <= symbol && symbol < num_symbol_codes)
+      code = symbol_codes[symbol][0];
 
-  return code;
+    return code;
+  }
 }
diff --git a/libinterp/corefcn/txt-eng.h b/libinterp/corefcn/text-engine.h
copy from libinterp/corefcn/txt-eng.h
copy to libinterp/corefcn/text-engine.h
--- a/libinterp/corefcn/txt-eng.h
+++ b/libinterp/corefcn/text-engine.h
@@ -15,440 +15,494 @@ MERCHANTABILITY or FITNESS FOR A PARTICU
 GNU General Public License for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, see
 <https://www.gnu.org/licenses/>.
 
 */
 
-#if ! defined (octave_txt_eng_h)
-#define octave_txt_eng_h 1
+#if ! defined (octave_text_engine_h)
+#define octave_text_engine_h 1
 
 #include "octave-config.h"
 
 #include <memory>
 #include <string>
 
 #include "base-list.h"
 #include "caseless-str.h"
 #include "dMatrix.h"
 
-class text_element;
-class text_element_string;
-class text_element_symbol;
-class text_element_list;
-class text_element_subscript;
-class text_element_superscript;
-class text_element_combined;
-class text_element_fontname;
-class text_element_fontsize;
-class text_element_fontstyle;
-class text_element_color;
-
-class text_processor;
-
-class
-OCTINTERP_API
-text_element
+namespace octave
 {
-public:
-  text_element (void) { }
+  class text_element;
+  class text_element_string;
+  class text_element_symbol;
+  class text_element_list;
+  class text_element_subscript;
+  class text_element_superscript;
+  class text_element_combined;
+  class text_element_fontname;
+  class text_element_fontsize;
+  class text_element_fontstyle;
+  class text_element_color;
 
-  virtual ~text_element (void) = default;
-
-  virtual void accept (text_processor& p) = 0;
-
-private:
-  text_element (const text_element&);
-};
+  class text_processor;
 
-class
-OCTINTERP_API
-text_element_string : public text_element
-{
-public:
-  text_element_string (const std::string& s = "")
-    : text_element (), str (s) { }
+  class
+  OCTINTERP_API
+  text_element
+  {
+  public:
+    text_element (void) { }
 
-  ~text_element_string (void) = default;
+    virtual ~text_element (void) = default;
 
-  std::string string_value (void) const { return str; }
-
-  void accept (text_processor& p);
+    virtual void accept (text_processor& p) = 0;
 
-private:
-  std::string str;
-
-private:
-  text_element_string (const text_element_string &);
-};
+  private:
+    text_element (const text_element&);
+  };
 
-class
-OCTINTERP_API
-text_element_symbol : public text_element
-{
-public:
-  enum { invalid_code = 0xFFFFFFFFU };
+  class
+  OCTINTERP_API
+  text_element_string : public text_element
+  {
+  public:
+    text_element_string (const std::string& s = "")
+      : text_element (), str (s) { }
 
-public:
-  text_element_symbol (int sym)
-    : text_element (), symbol (sym) { }
-
-  ~text_element_symbol (void) = default;
-
-  int get_symbol (void) const { return symbol; }
+    ~text_element_string (void) = default;
 
-  uint32_t get_symbol_code (void) const;
-
-  void accept (text_processor& p);
+    std::string string_value (void) const { return str; }
 
-private:
-  int symbol;
-};
+    void accept (text_processor& p);
+
+  private:
+    std::string str;
 
-class
-OCTINTERP_API
-text_element_list
-  : public text_element, public octave::base_list<text_element *>
-{
-public:
-  text_element_list (void)
-    : text_element (), octave::base_list<text_element*> () { }
+  private:
+    text_element_string (const text_element_string &);
+  };
 
-  text_element_list (text_element *e)
-    : text_element (), octave::base_list<text_element*> ()
-  { push_back (e); }
-
-  ~text_element_list (void)
+  class
+  OCTINTERP_API
+  text_element_symbol : public text_element
   {
-    while (! empty ())
-      {
-        auto it = begin ();
-        delete (*it);
-        erase (it);
-      }
-  }
+  public:
+    enum { invalid_code = 0xFFFFFFFFU };
+
+  public:
+    text_element_symbol (int sym)
+      : text_element (), symbol (sym) { }
+
+    ~text_element_symbol (void) = default;
 
-  void accept (text_processor& p);
-};
+    int get_symbol (void) const { return symbol; }
+
+    uint32_t get_symbol_code (void) const;
 
-class
-OCTINTERP_API
-text_element_subscript : public text_element
-{
-public:
-  text_element_subscript (text_element *e)
-    : text_element (), elem (e) { }
+    void accept (text_processor& p);
+
+  private:
+    int symbol;
+  };
 
-  text_element_subscript (char c)
-    : text_element ()
-  { elem = new text_element_string (std::string (1, c)); }
-
-  ~text_element_subscript (void)
-  { delete elem; }
-
-  void accept (text_processor& p);
-
-  text_element * get_element (void) { return elem; }
+  class
+  OCTINTERP_API
+  text_element_list
+    : public text_element, public base_list<text_element *>
+  {
+  public:
+    text_element_list (void)
+      : text_element (), base_list<text_element*> () { }
 
-private:
-  text_element *elem;
-
-private:
-  text_element_subscript (void);
-};
+    text_element_list (text_element *e)
+      : text_element (), base_list<text_element*> ()
+    {
+      push_back (e);
+    }
 
-class
-OCTINTERP_API
-text_element_superscript : public text_element
-{
-public:
-  text_element_superscript (text_element *e)
-    : text_element (), elem (e) { }
+    ~text_element_list (void)
+      {
+        while (! empty ())
+          {
+            auto it = begin ();
+            delete (*it);
+            erase (it);
+          }
+      }
+
+    void accept (text_processor& p);
+  };
 
-  text_element_superscript (char c)
-    : text_element ()
-  { elem = new text_element_string (std::string (1, c)); }
-
-  ~text_element_superscript (void)
-  { delete elem; }
-
-  void accept (text_processor& p);
+  class
+  OCTINTERP_API
+  text_element_subscript : public text_element
+  {
+  public:
+    text_element_subscript (text_element *e)
+      : text_element (), elem (e) { }
 
-  text_element * get_element (void) { return elem; }
+    text_element_subscript (char c)
+      : text_element ()
+      { elem = new text_element_string (std::string (1, c)); }
+
+    ~text_element_subscript (void)
+      { delete elem; }
 
-private:
-  text_element *elem;
+    void accept (text_processor& p);
 
-private:
-  text_element_superscript (void);
-};
+    text_element * get_element (void) { return elem; }
+
+  private:
+    text_element *elem;
 
-class
-OCTINTERP_API
-text_element_combined : public text_element_list
-{
-public:
-  text_element_combined (text_element *e)
-    : text_element_list (e) { }
+  private:
+    text_element_subscript (void);
+  };
 
-  text_element_combined (text_element *e1, text_element *e2)
-    : text_element_list(e1)
-  { push_back (e2); }
+  class
+  OCTINTERP_API
+  text_element_superscript : public text_element
+  {
+  public:
+    text_element_superscript (text_element *e)
+      : text_element (), elem (e) { }
 
-  void accept (text_processor& p);
-};
+    text_element_superscript (char c)
+      : text_element ()
+      { elem = new text_element_string (std::string (1, c)); }
+
+    ~text_element_superscript (void)
+      { delete elem; }
 
-class
-OCTINTERP_API
-text_element_fontstyle : public text_element
-{
-public:
-  enum fontstyle
-  {
-    normal,
-    bold,
-    italic,
-    oblique
+    void accept (text_processor& p);
+
+    text_element * get_element (void) { return elem; }
+
+  private:
+    text_element *elem;
+
+  private:
+    text_element_superscript (void);
   };
 
-  text_element_fontstyle (fontstyle st)
-    : text_element (), style (st) { }
-
-  ~text_element_fontstyle (void) = default;
-
-  fontstyle get_fontstyle (void) const { return style; }
+  class
+  OCTINTERP_API
+  text_element_combined : public text_element_list
+  {
+  public:
+    text_element_combined (text_element *e)
+      : text_element_list (e) { }
 
-  void accept (text_processor& p);
+    text_element_combined (text_element *e1, text_element *e2)
+      : text_element_list(e1)
+      { push_back (e2); }
 
-private:
-  fontstyle style;
-
-private:
-  text_element_fontstyle (void);
-};
+    void accept (text_processor& p);
+  };
 
-class
-OCTINTERP_API
-text_element_fontname : public text_element
-{
-public:
-  text_element_fontname (const std::string& fname)
-    : text_element (), name (fname) { }
+  class
+  OCTINTERP_API
+  text_element_fontstyle : public text_element
+  {
+  public:
+    enum fontstyle
+    {
+      normal,
+      bold,
+      italic,
+      oblique
+    };
 
-  ~text_element_fontname (void) = default;
-
-  const std::string& get_fontname (void) const { return name; }
+    text_element_fontstyle (fontstyle st)
+      : text_element (), style (st) { }
 
-  void accept (text_processor& p);
-
-private:
-  std::string name;
+    ~text_element_fontstyle (void) = default;
 
-private:
-  text_element_fontname (void);
-};
+    fontstyle get_fontstyle (void) const { return style; }
+
+    void accept (text_processor& p);
 
-class
-OCTINTERP_API
-text_element_fontsize : public text_element
-{
-public:
-  text_element_fontsize (double fsize)
-    : text_element (), size (fsize) { }
+  private:
+    fontstyle style;
 
-  ~text_element_fontsize (void) = default;
-
-  double get_fontsize (void) const { return size; }
+  private:
+    text_element_fontstyle (void);
+  };
 
-  void accept (text_processor& p);
+  class
+  OCTINTERP_API
+  text_element_fontname : public text_element
+  {
+  public:
+    text_element_fontname (const std::string& fname)
+      : text_element (), name (fname) { }
 
-private:
-  double size;
+    ~text_element_fontname (void) = default;
+
+    const std::string& get_fontname (void) const { return name; }
 
-private:
-  text_element_fontsize (void);
-};
+    void accept (text_processor& p);
+
+  private:
+    std::string name;
 
-class
-OCTINTERP_API
-text_element_color : public text_element
-{
-public:
-  text_element_color (double r, double g, double b)
-    : text_element (), rgb (1, 3, 0.0)
+  private:
+    text_element_fontname (void);
+  };
+
+  class
+  OCTINTERP_API
+  text_element_fontsize : public text_element
   {
-    rgb(0) = r;
-    rgb(1) = g;
-    rgb(2) = b;
-  }
+  public:
+    text_element_fontsize (double fsize)
+      : text_element (), size (fsize) { }
+
+    ~text_element_fontsize (void) = default;
+
+    double get_fontsize (void) const { return size; }
+
+    void accept (text_processor& p);
+
+  private:
+    double size;
+
+  private:
+    text_element_fontsize (void);
+  };
 
-  text_element_color (const std::string& cname)
-    : text_element (), rgb (1, 3, 0.0)
+  class
+  OCTINTERP_API
+  text_element_color : public text_element
   {
+  public:
+    text_element_color (double r, double g, double b)
+      : text_element (), rgb (1, 3, 0.0)
+      {
+        rgb(0) = r;
+        rgb(1) = g;
+        rgb(2) = b;
+      }
+
+    text_element_color (const std::string& cname)
+      : text_element (), rgb (1, 3, 0.0)
+      {
 #define ASSIGN_COLOR(r,g,b) { rgb(0) = r; rgb(1) = g; rgb(2) = b; }
-    if (cname == "red") ASSIGN_COLOR(1, 0, 0)
-      else if (cname == "green") ASSIGN_COLOR(0, 1, 0)
+        if (cname == "red") ASSIGN_COLOR(1, 0, 0)
+        else if (cname == "green") ASSIGN_COLOR(0, 1, 0)
         else if (cname == "yellow") ASSIGN_COLOR(1, 1, 0)
-          else if (cname == "magenta") ASSIGN_COLOR(1, 0, 1)
-            else if (cname == "blue") ASSIGN_COLOR(0, 0, 1)
-              else if (cname == "black") ASSIGN_COLOR(0, 0, 0)
-                else if (cname == "white") ASSIGN_COLOR(1, 1, 1)
-                  else if (cname == "gray") ASSIGN_COLOR(.5, .5, .5)
-                    else if (cname == "darkGreen") ASSIGN_COLOR(0, .5, 0)
-                      else if (cname == "orange") ASSIGN_COLOR(1, .65, 0)
-                        else if (cname == "lightBlue") ASSIGN_COLOR(0.68, .85, .9)
+        else if (cname == "magenta") ASSIGN_COLOR(1, 0, 1)
+        else if (cname == "blue") ASSIGN_COLOR(0, 0, 1)
+        else if (cname == "black") ASSIGN_COLOR(0, 0, 0)
+        else if (cname == "white") ASSIGN_COLOR(1, 1, 1)
+        else if (cname == "gray") ASSIGN_COLOR(.5, .5, .5)
+        else if (cname == "darkGreen") ASSIGN_COLOR(0, .5, 0)
+        else if (cname == "orange") ASSIGN_COLOR(1, .65, 0)
+        else if (cname == "lightBlue") ASSIGN_COLOR(0.68, .85, .9)
 #undef ASSIGN_COLOR
-  }
-
-  ~text_element_color (void) = default;
-
-  Matrix get_color (void) { return rgb; }
-
-  void accept (text_processor& p);
-
-private:
-  Matrix rgb;
-};
+      }
 
-class
-OCTINTERP_API
-text_processor
-{
-public:
-  virtual void visit (text_element_string& e) = 0;
+    ~text_element_color (void) = default;
 
-  virtual void visit (text_element_symbol&) { }
+    Matrix get_color (void) { return rgb; }
+
+    void accept (text_processor& p);
 
-  virtual void visit (text_element_list& e)
+  private:
+    Matrix rgb;
+  };
+
+  class
+  OCTINTERP_API
+  text_processor
   {
-    for (auto& el_p : e)
-      {
-        el_p->accept (*this);
-      }
-  }
+  public:
+    virtual void visit (text_element_string& e) = 0;
 
-  virtual void visit (text_element_subscript& e)
-  { e.get_element ()->accept (*this); }
+    virtual void visit (text_element_symbol&) { }
 
-  virtual void visit (text_element_superscript& e)
-  { e.get_element ()->accept (*this); }
+    virtual void visit (text_element_list& e)
+    {
+      for (auto& el_p : e)
+        {
+          el_p->accept (*this);
+        }
+    }
 
-  virtual void visit (text_element_combined&) { }
+    virtual void visit (text_element_subscript& e)
+    { e.get_element ()->accept (*this); }
 
-  virtual void visit (text_element_fontstyle&) { }
+    virtual void visit (text_element_superscript& e)
+    { e.get_element ()->accept (*this); }
 
-  virtual void visit (text_element_fontname&) { }
+    virtual void visit (text_element_combined&) { }
 
-  virtual void visit (text_element_fontsize&) { }
+    virtual void visit (text_element_fontstyle&) { }
+
+    virtual void visit (text_element_fontname&) { }
 
-  virtual void visit (text_element_color&) { }
+    virtual void visit (text_element_fontsize&) { }
 
-  virtual void reset (void) { }
+    virtual void visit (text_element_color&) { }
 
-protected:
-  text_processor (void) { }
+    virtual void reset (void) { }
 
-  virtual ~text_processor (void) = default;
-};
+  protected:
+    text_processor (void) { }
+
+    virtual ~text_processor (void) = default;
+  };
 
 #define TEXT_ELEMENT_ACCEPT(cls)                \
   inline void                                   \
   cls::accept (text_processor& p)               \
   {                                             \
     p.visit (*this);                            \
   }
 
-TEXT_ELEMENT_ACCEPT(text_element_string)
-TEXT_ELEMENT_ACCEPT(text_element_symbol)
-TEXT_ELEMENT_ACCEPT(text_element_list)
-TEXT_ELEMENT_ACCEPT(text_element_subscript)
-TEXT_ELEMENT_ACCEPT(text_element_superscript)
-TEXT_ELEMENT_ACCEPT(text_element_combined)
-TEXT_ELEMENT_ACCEPT(text_element_fontstyle)
-TEXT_ELEMENT_ACCEPT(text_element_fontname)
-TEXT_ELEMENT_ACCEPT(text_element_fontsize)
-TEXT_ELEMENT_ACCEPT(text_element_color)
+  TEXT_ELEMENT_ACCEPT(text_element_string)
+  TEXT_ELEMENT_ACCEPT(text_element_symbol)
+  TEXT_ELEMENT_ACCEPT(text_element_list)
+  TEXT_ELEMENT_ACCEPT(text_element_subscript)
+  TEXT_ELEMENT_ACCEPT(text_element_superscript)
+  TEXT_ELEMENT_ACCEPT(text_element_combined)
+  TEXT_ELEMENT_ACCEPT(text_element_fontstyle)
+  TEXT_ELEMENT_ACCEPT(text_element_fontname)
+  TEXT_ELEMENT_ACCEPT(text_element_fontsize)
+  TEXT_ELEMENT_ACCEPT(text_element_color)
+
+  class
+  OCTINTERP_API
+  text_parser
+  {
+  public:
+    text_parser (void) { }
+
+    virtual ~text_parser (void) = default;
 
-class
-OCTINTERP_API
-text_parser
-{
-public:
-  text_parser (void) { }
+    virtual text_element * parse (const std::string& s) = 0;
+
+  public:
+    static text_element * parse (const std::string& s,
+                                 const caseless_str& interpreter);
+  };
 
-  virtual ~text_parser (void) = default;
+  class
+  OCTINTERP_API
+  text_parser_none : public text_parser
+  {
+  public:
+    text_parser_none (void) : text_parser () { }
 
-  virtual text_element * parse (const std::string& s) = 0;
+    ~text_parser_none (void) = default;
+
+    // FIXME: is it possible to use reference counting to manage the
+    // memory for the object returned by the text parser?  That would be
+    // preferable to having to know when and where to delete the object it
+    // creates...
 
-public:
-  static text_element * parse (const std::string& s,
-                               const caseless_str& interpreter);
-};
+    text_element * parse (const std::string& s)
+    {
+      return new text_element_string (s);
+    }
+  };
+
+  class
+  OCTINTERP_API
+  text_parser_tex : public text_parser
+  {
+  public:
+    text_parser_tex (void)
+      : text_parser (), scanner (nullptr), buffer_state (nullptr), result (nullptr)
+      { }
+
+    ~text_parser_tex (void)
+      { destroy_lexer (); }
+
+    text_element * parse (const std::string& s);
+
+    void * get_scanner (void) { return scanner; }
+
+    void set_parse_result (text_element *e) { result = e; }
 
-class
-OCTINTERP_API
-text_parser_none : public text_parser
-{
-public:
-  text_parser_none (void) : text_parser () { }
+    text_element * get_parse_result (void) { return result; }
+
+  private:
+    bool init_lexer (const std::string& s);
 
-  ~text_parser_none (void) = default;
+    void destroy_lexer (void);
+
+  private:
+    void *scanner;
+
+    void *buffer_state;
 
-  // FIXME: is it possible to use reference counting to manage the
-  // memory for the object returned by the text parser?  That would be
-  // preferable to having to know when and where to delete the object it
-  // creates...
+    text_element *result;
+  };
 
-  text_element * parse (const std::string& s)
+  inline text_element*
+  text_parser::parse (const std::string& s, const caseless_str& interpreter)
   {
-    return new text_element_string (s);
+    std::unique_ptr<text_parser> parser;
+
+    if (interpreter.compare ("tex"))
+      parser.reset (new text_parser_tex ());
+    else
+      parser.reset (new text_parser_none ());
+
+    return parser->parse (s);
   }
-};
-
-class
-OCTINTERP_API
-text_parser_tex : public text_parser
-{
-public:
-  text_parser_tex (void)
-    : text_parser (), scanner (nullptr), buffer_state (nullptr), result (nullptr)
-  { }
-
-  ~text_parser_tex (void)
-  { destroy_lexer (); }
-
-  text_element * parse (const std::string& s);
-
-  void * get_scanner (void) { return scanner; }
-
-  void set_parse_result (text_element *e) { result = e; }
-
-  text_element * get_parse_result (void) { return result; }
-
-private:
-  bool init_lexer (const std::string& s);
-
-  void destroy_lexer (void);
-
-private:
-  void *scanner;
-
-  void *buffer_state;
-
-  text_element *result;
-};
-
-inline text_element*
-text_parser::parse (const std::string& s, const caseless_str& interpreter)
-{
-  std::unique_ptr<text_parser> parser;
-
-  if (interpreter.compare ("tex"))
-    parser.reset (new text_parser_tex ());
-  else
-    parser.reset (new text_parser_none ());
-
-  return parser->parse (s);
 }
 
+#if defined (OCAVE_USE_DEPRECATED_FUNCTIONS)
+
+OCTAVE_DEPRECATED (5, "use 'octave::text_element' instead")
+typedef octave::text_element text_element;
+
+OCTAVE_DEPRECATED (5, "use 'octave::text_element_string' instead")
+typedef octave::text_element_string text_element_string;
+
+OCTAVE_DEPRECATED (5, "use 'octave::text_element_symbol' instead")
+typedef octave::text_element_symbol text_element_symbol;
+
+OCTAVE_DEPRECATED (5, "use 'octave::text_element_list' instead")
+typedef octave::text_element_list text_element_list;
+
+OCTAVE_DEPRECATED (5, "use 'octave::text_element_subscript' instead")
+typedef octave::text_element_subscript text_element_subscript;
+
+OCTAVE_DEPRECATED (5, "use 'octave::text_element_superscript' instead")
+typedef octave::text_element_superscript text_element_superscript;
+
+OCTAVE_DEPRECATED (5, "use 'octave::text_element_combined' instead")
+typedef octave::text_element_combined text_element_combined;
+
+OCTAVE_DEPRECATED (5, "use 'octave::text_element_fontstyle' instead")
+typedef octave::text_element_fontstyle text_element_fontstyle;
+
+OCTAVE_DEPRECATED (5, "use 'octave::text_element_fontname' instead")
+typedef octave::text_element_fontname text_element_fontname;
+
+OCTAVE_DEPRECATED (5, "use 'octave::text_element_fontsize' instead")
+typedef octave::text_element_fontsize text_element_fontsize;
+
+OCTAVE_DEPRECATED (5, "use 'octave::text_element_color' instead")
+typedef octave::text_element_color text_element_color;
+
+OCTAVE_DEPRECATED (5, "use 'octave::text_processor' instead")
+typedef octave::text_processor text_processor;
+
+OCTAVE_DEPRECATED (5, "use 'octave::text_parser' instead")
+typedef octave::text_parser text_parser;
+
+OCTAVE_DEPRECATED (5, "use 'octave::text_parser_none' instead")
+typedef octave::text_parser_none text_parser_none;
+
+OCTAVE_DEPRECATED (5, "use 'octave::text_parser_tex' instead")
+typedef octave::text_parser_tex text_parser_tex;
+
 #endif
+
+#endif
diff --git a/libinterp/corefcn/text-renderer.h b/libinterp/corefcn/text-renderer.h
--- a/libinterp/corefcn/text-renderer.h
+++ b/libinterp/corefcn/text-renderer.h
@@ -29,21 +29,20 @@ along with Octave; see the file COPYING.
 #include <list>
 #include <string>
 #include <vector>
 
 #include "caseless-str.h"
 #include "dMatrix.h"
 #include "uint8NDArray.h"
 
-#include "txt-eng.h"
-
 namespace octave
 {
   class base_text_renderer;
+  class text_element;
 
   class
   OCTINTERP_API
   text_renderer
   {
   public:
 
     text_renderer (void);
diff --git a/libinterp/corefcn/txt-eng.h b/libinterp/corefcn/txt-eng.h
--- a/libinterp/corefcn/txt-eng.h
+++ b/libinterp/corefcn/txt-eng.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2009-2018 Michael Goffioul
+Copyright (C) 2018 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software: you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 
@@ -20,435 +20,13 @@ along with Octave; see the file COPYING.
 
 */
 
 #if ! defined (octave_txt_eng_h)
 #define octave_txt_eng_h 1
 
 #include "octave-config.h"
 
-#include <memory>
-#include <string>
-
-#include "base-list.h"
-#include "caseless-str.h"
-#include "dMatrix.h"
-
-class text_element;
-class text_element_string;
-class text_element_symbol;
-class text_element_list;
-class text_element_subscript;
-class text_element_superscript;
-class text_element_combined;
-class text_element_fontname;
-class text_element_fontsize;
-class text_element_fontstyle;
-class text_element_color;
-
-class text_processor;
-
-class
-OCTINTERP_API
-text_element
-{
-public:
-  text_element (void) { }
-
-  virtual ~text_element (void) = default;
-
-  virtual void accept (text_processor& p) = 0;
-
-private:
-  text_element (const text_element&);
-};
-
-class
-OCTINTERP_API
-text_element_string : public text_element
-{
-public:
-  text_element_string (const std::string& s = "")
-    : text_element (), str (s) { }
-
-  ~text_element_string (void) = default;
-
-  std::string string_value (void) const { return str; }
-
-  void accept (text_processor& p);
-
-private:
-  std::string str;
-
-private:
-  text_element_string (const text_element_string &);
-};
-
-class
-OCTINTERP_API
-text_element_symbol : public text_element
-{
-public:
-  enum { invalid_code = 0xFFFFFFFFU };
-
-public:
-  text_element_symbol (int sym)
-    : text_element (), symbol (sym) { }
-
-  ~text_element_symbol (void) = default;
-
-  int get_symbol (void) const { return symbol; }
-
-  uint32_t get_symbol_code (void) const;
-
-  void accept (text_processor& p);
-
-private:
-  int symbol;
-};
-
-class
-OCTINTERP_API
-text_element_list
-  : public text_element, public octave::base_list<text_element *>
-{
-public:
-  text_element_list (void)
-    : text_element (), octave::base_list<text_element*> () { }
-
-  text_element_list (text_element *e)
-    : text_element (), octave::base_list<text_element*> ()
-  { push_back (e); }
-
-  ~text_element_list (void)
-  {
-    while (! empty ())
-      {
-        auto it = begin ();
-        delete (*it);
-        erase (it);
-      }
-  }
-
-  void accept (text_processor& p);
-};
-
-class
-OCTINTERP_API
-text_element_subscript : public text_element
-{
-public:
-  text_element_subscript (text_element *e)
-    : text_element (), elem (e) { }
-
-  text_element_subscript (char c)
-    : text_element ()
-  { elem = new text_element_string (std::string (1, c)); }
-
-  ~text_element_subscript (void)
-  { delete elem; }
-
-  void accept (text_processor& p);
-
-  text_element * get_element (void) { return elem; }
-
-private:
-  text_element *elem;
-
-private:
-  text_element_subscript (void);
-};
-
-class
-OCTINTERP_API
-text_element_superscript : public text_element
-{
-public:
-  text_element_superscript (text_element *e)
-    : text_element (), elem (e) { }
-
-  text_element_superscript (char c)
-    : text_element ()
-  { elem = new text_element_string (std::string (1, c)); }
-
-  ~text_element_superscript (void)
-  { delete elem; }
-
-  void accept (text_processor& p);
-
-  text_element * get_element (void) { return elem; }
-
-private:
-  text_element *elem;
-
-private:
-  text_element_superscript (void);
-};
-
-class
-OCTINTERP_API
-text_element_combined : public text_element_list
-{
-public:
-  text_element_combined (text_element *e)
-    : text_element_list (e) { }
-
-  text_element_combined (text_element *e1, text_element *e2)
-    : text_element_list(e1)
-  { push_back (e2); }
-
-  void accept (text_processor& p);
-};
-
-class
-OCTINTERP_API
-text_element_fontstyle : public text_element
-{
-public:
-  enum fontstyle
-  {
-    normal,
-    bold,
-    italic,
-    oblique
-  };
-
-  text_element_fontstyle (fontstyle st)
-    : text_element (), style (st) { }
-
-  ~text_element_fontstyle (void) = default;
-
-  fontstyle get_fontstyle (void) const { return style; }
-
-  void accept (text_processor& p);
-
-private:
-  fontstyle style;
-
-private:
-  text_element_fontstyle (void);
-};
-
-class
-OCTINTERP_API
-text_element_fontname : public text_element
-{
-public:
-  text_element_fontname (const std::string& fname)
-    : text_element (), name (fname) { }
-
-  ~text_element_fontname (void) = default;
+#warning "txt-eng.h has been deprecated; use text-engine instead"
 
-  const std::string& get_fontname (void) const { return name; }
-
-  void accept (text_processor& p);
-
-private:
-  std::string name;
-
-private:
-  text_element_fontname (void);
-};
-
-class
-OCTINTERP_API
-text_element_fontsize : public text_element
-{
-public:
-  text_element_fontsize (double fsize)
-    : text_element (), size (fsize) { }
-
-  ~text_element_fontsize (void) = default;
-
-  double get_fontsize (void) const { return size; }
-
-  void accept (text_processor& p);
-
-private:
-  double size;
-
-private:
-  text_element_fontsize (void);
-};
-
-class
-OCTINTERP_API
-text_element_color : public text_element
-{
-public:
-  text_element_color (double r, double g, double b)
-    : text_element (), rgb (1, 3, 0.0)
-  {
-    rgb(0) = r;
-    rgb(1) = g;
-    rgb(2) = b;
-  }
-
-  text_element_color (const std::string& cname)
-    : text_element (), rgb (1, 3, 0.0)
-  {
-#define ASSIGN_COLOR(r,g,b) { rgb(0) = r; rgb(1) = g; rgb(2) = b; }
-    if (cname == "red") ASSIGN_COLOR(1, 0, 0)
-      else if (cname == "green") ASSIGN_COLOR(0, 1, 0)
-        else if (cname == "yellow") ASSIGN_COLOR(1, 1, 0)
-          else if (cname == "magenta") ASSIGN_COLOR(1, 0, 1)
-            else if (cname == "blue") ASSIGN_COLOR(0, 0, 1)
-              else if (cname == "black") ASSIGN_COLOR(0, 0, 0)
-                else if (cname == "white") ASSIGN_COLOR(1, 1, 1)
-                  else if (cname == "gray") ASSIGN_COLOR(.5, .5, .5)
-                    else if (cname == "darkGreen") ASSIGN_COLOR(0, .5, 0)
-                      else if (cname == "orange") ASSIGN_COLOR(1, .65, 0)
-                        else if (cname == "lightBlue") ASSIGN_COLOR(0.68, .85, .9)
-#undef ASSIGN_COLOR
-  }
-
-  ~text_element_color (void) = default;
-
-  Matrix get_color (void) { return rgb; }
-
-  void accept (text_processor& p);
-
-private:
-  Matrix rgb;
-};
-
-class
-OCTINTERP_API
-text_processor
-{
-public:
-  virtual void visit (text_element_string& e) = 0;
-
-  virtual void visit (text_element_symbol&) { }
-
-  virtual void visit (text_element_list& e)
-  {
-    for (auto& el_p : e)
-      {
-        el_p->accept (*this);
-      }
-  }
-
-  virtual void visit (text_element_subscript& e)
-  { e.get_element ()->accept (*this); }
-
-  virtual void visit (text_element_superscript& e)
-  { e.get_element ()->accept (*this); }
-
-  virtual void visit (text_element_combined&) { }
-
-  virtual void visit (text_element_fontstyle&) { }
-
-  virtual void visit (text_element_fontname&) { }
-
-  virtual void visit (text_element_fontsize&) { }
-
-  virtual void visit (text_element_color&) { }
-
-  virtual void reset (void) { }
-
-protected:
-  text_processor (void) { }
-
-  virtual ~text_processor (void) = default;
-};
-
-#define TEXT_ELEMENT_ACCEPT(cls)                \
-  inline void                                   \
-  cls::accept (text_processor& p)               \
-  {                                             \
-    p.visit (*this);                            \
-  }
-
-TEXT_ELEMENT_ACCEPT(text_element_string)
-TEXT_ELEMENT_ACCEPT(text_element_symbol)
-TEXT_ELEMENT_ACCEPT(text_element_list)
-TEXT_ELEMENT_ACCEPT(text_element_subscript)
-TEXT_ELEMENT_ACCEPT(text_element_superscript)
-TEXT_ELEMENT_ACCEPT(text_element_combined)
-TEXT_ELEMENT_ACCEPT(text_element_fontstyle)
-TEXT_ELEMENT_ACCEPT(text_element_fontname)
-TEXT_ELEMENT_ACCEPT(text_element_fontsize)
-TEXT_ELEMENT_ACCEPT(text_element_color)
-
-class
-OCTINTERP_API
-text_parser
-{
-public:
-  text_parser (void) { }
-
-  virtual ~text_parser (void) = default;
-
-  virtual text_element * parse (const std::string& s) = 0;
-
-public:
-  static text_element * parse (const std::string& s,
-                               const caseless_str& interpreter);
-};
-
-class
-OCTINTERP_API
-text_parser_none : public text_parser
-{
-public:
-  text_parser_none (void) : text_parser () { }
-
-  ~text_parser_none (void) = default;
-
-  // FIXME: is it possible to use reference counting to manage the
-  // memory for the object returned by the text parser?  That would be
-  // preferable to having to know when and where to delete the object it
-  // creates...
-
-  text_element * parse (const std::string& s)
-  {
-    return new text_element_string (s);
-  }
-};
-
-class
-OCTINTERP_API
-text_parser_tex : public text_parser
-{
-public:
-  text_parser_tex (void)
-    : text_parser (), scanner (nullptr), buffer_state (nullptr), result (nullptr)
-  { }
-
-  ~text_parser_tex (void)
-  { destroy_lexer (); }
-
-  text_element * parse (const std::string& s);
-
-  void * get_scanner (void) { return scanner; }
-
-  void set_parse_result (text_element *e) { result = e; }
-
-  text_element * get_parse_result (void) { return result; }
-
-private:
-  bool init_lexer (const std::string& s);
-
-  void destroy_lexer (void);
-
-private:
-  void *scanner;
-
-  void *buffer_state;
-
-  text_element *result;
-};
-
-inline text_element*
-text_parser::parse (const std::string& s, const caseless_str& interpreter)
-{
-  std::unique_ptr<text_parser> parser;
-
-  if (interpreter.compare ("tex"))
-    parser.reset (new text_parser_tex ());
-  else
-    parser.reset (new text_parser_none ());
-
-  return parser->parse (s);
-}
+#include "text-engine.h"
 
 #endif
