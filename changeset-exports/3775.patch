# HG changeset patch
# User jwe
# Date 981424626 0
#      Tue Feb 06 01:57:06 2001 +0000
# Node ID 13905c3a24af43e50c5dc5d4a7dc8ab49d1613e0
# Parent  de61a7ba91f2c9442549a44c87b5904bd92fcd7f
[project @ 2001-02-06 01:56:59 by jwe]

diff --git a/ChangeLog b/ChangeLog
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,8 +1,25 @@
+2001-02-05  Mumit Khan  <khan@nanotech.wisc.edu>
+
+	* configure.in (TEMPLATE_AR, TEMPLATE_ARFLAGS): New variables.
+	* Makeconf.in (TEMPLATE_AR, TEMPLATE_ARFLAGS): Likewise.
+	
+	* configure.in (XTRA_CXXFLAGS): Use -fno-implicit templates for
+	pre-gcc3 compilers. Remove -fno-rtti and -fno-exceptions.
+	(DEPEND_FLAGS, DEPEND_EXTRA_SED_PATTERN): New macros.
+	(BLAS_LIBS): Fix test for sunperf library on Sun Solaris.
+	(CPICFLAG, CXXPICFLAG, FPICFLAG, SH_LDFLAGS, RLD_FLAG): Add Sun
+	compiler support.
+	* Makefile.in (DEPEND_FLAGS, DEPEND_EXTRA_SED_PATTERN): New
+	variables.
+	(%.d : %.cc): Use.
+	(%.d : %.c): Likewise.
+	* acconfig.h (CXX_ISO_COMPLIANT_LIBRARY): Add #undef.
+
 2001-01-31  Mumit Khan  <khan@nanotech.wisc.edu>
 
 	* Makeconf.in (%.d : %.cc): Strip the directory portion of the
 	target.
 	(%.d : %.c): Likewise.
 
 	* aclocal.m4 (OCTAVE_CXX_ISO_COMPLIANT_LIBRARY): New macro.
 	* configure.in: Use it.
diff --git a/Makeconf.in b/Makeconf.in
--- a/Makeconf.in
+++ b/Makeconf.in
@@ -28,16 +28,19 @@ LEXLIB = @LEXLIB@
 YACC = @YACC@
 YFLAGS = -dv
 
 GPERF = @GPERF@
 
 AR = @AR@
 ARFLAGS = @ARFLAGS@ 
 
+TEMPLATE_AR = @TEMPLATE_AR@
+TEMPLATE_ARFLAGS = @TEMPLATE_ARFLAGS@
+
 RANLIB = @RANLIB@
 
 LN_S = @LN_S@
 
 RUNTEST = @RUNTEST@
 
 TEXI2DVI = $(top_srcdir)/texi2dvi
 
@@ -104,16 +107,19 @@ UGLY_DEFS = @UGLY_DEFS@
 CC = @CC@
 CC_VERSION = @CC_VERSION@
 CFLAGS = @CFLAGS@
 CPICFLAG = @CPICFLAG@
 XTRA_CFLAGS = @XTRA_CFLAGS@
 ALL_CFLAGS = $(INCFLAGS) $(DEFS) $(XTRA_CFLAGS) $(CFLAGS)
 BUG_CFLAGS = $(DEFS) $(XTRA_CFLAGS) $(CFLAGS)
 
+DEPEND_FLAGS = @DEPEND_FLAGS@
+DEPEND_EXTRA_SED_PATTERN = @DEPEND_EXTRA_SED_PATTERN@
+
 CXX = @CXX@
 CXX_VERSION = @CXX_VERSION@
 CXXCPP = @CXXCPP@
 CXXFLAGS = @CXXFLAGS@
 CXXPICFLAG = @CXXPICFLAG@
 XTRA_CXXFLAGS = @XTRA_CXXFLAGS@
 ALL_CXXFLAGS = $(INCFLAGS) $(DEFS) $(XTRA_CXXFLAGS) $(CXXFLAGS)
 UGLY_ALL_CXXFLAGS = $(INCFLAGS) $(UGLY_DEFS) $(XTRA_CXXFLAGS) $(CXXFLAGS)
@@ -295,28 +301,32 @@ pic/%.o : %.c
 pic/%.o : %.cc
 	$(CXX) -c $(CPPFLAGS) $(CXXPICFLAG) $(ALL_CXXFLAGS) $< -o $@
 
 # Here is a rule for generating dependencies for .cc files:
 
 %.d : %.cc
 	@echo making $@ from $<
 	@rm -f $@
-	@$(CXX) -M $(CPPFLAGS) $(ALL_CXXFLAGS) $< | \
-	  sed -e 's,^[^:]*/\(.*\.o\):,\1:,' \
+	@$(CXX) $(DEPEND_FLAGS) $(CPPFLAGS) $(ALL_CXXFLAGS) $< | \
+	  sed \
+              $(DEPEND_EXTRA_SED_PATTERN) \
+	      -e 's,^[^:]*/\(.*\.o\):,\1:,' \
 	      -e 's,$*\.o,pic/& & $@,g' > $@.tmp
 	@mv $@.tmp $@
 
 # And one for .c files.too:
 
 %.d : %.c
 	@echo making $@ from $<
 	@rm -f $@
-	@$(CC) -M $(CPPFLAGS) $(ALL_CFLAGS) $< | \
-	  sed -e 's,^[^:]*/\(.*\.o\):,\1:,' \
+	@$(CC) $(DEPEND_FLAGS) $(CPPFLAGS) $(ALL_CFLAGS) $< | \
+	  sed \
+              $(DEPEND_EXTRA_SED_PATTERN) \
+	      -e 's,^[^:]*/\(.*\.o\):,\1:,' \
 	      -e 's,$*\.o,pic/& & $@,g' > $@.tmp
 	@mv $@.tmp $@
 
 define do-subdir-for-command
 echo making $@ in $d; cd $d; $(MAKE) $@; cd ..;
 endef
 
 define subdir-for-command
diff --git a/acconfig.h b/acconfig.h
--- a/acconfig.h
+++ b/acconfig.h
@@ -9,16 +9,19 @@
 /* Define if your version of GNU libc has buggy inline assembly code
    for math functions like exp.  */
 #undef __NO_MATH_INLINES
 
 /* Define if you want bounds checking on element references for
    internal array and matrix classes. */
 #undef BOUNDS_CHECKING
 
+/* Define if your C++ runtime library is ISO compliant. */
+#undef CXX_ISO_COMPLIANT_LIBRARY
+
 /* Define if your compiler supports `<>' stuff for template friends. */
 #undef CXX_NEW_FRIEND_TEMPLATE_DECL
 
 /* Define if your compiler prepends underscores to external names. */
 #undef CXX_PREPENDS_UNDERSCORE
 
 /* Define if your math.h declares struct exception for matherr() */
 #undef EXCEPTION_IN_MATH
diff --git a/configure.in b/configure.in
--- a/configure.in
+++ b/configure.in
@@ -16,17 +16,17 @@ dnl Copyright (C) 1996, 1997 John W. Eat
 ### FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ### for more details.
 ### 
 ### You should have received a copy of the GNU General Public License
 ### along with Octave; see the file COPYING.  If not, write to the Free
 ### Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ### 02111-1307, USA. 
 
-AC_REVISION($Revision: 1.338 $)
+AC_REVISION($Revision: 1.339 $)
 AC_PREREQ(2.9)
 AC_INIT(src/octave.cc)
 AC_CONFIG_HEADER(config.h)
 
 AC_DEFINE(OCTAVE_SOURCE, 1)
 
 OCTAVE_HOST_TYPE
 
@@ -179,22 +179,34 @@ EXTERN_CXXFLAGS="$CXXFLAGS"
 AC_PROG_CXX
 AC_PROG_CXXCPP
 
 ### Do special things for g++.
 
 gxx_version=`$CXX -v 2>&1 | grep "^.*g.. version" | \
   sed -e 's/^.*g.. version *//' -e 's/cygnus-//' -e 's/egcs-//'`
 
+# 
+# Auto instantiate all templates, other than those that are explicitly
+# instantiated in Octave. Octave currently instantiates all needed
+# templates for GCC-2.8.x and EGCS-1.1.x, but not for newer GNU releases
+# nor for other supported compilers.
+#
+cxx_auto_instantiate_templates=yes
 case "$gxx_version" in
 changequote(,)dnl
   1.* | 2.[0123456].* | 2.7.[01]*)
 changequote([,])dnl
     AC_MSG_ERROR([g++ version $gxx_version will not work to compile Octave])
   ;;
+changequote(,)dnl
+  2.8* | 2.9[1-6]*)
+changequote([,])dnl
+    cxx_auto_instantiate_templates=no
+  ;;
 esac
 
 CXX_VERSION=
 if test -n "$gxx_version"; then
   CXX_VERSION="$gxx_version"
 fi
 AC_SUBST(CXX_VERSION)
 
@@ -227,16 +239,34 @@ case "$gcc_version" in
 esac
 
 CC_VERSION=
 if test -n "$gcc_version"; then
   CC_VERSION="$gcc_version"
 fi
 AC_SUBST(CC_VERSION)
 
+### The flag to create dependency varies depending on the compier.
+
+# Assume GCC.
+DEPEND_FLAGS="-M"
+DEPEND_EXTRA_SED_PATTERN=""
+case "$canonical_host_type" in
+  sparc-sun-solaris2* | i386-pc-solaris2*)
+    if test "$GCC" = "yes"; then
+      true
+    else
+      DEPEND_FLAGS="-xM1"
+      DEPEND_EXTRA_SED_PATTERN="-e '/\/opt\/SUNWspro/d'"
+    fi
+  ;;
+esac
+AC_SUBST(DEPEND_FLAGS)
+AC_SUBST(DEPEND_EXTRA_SED_PATTERN)
+
 ### On Intel systems with gcc, we may need to compile with -mieee-fp to
 ### get full support for IEEE floating point.
 ###
 ### On Alpha/OSF systems, we need -mieee.
 
 ieee_fp_flag=
 case "$canonical_host_type" in
 changequote(,)dnl
@@ -267,32 +297,23 @@ changequote([,])dnl
     OCTAVE_CC_FLAG(-mminimal-toc, [
       XTRA_CFLAGS="$XTRA_CFLAGS -mminimal-toc"])
 
     OCTAVE_CXX_FLAG(-mminimal-toc, [
       XTRA_CXXFLAGS="$XTRA_CXXFLAGS -mminimal-toc"])
   ;;
 esac
 
-### Octave doesn't use run-time type identification or exceptions yet,
-### so disable them for somewhat faster and smaller code.
-
-OCTAVE_CXX_FLAG(-fno-rtti, [
-  XTRA_CXXFLAGS="$XTRA_CXXFLAGS -fno-rtti"
-  AC_MSG_RESULT([adding -fno-rtti to XTRA_CXXFLAGS])])
+### We do our own template instantiation for specific compilers.
 
-OCTAVE_CXX_FLAG(-fno-exceptions, [
-  XTRA_CXXFLAGS="$XTRA_CXXFLAGS -fno-exceptions"
-  AC_MSG_RESULT([adding -fno-exceptions to XTRA_CXXFLAGS])])
-
-### We do our own template instantiation.
-
-OCTAVE_CXX_FLAG(-fno-implicit-templates, [
-  XTRA_CXXFLAGS="$XTRA_CXXFLAGS -fno-implicit-templates"
-  AC_MSG_RESULT([adding -fno-implicit-templates to XTRA_CXXFLAGS])])
+if test "$cxx_auto_instantiate_templates" = "no"; then
+  OCTAVE_CXX_FLAG(-fno-implicit-templates, [
+    XTRA_CXXFLAGS="$XTRA_CXXFLAGS -fno-implicit-templates"
+    AC_MSG_RESULT([adding -fno-implicit-templates to XTRA_CXXFLAGS])])
+fi
 
 AC_SUBST(XTRA_CFLAGS)
 AC_SUBST(XTRA_CXXFLAGS)
 
 ### Use -static if compiling on Alpha OSF/1 1.3 systems.
 
 case "$canonical_host_type" in
   alpha*-dec-osf1.3)
@@ -566,18 +587,21 @@ fi
 if test "x$BLAS_LIBS" = x; then
   # BLAS in Alpha DXML library? (now called CXML, see above)
   AC_CHECK_LIB(dxml, $dgemm_func, BLAS_LIBS="-ldxml", , $FLIBS)
 fi
 
 if test "x$BLAS_LIBS" = x; then
   # Check for BLAS in Sun Performance library:
   AC_CHECK_LIB(sunmath, acosp, BLAS_LIBS="-lsunmath")
-  AC_CHECK_LIB(sunperf, $dgemm_func, BLAS_LIBS="-xlic_lib=sunperf $BLAS_LIBS",
-               , $BLAS_LIBS)
+  # Don't use AC_CHECK_LIB here.
+  saved_LIBS="$LIBS"
+  LIBS="$LIBS $BLAS_LIBS -xlic_lib=sunperf"
+  AC_CHECK_FUNC($dgemm_func, BLAS_LIBS="-xlic_lib=sunperf $BLAS_LIBS",)
+  LIBS="$saved_LIBS"
 fi
 
 if test "x$BLAS_LIBS" = x; then
   # Check for BLAS in SCSL and SGIMATH libraries (prefer SCSL):
   AC_CHECK_LIB(scs, $dgemm_func,
                BLAS_LIBS="-lscs", 
 	       AC_CHECK_LIB(complib.sgimath, $dgemm_func,
 			    BLAS_LIBS="-lcomplib.sgimath", , $FLIBS), $FLIBS)
@@ -687,16 +711,18 @@ DLFCN_DIR=
 CPICFLAG=-fPIC
 CXXPICFLAG=-fPIC
 FPICFLAG=-fPIC
 SHLEXT=so
 SH_LD="$CXX"
 SH_LDFLAGS=-shared
 SONAME_FLAGS=
 RLD_FLAG=
+TEMPLATE_AR="$AR"
+TEMPLATE_ARFLAGS="$ARFLAGS"
 case "$canonical_host_type" in
   *-*-386bsd* | *-*-openbsd* | *-*-netbsd* | *-*-freebsd*)
     SH_LD=ld
     SH_LDFLAGS=-Bshareable
   ;;
   alpha*-dec-osf*)
     CPICFLAG=
     CXXPICFLAG=
@@ -747,19 +773,38 @@ changequote([,])dnl
     SH_LD=ld
     SH_LDFLAGS="-assert nodefinitions"
     RLD_FLAG='-L$(octlibdir)'
   ;;
   sparc-sun-solaris2* | i386-pc-solaris2*)
     if test "$octave_cv_f77_is_g77" = yes; then
       FPICFLAG=-fPIC
     else
-      FPICFLAG=-PIC
+      FPICFLAG=-KPIC
+    fi
+    if test "$GCC" = yes; then
+      CPICFLAG=-fPIC
+    else
+      CPICFLAG=-KPIC
     fi
-    RLD_FLAG='-Xlinker -R -Xlinker $(octlibdir)'
+    if test "$GXX" = yes; then
+      CXXPICFLAG=-fPIC
+      SH_LDFLAGS=-shared
+    else
+      CXXPICFLAG=-KPIC
+      SH_LDFLAGS=-G
+    fi
+    RLD_FLAG='-R $(octlibdir)'
+    # Template closures in archive libraries need a different mechanism.
+    if test "$GXX" = "yes"; then
+      true
+    else
+      TEMPLATE_AR="$CXX"
+      TEMPLATE_ARFLAGS="-xar -o"
+    fi
   ;;
 esac
 
 if $use_rpath; then
   true
 else
   RLD_FLAG=
 fi
@@ -768,25 +813,29 @@ AC_MSG_RESULT([defining FPICFLAG to be $
 AC_MSG_RESULT([defining CPICFLAG to be $CPICFLAG])
 AC_MSG_RESULT([defining CXXPICFLAG to be $CXXPICFLAG])
 AC_MSG_RESULT([defining SHLEXT to be $SHLEXT])
 AC_MSG_RESULT([defining DLFCN_DIR to be $DLFCN_DIR])
 AC_MSG_RESULT([defining SH_LD to be $SH_LD])
 AC_MSG_RESULT([defining SH_LDFLAGS to be $SH_LDFLAGS])
 AC_MSG_RESULT([defining SONAME_FLAGS to be $SONAME_FLAGS])
 AC_MSG_RESULT([defining RLD_FLAG to be $RLD_FLAG])
+AC_MSG_RESULT([defining TEMPLATE_AR to be $TEMPLATE_AR])
+AC_MSG_RESULT([defining TEMPLATE_ARFLAGS to be $TEMPLATE_ARFLAGS])
 AC_SUBST(FPICFLAG)
 AC_SUBST(CPICFLAG)
 AC_SUBST(CXXPICFLAG)
 AC_SUBST(SHLEXT)
 AC_SUBST(DLFCN_DIR)
 AC_SUBST(SH_LD)
 AC_SUBST(SH_LDFLAGS)
 AC_SUBST(SONAME_FLAGS)
 AC_SUBST(RLD_FLAG)
+AC_SUBST(TEMPLATE_AR)
+AC_SUBST(TEMPLATE_ARFLAGS)
 
 ### Allow compilation of smaller kernel.  This only works if some form
 ### of dynamic linking is also supported and used.
 
 AC_ARG_ENABLE(lite-kernel,
   [  --enable-lite-kernel    compile smaller kernel (requires dynamic linking)],
   [if test "$enableval" = no; then OCTAVE_LITE=false;
    else OCTAVE_LITE=true; fi],
diff --git a/liboctave/ArrayN-idx.h b/liboctave/ArrayN-idx.h
--- a/liboctave/ArrayN-idx.h
+++ b/liboctave/ArrayN-idx.h
@@ -72,34 +72,34 @@ template <class T>
 ArrayN<T>
 ArrayN<T>::index (idx_vector& idx) const
 {
   ArrayN<T> retval;
   assert (0);
   return retval;
 }
 
-static Array<int>
+static inline Array<int>
 freeze (Array<idx_vector>& idx, const Array<int>& dimensions)
 {
   Array<int> retval;
 
   int n = idx.length ();
 
   assert (n == dimensions.length ());
 
   retval.resize (n);
 
   for (int i = 0; i < n; i++)
     retval(i) = idx(i).freeze (dimensions(i), "XXX FIXME XXX");
 
   return retval;
 }
 
-static bool
+static inline bool
 all_ok (const Array<idx_vector>& idx)
 {
   bool retval = true;
 
   int n = idx.length ();
 
   for (int i = 0; i < n; i++)
     {
@@ -108,17 +108,17 @@ all_ok (const Array<idx_vector>& idx)
 	  retval = false;
 	  break;
 	}
     }
 
   return retval;
 }
 
-static bool
+static inline bool
 any_orig_empty (const Array<idx_vector>& idx)
 {
   bool retval = false;
 
   int n = idx.length ();
 
   for (int i = 0; i < n; i++)
     {
@@ -127,17 +127,17 @@ any_orig_empty (const Array<idx_vector>&
 	  retval = true;
 	  break;
 	}
     }
 
   return retval;
 }
 
-static bool
+static inline bool
 any_zero_len (const Array<int>& frozen_lengths)
 {
   bool retval = false;
 
   int n = frozen_lengths.length ();
 
   for (int i = 0; i < n; i++)
     {
@@ -146,26 +146,26 @@ any_zero_len (const Array<int>& frozen_l
 	  retval = true;
 	  break;
 	}
     }
 
   return retval;
 }
 
-static Array<int>
+static inline Array<int>
 get_zero_len_size (const Array<int>& frozen_lengths,
 		   const Array<int>& dimensions)
 {
   Array<int> retval;
   assert (0);
   return retval;
 }
 
-static bool
+static inline bool
 all_colon_equiv (const Array<idx_vector>& idx,
 		 const Array<int>& frozen_lengths)
 {
   bool retval = true;
 
   int idx_n = idx.length ();
 
   int n = frozen_lengths.length ();
@@ -194,40 +194,40 @@ get_elt_idx (const Array<idx_vector>& id
   for (int i = 0; i < n; i++)
     retval(i) = idx(result_idx(i));
 
   return retval;
 }
 
 template <class T>
 ArrayN<T>
-ArrayN<T>::index (Array<idx_vector>& idx) const
+ArrayN<T>::index (Array<idx_vector>& arr_idx) const
 {
   ArrayN<T> retval;
 
   int n_dims = dimensions.length ();
 
-  Array<int> frozen_lengths = freeze (idx, dimensions);
+  Array<int> frozen_lengths = freeze (arr_idx, dimensions);
 
   if (frozen_lengths.length () == n_dims)
     {
-      if (all_ok (idx))
+      if (all_ok (arr_idx))
 	{
-	  if (any_orig_empty (idx))
+	  if (any_orig_empty (arr_idx))
 	    {
 	      retval.resize (frozen_lengths);
 	    }
 	  else if (any_zero_len (frozen_lengths))
 	    {
 	      Array<int> new_size = get_zero_len_size (frozen_lengths,
 						       dimensions);
 
 	      retval.resize (new_size);
 	    }
-	  else if (all_colon_equiv (idx, frozen_lengths))
+	  else if (all_colon_equiv (arr_idx, frozen_lengths))
 	    {
 	      retval = *this;
 	    }
 	  else
 	    {
 #if 0
 	      retval.resize (frozen_lengths);
 
diff --git a/liboctave/ArrayN.cc b/liboctave/ArrayN.cc
--- a/liboctave/ArrayN.cc
+++ b/liboctave/ArrayN.cc
@@ -41,42 +41,42 @@ Software Foundation, 59 Temple Place - S
 #endif
 
 #include "lo-error.h"
 
 // N-dimensional array class.
 
 template <class T>
 int
-ArrayN<T>::compute_index (const Array<int>& idx) const
+ArrayN<T>::compute_index (const Array<int>& arr_idx) const
 {
   int retval = -1;
 
   int n = dimensions.length ();
 
-  if (n > 0 && n == idx.length ())
+  if (n > 0 && n == arr_idx.length ())
     {
-      retval = idx(--n);
+      retval = arr_idx(--n);
 
       while (--n >= 0)
 	{
 	  retval *= dimensions(n);
-	  retval += idx(n);
+	  retval += arr_idx(n);
 	}
     }
   else
     (*current_liboctave_error_handler)
-      ("ArrayN<T>::compute_index: invalid indexing operation");
+      ("ArrayN<T>::compute_index: invalid arr_idxing operation");
 
   return retval;
 }
 
 template <class T>
 int
-ArrayN<T>::get_size (const Array<int>& idx)
+ArrayN<T>::get_size (const Array<int>& arr_idx)
 {
   // XXX KLUGE XXX
 
   // If an allocation of an array with r * c elements of type T
   // would cause an overflow in the allocator when computing the
   // size of the allocation, then return a value which, although
   // not equivalent to the actual request, should be too large for
   // most current hardware, but not so large to cause the
@@ -92,112 +92,112 @@ ArrayN<T>::get_size (const Array<int>& i
 
   // This value should be an integer.  If we return this value and
   // things work the way we expect, we should be paying a visit to
   // new_handler in no time flat.
   static int max_items = static_cast<int> (ldexp (dl, nl));
 
   int retval = max_items;
 
-  int n = idx.length ();
+  int n = arr_idx.length ();
 
   int nt = 0;
   double dt = 1;
 
   for (int i = 0; i < n; i++)
     {
-      int nidx;
-      double didx = frexp (static_cast<double> (idx(i)), &nidx);
+      int narr_idx;
+      double darr_idx = frexp (static_cast<double> (arr_idx(i)), &narr_idx);
 
-      nt += nidx;
-      dt *= didx;
+      nt += narr_idx;
+      dt *= darr_idx;
     }
 
   if (dt <= 0.5)
     {
       nt--;
       dt *= 2;
 
       if (dt <= 0.5)
 	nt--;
     }
 
   if (nt < nl || (nt == nl && dt < dl))
     {
       retval = 1;
 
       for (int i = 0; i < n; i++)
-	retval *= idx(i);
+	retval *= arr_idx(i);
     }
 
   return retval;
 }
 
 template <class T>
 T
-ArrayN<T>::range_error (const char *fcn, const Array<int>& idx) const
+ArrayN<T>::range_error (const char *fcn, const Array<int>& arr_idx) const
 {
   // XXX FIXME XXX -- report index values too!
 
   (*current_liboctave_error_handler) ("range error");
 
   return T ();
 }
 
 template <class T>
 T&
-ArrayN<T>::range_error (const char *fcn, const Array<int>& idx)
+ArrayN<T>::range_error (const char *fcn, const Array<int>& arr_idx)
 {
   // XXX FIXME XXX -- report index values too!
 
   (*current_liboctave_error_handler) ("range error");
 
   static T foo;
   return foo;
 }
 
 static inline bool
-index_in_bounds (const Array<int>& idx, const Array<int>& dimensions)
+index_in_bounds (const Array<int>& arr_idx, const Array<int>& dimensions)
 {
   bool retval = true;
 
-  int n = idx.length ();
+  int n = arr_idx.length ();
 
   if (n == dimensions.length ())
     {
       for (int i = 0; i < n; i++)
 	{
-	  if (idx(i) < 0 || idx(i) >= dimensions (i))
+	  if (arr_idx(i) < 0 || arr_idx(i) >= dimensions (i))
 	    {
 	      retval = false;
 	      break;
 	    }
 	}
     }
   else
     retval = false;
 
   return retval;
 }
 
 static inline void
-increment_index (Array<int>& idx, const Array<int>& dimensions)
+increment_index (Array<int>& arr_idx, const Array<int>& dimensions)
 {
-  idx(0)++;
+  arr_idx(0)++;
 
-  int n = idx.length () - 1;
+  int n = arr_idx.length () - 1;
 
   for (int i = 0; i < n; i++)
     {
-      if (idx(i) < dimensions(i))
+      if (arr_idx(i) < dimensions(i))
 	break;
       else
 	{
-	  idx(i) = 0;
-	  idx(i+1)++;
+	  arr_idx(i) = 0;
+	  arr_idx(i+1)++;
 	}
     }
 }
 
 template <class T>
 void
 ArrayN<T>::resize (const Array<int>& dims)
 {
@@ -233,24 +233,24 @@ ArrayN<T>::resize (const Array<int>& dim
   rep = new Array<T>::ArrayRep (get_size (dims));
 
   Array<int> old_dimensions = dimensions;
 
   int old_len = length ();
 
   dimensions = dims;
 
-  Array<int> idx (dimensions.length (), 0);
+  Array<int> arr_idx (dimensions.length (), 0);
 
   for (int i = 0; i < old_len; i++)
     {
-      if (index_in_bounds (idx, dimensions))
-	xelem (idx) = old_data[i];
+      if (index_in_bounds (arr_idx, dimensions))
+	xelem (arr_idx) = old_data[i];
 
-      increment_index (idx, dimensions);
+      increment_index (arr_idx, dimensions);
     }
 
   if (--old_rep->count <= 0)
     delete old_rep;
 }
 
 template <class T>
 void
@@ -290,46 +290,46 @@ ArrayN<T>::resize (const Array<int>& dim
   rep = new Array<T>::ArrayRep (len);
 
   Array<int> old_dimensions = dimensions;
 
   int old_len = length ();
 
   dimensions = dims;
 
-  Array<int> idx (dimensions.length (), 0);
+  Array<int> arr_idx (dimensions.length (), 0);
 
   for (int i = 0; i < len; i++)
     rep->elem (i) = val;
 
   for (int i = 0; i < old_len; i++)
     {
-      if (index_in_bounds (idx, dimensions))
-	xelem (idx) = old_data[i];
+      if (index_in_bounds (arr_idx, dimensions))
+	xelem (arr_idx) = old_data[i];
 
-      increment_index (idx, dimensions);
+      increment_index (arr_idx, dimensions);
     }
 
   if (--old_rep->count <= 0)
     delete old_rep;
 }
 
 template <class T>
 ArrayN<T>&
-ArrayN<T>::insert (const ArrayN<T>& a, const Array<int>& idx)
+ArrayN<T>::insert (const ArrayN<T>& a, const Array<int>& arr_idx)
 {
-  int n = idx.length ();
+  int n = arr_idx.length ();
 
   if (n == dimensions.length ())
     {
       Array<int> a_dims = a.dims ();
 
       for (int i = 0; i < n; i++)
 	{
-	  if (idx(i) < 0 || idx(i) + a_dims(i) > dimensions(i))
+	  if (arr_idx(i) < 0 || arr_idx(i) + a_dims(i) > dimensions(i))
 	    {
 	      (*current_liboctave_error_handler)
 		("ArrayN<T>::insert: range error for insert");
 	      return *this;
 	    }
 	}
 
 #if 0
diff --git a/liboctave/ChangeLog b/liboctave/ChangeLog
--- a/liboctave/ChangeLog
+++ b/liboctave/ChangeLog
@@ -1,8 +1,29 @@
+2001-02-05  Mumit Khan  <khan@nanotech.wisc.edu>
+
+	* Makefile.in (TEMPLATE_AR, TEMPLATE_ARFLAGS): Use to create
+	archive libraries containing templates.
+
+	* ArrayN-idx.h (freeze, all_ok, any_orig_empty, any_zero_len,
+	get_zero_len_size, all_colon_equiv): Inline. 
+	(ArrayN<T>::index): Rename idx to arr_idx.
+	* ArrayN.cc (ArrayN<T>::index, ArrayN<T>::compute_index, 
+	ArrayN<T>::get_size, ArrayN<T>::range_error, ArrayN<T>::range_error,
+	increment_index, ArrayN<T>::resize, ArrayN<T>::insert): Likewise.
+
+2001-02-05  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* lo-mappers.h, lo-mappers.cc (tan (const Complex&),
+	log10 (const Complex&)): Delete.
+
+	* oct-cmplx.h: Define forwarding functions for real, imag, abs,
+	arg, norm, conj, polar, cos, cosh, exp, log, log10, pow, sin,
+	sinh, sqrt, tan, and tanh.
+
 2001-01-31  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* file-ops.cc, help.cc, load-save.cc, pr-output.cc, utils.cc:
 	Add std:: namespace qualifier as needed.
 
 	* mx-inlines.cc: Rename all functions with mx_inline_ prefix.
 	Change all uses to match.
 
diff --git a/liboctave/Makefile.in b/liboctave/Makefile.in
--- a/liboctave/Makefile.in
+++ b/liboctave/Makefile.in
@@ -158,17 +158,17 @@ else
   else
     libraries:
   endif
 endif
 .PHONY: libraries
 
 liboctave.$(LIBEXT): $(OBJECTS)
 	rm -f $@
-	$(AR) $(ARFLAGS) $@ $^
+	$(TEMPLATE_AR) $(TEMPLATE_ARFLAGS) $@ $^
 	$(RANLIB) $@
 
 liboctave.$(SHLEXT): liboctave.$(SHLEXT_VER)
 	rm -f $@
 	$(LN_S) $< $@
 
 liboctave.$(SHLEXT_VER): $(PICOBJ)
 	rm -f $@
diff --git a/liboctave/lo-mappers.cc b/liboctave/lo-mappers.cc
--- a/liboctave/lo-mappers.cc
+++ b/liboctave/lo-mappers.cc
@@ -252,40 +252,28 @@ fix (const Complex& x)
 
 Complex
 floor (const Complex& x)
 {
   return Complex (floor (real (x)), floor (imag (x)));
 }
 
 Complex
-log10 (const Complex& x)
-{
-  return M_LOG10E * log (x);
-}
-
-Complex
 round (const Complex& x)
 {
   return Complex (D_NINT (real (x)), D_NINT (imag (x)));
 }
 
 Complex
 signum (const Complex& x)
 {
   return x / abs (x);
 }
 
 Complex
-tan (const Complex& x)
-{
-  return sin (x) / cos (x);
-}
-
-Complex
 tanh (const Complex& x)
 {
   return sinh (x) / cosh (x);
 }
 
 // complex -> bool mappers.
 
 bool
diff --git a/liboctave/lo-mappers.h b/liboctave/lo-mappers.h
--- a/liboctave/lo-mappers.h
+++ b/liboctave/lo-mappers.h
@@ -46,20 +46,18 @@ extern Complex acos (const Complex& x);
 extern Complex acosh (const Complex& x);
 extern Complex asin (const Complex& x);
 extern Complex asinh (const Complex& x);
 extern Complex atan (const Complex& x);
 extern Complex atanh (const Complex& x);
 extern Complex ceil (const Complex& x);
 extern Complex fix (const Complex& x);
 extern Complex floor (const Complex& x);
-extern Complex log10 (const Complex& x);
 extern Complex round (const Complex& x);
 extern Complex signum (const Complex& x);
-extern Complex tan (const Complex& x);
 extern Complex tanh (const Complex& x);
 
 extern bool xisnan (const Complex& x);
 extern bool xfinite (const Complex& x);
 extern bool xisinf (const Complex& x);
 
 extern Complex xmin (const Complex& x, const Complex& y);
 extern Complex xmax (const Complex& x, const Complex& y);
diff --git a/liboctave/oct-cmplx.h b/liboctave/oct-cmplx.h
--- a/liboctave/oct-cmplx.h
+++ b/liboctave/oct-cmplx.h
@@ -18,19 +18,151 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 
 */
 
 #if !defined (octave_oct_cmplx_h)
 #define octave_oct_cmplx_h 1
 
+// By using this file instead of <complex>, we can easily avoid buggy
+// implementations of the standard complex data type (if needed).
+
 #include <complex>
 
 typedef std::complex<double> Complex;
 
+#if defined (CXX_ISO_COMPLIANT_LIBRARY)
+
+// If namespaces don't work, we will end up with some infinite looping.
+
+inline double
+real (const Complex& z)
+{
+  return std::real (z);
+}
+
+inline double
+imag (const Complex& z)
+{
+  return std::imag (z);
+}
+
+inline double
+abs (const Complex& z)
+{
+  return std::abs (z);
+}
+
+inline double
+arg (const Complex& z)
+{
+  return std::arg (z);
+}
+
+inline double
+norm (const Complex& z)
+{
+  return std::norm (z);
+}
+
+inline Complex
+conj (const Complex& z)
+{
+  return std::conj (z);
+}
+
+inline Complex
+polar (const double& x, const double& y);
+
+inline Complex
+cos (const Complex& z)
+{
+  return std::cos (z);
+}
+
+inline Complex
+cosh (const Complex& z)
+{
+  return std::cosh (z);
+}
+
+inline Complex
+exp (const Complex& z)
+{
+  return std::exp (z);
+}
+
+inline Complex
+log (const Complex& z)
+{
+  return std::log (z);
+}
+
+inline Complex
+log10 (const Complex& z)
+{
+  return std::log10 (z);
+}
+
+inline Complex
+pow (const Complex& z, int n)
+{
+  return std::pow (z, n);
+}
+
+inline Complex
+pow (const Complex& z, const double& x)
+{
+  return std::pow (z, x);
+}
+
+inline Complex
+pow (const Complex& z1, const Complex& z2)
+{
+  return std::pow (z1, z2);
+}
+
+inline Complex
+pow (const double& x, const Complex& z)
+{
+  return std::pow (x, z);
+}
+
+inline Complex
+sin (const Complex& z)
+{
+  return std::sin (z);
+}
+
+inline Complex
+sinh (const Complex& z)
+{
+  return std::sinh (z);
+}
+
+inline Complex
+sqrt (const Complex& z)
+{
+  return std::sqrt (z);
+}
+
+inline Complex
+tan (const Complex& z)
+{
+  return std::tan (z);
+}
+
+inline Complex
+tanh (const Complex& z)
+{
+  return std::tanh (z);
+}
+
+#endif
+
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/scripts/ChangeLog b/scripts/ChangeLog
--- a/scripts/ChangeLog
+++ b/scripts/ChangeLog
@@ -1,8 +1,12 @@
+2001-02-05  Ondrej Popp <ondrej@geocities.com>
+
+	* control/system/c2d.m: Add missing endif.
+
 2000-12-15  Teemu Ikonen  <tpikonen@pcu.helsinki.fi>
 
 	* strings/index.m: Return 0 if either string is empty.
 
 2000-12-15  Ben Sapp  <bsapp@lanl.gov>
 
 	* control/system/c2d.m: Allow option of matched pole/zero
 	equivalent for conversion.  
diff --git a/scripts/control/system/c2d.m b/scripts/control/system/c2d.m
--- a/scripts/control/system/c2d.m
+++ b/scripts/control/system/c2d.m
@@ -171,16 +171,17 @@ function dsys = c2d (sys, opt, T)
       A = (IT+a)/(IT-a);
       iab = (IT-a)\b;
       tk=2/sqrt(T);
       B = tk*iab;
       C = tk*(c/(IT-a));
       D = d + (c*iab);
       stnamed = strappend(stname,"_d");
       dsys = ss2sys(A,B,C,D,T,0,rows(A),stnamed,inname,outname);
+     endif
    elseif(strcmp(opt,"matched"))
      if(is_digital(sys))
        error("c2d: system is already digital");
      elseif((length(sys.inname) != 1) || (length(sys.outname) != 1))
        error("c2d: system in not single input, single output");
      else
        sys = sysupdate(sys,"zp");
        p = exp(sys.pol*T);
diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,8 +1,66 @@
+2001-02-05  Mumit Khan  <khan@nanotech.wisc.edu>
+
+	* oct-stream.cc (octave_scan): Implement, and specialize for
+	char*. Delete the old template instantiations.
+	(BEGIN_S_CONVERSION): Use strings instead of ostrstreambuf.
+	(octave_base_stream::do_scanf): Pass correct parameter to
+	do_scan_conv.
+
+	* Makefile.in (TEMPLATE_AR, TEMPLATE_ARFLAGS): Use to create
+	archive libraries containing templates.
+
+	* c-file-ptr-stream.h: Include <fstream>. Use <cstdio> instead of
+	<stdio.h>
+	(c_file_ptr_buf::int_type): Compat typedef for non-ISO libstdc++.
+	(c_file_ptr_buf::{overflow, underflow, uflow, pbackfail): Use.
+	(c_file_ptr_buf::c_file_ptr_buf): Handle various compilers.
+	(c_file_ptr_buf::file_number): New member function.
+	(c_file_ptr_buf::fd): New private data.
+	(i_c_file_ptr_stream::i_c_file_ptr_stream): Initialize stream
+	correctly.
+	(o_c_file_ptr_stream::o_c_file_ptr_stream): Likewise.
+	* c-file-ptr-stream.cc 
+	(c_file_ptr_buf::{overflow, underflow, uflow, pbackfail): Add
+	ISO-compliant EOF handling.
+	* oct-stream.cc (octave_base_stream::file_number): Use 
+	c_file_ptr_buf::file_number to get underlying file descriptor.
+
+	* comment-list.cc: Add missing class qualifier.
+
+	* file-io.cc, load-save.cc, mappers.cc, oct-fstrm.cc, oct-fstrm.h,
+	oct-iostrm.cc, oct-iostrm.h, oct-stdstrm.cc, oct-stdstrm.h,
+	oct-stream.cc, oct-stream.h, oct-strstrm.cc, oct-strstrm.h,
+	ov-base-nd-array.cc, ov-base-scalar.h, ov-complex.cc, ov-cx-mat.cc,
+	pager.cc, pr-output.cc, procstream.h, pt-bp.h, utils.cc:
+	Add std:: namespace qualifier as needed, and replace
+	deprecated or invalid libstdc++-v2 names with standard ones
+	where appropriate.
+
+	* DLD-FUNCTIONS/minmax.cc: Fix docstring.
+
+	* oct-fstrm.cc (octave_fstream::octave_fstream): Maintain fix for
+	libstdc++-v2.
+
+	* oct-stdstrm.cc (octave_ostdiostream::create): Remove default
+	parameter value in definition.
+
+	* oct-stream.cc (octave_stream::mode_as_string): Don't assume 
+	std::iso::openmode is an integral quantity.
+
+	* pager.cc, procstream.h: Initialize streams correctly.
+
+	* utils.cc: Use CXX_ISO_COMPLIANT_LIBRARY guard.
+
+	* ov-base-nd-array.cc (idx_list_to_idx_array): Inline. 
+
+	* ov-base-scalar.h (octave_base_scalar::octave_base_scalar): Use
+	``const ST& s'' instead of ST to workaround gcc3 complex bug.
+
 2001-02-05  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* lex.l (next_token_is_bin_op): Remove Checks for spacing except
 	for ops that begin with +, - but are not ++, --, +=, or -=.
 
 2001-02-02  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* input.cc (get_user_input): Handle dbg_cont and dbg_step here.
diff --git a/src/DLD-FUNCTIONS/minmax.cc b/src/DLD-FUNCTIONS/minmax.cc
--- a/src/DLD-FUNCTIONS/minmax.cc
+++ b/src/DLD-FUNCTIONS/minmax.cc
@@ -551,17 +551,17 @@ min (min (@var{x}))\n\
 @noindent\n\
 returns the smallest element of @var{x}.\n\
 \n\
 For complex arguments, the magnitude of the elements are used for\n\
 comparison.\n\
 \n\
 If called with two output arguments, also returns the index of the\n\
 minimum value(s). Thus,\n\
-@example\n
+@example\n\
 [x, ix] = min ([1, 3, 0, 2, 5])\n\
 @end example\n\
 \n\
 @noindent\n\
 returns @var{x} = 0 and @var{ix} = 3.")
 {
   MINMAX_BODY (min);
 }
@@ -575,21 +575,21 @@ vector.  Thus,\n\
 @example\n\
 max (max (@var{x}))\n\
 @end example\n\
 \n\
 @noindent\n\
 returns the largest element of @var{x}.\n\
 \n\
 For complex arguments, the magnitude of the elements are used for\n\
-comparison.
+comparison.\n\
 \n\
 If called with two output arguments, also returns the index of the\n\
 maximum value(s). Thus,\n\
-@example\n
+@example\n\
 [x, ix] = max([1, 3, 5, 2, 5])\n\
 @end example\n\
 \n\
 @noindent\n\
 returns @var{x} = 5 and @var{ix} = 3.")
 {
   MINMAX_BODY (max);
 }
diff --git a/src/Makefile.in b/src/Makefile.in
--- a/src/Makefile.in
+++ b/src/Makefile.in
@@ -227,17 +227,17 @@ else
   endif
 endif
 
 libraries: $(LIBRARIES)
 .PHONY: libraries
 
 liboctinterp.$(LIBEXT): $(OBJECTS)
 	rm -f $@
-	$(AR) $(ARFLAGS) $@ $^
+	$(TEMPLATE_AR) $(TEMPLATE_ARFLAGS) $@ $^
 	$(RANLIB) $@
 
 liboctinterp.$(SHLEXT): liboctinterp.$(SHLEXT_VER)
 	rm -f $@
 	$(LN_S) $< $@
 
 liboctinterp.$(SHLEXT_VER): $(PICOBJ)
 	rm -f $@
diff --git a/src/c-file-ptr-stream.cc b/src/c-file-ptr-stream.cc
--- a/src/c-file-ptr-stream.cc
+++ b/src/c-file-ptr-stream.cc
@@ -44,44 +44,60 @@ Software Foundation, 59 Temple Place - S
 
 c_file_ptr_buf::~c_file_ptr_buf (void)
 {
   close ();
 }
 
 // XXX FIXME XXX -- I'm sure there is room for improvement here...
 
-int
-c_file_ptr_buf::overflow (int c)
+c_file_ptr_buf::int_type
+c_file_ptr_buf::overflow (int_type c)
 {
+#if defined (CXX_ISO_COMPLIANT_LIBRARY)
+  if (f)
+    return (c != traits_type::eof ()) ? fputc (c, f) : flush ();
+  else
+    return traits_type::not_eof (c);
+#else
   if (f)
     return (c != EOF) ? fputc (c, f) : flush ();
   else
     return EOF;
+#endif
 }
 
-int
+c_file_ptr_buf::int_type
 c_file_ptr_buf::underflow (void)
 {
   if (f)
     return fgetc (f);
   else
+#if defined (CXX_ISO_COMPLIANT_LIBRARY)
+    return traits_type::eof ();
+#else
     return EOF;
+#endif
 }
 
-int
+c_file_ptr_buf::int_type
 c_file_ptr_buf::uflow (void)
 {
   return underflow ();
 }
 
-int
-c_file_ptr_buf::pbackfail (int c)
+c_file_ptr_buf::int_type
+c_file_ptr_buf::pbackfail (int_type c)
 {
+#if defined (CXX_ISO_COMPLIANT_LIBRARY)
+  return (c != traits_type::eof () && f) ? ungetc (c, f) : 
+    traits_type::not_eof (c);
+#else
   return (c != EOF && f) ? ungetc (c, f) : EOF;
+#endif
 }
 
 std::streamsize
 c_file_ptr_buf::xsputn (const char* s, std::streamsize n)
 {
   if (f)
     return fwrite (s, 1, n, f);
   else
diff --git a/src/c-file-ptr-stream.h b/src/c-file-ptr-stream.h
--- a/src/c-file-ptr-stream.h
+++ b/src/c-file-ptr-stream.h
@@ -23,39 +23,53 @@ Software Foundation, 59 Temple Place - S
 #if !defined (octave_c_file_ptr_stream_h)
 #define octave_c_file_ptr_stream_h 1
 
 #ifdef __GNUG__
 #pragma interface
 #endif
 
 #include <iostream>
-#include <stdio.h>
+#include <fstream>
+#include <cstdio>
 
 class
 c_file_ptr_buf : public std::filebuf
 {
 public:
 
+#if !defined (CXX_ISO_COMPLIANT_LIBRARY)
+  typedef int int_type;
+#endif
+
   typedef int (*close_fcn) (FILE *);
 
   FILE* stdiofile (void) const { return f; }
 
   c_file_ptr_buf (FILE *f_arg, close_fcn cf_arg = ::fclose)
-    : std::filebuf (f_arg ? fileno (f_arg) : -1), f (f_arg), cf (cf_arg) { }
+    : 
+#ifdef __SUNPRO_CC
+    std::filebuf (f_arg ? fileno (f_arg) : -1),
+#else
+    std::filebuf (f_arg ? fileno (f_arg) : -1,
+                  0, std::ios::in | std::ios::out),
+#endif
+    f (f_arg), cf (cf_arg),
+    fd (f_arg ? fileno (f_arg) : -1)
+    { }
 
   ~c_file_ptr_buf (void);
 
-  int overflow (int);
+  int_type overflow (int_type);
 
-  int underflow (void);
+  int_type underflow (void);
 
-  int uflow (void);
+  int_type uflow (void);
 
-  int pbackfail (int);
+  int_type pbackfail (int_type);
 
   std::streamsize xsputn (const char*, std::streamsize);
 
   std::streamsize xsgetn (char *, std::streamsize);
 
   std::streampos seekoff (std::streamoff, std::ios::seekdir,
 			  std::ios::openmode = std::ios::in | std::ios::out);
   
@@ -63,30 +77,36 @@ public:
 			  std::ios::openmode = std::ios::in | std::ios::out);
 
   int sync (void);
 
   int flush (void);
 
   int close (void);
 
+  int file_number () const { return fd; }
+
 protected:
 
   FILE *f;
 
   close_fcn cf;
+
+private:
+
+  int fd;
 };
 
 class
 i_c_file_ptr_stream : public std::istream
 {
 public:
 
   i_c_file_ptr_stream (FILE* f, c_file_ptr_buf::close_fcn cf = ::fclose)
-    : std::istream (), buf (new c_file_ptr_buf (f, cf)) { init (buf); }
+    : std::istream (0), buf (new c_file_ptr_buf (f, cf)) { init (buf); }
 
   ~i_c_file_ptr_stream (void) { delete buf; buf = 0; }
 
   c_file_ptr_buf *rdbuf (void) { return buf; }
 
   void close (void);
 
 private:
@@ -95,17 +115,17 @@ private:
 };
 
 class
 o_c_file_ptr_stream : public std::ostream
 {
 public:
 
   o_c_file_ptr_stream (FILE* f, c_file_ptr_buf::close_fcn cf = ::fclose)
-    : std::ostream (), buf (new c_file_ptr_buf (f, cf)) { init (buf); }
+    : std::ostream (0), buf (new c_file_ptr_buf (f, cf)) { init (buf); }
 
   ~o_c_file_ptr_stream (void) { delete buf; buf = 0; }
 
   c_file_ptr_buf *rdbuf (void) { return buf; }
 
   void close (void);
 
 private:
diff --git a/src/comment-list.cc b/src/comment-list.cc
--- a/src/comment-list.cc
+++ b/src/comment-list.cc
@@ -31,17 +31,17 @@ Software Foundation, 59 Temple Place - S
 #include "lo-utils.h"
 
 #include "comment-list.h"
 #include "error.h"
 
 #include "SLList.h"
 #include "SLList.cc"
 
-template SLList<octave_comment_elt>;
+template class SLList<octave_comment_elt>;
 
 octave_comment_buffer *octave_comment_buffer::instance = 0;
 
 bool
 octave_comment_buffer::instance_ok (void)
 {
   bool retval = true;
 
diff --git a/src/file-io.cc b/src/file-io.cc
--- a/src/file-io.cc
+++ b/src/file-io.cc
@@ -313,17 +313,19 @@ do_stream_open (const std::string& name,
   int md = fopen_mode_to_ios_mode (mode);
 
   if (! error_state)
     {
       oct_mach_info::float_format flt_fmt =
 	oct_mach_info::string_to_float_format (arch);
 
       if (! error_state)
-	retval = octave_fstream::create (name, md, flt_fmt);
+	retval = octave_fstream::create (name,
+	                                 static_cast<std::ios::openmode> (md), 
+					 flt_fmt);
     }
 
   return retval;
 }
 
 static octave_stream
 do_stream_open (const octave_value& tc_name, const octave_value& tc_mode,
 		const octave_value& tc_arch, const char *fcn, int& fid)
diff --git a/src/load-save.cc b/src/load-save.cc
--- a/src/load-save.cc
+++ b/src/load-save.cc
@@ -3282,17 +3282,17 @@ lists of lists of matrices, or ...).\n\
       else
 #endif /* HAVE_HDF5 */
 	// don't insert any statements here; the "else" above has to
 	// go with the "if" below!!!!!
       if (format != LS_UNKNOWN)
 	{
 	  i++;
 
-	  unsigned mode = std::ios::in;
+	  std::ios::openmode mode = std::ios::in;
 	  if (format == LS_BINARY ||
 	      format == LS_MAT_BINARY ||
 	      format == LS_MAT5_BINARY)
 	    mode |= std::ios::binary;
 
 	  std::ifstream file (fname.c_str (), mode);
 
 	  if (file)
@@ -4744,17 +4744,17 @@ write_header (std::ostream& os, load_sav
 	char tmp = (char) float_format_to_mopt_digit (flt_fmt);
 
 	os.write (X_CAST (char *, &tmp), 1);
       }
       break;
 
     case LS_MAT5_BINARY:
       {
-	char *versionmagic;
+	char const * versionmagic;
 	TWO_BYTE_INT number = *(TWO_BYTE_INT *)"\x00\x01";
 	struct tm bdt;
 	time_t now;
 	char headertext[128];
 
 	time (&now);
 	bdt = *gmtime (&now);
 	memset (headertext, ' ', 124);
@@ -4841,17 +4841,17 @@ save_user_variables (void)
       // XXX FIXME XXX -- should choose better file name?
 
       const char *fname = "octave-core";
 
       message (0, "attempting to save variables to `%s'...", fname);
 
       load_save_format format = get_default_save_format ();
 
-      unsigned mode = std::ios::out|std::ios::trunc;
+      std::ios::openmode mode = std::ios::out|std::ios::trunc;
       if (format == LS_BINARY ||
 	  format == LS_MAT_BINARY ||
 	  format == LS_MAT5_BINARY)
 	mode |= std::ios::binary;
 
 #ifdef HAVE_HDF5
       if (format == LS_HDF5)
 	{
@@ -5083,17 +5083,17 @@ the file @file{data} in Octave's binary 
       return retval;
     }
   else
     {
       std::string fname = file_ops::tilde_expand (argv[i]);
 
       i++;
 
-      unsigned mode = std::ios::out;
+      std::ios::openmode mode = std::ios::out;
       if (format == LS_BINARY ||
 	  format == LS_MAT_BINARY ||
 	  format == LS_MAT5_BINARY)
 	mode |= std::ios::binary;
 
       mode |= append ? std::ios::ate : std::ios::trunc;
 
 #ifdef HAVE_HDF5
@@ -5118,17 +5118,17 @@ the file @file{data} in Octave's binary 
 	// don't insert any statements here!  The brace below must go
 	// with the "else" above!
 	{
 	  std::ofstream file (fname.c_str (), mode);
 	  
 	  if (file)
 	    {
 	      bool write_header_info
-		= ((file.rdbuf ())->seekoff (0, std::ios::cur)
+		= ((file.rdbuf ())->pubseekoff (0, std::ios::cur)
 		   == static_cast<std::streampos> (0));
 	      
 	      save_vars (argv, i, argc, file, save_builtins, format,
 			 save_as_floats, write_header_info);
 	    }
 	  else
 	    {
 	      error ("save: couldn't open output file `%s'", fname.c_str ());
diff --git a/src/mappers.cc b/src/mappers.cc
--- a/src/mappers.cc
+++ b/src/mappers.cc
@@ -150,17 +150,17 @@ static double
 xreal (const Complex& x)
 {
   return x.real ();
 }
 
 void
 install_mapper_functions (void)
 {
-  DEFUN_MAPPER (abs, 0, 0, 0, fabs, abs, 0, 0.0, 0.0, 0,
+  DEFUN_MAPPER (abs, 0, 0, 0, std::fabs, abs, 0, 0.0, 0.0, 0,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} abs (@var{z})\n\
 Compute the magnitude of @var{z}, defined as\n\
 @iftex\n\
 @tex\n\
 $|z| = \\sqrt{x^2 + y^2}$.\n\
 @end tex\n\
 @end iftex\n\
@@ -173,17 +173,17 @@ For example,\n\
 @example\n\
 @group\n\
 abs (3 + 4i)\n\
      @result{} 5\n\
 @end group\n\
 @end example\n\
 @end deftypefn");
 
-  DEFUN_MAPPER (acos, 0, 0, 0, acos, 0, acos, -1.0, 1.0, 1,
+  DEFUN_MAPPER (acos, 0, 0, 0, std::acos, 0, acos, -1.0, 1.0, 1,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} acos (@var{x})\n\
 Compute the inverse cosine of each element of @var{x}.\n\
 @end deftypefn");
 
   DEFUN_MAPPER (acosh, 0, 0, 0, acosh, 0, acosh, 1.0, DBL_MAX, 1,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} acosh (@var{x})\n\
@@ -218,41 +218,41 @@ For example,\n\
 @example\n\
 @group\n\
 arg (3 + 4i)\n\
      @result{} 0.92730\n\
 @end group\n\
 @end example\n\
 @end deftypefn");
 
-  DEFUN_MAPPER (asin, 0, 0, 0, asin, 0, asin, -1.0, 1.0, 1,
+  DEFUN_MAPPER (asin, 0, 0, 0, std::asin, 0, asin, -1.0, 1.0, 1,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} asin (@var{x})\n\
 Compute the inverse sine of each element of @var{x}.\n\
 @end deftypefn");
 
   DEFUN_MAPPER (asinh, 0, 0, 0, asinh, 0, asinh, 0.0, 0.0, 0,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} asinh (@var{x})\n\
 Ompute the inverse hyperbolic sine of each element of @var{x}.\n\
 @end deftypefn");
 
-  DEFUN_MAPPER (atan, 0, 0, 0, atan, 0, atan, 0.0, 0.0, 0,
+  DEFUN_MAPPER (atan, 0, 0, 0, std::atan, 0, atan, 0.0, 0.0, 0,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} atan (@var{x})\n\
 Compute the inverse tangent of each element of @var{x}.\n\
 @end deftypefn");
 
   DEFUN_MAPPER (atanh, 0, 0, 0, atanh, 0, atanh, -1.0, 1.0, 1,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} atanh (@var{x})\n\
 Compute the inverse hyperbolic tanget of each element of @var{x}.\n\
 @end deftypefn");
 
-  DEFUN_MAPPER (ceil, 0, 0, 0, ceil, 0, ceil, 0.0, 0.0, 0,
+  DEFUN_MAPPER (ceil, 0, 0, 0, std::ceil, 0, ceil, 0.0, 0.0, 0,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} ceil (@var{x})\n\
 Return the smallest integer not less than @var{x}.  If @var{x} is\n\
 complex, return @code{ceil (real (@var{x})) + ceil (imag (@var{x})) * I}.\n\
 @end deftypefn");
 
   DEFUN_MAPPER (conj, 0, 0, 0, xconj, 0, xconj, 0.0, 0.0, 0,
     "-*- texinfo -*-\n\
@@ -264,23 +264,23 @@ Return the complex conjugate of @var{z},
 @end tex\n\
 @end iftex\n\
 @ifinfo\n\
 @code{conj (@var{z})} = @var{x} - @var{i}@var{y}.\n\
 @end ifinfo\n\
 @end deftypefn\n\
 @seealso{real and imag}");
 
-  DEFUN_MAPPER (cos, 0, 0, 0, cos, 0, cos, 0.0, 0.0, 0,
+  DEFUN_MAPPER (cos, 0, 0, 0, std::cos, 0, cos, 0.0, 0.0, 0,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} cos (@var{x})\n\
 Compute the cosine of each element of @var{x}.\n\
 @end deftypefn");
 
-  DEFUN_MAPPER (cosh, 0, 0, 0, cosh, 0, cosh, 0.0, 0.0, 0,
+  DEFUN_MAPPER (cosh, 0, 0, 0, std::cosh, 0, cosh, 0.0, 0.0, 0,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} cosh (@var{x})\n\
 Compute the hyperbolic cosine of each element of @var{x}.\n\
 @end deftypefn");
 
   DEFUN_MAPPER (erf, 0, 0, 0, xerf, 0, 0, 0.0, 0.0, 0,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} erf (@var{z})\n\
@@ -316,17 +316,17 @@ Computes the complementary error functio
 @end iftex\n\
 @ifinfo\n\
 @code{1 - erf (@var{z})}.\n\
 @end ifinfo\n\
 @end deftypefn\n\
 \n\
 @seealso{erf and erfinv}");
 
-  DEFUN_MAPPER (exp, 0, 0, 0, exp, 0, exp, 0.0, 0.0, 0,
+  DEFUN_MAPPER (exp, 0, 0, 0, std::exp, 0, exp, 0.0, 0.0, 0,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} exp (@var{x})\n\
 Compute the exponential of @var{x}.  To compute the matrix exponential,\n\
 see @ref{Linear Algebra}.\n\
 @end deftypefn");
 
   DEFUN_MAPPER (finite, 0, xfinite, xfinite, 0, 0, 0, 0.0, 0.0, 0,
     "-*- texinfo -*-\n\
@@ -344,17 +344,17 @@ finite ([13, Inf, NaN])\n\
 
   DEFUN_MAPPER (fix, 0, 0, 0, fix, 0, fix, 0.0, 0.0, 0,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} fix (@var{x})\n\
 Truncate @var{x} toward zero.  If @var{x} is complex, return\n\
 @code{fix (real (@var{x})) + fix (imag (@var{x})) * I}.\n\
 @end deftypefn");
 
-  DEFUN_MAPPER (floor, 0, 0, 0, floor, 0, floor, 0.0, 0.0, 0,
+  DEFUN_MAPPER (floor, 0, 0, 0, std::floor, 0, floor, 0.0, 0.0, 0,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} floor (@var{x})\n\
 Return the largest integer not greater than @var{x}.  If @var{x} is\n\
 complex, return @code{floor (real (@var{x})) + floor (imag (@var{x})) * I}.\n\
 @end deftypefn");
 
   DEFUN_MAPPER (gamma, 0, 0, 0, xgamma, 0, 0, 0.0, 0.0, 0,
     "-*- texinfo -*-\n\
@@ -495,25 +495,25 @@ Return 1 for characters that are hexadec
   DEFUN_MAPPER (lgamma, 0, 0, 0, xlgamma, 0, 0, 0.0, 0.0, 0,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} lgamma (@var{a}, @var{x})\n\
 @deftypefnx {Mapping Function} {} gammaln (@var{a}, @var{x})\n\
 Return the natural logarithm of the gamma function.\n\
 @end deftypefn\n\
 @seealso{gamma and gammai}");
 
-  DEFUN_MAPPER (log, 0, 0, 0, log, 0, log, 0.0, DBL_MAX, 1,
+  DEFUN_MAPPER (log, 0, 0, 0, std::log, 0, log, 0.0, DBL_MAX, 1,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} log (@var{x})\n\
 Compute the natural logarithm for each element of @var{x}.  To compute the\n\
 matrix logarithm, see @ref{Linear Algebra}.\n\
 @end deftypefn\n\
 @seealso{log2, log10, logspace, and exp}");
 
-  DEFUN_MAPPER (log10, 0, 0, 0, log10, 0, log10, 0.0, DBL_MAX, 1,
+  DEFUN_MAPPER (log10, 0, 0, 0, std::log10, 0, log10, 0.0, DBL_MAX, 1,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} log10 (@var{x})\n\
 Compute the base-10 logarithm for each element of @var{x}.\n\
 @end deftypefn\n\
 @seealso{log, log2, logspace, and exp}");
 
   DEFUN_MAPPER (real, 0, 0, 0, real, xreal, 0, 0.0, 0.0, 0,
     "-*- texinfo -*-\n\
@@ -548,43 +548,43 @@ Compute the @dfn{signum} function, which
 sign (x) =  0, x = 0;\n\
             1, x > 0.\n\
 @end example\n\
 @end ifinfo\n\
 \n\
 For complex arguments, @code{sign} returns @code{x ./ abs (@var{x})}.\n\
 @end deftypefn");
 
-  DEFUN_MAPPER (sin, 0, 0, 0, sin, 0, sin, 0.0, 0.0, 0,
+  DEFUN_MAPPER (sin, 0, 0, 0, std::sin, 0, sin, 0.0, 0.0, 0,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} sin (@var{x})\n\
 Compute the sin of each element of @var{x}.\n\
 @end deftypefn");
 
-  DEFUN_MAPPER (sinh, 0, 0, 0, sinh, 0, sinh, 0.0, 0.0, 0,
+  DEFUN_MAPPER (sinh, 0, 0, 0, std::sinh, 0, sinh, 0.0, 0.0, 0,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} sinh (@var{x})\n\
 Compute the inverse hyperbolic sin of each element of @var{x}.\n\
 @end deftypefn");
 
-  DEFUN_MAPPER (sqrt, 0, 0, 0, sqrt, 0, sqrt, 0.0, DBL_MAX, 1,
+  DEFUN_MAPPER (sqrt, 0, 0, 0, std::sqrt, 0, sqrt, 0.0, DBL_MAX, 1,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} sqrt (@var{x})\n\
 Compute the square root of @var{x}.  If @var{x} is negative, a complex\n\
 result is returned.  To compute the matrix square root, see\n\
 @ref{Linear Algebra}.\n\
 @end deftypefn");
 
-  DEFUN_MAPPER (tan, 0, 0, 0, tan, 0, tan, 0.0, 0.0, 0,
+  DEFUN_MAPPER (tan, 0, 0, 0, std::tan, 0, tan, 0.0, 0.0, 0,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} tan (@var{z})\n\
 Compute tanget of each element of @var{x}.\n\
 @end deftypefn");
 
-  DEFUN_MAPPER (tanh, 0, 0, 0, tanh, 0, tanh, 0.0, 0.0, 0,
+  DEFUN_MAPPER (tanh, 0, 0, 0, std::tanh, 0, tanh, 0.0, 0.0, 0,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} tanh (@var{x})\n\
 Compute hyperbolic tangent of each element of @var{x}.\n\
 @end deftypefn");
 
   DEFUN_MAPPER (toascii, xtoascii, 0, 0, 0, 0, 0, 0.0, 0.0, 1,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} toascii (@var{s})\n\
diff --git a/src/oct-fstrm.cc b/src/oct-fstrm.cc
--- a/src/oct-fstrm.cc
+++ b/src/oct-fstrm.cc
@@ -37,33 +37,41 @@ octave_fstream::create (const std::strin
   return octave_stream (new octave_fstream (nm_arg, arg_md, flt_fmt));
 }
 
 octave_fstream::octave_fstream (const std::string& nm_arg,
 				std::ios::openmode arg_md,
 				oct_mach_info::float_format flt_fmt)
   : octave_base_stream (arg_md, flt_fmt), nm (nm_arg)
 {
+
+#if CXX_ISO_COMPLIANT_LIBRARY
+
+  fs.open (nm.c_str (), arg_md);
+
+#else
   // Override default protection of 0664 so that umask will appear to
   // do the right thing.
 
   fs.open (nm.c_str (), arg_md, 0666);
 
+#endif
+
   if (! fs)
     {
       using namespace std;
 
       error (strerror (errno));
     }
 }
 
 // Position a stream at OFFSET relative to ORIGIN.
 
 int
-octave_fstream::seek (std::streamoff offset, std::ios::seek_dir origin)
+octave_fstream::seek (std::streamoff offset, std::ios::seekdir origin)
 {
   int retval = -1;
 
   if (! fs.bad ())
     {
       fs.clear ();
 
       std::filebuf *fb = fs.rdbuf ();
diff --git a/src/oct-fstrm.h b/src/oct-fstrm.h
--- a/src/oct-fstrm.h
+++ b/src/oct-fstrm.h
@@ -19,16 +19,17 @@ along with Octave; see the file COPYING.
 Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 
 */
 
 #if !defined (octave_octave_fstream_h)
 #define octave_octave_fstream_h 1
 
 #include <fstream>
+#include <string>
 
 #include "oct-stream.h"
 
 class
 octave_fstream : public octave_base_stream
 {
 public:
 
@@ -39,17 +40,17 @@ public:
 
   static octave_stream
   create (const std::string& nm_arg,
 	  std::ios::openmode arg_md = std::ios::in|std::ios::out,
 	  oct_mach_info::float_format flt_fmt = oct_mach_info::native);
 
   // Position a stream at OFFSET relative to ORIGIN.
 
-  int seek (std::streamoff offset, std::ios::seek_dir origin);
+  int seek (std::streamoff offset, std::ios::seekdir origin);
 
   // Return current stream position.
 
   long tell (void) const;
 
   // Return non-zero if EOF has been reached on this stream.
 
   bool eof (void) const;
diff --git a/src/oct-iostrm.cc b/src/oct-iostrm.cc
--- a/src/oct-iostrm.cc
+++ b/src/oct-iostrm.cc
@@ -25,17 +25,17 @@ Software Foundation, 59 Temple Place - S
 #endif
 
 #include "error.h"
 #include "oct-iostrm.h"
 
 // Position a stream at OFFSET relative to ORIGIN.
 
 int
-octave_base_iostream::seek (std::streamoff, std::ios::seek_dir)
+octave_base_iostream::seek (std::streamoff, std::ios::seekdir)
 {
   invalid_operation ();
   return -1;
 }
 
 // Return current stream position.
 
 long
diff --git a/src/oct-iostrm.h b/src/oct-iostrm.h
--- a/src/oct-iostrm.h
+++ b/src/oct-iostrm.h
@@ -35,17 +35,17 @@ public:
   octave_base_iostream (const std::string& n = std::string (),
 			std::ios::openmode md = std::ios::in|std::ios::out,
 			oct_mach_info::float_format flt_fmt =
 			oct_mach_info::native)
     : octave_base_stream (md, flt_fmt), nm (n) { }
 
   // Position a stream at OFFSET relative to ORIGIN.
 
-  int seek (std::streamoff offset, std::ios::seek_dir origin);
+  int seek (std::streamoff offset, std::ios::seekdir origin);
 
   // Return current stream position.
 
   long tell (void) const;
 
   // Return non-zero if EOF has been reached on this stream.
 
   bool eof (void) const;
diff --git a/src/oct-stdstrm.cc b/src/oct-stdstrm.cc
--- a/src/oct-stdstrm.cc
+++ b/src/oct-stdstrm.cc
@@ -26,17 +26,17 @@ Software Foundation, 59 Temple Place - S
 
 #include <cstdio>
 
 #include "oct-stdstrm.h"
 
 // Position a stream at OFFSET relative to ORIGIN.
 
 int
-octave_base_stdiostream::seek (std::streamoff offset, std::ios::seek_dir origin)
+octave_base_stdiostream::seek (std::streamoff offset, std::ios::seekdir origin)
 {
   int retval = -1;
 
   if (! bad ())
     {
       c_file_ptr_buf *sb = rdbuf ();
 
       if (sb)
@@ -102,17 +102,17 @@ void
 octave_istdiostream::do_close (void)
 {
   if (is)
     is->close ();
 }
 
 octave_stream
 octave_ostdiostream::create (const std::string& n, FILE *f,
-			     c_file_ptr_buf::close_fcn cf = ::fclose,
+			     c_file_ptr_buf::close_fcn cf,
 			     std::ios::openmode arg_md,
 			     oct_mach_info::float_format flt_fmt)
 {
   return octave_stream (new octave_ostdiostream (n, f, cf, arg_md, flt_fmt));
 }
 
 octave_ostdiostream::octave_ostdiostream (const std::string& n, FILE *f,
 					  c_file_ptr_buf::close_fcn cf,
diff --git a/src/oct-stdstrm.h b/src/oct-stdstrm.h
--- a/src/oct-stdstrm.h
+++ b/src/oct-stdstrm.h
@@ -34,17 +34,17 @@ public:
   octave_base_stdiostream
     (const std::string& n,
      std::ios::openmode arg_md = std::ios::in|std::ios::out,
      oct_mach_info::float_format flt_fmt = oct_mach_info::native)
     : octave_base_stream (arg_md, flt_fmt), nm (n) { }
 
   // Position a stream at OFFSET relative to ORIGIN.
 
-  int seek (std::streamoff offset, std::ios::seek_dir origin);
+  int seek (std::streamoff offset, std::ios::seekdir origin);
 
   // Return current stream position.
 
   long tell (void) const;
 
   // The name of the file.
 
   std::string name (void) const { return nm; }
diff --git a/src/oct-stream.cc b/src/oct-stream.cc
--- a/src/oct-stream.cc
+++ b/src/oct-stream.cc
@@ -34,16 +34,17 @@ Software Foundation, 59 Temple Place - S
 
 #include "lo-ieee.h"
 #include "lo-mappers.h"
 #include "lo-utils.h"
 #include "str-vec.h"
 
 #include "error.h"
 #include "input.h"
+#include "oct-stdstrm.h"
 #include "oct-stream.h"
 #include "oct-obj.h"
 #include "utils.h"
 
 // Possible values for conv_err:
 //
 //   1 : not a real scalar
 //   2 : value is NaN
@@ -889,19 +890,27 @@ octave_base_stream::file_number (void)
   if (name () == "stderr")
     return 2;
 
   int retval = -1;
 
   std::istream *is = input_stream ();
   std::ostream *os = output_stream ();
 
-  // XXX FIXME XXX -- there must be a better way...
-  int i_fid = is ? ((std::filebuf *) (is->rdbuf ()))->fd () : -1;
-  int o_fid = os ? ((std::filebuf *) (os->rdbuf ()))->fd () : -1;
+  // There is no standard way to get the underlying file descriptor from 
+  // std::filebuf (nor in the GNU libstdc++-v3 implementation). We cache
+  // the descriptor in c_file_ptr_buf, and then extract it here.
+
+  c_file_ptr_buf *ibuf = is ?
+    dynamic_cast<c_file_ptr_buf *> (is->rdbuf ()) : 0;
+  c_file_ptr_buf *obuf = os ?
+    dynamic_cast<c_file_ptr_buf *> (os->rdbuf ()) : 0;
+
+  int i_fid = ibuf ? ibuf->file_number () : -1;
+  int o_fid = obuf ? obuf->file_number () : -1;
 
   if (i_fid >= 0)
     {
       if (o_fid >= 0)
 	retval = (i_fid == o_fid) ? i_fid : -1;
       else
 	retval = i_fid;
     }
@@ -1050,17 +1059,17 @@ octave_base_stream::read (const Matrix& 
 	}
     }
   else
     invalid_operation ("fread", "reading");
 
   return retval;
 }
 
-#if defined (__GNUG__)
+#if defined (__GNUG__) && !CXX_ISO_COMPLIANT_LIBRARY
 
 #define OCTAVE_SCAN(is, fmt, arg) is.scan ((fmt).text, arg)
 
 #else
 
 #define OCTAVE_SCAN(is, fmt, arg) octave_scan (is, fmt, arg)
 
 template <class T>
@@ -2508,17 +2517,17 @@ octave_stream::gets (const octave_value&
     }
   else
     retval = gets (max_len, err);
 
   return retval;
 }
 
 int
-octave_stream::seek (std::streamoff offset, std::ios::seek_dir origin)
+octave_stream::seek (std::streamoff offset, std::ios::seekdir origin)
 {
   int retval = -1;
 
   if (stream_ok ("fseek"))
     retval = rep->seek (offset, origin);
 
   return retval;
 }
@@ -2530,17 +2539,17 @@ octave_stream::seek (const octave_value&
   int retval = -1;
 
   int conv_err = 0;
 
   int xoffset = convert_to_valid_int (tc_offset, conv_err);
 
   if (! conv_err)
     {
-      std::ios::seek_dir origin = std::ios::beg;
+      std::ios::seekdir origin = std::ios::beg;
 
       if (tc_origin.is_string ())
 	{
 	  std::string xorigin = tc_origin.string_value ();
 
 	  if (xorigin == "bof")
 	    origin = std::ios::beg;
 	  else if (xorigin == "cof")
@@ -2760,72 +2769,46 @@ octave_stream::float_format (void) const
 
   return retval;
 }
 
 std::string
 octave_stream::mode_as_string (int mode)
 {
   std::string retval = "???";
-
-  switch (mode)
-    {
-    case std::ios::in:
-      retval = "r";
-      break;
-
-    case std::ios::out:
-    case std::ios::out | std::ios::trunc:
-      retval = "w";
-      break;
-
-    case std::ios::out | std::ios::app:
-      retval = "a";
-      break;
-
-    case std::ios::in | std::ios::out:
-      retval = "r+";
-      break;
-
-    case std::ios::in | std::ios::out | std::ios::trunc:
-      retval = "w+";
-      break;
-
-    case std::ios::in | std::ios::out | std::ios::app:
-      retval = "a+";
-      break;
-
-    case std::ios::in | std::ios::binary:
-      retval = "rb";
-      break;
-
-    case std::ios::out | std::ios::binary:
-    case std::ios::out | std::ios::trunc | std::ios::binary:
-      retval = "wb";
-      break;
-
-    case std::ios::out | std::ios::app | std::ios::binary:
-      retval = "ab";
-      break;
-
-    case std::ios::in | std::ios::out | std::ios::binary:
-      retval = "r+b";
-      break;
-
-    case std::ios::in | std::ios::out | std::ios::trunc | std::ios::binary:
-      retval = "w+b";
-      break;
-
-    case std::ios::in | std::ios::out | std::ios::app | std::ios::binary:
-      retval = "a+b";
-      break;
-
-    default:
-      break;
-    }
+  std::ios::openmode in_mode = static_cast<std::ios::openmode> (mode);
+
+  if (in_mode == std::ios::in)
+    retval = "r";
+  else if (in_mode == std::ios::out 
+           || in_mode == std::ios::out | std::ios::trunc)
+    retval = "w";
+  else if (in_mode == std::ios::out | std::ios::app)
+    retval = "a";
+  else if (in_mode == std::ios::in | std::ios::out)
+    retval = "r+";
+  else if (in_mode == std::ios::in | std::ios::out | std::ios::trunc)
+    retval = "w+";
+  else if (in_mode == std::ios::in | std::ios::out | std::ios::app)
+    retval = "a+";
+  else if (in_mode == std::ios::in | std::ios::binary)
+    retval = "rb";
+  else if (in_mode == std::ios::out | std::ios::binary
+           || in_mode == std::ios::out | std::ios::trunc | std::ios::binary)
+    retval = "wb";
+  else if (in_mode == std::ios::out | std::ios::app | std::ios::binary)
+    retval = "ab";
+  else if (in_mode == std::ios::in | std::ios::out | std::ios::binary)
+    retval = "r+b";
+  else if (in_mode == std::ios::in | std::ios::out | std::ios::trunc 
+           | std::ios::binary)
+    retval = "w+b";
+  else if (in_mode == std::ios::in | std::ios::out | std::ios::app
+           | std::ios::binary)
+    retval = "a+b";
 
   return retval;
 }
 
 void
 octave_stream::invalid_stream_error (const char *op) const
 {
   ::error ("%s: attempt to use invalid I/O stream", op);
diff --git a/src/oct-stream.h b/src/oct-stream.h
--- a/src/oct-stream.h
+++ b/src/oct-stream.h
@@ -329,17 +329,17 @@ public:
 
   virtual ~octave_base_stream (void) { }
 
   // The remaining functions are not specific to input or output only,
   // and must be provided by the derived classes.
 
   // Position a stream at OFFSET relative to ORIGIN.
 
-  virtual int seek (std::streamoff offset, std::ios::seek_dir origin) = 0;
+  virtual int seek (std::streamoff offset, std::ios::seekdir origin) = 0;
 
   // Return current stream position.
 
   virtual long tell (void) const = 0;
 
   // Return TRUE if EOF has been reached on this stream.
 
   virtual bool eof (void) const = 0;
@@ -497,17 +497,17 @@ public:
   int flush (void);
 
   std::string getl (int max_len, bool& err);
   std::string getl (const octave_value& max_len, bool& err);
 
   std::string gets (int max_len, bool& err);
   std::string gets (const octave_value& max_len, bool& err);
 
-  int seek (std::streamoff offset, std::ios::seek_dir origin);
+  int seek (std::streamoff offset, std::ios::seekdir origin);
   int seek (const octave_value& offset, const octave_value& origin);
 
   long tell (void) const;
 
   int rewind (void);
 
   bool is_open (void) const;
 
diff --git a/src/oct-strstrm.cc b/src/oct-strstrm.cc
--- a/src/oct-strstrm.cc
+++ b/src/oct-strstrm.cc
@@ -24,17 +24,17 @@ Software Foundation, 59 Temple Place - S
 #include <config.h>
 #endif
 
 #include "oct-strstrm.h"
 
 // Position a stream at OFFSET relative to ORIGIN.
 
 int
-octave_base_strstream::seek (std::streamoff offset, std::ios::seek_dir origin)
+octave_base_strstream::seek (std::streamoff offset, std::ios::seekdir origin)
 {
   int retval = -1;
 
   if (! bad ())
     {
       std::streambuf *sb = rdbuf ();
 
       if (sb)
diff --git a/src/oct-strstrm.h b/src/oct-strstrm.h
--- a/src/oct-strstrm.h
+++ b/src/oct-strstrm.h
@@ -35,17 +35,17 @@ public:
 
   octave_base_strstream (std::ios::openmode arg_md = std::ios::out,
 			 oct_mach_info::float_format flt_fmt =
 			 oct_mach_info::native)
     : octave_base_stream (arg_md, flt_fmt) { }
 
   // Position a stream at OFFSET relative to ORIGIN.
 
-  int seek (std::streamoff offset, std::ios::seek_dir origin);
+  int seek (std::streamoff offset, std::ios::seekdir origin);
 
   // Return current stream position.
 
   long tell (void) const;
 
   // The name of the file.
 
   std::string name (void) const { return std::string (); }
diff --git a/src/ov-base-nd-array.cc b/src/ov-base-nd-array.cc
--- a/src/ov-base-nd-array.cc
+++ b/src/ov-base-nd-array.cc
@@ -30,17 +30,17 @@ Software Foundation, 59 Temple Place - S
 
 #include <iostream>
 
 #include "oct-obj.h"
 #include "ov-base.h"
 #include "ov-base-nd-array.h"
 #include "pr-output.h"
 
-static Array<idx_vector>
+static inline Array<idx_vector>
 idx_list_to_idx_array (const octave_value_list& idx)
 {
   int n = idx.length ();
 
   Array<idx_vector> retval (n);
 
   for (int i = 0; i < n; i++)
     retval(i) = idx(i).index_vector ();
diff --git a/src/ov-base-scalar.h b/src/ov-base-scalar.h
--- a/src/ov-base-scalar.h
+++ b/src/ov-base-scalar.h
@@ -46,17 +46,17 @@ template <class ST>
 class
 octave_base_scalar : public octave_base_value
 {
 public:
 
   octave_base_scalar (void)
     : octave_base_value () { }
 
-  octave_base_scalar (ST s)
+  octave_base_scalar (const ST& s)
     : octave_base_value (), scalar (s) { }
 
   octave_base_scalar (const octave_base_scalar& s)
     : octave_base_value (), scalar (s.scalar) { }
 
   ~octave_base_scalar (void) { }
 
   int rows (void) const { return 1; }
diff --git a/src/ov-complex.cc b/src/ov-complex.cc
--- a/src/ov-complex.cc
+++ b/src/ov-complex.cc
@@ -50,17 +50,17 @@ DEFINE_OCTAVE_ALLOCATOR (octave_complex)
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_complex, "complex scalar");
 
 octave_value *
 octave_complex::try_narrowing_conversion (void)
 {
   octave_value *retval = 0;
 
   if (imag (scalar) == 0.0)
-    retval = new octave_scalar (::real (scalar));
+    retval = new octave_scalar (real (scalar));
 
   return retval;
 }
 
 static inline bool
 valid_scalar_indices (const octave_value_list& args)
 {
   int nargin = args.length ();
@@ -108,17 +108,17 @@ octave_complex::double_value (bool force
 
   if (! flag)
     flag = Vok_to_lose_imaginary_part;
 
   if (flag < 0)
     gripe_implicit_conversion ("complex scalar", "real scalar");
 
   if (flag)
-    retval = ::real (scalar);
+    retval = std::real (scalar);
   else
     gripe_invalid_conversion ("complex scalar", "real scalar");
 
   return retval;
 }
 
 Matrix
 octave_complex::matrix_value (bool force_conversion) const
@@ -129,17 +129,17 @@ octave_complex::matrix_value (bool force
 
   if (! flag)
     flag = Vok_to_lose_imaginary_part;
 
   if (flag < 0)
     gripe_implicit_conversion ("complex scalar", "real matrix");
 
   if (flag)
-    retval = Matrix (1, 1, ::real (scalar));
+    retval = Matrix (1, 1, std::real (scalar));
   else
     gripe_invalid_conversion ("complex scalar", "real matrix");
 
   return retval;
 }
 
 Complex
 octave_complex::complex_value (bool) const
diff --git a/src/ov-cx-mat.cc b/src/ov-cx-mat.cc
--- a/src/ov-cx-mat.cc
+++ b/src/ov-cx-mat.cc
@@ -59,17 +59,17 @@ octave_complex_matrix::try_narrowing_con
   int nr = matrix.rows ();
   int nc = matrix.cols ();
 
   if (nr == 1 && nc == 1)
     {
       Complex c = matrix (0, 0);
 
       if (imag (c) == 0.0)
-	retval = new octave_scalar (::real (c));
+	retval = new octave_scalar (std::real (c));
       else
 	retval = new octave_complex (c);
     }
   else if (nr == 0 || nc == 0)
     retval = new octave_matrix (Matrix (nr, nc));
   else if (matrix.all_elements_are_real ())
     retval = new octave_matrix (::real (matrix));
 
@@ -177,17 +177,17 @@ octave_complex_matrix::double_value (boo
 
   if (flag < 0)
     gripe_implicit_conversion ("complex matrix", "real scalar");
 
   if (flag)
     {
       if ((rows () == 1 && columns () == 1)
 	  || (Vdo_fortran_indexing && rows () > 0 && columns () > 0))
-	retval = ::real (matrix (0, 0));
+	retval = std::real (matrix (0, 0));
       else
 	gripe_invalid_conversion ("complex matrix", "real scalar");
     }
   else
     gripe_invalid_conversion ("complex matrix", "real scalar");
 
   return retval;
 }
diff --git a/src/pager.cc b/src/pager.cc
--- a/src/pager.cc
+++ b/src/pager.cc
@@ -279,17 +279,17 @@ octave_diary_buf::sync (void)
 
   seekoff (0, std::ios::beg);
 
   return 0;
 }
 
 octave_pager_stream *octave_pager_stream::instance = 0;
 
-octave_pager_stream::octave_pager_stream (void) : std::ostream (), pb (0)
+octave_pager_stream::octave_pager_stream (void) : std::ostream (0), pb (0)
 {
   pb = new octave_pager_buf;
   rdbuf (pb);
   setf (unitbuf);
 }
 
 octave_pager_stream::~octave_pager_stream (void)
 {
@@ -317,17 +317,17 @@ void
 octave_pager_stream::set_diary_skip (void)
 {
   if (pb)
     pb->set_diary_skip ();
 }
 
 octave_diary_stream *octave_diary_stream::instance = 0;
 
-octave_diary_stream::octave_diary_stream (void) : std::ostream (), db (0)
+octave_diary_stream::octave_diary_stream (void) : std::ostream (0), db (0)
 {
   db = new octave_diary_buf;
   rdbuf (db);
   setf (unitbuf);
 }
 
 octave_diary_stream::~octave_diary_stream (void)
 {
diff --git a/src/pr-output.cc b/src/pr-output.cc
--- a/src/pr-output.cc
+++ b/src/pr-output.cc
@@ -179,17 +179,19 @@ std::ostream&
 operator << (std::ostream& os, const pr_formatted_float& pff)
 {
   if (pff.f.fw >= 0)
     os << std::setw (pff.f.fw);
 
   if (pff.f.prec >= 0)
     os << std::setprecision (pff.f.prec);
 
-  std::ios::fmtflags oflags = os.flags (pff.f.fmt | pff.f.up | pff.f.sp);
+  std::ios::fmtflags oflags = 
+    os.flags (static_cast<std::ios::fmtflags> 
+              (pff.f.fmt | pff.f.up | pff.f.sp));
 
   os << pff.val;
 
   os.flags (oflags);
 
   return os;
 }
 
diff --git a/src/procstream.h b/src/procstream.h
--- a/src/procstream.h
+++ b/src/procstream.h
@@ -61,68 +61,71 @@ private:
   void pb_init (void) { init (&pb); }
 
   procstreambase (const procstreambase&);
 
   procstreambase& operator = (const procstreambase&);
 };
 
 class
-iprocstream : public procstreambase, public std::istream
+iprocstream : public std::istream, public procstreambase
+// iprocstream : public procstreambase, public std::istream
 {
 public:
 
-  iprocstream (void) : procstreambase () { }
+  iprocstream (void) : std::istream (0), procstreambase () { }
 
   iprocstream (const char *name, int mode = std::ios::in)
-    : procstreambase (name, mode) { }
+    : std::istream (0), procstreambase (name, mode) { }
 
   ~iprocstream (void) { }
 
   void open (const char *name, int mode = std::ios::in)
     { procstreambase::open (name, mode); }
 
 private:
 
   iprocstream (const iprocstream&);
 
   iprocstream& operator = (const iprocstream&);
 };
 
 class
-oprocstream : public procstreambase, public std::ostream
+oprocstream : public std::ostream, public procstreambase
+// oprocstream : public procstreambase, public std::ostream
 {
 public:
  
-  oprocstream (void) : procstreambase () { }
+  oprocstream (void) : std::ostream (0), procstreambase () { }
 
   oprocstream (const char *name, int mode = std::ios::out)
-    : procstreambase(name, mode) { }
+    : std::ostream (0), procstreambase(name, mode) { }
 
   ~oprocstream (void) { }
 
   void open (const char *name, int mode = std::ios::out)
     { procstreambase::open (name, mode); }
 
 private:
 
   oprocstream (const oprocstream&);
 
   oprocstream& operator = (const oprocstream&);
 };
 
 class
-procstream : public procstreambase, public std::iostream
+procstream : public std::iostream, public procstreambase
+// procstream : public procstreambase, public std::iostream
 {
 public:
 
-  procstream (void) : procstreambase () { }
+  procstream (void) : std::iostream (0), procstreambase () { }
 
   procstream (const char *name, int mode)
-    : procstreambase (name, mode) { }
+    : std::iostream (0), procstreambase (name, mode) { }
 
   ~procstream (void) { }
 
   void open (const char *name, int mode)
     { procstreambase::open (name, mode); }
 
 private:
 
diff --git a/src/pt-bp.h b/src/pt-bp.h
--- a/src/pt-bp.h
+++ b/src/pt-bp.h
@@ -164,17 +164,17 @@ tree_breakpoint : public tree_walker
 };
 
 #define MAYBE_DO_BREAKPOINT \
   do \
     { \
       if (tree::break_next || is_breakpoint ()) \
         { \
           tree::break_next = false; \
-          octave_stdout << "line: " << line () << endl; \
+          octave_stdout << "line: " << line () << std::endl; \
           do_keyboard (); \
         } \
     } \
   while (0)
 
 #endif
 
 /*
diff --git a/src/utils.cc b/src/utils.cc
--- a/src/utils.cc
+++ b/src/utils.cc
@@ -713,17 +713,17 @@ octave_format (std::ostream& os, const c
   return retval;
 }
 
 extern int
 octave_vformat (std::ostream& os, const char *fmt, va_list args)
 {
   int retval = -1;
 
-#if defined (__GNUG__)
+#if defined (__GNUG__) && !CXX_ISO_COMPLIANT_LIBRARY
 
   std::ostrstream buf;
 
   buf.vform (fmt, args);
 
   buf << std::ends;
 
   char *s = buf.str ();
