# HG changeset patch
# User Stefan Mahr <dac922@gmx.de>
# Date 1376321814 -7200
#      Mon Aug 12 17:36:54 2013 +0200
# Node ID 7babcdb9bc131835e9d61800bab93ca8252bde38
# Parent  9de751a10910435dd6e6db16e05f87f5a76fe351
Use ... instead of \ for line continuation marker.

* plotimages.m, bsxfun.cc, cellfun.cc, __unimplemented__.m,
importdata.m, textscan.m, edit.m, fsolve.m, sqp.m,
__gnuplot_drawnow__.m, __marching_cube__.m, stemleaf.m, polyfit.m,
z_test.m, z_test_2.m, test.m:
Use ... instead of \ for line continuation marker.

diff --git a/doc/interpreter/plotimages.m b/doc/interpreter/plotimages.m
--- a/doc/interpreter/plotimages.m
+++ b/doc/interpreter/plotimages.m
@@ -83,17 +83,17 @@ function plotimages (nm, typ)
     title ("plot3 display of 3-D helix");
     print ([nm "." typ], d_typ);
   elseif (strcmp (nm, "extended"))
     x = 0:0.01:3;
     plot (x,erf(x));
     hold on;
     plot (x,x,"r");
     axis ([0, 3, 0, 1]);
-    text (0.65, 0.6175, ['\leftarrow x = {2/\surd\pi {\fontsize{16}' \
+    text (0.65, 0.6175, ['\leftarrow x = {2/\surd\pi {\fontsize{16}' ...
           '\int_{\fontsize{8}0}^{\fontsize{8}x}} e^{-t^2} dt} = 0.6175']);
     xlabel ("x");
     ylabel ("erf (x)");
     title ("erf (x) with text annotation");
     print ([nm "." typ], d_typ);
   else
     error ("unrecognized plot requested");
   endif
diff --git a/libinterp/corefcn/bsxfun.cc b/libinterp/corefcn/bsxfun.cc
--- a/libinterp/corefcn/bsxfun.cc
+++ b/libinterp/corefcn/bsxfun.cc
@@ -768,46 +768,46 @@ dimensionality as the other array.\n\
 %!assert (bsxfun (@min, a, b), min (aa, bb))
 %!assert (bsxfun (@max, a, b), max (aa, bb))
 %!assert (bsxfun (@and, a > 0, b > 0), (aa > 0) & (bb > 0))
 %!assert (bsxfun (@or, a > 0, b > 0), (aa > 0) | (bb > 0))
 
 %% Test automatic bsxfun
 %
 %!test
-%! funs = {@plus, @minus, @times, @rdivide, @ldivide, @power, @max, @min, \
-%!         @rem, @mod, @atan2, @hypot, @eq, @ne, @lt, @le, @gt, @ge, \
+%! funs = {@plus, @minus, @times, @rdivide, @ldivide, @power, @max, @min, ...
+%!         @rem, @mod, @atan2, @hypot, @eq, @ne, @lt, @le, @gt, @ge, ...
 %!         @and, @or, @xor };
 %!
 %! float_types = {@single, @double};
-%! int_types = {@int8, @int16, @int32, @int64, \
+%! int_types = {@int8, @int16, @int32, @int64, ...
 %!              @uint8, @uint16, @uint32, @uint64};
 %!
 %! x = rand (3) * 10-5;
 %! y = rand (3,1) * 10-5;
 %!
 %! for i=1:length (funs)
 %!   for j = 1:length (float_types)
 %!     for k = 1:length (int_types)
 %!
 %!       fun = funs{i};
 %!       f_type = float_types{j};
 %!       i_type = int_types{k};
 %!
-%!         assert (bsxfun (fun, f_type (x), i_type (y)), \
+%!         assert (bsxfun (fun, f_type (x), i_type (y)), ...
 %!                 fun (f_type(x), i_type (y)));
-%!         assert (bsxfun (fun, f_type (y), i_type (x)), \
+%!         assert (bsxfun (fun, f_type (y), i_type (x)), ...
 %!                 fun (f_type(y), i_type (x)));
 %!
-%!         assert (bsxfun (fun, i_type (x), i_type (y)), \
+%!         assert (bsxfun (fun, i_type (x), i_type (y)), ...
 %!                 fun (i_type (x), i_type (y)));
-%!         assert (bsxfun (fun, i_type (y), i_type (x)), \
+%!         assert (bsxfun (fun, i_type (y), i_type (x)), ...
 %!                 fun (i_type (y), i_type (x)));
 %!
-%!         assert (bsxfun (fun, f_type (x), f_type (y)), \
+%!         assert (bsxfun (fun, f_type (x), f_type (y)), ...
 %!                 fun (f_type (x), f_type (y)));
-%!         assert (bsxfun (fun, f_type(y), f_type(x)), \
+%!         assert (bsxfun (fun, f_type(y), f_type(x)), ...
 %!                 fun (f_type (y), f_type (x)));
 %!     endfor
 %!   endfor
 %! endfor
 %!
 */
diff --git a/libinterp/corefcn/cellfun.cc b/libinterp/corefcn/cellfun.cc
--- a/libinterp/corefcn/cellfun.cc
+++ b/libinterp/corefcn/cellfun.cc
@@ -811,17 +811,17 @@ v = cellfun (@@det, a); # faster\n\
 %! A = cellfun ("prodofsize", {[1, 2; 3, 4], (cell (1,2,3,4))});
 %! assert (A, [4, 24]);
 
 %% Number of input and output arguments may not be limited to one
 %!test
 %! A = cellfun (@(x,y,z) x + y + z, {1, 1, 1}, {2, 2, 2}, {3, 4, 5});
 %! assert (A, [6, 7, 8]);
 %!test
-%! A = cellfun (@(x,y,z) x + y + z, {1, 1, 1}, {2, 2, 2}, {3, 4, 5}, \
+%! A = cellfun (@(x,y,z) x + y + z, {1, 1, 1}, {2, 2, 2}, {3, 4, 5}, ...
 %!              "UniformOutput", false);
 %! assert (A, {6, 7, 8});
 %!test %% Two input arguments of different types
 %! A = cellfun (@(x,y) islogical (x) && ischar (y), {false, true}, {"a", 3});
 %! assert (A, [true, false]);
 %!test %% Pass another variable to the anonymous function
 %! y = true;
 %! A = cellfun (@(x) islogical (x) && y, {false, 0.3});
@@ -832,73 +832,73 @@ v = cellfun (@@det, a); # faster\n\
 %! assert (isequal (B, {true, true; [], true}));
 %! assert (isequal (C, {10, 11; [], 12}));
 
 %% Input arguments can be of type cell array of logical
 %!test
 %! A = cellfun (@(x,y) x == y, {false, true}, {true, true});
 %! assert (A, [false, true]);
 %!test
-%! A = cellfun (@(x,y) x == y, {false; true}, {true; true}, \
+%! A = cellfun (@(x,y) x == y, {false; true}, {true; true}, ...
 %!              "UniformOutput", true);
 %! assert (A, [false; true]);
 %!test
 %! A = cellfun (@(x) x, {false, true; false, true}, "UniformOutput", false);
 %! assert (A, {false, true; false, true});
 %!test %% Three ouptut arguments of same type
-%! [A, B, C] = cellfun (@find, {true, false; false, true}, \
+%! [A, B, C] = cellfun (@find, {true, false; false, true}, ...
 %!                      "UniformOutput", false);
 %! assert (isequal (A, {true, []; [], true}));
 %! assert (isequal (B, {true, []; [], true}));
 %! assert (isequal (C, {true, []; [], true}));
 %!test
-%! A = cellfun (@(x,y) cell2str (x,y), {true}, {true}, \
+%! A = cellfun (@(x,y) cell2str (x,y), {true}, {true}, ...
 %!              "ErrorHandler", @__cellfunerror);
 %! assert (isfield (A, "identifier"), true);
 %! assert (isfield (A, "message"), true);
 %! assert (isfield (A, "index"), true);
 %! assert (isempty (A.message), false);
 %! assert (A.index, 1);
 %!test %% Overwriting setting of "UniformOutput" true
-%! A = cellfun (@(x,y) cell2str (x,y), {true}, {true}, \
+%! A = cellfun (@(x,y) cell2str (x,y), {true}, {true}, ...
 %!              "UniformOutput", true, "ErrorHandler", @__cellfunerror);
 %! assert (isfield (A, "identifier"), true);
 %! assert (isfield (A, "message"), true);
 %! assert (isfield (A, "index"), true);
 %! assert (isempty (A.message), false);
 %! assert (A.index, 1);
 
 %% Input arguments can be of type cell array of numeric
 %!test
 %! A = cellfun (@(x,y) x>y, {1.1, 4.2}, {3.1, 2+3*i});
 %! assert (A, [false, true]);
 %!test
-%! A = cellfun (@(x,y) x>y, {1.1, 4.2; 2, 4}, {3.1, 2; 2, 4+2*i}, \
+%! A = cellfun (@(x,y) x>y, {1.1, 4.2; 2, 4}, {3.1, 2; 2, 4+2*i}, ...
 %!              "UniformOutput", true);
 %! assert (A, [false, true; false, false]);
 %!test
 %! A = cellfun (@(x,y) x:y, {1.1, 4}, {3.1, 6}, "UniformOutput", false);
 %! assert (isequal (A{1}, [1.1, 2.1, 3.1]));
 %! assert (isequal (A{2}, [4, 5, 6]));
 %!test %% Three ouptut arguments of different type
 %! [A, B, C] = cellfun (@find, {10, 11; 0, 12}, "UniformOutput", false);
 %! assert (isequal (A, {true, true; [], true}));
 %! assert (isequal (B, {true, true; [], true}));
 %! assert (isequal (C, {10, 11; [], 12}));
 %!test
-%! A = cellfun (@(x,y) cell2str (x,y), {1.1, 4}, {3.1, 6}, \
+%! A = cellfun (@(x,y) cell2str (x,y), {1.1, 4}, {3.1, 6}, ...
 %!              "ErrorHandler", @__cellfunerror);
 %! B = isfield (A(1), "message") && isfield (A(1), "index");
 %! assert ([(isfield (A(1), "identifier")), (isfield (A(2), "identifier"))], [true, true]);
 %! assert ([(isfield (A(1), "message")), (isfield (A(2), "message"))], [true, true]);
 %! assert ([(isfield (A(1), "index")), (isfield (A(2), "index"))], [true, true]);
 %! assert ([(isempty (A(1).message)), (isempty (A(2).message))], [false, false]);
 %! assert ([A(1).index, A(2).index], [1, 2]);
 %!test %% Overwriting setting of "UniformOutput" true
-%! A = cellfun (@(x,y) cell2str (x,y), {1.1, 4}, {3.1, 6}, \
+%! A = cellfun (@(x,y) cell2str (x,y), {1.1, 4}, {3.1, 6}, ...
 %!              "UniformOutput", true, "ErrorHandler", @__cellfunerror);
 %! B = isfield (A(1), "message") && isfield (A(1), "index");
 %! assert ([(isfield (A(1), "identifier")), (isfield (A(2), "identifier"))], [true, true]);
 %! assert ([(isfield (A(1), "message")), (isfield (A(2), "message"))], [true, true]);
 %! assert ([(isfield (A(1), "index")), (isfield (A(2), "index"))], [true, true]);
 %! assert ([(isempty (A(1).message)), (isempty (A(2).message))], [false, false]);
 %! assert ([A(1).index, A(2).index], [1, 2]);
 
@@ -907,25 +907,25 @@ v = cellfun (@@det, a); # faster\n\
 %! A = cellfun (@(x,y) x>y, {"ad", "c", "ghi"}, {"cc", "d", "fgh"});
 %!test
 %! A = cellfun (@(x,y) x>y, {"a"; "f"}, {"c"; "d"}, "UniformOutput", true);
 %! assert (A, [false; true]);
 %!test
 %! A = cellfun (@(x,y) x:y, {"a", "d"}, {"c", "f"}, "UniformOutput", false);
 %! assert (A, {"abc", "def"});
 %!test
-%! A = cellfun (@(x,y) cell2str (x,y), {"a", "d"}, {"c", "f"}, \
+%! A = cellfun (@(x,y) cell2str (x,y), {"a", "d"}, {"c", "f"}, ...
 %!              "ErrorHandler", @__cellfunerror);
 %! assert ([(isfield (A(1), "identifier")), (isfield (A(2), "identifier"))], [true, true]);
 %! assert ([(isfield (A(1), "message")), (isfield (A(2), "message"))], [true, true]);
 %! assert ([(isfield (A(1), "index")), (isfield (A(2), "index"))], [true, true]);
 %! assert ([(isempty (A(1).message)), (isempty (A(2).message))], [false, false]);
 %! assert ([A(1).index, A(2).index], [1, 2]);
 %!test %% Overwriting setting of "UniformOutput" true
-%! A = cellfun (@(x,y) cell2str (x,y), {"a", "d"}, {"c", "f"}, \
+%! A = cellfun (@(x,y) cell2str (x,y), {"a", "d"}, {"c", "f"}, ...
 %!              "UniformOutput", true, "ErrorHandler", @__cellfunerror);
 %! assert ([(isfield (A(1), "identifier")), (isfield (A(2), "identifier"))], [true, true]);
 %! assert ([(isfield (A(1), "message")), (isfield (A(2), "message"))], [true, true]);
 %! assert ([(isfield (A(1), "index")), (isfield (A(2), "index"))], [true, true]);
 %! assert ([(isempty (A(1).message)), (isempty (A(2).message))], [false, false]);
 %! assert ([A(1).index, A(2).index], [1, 2]);
 
 %% Structures cannot be handled by cellfun
@@ -933,67 +933,67 @@ v = cellfun (@@det, a); # faster\n\
 %! vst1.a = 1.1;  vst1.b = 4.2;  vst2.a = 3.1;  vst2.b = 2;
 %! A = cellfun (@(x,y) (x.a < y.a) && (x.b > y.b), vst1, vst2);
 
 %% Input arguments can be of type cell array of cell arrays
 %!test
 %! A = cellfun (@(x,y) x{1} < y{1}, {{1.1}, {4.2}}, {{3.1}, {2}});
 %! assert (A, [1, 0], 1e-16);
 %!test
-%! A = cellfun (@(x,y) x{1} < y{1}, {{1.1}; {4.2}}, {{3.1}; {2}}, \
+%! A = cellfun (@(x,y) x{1} < y{1}, {{1.1}; {4.2}}, {{3.1}; {2}}, ...
 %!              "UniformOutput", true);
 %! assert (A, [1; 0], 1e-16);
 %!test
-%! A = cellfun (@(x,y) x{1} < y{1}, {{1.1}, {4.2}}, {{3.1}, {2}}, \
+%! A = cellfun (@(x,y) x{1} < y{1}, {{1.1}, {4.2}}, {{3.1}, {2}}, ...
 %!              "UniformOutput", false);
 %! assert (A, {true, false});
 %!test
-%! A = cellfun (@(x,y) mat2str (x,y), {{1.1}, {4.2}}, {{3.1}, {2}}, \
+%! A = cellfun (@(x,y) mat2str (x,y), {{1.1}, {4.2}}, {{3.1}, {2}}, ...
 %!              "ErrorHandler", @__cellfunerror);
 %! assert ([(isfield (A(1), "identifier")), (isfield (A(2), "identifier"))], [true, true]);
 %! assert ([(isfield (A(1), "message")), (isfield (A(2), "message"))], [true, true]);
 %! assert ([(isfield (A(1), "index")), (isfield (A(2), "index"))], [true, true]);
 %! assert ([(isempty (A(1).message)), (isempty (A(2).message))], [false, false]);
 %! assert ([A(1).index, A(2).index], [1, 2]);
 %!test %% Overwriting setting of "UniformOutput" true
-%! A = cellfun (@(x,y) mat2str (x,y), {{1.1}, {4.2}}, {{3.1}, {2}}, \
+%! A = cellfun (@(x,y) mat2str (x,y), {{1.1}, {4.2}}, {{3.1}, {2}}, ...
 %!              "UniformOutput", true, "ErrorHandler", @__cellfunerror);
 %! assert ([(isfield (A(1), "identifier")), (isfield (A(2), "identifier"))], [true, true]);
 %! assert ([(isfield (A(1), "message")), (isfield (A(2), "message"))], [true, true]);
 %! assert ([(isfield (A(1), "index")), (isfield (A(2), "index"))], [true, true]);
 %! assert ([(isempty (A(1).message)), (isempty (A(2).message))], [false, false]);
 %! assert ([A(1).index, A(2).index], [1, 2]);
 
 %% Input arguments can be of type cell array of structure arrays
 %!test
 %! a = struct ("a", 1, "b", 2);  b = struct ("a", 1, "b", 3);
 %! A = cellfun (@(x,y) (x.a == y.a) && (x.b < y.b), {a}, {b});
 %! assert (A, true);
 %!test
 %! a = struct ("a", 1, "b", 2);  b = struct ("a", 1, "b", 3);
-%! A = cellfun (@(x,y) (x.a == y.a) && (x.b < y.b) , {a}, {b}, \
+%! A = cellfun (@(x,y) (x.a == y.a) && (x.b < y.b) , {a}, {b}, ...
 %!              "UniformOutput", true);
 %! assert (A, true);
 %!test
 %! a = struct ("a", 1, "b", 2);  b = struct ("a", 1, "b", 3);
-%! A = cellfun (@(x,y) (x.a == y.a) && (x.b < y.b) , {a}, {b}, \
+%! A = cellfun (@(x,y) (x.a == y.a) && (x.b < y.b) , {a}, {b}, ...
 %!              "UniformOutput", false);
 %! assert (A, {true});
 %!test
 %! a = struct ("a", 1, "b", 2);  b = struct ("a", 1, "b", 3);
-%! A = cellfun (@(x,y) cell2str (x.a, y.a), {a}, {b}, \
+%! A = cellfun (@(x,y) cell2str (x.a, y.a), {a}, {b}, ...
 %!              "ErrorHandler", @__cellfunerror);
 %! assert (isfield (A, "identifier"), true);
 %! assert (isfield (A, "message"), true);
 %! assert (isfield (A, "index"), true);
 %! assert (isempty (A.message), false);
 %! assert (A.index, 1);
 %!test %% Overwriting setting of "UniformOutput" true
 %! a = struct ("a", 1, "b", 2);  b = struct ("a", 1, "b", 3);
-%! A = cellfun (@(x,y) cell2str (x.a, y.a), {a}, {b}, \
+%! A = cellfun (@(x,y) cell2str (x.a, y.a), {a}, {b}, ...
 %!              "UniformOutput", true, "ErrorHandler", @__cellfunerror);
 %! assert (isfield (A, "identifier"), true);
 %! assert (isfield (A, "message"), true);
 %! assert (isfield (A, "index"), true);
 %! assert (isempty (A.message), false);
 %! assert (A.index, 1);
 
 %% A lot of other tests
@@ -1554,25 +1554,25 @@ arrayfun (@@str2num, [1234],\n\
 %! A = arrayfun (@(x) x, [false, true, false, true], "UniformOutput", false);
 %! assert (A, {false, true, false, true});
 %!test %% Three ouptut arguments of same type
 %! [A, B, C] = arrayfun (@find, [true, false; false, true], "UniformOutput", false);
 %! assert (isequal (A, {true, []; [], true}));
 %! assert (isequal (B, {true, []; [], true}));
 %! assert (isequal (C, {true, []; [], true}));
 %!test
-%! A = arrayfun (@(x,y) array2str (x,y), true, true, \
+%! A = arrayfun (@(x,y) array2str (x,y), true, true, ...
 %!               "ErrorHandler", @__arrayfunerror);
 %! assert (isfield (A, "identifier"), true);
 %! assert (isfield (A, "message"), true);
 %! assert (isfield (A, "index"), true);
 %! assert (isempty (A.message), false);
 %! assert (A.index, 1);
 %!test %% Overwriting setting of "UniformOutput" true
-%! A = arrayfun (@(x,y) array2str (x,y), true, true, "UniformOutput", true, \
+%! A = arrayfun (@(x,y) array2str (x,y), true, true, "UniformOutput", true, ...
 %!               "ErrorHandler", @__arrayfunerror);
 %! assert (isfield (A, "identifier"), true);
 %! assert (isfield (A, "message"), true);
 %! assert (isfield (A, "index"), true);
 %! assert (isempty (A.message), false);
 %! assert (A.index, 1);
 
 %% Input arguments can be of type numeric
@@ -1587,26 +1587,26 @@ arrayfun (@@str2num, [1234],\n\
 %! assert (isequal (A{1}, [1.1, 2.1, 3.1]));
 %! assert (isequal (A{2}, [4, 5, 6]));
 %!test %% Three ouptut arguments of different type
 %! [A, B, C] = arrayfun (@find, [10, 11; 0, 12], "UniformOutput", false);
 %! assert (isequal (A, {true, true; [], true}));
 %! assert (isequal (B, {true, true; [], true}));
 %! assert (isequal (C, {10, 11; [], 12}));
 %!test
-%! A = arrayfun (@(x,y) array2str (x,y), {1.1, 4}, {3.1, 6}, \
+%! A = arrayfun (@(x,y) array2str (x,y), {1.1, 4}, {3.1, 6}, ...
 %!               "ErrorHandler", @__arrayfunerror);
 %! B = isfield (A(1), "message") && isfield (A(1), "index");
 %! assert ([(isfield (A(1), "identifier")), (isfield (A(2), "identifier"))], [true, true]);
 %! assert ([(isfield (A(1), "message")), (isfield (A(2), "message"))], [true, true]);
 %! assert ([(isfield (A(1), "index")), (isfield (A(2), "index"))], [true, true]);
 %! assert ([(isempty (A(1).message)), (isempty (A(2).message))], [false, false]);
 %! assert ([A(1).index, A(2).index], [1, 2]);
 %!test %% Overwriting setting of "UniformOutput" true
-%! A = arrayfun (@(x,y) array2str (x,y), {1.1, 4}, {3.1, 6}, \
+%! A = arrayfun (@(x,y) array2str (x,y), {1.1, 4}, {3.1, 6}, ...
 %!               "UniformOutput", true, "ErrorHandler", @__arrayfunerror);
 %! B = isfield (A(1), "message") && isfield (A(1), "index");
 %! assert ([(isfield (A(1), "identifier")), (isfield (A(2), "identifier"))], [true, true]);
 %! assert ([(isfield (A(1), "message")), (isfield (A(2), "message"))], [true, true]);
 %! assert ([(isfield (A(1), "index")), (isfield (A(2), "index"))], [true, true]);
 %! assert ([(isempty (A(1).message)), (isempty (A(2).message))], [false, false]);
 %! assert ([A(1).index, A(2).index], [1, 2]);
 
@@ -1616,17 +1616,17 @@ arrayfun (@@str2num, [1234],\n\
 %! assert (A, [false, true, false, true, true, true]);
 %!test
 %! A = arrayfun (@(x,y) x>y, ["a"; "f"], ["c"; "d"], "UniformOutput", true);
 %! assert (A, [false; true]);
 %!test
 %! A = arrayfun (@(x,y) x:y, ["a", "d"], ["c", "f"], "UniformOutput", false);
 %! assert (A, {"abc", "def"});
 %!test
-%! A = arrayfun (@(x,y) cell2str (x,y), ["a", "d"], ["c", "f"], \
+%! A = arrayfun (@(x,y) cell2str (x,y), ["a", "d"], ["c", "f"], ...
 %!               "ErrorHandler", @__arrayfunerror);
 %! B = isfield (A(1), "identifier") && isfield (A(1), "message") && isfield (A(1), "index");
 %! assert (B, true);
 
 %% Input arguments can be of type structure
 %!test
 %! a = struct ("a", 1.1, "b", 4.2);  b = struct ("a", 3.1, "b", 2);
 %! A = arrayfun (@(x,y) (x.a < y.a) && (x.b > y.b), a, b);
@@ -1642,17 +1642,17 @@ arrayfun (@@str2num, [1234],\n\
 %!test
 %! A = arrayfun (@(x) mat2str(x), "a", "ErrorHandler", @__arrayfunerror);
 %! assert (isfield (A, "identifier"), true);
 %! assert (isfield (A, "message"), true);
 %! assert (isfield (A, "index"), true);
 %! assert (isempty (A.message), false);
 %! assert (A.index, 1);
 %!test %% Overwriting setting of "UniformOutput" true
-%! A = arrayfun (@(x) mat2str(x), "a", "UniformOutput", true, \
+%! A = arrayfun (@(x) mat2str(x), "a", "UniformOutput", true, ...
 %!               "ErrorHandler", @__arrayfunerror);
 %! assert (isfield (A, "identifier"), true);
 %! assert (isfield (A, "message"), true);
 %! assert (isfield (A, "index"), true);
 %! assert (isempty (A.message), false);
 %! assert (A.index, 1);
 
 %% Input arguments can be of type cell array
@@ -1668,17 +1668,17 @@ arrayfun (@@str2num, [1234],\n\
 %!test
 %! A = arrayfun (@(x,y) num2str(x,y), {1.1, 4.2}, {3.1, 2}, "ErrorHandler", @__arrayfunerror);
 %! assert ([(isfield (A(1), "identifier")), (isfield (A(2), "identifier"))], [true, true]);
 %! assert ([(isfield (A(1), "message")), (isfield (A(2), "message"))], [true, true]);
 %! assert ([(isfield (A(1), "index")), (isfield (A(2), "index"))], [true, true]);
 %! assert ([(isempty (A(1).message)), (isempty (A(2).message))], [false, false]);
 %! assert ([A(1).index, A(2).index], [1, 2]);
 %!test
-%! A = arrayfun (@(x,y) num2str (x,y), {1.1, 4.2}, {3.1, 2}, \
+%! A = arrayfun (@(x,y) num2str (x,y), {1.1, 4.2}, {3.1, 2}, ...
 %!               "UniformOutput", true, "ErrorHandler", @__arrayfunerror);
 %! assert ([(isfield (A(1), "identifier")), (isfield (A(2), "identifier"))], [true, true]);
 %! assert ([(isfield (A(1), "message")), (isfield (A(2), "message"))], [true, true]);
 %! assert ([(isfield (A(1), "index")), (isfield (A(2), "index"))], [true, true]);
 %! assert ([(isempty (A(1).message)), (isempty (A(2).message))], [false, false]);
 %! assert ([A(1).index, A(2).index], [1, 2]);
 */
 
diff --git a/scripts/help/__unimplemented__.m b/scripts/help/__unimplemented__.m
--- a/scripts/help/__unimplemented__.m
+++ b/scripts/help/__unimplemented__.m
@@ -36,84 +36,84 @@ function txt = __unimplemented__ (fcn)
     print_usage ();
   endif
 
   is_matlab_function = true;
 
   ## Some smarter cases, add more as needed.
   switch (fcn)
     case {"avifile", "aviinfo", "aviread"}
-      txt = ["Basic video file support is provided in the video package.  ", \
+      txt = ["Basic video file support is provided in the video package.  ", ...
              "See @url{http://octave.sf.net/video/}."];
 
     case "gsvd"
-      txt = ["gsvd is not currently part of core Octave.  ", \
-             "See the linear-algebra package at ", \
+      txt = ["gsvd is not currently part of core Octave.  ", ...
+             "See the linear-algebra package at ", ...
              "@url{http://octave.sourceforge.net/linear-algebra/}."];
 
     case "funm"
-      txt = ["funm is not currently part of core Octave.  ", \
-             "See the linear-algebra package at ", \
+      txt = ["funm is not currently part of core Octave.  ", ...
+             "See the linear-algebra package at ", ...
              "@url{http://octave.sourceforge.net/linear-algebra/}."];
 
     case "griddedInterpolant"
-      txt = ["griddedInterpolant is not implemented.  ", \
+      txt = ["griddedInterpolant is not implemented.  ", ...
              "Consider using griddata."];
 
     case "integral"
-      txt = ["Octave provides many routines for 1-D numerical integration.  ", \
+      txt = ["Octave provides many routines for 1-D numerical integration.  ", ...
              "Consider quadcc, quad, quadv, quadl, quadgk."];
 
     case "integral2"
       txt = ["integral2 is not implemented.  Consider using dblquad."];
 
     case "integral3"
       txt = ["integral3 is not implemented.  Consider using triplequad"];
 
     case "linprog"
-      txt = ["Octave does not currently provide linprog.  ", \
-             "Linear programming problems may be solved using @code{glpk}.  ",\
+      txt = ["Octave does not currently provide linprog.  ", ...
+             "Linear programming problems may be solved using @code{glpk}.  ", ...
              "Try @code{help glpk} for more info."];
 
     case "matlabrc"
-      txt = ["matlabrc is not implemented.  ", \
+      txt = ["matlabrc is not implemented.  ", ...
              'Octave uses the file ".octaverc" instead.'];
 
-    case {"ode113", "ode15i", "ode15s", "ode23", "ode23s", "ode23t", \
+    case {"ode113", "ode15i", "ode15s", "ode23", "ode23s", "ode23t", ...
           "ode23tb", "ode45", "odeget", "odeset"}
-      txt = ["Octave provides lsode for solving differential equations.  ", \
-             "For more information try @code{help lsode}.  ", \
-             "Matlab-compatible ODE functions are provided by the odepkg ", \
+      txt = ["Octave provides lsode for solving differential equations.  ", ...
+             "For more information try @code{help lsode}.  ", ...
+             "Matlab-compatible ODE functions are provided by the odepkg ", ...
              "package.  See @url{http://octave.sourceforge.net/odepkg/}."];
 
     case "startup"
-      txt = ["startup is not implemented.  ", \
+      txt = ["startup is not implemented.  ", ...
              'Octave uses the file ".octaverc" instead.'];
 
     case "quad2d"
       txt = ["quad2d is not implemented.  Consider using dblquad."];
 
     case {"xlsread", "xlsfinfo", "xlswrite", "wk1read", "wk1finfo", "wk1write"}
-      txt = ["Functions for spreadsheet style I/O ", \
-             "(.xls .xlsx .sxc .ods .dbf .wk1 etc.) " ,  \
-             "are provided in the io package. ", \
+      txt = ["Functions for spreadsheet style I/O ", ...
+             "(.xls .xlsx .sxc .ods .dbf .wk1 etc.) " , ...
+             "are provided in the io package. ", ...
              "See @url{http://octave.sf.net/io/}."];
 
     otherwise
       if (ismember (fcn, missing_functions ()))
         txt = ["the '" fcn "' function is not yet implemented in Octave"];
       else
         is_matlab_function = false;
         txt = "";
       endif
   endswitch
 
   if (is_matlab_function)
-    txt = [txt, "\n\n@noindent\nPlease read ", \
-           "@url{http://www.octave.org/missing.html} to learn how ", \
+    txt = [txt, "\n\n@noindent\nPlease read ", ...
+           "@url{http://www.octave.org/missing.html} to learn how ", ...
            "you can contribute missing functionality."];
     txt = __makeinfo__ (txt);
   endif
 
   if (nargout == 0)
     warning ("Octave:missing-function", "%s", txt);
   endif
 
diff --git a/scripts/io/importdata.m b/scripts/io/importdata.m
--- a/scripts/io/importdata.m
+++ b/scripts/io/importdata.m
@@ -120,18 +120,18 @@ function [output, delimiter, header_rows
   ## Make sure file extension is in lower case.
   fileExt = lower (fileExt);
 
   switch (fileExt)
     case {".au", ".snd"}
       error ("importdata: not implemented for file format %s", fileExt);
     case ".avi"
       error ("importdata: not implemented for file format %s", fileExt);
-    case {".bmp", ".cur", ".gif", ".hdf", ".ico", ".jpe", ".jpeg", ".jpg", \
-          ".pbm", ".pcx", ".pgm", ".png", ".pnm", ".ppm", ".ras", \
+    case {".bmp", ".cur", ".gif", ".hdf", ".ico", ".jpe", ".jpeg", ".jpg", ...
+          ".pbm", ".pcx", ".pgm", ".png", ".pnm", ".ppm", ".ras", ...
           ".tif", ".tiff", ".xwd"}
       delimiter  = NaN;
       header_rows = 0;
       [output.cdata, output.colormap, output.alpha] = imread (fname);
     case ".mat"
       delimiter  = NaN;
       header_rows = 0;
       output = load (fname);
@@ -147,17 +147,17 @@ function [output, delimiter, header_rows
         output = xlsread (fname);
       end_try_catch
     case {".wav", ".wave"}
       delimiter  = NaN;
       header_rows = 0;
       [output.data, output.fs] = wavread (fname);
     otherwise
       ## Assume the file is in ascii format.
-      [output, delimiter, header_rows]  = \
+      [output, delimiter, header_rows]  = ...
           importdata_ascii (fname, delimiter, header_rows);
   endswitch
 
   ## If there are any empty fields in the output structure, then remove them
   if (isstruct (output) && length (output) == 1)
     fields = fieldnames (output);
     for i=1:length (fields)
       if (isempty (getfield (output, fields{i})))
@@ -174,17 +174,17 @@ function [output, delimiter, header_rows
       output = getfield (output, fields{1});
     endif
   endif
 endfunction
 
 
 ########################################
 
-function [output, delimiter, header_rows] = \
+function [output, delimiter, header_rows] = ...
       importdata_ascii (fname, delimiter, header_rows)
 
   ## Define the fields in the output structure so that the order will be
   ## correct.
 
   output.data       = [];
   output.textdata   = [];
   output.rowheaders = [];
@@ -234,17 +234,17 @@ function [output, delimiter, header_rows
       file_content_rows{i} = strtrim (file_content_rows{i});
     endfor
   endif
 
   ## Remove empty data rows. Go through them backwards so that you wont
   ## get out of bounds.
   for i=length (file_content_rows):-1:(header_rows + 1)
     if (length (file_content_rows{i}) < 1)
-      file_content_rows = [file_content_rows(1:i-1), \
+      file_content_rows = [file_content_rows(1:i-1), ...
                            file_content_rows(i+1:length(file_content_rows))];
     endif
   endfor
 
   ## Count the number of data columns. If there are different number of
   ## columns, use the greatest value.
   data_columns = 0;
   delimiter_pattern = delimiter;
@@ -348,17 +348,17 @@ endfunction
 %! unlink (fn);
 %! assert (a, A);
 %! assert (d, " ");
 %! assert (h, 0);
 
 %!test
 %! # Header
 %! A.data = [3.1 -7.2 0; 0.012 6.5 128];
-%! A.textdata = {"This is a header row."; \
+%! A.textdata = {"This is a header row."; ...
 %!               "this row does not contain any data, but the next one does."};
 %! fn  = tmpnam ();
 %! fid = fopen (fn, "w");
 %! fputs (fid, [A.textdata{1} "\n"]);
 %! fputs (fid, [A.textdata{2} "\n"]);
 %! fputs (fid, "3.1\t-7.2\t0\n0.012\t6.5\t128");
 %! fclose (fid);
 %! [a,d,h] = importdata (fn, "\\t");
diff --git a/scripts/io/textscan.m b/scripts/io/textscan.m
--- a/scripts/io/textscan.m
+++ b/scripts/io/textscan.m
@@ -271,17 +271,17 @@ function [C, position] = textscan (fid, 
         endif
       endwhile
       ## OK, found EOL delimiting last requested line. Compute ptr (incl. EOL)
       if (isempty (eoi))
         printf ("textscan: format repeat count specified but no endofline found\n");
         data_size = nblks * BUFLENGTH + count;
       else
         ## Compute data size to read incl complete EOL
-        data_size = (nblks * BUFLENGTH) + eoi(end + min (nlines, n_eoi) - n_eoi) \
+        data_size = (nblks * BUFLENGTH) + eoi(end + min (nlines, n_eoi) - n_eoi) ...
                     + l_eol_char - 1;
       endif
       fseek (fid, st_pos, "bof");
       str = fscanf (fid, "%c", data_size);
     else
       fseek (fid, st_pos, "bof");
       str = fread (fid, "char=>char").';
     endif
diff --git a/scripts/miscellaneous/edit.m b/scripts/miscellaneous/edit.m
--- a/scripts/miscellaneous/edit.m
+++ b/scripts/miscellaneous/edit.m
@@ -463,41 +463,41 @@ SUCH DAMAGE.\
           comment = ["/*\n\n", head, "\n\n", tail, "\n\n*/\n\n"];
         endif
         ## If we are shadowing an m-file, paste the code for the m-file.
         if (any (exists == [2, 103]))
           code = ['\ ', strrep(type(name){1}, "\n", "\n// ")];
         else
           code = " ";
         endif
-        body = ["#include <octave/oct.h>\n\n",               \
-                "DEFUN_DLD(" name ", args, nargout, \"\\\n", \
-                name, "\\n\\\n\")\n{\n",                     \
-                "  octave_value_list retval;\n",             \
-                "  int nargin = args.length ();\n\n",        \
+        body = ["#include <octave/oct.h>\n\n",               ...
+                "DEFUN_DLD(" name ", args, nargout, \"\\\n", ...
+                name, "\\n\\\n\")\n{\n",                     ...
+                "  octave_value_list retval;\n",             ...
+                "  int nargin = args.length ();\n\n",        ...
                 code, "\n  return retval;\n}\n"];
 
         text = [comment, body];
       case "m"
         ## If we are editing a function defined on the fly, paste the code.
         if (any (exists == [2, 103]))
           body = type (name){1};
         else
           body = ["function [retval] = " name " ()\n\nendfunction\n"];
         endif
         if (isempty (head))
-          comment = ["## -*- texinfo -*- \n## @deftypefn {Function File} " \
-                     "{@var{retval} =} " name " (@var{x}, @var{y})\n##\n"  \
-                     "## @seealso{}\n## @end deftypefn\n\n"                \
+          comment = ["## -*- texinfo -*- \n## @deftypefn {Function File} " ...
+                     "{@var{retval} =} " name " (@var{x}, @var{y})\n##\n"  ...
+                     "## @seealso{}\n## @end deftypefn\n\n"                ...
                      "## " strrep(tail, "\n", "\n## ") "\n\n"];
         else
-          comment = ["## " strrep(head,"\n","\n## ") "\n\n"                \
-                     "## -*- texinfo -*- \n## @deftypefn {Function File} " \
-                     "{@var{retval} =} " name " (@var{x} @var{y})\n##\n"   \
-                     "## @seealso{}\n## @end deftypefn\n\n"                \
+          comment = ["## " strrep(head,"\n","\n## ") "\n\n"                ...
+                     "## -*- texinfo -*- \n## @deftypefn {Function File} " ...
+                     "{@var{retval} =} " name " (@var{x} @var{y})\n##\n"   ...
+                     "## @seealso{}\n## @end deftypefn\n\n"                ...
                      "## " strrep(tail, "\n", "\n## ") "\n\n"];
         endif
         text = [comment, body];
     endswitch
 
     ## Write the initial file (if there is anything to write)
     fid = fopen (fileandpath, "wt");
     if (fid < 0)
diff --git a/scripts/optimization/fsolve.m b/scripts/optimization/fsolve.m
--- a/scripts/optimization/fsolve.m
+++ b/scripts/optimization/fsolve.m
@@ -129,17 +129,17 @@
 
 ## PKG_ADD: ## Discard result to avoid polluting workspace with ans at startup.
 ## PKG_ADD: [~] = __all_opts__ ("fsolve");
 
 function [x, fvec, info, output, fjac] = fsolve (fcn, x0, options = struct ())
 
   ## Get default options if requested.
   if (nargin == 1 && ischar (fcn) && strcmp (fcn, 'defaults'))
-    x = optimset ("MaxIter", 400, "MaxFunEvals", Inf, \
+    x = optimset ("MaxIter", 400, "MaxFunEvals", Inf, ...
     "Jacobian", "off", "TolX", 1e-7, "TolFun", 1e-7,
     "OutputFcn", [], "Updating", "on", "FunValCheck", "off",
     "ComplexEqn", "off", "FinDiffType", "central",
     "TypicalX", [], "AutoScaling", "off");
     return;
   endif
 
   if (nargin < 2 || nargin > 3 || ! ismatrix (x0))
diff --git a/scripts/optimization/sqp.m b/scripts/optimization/sqp.m
--- a/scripts/optimization/sqp.m
+++ b/scripts/optimization/sqp.m
@@ -420,18 +420,18 @@ function [x, obj, info, iter, nf, lambda
         warning (id, "sqp: QP subproblem failed to converge in %d iterations",
                  INFO.solveiter);
       case 6
         warning (id, "sqp: QP subproblem is infeasible");
     endswitch
 
     ## Choose mu such that p is a descent direction for the chosen
     ## merit function phi.
-    [x_new, alpha, obj_new, globals] = \
-        linesearch_L1 (x, p, obj_fun, obj_grd, ce_fun, ci_fun, lambda, \
+    [x_new, alpha, obj_new, globals] = ...
+        linesearch_L1 (x, p, obj_fun, obj_grd, ce_fun, ci_fun, lambda, ...
                        obj, globals);
 
     ## Evaluate objective function, constraints, and gradients at x_new.
     c_new = feval (obj_grd, x_new);
 
     ce_new = feval (ce_fun, x_new);
     F_new = feval (ce_grd, x_new);
 
@@ -515,17 +515,17 @@ function [x, obj, info, iter, nf, lambda
     info = 103;
   endif
 
   nf = globals.nfun;
 
 endfunction
 
 
-function [merit, obj, globals] = phi_L1 (obj, obj_fun, ce_fun, ci_fun, \
+function [merit, obj, globals] = phi_L1 (obj, obj_fun, ce_fun, ci_fun, ...
                                          x, mu, globals)
 
   ce = feval (ce_fun, x);
   ci = feval (ci_fun, x);
 
   idx = ci < 0;
 
   con = [ce; ci(idx)];
@@ -540,18 +540,18 @@ function [merit, obj, globals] = phi_L1 
 
   if (! isempty (t))
     merit += t;
   endif
 
 endfunction
 
 
-function [x_new, alpha, obj, globals] = \
-      linesearch_L1 (x, p, obj_fun, obj_grd, ce_fun, ci_fun, lambda, \
+function [x_new, alpha, obj, globals] = ...
+      linesearch_L1 (x, p, obj_fun, obj_grd, ce_fun, ci_fun, lambda, ...
                      obj, globals)
 
   ## Choose parameters
   ##
   ## eta in the range (0, 0.5)
   ## tau in the range (0, 1)
 
   eta = 0.25;
@@ -565,31 +565,31 @@ function [x_new, alpha, obj, globals] = 
     mu = 1 / (norm (lambda, Inf) + delta_bar);
   endif
 
   alpha = 1;
 
   c = feval (obj_grd, x);
   ce = feval (ce_fun, x);
 
-  [phi_x_mu, obj, globals] = phi_L1 (obj, obj_fun, ce_fun, ci_fun, x, \
+  [phi_x_mu, obj, globals] = phi_L1 (obj, obj_fun, ce_fun, ci_fun, x, ...
                                      mu, globals);
 
   D_phi_x_mu = c' * p;
   d = feval (ci_fun, x);
   ## only those elements of d corresponding
   ## to violated constraints should be included.
   idx = d < 0;
   t = - norm ([ce; d(idx)], 1) / mu;
   if (! isempty (t))
     D_phi_x_mu += t;
   endif
 
   while (1)
-    [p1, obj, globals] = phi_L1 ([], obj_fun, ce_fun, ci_fun, \
+    [p1, obj, globals] = phi_L1 ([], obj_fun, ce_fun, ci_fun, ...
                                  x+alpha*p, mu, globals);
     p2 = phi_x_mu+eta*alpha*D_phi_x_mu;
     if (p1 > p2)
       ## Reset alpha = tau_alpha * alpha for some tau_alpha in the
       ## range (0, tau).
       tau_alpha = 0.9 * tau;  # ??
       alpha = tau_alpha * alpha;
     else
diff --git a/scripts/plot/__gnuplot_drawnow__.m b/scripts/plot/__gnuplot_drawnow__.m
--- a/scripts/plot/__gnuplot_drawnow__.m
+++ b/scripts/plot/__gnuplot_drawnow__.m
@@ -291,19 +291,19 @@ function enhanced = gnuplot_set_term (pl
         ## size_str comes after other options to permit specification of
         ## the canvas size for terminals cdr/corel.
         term_str = [term_str " " size_str];
       endif
     endif
     if (! __gnuplot_has_feature__ ("has_termoption_dashed"))
       ## If "set termoption dashed" isn't available add "dashed" option
       ## to the "set terminal ..." command, if it is supported.
-      if (any (strcmp (term, {"aqua", "cgm", "eepic", "emf", "epslatex", \
-                              "fig", "pcl5", "mp", "next", "openstep", "pdf", \
-                              "pdfcairo", "pngcairo", "postscript", \
+      if (any (strcmp (term, {"aqua", "cgm", "eepic", "emf", "epslatex", ...
+                              "fig", "pcl5", "mp", "next", "openstep", "pdf", ...
+                              "pdfcairo", "pngcairo", "postscript", ...
                               "pslatex", "pstext", "svg", "tgif", "x11"})))
         term_str = [term_str " dashed"];
       endif
     end
     if (any (strcmp (term, {"aqua", "wxt"})))
       term_str = [term_str, " ", "dashlength 1"];
     elseif (any (strcmp (term, {"epslatex", "postscript", "pslatex"})))
       term_str = [term_str, " ", "dashlength 2"];
diff --git a/scripts/plot/private/__marching_cube__.m b/scripts/plot/private/__marching_cube__.m
--- a/scripts/plot/private/__marching_cube__.m
+++ b/scripts/plot/private/__marching_cube__.m
@@ -61,17 +61,17 @@
 ## @end example
 ##
 ## Instead of the @command{trimesh} function the @command{patch}
 ## function can be used to visualize the geometry.  For example:
 ##
 ## @example
 ## @group
 ## figure (); view (-38, 20);
-## pa = patch ("Faces", t, "Vertices", p, "FaceVertexCData", p, \
+## pa = patch ("Faces", t, "Vertices", p, "FaceVertexCData", p, ...
 ##             "FaceColor", "interp", "EdgeColor", "none");
 ##
 ## ## Revert normals
 ## set (pa, "VertexNormals", -get (pa, "VertexNormals"));
 ##
 ## ## Set lightning (available with the JHandles package)
 ## # set (pa, "FaceLighting", "gouraud");
 ## # light ( "Position", [1 1 5]);
diff --git a/scripts/plot/stemleaf.m b/scripts/plot/stemleaf.m
--- a/scripts/plot/stemleaf.m
+++ b/scripts/plot/stemleaf.m
@@ -331,22 +331,22 @@ endfunction
 
 %!demo
 %! %% Gaussian leaves:
 %! x = fix (30 * randn (300,1));
 %! stemleaf (x, 'Gaussian leaves');
 
 %!test
 %! ## test minus to plus
-%! x = [-22 12 -28 52  39 -2 12 10 11 11 42 38 44 18 44 37 113 124 37 48 127  \
-%!      36 29 31 125 139 131 115 105 132 104 123 35 113 122 42 117 119 58 109 \
-%!      23 105 63 27 44 105 99 41 128 121 116 125 32 61 37 127 29 113 121 58  \
-%!      114 126 53 114 96 25 109 7 31 141 46 -13 71 43 117 116 27 7 68 40 31  \
-%!      115 124 42 128 52 71 118 117 38 27 106 33 117 116 111 40 119 47 105 57\
-%!      122 109 124 115 43 120 43 27 27 18 28 48 125 107 114 34 133 45 120 30 \
+%! x = [-22 12 -28 52  39 -2 12 10 11 11 42 38 44 18 44 37 113 124 37 48 127   ...
+%!      36 29 31 125 139 131 115 105 132 104 123 35 113 122 42 117 119 58 109  ...
+%!      23 105 63 27 44 105 99 41 128 121 116 125 32 61 37 127 29 113 121 58   ...
+%!      114 126 53 114 96 25 109 7 31 141 46 -13 71 43 117 116 27 7 68 40 31   ...
+%!      115 124 42 128 52 71 118 117 38 27 106 33 117 116 111 40 119 47 105 57 ...
+%!      122 109 124 115 43 120 43 27 27 18 28 48 125 107 114 34 133 45 120 30  ...
 %!      127 31 116 146 21 23 30 10 20 21 30 0 100 110 1 20 0];
 %! x = sort (x);
 %! rexp = char (
 %! "       Data: test minus to plus"    ,
 %! " "                                  ,
 %! "         Fenced Letter Display"     ,
 %! " "                                  ,
 %! "     #138|___________________"      ,     
diff --git a/scripts/polynomial/polyfit.m b/scripts/polynomial/polyfit.m
--- a/scripts/polynomial/polyfit.m
+++ b/scripts/polynomial/polyfit.m
@@ -166,20 +166,20 @@ endfunction
 %!fail ("polyfit (x, x.^2+x+1)")
 %!fail ("polyfit (x, x.^2+x+1, [])")
 
 ## Test difficult case where scaling is really needed. This example
 ## demonstrates the rather poor result which occurs when the dependent
 ## variable is not normalized properly.
 ## Also check the usage of 2nd & 3rd output arguments.
 %!test
-%! x = [ -1196.4, -1195.2, -1194, -1192.8, -1191.6, -1190.4, -1189.2, -1188, \
+%! x = [ -1196.4, -1195.2, -1194, -1192.8, -1191.6, -1190.4, -1189.2, -1188, ...
 %!       -1186.8, -1185.6, -1184.4, -1183.2, -1182];
-%! y = [ 315571.7086, 315575.9618, 315579.4195, 315582.6206, 315585.4966,    \
-%!       315588.3172, 315590.9326, 315593.5934, 315596.0455, 315598.4201,    \
+%! y = [ 315571.7086, 315575.9618, 315579.4195, 315582.6206, 315585.4966, ...
+%!       315588.3172, 315590.9326, 315593.5934, 315596.0455, 315598.4201, ...
 %!       315600.7143, 315602.9508, 315605.1765 ];
 %! [p1, s1] = polyfit (x, y, 10);
 %! [p2, s2, mu] = polyfit (x, y, 10);
 %! assert (s2.normr < s1.normr);
 
 %!test
 %! x = 1:4;
 %! p0 = [1i, 0, 2i, 4];
diff --git a/scripts/statistics/tests/z_test.m b/scripts/statistics/tests/z_test.m
--- a/scripts/statistics/tests/z_test.m
+++ b/scripts/statistics/tests/z_test.m
@@ -73,15 +73,15 @@ function [pval, z] = z_test (x, m, v, al
     pval = 1 - cdf;
   elseif (strcmp (alt, "<"))
     pval = cdf;
   else
     error ("z_test: option %s not recognized", alt);
   endif
 
   if (nargout == 0)
-    s = ["Z-test of mean(x) == %g against mean(x) %s %g,\n", \
-         "with known var(x) == %g:\n",                       \
+    s = ["Z-test of mean(x) == %g against mean(x) %s %g,\n", ...
+         "with known var(x) == %g:\n",                       ...
          "  pval = %g\n");
     printf (s, m, alt, m, v, pval);
   endif
 
 endfunction
diff --git a/scripts/statistics/tests/z_test_2.m b/scripts/statistics/tests/z_test_2.m
--- a/scripts/statistics/tests/z_test_2.m
+++ b/scripts/statistics/tests/z_test_2.m
@@ -73,16 +73,16 @@ function [pval, z] = z_test_2 (x, y, v_x
     pval = 1 - cdf;
   elseif (strcmp (alt, "<"))
     pval = cdf;
   else
     error ("z_test_2: option %s not recognized", alt);
   endif
 
   if (nargout == 0)
-    s = ["Two-sample Z-test of mean(x) == mean(y) against ", \
-         "mean(x) %s mean(y),\n",                            \
-         "with known var(x) == %g and var(y) == %g:\n",      \
+    s = ["Two-sample Z-test of mean(x) == mean(y) against ", ...
+         "mean(x) %s mean(y),\n",                            ...
+         "with known var(x) == %g and var(y) == %g:\n",      ...
          "  pval = %g\n"];
     printf (s, alt, v_x, v_y, pval);
   endif
 
 endfunction
diff --git a/scripts/testfun/test.m b/scripts/testfun/test.m
--- a/scripts/testfun/test.m
+++ b/scripts/testfun/test.m
@@ -429,17 +429,17 @@ function [__ret1, __ret2, __ret3, __ret4
               [~, __err] = lastwarn ();
               __mismatch = ! strcmp (__err, __id);
             else
               __err = trimerr (lastwarn (), "warning");
               __mismatch = isempty (regexp (__err, __pattern, "once"));
             endif
             warning (__warnstate.state, "quiet");
             if (isempty (__err))
-              __msg = sprintf (["%swarning failed.\n" \
+              __msg = sprintf (["%swarning failed.\n" ...
                                 "Expected %s but got no warning\n"],
                                __signal_fail, __patstr);
             elseif (__mismatch)
               __msg = sprintf ("%swarning failed.\nExpected %s but got <%s>\n",
                                __signal_fail, __patstr, __err);
             else
               __success = 1;
             endif
@@ -450,17 +450,17 @@ function [__ret1, __ret2, __ret3, __ret4
             [~, __err] = lasterr ();
             __mismatch = ! strcmp (__err, __id);
           else
             __err = trimerr (lasterr (), "error");
             __mismatch = isempty (regexp (__err, __pattern, "once"));
           endif
           warning (__warnstate.state, "quiet");
           if (__warning)
-            __msg = sprintf (["%swarning failed.\n" \
+            __msg = sprintf (["%swarning failed.\n" ...
                               "Expected warning %s but got error <%s>\n"],
                              __signal_fail, __patstr, __err);
           elseif (__mismatch)
             __msg = sprintf ("%serror failed.\nExpected %s but got <%s>\n",
                              __signal_fail, __patstr, __err);
           else
             __success = 1;
           endif
