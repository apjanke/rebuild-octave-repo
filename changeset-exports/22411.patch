# HG changeset patch
# User Rik <rik@octave.org>
# Date 1472671246 25200
#      Wed Aug 31 12:20:46 2016 -0700
# Node ID c69805d1fa643e94e4de25c43f8e9f78f614c7be
# Parent  bc38c1ff6698abbc1ef33e6b7c24f15e5f4075b2
maint: Style check C++ code in libgui/

* Backend.cc, Backend.h, BaseControl.cc, BaseControl.h, ButtonControl.cc,
ButtonControl.h, ButtonGroup.cc, ButtonGroup.h, Canvas.cc, Canvas.h,
CheckBoxControl.cc, CheckBoxControl.h, Container.cc, Container.h,
ContextMenu.cc, ContextMenu.h, EditControl.cc, EditControl.h, Figure.cc,
Figure.h, FigureWindow.cc, FigureWindow.h, GLCanvas.cc, GLCanvas.h,
GenericEventNotify.h, KeyMap.cc, KeyMap.h, ListBoxControl.cc, ListBoxControl.h,
Logger.cc, Logger.h, Menu.cc, Menu.h, MenuContainer.h, MouseModeActionGroup.cc,
MouseModeActionGroup.h, Object.cc, Object.h, ObjectFactory.cc, ObjectFactory.h,
ObjectProxy.cc, ObjectProxy.h, Panel.cc, Panel.h, PopupMenuControl.cc,
PopupMenuControl.h, PushButtonControl.cc, PushButtonControl.h, PushTool.cc,
PushTool.h, QtHandlesUtils.cc, QtHandlesUtils.h, RadioButtonControl.cc,
RadioButtonControl.h, SliderControl.cc, SliderControl.h, TextControl.cc,
TextControl.h, TextEdit.cc, TextEdit.h, ToggleButtonControl.cc,
ToggleButtonControl.h, ToggleTool.cc, ToggleTool.h, ToolBar.cc, ToolBar.h,
ToolBarButton.cc, ToolBarButton.h, __init_qt__.cc, __init_qt__.h,
annotation-dialog.cc, annotation-dialog.h, gl-select.cc, gl-select.h,
color-picker.cc, color-picker.h, dialog.h, documentation-dock-widget.cc,
documentation-dock-widget.h, files-dock-widget.cc, files-dock-widget.h,
find-files-dialog.h, find-files-model.cc, find-files-model.h,
history-dock-widget.cc, history-dock-widget.h, liboctgui-build-info.h,
liboctgui-build-info.in.cc, file-editor-interface.h, file-editor-tab.cc,
file-editor-tab.h, file-editor.cc, file-editor.h, find-dialog.cc,
find-dialog.h, marker.cc, marker.h, octave-qscintilla.cc, octave-qscintilla.h,
octave-txt-lexer.cc, octave-txt-lexer.h, main-window.cc, main-window.h,
octave-cmd.cc, octave-cmd.h, octave-dock-widget.cc, octave-dock-widget.h,
octave-gui.cc, octave-gui.h, octave-interpreter.cc, octave-interpreter.h,
octave-qt-link.cc, octave-qt-link.h, parser.cc, parser.h, webinfo.cc,
webinfo.h, resource-manager.cc, resource-manager.h, settings-dialog.cc,
settings-dialog.h, shortcut-manager.cc, shortcut-manager.h,
terminal-dock-widget.h, thread-manager.cc, thread-manager.h, welcome-wizard.cc,
welcome-wizard.h, workspace-model.cc, workspace-model.h, workspace-view.cc,
workspace-view.h:
Style check C++ code in libgui/

diff --git a/libgui/graphics/Backend.cc b/libgui/graphics/Backend.cc
--- a/libgui/graphics/Backend.cc
+++ b/libgui/graphics/Backend.cc
@@ -43,186 +43,187 @@ along with Octave; see the file COPYING.
 # define OCTAVE_PTR_TYPE octave_uint64
 # define OCTAVE_INTPTR_TYPE uint64_t
 # define OCTAVE_PTR_SCALAR uint64_scalar_value
 //#endif
 
 namespace QtHandles
 {
 
-static std::string
-toolkitObjectProperty (const graphics_object& go)
-{
-  if (go.isa ("figure"))
-    return std::string ("__plot_stream__");
-  else if (go.isa ("uicontrol")
-           || go.isa ("uipanel")
-           || go.isa ("uibuttongroup")
-           || go.isa ("uimenu")
-           || go.isa ("uicontextmenu")
-           || go.isa ("uitoolbar")
-           || go.isa ("uipushtool")
-           || go.isa ("uitoggletool"))
-    return std::string ("__object__");
-  else
-    qCritical ("QtHandles::Backend: no __object__ property known for object "
-               "of type %s", go.type ().c_str ());
+  static std::string
+  toolkitObjectProperty (const graphics_object& go)
+  {
+    if (go.isa ("figure"))
+      return std::string ("__plot_stream__");
+    else if (go.isa ("uicontrol")
+             || go.isa ("uipanel")
+             || go.isa ("uibuttongroup")
+             || go.isa ("uimenu")
+             || go.isa ("uicontextmenu")
+             || go.isa ("uitoolbar")
+             || go.isa ("uipushtool")
+             || go.isa ("uitoggletool"))
+      return std::string ("__object__");
+    else
+      qCritical ("QtHandles::Backend: no __object__ property known for object "
+                 "of type %s", go.type ().c_str ());
 
-  return "";
-}
+    return "";
+  }
 
-Backend::Backend (void)
-  : QObject (), base_graphics_toolkit ("qt")
-{
-  ObjectFactory* factory = ObjectFactory::instance ();
+  Backend::Backend (void)
+    : QObject (), base_graphics_toolkit ("qt")
+  {
+    ObjectFactory* factory = ObjectFactory::instance ();
 
-  connect (this, SIGNAL (createObject (double)),
-           factory, SLOT (createObject (double)));
-}
+    connect (this, SIGNAL (createObject (double)),
+             factory, SLOT (createObject (double)));
+  }
 
-Backend::~Backend (void)
-{
-}
+  Backend::~Backend (void)
+  {
+  }
 
-bool
-Backend::initialize (const graphics_object& go)
-{
-  if (go.isa ("figure")
-      || go.isa ("uicontrol")
-      || go.isa ("uipanel")
-      || go.isa ("uibuttongroup")
-      || go.isa ("uimenu")
-      || go.isa ("uicontextmenu")
-      || go.isa ("uitoolbar")
-      || go.isa ("uipushtool")
-      || go.isa ("uitoggletool"))
-    {
-      Logger::debug ("Backend::initialize %s from thread %08x",
-                     go.type ().c_str (), QThread::currentThreadId ());
+  bool
+  Backend::initialize (const graphics_object& go)
+  {
+    if (go.isa ("figure")
+        || go.isa ("uicontrol")
+        || go.isa ("uipanel")
+        || go.isa ("uibuttongroup")
+        || go.isa ("uimenu")
+        || go.isa ("uicontextmenu")
+        || go.isa ("uitoolbar")
+        || go.isa ("uipushtool")
+        || go.isa ("uitoggletool"))
+      {
+        Logger::debug ("Backend::initialize %s from thread %08x",
+                       go.type ().c_str (), QThread::currentThreadId ());
 
-      ObjectProxy* proxy = new ObjectProxy ();
-      graphics_object gObj (go);
+        ObjectProxy* proxy = new ObjectProxy ();
+        graphics_object gObj (go);
 
-      OCTAVE_PTR_TYPE tmp (reinterpret_cast<OCTAVE_INTPTR_TYPE> (proxy));
-      gObj.get_properties ().set(toolkitObjectProperty (go), tmp);
+        OCTAVE_PTR_TYPE tmp (reinterpret_cast<OCTAVE_INTPTR_TYPE> (proxy));
+        gObj.get_properties ().set(toolkitObjectProperty (go), tmp);
 
-      emit createObject (go.get_handle ().value ());
+        emit createObject (go.get_handle ().value ());
 
-      return true;
-    }
+        return true;
+      }
 
-  return false;
-}
+    return false;
+  }
 
-void
-Backend::update (const graphics_object& go, int pId)
-{
-  // Rule out obvious properties we want to ignore.
-  if (pId == figure::properties::ID___PLOT_STREAM__
-      || pId == uicontrol::properties::ID___OBJECT__
-      || pId == uipanel::properties::ID___OBJECT__
-      || pId == uibuttongroup::properties::ID___OBJECT__
-      || pId == uimenu::properties::ID___OBJECT__
-      || pId == uicontextmenu::properties::ID___OBJECT__
-      || pId == uitoolbar::properties::ID___OBJECT__
-      || pId == uipushtool::properties::ID___OBJECT__
-      || pId == uitoggletool::properties::ID___OBJECT__
-      || pId == base_properties::ID___MODIFIED__)
-    return;
+  void
+  Backend::update (const graphics_object& go, int pId)
+  {
+    // Rule out obvious properties we want to ignore.
+    if (pId == figure::properties::ID___PLOT_STREAM__
+        || pId == uicontrol::properties::ID___OBJECT__
+        || pId == uipanel::properties::ID___OBJECT__
+        || pId == uibuttongroup::properties::ID___OBJECT__
+        || pId == uimenu::properties::ID___OBJECT__
+        || pId == uicontextmenu::properties::ID___OBJECT__
+        || pId == uitoolbar::properties::ID___OBJECT__
+        || pId == uipushtool::properties::ID___OBJECT__
+        || pId == uitoggletool::properties::ID___OBJECT__
+        || pId == base_properties::ID___MODIFIED__)
+      return;
 
-  Logger::debug ("Backend::update %s(%d) from thread %08x",
-                 go.type ().c_str (), pId, QThread::currentThreadId ());
+    Logger::debug ("Backend::update %s(%d) from thread %08x",
+                   go.type ().c_str (), pId, QThread::currentThreadId ());
 
-  ObjectProxy* proxy = toolkitObjectProxy (go);
+    ObjectProxy* proxy = toolkitObjectProxy (go);
 
-  if (proxy)
-    {
-      if (go.isa ("uicontrol")
-          && pId == uicontrol::properties::ID_STYLE)
-        {
-          // Special case: we need to recreate the control widget
-          // associated with the octave graphics_object
+    if (proxy)
+      {
+        if (go.isa ("uicontrol")
+            && pId == uicontrol::properties::ID_STYLE)
+          {
+            // Special case: we need to recreate the control widget
+            // associated with the octave graphics_object
 
-          finalize (go);
-          initialize (go);
-        }
-      else
-        proxy->update (pId);
-    }
-}
+            finalize (go);
+            initialize (go);
+          }
+        else
+          proxy->update (pId);
+      }
+  }
 
-void
-Backend::finalize (const graphics_object& go)
-{
-  Logger::debug ("Backend::finalize %s from thread %08x",
-                 go.type ().c_str (), QThread::currentThreadId ());
+  void
+  Backend::finalize (const graphics_object& go)
+  {
+    Logger::debug ("Backend::finalize %s from thread %08x",
+                   go.type ().c_str (), QThread::currentThreadId ());
 
-  ObjectProxy* proxy = toolkitObjectProxy (go);
+    ObjectProxy* proxy = toolkitObjectProxy (go);
 
-  if (proxy)
-    {
-      proxy->finalize ();
-      delete proxy;
+    if (proxy)
+      {
+        proxy->finalize ();
+        delete proxy;
 
-      graphics_object gObj (go);
+        graphics_object gObj (go);
 
-      gObj.get_properties ().set (toolkitObjectProperty (go), Matrix ());
-    }
-}
+        gObj.get_properties ().set (toolkitObjectProperty (go), Matrix ());
+      }
+  }
 
-void
-Backend::redraw_figure (const graphics_object& go) const
-{
-  if (go.get_properties ().is_visible ())
-    {
-      ObjectProxy* proxy = toolkitObjectProxy (go);
+  void
+  Backend::redraw_figure (const graphics_object& go) const
+  {
+    if (go.get_properties ().is_visible ())
+      {
+        ObjectProxy* proxy = toolkitObjectProxy (go);
 
-      if (proxy)
-        proxy->redraw ();
-    }
-}
+        if (proxy)
+          proxy->redraw ();
+      }
+  }
 
-void
-Backend::print_figure (const graphics_object& go,
-                            const std::string& term,
-                            const std::string& file_cmd,
-                            const std::string& /*debug_file*/) const
-{
-  if (go.get_properties ().is_visible ())
-    {
-      ObjectProxy* proxy = toolkitObjectProxy (go);
+  void
+  Backend::print_figure (const graphics_object& go,
+                         const std::string& term,
+                         const std::string& file_cmd,
+                         const std::string& /*debug_file*/) const
+  {
+    if (go.get_properties ().is_visible ())
+      {
+        ObjectProxy* proxy = toolkitObjectProxy (go);
 
-      if (proxy)
-        proxy->print (QString::fromStdString (file_cmd),
-                      QString::fromStdString (term));
-    }
-}
+        if (proxy)
+          proxy->print (QString::fromStdString (file_cmd),
+                        QString::fromStdString (term));
+      }
+  }
 
-Object*
-Backend::toolkitObject (const graphics_object& go)
-{
-  ObjectProxy* proxy = toolkitObjectProxy (go);
+  Object*
+  Backend::toolkitObject (const graphics_object& go)
+  {
+    ObjectProxy* proxy = toolkitObjectProxy (go);
 
-  if (proxy)
-    return proxy->object ();
+    if (proxy)
+      return proxy->object ();
 
-  return 0;
-}
+    return 0;
+  }
 
-ObjectProxy*
-Backend::toolkitObjectProxy (const graphics_object& go)
-{
-  if (go)
-    {
-      octave_value ov = go.get (toolkitObjectProperty (go));
+  ObjectProxy*
+  Backend::toolkitObjectProxy (const graphics_object& go)
+  {
+    if (go)
+      {
+        octave_value ov = go.get (toolkitObjectProperty (go));
 
-      if (ov.is_defined () && ! ov.is_empty ())
-        {
-          OCTAVE_INTPTR_TYPE ptr = ov.OCTAVE_PTR_SCALAR ().value ();
+        if (ov.is_defined () && ! ov.is_empty ())
+          {
+            OCTAVE_INTPTR_TYPE ptr = ov.OCTAVE_PTR_SCALAR ().value ();
 
-          return reinterpret_cast<ObjectProxy*> (ptr);
-        }
-    }
+            return reinterpret_cast<ObjectProxy*> (ptr);
+          }
+      }
 
-  return 0;
-}
+    return 0;
+  }
 
 };
+
diff --git a/libgui/graphics/Backend.h b/libgui/graphics/Backend.h
--- a/libgui/graphics/Backend.h
+++ b/libgui/graphics/Backend.h
@@ -25,48 +25,49 @@ along with Octave; see the file COPYING.
 
 #include <QObject>
 
 #include "graphics.h"
 
 namespace QtHandles
 {
 
-class Object;
-class ObjectProxy;
+  class Object;
+  class ObjectProxy;
 
-class Backend :
+  class Backend :
   public QObject,
   public base_graphics_toolkit
-{
-  Q_OBJECT
+  {
+    Q_OBJECT
 
-public:
-  Backend (void);
+  public:
+    Backend (void);
 
-  ~Backend (void);
+    ~Backend (void);
 
-  bool is_valid (void) const { return true; }
+    bool is_valid (void) const { return true; }
 
-  void redraw_figure (const graphics_object& h) const;
+    void redraw_figure (const graphics_object& h) const;
 
-  void update (const graphics_object& obj, int pId);
+    void update (const graphics_object& obj, int pId);
 
-  bool initialize (const graphics_object& obj);
+    bool initialize (const graphics_object& obj);
 
-  void finalize (const graphics_object& obj);
+    void finalize (const graphics_object& obj);
 
-  void print_figure (const graphics_object& go,
-                     const std::string& term,
-                     const std::string& file_cmd,
-                     const std::string& /*debug_file*/) const;
+    void print_figure (const graphics_object& go,
+                       const std::string& term,
+                       const std::string& file_cmd,
+                       const std::string& /*debug_file*/) const;
 
-  static Object* toolkitObject (const graphics_object& go);
+    static Object* toolkitObject (const graphics_object& go);
 
-  static ObjectProxy* toolkitObjectProxy (const graphics_object& go);
+    static ObjectProxy* toolkitObjectProxy (const graphics_object& go);
 
-signals:
-  void createObject (double handle);
-};
+  signals:
+    void createObject (double handle);
+  };
 
 }; // namespace QtHandles
 
 #endif
+
diff --git a/libgui/graphics/BaseControl.cc b/libgui/graphics/BaseControl.cc
--- a/libgui/graphics/BaseControl.cc
+++ b/libgui/graphics/BaseControl.cc
@@ -31,219 +31,220 @@ along with Octave; see the file COPYING.
 
 #include "BaseControl.h"
 #include "ContextMenu.h"
 #include "QtHandlesUtils.h"
 
 namespace QtHandles
 {
 
-static void
-updatePalette (const uicontrol::properties& props, QWidget* w)
-{
-  QPalette p = w->palette ();
+  static void
+  updatePalette (const uicontrol::properties& props, QWidget* w)
+  {
+    QPalette p = w->palette ();
 
-  if (props.style_is ("edit")
-      || props.style_is ("listbox")
-      || props.style_is ("popupmenu"))
-    {
-      p.setColor (QPalette::Base,
-                  Utils::fromRgb (props.get_backgroundcolor_rgb ()));
-      p.setColor (QPalette::Text,
-                  Utils::fromRgb (props.get_foregroundcolor_rgb ()));
-    }
-  else if (props.style_is ("pushbutton")
-           || props.style_is ("togglebutton"))
-    {
-      p.setColor (QPalette::Button,
-                  Utils::fromRgb (props.get_backgroundcolor_rgb ()));
-      p.setColor (QPalette::ButtonText,
-                  Utils::fromRgb (props.get_foregroundcolor_rgb ()));
-    }
-  else
-    {
-      p.setColor (QPalette::Window,
-                  Utils::fromRgb (props.get_backgroundcolor_rgb ()));
-      p.setColor (QPalette::WindowText,
-                  Utils::fromRgb (props.get_foregroundcolor_rgb ()));
-    }
+    if (props.style_is ("edit")
+        || props.style_is ("listbox")
+        || props.style_is ("popupmenu"))
+      {
+        p.setColor (QPalette::Base,
+                    Utils::fromRgb (props.get_backgroundcolor_rgb ()));
+        p.setColor (QPalette::Text,
+                    Utils::fromRgb (props.get_foregroundcolor_rgb ()));
+      }
+    else if (props.style_is ("pushbutton")
+             || props.style_is ("togglebutton"))
+      {
+        p.setColor (QPalette::Button,
+                    Utils::fromRgb (props.get_backgroundcolor_rgb ()));
+        p.setColor (QPalette::ButtonText,
+                    Utils::fromRgb (props.get_foregroundcolor_rgb ()));
+      }
+    else
+      {
+        p.setColor (QPalette::Window,
+                    Utils::fromRgb (props.get_backgroundcolor_rgb ()));
+        p.setColor (QPalette::WindowText,
+                    Utils::fromRgb (props.get_foregroundcolor_rgb ()));
+      }
 
-  w->setPalette (p);
-}
+    w->setPalette (p);
+  }
 
-BaseControl::BaseControl (const graphics_object& go, QWidget* w)
-  : Object (go, w), m_normalizedFont (false), m_keyPressHandlerDefined (false)
-{
-  init (w);
-}
+  BaseControl::BaseControl (const graphics_object& go, QWidget* w)
+    : Object (go, w), m_normalizedFont (false), m_keyPressHandlerDefined (false)
+  {
+    init (w);
+  }
 
-void
-BaseControl::init (QWidget* w, bool callBase)
-{
-  if (callBase)
-    Object::init (w, callBase);
+  void
+  BaseControl::init (QWidget* w, bool callBase)
+  {
+    if (callBase)
+      Object::init (w, callBase);
 
-  uicontrol::properties& up = properties<uicontrol> ();
+    uicontrol::properties& up = properties<uicontrol> ();
 
-  Matrix bb = up.get_boundingbox (false);
-  w->setGeometry (octave::math::round (bb(0)), octave::math::round (bb(1)),
-                  octave::math::round (bb(2)), octave::math::round (bb(3)));
-  w->setFont (Utils::computeFont<uicontrol> (up, bb(3)));
-  updatePalette (up, w);
-  w->setEnabled (up.enable_is ("on"));
-  w->setToolTip (Utils::fromStdString (up.get_tooltipstring ()));
-  w->setVisible (up.is_visible ());
-  m_keyPressHandlerDefined = ! up.get_keypressfcn ().is_empty ();
+    Matrix bb = up.get_boundingbox (false);
+    w->setGeometry (octave::math::round (bb(0)), octave::math::round (bb(1)),
+                    octave::math::round (bb(2)), octave::math::round (bb(3)));
+    w->setFont (Utils::computeFont<uicontrol> (up, bb(3)));
+    updatePalette (up, w);
+    w->setEnabled (up.enable_is ("on"));
+    w->setToolTip (Utils::fromStdString (up.get_tooltipstring ()));
+    w->setVisible (up.is_visible ());
+    m_keyPressHandlerDefined = ! up.get_keypressfcn ().is_empty ();
 
-  w->installEventFilter (this);
+    w->installEventFilter (this);
 
-  m_normalizedFont = up.fontunits_is ("normalized");
-}
+    m_normalizedFont = up.fontunits_is ("normalized");
+  }
 
-BaseControl::~BaseControl (void)
-{
-}
+  BaseControl::~BaseControl (void)
+  {
+  }
 
-void
-BaseControl::update (int pId)
-{
-  uicontrol::properties& up = properties<uicontrol> ();
-  QWidget* w = qWidget<QWidget> ();
+  void
+  BaseControl::update (int pId)
+  {
+    uicontrol::properties& up = properties<uicontrol> ();
+    QWidget* w = qWidget<QWidget> ();
 
-   switch (pId)
-    {
-    case uicontrol::properties::ID_POSITION:
+    switch (pId)
+      {
+      case uicontrol::properties::ID_POSITION:
         {
           Matrix bb = up.get_boundingbox (false);
           w->setGeometry (octave::math::round (bb(0)), octave::math::round (bb(1)),
                           octave::math::round (bb(2)), octave::math::round (bb(3)));
         }
-      break;
-
-    case uicontrol::properties::ID_FONTNAME:
-    case uicontrol::properties::ID_FONTSIZE:
-    case uicontrol::properties::ID_FONTWEIGHT:
-    case uicontrol::properties::ID_FONTANGLE:
-      w->setFont (Utils::computeFont<uicontrol> (up));
-      break;
+        break;
 
-    case uicontrol::properties::ID_FONTUNITS:
-      // FIXME: We shouldn't have to do anything, octave should update
-      //        the "fontsize" property automatically to the new units.
-      //        Hence the actual font used shouldn't change.
-      m_normalizedFont = up.fontunits_is ("normalized");
-      break;
-
-    case uicontrol::properties::ID_BACKGROUNDCOLOR:
-    case uicontrol::properties::ID_FOREGROUNDCOLOR:
-      updatePalette (up, w);
-      break;
+      case uicontrol::properties::ID_FONTNAME:
+      case uicontrol::properties::ID_FONTSIZE:
+      case uicontrol::properties::ID_FONTWEIGHT:
+      case uicontrol::properties::ID_FONTANGLE:
+        w->setFont (Utils::computeFont<uicontrol> (up));
+        break;
 
-    case uicontrol::properties::ID_ENABLE:
-      w->setEnabled (up.enable_is ("on"));
-      break;
-
-    case uicontrol::properties::ID_TOOLTIPSTRING:
-      w->setToolTip (Utils::fromStdString (up.get_tooltipstring ()));
-      break;
+      case uicontrol::properties::ID_FONTUNITS:
+        // FIXME: We shouldn't have to do anything, octave should update
+        //        the "fontsize" property automatically to the new units.
+        //        Hence the actual font used shouldn't change.
+        m_normalizedFont = up.fontunits_is ("normalized");
+        break;
 
-    case base_properties::ID_VISIBLE:
-      w->setVisible (up.is_visible ());
-      break;
+      case uicontrol::properties::ID_BACKGROUNDCOLOR:
+      case uicontrol::properties::ID_FOREGROUNDCOLOR:
+        updatePalette (up, w);
+        break;
 
-    case uicontrol::properties::ID_KEYPRESSFCN:
-      m_keyPressHandlerDefined = ! up.get_keypressfcn ().is_empty ();
-      break;
+      case uicontrol::properties::ID_ENABLE:
+        w->setEnabled (up.enable_is ("on"));
+        break;
 
-    default:
-      break;
-    }
-}
+      case uicontrol::properties::ID_TOOLTIPSTRING:
+        w->setToolTip (Utils::fromStdString (up.get_tooltipstring ()));
+        break;
 
-bool
-BaseControl::eventFilter (QObject* watched, QEvent* xevent)
-{
-  switch (xevent->type ())
-    {
-    case QEvent::Resize:
-      if (m_normalizedFont)
-        {
-          gh_manager::auto_lock lock;
+      case base_properties::ID_VISIBLE:
+        w->setVisible (up.is_visible ());
+        break;
+
+      case uicontrol::properties::ID_KEYPRESSFCN:
+        m_keyPressHandlerDefined = ! up.get_keypressfcn ().is_empty ();
+        break;
 
-          qWidget<QWidget> ()->setFont (Utils::computeFont<uicontrol>
-                                        (properties<uicontrol> ()));
-        }
-      break;
+      default:
+        break;
+      }
+  }
 
-    case QEvent::MouseButtonPress:
+  bool
+  BaseControl::eventFilter (QObject* watched, QEvent* xevent)
+  {
+    switch (xevent->type ())
       {
-        gh_manager::auto_lock lock;
-
-        QMouseEvent* m = dynamic_cast<QMouseEvent*> (xevent);
-        graphics_object go = object ();
-        uicontrol::properties& up = Utils::properties<uicontrol> (go);
-        graphics_object fig = go.get_ancestor ("figure");
-
-        if (m->button () != Qt::LeftButton
-            || ! up.enable_is ("on"))
+      case QEvent::Resize:
+        if (m_normalizedFont)
           {
-            gh_manager::post_set (fig.get_handle (), "selectiontype",
-                                  Utils::figureSelectionType (m), false);
-            gh_manager::post_set (fig.get_handle (), "currentpoint",
-                                  Utils::figureCurrentPoint (fig, m),
-                                  false);
-            gh_manager::post_callback (fig.get_handle (),
-                                       "windowbuttondownfcn");
-            gh_manager::post_callback (m_handle, "buttondownfcn");
+            gh_manager::auto_lock lock;
 
-            if (m->button () == Qt::RightButton)
-              ContextMenu::executeAt (up, m->globalPos ());
+            qWidget<QWidget> ()->setFont (Utils::computeFont<uicontrol>
+                                          (properties<uicontrol> ()));
           }
-        else
-          {
-            if (up.style_is ("listbox"))
-              gh_manager::post_set (fig.get_handle (), "selectiontype",
-                                    Utils::figureSelectionType (m), false);
-            else
-              gh_manager::post_set (fig.get_handle (), "selectiontype",
-                                    octave_value ("normal"), false);
-          }
-      }
-      break;
+        break;
 
-    case QEvent::MouseMove:
-      if (qWidget<QWidget> ()->hasMouseTracking ())
+      case QEvent::MouseButtonPress:
         {
           gh_manager::auto_lock lock;
 
           QMouseEvent* m = dynamic_cast<QMouseEvent*> (xevent);
           graphics_object go = object ();
+          uicontrol::properties& up = Utils::properties<uicontrol> (go);
           graphics_object fig = go.get_ancestor ("figure");
 
-          gh_manager::post_set (fig.get_handle (), "currentpoint",
-                                Utils::figureCurrentPoint (fig, m), false);
-          gh_manager::post_callback (fig.get_handle (), "windowbuttonmotionfcn");
+          if (m->button () != Qt::LeftButton
+              || ! up.enable_is ("on"))
+            {
+              gh_manager::post_set (fig.get_handle (), "selectiontype",
+                                    Utils::figureSelectionType (m), false);
+              gh_manager::post_set (fig.get_handle (), "currentpoint",
+                                    Utils::figureCurrentPoint (fig, m),
+                                    false);
+              gh_manager::post_callback (fig.get_handle (),
+                                         "windowbuttondownfcn");
+              gh_manager::post_callback (m_handle, "buttondownfcn");
+
+              if (m->button () == Qt::RightButton)
+                ContextMenu::executeAt (up, m->globalPos ());
+            }
+          else
+            {
+              if (up.style_is ("listbox"))
+                gh_manager::post_set (fig.get_handle (), "selectiontype",
+                                      Utils::figureSelectionType (m), false);
+              else
+                gh_manager::post_set (fig.get_handle (), "selectiontype",
+                                      octave_value ("normal"), false);
+            }
         }
-      break;
+        break;
 
-    case QEvent::KeyPress:
-      if (m_keyPressHandlerDefined)
-        {
-          gh_manager::auto_lock lock;
+      case QEvent::MouseMove:
+        if (qWidget<QWidget> ()->hasMouseTracking ())
+          {
+            gh_manager::auto_lock lock;
 
-          octave_scalar_map keyData =
-            Utils::makeKeyEventStruct (dynamic_cast<QKeyEvent*> (xevent));
-          graphics_object fig = object ().get_ancestor ("figure");
+            QMouseEvent* m = dynamic_cast<QMouseEvent*> (xevent);
+            graphics_object go = object ();
+            graphics_object fig = go.get_ancestor ("figure");
+
+            gh_manager::post_set (fig.get_handle (), "currentpoint",
+                                  Utils::figureCurrentPoint (fig, m), false);
+            gh_manager::post_callback (fig.get_handle (), "windowbuttonmotionfcn");
+          }
+        break;
+
+      case QEvent::KeyPress:
+        if (m_keyPressHandlerDefined)
+          {
+            gh_manager::auto_lock lock;
 
-          gh_manager::post_set (fig.get_handle (), "currentcharacter",
-                                keyData.getfield ("Character"), false);
-          gh_manager::post_callback (m_handle, "keypressfcn", keyData);
-        }
-      break;
+            octave_scalar_map keyData =
+              Utils::makeKeyEventStruct (dynamic_cast<QKeyEvent*> (xevent));
+            graphics_object fig = object ().get_ancestor ("figure");
 
-    default:
-      break;
-    }
+            gh_manager::post_set (fig.get_handle (), "currentcharacter",
+                                  keyData.getfield ("Character"), false);
+            gh_manager::post_callback (m_handle, "keypressfcn", keyData);
+          }
+        break;
 
-  return Object::eventFilter (watched, xevent);
-}
+      default:
+        break;
+      }
+
+    return Object::eventFilter (watched, xevent);
+  }
 
 }; // namespace QtHandles
+
diff --git a/libgui/graphics/BaseControl.h b/libgui/graphics/BaseControl.h
--- a/libgui/graphics/BaseControl.h
+++ b/libgui/graphics/BaseControl.h
@@ -26,30 +26,31 @@ along with Octave; see the file COPYING.
 #include "Object.h"
 
 class QEvent;
 class QObject;
 
 namespace QtHandles
 {
 
-class BaseControl : public Object
-{
-public:
-  BaseControl (const graphics_object& go, QWidget* w);
-  ~BaseControl (void);
+  class BaseControl : public Object
+  {
+  public:
+    BaseControl (const graphics_object& go, QWidget* w);
+    ~BaseControl (void);
 
-  Container* innerContainer (void) { return 0; }
+    Container* innerContainer (void) { return 0; }
 
-  bool eventFilter (QObject* watched, QEvent* e);
+    bool eventFilter (QObject* watched, QEvent* e);
 
-protected:
-  void init (QWidget* w, bool callBase = false);
-  void update (int pId);
+  protected:
+    void init (QWidget* w, bool callBase = false);
+    void update (int pId);
 
-private:
-  bool m_normalizedFont;
-  bool m_keyPressHandlerDefined;
-};
+  private:
+    bool m_normalizedFont;
+    bool m_keyPressHandlerDefined;
+  };
 
 }; // namespace QtHandles
 
 #endif
+
diff --git a/libgui/graphics/ButtonControl.cc b/libgui/graphics/ButtonControl.cc
--- a/libgui/graphics/ButtonControl.cc
+++ b/libgui/graphics/ButtonControl.cc
@@ -29,117 +29,119 @@ along with Octave; see the file COPYING.
 #include "ButtonControl.h"
 #include "ButtonGroup.h"
 #include "Container.h"
 #include "QtHandlesUtils.h"
 
 namespace QtHandles
 {
 
-ButtonControl::ButtonControl (const graphics_object& go, QAbstractButton* btn)
-  : BaseControl (go, btn), m_blockCallback (false)
-{
-  uicontrol::properties& up = properties<uicontrol> ();
-
-  QString str = Utils::fromStdString (up.get_string_string ());
-  str.replace ("&", "&&");
-  btn->setText (str);
-  if (btn->isCheckable () || up.style_is ("togglebutton"))
-    {
-      btn->setCheckable (true);
-
-      Matrix value = up.get_value ().matrix_value ();
-
-      if (value.numel () > 0 && value(0) == up.get_max ())
-        btn->setChecked (true);
-    }
+  ButtonControl::ButtonControl (const graphics_object& go, QAbstractButton* btn)
+    : BaseControl (go, btn), m_blockCallback (false)
+  {
+    uicontrol::properties& up = properties<uicontrol> ();
 
-  connect (btn, SIGNAL (clicked (void)), SLOT (clicked (void)));
-  connect (btn, SIGNAL (toggled (bool)), SLOT (toggled (bool)));
-}
-
-ButtonControl::~ButtonControl (void)
-{
-}
+    QString str = Utils::fromStdString (up.get_string_string ());
+    str.replace ("&", "&&");
+    btn->setText (str);
+    if (btn->isCheckable () || up.style_is ("togglebutton"))
+      {
+        btn->setCheckable (true);
 
-void
-ButtonControl::update (int pId)
-{
-  uicontrol::properties& up = properties<uicontrol> ();
-  QAbstractButton* btn = qWidget<QAbstractButton> ();
+        Matrix value = up.get_value ().matrix_value ();
 
-  switch (pId)
-    {
-    case uicontrol::properties::ID_STRING:
-      {
-        QString str = Utils::fromStdString (up.get_string_string ());
-        str.replace ("&", "&&");
-        btn->setText (str);
-        break;
+        if (value.numel () > 0 && value(0) == up.get_max ())
+          btn->setChecked (true);
       }
 
-    case uicontrol::properties::ID_VALUE:
-      m_blockCallback = true;
-      if (btn->isCheckable ())
-        {
-          Matrix value = up.get_value ().matrix_value ();
+    connect (btn, SIGNAL (clicked (void)), SLOT (clicked (void)));
+    connect (btn, SIGNAL (toggled (bool)), SLOT (toggled (bool)));
+  }
 
-          if (value.numel () > 0)
-            {
-              double dValue = value(0);
+  ButtonControl::~ButtonControl (void)
+  {
+  }
+
+  void
+  ButtonControl::update (int pId)
+  {
+    uicontrol::properties& up = properties<uicontrol> ();
+    QAbstractButton* btn = qWidget<QAbstractButton> ();
 
-              if (dValue != 0.0 && dValue != 1.0)
-                warning ("button value not within valid display range");
-              else if (dValue == up.get_min () && btn->isChecked ())
-                {
-                  btn->setChecked (false);
-                  if (up.style_is ("radiobutton") || up.style_is ("togglebutton"))
-                    {
-                      Object* parent = Object::parentObject (gh_manager::get_object (up.get___myhandle__ ()));
-                      ButtonGroup* btnGroup = dynamic_cast<ButtonGroup*>(parent);
-                      if (btnGroup)
-                        btnGroup->selectNothing ();
-                    }
-                }
-              else if (dValue == up.get_max () && ! btn->isChecked ())
-                btn->setChecked (true);
-            }
+    switch (pId)
+      {
+      case uicontrol::properties::ID_STRING:
+        {
+          QString str = Utils::fromStdString (up.get_string_string ());
+          str.replace ("&", "&&");
+          btn->setText (str);
+          break;
         }
-      m_blockCallback = false;
-      break;
+
+      case uicontrol::properties::ID_VALUE:
+        m_blockCallback = true;
+        if (btn->isCheckable ())
+          {
+            Matrix value = up.get_value ().matrix_value ();
+
+            if (value.numel () > 0)
+              {
+                double dValue = value(0);
 
-    default:
-      BaseControl::update (pId);
-      break;
-    }
-}
+                if (dValue != 0.0 && dValue != 1.0)
+                  warning ("button value not within valid display range");
+                else if (dValue == up.get_min () && btn->isChecked ())
+                  {
+                    btn->setChecked (false);
+                    if (up.style_is ("radiobutton") || up.style_is ("togglebutton"))
+                      {
+                        Object* parent = Object::parentObject (gh_manager::get_object (
+                            up.get___myhandle__ ()));
+                        ButtonGroup* btnGroup = dynamic_cast<ButtonGroup*>(parent);
+                        if (btnGroup)
+                          btnGroup->selectNothing ();
+                      }
+                  }
+                else if (dValue == up.get_max () && ! btn->isChecked ())
+                  btn->setChecked (true);
+              }
+          }
+        m_blockCallback = false;
+        break;
 
-void
-ButtonControl::toggled (bool checked)
-{
-  QAbstractButton* btn = qWidget<QAbstractButton> ();
-
-  if (! m_blockCallback && btn->isCheckable ())
-    {
-      gh_manager::auto_lock lock;
-
-      uicontrol::properties& up = properties<uicontrol> ();
+      default:
+        BaseControl::update (pId);
+        break;
+      }
+  }
 
-      Matrix oldValue = up.get_value ().matrix_value ();
-      double newValue = (checked ? up.get_max () : up.get_min ());
+  void
+  ButtonControl::toggled (bool checked)
+  {
+    QAbstractButton* btn = qWidget<QAbstractButton> ();
+
+    if (! m_blockCallback && btn->isCheckable ())
+      {
+        gh_manager::auto_lock lock;
+
+        uicontrol::properties& up = properties<uicontrol> ();
+
+        Matrix oldValue = up.get_value ().matrix_value ();
+        double newValue = (checked ? up.get_max () : up.get_min ());
 
-      if (oldValue.numel() != 1
-          || (newValue != oldValue(0)))
-        gh_manager::post_set (m_handle, "value", newValue, false);
+        if (oldValue.numel() != 1
+            || (newValue != oldValue(0)))
+          gh_manager::post_set (m_handle, "value", newValue, false);
+        gh_manager::post_callback (m_handle, "callback");
+      }
+  }
+
+  void
+  ButtonControl::clicked (void)
+  {
+    QAbstractButton* btn = qWidget<QAbstractButton> ();
+
+    if (! btn->isCheckable ())
       gh_manager::post_callback (m_handle, "callback");
-    }
-}
-
-void
-ButtonControl::clicked (void)
-{
-  QAbstractButton* btn = qWidget<QAbstractButton> ();
-
-  if (! btn->isCheckable ())
-    gh_manager::post_callback (m_handle, "callback");
-}
+  }
 
 };
+
diff --git a/libgui/graphics/ButtonControl.h b/libgui/graphics/ButtonControl.h
--- a/libgui/graphics/ButtonControl.h
+++ b/libgui/graphics/ButtonControl.h
@@ -25,30 +25,31 @@ along with Octave; see the file COPYING.
 
 #include "BaseControl.h"
 
 class QAbstractButton;
 
 namespace QtHandles
 {
 
-class ButtonControl : public BaseControl
-{
-  Q_OBJECT
+  class ButtonControl : public BaseControl
+  {
+    Q_OBJECT
 
-public:
-  ButtonControl (const graphics_object& go, QAbstractButton* btn);
-  ~ButtonControl (void);
+  public:
+    ButtonControl (const graphics_object& go, QAbstractButton* btn);
+    ~ButtonControl (void);
 
-protected:
-  void update (int pId);
+  protected:
+    void update (int pId);
 
-private slots:
-  void clicked (void);
-  void toggled (bool checked);
+  private slots:
+    void clicked (void);
+    void toggled (bool checked);
 
-private:
-  bool m_blockCallback;
-};
+  private:
+    bool m_blockCallback;
+  };
 
 }; // namespace QtHandles
 
 #endif
+
diff --git a/libgui/graphics/ButtonGroup.cc b/libgui/graphics/ButtonGroup.cc
--- a/libgui/graphics/ButtonGroup.cc
+++ b/libgui/graphics/ButtonGroup.cc
@@ -42,148 +42,152 @@ along with Octave; see the file COPYING.
 #include "Backend.h"
 #include "QtHandlesUtils.h"
 
 #include "ov-struct.h"
 
 namespace QtHandles
 {
 
-static int
-frameStyleFromProperties (const uibuttongroup::properties& pp)
-{
+  static int
+  frameStyleFromProperties (const uibuttongroup::properties& pp)
+  {
     if (pp.bordertype_is ("none"))
       return QFrame::NoFrame;
     else if (pp.bordertype_is ("etchedin"))
       return (QFrame::Box | QFrame::Sunken);
     else if (pp.bordertype_is ("etchedout"))
       return (QFrame::Box | QFrame::Raised);
     else if (pp.bordertype_is ("beveledin"))
       return (QFrame::Panel | QFrame::Sunken);
     else if (pp.bordertype_is ("beveledout"))
       return (QFrame::Panel | QFrame::Raised);
     else
       return (QFrame::Panel | QFrame::Plain);
-}
+  }
 
-static void
-setupPalette (const uibuttongroup::properties& pp, QPalette &p)
-{
-  p.setColor (QPalette::Window,
-              Utils::fromRgb (pp.get_backgroundcolor_rgb ()));
-  p.setColor (QPalette::WindowText,
-              Utils::fromRgb (pp.get_foregroundcolor_rgb ()));
-  p.setColor (QPalette::Light,
-              Utils::fromRgb (pp.get_highlightcolor_rgb ()));
-  p.setColor (QPalette::Dark,
-              Utils::fromRgb (pp.get_shadowcolor_rgb ()));
-}
+  static void
+  setupPalette (const uibuttongroup::properties& pp, QPalette &p)
+  {
+    p.setColor (QPalette::Window,
+                Utils::fromRgb (pp.get_backgroundcolor_rgb ()));
+    p.setColor (QPalette::WindowText,
+                Utils::fromRgb (pp.get_foregroundcolor_rgb ()));
+    p.setColor (QPalette::Light,
+                Utils::fromRgb (pp.get_highlightcolor_rgb ()));
+    p.setColor (QPalette::Dark,
+                Utils::fromRgb (pp.get_shadowcolor_rgb ()));
+  }
 
-static int
-borderWidthFromProperties (const uibuttongroup::properties& pp)
-{
-  int bw = 0;
+  static int
+  borderWidthFromProperties (const uibuttongroup::properties& pp)
+  {
+    int bw = 0;
+
+    if (! pp.bordertype_is ("none"))
+      {
+        bw = octave::math::round (pp.get_borderwidth ());
+        if (pp.bordertype_is ("etchedin") || pp.bordertype_is ("etchedout"))
+          bw *= 2;
+      }
 
-  if (! pp.bordertype_is ("none"))
-    {
-      bw = octave::math::round (pp.get_borderwidth ());
-      if (pp.bordertype_is ("etchedin") || pp.bordertype_is ("etchedout"))
-        bw *= 2;
-    }
+    return bw;
+  }
 
-  return bw;
-}
+  ButtonGroup*
+  ButtonGroup::create (const graphics_object& go)
+  {
+    Object* parent = Object::parentObject (go);
 
-ButtonGroup*
-ButtonGroup::create (const graphics_object& go)
-{
-  Object* parent = Object::parentObject (go);
+    if (parent)
+      {
+        Container* container = parent->innerContainer ();
 
-  if (parent)
-    {
-      Container* container = parent->innerContainer ();
-
-      if (container) {
-        QFrame* frame = new QFrame(container);
-        return new ButtonGroup (go, new QButtonGroup (frame), frame);
+        if (container)
+          {
+            QFrame* frame = new QFrame(container);
+            return new ButtonGroup (go, new QButtonGroup (frame), frame);
+          }
       }
-    }
 
-  return 0;
-}
+    return 0;
+  }
 
-ButtonGroup::ButtonGroup (const graphics_object& go, QButtonGroup* buttongroup, QFrame* frame)
-  : Object (go, frame), m_hiddenbutton(0), m_container (0), m_title (0), m_blockUpdates (false)
-{
-  uibuttongroup::properties& pp = properties<uibuttongroup> ();
+  ButtonGroup::ButtonGroup (const graphics_object& go, QButtonGroup* buttongroup,
+                            QFrame* frame)
+    : Object (go, frame), m_hiddenbutton(0), m_container (0), m_title (0),
+      m_blockUpdates (false)
+  {
+    uibuttongroup::properties& pp = properties<uibuttongroup> ();
 
-  frame->setObjectName ("UIButtonGroup");
-  frame->setAutoFillBackground (true);
-  Matrix bb = pp.get_boundingbox (false);
-  frame->setGeometry (octave::math::round (bb(0)), octave::math::round (bb(1)),
-                      octave::math::round (bb(2)), octave::math::round (bb(3)));
-  frame->setFrameStyle (frameStyleFromProperties (pp));
-  frame->setLineWidth (octave::math::round (pp.get_borderwidth ()));
-  QPalette pal = frame->palette ();
-  setupPalette (pp, pal);
-  frame->setPalette (pal);
-  m_buttongroup = buttongroup;
-  m_hiddenbutton = new QRadioButton (frame);
-  m_hiddenbutton->hide ();
-  m_buttongroup->addButton (m_hiddenbutton);
+    frame->setObjectName ("UIButtonGroup");
+    frame->setAutoFillBackground (true);
+    Matrix bb = pp.get_boundingbox (false);
+    frame->setGeometry (octave::math::round (bb(0)), octave::math::round (bb(1)),
+                        octave::math::round (bb(2)), octave::math::round (bb(3)));
+    frame->setFrameStyle (frameStyleFromProperties (pp));
+    frame->setLineWidth (octave::math::round (pp.get_borderwidth ()));
+    QPalette pal = frame->palette ();
+    setupPalette (pp, pal);
+    frame->setPalette (pal);
+    m_buttongroup = buttongroup;
+    m_hiddenbutton = new QRadioButton (frame);
+    m_hiddenbutton->hide ();
+    m_buttongroup->addButton (m_hiddenbutton);
 
-  m_container = new Container (frame);
-  m_container->canvas (m_handle);
+    m_container = new Container (frame);
+    m_container->canvas (m_handle);
 
-  if (frame->hasMouseTracking ())
-    {
-      foreach (QWidget* w, frame->findChildren<QWidget*> ())
+    if (frame->hasMouseTracking ())
+      {
+        foreach (QWidget* w, frame->findChildren<QWidget*> ())
         { w->setMouseTracking (true); }
-      foreach (QWidget* w, buttongroup->findChildren<QWidget*> ())
+        foreach (QWidget* w, buttongroup->findChildren<QWidget*> ())
         { w->setMouseTracking (true); }
-    }
+      }
 
-  QString title = Utils::fromStdString (pp.get_title ());
-  if (! title.isEmpty ())
-    {
-      m_title = new QLabel (title, frame);
-      m_title->setAutoFillBackground (true);
-      m_title->setContentsMargins (4, 0, 4, 0);
-      m_title->setPalette (pal);
-      m_title->setFont (Utils::computeFont<uibuttongroup> (pp, bb(3)));
-    }
+    QString title = Utils::fromStdString (pp.get_title ());
+    if (! title.isEmpty ())
+      {
+        m_title = new QLabel (title, frame);
+        m_title->setAutoFillBackground (true);
+        m_title->setContentsMargins (4, 0, 4, 0);
+        m_title->setPalette (pal);
+        m_title->setFont (Utils::computeFont<uibuttongroup> (pp, bb(3)));
+      }
 
-  frame->installEventFilter (this);
-  m_container->installEventFilter (this);
+    frame->installEventFilter (this);
+    m_container->installEventFilter (this);
 
-  if (pp.is_visible ())
-    {
-      QTimer::singleShot (0, frame, SLOT (show (void)));
-      QTimer::singleShot (0, buttongroup, SLOT (show (void)));
-    }
-  else
-    frame->hide ();
+    if (pp.is_visible ())
+      {
+        QTimer::singleShot (0, frame, SLOT (show (void)));
+        QTimer::singleShot (0, buttongroup, SLOT (show (void)));
+      }
+    else
+      frame->hide ();
 
-  connect (m_buttongroup, SIGNAL (buttonClicked (QAbstractButton*)), SLOT (buttonClicked (QAbstractButton*)));
-}
+    connect (m_buttongroup, SIGNAL (buttonClicked (QAbstractButton*)),
+             SLOT (buttonClicked (QAbstractButton*)));
+  }
 
-ButtonGroup::~ButtonGroup (void)
-{
-}
+  ButtonGroup::~ButtonGroup (void)
+  {
+  }
 
-bool
-ButtonGroup::eventFilter (QObject* watched, QEvent* xevent)
-{
-  if (! m_blockUpdates)
-    {
-      if (watched == qObject ())
-        {
-          switch (xevent->type ())
-            {
-            case QEvent::Resize:
+  bool
+  ButtonGroup::eventFilter (QObject* watched, QEvent* xevent)
+  {
+    if (! m_blockUpdates)
+      {
+        if (watched == qObject ())
+          {
+            switch (xevent->type ())
+              {
+              case QEvent::Resize:
                 {
                   gh_manager::auto_lock lock;
                   graphics_object go = object ();
 
                   if (go.valid_object ())
                     {
                       if (m_title)
                         {
@@ -197,291 +201,298 @@ ButtonGroup::eventFilter (QObject* watch
                               m_title->setFont (Utils::computeFont<uibuttongroup>
                                                 (pp, frame->height ()));
                               m_title->resize (m_title->sizeHint ());
                             }
                         }
                       updateLayout ();
                     }
                 }
-              break;
+                break;
 
-            case QEvent::MouseButtonPress:
+              case QEvent::MouseButtonPress:
                 {
                   QMouseEvent* m = dynamic_cast<QMouseEvent*> (xevent);
 
                   if (m->button () == Qt::RightButton)
                     {
                       gh_manager::auto_lock lock;
 
                       ContextMenu::executeAt (properties (), m->globalPos ());
                     }
                 }
-              break;
-
-            default:
-              break;
-            }
-        }
-      else if (watched == m_container)
-        {
-          switch (xevent->type ())
-            {
-            case QEvent::Resize:
-              if (qWidget<QWidget> ()->isVisible ())
-                {
-                  gh_manager::auto_lock lock;
-
-                  properties ().update_boundingbox ();
-                }
-              break;
-
-            default:
-              break;
-            }
-        }
-    }
-
-  return false;
-}
-
-void
-ButtonGroup::update (int pId)
-{
-  uibuttongroup::properties& pp = properties<uibuttongroup> ();
-  QFrame* frame = qWidget<QFrame> ();
-
-  m_blockUpdates = true;
-
-  switch (pId)
-    {
-    case uibuttongroup::properties::ID_POSITION:
-      {
-        Matrix bb = pp.get_boundingbox (false);
+                break;
 
-        frame->setGeometry (octave::math::round (bb(0)), octave::math::round (bb(1)),
-                            octave::math::round (bb(2)), octave::math::round (bb(3)));
-        updateLayout ();
-      }
-      break;
-
-    case uibuttongroup::properties::ID_BORDERWIDTH:
-      frame->setLineWidth (octave::math::round (pp.get_borderwidth ()));
-      updateLayout ();
-      break;
-
-    case uibuttongroup::properties::ID_BACKGROUNDCOLOR:
-    case uibuttongroup::properties::ID_FOREGROUNDCOLOR:
-    case uibuttongroup::properties::ID_HIGHLIGHTCOLOR:
-    case uibuttongroup::properties::ID_SHADOWCOLOR:
-      {
-        QPalette pal = frame->palette ();
-
-        setupPalette (pp, pal);
-        frame->setPalette (pal);
-        if (m_title)
-          m_title->setPalette (pal);
-      }
-      break;
+              default:
+                break;
+              }
+          }
+        else if (watched == m_container)
+          {
+            switch (xevent->type ())
+              {
+              case QEvent::Resize:
+                if (qWidget<QWidget> ()->isVisible ())
+                  {
+                    gh_manager::auto_lock lock;
 
-    case uibuttongroup::properties::ID_TITLE:
-      {
-        QString title = Utils::fromStdString (pp.get_title ());
+                    properties ().update_boundingbox ();
+                  }
+                break;
 
-        if (title.isEmpty ())
-          {
-            if (m_title)
-              delete m_title;
-            m_title = 0;
-          }
-        else
-          {
-            if (! m_title)
-              {
-                QPalette pal = frame->palette ();
-
-                m_title = new QLabel (title, frame);
-                m_title->setAutoFillBackground (true);
-                m_title->setContentsMargins (4, 0, 4, 0);
-                m_title->setPalette (pal);
-                m_title->setFont (Utils::computeFont<uibuttongroup> (pp));
-                m_title->show ();
-              }
-            else
-              {
-                m_title->setText (title);
-                m_title->resize (m_title->sizeHint ());
+              default:
+                break;
               }
           }
-        updateLayout ();
       }
-      break;
+
+    return false;
+  }
+
+  void
+  ButtonGroup::update (int pId)
+  {
+    uibuttongroup::properties& pp = properties<uibuttongroup> ();
+    QFrame* frame = qWidget<QFrame> ();
+
+    m_blockUpdates = true;
 
-    case uibuttongroup::properties::ID_TITLEPOSITION:
-      updateLayout ();
-      break;
+    switch (pId)
+      {
+      case uibuttongroup::properties::ID_POSITION:
+        {
+          Matrix bb = pp.get_boundingbox (false);
+
+          frame->setGeometry (octave::math::round (bb(0)), octave::math::round (bb(1)),
+                              octave::math::round (bb(2)), octave::math::round (bb(3)));
+          updateLayout ();
+        }
+        break;
+
+      case uibuttongroup::properties::ID_BORDERWIDTH:
+        frame->setLineWidth (octave::math::round (pp.get_borderwidth ()));
+        updateLayout ();
+        break;
+
+      case uibuttongroup::properties::ID_BACKGROUNDCOLOR:
+      case uibuttongroup::properties::ID_FOREGROUNDCOLOR:
+      case uibuttongroup::properties::ID_HIGHLIGHTCOLOR:
+      case uibuttongroup::properties::ID_SHADOWCOLOR:
+        {
+          QPalette pal = frame->palette ();
 
-    case uibuttongroup::properties::ID_BORDERTYPE:
-      frame->setFrameStyle (frameStyleFromProperties (pp));
-      updateLayout ();
-      break;
+          setupPalette (pp, pal);
+          frame->setPalette (pal);
+          if (m_title)
+            m_title->setPalette (pal);
+        }
+        break;
+
+      case uibuttongroup::properties::ID_TITLE:
+        {
+          QString title = Utils::fromStdString (pp.get_title ());
 
-    case uibuttongroup::properties::ID_FONTNAME:
-    case uibuttongroup::properties::ID_FONTSIZE:
-    case uibuttongroup::properties::ID_FONTWEIGHT:
-    case uibuttongroup::properties::ID_FONTANGLE:
-      if (m_title)
-        {
-          m_title->setFont (Utils::computeFont<uibuttongroup> (pp));
-          m_title->resize (m_title->sizeHint ());
+          if (title.isEmpty ())
+            {
+              if (m_title)
+                delete m_title;
+              m_title = 0;
+            }
+          else
+            {
+              if (! m_title)
+                {
+                  QPalette pal = frame->palette ();
+
+                  m_title = new QLabel (title, frame);
+                  m_title->setAutoFillBackground (true);
+                  m_title->setContentsMargins (4, 0, 4, 0);
+                  m_title->setPalette (pal);
+                  m_title->setFont (Utils::computeFont<uibuttongroup> (pp));
+                  m_title->show ();
+                }
+              else
+                {
+                  m_title->setText (title);
+                  m_title->resize (m_title->sizeHint ());
+                }
+            }
           updateLayout ();
         }
-      break;
+        break;
 
-    case uibuttongroup::properties::ID_VISIBLE:
-      frame->setVisible (pp.is_visible ());
-      updateLayout ();
-      break;
+      case uibuttongroup::properties::ID_TITLEPOSITION:
+        updateLayout ();
+        break;
 
-    case uibuttongroup::properties::ID_SELECTEDOBJECT:
-      {
-        graphics_handle h = pp.get_selectedobject ();
-        gh_manager::auto_lock lock;
-        graphics_object go = gh_manager::get_object (h);
-        Object* selectedObject = Backend::toolkitObject (go);
-        ToggleButtonControl* toggle = static_cast<ToggleButtonControl*> (selectedObject);
-        RadioButtonControl* radio = static_cast<RadioButtonControl*>(selectedObject);
-        if (toggle)
-          {
-            go.get_properties ().set ("value", 1);
-          }
-        else if (radio)
+      case uibuttongroup::properties::ID_BORDERTYPE:
+        frame->setFrameStyle (frameStyleFromProperties (pp));
+        updateLayout ();
+        break;
+
+      case uibuttongroup::properties::ID_FONTNAME:
+      case uibuttongroup::properties::ID_FONTSIZE:
+      case uibuttongroup::properties::ID_FONTWEIGHT:
+      case uibuttongroup::properties::ID_FONTANGLE:
+        if (m_title)
           {
-            go.get_properties ().set ("value", 1);
+            m_title->setFont (Utils::computeFont<uibuttongroup> (pp));
+            m_title->resize (m_title->sizeHint ());
+            updateLayout ();
           }
-        else
-          {
-            m_hiddenbutton->setChecked (true);
-          }
-      }
-      break;
+        break;
+
+      case uibuttongroup::properties::ID_VISIBLE:
+        frame->setVisible (pp.is_visible ());
+        updateLayout ();
+        break;
 
-    default:
-      break;
-    }
+      case uibuttongroup::properties::ID_SELECTEDOBJECT:
+        {
+          graphics_handle h = pp.get_selectedobject ();
+          gh_manager::auto_lock lock;
+          graphics_object go = gh_manager::get_object (h);
+          Object* selectedObject = Backend::toolkitObject (go);
+          ToggleButtonControl* toggle = static_cast<ToggleButtonControl*>
+                                        (selectedObject);
+          RadioButtonControl* radio = static_cast<RadioButtonControl*>(selectedObject);
+          if (toggle)
+            {
+              go.get_properties ().set ("value", 1);
+            }
+          else if (radio)
+            {
+              go.get_properties ().set ("value", 1);
+            }
+          else
+            {
+              m_hiddenbutton->setChecked (true);
+            }
+        }
+        break;
 
-  m_blockUpdates = false;
-}
-
-void
-ButtonGroup::redraw (void)
-{
-  Canvas* canvas = m_container->canvas (m_handle);
+      default:
+        break;
+      }
 
-  if (canvas)
-    canvas->redraw ();
-}
+    m_blockUpdates = false;
+  }
 
-void
-ButtonGroup::updateLayout (void)
-{
-  uibuttongroup::properties& pp = properties<uibuttongroup> ();
-  QFrame* frame = qWidget<QFrame> ();
+  void
+  ButtonGroup::redraw (void)
+  {
+    Canvas* canvas = m_container->canvas (m_handle);
+
+    if (canvas)
+      canvas->redraw ();
+  }
 
-  Matrix bb = pp.get_boundingbox (true);
-  int bw = borderWidthFromProperties (pp);
+  void
+  ButtonGroup::updateLayout (void)
+  {
+    uibuttongroup::properties& pp = properties<uibuttongroup> ();
+    QFrame* frame = qWidget<QFrame> ();
 
-  frame->setFrameRect (QRect (octave::math::round (bb(0)) - bw, octave::math::round (bb(1)) - bw,
-                              octave::math::round (bb(2)) + 2*bw, octave::math::round (bb(3)) + 2*bw));
-  m_container->setGeometry (octave::math::round (bb(0)), octave::math::round (bb(1)),
-                            octave::math::round (bb(2)), octave::math::round (bb(3)));
+    Matrix bb = pp.get_boundingbox (true);
+    int bw = borderWidthFromProperties (pp);
 
-  if (m_blockUpdates)
-    pp.update_boundingbox ();
+    frame->setFrameRect (QRect (octave::math::round (bb(0)) - bw,
+                                octave::math::round (bb(1)) - bw,
+                                octave::math::round (bb(2)) + 2*bw, octave::math::round (bb(3)) + 2*bw));
+    m_container->setGeometry (octave::math::round (bb(0)),
+                              octave::math::round (bb(1)),
+                              octave::math::round (bb(2)), octave::math::round (bb(3)));
 
-  if (m_title)
-    {
-      QSize sz = m_title->sizeHint ();
-      int offset = 5;
+    if (m_blockUpdates)
+      pp.update_boundingbox ();
+
+    if (m_title)
+      {
+        QSize sz = m_title->sizeHint ();
+        int offset = 5;
 
-      if (pp.titleposition_is ("lefttop"))
-        m_title->move (bw+offset, 0);
-      else if (pp.titleposition_is ("righttop"))
-        m_title->move (frame->width () - bw - offset - sz.width (), 0);
-      else if (pp.titleposition_is ("leftbottom"))
-        m_title->move (bw+offset, frame->height () - sz.height ());
-      else if (pp.titleposition_is ("rightbottom"))
-        m_title->move (frame->width () - bw - offset - sz.width (),
-                       frame->height () - sz.height ());
-      else if (pp.titleposition_is ("centertop"))
-        m_title->move (frame->width () / 2 - sz.width () / 2, 0);
-      else if (pp.titleposition_is ("centerbottom"))
-        m_title->move (frame->width () / 2 - sz.width () / 2,
-                       frame->height () - sz.height ());
-    }
-}
+        if (pp.titleposition_is ("lefttop"))
+          m_title->move (bw+offset, 0);
+        else if (pp.titleposition_is ("righttop"))
+          m_title->move (frame->width () - bw - offset - sz.width (), 0);
+        else if (pp.titleposition_is ("leftbottom"))
+          m_title->move (bw+offset, frame->height () - sz.height ());
+        else if (pp.titleposition_is ("rightbottom"))
+          m_title->move (frame->width () - bw - offset - sz.width (),
+                         frame->height () - sz.height ());
+        else if (pp.titleposition_is ("centertop"))
+          m_title->move (frame->width () / 2 - sz.width () / 2, 0);
+        else if (pp.titleposition_is ("centerbottom"))
+          m_title->move (frame->width () / 2 - sz.width () / 2,
+                         frame->height () - sz.height ());
+      }
+  }
 
-void
-ButtonGroup::selectNothing (void)
-{
-  m_hiddenbutton->setChecked (true);
-}
+  void
+  ButtonGroup::selectNothing (void)
+  {
+    m_hiddenbutton->setChecked (true);
+  }
 
 
-void
-ButtonGroup::addButton (QAbstractButton* btn)
-{
-  m_buttongroup->addButton(btn);
-  connect (btn, SIGNAL (toggled (bool)), SLOT (buttonToggled (bool)));
-}
+  void
+  ButtonGroup::addButton (QAbstractButton* btn)
+  {
+    m_buttongroup->addButton(btn);
+    connect (btn, SIGNAL (toggled (bool)), SLOT (buttonToggled (bool)));
+  }
+
+  void
+  ButtonGroup::buttonToggled (bool toggled)
+  {
+    Q_UNUSED (toggled);
+    if (!m_blockUpdates)
+      {
+        gh_manager::auto_lock lock;
+        uibuttongroup::properties& bp = properties<uibuttongroup> ();
+
+        graphics_handle oldValue = bp.get_selectedobject();
 
-void
-ButtonGroup::buttonToggled (bool toggled)
-{
-  Q_UNUSED (toggled);
-  if (!m_blockUpdates)
+        QAbstractButton* checkedBtn = m_buttongroup->checkedButton();
+
+        graphics_handle newValue = graphics_handle ();
+        if (checkedBtn != m_hiddenbutton)
+          {
+            Object* checkedObj = Object::fromQObject(checkedBtn);
+            newValue = checkedObj->properties ().get___myhandle__ ();
+          }
+
+        if (oldValue != newValue)
+          gh_manager::post_set (m_handle, "selectedobject", newValue.as_octave_value (),
+                                false);
+      }
+  }
+
+  void
+  ButtonGroup::buttonClicked (QAbstractButton* btn)
   {
+    Q_UNUSED(btn);
+
     gh_manager::auto_lock lock;
     uibuttongroup::properties& bp = properties<uibuttongroup> ();
 
     graphics_handle oldValue = bp.get_selectedobject();
 
     QAbstractButton* checkedBtn = m_buttongroup->checkedButton();
-
-    graphics_handle newValue = graphics_handle ();
-    if (checkedBtn != m_hiddenbutton)
-      {
-        Object* checkedObj = Object::fromQObject(checkedBtn);
-        newValue = checkedObj->properties ().get___myhandle__ ();
-      }
+    Object* checkedObj = Object::fromQObject(checkedBtn);
+    graphics_handle newValue = checkedObj->properties ().get___myhandle__ ();
 
     if (oldValue != newValue)
-      gh_manager::post_set (m_handle, "selectedobject", newValue.as_octave_value (), false);
+      {
+        octave_scalar_map eventData;
+        eventData.setfield ("OldValue", oldValue.as_octave_value ());
+        eventData.setfield ("NewValue", newValue.as_octave_value ());
+        eventData.setfield ("Source", bp.get___myhandle__ ().as_octave_value ());
+        eventData.setfield ("EventName", "SelectionChanged");
+        octave_value selectionChangedEventObject = octave_value (new octave_struct (
+              eventData));
+        gh_manager::post_callback(m_handle, "selectionchangedfcn",
+                                  selectionChangedEventObject);
+      }
   }
-}
-
-void
-ButtonGroup::buttonClicked (QAbstractButton* btn)
-{
-  Q_UNUSED(btn);
-
-  gh_manager::auto_lock lock;
-  uibuttongroup::properties& bp = properties<uibuttongroup> ();
-
-  graphics_handle oldValue = bp.get_selectedobject();
-
-  QAbstractButton* checkedBtn = m_buttongroup->checkedButton();
-  Object* checkedObj = Object::fromQObject(checkedBtn);
-  graphics_handle newValue = checkedObj->properties ().get___myhandle__ ();
-
-  if (oldValue != newValue)
-    {
-      octave_scalar_map eventData;
-      eventData.setfield ("OldValue", oldValue.as_octave_value ());
-      eventData.setfield ("NewValue", newValue.as_octave_value ());
-      eventData.setfield ("Source", bp.get___myhandle__ ().as_octave_value ());
-      eventData.setfield ("EventName", "SelectionChanged");
-      octave_value selectionChangedEventObject = octave_value (new octave_struct (eventData));
-      gh_manager::post_callback(m_handle, "selectionchangedfcn", selectionChangedEventObject);
-    }
-}
 
 };
+
diff --git a/libgui/graphics/ButtonGroup.h b/libgui/graphics/ButtonGroup.h
--- a/libgui/graphics/ButtonGroup.h
+++ b/libgui/graphics/ButtonGroup.h
@@ -29,50 +29,52 @@ class QAbstractButton;
 class QButtonGroup;
 class QFrame;
 class QLabel;
 class QRadioButton;
 
 namespace QtHandles
 {
 
-class Container;
+  class Container;
 
-class ButtonGroup : public Object
-{
-  Q_OBJECT
+  class ButtonGroup : public Object
+  {
+    Q_OBJECT
 
-public:
-  ButtonGroup (const graphics_object& go, QButtonGroup* buttongroup, QFrame* frame);
-  ~ButtonGroup (void);
-
-  Container* innerContainer (void) { return m_container; }
+  public:
+    ButtonGroup (const graphics_object& go, QButtonGroup* buttongroup,
+                 QFrame* frame);
+    ~ButtonGroup (void);
 
-  bool eventFilter (QObject* watched, QEvent* event);
+    Container* innerContainer (void) { return m_container; }
+
+    bool eventFilter (QObject* watched, QEvent* event);
 
-  static ButtonGroup* create (const graphics_object& go);
+    static ButtonGroup* create (const graphics_object& go);
 
-  void addButton (QAbstractButton* btn);
+    void addButton (QAbstractButton* btn);
 
-  void selectNothing (void);
+    void selectNothing (void);
 
-protected:
-  void update (int pId);
-  void redraw (void);
+  protected:
+    void update (int pId);
+    void redraw (void);
 
-private slots:
-  void buttonToggled (bool toggled);
-  void buttonClicked (QAbstractButton* btn);
+  private slots:
+    void buttonToggled (bool toggled);
+    void buttonClicked (QAbstractButton* btn);
 
-private:
-  void updateLayout (void);
+  private:
+    void updateLayout (void);
 
-private:
-  QButtonGroup* m_buttongroup;
-  QRadioButton* m_hiddenbutton;
-  Container* m_container;
-  QLabel* m_title;
-  bool m_blockUpdates;
-};
+  private:
+    QButtonGroup* m_buttongroup;
+    QRadioButton* m_hiddenbutton;
+    Container* m_container;
+    QLabel* m_title;
+    bool m_blockUpdates;
+  };
 
 }; // namespace QtHandles
 
 #endif
+
diff --git a/libgui/graphics/Canvas.cc b/libgui/graphics/Canvas.cc
--- a/libgui/graphics/Canvas.cc
+++ b/libgui/graphics/Canvas.cc
@@ -45,988 +45,990 @@ along with Octave; see the file COPYING.
 #include "oct-opengl.h"
 #include "octave-qt-link.h"
 
 #include "builtin-defun-decls.h"
 
 namespace QtHandles
 {
 
-void
-Canvas::redraw (bool sync)
-{
-  QWidget *w = qWidget ();
+  void
+  Canvas::redraw (bool sync)
+  {
+    QWidget *w = qWidget ();
 
-  if (w)
-    {
-      if (sync)
-        w->repaint ();
-      else
-        w->update ();
-    }
-}
-
-void
-Canvas::blockRedraw (bool block)
-{
-  m_redrawBlocked = block;
-}
-
-void
-Canvas::setCursor (MouseMode mode)
-{
-  QWidget *w = qWidget ();
+    if (w)
+      {
+        if (sync)
+          w->repaint ();
+        else
+          w->update ();
+      }
+  }
 
-  if (w)
-    {
-      static QCursor origCursor = w->cursor ();
-
-      switch (mode)
-        {
-        case PanMode:
-        case RotateMode:
-          w->setCursor (Qt::OpenHandCursor);
-          break;
+  void
+  Canvas::blockRedraw (bool block)
+  {
+    m_redrawBlocked = block;
+  }
 
-        case ZoomInMode:
-          w->setCursor (QPixmap (":/images/zoom-in.png"));
-          break;
+  void
+  Canvas::setCursor (MouseMode mode)
+  {
+    QWidget *w = qWidget ();
 
-        case ZoomOutMode:
-          w->setCursor (QPixmap (":/images/zoom-out.png"));
-          break;
-
-        default:
-          w->setCursor (origCursor);
-          break;
-        }
-    }
-}
+    if (w)
+      {
+        static QCursor origCursor = w->cursor ();
 
-void
-Canvas::print (const QString& file_cmd, const QString& term)
-{
-  gh_manager::auto_lock lock;
-  graphics_object obj = gh_manager::get_object (m_handle);
-
-  if (obj.valid_object ())
-    {
-      graphics_object figObj (obj.get_ancestor ("figure"));
+        switch (mode)
+          {
+          case PanMode:
+          case RotateMode:
+            w->setCursor (Qt::OpenHandCursor);
+            break;
 
-      gl2ps_print (figObj, file_cmd.toStdString (), term.toStdString ());
-    }
-}
+          case ZoomInMode:
+            w->setCursor (QPixmap (":/images/zoom-in.png"));
+            break;
 
-/*
-   Two updateCurrentPoint() routines are required:
-   1) Used for QMouseEvents where cursor position data is in callback from Qt.
-   2) Used for QKeyEvents where cursor position must be determined.
-*/
-void
-Canvas::updateCurrentPoint(const graphics_object& fig,
-                           const graphics_object& obj, QMouseEvent* event)
-{
-  gh_manager::auto_lock lock;
+          case ZoomOutMode:
+            w->setCursor (QPixmap (":/images/zoom-out.png"));
+            break;
 
-  gh_manager::post_set (fig.get_handle (), "currentpoint",
-                        Utils::figureCurrentPoint (fig, event), false);
-
-  Matrix children = obj.get_properties ().get_children ();
-  octave_idx_type num_children = children.numel ();
-
-  for (int i = 0; i < num_children; i++)
-    {
-      graphics_object childObj (gh_manager::get_object (children(i)));
+          default:
+            w->setCursor (origCursor);
+            break;
+          }
+      }
+  }
 
-      if (childObj.isa ("axes"))
-        {
-          axes::properties& ap = Utils::properties<axes> (childObj);
-          Matrix x_zlim = ap.get_transform_zlim ();
-          graphics_xform x_form = ap.get_transform ();
+  void
+  Canvas::print (const QString& file_cmd, const QString& term)
+  {
+    gh_manager::auto_lock lock;
+    graphics_object obj = gh_manager::get_object (m_handle);
 
-          ColumnVector p1 = x_form.untransform (event->x (), event->y (),
-                                                x_zlim(0));
-          ColumnVector p2 = x_form.untransform (event->x (), event->y (),
-                                                x_zlim(1));
-
-          Matrix cp (2, 3, 0.0);
-
-          cp(0,0) = p1(0); cp(0,1) = p1(1); cp(0,2) = p1(2);
-          cp(1,0) = p2(0); cp(1,1) = p2(1); cp(1,2) = p2(2);
+    if (obj.valid_object ())
+      {
+        graphics_object figObj (obj.get_ancestor ("figure"));
 
-          gh_manager::post_set (childObj.get_handle (), "currentpoint", cp,
-                                false);
-        }
-    }
-}
+        gl2ps_print (figObj, file_cmd.toStdString (), term.toStdString ());
+      }
+  }
 
-void
-Canvas::updateCurrentPoint(const graphics_object& fig,
-                           const graphics_object& obj)
-{
-  gh_manager::auto_lock lock;
-
-  gh_manager::post_set (fig.get_handle (), "currentpoint",
-                        Utils::figureCurrentPoint (fig), false);
-
-  Matrix children = obj.get_properties ().get_children ();
-  octave_idx_type num_children = children.numel ();
-
-  for (int i = 0; i < num_children; i++)
-    {
-      graphics_object childObj (gh_manager::get_object (children(i)));
+  /*
+     Two updateCurrentPoint() routines are required:
+     1) Used for QMouseEvents where cursor position data is in callback from Qt.
+     2) Used for QKeyEvents where cursor position must be determined.
+  */
+  void
+  Canvas::updateCurrentPoint(const graphics_object& fig,
+                             const graphics_object& obj, QMouseEvent* event)
+  {
+    gh_manager::auto_lock lock;
 
-      if (childObj.isa ("axes"))
-        {
-          // FIXME: QCursor::pos() may give inaccurate results with asynchronous
-          //        window systems like X11 over ssh.
-          QWidget *w = qWidget ();
-          QPoint p = w->mapFromGlobal (QCursor::pos ());
-          axes::properties& ap = Utils::properties<axes> (childObj);
-          Matrix x_zlim = ap.get_transform_zlim ();
-          graphics_xform x_form = ap.get_transform ();
+    gh_manager::post_set (fig.get_handle (), "currentpoint",
+                          Utils::figureCurrentPoint (fig, event), false);
 
-          ColumnVector p1 = x_form.untransform (p.x (), p.y (), x_zlim(0));
-          ColumnVector p2 = x_form.untransform (p.x (), p.y (), x_zlim(1));
+    Matrix children = obj.get_properties ().get_children ();
+    octave_idx_type num_children = children.numel ();
 
-          Matrix cp (2, 3, 0.0);
-
-          cp(0,0) = p1(0); cp(0,1) = p1(1); cp(0,2) = p1(2);
-          cp(1,0) = p2(0); cp(1,1) = p2(1); cp(1,2) = p2(2);
+    for (int i = 0; i < num_children; i++)
+      {
+        graphics_object childObj (gh_manager::get_object (children(i)));
 
-          gh_manager::post_set (childObj.get_handle (), "currentpoint", cp,
-                                false);
-        }
-    }
-}
-
-void
-Canvas::annotation_callback (const octave_value_list& args)
-{
-  Ffeval (ovl ("annotation").append (args));
+        if (childObj.isa ("axes"))
+          {
+            axes::properties& ap = Utils::properties<axes> (childObj);
+            Matrix x_zlim = ap.get_transform_zlim ();
+            graphics_xform x_form = ap.get_transform ();
 
-  redraw ();
-}
+            ColumnVector p1 = x_form.untransform (event->x (), event->y (),
+                                                  x_zlim(0));
+            ColumnVector p2 = x_form.untransform (event->x (), event->y (),
+                                                  x_zlim(1));
 
-void
-Canvas::canvasToggleAxes (const graphics_handle& handle)
-{
-  gh_manager::auto_lock lock;
-
-  graphics_object go = gh_manager::get_object (handle);
+            Matrix cp (2, 3, 0.0);
 
-  if (go.valid_object ())
-    {
-      figure::properties& fp = Utils::properties<figure> (go);
-
-      graphics_handle ah = fp.get_currentaxes ();
-
-      graphics_object ax = gh_manager::get_object (ah);
+            cp(0,0) = p1(0); cp(0,1) = p1(1); cp(0,2) = p1(2);
+            cp(1,0) = p2(0); cp(1,1) = p2(1); cp(1,2) = p2(2);
 
-      if (ax.valid_object ())
-        {
-          axes::properties& ap = Utils::properties<axes> (ax);
-
-          if (ap.handlevisibility_is ("on"))
-            {
-              ap.set_visible (! ap.is_visible ());
+            gh_manager::post_set (childObj.get_handle (), "currentpoint", cp,
+                                  false);
+          }
+      }
+  }
 
-              redraw (true);
-            }
-        }
-    }
-}
-
-void
-Canvas::canvasToggleGrid (const graphics_handle& handle)
-{
-  gh_manager::auto_lock lock;
-
-  graphics_object go = gh_manager::get_object (handle);
+  void
+  Canvas::updateCurrentPoint(const graphics_object& fig,
+                             const graphics_object& obj)
+  {
+    gh_manager::auto_lock lock;
 
-  if (go.valid_object ())
-    {
-      figure::properties& fp = Utils::properties<figure> (go);
-
-      graphics_handle ah = fp.get_currentaxes ();
-
-      graphics_object ax = gh_manager::get_object (ah);
+    gh_manager::post_set (fig.get_handle (), "currentpoint",
+                          Utils::figureCurrentPoint (fig), false);
 
-      if (ax.valid_object ())
-        {
-          axes::properties& ap = Utils::properties<axes> (ax);
+    Matrix children = obj.get_properties ().get_children ();
+    octave_idx_type num_children = children.numel ();
 
-          std::string tmp;
-
-          // If any grid is off, then turn them all on.  If they are all
-          // on, then turn them off.
+    for (int i = 0; i < num_children; i++)
+      {
+        graphics_object childObj (gh_manager::get_object (children(i)));
 
-          std::string state = ((ap.get_xgrid () == "off"
-                                || ap.get_ygrid () == "off"
-                                || ap.get_zgrid () == "off")
-                               ? "on" : "off");
-
-          ap.set_xgrid (state);
-          ap.set_ygrid (state);
-          ap.set_zgrid (state);
+        if (childObj.isa ("axes"))
+          {
+            // FIXME: QCursor::pos() may give inaccurate results with asynchronous
+            //        window systems like X11 over ssh.
+            QWidget *w = qWidget ();
+            QPoint p = w->mapFromGlobal (QCursor::pos ());
+            axes::properties& ap = Utils::properties<axes> (childObj);
+            Matrix x_zlim = ap.get_transform_zlim ();
+            graphics_xform x_form = ap.get_transform ();
 
-          redraw (true);
-        }
-    }
-}
-
-static void
-autoscale_axes (axes::properties& ap)
-{
-  ap.clear_zoom_stack ();
-
-  ap.set_xlimmode ("auto");
-  ap.set_ylimmode ("auto");
-  ap.set_zlimmode ("auto");
-}
+            ColumnVector p1 = x_form.untransform (p.x (), p.y (), x_zlim(0));
+            ColumnVector p2 = x_form.untransform (p.x (), p.y (), x_zlim(1));
 
-void
-Canvas::canvasAutoAxes (const graphics_handle& handle)
-{
-  gh_manager::auto_lock lock;
+            Matrix cp (2, 3, 0.0);
 
-  graphics_object go = gh_manager::get_object (handle);
-
-  if (go.valid_object ())
-    {
-      figure::properties& fp = Utils::properties<figure> (go);
-
-      graphics_handle ah = fp.get_currentaxes ();
+            cp(0,0) = p1(0); cp(0,1) = p1(1); cp(0,2) = p1(2);
+            cp(1,0) = p2(0); cp(1,1) = p2(1); cp(1,2) = p2(2);
 
-      graphics_object ax = gh_manager::get_object (ah);
-
-      if (ax.valid_object ())
-        {
-          axes::properties& ap = Utils::properties<axes> (ax);
+            gh_manager::post_set (childObj.get_handle (), "currentpoint", cp,
+                                  false);
+          }
+      }
+  }
 
-          autoscale_axes (ap);
-
-          redraw (true);
-        }
-    }
-}
+  void
+  Canvas::annotation_callback (const octave_value_list& args)
+  {
+    Ffeval (ovl ("annotation").append (args));
 
-void
-Canvas::canvasPaintEvent (void)
-{
-  if (! m_redrawBlocked)
-    {
-      gh_manager::auto_lock lock;
+    redraw ();
+  }
 
-      draw (m_handle);
+  void
+  Canvas::canvasToggleAxes (const graphics_handle& handle)
+  {
+    gh_manager::auto_lock lock;
 
-      if ((m_mouseMode == ZoomInMode && m_mouseAxes.ok ()) || m_rectMode)
-        drawZoomBox (m_mouseAnchor, m_mouseCurrent);
-    }
-}
+    graphics_object go = gh_manager::get_object (handle);
 
-static bool
-pan_enabled (const graphics_object figObj)
-{
-  // Getting pan mode property:
-  octave_value ov_pm
-    = Utils::properties<figure> (figObj).get___pan_mode__ ();
+    if (go.valid_object ())
+      {
+        figure::properties& fp = Utils::properties<figure> (go);
 
-  octave_scalar_map pm = ov_pm.scalar_map_value ();
-
-  return pm.contents ("Enable").string_value () == "on";
-}
+        graphics_handle ah = fp.get_currentaxes ();
 
-static std::string
-pan_mode (const graphics_object figObj)
-{
-  // Getting pan mode property:
-  octave_value ov_pm
-    = Utils::properties<figure> (figObj).get___pan_mode__ ();
+        graphics_object ax = gh_manager::get_object (ah);
 
-  octave_scalar_map pm = ov_pm.scalar_map_value ();
-
-  return pm.contents ("Motion").string_value ();
-}
+        if (ax.valid_object ())
+          {
+            axes::properties& ap = Utils::properties<axes> (ax);
 
-static bool
-zoom_enabled (const graphics_object figObj)
-{
-  // Getting zoom mode property:
-  octave_value ov_zm
-    = Utils::properties<figure> (figObj).get___zoom_mode__ ();
-
-  octave_scalar_map zm = ov_zm.scalar_map_value ();
+            if (ap.handlevisibility_is ("on"))
+              {
+                ap.set_visible (! ap.is_visible ());
 
-  return zm.contents ("Enable").string_value () == "on";
-}
-
-static std::string
-zoom_mode (const graphics_object figObj)
-{
-  // Getting zoom mode property:
-  octave_value ov_zm
-    = Utils::properties<figure> (figObj).get___zoom_mode__ ();
+                redraw (true);
+              }
+          }
+      }
+  }
 
-  octave_scalar_map zm = ov_zm.scalar_map_value ();
-
-  return zm.contents ("Motion").string_value ();
-}
+  void
+  Canvas::canvasToggleGrid (const graphics_handle& handle)
+  {
+    gh_manager::auto_lock lock;
 
-void
-Canvas::select_object (graphics_object obj, QMouseEvent* event,
-                       graphics_object &currentObj, graphics_object &axesObj,
-                       bool axes_only)
-{
-  QList<graphics_object> axesList;
-  Matrix children = obj.get_properties ().get_all_children ();
-  octave_idx_type num_children = children.numel ();
+    graphics_object go = gh_manager::get_object (handle);
 
-  for (int i = 0; i < num_children; i++)
-    {
-      graphics_object childObj (gh_manager::get_object (children(i)));
+    if (go.valid_object ())
+      {
+        figure::properties& fp = Utils::properties<figure> (go);
+
+        graphics_handle ah = fp.get_currentaxes ();
 
-      if (childObj.isa ("axes"))
-        axesList.append (childObj);
-      else if (childObj.isa ("uicontrol") || childObj.isa ("uipanel")
-               || childObj.isa ("uibuttongroup"))
-        {
-          Matrix bb = childObj.get_properties ().get_boundingbox (false);
-          QRectF r (bb(0), bb(1), bb(2), bb(3));
+        graphics_object ax = gh_manager::get_object (ah);
 
-          r.adjust (-5, -5, 5, 5);
+        if (ax.valid_object ())
+          {
+            axes::properties& ap = Utils::properties<axes> (ax);
+
+            std::string tmp;
 
-#if (HAVE_QT4)
-          bool rect_contains_pos = r.contains (event->posF ());
-#else
-          bool rect_contains_pos = r.contains (event->localPos ());
-#endif
-          if (rect_contains_pos)
-            {
-              currentObj = childObj;
-              break;
-            }
-        }
-    }
+            // If any grid is off, then turn them all on.  If they are all
+            // on, then turn them off.
 
-  if (axes_only)
-    {
-      QPoint pt = event->pos ();
-
-      for (QList<graphics_object>::ConstIterator it = axesList.begin ();
-           it != axesList.end (); ++it)
-        {
-          const axes::properties& ap =
-            dynamic_cast<const axes::properties&> ((*it).get_properties ());
+            std::string state = ((ap.get_xgrid () == "off"
+                                  || ap.get_ygrid () == "off"
+                                  || ap.get_zgrid () == "off")
+                                 ? "on" : "off");
 
-          ColumnVector p0 = ap.pixel2coord (pt.x (), pt.y ());
-          Matrix xlim = ap.get_xlim ().matrix_value ();
-          Matrix ylim = ap.get_ylim ().matrix_value ();
+            ap.set_xgrid (state);
+            ap.set_ygrid (state);
+            ap.set_zgrid (state);
 
-          if (xlim(0) < p0(0) && xlim(1) > p0(0)
-              && ylim(0) < p0(1) && ylim(1) > p0(1))
-            {
-              axesObj = *it;
-              return;
-            }
-        }
-    }
-  else if (! currentObj)
-    {
-      for (QList<graphics_object>::ConstIterator it = axesList.begin ();
-           it != axesList.end (); ++it)
-        {
-          graphics_object go = selectFromAxes (*it, event->pos ());
+            redraw (true);
+          }
+      }
+  }
+
+  static void
+  autoscale_axes (axes::properties& ap)
+  {
+    ap.clear_zoom_stack ();
 
-          if (go)
-            {
-              currentObj = go;
-              axesObj = *it;
-            }
-          // FIXME: is this really necessary? the axes object should
-          //        have been selected through selectFromAxes anyway
-          else if (it->get_properties ().is_hittest ())
-            {
-              Matrix bb = it->get_properties ().get_boundingbox (true);
-              QRectF r (bb(0), bb(1), bb(2), bb(3));
+    ap.set_xlimmode ("auto");
+    ap.set_ylimmode ("auto");
+    ap.set_zlimmode ("auto");
+  }
+
+  void
+  Canvas::canvasAutoAxes (const graphics_handle& handle)
+  {
+    gh_manager::auto_lock lock;
 
-#if defined (HAVE_QT4)
-              bool rect_contains_pos = r.contains (event->posF ());
-#else
-              bool rect_contains_pos = r.contains (event->localPos ());
-#endif
-              if (rect_contains_pos)
-                axesObj = *it;
-            }
+    graphics_object go = gh_manager::get_object (handle);
+
+    if (go.valid_object ())
+      {
+        figure::properties& fp = Utils::properties<figure> (go);
 
-          if (axesObj && currentObj)
-            break;
-        }
-    }
-}
+        graphics_handle ah = fp.get_currentaxes ();
 
-void
-Canvas::canvasMouseMoveEvent (QMouseEvent* event)
-{
-  gh_manager::auto_lock lock;
-  graphics_object ax = gh_manager::get_object (m_mouseAxes);
+        graphics_object ax = gh_manager::get_object (ah);
 
-  if (m_mouseMode != NoMode && (ax.valid_object () || m_mouseMode == TextMode))
-    {
-      switch (m_mouseMode)
-        {
-        case RotateMode:
+        if (ax.valid_object ())
           {
             axes::properties& ap = Utils::properties<axes> (ax);
 
-            ap.rotate3d (m_mouseCurrent.x (), event->x (),
-                         m_mouseCurrent.y (), event->y ());
+            autoscale_axes (ap);
 
-            // Update current mouse position
-            m_mouseCurrent = event->pos ();
-
-            // Force immediate redraw
             redraw (true);
           }
-          break;
-        case TextMode:
-        case ZoomInMode:
-        case ZoomOutMode:
-          m_mouseCurrent = event->pos ();
-          redraw (true);
-          break;
+      }
+  }
+
+  void
+  Canvas::canvasPaintEvent (void)
+  {
+    if (! m_redrawBlocked)
+      {
+        gh_manager::auto_lock lock;
+
+        draw (m_handle);
+
+        if ((m_mouseMode == ZoomInMode && m_mouseAxes.ok ()) || m_rectMode)
+          drawZoomBox (m_mouseAnchor, m_mouseCurrent);
+      }
+  }
+
+  static bool
+  pan_enabled (const graphics_object figObj)
+  {
+    // Getting pan mode property:
+    octave_value ov_pm
+      = Utils::properties<figure> (figObj).get___pan_mode__ ();
+
+    octave_scalar_map pm = ov_pm.scalar_map_value ();
+
+    return pm.contents ("Enable").string_value () == "on";
+  }
+
+  static std::string
+  pan_mode (const graphics_object figObj)
+  {
+    // Getting pan mode property:
+    octave_value ov_pm
+      = Utils::properties<figure> (figObj).get___pan_mode__ ();
+
+    octave_scalar_map pm = ov_pm.scalar_map_value ();
+
+    return pm.contents ("Motion").string_value ();
+  }
+
+  static bool
+  zoom_enabled (const graphics_object figObj)
+  {
+    // Getting zoom mode property:
+    octave_value ov_zm
+      = Utils::properties<figure> (figObj).get___zoom_mode__ ();
+
+    octave_scalar_map zm = ov_zm.scalar_map_value ();
+
+    return zm.contents ("Enable").string_value () == "on";
+  }
+
+  static std::string
+  zoom_mode (const graphics_object figObj)
+  {
+    // Getting zoom mode property:
+    octave_value ov_zm
+      = Utils::properties<figure> (figObj).get___zoom_mode__ ();
+
+    octave_scalar_map zm = ov_zm.scalar_map_value ();
+
+    return zm.contents ("Motion").string_value ();
+  }
+
+  void
+  Canvas::select_object (graphics_object obj, QMouseEvent* event,
+                         graphics_object &currentObj, graphics_object &axesObj,
+                         bool axes_only)
+  {
+    QList<graphics_object> axesList;
+    Matrix children = obj.get_properties ().get_all_children ();
+    octave_idx_type num_children = children.numel ();
 
-        case PanMode:
+    for (int i = 0; i < num_children; i++)
+      {
+        graphics_object childObj (gh_manager::get_object (children(i)));
+
+        if (childObj.isa ("axes"))
+          axesList.append (childObj);
+        else if (childObj.isa ("uicontrol") || childObj.isa ("uipanel")
+                 || childObj.isa ("uibuttongroup"))
+          {
+            Matrix bb = childObj.get_properties ().get_boundingbox (false);
+            QRectF r (bb(0), bb(1), bb(2), bb(3));
+
+            r.adjust (-5, -5, 5, 5);
+
+#if (HAVE_QT4)
+            bool rect_contains_pos = r.contains (event->posF ());
+#else
+            bool rect_contains_pos = r.contains (event->localPos ());
+#endif
+            if (rect_contains_pos)
+              {
+                currentObj = childObj;
+                break;
+              }
+          }
+      }
+
+    if (axes_only)
+      {
+        QPoint pt = event->pos ();
+
+        for (QList<graphics_object>::ConstIterator it = axesList.begin ();
+             it != axesList.end (); ++it)
           {
-            axes::properties& ap = Utils::properties<axes> (ax);
+            const axes::properties& ap =
+              dynamic_cast<const axes::properties&> ((*it).get_properties ());
+
+            ColumnVector p0 = ap.pixel2coord (pt.x (), pt.y ());
+            Matrix xlim = ap.get_xlim ().matrix_value ();
+            Matrix ylim = ap.get_ylim ().matrix_value ();
 
-            graphics_object figObj (ax.get_ancestor ("figure"));
+            if (xlim(0) < p0(0) && xlim(1) > p0(0)
+                && ylim(0) < p0(1) && ylim(1) > p0(1))
+              {
+                axesObj = *it;
+                return;
+              }
+          }
+      }
+    else if (! currentObj)
+      {
+        for (QList<graphics_object>::ConstIterator it = axesList.begin ();
+             it != axesList.end (); ++it)
+          {
+            graphics_object go = selectFromAxes (*it, event->pos ());
+
+            if (go)
+              {
+                currentObj = go;
+                axesObj = *it;
+              }
+            // FIXME: is this really necessary? the axes object should
+            //        have been selected through selectFromAxes anyway
+            else if (it->get_properties ().is_hittest ())
+              {
+                Matrix bb = it->get_properties ().get_boundingbox (true);
+                QRectF r (bb(0), bb(1), bb(2), bb(3));
+
+#if defined (HAVE_QT4)
+                bool rect_contains_pos = r.contains (event->posF ());
+#else
+                bool rect_contains_pos = r.contains (event->localPos ());
+#endif
+                if (rect_contains_pos)
+                  axesObj = *it;
+              }
 
-            std::string mode = pan_mode (figObj);
+            if (axesObj && currentObj)
+              break;
+          }
+      }
+  }
+
+  void
+  Canvas::canvasMouseMoveEvent (QMouseEvent* event)
+  {
+    gh_manager::auto_lock lock;
+    graphics_object ax = gh_manager::get_object (m_mouseAxes);
+
+    if (m_mouseMode != NoMode && (ax.valid_object () || m_mouseMode == TextMode))
+      {
+        switch (m_mouseMode)
+          {
+          case RotateMode:
+            {
+              axes::properties& ap = Utils::properties<axes> (ax);
+
+              ap.rotate3d (m_mouseCurrent.x (), event->x (),
+                           m_mouseCurrent.y (), event->y ());
+
+              // Update current mouse position
+              m_mouseCurrent = event->pos ();
+
+              // Force immediate redraw
+              redraw (true);
+            }
+            break;
+          case TextMode:
+          case ZoomInMode:
+          case ZoomOutMode:
+            m_mouseCurrent = event->pos ();
+            redraw (true);
+            break;
 
-            ColumnVector p0 = ap.pixel2coord (m_mouseCurrent.x (),
-                                              m_mouseCurrent.y ());
-            ColumnVector p1 = ap.pixel2coord (event->x (),
-                                              event->y ());
+          case PanMode:
+            {
+              axes::properties& ap = Utils::properties<axes> (ax);
+
+              graphics_object figObj (ax.get_ancestor ("figure"));
+
+              std::string mode = pan_mode (figObj);
+
+              ColumnVector p0 = ap.pixel2coord (m_mouseCurrent.x (),
+                                                m_mouseCurrent.y ());
+              ColumnVector p1 = ap.pixel2coord (event->x (),
+                                                event->y ());
+
+              ap.translate_view (mode, p0(0), p1(0), p0(1), p1(1));
+
+              // Update current mouse position
+              m_mouseCurrent = event->pos ();
+
+              // Force immediate redraw
+              redraw (true);
+            }
+
+          default:
+            break;
+          }
+      }
+    else if (m_mouseMode == NoMode)
+      {
+        graphics_object obj = gh_manager::get_object (m_handle);
+
+        if (obj.valid_object ())
+          {
+            graphics_object figObj (obj.get_ancestor ("figure"));
+
+            if (figObj.valid_object () &&
+                ! figObj.get ("windowbuttonmotionfcn").is_empty ())
+              {
+                updateCurrentPoint (figObj, obj, event);
+                gh_manager::post_callback (figObj.get_handle (),
+                                           "windowbuttonmotionfcn");
+              }
+          }
+      }
 
-            ap.translate_view (mode, p0(0), p1(0), p0(1), p1(1));
+    // Update mouse coordinates in the figure window status bar
+    graphics_object obj = gh_manager::get_object (m_handle);
+    graphics_object figObj = obj.get_ancestor ("figure");
+
+    if (figObj.valid_object () && obj.valid_object ())
+      {
+        graphics_object currentObj, axesObj;
+        select_object (obj, event, currentObj, axesObj, true);
+
+        if (axesObj.valid_object ())
+          {
+            // FIXME: should we use signal/slot mechanism instead of
+            //        directly calling parent fig methods
+            Figure* fig =
+              dynamic_cast<Figure*> (Backend::toolkitObject (figObj));
+            axes::properties& ap = Utils::properties<axes> (axesObj);
+
+            if (fig)
+              fig->updateStatusBar (ap.pixel2coord (event->x (), event->y ()));
+          }
+      }
+  }
+
+  void
+  Canvas::canvasMouseDoubleClickEvent (QMouseEvent* event)
+  {
+    // same processing as normal click, but event type is MouseButtonDblClick
+    canvasMousePressEvent (event);
+  }
+
+  static double
+  button_number (QMouseEvent *event)
+  {
+    double retval = 0;
 
-            // Update current mouse position
-            m_mouseCurrent = event->pos ();
+    switch (event->button ())
+      {
+      case Qt::LeftButton:
+        retval = 1;
+        break;
+
+      case Qt::MidButton:
+        retval = 2;
+        break;
+
+      case Qt::RightButton:
+        retval = 3;
+        break;
+
+      default:
+        break;
+      }
+
+    return retval;
+  }
 
-            // Force immediate redraw
-            redraw (true);
+  void
+  Canvas::canvasMousePressEvent (QMouseEvent* event)
+  {
+    gh_manager::auto_lock lock;
+    graphics_object obj = gh_manager::get_object (m_handle);
+
+    bool isdblclick = (event->type () == QEvent::MouseButtonDblClick);
+
+    if (obj.valid_object ())
+      {
+        graphics_object figObj (obj.get_ancestor ("figure"));
+        graphics_object currentObj, axesObj;
+
+        select_object (obj, event, currentObj, axesObj);
+
+        if (axesObj)
+          {
+            if (axesObj.get_properties ().handlevisibility_is ("on")
+                && axesObj.get_properties ().get_tag () != "legend"
+                && axesObj.get_properties ().get_tag () != "colorbar")
+              Utils::properties<figure> (figObj)
+              .set_currentaxes (axesObj.get_handle ().as_octave_value ());
+            if (! currentObj)
+              currentObj = axesObj;
           }
 
-        default:
-          break;
-        }
-    }
-  else if (m_mouseMode == NoMode)
-    {
-      graphics_object obj = gh_manager::get_object (m_handle);
-
-      if (obj.valid_object ())
-        {
-          graphics_object figObj (obj.get_ancestor ("figure"));
-
-          if (figObj.valid_object () &&
-              ! figObj.get ("windowbuttonmotionfcn").is_empty ())
-            {
-              updateCurrentPoint (figObj, obj, event);
-              gh_manager::post_callback (figObj.get_handle (),
-                                         "windowbuttonmotionfcn");
-            }
-        }
-    }
-
-  // Update mouse coordinates in the figure window status bar
-  graphics_object obj = gh_manager::get_object (m_handle);
-  graphics_object figObj = obj.get_ancestor ("figure");
-
-  if (figObj.valid_object () && obj.valid_object ())
-    {
-      graphics_object currentObj, axesObj;
-      select_object (obj, event, currentObj, axesObj, true);
+        if (! currentObj)
+          currentObj = obj;
 
-      if (axesObj.valid_object ())
-        {
-          // FIXME: should we use signal/slot mechanism instead of
-          //        directly calling parent fig methods
-          Figure* fig =
-            dynamic_cast<Figure*> (Backend::toolkitObject (figObj));
-          axes::properties& ap = Utils::properties<axes> (axesObj);
-
-          if (fig)
-            fig->updateStatusBar (ap.pixel2coord (event->x (), event->y ()));
-        }
-    }
-}
+        if (currentObj.get_properties ().handlevisibility_is ("on"))
+          Utils::properties<figure> (figObj)
+          .set_currentobject (currentObj.get_handle ().as_octave_value ());
+        else
+          Utils::properties<figure> (figObj).set_currentobject (
+            octave::numeric_limits<double>::NaN ());
 
-void
-Canvas::canvasMouseDoubleClickEvent (QMouseEvent* event)
-{
-  // same processing as normal click, but event type is MouseButtonDblClick
-  canvasMousePressEvent (event);
-}
-
-static double
-button_number (QMouseEvent *event)
-{
-  double retval = 0;
+        Figure* fig = dynamic_cast<Figure*> (Backend::toolkitObject (figObj));
 
-  switch (event->button ())
-    {
-    case Qt::LeftButton:
-      retval = 1;
-      break;
-
-    case Qt::MidButton:
-      retval = 2;
-      break;
-
-    case Qt::RightButton:
-      retval = 3;
-      break;
+        MouseMode newMouseMode = NoMode;
 
-    default:
-      break;
-    }
-
-  return retval;
-}
-
-void
-Canvas::canvasMousePressEvent (QMouseEvent* event)
-{
-  gh_manager::auto_lock lock;
-  graphics_object obj = gh_manager::get_object (m_handle);
-
-  bool isdblclick = (event->type () == QEvent::MouseButtonDblClick);
-
-  if (obj.valid_object ())
-    {
-      graphics_object figObj (obj.get_ancestor ("figure"));
-      graphics_object currentObj, axesObj;
-
-      select_object (obj, event, currentObj, axesObj);
-
-      if (axesObj)
-        {
-              if (axesObj.get_properties ().handlevisibility_is ("on")
-                  && axesObj.get_properties ().get_tag () != "legend"
-                  && axesObj.get_properties ().get_tag () != "colorbar")
-            Utils::properties<figure> (figObj)
-              .set_currentaxes (axesObj.get_handle ().as_octave_value ());
-          if (! currentObj)
-            currentObj = axesObj;
-        }
-
-      if (! currentObj)
-        currentObj = obj;
+        if (fig)
+          newMouseMode = fig->mouseMode ();
 
-      if (currentObj.get_properties ().handlevisibility_is ("on"))
-        Utils::properties<figure> (figObj)
-          .set_currentobject (currentObj.get_handle ().as_octave_value ());
-      else
-        Utils::properties<figure> (figObj).set_currentobject (octave::numeric_limits<double>::NaN ());
-
-      Figure* fig = dynamic_cast<Figure*> (Backend::toolkitObject (figObj));
-
-      MouseMode newMouseMode = NoMode;
-
-      if (fig)
-        newMouseMode = fig->mouseMode ();
-
-      switch (newMouseMode)
-        {
-        case NoMode:
-          gh_manager::post_set (figObj.get_handle (), "selectiontype",
-                                Utils::figureSelectionType (event, isdblclick), false);
+        switch (newMouseMode)
+          {
+          case NoMode:
+            gh_manager::post_set (figObj.get_handle (), "selectiontype",
+                                  Utils::figureSelectionType (event, isdblclick), false);
 
-          updateCurrentPoint (figObj, obj, event);
-
-          gh_manager::post_callback (figObj.get_handle (),
-                                     "windowbuttondownfcn",
-                                     button_number (event));
+            updateCurrentPoint (figObj, obj, event);
 
-          if (currentObj.get ("buttondownfcn").is_empty ())
-            {
-              graphics_object parentObj =
-                gh_manager::get_object (currentObj.get_parent ());
-
-              if (parentObj.valid_object () && parentObj.isa ("hggroup"))
-                gh_manager::post_callback (parentObj.get_handle (),
-                                           "buttondownfcn",
-                                           button_number (event));
-            }
-          else
-            gh_manager::post_callback (currentObj.get_handle (),
-                                       "buttondownfcn",
+            gh_manager::post_callback (figObj.get_handle (),
+                                       "windowbuttondownfcn",
                                        button_number (event));
 
-          if (event->button () == Qt::RightButton)
-            ContextMenu::executeAt (currentObj.get_properties (),
-                                    event->globalPos ());
-          break;
-
-        case TextMode:
-          {
-            if (event->modifiers () == Qt::NoModifier)
+            if (currentObj.get ("buttondownfcn").is_empty ())
               {
-                switch (event->buttons ())
-                  {
-                  case Qt::LeftButton:
-                    m_mouseAnchor = m_mouseCurrent = event->pos ();
-                    m_mouseMode = newMouseMode;
-                    m_rectMode = true;
-                  }
-              }
-            redraw (false);
-          }
-          break;
+                graphics_object parentObj =
+                  gh_manager::get_object (currentObj.get_parent ());
 
-        case PanMode:
-        case RotateMode:
-        case ZoomInMode:
-        case ZoomOutMode:
-          if (axesObj && axesObj.get_properties ().handlevisibility_is ("on"))
-            {
-              bool redraw_figure = true;
+                if (parentObj.valid_object () && parentObj.isa ("hggroup"))
+                  gh_manager::post_callback (parentObj.get_handle (),
+                                             "buttondownfcn",
+                                             button_number (event));
+              }
+            else
+              gh_manager::post_callback (currentObj.get_handle (),
+                                         "buttondownfcn",
+                                         button_number (event));
 
-              if (isdblclick)
-                {
-                  if (event->button () == Qt::LeftButton)
-                    {
-                      axes::properties& ap = Utils::properties<axes> (axesObj);
+            if (event->button () == Qt::RightButton)
+              ContextMenu::executeAt (currentObj.get_properties (),
+                                      event->globalPos ());
+            break;
 
-                      autoscale_axes (ap);
-                    }
-                  else
-                    {
-                      redraw_figure = false;
-                    }
-                }
-              else if (event->modifiers () == Qt::NoModifier)
+          case TextMode:
+            {
+              if (event->modifiers () == Qt::NoModifier)
                 {
                   switch (event->buttons ())
                     {
                     case Qt::LeftButton:
                       m_mouseAnchor = m_mouseCurrent = event->pos ();
-                      m_mouseAxes = axesObj.get_handle ();
                       m_mouseMode = newMouseMode;
-                      m_clickMode = newMouseMode == ZoomInMode;
-                      break;
+                      m_rectMode = true;
+                    }
+                }
+              redraw (false);
+            }
+            break;
+
+          case PanMode:
+          case RotateMode:
+          case ZoomInMode:
+          case ZoomOutMode:
+            if (axesObj && axesObj.get_properties ().handlevisibility_is ("on"))
+              {
+                bool redraw_figure = true;
+
+                if (isdblclick)
+                  {
+                    if (event->button () == Qt::LeftButton)
+                      {
+                        axes::properties& ap = Utils::properties<axes> (axesObj);
 
-                    case Qt::RightButton:
-                      if (newMouseMode == ZoomInMode)
-                        {
-                          m_mouseAnchor = m_mouseCurrent = event->pos ();
-                          m_mouseAxes = axesObj.get_handle ();
-                          m_mouseMode = newMouseMode;
-                          m_clickMode = false;
-                        }
+                        autoscale_axes (ap);
+                      }
+                    else
+                      {
+                        redraw_figure = false;
+                      }
+                  }
+                else if (event->modifiers () == Qt::NoModifier)
+                  {
+                    switch (event->buttons ())
+                      {
+                      case Qt::LeftButton:
+                        m_mouseAnchor = m_mouseCurrent = event->pos ();
+                        m_mouseAxes = axesObj.get_handle ();
+                        m_mouseMode = newMouseMode;
+                        m_clickMode = newMouseMode == ZoomInMode;
+                        break;
 
-                      break;
+                      case Qt::RightButton:
+                        if (newMouseMode == ZoomInMode)
+                          {
+                            m_mouseAnchor = m_mouseCurrent = event->pos ();
+                            m_mouseAxes = axesObj.get_handle ();
+                            m_mouseMode = newMouseMode;
+                            m_clickMode = false;
+                          }
 
-                    case Qt::MidButton:
+                        break;
+
+                      case Qt::MidButton:
                         {
                           axes::properties& ap =
                             Utils::properties<axes> (axesObj);
 
                           autoscale_axes (ap);
                         }
-                      break;
+                        break;
 
-                    default:
-                      redraw_figure = false;
-                      break;
-                    }
-                }
-              else if (event->modifiers () == Qt::ShiftModifier)
-                {
-                  switch (event->buttons ())
-                    {
-                    case Qt::LeftButton:
-                      if (newMouseMode == ZoomInMode)
-                        {
-                          m_mouseAnchor = m_mouseCurrent = event->pos ();
-                          m_mouseAxes = axesObj.get_handle ();
-                          m_mouseMode = newMouseMode;
-                          m_clickMode = false;
-                        }
-                      break;
+                      default:
+                        redraw_figure = false;
+                        break;
+                      }
+                  }
+                else if (event->modifiers () == Qt::ShiftModifier)
+                  {
+                    switch (event->buttons ())
+                      {
+                      case Qt::LeftButton:
+                        if (newMouseMode == ZoomInMode)
+                          {
+                            m_mouseAnchor = m_mouseCurrent = event->pos ();
+                            m_mouseAxes = axesObj.get_handle ();
+                            m_mouseMode = newMouseMode;
+                            m_clickMode = false;
+                          }
+                        break;
 
-                    default:
-                      redraw_figure = false;
-                      break;
-                    }
-                }
+                      default:
+                        redraw_figure = false;
+                        break;
+                      }
+                  }
 
-              if (redraw_figure)
-                redraw (false);
-            }
-          break;
+                if (redraw_figure)
+                  redraw (false);
+              }
+            break;
 
-        default:
-          break;
-        }
-    }
+          default:
+            break;
+          }
+      }
 
-}
+  }
 
-void
-Canvas::canvasMouseReleaseEvent (QMouseEvent* event)
-{
-  if ((m_mouseMode == ZoomInMode || m_mouseMode == ZoomOutMode)
-      && m_mouseAxes.ok ())
-    {
-      gh_manager::auto_lock lock;
-      graphics_object ax = gh_manager::get_object (m_mouseAxes);
+  void
+  Canvas::canvasMouseReleaseEvent (QMouseEvent* event)
+  {
+    if ((m_mouseMode == ZoomInMode || m_mouseMode == ZoomOutMode)
+        && m_mouseAxes.ok ())
+      {
+        gh_manager::auto_lock lock;
+        graphics_object ax = gh_manager::get_object (m_mouseAxes);
 
-      if (ax.valid_object ())
-        {
-          axes::properties& ap = Utils::properties<axes> (ax);
+        if (ax.valid_object ())
+          {
+            axes::properties& ap = Utils::properties<axes> (ax);
 
-          graphics_object obj = gh_manager::get_object (m_handle);
+            graphics_object obj = gh_manager::get_object (m_handle);
 
-          graphics_object figObj (obj.get_ancestor ("figure"));
+            graphics_object figObj (obj.get_ancestor ("figure"));
 
-          std::string zm = zoom_mode (figObj);
+            std::string zm = zoom_mode (figObj);
 
-          if (m_mouseAnchor == event->pos ())
-            {
-              double factor = m_clickMode ? 2.0 : 0.5;
+            if (m_mouseAnchor == event->pos ())
+              {
+                double factor = m_clickMode ? 2.0 : 0.5;
 
-              ColumnVector p1 = ap.pixel2coord (event->x (), event->y ());
+                ColumnVector p1 = ap.pixel2coord (event->x (), event->y ());
 
-              ap.zoom_about_point (zm, p1(0), p1(1), factor);
-            }
-          else if (m_mouseMode == ZoomInMode)
-            {
-              ColumnVector p0 = ap.pixel2coord (m_mouseAnchor.x (),
-                                                m_mouseAnchor.y ());
-              ColumnVector p1 = ap.pixel2coord (event->x (),
-                                                event->y ());
+                ap.zoom_about_point (zm, p1(0), p1(1), factor);
+              }
+            else if (m_mouseMode == ZoomInMode)
+              {
+                ColumnVector p0 = ap.pixel2coord (m_mouseAnchor.x (),
+                                                  m_mouseAnchor.y ());
+                ColumnVector p1 = ap.pixel2coord (event->x (),
+                                                  event->y ());
 
-              Matrix xl (1, 2, 0.0);
-              Matrix yl (1, 2, 0.0);
+                Matrix xl (1, 2, 0.0);
+                Matrix yl (1, 2, 0.0);
 
-              xl(0) = std::min (p0(0), p1(0));
-              xl(1) = std::max (p0(0), p1(0));
-              yl(0) = std::min (p0(1), p1(1));
-              yl(1) = std::max (p0(1), p1(1));
+                xl(0) = std::min (p0(0), p1(0));
+                xl(1) = std::max (p0(0), p1(0));
+                yl(0) = std::min (p0(1), p1(1));
+                yl(1) = std::max (p0(1), p1(1));
 
-              ap.zoom (zm, xl, yl);
-            }
+                ap.zoom (zm, xl, yl);
+              }
 
-          redraw (false);
-        }
-    }
-  else if (m_mouseMode == NoMode)
-    {
-      gh_manager::auto_lock lock;
-      graphics_object obj = gh_manager::get_object (m_handle);
+            redraw (false);
+          }
+      }
+    else if (m_mouseMode == NoMode)
+      {
+        gh_manager::auto_lock lock;
+        graphics_object obj = gh_manager::get_object (m_handle);
 
-      if (obj.valid_object ())
-        {
-          graphics_object figObj (obj.get_ancestor ("figure"));
+        if (obj.valid_object ())
+          {
+            graphics_object figObj (obj.get_ancestor ("figure"));
 
-          updateCurrentPoint (figObj, obj, event);
-          gh_manager::post_callback (figObj.get_handle (),
-                                     "windowbuttonupfcn");
-        }
-    }
-  else if (m_mouseMode == TextMode)
-    {
-      gh_manager::auto_lock lock;
+            updateCurrentPoint (figObj, obj, event);
+            gh_manager::post_callback (figObj.get_handle (),
+                                       "windowbuttonupfcn");
+          }
+      }
+    else if (m_mouseMode == TextMode)
+      {
+        gh_manager::auto_lock lock;
 
-      graphics_object figObj =
-        gh_manager::get_object (m_handle).get_ancestor ("figure");
-      if (figObj.valid_object ())
-        {
-          QWidget *w = qWidget ();
-          if (w)
-            {
-              Matrix bb = figObj.get ("position").matrix_value ();
-              bb(0) = m_mouseAnchor.x () / bb(2);
-              bb(1) = 1.0 - (m_mouseAnchor.y () / bb(3));
-              bb(2) = (event->x () - m_mouseAnchor.x ()) / bb(2);
-              bb(3) = (m_mouseAnchor.y () - event->y ()) / bb(3);
+        graphics_object figObj =
+          gh_manager::get_object (m_handle).get_ancestor ("figure");
+        if (figObj.valid_object ())
+          {
+            QWidget *w = qWidget ();
+            if (w)
+              {
+                Matrix bb = figObj.get ("position").matrix_value ();
+                bb(0) = m_mouseAnchor.x () / bb(2);
+                bb(1) = 1.0 - (m_mouseAnchor.y () / bb(3));
+                bb(2) = (event->x () - m_mouseAnchor.x ()) / bb(2);
+                bb(3) = (m_mouseAnchor.y () - event->y ()) / bb(3);
 
-              octave_value_list props = ovl ("textbox", bb);
+                octave_value_list props = ovl ("textbox", bb);
 
-              annotation_dialog anno_dlg (w, props);
+                annotation_dialog anno_dlg (w, props);
 
-              if (anno_dlg.exec () == QDialog::Accepted)
-                {
-                  props = anno_dlg.get_properties ();
-                  props.prepend (figObj.get_handle ().as_octave_value ());
+                if (anno_dlg.exec () == QDialog::Accepted)
+                  {
+                    props = anno_dlg.get_properties ();
+                    props.prepend (figObj.get_handle ().as_octave_value ());
 
-                  octave_link::post_event (this, &Canvas::annotation_callback,
-                                           props);
-                }
-            }
-        }
-    }
-  m_rectMode = false;
-  m_mouseAxes = graphics_handle ();
-  m_mouseMode = NoMode;
-}
+                    octave_link::post_event (this, &Canvas::annotation_callback,
+                                             props);
+                  }
+              }
+          }
+      }
+    m_rectMode = false;
+    m_mouseAxes = graphics_handle ();
+    m_mouseMode = NoMode;
+  }
 
-void
-Canvas::canvasWheelEvent (QWheelEvent* event)
-{
-  gh_manager::auto_lock lock;
-  graphics_object obj = gh_manager::get_object (m_handle);
+  void
+  Canvas::canvasWheelEvent (QWheelEvent* event)
+  {
+    gh_manager::auto_lock lock;
+    graphics_object obj = gh_manager::get_object (m_handle);
 
-  if (obj.valid_object ())
-    {
-      std::string mode;
+    if (obj.valid_object ())
+      {
+        std::string mode;
 
-      graphics_object axesObj;
+        graphics_object axesObj;
 
-      Matrix children = obj.get_properties ().get_children ();
-      octave_idx_type num_children = children.numel ();
+        Matrix children = obj.get_properties ().get_children ();
+        octave_idx_type num_children = children.numel ();
 
-      for (int i = 0; i < num_children; i++)
-        {
-          graphics_object childObj (gh_manager::get_object (children(i)));
+        for (int i = 0; i < num_children; i++)
+          {
+            graphics_object childObj (gh_manager::get_object (children(i)));
 
-          if (childObj.isa ("axes"))
-            {
-              graphics_object go = selectFromAxes (childObj, event->pos ());
+            if (childObj.isa ("axes"))
+              {
+                graphics_object go = selectFromAxes (childObj, event->pos ());
 
-              if (go)
-                {
-                  axesObj = childObj;
-                  break;
-                }
-            }
-        }
+                if (go)
+                  {
+                    axesObj = childObj;
+                    break;
+                  }
+              }
+          }
 
-      if (axesObj)
-        {
-          MouseMode newMouseMode = NoMode;
+        if (axesObj)
+          {
+            MouseMode newMouseMode = NoMode;
 
-          graphics_object figObj (obj.get_ancestor ("figure"));
+            graphics_object figObj (obj.get_ancestor ("figure"));
 
-          Figure* fig = dynamic_cast<Figure*> (Backend::toolkitObject (figObj));
+            Figure* fig = dynamic_cast<Figure*> (Backend::toolkitObject (figObj));
 
-          if (fig)
-            newMouseMode = fig->mouseMode ();
+            if (fig)
+              newMouseMode = fig->mouseMode ();
 
-          if (axesObj.get_properties ().handlevisibility_is ("on"))
-            {
-              Utils::properties<figure> (figObj)
+            if (axesObj.get_properties ().handlevisibility_is ("on"))
+              {
+                Utils::properties<figure> (figObj)
                 .set_currentaxes (axesObj.get_handle ().as_octave_value ());
 
-              if (zoom_enabled (figObj))
-                {
-                  if (event->delta () > 0)
-                    newMouseMode = ZoomInMode;
-                  else
-                    newMouseMode = ZoomOutMode;
+                if (zoom_enabled (figObj))
+                  {
+                    if (event->delta () > 0)
+                      newMouseMode = ZoomInMode;
+                    else
+                      newMouseMode = ZoomOutMode;
 
-                  mode = zoom_mode (figObj);
-                }
-              else if (pan_enabled (figObj))
-                {
-                  newMouseMode = PanMode;
+                    mode = zoom_mode (figObj);
+                  }
+                else if (pan_enabled (figObj))
+                  {
+                    newMouseMode = PanMode;
 
-                  mode = pan_mode (figObj);
-                }
-            }
+                    mode = pan_mode (figObj);
+                  }
+              }
 
-          bool redrawFigure = true;
+            bool redrawFigure = true;
 
-          switch (newMouseMode)
-            {
-            case ZoomInMode:
-            case ZoomOutMode:
+            switch (newMouseMode)
               {
-                axes::properties& ap = Utils::properties<axes> (axesObj);
+              case ZoomInMode:
+              case ZoomOutMode:
+                {
+                  axes::properties& ap = Utils::properties<axes> (axesObj);
 
-                // Control how fast to zoom when using scroll wheel.
-                double wheel_zoom_speed = ap.get_mousewheelzoom ();
+                  // Control how fast to zoom when using scroll wheel.
+                  double wheel_zoom_speed = ap.get_mousewheelzoom ();
 
-                // Determine if we're zooming in or out.
-                double factor = (newMouseMode == ZoomInMode
-                                 ? 1 / (1.0 - wheel_zoom_speed)
-                                 : 1.0 - wheel_zoom_speed);
+                  // Determine if we're zooming in or out.
+                  double factor = (newMouseMode == ZoomInMode
+                                   ? 1 / (1.0 - wheel_zoom_speed)
+                                   : 1.0 - wheel_zoom_speed);
 
-                // FIXME: should we zoom about point for 2D plots?
+                  // FIXME: should we zoom about point for 2D plots?
 
-                ap.zoom (mode, factor);
-              }
-              break;
+                  ap.zoom (mode, factor);
+                }
+                break;
 
-            case PanMode:
-              {
-                axes::properties& ap = Utils::properties<axes> (axesObj);
+              case PanMode:
+                {
+                  axes::properties& ap = Utils::properties<axes> (axesObj);
 
-                double factor = event->delta () > 0 ? 0.1 : -0.1;
+                  double factor = event->delta () > 0 ? 0.1 : -0.1;
 
-                ap.pan (mode, factor);
-              }
-              break;
+                  ap.pan (mode, factor);
+                }
+                break;
 
-            default:
-              redrawFigure = false;
-              break;
-            }
+              default:
+                redrawFigure = false;
+                break;
+              }
 
-          if (redrawFigure)
-            redraw (false);
-        }
-    }
-}
+            if (redrawFigure)
+              redraw (false);
+          }
+      }
+  }
 
-bool
-Canvas::canvasKeyPressEvent (QKeyEvent* event)
-{
-  if (m_eventMask & KeyPress)
-    {
-      gh_manager::auto_lock lock;
-      graphics_object obj = gh_manager::get_object (m_handle);
+  bool
+  Canvas::canvasKeyPressEvent (QKeyEvent* event)
+  {
+    if (m_eventMask & KeyPress)
+      {
+        gh_manager::auto_lock lock;
+        graphics_object obj = gh_manager::get_object (m_handle);
 
-      if (obj.valid_object ())
-        {
-          graphics_object figObj (obj.get_ancestor ("figure"));
+        if (obj.valid_object ())
+          {
+            graphics_object figObj (obj.get_ancestor ("figure"));
 
-          updateCurrentPoint (figObj, obj);
-        }
+            updateCurrentPoint (figObj, obj);
+          }
 
-      octave_scalar_map eventData = Utils::makeKeyEventStruct (event);
+        octave_scalar_map eventData = Utils::makeKeyEventStruct (event);
 
-      gh_manager::post_set (m_handle, "currentcharacter",
-                            eventData.getfield ("Character"), false);
-      gh_manager::post_callback (m_handle, "keypressfcn", eventData);
+        gh_manager::post_set (m_handle, "currentcharacter",
+                              eventData.getfield ("Character"), false);
+        gh_manager::post_callback (m_handle, "keypressfcn", eventData);
 
-      return true;
-    }
+        return true;
+      }
 
-  return false;
-}
+    return false;
+  }
 
-bool
-Canvas::canvasKeyReleaseEvent (QKeyEvent* event)
-{
-  if (! event->isAutoRepeat () && (m_eventMask & KeyRelease))
-    {
-      gh_manager::post_callback (m_handle, "keyreleasefcn",
-                                 Utils::makeKeyEventStruct (event));
+  bool
+  Canvas::canvasKeyReleaseEvent (QKeyEvent* event)
+  {
+    if (! event->isAutoRepeat () && (m_eventMask & KeyRelease))
+      {
+        gh_manager::post_callback (m_handle, "keyreleasefcn",
+                                   Utils::makeKeyEventStruct (event));
 
-      return true;
-    }
+        return true;
+      }
 
-  return false;
-}
+    return false;
+  }
 
-Canvas*
-Canvas::create (const std::string& /* name */, QWidget* parent,
-                const graphics_handle& handle)
-{
-  // Only OpenGL
-  return new GLCanvas (parent, handle);
-}
+  Canvas*
+  Canvas::create (const std::string& /* name */, QWidget* parent,
+                  const graphics_handle& handle)
+  {
+    // Only OpenGL
+    return new GLCanvas (parent, handle);
+  }
 
 }; // namespace QtHandles
+
diff --git a/libgui/graphics/Canvas.h b/libgui/graphics/Canvas.h
--- a/libgui/graphics/Canvas.h
+++ b/libgui/graphics/Canvas.h
@@ -34,94 +34,95 @@ class QMouseEvent;
 class QWheelEvent;
 class QWidget;
 
 class octave_value_list;
 
 namespace QtHandles
 {
 
-class Canvas
-{
-public:
-  enum EventMask
+  class Canvas
+  {
+  public:
+    enum EventMask
     {
       KeyPress   = 0x01,
       KeyRelease = 0x02
     };
 
-public:
-  virtual ~Canvas (void) { }
+  public:
+    virtual ~Canvas (void) { }
 
-  void redraw (bool sync = false);
-  void blockRedraw (bool block = true);
+    void redraw (bool sync = false);
+    void blockRedraw (bool block = true);
 
-  void print (const QString& file_cmd, const QString& term);
+    void print (const QString& file_cmd, const QString& term);
 
-  void addEventMask (int m) { m_eventMask |= m; }
-  void clearEventMask (int m) { m_eventMask &= (~m); }
-  void setEventMask (int m) { m_eventMask = m; }
+    void addEventMask (int m) { m_eventMask |= m; }
+    void clearEventMask (int m) { m_eventMask &= (~m); }
+    void setEventMask (int m) { m_eventMask = m; }
 
-  void setCursor (MouseMode mode);
+    void setCursor (MouseMode mode);
 
-  virtual QWidget* qWidget (void) = 0;
+    virtual QWidget* qWidget (void) = 0;
 
-  static Canvas* create (const std::string& name, QWidget* parent,
-                         const graphics_handle& handle);
+    static Canvas* create (const std::string& name, QWidget* parent,
+                           const graphics_handle& handle);
 
-  virtual void toggleAxes (const graphics_handle& handle) = 0;
-  virtual void toggleGrid (const graphics_handle& handle) = 0;
-  virtual void autoAxes (const graphics_handle& handle) = 0;
+    virtual void toggleAxes (const graphics_handle& handle) = 0;
+    virtual void toggleGrid (const graphics_handle& handle) = 0;
+    virtual void autoAxes (const graphics_handle& handle) = 0;
 
-protected:
-  virtual void draw (const graphics_handle& handle) = 0;
-  virtual void drawZoomBox (const QPoint& p1, const QPoint& p2) = 0;
-  virtual void resize (int x, int y, int width, int height) = 0;
-  virtual graphics_object selectFromAxes (const graphics_object& ax,
-                                          const QPoint& pt) = 0;
+  protected:
+    virtual void draw (const graphics_handle& handle) = 0;
+    virtual void drawZoomBox (const QPoint& p1, const QPoint& p2) = 0;
+    virtual void resize (int x, int y, int width, int height) = 0;
+    virtual graphics_object selectFromAxes (const graphics_object& ax,
+                                            const QPoint& pt) = 0;
 
-protected:
-  Canvas (const graphics_handle& handle)
-    : m_handle (handle),
-      m_redrawBlocked (false),
-      m_mouseMode (NoMode),
-      m_clickMode (false),
-      m_eventMask (0),
-      m_rectMode (false)
+  protected:
+    Canvas (const graphics_handle& handle)
+      : m_handle (handle),
+        m_redrawBlocked (false),
+        m_mouseMode (NoMode),
+        m_clickMode (false),
+        m_eventMask (0),
+        m_rectMode (false)
     { }
 
-  void canvasToggleAxes (const graphics_handle& handle);
-  void canvasToggleGrid (const graphics_handle& handle);
-  void canvasAutoAxes (const graphics_handle& handle);
-  void canvasPaintEvent (void);
-  void canvasMouseDoubleClickEvent (QMouseEvent* event);
-  void canvasMouseMoveEvent (QMouseEvent* event);
-  void canvasMousePressEvent (QMouseEvent* event);
-  void canvasMouseReleaseEvent (QMouseEvent* event);
-  void canvasWheelEvent (QWheelEvent* event);
-  bool canvasKeyPressEvent (QKeyEvent* event);
-  bool canvasKeyReleaseEvent (QKeyEvent* event);
+    void canvasToggleAxes (const graphics_handle& handle);
+    void canvasToggleGrid (const graphics_handle& handle);
+    void canvasAutoAxes (const graphics_handle& handle);
+    void canvasPaintEvent (void);
+    void canvasMouseDoubleClickEvent (QMouseEvent* event);
+    void canvasMouseMoveEvent (QMouseEvent* event);
+    void canvasMousePressEvent (QMouseEvent* event);
+    void canvasMouseReleaseEvent (QMouseEvent* event);
+    void canvasWheelEvent (QWheelEvent* event);
+    bool canvasKeyPressEvent (QKeyEvent* event);
+    bool canvasKeyReleaseEvent (QKeyEvent* event);
 
-  void updateCurrentPoint (const graphics_object& fig,
-                           const graphics_object& obj, QMouseEvent *event);
-  void updateCurrentPoint (const graphics_object& fig,
-                           const graphics_object& obj);
+    void updateCurrentPoint (const graphics_object& fig,
+                             const graphics_object& obj, QMouseEvent *event);
+    void updateCurrentPoint (const graphics_object& fig,
+                             const graphics_object& obj);
 
-  void annotation_callback (const octave_value_list& args);
-  void select_object (graphics_object obj, QMouseEvent* event,
-                      graphics_object &currentObj, graphics_object &axesObj,
-                      bool axes_only = false);
+    void annotation_callback (const octave_value_list& args);
+    void select_object (graphics_object obj, QMouseEvent* event,
+                        graphics_object &currentObj, graphics_object &axesObj,
+                        bool axes_only = false);
 
-private:
-  graphics_handle m_handle;
-  bool m_redrawBlocked;
-  MouseMode m_mouseMode;
-  bool m_clickMode;              // True: ZoomIn, False: ZoomOut
-  QPoint m_mouseAnchor;
-  QPoint m_mouseCurrent;
-  graphics_handle m_mouseAxes;
-  int m_eventMask;
-  bool m_rectMode;
-};
+  private:
+    graphics_handle m_handle;
+    bool m_redrawBlocked;
+    MouseMode m_mouseMode;
+    bool m_clickMode;              // True: ZoomIn, False: ZoomOut
+    QPoint m_mouseAnchor;
+    QPoint m_mouseCurrent;
+    graphics_handle m_mouseAxes;
+    int m_eventMask;
+    bool m_rectMode;
+  };
 
 }; // namespace QtHandles
 
 #endif
+
diff --git a/libgui/graphics/CheckBoxControl.cc b/libgui/graphics/CheckBoxControl.cc
--- a/libgui/graphics/CheckBoxControl.cc
+++ b/libgui/graphics/CheckBoxControl.cc
@@ -27,35 +27,36 @@ along with Octave; see the file COPYING.
 #include <QCheckBox>
 
 #include "CheckBoxControl.h"
 #include "Container.h"
 
 namespace QtHandles
 {
 
-CheckBoxControl*
-CheckBoxControl::create (const graphics_object& go)
-{
-  Object* parent = Object::parentObject (go);
+  CheckBoxControl*
+  CheckBoxControl::create (const graphics_object& go)
+  {
+    Object* parent = Object::parentObject (go);
 
-  if (parent)
-    {
-      Container* container = parent->innerContainer ();
+    if (parent)
+      {
+        Container* container = parent->innerContainer ();
 
-      if (container)
-        return new CheckBoxControl (go, new QCheckBox (container));
-    }
+        if (container)
+          return new CheckBoxControl (go, new QCheckBox (container));
+      }
 
-  return 0;
-}
+    return 0;
+  }
 
-CheckBoxControl::CheckBoxControl (const graphics_object& go, QCheckBox* box)
+  CheckBoxControl::CheckBoxControl (const graphics_object& go, QCheckBox* box)
     : ButtonControl (go, box)
-{
-  box->setAutoFillBackground (true);
-}
+  {
+    box->setAutoFillBackground (true);
+  }
 
-CheckBoxControl::~CheckBoxControl (void)
-{
-}
+  CheckBoxControl::~CheckBoxControl (void)
+  {
+  }
 
 };
+
diff --git a/libgui/graphics/CheckBoxControl.h b/libgui/graphics/CheckBoxControl.h
--- a/libgui/graphics/CheckBoxControl.h
+++ b/libgui/graphics/CheckBoxControl.h
@@ -25,20 +25,21 @@ along with Octave; see the file COPYING.
 
 #include "ButtonControl.h"
 
 class QCheckBox;
 
 namespace QtHandles
 {
 
-class CheckBoxControl : public ButtonControl
-{
-public:
-  CheckBoxControl (const graphics_object& go, QCheckBox* box);
-  ~CheckBoxControl (void);
+  class CheckBoxControl : public ButtonControl
+  {
+  public:
+    CheckBoxControl (const graphics_object& go, QCheckBox* box);
+    ~CheckBoxControl (void);
 
-  static CheckBoxControl* create (const graphics_object& go);
-};
+    static CheckBoxControl* create (const graphics_object& go);
+  };
 
 }; // namespace QtHandles
 
 #endif
+
diff --git a/libgui/graphics/Container.cc b/libgui/graphics/Container.cc
--- a/libgui/graphics/Container.cc
+++ b/libgui/graphics/Container.cc
@@ -32,83 +32,85 @@ along with Octave; see the file COPYING.
 #include "Canvas.h"
 #include "Container.h"
 #include "Object.h"
 #include "QtHandlesUtils.h"
 
 namespace QtHandles
 {
 
-Container::Container (QWidget* xparent)
-  : ContainerBase (xparent), m_canvas (0)
-{
-  setFocusPolicy (Qt::ClickFocus);
-}
+  Container::Container (QWidget* xparent)
+    : ContainerBase (xparent), m_canvas (0)
+  {
+    setFocusPolicy (Qt::ClickFocus);
+  }
 
-Container::~Container (void)
-{
-}
+  Container::~Container (void)
+  {
+  }
 
-Canvas*
-Container::canvas (const graphics_handle& gh, bool xcreate)
-{
-  if (! m_canvas && xcreate)
-    {
-      gh_manager::auto_lock lock;
-      graphics_object go = gh_manager::get_object (gh);
+  Canvas*
+  Container::canvas (const graphics_handle& gh, bool xcreate)
+  {
+    if (! m_canvas && xcreate)
+      {
+        gh_manager::auto_lock lock;
+        graphics_object go = gh_manager::get_object (gh);
 
-      if (go)
-        {
-          graphics_object fig = go.get_ancestor ("figure");
+        if (go)
+          {
+            graphics_object fig = go.get_ancestor ("figure");
 
-          m_canvas = Canvas::create (fig.get("renderer").string_value (),
-                                     this, gh);
+            m_canvas = Canvas::create (fig.get("renderer").string_value (),
+                                       this, gh);
 
-          QWidget* canvasWidget = m_canvas->qWidget ();
+            QWidget* canvasWidget = m_canvas->qWidget ();
 
-          canvasWidget->lower ();
-          canvasWidget->show ();
-          canvasWidget->setGeometry (0, 0, width (), height ());
-        }
-    }
+            canvasWidget->lower ();
+            canvasWidget->show ();
+            canvasWidget->setGeometry (0, 0, width (), height ());
+          }
+      }
 
-  return m_canvas;
-}
+    return m_canvas;
+  }
 
-void
-Container::resizeEvent (QResizeEvent* /* event */)
-{
-  if (m_canvas)
-    m_canvas->qWidget ()->setGeometry (0, 0, width (), height ());
+  void
+  Container::resizeEvent (QResizeEvent* /* event */)
+  {
+    if (m_canvas)
+      m_canvas->qWidget ()->setGeometry (0, 0, width (), height ());
 
-  gh_manager::auto_lock lock;
+    gh_manager::auto_lock lock;
 
-  foreach (QObject* qObj, children ())
+    foreach (QObject* qObj, children ())
     {
       if (qObj->isWidgetType ())
         {
           Object* obj = Object::fromQObject (qObj);
 
           if (obj)
             {
               graphics_object go = obj->object ();
 
               if (go.valid_object ())
                 {
                   Matrix bb = go.get_properties ().get_boundingbox (false);
 
                   obj->qWidget<QWidget> ()
-                    ->setGeometry (octave::math::round (bb(0)), octave::math::round (bb(1)),
-                                   octave::math::round (bb(2)), octave::math::round (bb(3)));
+                  ->setGeometry (octave::math::round (bb(0)), octave::math::round (bb(1)),
+                                 octave::math::round (bb(2)), octave::math::round (bb(3)));
                 }
             }
         }
     }
-}
+  }
 
-void
-Container::childEvent (QChildEvent* xevent)
-{
-  if (xevent->child ()->isWidgetType ())
-    qobject_cast<QWidget*> (xevent->child ())->setMouseTracking (hasMouseTracking ());
-}
+  void
+  Container::childEvent (QChildEvent* xevent)
+  {
+    if (xevent->child ()->isWidgetType ())
+      qobject_cast<QWidget*> (xevent->child ())->setMouseTracking (
+        hasMouseTracking ());
+  }
 
 }; // namespace QtHandles
+
diff --git a/libgui/graphics/Container.h b/libgui/graphics/Container.h
--- a/libgui/graphics/Container.h
+++ b/libgui/graphics/Container.h
@@ -27,31 +27,32 @@ along with Octave; see the file COPYING.
 
 #include "GenericEventNotify.h"
 
 #include "graphics.h"
 
 namespace QtHandles
 {
 
-DECLARE_GENERICEVENTNOTIFY_SENDER(ContainerBase, QWidget);
+  DECLARE_GENERICEVENTNOTIFY_SENDER(ContainerBase, QWidget);
 
-class Canvas;
+  class Canvas;
 
-class Container : public ContainerBase
-{
-public:
-  Container (QWidget* parent);
-  ~Container (void);
+  class Container : public ContainerBase
+  {
+  public:
+    Container (QWidget* parent);
+    ~Container (void);
 
-  Canvas* canvas (const graphics_handle& handle, bool create = true);
+    Canvas* canvas (const graphics_handle& handle, bool create = true);
 
-protected:
-  void childEvent (QChildEvent* event);
-  void resizeEvent (QResizeEvent* event);
+  protected:
+    void childEvent (QChildEvent* event);
+    void resizeEvent (QResizeEvent* event);
 
-private:
-  Canvas* m_canvas;
-};
+  private:
+    Canvas* m_canvas;
+  };
 
 }; // namespace QtHandles
 
 #endif
+
diff --git a/libgui/graphics/ContextMenu.cc b/libgui/graphics/ContextMenu.cc
--- a/libgui/graphics/ContextMenu.cc
+++ b/libgui/graphics/ContextMenu.cc
@@ -28,112 +28,113 @@ along with Octave; see the file COPYING.
 
 #include "Backend.h"
 #include "ContextMenu.h"
 #include "QtHandlesUtils.h"
 
 namespace QtHandles
 {
 
-ContextMenu*
-ContextMenu::create (const graphics_object& go)
-{
-  Object* xparent = Object::parentObject (go);
+  ContextMenu*
+  ContextMenu::create (const graphics_object& go)
+  {
+    Object* xparent = Object::parentObject (go);
 
-  if (xparent)
-    {
-      QWidget* w = xparent->qWidget<QWidget> ();
+    if (xparent)
+      {
+        QWidget* w = xparent->qWidget<QWidget> ();
 
-      return new ContextMenu (go, new QMenu (w));
-    }
+        return new ContextMenu (go, new QMenu (w));
+      }
 
-  return 0;
-}
+    return 0;
+  }
 
-ContextMenu::ContextMenu (const graphics_object& go, QMenu* xmenu)
+  ContextMenu::ContextMenu (const graphics_object& go, QMenu* xmenu)
     : Object (go, xmenu)
-{
-  xmenu->setAutoFillBackground (true);
+  {
+    xmenu->setAutoFillBackground (true);
 
-  connect (xmenu, SIGNAL (aboutToShow (void)), SLOT (aboutToShow (void)));
-  connect (xmenu, SIGNAL (aboutToHide (void)), SLOT (aboutToHide (void)));
-}
+    connect (xmenu, SIGNAL (aboutToShow (void)), SLOT (aboutToShow (void)));
+    connect (xmenu, SIGNAL (aboutToHide (void)), SLOT (aboutToHide (void)));
+  }
 
-ContextMenu::~ContextMenu (void)
-{
-}
+  ContextMenu::~ContextMenu (void)
+  {
+  }
 
-void
-ContextMenu::update (int pId)
-{
-  uicontextmenu::properties& up = properties<uicontextmenu> ();
-  QMenu* xmenu = qWidget<QMenu> ();
+  void
+  ContextMenu::update (int pId)
+  {
+    uicontextmenu::properties& up = properties<uicontextmenu> ();
+    QMenu* xmenu = qWidget<QMenu> ();
 
-  switch (pId)
-    {
-    case base_properties::ID_VISIBLE:
-      if (up.is_visible ())
-        {
-          Matrix pos = up.get_position ().matrix_value ();
-          QWidget* parentW = xmenu->parentWidget ();
-          QPoint pt;
+    switch (pId)
+      {
+      case base_properties::ID_VISIBLE:
+        if (up.is_visible ())
+          {
+            Matrix pos = up.get_position ().matrix_value ();
+            QWidget* parentW = xmenu->parentWidget ();
+            QPoint pt;
 
-          pt.rx () = octave::math::round (pos(0));
-          pt.ry () = parentW->height () - octave::math::round (pos(1));
-          pt = parentW->mapToGlobal (pt);
+            pt.rx () = octave::math::round (pos(0));
+            pt.ry () = parentW->height () - octave::math::round (pos(1));
+            pt = parentW->mapToGlobal (pt);
 
-          xmenu->popup (pt);
-        }
-      else
-        xmenu->hide ();
-      break;
-    default:
-      Object::update (pId);
-      break;
-    }
-}
+            xmenu->popup (pt);
+          }
+        else
+          xmenu->hide ();
+        break;
+      default:
+        Object::update (pId);
+        break;
+      }
+  }
 
-void
-ContextMenu::aboutToShow (void)
-{
-  gh_manager::post_callback (m_handle, "callback");
-  gh_manager::post_set (m_handle, "visible", "on", false);
-}
+  void
+  ContextMenu::aboutToShow (void)
+  {
+    gh_manager::post_callback (m_handle, "callback");
+    gh_manager::post_set (m_handle, "visible", "on", false);
+  }
 
-void
-ContextMenu::aboutToHide (void)
-{
-  gh_manager::post_set (m_handle, "visible", "off", false);
-}
+  void
+  ContextMenu::aboutToHide (void)
+  {
+    gh_manager::post_set (m_handle, "visible", "off", false);
+  }
 
-QWidget*
-ContextMenu::menu (void)
-{
-  return qWidget<QWidget> ();
-}
+  QWidget*
+  ContextMenu::menu (void)
+  {
+    return qWidget<QWidget> ();
+  }
 
-void
-ContextMenu::executeAt (const base_properties& props, const QPoint& pt)
-{
-  graphics_handle h = props.get_uicontextmenu ();
+  void
+  ContextMenu::executeAt (const base_properties& props, const QPoint& pt)
+  {
+    graphics_handle h = props.get_uicontextmenu ();
 
-  if (h.ok ())
-    {
-      gh_manager::auto_lock lock;
-      graphics_object go = gh_manager::get_object (h);
+    if (h.ok ())
+      {
+        gh_manager::auto_lock lock;
+        graphics_object go = gh_manager::get_object (h);
 
-      if (go.valid_object ())
-        {
-          ContextMenu* cMenu =
-            dynamic_cast<ContextMenu*> (Backend::toolkitObject (go));
+        if (go.valid_object ())
+          {
+            ContextMenu* cMenu =
+              dynamic_cast<ContextMenu*> (Backend::toolkitObject (go));
 
-          if (cMenu)
-            {
-              QMenu* menu = cMenu->qWidget<QMenu> ();
+            if (cMenu)
+              {
+                QMenu* menu = cMenu->qWidget<QMenu> ();
 
-              if (menu)
-                menu->popup (pt);
-            }
-        }
-    }
-}
+                if (menu)
+                  menu->popup (pt);
+              }
+          }
+      }
+  }
 
 }; // namespace QtHandles
+
diff --git a/libgui/graphics/ContextMenu.h b/libgui/graphics/ContextMenu.h
--- a/libgui/graphics/ContextMenu.h
+++ b/libgui/graphics/ContextMenu.h
@@ -28,34 +28,35 @@ along with Octave; see the file COPYING.
 #include "MenuContainer.h"
 #include "Object.h"
 
 class QMenu;
 
 namespace QtHandles
 {
 
-class ContextMenu : public Object, public MenuContainer
-{
-  Q_OBJECT
+  class ContextMenu : public Object, public MenuContainer
+  {
+    Q_OBJECT
 
-public:
-  ContextMenu (const graphics_object& go, QMenu* menu);
-  ~ContextMenu (void);
+  public:
+    ContextMenu (const graphics_object& go, QMenu* menu);
+    ~ContextMenu (void);
 
-  static ContextMenu* create (const graphics_object& go);
-  static void executeAt (const base_properties& props, const QPoint& pt);
+    static ContextMenu* create (const graphics_object& go);
+    static void executeAt (const base_properties& props, const QPoint& pt);
 
-  Container* innerContainer (void) { return 0; }
+    Container* innerContainer (void) { return 0; }
 
-  QWidget* menu (void);
+    QWidget* menu (void);
 
-protected:
-  void update (int pId);
+  protected:
+    void update (int pId);
 
-private slots:
-  void aboutToShow (void);
-  void aboutToHide (void);
-};
+  private slots:
+    void aboutToShow (void);
+    void aboutToHide (void);
+  };
 
 }; // namespace QtHandles
 
 #endif
+
diff --git a/libgui/graphics/EditControl.cc b/libgui/graphics/EditControl.cc
--- a/libgui/graphics/EditControl.cc
+++ b/libgui/graphics/EditControl.cc
@@ -29,232 +29,236 @@ along with Octave; see the file COPYING.
 #include "Container.h"
 #include "EditControl.h"
 #include "TextEdit.h"
 #include "QtHandlesUtils.h"
 
 namespace QtHandles
 {
 
-EditControl*
-EditControl::create (const graphics_object& go)
-{
-  Object* parent = Object::parentObject (go);
+  EditControl*
+  EditControl::create (const graphics_object& go)
+  {
+    Object* parent = Object::parentObject (go);
 
-  if (parent)
-    {
-      Container* container = parent->innerContainer ();
+    if (parent)
+      {
+        Container* container = parent->innerContainer ();
 
-      if (container)
-        {
-          uicontrol::properties& up = Utils::properties<uicontrol> (go);
+        if (container)
+          {
+            uicontrol::properties& up = Utils::properties<uicontrol> (go);
 
-          if ((up.get_max () - up.get_min ()) > 1)
-            return new EditControl (go, new TextEdit (container));
-          else
-            return new EditControl (go, new QLineEdit (container));
-        }
-    }
+            if ((up.get_max () - up.get_min ()) > 1)
+              return new EditControl (go, new TextEdit (container));
+            else
+              return new EditControl (go, new QLineEdit (container));
+          }
+      }
 
-  return 0;
-}
+    return 0;
+  }
 
-EditControl::EditControl (const graphics_object& go, QLineEdit* edit)
-     : BaseControl (go, edit), m_multiLine (false), m_textChanged (false)
-{
-  init (edit);
-}
+  EditControl::EditControl (const graphics_object& go, QLineEdit* edit)
+    : BaseControl (go, edit), m_multiLine (false), m_textChanged (false)
+  {
+    init (edit);
+  }
 
-void
-EditControl::init (QLineEdit* edit, bool callBase)
-{
-  if (callBase)
-    BaseControl::init (edit, callBase);
+  void
+  EditControl::init (QLineEdit* edit, bool callBase)
+  {
+    if (callBase)
+      BaseControl::init (edit, callBase);
 
-  m_multiLine = false;
-  initCommon (edit);
+    m_multiLine = false;
+    initCommon (edit);
 
-  uicontrol::properties& up = properties<uicontrol> ();
+    uicontrol::properties& up = properties<uicontrol> ();
 
-  edit->setText (Utils::fromStdString (up.get_string_string ()));
-  edit->setAlignment (Utils::fromHVAlign (up.get_horizontalalignment (),
-                                          up.get_verticalalignment ()));
+    edit->setText (Utils::fromStdString (up.get_string_string ()));
+    edit->setAlignment (Utils::fromHVAlign (up.get_horizontalalignment (),
+                                            up.get_verticalalignment ()));
 
-  connect (edit, SIGNAL (textEdited (const QString&)),
-           SLOT (textChanged (void)));
-  connect (edit, SIGNAL (editingFinished (void)),
-           SLOT (editingFinished (void)));
-  connect (edit, SIGNAL (returnPressed (void)),
-           SLOT (returnPressed (void)));
-}
+    connect (edit, SIGNAL (textEdited (const QString&)),
+             SLOT (textChanged (void)));
+    connect (edit, SIGNAL (editingFinished (void)),
+             SLOT (editingFinished (void)));
+    connect (edit, SIGNAL (returnPressed (void)),
+             SLOT (returnPressed (void)));
+  }
 
-EditControl::EditControl (const graphics_object& go, TextEdit* edit)
-  : BaseControl (go, edit), m_multiLine (true), m_textChanged (false)
-{
-  init (edit);
-}
+  EditControl::EditControl (const graphics_object& go, TextEdit* edit)
+    : BaseControl (go, edit), m_multiLine (true), m_textChanged (false)
+  {
+    init (edit);
+  }
 
-void
-EditControl::init (TextEdit* edit, bool callBase)
-{
-  if (callBase)
-    BaseControl::init (edit, callBase);
+  void
+  EditControl::init (TextEdit* edit, bool callBase)
+  {
+    if (callBase)
+      BaseControl::init (edit, callBase);
 
-  m_multiLine = true;
-  initCommon (edit);
+    m_multiLine = true;
+    initCommon (edit);
 
-  uicontrol::properties& up = properties<uicontrol> ();
-
-  edit->setAcceptRichText (false);
-  edit->setPlainText (Utils::fromStringVector (up.get_string_vector()).join("\n"));
+    uicontrol::properties& up = properties<uicontrol> ();
 
-  connect (edit, SIGNAL (textChanged (void)),
-           SLOT (textChanged (void)));
-  connect (edit, SIGNAL (editingFinished (void)),
-           SLOT (editingFinished (void)));
-  connect (edit, SIGNAL (returnPressed (void)),
-           SLOT (returnPressed (void)));
-}
+    edit->setAcceptRichText (false);
+    edit->setPlainText (Utils::fromStringVector (
+                          up.get_string_vector()).join("\n"));
+
+    connect (edit, SIGNAL (textChanged (void)),
+             SLOT (textChanged (void)));
+    connect (edit, SIGNAL (editingFinished (void)),
+             SLOT (editingFinished (void)));
+    connect (edit, SIGNAL (returnPressed (void)),
+             SLOT (returnPressed (void)));
+  }
 
-EditControl::~EditControl (void)
-{
-}
+  EditControl::~EditControl (void)
+  {
+  }
 
-void
-EditControl::initCommon (QWidget*)
-{
-  m_textChanged = false;
-}
+  void
+  EditControl::initCommon (QWidget*)
+  {
+    m_textChanged = false;
+  }
 
-void
-EditControl::update (int pId)
-{
-  bool handled = false;
+  void
+  EditControl::update (int pId)
+  {
+    bool handled = false;
 
-  if (m_multiLine)
-    handled = updateMultiLine (pId);
-  else
-    handled = updateSingleLine (pId);
+    if (m_multiLine)
+      handled = updateMultiLine (pId);
+    else
+      handled = updateSingleLine (pId);
 
-  if (! handled)
-    {
-      switch (pId)
-        {
-        default:
-          BaseControl::update (pId);
-          break;
-        }
-    }
-}
+    if (! handled)
+      {
+        switch (pId)
+          {
+          default:
+            BaseControl::update (pId);
+            break;
+          }
+      }
+  }
 
-bool
-EditControl::updateSingleLine (int pId)
-{
-  uicontrol::properties& up = properties<uicontrol> ();
-  QLineEdit* edit = qWidget<QLineEdit> ();
+  bool
+  EditControl::updateSingleLine (int pId)
+  {
+    uicontrol::properties& up = properties<uicontrol> ();
+    QLineEdit* edit = qWidget<QLineEdit> ();
 
-  switch (pId)
-    {
-    case uicontrol::properties::ID_STRING:
-      edit->setText (Utils::fromStdString (up.get_string_string ()));
-      return true;
+    switch (pId)
+      {
+      case uicontrol::properties::ID_STRING:
+        edit->setText (Utils::fromStdString (up.get_string_string ()));
+        return true;
 
-    case uicontrol::properties::ID_HORIZONTALALIGNMENT:
-    case uicontrol::properties::ID_VERTICALALIGNMENT:
-      edit->setAlignment (Utils::fromHVAlign (up.get_horizontalalignment (),
-                                              up.get_verticalalignment ()));
-      return true;
+      case uicontrol::properties::ID_HORIZONTALALIGNMENT:
+      case uicontrol::properties::ID_VERTICALALIGNMENT:
+        edit->setAlignment (Utils::fromHVAlign (up.get_horizontalalignment (),
+                                                up.get_verticalalignment ()));
+        return true;
 
-    case uicontrol::properties::ID_MIN:
-    case uicontrol::properties::ID_MAX:
-      if ((up.get_max () - up.get_min ()) > 1)
-        {
-          QWidget* container = edit->parentWidget ();
+      case uicontrol::properties::ID_MIN:
+      case uicontrol::properties::ID_MAX:
+        if ((up.get_max () - up.get_min ()) > 1)
+          {
+            QWidget* container = edit->parentWidget ();
 
-          delete edit;
-          init (new TextEdit (container), true);
-        }
-      return true;
+            delete edit;
+            init (new TextEdit (container), true);
+          }
+        return true;
 
-    default:
-      break;
-    }
+      default:
+        break;
+      }
 
-  return false;
-}
+    return false;
+  }
 
-bool
-EditControl::updateMultiLine (int pId)
-{
-  uicontrol::properties& up = properties<uicontrol> ();
-  TextEdit* edit = qWidget<TextEdit> ();
+  bool
+  EditControl::updateMultiLine (int pId)
+  {
+    uicontrol::properties& up = properties<uicontrol> ();
+    TextEdit* edit = qWidget<TextEdit> ();
 
-  switch (pId)
-    {
-    case uicontrol::properties::ID_STRING:
-      edit->setPlainText (Utils::fromStringVector (up.get_string_vector()).join("\n"));
-      return true;
+    switch (pId)
+      {
+      case uicontrol::properties::ID_STRING:
+        edit->setPlainText (Utils::fromStringVector (
+                              up.get_string_vector()).join("\n"));
+        return true;
 
-    case uicontrol::properties::ID_MIN:
-    case uicontrol::properties::ID_MAX:
-      if ((up.get_max () - up.get_min ()) <= 1)
-        {
-          QWidget* container = edit->parentWidget ();
+      case uicontrol::properties::ID_MIN:
+      case uicontrol::properties::ID_MAX:
+        if ((up.get_max () - up.get_min ()) <= 1)
+          {
+            QWidget* container = edit->parentWidget ();
 
-          delete edit;
-          init (new QLineEdit (container), true);
-        }
-      return true;
+            delete edit;
+            init (new QLineEdit (container), true);
+          }
+        return true;
 
-    default:
-      break;
-    }
+      default:
+        break;
+      }
 
-  return false;
-}
+    return false;
+  }
 
-void
-EditControl::textChanged (void)
-{
-  m_textChanged = true;
-}
+  void
+  EditControl::textChanged (void)
+  {
+    m_textChanged = true;
+  }
 
-void
-EditControl::returnPressed (void)
-{
-  QString txt = (m_multiLine
-                 ? qWidget<TextEdit> ()->toPlainText ()
-                 : qWidget<QLineEdit> ()->text ());
+  void
+  EditControl::returnPressed (void)
+  {
+    QString txt = (m_multiLine
+                   ? qWidget<TextEdit> ()->toPlainText ()
+                   : qWidget<QLineEdit> ()->text ());
 
-  if (m_textChanged)
-    {
-      if (m_multiLine)
-        gh_manager::post_set (m_handle, "string", Utils::toCellString(txt.split("\n")), false);
-      else
-        gh_manager::post_set (m_handle, "string", Utils::toStdString (txt), false);
+    if (m_textChanged)
+      {
+        if (m_multiLine)
+          gh_manager::post_set (m_handle, "string", Utils::toCellString(txt.split("\n")),
+                                false);
+        else
+          gh_manager::post_set (m_handle, "string", Utils::toStdString (txt), false);
 
-      m_textChanged = false;
-    }
+        m_textChanged = false;
+      }
 
-  if (txt.length () > 0)
-    gh_manager::post_callback (m_handle, "callback");
-}
+    if (txt.length () > 0)
+      gh_manager::post_callback (m_handle, "callback");
+  }
 
-void
-EditControl::editingFinished (void)
-{
-  if (m_textChanged)
-    {
-      QString txt = (m_multiLine
-                     ? qWidget<TextEdit> ()->toPlainText ()
-                     : qWidget<QLineEdit> ()->text ());
-      if (m_multiLine)
-        gh_manager::post_set (m_handle, "string", Utils::toCellString(txt.split("\n")), false);
-      else
-        gh_manager::post_set (m_handle, "string", Utils::toStdString (txt), false);
-      gh_manager::post_callback (m_handle, "callback");
+  void
+  EditControl::editingFinished (void)
+  {
+    if (m_textChanged)
+      {
+        QString txt = (m_multiLine
+                       ? qWidget<TextEdit> ()->toPlainText ()
+                       : qWidget<QLineEdit> ()->text ());
+        if (m_multiLine)
+          gh_manager::post_set (m_handle, "string", Utils::toCellString(txt.split("\n")),
+                                false);
+        else
+          gh_manager::post_set (m_handle, "string", Utils::toStdString (txt), false);
+        gh_manager::post_callback (m_handle, "callback");
 
-      m_textChanged = false;
-    }
-}
+        m_textChanged = false;
+      }
+  }
 
 }; // namespace QtHandles
 
diff --git a/libgui/graphics/EditControl.h b/libgui/graphics/EditControl.h
--- a/libgui/graphics/EditControl.h
+++ b/libgui/graphics/EditControl.h
@@ -26,44 +26,45 @@ along with Octave; see the file COPYING.
 #include "BaseControl.h"
 
 class QLineEdit;
 class QWidget;
 
 namespace QtHandles
 {
 
-class TextEdit;
+  class TextEdit;
 
-class EditControl : public BaseControl
-{
-  Q_OBJECT
+  class EditControl : public BaseControl
+  {
+    Q_OBJECT
 
-public:
-  EditControl (const graphics_object& go, QLineEdit* edit);
-  EditControl (const graphics_object& go, TextEdit* edit);
-  ~EditControl (void);
+  public:
+    EditControl (const graphics_object& go, QLineEdit* edit);
+    EditControl (const graphics_object& go, TextEdit* edit);
+    ~EditControl (void);
 
-  static EditControl* create (const graphics_object& go);
+    static EditControl* create (const graphics_object& go);
 
-protected:
-  void update (int pId);
+  protected:
+    void update (int pId);
 
-private:
-  void init (QLineEdit* edit, bool callBase = false);
-  void init (TextEdit* edit, bool callBase = false);
-  void initCommon (QWidget* widget);
-  bool updateSingleLine (int pId);
-  bool updateMultiLine (int pId);
+  private:
+    void init (QLineEdit* edit, bool callBase = false);
+    void init (TextEdit* edit, bool callBase = false);
+    void initCommon (QWidget* widget);
+    bool updateSingleLine (int pId);
+    bool updateMultiLine (int pId);
 
-private slots:
-  void textChanged (void);
-  void editingFinished (void);
-  void returnPressed (void);
+  private slots:
+    void textChanged (void);
+    void editingFinished (void);
+    void returnPressed (void);
 
-private:
-  bool m_multiLine;
-  bool m_textChanged;
-};
+  private:
+    bool m_multiLine;
+    bool m_textChanged;
+  };
 
 }; // namespace QtHandles
 
 #endif
+
diff --git a/libgui/graphics/Figure.cc b/libgui/graphics/Figure.cc
--- a/libgui/graphics/Figure.cc
+++ b/libgui/graphics/Figure.cc
@@ -56,958 +56,961 @@ along with Octave; see the file COPYING.
 
 #include "octave-qt-link.h"
 
 #include "builtin-defun-decls.h"
 
 namespace QtHandles
 {
 
-DECLARE_GENERICEVENTNOTIFY_SENDER(MenuBar, QMenuBar);
+  DECLARE_GENERICEVENTNOTIFY_SENDER(MenuBar, QMenuBar);
+
+  static bool
+  hasUiControlChildren (const figure::properties& fp)
+  {
+    gh_manager::auto_lock lock;
+
+    Matrix kids = fp.get_all_children ();
 
-static bool
-hasUiControlChildren (const figure::properties& fp)
-{
-  gh_manager::auto_lock lock;
+    for (int i = 0; i < kids.numel (); i++)
+      {
+        graphics_object go (gh_manager::get_object (kids(i)));
 
-  Matrix kids = fp.get_all_children ();
+        if (go && (go.isa ("uicontrol") || go.isa ("uipanel")
+                   || go.isa ("uibuttongroup")))
+          return true;
+      }
 
-  for (int i = 0; i < kids.numel (); i++)
-    {
-      graphics_object go (gh_manager::get_object (kids(i)));
+    return false;
+  }
+
+  static bool
+  hasUiMenuChildren (const figure::properties& fp)
+  {
+    gh_manager::auto_lock lock;
+
+    Matrix kids = fp.get_all_children ();
 
-      if (go && (go.isa ("uicontrol") || go.isa ("uipanel")
-                 || go.isa ("uibuttongroup")))
-        return true;
-    }
+    for (int i = 0; i < kids.numel (); i++)
+      {
+        graphics_object go (gh_manager::get_object (kids(i)));
+
+        if (go && go.isa ("uimenu"))
+          return true;
+      }
+
+    return false;
+  }
 
-  return false;
-}
+  static QRect
+  boundingBoxToRect (const Matrix& bb)
+  {
+    QRect r;
 
-static bool
-hasUiMenuChildren (const figure::properties& fp)
-{
-  gh_manager::auto_lock lock;
+    if (bb.numel () == 4)
+      {
+        r = QRect (octave::math::round (bb(0)), octave::math::round (bb(1)),
+                   octave::math::round (bb(2)), octave::math::round (bb(3)));
+        if (! r.isValid ())
+          r = QRect ();
+      }
 
-  Matrix kids = fp.get_all_children ();
+    return r;
+  }
 
-  for (int i = 0; i < kids.numel (); i++)
-    {
-      graphics_object go (gh_manager::get_object (kids(i)));
+  Figure*
+  Figure::create (const graphics_object& go)
+  {
+    return new Figure (go, new FigureWindow ());
+  }
 
-      if (go && go.isa ("uimenu"))
-        return true;
-    }
+  Figure::Figure (const graphics_object& go, FigureWindow* win)
+    : Object (go, win), m_blockUpdates (false), m_figureToolBar (0),
+      m_menuBar (0), m_innerRect (), m_outerRect (), m_mouseModeGroup (0)
+  {
+    m_container = new Container (win);
+    win->setCentralWidget (m_container);
 
-  return false;
-}
+    figure::properties& fp = properties<figure> ();
+
+    // Status bar
+    m_statusBar = win->statusBar ();
+    int boffset = 0;
+
+    // Toolbar and menubar
+    createFigureToolBarAndMenuBar ();
+    int toffset = 0;
 
-static QRect
-boundingBoxToRect (const Matrix& bb)
-{
-  QRect r;
+    if (fp.toolbar_is ("figure") ||
+        (fp.toolbar_is ("auto") && fp.menubar_is ("figure") &&
+         ! hasUiControlChildren (fp)))
+      {
+        toffset += m_figureToolBar->sizeHint ().height ();
+        boffset += m_statusBar->sizeHint ().height ();
+      }
+    else
+      {
+        m_figureToolBar->hide ();
+        m_statusBar->hide ();
+      }
+
+    if (fp.menubar_is ("figure") || hasUiMenuChildren (fp))
+      toffset += m_menuBar->sizeHint ().height ();
+    else
+      m_menuBar->hide ();
 
-  if (bb.numel () == 4)
-    {
-      r = QRect (octave::math::round (bb(0)), octave::math::round (bb(1)),
-                 octave::math::round (bb(2)), octave::math::round (bb(3)));
-      if (! r.isValid ())
-        r = QRect ();
-    }
+    m_innerRect = boundingBoxToRect (fp.get_boundingbox (true));
+    m_outerRect = boundingBoxToRect (fp.get_boundingbox (false));
+
+    win->setGeometry (m_innerRect.adjusted (0, -toffset, 0, boffset));
+
+    // Enable mouse tracking unconditionally
+    enableMouseTracking ();
+
+    // When this constructor gets called all properties are already
+    // set, even non default. We force "update" here to get things right.
 
-  return r;
-}
+    // Figure title
+    update (figure::properties::ID_NUMBERTITLE);
+
+    // Decide what keyboard events we listen to
+    m_container->canvas (m_handle)->setEventMask (0);
+    update (figure::properties::ID_KEYPRESSFCN);
+    update (figure::properties::ID_KEYRELEASEFCN);
+
+    // modal style
+    update (figure::properties::ID_WINDOWSTYLE);
 
-Figure*
-Figure::create (const graphics_object& go)
-{
-  return new Figure (go, new FigureWindow ());
-}
+    // Visibility
+    update (figure::properties::ID_VISIBLE);
+
+    connect (this, SIGNAL (asyncUpdate (void)),
+             this, SLOT (updateContainer (void)));
+
+    win->addReceiver (this);
+    m_container->addReceiver (this);
+  }
+
+  Figure::~Figure (void)
+  {
+  }
 
-Figure::Figure (const graphics_object& go, FigureWindow* win)
-  : Object (go, win), m_blockUpdates (false), m_figureToolBar (0),
-    m_menuBar (0), m_innerRect (), m_outerRect (), m_mouseModeGroup (0)
-{
-  m_container = new Container (win);
-  win->setCentralWidget (m_container);
+  static std::string
+  mouse_mode_to_string (MouseMode mode)
+  {
+    switch (mode)
+      {
+      case NoMode:
+        return "none";
+
+      case RotateMode:
+        return "rotate";
 
-  figure::properties& fp = properties<figure> ();
+      case ZoomInMode:
+        return "zoom in";
+
+      case ZoomOutMode:
+        return "zoom out";
 
-  // Status bar
-  m_statusBar = win->statusBar ();
-  int boffset = 0;
+      case PanMode:
+        return "pan";
 
-  // Toolbar and menubar
-  createFigureToolBarAndMenuBar ();
-  int toffset = 0;
+      case TextMode:
+        return "text";
+
+      case SelectMode:
+        return "select";
 
-  if (fp.toolbar_is ("figure") ||
-      (fp.toolbar_is ("auto") && fp.menubar_is ("figure") &&
-       ! hasUiControlChildren (fp)))
-    {
-      toffset += m_figureToolBar->sizeHint ().height ();
-      boffset += m_statusBar->sizeHint ().height ();
-    }
-  else
-    {
-      m_figureToolBar->hide ();
-      m_statusBar->hide ();
-    }
+      default:
+        break;
+      }
+
+    return "none";
+  }
 
-  if (fp.menubar_is ("figure") || hasUiMenuChildren (fp))
-    toffset += m_menuBar->sizeHint ().height ();
-  else
-    m_menuBar->hide ();
+  static MouseMode
+  mouse_mode_from_string (const std::string& mode)
+  {
+    if (mode == "none")
+      return NoMode;
+    else if (mode == "rotate")
+      return RotateMode;
+    else if (mode == "zoom in")
+      return ZoomInMode;
+    else if (mode == "zoom out")
+      return ZoomOutMode;
+    else if (mode == "pan")
+      return PanMode;
+    else if (mode == "text")
+      return TextMode;
+    else if (mode == "select")
+      return SelectMode;
+    else
+      return NoMode;
+  }
+
+  QString
+  Figure::fileName (void)
+  {
+    gh_manager::auto_lock lock;
+
+    const figure::properties& fp = properties<figure> ();
+
+    std::string name = fp.get_filename ();
+
+    return QString::fromStdString (name);
+  }
 
-  m_innerRect = boundingBoxToRect (fp.get_boundingbox (true));
-  m_outerRect = boundingBoxToRect (fp.get_boundingbox (false));
+  void
+  Figure::setFileName (const QString& name)
+  {
+    gh_manager::auto_lock lock;
 
-  win->setGeometry (m_innerRect.adjusted (0, -toffset, 0, boffset));
+    figure::properties& fp = properties<figure> ();
 
-  // Enable mouse tracking unconditionally
-  enableMouseTracking ();
+    fp.set_filename (name.toStdString ());
+  }
 
-  // When this constructor gets called all properties are already
-  // set, even non default. We force "update" here to get things right.
+  MouseMode
+  Figure::mouseMode (void)
+  {
+    gh_manager::auto_lock lock;
+
+    const figure::properties& fp = properties<figure> ();
+
+    std::string mode = fp.get___mouse_mode__ ();
 
-  // Figure title
-  update (figure::properties::ID_NUMBERTITLE);
+    if (mode == "zoom")
+      {
+        octave_scalar_map zm = fp.get___zoom_mode__ ().scalar_map_value ();
+
+        std::string direction = zm.getfield ("Direction").string_value ();
+
+        mode += " " + direction;
+      }
 
-  // Decide what keyboard events we listen to
-  m_container->canvas (m_handle)->setEventMask (0);
-  update (figure::properties::ID_KEYPRESSFCN);
-  update (figure::properties::ID_KEYRELEASEFCN);
+    return mouse_mode_from_string (mode);
+  }
 
-  // modal style
-  update (figure::properties::ID_WINDOWSTYLE);
+  void
+  Figure::createFigureToolBarAndMenuBar (void)
+  {
+    QMainWindow* win = qWidget<QMainWindow> ();
+
+    m_figureToolBar = win->addToolBar (tr ("Figure ToolBar"));
+    m_figureToolBar->setMovable (false);
+    m_figureToolBar->setFloatable (false);
 
-  // Visibility
-  update (figure::properties::ID_VISIBLE);
+    m_mouseModeGroup = new MouseModeActionGroup (win);
+    connect (m_mouseModeGroup, SIGNAL (modeChanged (MouseMode)),
+             SLOT (setMouseMode (MouseMode)));
+    m_figureToolBar->addActions (m_mouseModeGroup->actions ());
+
+    QAction *toggle_axes = m_figureToolBar->addAction (tr ("Axes"));
+    connect (toggle_axes, SIGNAL (triggered (void)),
+             this, SLOT (toggleAxes (void)));
+
+    QAction *toggle_grid = m_figureToolBar->addAction (tr ("Grid"));
+    connect (toggle_grid, SIGNAL (triggered (void)),
+             this, SLOT (toggleGrid (void)));
+
+    QAction *auto_axes = m_figureToolBar->addAction (tr ("Autoscale"));
+    connect (auto_axes, SIGNAL (triggered (void)),
+             this, SLOT (autoAxes (void)));
 
-  connect (this, SIGNAL (asyncUpdate (void)),
-           this, SLOT (updateContainer (void)));
+    m_menuBar = new MenuBar (win);
+    win->setMenuBar (m_menuBar);
+
+    QMenu* fileMenu = m_menuBar->addMenu (tr ("&File"));
+    fileMenu->menuAction ()->setObjectName ("builtinMenu");
+    fileMenu->addAction (tr ("&Save"), this, SLOT (fileSaveFigure (bool)));
+    fileMenu->addAction (tr ("Save &As"), this, SLOT (fileSaveFigureAs (void)));
+    fileMenu->addSeparator ();
+    fileMenu->addAction (tr ("&Close Figure"), this,
+                         SLOT (fileCloseFigure (void)), Qt::CTRL | Qt::Key_W);
+
+    QMenu* editMenu = m_menuBar->addMenu (tr ("&Edit"));
+    editMenu->menuAction ()->setObjectName ("builtinMenu");
+    editMenu->addAction (tr ("Cop&y"), this, SLOT (editCopy (bool)),
+                         Qt::CTRL | Qt::Key_C);
+    editMenu->addSeparator ();
+    editMenu->addActions (m_mouseModeGroup->actions ());
 
-  win->addReceiver (this);
-  m_container->addReceiver (this);
-}
+    QMenu* helpMenu = m_menuBar->addMenu (tr ("&Help"));
+    helpMenu->menuAction ()->setObjectName ("builtinMenu");
+    helpMenu->addAction (tr ("About Octave"), this,
+                         SLOT (helpAboutOctave (void)));
+
+    m_menuBar->addReceiver (this);
+  }
+
+  void
+  Figure::updateFigureToolBarAndMenuBar (void)
+  {
+    if (m_mouseModeGroup)
+      {
+        m_blockUpdates = true;
+        m_mouseModeGroup->setMode (mouseMode ());
+        m_blockUpdates = false;
+      }
+  }
 
-Figure::~Figure (void)
-{
-}
+  Container*
+  Figure::innerContainer (void)
+  {
+    return m_container;
+  }
 
-static std::string
-mouse_mode_to_string (MouseMode mode)
-{
-  switch (mode)
+  void
+  Figure::redraw (void)
+  {
+    Canvas* canvas = m_container->canvas (m_handle);
+
+    if (canvas)
+      {
+        canvas->redraw ();
+        //canvas->setMouseMode (RotateMode);
+      }
+
+    foreach (QFrame* frame,
+             qWidget<QWidget> ()->findChildren<QFrame*> ())
     {
-    case NoMode:
-      return "none";
-
-    case RotateMode:
-      return "rotate";
-
-    case ZoomInMode:
-      return "zoom in";
-
-    case ZoomOutMode:
-      return "zoom out";
+      if (frame->objectName () == "UIPanel"
+          || frame->objectName () == "UIButtonGroup")
+        {
+          Object* obj = Object::fromQObject (frame);
 
-    case PanMode:
-      return "pan";
-
-    case TextMode:
-      return "text";
-
-    case SelectMode:
-      return "select";
-
-    default:
-      break;
+          if (obj)
+            obj->slotRedraw ();
+        }
     }
 
-  return "none";
-}
+    updateFigureToolBarAndMenuBar ();
+  }
 
-static MouseMode
-mouse_mode_from_string (const std::string& mode)
-{
-  if (mode == "none")
-    return NoMode;
-  else if (mode == "rotate")
-    return RotateMode;
-  else if (mode == "zoom in")
-    return ZoomInMode;
-  else if (mode == "zoom out")
-    return ZoomOutMode;
-  else if (mode == "pan")
-    return PanMode;
-  else if (mode == "text")
-    return TextMode;
-  else if (mode == "select")
-    return SelectMode;
-  else
-    return NoMode;
-}
-
-QString
-Figure::fileName (void)
-{
-  gh_manager::auto_lock lock;
-
-  const figure::properties& fp = properties<figure> ();
-
-  std::string name = fp.get_filename ();
-
-  return QString::fromStdString (name);
-}
-
-void
-Figure::setFileName (const QString& name)
-{
-  gh_manager::auto_lock lock;
-
-  figure::properties& fp = properties<figure> ();
-
-  fp.set_filename (name.toStdString ());
-}
+  void
+  Figure::print (const QString& file_cmd, const QString& term)
+  {
+    Canvas* canvas = m_container->canvas (m_handle);
 
-MouseMode
-Figure::mouseMode (void)
-{
-  gh_manager::auto_lock lock;
-
-  const figure::properties& fp = properties<figure> ();
-
-  std::string mode = fp.get___mouse_mode__ ();
-
-  if (mode == "zoom")
-    {
-      octave_scalar_map zm = fp.get___zoom_mode__ ().scalar_map_value ();
-
-      std::string direction = zm.getfield ("Direction").string_value ();
-
-      mode += " " + direction;
-    }
-
-  return mouse_mode_from_string (mode);
-}
+    if (canvas)
+      canvas->print (file_cmd, term);
+  }
 
-void
-Figure::createFigureToolBarAndMenuBar (void)
-{
-  QMainWindow* win = qWidget<QMainWindow> ();
-
-  m_figureToolBar = win->addToolBar (tr ("Figure ToolBar"));
-  m_figureToolBar->setMovable (false);
-  m_figureToolBar->setFloatable (false);
-
-  m_mouseModeGroup = new MouseModeActionGroup (win);
-  connect (m_mouseModeGroup, SIGNAL (modeChanged (MouseMode)),
-           SLOT (setMouseMode (MouseMode)));
-  m_figureToolBar->addActions (m_mouseModeGroup->actions ());
+  void
+  Figure::beingDeleted (void)
+  {
+    Canvas* canvas = m_container->canvas (m_handle.value (), false);
 
-  QAction *toggle_axes = m_figureToolBar->addAction (tr ("Axes"));
-  connect (toggle_axes, SIGNAL (triggered (void)),
-           this, SLOT (toggleAxes (void)));
-
-  QAction *toggle_grid = m_figureToolBar->addAction (tr ("Grid"));
-  connect (toggle_grid, SIGNAL (triggered (void)),
-           this, SLOT (toggleGrid (void)));
-
-  QAction *auto_axes = m_figureToolBar->addAction (tr ("Autoscale"));
-  connect (auto_axes, SIGNAL (triggered (void)),
-           this, SLOT (autoAxes (void)));
-
-  m_menuBar = new MenuBar (win);
-  win->setMenuBar (m_menuBar);
+    if (canvas)
+      canvas->blockRedraw (true);
 
-  QMenu* fileMenu = m_menuBar->addMenu (tr ("&File"));
-  fileMenu->menuAction ()->setObjectName ("builtinMenu");
-  fileMenu->addAction (tr ("&Save"), this, SLOT (fileSaveFigure (bool)));
-  fileMenu->addAction (tr ("Save &As"), this, SLOT (fileSaveFigureAs (void)));
-  fileMenu->addSeparator ();
-  fileMenu->addAction (tr ("&Close Figure"), this,
-                       SLOT (fileCloseFigure (void)), Qt::CTRL | Qt::Key_W);
-
-  QMenu* editMenu = m_menuBar->addMenu (tr ("&Edit"));
-  editMenu->menuAction ()->setObjectName ("builtinMenu");
-  editMenu->addAction (tr ("Cop&y"), this, SLOT (editCopy (bool)),
-                       Qt::CTRL | Qt::Key_C);
-  editMenu->addSeparator ();
-  editMenu->addActions (m_mouseModeGroup->actions ());
-
-  QMenu* helpMenu = m_menuBar->addMenu (tr ("&Help"));
-  helpMenu->menuAction ()->setObjectName ("builtinMenu");
-  helpMenu->addAction (tr ("About Octave"), this,
-                       SLOT (helpAboutOctave (void)));
-
-  m_menuBar->addReceiver (this);
-}
-
-void
-Figure::updateFigureToolBarAndMenuBar (void)
-{
-  if (m_mouseModeGroup)
-    {
-      m_blockUpdates = true;
-      m_mouseModeGroup->setMode (mouseMode ());
-      m_blockUpdates = false;
-    }
-}
-
-Container*
-Figure::innerContainer (void)
-{
-  return m_container;
-}
-
-void
-Figure::redraw (void)
-{
-  Canvas* canvas = m_container->canvas (m_handle);
-
-  if (canvas)
-    {
-    canvas->redraw ();
-    //canvas->setMouseMode (RotateMode);
-    }
+    m_menuBar->removeReceiver (this);
+    m_container->removeReceiver (this);
+    qWidget<FigureWindow> ()->removeReceiver (this);
+  }
 
-  foreach (QFrame* frame,
-           qWidget<QWidget> ()->findChildren<QFrame*> ())
-    {
-      if (frame->objectName () == "UIPanel" || frame->objectName () == "UIButtonGroup") {
-        Object* obj = Object::fromQObject (frame);
-
-        if (obj)
-          obj->slotRedraw ();
-      }
-    }
-
-  updateFigureToolBarAndMenuBar ();
-}
-
-void
-Figure::print (const QString& file_cmd, const QString& term)
-{
-  Canvas* canvas = m_container->canvas (m_handle);
-
-  if (canvas)
-    canvas->print (file_cmd, term);
-}
+  void
+  Figure::update (int pId)
+  {
+    if (m_blockUpdates)
+      return;
 
-void
-Figure::beingDeleted (void)
-{
-  Canvas* canvas = m_container->canvas (m_handle.value (), false);
-
-  if (canvas)
-    canvas->blockRedraw (true);
-
-  m_menuBar->removeReceiver (this);
-  m_container->removeReceiver (this);
-  qWidget<FigureWindow> ()->removeReceiver (this);
-}
+    figure::properties& fp = properties<figure> ();
+    QMainWindow* win = qWidget<QMainWindow> ();
 
-void
-Figure::update (int pId)
-{
-  if (m_blockUpdates)
-    return;
+    m_blockUpdates = true;
 
-  figure::properties& fp = properties<figure> ();
-  QMainWindow* win = qWidget<QMainWindow> ();
-
-  m_blockUpdates = true;
-
-  switch (pId)
-    {
-    case figure::properties::ID_POSITION:
+    switch (pId)
+      {
+      case figure::properties::ID_POSITION:
         {
           m_innerRect = boundingBoxToRect (fp.get_boundingbox (true));
           int toffset = 0;
           int boffset = 0;
 
           foreach (QToolBar* tb, win->findChildren<QToolBar*> ())
-            if (! tb->isHidden ())
-              toffset += tb->sizeHint ().height ();
+          if (! tb->isHidden ())
+            toffset += tb->sizeHint ().height ();
 
           if (! m_menuBar->isHidden ())
             toffset += m_menuBar->sizeHint ().height ();
 
           if (! m_statusBar->isHidden ())
             boffset += m_statusBar->sizeHint ().height ();
 
           win->setGeometry (m_innerRect.adjusted (0, -toffset, 0, boffset));
         }
-      break;
+        break;
 
-    case figure::properties::ID_NAME:
-    case figure::properties::ID_NUMBERTITLE:
-      win->setWindowTitle (Utils::fromStdString (fp.get_title ()));
-      break;
+      case figure::properties::ID_NAME:
+      case figure::properties::ID_NUMBERTITLE:
+        win->setWindowTitle (Utils::fromStdString (fp.get_title ()));
+        break;
 
-    case figure::properties::ID_VISIBLE:
-      if (fp.is_visible ())
-        QTimer::singleShot (0, win, SLOT (show ()));
-      else
-        win->hide ();
-      break;
+      case figure::properties::ID_VISIBLE:
+        if (fp.is_visible ())
+          QTimer::singleShot (0, win, SLOT (show ()));
+        else
+          win->hide ();
+        break;
 
-    case figure::properties::ID_TOOLBAR:
-      if (fp.toolbar_is ("none"))
-        showFigureToolBar (false);
-      else if (fp.toolbar_is ("figure"))
-        showFigureToolBar (true);
-      else // "auto"
-        showFigureToolBar (! hasUiControlChildren (fp) &&
-                           fp.menubar_is ("figure"));
-      break;
+      case figure::properties::ID_TOOLBAR:
+        if (fp.toolbar_is ("none"))
+          showFigureToolBar (false);
+        else if (fp.toolbar_is ("figure"))
+          showFigureToolBar (true);
+        else // "auto"
+          showFigureToolBar (! hasUiControlChildren (fp) &&
+                             fp.menubar_is ("figure"));
+        break;
 
-    case figure::properties::ID_MENUBAR:
-      showMenuBar (fp.menubar_is ("figure"));
-      if (fp.toolbar_is ("auto"))
-        showFigureToolBar (fp.menubar_is ("figure"));
-      break;
+      case figure::properties::ID_MENUBAR:
+        showMenuBar (fp.menubar_is ("figure"));
+        if (fp.toolbar_is ("auto"))
+          showFigureToolBar (fp.menubar_is ("figure"));
+        break;
 
-    case figure::properties::ID_KEYPRESSFCN:
-      if (fp.get_keypressfcn ().is_empty ())
-        m_container->canvas (m_handle)->clearEventMask (Canvas::KeyPress);
-      else
-        m_container->canvas (m_handle)->addEventMask (Canvas::KeyPress);
-      break;
+      case figure::properties::ID_KEYPRESSFCN:
+        if (fp.get_keypressfcn ().is_empty ())
+          m_container->canvas (m_handle)->clearEventMask (Canvas::KeyPress);
+        else
+          m_container->canvas (m_handle)->addEventMask (Canvas::KeyPress);
+        break;
 
-    case figure::properties::ID_KEYRELEASEFCN:
-      if (fp.get_keyreleasefcn ().is_empty ())
-        m_container->canvas (m_handle)->clearEventMask (Canvas::KeyRelease);
-      else
-        m_container->canvas (m_handle)->addEventMask (Canvas::KeyRelease);
-      break;
+      case figure::properties::ID_KEYRELEASEFCN:
+        if (fp.get_keyreleasefcn ().is_empty ())
+          m_container->canvas (m_handle)->clearEventMask (Canvas::KeyRelease);
+        else
+          m_container->canvas (m_handle)->addEventMask (Canvas::KeyRelease);
+        break;
 
-    case figure::properties::ID_WINDOWSTYLE:
-      if (fp.windowstyle_is ("modal"))
-        {
-          bool is_visible = win->isVisible ();
+      case figure::properties::ID_WINDOWSTYLE:
+        if (fp.windowstyle_is ("modal"))
+          {
+            bool is_visible = win->isVisible ();
 
-          // if window is already visible, need to hide and reshow it in order to
-          // make it use the modal settings
-          if (is_visible)
-            win->setVisible (false);
+            // if window is already visible, need to hide and reshow it in order to
+            // make it use the modal settings
+            if (is_visible)
+              win->setVisible (false);
 
-          win->setWindowModality (Qt::ApplicationModal);
-          win->setVisible (is_visible);
-        }
-      else
-        win->setWindowModality (Qt::NonModal);
+            win->setWindowModality (Qt::ApplicationModal);
+            win->setVisible (is_visible);
+          }
+        else
+          win->setWindowModality (Qt::NonModal);
 
-      break;
+        break;
 
-    default:
-      break;
-    }
+      default:
+        break;
+      }
 
-  m_blockUpdates = false;
-}
+    m_blockUpdates = false;
+  }
 
-void
-Figure::showFigureToolBar (bool visible)
-{
-  if ((! m_figureToolBar->isHidden ()) != visible)
-    {
-      int dy1 = m_figureToolBar->sizeHint ().height ();
-      int dy2 = m_statusBar->sizeHint ().height ();
-      QRect r = qWidget<QWidget> ()->geometry ();
+  void
+  Figure::showFigureToolBar (bool visible)
+  {
+    if ((! m_figureToolBar->isHidden ()) != visible)
+      {
+        int dy1 = m_figureToolBar->sizeHint ().height ();
+        int dy2 = m_statusBar->sizeHint ().height ();
+        QRect r = qWidget<QWidget> ()->geometry ();
 
-      if (! visible)
-        r.adjust (0, dy1, 0, -dy2);
-      else
-        r.adjust (0, -dy1, 0, dy2);
+        if (! visible)
+          r.adjust (0, dy1, 0, -dy2);
+        else
+          r.adjust (0, -dy1, 0, dy2);
 
-      m_blockUpdates = true;
-      qWidget<QWidget> ()->setGeometry (r);
-      m_figureToolBar->setVisible (visible);
-      m_statusBar->setVisible (visible);
-      m_blockUpdates = false;
+        m_blockUpdates = true;
+        qWidget<QWidget> ()->setGeometry (r);
+        m_figureToolBar->setVisible (visible);
+        m_statusBar->setVisible (visible);
+        m_blockUpdates = false;
 
-      updateBoundingBox (false);
-    }
-}
+        updateBoundingBox (false);
+      }
+  }
 
-void
-Figure::showMenuBar (bool visible)
-{
-  int h1 = m_menuBar->sizeHint ().height ();
+  void
+  Figure::showMenuBar (bool visible)
+  {
+    int h1 = m_menuBar->sizeHint ().height ();
 
-  foreach (QAction* a, m_menuBar->actions ())
+    foreach (QAction* a, m_menuBar->actions ())
     if (a->objectName () == "builtinMenu")
       a->setVisible (visible);
 
-  int h2 = m_menuBar->sizeHint ().height ();
-
-  if (! visible)
-    visible = hasUiMenuChildren (properties<figure> ());
+    int h2 = m_menuBar->sizeHint ().height ();
 
-  if (! m_menuBar->isHidden ())
-    {
-      int dy = qMax (h1, h2);
-      QRect r = qWidget<QWidget> ()->geometry ();
+    if (! visible)
+      visible = hasUiMenuChildren (properties<figure> ());
 
-      //qDebug () << "Figure::showMenuBar:" << r;
-      if (! visible)
-        r.adjust (0, dy, 0, 0);
-      else
-        r.adjust (0, -dy, 0, 0);
-      //qDebug () << "Figure::showMenuBar(adjusted):" << r;
+    if (! m_menuBar->isHidden ())
+      {
+        int dy = qMax (h1, h2);
+        QRect r = qWidget<QWidget> ()->geometry ();
 
-      m_blockUpdates = true;
-      qWidget<QWidget> ()->setGeometry (r);
-      m_menuBar->setVisible (visible);
-      m_blockUpdates = false;
+        //qDebug () << "Figure::showMenuBar:" << r;
+        if (! visible)
+          r.adjust (0, dy, 0, 0);
+        else
+          r.adjust (0, -dy, 0, 0);
+        //qDebug () << "Figure::showMenuBar(adjusted):" << r;
 
-      updateBoundingBox (false);
-    }
-}
+        m_blockUpdates = true;
+        qWidget<QWidget> ()->setGeometry (r);
+        m_menuBar->setVisible (visible);
+        m_blockUpdates = false;
 
-void
-Figure::updateMenuBar (void)
-{
-  gh_manager::auto_lock lock;
-  graphics_object go = object ();
-
-  if (go.valid_object ())
-    showMenuBar (Utils::properties<figure> (go).menubar_is ("figure"));
-}
+        updateBoundingBox (false);
+      }
+  }
 
-void
-Figure::updateStatusBar (ColumnVector pt)
-{
-  if (! m_statusBar->isHidden ())
-    m_statusBar->showMessage (QString ("(%1, %2)")
-                              .arg (pt(0), 0, 'g', 5)
-                              .arg (pt(1), 0, 'g', 5));
-}
+  void
+  Figure::updateMenuBar (void)
+  {
+    gh_manager::auto_lock lock;
+    graphics_object go = object ();
 
-QWidget*
-Figure::menu (void)
-{
-  return qWidget<QMainWindow> ()->menuBar ();
-}
+    if (go.valid_object ())
+      showMenuBar (Utils::properties<figure> (go).menubar_is ("figure"));
+  }
 
-struct UpdateBoundingBoxData
-{
-  Matrix m_bbox;
-  bool m_internal;
-  graphics_handle m_handle;
-  Figure* m_figure;
-};
-
-void
-Figure::updateBoundingBoxHelper (void* data)
-{
-  gh_manager::auto_lock lock;
+  void
+  Figure::updateStatusBar (ColumnVector pt)
+  {
+    if (! m_statusBar->isHidden ())
+      m_statusBar->showMessage (QString ("(%1, %2)")
+                                .arg (pt(0), 0, 'g', 5)
+                                .arg (pt(1), 0, 'g', 5));
+  }
 
-  UpdateBoundingBoxData* d = reinterpret_cast<UpdateBoundingBoxData*> (data);
-  graphics_object go = gh_manager::get_object (d->m_handle);
-
-  if (go.valid_object ())
-    {
-      figure::properties& fp = Utils::properties<figure> (go);
-
-      fp.set_boundingbox (d->m_bbox, d->m_internal, false);
-    }
-
-  delete d;
-}
+  QWidget*
+  Figure::menu (void)
+  {
+    return qWidget<QMainWindow> ()->menuBar ();
+  }
 
-void
-Figure::updateBoundingBox (bool internal, int flags)
-{
-  QWidget* win = qWidget<QWidget> ();
-  Matrix bb (1, 4);
-
-  if (internal)
-    {
-      QRect r = m_innerRect;
-
-      if (flags & UpdateBoundingBoxPosition)
-        r.moveTopLeft (win->mapToGlobal (m_container->pos ()));
-      if (flags & UpdateBoundingBoxSize)
-        r.setSize (m_container->size ());
+  struct UpdateBoundingBoxData
+  {
+    Matrix m_bbox;
+    bool m_internal;
+    graphics_handle m_handle;
+    Figure* m_figure;
+  };
 
-      if (r.isValid () && r != m_innerRect)
-        {
-          m_innerRect = r;
+  void
+  Figure::updateBoundingBoxHelper (void* data)
+  {
+    gh_manager::auto_lock lock;
 
-          bb(0) = r.x ();
-          bb(1) = r.y ();
-          bb(2) = r.width ();
-          bb(3) = r.height ();
-        }
-      else
-        return;
-    }
-  else
-    {
-      QRect r = m_outerRect;
+    UpdateBoundingBoxData* d = reinterpret_cast<UpdateBoundingBoxData*> (data);
+    graphics_object go = gh_manager::get_object (d->m_handle);
+
+    if (go.valid_object ())
+      {
+        figure::properties& fp = Utils::properties<figure> (go);
+
+        fp.set_boundingbox (d->m_bbox, d->m_internal, false);
+      }
 
-      if (flags & UpdateBoundingBoxPosition)
-        r.moveTopLeft (win->pos ());
-      if (flags & UpdateBoundingBoxSize)
-        r.setSize (win->frameGeometry ().size ());
-
-      if (r.isValid () && r != m_outerRect)
-        {
-          m_outerRect = r;
+    delete d;
+  }
 
-          bb(0) = r.x ();
-          bb(1) = r.y ();
-          bb(2) = r.width ();
-          bb(3) = r.height ();
-        }
-      else
-        return;
-    }
+  void
+  Figure::updateBoundingBox (bool internal, int flags)
+  {
+    QWidget* win = qWidget<QWidget> ();
+    Matrix bb (1, 4);
 
-  UpdateBoundingBoxData* d = new UpdateBoundingBoxData ();
-
-  d->m_bbox = bb;
-  d->m_internal = internal;
-  d->m_handle = m_handle;
-  d->m_figure = this;
+    if (internal)
+      {
+        QRect r = m_innerRect;
 
-  gh_manager::post_function (Figure::updateBoundingBoxHelper, d);
-}
+        if (flags & UpdateBoundingBoxPosition)
+          r.moveTopLeft (win->mapToGlobal (m_container->pos ()));
+        if (flags & UpdateBoundingBoxSize)
+          r.setSize (m_container->size ());
+
+        if (r.isValid () && r != m_innerRect)
+          {
+            m_innerRect = r;
 
-bool
-Figure::eventNotifyBefore (QObject* obj, QEvent* xevent)
-{
-  if (! m_blockUpdates)
-    {
-      if (obj == m_container)
-        {
-          // Do nothing...
-        }
-      else if (obj == m_menuBar)
-        {
-          switch (xevent->type ())
-            {
-            case QEvent::ActionRemoved:
-              {
-                QAction* a = dynamic_cast<QActionEvent*> (xevent)->action ();
-
-                if (! a->isSeparator ()
-                    && a->objectName () != "builtinMenu")
-                  updateMenuBar ();
-              }
-              break;
+            bb(0) = r.x ();
+            bb(1) = r.y ();
+            bb(2) = r.width ();
+            bb(3) = r.height ();
+          }
+        else
+          return;
+      }
+    else
+      {
+        QRect r = m_outerRect;
 
-            default:
-              break;
-            }
-        }
-      else
-        {
-          switch (xevent->type ())
-            {
-            case QEvent::Close:
-              xevent->ignore ();
-              gh_manager::post_callback (m_handle, "closerequestfcn");
-              return true;
+        if (flags & UpdateBoundingBoxPosition)
+          r.moveTopLeft (win->pos ());
+        if (flags & UpdateBoundingBoxSize)
+          r.setSize (win->frameGeometry ().size ());
+
+        if (r.isValid () && r != m_outerRect)
+          {
+            m_outerRect = r;
 
-            default:
-              break;
-            }
-        }
-    }
+            bb(0) = r.x ();
+            bb(1) = r.y ();
+            bb(2) = r.width ();
+            bb(3) = r.height ();
+          }
+        else
+          return;
+      }
 
-  return false;
-}
+    UpdateBoundingBoxData* d = new UpdateBoundingBoxData ();
 
-void
-Figure::eventNotifyAfter (QObject* watched, QEvent* xevent)
-{
-  if (! m_blockUpdates)
-    {
-      if (watched == m_container)
-        {
-          switch (xevent->type ())
-            {
-            case QEvent::Resize:
-              updateBoundingBox (true, UpdateBoundingBoxSize);
-              break;
+    d->m_bbox = bb;
+    d->m_internal = internal;
+    d->m_handle = m_handle;
+    d->m_figure = this;
 
-            case QEvent::ChildAdded:
-              if (dynamic_cast<QChildEvent*> (xevent)->child
-                  ()->isWidgetType())
-                {
-                  gh_manager::auto_lock lock;
-                  update (figure::properties::ID_TOOLBAR);
+    gh_manager::post_function (Figure::updateBoundingBoxHelper, d);
+  }
 
-                  enableMouseTracking ();
-                }
-
-            case QEvent::ChildRemoved:
-              if (dynamic_cast<QChildEvent*> (xevent)->child
-                  ()->isWidgetType())
-                {
-                  gh_manager::auto_lock lock;
-                  update (figure::properties::ID_TOOLBAR);
-                }
-
-            default:
-              break;
-            }
-        }
-      else if (watched == m_menuBar)
-        {
-          switch (xevent->type ())
-            {
-            case QEvent::ActionAdded:
+  bool
+  Figure::eventNotifyBefore (QObject* obj, QEvent* xevent)
+  {
+    if (! m_blockUpdates)
+      {
+        if (obj == m_container)
+          {
+            // Do nothing...
+          }
+        else if (obj == m_menuBar)
+          {
+            switch (xevent->type ())
+              {
+              case QEvent::ActionRemoved:
                 {
                   QAction* a = dynamic_cast<QActionEvent*> (xevent)->action ();
 
                   if (! a->isSeparator ()
                       && a->objectName () != "builtinMenu")
                     updateMenuBar ();
                 }
-              break;
+                break;
+
+              default:
+                break;
+              }
+          }
+        else
+          {
+            switch (xevent->type ())
+              {
+              case QEvent::Close:
+                xevent->ignore ();
+                gh_manager::post_callback (m_handle, "closerequestfcn");
+                return true;
+
+              default:
+                break;
+              }
+          }
+      }
 
-            default:
-              break;
-            }
-        }
-      else
-        {
-          switch (xevent->type ())
-            {
-            case QEvent::Move:
-              updateBoundingBox (false, UpdateBoundingBoxPosition);
-              updateBoundingBox (true, UpdateBoundingBoxPosition);
-              break;
+    return false;
+  }
 
-            case QEvent::Resize:
-              updateBoundingBox (false, UpdateBoundingBoxSize);
-              break;
+  void
+  Figure::eventNotifyAfter (QObject* watched, QEvent* xevent)
+  {
+    if (! m_blockUpdates)
+      {
+        if (watched == m_container)
+          {
+            switch (xevent->type ())
+              {
+              case QEvent::Resize:
+                updateBoundingBox (true, UpdateBoundingBoxSize);
+                break;
 
-            default:
-              break;
-            }
-        }
-    }
-}
+              case QEvent::ChildAdded:
+                if (dynamic_cast<QChildEvent*> (xevent)->child
+                    ()->isWidgetType())
+                  {
+                    gh_manager::auto_lock lock;
+                    update (figure::properties::ID_TOOLBAR);
+
+                    enableMouseTracking ();
+                  }
 
-void
-Figure::helpAboutOctave (void)
-{
-  std::string message
-    = octave_name_version_copyright_copying_warranty_and_bugs (true);
+              case QEvent::ChildRemoved:
+                if (dynamic_cast<QChildEvent*> (xevent)->child
+                    ()->isWidgetType())
+                  {
+                    gh_manager::auto_lock lock;
+                    update (figure::properties::ID_TOOLBAR);
+                  }
 
-  QMessageBox::about (qWidget<QMainWindow> (), tr ("About Octave"),
-                      QString::fromStdString (message));
-}
-
-void
-Figure::setMouseMode (MouseMode mode)
-{
-  if (m_blockUpdates)
-    return;
-
-  gh_manager::auto_lock lock;
+              default:
+                break;
+              }
+          }
+        else if (watched == m_menuBar)
+          {
+            switch (xevent->type ())
+              {
+              case QEvent::ActionAdded:
+                {
+                  QAction* a = dynamic_cast<QActionEvent*> (xevent)->action ();
 
-  figure::properties& fp = properties<figure> ();
-
-  fp.set___mouse_mode__ (mouse_mode_to_string (mode));
-
-  Canvas* canvas = m_container->canvas (m_handle);
+                  if (! a->isSeparator ()
+                      && a->objectName () != "builtinMenu")
+                    updateMenuBar ();
+                }
+                break;
 
-  if (canvas)
-    canvas->setCursor (mode);
-}
+              default:
+                break;
+              }
+          }
+        else
+          {
+            switch (xevent->type ())
+              {
+              case QEvent::Move:
+                updateBoundingBox (false, UpdateBoundingBoxPosition);
+                updateBoundingBox (true, UpdateBoundingBoxPosition);
+                break;
 
-void
-Figure::fileSaveFigure (bool prompt)
-{
-  QString file = fileName ();
+              case QEvent::Resize:
+                updateBoundingBox (false, UpdateBoundingBoxSize);
+                break;
 
-  if (file.isEmpty ())
-    {
-      prompt = true;
+              default:
+                break;
+              }
+          }
+      }
+  }
 
-      file = "untitled.pdf";
-    }
+  void
+  Figure::helpAboutOctave (void)
+  {
+    std::string message
+      = octave_name_version_copyright_copying_warranty_and_bugs (true);
+
+    QMessageBox::about (qWidget<QMainWindow> (), tr ("About Octave"),
+                        QString::fromStdString (message));
+  }
 
-  if (prompt || file.isEmpty ())
-    {
-      QFileInfo finfo (file);
+  void
+  Figure::setMouseMode (MouseMode mode)
+  {
+    if (m_blockUpdates)
+      return;
 
-      file = QFileDialog::getSaveFileName (qWidget<FigureWindow> (),
-                                           tr ("Save Figure As"),
-                                           finfo.absoluteFilePath (), 0, 0,
-                                           QFileDialog::DontUseNativeDialog);
-    }
+    gh_manager::auto_lock lock;
+
+    figure::properties& fp = properties<figure> ();
+
+    fp.set___mouse_mode__ (mouse_mode_to_string (mode));
+
+    Canvas* canvas = m_container->canvas (m_handle);
 
-  if (! file.isEmpty ())
-    {
-      QFileInfo finfo (file);
+    if (canvas)
+      canvas->setCursor (mode);
+  }
 
-      setFileName (finfo.absoluteFilePath ());
+  void
+  Figure::fileSaveFigure (bool prompt)
+  {
+    QString file = fileName ();
+
+    if (file.isEmpty ())
+      {
+        prompt = true;
 
-      octave_link::post_event (this, &Figure::save_figure_callback,
-                               file.toStdString ());
-    }
-}
+        file = "untitled.pdf";
+      }
 
-void
-Figure::save_figure_callback (const std::string& file)
-{
-  figure::properties& fp = properties<figure> ();
-  octave_value fnum = fp.get___myhandle__ ().as_octave_value ();
+    if (prompt || file.isEmpty ())
+      {
+        QFileInfo finfo (file);
 
-  Ffeval (ovl ("print", fnum, file));
-}
+        file = QFileDialog::getSaveFileName (qWidget<FigureWindow> (),
+                                             tr ("Save Figure As"),
+                                             finfo.absoluteFilePath (), 0, 0,
+                                             QFileDialog::DontUseNativeDialog);
+      }
 
-void
-Figure::copy_figure_callback (const std::string& format)
-{
-  std::string msg;
+    if (! file.isEmpty ())
+      {
+        QFileInfo finfo (file);
 
-  std::string file = octave::sys::tempnam ("", "oct-", msg) + "." + format;
+        setFileName (finfo.absoluteFilePath ());
+
+        octave_link::post_event (this, &Figure::save_figure_callback,
+                                 file.toStdString ());
+      }
+  }
 
-  if (file.empty ())
-    {
-      // Report error?
-      return;
-    }
+  void
+  Figure::save_figure_callback (const std::string& file)
+  {
+    figure::properties& fp = properties<figure> ();
+    octave_value fnum = fp.get___myhandle__ ().as_octave_value ();
 
-  save_figure_callback (file);
+    Ffeval (ovl ("print", fnum, file));
+  }
+
+  void
+  Figure::copy_figure_callback (const std::string& format)
+  {
+    std::string msg;
+
+    std::string file = octave::sys::tempnam ("", "oct-", msg) + "." + format;
 
-  octave_link::copy_image_to_clipboard (file);
-}
+    if (file.empty ())
+      {
+        // Report error?
+        return;
+      }
 
-void
-Figure::fileSaveFigureAs (void)
-{
-  fileSaveFigure (true);
-}
+    save_figure_callback (file);
+
+    octave_link::copy_image_to_clipboard (file);
+  }
 
-void
-Figure::fileCloseFigure (void)
-{
-  qWidget<QMainWindow> ()->close ();
-}
+  void
+  Figure::fileSaveFigureAs (void)
+  {
+    fileSaveFigure (true);
+  }
 
-void
-Figure::editCopy (bool /* choose_format */)
-{
-  QString format = "png";
+  void
+  Figure::fileCloseFigure (void)
+  {
+    qWidget<QMainWindow> ()->close ();
+  }
+
+  void
+  Figure::editCopy (bool /* choose_format */)
+  {
+    QString format = "png";
 
 #if 0
 
-  // FIXME: allow choice of image formats.
+    // FIXME: allow choice of image formats.
 
-  if (choose_format)
-    {
-      QFileInfo finfo (file);
+    if (choose_format)
+      {
+        QFileInfo finfo (file);
 
-      format = QFileDialog::getSaveFileName (qWidget<FigureWindow> (),
-                                           tr ("Save Figure As"),
-                                           finfo.absoluteFilePath (), 0, 0,
-                                           QFileDialog::DontUseNativeDialog);
-    }
+        format = QFileDialog::getSaveFileName (qWidget<FigureWindow> (),
+                                               tr ("Save Figure As"),
+                                               finfo.absoluteFilePath (), 0, 0,
+                                               QFileDialog::DontUseNativeDialog);
+      }
 #endif
 
-  octave_link::post_event (this, &Figure::copy_figure_callback,
-                           format.toStdString ());
-}
+    octave_link::post_event (this, &Figure::copy_figure_callback,
+                             format.toStdString ());
+  }
 
-void
-Figure::addCustomToolBar (QToolBar* bar, bool visible)
-{
-  QMainWindow* win = qWidget<QMainWindow> ();
+  void
+  Figure::addCustomToolBar (QToolBar* bar, bool visible)
+  {
+    QMainWindow* win = qWidget<QMainWindow> ();
 
-  if (! visible)
-    win->addToolBar (bar);
-  else
-    {
-      QSize sz = bar->sizeHint ();
-      QRect r = win->geometry ();
-      //qDebug () << "Figure::addCustomToolBar:" << r;
+    if (! visible)
+      win->addToolBar (bar);
+    else
+      {
+        QSize sz = bar->sizeHint ();
+        QRect r = win->geometry ();
+        //qDebug () << "Figure::addCustomToolBar:" << r;
 
-      r.adjust (0, -sz.height (), 0, 0);
+        r.adjust (0, -sz.height (), 0, 0);
 
-      m_blockUpdates = true;
-      win->setGeometry (r);
-      win->addToolBarBreak ();
-      win->addToolBar (bar);
-      m_blockUpdates = false;
+        m_blockUpdates = true;
+        win->setGeometry (r);
+        win->addToolBarBreak ();
+        win->addToolBar (bar);
+        m_blockUpdates = false;
 
-      //qDebug () << "Figure::addCustomToolBar:" << win->geometry ();
-      updateBoundingBox (false);
-    }
-}
+        //qDebug () << "Figure::addCustomToolBar:" << win->geometry ();
+        updateBoundingBox (false);
+      }
+  }
 
-void
-Figure::showCustomToolBar (QToolBar* bar, bool visible)
-{
-  QMainWindow* win = qWidget<QMainWindow> ();
+  void
+  Figure::showCustomToolBar (QToolBar* bar, bool visible)
+  {
+    QMainWindow* win = qWidget<QMainWindow> ();
 
-  if ((! bar->isHidden ()) != visible)
-    {
-      QSize sz = bar->sizeHint ();
-      QRect r = win->geometry ();
+    if ((! bar->isHidden ()) != visible)
+      {
+        QSize sz = bar->sizeHint ();
+        QRect r = win->geometry ();
 
-      if (visible)
-        r.adjust (0, -sz.height (), 0, 0);
-      else
-        r.adjust (0, sz.height (), 0, 0);
+        if (visible)
+          r.adjust (0, -sz.height (), 0, 0);
+        else
+          r.adjust (0, sz.height (), 0, 0);
 
-      m_blockUpdates = true;
-      win->setGeometry (r);
-      bar->setVisible (visible);
-      m_blockUpdates = false;
+        m_blockUpdates = true;
+        win->setGeometry (r);
+        bar->setVisible (visible);
+        m_blockUpdates = false;
 
-      updateBoundingBox (false);
-    }
-}
+        updateBoundingBox (false);
+      }
+  }
 
-void
-Figure::updateContainer (void)
-{
-  redraw ();
-}
+  void
+  Figure::updateContainer (void)
+  {
+    redraw ();
+  }
 
-void
-Figure::toggleAxes (void)
-{
-  Canvas* canvas = m_container->canvas (m_handle);
+  void
+  Figure::toggleAxes (void)
+  {
+    Canvas* canvas = m_container->canvas (m_handle);
 
-  if (canvas)
-    canvas->toggleAxes (m_handle);
-}
+    if (canvas)
+      canvas->toggleAxes (m_handle);
+  }
 
-void
-Figure::toggleGrid (void)
-{
-  Canvas* canvas = m_container->canvas (m_handle);
+  void
+  Figure::toggleGrid (void)
+  {
+    Canvas* canvas = m_container->canvas (m_handle);
 
-  if (canvas)
-    canvas->toggleGrid (m_handle);
-}
+    if (canvas)
+      canvas->toggleGrid (m_handle);
+  }
 
-void
-Figure::autoAxes (void)
-{
-  Canvas* canvas = m_container->canvas (m_handle);
+  void
+  Figure::autoAxes (void)
+  {
+    Canvas* canvas = m_container->canvas (m_handle);
 
-  if (canvas)
-    canvas->autoAxes (m_handle);
-}
+    if (canvas)
+      canvas->autoAxes (m_handle);
+  }
 
-void
-Figure::enableMouseTracking (void)
-{
-  // Enable mouse tracking on every widgets
-  m_container->setMouseTracking (true);
-  m_container->canvas (m_handle)->qWidget ()->setMouseTracking (true);
-  foreach (QWidget* w, m_container->findChildren<QWidget*> ())
+  void
+  Figure::enableMouseTracking (void)
+  {
+    // Enable mouse tracking on every widgets
+    m_container->setMouseTracking (true);
+    m_container->canvas (m_handle)->qWidget ()->setMouseTracking (true);
+    foreach (QWidget* w, m_container->findChildren<QWidget*> ())
     { w->setMouseTracking (true); }
-}
+  }
 
 }; // namespace QtHandles
+
diff --git a/libgui/graphics/Figure.h b/libgui/graphics/Figure.h
--- a/libgui/graphics/Figure.h
+++ b/libgui/graphics/Figure.h
@@ -31,117 +31,118 @@ along with Octave; see the file COPYING.
 #include "Object.h"
 
 class QMainWindow;
 class QToolBar;
 
 namespace QtHandles
 {
 
-enum MouseMode
-{
-  // NOTE: These values must match the order of the buttons in the
-  // MouseModeActionGroup object.
+  enum MouseMode
+  {
+    // NOTE: These values must match the order of the buttons in the
+    // MouseModeActionGroup object.
 
-  NoMode      = 0,
-  RotateMode  = 1,
-  ZoomInMode  = 2,
-  ZoomOutMode = 3,
-  PanMode     = 4,
-  TextMode    = 5,
-  SelectMode  = 6
-};
+    NoMode      = 0,
+    RotateMode  = 1,
+    ZoomInMode  = 2,
+    ZoomOutMode = 3,
+    PanMode     = 4,
+    TextMode    = 5,
+    SelectMode  = 6
+  };
 
-class Container;
-class FigureWindow;
-class MenuBar;
-class ToolBar;
+  class Container;
+  class FigureWindow;
+  class MenuBar;
+  class ToolBar;
 
-class MouseModeActionGroup;
+  class MouseModeActionGroup;
 
-class Figure :
+  class Figure :
   public Object,
   public MenuContainer,
   public GenericEventNotifyReceiver
-{
-  Q_OBJECT
+  {
+    Q_OBJECT
 
-  friend class ToolBar;
+    friend class ToolBar;
 
-public:
-  Figure (const graphics_object& go, FigureWindow* win);
-  ~Figure (void);
+  public:
+    Figure (const graphics_object& go, FigureWindow* win);
+    ~Figure (void);
 
-  static Figure* create (const graphics_object& go);
+    static Figure* create (const graphics_object& go);
 
-  QString fileName (void);
-  void setFileName (const QString& name);
+    QString fileName (void);
+    void setFileName (const QString& name);
 
-  MouseMode mouseMode (void);
+    MouseMode mouseMode (void);
 
-  Container* innerContainer (void);
-  QWidget* menu (void);
-  void updateStatusBar (ColumnVector pt);
+    Container* innerContainer (void);
+    QWidget* menu (void);
+    void updateStatusBar (ColumnVector pt);
 
-  bool eventNotifyBefore (QObject* watched, QEvent* event);
-  void eventNotifyAfter (QObject* watched, QEvent* event);
+    bool eventNotifyBefore (QObject* watched, QEvent* event);
+    void eventNotifyAfter (QObject* watched, QEvent* event);
 
-protected:
-  enum UpdateBoundingBoxFlag
+  protected:
+    enum UpdateBoundingBoxFlag
     {
       UpdateBoundingBoxPosition = 0x1,
       UpdateBoundingBoxSize     = 0x2,
       UpdateBoundingBoxAll      = 0x3
     };
 
-protected:
-  void redraw (void);
-  void print (const QString& file_cmd, const QString& term);
-  void update (int pId);
-  void updateBoundingBox (bool internal = false, int flags = 0);
-  void beingDeleted (void);
+  protected:
+    void redraw (void);
+    void print (const QString& file_cmd, const QString& term);
+    void update (int pId);
+    void updateBoundingBox (bool internal = false, int flags = 0);
+    void beingDeleted (void);
 
-private:
-  void createFigureToolBarAndMenuBar (void);
-  void showFigureToolBar (bool visible);
-  void showMenuBar (bool visible);
-  void addCustomToolBar (QToolBar* bar, bool visible);
-  void showCustomToolBar (QToolBar* bar, bool visible);
+  private:
+    void createFigureToolBarAndMenuBar (void);
+    void showFigureToolBar (bool visible);
+    void showMenuBar (bool visible);
+    void addCustomToolBar (QToolBar* bar, bool visible);
+    void showCustomToolBar (QToolBar* bar, bool visible);
 
-  void updateFigureToolBarAndMenuBar (void);
+    void updateFigureToolBarAndMenuBar (void);
 
-  static void updateBoundingBoxHelper (void*);
+    static void updateBoundingBoxHelper (void*);
 
-  void save_figure_callback (const std::string& file);
-  void copy_figure_callback (const std::string& format);
+    void save_figure_callback (const std::string& file);
+    void copy_figure_callback (const std::string& format);
 
-  void enableMouseTracking (void);
+    void enableMouseTracking (void);
 
-private slots:
-  void setMouseMode (MouseMode mode);
-  void fileSaveFigure (bool prompt = false);
-  void fileSaveFigureAs (void);
-  void fileCloseFigure (void);
-  void editCopy (bool choose_format = false);
-  void helpAboutOctave (void);
-  void updateMenuBar (void);
-  void updateContainer (void);
-  void toggleAxes (void);
-  void toggleGrid (void);
-  void autoAxes (void);
+  private slots:
+    void setMouseMode (MouseMode mode);
+    void fileSaveFigure (bool prompt = false);
+    void fileSaveFigureAs (void);
+    void fileCloseFigure (void);
+    void editCopy (bool choose_format = false);
+    void helpAboutOctave (void);
+    void updateMenuBar (void);
+    void updateContainer (void);
+    void toggleAxes (void);
+    void toggleGrid (void);
+    void autoAxes (void);
 
-signals:
-  void asyncUpdate (void);
+  signals:
+    void asyncUpdate (void);
 
-private:
-  Container* m_container;
-  bool m_blockUpdates;
-  QToolBar* m_figureToolBar;
-  MenuBar* m_menuBar;
-  QStatusBar* m_statusBar;
-  QRect m_innerRect;
-  QRect m_outerRect;
-  MouseModeActionGroup* m_mouseModeGroup;
-};
+  private:
+    Container* m_container;
+    bool m_blockUpdates;
+    QToolBar* m_figureToolBar;
+    MenuBar* m_menuBar;
+    QStatusBar* m_statusBar;
+    QRect m_innerRect;
+    QRect m_outerRect;
+    MouseModeActionGroup* m_mouseModeGroup;
+  };
 
 }; // namespace QtHandles
 
 #endif
+
diff --git a/libgui/graphics/FigureWindow.cc b/libgui/graphics/FigureWindow.cc
--- a/libgui/graphics/FigureWindow.cc
+++ b/libgui/graphics/FigureWindow.cc
@@ -26,27 +26,28 @@ along with Octave; see the file COPYING.
 
 #include <QMenu>
 
 #include "FigureWindow.h"
 
 namespace QtHandles
 {
 
-FigureWindow::FigureWindow (QWidget* xparent)
-  : FigureWindowBase (xparent)
-{
-  // set icon from application resources
-  setWindowIcon (QIcon (":/actions/icons/logo.png"));
-}
+  FigureWindow::FigureWindow (QWidget* xparent)
+    : FigureWindowBase (xparent)
+  {
+    // set icon from application resources
+    setWindowIcon (QIcon (":/actions/icons/logo.png"));
+  }
 
-FigureWindow::~FigureWindow (void)
-{
-}
+  FigureWindow::~FigureWindow (void)
+  {
+  }
 
-QMenu*
-FigureWindow::createPopupMenu (void)
-{
-  // For the time being, disable menubar/toolbar popup menu
-  return 0;
-}
+  QMenu*
+  FigureWindow::createPopupMenu (void)
+  {
+    // For the time being, disable menubar/toolbar popup menu
+    return 0;
+  }
 
 }; // namespace QtHandles
+
diff --git a/libgui/graphics/FigureWindow.h b/libgui/graphics/FigureWindow.h
--- a/libgui/graphics/FigureWindow.h
+++ b/libgui/graphics/FigureWindow.h
@@ -25,24 +25,25 @@ along with Octave; see the file COPYING.
 
 #include <QMainWindow>
 
 #include "GenericEventNotify.h"
 
 namespace QtHandles
 {
 
-DECLARE_GENERICEVENTNOTIFY_SENDER(FigureWindowBase, QMainWindow);
+  DECLARE_GENERICEVENTNOTIFY_SENDER(FigureWindowBase, QMainWindow);
 
-class FigureWindow : public FigureWindowBase
-{
-  Q_OBJECT
+  class FigureWindow : public FigureWindowBase
+  {
+    Q_OBJECT
 
-public:
-  FigureWindow (QWidget* parent = 0);
-  ~FigureWindow (void);
+  public:
+    FigureWindow (QWidget* parent = 0);
+    ~FigureWindow (void);
 
-  QMenu* createPopupMenu (void);
-};
+    QMenu* createPopupMenu (void);
+  };
 
 }; // namespace QtHandles
 
 #endif
+
diff --git a/libgui/graphics/GLCanvas.cc b/libgui/graphics/GLCanvas.cc
--- a/libgui/graphics/GLCanvas.cc
+++ b/libgui/graphics/GLCanvas.cc
@@ -28,164 +28,165 @@ along with Octave; see the file COPYING.
 #include "graphics.h"
 
 #include "GLCanvas.h"
 #include "gl-select.h"
 
 namespace QtHandles
 {
 
-GLCanvas::GLCanvas (QWidget* xparent, const graphics_handle& gh)
+  GLCanvas::GLCanvas (QWidget* xparent, const graphics_handle& gh)
 #if defined (Q_OS_WIN32)
-  : QGLWidget (QGLFormat (QGL::SampleBuffers | QGL::IndirectRendering),
-               xparent), Canvas (gh)
+    : QGLWidget (QGLFormat (QGL::SampleBuffers | QGL::IndirectRendering),
+                 xparent), Canvas (gh)
 #else
-  : QGLWidget (QGLFormat (QGL::SampleBuffers), xparent), Canvas (gh)
+    : QGLWidget (QGLFormat (QGL::SampleBuffers), xparent), Canvas (gh)
 #endif
-{
-  setFocusPolicy (Qt::ClickFocus);
-  setFocus();
-}
+  {
+    setFocusPolicy (Qt::ClickFocus);
+    setFocus();
+  }
 
-GLCanvas::~GLCanvas (void)
-{
-}
+  GLCanvas::~GLCanvas (void)
+  {
+  }
 
-void
-GLCanvas::draw (const graphics_handle& gh)
-{
-  gh_manager::auto_lock lock;
-  graphics_object go = gh_manager::get_object (gh);
+  void
+  GLCanvas::draw (const graphics_handle& gh)
+  {
+    gh_manager::auto_lock lock;
+    graphics_object go = gh_manager::get_object (gh);
 
-  if (go)
-    {
-      octave::opengl_renderer r;
+    if (go)
+      {
+        octave::opengl_renderer r;
 
-      r.set_viewport (width (), height ());
-      r.draw(go);
-    }
-}
+        r.set_viewport (width (), height ());
+        r.draw(go);
+      }
+  }
 
-void
-GLCanvas::toggleAxes (const graphics_handle& gh)
-{
-  canvasToggleAxes (gh);
-}
+  void
+  GLCanvas::toggleAxes (const graphics_handle& gh)
+  {
+    canvasToggleAxes (gh);
+  }
 
-void
-GLCanvas::toggleGrid (const graphics_handle& gh)
-{
-  canvasToggleGrid (gh);
-}
+  void
+  GLCanvas::toggleGrid (const graphics_handle& gh)
+  {
+    canvasToggleGrid (gh);
+  }
 
-void
-GLCanvas::autoAxes (const graphics_handle& gh)
-{
-  canvasAutoAxes (gh);
-}
+  void
+  GLCanvas::autoAxes (const graphics_handle& gh)
+  {
+    canvasAutoAxes (gh);
+  }
 
-graphics_object
-GLCanvas::selectFromAxes (const graphics_object& ax, const QPoint& pt)
-{
-  makeCurrent ();
+  graphics_object
+  GLCanvas::selectFromAxes (const graphics_object& ax, const QPoint& pt)
+  {
+    makeCurrent ();
 
-  if (ax)
-    {
-      octave::opengl_selector s;
+    if (ax)
+      {
+        octave::opengl_selector s;
 
-      s.set_viewport (width (), height ());
-      return s.select (ax, pt.x (), height () - pt.y ());
-    }
+        s.set_viewport (width (), height ());
+        return s.select (ax, pt.x (), height () - pt.y ());
+      }
 
-  return graphics_object ();
-}
+    return graphics_object ();
+  }
 
-inline void
-glDrawZoomBox (const QPoint& p1, const QPoint& p2)
-{
-  glVertex2d (p1.x (), p1.y ());
-  glVertex2d (p2.x (), p1.y ());
-  glVertex2d (p2.x (), p2.y ());
-  glVertex2d (p1.x (), p2.y ());
-  glVertex2d (p1.x (), p1.y ());
-}
+  inline void
+  glDrawZoomBox (const QPoint& p1, const QPoint& p2)
+  {
+    glVertex2d (p1.x (), p1.y ());
+    glVertex2d (p2.x (), p1.y ());
+    glVertex2d (p2.x (), p2.y ());
+    glVertex2d (p1.x (), p2.y ());
+    glVertex2d (p1.x (), p1.y ());
+  }
 
-void
-GLCanvas::drawZoomBox (const QPoint& p1, const QPoint& p2)
-{
-  glPushMatrix ();
+  void
+  GLCanvas::drawZoomBox (const QPoint& p1, const QPoint& p2)
+  {
+    glPushMatrix ();
 
-  glMatrixMode (GL_MODELVIEW);
-  glLoadIdentity ();
+    glMatrixMode (GL_MODELVIEW);
+    glLoadIdentity ();
 
-  glMatrixMode (GL_PROJECTION);
-  glLoadIdentity ();
-  glOrtho (0, width (), height (), 0, 1, -1);
+    glMatrixMode (GL_PROJECTION);
+    glLoadIdentity ();
+    glOrtho (0, width (), height (), 0, 1, -1);
 
-  glPushAttrib (GL_DEPTH_BUFFER_BIT | GL_CURRENT_BIT);
-  glDisable (GL_DEPTH_TEST);
+    glPushAttrib (GL_DEPTH_BUFFER_BIT | GL_CURRENT_BIT);
+    glDisable (GL_DEPTH_TEST);
 
-  glBegin (GL_POLYGON);
-  glColor4f (0.45, 0.62, 0.81, 0.1);
-  glDrawZoomBox (p1, p2);
-  glEnd ();
+    glBegin (GL_POLYGON);
+    glColor4f (0.45, 0.62, 0.81, 0.1);
+    glDrawZoomBox (p1, p2);
+    glEnd ();
 
-  glBegin (GL_LINE_STRIP);
-  glLineWidth (1.5);
-  glColor4f (0.45, 0.62, 0.81, 0.9);
-  glDrawZoomBox (p1, p2);
-  glEnd ();
+    glBegin (GL_LINE_STRIP);
+    glLineWidth (1.5);
+    glColor4f (0.45, 0.62, 0.81, 0.9);
+    glDrawZoomBox (p1, p2);
+    glEnd ();
 
-  glPopAttrib ();
-  glPopMatrix ();
-}
+    glPopAttrib ();
+    glPopMatrix ();
+  }
 
-void
-GLCanvas::paintGL (void)
-{
-  canvasPaintEvent ();
-}
+  void
+  GLCanvas::paintGL (void)
+  {
+    canvasPaintEvent ();
+  }
 
-void
-GLCanvas::mouseDoubleClickEvent (QMouseEvent* xevent)
-{
-  canvasMouseDoubleClickEvent (xevent);
-}
+  void
+  GLCanvas::mouseDoubleClickEvent (QMouseEvent* xevent)
+  {
+    canvasMouseDoubleClickEvent (xevent);
+  }
 
-void
-GLCanvas::mouseMoveEvent (QMouseEvent* xevent)
-{
-  canvasMouseMoveEvent (xevent);
-}
+  void
+  GLCanvas::mouseMoveEvent (QMouseEvent* xevent)
+  {
+    canvasMouseMoveEvent (xevent);
+  }
 
-void
-GLCanvas::mousePressEvent (QMouseEvent* xevent)
-{
-  canvasMousePressEvent (xevent);
-}
+  void
+  GLCanvas::mousePressEvent (QMouseEvent* xevent)
+  {
+    canvasMousePressEvent (xevent);
+  }
 
-void
-GLCanvas::mouseReleaseEvent (QMouseEvent* xevent)
-{
-  canvasMouseReleaseEvent (xevent);
-}
+  void
+  GLCanvas::mouseReleaseEvent (QMouseEvent* xevent)
+  {
+    canvasMouseReleaseEvent (xevent);
+  }
 
-void
-GLCanvas::wheelEvent (QWheelEvent* xevent)
-{
-  canvasWheelEvent (xevent);
-}
+  void
+  GLCanvas::wheelEvent (QWheelEvent* xevent)
+  {
+    canvasWheelEvent (xevent);
+  }
 
-void
-GLCanvas::keyPressEvent (QKeyEvent* xevent)
-{
-  if (! canvasKeyPressEvent (xevent))
-    QGLWidget::keyPressEvent (xevent);
-}
+  void
+  GLCanvas::keyPressEvent (QKeyEvent* xevent)
+  {
+    if (! canvasKeyPressEvent (xevent))
+      QGLWidget::keyPressEvent (xevent);
+  }
 
-void
-GLCanvas::keyReleaseEvent (QKeyEvent* xevent)
-{
-  if (! canvasKeyReleaseEvent (xevent))
-    QGLWidget::keyReleaseEvent (xevent);
-}
+  void
+  GLCanvas::keyReleaseEvent (QKeyEvent* xevent)
+  {
+    if (! canvasKeyReleaseEvent (xevent))
+      QGLWidget::keyReleaseEvent (xevent);
+  }
 
 }; // namespace QtHandles
+
diff --git a/libgui/graphics/GLCanvas.h b/libgui/graphics/GLCanvas.h
--- a/libgui/graphics/GLCanvas.h
+++ b/libgui/graphics/GLCanvas.h
@@ -25,39 +25,40 @@ along with Octave; see the file COPYING.
 
 #include <QGLWidget>
 
 #include "Canvas.h"
 
 namespace QtHandles
 {
 
-class GLCanvas : public QGLWidget, public Canvas
-{
-public:
-  GLCanvas (QWidget* parent, const graphics_handle& handle);
-  ~GLCanvas (void);
+  class GLCanvas : public QGLWidget, public Canvas
+  {
+  public:
+    GLCanvas (QWidget* parent, const graphics_handle& handle);
+    ~GLCanvas (void);
 
-  void draw (const graphics_handle& handle);
-  void toggleAxes (const graphics_handle& handle);
-  void toggleGrid (const graphics_handle& handle);
-  void autoAxes (const graphics_handle& handle);
-  void drawZoomBox (const QPoint& p1, const QPoint& p2);
-  void resize (int /* x */, int /* y */,
-               int /* width */, int /* height */) { }
-  graphics_object selectFromAxes (const graphics_object& ax,
-                                  const QPoint& pt);
-  QWidget* qWidget (void) { return this; }
+    void draw (const graphics_handle& handle);
+    void toggleAxes (const graphics_handle& handle);
+    void toggleGrid (const graphics_handle& handle);
+    void autoAxes (const graphics_handle& handle);
+    void drawZoomBox (const QPoint& p1, const QPoint& p2);
+    void resize (int /* x */, int /* y */,
+                 int /* width */, int /* height */) { }
+    graphics_object selectFromAxes (const graphics_object& ax,
+                                    const QPoint& pt);
+    QWidget* qWidget (void) { return this; }
 
-protected:
-  void paintGL (void);
-  void mouseDoubleClickEvent (QMouseEvent* event);
-  void mouseMoveEvent (QMouseEvent* event);
-  void mousePressEvent (QMouseEvent* event);
-  void mouseReleaseEvent (QMouseEvent* event);
-  void wheelEvent (QWheelEvent* event);
-  void keyPressEvent (QKeyEvent* event);
-  void keyReleaseEvent (QKeyEvent* event);
-};
+  protected:
+    void paintGL (void);
+    void mouseDoubleClickEvent (QMouseEvent* event);
+    void mouseMoveEvent (QMouseEvent* event);
+    void mousePressEvent (QMouseEvent* event);
+    void mouseReleaseEvent (QMouseEvent* event);
+    void wheelEvent (QWheelEvent* event);
+    void keyPressEvent (QKeyEvent* event);
+    void keyReleaseEvent (QKeyEvent* event);
+  };
 
 }; // namespace QtHandles
 
 #endif
+
diff --git a/libgui/graphics/GenericEventNotify.h b/libgui/graphics/GenericEventNotify.h
--- a/libgui/graphics/GenericEventNotify.h
+++ b/libgui/graphics/GenericEventNotify.h
@@ -27,65 +27,65 @@ along with Octave; see the file COPYING.
 
 class QEvent;
 class QObject;
 class QWidget;
 
 namespace QtHandles
 {
 
-class GenericEventNotifyReceiver;
+  class GenericEventNotifyReceiver;
 
-class GenericEventNotifySender
-{
-public:
-  GenericEventNotifySender (void) : m_receivers () { }
-  virtual ~GenericEventNotifySender (void) { }
+  class GenericEventNotifySender
+  {
+  public:
+    GenericEventNotifySender (void) : m_receivers () { }
+    virtual ~GenericEventNotifySender (void) { }
 
-  void addReceiver (GenericEventNotifyReceiver* r)
+    void addReceiver (GenericEventNotifyReceiver* r)
     { m_receivers.insert (r); }
 
-  void removeReceiver (GenericEventNotifyReceiver* r)
+    void removeReceiver (GenericEventNotifyReceiver* r)
     { m_receivers.remove (r); }
 
-protected:
-  bool notifyReceiversBefore (QObject* obj, QEvent* evt);
-  void notifyReceiversAfter (QObject* obj, QEvent* evt);
+  protected:
+    bool notifyReceiversBefore (QObject* obj, QEvent* evt);
+    void notifyReceiversAfter (QObject* obj, QEvent* evt);
 
-private:
-  QSet<GenericEventNotifyReceiver*> m_receivers;
-};
+  private:
+    QSet<GenericEventNotifyReceiver*> m_receivers;
+  };
 
-class GenericEventNotifyReceiver
-{
-public:
-  GenericEventNotifyReceiver (void) { }
-  virtual ~GenericEventNotifyReceiver (void) { }
+  class GenericEventNotifyReceiver
+  {
+  public:
+    GenericEventNotifyReceiver (void) { }
+    virtual ~GenericEventNotifyReceiver (void) { }
 
-  virtual bool eventNotifyBefore (QObject* obj, QEvent* evt) = 0;
-  virtual void eventNotifyAfter (QObject* obj, QEvent* evt) = 0;
-};
+    virtual bool eventNotifyBefore (QObject* obj, QEvent* evt) = 0;
+    virtual void eventNotifyAfter (QObject* obj, QEvent* evt) = 0;
+  };
 
-inline
-bool GenericEventNotifySender::notifyReceiversBefore (QObject* obj,
-                                                      QEvent* evt)
-{
-  foreach (GenericEventNotifyReceiver* r, m_receivers)
+  inline
+  bool GenericEventNotifySender::notifyReceiversBefore (QObject* obj,
+      QEvent* evt)
+  {
+    foreach (GenericEventNotifyReceiver* r, m_receivers)
     if (r->eventNotifyBefore (obj, evt))
       return true;
-  return false;
-}
+    return false;
+  }
 
-inline
-void GenericEventNotifySender::notifyReceiversAfter (QObject* obj,
-                                                     QEvent* evt)
-{
-  foreach (GenericEventNotifyReceiver* r, m_receivers)
+  inline
+  void GenericEventNotifySender::notifyReceiversAfter (QObject* obj,
+      QEvent* evt)
+  {
+    foreach (GenericEventNotifyReceiver* r, m_receivers)
     r->eventNotifyAfter (obj, evt);
-}
+  }
 
 #define DECLARE_GENERICEVENTNOTIFY_SENDER(T,B) \
 class T : public B, public GenericEventNotifySender \
 { \
 public: \
   T (QWidget* xparent) : B (xparent), GenericEventNotifySender () { } \
   ~ T (void) { } \
 \
@@ -97,8 +97,9 @@ public: \
       notifyReceiversAfter (this, evt); \
       return result; \
     } \
 }
 
 };
 
 #endif
+
diff --git a/libgui/graphics/KeyMap.cc b/libgui/graphics/KeyMap.cc
--- a/libgui/graphics/KeyMap.cc
+++ b/libgui/graphics/KeyMap.cc
@@ -27,233 +27,234 @@ along with Octave; see the file COPYING.
 #include <QMap>
 #include <Qt>
 
 #include "KeyMap.h"
 
 namespace QtHandles
 {
 
-namespace KeyMap
-{
+  namespace KeyMap
+  {
 
-std::string
-qKeyToKeyString (int key)
-{
-  static QMap<int, std::string> keyMapper;
-
-  if (keyMapper.isEmpty ())
+    std::string
+    qKeyToKeyString (int key)
     {
-      keyMapper[Qt::Key_Escape] = "escape";
-      keyMapper[Qt::Key_Tab] = "tab";
-      keyMapper[Qt::Key_Backtab] = "backtab";
-      keyMapper[Qt::Key_Backspace] = "backspace";
-      keyMapper[Qt::Key_Return] = "return";
-      keyMapper[Qt::Key_Enter] = "enter";
-      keyMapper[Qt::Key_Insert] = "insert";
-      keyMapper[Qt::Key_Delete] = "delete";
-      keyMapper[Qt::Key_Pause] = "pause";
-      keyMapper[Qt::Key_Print] = "print";
-      keyMapper[Qt::Key_SysReq] = "sysreq";
-      keyMapper[Qt::Key_Clear] = "clear";
-      keyMapper[Qt::Key_Home] = "home";
-      keyMapper[Qt::Key_End] = "end";
-      keyMapper[Qt::Key_Left] = "left";
-      keyMapper[Qt::Key_Up] = "up";
-      keyMapper[Qt::Key_Right] = "right";
-      keyMapper[Qt::Key_Down] = "down";
-      keyMapper[Qt::Key_PageUp] = "pageup";
-      keyMapper[Qt::Key_PageDown] = "pagedown";
-      keyMapper[Qt::Key_Shift] = "shift";
-      keyMapper[Qt::Key_Control] = "control";
-      keyMapper[Qt::Key_Meta] = "meta";
-      keyMapper[Qt::Key_Alt] = "alt";
-      keyMapper[Qt::Key_CapsLock] = "capslock";
-      keyMapper[Qt::Key_NumLock] = "numlock";
-      keyMapper[Qt::Key_ScrollLock] = "scrolllock";
-      keyMapper[Qt::Key_F1] = "f1";
-      keyMapper[Qt::Key_F2] = "f2";
-      keyMapper[Qt::Key_F3] = "f3";
-      keyMapper[Qt::Key_F4] = "f4";
-      keyMapper[Qt::Key_F5] = "f5";
-      keyMapper[Qt::Key_F6] = "f6";
-      keyMapper[Qt::Key_F7] = "f7";
-      keyMapper[Qt::Key_F8] = "f8";
-      keyMapper[Qt::Key_F9] = "f9";
-      keyMapper[Qt::Key_F10] = "f10";
-      keyMapper[Qt::Key_F11] = "f11";
-      keyMapper[Qt::Key_F12] = "f12";
-      keyMapper[Qt::Key_F13] = "f13";
-      keyMapper[Qt::Key_F14] = "f14";
-      keyMapper[Qt::Key_F15] = "f15";
-      keyMapper[Qt::Key_F16] = "f16";
-      keyMapper[Qt::Key_F17] = "f17";
-      keyMapper[Qt::Key_F18] = "f18";
-      keyMapper[Qt::Key_F19] = "f19";
-      keyMapper[Qt::Key_F20] = "f20";
-      keyMapper[Qt::Key_F21] = "f21";
-      keyMapper[Qt::Key_F22] = "f22";
-      keyMapper[Qt::Key_F23] = "f23";
-      keyMapper[Qt::Key_F24] = "f24";
-      keyMapper[Qt::Key_F25] = "f25";
-      keyMapper[Qt::Key_F26] = "f26";
-      keyMapper[Qt::Key_F27] = "f27";
-      keyMapper[Qt::Key_F28] = "f28";
-      keyMapper[Qt::Key_F29] = "f29";
-      keyMapper[Qt::Key_F30] = "f30";
-      keyMapper[Qt::Key_F31] = "f31";
-      keyMapper[Qt::Key_F32] = "f32";
-      keyMapper[Qt::Key_F33] = "f33";
-      keyMapper[Qt::Key_F34] = "f34";
-      keyMapper[Qt::Key_F35] = "f35";
-      keyMapper[Qt::Key_Super_L] = "super_l";
-      keyMapper[Qt::Key_Super_R] = "super_r";
-      keyMapper[Qt::Key_Menu] = "menu";
-      keyMapper[Qt::Key_Hyper_L] = "hyper_l";
-      keyMapper[Qt::Key_Hyper_R] = "hyper_r";
-      keyMapper[Qt::Key_Help] = "help";
-      keyMapper[Qt::Key_Direction_L] = "direction_l";
-      keyMapper[Qt::Key_Direction_R] = "direction_r";
-      keyMapper[Qt::Key_Space] = "space";
-      keyMapper[Qt::Key_Any] = "any";
-      keyMapper[Qt::Key_Exclam] = "exclam";
-      keyMapper[Qt::Key_QuoteDbl] = "quotedbl";
-      keyMapper[Qt::Key_NumberSign] = "numbersign";
-      keyMapper[Qt::Key_Dollar] = "dollar";
-      keyMapper[Qt::Key_Percent] = "percent";
-      keyMapper[Qt::Key_Ampersand] = "ampersand";
-      keyMapper[Qt::Key_Apostrophe] = "apostrophe";
-      keyMapper[Qt::Key_ParenLeft] = "parenleft";
-      keyMapper[Qt::Key_ParenRight] = "parenright";
-      keyMapper[Qt::Key_Asterisk] = "asterisk";
-      keyMapper[Qt::Key_Plus] = "plus";
-      keyMapper[Qt::Key_Comma] = "comma";
-      keyMapper[Qt::Key_Minus] = "minus";
-      keyMapper[Qt::Key_Period] = "period";
-      keyMapper[Qt::Key_Slash] = "slash";
-      keyMapper[Qt::Key_0] = "0";
-      keyMapper[Qt::Key_1] = "1";
-      keyMapper[Qt::Key_2] = "2";
-      keyMapper[Qt::Key_3] = "3";
-      keyMapper[Qt::Key_4] = "4";
-      keyMapper[Qt::Key_5] = "5";
-      keyMapper[Qt::Key_6] = "6";
-      keyMapper[Qt::Key_7] = "7";
-      keyMapper[Qt::Key_8] = "8";
-      keyMapper[Qt::Key_9] = "9";
-      keyMapper[Qt::Key_Colon] = "colon";
-      keyMapper[Qt::Key_Semicolon] = "semicolon";
-      keyMapper[Qt::Key_Less] = "less";
-      keyMapper[Qt::Key_Equal] = "equal";
-      keyMapper[Qt::Key_Greater] = "greater";
-      keyMapper[Qt::Key_Question] = "question";
-      keyMapper[Qt::Key_At] = "at";
-      keyMapper[Qt::Key_A] = "a";
-      keyMapper[Qt::Key_B] = "b";
-      keyMapper[Qt::Key_C] = "c";
-      keyMapper[Qt::Key_D] = "d";
-      keyMapper[Qt::Key_E] = "e";
-      keyMapper[Qt::Key_F] = "f";
-      keyMapper[Qt::Key_G] = "g";
-      keyMapper[Qt::Key_H] = "h";
-      keyMapper[Qt::Key_I] = "i";
-      keyMapper[Qt::Key_J] = "j";
-      keyMapper[Qt::Key_K] = "k";
-      keyMapper[Qt::Key_L] = "l";
-      keyMapper[Qt::Key_M] = "m";
-      keyMapper[Qt::Key_N] = "n";
-      keyMapper[Qt::Key_O] = "o";
-      keyMapper[Qt::Key_P] = "p";
-      keyMapper[Qt::Key_Q] = "q";
-      keyMapper[Qt::Key_R] = "r";
-      keyMapper[Qt::Key_S] = "s";
-      keyMapper[Qt::Key_T] = "t";
-      keyMapper[Qt::Key_U] = "u";
-      keyMapper[Qt::Key_V] = "v";
-      keyMapper[Qt::Key_W] = "w";
-      keyMapper[Qt::Key_X] = "x";
-      keyMapper[Qt::Key_Y] = "y";
-      keyMapper[Qt::Key_Z] = "z";
-      keyMapper[Qt::Key_BracketLeft] = "bracketleft";
-      keyMapper[Qt::Key_Backslash] = "backslash";
-      keyMapper[Qt::Key_BracketRight] = "bracketright";
-      keyMapper[Qt::Key_AsciiCircum] = "asciicircum";
-      keyMapper[Qt::Key_Underscore] = "underscore";
-      keyMapper[Qt::Key_QuoteLeft] = "quoteleft";
-      keyMapper[Qt::Key_BraceLeft] = "braceleft";
-      keyMapper[Qt::Key_Bar] = "bar";
-      keyMapper[Qt::Key_BraceRight] = "braceright";
-      keyMapper[Qt::Key_AsciiTilde] = "asciitilde";
+      static QMap<int, std::string> keyMapper;
 
-      keyMapper[Qt::Key_nobreakspace] = "nobreakspace";
-      keyMapper[Qt::Key_exclamdown] = "exclamdown";
-      keyMapper[Qt::Key_cent] = "cent";
-      keyMapper[Qt::Key_sterling] = "sterling";
-      keyMapper[Qt::Key_currency] = "currency";
-      keyMapper[Qt::Key_yen] = "yen";
-      keyMapper[Qt::Key_brokenbar] = "brokenbar";
-      keyMapper[Qt::Key_section] = "section";
-      keyMapper[Qt::Key_diaeresis] = "diaeresis";
-      keyMapper[Qt::Key_copyright] = "copyright";
-      keyMapper[Qt::Key_ordfeminine] = "ordfeminine";
-      keyMapper[Qt::Key_guillemotleft] = "guillemotleft";
-      keyMapper[Qt::Key_notsign] = "notsign";
-      keyMapper[Qt::Key_hyphen] = "hyphen";
-      keyMapper[Qt::Key_registered] = "registered";
-      keyMapper[Qt::Key_macron] = "macron";
-      keyMapper[Qt::Key_degree] = "degree";
-      keyMapper[Qt::Key_plusminus] = "plusminus";
-      keyMapper[Qt::Key_twosuperior] = "twosuperior";
-      keyMapper[Qt::Key_threesuperior] = "threesuperior";
-      keyMapper[Qt::Key_acute] = "acute";
-      keyMapper[Qt::Key_mu] = "mu";
-      keyMapper[Qt::Key_paragraph] = "paragraph";
-      keyMapper[Qt::Key_periodcentered] = "periodcentered";
-      keyMapper[Qt::Key_cedilla] = "cedilla";
-      keyMapper[Qt::Key_onesuperior] = "onesuperior";
-      keyMapper[Qt::Key_masculine] = "masculine";
-      keyMapper[Qt::Key_guillemotright] = "guillemotright";
-      keyMapper[Qt::Key_onequarter] = "onequarter";
-      keyMapper[Qt::Key_onehalf] = "onehalf";
-      keyMapper[Qt::Key_threequarters] = "threequarters";
-      keyMapper[Qt::Key_questiondown] = "questiondown";
-      keyMapper[Qt::Key_Agrave] = "agrave";
-      keyMapper[Qt::Key_Aacute] = "aacute";
-      keyMapper[Qt::Key_Acircumflex] = "acircumflex";
-      keyMapper[Qt::Key_Atilde] = "atilde";
-      keyMapper[Qt::Key_Adiaeresis] = "adiaeresis";
-      keyMapper[Qt::Key_Aring] = "aring";
-      keyMapper[Qt::Key_AE] = "ae";
-      keyMapper[Qt::Key_Ccedilla] = "ccedilla";
-      keyMapper[Qt::Key_Egrave] = "egrave";
-      keyMapper[Qt::Key_Eacute] = "eacute";
-      keyMapper[Qt::Key_Ecircumflex] = "ecircumflex";
-      keyMapper[Qt::Key_Ediaeresis] = "ediaeresis";
-      keyMapper[Qt::Key_Igrave] = "igrave";
-      keyMapper[Qt::Key_Iacute] = "iacute";
-      keyMapper[Qt::Key_Icircumflex] = "icircumflex";
-      keyMapper[Qt::Key_Idiaeresis] = "idiaeresis";
-      keyMapper[Qt::Key_ETH] = "eth";
-      keyMapper[Qt::Key_Ntilde] = "ntilde";
-      keyMapper[Qt::Key_Ograve] = "ograve";
-      keyMapper[Qt::Key_Oacute] = "oacute";
-      keyMapper[Qt::Key_Ocircumflex] = "ocircumflex";
-      keyMapper[Qt::Key_Otilde] = "otilde";
-      keyMapper[Qt::Key_Odiaeresis] = "odiaeresis";
-      keyMapper[Qt::Key_multiply] = "multiply";
-      keyMapper[Qt::Key_Ooblique] = "ooblique";
-      keyMapper[Qt::Key_Ugrave] = "ugrave";
-      keyMapper[Qt::Key_Uacute] = "uacute";
-      keyMapper[Qt::Key_Ucircumflex] = "ucircumflex";
-      keyMapper[Qt::Key_Udiaeresis] = "udiaeresis";
-      keyMapper[Qt::Key_Yacute] = "yacute";
-      keyMapper[Qt::Key_THORN] = "thorn";
-      keyMapper[Qt::Key_ssharp] = "ssharp";
-      keyMapper[Qt::Key_division] = "division";
-      keyMapper[Qt::Key_ydiaeresis] = "ydiaeresis";
+      if (keyMapper.isEmpty ())
+        {
+          keyMapper[Qt::Key_Escape] = "escape";
+          keyMapper[Qt::Key_Tab] = "tab";
+          keyMapper[Qt::Key_Backtab] = "backtab";
+          keyMapper[Qt::Key_Backspace] = "backspace";
+          keyMapper[Qt::Key_Return] = "return";
+          keyMapper[Qt::Key_Enter] = "enter";
+          keyMapper[Qt::Key_Insert] = "insert";
+          keyMapper[Qt::Key_Delete] = "delete";
+          keyMapper[Qt::Key_Pause] = "pause";
+          keyMapper[Qt::Key_Print] = "print";
+          keyMapper[Qt::Key_SysReq] = "sysreq";
+          keyMapper[Qt::Key_Clear] = "clear";
+          keyMapper[Qt::Key_Home] = "home";
+          keyMapper[Qt::Key_End] = "end";
+          keyMapper[Qt::Key_Left] = "left";
+          keyMapper[Qt::Key_Up] = "up";
+          keyMapper[Qt::Key_Right] = "right";
+          keyMapper[Qt::Key_Down] = "down";
+          keyMapper[Qt::Key_PageUp] = "pageup";
+          keyMapper[Qt::Key_PageDown] = "pagedown";
+          keyMapper[Qt::Key_Shift] = "shift";
+          keyMapper[Qt::Key_Control] = "control";
+          keyMapper[Qt::Key_Meta] = "meta";
+          keyMapper[Qt::Key_Alt] = "alt";
+          keyMapper[Qt::Key_CapsLock] = "capslock";
+          keyMapper[Qt::Key_NumLock] = "numlock";
+          keyMapper[Qt::Key_ScrollLock] = "scrolllock";
+          keyMapper[Qt::Key_F1] = "f1";
+          keyMapper[Qt::Key_F2] = "f2";
+          keyMapper[Qt::Key_F3] = "f3";
+          keyMapper[Qt::Key_F4] = "f4";
+          keyMapper[Qt::Key_F5] = "f5";
+          keyMapper[Qt::Key_F6] = "f6";
+          keyMapper[Qt::Key_F7] = "f7";
+          keyMapper[Qt::Key_F8] = "f8";
+          keyMapper[Qt::Key_F9] = "f9";
+          keyMapper[Qt::Key_F10] = "f10";
+          keyMapper[Qt::Key_F11] = "f11";
+          keyMapper[Qt::Key_F12] = "f12";
+          keyMapper[Qt::Key_F13] = "f13";
+          keyMapper[Qt::Key_F14] = "f14";
+          keyMapper[Qt::Key_F15] = "f15";
+          keyMapper[Qt::Key_F16] = "f16";
+          keyMapper[Qt::Key_F17] = "f17";
+          keyMapper[Qt::Key_F18] = "f18";
+          keyMapper[Qt::Key_F19] = "f19";
+          keyMapper[Qt::Key_F20] = "f20";
+          keyMapper[Qt::Key_F21] = "f21";
+          keyMapper[Qt::Key_F22] = "f22";
+          keyMapper[Qt::Key_F23] = "f23";
+          keyMapper[Qt::Key_F24] = "f24";
+          keyMapper[Qt::Key_F25] = "f25";
+          keyMapper[Qt::Key_F26] = "f26";
+          keyMapper[Qt::Key_F27] = "f27";
+          keyMapper[Qt::Key_F28] = "f28";
+          keyMapper[Qt::Key_F29] = "f29";
+          keyMapper[Qt::Key_F30] = "f30";
+          keyMapper[Qt::Key_F31] = "f31";
+          keyMapper[Qt::Key_F32] = "f32";
+          keyMapper[Qt::Key_F33] = "f33";
+          keyMapper[Qt::Key_F34] = "f34";
+          keyMapper[Qt::Key_F35] = "f35";
+          keyMapper[Qt::Key_Super_L] = "super_l";
+          keyMapper[Qt::Key_Super_R] = "super_r";
+          keyMapper[Qt::Key_Menu] = "menu";
+          keyMapper[Qt::Key_Hyper_L] = "hyper_l";
+          keyMapper[Qt::Key_Hyper_R] = "hyper_r";
+          keyMapper[Qt::Key_Help] = "help";
+          keyMapper[Qt::Key_Direction_L] = "direction_l";
+          keyMapper[Qt::Key_Direction_R] = "direction_r";
+          keyMapper[Qt::Key_Space] = "space";
+          keyMapper[Qt::Key_Any] = "any";
+          keyMapper[Qt::Key_Exclam] = "exclam";
+          keyMapper[Qt::Key_QuoteDbl] = "quotedbl";
+          keyMapper[Qt::Key_NumberSign] = "numbersign";
+          keyMapper[Qt::Key_Dollar] = "dollar";
+          keyMapper[Qt::Key_Percent] = "percent";
+          keyMapper[Qt::Key_Ampersand] = "ampersand";
+          keyMapper[Qt::Key_Apostrophe] = "apostrophe";
+          keyMapper[Qt::Key_ParenLeft] = "parenleft";
+          keyMapper[Qt::Key_ParenRight] = "parenright";
+          keyMapper[Qt::Key_Asterisk] = "asterisk";
+          keyMapper[Qt::Key_Plus] = "plus";
+          keyMapper[Qt::Key_Comma] = "comma";
+          keyMapper[Qt::Key_Minus] = "minus";
+          keyMapper[Qt::Key_Period] = "period";
+          keyMapper[Qt::Key_Slash] = "slash";
+          keyMapper[Qt::Key_0] = "0";
+          keyMapper[Qt::Key_1] = "1";
+          keyMapper[Qt::Key_2] = "2";
+          keyMapper[Qt::Key_3] = "3";
+          keyMapper[Qt::Key_4] = "4";
+          keyMapper[Qt::Key_5] = "5";
+          keyMapper[Qt::Key_6] = "6";
+          keyMapper[Qt::Key_7] = "7";
+          keyMapper[Qt::Key_8] = "8";
+          keyMapper[Qt::Key_9] = "9";
+          keyMapper[Qt::Key_Colon] = "colon";
+          keyMapper[Qt::Key_Semicolon] = "semicolon";
+          keyMapper[Qt::Key_Less] = "less";
+          keyMapper[Qt::Key_Equal] = "equal";
+          keyMapper[Qt::Key_Greater] = "greater";
+          keyMapper[Qt::Key_Question] = "question";
+          keyMapper[Qt::Key_At] = "at";
+          keyMapper[Qt::Key_A] = "a";
+          keyMapper[Qt::Key_B] = "b";
+          keyMapper[Qt::Key_C] = "c";
+          keyMapper[Qt::Key_D] = "d";
+          keyMapper[Qt::Key_E] = "e";
+          keyMapper[Qt::Key_F] = "f";
+          keyMapper[Qt::Key_G] = "g";
+          keyMapper[Qt::Key_H] = "h";
+          keyMapper[Qt::Key_I] = "i";
+          keyMapper[Qt::Key_J] = "j";
+          keyMapper[Qt::Key_K] = "k";
+          keyMapper[Qt::Key_L] = "l";
+          keyMapper[Qt::Key_M] = "m";
+          keyMapper[Qt::Key_N] = "n";
+          keyMapper[Qt::Key_O] = "o";
+          keyMapper[Qt::Key_P] = "p";
+          keyMapper[Qt::Key_Q] = "q";
+          keyMapper[Qt::Key_R] = "r";
+          keyMapper[Qt::Key_S] = "s";
+          keyMapper[Qt::Key_T] = "t";
+          keyMapper[Qt::Key_U] = "u";
+          keyMapper[Qt::Key_V] = "v";
+          keyMapper[Qt::Key_W] = "w";
+          keyMapper[Qt::Key_X] = "x";
+          keyMapper[Qt::Key_Y] = "y";
+          keyMapper[Qt::Key_Z] = "z";
+          keyMapper[Qt::Key_BracketLeft] = "bracketleft";
+          keyMapper[Qt::Key_Backslash] = "backslash";
+          keyMapper[Qt::Key_BracketRight] = "bracketright";
+          keyMapper[Qt::Key_AsciiCircum] = "asciicircum";
+          keyMapper[Qt::Key_Underscore] = "underscore";
+          keyMapper[Qt::Key_QuoteLeft] = "quoteleft";
+          keyMapper[Qt::Key_BraceLeft] = "braceleft";
+          keyMapper[Qt::Key_Bar] = "bar";
+          keyMapper[Qt::Key_BraceRight] = "braceright";
+          keyMapper[Qt::Key_AsciiTilde] = "asciitilde";
+
+          keyMapper[Qt::Key_nobreakspace] = "nobreakspace";
+          keyMapper[Qt::Key_exclamdown] = "exclamdown";
+          keyMapper[Qt::Key_cent] = "cent";
+          keyMapper[Qt::Key_sterling] = "sterling";
+          keyMapper[Qt::Key_currency] = "currency";
+          keyMapper[Qt::Key_yen] = "yen";
+          keyMapper[Qt::Key_brokenbar] = "brokenbar";
+          keyMapper[Qt::Key_section] = "section";
+          keyMapper[Qt::Key_diaeresis] = "diaeresis";
+          keyMapper[Qt::Key_copyright] = "copyright";
+          keyMapper[Qt::Key_ordfeminine] = "ordfeminine";
+          keyMapper[Qt::Key_guillemotleft] = "guillemotleft";
+          keyMapper[Qt::Key_notsign] = "notsign";
+          keyMapper[Qt::Key_hyphen] = "hyphen";
+          keyMapper[Qt::Key_registered] = "registered";
+          keyMapper[Qt::Key_macron] = "macron";
+          keyMapper[Qt::Key_degree] = "degree";
+          keyMapper[Qt::Key_plusminus] = "plusminus";
+          keyMapper[Qt::Key_twosuperior] = "twosuperior";
+          keyMapper[Qt::Key_threesuperior] = "threesuperior";
+          keyMapper[Qt::Key_acute] = "acute";
+          keyMapper[Qt::Key_mu] = "mu";
+          keyMapper[Qt::Key_paragraph] = "paragraph";
+          keyMapper[Qt::Key_periodcentered] = "periodcentered";
+          keyMapper[Qt::Key_cedilla] = "cedilla";
+          keyMapper[Qt::Key_onesuperior] = "onesuperior";
+          keyMapper[Qt::Key_masculine] = "masculine";
+          keyMapper[Qt::Key_guillemotright] = "guillemotright";
+          keyMapper[Qt::Key_onequarter] = "onequarter";
+          keyMapper[Qt::Key_onehalf] = "onehalf";
+          keyMapper[Qt::Key_threequarters] = "threequarters";
+          keyMapper[Qt::Key_questiondown] = "questiondown";
+          keyMapper[Qt::Key_Agrave] = "agrave";
+          keyMapper[Qt::Key_Aacute] = "aacute";
+          keyMapper[Qt::Key_Acircumflex] = "acircumflex";
+          keyMapper[Qt::Key_Atilde] = "atilde";
+          keyMapper[Qt::Key_Adiaeresis] = "adiaeresis";
+          keyMapper[Qt::Key_Aring] = "aring";
+          keyMapper[Qt::Key_AE] = "ae";
+          keyMapper[Qt::Key_Ccedilla] = "ccedilla";
+          keyMapper[Qt::Key_Egrave] = "egrave";
+          keyMapper[Qt::Key_Eacute] = "eacute";
+          keyMapper[Qt::Key_Ecircumflex] = "ecircumflex";
+          keyMapper[Qt::Key_Ediaeresis] = "ediaeresis";
+          keyMapper[Qt::Key_Igrave] = "igrave";
+          keyMapper[Qt::Key_Iacute] = "iacute";
+          keyMapper[Qt::Key_Icircumflex] = "icircumflex";
+          keyMapper[Qt::Key_Idiaeresis] = "idiaeresis";
+          keyMapper[Qt::Key_ETH] = "eth";
+          keyMapper[Qt::Key_Ntilde] = "ntilde";
+          keyMapper[Qt::Key_Ograve] = "ograve";
+          keyMapper[Qt::Key_Oacute] = "oacute";
+          keyMapper[Qt::Key_Ocircumflex] = "ocircumflex";
+          keyMapper[Qt::Key_Otilde] = "otilde";
+          keyMapper[Qt::Key_Odiaeresis] = "odiaeresis";
+          keyMapper[Qt::Key_multiply] = "multiply";
+          keyMapper[Qt::Key_Ooblique] = "ooblique";
+          keyMapper[Qt::Key_Ugrave] = "ugrave";
+          keyMapper[Qt::Key_Uacute] = "uacute";
+          keyMapper[Qt::Key_Ucircumflex] = "ucircumflex";
+          keyMapper[Qt::Key_Udiaeresis] = "udiaeresis";
+          keyMapper[Qt::Key_Yacute] = "yacute";
+          keyMapper[Qt::Key_THORN] = "thorn";
+          keyMapper[Qt::Key_ssharp] = "ssharp";
+          keyMapper[Qt::Key_division] = "division";
+          keyMapper[Qt::Key_ydiaeresis] = "ydiaeresis";
+        }
+
+      return keyMapper.value (key, std::string ("<unknown key>"));
     }
 
-  return keyMapper.value (key, std::string ("<unknown key>"));
-}
-
-}; //namespace KeyMap
+  }; //namespace KeyMap
 
 }; // namespace QtHandles
+
diff --git a/libgui/graphics/KeyMap.h b/libgui/graphics/KeyMap.h
--- a/libgui/graphics/KeyMap.h
+++ b/libgui/graphics/KeyMap.h
@@ -23,18 +23,19 @@ along with Octave; see the file COPYING.
 #if ! defined (octave_KeyMap_h)
 #define octave_KeyMap_h 1
 
 #include <string>
 
 namespace QtHandles
 {
 
-namespace KeyMap
-{
+  namespace KeyMap
+  {
 
-std::string qKeyToKeyString (int key);
+    std::string qKeyToKeyString (int key);
 
-}; // namespace KeyMap
+  }; // namespace KeyMap
 
 }; // namespace QtHandles
 
 #endif
+
diff --git a/libgui/graphics/ListBoxControl.cc b/libgui/graphics/ListBoxControl.cc
--- a/libgui/graphics/ListBoxControl.cc
+++ b/libgui/graphics/ListBoxControl.cc
@@ -28,152 +28,153 @@ along with Octave; see the file COPYING.
 
 #include "Container.h"
 #include "ListBoxControl.h"
 #include "QtHandlesUtils.h"
 
 namespace QtHandles
 {
 
-static void
-updateSelection (QListWidget* list, const Matrix& value)
-{
-  octave_idx_type n = value.numel ();
-  int lc = list->count ();
+  static void
+  updateSelection (QListWidget* list, const Matrix& value)
+  {
+    octave_idx_type n = value.numel ();
+    int lc = list->count ();
 
-  list->clearSelection ();
+    list->clearSelection ();
 
-  for (octave_idx_type i = 0; i < n; i++)
-    {
-      int idx = octave::math::round (value(i));
+    for (octave_idx_type i = 0; i < n; i++)
+      {
+        int idx = octave::math::round (value(i));
 
-      if (1 <= idx && idx <= lc)
-        {
-          list->item (idx-1)->setSelected (true);
-          list->scrollToItem (list->item (idx-1));
-          if (i == 0
-              && list->selectionMode () == QAbstractItemView::SingleSelection)
+        if (1 <= idx && idx <= lc)
+          {
+            list->item (idx-1)->setSelected (true);
+            list->scrollToItem (list->item (idx-1));
+            if (i == 0
+                && list->selectionMode () == QAbstractItemView::SingleSelection)
+              break;
+          }
+        else
+          {
+            // Invalid selection.
+            list->clearSelection ();
             break;
-        }
-      else
-        {
-          // Invalid selection.
-          list->clearSelection ();
-          break;
-        }
-    }
-}
+          }
+      }
+  }
 
-ListBoxControl*
-ListBoxControl::create (const graphics_object& go)
-{
-  Object* parent = Object::parentObject (go);
+  ListBoxControl*
+  ListBoxControl::create (const graphics_object& go)
+  {
+    Object* parent = Object::parentObject (go);
 
-  if (parent)
-    {
-      Container* container = parent->innerContainer ();
+    if (parent)
+      {
+        Container* container = parent->innerContainer ();
 
-      if (container)
-        return new ListBoxControl (go, new QListWidget (container));
-    }
+        if (container)
+          return new ListBoxControl (go, new QListWidget (container));
+      }
 
-  return 0;
-}
+    return 0;
+  }
 
-ListBoxControl::ListBoxControl (const graphics_object& go, QListWidget* list)
-  : BaseControl (go, list), m_blockCallback (false)
-{
-  uicontrol::properties& up = properties<uicontrol> ();
+  ListBoxControl::ListBoxControl (const graphics_object& go, QListWidget* list)
+    : BaseControl (go, list), m_blockCallback (false)
+  {
+    uicontrol::properties& up = properties<uicontrol> ();
 
-  list->addItems (Utils::fromStringVector (up.get_string_vector ()));
-  if ((up.get_max () - up.get_min ()) > 1)
-    list->setSelectionMode (QAbstractItemView::ExtendedSelection);
-  else
-    list->setSelectionMode (QAbstractItemView::SingleSelection);
-  Matrix value = up.get_value ().matrix_value ();
-  if (value.numel () > 0)
-    {
-      octave_idx_type n = value.numel ();
-      int lc = list->count ();
+    list->addItems (Utils::fromStringVector (up.get_string_vector ()));
+    if ((up.get_max () - up.get_min ()) > 1)
+      list->setSelectionMode (QAbstractItemView::ExtendedSelection);
+    else
+      list->setSelectionMode (QAbstractItemView::SingleSelection);
+    Matrix value = up.get_value ().matrix_value ();
+    if (value.numel () > 0)
+      {
+        octave_idx_type n = value.numel ();
+        int lc = list->count ();
 
-      for (octave_idx_type i = 0; i < n; i++)
-        {
-          int idx = octave::math::round (value(i));
+        for (octave_idx_type i = 0; i < n; i++)
+          {
+            int idx = octave::math::round (value(i));
 
-          if (1 <= idx && idx <= lc)
-            {
-              list->item (idx-1)->setSelected (true);
-              list->scrollToItem (list->item (idx-1));
-              if (i == 0 && (list->selectionMode ()
-                             == QAbstractItemView::SingleSelection))
-                break;
-            }
-        }
-    }
+            if (1 <= idx && idx <= lc)
+              {
+                list->item (idx-1)->setSelected (true);
+                list->scrollToItem (list->item (idx-1));
+                if (i == 0 && (list->selectionMode ()
+                               == QAbstractItemView::SingleSelection))
+                  break;
+              }
+          }
+      }
 
-  list->removeEventFilter (this);
-  list->viewport ()->installEventFilter (this);
+    list->removeEventFilter (this);
+    list->viewport ()->installEventFilter (this);
 
-  connect (list, SIGNAL (itemSelectionChanged (void)),
-           SLOT (itemSelectionChanged (void)));
-}
+    connect (list, SIGNAL (itemSelectionChanged (void)),
+             SLOT (itemSelectionChanged (void)));
+  }
 
-ListBoxControl::~ListBoxControl (void)
-{
-}
+  ListBoxControl::~ListBoxControl (void)
+  {
+  }
 
-void
-ListBoxControl::update (int pId)
-{
-  uicontrol::properties& up = properties<uicontrol> ();
-  QListWidget* list = qWidget<QListWidget> ();
+  void
+  ListBoxControl::update (int pId)
+  {
+    uicontrol::properties& up = properties<uicontrol> ();
+    QListWidget* list = qWidget<QListWidget> ();
 
-  switch (pId)
-    {
-    case uicontrol::properties::ID_STRING:
-      m_blockCallback = true;
-      list->clear ();
-      list->addItems (Utils::fromStringVector (up.get_string_vector ()));
-      updateSelection (list, up.get_value ().matrix_value ());
-      m_blockCallback = false;
-      break;
+    switch (pId)
+      {
+      case uicontrol::properties::ID_STRING:
+        m_blockCallback = true;
+        list->clear ();
+        list->addItems (Utils::fromStringVector (up.get_string_vector ()));
+        updateSelection (list, up.get_value ().matrix_value ());
+        m_blockCallback = false;
+        break;
 
-    case uicontrol::properties::ID_MIN:
+      case uicontrol::properties::ID_MIN:
 
-    case uicontrol::properties::ID_MAX:
-      if ((up.get_max () - up.get_min ()) > 1)
-        list->setSelectionMode (QAbstractItemView::ExtendedSelection);
-      else
-        list->setSelectionMode (QAbstractItemView::SingleSelection);
-      break;
+      case uicontrol::properties::ID_MAX:
+        if ((up.get_max () - up.get_min ()) > 1)
+          list->setSelectionMode (QAbstractItemView::ExtendedSelection);
+        else
+          list->setSelectionMode (QAbstractItemView::SingleSelection);
+        break;
 
-    case uicontrol::properties::ID_VALUE:
-      m_blockCallback = true;
-      updateSelection (list, up.get_value ().matrix_value ());
-      m_blockCallback = false;
-      break;
+      case uicontrol::properties::ID_VALUE:
+        m_blockCallback = true;
+        updateSelection (list, up.get_value ().matrix_value ());
+        m_blockCallback = false;
+        break;
 
-    default:
-      BaseControl::update (pId);
-      break;
-    }
-}
+      default:
+        BaseControl::update (pId);
+        break;
+      }
+  }
 
-void
-ListBoxControl::itemSelectionChanged (void)
-{
-  if (! m_blockCallback)
-    {
-      QListWidget* list = qWidget<QListWidget> ();
+  void
+  ListBoxControl::itemSelectionChanged (void)
+  {
+    if (! m_blockCallback)
+      {
+        QListWidget* list = qWidget<QListWidget> ();
 
-      QModelIndexList l = list->selectionModel ()->selectedIndexes ();
-      Matrix value (dim_vector (1, l.size ()));
-      int i = 0;
+        QModelIndexList l = list->selectionModel ()->selectedIndexes ();
+        Matrix value (dim_vector (1, l.size ()));
+        int i = 0;
 
-      foreach (const QModelIndex& idx, l)
-       value(i++) = (idx.row () + 1);
+        foreach (const QModelIndex& idx, l)
+        value(i++) = (idx.row () + 1);
 
-      gh_manager::post_set (m_handle, "value", octave_value (value), false);
-      gh_manager::post_callback (m_handle, "callback");
-    }
-}
+        gh_manager::post_set (m_handle, "value", octave_value (value), false);
+        gh_manager::post_callback (m_handle, "callback");
+      }
+  }
 
 }; // namespace QtHandles
+
diff --git a/libgui/graphics/ListBoxControl.h b/libgui/graphics/ListBoxControl.h
--- a/libgui/graphics/ListBoxControl.h
+++ b/libgui/graphics/ListBoxControl.h
@@ -25,31 +25,32 @@ along with Octave; see the file COPYING.
 
 #include "BaseControl.h"
 
 class QListWidget;
 
 namespace QtHandles
 {
 
-class ListBoxControl : public BaseControl
-{
-  Q_OBJECT
+  class ListBoxControl : public BaseControl
+  {
+    Q_OBJECT
 
-public:
-  ListBoxControl (const graphics_object& go, QListWidget* list);
-  ~ListBoxControl (void);
+  public:
+    ListBoxControl (const graphics_object& go, QListWidget* list);
+    ~ListBoxControl (void);
 
-  static ListBoxControl* create (const graphics_object& go);
+    static ListBoxControl* create (const graphics_object& go);
 
-protected:
-  void update (int pId);
+  protected:
+    void update (int pId);
 
-private slots:
-  void itemSelectionChanged (void);
+  private slots:
+    void itemSelectionChanged (void);
 
-private:
-  bool m_blockCallback;
-};
+  private:
+    bool m_blockCallback;
+  };
 
 }; // namespace QtHandles
 
 #endif
+
diff --git a/libgui/graphics/Logger.cc b/libgui/graphics/Logger.cc
--- a/libgui/graphics/Logger.cc
+++ b/libgui/graphics/Logger.cc
@@ -30,59 +30,60 @@ along with Octave; see the file COPYING.
 
 #include <cstdio>
 
 #include "Logger.h"
 
 namespace QtHandles
 {
 
-Logger* Logger::s_instance = 0;
-QMutex* Logger::s_mutex = 0;
+  Logger* Logger::s_instance = 0;
+  QMutex* Logger::s_mutex = 0;
 
-Logger::Logger (void)
-  : m_debugEnabled (false)
-{
-  QProcessEnvironment pe (QProcessEnvironment::systemEnvironment ());
+  Logger::Logger (void)
+    : m_debugEnabled (false)
+  {
+    QProcessEnvironment pe (QProcessEnvironment::systemEnvironment ());
 
-  if (pe.value ("QTHANDLES_DEBUG", "0") != "0")
-    m_debugEnabled = true;
-}
+    if (pe.value ("QTHANDLES_DEBUG", "0") != "0")
+      m_debugEnabled = true;
+  }
 
-Logger::~Logger (void)
-{
-}
+  Logger::~Logger (void)
+  {
+  }
 
-Logger*
-Logger::instance (void)
-{
-  if (! s_instance)
-    {
-      s_instance = new Logger ();
-      s_mutex = new QMutex ();
-    }
+  Logger*
+  Logger::instance (void)
+  {
+    if (! s_instance)
+      {
+        s_instance = new Logger ();
+        s_mutex = new QMutex ();
+      }
 
-  return s_instance;
-}
+    return s_instance;
+  }
 
 #define STATIC_LOGGER(fun) \
   void Logger::fun (const char* fmt, ...) \
   { \
     QMutexLocker lock (s_mutex); \
     va_list vl; \
     va_start (vl, fmt); \
     instance ()->fun ## V (fmt, vl); \
     va_end (vl); \
   }
 
-STATIC_LOGGER (debug)
+  STATIC_LOGGER (debug)
 
-void
-Logger::debugV (const char* fmt, va_list arg)
-{
-  if (m_debugEnabled)
-    {
-      vfprintf (stderr, fmt, arg);
-      fprintf (stderr, "\n");
-    }
-}
+  void
+  Logger::debugV (const char* fmt, va_list arg)
+  {
+    if (m_debugEnabled)
+      {
+        vfprintf (stderr, fmt, arg);
+        fprintf (stderr, "\n");
+      }
+  }
 
 }; // namespace QtHandles
+
diff --git a/libgui/graphics/Logger.h b/libgui/graphics/Logger.h
--- a/libgui/graphics/Logger.h
+++ b/libgui/graphics/Logger.h
@@ -25,31 +25,32 @@ along with Octave; see the file COPYING.
 
 #include <cstdarg>
 
 class QMutex;
 
 namespace QtHandles
 {
 
-class Logger
-{
-public:
-  static void debug (const char* fmt, ...);
+  class Logger
+  {
+  public:
+    static void debug (const char* fmt, ...);
 
-private:
-  bool m_debugEnabled;
+  private:
+    bool m_debugEnabled;
 
-  static Logger* s_instance;
-  static QMutex* s_mutex;
+    static Logger* s_instance;
+    static QMutex* s_mutex;
 
-private:
-  Logger (void);
-  ~Logger (void);
+  private:
+    Logger (void);
+    ~Logger (void);
 
-  static Logger* instance (void);
+    static Logger* instance (void);
 
-  void debugV (const char* fmt, va_list arg);
-};
+    void debugV (const char* fmt, va_list arg);
+  };
 
 }; // namespace QtHandles
 
 #endif
+
diff --git a/libgui/graphics/Menu.cc b/libgui/graphics/Menu.cc
--- a/libgui/graphics/Menu.cc
+++ b/libgui/graphics/Menu.cc
@@ -31,298 +31,299 @@ along with Octave; see the file COPYING.
 
 #include "Figure.h"
 #include "Menu.h"
 #include "QtHandlesUtils.h"
 
 namespace QtHandles
 {
 
-static QKeySequence
-accelSequence (const uimenu::properties& up)
-{
-  std::string s (up.get_accelerator ());
+  static QKeySequence
+  accelSequence (const uimenu::properties& up)
+  {
+    std::string s (up.get_accelerator ());
 
-  if (! s.empty ())
-    {
-      char c = s[0];
-      int keyMod = Qt::CTRL;
+    if (! s.empty ())
+      {
+        char c = s[0];
+        int keyMod = Qt::CTRL;
 
-      if (c >= 'A' && c <= 'Z')
-        keyMod |= Qt::SHIFT;
-      if (c >= 'a' && c <= 'z')
-        c -= ('a' - 'A');
-      if (c >= 'A' && c <= 'Z')
-        return QKeySequence (keyMod | static_cast<int> (c));
-    }
+        if (c >= 'A' && c <= 'Z')
+          keyMod |= Qt::SHIFT;
+        if (c >= 'a' && c <= 'z')
+          c -= ('a' - 'A');
+        if (c >= 'A' && c <= 'Z')
+          return QKeySequence (keyMod | static_cast<int> (c));
+      }
 
-  return QKeySequence ();
-}
+    return QKeySequence ();
+  }
 
-Menu*
-Menu::create (const graphics_object& go)
-{
-  Object* parent_obj = Object::parentObject (go);
+  Menu*
+  Menu::create (const graphics_object& go)
+  {
+    Object* parent_obj = Object::parentObject (go);
 
-  if (parent_obj)
-    {
-      QObject* qObj = parent_obj->qObject ();
+    if (parent_obj)
+      {
+        QObject* qObj = parent_obj->qObject ();
 
-      if (qObj)
-        return new Menu (go, new QAction (qObj), parent_obj);
-    }
+        if (qObj)
+          return new Menu (go, new QAction (qObj), parent_obj);
+      }
 
-  return 0;
-}
+    return 0;
+  }
 
-Menu::Menu (const graphics_object& go, QAction* action, Object* xparent)
-  : Object (go, action), m_parent (0), m_separator (0)
-{
-  uimenu::properties& up = properties<uimenu> ();
+  Menu::Menu (const graphics_object& go, QAction* action, Object* xparent)
+    : Object (go, action), m_parent (0), m_separator (0)
+  {
+    uimenu::properties& up = properties<uimenu> ();
 
-  action->setText (Utils::fromStdString (up.get_label ()));
+    action->setText (Utils::fromStdString (up.get_label ()));
 
-  if (up.is_checked ())
-    {
-      action->setCheckable (true);
-      action->setChecked (up.is_checked ());
-    }
+    if (up.is_checked ())
+      {
+        action->setCheckable (true);
+        action->setChecked (up.is_checked ());
+      }
 
-  action->setEnabled (up.is_enable ());
-  action->setShortcut (accelSequence (up));
-  action->setVisible (up.is_visible ());
+    action->setEnabled (up.is_enable ());
+    action->setShortcut (accelSequence (up));
+    action->setVisible (up.is_visible ());
 
-  if (up.is_separator ())
-    {
-      m_separator = new QAction (action);
-      m_separator->setSeparator (true);
-      m_separator->setVisible (up.is_visible ());
-    }
+    if (up.is_separator ())
+      {
+        m_separator = new QAction (action);
+        m_separator->setSeparator (true);
+        m_separator->setVisible (up.is_visible ());
+      }
 
-  MenuContainer* menuContainer = dynamic_cast<MenuContainer*> (xparent);
+    MenuContainer* menuContainer = dynamic_cast<MenuContainer*> (xparent);
 
-  if (menuContainer)
-    m_parent = menuContainer->menu ();
+    if (menuContainer)
+      m_parent = menuContainer->menu ();
 
-  if (m_parent)
-    {
-      int pos = static_cast<int> (up.get_position ());
+    if (m_parent)
+      {
+        int pos = static_cast<int> (up.get_position ());
 
-      if (pos <= 0)
-        {
-          if (m_separator)
-            m_parent->insertAction (0, m_separator);
-          m_parent->insertAction (0, action);
+        if (pos <= 0)
+          {
+            if (m_separator)
+              m_parent->insertAction (0, m_separator);
+            m_parent->insertAction (0, action);
 
-          int count = 0;
+            int count = 0;
 
-          foreach (QAction* a, m_parent->actions ())
+            foreach (QAction* a, m_parent->actions ())
             if (! a->isSeparator () && a->objectName () != "builtinMenu")
               count++;
-          up.get_property ("position").set
+            up.get_property ("position").set
             (octave_value (static_cast<double> (count)), true, false);
-        }
-      else
-        {
+          }
+        else
+          {
 
-          int count = 0;
-          QAction* before = 0;
+            int count = 0;
+            QAction* before = 0;
 
-          foreach (QAction* a, m_parent->actions ())
+            foreach (QAction* a, m_parent->actions ())
             if (! a->isSeparator () && a->objectName () != "builtinMenu")
               {
                 count++;
                 if (pos <= count)
                   {
                     before = a;
                     break;
                   }
               }
 
-          if (m_separator)
-            m_parent->insertAction (before, m_separator);
-          m_parent->insertAction (before, action);
+            if (m_separator)
+              m_parent->insertAction (before, m_separator);
+            m_parent->insertAction (before, action);
 
-          if (before)
-            updateSiblingPositions ();
-          else
-            up.get_property ("position").set
+            if (before)
+              updateSiblingPositions ();
+            else
+              up.get_property ("position").set
               (octave_value (static_cast<double> (count+1)), true, false);
-        }
-    }
+          }
+      }
 
-  connect (action, SIGNAL (triggered (bool)), SLOT (actionTriggered (void)));
-}
+    connect (action, SIGNAL (triggered (bool)), SLOT (actionTriggered (void)));
+  }
 
-Menu::~Menu (void)
-{
-}
+  Menu::~Menu (void)
+  {
+  }
 
-void
-Menu::update (int pId)
-{
-  uimenu::properties& up = properties<uimenu> ();
-  QAction* action = qWidget<QAction> ();
+  void
+  Menu::update (int pId)
+  {
+    uimenu::properties& up = properties<uimenu> ();
+    QAction* action = qWidget<QAction> ();
 
-  switch (pId)
-    {
-    case uimenu::properties::ID_LABEL:
-      action->setText (Utils::fromStdString (up.get_label ()));
-      break;
+    switch (pId)
+      {
+      case uimenu::properties::ID_LABEL:
+        action->setText (Utils::fromStdString (up.get_label ()));
+        break;
 
-    case uimenu::properties::ID_CHECKED:
-      if (up.is_checked ())
-        {
-          action->setCheckable (true);
-          action->setChecked (up.is_checked ());
-        }
-      else
-        {
-          action->setChecked (false);
-          action->setCheckable (false);
-        }
-      break;
+      case uimenu::properties::ID_CHECKED:
+        if (up.is_checked ())
+          {
+            action->setCheckable (true);
+            action->setChecked (up.is_checked ());
+          }
+        else
+          {
+            action->setChecked (false);
+            action->setCheckable (false);
+          }
+        break;
 
-    case uimenu::properties::ID_ENABLE:
-      action->setEnabled (up.is_enable ());
-      break;
+      case uimenu::properties::ID_ENABLE:
+        action->setEnabled (up.is_enable ());
+        break;
+
+      case uimenu::properties::ID_ACCELERATOR:
+        if (! action->menu ())
+          action->setShortcut (accelSequence (up));
+        break;
 
-    case uimenu::properties::ID_ACCELERATOR:
-      if (! action->menu ())
-        action->setShortcut (accelSequence (up));
-      break;
+      case uimenu::properties::ID_SEPARATOR:
+        if (up.is_separator ())
+          {
+            if (! m_separator)
+              {
+                m_separator = new QAction (action);
+                m_separator->setSeparator (true);
+                m_separator->setVisible (up.is_visible ());
+                if (m_parent)
+                  m_parent->insertAction (action, m_separator);
+              }
+          }
+        else
+          {
+            if (m_separator)
+              delete m_separator;
+            m_separator = 0;
+          }
+        break;
 
-    case uimenu::properties::ID_SEPARATOR:
-      if (up.is_separator ())
-        {
-          if (! m_separator)
-            {
-              m_separator = new QAction (action);
-              m_separator->setSeparator (true);
-              m_separator->setVisible (up.is_visible ());
-              if (m_parent)
-                m_parent->insertAction (action, m_separator);
-            }
-        }
-      else
+      case uimenu::properties::ID_VISIBLE:
+        action->setVisible (up.is_visible ());
+        if (m_separator)
+          m_separator->setVisible (up.is_visible ());
+        break;
+
+      case uimenu::properties::ID_POSITION:
         {
           if (m_separator)
-            delete m_separator;
-          m_separator = 0;
-        }
-      break;
+            m_parent->removeAction (m_separator);
 
-    case uimenu::properties::ID_VISIBLE:
-      action->setVisible (up.is_visible ());
-      if (m_separator)
-        m_separator->setVisible (up.is_visible ());
-      break;
+          m_parent->removeAction (action);
 
-    case uimenu::properties::ID_POSITION:
-      {
-        if (m_separator)
-          m_parent->removeAction (m_separator);
-
-        m_parent->removeAction (action);
+          int pos = static_cast<int> (up.get_position ());
+          QAction* before = 0;
 
-        int pos = static_cast<int> (up.get_position ());
-        QAction* before = 0;
+          if (pos > 0)
+            {
+              int count = 0;
 
-        if (pos > 0)
-          {
-            int count = 0;
-
-            foreach (QAction* a, m_parent->actions ())
+              foreach (QAction* a, m_parent->actions ())
               if (! a->isSeparator () && a->objectName () != "builtinMenu")
                 {
                   count++;
                   if (pos <= count)
                     {
                       before = a;
                       break;
                     }
                 }
-          }
+            }
 
-        if (m_separator)
-          m_parent->insertAction (before, m_separator);
+          if (m_separator)
+            m_parent->insertAction (before, m_separator);
 
-        m_parent->insertAction (before, action);
+          m_parent->insertAction (before, action);
 
-        updateSiblingPositions ();
-      }
-      break;
+          updateSiblingPositions ();
+        }
+        break;
 
-    default:
-      Object::update (pId);
-      break;
-    }
-}
+      default:
+        Object::update (pId);
+        break;
+      }
+  }
 
-QWidget*
-Menu::menu (void)
-{
-  QAction* action = qWidget<QAction> ();
-  QMenu* _menu = action->menu ();
+  QWidget*
+  Menu::menu (void)
+  {
+    QAction* action = qWidget<QAction> ();
+    QMenu* _menu = action->menu ();
 
-  if (! _menu)
-    {
-      _menu = new QMenu (action->parentWidget ());
-      action->setMenu (_menu);
-      action->setShortcut (QKeySequence ());
-      connect (_menu, SIGNAL (aboutToShow (void)),
-               this, SLOT (actionHovered (void)));
-    }
+    if (! _menu)
+      {
+        _menu = new QMenu (action->parentWidget ());
+        action->setMenu (_menu);
+        action->setShortcut (QKeySequence ());
+        connect (_menu, SIGNAL (aboutToShow (void)),
+                 this, SLOT (actionHovered (void)));
+      }
 
-  return _menu;
-}
+    return _menu;
+  }
 
-void
-Menu::actionTriggered (void)
-{
-  QAction* action = qWidget<QAction> ();
+  void
+  Menu::actionTriggered (void)
+  {
+    QAction* action = qWidget<QAction> ();
 
-  if (action->isCheckable ())
-    action->setChecked (! action->isChecked ());
-  gh_manager::post_callback (m_handle, "callback");
-}
+    if (action->isCheckable ())
+      action->setChecked (! action->isChecked ());
+    gh_manager::post_callback (m_handle, "callback");
+  }
 
-void
-Menu::actionHovered (void)
-{
-  gh_manager::post_callback (m_handle, "callback");
-}
+  void
+  Menu::actionHovered (void)
+  {
+    gh_manager::post_callback (m_handle, "callback");
+  }
 
-void
-Menu::updateSiblingPositions (void)
-{
-  if (m_parent)
-    {
-      double count = 1.0;
+  void
+  Menu::updateSiblingPositions (void)
+  {
+    if (m_parent)
+      {
+        double count = 1.0;
 
-      foreach (QAction* a, m_parent->actions ())
+        foreach (QAction* a, m_parent->actions ())
         {
           if (! a->isSeparator () && a->objectName () != "builtinMenu")
             {
               Object* aObj = Object::fromQObject (a);
 
               if (aObj)
                 {
                   graphics_object go = aObj->object ();
 
                   // Probably overkill as a uimenu child can only be another
                   // uimenu object.
                   if (go.isa ("uimenu"))
                     {
                       uimenu::properties& up = Utils::properties<uimenu> (go);
 
                       up.get_property ("position").set
-                        (octave_value (count), true, false);
+                      (octave_value (count), true, false);
                     }
                 }
 
               count++;
             }
         }
-    }
-}
+      }
+  }
 
 }; // namespace QtHandles
+
diff --git a/libgui/graphics/Menu.h b/libgui/graphics/Menu.h
--- a/libgui/graphics/Menu.h
+++ b/libgui/graphics/Menu.h
@@ -28,40 +28,41 @@ along with Octave; see the file COPYING.
 
 class QAction;
 class QMenu;
 class QWidget;
 
 namespace QtHandles
 {
 
-class Menu : public Object, public MenuContainer
-{
-  Q_OBJECT
+  class Menu : public Object, public MenuContainer
+  {
+    Q_OBJECT
 
-public:
-  Menu (const graphics_object& go, QAction* action, Object* parent);
-  ~Menu (void);
+  public:
+    Menu (const graphics_object& go, QAction* action, Object* parent);
+    ~Menu (void);
 
-  static Menu* create (const graphics_object& go);
+    static Menu* create (const graphics_object& go);
 
-  Container* innerContainer (void) { return 0; }
+    Container* innerContainer (void) { return 0; }
 
-  QWidget* menu (void);
+    QWidget* menu (void);
 
-protected:
-  void update (int pId);
+  protected:
+    void update (int pId);
 
-private slots:
-  void actionTriggered (void);
-  void actionHovered (void);
+  private slots:
+    void actionTriggered (void);
+    void actionHovered (void);
 
-private:
-  void updateSiblingPositions (void);
+  private:
+    void updateSiblingPositions (void);
 
-private:
-  QWidget* m_parent;
-  QAction* m_separator;
-};
+  private:
+    QWidget* m_parent;
+    QAction* m_separator;
+  };
 
 }; // namespace QtHandles
 
 #endif
+
diff --git a/libgui/graphics/MenuContainer.h b/libgui/graphics/MenuContainer.h
--- a/libgui/graphics/MenuContainer.h
+++ b/libgui/graphics/MenuContainer.h
@@ -23,17 +23,18 @@ along with Octave; see the file COPYING.
 #if ! defined (octave_MenuContainer_h)
 #define octave_MenuContainer_h 1
 
 class QWidget;
 
 namespace QtHandles
 {
 
-class MenuContainer
-{
-public:
-  virtual QWidget* menu (void) = 0;
-};
+  class MenuContainer
+  {
+  public:
+    virtual QWidget* menu (void) = 0;
+  };
 
 }; // namespace QtHandles
 
 #endif
+
diff --git a/libgui/graphics/MouseModeActionGroup.cc b/libgui/graphics/MouseModeActionGroup.cc
--- a/libgui/graphics/MouseModeActionGroup.cc
+++ b/libgui/graphics/MouseModeActionGroup.cc
@@ -28,85 +28,86 @@ along with Octave; see the file COPYING.
 #include <QIcon>
 
 #include "Figure.h"
 #include "MouseModeActionGroup.h"
 
 namespace QtHandles
 {
 
-MouseModeActionGroup::MouseModeActionGroup (QObject* xparent)
-  : QObject (xparent), m_current (0)
-{
-  m_actions.append (new QAction (QIcon (":/images/rotate.png"),
-                                 tr ("Rotate"), this));
-  QAction *zoom_in = new QAction ("Z+", this);
-  zoom_in->setToolTip (tr ("Zoom In"));
-  m_actions.append (zoom_in);
+  MouseModeActionGroup::MouseModeActionGroup (QObject* xparent)
+    : QObject (xparent), m_current (0)
+  {
+    m_actions.append (new QAction (QIcon (":/images/rotate.png"),
+                                   tr ("Rotate"), this));
+    QAction *zoom_in = new QAction ("Z+", this);
+    zoom_in->setToolTip (tr ("Zoom In"));
+    m_actions.append (zoom_in);
 
-  QAction *zoom_out = new QAction ("Z-", this);
-  zoom_out->setToolTip (tr ("Zoom Out"));
-  m_actions.append (zoom_out);
+    QAction *zoom_out = new QAction ("Z-", this);
+    zoom_out->setToolTip (tr ("Zoom Out"));
+    m_actions.append (zoom_out);
 
-  m_actions.append (new QAction (QIcon (":/images/pan.png"),
-                                 tr ("Pan"), this));
-  m_actions.append (new QAction (QIcon::fromTheme ("insert-text"),
-                                 tr ("Insert Text"), this));
-  m_actions.append (new QAction (QIcon (":/images/select.png"),
-                                 tr ("Select"), this));
+    m_actions.append (new QAction (QIcon (":/images/pan.png"),
+                                   tr ("Pan"), this));
+    m_actions.append (new QAction (QIcon::fromTheme ("insert-text"),
+                                   tr ("Insert Text"), this));
+    m_actions.append (new QAction (QIcon (":/images/select.png"),
+                                   tr ("Select"), this));
 
-  foreach (QAction* a, m_actions)
+    foreach (QAction* a, m_actions)
     {
       a->setCheckable (true);
       connect (a, SIGNAL (toggled (bool)), this, SLOT (actionToggled (bool)));
     }
-}
+  }
 
-MouseModeActionGroup::~MouseModeActionGroup (void)
-{
-}
+  MouseModeActionGroup::~MouseModeActionGroup (void)
+  {
+  }
 
-void
-MouseModeActionGroup::actionToggled (bool checked)
-{
-  if (! checked)
-    {
-      if (sender () == m_current)
-        {
-          m_current = 0;
-          emit modeChanged (NoMode);
-        }
-    }
-  else
-    {
-      int i = m_actions.indexOf (qobject_cast<QAction*> (sender ()));
+  void
+  MouseModeActionGroup::actionToggled (bool checked)
+  {
+    if (! checked)
+      {
+        if (sender () == m_current)
+          {
+            m_current = 0;
+            emit modeChanged (NoMode);
+          }
+      }
+    else
+      {
+        int i = m_actions.indexOf (qobject_cast<QAction*> (sender ()));
 
-      if (i >= 0)
-        {
-          m_current = m_actions[i];
-          for (int j = 0; j < m_actions.size (); j++)
-            {
-              // SelectMode cancels all the others but the button
-              // doesn't remain highlighed.
+        if (i >= 0)
+          {
+            m_current = m_actions[i];
+            for (int j = 0; j < m_actions.size (); j++)
+              {
+                // SelectMode cancels all the others but the button
+                // doesn't remain highlighed.
 
-              if (j != i || i+1 == SelectMode)
-                m_actions[j]->setChecked (false);
-            }
+                if (j != i || i+1 == SelectMode)
+                  m_actions[j]->setChecked (false);
+              }
 
-          emit modeChanged (static_cast<MouseMode> (i+1));
-        }
-    }
-}
+            emit modeChanged (static_cast<MouseMode> (i+1));
+          }
+      }
+  }
 
-void
-MouseModeActionGroup::setMode (MouseMode mode)
-{
-  for (int i = 0; i < m_actions.size (); i++)
-    m_actions[i]->setChecked (i+1 == mode);
+  void
+  MouseModeActionGroup::setMode (MouseMode mode)
+  {
+    for (int i = 0; i < m_actions.size (); i++)
+      m_actions[i]->setChecked (i+1 == mode);
 
-  // SelectMode cancels all the others but the button doesn't remain
-  // highlighed.
+    // SelectMode cancels all the others but the button doesn't remain
+    // highlighed.
 
-  if (mode == SelectMode)
-    m_actions[SelectMode-1]->setChecked (false);
-}
+    if (mode == SelectMode)
+      m_actions[SelectMode-1]->setChecked (false);
+  }
 
 };
+
diff --git a/libgui/graphics/MouseModeActionGroup.h b/libgui/graphics/MouseModeActionGroup.h
--- a/libgui/graphics/MouseModeActionGroup.h
+++ b/libgui/graphics/MouseModeActionGroup.h
@@ -28,34 +28,35 @@ along with Octave; see the file COPYING.
 
 #include "Figure.h"
 
 class QAction;
 
 namespace QtHandles
 {
 
-class MouseModeActionGroup : public QObject
-{
-  Q_OBJECT
+  class MouseModeActionGroup : public QObject
+  {
+    Q_OBJECT
 
-public:
-  MouseModeActionGroup (QObject* parent = 0);
-  ~MouseModeActionGroup (void);
+  public:
+    MouseModeActionGroup (QObject* parent = 0);
+    ~MouseModeActionGroup (void);
 
-  QList<QAction*> actions (void) const { return m_actions; }
+    QList<QAction*> actions (void) const { return m_actions; }
 
-  void setMode (MouseMode mode);
+    void setMode (MouseMode mode);
 
-signals:
-  void modeChanged (MouseMode mode);
+  signals:
+    void modeChanged (MouseMode mode);
 
-private slots:
-  void actionToggled (bool checked);
+  private slots:
+    void actionToggled (bool checked);
 
-private:
-  QList<QAction*> m_actions;
-  QAction* m_current;
-};
+  private:
+    QList<QAction*> m_actions;
+    QAction* m_current;
+  };
 
 };
 
 #endif
+
diff --git a/libgui/graphics/Object.cc b/libgui/graphics/Object.cc
--- a/libgui/graphics/Object.cc
+++ b/libgui/graphics/Object.cc
@@ -29,163 +29,164 @@ along with Octave; see the file COPYING.
 
 #include "Backend.h"
 #include "Object.h"
 #include "QtHandlesUtils.h"
 
 namespace QtHandles
 {
 
-Object::Object (const graphics_object& go, QObject* obj)
-  : QObject (), m_handle (go.get_handle ()), m_qobject (0)
-{
-  gh_manager::auto_lock lock (false);
+  Object::Object (const graphics_object& go, QObject* obj)
+    : QObject (), m_handle (go.get_handle ()), m_qobject (0)
+  {
+    gh_manager::auto_lock lock (false);
 
-  if (! lock)
-    qCritical ("QtHandles::Object::Object: "
-               "creating Object (h=%g) without a valid lock!!!",
-               m_handle.value ());
+    if (! lock)
+      qCritical ("QtHandles::Object::Object: "
+                 "creating Object (h=%g) without a valid lock!!!",
+                 m_handle.value ());
 
-  init (obj);
-}
+    init (obj);
+  }
 
-void
-Object::init (QObject* obj, bool)
-{
-  if (m_qobject)
-    qCritical ("QtHandles::Object::init: "
-               "resetting QObject while in invalid state");
+  void
+  Object::init (QObject* obj, bool)
+  {
+    if (m_qobject)
+      qCritical ("QtHandles::Object::init: "
+                 "resetting QObject while in invalid state");
 
-  m_qobject = obj;
+    m_qobject = obj;
 
-  if (m_qobject)
-    {
-      m_qobject->setProperty ("QtHandles::Object",
-                              qVariantFromValue<void*> (this));
-      connect (m_qobject, SIGNAL (destroyed (QObject*)),
-               SLOT (objectDestroyed (QObject*)));
-    }
-}
+    if (m_qobject)
+      {
+        m_qobject->setProperty ("QtHandles::Object",
+                                qVariantFromValue<void*> (this));
+        connect (m_qobject, SIGNAL (destroyed (QObject*)),
+                 SLOT (objectDestroyed (QObject*)));
+      }
+  }
 
-Object::~Object (void)
-{
-}
+  Object::~Object (void)
+  {
+  }
 
-graphics_object
-Object::object (void) const
-{
-  gh_manager::auto_lock lock (false);
+  graphics_object
+  Object::object (void) const
+  {
+    gh_manager::auto_lock lock (false);
 
-  if (! lock)
-    qCritical ("QtHandles::Object::object: "
-               "accessing graphics object (h=%g) without a valid lock!!!",
-               m_handle.value ());
+    if (! lock)
+      qCritical ("QtHandles::Object::object: "
+                 "accessing graphics object (h=%g) without a valid lock!!!",
+                 m_handle.value ());
 
-  return gh_manager::get_object (m_handle);
-}
+    return gh_manager::get_object (m_handle);
+  }
 
-void
-Object::slotUpdate (int pId)
-{
-  gh_manager::auto_lock lock;
+  void
+  Object::slotUpdate (int pId)
+  {
+    gh_manager::auto_lock lock;
 
-  switch (pId)
-    {
-    // Special case for objects being deleted, as it's very likely
-    // that the graphics_object already has been destroyed when this
-    // is executed (because of the async behavior).
-    case base_properties::ID_BEINGDELETED:
-      beingDeleted ();
-      break;
+    switch (pId)
+      {
+      // Special case for objects being deleted, as it's very likely
+      // that the graphics_object already has been destroyed when this
+      // is executed (because of the async behavior).
+      case base_properties::ID_BEINGDELETED:
+        beingDeleted ();
+        break;
 
-    default:
-      if (object ().valid_object ())
-        update (pId);
-      break;
-    }
-}
+      default:
+        if (object ().valid_object ())
+          update (pId);
+        break;
+      }
+  }
 
-void
-Object::slotFinalize (void)
-{
-  gh_manager::auto_lock lock;
+  void
+  Object::slotFinalize (void)
+  {
+    gh_manager::auto_lock lock;
 
-  finalize ();
-}
+    finalize ();
+  }
 
-void
-Object::slotRedraw (void)
-{
-  gh_manager::auto_lock lock;
+  void
+  Object::slotRedraw (void)
+  {
+    gh_manager::auto_lock lock;
 
-  if (object ().valid_object ())
-    redraw ();
-}
+    if (object ().valid_object ())
+      redraw ();
+  }
 
-void
-Object::slotPrint (const QString& file_cmd, const QString& term)
-{
-  gh_manager::auto_lock lock;
+  void
+  Object::slotPrint (const QString& file_cmd, const QString& term)
+  {
+    gh_manager::auto_lock lock;
 
-  if (object ().valid_object ())
-    print (file_cmd, term);
-}
+    if (object ().valid_object ())
+      print (file_cmd, term);
+  }
 
-void
-Object::update (int /* pId */)
-{
-}
+  void
+  Object::update (int /* pId */)
+  {
+  }
 
-void
-Object::finalize (void)
-{
-  if (m_qobject)
-    {
-      delete m_qobject;
-      m_qobject = 0;
-    }
-  deleteLater ();
-}
+  void
+  Object::finalize (void)
+  {
+    if (m_qobject)
+      {
+        delete m_qobject;
+        m_qobject = 0;
+      }
+    deleteLater ();
+  }
 
-void
-Object::redraw (void)
-{
-}
+  void
+  Object::redraw (void)
+  {
+  }
 
-void
-Object::print (const QString& /* file_cmd */, const QString& /* term */)
-{
-}
+  void
+  Object::print (const QString& /* file_cmd */, const QString& /* term */)
+  {
+  }
 
-void
-Object::beingDeleted (void)
-{
-}
+  void
+  Object::beingDeleted (void)
+  {
+  }
 
-void Object::objectDestroyed (QObject* obj)
-{
-  if (obj && obj == m_qobject)
-    m_qobject = 0;
-}
+  void Object::objectDestroyed (QObject* obj)
+  {
+    if (obj && obj == m_qobject)
+      m_qobject = 0;
+  }
 
-Object*
-Object::parentObject (const graphics_object& go)
-{
-  gh_manager::auto_lock lock;
+  Object*
+  Object::parentObject (const graphics_object& go)
+  {
+    gh_manager::auto_lock lock;
 
-  Object* parent = Backend::toolkitObject
-    (gh_manager::get_object (go.get_parent ()));
+    Object* parent = Backend::toolkitObject
+                     (gh_manager::get_object (go.get_parent ()));
 
-  return parent;
-}
+    return parent;
+  }
 
-Object*
-Object::fromQObject (QObject* obj)
-{
-  QVariant v = obj->property ("QtHandles::Object");
+  Object*
+  Object::fromQObject (QObject* obj)
+  {
+    QVariant v = obj->property ("QtHandles::Object");
 
-  if (v.isValid ())
-    return reinterpret_cast<Object*> (qvariant_cast<void*> (v));
+    if (v.isValid ())
+      return reinterpret_cast<Object*> (qvariant_cast<void*> (v));
 
-  return 0;
-}
+    return 0;
+  }
 
 }; // namespace QtHandles
+
diff --git a/libgui/graphics/Object.h b/libgui/graphics/Object.h
--- a/libgui/graphics/Object.h
+++ b/libgui/graphics/Object.h
@@ -29,78 +29,79 @@ along with Octave; see the file COPYING.
 
 class QObject;
 class QString;
 class QWidget;
 
 namespace QtHandles
 {
 
-class Container;
-class ObjectProxy;
+  class Container;
+  class ObjectProxy;
 
-class Object : public QObject
-{
-  Q_OBJECT
+  class Object : public QObject
+  {
+    Q_OBJECT
 
-public:
-  Object (const graphics_object& go, QObject* obj = 0);
+  public:
+    Object (const graphics_object& go, QObject* obj = 0);
 
-  virtual ~Object (void);
+    virtual ~Object (void);
 
-  base_properties& properties (void)
+    base_properties& properties (void)
     { return object ().get_properties (); }
 
-  const base_properties& properties (void) const
+    const base_properties& properties (void) const
     { return object ().get_properties (); }
 
-  template <typename T>
-  typename T::properties& properties (void)
+    template <typename T>
+    typename T::properties& properties (void)
     {
       return dynamic_cast<typename T::properties&>
-        (object ().get_properties ());
+             (object ().get_properties ());
     }
 
-  template <typename T>
-  const typename T::properties& properties (void) const
+    template <typename T>
+    const typename T::properties& properties (void) const
     {
       return dynamic_cast<const typename T::properties&>
-        (object ().get_properties ());
+             (object ().get_properties ());
     }
 
-  graphics_object object (void) const;
+    graphics_object object (void) const;
 
-  virtual QObject* qObject (void) { return m_qobject; }
+    virtual QObject* qObject (void) { return m_qobject; }
 
-  template <typename T>
-  T* qWidget (void) { return qobject_cast<T*>(qObject ()); }
+    template <typename T>
+    T* qWidget (void) { return qobject_cast<T*>(qObject ()); }
 
-  virtual Container* innerContainer (void) = 0;
+    virtual Container* innerContainer (void) = 0;
 
-  static Object* fromQObject (QObject* obj);
+    static Object* fromQObject (QObject* obj);
 
-public slots:
-  void slotUpdate (int pId);
-  void slotFinalize (void);
-  void slotRedraw (void);
-  void slotPrint (const QString& file_cmd, const QString& term);
+  public slots:
+    void slotUpdate (int pId);
+    void slotFinalize (void);
+    void slotRedraw (void);
+    void slotPrint (const QString& file_cmd, const QString& term);
 
-  void objectDestroyed (QObject *obj = 0);
+    void objectDestroyed (QObject *obj = 0);
 
-protected:
-  static Object* parentObject (const graphics_object& go);
-  void init (QObject* obj, bool callBase = false);
+  protected:
+    static Object* parentObject (const graphics_object& go);
+    void init (QObject* obj, bool callBase = false);
 
-  virtual void update (int pId);
-  virtual void finalize (void);
-  virtual void redraw (void);
-  virtual void print (const QString& file_cmd, const QString& term);
+    virtual void update (int pId);
+    virtual void finalize (void);
+    virtual void redraw (void);
+    virtual void print (const QString& file_cmd, const QString& term);
 
-  virtual void beingDeleted (void);
+    virtual void beingDeleted (void);
 
-protected:
-  graphics_handle m_handle;
-  QObject* m_qobject;
-};
+  protected:
+    graphics_handle m_handle;
+    QObject* m_qobject;
+  };
 
 }; // namespace QtHandles
 
 #endif
+
diff --git a/libgui/graphics/ObjectFactory.cc b/libgui/graphics/ObjectFactory.cc
--- a/libgui/graphics/ObjectFactory.cc
+++ b/libgui/graphics/ObjectFactory.cc
@@ -50,105 +50,106 @@ along with Octave; see the file COPYING.
 #include "ToggleButtonControl.h"
 #include "ToggleTool.h"
 #include "ToolBar.h"
 #include "QtHandlesUtils.h"
 
 namespace QtHandles
 {
 
-ObjectFactory*
-ObjectFactory::instance (void)
-{
-  static ObjectFactory s_instance;
-  static bool s_instanceCreated = false;
+  ObjectFactory*
+  ObjectFactory::instance (void)
+  {
+    static ObjectFactory s_instance;
+    static bool s_instanceCreated = false;
 
-  if (! s_instanceCreated)
-    {
-      if (QThread::currentThread () != QApplication::instance ()->thread ())
-        s_instance.moveToThread (QApplication::instance ()->thread ());
-      s_instanceCreated = true;
-    }
+    if (! s_instanceCreated)
+      {
+        if (QThread::currentThread () != QApplication::instance ()->thread ())
+          s_instance.moveToThread (QApplication::instance ()->thread ());
+        s_instanceCreated = true;
+      }
 
-  return &s_instance;
-}
+    return &s_instance;
+  }
 
-void
-ObjectFactory::createObject (double handle)
-{
-  gh_manager::auto_lock lock;
+  void
+  ObjectFactory::createObject (double handle)
+  {
+    gh_manager::auto_lock lock;
 
-  graphics_object go (gh_manager::get_object (graphics_handle (handle)));
+    graphics_object go (gh_manager::get_object (graphics_handle (handle)));
 
-  if (go.valid_object ())
-    {
-      if (go.get_properties ().is_beingdeleted ())
-        qWarning ("ObjectFactory::createObject: object is being deleted");
-      else
-        {
-          ObjectProxy* proxy = Backend::toolkitObjectProxy (go);
+    if (go.valid_object ())
+      {
+        if (go.get_properties ().is_beingdeleted ())
+          qWarning ("ObjectFactory::createObject: object is being deleted");
+        else
+          {
+            ObjectProxy* proxy = Backend::toolkitObjectProxy (go);
 
-          if (proxy)
-            {
-              Logger::debug ("ObjectFactory::createObject: "
-                             "create %s from thread %08x",
-                             go.type ().c_str (), QThread::currentThreadId ());
+            if (proxy)
+              {
+                Logger::debug ("ObjectFactory::createObject: "
+                               "create %s from thread %08x",
+                               go.type ().c_str (), QThread::currentThreadId ());
 
-              Object* obj = 0;
+                Object* obj = 0;
 
-              if (go.isa ("figure"))
-                obj = Figure::create (go);
-              else if (go.isa ("uicontrol"))
-                {
-                  uicontrol::properties& up =
-                   Utils::properties<uicontrol> (go);
+                if (go.isa ("figure"))
+                  obj = Figure::create (go);
+                else if (go.isa ("uicontrol"))
+                  {
+                    uicontrol::properties& up =
+                      Utils::properties<uicontrol> (go);
 
-                  if (up.style_is ("pushbutton"))
-                    obj = PushButtonControl::create (go);
-                  else if (up.style_is ("edit"))
-                    obj = EditControl::create (go);
-                  else if (up.style_is ("checkbox"))
-                    obj = CheckBoxControl::create (go);
-                  else if (up.style_is ("radiobutton"))
-                    obj = RadioButtonControl::create (go);
-                  else if (up.style_is ("togglebutton"))
-                    obj = ToggleButtonControl::create (go);
-                  else if (up.style_is ("text"))
-                    obj = TextControl::create (go);
-                  else if (up.style_is ("popupmenu"))
-                    obj = PopupMenuControl::create (go);
-                  else if (up.style_is ("slider"))
-                    obj = SliderControl::create (go);
-                  else if (up.style_is ("listbox"))
-                    obj = ListBoxControl::create (go);
-                }
-              else if (go.isa ("uibuttongroup"))
-                obj = ButtonGroup::create (go);
-              else if (go.isa ("uipanel"))
-                obj = Panel::create (go);
-              else if (go.isa ("uimenu"))
-                obj = Menu::create (go);
-              else if (go.isa ("uicontextmenu"))
-                obj = ContextMenu::create (go);
-              else if (go.isa ("uitoolbar"))
-                obj = ToolBar::create (go);
-              else if (go.isa ("uipushtool"))
-                obj = PushTool::create (go);
-              else if (go.isa ("uitoggletool"))
-                obj = ToggleTool::create (go);
-              else
-                qWarning ("ObjectFactory::createObject: unsupported type `%s'",
-                          go.type ().c_str ());
+                    if (up.style_is ("pushbutton"))
+                      obj = PushButtonControl::create (go);
+                    else if (up.style_is ("edit"))
+                      obj = EditControl::create (go);
+                    else if (up.style_is ("checkbox"))
+                      obj = CheckBoxControl::create (go);
+                    else if (up.style_is ("radiobutton"))
+                      obj = RadioButtonControl::create (go);
+                    else if (up.style_is ("togglebutton"))
+                      obj = ToggleButtonControl::create (go);
+                    else if (up.style_is ("text"))
+                      obj = TextControl::create (go);
+                    else if (up.style_is ("popupmenu"))
+                      obj = PopupMenuControl::create (go);
+                    else if (up.style_is ("slider"))
+                      obj = SliderControl::create (go);
+                    else if (up.style_is ("listbox"))
+                      obj = ListBoxControl::create (go);
+                  }
+                else if (go.isa ("uibuttongroup"))
+                  obj = ButtonGroup::create (go);
+                else if (go.isa ("uipanel"))
+                  obj = Panel::create (go);
+                else if (go.isa ("uimenu"))
+                  obj = Menu::create (go);
+                else if (go.isa ("uicontextmenu"))
+                  obj = ContextMenu::create (go);
+                else if (go.isa ("uitoolbar"))
+                  obj = ToolBar::create (go);
+                else if (go.isa ("uipushtool"))
+                  obj = PushTool::create (go);
+                else if (go.isa ("uitoggletool"))
+                  obj = ToggleTool::create (go);
+                else
+                  qWarning ("ObjectFactory::createObject: unsupported type `%s'",
+                            go.type ().c_str ());
 
-              if (obj)
-                proxy->setObject (obj);
-            }
-          else
-            qWarning ("ObjectFactory::createObject: no proxy for handle %g",
-                      handle);
-        }
-    }
-  else
-    qWarning ("ObjectFactory::createObject: invalid object for handle %g",
-              handle);
-}
+                if (obj)
+                  proxy->setObject (obj);
+              }
+            else
+              qWarning ("ObjectFactory::createObject: no proxy for handle %g",
+                        handle);
+          }
+      }
+    else
+      qWarning ("ObjectFactory::createObject: invalid object for handle %g",
+                handle);
+  }
 
 };
+
diff --git a/libgui/graphics/ObjectFactory.h b/libgui/graphics/ObjectFactory.h
--- a/libgui/graphics/ObjectFactory.h
+++ b/libgui/graphics/ObjectFactory.h
@@ -25,29 +25,30 @@ along with Octave; see the file COPYING.
 
 #include <QObject>
 
 class graphics_object;
 
 namespace QtHandles
 {
 
-class Object;
+  class Object;
 
-class ObjectFactory : public QObject
-{
-  Q_OBJECT
+  class ObjectFactory : public QObject
+  {
+    Q_OBJECT
 
-public:
-  static ObjectFactory* instance (void);
+  public:
+    static ObjectFactory* instance (void);
 
-public slots:
-  void createObject (double handle);
+  public slots:
+    void createObject (double handle);
 
-private:
-  ObjectFactory (void)
-    : QObject ()
+  private:
+    ObjectFactory (void)
+      : QObject ()
     { }
-};
+  };
 
 };
 
 #endif
+
diff --git a/libgui/graphics/ObjectProxy.cc b/libgui/graphics/ObjectProxy.cc
--- a/libgui/graphics/ObjectProxy.cc
+++ b/libgui/graphics/ObjectProxy.cc
@@ -29,84 +29,85 @@ along with Octave; see the file COPYING.
 #include "oct-mutex.h"
 
 #include "Object.h"
 #include "ObjectProxy.h"
 
 namespace QtHandles
 {
 
-ObjectProxy::ObjectProxy (Object* obj)
-  : QObject (), m_object (0)
-{
-  init (obj);
-}
+  ObjectProxy::ObjectProxy (Object* obj)
+    : QObject (), m_object (0)
+  {
+    init (obj);
+  }
 
-void
-ObjectProxy::init (Object* obj)
-{
-  if (obj != m_object)
-    {
-      if (m_object)
-        {
-          disconnect (this, SIGNAL (sendUpdate (int)),
-                      m_object, SLOT (slotUpdate (int)));
-          disconnect (this, SIGNAL (sendFinalize (void)),
-                      m_object, SLOT (slotFinalize (void)));
-          disconnect (this, SIGNAL (sendRedraw (void)),
-                      m_object, SLOT (slotRedraw (void)));
-          disconnect (this, SIGNAL (sendPrint (const QString&, const QString&)),
-                      m_object, SLOT (slotPrint (const QString&, const QString&)));
-        }
+  void
+  ObjectProxy::init (Object* obj)
+  {
+    if (obj != m_object)
+      {
+        if (m_object)
+          {
+            disconnect (this, SIGNAL (sendUpdate (int)),
+                        m_object, SLOT (slotUpdate (int)));
+            disconnect (this, SIGNAL (sendFinalize (void)),
+                        m_object, SLOT (slotFinalize (void)));
+            disconnect (this, SIGNAL (sendRedraw (void)),
+                        m_object, SLOT (slotRedraw (void)));
+            disconnect (this, SIGNAL (sendPrint (const QString&, const QString&)),
+                        m_object, SLOT (slotPrint (const QString&, const QString&)));
+          }
 
-      m_object = obj;
+        m_object = obj;
 
-      if (m_object)
-        {
-          connect (this, SIGNAL (sendUpdate (int)),
-                   m_object, SLOT (slotUpdate (int)));
-          connect (this, SIGNAL (sendFinalize (void)),
-                   m_object, SLOT (slotFinalize (void)));
-          connect (this, SIGNAL (sendRedraw (void)),
-                   m_object, SLOT (slotRedraw (void)));
-          connect (this, SIGNAL (sendPrint (const QString&, const QString&)),
-                   m_object, SLOT (slotPrint (const QString&, const QString&)),
-                   Qt::BlockingQueuedConnection);
-        }
-    }
-}
+        if (m_object)
+          {
+            connect (this, SIGNAL (sendUpdate (int)),
+                     m_object, SLOT (slotUpdate (int)));
+            connect (this, SIGNAL (sendFinalize (void)),
+                     m_object, SLOT (slotFinalize (void)));
+            connect (this, SIGNAL (sendRedraw (void)),
+                     m_object, SLOT (slotRedraw (void)));
+            connect (this, SIGNAL (sendPrint (const QString&, const QString&)),
+                     m_object, SLOT (slotPrint (const QString&, const QString&)),
+                     Qt::BlockingQueuedConnection);
+          }
+      }
+  }
 
-void
-ObjectProxy::setObject (Object* obj)
-{
-  emit sendFinalize ();
-  init (obj);
-}
+  void
+  ObjectProxy::setObject (Object* obj)
+  {
+    emit sendFinalize ();
+    init (obj);
+  }
 
-void
-ObjectProxy::update (int pId)
-{
-  if (octave_thread::is_octave_thread ())
-    emit sendUpdate (pId);
-  else if (m_object)
-    m_object->slotUpdate (pId);
-}
+  void
+  ObjectProxy::update (int pId)
+  {
+    if (octave_thread::is_octave_thread ())
+      emit sendUpdate (pId);
+    else if (m_object)
+      m_object->slotUpdate (pId);
+  }
 
-void
-ObjectProxy::finalize (void)
-{
-  emit sendFinalize ();
-  init (0);
-}
+  void
+  ObjectProxy::finalize (void)
+  {
+    emit sendFinalize ();
+    init (0);
+  }
 
-void
-ObjectProxy::redraw (void)
-{
-  emit sendRedraw ();
-}
+  void
+  ObjectProxy::redraw (void)
+  {
+    emit sendRedraw ();
+  }
 
-void
-ObjectProxy::print (const QString& file_cmd, const QString& term)
-{
-  emit sendPrint (file_cmd, term);
-}
+  void
+  ObjectProxy::print (const QString& file_cmd, const QString& term)
+  {
+    emit sendPrint (file_cmd, term);
+  }
 
 };
+
diff --git a/libgui/graphics/ObjectProxy.h b/libgui/graphics/ObjectProxy.h
--- a/libgui/graphics/ObjectProxy.h
+++ b/libgui/graphics/ObjectProxy.h
@@ -25,41 +25,42 @@ along with Octave; see the file COPYING.
 
 #include <QObject>
 
 class QString;
 
 namespace QtHandles
 {
 
-class Object;
+  class Object;
 
-class ObjectProxy : public QObject
-{
-  Q_OBJECT
+  class ObjectProxy : public QObject
+  {
+    Q_OBJECT
 
-public:
-   ObjectProxy (Object* obj = 0);
+  public:
+    ObjectProxy (Object* obj = 0);
 
-   void update (int pId);
-   void finalize (void);
-   void redraw (void);
-   void print (const QString& file_cmd, const QString& term);
+    void update (int pId);
+    void finalize (void);
+    void redraw (void);
+    void print (const QString& file_cmd, const QString& term);
 
-   Object* object (void) { return m_object; }
-   void setObject (Object* obj);
+    Object* object (void) { return m_object; }
+    void setObject (Object* obj);
 
-signals:
-   void sendUpdate (int pId);
-   void sendFinalize (void);
-   void sendRedraw (void);
-   void sendPrint (const QString& file_cmd, const QString& term);
+  signals:
+    void sendUpdate (int pId);
+    void sendFinalize (void);
+    void sendRedraw (void);
+    void sendPrint (const QString& file_cmd, const QString& term);
 
-private:
-   void init (Object* obj);
+  private:
+    void init (Object* obj);
 
-private:
-   Object* m_object;
-};
+  private:
+    Object* m_object;
+  };
 
 };
 
 #endif
+
diff --git a/libgui/graphics/Panel.cc b/libgui/graphics/Panel.cc
--- a/libgui/graphics/Panel.cc
+++ b/libgui/graphics/Panel.cc
@@ -34,135 +34,135 @@ along with Octave; see the file COPYING.
 #include "Container.h"
 #include "ContextMenu.h"
 #include "Panel.h"
 #include "QtHandlesUtils.h"
 
 namespace QtHandles
 {
 
-static int
-frameStyleFromProperties (const uipanel::properties& pp)
-{
-  if (pp.bordertype_is ("none"))
-    return QFrame::NoFrame;
-  else if (pp.bordertype_is ("etchedin"))
-    return (QFrame::Box | QFrame::Sunken);
-  else if (pp.bordertype_is ("etchedout"))
-    return (QFrame::Box | QFrame::Raised);
-  else if (pp.bordertype_is ("beveledin"))
-    return (QFrame::Panel | QFrame::Sunken);
-  else if (pp.bordertype_is ("beveledout"))
-    return (QFrame::Panel | QFrame::Raised);
-  else
-    return (QFrame::Panel | QFrame::Plain);
-}
+  static int
+  frameStyleFromProperties (const uipanel::properties& pp)
+  {
+    if (pp.bordertype_is ("none"))
+      return QFrame::NoFrame;
+    else if (pp.bordertype_is ("etchedin"))
+      return (QFrame::Box | QFrame::Sunken);
+    else if (pp.bordertype_is ("etchedout"))
+      return (QFrame::Box | QFrame::Raised);
+    else if (pp.bordertype_is ("beveledin"))
+      return (QFrame::Panel | QFrame::Sunken);
+    else if (pp.bordertype_is ("beveledout"))
+      return (QFrame::Panel | QFrame::Raised);
+    else
+      return (QFrame::Panel | QFrame::Plain);
+  }
 
-static void
-setupPalette (const uipanel::properties& pp, QPalette& p)
-{
-  p.setColor (QPalette::Window,
-              Utils::fromRgb (pp.get_backgroundcolor_rgb ()));
-  p.setColor (QPalette::WindowText,
-              Utils::fromRgb (pp.get_foregroundcolor_rgb ()));
-  p.setColor (QPalette::Light,
-              Utils::fromRgb (pp.get_highlightcolor_rgb ()));
-  p.setColor (QPalette::Dark,
-              Utils::fromRgb (pp.get_shadowcolor_rgb ()));
-}
+  static void
+  setupPalette (const uipanel::properties& pp, QPalette& p)
+  {
+    p.setColor (QPalette::Window,
+                Utils::fromRgb (pp.get_backgroundcolor_rgb ()));
+    p.setColor (QPalette::WindowText,
+                Utils::fromRgb (pp.get_foregroundcolor_rgb ()));
+    p.setColor (QPalette::Light,
+                Utils::fromRgb (pp.get_highlightcolor_rgb ()));
+    p.setColor (QPalette::Dark,
+                Utils::fromRgb (pp.get_shadowcolor_rgb ()));
+  }
 
-static int
-borderWidthFromProperties (const uipanel::properties& pp)
-{
-  int bw = 0;
+  static int
+  borderWidthFromProperties (const uipanel::properties& pp)
+  {
+    int bw = 0;
 
-  if (! pp.bordertype_is ("none"))
-    {
-      bw = octave::math::round (pp.get_borderwidth ());
-      if (pp.bordertype_is ("etchedin") || pp.bordertype_is ("etchedout"))
-        bw *= 2;
-    }
+    if (! pp.bordertype_is ("none"))
+      {
+        bw = octave::math::round (pp.get_borderwidth ());
+        if (pp.bordertype_is ("etchedin") || pp.bordertype_is ("etchedout"))
+          bw *= 2;
+      }
 
-  return bw;
-}
+    return bw;
+  }
 
-Panel*
-Panel::create (const graphics_object& go)
-{
-  Object* parent = Object::parentObject (go);
+  Panel*
+  Panel::create (const graphics_object& go)
+  {
+    Object* parent = Object::parentObject (go);
 
-  if (parent)
-    {
-      Container* container = parent->innerContainer ();
+    if (parent)
+      {
+        Container* container = parent->innerContainer ();
 
-      if (container)
-        return new Panel (go, new QFrame (container));
-    }
+        if (container)
+          return new Panel (go, new QFrame (container));
+      }
 
-  return 0;
-}
+    return 0;
+  }
 
-Panel::Panel (const graphics_object& go, QFrame* frame)
-  : Object (go, frame), m_container (0), m_title (0), m_blockUpdates (false)
-{
-  uipanel::properties& pp = properties<uipanel> ();
+  Panel::Panel (const graphics_object& go, QFrame* frame)
+    : Object (go, frame), m_container (0), m_title (0), m_blockUpdates (false)
+  {
+    uipanel::properties& pp = properties<uipanel> ();
 
-  frame->setObjectName ("UIPanel");
-  frame->setAutoFillBackground (true);
-  Matrix bb = pp.get_boundingbox (false);
-  frame->setGeometry (octave::math::round (bb(0)), octave::math::round (bb(1)),
-                      octave::math::round (bb(2)), octave::math::round (bb(3)));
-  frame->setFrameStyle (frameStyleFromProperties (pp));
-  frame->setLineWidth (octave::math::round (pp.get_borderwidth ()));
-  QPalette pal = frame->palette ();
-  setupPalette (pp, pal);
-  frame->setPalette (pal);
+    frame->setObjectName ("UIPanel");
+    frame->setAutoFillBackground (true);
+    Matrix bb = pp.get_boundingbox (false);
+    frame->setGeometry (octave::math::round (bb(0)), octave::math::round (bb(1)),
+                        octave::math::round (bb(2)), octave::math::round (bb(3)));
+    frame->setFrameStyle (frameStyleFromProperties (pp));
+    frame->setLineWidth (octave::math::round (pp.get_borderwidth ()));
+    QPalette pal = frame->palette ();
+    setupPalette (pp, pal);
+    frame->setPalette (pal);
 
-  m_container = new Container (frame);
-  m_container->canvas (m_handle);
+    m_container = new Container (frame);
+    m_container->canvas (m_handle);
 
-  if (frame->hasMouseTracking ())
-    {
-      foreach (QWidget* w, frame->findChildren<QWidget*> ())
+    if (frame->hasMouseTracking ())
+      {
+        foreach (QWidget* w, frame->findChildren<QWidget*> ())
         { w->setMouseTracking (true); }
-    }
+      }
 
-  QString title = Utils::fromStdString (pp.get_title ());
-  if (! title.isEmpty ())
-    {
-      m_title = new QLabel (title, frame);
-      m_title->setAutoFillBackground (true);
-      m_title->setContentsMargins (4, 0, 4, 0);
-      m_title->setPalette (pal);
-      m_title->setFont (Utils::computeFont<uipanel> (pp, bb(3)));
-    }
+    QString title = Utils::fromStdString (pp.get_title ());
+    if (! title.isEmpty ())
+      {
+        m_title = new QLabel (title, frame);
+        m_title->setAutoFillBackground (true);
+        m_title->setContentsMargins (4, 0, 4, 0);
+        m_title->setPalette (pal);
+        m_title->setFont (Utils::computeFont<uipanel> (pp, bb(3)));
+      }
 
-  frame->installEventFilter (this);
-  m_container->installEventFilter (this);
+    frame->installEventFilter (this);
+    m_container->installEventFilter (this);
 
-  if (pp.is_visible ())
-    QTimer::singleShot (0, frame, SLOT (show (void)));
-  else
-    frame->hide ();
-}
+    if (pp.is_visible ())
+      QTimer::singleShot (0, frame, SLOT (show (void)));
+    else
+      frame->hide ();
+  }
 
-Panel::~Panel (void)
-{
-}
+  Panel::~Panel (void)
+  {
+  }
 
-bool
-Panel::eventFilter (QObject* watched, QEvent* xevent)
-{
-  if (! m_blockUpdates)
-    {
-      if (watched == qObject ())
-        {
-          switch (xevent->type ())
-            {
-            case QEvent::Resize:
+  bool
+  Panel::eventFilter (QObject* watched, QEvent* xevent)
+  {
+    if (! m_blockUpdates)
+      {
+        if (watched == qObject ())
+          {
+            switch (xevent->type ())
+              {
+              case QEvent::Resize:
                 {
                   gh_manager::auto_lock lock;
                   graphics_object go = object ();
 
                   if (go.valid_object ())
                     {
                       if (m_title)
                         {
@@ -176,210 +176,213 @@ Panel::eventFilter (QObject* watched, QE
                               m_title->setFont (Utils::computeFont<uipanel>
                                                 (pp, frame->height ()));
                               m_title->resize (m_title->sizeHint ());
                             }
                         }
                       updateLayout ();
                     }
                 }
-              break;
+                break;
 
-            case QEvent::MouseButtonPress:
+              case QEvent::MouseButtonPress:
                 {
                   QMouseEvent* m = dynamic_cast<QMouseEvent*> (xevent);
 
                   if (m->button () == Qt::RightButton)
                     {
                       gh_manager::auto_lock lock;
 
                       graphics_object go = object ();
 
                       if (go.valid_object ())
                         ContextMenu::executeAt (go.get_properties (),
                                                 m->globalPos ());
                     }
                 }
-              break;
-
-            default:
-              break;
-            }
-        }
-      else if (watched == m_container)
-        {
-          switch (xevent->type ())
-            {
-            case QEvent::Resize:
-              if (qWidget<QWidget> ()->isVisible ())
-                {
-                  gh_manager::auto_lock lock;
-
-                  graphics_object go = object ();
-
-                  if (go.valid_object ())
-                    go.get_properties ().update_boundingbox ();
-                }
-              break;
-
-            default:
-              break;
-            }
-        }
-    }
-
-  return false;
-}
-
-void
-Panel::update (int pId)
-{
-  uipanel::properties& pp = properties<uipanel> ();
-  QFrame* frame = qWidget<QFrame> ();
-
-  m_blockUpdates = true;
-
-  switch (pId)
-    {
-    case uipanel::properties::ID_POSITION:
-      {
-        Matrix bb = pp.get_boundingbox (false);
+                break;
 
-        frame->setGeometry (octave::math::round (bb(0)), octave::math::round (bb(1)),
-                            octave::math::round (bb(2)), octave::math::round (bb(3)));
-        updateLayout ();
-      }
-      break;
-
-    case uipanel::properties::ID_BORDERWIDTH:
-      frame->setLineWidth (octave::math::round (pp.get_borderwidth ()));
-      updateLayout ();
-      break;
-
-    case uipanel::properties::ID_BACKGROUNDCOLOR:
-    case uipanel::properties::ID_FOREGROUNDCOLOR:
-    case uipanel::properties::ID_HIGHLIGHTCOLOR:
-    case uipanel::properties::ID_SHADOWCOLOR:
-      {
-        QPalette pal = frame->palette ();
-
-        setupPalette (pp, pal);
-        frame->setPalette (pal);
-        if (m_title)
-          m_title->setPalette (pal);
-      }
-      break;
+              default:
+                break;
+              }
+          }
+        else if (watched == m_container)
+          {
+            switch (xevent->type ())
+              {
+              case QEvent::Resize:
+                if (qWidget<QWidget> ()->isVisible ())
+                  {
+                    gh_manager::auto_lock lock;
 
-    case uipanel::properties::ID_TITLE:
-      {
-        QString title = Utils::fromStdString (pp.get_title ());
+                    graphics_object go = object ();
 
-        if (title.isEmpty ())
-          {
-            if (m_title)
-              delete m_title;
-            m_title = 0;
-          }
-        else
-          {
-            if (! m_title)
-              {
-                QPalette pal = frame->palette ();
+                    if (go.valid_object ())
+                      go.get_properties ().update_boundingbox ();
+                  }
+                break;
 
-                m_title = new QLabel (title, frame);
-                m_title->setAutoFillBackground (true);
-                m_title->setContentsMargins (4, 0, 4, 0);
-                m_title->setPalette (pal);
-                m_title->setFont (Utils::computeFont<uipanel> (pp));
-                m_title->show ();
-              }
-            else
-              {
-                m_title->setText (title);
-                m_title->resize (m_title->sizeHint ());
+              default:
+                break;
               }
           }
-        updateLayout ();
       }
-      break;
+
+    return false;
+  }
+
+  void
+  Panel::update (int pId)
+  {
+    uipanel::properties& pp = properties<uipanel> ();
+    QFrame* frame = qWidget<QFrame> ();
+
+    m_blockUpdates = true;
 
-    case uipanel::properties::ID_TITLEPOSITION:
-      updateLayout ();
-      break;
+    switch (pId)
+      {
+      case uipanel::properties::ID_POSITION:
+        {
+          Matrix bb = pp.get_boundingbox (false);
+
+          frame->setGeometry (octave::math::round (bb(0)), octave::math::round (bb(1)),
+                              octave::math::round (bb(2)), octave::math::round (bb(3)));
+          updateLayout ();
+        }
+        break;
+
+      case uipanel::properties::ID_BORDERWIDTH:
+        frame->setLineWidth (octave::math::round (pp.get_borderwidth ()));
+        updateLayout ();
+        break;
+
+      case uipanel::properties::ID_BACKGROUNDCOLOR:
+      case uipanel::properties::ID_FOREGROUNDCOLOR:
+      case uipanel::properties::ID_HIGHLIGHTCOLOR:
+      case uipanel::properties::ID_SHADOWCOLOR:
+        {
+          QPalette pal = frame->palette ();
 
-    case uipanel::properties::ID_BORDERTYPE:
-      frame->setFrameStyle (frameStyleFromProperties (pp));
-      updateLayout ();
-      break;
+          setupPalette (pp, pal);
+          frame->setPalette (pal);
+          if (m_title)
+            m_title->setPalette (pal);
+        }
+        break;
+
+      case uipanel::properties::ID_TITLE:
+        {
+          QString title = Utils::fromStdString (pp.get_title ());
 
-    case uipanel::properties::ID_FONTNAME:
-    case uipanel::properties::ID_FONTSIZE:
-    case uipanel::properties::ID_FONTWEIGHT:
-    case uipanel::properties::ID_FONTANGLE:
-      if (m_title)
-        {
-          m_title->setFont (Utils::computeFont<uipanel> (pp));
-          m_title->resize (m_title->sizeHint ());
+          if (title.isEmpty ())
+            {
+              if (m_title)
+                delete m_title;
+              m_title = 0;
+            }
+          else
+            {
+              if (! m_title)
+                {
+                  QPalette pal = frame->palette ();
+
+                  m_title = new QLabel (title, frame);
+                  m_title->setAutoFillBackground (true);
+                  m_title->setContentsMargins (4, 0, 4, 0);
+                  m_title->setPalette (pal);
+                  m_title->setFont (Utils::computeFont<uipanel> (pp));
+                  m_title->show ();
+                }
+              else
+                {
+                  m_title->setText (title);
+                  m_title->resize (m_title->sizeHint ());
+                }
+            }
           updateLayout ();
         }
-      break;
-
-    case uipanel::properties::ID_VISIBLE:
-      frame->setVisible (pp.is_visible ());
-      updateLayout ();
-      break;
+        break;
 
-    default:
-      break;
-    }
+      case uipanel::properties::ID_TITLEPOSITION:
+        updateLayout ();
+        break;
 
-  m_blockUpdates = false;
-}
+      case uipanel::properties::ID_BORDERTYPE:
+        frame->setFrameStyle (frameStyleFromProperties (pp));
+        updateLayout ();
+        break;
 
-void
-Panel::redraw (void)
-{
-  Canvas* canvas = m_container->canvas (m_handle);
+      case uipanel::properties::ID_FONTNAME:
+      case uipanel::properties::ID_FONTSIZE:
+      case uipanel::properties::ID_FONTWEIGHT:
+      case uipanel::properties::ID_FONTANGLE:
+        if (m_title)
+          {
+            m_title->setFont (Utils::computeFont<uipanel> (pp));
+            m_title->resize (m_title->sizeHint ());
+            updateLayout ();
+          }
+        break;
 
-  if (canvas)
-    canvas->redraw ();
-}
+      case uipanel::properties::ID_VISIBLE:
+        frame->setVisible (pp.is_visible ());
+        updateLayout ();
+        break;
 
-void
-Panel::updateLayout (void)
-{
-  uipanel::properties& pp = properties<uipanel> ();
-  QFrame* frame = qWidget<QFrame> ();
+      default:
+        break;
+      }
+
+    m_blockUpdates = false;
+  }
+
+  void
+  Panel::redraw (void)
+  {
+    Canvas* canvas = m_container->canvas (m_handle);
 
-  Matrix bb = pp.get_boundingbox (true);
-  int bw = borderWidthFromProperties (pp);
+    if (canvas)
+      canvas->redraw ();
+  }
 
-  frame->setFrameRect (QRect (octave::math::round (bb(0)) - bw, octave::math::round (bb(1)) - bw,
-                              octave::math::round (bb(2)) + 2*bw, octave::math::round (bb(3)) + 2*bw));
-  m_container->setGeometry (octave::math::round (bb(0)), octave::math::round (bb(1)),
-                            octave::math::round (bb(2)), octave::math::round (bb(3)));
+  void
+  Panel::updateLayout (void)
+  {
+    uipanel::properties& pp = properties<uipanel> ();
+    QFrame* frame = qWidget<QFrame> ();
 
-  if (m_blockUpdates)
-    pp.update_boundingbox ();
+    Matrix bb = pp.get_boundingbox (true);
+    int bw = borderWidthFromProperties (pp);
 
-  if (m_title)
-    {
-      QSize sz = m_title->sizeHint ();
-      int offset = 5;
+    frame->setFrameRect (QRect (octave::math::round (bb(0)) - bw,
+                                octave::math::round (bb(1)) - bw,
+                                octave::math::round (bb(2)) + 2*bw, octave::math::round (bb(3)) + 2*bw));
+    m_container->setGeometry (octave::math::round (bb(0)),
+                              octave::math::round (bb(1)),
+                              octave::math::round (bb(2)), octave::math::round (bb(3)));
 
-      if (pp.titleposition_is ("lefttop"))
-        m_title->move (bw+offset, 0);
-      else if (pp.titleposition_is ("righttop"))
-        m_title->move (frame->width () - bw - offset - sz.width (), 0);
-      else if (pp.titleposition_is ("leftbottom"))
-        m_title->move (bw+offset, frame->height () - sz.height ());
-      else if (pp.titleposition_is ("rightbottom"))
-        m_title->move (frame->width () - bw - offset - sz.width (),
-                       frame->height () - sz.height ());
-      else if (pp.titleposition_is ("centertop"))
-        m_title->move (frame->width () / 2 - sz.width () / 2, 0);
-      else if (pp.titleposition_is ("centerbottom"))
-        m_title->move (frame->width () / 2 - sz.width () / 2,
-                       frame->height () - sz.height ());
-    }
-}
+    if (m_blockUpdates)
+      pp.update_boundingbox ();
+
+    if (m_title)
+      {
+        QSize sz = m_title->sizeHint ();
+        int offset = 5;
+
+        if (pp.titleposition_is ("lefttop"))
+          m_title->move (bw+offset, 0);
+        else if (pp.titleposition_is ("righttop"))
+          m_title->move (frame->width () - bw - offset - sz.width (), 0);
+        else if (pp.titleposition_is ("leftbottom"))
+          m_title->move (bw+offset, frame->height () - sz.height ());
+        else if (pp.titleposition_is ("rightbottom"))
+          m_title->move (frame->width () - bw - offset - sz.width (),
+                         frame->height () - sz.height ());
+        else if (pp.titleposition_is ("centertop"))
+          m_title->move (frame->width () / 2 - sz.width () / 2, 0);
+        else if (pp.titleposition_is ("centerbottom"))
+          m_title->move (frame->width () / 2 - sz.width () / 2,
+                         frame->height () - sz.height ());
+      }
+  }
 
 };
+
diff --git a/libgui/graphics/Panel.h b/libgui/graphics/Panel.h
--- a/libgui/graphics/Panel.h
+++ b/libgui/graphics/Panel.h
@@ -26,38 +26,39 @@ along with Octave; see the file COPYING.
 #include "Object.h"
 
 class QFrame;
 class QLabel;
 
 namespace QtHandles
 {
 
-class Container;
+  class Container;
 
-class Panel : public Object
-{
-public:
-  Panel (const graphics_object& go, QFrame* frame);
-  ~Panel (void);
+  class Panel : public Object
+  {
+  public:
+    Panel (const graphics_object& go, QFrame* frame);
+    ~Panel (void);
 
-  Container* innerContainer (void) { return m_container; }
+    Container* innerContainer (void) { return m_container; }
 
-  bool eventFilter (QObject* watched, QEvent* event);
+    bool eventFilter (QObject* watched, QEvent* event);
 
-  static Panel* create (const graphics_object& go);
+    static Panel* create (const graphics_object& go);
 
-protected:
-  void update (int pId);
-  void redraw (void);
+  protected:
+    void update (int pId);
+    void redraw (void);
 
-private:
-  void updateLayout (void);
+  private:
+    void updateLayout (void);
 
-private:
-  Container* m_container;
-  QLabel* m_title;
-  bool m_blockUpdates;
-};
+  private:
+    Container* m_container;
+    QLabel* m_title;
+    bool m_blockUpdates;
+  };
 
 }; // namespace QtHandles
 
 #endif
+
diff --git a/libgui/graphics/PopupMenuControl.cc b/libgui/graphics/PopupMenuControl.cc
--- a/libgui/graphics/PopupMenuControl.cc
+++ b/libgui/graphics/PopupMenuControl.cc
@@ -28,58 +28,58 @@ along with Octave; see the file COPYING.
 
 #include "Container.h"
 #include "PopupMenuControl.h"
 #include "QtHandlesUtils.h"
 
 namespace QtHandles
 {
 
-PopupMenuControl*
-PopupMenuControl::create (const graphics_object& go)
-{
-  Object* parent = Object::parentObject (go);
+  PopupMenuControl*
+  PopupMenuControl::create (const graphics_object& go)
+  {
+    Object* parent = Object::parentObject (go);
 
-  if (parent)
-    {
-      Container* container = parent->innerContainer ();
+    if (parent)
+      {
+        Container* container = parent->innerContainer ();
 
-      if (container)
-        return new PopupMenuControl (go, new QComboBox (container));
-    }
+        if (container)
+          return new PopupMenuControl (go, new QComboBox (container));
+      }
 
-  return 0;
-}
+    return 0;
+  }
 
-PopupMenuControl::PopupMenuControl (const graphics_object& go, QComboBox *box)
-  : BaseControl (go, box), m_blockUpdate (false)
-{
-  uicontrol::properties& up = properties<uicontrol> ();
+  PopupMenuControl::PopupMenuControl (const graphics_object& go, QComboBox *box)
+    : BaseControl (go, box), m_blockUpdate (false)
+  {
+    uicontrol::properties& up = properties<uicontrol> ();
 
-  box->addItems (Utils::fromStdString (up.get_string_string ()).split ('|'));
+    box->addItems (Utils::fromStdString (up.get_string_string ()).split ('|'));
 
-  update (uicontrol::properties::ID_VALUE);
+    update (uicontrol::properties::ID_VALUE);
 
-  connect (box, SIGNAL (currentIndexChanged (int)),
-           SLOT (currentIndexChanged (int)));
-}
+    connect (box, SIGNAL (currentIndexChanged (int)),
+             SLOT (currentIndexChanged (int)));
+  }
 
-PopupMenuControl::~PopupMenuControl (void)
-{
-}
+  PopupMenuControl::~PopupMenuControl (void)
+  {
+  }
 
-void PopupMenuControl::update (int pId)
-{
-  uicontrol::properties& up = properties<uicontrol> ();
-  QComboBox* box = qWidget<QComboBox> ();
+  void PopupMenuControl::update (int pId)
+  {
+    uicontrol::properties& up = properties<uicontrol> ();
+    QComboBox* box = qWidget<QComboBox> ();
 
-  switch (pId)
-    {
-    case uicontrol::properties::ID_STRING:
-      m_blockUpdate = true;
+    switch (pId)
+      {
+      case uicontrol::properties::ID_STRING:
+        m_blockUpdate = true;
         {
           int oldCurrent = box->currentIndex ();
 
           box->clear ();
           box->addItems (Utils::fromStdString
                          (up.get_string_string ()).split ('|'));
           if (box->count() > 0
               && oldCurrent >= 0
@@ -90,21 +90,21 @@ void PopupMenuControl::update (int pId)
           else
             {
               gh_manager::post_set (m_handle, "value",
                                     octave_value (box->count () > 0
                                                   ? 1.0 : 0.0),
                                     false);
             }
         }
-      m_blockUpdate = false;
-      break;
+        m_blockUpdate = false;
+        break;
 
-    case uicontrol::properties::ID_VALUE:
-      m_blockUpdate = true;
+      case uicontrol::properties::ID_VALUE:
+        m_blockUpdate = true;
         {
           Matrix value = up.get_value ().matrix_value ();
 
           if (value.numel () > 0)
             {
               if (value(0) != static_cast<int>(value(0)))
                 warning ("popupmenu value should be integer");
               else
@@ -116,30 +116,31 @@ void PopupMenuControl::update (int pId)
                       if (newIndex != box->currentIndex ())
                         box->setCurrentIndex (newIndex);
                     }
                   else
                     warning ("popupmenu value not within valid display range");
                 }
             }
         }
-      m_blockUpdate = false;
-      break;
+        m_blockUpdate = false;
+        break;
 
-    default:
-      BaseControl::update (pId);
-      break;
-    }
-}
+      default:
+        BaseControl::update (pId);
+        break;
+      }
+  }
 
-void
-PopupMenuControl::currentIndexChanged (int index)
-{
-  if (! m_blockUpdate)
-    {
-      gh_manager::post_set (m_handle, "value",
-                            octave_value (double (index + 1)),
-                            false);
-      gh_manager::post_callback (m_handle, "callback");
-    }
-}
+  void
+  PopupMenuControl::currentIndexChanged (int index)
+  {
+    if (! m_blockUpdate)
+      {
+        gh_manager::post_set (m_handle, "value",
+                              octave_value (double (index + 1)),
+                              false);
+        gh_manager::post_callback (m_handle, "callback");
+      }
+  }
 
 }; // namespace QtHandles
+
diff --git a/libgui/graphics/PopupMenuControl.h b/libgui/graphics/PopupMenuControl.h
--- a/libgui/graphics/PopupMenuControl.h
+++ b/libgui/graphics/PopupMenuControl.h
@@ -25,31 +25,32 @@ along with Octave; see the file COPYING.
 
 #include "BaseControl.h"
 
 class QComboBox;
 
 namespace QtHandles
 {
 
-class PopupMenuControl : public BaseControl
-{
-  Q_OBJECT
+  class PopupMenuControl : public BaseControl
+  {
+    Q_OBJECT
 
-public:
-  PopupMenuControl (const graphics_object& go, QComboBox* box);
-  ~PopupMenuControl (void);
+  public:
+    PopupMenuControl (const graphics_object& go, QComboBox* box);
+    ~PopupMenuControl (void);
 
-  static PopupMenuControl* create (const graphics_object& go);
+    static PopupMenuControl* create (const graphics_object& go);
 
-protected:
-  void update (int pId);
+  protected:
+    void update (int pId);
 
-private slots:
-  void currentIndexChanged (int index);
+  private slots:
+    void currentIndexChanged (int index);
 
-private:
-  bool m_blockUpdate;
-};
+  private:
+    bool m_blockUpdate;
+  };
 
 }; // namespace QtHandles
 
 #endif
+
diff --git a/libgui/graphics/PushButtonControl.cc b/libgui/graphics/PushButtonControl.cc
--- a/libgui/graphics/PushButtonControl.cc
+++ b/libgui/graphics/PushButtonControl.cc
@@ -29,54 +29,55 @@ along with Octave; see the file COPYING.
 
 #include "PushButtonControl.h"
 #include "Container.h"
 #include "QtHandlesUtils.h"
 
 namespace QtHandles
 {
 
-PushButtonControl*
-PushButtonControl::create (const graphics_object& go)
-{
-  Object* parent = Object::parentObject (go);
+  PushButtonControl*
+  PushButtonControl::create (const graphics_object& go)
+  {
+    Object* parent = Object::parentObject (go);
 
-  if (parent)
-    {
-      Container* container = parent->innerContainer ();
+    if (parent)
+      {
+        Container* container = parent->innerContainer ();
 
-      if (container)
-        return new PushButtonControl (go, new QPushButton (container));
-    }
+        if (container)
+          return new PushButtonControl (go, new QPushButton (container));
+      }
 
-  return 0;
-}
+    return 0;
+  }
 
-PushButtonControl::PushButtonControl (const graphics_object& go,
-                                      QPushButton* btn)
-  : ButtonControl (go, btn)
-{
-  btn->setAutoFillBackground (true);
-}
+  PushButtonControl::PushButtonControl (const graphics_object& go,
+                                        QPushButton* btn)
+    : ButtonControl (go, btn)
+  {
+    btn->setAutoFillBackground (true);
+  }
 
-PushButtonControl::~PushButtonControl (void)
-{
-}
+  PushButtonControl::~PushButtonControl (void)
+  {
+  }
 
-void
-PushButtonControl::update (int pId)
-{
-  uicontrol::properties& up = properties<uicontrol> ();
-  QPushButton* btn = qWidget<QPushButton> ();
+  void
+  PushButtonControl::update (int pId)
+  {
+    uicontrol::properties& up = properties<uicontrol> ();
+    QPushButton* btn = qWidget<QPushButton> ();
 
-  switch (pId)
-    {
-    case uicontrol::properties::ID_STRING:
-      btn->setText (Utils::fromStdString (up.get_string_string ()));
-      break;
+    switch (pId)
+      {
+      case uicontrol::properties::ID_STRING:
+        btn->setText (Utils::fromStdString (up.get_string_string ()));
+        break;
 
-    default:
-      BaseControl::update (pId);
-      break;
-    }
-}
+      default:
+        BaseControl::update (pId);
+        break;
+      }
+  }
 
 }; // namespave QtHandles
+
diff --git a/libgui/graphics/PushButtonControl.h b/libgui/graphics/PushButtonControl.h
--- a/libgui/graphics/PushButtonControl.h
+++ b/libgui/graphics/PushButtonControl.h
@@ -25,23 +25,24 @@ along with Octave; see the file COPYING.
 
 #include "ButtonControl.h"
 
 class QPushButton;
 
 namespace QtHandles
 {
 
-class PushButtonControl : public ButtonControl
-{
-public:
-  PushButtonControl (const graphics_object& go, QPushButton* btn);
-  ~PushButtonControl (void);
+  class PushButtonControl : public ButtonControl
+  {
+  public:
+    PushButtonControl (const graphics_object& go, QPushButton* btn);
+    ~PushButtonControl (void);
 
-  static PushButtonControl* create (const graphics_object& go);
+    static PushButtonControl* create (const graphics_object& go);
 
-protected:
-  void update (int pId);
-};
+  protected:
+    void update (int pId);
+  };
 
 }; // namespace QtHandles
 
 #endif
+
diff --git a/libgui/graphics/PushTool.cc b/libgui/graphics/PushTool.cc
--- a/libgui/graphics/PushTool.cc
+++ b/libgui/graphics/PushTool.cc
@@ -26,52 +26,53 @@ along with Octave; see the file COPYING.
 
 #include "PushTool.h"
 
 #include "ToolBarButton.cc"
 
 namespace QtHandles
 {
 
-PushTool*
-PushTool::create (const graphics_object& go)
-{
-  Object* parent = Object::parentObject (go);
+  PushTool*
+  PushTool::create (const graphics_object& go)
+  {
+    Object* parent = Object::parentObject (go);
 
-  if (parent)
-    {
-      QWidget* parentWidget = parent->qWidget<QWidget> ();
+    if (parent)
+      {
+        QWidget* parentWidget = parent->qWidget<QWidget> ();
 
-      if (parentWidget)
-        return new PushTool (go, new QAction (parentWidget));
-    }
+        if (parentWidget)
+          return new PushTool (go, new QAction (parentWidget));
+      }
 
-  return 0;
-}
+    return 0;
+  }
 
-PushTool::PushTool (const graphics_object& go, QAction* action)
-  : ToolBarButton<uipushtool> (go, action)
-{
-  connect (action, SIGNAL (triggered (bool)), this, SLOT (clicked (void)));
-}
+  PushTool::PushTool (const graphics_object& go, QAction* action)
+    : ToolBarButton<uipushtool> (go, action)
+  {
+    connect (action, SIGNAL (triggered (bool)), this, SLOT (clicked (void)));
+  }
 
-PushTool::~PushTool (void)
-{
-}
+  PushTool::~PushTool (void)
+  {
+  }
 
-void
-PushTool::update (int pId)
-{
-  switch (pId)
-    {
-    default:
-      ToolBarButton<uipushtool>::update (pId);
-      break;
-    }
-}
+  void
+  PushTool::update (int pId)
+  {
+    switch (pId)
+      {
+      default:
+        ToolBarButton<uipushtool>::update (pId);
+        break;
+      }
+  }
 
-void
-PushTool::clicked (void)
-{
-  gh_manager::post_callback (m_handle, "clickedcallback");
-}
+  void
+  PushTool::clicked (void)
+  {
+    gh_manager::post_callback (m_handle, "clickedcallback");
+  }
 
 };
+
diff --git a/libgui/graphics/PushTool.h b/libgui/graphics/PushTool.h
--- a/libgui/graphics/PushTool.h
+++ b/libgui/graphics/PushTool.h
@@ -23,28 +23,29 @@ along with Octave; see the file COPYING.
 #if ! defined (octave_PushTool_h)
 #define octave_PushTool_h 1
 
 #include "ToolBarButton.h"
 
 namespace QtHandles
 {
 
-class PushTool : public ToolBarButton<uipushtool>
-{
-  Q_OBJECT
+  class PushTool : public ToolBarButton<uipushtool>
+  {
+    Q_OBJECT
 
-public:
-  PushTool (const graphics_object& go, QAction* action);
-  ~PushTool (void);
+  public:
+    PushTool (const graphics_object& go, QAction* action);
+    ~PushTool (void);
 
-  static PushTool* create (const graphics_object& go);
+    static PushTool* create (const graphics_object& go);
 
-protected:
-  void update (int pId);
+  protected:
+    void update (int pId);
 
-private slots:
-  void clicked (void);
-};
+  private slots:
+    void clicked (void);
+  };
 
 }; // namespace QtHandles
 
 #endif
+
diff --git a/libgui/graphics/QtHandlesUtils.cc b/libgui/graphics/QtHandlesUtils.cc
--- a/libgui/graphics/QtHandlesUtils.cc
+++ b/libgui/graphics/QtHandlesUtils.cc
@@ -39,350 +39,354 @@ along with Octave; see the file COPYING.
 #include "Object.h"
 #include "QtHandlesUtils.h"
 
 #include "oct-string.h"
 
 namespace QtHandles
 {
 
-namespace Utils
-{
+  namespace Utils
+  {
 
-QString
-fromStdString (const std::string& s)
-{
-  return QString::fromLocal8Bit (s.c_str ());
-}
-
-std::string
-toStdString (const QString& s)
-{
-  return std::string (s.toLocal8Bit ().data ());
-}
+    QString
+    fromStdString (const std::string& s)
+    {
+      return QString::fromLocal8Bit (s.c_str ());
+    }
 
-QStringList
-fromStringVector (const string_vector& v)
-{
-  QStringList l;
-  octave_idx_type n = v.numel ();
-
-  for (octave_idx_type i = 0; i < n; i++)
-    l << fromStdString (v[i]);
-
-  return l;
-}
+    std::string
+    toStdString (const QString& s)
+    {
+      return std::string (s.toLocal8Bit ().data ());
+    }
 
-string_vector
-toStringVector (const QStringList& l)
-{
-  string_vector v (l.length ());
-  int i = 0;
+    QStringList
+    fromStringVector (const string_vector& v)
+    {
+      QStringList l;
+      octave_idx_type n = v.numel ();
 
-  foreach (const QString& s, l)
-    v[i++] = toStdString (s);
+      for (octave_idx_type i = 0; i < n; i++)
+        l << fromStdString (v[i]);
 
-  return v;
-}
+      return l;
+    }
 
-Cell toCellString (const QStringList& l)
-{
-  QStringList tmp = l;
-
-  // don't get any empty lines from end of the list
-  while ((tmp.length () > 0) && tmp.last ().isEmpty ())
+    string_vector
+    toStringVector (const QStringList& l)
     {
-      tmp.removeLast ();
+      string_vector v (l.length ());
+      int i = 0;
+
+      foreach (const QString& s, l)
+      v[i++] = toStdString (s);
+
+      return v;
     }
-  // no strings converts to a 1x1 cell with empty string
-  if (tmp.isEmpty ())
-    tmp += "";
-
-  Cell v(toStringVector (tmp));
-  return v;
-}
 
-template <typename T>
-QFont
-computeFont (const typename T::properties& props, int height)
-{
-  QFont f (fromStdString (props.get_fontname ()));
-
-  static std::map<std::string, QFont::Weight> weightMap;
-  static std::map<std::string, QFont::Style> angleMap;
-  static bool mapsInitialized = false;
+    Cell toCellString (const QStringList& l)
+    {
+      QStringList tmp = l;
 
-  if (! mapsInitialized)
-    {
-      weightMap[std::string ("normal")] = QFont::Normal;
-      weightMap[std::string ("light")] = QFont::Light;
-      weightMap[std::string ("demi")] = QFont::DemiBold;
-      weightMap[std::string ("bold")] = QFont::Normal;
+      // don't get any empty lines from end of the list
+      while ((tmp.length () > 0) && tmp.last ().isEmpty ())
+        {
+          tmp.removeLast ();
+        }
+      // no strings converts to a 1x1 cell with empty string
+      if (tmp.isEmpty ())
+        tmp += "";
 
-      angleMap[std::string ("normal")] = QFont::StyleNormal;
-      angleMap[std::string ("italic")] = QFont::StyleItalic;
-      angleMap[std::string ("oblique")] = QFont::StyleOblique;
-
-      mapsInitialized = true;
+      Cell v(toStringVector (tmp));
+      return v;
     }
 
-  f.setPointSizeF (props.get_fontsize_points (height));
-  f.setWeight (weightMap[props.get_fontweight ()]);
-  f.setStyle (angleMap[props.get_fontangle ()]);
+    template <typename T>
+    QFont
+    computeFont (const typename T::properties& props, int height)
+    {
+      QFont f (fromStdString (props.get_fontname ()));
 
-  return f;
-}
+      static std::map<std::string, QFont::Weight> weightMap;
+      static std::map<std::string, QFont::Style> angleMap;
+      static bool mapsInitialized = false;
 
-template QFont computeFont<uicontrol> (const uicontrol::properties& props,
-                                       int height);
+      if (! mapsInitialized)
+        {
+          weightMap[std::string ("normal")] = QFont::Normal;
+          weightMap[std::string ("light")] = QFont::Light;
+          weightMap[std::string ("demi")] = QFont::DemiBold;
+          weightMap[std::string ("bold")] = QFont::Normal;
+
+          angleMap[std::string ("normal")] = QFont::StyleNormal;
+          angleMap[std::string ("italic")] = QFont::StyleItalic;
+          angleMap[std::string ("oblique")] = QFont::StyleOblique;
 
-template QFont computeFont<uipanel> (const uipanel::properties& props,
-                                     int height);
+          mapsInitialized = true;
+        }
 
-template QFont computeFont<uibuttongroup> (const uibuttongroup::properties& props,
+      f.setPointSizeF (props.get_fontsize_points (height));
+      f.setWeight (weightMap[props.get_fontweight ()]);
+      f.setStyle (angleMap[props.get_fontangle ()]);
+
+      return f;
+    }
+
+    template QFont computeFont<uicontrol> (const uicontrol::properties& props,
                                            int height);
-QColor
-fromRgb (const Matrix& rgb)
-{
-  QColor c;
 
-  if (rgb.numel () == 3)
-    c.setRgbF (rgb(0), rgb(1), rgb(2));
+    template QFont computeFont<uipanel> (const uipanel::properties& props,
+                                         int height);
 
-  return c;
-}
+    template QFont computeFont<uibuttongroup> (const uibuttongroup::properties&
+        props,
+        int height);
+    QColor
+    fromRgb (const Matrix& rgb)
+    {
+      QColor c;
 
-Matrix
-toRgb (const QColor& c)
-{
-  Matrix rgb (1, 3);
-  double* rgbData = rgb.fortran_vec ();
+      if (rgb.numel () == 3)
+        c.setRgbF (rgb(0), rgb(1), rgb(2));
 
-  // qreal is a typedef for double except for ARM CPU architectures
-  // where it is a typedef for float (Bug #44970).
-  qreal tmp[3];
-  c.getRgbF (tmp, tmp+1, tmp+2);
-  rgbData[0] = tmp[0]; rgbData[1] = tmp[1]; rgbData[2] = tmp[2];
+      return c;
+    }
 
-  return rgb;
-}
+    Matrix
+    toRgb (const QColor& c)
+    {
+      Matrix rgb (1, 3);
+      double* rgbData = rgb.fortran_vec ();
 
-std::string
-figureSelectionType (QMouseEvent* event, bool isDoubleClick)
-{
-  if (isDoubleClick)
-    return std::string ("open");
-  else
-    {
-      Qt::MouseButtons buttons = event->buttons ();
-      Qt::KeyboardModifiers mods = event->modifiers ();
+      // qreal is a typedef for double except for ARM CPU architectures
+      // where it is a typedef for float (Bug #44970).
+      qreal tmp[3];
+      c.getRgbF (tmp, tmp+1, tmp+2);
+      rgbData[0] = tmp[0]; rgbData[1] = tmp[1]; rgbData[2] = tmp[2];
+
+      return rgb;
+    }
 
-      if (mods == Qt::NoModifier)
+    std::string
+    figureSelectionType (QMouseEvent* event, bool isDoubleClick)
+    {
+      if (isDoubleClick)
+        return std::string ("open");
+      else
         {
-          if (buttons == Qt::LeftButton)
-            return std::string ("normal");
-          else if (buttons == Qt::RightButton)
-            return std::string ("alt");
+          Qt::MouseButtons buttons = event->buttons ();
+          Qt::KeyboardModifiers mods = event->modifiers ();
+
+          if (mods == Qt::NoModifier)
+            {
+              if (buttons == Qt::LeftButton)
+                return std::string ("normal");
+              else if (buttons == Qt::RightButton)
+                return std::string ("alt");
 #if defined (Q_WS_WIN)
-          else if (buttons == (Qt::LeftButton | Qt::RightButton))
-            return std::string ("extend");
+              else if (buttons == (Qt::LeftButton | Qt::RightButton))
+                return std::string ("extend");
 #elif defined (Q_WS_X11)
-          else if (buttons == Qt::MidButton)
-            return std::string ("extend");
+              else if (buttons == Qt::MidButton)
+                return std::string ("extend");
 #endif
+            }
+          else if (buttons == Qt::LeftButton)
+            {
+              if (mods == Qt::ShiftModifier)
+                return std::string ("extend");
+              else if (mods == Qt::ControlModifier)
+                return std::string ("alt");
+            }
         }
-      else if (buttons == Qt::LeftButton)
-        {
-          if (mods == Qt::ShiftModifier)
-            return std::string ("extend");
-          else if (mods == Qt::ControlModifier)
-            return std::string ("alt");
-        }
+
+      return std::string ("normal");
     }
 
-  return std::string ("normal");
-}
+    /*
+       Two figureCurrentPoint() routines are required:
+       1) Used for QMouseEvents where cursor position data is in callback from Qt.
+       2) Used for QKeyEvents where cursor position must be determined.
+    */
+    Matrix
+    figureCurrentPoint (const graphics_object& fig, QMouseEvent* event)
+    {
+      Object* tkFig = Backend::toolkitObject (fig);
 
-/*
-   Two figureCurrentPoint() routines are required:
-   1) Used for QMouseEvents where cursor position data is in callback from Qt.
-   2) Used for QKeyEvents where cursor position must be determined.
-*/
-Matrix
-figureCurrentPoint (const graphics_object& fig, QMouseEvent* event)
-{
-  Object* tkFig = Backend::toolkitObject (fig);
+      if (tkFig)
+        {
+          Container* c = tkFig->innerContainer ();
 
-  if (tkFig)
-    {
-      Container* c = tkFig->innerContainer ();
+          if (c)
+            {
+              QPoint qp = c->mapFromGlobal (event->globalPos ());
 
-      if (c)
-        {
-          QPoint qp = c->mapFromGlobal (event->globalPos ());
+              return tkFig->properties<figure> ().map_from_boundingbox (qp.x (),
+                     qp.y ());
+            }
+        }
 
-          return tkFig->properties<figure> ().map_from_boundingbox (qp.x (),
-                                                                    qp.y ());
-        }
+      return Matrix (1, 2, 0.0);
     }
 
-  return Matrix (1, 2, 0.0);
-}
-
-Matrix
-figureCurrentPoint (const graphics_object& fig)
-{
-  Object* tkFig = Backend::toolkitObject (fig);
-
-  if (tkFig)
+    Matrix
+    figureCurrentPoint (const graphics_object& fig)
     {
-      Container* c = tkFig->innerContainer ();
+      Object* tkFig = Backend::toolkitObject (fig);
 
-      if (c)
+      if (tkFig)
         {
-          // FIXME: QCursor::pos() may give inaccurate results with asynchronous
-          //        window systems like X11 over ssh.
-          QPoint qp = c->mapFromGlobal (QCursor::pos ());
+          Container* c = tkFig->innerContainer ();
+
+          if (c)
+            {
+              // FIXME: QCursor::pos() may give inaccurate results with asynchronous
+              //        window systems like X11 over ssh.
+              QPoint qp = c->mapFromGlobal (QCursor::pos ());
+
+              return tkFig->properties<figure> ().map_from_boundingbox (qp.x (),
+                     qp.y ());
+            }
+        }
+
+      return Matrix (1, 2, 0.0);
+    }
 
-          return tkFig->properties<figure> ().map_from_boundingbox (qp.x (),
-                                                                    qp.y ());
-        }
+    Qt::Alignment
+    fromHVAlign (const std::string& halign, const std::string& valign)
+    {
+      Qt::Alignment flags;
+
+      if (octave::string::strcmpi (halign, "left"))
+        flags |= Qt::AlignLeft;
+      else if (octave::string::strcmpi (halign, "center"))
+        flags |= Qt::AlignHCenter;
+      else if (octave::string::strcmpi (halign, "right"))
+        flags |= Qt::AlignRight;
+      else
+        flags |= Qt::AlignLeft;
+
+      if (octave::string::strcmpi (valign, "middle"))
+        flags |= Qt::AlignVCenter;
+      else if (octave::string::strcmpi (valign, "top"))
+        flags |= Qt::AlignTop;
+      else if (octave::string::strcmpi (valign, "bottom"))
+        flags |= Qt::AlignBottom;
+      else
+        flags |= Qt::AlignVCenter;
+
+      return flags;
     }
 
-  return Matrix (1, 2, 0.0);
-}
-
-Qt::Alignment
-fromHVAlign (const std::string& halign, const std::string& valign)
-{
-  Qt::Alignment flags;
+    QImage
+    makeImageFromCData (const octave_value& v, int width, int height)
+    {
+      dim_vector dv (v.dims ());
 
-  if (octave::string::strcmpi (halign, "left"))
-    flags |= Qt::AlignLeft;
-  else if (octave::string::strcmpi (halign, "center"))
-    flags |= Qt::AlignHCenter;
-  else if (octave::string::strcmpi (halign, "right"))
-    flags |= Qt::AlignRight;
-  else
-    flags |= Qt::AlignLeft;
+      if (dv.ndims () == 3 && dv(2) == 3)
+        {
+          int w = qMin (dv(1), static_cast<octave_idx_type> (width));
+          int h = qMin (dv(0), static_cast<octave_idx_type> (height));
+
+          int x_off = (w < width ? (width - w) / 2 : 0);
+          int y_off = (h < height ? (height - h) / 2 : 0);
+
+          QImage img (width, height, QImage::Format_ARGB32);
+          img.fill (qRgba (0, 0, 0, 0));
 
-  if (octave::string::strcmpi (valign, "middle"))
-    flags |= Qt::AlignVCenter;
-  else if (octave::string::strcmpi (valign, "top"))
-    flags |= Qt::AlignTop;
-  else if (octave::string::strcmpi (valign, "bottom"))
-    flags |= Qt::AlignBottom;
-  else
-    flags |= Qt::AlignVCenter;
-
-  return flags;
-}
+          if (v.is_uint8_type ())
+            {
+              uint8NDArray d = v.uint8_array_value ();
 
-QImage
-makeImageFromCData (const octave_value& v, int width, int height)
-{
-  dim_vector dv (v.dims ());
-
-  if (dv.ndims () == 3 && dv(2) == 3)
-    {
-      int w = qMin (dv(1), static_cast<octave_idx_type> (width));
-      int h = qMin (dv(0), static_cast<octave_idx_type> (height));
+              for (int i = 0; i < w; i++)
+                for (int j = 0; j < h; j++)
+                  {
+                    int r = d(j, i, 0);
+                    int g = d(j, i, 1);
+                    int b = d(j, i, 2);
+                    int a = 255;
 
-      int x_off = (w < width ? (width - w) / 2 : 0);
-      int y_off = (h < height ? (height - h) / 2 : 0);
-
-      QImage img (width, height, QImage::Format_ARGB32);
-      img.fill (qRgba (0, 0, 0, 0));
-
-      if (v.is_uint8_type ())
-        {
-          uint8NDArray d = v.uint8_array_value ();
+                    img.setPixel (x_off + i, y_off + j, qRgba (r, g, b, a));
+                  }
+            }
+          else if (v.is_single_type ())
+            {
+              FloatNDArray f = v.float_array_value ();
 
-          for (int i = 0; i < w; i++)
-            for (int j = 0; j < h; j++)
-              {
-                int r = d(j, i, 0);
-                int g = d(j, i, 1);
-                int b = d(j, i, 2);
-                int a = 255;
-
-                img.setPixel (x_off + i, y_off + j, qRgba (r, g, b, a));
-              }
-        }
-      else if (v.is_single_type ())
-        {
-          FloatNDArray f = v.float_array_value ();
-
-          for (int i = 0; i < w; i++)
-            for (int j = 0; j < h; j++)
-              {
-                float r = f(j, i, 0);
-                float g = f(j, i, 1);
-                float b = f(j, i, 2);
-                int a = (octave::math::isnan (r) || octave::math::isnan (g) || octave::math::isnan (b) ? 0 : 255);
+              for (int i = 0; i < w; i++)
+                for (int j = 0; j < h; j++)
+                  {
+                    float r = f(j, i, 0);
+                    float g = f(j, i, 1);
+                    float b = f(j, i, 2);
+                    int a = (octave::math::isnan (r) || octave::math::isnan (g)
+                             || octave::math::isnan (b) ? 0 : 255);
 
-                img.setPixel (x_off + i, y_off + j,
-                              qRgba (octave::math::round (r * 255),
-                                     octave::math::round (g * 255),
-                                     octave::math::round (b * 255),
-                                     a));
-              }
-        }
-      else if (v.is_real_type ())
-        {
-          NDArray d = v.array_value ();
+                    img.setPixel (x_off + i, y_off + j,
+                                  qRgba (octave::math::round (r * 255),
+                                         octave::math::round (g * 255),
+                                         octave::math::round (b * 255),
+                                         a));
+                  }
+            }
+          else if (v.is_real_type ())
+            {
+              NDArray d = v.array_value ();
 
-          for (int i = 0; i < w; i++)
-            for (int j = 0; j < h; j++)
-              {
-                double r = d(j, i, 0);
-                double g = d(j, i, 1);
-                double b = d(j, i, 2);
-                int a = (octave::math::isnan (r) || octave::math::isnan (g) || octave::math::isnan (b) ? 0 : 255);
+              for (int i = 0; i < w; i++)
+                for (int j = 0; j < h; j++)
+                  {
+                    double r = d(j, i, 0);
+                    double g = d(j, i, 1);
+                    double b = d(j, i, 2);
+                    int a = (octave::math::isnan (r) || octave::math::isnan (g)
+                             || octave::math::isnan (b) ? 0 : 255);
 
-                img.setPixel (x_off + i, y_off + j,
-                              qRgba (octave::math::round (r * 255),
-                                     octave::math::round (g * 255),
-                                     octave::math::round (b * 255),
-                                     a));
-              }
+                    img.setPixel (x_off + i, y_off + j,
+                                  qRgba (octave::math::round (r * 255),
+                                         octave::math::round (g * 255),
+                                         octave::math::round (b * 255),
+                                         a));
+                  }
+            }
+
+          return img;
         }
 
-      return img;
+      return QImage ();
     }
 
-  return QImage ();
-}
+    octave_scalar_map
+    makeKeyEventStruct (QKeyEvent* event)
+    {
+      octave_scalar_map retval;
 
-octave_scalar_map
-makeKeyEventStruct (QKeyEvent* event)
-{
-  octave_scalar_map retval;
+      retval.setfield ("Key", KeyMap::qKeyToKeyString (event->key ()));
+      retval.setfield ("Character", toStdString (event->text ()));
 
-  retval.setfield ("Key", KeyMap::qKeyToKeyString (event->key ()));
-  retval.setfield ("Character", toStdString (event->text ()));
-
-  std::list<std::string> modList;
-  Qt::KeyboardModifiers mods = event->modifiers ();
+      std::list<std::string> modList;
+      Qt::KeyboardModifiers mods = event->modifiers ();
 
-  if (mods & Qt::ShiftModifier)
-    modList.push_back ("shift");
-  if (mods & Qt::ControlModifier)
+      if (mods & Qt::ShiftModifier)
+        modList.push_back ("shift");
+      if (mods & Qt::ControlModifier)
 #if defined (Q_OS_MAC)
-    modList.push_back ("command");
+        modList.push_back ("command");
 #else
-    modList.push_back ("control");
+        modList.push_back ("control");
 #endif
-  if (mods & Qt::AltModifier)
-    modList.push_back ("alt");
+      if (mods & Qt::AltModifier)
+        modList.push_back ("alt");
 #if defined (Q_OS_MAC)
-  if (mods & Qt::MetaModifier)
-    modList.push_back ("control");
+      if (mods & Qt::MetaModifier)
+        modList.push_back ("control");
 #endif
 
-  retval.setfield ("Modifier", Cell (modList));
+      retval.setfield ("Modifier", Cell (modList));
 
-  return retval;
-}
+      return retval;
+    }
 
-}; // namespace Utils
+  }; // namespace Utils
 
 }; // namespace QtHandles
+
diff --git a/libgui/graphics/QtHandlesUtils.h b/libgui/graphics/QtHandlesUtils.h
--- a/libgui/graphics/QtHandlesUtils.h
+++ b/libgui/graphics/QtHandlesUtils.h
@@ -34,52 +34,53 @@ along with Octave; see the file COPYING.
 #include "graphics.h"
 
 class QKeyEvent;
 class QMouseEvent;
 
 namespace QtHandles
 {
 
-namespace Utils
-{
-  QString fromStdString (const std::string& s);
-  std::string toStdString (const QString& s);
+  namespace Utils
+  {
+    QString fromStdString (const std::string& s);
+    std::string toStdString (const QString& s);
 
-  QStringList fromStringVector (const string_vector& v);
-  string_vector toStringVector (const QStringList& l);
+    QStringList fromStringVector (const string_vector& v);
+    string_vector toStringVector (const QStringList& l);
 
-  Cell toCellString (const QStringList& l);
+    Cell toCellString (const QStringList& l);
 
-  template <typename T>
-  QFont computeFont (const typename T::properties& props, int height = -1);
+    template <typename T>
+    QFont computeFont (const typename T::properties& props, int height = -1);
 
-  QColor fromRgb (const Matrix& rgb);
-  Matrix toRgb (const QColor& c);
+    QColor fromRgb (const Matrix& rgb);
+    Matrix toRgb (const QColor& c);
 
-  Qt::Alignment fromHVAlign (const std::string& halign,
-                             const std::string& valign);
+    Qt::Alignment fromHVAlign (const std::string& halign,
+                               const std::string& valign);
 
-  std::string figureSelectionType (QMouseEvent* event,
-                                   bool isDoubleClick = false);
+    std::string figureSelectionType (QMouseEvent* event,
+                                     bool isDoubleClick = false);
 
-  Matrix figureCurrentPoint (const graphics_object& fig, QMouseEvent* event);
-  Matrix figureCurrentPoint (const graphics_object& fig);
+    Matrix figureCurrentPoint (const graphics_object& fig, QMouseEvent* event);
+    Matrix figureCurrentPoint (const graphics_object& fig);
 
-  template <typename T>
-  inline typename T::properties&
-  properties (graphics_object obj)
+    template <typename T>
+    inline typename T::properties&
+    properties (graphics_object obj)
     { return dynamic_cast<typename T::properties&> (obj.get_properties ()); }
 
-  template <typename T>
-  inline typename T::properties&
-  properties (const graphics_handle& h)
+    template <typename T>
+    inline typename T::properties&
+    properties (const graphics_handle& h)
     { return Utils::properties<T> (gh_manager::get_object (h)); }
 
-  QImage makeImageFromCData (const octave_value& v, int width = -1,
-                             int height = -1);
+    QImage makeImageFromCData (const octave_value& v, int width = -1,
+                               int height = -1);
 
-  octave_scalar_map makeKeyEventStruct (QKeyEvent* event);
-};
+    octave_scalar_map makeKeyEventStruct (QKeyEvent* event);
+  };
 
 }; // namespace QtHandles
 
 #endif
+
diff --git a/libgui/graphics/RadioButtonControl.cc b/libgui/graphics/RadioButtonControl.cc
--- a/libgui/graphics/RadioButtonControl.cc
+++ b/libgui/graphics/RadioButtonControl.cc
@@ -29,42 +29,43 @@ along with Octave; see the file COPYING.
 #include "ButtonGroup.h"
 #include "RadioButtonControl.h"
 #include "Container.h"
 #include "QtHandlesUtils.h"
 
 namespace QtHandles
 {
 
-RadioButtonControl*
-RadioButtonControl::create (const graphics_object& go)
-{
-  Object* parent = Object::parentObject (go);
+  RadioButtonControl*
+  RadioButtonControl::create (const graphics_object& go)
+  {
+    Object* parent = Object::parentObject (go);
 
-  if (parent)
-    {
-      Container* container = parent->innerContainer ();
+    if (parent)
+      {
+        Container* container = parent->innerContainer ();
 
-      if (container)
-        return new RadioButtonControl (go, new QRadioButton (container));
-    }
+        if (container)
+          return new RadioButtonControl (go, new QRadioButton (container));
+      }
 
-  return 0;
-}
+    return 0;
+  }
 
-RadioButtonControl::RadioButtonControl (const graphics_object& go,
-                                        QRadioButton* radio)
-  : ButtonControl (go, radio)
-{
-  Object* parent = Object::parentObject (go);
-  ButtonGroup* btnGroup = dynamic_cast<ButtonGroup*>(parent);
-  if (btnGroup)
-    btnGroup->addButton (radio);
+  RadioButtonControl::RadioButtonControl (const graphics_object& go,
+                                          QRadioButton* radio)
+    : ButtonControl (go, radio)
+  {
+    Object* parent = Object::parentObject (go);
+    ButtonGroup* btnGroup = dynamic_cast<ButtonGroup*>(parent);
+    if (btnGroup)
+      btnGroup->addButton (radio);
 
-  radio->setAutoFillBackground (true);
-  radio->setAutoExclusive (false);
-}
+    radio->setAutoFillBackground (true);
+    radio->setAutoExclusive (false);
+  }
 
-RadioButtonControl::~RadioButtonControl (void)
-{
-}
+  RadioButtonControl::~RadioButtonControl (void)
+  {
+  }
 
 };
+
diff --git a/libgui/graphics/RadioButtonControl.h b/libgui/graphics/RadioButtonControl.h
--- a/libgui/graphics/RadioButtonControl.h
+++ b/libgui/graphics/RadioButtonControl.h
@@ -25,20 +25,21 @@ along with Octave; see the file COPYING.
 
 #include "ButtonControl.h"
 
 class QRadioButton;
 
 namespace QtHandles
 {
 
-class RadioButtonControl : public ButtonControl
-{
-public:
-  RadioButtonControl (const graphics_object& go, QRadioButton* box);
-  ~RadioButtonControl (void);
+  class RadioButtonControl : public ButtonControl
+  {
+  public:
+    RadioButtonControl (const graphics_object& go, QRadioButton* box);
+    ~RadioButtonControl (void);
 
-  static RadioButtonControl* create (const graphics_object& go);
-};
+    static RadioButtonControl* create (const graphics_object& go);
+  };
 
 }; // namespace QtHandles
 
 #endif
+
diff --git a/libgui/graphics/SliderControl.cc b/libgui/graphics/SliderControl.cc
--- a/libgui/graphics/SliderControl.cc
+++ b/libgui/graphics/SliderControl.cc
@@ -30,126 +30,127 @@ along with Octave; see the file COPYING.
 #include "SliderControl.h"
 #include "QtHandlesUtils.h"
 
 #define RANGE_INT_MAX 1000000
 
 namespace QtHandles
 {
 
-SliderControl*
-SliderControl::create (const graphics_object& go)
-{
-  Object* parent = Object::parentObject (go);
+  SliderControl*
+  SliderControl::create (const graphics_object& go)
+  {
+    Object* parent = Object::parentObject (go);
+
+    if (parent)
+      {
+        Container* container = parent->innerContainer ();
 
-  if (parent)
-    {
-      Container* container = parent->innerContainer ();
+        if (container)
+          return new SliderControl (go, new QScrollBar (container));
+      }
 
-      if (container)
-        return new SliderControl (go, new QScrollBar (container));
-    }
+    return 0;
+  }
 
-  return 0;
-}
+  SliderControl::SliderControl (const graphics_object& go,
+                                QAbstractSlider* slider)
+    : BaseControl (go, slider), m_blockUpdates (false)
+  {
+    uicontrol::properties& up = properties<uicontrol> ();
 
-SliderControl::SliderControl (const graphics_object& go,
-                              QAbstractSlider* slider)
-  : BaseControl (go, slider), m_blockUpdates (false)
-{
-  uicontrol::properties& up = properties<uicontrol> ();
+    slider->setTracking (false);
+    Matrix bb = up.get_boundingbox ();
+    slider->setOrientation (bb(2) > bb(3) ? Qt::Horizontal : Qt::Vertical);
+    Matrix steps = up.get_sliderstep ().matrix_value ();
+    slider->setMinimum (0);
+    slider->setMaximum (RANGE_INT_MAX);
+    slider->setSingleStep (octave::math::round (steps(0) * RANGE_INT_MAX));
+    slider->setPageStep (octave::math::round (steps(1) * RANGE_INT_MAX));
+    Matrix value = up.get_value ().matrix_value ();
+    if (value.numel () > 0)
+      {
+        double dmin = up.get_min (), dmax = up.get_max ();
 
-  slider->setTracking (false);
-  Matrix bb = up.get_boundingbox ();
-  slider->setOrientation (bb(2) > bb(3) ? Qt::Horizontal : Qt::Vertical);
-  Matrix steps = up.get_sliderstep ().matrix_value ();
-  slider->setMinimum (0);
-  slider->setMaximum (RANGE_INT_MAX);
-  slider->setSingleStep (octave::math::round (steps(0) * RANGE_INT_MAX));
-  slider->setPageStep (octave::math::round (steps(1) * RANGE_INT_MAX));
-  Matrix value = up.get_value ().matrix_value ();
-  if (value.numel () > 0)
-    {
-      double dmin = up.get_min (), dmax = up.get_max ();
+        slider->setValue (octave::math::round (((value(0) - dmin) / (dmax - dmin))
+                                               * RANGE_INT_MAX));
+      }
+
+    connect (slider, SIGNAL (valueChanged (int)), SLOT (valueChanged (int)));
+  }
+
+  SliderControl::~SliderControl (void)
+  {
+  }
+
+  void
+  SliderControl::update (int pId)
+  {
+    uicontrol::properties& up = properties<uicontrol> ();
+    QScrollBar* slider = qWidget<QScrollBar> ();
 
-      slider->setValue (octave::math::round (((value(0) - dmin) / (dmax - dmin))
-                                * RANGE_INT_MAX));
-    }
-
-  connect (slider, SIGNAL (valueChanged (int)), SLOT (valueChanged (int)));
-}
-
-SliderControl::~SliderControl (void)
-{
-}
-
-void
-SliderControl::update (int pId)
-{
-  uicontrol::properties& up = properties<uicontrol> ();
-  QScrollBar* slider = qWidget<QScrollBar> ();
-
-  switch (pId)
-    {
-    case uicontrol::properties::ID_SLIDERSTEP:
+    switch (pId)
       {
-        Matrix steps = up.get_sliderstep ().matrix_value ();
+      case uicontrol::properties::ID_SLIDERSTEP:
+        {
+          Matrix steps = up.get_sliderstep ().matrix_value ();
+
+          slider->setSingleStep (octave::math::round (steps(0) * RANGE_INT_MAX));
+          slider->setPageStep (octave::math::round (steps(1) * RANGE_INT_MAX));
+        }
+        break;
+
+      case uicontrol::properties::ID_VALUE:
+        {
+          Matrix value = up.get_value ().matrix_value ();
+          double dmax = up.get_max (), dmin = up.get_min ();
 
-        slider->setSingleStep (octave::math::round (steps(0) * RANGE_INT_MAX));
-        slider->setPageStep (octave::math::round (steps(1) * RANGE_INT_MAX));
+          if (value.numel () > 0)
+            {
+              int ival = octave::math::round (((value(0) - dmin) / (dmax - dmin))
+                                              * RANGE_INT_MAX);
+
+              m_blockUpdates = true;
+              slider->setValue (ival);
+              m_blockUpdates = false;
+            }
+        }
+        break;
+
+      default:
+        BaseControl::update (pId);
+        break;
       }
-      break;
+  }
 
-    case uicontrol::properties::ID_VALUE:
+  void
+  SliderControl::valueChanged (int ival)
+  {
+    if (! m_blockUpdates)
       {
-        Matrix value = up.get_value ().matrix_value ();
-        double dmax = up.get_max (), dmin = up.get_min ();
+        gh_manager::auto_lock lock;
+        graphics_object go = object ();
 
-        if (value.numel () > 0)
+        if (go.valid_object ())
           {
-            int ival = octave::math::round (((value(0) - dmin) / (dmax - dmin))
-                               * RANGE_INT_MAX);
+            uicontrol::properties& up = Utils::properties<uicontrol> (go);
+
+            Matrix value = up.get_value ().matrix_value ();
+            double dmin = up.get_min (), dmax = up.get_max ();
 
-            m_blockUpdates = true;
-            slider->setValue (ival);
-            m_blockUpdates = false;
+            int ival_tmp = (value.numel () > 0 ?
+                            octave::math::round (((value(0) - dmin) / (dmax - dmin))
+                                                 * RANGE_INT_MAX) :
+                            0);
+
+            if (ival != ival_tmp || value.numel () > 0)
+              {
+                double dval = dmin + (ival * (dmax - dmin) / RANGE_INT_MAX);
+
+                gh_manager::post_set (m_handle, "value", octave_value (dval));
+                gh_manager::post_callback (m_handle, "callback");
+              }
           }
       }
-      break;
-
-    default:
-      BaseControl::update (pId);
-      break;
-    }
-}
-
-void
-SliderControl::valueChanged (int ival)
-{
-  if (! m_blockUpdates)
-    {
-      gh_manager::auto_lock lock;
-      graphics_object go = object ();
-
-      if (go.valid_object ())
-        {
-          uicontrol::properties& up = Utils::properties<uicontrol> (go);
-
-          Matrix value = up.get_value ().matrix_value ();
-          double dmin = up.get_min (), dmax = up.get_max ();
-
-          int ival_tmp = (value.numel () > 0 ?
-                          octave::math::round (((value(0) - dmin) / (dmax - dmin))
-                                  * RANGE_INT_MAX) :
-                          0);
-
-          if (ival != ival_tmp || value.numel () > 0)
-            {
-              double dval = dmin + (ival * (dmax - dmin) / RANGE_INT_MAX);
-
-              gh_manager::post_set (m_handle, "value", octave_value (dval));
-              gh_manager::post_callback (m_handle, "callback");
-            }
-        }
-    }
-}
+  }
 
 }; // namespace QtHandles
+
diff --git a/libgui/graphics/SliderControl.h b/libgui/graphics/SliderControl.h
--- a/libgui/graphics/SliderControl.h
+++ b/libgui/graphics/SliderControl.h
@@ -25,31 +25,32 @@ along with Octave; see the file COPYING.
 
 #include "BaseControl.h"
 
 class QAbstractSlider;
 
 namespace QtHandles
 {
 
-class SliderControl : public BaseControl
-{
-  Q_OBJECT
+  class SliderControl : public BaseControl
+  {
+    Q_OBJECT
 
-public:
-  SliderControl (const graphics_object& go, QAbstractSlider* slider);
-  ~SliderControl (void);
+  public:
+    SliderControl (const graphics_object& go, QAbstractSlider* slider);
+    ~SliderControl (void);
 
-  static SliderControl* create (const graphics_object& go);
+    static SliderControl* create (const graphics_object& go);
 
-protected:
-  void update (int pId);
+  protected:
+    void update (int pId);
 
-private slots:
-  void valueChanged (int ival);
+  private slots:
+    void valueChanged (int ival);
 
-private:
-  bool m_blockUpdates;
-};
+  private:
+    bool m_blockUpdates;
+  };
 
 }; // namespace QtHandles
 
 #endif
+
diff --git a/libgui/graphics/TextControl.cc b/libgui/graphics/TextControl.cc
--- a/libgui/graphics/TextControl.cc
+++ b/libgui/graphics/TextControl.cc
@@ -28,66 +28,67 @@ along with Octave; see the file COPYING.
 
 #include "Container.h"
 #include "TextControl.h"
 #include "QtHandlesUtils.h"
 
 namespace QtHandles
 {
 
-TextControl*
-TextControl::create (const graphics_object& go)
-{
-  Object* parent = Object::parentObject (go);
+  TextControl*
+  TextControl::create (const graphics_object& go)
+  {
+    Object* parent = Object::parentObject (go);
 
-  if (parent)
-    {
-      Container* container = parent->innerContainer ();
+    if (parent)
+      {
+        Container* container = parent->innerContainer ();
 
-      if (container)
-        return new TextControl (go, new QLabel (container));
-    }
+        if (container)
+          return new TextControl (go, new QLabel (container));
+      }
 
-  return 0;
-}
+    return 0;
+  }
 
-TextControl::TextControl (const graphics_object& go, QLabel* label)
-  : BaseControl (go, label)
-{
-  uicontrol::properties& up = properties<uicontrol> ();
+  TextControl::TextControl (const graphics_object& go, QLabel* label)
+    : BaseControl (go, label)
+  {
+    uicontrol::properties& up = properties<uicontrol> ();
 
-  label->setAutoFillBackground (true);
-  label->setTextFormat (Qt::PlainText);
-  label->setWordWrap (false);
-  label->setAlignment (Utils::fromHVAlign (up.get_horizontalalignment (),
-                                           up.get_verticalalignment ()));
-  label->setText(Utils::fromStringVector (up.get_string_vector()).join("\n"));
-}
+    label->setAutoFillBackground (true);
+    label->setTextFormat (Qt::PlainText);
+    label->setWordWrap (false);
+    label->setAlignment (Utils::fromHVAlign (up.get_horizontalalignment (),
+                         up.get_verticalalignment ()));
+    label->setText(Utils::fromStringVector (up.get_string_vector()).join("\n"));
+  }
 
-TextControl::~TextControl (void)
-{
-}
+  TextControl::~TextControl (void)
+  {
+  }
 
-void
-TextControl::update (int pId)
-{
-  uicontrol::properties& up = properties<uicontrol> ();
-  QLabel* label = qWidget<QLabel> ();
+  void
+  TextControl::update (int pId)
+  {
+    uicontrol::properties& up = properties<uicontrol> ();
+    QLabel* label = qWidget<QLabel> ();
 
-  switch (pId)
-    {
-    case uicontrol::properties::ID_STRING:
-      label->setText(Utils::fromStringVector (up.get_string_vector()).join("\n"));
-      break;
+    switch (pId)
+      {
+      case uicontrol::properties::ID_STRING:
+        label->setText(Utils::fromStringVector (up.get_string_vector()).join("\n"));
+        break;
 
-    case uicontrol::properties::ID_HORIZONTALALIGNMENT:
-    case uicontrol::properties::ID_VERTICALALIGNMENT:
-      label->setAlignment (Utils::fromHVAlign (up.get_horizontalalignment (),
-                                               up.get_verticalalignment ()));
-      break;
+      case uicontrol::properties::ID_HORIZONTALALIGNMENT:
+      case uicontrol::properties::ID_VERTICALALIGNMENT:
+        label->setAlignment (Utils::fromHVAlign (up.get_horizontalalignment (),
+                             up.get_verticalalignment ()));
+        break;
 
-    default:
-      BaseControl::update (pId);
-      break;
-    }
-}
+      default:
+        BaseControl::update (pId);
+        break;
+      }
+  }
 
 }; // namespace QtHandles
+
diff --git a/libgui/graphics/TextControl.h b/libgui/graphics/TextControl.h
--- a/libgui/graphics/TextControl.h
+++ b/libgui/graphics/TextControl.h
@@ -25,23 +25,24 @@ along with Octave; see the file COPYING.
 
 #include "BaseControl.h"
 
 class QLabel;
 
 namespace QtHandles
 {
 
-class TextControl : public BaseControl
-{
-public:
-  TextControl (const graphics_object& go, QLabel* label);
-  ~TextControl (void);
+  class TextControl : public BaseControl
+  {
+  public:
+    TextControl (const graphics_object& go, QLabel* label);
+    ~TextControl (void);
 
-  static TextControl* create (const graphics_object& go);
+    static TextControl* create (const graphics_object& go);
 
-protected:
-  void update (int pId);
-};
+  protected:
+    void update (int pId);
+  };
 
 }; // namespace QtHandles
 
 #endif
+
diff --git a/libgui/graphics/TextEdit.cc b/libgui/graphics/TextEdit.cc
--- a/libgui/graphics/TextEdit.cc
+++ b/libgui/graphics/TextEdit.cc
@@ -26,28 +26,29 @@ along with Octave; see the file COPYING.
 
 #include <QKeyEvent>
 
 #include "TextEdit.h"
 
 namespace QtHandles
 {
 
-void
-TextEdit::focusOutEvent (QFocusEvent* xevent)
-{
-  QTextEdit::focusOutEvent (xevent);
+  void
+  TextEdit::focusOutEvent (QFocusEvent* xevent)
+  {
+    QTextEdit::focusOutEvent (xevent);
 
-  emit editingFinished ();
-}
+    emit editingFinished ();
+  }
 
-void
-TextEdit::keyPressEvent (QKeyEvent* xevent)
-{
-  QTextEdit::keyPressEvent (xevent);
+  void
+  TextEdit::keyPressEvent (QKeyEvent* xevent)
+  {
+    QTextEdit::keyPressEvent (xevent);
 
-  if ((xevent->key () == Qt::Key_Return
-       || xevent->key () == Qt::Key_Enter)
-      && xevent->modifiers () == Qt::ControlModifier)
-    emit returnPressed ();
-}
+    if ((xevent->key () == Qt::Key_Return
+         || xevent->key () == Qt::Key_Enter)
+        && xevent->modifiers () == Qt::ControlModifier)
+      emit returnPressed ();
+  }
 
 }; // namespace QtHandles
+
diff --git a/libgui/graphics/TextEdit.h b/libgui/graphics/TextEdit.h
--- a/libgui/graphics/TextEdit.h
+++ b/libgui/graphics/TextEdit.h
@@ -23,28 +23,29 @@ along with Octave; see the file COPYING.
 #if ! defined (octave_TextEdit_h)
 #define octave_TextEdit_h 1
 
 #include <QTextEdit>
 
 namespace QtHandles
 {
 
-class TextEdit : public QTextEdit
-{
-  Q_OBJECT
+  class TextEdit : public QTextEdit
+  {
+    Q_OBJECT
 
-public:
-  TextEdit (QWidget* xparent) : QTextEdit(xparent) { }
-  ~TextEdit (void) { }
+  public:
+    TextEdit (QWidget* xparent) : QTextEdit(xparent) { }
+    ~TextEdit (void) { }
 
-signals:
-  void editingFinished (void);
-  void returnPressed (void);
+  signals:
+    void editingFinished (void);
+    void returnPressed (void);
 
-protected:
-  void focusOutEvent (QFocusEvent* event);
-  void keyPressEvent (QKeyEvent* event);
-};
+  protected:
+    void focusOutEvent (QFocusEvent* event);
+    void keyPressEvent (QKeyEvent* event);
+  };
 
 }; // namespace QtHandles
 
 #endif
+
diff --git a/libgui/graphics/ToggleButtonControl.cc b/libgui/graphics/ToggleButtonControl.cc
--- a/libgui/graphics/ToggleButtonControl.cc
+++ b/libgui/graphics/ToggleButtonControl.cc
@@ -29,42 +29,43 @@ along with Octave; see the file COPYING.
 #include "ToggleButtonControl.h"
 #include "ButtonGroup.h"
 #include "Container.h"
 #include "QtHandlesUtils.h"
 
 namespace QtHandles
 {
 
-ToggleButtonControl*
-ToggleButtonControl::create (const graphics_object& go)
-{
-  Object* parent = Object::parentObject (go);
+  ToggleButtonControl*
+  ToggleButtonControl::create (const graphics_object& go)
+  {
+    Object* parent = Object::parentObject (go);
 
-  if (parent)
-    {
-      Container* container = parent->innerContainer ();
+    if (parent)
+      {
+        Container* container = parent->innerContainer ();
 
-      if (container)
-        return new ToggleButtonControl (go, new QPushButton (container));
-    }
+        if (container)
+          return new ToggleButtonControl (go, new QPushButton (container));
+      }
 
-  return 0;
-}
+    return 0;
+  }
 
-ToggleButtonControl::ToggleButtonControl (const graphics_object& go,
-                                          QPushButton* btn)
+  ToggleButtonControl::ToggleButtonControl (const graphics_object& go,
+      QPushButton* btn)
     : ButtonControl (go, btn)
-{
-  Object* parent = Object::parentObject (go);
-  ButtonGroup* btnGroup = dynamic_cast<ButtonGroup*>(parent);
-  if (btnGroup)
-    btnGroup->addButton (btn);
+  {
+    Object* parent = Object::parentObject (go);
+    ButtonGroup* btnGroup = dynamic_cast<ButtonGroup*>(parent);
+    if (btnGroup)
+      btnGroup->addButton (btn);
 
-  btn->setCheckable (true);
-  btn->setAutoFillBackground (true);
-}
+    btn->setCheckable (true);
+    btn->setAutoFillBackground (true);
+  }
 
-ToggleButtonControl::~ToggleButtonControl (void)
-{
-}
+  ToggleButtonControl::~ToggleButtonControl (void)
+  {
+  }
 
 };
+
diff --git a/libgui/graphics/ToggleButtonControl.h b/libgui/graphics/ToggleButtonControl.h
--- a/libgui/graphics/ToggleButtonControl.h
+++ b/libgui/graphics/ToggleButtonControl.h
@@ -25,20 +25,21 @@ along with Octave; see the file COPYING.
 
 #include "ButtonControl.h"
 
 class QPushButton;
 
 namespace QtHandles
 {
 
-class ToggleButtonControl : public ButtonControl
-{
-public:
-  ToggleButtonControl (const graphics_object& go, QPushButton* box);
-  ~ToggleButtonControl (void);
+  class ToggleButtonControl : public ButtonControl
+  {
+  public:
+    ToggleButtonControl (const graphics_object& go, QPushButton* box);
+    ~ToggleButtonControl (void);
 
-  static ToggleButtonControl* create (const graphics_object& go);
-};
+    static ToggleButtonControl* create (const graphics_object& go);
+  };
 
 }; // namespace QtHandles
 
 #endif
+
diff --git a/libgui/graphics/ToggleTool.cc b/libgui/graphics/ToggleTool.cc
--- a/libgui/graphics/ToggleTool.cc
+++ b/libgui/graphics/ToggleTool.cc
@@ -26,70 +26,71 @@ along with Octave; see the file COPYING.
 
 #include "ToggleTool.h"
 
 #include "ToolBarButton.cc"
 
 namespace QtHandles
 {
 
-ToggleTool*
-ToggleTool::create (const graphics_object& go)
-{
-  Object* parent = Object::parentObject (go);
+  ToggleTool*
+  ToggleTool::create (const graphics_object& go)
+  {
+    Object* parent = Object::parentObject (go);
 
-  if (parent)
-    {
-      QWidget* parentWidget = parent->qWidget<QWidget> ();
+    if (parent)
+      {
+        QWidget* parentWidget = parent->qWidget<QWidget> ();
 
-      if (parentWidget)
-        return new ToggleTool (go, new QAction (parentWidget));
-    }
+        if (parentWidget)
+          return new ToggleTool (go, new QAction (parentWidget));
+      }
 
-  return 0;
-}
+    return 0;
+  }
 
-ToggleTool::ToggleTool (const graphics_object& go, QAction* action)
-  : ToolBarButton<uitoggletool> (go, action)
-{
-  uitoggletool::properties& tp = properties<uitoggletool> ();
+  ToggleTool::ToggleTool (const graphics_object& go, QAction* action)
+    : ToolBarButton<uitoggletool> (go, action)
+  {
+    uitoggletool::properties& tp = properties<uitoggletool> ();
 
-  action->setCheckable (true);
-  action->setChecked (tp.is_state ());
+    action->setCheckable (true);
+    action->setChecked (tp.is_state ());
 
-  connect (action, SIGNAL (toggled (bool)),
-           this, SLOT (triggered (bool)));
-}
+    connect (action, SIGNAL (toggled (bool)),
+             this, SLOT (triggered (bool)));
+  }
 
-ToggleTool::~ToggleTool (void)
-{
-}
+  ToggleTool::~ToggleTool (void)
+  {
+  }
 
-void
-ToggleTool::update (int pId)
-{
-  uitoggletool::properties& tp = properties<uitoggletool> ();
-  QAction* action = qWidget<QAction> ();
+  void
+  ToggleTool::update (int pId)
+  {
+    uitoggletool::properties& tp = properties<uitoggletool> ();
+    QAction* action = qWidget<QAction> ();
 
-  switch (pId)
-    {
-    case uitoggletool::properties::ID_STATE:
-      action->setChecked (tp.is_state ());
-      break;
+    switch (pId)
+      {
+      case uitoggletool::properties::ID_STATE:
+        action->setChecked (tp.is_state ());
+        break;
 
-    default:
-      ToolBarButton<uitoggletool>::update (pId);
-      break;
-    }
-}
+      default:
+        ToolBarButton<uitoggletool>::update (pId);
+        break;
+      }
+  }
 
-void
-ToggleTool::triggered (bool checked)
-{
-  gh_manager::post_set (m_handle, "state", checked, false);
-  gh_manager::post_callback (m_handle,
-                             checked
-                             ? "oncallback"
-                             : "offcallback");
-  gh_manager::post_callback (m_handle, "clickedcallback");
-}
+  void
+  ToggleTool::triggered (bool checked)
+  {
+    gh_manager::post_set (m_handle, "state", checked, false);
+    gh_manager::post_callback (m_handle,
+                               checked
+                               ? "oncallback"
+                               : "offcallback");
+    gh_manager::post_callback (m_handle, "clickedcallback");
+  }
 
 };
+
diff --git a/libgui/graphics/ToggleTool.h b/libgui/graphics/ToggleTool.h
--- a/libgui/graphics/ToggleTool.h
+++ b/libgui/graphics/ToggleTool.h
@@ -23,28 +23,29 @@ along with Octave; see the file COPYING.
 #if ! defined (octave_ToggleTool_h)
 #define octave_ToggleTool_h 1
 
 #include "ToolBarButton.h"
 
 namespace QtHandles
 {
 
-class ToggleTool : public ToolBarButton<uitoggletool>
-{
-  Q_OBJECT
+  class ToggleTool : public ToolBarButton<uitoggletool>
+  {
+    Q_OBJECT
 
-public:
-  ToggleTool (const graphics_object& go, QAction* action);
-  ~ToggleTool (void);
+  public:
+    ToggleTool (const graphics_object& go, QAction* action);
+    ~ToggleTool (void);
 
-  static ToggleTool* create (const graphics_object& go);
+    static ToggleTool* create (const graphics_object& go);
 
-protected:
-  void update (int pId);
+  protected:
+    void update (int pId);
 
-private slots:
-  void triggered (bool checked);
-};
+  private slots:
+    void triggered (bool checked);
+  };
 
 }; // namespace QtHandles
 
 #endif
+
diff --git a/libgui/graphics/ToolBar.cc b/libgui/graphics/ToolBar.cc
--- a/libgui/graphics/ToolBar.cc
+++ b/libgui/graphics/ToolBar.cc
@@ -36,106 +36,106 @@ along with Octave; see the file COPYING.
 
 #include "Figure.h"
 #include "ToolBar.h"
 #include "QtHandlesUtils.h"
 
 namespace QtHandles
 {
 
-static QAction*
-addEmptyAction (QToolBar* bar)
-{
-  static QIcon _empty;
+  static QAction*
+  addEmptyAction (QToolBar* bar)
+  {
+    static QIcon _empty;
 
-  if (_empty.isNull ())
-    {
-      QPixmap pix (16, 16);
+    if (_empty.isNull ())
+      {
+        QPixmap pix (16, 16);
 
-      pix.fill (Qt::transparent);
+        pix.fill (Qt::transparent);
 
-      _empty = QIcon (pix);
-    }
+        _empty = QIcon (pix);
+      }
 
-  QAction* a = bar->addAction (_empty, "Empty Toolbar");
+    QAction* a = bar->addAction (_empty, "Empty Toolbar");
 
-  a->setEnabled (false);
-  a->setToolTip ("");
+    a->setEnabled (false);
+    a->setToolTip ("");
 
-  return a;
-}
+    return a;
+  }
 
-ToolBar*
-ToolBar::create (const graphics_object& go)
-{
-  Object* parent = Object::parentObject (go);
+  ToolBar*
+  ToolBar::create (const graphics_object& go)
+  {
+    Object* parent = Object::parentObject (go);
 
-  if (parent)
-    {
-      QWidget* parentWidget = parent->qWidget<QWidget> ();
+    if (parent)
+      {
+        QWidget* parentWidget = parent->qWidget<QWidget> ();
 
-      if (parentWidget)
-        return new ToolBar (go, new QToolBar (parentWidget));
-    }
+        if (parentWidget)
+          return new ToolBar (go, new QToolBar (parentWidget));
+      }
 
-  return 0;
-}
+    return 0;
+  }
 
-ToolBar::ToolBar (const graphics_object& go, QToolBar* bar)
-  : Object (go, bar), m_empty (0), m_figure (0)
-{
-  uitoolbar::properties& tp = properties<uitoolbar> ();
+  ToolBar::ToolBar (const graphics_object& go, QToolBar* bar)
+    : Object (go, bar), m_empty (0), m_figure (0)
+  {
+    uitoolbar::properties& tp = properties<uitoolbar> ();
 
-  bar->setFloatable (false);
-  bar->setMovable (false);
-  bar->setVisible (tp.is_visible ());
+    bar->setFloatable (false);
+    bar->setMovable (false);
+    bar->setVisible (tp.is_visible ());
 
-  m_empty = addEmptyAction (bar);
+    m_empty = addEmptyAction (bar);
 
-  m_figure =
-    dynamic_cast<Figure*> (Object::fromQObject (bar->parentWidget ()));
+    m_figure =
+      dynamic_cast<Figure*> (Object::fromQObject (bar->parentWidget ()));
 
-  if (m_figure)
-    m_figure->addCustomToolBar (bar, tp.is_visible ());
+    if (m_figure)
+      m_figure->addCustomToolBar (bar, tp.is_visible ());
 
-  bar->installEventFilter (this);
-}
+    bar->installEventFilter (this);
+  }
 
-ToolBar::~ToolBar (void)
-{
-}
+  ToolBar::~ToolBar (void)
+  {
+  }
 
-void
-ToolBar::update (int pId)
-{
-  uitoolbar::properties& tp = properties<uitoolbar> ();
-  QToolBar* bar = qWidget<QToolBar> ();
+  void
+  ToolBar::update (int pId)
+  {
+    uitoolbar::properties& tp = properties<uitoolbar> ();
+    QToolBar* bar = qWidget<QToolBar> ();
 
-  switch (pId)
-    {
-    case base_properties::ID_VISIBLE:
-      if (m_figure)
-        m_figure->showCustomToolBar (bar, tp.is_visible ());
-      break;
+    switch (pId)
+      {
+      case base_properties::ID_VISIBLE:
+        if (m_figure)
+          m_figure->showCustomToolBar (bar, tp.is_visible ());
+        break;
 
-    default:
-      Object::update (pId);
-      break;
-    }
-}
+      default:
+        Object::update (pId);
+        break;
+      }
+  }
 
-bool
-ToolBar::eventFilter (QObject* watched, QEvent* xevent)
-{
-  if (watched == qObject ())
-    {
-      switch (xevent->type ())
-        {
-        case QEvent::ActionAdded:
-        case QEvent::ActionRemoved:
+  bool
+  ToolBar::eventFilter (QObject* watched, QEvent* xevent)
+  {
+    if (watched == qObject ())
+      {
+        switch (xevent->type ())
+          {
+          case QEvent::ActionAdded:
+          case QEvent::ActionRemoved:
             {
               QActionEvent* ae = dynamic_cast<QActionEvent*> (xevent);
               QToolBar* bar = qWidget<QToolBar> ();
 
               if (ae->action () != m_empty)
                 {
                   if (xevent->type () == QEvent::ActionAdded)
                     {
@@ -144,37 +144,38 @@ ToolBar::eventFilter (QObject* watched, 
                     }
                   else
                     {
                       if (bar->actions ().size () == 1)
                         m_empty->setVisible (true);
                     }
                 }
             }
-          break;
+            break;
 
-        default:
-          break;
-        }
-    }
+          default:
+            break;
+          }
+      }
 
-  return false;
-}
+    return false;
+  }
 
-void
-ToolBar::hideEmpty (void)
-{
-  m_empty->setVisible (false);
-}
+  void
+  ToolBar::hideEmpty (void)
+  {
+    m_empty->setVisible (false);
+  }
 
-void
-ToolBar::beingDeleted (void)
-{
-  if (m_figure)
-    {
-      QToolBar* bar = qWidget<QToolBar> ();
+  void
+  ToolBar::beingDeleted (void)
+  {
+    if (m_figure)
+      {
+        QToolBar* bar = qWidget<QToolBar> ();
 
-      if (bar)
-        m_figure->showCustomToolBar (bar, false);
-    }
-}
+        if (bar)
+          m_figure->showCustomToolBar (bar, false);
+      }
+  }
 
 }; // namespace QtHandles
+
diff --git a/libgui/graphics/ToolBar.h b/libgui/graphics/ToolBar.h
--- a/libgui/graphics/ToolBar.h
+++ b/libgui/graphics/ToolBar.h
@@ -26,39 +26,40 @@ along with Octave; see the file COPYING.
 #include "Object.h"
 
 class QAction;
 class QToolBar;
 
 namespace QtHandles
 {
 
-class Figure;
+  class Figure;
 
-class ToolBar : public Object
-{
-  Q_OBJECT
+  class ToolBar : public Object
+  {
+    Q_OBJECT
 
-public:
-  ToolBar (const graphics_object& go, QToolBar* bar);
-  ~ToolBar (void);
+  public:
+    ToolBar (const graphics_object& go, QToolBar* bar);
+    ~ToolBar (void);
 
-  static ToolBar* create (const graphics_object& go);
+    static ToolBar* create (const graphics_object& go);
 
-  Container* innerContainer (void) { return 0; }
+    Container* innerContainer (void) { return 0; }
 
-  bool eventFilter (QObject* watched, QEvent* event);
+    bool eventFilter (QObject* watched, QEvent* event);
 
-protected:
-  void update (int pId);
-  void beingDeleted (void);
+  protected:
+    void update (int pId);
+    void beingDeleted (void);
 
-private slots:
-  void hideEmpty (void);
+  private slots:
+    void hideEmpty (void);
 
-private:
-  QAction* m_empty;
-  Figure* m_figure;
-};
+  private:
+    QAction* m_empty;
+    Figure* m_figure;
+  };
 
 }; // namespace QtHandles
 
 #endif
+
diff --git a/libgui/graphics/ToolBarButton.cc b/libgui/graphics/ToolBarButton.cc
--- a/libgui/graphics/ToolBarButton.cc
+++ b/libgui/graphics/ToolBarButton.cc
@@ -28,98 +28,99 @@ along with Octave; see the file COPYING.
 #include <QWidget>
 
 #include "ToolBarButton.h"
 #include "QtHandlesUtils.h"
 
 namespace QtHandles
 {
 
-template <typename T>
-ToolBarButton<T>::ToolBarButton (const graphics_object& go, QAction* action)
-  : Object (go, action), m_separator (0)
-{
-  typename T::properties& tp = properties<T> ();
-
-  action->setToolTip (Utils::fromStdString (tp.get_tooltipstring ()));
-  action->setVisible (tp.is_visible ());
-  QImage img = Utils::makeImageFromCData (tp.get_cdata (), 16, 16);
-  action->setIcon (QIcon (QPixmap::fromImage (img)));
-  if (tp.is_separator ())
-    {
-      m_separator = new QAction (action);
-      m_separator->setSeparator (true);
-      m_separator->setVisible (tp.is_visible ());
-    }
-  action->setEnabled (tp.is_enable ());
-
-  QWidget* w = qobject_cast<QWidget*> (action->parent ());
+  template <typename T>
+  ToolBarButton<T>::ToolBarButton (const graphics_object& go, QAction* action)
+    : Object (go, action), m_separator (0)
+  {
+    typename T::properties& tp = properties<T> ();
 
-  w->insertAction (w->actions ().back (), action);
-  if (m_separator)
-    w->insertAction (action, m_separator);
-}
-
-template <typename T>
-ToolBarButton<T>::~ToolBarButton (void)
-{
-}
-
-template <typename T>
-void
-ToolBarButton<T>::update (int pId)
-{
-  typename T::properties& tp = properties<T> ();
-  QAction* action = qWidget<QAction> ();
-
-  switch (pId)
-    {
-    case base_properties::ID_VISIBLE:
-      action->setVisible (tp.is_visible ());
-      if (m_separator)
+    action->setToolTip (Utils::fromStdString (tp.get_tooltipstring ()));
+    action->setVisible (tp.is_visible ());
+    QImage img = Utils::makeImageFromCData (tp.get_cdata (), 16, 16);
+    action->setIcon (QIcon (QPixmap::fromImage (img)));
+    if (tp.is_separator ())
+      {
+        m_separator = new QAction (action);
+        m_separator->setSeparator (true);
         m_separator->setVisible (tp.is_visible ());
-      break;
+      }
+    action->setEnabled (tp.is_enable ());
+
+    QWidget* w = qobject_cast<QWidget*> (action->parent ());
 
-    case T::properties::ID_TOOLTIPSTRING:
-      action->setToolTip (Utils::fromStdString (tp.get_tooltipstring ()));
-      break;
+    w->insertAction (w->actions ().back (), action);
+    if (m_separator)
+      w->insertAction (action, m_separator);
+  }
 
-    case T::properties::ID_CDATA:
-      {
-        QImage img = Utils::makeImageFromCData (tp.get_cdata (), 16, 16);
+  template <typename T>
+  ToolBarButton<T>::~ToolBarButton (void)
+  {
+  }
 
-        action->setIcon (QIcon (QPixmap::fromImage (img)));
-      }
-      break;
+  template <typename T>
+  void
+  ToolBarButton<T>::update (int pId)
+  {
+    typename T::properties& tp = properties<T> ();
+    QAction* action = qWidget<QAction> ();
 
-    case T::properties::ID_SEPARATOR:
-      if (tp.is_separator ())
-        {
-          if (! m_separator)
-            {
-              m_separator = new QAction (action);
-              m_separator->setSeparator (true);
-              m_separator->setVisible (tp.is_visible ());
+    switch (pId)
+      {
+      case base_properties::ID_VISIBLE:
+        action->setVisible (tp.is_visible ());
+        if (m_separator)
+          m_separator->setVisible (tp.is_visible ());
+        break;
+
+      case T::properties::ID_TOOLTIPSTRING:
+        action->setToolTip (Utils::fromStdString (tp.get_tooltipstring ()));
+        break;
 
-              QWidget* w = qobject_cast<QWidget*> (action->parent ());
+      case T::properties::ID_CDATA:
+        {
+          QImage img = Utils::makeImageFromCData (tp.get_cdata (), 16, 16);
 
-              w->insertAction (action, m_separator);
-            }
-        }
-      else
-        {
-          if (m_separator)
-            delete m_separator;
-          m_separator = 0;
+          action->setIcon (QIcon (QPixmap::fromImage (img)));
         }
-      break;
+        break;
 
-    case T::properties::ID_ENABLE:
-      action->setEnabled (tp.is_enable ());
-      break;
+      case T::properties::ID_SEPARATOR:
+        if (tp.is_separator ())
+          {
+            if (! m_separator)
+              {
+                m_separator = new QAction (action);
+                m_separator->setSeparator (true);
+                m_separator->setVisible (tp.is_visible ());
+
+                QWidget* w = qobject_cast<QWidget*> (action->parent ());
 
-    default:
-      Object::update (pId);
-      break;
-    }
-}
+                w->insertAction (action, m_separator);
+              }
+          }
+        else
+          {
+            if (m_separator)
+              delete m_separator;
+            m_separator = 0;
+          }
+        break;
+
+      case T::properties::ID_ENABLE:
+        action->setEnabled (tp.is_enable ());
+        break;
+
+      default:
+        Object::update (pId);
+        break;
+      }
+  }
 
 }; // namespace QtHandles
+
diff --git a/libgui/graphics/ToolBarButton.h b/libgui/graphics/ToolBarButton.h
--- a/libgui/graphics/ToolBarButton.h
+++ b/libgui/graphics/ToolBarButton.h
@@ -25,29 +25,30 @@ along with Octave; see the file COPYING.
 
 #include "Object.h"
 
 class QAction;
 
 namespace QtHandles
 {
 
-class Container;
+  class Container;
 
-template <typename T>
-class ToolBarButton : public Object
-{
-public:
-  ToolBarButton (const graphics_object& go, QAction* action);
-  ~ToolBarButton (void);
+  template <typename T>
+  class ToolBarButton : public Object
+  {
+  public:
+    ToolBarButton (const graphics_object& go, QAction* action);
+    ~ToolBarButton (void);
 
-  Container* innerContainer (void) { return 0; }
+    Container* innerContainer (void) { return 0; }
 
-protected:
-  void update (int pId);
+  protected:
+    void update (int pId);
 
-private:
-  QAction* m_separator;
-};
+  private:
+    QAction* m_separator;
+  };
 
 };
 
 #endif
+
diff --git a/libgui/graphics/__init_qt__.cc b/libgui/graphics/__init_qt__.cc
--- a/libgui/graphics/__init_qt__.cc
+++ b/libgui/graphics/__init_qt__.cc
@@ -36,99 +36,99 @@ along with Octave; see the file COPYING.
 #include "defun.h"
 
 #include "Backend.h"
 #include "QtHandlesUtils.h"
 
 namespace QtHandles
 {
 
-static bool qtHandlesInitialized = false;
+  static bool qtHandlesInitialized = false;
 
-bool
-__init__ (void)
-{
-  if (! qtHandlesInitialized)
-    {
-      if (qApp)
-        {
-          gh_manager::auto_lock lock;
+  bool
+  __init__ (void)
+  {
+    if (! qtHandlesInitialized)
+      {
+        if (qApp)
+          {
+            gh_manager::auto_lock lock;
 
-          qRegisterMetaType<graphics_object> ("graphics_object");
+            qRegisterMetaType<graphics_object> ("graphics_object");
 
-          gh_manager::enable_event_processing (true);
+            gh_manager::enable_event_processing (true);
 
-          graphics_toolkit tk (new Backend ());
-          gtk_manager::load_toolkit (tk);
+            graphics_toolkit tk (new Backend ());
+            gtk_manager::load_toolkit (tk);
 
-          octave_add_atexit_function ("__shutdown_qt__");
+            octave_add_atexit_function ("__shutdown_qt__");
 
-          // Change some default settings to use Qt default colors
-          QPalette p;
-          graphics_object root = gh_manager::get_object (0);
+            // Change some default settings to use Qt default colors
+            QPalette p;
+            graphics_object root = gh_manager::get_object (0);
 
-          /*
-          root.set ("defaultfigurecolor",
-                    octave_value (Utils::toRgb (p.color (QPalette::Window))));
-          */
-          root.set ("defaultuicontrolbackgroundcolor",
-                    octave_value (Utils::toRgb (p.color (QPalette::Window))));
-          root.set ("defaultuicontrolforegroundcolor",
-                    octave_value (Utils::toRgb
-                                  (p.color (QPalette::WindowText))));
-          root.set ("defaultuipanelbackgroundcolor",
-                    octave_value (Utils::toRgb (p.color (QPalette::Window))));
-          root.set ("defaultuipanelforegroundcolor",
-                    octave_value (Utils::toRgb
-                                  (p.color (QPalette::WindowText))));
-          root.set ("defaultuipanelhighlightcolor",
-                    octave_value (Utils::toRgb (p.color (QPalette::Light))));
-          root.set ("defaultuipanelshadowcolor",
-                    octave_value (Utils::toRgb (p.color (QPalette::Dark))));
-          root.set ("defaultuibuttongroupbackgroundcolor",
-                    octave_value (Utils::toRgb (p.color (QPalette::Window))));
-          root.set ("defaultuibuttongroupforegroundcolor",
-                    octave_value (Utils::toRgb
-                                  (p.color (QPalette::WindowText))));
-          root.set ("defaultuibuttongrouphighlightcolor",
-                    octave_value (Utils::toRgb (p.color (QPalette::Light))));
-          root.set ("defaultuibuttongroupshadowcolor",
-                    octave_value (Utils::toRgb (p.color (QPalette::Dark))));
+            /*
+            root.set ("defaultfigurecolor",
+                      octave_value (Utils::toRgb (p.color (QPalette::Window))));
+            */
+            root.set ("defaultuicontrolbackgroundcolor",
+                      octave_value (Utils::toRgb (p.color (QPalette::Window))));
+            root.set ("defaultuicontrolforegroundcolor",
+                      octave_value (Utils::toRgb
+                                    (p.color (QPalette::WindowText))));
+            root.set ("defaultuipanelbackgroundcolor",
+                      octave_value (Utils::toRgb (p.color (QPalette::Window))));
+            root.set ("defaultuipanelforegroundcolor",
+                      octave_value (Utils::toRgb
+                                    (p.color (QPalette::WindowText))));
+            root.set ("defaultuipanelhighlightcolor",
+                      octave_value (Utils::toRgb (p.color (QPalette::Light))));
+            root.set ("defaultuipanelshadowcolor",
+                      octave_value (Utils::toRgb (p.color (QPalette::Dark))));
+            root.set ("defaultuibuttongroupbackgroundcolor",
+                      octave_value (Utils::toRgb (p.color (QPalette::Window))));
+            root.set ("defaultuibuttongroupforegroundcolor",
+                      octave_value (Utils::toRgb
+                                    (p.color (QPalette::WindowText))));
+            root.set ("defaultuibuttongrouphighlightcolor",
+                      octave_value (Utils::toRgb (p.color (QPalette::Light))));
+            root.set ("defaultuibuttongroupshadowcolor",
+                      octave_value (Utils::toRgb (p.color (QPalette::Dark))));
 
-          qtHandlesInitialized = true;
+            qtHandlesInitialized = true;
 
-          return true;
-        }
-      else
-        error ("__init_qt__: QApplication object must exist.");
-    }
+            return true;
+          }
+        else
+          error ("__init_qt__: QApplication object must exist.");
+      }
 
-  return false;
-}
+    return false;
+  }
 
-bool
-__shutdown__ (void)
-{
-  if (qtHandlesInitialized)
-    {
-      gh_manager::auto_lock lock;
+  bool
+  __shutdown__ (void)
+  {
+    if (qtHandlesInitialized)
+      {
+        gh_manager::auto_lock lock;
 
-      octave_add_atexit_function ("__shutdown_qt__");
+        octave_add_atexit_function ("__shutdown_qt__");
 
-      gtk_manager::unload_toolkit ("qt");
+        gtk_manager::unload_toolkit ("qt");
 
-      gh_manager::enable_event_processing (false);
+        gh_manager::enable_event_processing (false);
 
-      qtHandlesInitialized = false;
+        qtHandlesInitialized = false;
 
-      return true;
-    }
+        return true;
+      }
 
-  return false;
-}
+    return false;
+  }
 
 }; // namespace QtHandles
 
 DEFUN (__init_qt__, , , "")
 {
   QtHandles::__init__ ();
 
   return octave_value ();
@@ -234,23 +234,23 @@ DEFUN (__uigetfile_qt__, args, , "")
 
       if (! files.isEmpty ())
         {
           Cell cFiles (1, files.length ());
           QString dirName;
           int i = 0;
 
           foreach (const QString& s, files)
-            {
-              QFileInfo fi (s);
+          {
+            QFileInfo fi (s);
 
-              if (dirName.isEmpty ())
-                dirName = appendDirSep (fi.canonicalPath ());
-              cFiles(i++) = toStdString (fi.fileName ());
-            }
+            if (dirName.isEmpty ())
+              dirName = appendDirSep (fi.canonicalPath ());
+            cFiles(i++) = toStdString (fi.fileName ());
+          }
 
           retval(0) = cFiles;
           retval(1) = toStdString (dirName);
           if (! filter.isEmpty ())
             retval(2) = static_cast<double> (filterSpecs.indexOf (filter) + 1);
         }
     }
   else
@@ -333,17 +333,18 @@ DEFUN (__uigetdir_qt__, args, , "")
   //   args(1) : Dialog title
 
   octave_value retval ("");
 
   QString caption = fromStdString (args(1).string_value ());
   QString defaultDirectory = fromStdString (args(0).string_value ());
 
   QString dirName = QFileDialog::getExistingDirectory (0, caption,
-                                                       defaultDirectory);
+                    defaultDirectory);
 
   if (! dirName.isNull ())
     retval = toStdString (dirName);
 
   return retval;
 }
 
 #endif
+
diff --git a/libgui/graphics/__init_qt__.h b/libgui/graphics/__init_qt__.h
--- a/libgui/graphics/__init_qt__.h
+++ b/libgui/graphics/__init_qt__.h
@@ -21,15 +21,16 @@ along with Octave; see the file COPYING.
 */
 
 #if ! defined (octave__init_qt___h)
 #define octave__init_qt___h 1
 
 namespace QtHandles
 {
 
-bool __init__ (void);
+  bool __init__ (void);
 
 }; // namespace QtHandles
 
 extern void install___init_qt___functions (void);
 
 #endif
+
diff --git a/libgui/graphics/annotation-dialog.cc b/libgui/graphics/annotation-dialog.cc
--- a/libgui/graphics/annotation-dialog.cc
+++ b/libgui/graphics/annotation-dialog.cc
@@ -69,49 +69,50 @@ annotation_dialog::init ()
   connect (ui->btn_background_color, SIGNAL (clicked ()),
            this, SLOT (prompt_for_color ()));
 
   connect (ui->btn_edge_color, SIGNAL (clicked ()),
            this, SLOT (prompt_for_color ()));
 
   // set gui element to default values
   ui->cb_fit_box_to_text->setChecked (true);
-  ui->cb_horz_align->setCurrentIndex ( ui->cb_horz_align->findText("left") );
-  ui->cb_vert_align->setCurrentIndex ( ui->cb_vert_align->findText("middle") );
+  ui->cb_horz_align->setCurrentIndex (ui->cb_horz_align->findText("left"));
+  ui->cb_vert_align->setCurrentIndex (ui->cb_vert_align->findText("middle"));
 
   // set gui elements to any values from input properties
   set_gui_props ();
 }
 
 annotation_dialog::~annotation_dialog ()
 {
   delete ui;
 }
 
 // internal slots
 
 void
 annotation_dialog::button_clicked (QAbstractButton *button)
 {
-  QDialogButtonBox::ButtonRole button_role = ui->button_box->buttonRole (button);
+  QDialogButtonBox::ButtonRole button_role
+    = ui->button_box->buttonRole (button);
 
   QSettings *settings = resource_manager::get_settings ();
 
   // save position
   if (settings)
     settings->setValue ("annotation/geometry",saveGeometry ());
 
-  if (button_role == QDialogButtonBox::ApplyRole ||
-      button_role == QDialogButtonBox::AcceptRole)
+  if (button_role == QDialogButtonBox::ApplyRole
+      || button_role == QDialogButtonBox::AcceptRole)
     {
       get_gui_props ();
     }
 
-  if (button_role == QDialogButtonBox::RejectRole ||
-      button_role == QDialogButtonBox::AcceptRole)
+  if (button_role == QDialogButtonBox::RejectRole
+      || button_role == QDialogButtonBox::AcceptRole)
     close ();
 }
 
 octave_value_list
 annotation_dialog::get_properties () const
 {
   return props;
 }
@@ -125,42 +126,42 @@ annotation_dialog::get_gui_props ()
   Matrix position(1,4);
   position(0) = ui->sb_x->value ();
   position(1) = ui->sb_y->value ();
   position(2) = ui->sb_width->value ();
   position(3) = ui->sb_height->value ();
   props.append (ovl ("textbox", position));
 
   props.append (ovl ("string", ui->edit_string->text ().toStdString ()));
-  props.append (ovl ("fitboxtotext", ui->cb_fit_box_to_text->isChecked() ? 
-                     "on" : "off" ));
+  props.append (ovl ("fitboxtotext",
+                     ui->cb_fit_box_to_text->isChecked () ? "on" : "off"));
 
-  // FIXME: only "normalized" units is selectable, change the code bellow
+  // FIXME: only "normalized" units is selectable, change the code below
   //        once more units are added in the UI.
-  std::string tmpval;
+  std::string tmpstr;
   props.append (ovl ("units", "normalized"));
-  
-  tmpval = (ui->cb_horz_align->currentIndex () == 0 ? "left" :
+
+  tmpstr = (ui->cb_horz_align->currentIndex () == 0 ? "left" :
             (ui->cb_horz_align->currentIndex () == 1 ? "center" : "right"));
-  props.append (ovl ("horizontalalignment", tmpval));
+  props.append (ovl ("horizontalalignment", tmpstr));
 
-  tmpval = (ui->cb_vert_align->currentIndex () == 0 ? "top" :
+  tmpstr = (ui->cb_vert_align->currentIndex () == 0 ? "top" :
             (ui->cb_horz_align->currentIndex () == 1 ? "middle" : "bottom"));
-  props.append (ovl ("verticalalignment", tmpval));
+  props.append (ovl ("verticalalignment", tmpstr));
 
-  tmpval = ui->cb_font_name->currentText ().toStdString();
-  props.append (ovl ("fontname", tmpval));
+  tmpstr = ui->cb_font_name->currentText ().toStdString();
+  props.append (ovl ("fontname", tmpstr));
 
   props.append (ovl ("fontsize", ui->sb_font_size->value ()));
-  props.append (ovl ("fontweight", ui->cb_font_bold->isChecked() ? 
-                     "bold" : "normal" ));
-  props.append (ovl ("fontangle", ui->cb_font_italic->isChecked() ? 
-                     "italic" : "normal" ));
+  props.append (ovl ("fontweight",
+                     ui->cb_font_bold->isChecked () ? "bold" : "normal"));
+  props.append (ovl ("fontangle",
+                     ui->cb_font_italic->isChecked () ? "italic" : "normal"));
   props.append (ovl ("color", Utils::toRgb (ui->btn_color->palette ().
-                                            color (QPalette::Button))));
+                     color (QPalette::Button))));
 
   // FIXME: only "none" linestyle is selectable, change the code bellow
   //        once more linestyles are added in the UI.
   props.append (ovl ("linestyle", "none"));
 }
 
 void
 annotation_dialog::set_gui_props ()
@@ -199,53 +200,57 @@ annotation_dialog::set_gui_props ()
         }
       else if (name == "string")
         {
           // FIXME: handle if is array of strings ?
           ui->edit_string->setText (props(2*i +1).string_value ().c_str ());
         }
       else if (name == "fitboxtotext")
         {
-          ui->cb_fit_box_to_text->setChecked ( props(1*i +1).string_value () == "on" );
+          ui->cb_fit_box_to_text->setChecked (props(1*i +1).string_value () == "on");
         }
       else if (name == "units")
         {
-          ui->cb_units->setCurrentIndex ( ui->cb_units->findText(props(1*i +1).string_value ().c_str ()) );
+          ui->cb_units->setCurrentIndex (ui->cb_units->findText (props(
+                                            1*i +1).string_value ().c_str ()));
         }
       else if (name == "horizontalalignment")
         {
-          ui->cb_horz_align->setCurrentIndex ( ui->cb_horz_align->findText(props(1*i +1).string_value ().c_str ()) );
+          ui->cb_horz_align->setCurrentIndex (ui->cb_horz_align->findText (props(
+                                                 1*i +1).string_value ().c_str ()));
         }
       else if (name == "verticalalignment")
         {
-          ui->cb_vert_align->setCurrentIndex ( ui->cb_vert_align->findText(props(1*i +1).string_value ().c_str ()) );
+          ui->cb_vert_align->setCurrentIndex (ui->cb_vert_align->findText (props(
+                                                 1*i +1).string_value ().c_str ()));
         }
       else if (name == "fontname")
         {
-          ui->cb_vert_align->setCurrentIndex ( ui->cb_font_name->findText(props(1*i +1).string_value ().c_str ()) );
+          ui->cb_vert_align->setCurrentIndex (ui->cb_font_name->findText (props(
+                                                 1*i +1).string_value ().c_str ()));
         }
-       else if (name == "fontsize")
-        {
-          ui->sb_font_size->setValue ( props(1*i +1).float_value () );
-        }
-       else if (name == "fontweight")
+      else if (name == "fontsize")
         {
-          ui->cb_font_bold->setChecked ( props(1*i +1).string_value () == "bold" );
+          ui->sb_font_size->setValue (props(1*i +1).float_value ());
         }
-       else if (name == "fontangle")
+      else if (name == "fontweight")
         {
-          ui->cb_font_italic->setChecked ( props(1*i +1).string_value () == "italic" );
+          ui->cb_font_bold->setChecked (props(1*i +1).string_value () == "bold");
         }
-       else if (name == "color")
+      else if (name == "fontangle")
+        {
+          ui->cb_font_italic->setChecked (props(1*i +1).string_value () == "italic");
+        }
+      else if (name == "color")
         {
           QColor color;
           if (props(1*i +1).is_matrix_type ())
-              color = Utils::fromRgb (props(2*i +1).matrix_value ());
+            color = Utils::fromRgb (props(2*i +1).matrix_value ());
           else
-             color.setNamedColor (props(2*i +1).string_value ().c_str ());
+            color.setNamedColor (props(2*i +1).string_value ().c_str ());
 
           if (color.isValid ())
             ui->btn_color->setPalette (QPalette (color));
         }
 
     }
 
   edit_string_changed (ui->edit_string->text ());
@@ -263,21 +268,21 @@ annotation_dialog::prompt_for_color ()
   QWidget *widg = dynamic_cast<QWidget*> (sender ());
   if (widg)
     {
       QColor color = widg->palette ().color (QPalette::Button);
 
       color = QColorDialog::getColor(color, this);
 
       if (color.isValid ())
-      {
-        widg->setPalette (QPalette (color));
+        {
+          widg->setPalette (QPalette (color));
 
-        QString css = QString ("background-color: %1; border: 1px solid %2;")
-                .arg (color.name ())
-                .arg ("#000000");
+          QString css = QString ("background-color: %1; border: 1px solid %2;")
+                        .arg (color.name ())
+                        .arg ("#000000");
 
-        widg->setStyleSheet (css);
-        widg->update ();
-      }
+          widg->setStyleSheet (css);
+          widg->update ();
+        }
     }
 }
 
diff --git a/libgui/graphics/annotation-dialog.h b/libgui/graphics/annotation-dialog.h
--- a/libgui/graphics/annotation-dialog.h
+++ b/libgui/graphics/annotation-dialog.h
@@ -55,8 +55,9 @@ private:
   void get_gui_props ();
   void set_gui_props ();
 
   Ui::annotation_dialog * ui;
   octave_value_list props;
 };
 
 #endif
+
diff --git a/libgui/graphics/gl-select.cc b/libgui/graphics/gl-select.cc
--- a/libgui/graphics/gl-select.cc
+++ b/libgui/graphics/gl-select.cc
@@ -26,211 +26,212 @@ along with Octave; see the file COPYING.
 
 #include <iostream>
 
 #include "gl-select.h"
 
 namespace octave
 {
 
-void
-opengl_selector::apply_pick_matrix (void)
-{
-  GLdouble p_matrix[16];
-  GLint viewport[4];
+  void
+  opengl_selector::apply_pick_matrix (void)
+  {
+    GLdouble p_matrix[16];
+    GLint viewport[4];
 
-  glGetDoublev (GL_PROJECTION_MATRIX, p_matrix);
-  glGetIntegerv (GL_VIEWPORT, viewport);
-  glMatrixMode (GL_PROJECTION);
-  glLoadIdentity ();
-  gluPickMatrix (xp, yp, size, size, viewport);
-  glMultMatrixd (p_matrix);
-  glMatrixMode (GL_MODELVIEW);
-}
+    glGetDoublev (GL_PROJECTION_MATRIX, p_matrix);
+    glGetIntegerv (GL_VIEWPORT, viewport);
+    glMatrixMode (GL_PROJECTION);
+    glLoadIdentity ();
+    gluPickMatrix (xp, yp, size, size, viewport);
+    glMultMatrixd (p_matrix);
+    glMatrixMode (GL_MODELVIEW);
+  }
 
-void
-opengl_selector::setup_opengl_transformation (const axes::properties& props)
-{
-  opengl_renderer::setup_opengl_transformation (props);
-  apply_pick_matrix ();
-}
+  void
+  opengl_selector::setup_opengl_transformation (const axes::properties& props)
+  {
+    opengl_renderer::setup_opengl_transformation (props);
+    apply_pick_matrix ();
+  }
 
-void
-opengl_selector::init_marker (const std::string& m, double sz, float width)
-{
-  opengl_renderer::init_marker (m, sz, width);
-  apply_pick_matrix ();
-}
+  void
+  opengl_selector::init_marker (const std::string& m, double sz, float width)
+  {
+    opengl_renderer::init_marker (m, sz, width);
+    apply_pick_matrix ();
+  }
 
 # define BUFFER_SIZE 128
 
-graphics_object
-opengl_selector::select (const graphics_object& ax, int x, int y, int flags)
-{
-  glEnable (GL_DEPTH_TEST);
-  glDepthFunc (GL_LEQUAL);
+  graphics_object
+  opengl_selector::select (const graphics_object& ax, int x, int y, int flags)
+  {
+    glEnable (GL_DEPTH_TEST);
+    glDepthFunc (GL_LEQUAL);
+
+    xp = x;
+    yp = y;
 
-  xp = x;
-  yp = y;
+    GLuint select_buffer[BUFFER_SIZE];
+
+    glSelectBuffer (BUFFER_SIZE, select_buffer);
+    glRenderMode (GL_SELECT);
+    glInitNames ();
+
+    object_map.clear ();
+
+    draw (ax);
 
-  GLuint select_buffer[BUFFER_SIZE];
+    int hits = glRenderMode (GL_RENDER);
+    graphics_object obj;
+
+    if (hits > 0)
+      {
+        GLuint current_minZ = 0xffffffff;
+        GLuint current_name = 0xffffffff;
 
-  glSelectBuffer (BUFFER_SIZE, select_buffer);
-  glRenderMode (GL_SELECT);
-  glInitNames ();
+        for (int i = 0, j = 0; i < hits && j < BUFFER_SIZE-3; i++)
+          {
+            GLuint n = select_buffer[j++],
+                   minZ = select_buffer[j++];
 
-  object_map.clear ();
-
-  draw (ax);
+            j++; // skip maxZ
+            if (((flags & select_last) == 0 && (minZ <= current_minZ))
+                || ((flags & select_last) != 0 && (minZ >= current_minZ)))
+              {
+                bool candidate = true;
+                GLuint name =
+                  select_buffer[std::min (j + n, GLuint (BUFFER_SIZE)) - 1];
 
-  int hits = glRenderMode (GL_RENDER);
-  graphics_object obj;
+                if ((flags & select_ignore_hittest) == 0)
+                  {
+                    graphics_object go = object_map[name];
+
+                    if (! go.get_properties ().is_hittest ())
+                      candidate = false;
+                  }
 
-  if (hits > 0)
-    {
-      GLuint current_minZ = 0xffffffff;
-      GLuint current_name = 0xffffffff;
+                if (candidate)
+                  {
+                    current_minZ = minZ;
+                    current_name = name;
+                  }
+
+                j += n;
+              }
+            else
+              j += n;
+          }
 
-      for (int i = 0, j = 0; i < hits && j < BUFFER_SIZE-3; i++)
-        {
-          GLuint n = select_buffer[j++],
-                 minZ = select_buffer[j++];
+        if (current_name != 0xffffffff)
+          obj = object_map[current_name];
+      }
+    else if (hits < 0)
+      warning ("opengl_selector::select: selection buffer overflow");
+
+    object_map.clear ();
+
+    return obj;
+  }
 
-          j++; // skip maxZ
-          if (((flags & select_last) == 0 && (minZ <= current_minZ))
-              || ((flags & select_last) != 0 && (minZ >= current_minZ)))
-            {
-              bool candidate = true;
-              GLuint name =
-                select_buffer[std::min (j + n, GLuint (BUFFER_SIZE)) - 1];
+  void
+  opengl_selector::draw (const graphics_object& go, bool toplevel)
+  {
+    GLuint name = object_map.size ();
+
+    object_map[name] = go;
+    glPushName (name);
+    opengl_renderer::draw (go, toplevel);
+    glPopName ();
+  }
 
-              if ((flags & select_ignore_hittest) == 0)
-                {
-                  graphics_object go = object_map[name];
+  void
+  opengl_selector::fake_text (double x, double y, double z, const Matrix& bbox,
+                              bool use_scale)
+  {
+    ColumnVector xpos, xp1, xp2;
+
+    xpos = get_transform ().transform (x, y, z, use_scale);
 
-                  if (! go.get_properties ().is_hittest ())
-                    candidate = false;
-                }
+    xp1 = xp2 = xpos;
+    xp1(0) += bbox(0);
+    xp1(1) -= bbox(1);
+    xp2(0) += (bbox(0) + bbox(2));
+    xp2(1) -= (bbox(1) + bbox(3));
+
+    ColumnVector p1, p2, p3, p4;
 
-              if (candidate)
-                {
-                  current_minZ = minZ;
-                  current_name = name;
-                }
+    p1 = get_transform ().untransform (xp1(0), xp1(1), xp1(2), false);
+    p2 = get_transform ().untransform (xp2(0), xp1(1), xp1(2), false);
+    p3 = get_transform ().untransform (xp2(0), xp2(1), xp1(2), false);
+    p4 = get_transform ().untransform (xp1(0), xp2(1), xp1(2), false);
 
-              j += n;
-            }
-          else
-            j += n;
-        }
+    glBegin (GL_QUADS);
+    glVertex3dv (p1.data ());
+    glVertex3dv (p2.data ());
+    glVertex3dv (p3.data ());
+    glVertex3dv (p4.data ());
+    glEnd ();
+  }
+
+  void
+  opengl_selector::draw_text (const text::properties& props)
+  {
+    if (props.get_string ().is_empty ())
+      return;
+
+    Matrix pos = props.get_data_position ();
+    const Matrix bbox = props.get_extent_matrix ();
+
+    fake_text (pos(0), pos(1), pos.numel () > 2 ? pos(2) : 0.0, bbox);
+  }
 
-      if (current_name != 0xffffffff)
-        obj = object_map[current_name];
-    }
-  else if (hits < 0)
-    warning ("opengl_selector::select: selection buffer overflow");
+  Matrix
+  opengl_selector::render_text (const std::string& txt,
+                                double x, double y, double z,
+                                int halign, int valign, double rotation)
+  {
+    uint8NDArray pixels;
+    Matrix bbox (1, 4, 0.0);
 
-  object_map.clear ();
+    // FIXME: probably more efficient to only compute bbox instead
+    //        of doing full text rendering...
+    text_to_pixels (txt, pixels, bbox, halign, valign, rotation);
+    fake_text(x, y, z, bbox, false);
+
+    return bbox;
+  }
+
+  void
+  opengl_selector::draw_image (const image::properties& props)
+  {
+    Matrix xd = props.get_xdata ().matrix_value ();
+    octave_idx_type nc = props.get_cdata ().columns ();
+    double x_pix_size = (nc == 1 ? 1 : (xd(1) - xd(0)) / (nc - 1));
 
-  return obj;
-}
+    Matrix yd = props.get_ydata ().matrix_value ();
+    octave_idx_type nr = props.get_cdata ().rows ();
+    double y_pix_size = (nr == 1 ? 1 : (yd(1) - yd(0)) / (nr - 1));
+
+    ColumnVector p1(3, 0.0), p2(3, 0.0), p3(3, 0.0), p4(3, 0.0);
+    p1(0) = xd(0) - x_pix_size/2;
+    p1(1) = yd(0) - y_pix_size/2;
+
+    p2(0) = xd(1) + x_pix_size/2;
+    p2(1) = yd(0) - y_pix_size/2;
 
-void
-opengl_selector::draw (const graphics_object& go, bool toplevel)
-{
-  GLuint name = object_map.size ();
+    p3(0) = xd(1) + x_pix_size/2;
+    p3(1) = yd(1) + y_pix_size/2;
+
+    p4(0) = xd(0) - x_pix_size/2;
+    p4(1) = yd(1) + y_pix_size/2;
 
-  object_map[name] = go;
-  glPushName (name);
-  opengl_renderer::draw (go, toplevel);
-  glPopName ();
+    glBegin (GL_QUADS);
+    glVertex3dv (p1.data ());
+    glVertex3dv (p2.data ());
+    glVertex3dv (p3.data ());
+    glVertex3dv (p4.data ());
+    glEnd ();
+  }
+
 }
 
-void
-opengl_selector::fake_text (double x, double y, double z, const Matrix& bbox,
-                            bool use_scale)
-{
-  ColumnVector xpos, xp1, xp2;
-
-  xpos = get_transform ().transform (x, y, z, use_scale);
-
-  xp1 = xp2 = xpos;
-  xp1(0) += bbox(0);
-  xp1(1) -= bbox(1);
-  xp2(0) += (bbox(0) + bbox(2));
-  xp2(1) -= (bbox(1) + bbox(3));
-
-  ColumnVector p1, p2, p3, p4;
-
-  p1 = get_transform ().untransform (xp1(0), xp1(1), xp1(2), false);
-  p2 = get_transform ().untransform (xp2(0), xp1(1), xp1(2), false);
-  p3 = get_transform ().untransform (xp2(0), xp2(1), xp1(2), false);
-  p4 = get_transform ().untransform (xp1(0), xp2(1), xp1(2), false);
-
-  glBegin (GL_QUADS);
-  glVertex3dv (p1.data ());
-  glVertex3dv (p2.data ());
-  glVertex3dv (p3.data ());
-  glVertex3dv (p4.data ());
-  glEnd ();
-}
-
-void
-opengl_selector::draw_text (const text::properties& props)
-{
-  if (props.get_string ().is_empty ())
-    return;
-
-  Matrix pos = props.get_data_position ();
-  const Matrix bbox = props.get_extent_matrix ();
-
-  fake_text (pos(0), pos(1), pos.numel () > 2 ? pos(2) : 0.0, bbox);
-}
-
-Matrix
-opengl_selector::render_text (const std::string& txt,
-                              double x, double y, double z,
-                              int halign, int valign, double rotation)
-{
-  uint8NDArray pixels;
-  Matrix bbox (1, 4, 0.0);
-
-  // FIXME: probably more efficient to only compute bbox instead
-  //        of doing full text rendering...
-  text_to_pixels (txt, pixels, bbox, halign, valign, rotation);
-  fake_text(x, y, z, bbox, false);
-
-  return bbox;
-}
-
-void
-opengl_selector::draw_image (const image::properties& props)
-{
-  Matrix xd = props.get_xdata ().matrix_value ();
-  octave_idx_type nc = props.get_cdata ().columns ();
-  double x_pix_size = (nc == 1 ? 1 : (xd(1) - xd(0)) / (nc - 1));
-
-  Matrix yd = props.get_ydata ().matrix_value ();
-  octave_idx_type nr = props.get_cdata ().rows ();
-  double y_pix_size = (nr == 1 ? 1 : (yd(1) - yd(0)) / (nr - 1));
-
-  ColumnVector p1(3, 0.0), p2(3, 0.0), p3(3, 0.0), p4(3, 0.0);
-  p1(0) = xd(0) - x_pix_size/2;
-  p1(1) = yd(0) - y_pix_size/2;
-
-  p2(0) = xd(1) + x_pix_size/2;
-  p2(1) = yd(0) - y_pix_size/2;
-
-  p3(0) = xd(1) + x_pix_size/2;
-  p3(1) = yd(1) + y_pix_size/2;
-
-  p4(0) = xd(0) - x_pix_size/2;
-  p4(1) = yd(1) + y_pix_size/2;
-
-  glBegin (GL_QUADS);
-  glVertex3dv (p1.data ());
-  glVertex3dv (p2.data ());
-  glVertex3dv (p3.data ());
-  glVertex3dv (p4.data ());
-  glEnd ();
-}
-
-}
diff --git a/libgui/graphics/gl-select.h b/libgui/graphics/gl-select.h
--- a/libgui/graphics/gl-select.h
+++ b/libgui/graphics/gl-select.h
@@ -26,59 +26,60 @@ along with Octave; see the file COPYING.
 #include <map>
 
 #include "gl-render.h"
 #include "oct-opengl.h"
 
 namespace octave
 {
 
-enum select_flags
-{
-  select_ignore_hittest = 0x01,
-  select_last           = 0x02
-};
+  enum select_flags
+  {
+    select_ignore_hittest = 0x01,
+    select_last           = 0x02
+  };
 
-class opengl_selector : public opengl_renderer
-{
-public:
-  opengl_selector (void) : size (5) { }
+  class opengl_selector : public opengl_renderer
+  {
+  public:
+    opengl_selector (void) : size (5) { }
 
-  virtual ~opengl_selector (void) { }
+    virtual ~opengl_selector (void) { }
 
-  graphics_object select (const graphics_object& ax, int x, int y,
-                          int flags = 0);
+    graphics_object select (const graphics_object& ax, int x, int y,
+                            int flags = 0);
 
-  virtual void draw (const graphics_object& go, bool toplevel = true);
+    virtual void draw (const graphics_object& go, bool toplevel = true);
 
-protected:
-  virtual void draw_text (const text::properties& props);
+  protected:
+    virtual void draw_text (const text::properties& props);
 
-  virtual void draw_image (const image::properties& props);
+    virtual void draw_image (const image::properties& props);
 
-  virtual void setup_opengl_transformation (const axes::properties& props);
+    virtual void setup_opengl_transformation (const axes::properties& props);
 
-  virtual void init_marker (const std::string& m, double size, float width);
+    virtual void init_marker (const std::string& m, double size, float width);
 
-  virtual Matrix render_text (const std::string& txt,
-                              double x, double y, double z,
-                              int halign, int valign, double rotation = 0.0);
+    virtual Matrix render_text (const std::string& txt,
+                                double x, double y, double z,
+                                int halign, int valign, double rotation = 0.0);
 
-private:
-  void apply_pick_matrix (void);
+  private:
+    void apply_pick_matrix (void);
 
-  void fake_text (double x, double y, double z, const Matrix& bbox,
-                  bool use_scale = true);
+    void fake_text (double x, double y, double z, const Matrix& bbox,
+                    bool use_scale = true);
 
-private:
-  // The mouse coordinate of the selection/picking point
-  int xp, yp;
+  private:
+    // The mouse coordinate of the selection/picking point
+    int xp, yp;
 
-  // The size (in pixels) of the picking window
-  int size;
+    // The size (in pixels) of the picking window
+    int size;
 
-  // The OpenGL name mapping
-  std::map<GLuint, graphics_object> object_map;
-};
+    // The OpenGL name mapping
+    std::map<GLuint, graphics_object> object_map;
+  };
 
 }
 
 #endif
+
diff --git a/libgui/src/color-picker.cc b/libgui/src/color-picker.cc
--- a/libgui/src/color-picker.cc
+++ b/libgui/src/color-picker.cc
@@ -64,8 +64,9 @@ void color_picker::update_button ()
 
   QString css = QString ("background-color: %1; border: 1px solid %2;")
                 .arg (_color.name ())
                 .arg (bordercolor);
 
   setStyleSheet (css);
   repaint ();
 }
+
diff --git a/libgui/src/color-picker.h b/libgui/src/color-picker.h
--- a/libgui/src/color-picker.h
+++ b/libgui/src/color-picker.h
@@ -42,8 +42,9 @@ private slots:
   void select_color ();
 
 private:
   virtual void update_button ();
   QColor _color;
 };
 
 #endif
+
diff --git a/libgui/src/dialog.h b/libgui/src/dialog.h
--- a/libgui/src/dialog.h
+++ b/libgui/src/dialog.h
@@ -260,8 +260,9 @@ signals:
 private slots:
 
   void rejectSelection (void);
 
   void acceptSelection (void);
 };
 
 #endif
+
diff --git a/libgui/src/documentation-dock-widget.cc b/libgui/src/documentation-dock-widget.cc
--- a/libgui/src/documentation-dock-widget.cc
+++ b/libgui/src/documentation-dock-widget.cc
@@ -63,8 +63,9 @@ documentation_dock_widget::showDoc (cons
   // show the doc pane without focus for carrying on typing in the console
   if (! isVisible ())
     setVisible (true);
   raise ();
 
   _webinfo->load_ref (name);
 
 }
+
diff --git a/libgui/src/documentation-dock-widget.h b/libgui/src/documentation-dock-widget.h
--- a/libgui/src/documentation-dock-widget.h
+++ b/libgui/src/documentation-dock-widget.h
@@ -42,8 +42,9 @@ protected slots:
 
   void showDoc (const QString & name);
 private:
 
   webinfo *_webinfo;
 };
 
 #endif
+
diff --git a/libgui/src/files-dock-widget.cc b/libgui/src/files-dock-widget.cc
--- a/libgui/src/files-dock-widget.cc
+++ b/libgui/src/files-dock-widget.cc
@@ -134,18 +134,18 @@ files_dock_widget::files_dock_widget (QW
   popdown_menu->addAction (resource_manager::icon ("user-home"),
                            tr ("Show Home Directory"),
                            this, SLOT (popdownmenu_home (bool)));
   popdown_menu->addAction (_sync_browser_directory_action);
   popdown_menu->addAction (_sync_octave_directory_action);
   popdown_button->setMenu (popdown_menu);
   popdown_button->setPopupMode (QToolButton::InstantPopup);
   popdown_button->setDefaultAction (new QAction (
-                              resource_manager::icon ("applications-system"), "",
-                              _navigation_tool_bar));
+                            resource_manager::icon ("applications-system"), "",
+                            _navigation_tool_bar));
 
   popdown_menu->addSeparator ();
   popdown_menu->addAction (resource_manager::icon ("folder"),
                            tr ("Set Browser Directory..."),
                            this, SLOT (popdownmenu_search_dir (bool)));
   popdown_menu->addSeparator ();
   popdown_menu->addAction (resource_manager::icon ("edit-find"),
                            tr ("Find Files..."),
@@ -181,17 +181,18 @@ files_dock_widget::files_dock_widget (QW
       QStringList last_dirs
         = settings->value ("filesdockwidget/mru_dir_list").toStringList ();
       if (last_dirs.length () > 0)
         startup_dir = QDir (last_dirs.at (0));  // last dir in previous session
     }
   else if (! settings->value ("filesdockwidget/startup_dir").toString ().isEmpty ())
     {
       // do not restore but there is a startup dir configured
-      startup_dir = QDir (settings->value ("filesdockwidget/startup_dir").toString ());
+      startup_dir
+        = QDir (settings->value ("filesdockwidget/startup_dir").toString ());
     }
 
   if (! startup_dir.exists ())
     {
       // the configured startup dir does not exist, take actual one
       startup_dir = QDir ();
     }
 
@@ -421,27 +422,27 @@ void files_dock_widget::toggle_header (i
 
   QString key = _columns_shown_keys.at (col);
   bool shown = settings->value (key,false).toBool ();
   settings->setValue (key, ! shown);
   settings->sync ();
 
   switch (col)
     {
-      case 0:
-      case 1:
-      case 2:
-        // toggle column visibility
-        _file_tree_view->setColumnHidden (col + 1, shown);
-        break;
-      case 3:
-      case 4:
-        // other actions depending on new settings
-        notice_settings (settings);
-        break;
+    case 0:
+    case 1:
+    case 2:
+      // toggle column visibility
+      _file_tree_view->setColumnHidden (col + 1, shown);
+      break;
+    case 3:
+    case 4:
+      // other actions depending on new settings
+      notice_settings (settings);
+      break;
     }
 }
 
 void
 files_dock_widget::headercontextmenu_requested (const QPoint& mpos)
 {
   QMenu menu (this);
 
@@ -456,17 +457,18 @@ files_dock_widget::headercontextmenu_req
       QAction *action = menu.addAction (_columns_shown.at (i),
                                         _sig_mapper, SLOT (map ()));
       _sig_mapper->setMapping(action, i);
       action->setCheckable (true);
       action->setChecked (
             settings->value (_columns_shown_keys.at (i),true).toBool ());
     }
 
-  connect (_sig_mapper, SIGNAL (mapped (int)), this, SLOT (toggle_header (int)));
+  connect (_sig_mapper, SIGNAL (mapped (int)),
+           this, SLOT (toggle_header (int)));
 
   menu.exec (_file_tree_view->mapToGlobal (mpos));
 }
 
 void
 files_dock_widget::contextmenu_requested (const QPoint& mpos)
 {
 
@@ -478,20 +480,22 @@ files_dock_widget::contextmenu_requested
     {
       QFileInfo info = _file_system_model->fileInfo (index);
 
       QItemSelectionModel *m = _file_tree_view->selectionModel ();
       QModelIndexList sel = m->selectedRows ();
 
       // check if item at mouse position is seleccted
       if (! sel.contains (index))
-        { // is not selected -> clear actual selection and select this item
+        {
+          // is not selected -> clear actual selection and select this item
           m->setCurrentIndex(index,
-                  QItemSelectionModel::Clear | QItemSelectionModel::Select |
-                  QItemSelectionModel::Rows);
+                             QItemSelectionModel::Clear
+                             | QItemSelectionModel::Select
+                             | QItemSelectionModel::Rows);
         }
 
       // construct the context menu depending on item
       menu.addAction (resource_manager::icon ("document-open"), tr ("Open"),
                       this, SLOT (contextmenu_open (bool)));
 
       if (info.isDir ())
         {
@@ -795,24 +799,24 @@ files_dock_widget::notice_settings (cons
     icon_size = st->pixelMetric (QStyle::PM_LargeIconSize);
   else if (icon_size_settings == -1)
     icon_size = st->pixelMetric (QStyle::PM_SmallIconSize);
 
   _navigation_tool_bar->setIconSize (QSize (icon_size,icon_size));
 
   // filenames are always shown, other columns can be hidden by settings
   for (int i = 0; i < 3; i++)
-     _file_tree_view->setColumnHidden (i + 1, ! settings->value (
-                                  _columns_shown_keys.at (i),false).toBool ());
+    _file_tree_view->setColumnHidden (i + 1,
+        ! settings->value (_columns_shown_keys.at (i),false).toBool ());
 
   if (settings->value (_columns_shown_keys.at (3),false).toBool ())
-      _file_system_model->setFilter (QDir::NoDotAndDotDot | QDir::AllEntries
-                                     | QDir::Hidden);
+    _file_system_model->setFilter (QDir::NoDotAndDotDot | QDir::AllEntries
+                                   | QDir::Hidden);
   else
-      _file_system_model->setFilter (QDir::NoDotAndDotDot | QDir::AllEntries);
+    _file_system_model->setFilter (QDir::NoDotAndDotDot | QDir::AllEntries);
 
   _file_tree_view->setAlternatingRowColors (
     settings->value (_columns_shown_keys.at (4),true).toBool ());
   _file_tree_view->setModel (_file_system_model);
 
   // enable the buttons to sync octave/browser dir
   // only if this is not done by default
   _sync_octave_dir
@@ -823,31 +827,33 @@ files_dock_widget::notice_settings (cons
   if (_sync_octave_dir)
     display_directory (_octave_dir);  // sync browser to octave dir
 
 }
 
 void
 files_dock_widget::popdownmenu_home (bool)
 {
-  QString dir = QString::fromStdString (octave::sys::env::get_home_directory ());
+  QString dir
+    = QString::fromStdString (octave::sys::env::get_home_directory ());
 
   if (dir.isEmpty ())
     dir = QDir::homePath ();
 
   set_current_directory (dir);
 }
 
 void
 files_dock_widget::popdownmenu_search_dir (bool)
 {
   QString dir = QFileDialog::getExistingDirectory
                   (this, tr ("Set directory of file browser"),
                    _file_system_model->rootPath (),
-                   QFileDialog::ShowDirsOnly | QFileDialog::DontUseNativeDialog);
+                   QFileDialog::ShowDirsOnly
+                   | QFileDialog::DontUseNativeDialog);
   set_current_directory (dir);
 }
 
 void
 files_dock_widget::popdownmenu_findfiles (bool)
 {
   process_find_files (_file_system_model->rootPath ());
 }
diff --git a/libgui/src/files-dock-widget.h b/libgui/src/files-dock-widget.h
--- a/libgui/src/files-dock-widget.h
+++ b/libgui/src/files-dock-widget.h
@@ -162,8 +162,9 @@ private:
   enum { MaxMRUDirs = 10 };
 
   QStringList _columns_shown;
   QStringList _columns_shown_keys;
   QSignalMapper *_sig_mapper;
 };
 
 #endif
+
diff --git a/libgui/src/find-files-dialog.h b/libgui/src/find-files-dialog.h
--- a/libgui/src/find-files-dialog.h
+++ b/libgui/src/find-files-dialog.h
@@ -72,8 +72,9 @@ private:
   QCheckBox   * _contains_text_check;
   QCheckBox   * _content_case_check;
   QLineEdit * _contains_text_edit;
   QDirIterator * _dir_iterator;
   QStatusBar * _status_bar;
 };
 
 #endif
+
diff --git a/libgui/src/find-files-model.cc b/libgui/src/find-files-model.cc
--- a/libgui/src/find-files-model.cc
+++ b/libgui/src/find-files-model.cc
@@ -212,8 +212,9 @@ find_files_model::fileIcon (const QModel
 {
   QFileIconProvider icon_provider;
   if (p.isValid ())
     {
       return icon_provider.icon (_files[p.row ()]);
     }
   return QIcon ();
 }
+
diff --git a/libgui/src/find-files-model.h b/libgui/src/find-files-model.h
--- a/libgui/src/find-files-model.h
+++ b/libgui/src/find-files-model.h
@@ -56,8 +56,9 @@ public:
   QIcon     fileIcon (const QModelIndex &p) const;
 private:
   QList<QFileInfo> _files;
   QStringList _columnNames;
   int _sortorder;
 };
 
 #endif
+
diff --git a/libgui/src/history-dock-widget.cc b/libgui/src/history-dock-widget.cc
--- a/libgui/src/history-dock-widget.cc
+++ b/libgui/src/history-dock-widget.cc
@@ -107,29 +107,31 @@ history_dock_widget::construct ()
   hist_layout->addWidget (_history_list_view);
 
   hist_layout->setMargin (2);
   widget ()->setLayout (hist_layout);
 
   // Init state of the filter
   QSettings *settings = resource_manager::get_settings ();
 
-  _filter_shown = settings->value ("history_dock_widget/filter_shown",true).toBool();
+  _filter_shown
+    = settings->value ("history_dock_widget/filter_shown",true).toBool();
   _filter_widget->setVisible (_filter_shown);
 
   _filter->addItems (settings->value ("history_dock_widget/mru_list").toStringList ());
 
-  bool filter_state =
-            settings->value ("history_dock_widget/filter_active", false).toBool ();
+  bool filter_state
+    = settings->value ("history_dock_widget/filter_active", false).toBool ();
   _filter_checkbox->setChecked (filter_state);
   filter_activate (filter_state);
 
   // Connect signals and slots
   connect (_filter, SIGNAL (editTextChanged (const QString&)),
-           &_sort_filter_proxy_model, SLOT (setFilterWildcard (const QString&)));
+           &_sort_filter_proxy_model,
+           SLOT (setFilterWildcard (const QString&)));
   connect (_filter_checkbox, SIGNAL (toggled (bool)),
            this, SLOT (filter_activate (bool)));
   connect (_filter->lineEdit (), SIGNAL (editingFinished ()),
            this, SLOT (update_filter_history ()));
 
   connect (_history_list_view, SIGNAL (doubleClicked (QModelIndex)),
            this, SLOT (handle_double_click (QModelIndex)));
 
@@ -193,22 +195,22 @@ void history_dock_widget::ctxMenu (const
 {
   QMenu menu (this);
 
   QModelIndex index = _history_list_view->indexAt (xpos);
 
   if (index.isValid () && index.column () == 0)
     {
       menu.addAction (resource_manager::icon ("edit-copy"),
-                  tr ("Copy"), this, SLOT (handle_contextmenu_copy (bool)));
+                      tr ("Copy"), this, SLOT (handle_contextmenu_copy (bool)));
       menu.addAction (tr ("Evaluate"), this,
-                  SLOT (handle_contextmenu_evaluate (bool)));
+                      SLOT (handle_contextmenu_evaluate (bool)));
       menu.addAction (resource_manager::icon ("document-new"),
-                  tr ("Create script"), this,
-                  SLOT (handle_contextmenu_create_script (bool)));
+                      tr ("Create script"), this,
+                      SLOT (handle_contextmenu_create_script (bool)));
     }
   if (_filter_shown)
     menu.addAction (tr ("Hide filter"), this,
                     SLOT (handle_contextmenu_filter ()));
   else
     menu.addAction (tr ("Show filter"), this,
                     SLOT (handle_contextmenu_filter ()));
 
@@ -317,17 +319,17 @@ void
 history_dock_widget::copyClipboard ()
 {
   if (_history_list_view->hasFocus ())
     handle_contextmenu_copy (true);
   if (_filter->lineEdit ()->hasFocus ()
       && _filter->lineEdit ()->hasSelectedText ())
     {
       QClipboard *clipboard = QApplication::clipboard ();
-      clipboard->setText ( _filter->lineEdit ()->selectedText ());
+      clipboard->setText (_filter->lineEdit ()->selectedText ());
     }
 }
 
 void
 history_dock_widget::pasteClipboard ()
 {
   if (_filter->lineEdit ()->hasFocus ())
     {
@@ -356,8 +358,9 @@ void history_dock_widget::handle_visibil
   octave_dock_widget::handle_visibility (visible);
 
   if (visible)
     {
       int filter_state = _filter_checkbox->isChecked ();
       filter_activate (filter_state);
     }
 }
+
diff --git a/libgui/src/history-dock-widget.h b/libgui/src/history-dock-widget.h
--- a/libgui/src/history-dock-widget.h
+++ b/libgui/src/history-dock-widget.h
@@ -89,8 +89,9 @@ private:
   QCheckBox *_filter_checkbox;
   QComboBox *_filter;
   QWidget *_filter_widget;
   bool _filter_shown;
   enum { MaxFilterHistory = 10 };
 };
 
 #endif
+
diff --git a/libgui/src/liboctgui-build-info.h b/libgui/src/liboctgui-build-info.h
--- a/libgui/src/liboctgui-build-info.h
+++ b/libgui/src/liboctgui-build-info.h
@@ -27,8 +27,9 @@ along with Octave; see the file COPYING.
 
 #include <ctime>
 
 #include <string>
 
 extern std::string liboctgui_hg_id (void);
 
 #endif
+
diff --git a/libgui/src/liboctgui-build-info.in.cc b/libgui/src/liboctgui-build-info.in.cc
--- a/libgui/src/liboctgui-build-info.in.cc
+++ b/libgui/src/liboctgui-build-info.in.cc
@@ -27,8 +27,9 @@ along with Octave; see the file COPYING.
 
 #include "liboctgui-build-info.h"
 
 std::string
 liboctgui_hg_id (void)
 {
   return "%OCTAVE_HG_ID%";
 }
+
diff --git a/libgui/src/m-editor/file-editor-interface.h b/libgui/src/m-editor/file-editor-interface.h
--- a/libgui/src/m-editor/file-editor-interface.h
+++ b/libgui/src/m-editor/file-editor-interface.h
@@ -82,8 +82,9 @@ public slots:
 
 //protected:
 
 //protected slots:
 
 };
 
 #endif
+
diff --git a/libgui/src/m-editor/file-editor-tab.cc b/libgui/src/m-editor/file-editor-tab.cc
--- a/libgui/src/m-editor/file-editor-tab.cc
+++ b/libgui/src/m-editor/file-editor-tab.cc
@@ -157,20 +157,22 @@ file_editor_tab::file_editor_tab (const 
   _edit_area->setMarginSensitivity (1, true);
   _edit_area->markerDefine (QsciScintilla::RightTriangle, marker::bookmark);
   _edit_area->setMarkerBackgroundColor (QColor (0,0,232), marker::bookmark);
   _edit_area->markerDefine (QsciScintilla::Circle, marker::breakpoint);
   _edit_area->setMarkerBackgroundColor (QColor (192,0,0), marker::breakpoint);
   _edit_area->markerDefine (QsciScintilla::Circle, marker::cond_break);
   _edit_area->setMarkerBackgroundColor (QColor (255,127,0), marker::cond_break);
   _edit_area->markerDefine (QsciScintilla::RightArrow, marker::debugger_position);
-  _edit_area->setMarkerBackgroundColor (QColor (255,255,0), marker::debugger_position);
+  _edit_area->setMarkerBackgroundColor (QColor (255,255,0),
+                                        marker::debugger_position);
   _edit_area->markerDefine (QsciScintilla::RightArrow,
                             marker::unsure_debugger_position);
-  _edit_area->setMarkerBackgroundColor (QColor (192,192,192), marker::unsure_debugger_position);
+  _edit_area->setMarkerBackgroundColor (QColor (192,192,192),
+                                        marker::unsure_debugger_position);
 
   connect (_edit_area, SIGNAL (marginClicked (int, int,
                                               Qt::KeyboardModifiers)),
            this, SLOT (handle_margin_clicked (int, int,
                                               Qt::KeyboardModifiers)));
 
   connect (_edit_area, SIGNAL (context_menu_break_condition_signal (int)),
            this, SLOT (handle_context_menu_break_condition (int)));
@@ -263,17 +265,18 @@ file_editor_tab::set_encoding (const QSt
 
 void
 file_editor_tab::closeEvent (QCloseEvent *e)
 {
   _cancelled = false;  // prevent unwanted interaction of previous
                        // exits of octave which were canceled by the user
 
   if (check_file_modified () == QMessageBox::Cancel)
-    { // ignore close event if file is not saved and user cancels
+    {
+      // ignore close event if file is not saved and user cancels
       // closing this window
       e->ignore ();
     }
   else
     {
       e->accept ();
       emit tab_remove_request ();
     }
@@ -286,23 +289,23 @@ file_editor_tab::set_current_directory (
 }
 
 void
 file_editor_tab::handle_context_menu_edit (const QString& word_at_cursor)
 {
   // search for a subfunction in actual file (this is done at first because
   // octave finds this function before other with same name in the search path
   QRegExp rxfun1 ("^[\t ]*function[^=]+=[\t ]*"
-      + word_at_cursor + "[\t ]*\\([^\\)]*\\)[\t ]*$");
+                  + word_at_cursor + "[\t ]*\\([^\\)]*\\)[\t ]*$");
   QRegExp rxfun2 ("^[\t ]*function[\t ]+"
-      + word_at_cursor + "[\t ]*\\([^\\)]*\\)[\t ]*$");
+                  + word_at_cursor + "[\t ]*\\([^\\)]*\\)[\t ]*$");
   QRegExp rxfun3 ("^[\t ]*function[\t ]+"
-      + word_at_cursor + "[\t ]*$");
+                  + word_at_cursor + "[\t ]*$");
   QRegExp rxfun4 ("^[\t ]*function[^=]+=[\t ]*"
-      + word_at_cursor + "[\t ]*$");
+                  + word_at_cursor + "[\t ]*$");
 
   int pos_fct = -1;
   QStringList lines = _edit_area->text ().split ("\n");
 
   int line;
   for (line = 0; line < lines.count (); line++)
     {
       if ((pos_fct = rxfun1.indexIn (lines.at (line))) != -1)
@@ -311,17 +314,18 @@ file_editor_tab::handle_context_menu_edi
         break;
       if ((pos_fct = rxfun3.indexIn (lines.at (line))) != -1)
         break;
       if ((pos_fct = rxfun4.indexIn (lines.at (line))) != -1)
         break;
     }
 
   if (pos_fct > -1)
-    { // reg expr. found: it is an internal function
+    {
+      // reg expr. found: it is an internal function
       _edit_area->setCursorPosition (line, pos_fct);
       _edit_area->SendScintilla (2232, line);     // SCI_ENSUREVISIBLE
                                                   // SCI_VISIBLEFROMDOCLINE
       int vis_line = _edit_area->SendScintilla(2220, line);
       _edit_area->SendScintilla (2613, vis_line); // SCI_SETFIRSTVISIBLELINE
       return;
     }
 
@@ -458,19 +462,19 @@ file_editor_tab::valid_file_name (const 
 // to save before creating the breakpoint.
 bool
 file_editor_tab::unchanged_or_saved (void)
 {
   bool retval = true;
   if (_edit_area->isModified ())
     {
       int ans = QMessageBox::question (0, tr ("Octave Editor"),
-         tr ("Cannot add breakpoint to modified file.\n"
-             "Save and add breakpoint, or canel?"),
-          QMessageBox::Save | QMessageBox::Cancel, QMessageBox::Save);
+                  tr ("Cannot add breakpoint to modified file.\n"
+                      "Save and add breakpoint, or canel?"),
+                  QMessageBox::Save | QMessageBox::Cancel, QMessageBox::Save);
 
       if (ans == QMessageBox::Save)
         save_file (_file_name, false);
       else
         retval = false;
     }
 
   return retval;
@@ -618,17 +622,18 @@ file_editor_tab::update_lexer ()
 
           if (octave_functions)
             _prep_apis_file += "f";  // use keywords, too
 
           _prep_apis_file += ".pap"; // final name of apis file
 
           // check whether the APIs info needs to be prepared and saved
           QFileInfo apis_file = QFileInfo (_prep_apis_file);
-          update_apis_file = ! apis_file.exists ();  // flag whether apis file needs update
+          // flag whether apis file needs update
+          update_apis_file = ! apis_file.exists ();
 
           // function list depends on installed packages: check mod. date
           if (! update_apis_file && octave_functions)
             {
               // check whether package file is newer than apis_file
               QDateTime apis_date = apis_file.lastModified ();
 
               // compare to local package list
@@ -639,26 +644,26 @@ file_editor_tab::update_lexer ()
                              + "/.octave_packages");
 #else
               QFileInfo local_pkg_list
                 = QFileInfo (QStandardPaths::writableLocation (QStandardPaths::HomeLocation)
                              + "/.octave_packages");
 #endif
 
               if (local_pkg_list.exists ()
-                  & (apis_date < local_pkg_list.lastModified ()) )
+                  && (apis_date < local_pkg_list.lastModified ()))
                 update_apis_file = true;
 
               // compare to global package list
               // FIXME: How to get user chosen location?
               QFileInfo global_pkg_list = QFileInfo (
                                         QString::fromStdString (Voctave_home)
                                         + "/share/octave/octave_packages");
                if (global_pkg_list.exists ()
-                   && (apis_date < global_pkg_list.lastModified ()) )
+                   && (apis_date < global_pkg_list.lastModified ()))
                 update_apis_file = true;
             }
           }
         else  // no octave file, just add extension
           {
             _prep_apis_file = prep_apis_path + lexer->lexer () + ".pap";
           }
 
@@ -2690,8 +2695,9 @@ file_editor_tab::get_function_name ()
       else if (rxfun4.indexIn (lines.at (i)) != -1)
         return rxfun4.cap (1).remove (QRegExp("[ \t]*"));
     }
 
   return QString ();
 }
 
 #endif
+
diff --git a/libgui/src/m-editor/file-editor-tab.h b/libgui/src/m-editor/file-editor-tab.h
--- a/libgui/src/m-editor/file-editor-tab.h
+++ b/libgui/src/m-editor/file-editor-tab.h
@@ -300,8 +300,9 @@ private:
 
   int _line;
   int _col;
   bool _lines_changed;
 
 };
 
 #endif
+
diff --git a/libgui/src/m-editor/file-editor.cc b/libgui/src/m-editor/file-editor.cc
--- a/libgui/src/m-editor/file-editor.cc
+++ b/libgui/src/m-editor/file-editor.cc
@@ -289,22 +289,22 @@ file_editor::request_open_file (void)
   connect (combo_enc, SIGNAL (currentIndexChanged (QString)),
            this, SLOT (handle_combo_enc_current_index (QString)));
 
   // build the extra grid layout
   extra->addWidget (separator,0,0,1,3);
   extra->addWidget (label_enc,1,0);
   extra->addWidget (combo_enc,1,1);
   extra->addItem   (new QSpacerItem (1,20,QSizePolicy::Expanding,
-                                          QSizePolicy::Fixed), 1,2);
+                                     QSizePolicy::Fixed), 1,2);
 
   // and add the extra grid layout to the dialog's layout
   QGridLayout *dialog_layout = dynamic_cast<QGridLayout*> (fileDialog->layout ());
   dialog_layout->addLayout (extra,dialog_layout->rowCount (),0,
-                                  1,dialog_layout->columnCount ());
+                            1,dialog_layout->columnCount ());
 
   fileDialog->setAcceptMode (QFileDialog::AcceptOpen);
   fileDialog->setViewMode (QFileDialog::Detail);
   fileDialog->setFileMode (QFileDialog::ExistingFiles);
   fileDialog->setDirectory (ced);
 
   connect (fileDialog, SIGNAL (filesSelected (const QStringList&)),
            this, SLOT (request_open_files (const QStringList&)));
@@ -363,19 +363,19 @@ file_editor::call_custom_editor (const Q
         {
           QMessageBox *msgBox
             = new QMessageBox (QMessageBox::Critical,
                                tr ("Octave Editor"),
                                tr ("Could not start custom file editor\n%1").
                                arg (editor),
                                QMessageBox::Ok, this);
 
-           msgBox->setWindowModality (Qt::NonModal);
-           msgBox->setAttribute (Qt::WA_DeleteOnClose);
-           msgBox->show ();
+          msgBox->setWindowModality (Qt::NonModal);
+          msgBox->setAttribute (Qt::WA_DeleteOnClose);
+          msgBox->show ();
         }
 
       if (line < 0 && ! file_name.isEmpty ())
         handle_mru_add_file (QFileInfo (file_name).canonicalFilePath (),
                              QString ());
 
       return true;
     }
@@ -677,17 +677,18 @@ file_editor::handle_edit_mfile_request (
                          map.contents ("type").data ()[0].string_value ());
   QString name = QString::fromStdString (
                          map.contents ("name").data ()[0].string_value ());
 
   QString message = QString ();
   QString filename = QString ();
 
   if (type == QString("built-in function"))
-    { // built in function: can't edit
+    {
+      // built in function: can't edit
       message = tr ("%1 is a built-in function");
     }
   else if (type.isEmpty ())
     {
       // function not known to octave -> try directory of edited file
       // get directory
       QDir dir;
       if (ffile.isEmpty ())
@@ -703,17 +704,18 @@ file_editor::handle_edit_mfile_request (
       // function not known to octave -> try directory of edited file
       QFileInfo file = QFileInfo (dir, fname + ".m");
 
       if (file.exists ())
         {
           filename = file.canonicalFilePath (); // local file exists
         }
       else
-        { // local file does not exist -> try private directory
+        {
+          // local file does not exist -> try private directory
           file = QFileInfo (ffile);
           file = QFileInfo (QDir (file.canonicalPath () + "/private"),
                             fname + ".m");
 
           if (file.exists ())
             {
               filename = file.canonicalFilePath ();  // private function exists
             }
@@ -722,28 +724,28 @@ file_editor::handle_edit_mfile_request (
               message = tr ("Can not find function %1");  // no file found
             }
         }
     }
 
   if (! message.isEmpty ())
     {
       QMessageBox *msgBox
-          = new QMessageBox (QMessageBox::Critical,
-                             tr ("Octave Editor"),
-                             message.arg (name),
-                             QMessageBox::Ok, this);
+        = new QMessageBox (QMessageBox::Critical,
+                           tr ("Octave Editor"),
+                           message.arg (name),
+                           QMessageBox::Ok, this);
 
       msgBox->setWindowModality (Qt::NonModal);
       msgBox->setAttribute (Qt::WA_DeleteOnClose);
       msgBox->show ();
       return;
     }
 
-  if ( filename.isEmpty ())
+  if (filename.isEmpty ())
     filename = QString::fromStdString (
                            map.contents ("file").data ()[0].string_value ());
 
   if (! filename.endsWith (".m"))
     filename.append (".m");
 
   request_open_file (filename, QString (), line);  // default encoding
 }
@@ -1160,18 +1162,18 @@ file_editor::handle_file_name_changed (c
             }
         }
     }
 }
 
 void
 file_editor::request_close_file (bool)
 {
-  file_editor_tab *editor_tab =
-      static_cast<file_editor_tab *> (_tab_widget->currentWidget ());
+  file_editor_tab *editor_tab
+    = static_cast<file_editor_tab *> (_tab_widget->currentWidget ());
   editor_tab->conditional_close ();
 }
 
 void
 file_editor::request_close_all_files (bool)
 {
   file_editor_tab *editor_tab;
 
@@ -1189,28 +1191,28 @@ file_editor::request_close_other_files (
   file_editor_tab *editor_tab;
   QWidget *tabID = _tab_widget->currentWidget ();
 
   // loop over all tabs starting from last one otherwise deletion changes index
   for (int index = _tab_widget->count ()-1; index >= 0; index--)
     {
       if (tabID != _tab_widget->widget (index))
         {
-          editor_tab =
-              static_cast<file_editor_tab *> (_tab_widget->widget (index));
+          editor_tab
+            = static_cast<file_editor_tab *> (_tab_widget->widget (index));
           editor_tab->conditional_close ();
         }
     }
 }
 
 void
 file_editor::handle_tab_close_request (int index)
 {
-  file_editor_tab *editor_tab =
-       static_cast<file_editor_tab *> (_tab_widget->widget (index));
+  file_editor_tab *editor_tab
+    = static_cast<file_editor_tab *> (_tab_widget->widget (index));
   editor_tab->conditional_close ();
 }
 
 void
 file_editor::handle_tab_remove_request (void)
 {
   QObject *fileEditorTab = sender ();
   if (fileEditorTab)
@@ -1557,17 +1559,18 @@ file_editor::construct (void)
 
   // the mru-list and an empty array of actions
   QSettings *settings = resource_manager::get_settings ();
   _mru_files = settings->value ("editor/mru_file_list").toStringList ();
   _mru_files_encodings = settings->value ("editor/mru_file_encodings")
                                    .toStringList ();
 
   if (_mru_files_encodings.count () != _mru_files.count ())
-    { // encodings don't have the same count -> do not use them!
+    {
+      // encodings don't have the same count -> do not use them!
       _mru_files_encodings = QStringList ();
       for (int i = 0; i < _mru_files.count (); i++)
         _mru_files_encodings << QString ();
     }
 
   for (int i = 0; i < MaxMRUFiles; ++i)
     {
       _mru_file_actions[i] = new QAction (this);
@@ -1938,17 +1941,17 @@ file_editor::restore_session (QSettings 
         continue;
 
       session_data item = { QString (), sessionFileNames.at (n), QString ()};
       if (do_index)
         item.index = session_index.at (n);
       if (do_encoding)
         item.encoding = session_encodings.at (n);
 
-     s_data << item;
+      s_data << item;
     }
 
   qSort (s_data);
 
   // finally open the file with the desired encoding in the desired order
   for (int n = 0; n < s_data.count (); ++n)
     request_open_file (s_data.at (n).file_name, s_data.at (n).encoding);
 }
@@ -1963,50 +1966,53 @@ file_editor::add_file_editor_tab (file_e
            this, SLOT (edit_status_update (bool, bool)));
 
   connect (f->qsci_edit_area (), SIGNAL (show_doc_signal (const QString&)),
            main_win (), SLOT (handle_show_doc (const QString&)));
 
   connect (f->qsci_edit_area (), SIGNAL (create_context_menu_signal (QMenu *)),
            this, SLOT (create_context_menu (QMenu *)));
 
-  connect (f->qsci_edit_area (), SIGNAL (execute_command_in_terminal_signal (const QString&)),
+  connect (f->qsci_edit_area (),
+           SIGNAL (execute_command_in_terminal_signal (const QString&)),
            main_win (), SLOT (execute_command_in_terminal (const QString&)));
 
   // Signals from the file editor_tab
   connect (f, SIGNAL (file_name_changed (const QString&, const QString&)),
            this, SLOT (handle_file_name_changed (const QString&,
                                                  const QString&)));
 
   connect (f, SIGNAL (editor_state_changed (bool, bool)),
            this, SLOT (handle_editor_state_changed (bool, bool)));
 
   connect (f, SIGNAL (tab_remove_request ()),
            this, SLOT (handle_tab_remove_request ()));
 
   connect (f, SIGNAL (add_filename_to_list (const QString&,
                                             const QString&, QWidget*)),
            this, SLOT (handle_add_filename_to_list (const QString&,
-                                                    const QString&, QWidget*)));
+                                                    const QString&,
+                                                    QWidget*)));
 
   connect (f, SIGNAL (editor_check_conflict_save (const QString&, bool)),
            this, SLOT (check_conflict_save (const QString&, bool)));
 
   connect (f, SIGNAL (mru_add_file (const QString&, const QString&)),
            this, SLOT (handle_mru_add_file (const QString&, const QString&)));
 
   connect (f, SIGNAL (run_file_signal (const QFileInfo&)),
            main_win (), SLOT (run_file_in_terminal (const QFileInfo&)));
 
   connect (f, SIGNAL (request_open_file (const QString&)),
            this, SLOT (request_open_file (const QString&)));
 
   connect (f, SIGNAL (edit_mfile_request (const QString&, const QString&,
                                           const QString&, int)),
-           this, SLOT (handle_edit_mfile_request (const QString&, const QString&,
+           this, SLOT (handle_edit_mfile_request (const QString&,
+                                                  const QString&,
                                                   const QString&, int)));
 
   // Signals from the file_editor non-trivial operations
   connect (this, SIGNAL (fetab_settings_changed (const QSettings *)),
            f, SLOT (settings_changed (const QSettings *)));
 
   connect (this, SIGNAL (fetab_change_request (const QWidget*)),
            f, SLOT (change_editor_state (const QWidget*)));
@@ -2078,32 +2084,34 @@ file_editor::add_file_editor_tab (file_e
            f, SLOT (next_breakpoint (const QWidget*)));
 
   connect (this, SIGNAL (fetab_previous_breakpoint (const QWidget*)),
            f, SLOT (previous_breakpoint (const QWidget*)));
 
   connect (this, SIGNAL (fetab_remove_all_breakpoints (const QWidget*)),
            f, SLOT (remove_all_breakpoints (const QWidget*)));
 
-  connect (this, SIGNAL (fetab_scintilla_command (const QWidget *, unsigned int)),
+  connect (this, SIGNAL (fetab_scintilla_command (const QWidget *,
+                                                  unsigned int)),
            f, SLOT (scintilla_command (const QWidget *, unsigned int)));
 
   connect (this, SIGNAL (fetab_comment_selected_text (const QWidget*)),
            f, SLOT (comment_selected_text (const QWidget*)));
 
   connect (this, SIGNAL (fetab_uncomment_selected_text (const QWidget*)),
            f, SLOT (uncomment_selected_text (const QWidget*)));
 
   connect (this, SIGNAL (fetab_indent_selected_text (const QWidget*)),
            f, SLOT (indent_selected_text (const QWidget*)));
 
   connect (this, SIGNAL (fetab_unindent_selected_text (const QWidget*)),
            f, SLOT (unindent_selected_text (const QWidget*)));
 
-  connect (this, SIGNAL (fetab_convert_eol (const QWidget*, QsciScintilla::EolMode)),
+  connect (this,
+           SIGNAL (fetab_convert_eol (const QWidget*, QsciScintilla::EolMode)),
            f, SLOT (convert_eol (const QWidget*, QsciScintilla::EolMode)));
 
   connect (this, SIGNAL (fetab_find (const QWidget*, QList<QAction *>)),
            f, SLOT (find (const QWidget*, QList<QAction *>)));
 
   connect (this, SIGNAL (fetab_find_next (const QWidget*)),
            f, SLOT (find_next (const QWidget*)));
 
@@ -2326,43 +2334,43 @@ file_editor::empty_script (bool startup,
   request_new_file ("");
 }
 
 // This slot is a reimplementation of the virtual slot in octave_dock_widget.
 // We need this for creating an empty script when the editor has no open files
 // and is made visible
 void
 file_editor::handle_visibility (bool visible)
-  {
-    empty_script (false, visible);
+{
+  empty_script (false, visible);
 
-    if (visible && ! isFloating ())
-      focus ();
-  }
+  if (visible && ! isFloating ())
+    focus ();
+}
 
 void
 file_editor::dragEnterEvent (QDragEnterEvent *e)
-  {
-    if (e->mimeData ()->hasUrls ())
-      {
-        e->acceptProposedAction();
-      }
-  }
+{
+  if (e->mimeData ()->hasUrls ())
+    {
+      e->acceptProposedAction();
+    }
+}
 
 void
 file_editor::dropEvent (QDropEvent *e)
-  {
-    if (e->mimeData ()->hasUrls ())
+{
+  if (e->mimeData ()->hasUrls ())
+    {
+      foreach (QUrl url, e->mimeData ()->urls ())
       {
-        foreach (QUrl url, e->mimeData ()->urls ())
-        {
-          request_open_file (url.toLocalFile ());
-        }
+        request_open_file (url.toLocalFile ());
       }
-  }
+    }
+}
 
 // slots for tab navigation
 void
 file_editor::switch_left_tab ()
 {
   switch_tab (-1);
 }
 void
@@ -2407,8 +2415,9 @@ file_editor::switch_tab (int direction, 
       focus ();
 #endif
     }
   else
     _tab_widget->setCurrentIndex (new_pos);
 }
 
 #endif
+
diff --git a/libgui/src/m-editor/file-editor.h b/libgui/src/m-editor/file-editor.h
--- a/libgui/src/m-editor/file-editor.h
+++ b/libgui/src/m-editor/file-editor.h
@@ -52,57 +52,57 @@ public:
 
 class file_editor : public file_editor_interface
 {
   Q_OBJECT
 
 public:
 
   struct tab_info
-    {
-      QWidget *fet_ID;
-      QString  encoding;
-    };
+  {
+    QWidget *fet_ID;
+    QString  encoding;
+  };
 
   typedef std::map<QString, tab_info>::iterator editor_tab_map_iterator;
   typedef std::map<QString, tab_info>::const_iterator editor_tab_map_const_iterator;
 
   // struct that allows to sort with respect to the tab index
   struct session_data
+  {
+    QString index;
+    QString file_name;
+    QString encoding;
+    bool operator<(const session_data &other) const
     {
-      QString index;
-      QString file_name;
-      QString encoding;
-      bool operator<(const session_data &other) const
-        {
-          return index < other.index;
-        }
-    };
+      return index < other.index;
+    }
+  };
 
   file_editor (QWidget *p);
   ~file_editor (void);
 
   void loadFile (const QString& fileName);
 
   QMenu *get_mru_menu (void) { return _mru_file_menu; }
   QMenu *debug_menu (void);
   QToolBar *toolbar (void);
 
   void insert_global_actions (QList<QAction*>);
   enum shared_actions_idx
-    {
-      NEW_SCRIPT_ACTION = 0,
-      NEW_FUNCTION_ACTION,
-      OPEN_ACTION,
-      FIND_FILES_ACTION,
-      UNDO_ACTION,
-      COPY_ACTION,
-      PASTE_ACTION,
-      SELECTALL_ACTION
-    };
+  {
+    NEW_SCRIPT_ACTION = 0,
+    NEW_FUNCTION_ACTION,
+    OPEN_ACTION,
+    FIND_FILES_ACTION,
+    UNDO_ACTION,
+    COPY_ACTION,
+    PASTE_ACTION,
+    SELECTALL_ACTION
+  };
 
   void handle_enter_debug_mode (void);
   void handle_exit_debug_mode (void);
 
   void check_actions (void);
   void empty_script (bool startup, bool visible);
 
 signals:
@@ -435,8 +435,9 @@ private:
   enum { MaxMRUFiles = 10 };
   QMenu *_mru_file_menu;
   QAction *_mru_file_actions[MaxMRUFiles];
   QStringList _mru_files;
   QStringList _mru_files_encodings;
 };
 
 #endif
+
diff --git a/libgui/src/m-editor/find-dialog.cc b/libgui/src/m-editor/find-dialog.cc
--- a/libgui/src/m-editor/find-dialog.cc
+++ b/libgui/src/m-editor/find-dialog.cc
@@ -315,39 +315,39 @@ find_dialog::find (bool forward)
               line = _edit_area->lines () - 1;
               col  = _edit_area->text (line).length () - 1;
               if (col == -1)
                 col = 0;
             }
         }
       else if (! do_forward)
         {
-           // search from position before search characters text length
-           // if search backward on existing results,
-           _edit_area->getCursorPosition (&line,&col);
-           if (_find_result_available && _edit_area->hasSelectedText ())
-             {
-               int currpos = _edit_area->positionFromLineIndex(line,col);
-               currpos -= (_search_line_edit->text ().length ());
-               if (currpos < 0)
-                 currpos = 0;
-               _edit_area->lineIndexFromPosition(currpos, &line,&col);
-             }
+          // search from position before search characters text length
+          // if search backward on existing results,
+          _edit_area->getCursorPosition (&line,&col);
+          if (_find_result_available && _edit_area->hasSelectedText ())
+            {
+              int currpos = _edit_area->positionFromLineIndex(line,col);
+              currpos -= (_search_line_edit->text ().length ());
+              if (currpos < 0)
+                currpos = 0;
+              _edit_area->lineIndexFromPosition(currpos, &line,&col);
+            }
         }
     }
 
   if (_edit_area)
     {
       if (_edit_area->hasSelectedText ()
           && _search_selection_check_box->isChecked ())
         {
 #if defined (HAVE_QSCI_FINDSELECTION)
-           if (_find_result_available)
-             _find_result_available = _edit_area->findNext ();
-           else
+          if (_find_result_available)
+            _find_result_available = _edit_area->findNext ();
+          else
             _find_result_available
               = _edit_area->findFirstInSelection (
                                       _search_line_edit->text (),
                                       _regex_check_box->isChecked (),
                                       _case_check_box->isChecked (),
                                       _whole_words_check_box->isChecked (),
                                       do_forward,
                                       true
@@ -356,25 +356,25 @@ find_dialog::find (bool forward)
 #endif
                                       );
 #endif
         }
       else
         {
           _find_result_available
             = _edit_area->findFirst (_search_line_edit->text (),
-                                    _regex_check_box->isChecked (),
-                                    _case_check_box->isChecked (),
-                                    _whole_words_check_box->isChecked (),
-                                    do_wrap,
-                                    do_forward,
-                                    line,col,
-                                    true
+                                     _regex_check_box->isChecked (),
+                                     _case_check_box->isChecked (),
+                                     _whole_words_check_box->isChecked (),
+                                     do_wrap,
+                                     do_forward,
+                                     line,col,
+                                     true
 #if defined (HAVE_QSCI_VERSION_2_6_0)
-                                    , true
+                                     , true
 #endif
                                     );
         }
     }
 
   if (_find_result_available)
     _from_start_check_box->setChecked (0);
   else if (! _rep_all)
@@ -444,8 +444,9 @@ void
 find_dialog::no_matches_message ()
 {
   QMessageBox msg_box (QMessageBox::Information, tr ("Find Result"),
                        tr ("No more matches found"), QMessageBox::Ok, this);
   msg_box.exec ();
 }
 
 #endif
+
diff --git a/libgui/src/m-editor/find-dialog.h b/libgui/src/m-editor/find-dialog.h
--- a/libgui/src/m-editor/find-dialog.h
+++ b/libgui/src/m-editor/find-dialog.h
@@ -118,8 +118,9 @@ private:
   QWidget           *_extension;
   QsciScintilla     *_edit_area;
   bool               _find_result_available;
   int                _rep_all;
   bool               _rep_active;
 };
 
 #endif
+
diff --git a/libgui/src/m-editor/marker.cc b/libgui/src/m-editor/marker.cc
--- a/libgui/src/m-editor/marker.cc
+++ b/libgui/src/m-editor/marker.cc
@@ -103,28 +103,30 @@ marker::handle_find_translation (int lin
     {
       translation_linenr = _edit_area->markerLine (_mhandle);
       bp = this;
     }
 }
 
 
 void
-marker::handle_find_just_before (int linenr, int& original_linenr, int& editor_linenr)
+marker::handle_find_just_before (int linenr, int& original_linenr,
+                                 int& editor_linenr)
 {
   if (_original_linenr < linenr && _original_linenr >= original_linenr)
     {
       original_linenr = _original_linenr;
       editor_linenr = _edit_area->markerLine (_mhandle);
     }
 }
 
 
 void
-marker::handle_find_just_after (int linenr, int& original_linenr, int& editor_linenr)
+marker::handle_find_just_after (int linenr, int& original_linenr,
+                                int& editor_linenr)
 {
   if (_original_linenr > linenr && _original_linenr <= original_linenr)
     {
       original_linenr = _original_linenr;
       editor_linenr = _edit_area->markerLine (_mhandle);
     }
 }
 
@@ -164,20 +166,22 @@ marker::handle_marker_line_undeleted (in
 {
   // FUTURE SUPPORT: There really should be a signal in QsciScintilla
   // called markerLineUndeleted (int mhandle) because there is no way
   // of knowing this.  QsciScintilla will place the marker at a
   // different line rather than remove it from the margin.  I (DJS) will
   // lobby for such a signal.
   if (_mhandle == mhandle)
     {
-      if (_marker_type == unsure_breakpoint || _marker_type == unsure_debugger_position)
+      if (_marker_type == unsure_breakpoint
+          || _marker_type == unsure_debugger_position)
         {
           int editor_linenr = _edit_area->markerLine (_mhandle);
           _edit_area->markerDeleteHandle(_mhandle);
           _marker_type = _marker_type == unsure_breakpoint ? breakpoint
                                                            : debugger_position;
           _mhandle = _edit_area->markerAdd (editor_linenr, _marker_type);
         }
     }
 }
 
 #endif
+
diff --git a/libgui/src/m-editor/marker.h b/libgui/src/m-editor/marker.h
--- a/libgui/src/m-editor/marker.h
+++ b/libgui/src/m-editor/marker.h
@@ -41,24 +41,24 @@ class marker : public QObject
   Q_OBJECT
 
 public:
 
   // List of all marker types
   // If multiple markers are on the same line, the first one listed
   // is drawn at the back, so big ones should be first.
   enum editor_markers
-    {
-      breakpoint,
-      cond_break,
-      unsure_breakpoint,
-      bookmark,
-      debugger_position,
-      unsure_debugger_position
-    };
+  {
+    breakpoint,
+    cond_break,
+    unsure_breakpoint,
+    bookmark,
+    debugger_position,
+    unsure_debugger_position
+  };
 
   marker (QsciScintilla *edit_area, int original_linenr,
           editor_markers marker_type, const QString& condition = "");
   marker (QsciScintilla *edit_area, int original_linenr,
           editor_markers marker_type, int editor_linenr,
           const QString& condition = "");
   ~marker (void);
 
@@ -67,19 +67,21 @@ public:
   void set_cond (const QString& cond) { _condition = cond; }
 
 public slots:
   void handle_remove_via_original_linenr (int original_linenr);
   void handle_request_remove_via_editor_linenr (int editor_linenr);
   void handle_remove (void);
   void handle_find_translation (int original_linenr, int& editor_linenr,
                                 marker*& bp);
-  void handle_find_just_before (int linenr, int& original_linenr, int& editor_linenr);
-  void handle_find_just_after (int linenr, int& original_linenr, int& editor_linenr);
-/*  void handle_lines_changed (void);*/
+  void handle_find_just_before (int linenr, int& original_linenr,
+                                int& editor_linenr);
+  void handle_find_just_after (int linenr, int& original_linenr,
+                               int& editor_linenr);
+  /*  void handle_lines_changed (void);*/
   void handle_marker_line_deleted (int mhandle);
   void handle_marker_line_undeleted (int mhandle);
   void handle_report_editor_linenr (QIntList& lines, QStringList& conditions);
 
 signals:
   void request_remove (int original_linenr);
 
 private:
diff --git a/libgui/src/m-editor/octave-qscintilla.cc b/libgui/src/m-editor/octave-qscintilla.cc
--- a/libgui/src/m-editor/octave-qscintilla.cc
+++ b/libgui/src/m-editor/octave-qscintilla.cc
@@ -69,38 +69,38 @@ octave_qscintilla::octave_qscintilla (QW
 #else
   // find commands via its default key (tricky way without find ())
   QList< QsciCommand * > cmd_list = cmd_set->commands ();
   for (int i = 0; i < cmd_list.length (); i++)
     {
       int cmd_key = cmd_list.at (i)->key ();
       switch (cmd_key)
         {
-          case Qt::Key_C | Qt::CTRL :               // SelectionCopy
-          case Qt::Key_X | Qt::CTRL :               // SelectionCut
-          case Qt::Key_V | Qt::CTRL :               // Paste
-          case Qt::Key_A | Qt::CTRL :               // SelectAll
-          case Qt::Key_D | Qt::CTRL :               // SelectionDuplicate
-          case Qt::Key_T | Qt::CTRL :               // LineTranspose
-          case Qt::Key_Z | Qt::CTRL :               // Undo
-          case Qt::Key_Y | Qt::CTRL :               // Redo
-          case Qt::Key_Z | Qt::CTRL | Qt::SHIFT :   // Redo
-          case Qt::Key_U | Qt::CTRL :               // SelectionLowerCase
-          case Qt::Key_U | Qt::CTRL | Qt::SHIFT :   // SelectionUpperCase
-          case Qt::Key_Plus | Qt::CTRL :            // ZoomIn
-          case Qt::Key_Minus | Qt::CTRL :           // ZoomOut
-          case Qt::Key_Backspace | Qt::CTRL | Qt::SHIFT :   // DeleteLineLeft
-          case Qt::Key_Delete | Qt::CTRL | Qt::SHIFT :      // DeleteLineRight
-          case Qt::Key_K | Qt::META :                       // DeleteLineRight
-          case Qt::Key_Backspace | Qt::CTRL :       // DeleteWordLeft
-          case Qt::Key_Delete | Qt::CTRL :          // DeleteWordRight
-          case Qt::Key_L | Qt::CTRL | Qt::SHIFT :   // LineDelete
-          case Qt::Key_L | Qt::CTRL :               // LineCut
-          case Qt::Key_T | Qt::CTRL | Qt::SHIFT :   // LineCopy
-            cmd_list.at (i)->setKey (0);
+        case Qt::Key_C | Qt::CTRL :               // SelectionCopy
+        case Qt::Key_X | Qt::CTRL :               // SelectionCut
+        case Qt::Key_V | Qt::CTRL :               // Paste
+        case Qt::Key_A | Qt::CTRL :               // SelectAll
+        case Qt::Key_D | Qt::CTRL :               // SelectionDuplicate
+        case Qt::Key_T | Qt::CTRL :               // LineTranspose
+        case Qt::Key_Z | Qt::CTRL :               // Undo
+        case Qt::Key_Y | Qt::CTRL :               // Redo
+        case Qt::Key_Z | Qt::CTRL | Qt::SHIFT :   // Redo
+        case Qt::Key_U | Qt::CTRL :               // SelectionLowerCase
+        case Qt::Key_U | Qt::CTRL | Qt::SHIFT :   // SelectionUpperCase
+        case Qt::Key_Plus | Qt::CTRL :            // ZoomIn
+        case Qt::Key_Minus | Qt::CTRL :           // ZoomOut
+        case Qt::Key_Backspace | Qt::CTRL | Qt::SHIFT :   // DeleteLineLeft
+        case Qt::Key_Delete | Qt::CTRL | Qt::SHIFT :      // DeleteLineRight
+        case Qt::Key_K | Qt::META :                       // DeleteLineRight
+        case Qt::Key_Backspace | Qt::CTRL :       // DeleteWordLeft
+        case Qt::Key_Delete | Qt::CTRL :          // DeleteWordRight
+        case Qt::Key_L | Qt::CTRL | Qt::SHIFT :   // LineDelete
+        case Qt::Key_L | Qt::CTRL :               // LineCut
+        case Qt::Key_T | Qt::CTRL | Qt::SHIFT :   // LineCopy
+          cmd_list.at (i)->setKey (0);
         }
     }
 #endif
 
 #if defined (Q_OS_MAC)
   // Octave interprets Cmd key as Meta whereas Qscintilla interprets it
   // as Ctrl. We thus invert Meta/Ctrl in Qscintilla's shortcuts list.
   QList< QsciCommand * > cmd_list_mac = cmd_set->commands ();
@@ -238,31 +238,31 @@ octave_qscintilla::contextMenuEvent (QCo
                                        this, SLOT (contextmenu_help (bool)));
               context_menu->addAction (tr ("Documentation on")
                                        + " " + _word_at_cursor,
                                        this, SLOT (contextmenu_doc (bool)));
               context_menu->addAction (tr ("Edit") + " " + _word_at_cursor,
                                        this, SLOT (contextmenu_edit (bool)));
             }
         }
-      }
+    }
 #if defined (HAVE_QSCI_VERSION_2_6_0)
-    else
-      {
-        // remove all standard actions from scintilla
-        QList<QAction *> all_actions = context_menu->actions ();
-        QAction* a;
+  else
+    {
+      // remove all standard actions from scintilla
+      QList<QAction *> all_actions = context_menu->actions ();
+      QAction* a;
 
-        foreach (a, all_actions)
-          context_menu->removeAction (a);
+      foreach (a, all_actions)
+      context_menu->removeAction (a);
 
-        a = context_menu->addAction (tr ("dbstop if ..."), this,
-                                     SLOT (contextmenu_break_condition (bool)));
-        a->setData (local_pos);
-      }
+      a = context_menu->addAction (tr ("dbstop if ..."), this,
+                                   SLOT (contextmenu_break_condition (bool)));
+      a->setData (local_pos);
+    }
 #endif
 
   // finaly show the menu
   context_menu->exec (global_pos);
 #endif
 }
 
 // handle the menu entry for calling help or doc
@@ -338,8 +338,9 @@ octave_qscintilla::text_changed ()
 void octave_qscintilla::focusInEvent(QFocusEvent *focusEvent)
 {
   emit status_update (isUndoAvailable (), isRedoAvailable ());
 
   QsciScintilla::focusInEvent(focusEvent);
 }
 
 #endif
+
diff --git a/libgui/src/m-editor/octave-qscintilla.h b/libgui/src/m-editor/octave-qscintilla.h
--- a/libgui/src/m-editor/octave-qscintilla.h
+++ b/libgui/src/m-editor/octave-qscintilla.h
@@ -76,8 +76,9 @@ protected:
 
 private:
 
   QString _word_at_cursor;
 
 };
 
 #endif
+
diff --git a/libgui/src/m-editor/octave-txt-lexer.cc b/libgui/src/m-editor/octave-txt-lexer.cc
--- a/libgui/src/m-editor/octave-txt-lexer.cc
+++ b/libgui/src/m-editor/octave-txt-lexer.cc
@@ -49,8 +49,9 @@ octave_txt_lexer::language () const
 
 const char*
 octave_txt_lexer::lexer () const
 {
   return "text";
 }
 
 #endif
+
diff --git a/libgui/src/m-editor/octave-txt-lexer.h b/libgui/src/m-editor/octave-txt-lexer.h
--- a/libgui/src/m-editor/octave-txt-lexer.h
+++ b/libgui/src/m-editor/octave-txt-lexer.h
@@ -37,8 +37,9 @@ public:
 
   virtual const char *language () const;
   virtual const char *lexer () const;
   virtual QString description (int style) const;
 
 };
 
 #endif
+
diff --git a/libgui/src/main-window.cc b/libgui/src/main-window.cc
--- a/libgui/src/main-window.cc
+++ b/libgui/src/main-window.cc
@@ -191,18 +191,18 @@ main_window::focus_changed (QWidget *, Q
       w_new = qobject_cast<QWidget *> (w_new->previousInFocusChain ());
       if (w_new == start)
         break; // we have arrived where we began ==> exit loop
 
       count++;
     }
 
   // editor needs extra handling
-  octave_dock_widget *edit_dock_widget =
-                        static_cast<octave_dock_widget *> (editor_window);
+  octave_dock_widget *edit_dock_widget
+    = static_cast<octave_dock_widget *> (editor_window);
   // if new dock has focus, emit signal and store active focus
   // except editor changes to a dialog (dock=0)
   if ((dock || _active_dock != edit_dock_widget) && (dock != _active_dock))
     {
       // signal to all dock widgets for updating the style
       emit active_dock_changed (_active_dock, dock);
 
       QList<QDockWidget *> tabbed = tabifiedDockWidgets (dock);
@@ -252,19 +252,19 @@ void
 main_window::report_status_message (const QString& statusMessage)
 {
   status_bar->showMessage (statusMessage, 1000);
 }
 
 void
 main_window::handle_save_workspace_request (void)
 {
-  QString file =
-    QFileDialog::getSaveFileName (this, tr ("Save Workspace As"), ".", 0, 0,
-                                  QFileDialog::DontUseNativeDialog);
+  QString file
+    = QFileDialog::getSaveFileName (this, tr ("Save Workspace As"), ".", 0, 0,
+                                    QFileDialog::DontUseNativeDialog);
 
   if (! file.isEmpty ())
     octave_link::post_event (this, &main_window::save_workspace_callback,
                              file.toStdString ());
 }
 
 void
 main_window::handle_load_workspace_request (const QString& file_arg)
@@ -646,17 +646,18 @@ main_window::open_donate_page (void)
 {
   QDesktopServices::openUrl (QUrl ("http://octave.org/donate.html"));
 }
 
 void
 main_window::process_settings_dialog_request (const QString& desired_tab)
 {
   if (_settings_dlg)  // _settings_dlg is a guarded pointer!
-    {                 // here the dialog is still open and called once again
+    {
+      // here the dialog is still open and called once again
       if (! desired_tab.isEmpty ())
         _settings_dlg->show_tab (desired_tab);
       return;
     }
 
   _settings_dlg = new settings_dialog (this, desired_tab);
 
   connect (_settings_dlg, SIGNAL (apply_new_settings ()),
@@ -736,17 +737,17 @@ main_window::notice_settings (const QSet
     }
 
   QString icon;
   foreach (octave_dock_widget *widget, dock_widget_list ())
     {
       QString name = widget->objectName ();
       if (! name.isEmpty ())
         { // if children has a name
-          icon = widget_icon_data[icon_set_found].path; // prefix or octave-logo
+          icon = widget_icon_data[icon_set_found].path; // prefix | octave-logo
           if (widget_icon_data[icon_set_found].name != "NONE")
             icon += name + ".png"; // add widget name and ext.
           widget->setWindowIcon (QIcon (icon));
         }
     }
   if (widget_icon_data[icon_set_found].name != "NONE")
     _release_notes_icon = widget_icon_data[icon_set_found].path
                           + "ReleaseWidget.png";
@@ -764,21 +765,21 @@ main_window::notice_settings (const QSet
 
   _main_tool_bar->setIconSize (QSize (icon_size,icon_size));
 
   if (settings->value ("show_status_bar",true).toBool ())
     status_bar->show ();
   else
     status_bar->hide ();
 
-  _prevent_readline_conflicts =
-    settings->value ("shortcuts/prevent_readline_conflicts", true).toBool ();
-
-  _suppress_dbg_location =
-        ! settings->value ("terminal/print_debug_location", false).toBool ();
+  _prevent_readline_conflicts
+    = settings->value ("shortcuts/prevent_readline_conflicts", true).toBool ();
+
+  _suppress_dbg_location
+    = ! settings->value ("terminal/print_debug_location", false).toBool ();
 
   resource_manager::update_network_settings ();
 
   emit active_dock_changed (0, _active_dock); // update dock widget styles
 
   configure_shortcuts ();
   set_global_shortcuts (_active_dock == command_window);
   disable_menu_shortcuts (_active_dock == editor_window);
@@ -792,17 +793,19 @@ main_window::confirm_shutdown_octave (vo
   if (_start_gui)
     {
       QSettings *settings = resource_manager::get_settings ();
 
       if (settings->value ("prompt_to_exit", false).toBool ())
         {
           int ans = QMessageBox::question (this, tr ("Octave"),
                                            tr ("Are you sure you want to exit Octave?"),
-                                           QMessageBox::Ok | QMessageBox::Cancel, QMessageBox::Ok);
+                                           (QMessageBox::Ok
+                                           | QMessageBox::Cancel),
+                                           QMessageBox::Ok);
 
           if (ans != QMessageBox::Ok)
             closenow = false;
         }
 
 #if defined (HAVE_QSCINTILLA)
       if (closenow)
         closenow = editor_window->check_closing ();
@@ -949,45 +952,48 @@ main_window::handle_exit_debugger (void)
 #if defined (HAVE_QSCINTILLA)
   editor_window->handle_exit_debug_mode ();
 #endif
 }
 
 void
 main_window::debug_continue (void)
 {
-  octave_cmd_debug *cmd = new octave_cmd_debug ("cont", _suppress_dbg_location);
+  octave_cmd_debug *cmd
+    = new octave_cmd_debug ("cont", _suppress_dbg_location);
   _cmd_queue.add_cmd (cmd);
 }
 
 void
 main_window::debug_step_into (void)
 {
   octave_cmd_debug *cmd = new octave_cmd_debug ("in", _suppress_dbg_location);
   _cmd_queue.add_cmd (cmd);
 }
 
 void
 main_window::debug_step_over (void)
 {
-  octave_cmd_debug *cmd = new octave_cmd_debug ("step", _suppress_dbg_location);
+  octave_cmd_debug *cmd
+    = new octave_cmd_debug ("step", _suppress_dbg_location);
   _cmd_queue.add_cmd (cmd);
 }
 
 void
 main_window::debug_step_out (void)
 {
   octave_cmd_debug *cmd = new octave_cmd_debug ("out", _suppress_dbg_location);
   _cmd_queue.add_cmd (cmd);
 }
 
 void
 main_window::debug_quit (void)
 {
-  octave_cmd_debug *cmd = new octave_cmd_debug ("quit", _suppress_dbg_location);
+  octave_cmd_debug *cmd
+    = new octave_cmd_debug ("quit", _suppress_dbg_location);
   _cmd_queue.add_cmd (cmd);
 }
 
 void
 main_window::handle_insert_debugger_pointer_request (const QString& file,
                                                      int line)
 {
   bool cmd_focus = command_window_has_focus ();
@@ -1099,25 +1105,26 @@ main_window::set_window_layout (QSetting
 #if ! defined (Q_OS_WIN32)
           // restore geometry
           QVariant val = settings->value ("DockWidgets/" + name);
           widget->restoreGeometry (val.toByteArray ());
 #endif
           // make widget visible if desired
           if (floating && visible)              // floating and visible
             {
-              if (settings->value ("DockWidgets/" + widget->objectName () + "_minimized").toBool ())
+              if (settings->value ("DockWidgets/" + widget->objectName ()
+                                   + "_minimized").toBool ())
                 widget->showMinimized ();
               else
                 widget->setVisible (true);
             }
           else
             {
               widget->make_widget ();
-              widget->setVisible (visible);       // not floating -> show
+              widget->setVisible (visible);     // not floating -> show
             }
         }
     }
 
 #if defined (Q_OS_WIN32)
   restoreState (settings->value ("MainWindow/windowState").toByteArray ());
   restoreGeometry (settings->value ("MainWindow/geometry").toByteArray ());
 #endif
@@ -1429,34 +1436,37 @@ main_window::construct (void)
       setGeometry (0, 0, win_x, win_y);
 
       setStatusBar (status_bar);
 
 #if defined (HAVE_QSCINTILLA)
       connect (this,
                SIGNAL (insert_debugger_pointer_signal (const QString&, int)),
                editor_window,
-               SLOT (handle_insert_debugger_pointer_request (const QString&, int)));
+               SLOT (handle_insert_debugger_pointer_request (const QString&,
+                                                             int)));
 
       connect (this,
                SIGNAL (delete_debugger_pointer_signal (const QString&, int)),
                editor_window,
-               SLOT (handle_delete_debugger_pointer_request (const QString&, int)));
+               SLOT (handle_delete_debugger_pointer_request (const QString&,
+                                                             int)));
 
       connect (this,
                SIGNAL (update_breakpoint_marker_signal (bool, const QString&,
 	                                                int, const QString&)),
                editor_window,
                SLOT (handle_update_breakpoint_marker_request (bool,
                                                               const QString&,
                                                               int,
-							      const QString&)));
+							                                                const QString&)));
 #endif
 
-      octave_link::post_event (this, &main_window::resize_command_window_callback);
+      octave_link::post_event (this,
+                               &main_window::resize_command_window_callback);
 
       configure_shortcuts ();
     }
 }
 
 void
 main_window::handle_octave_ready ()
 {
@@ -1467,22 +1477,24 @@ main_window::handle_octave_ready ()
 
   if (settings)
     {
       if (settings->value ("restore_octave_dir").toBool ())
         {
           // restore last dir from previous session
           QStringList curr_dirs
             = settings->value ("MainWindow/current_directory_list").toStringList ();
-          startup_dir = QDir (curr_dirs.at (0));  // last dir in previous session
+          startup_dir
+            = QDir (curr_dirs.at (0));  // last dir in previous session
         }
       else if (! settings->value ("octave_startup_dir").toString ().isEmpty ())
         {
           // do not restore but there is a startup dir configured
-          startup_dir = QDir (settings->value ("octave_startup_dir").toString ());
+          startup_dir
+            = QDir (settings->value ("octave_startup_dir").toString ());
         }
     }
 
   if (! startup_dir.exists ())
     {
       // the configured startup dir does not exist, take actual one
       startup_dir = QDir ();
     }
@@ -1573,31 +1585,33 @@ main_window::construct_octave_qt_link (v
                SIGNAL (edit_file_signal (const QString&)),
                editor_window,
                SLOT (handle_edit_file_request (const QString&)));
 #endif
 
       connect (_octave_qt_link,
                SIGNAL (insert_debugger_pointer_signal (const QString&, int)),
                this,
-               SLOT (handle_insert_debugger_pointer_request (const QString&, int)));
+               SLOT (handle_insert_debugger_pointer_request (const QString&,
+                                                             int)));
 
       connect (_octave_qt_link,
                SIGNAL (delete_debugger_pointer_signal (const QString&, int)),
                this,
-               SLOT (handle_delete_debugger_pointer_request (const QString&, int)));
+               SLOT (handle_delete_debugger_pointer_request (const QString&,
+                                                             int)));
 
       connect (_octave_qt_link,
                SIGNAL (update_breakpoint_marker_signal (bool, const QString&,
-	                                                int, const QString&)),
+	                                                      int, const QString&)),
                this,
                SLOT (handle_update_breakpoint_marker_request (bool,
-	                                                      const QString&,
+	                                                            const QString&,
                                                               int,
-							      const QString&)));
+							                                                const QString&)));
 
       connect (_octave_qt_link,
                SIGNAL (show_doc_signal (const QString &)),
                this, SLOT (handle_show_doc (const QString &)));
 
       connect (_workspace_model,
                SIGNAL (rename_variable (const QString&, const QString&)),
                this,
@@ -1805,17 +1819,17 @@ main_window::construct_edit_menu (QMenuB
   _clear_clipboard_action
     = edit_menu->addAction (tr ("Clear Clipboard"), this,
                             SLOT (clear_clipboard ()));
 
   edit_menu->addSeparator ();
 
   _find_files_action
     = edit_menu->addAction (resource_manager::icon ("edit-find"),
-                             tr ("Find Files..."));
+                            tr ("Find Files..."));
 
   edit_menu->addSeparator ();
 
   _clear_command_window_action
     = edit_menu->addAction (tr ("Clear Command Window"));
 
   _clear_command_history_action
     = edit_menu->addAction (tr ("Clear Command History"));
@@ -1849,17 +1863,17 @@ main_window::construct_edit_menu (QMenuB
            this, SLOT (process_settings_dialog_request ()));
 }
 
 QAction *
 main_window::construct_debug_menu_item (const char *icon, const QString& item,
                                         const char *member)
 {
   QAction *action = add_action (_debug_menu,
-                                  resource_manager::icon (QString (icon)),
+                                resource_manager::icon (QString (icon)),
                                 item, member);
 
   action->setEnabled (false);
 
 #if defined (HAVE_QSCINTILLA)
   editor_window->debug_menu ()->addAction (action);
   editor_window->toolbar ()->addAction (action);
 #endif
@@ -1868,39 +1882,39 @@ main_window::construct_debug_menu_item (
 }
 
 void
 main_window::construct_debug_menu (QMenuBar *p)
 {
   _debug_menu = m_add_menu (p, tr ("De&bug"));
 
   _debug_step_over = construct_debug_menu_item (
-                      "db-step", tr ("Step"),
+                       "db-step", tr ("Step"),
                        SLOT (debug_step_over ()));
 
   _debug_step_into = construct_debug_menu_item (
-                      "db-step-in", tr ("Step In"),
+                       "db-step-in", tr ("Step In"),
                        SLOT (debug_step_into ()));
 
   _debug_step_out = construct_debug_menu_item (
                       "db-step-out", tr ("Step Out"),
-                       SLOT (debug_step_out ()));
+                      SLOT (debug_step_out ()));
 
   _debug_continue = construct_debug_menu_item (
                       "db-cont", tr ("Continue"),
-                       SLOT (debug_continue ()));
+                      SLOT (debug_continue ()));
 
   _debug_menu->addSeparator ();
 #if defined (HAVE_QSCINTILLA)
   editor_window->debug_menu ()->addSeparator ();
 #endif
 
   _debug_quit = construct_debug_menu_item (
-                      "db-stop", tr ("Quit Debug Mode"),
-                       SLOT (debug_quit ()));
+                  "db-stop", tr ("Quit Debug Mode"),
+                  SLOT (debug_quit ()));
 }
 
 QAction *
 main_window::construct_window_menu_item (QMenu *p, const QString& item,
                                          bool checkable, QWidget *widget)
 {
   QAction *action = p->addAction (QIcon (), item);
 
diff --git a/libgui/src/main-window.h b/libgui/src/main-window.h
--- a/libgui/src/main-window.h
+++ b/libgui/src/main-window.h
@@ -164,17 +164,17 @@ public slots:
   void debug_step_over (void);
   void debug_step_out (void);
   void debug_quit (void);
 
   void handle_insert_debugger_pointer_request (const QString& file, int line);
   void handle_delete_debugger_pointer_request (const QString& file, int line);
   void handle_update_breakpoint_marker_request (bool insert,
                                                 const QString& file, int line,
-						const QString& cond);
+                                    						const QString& cond);
 
   void read_settings (void);
   void init_terminal_size (void);
   void set_window_layout (QSettings *settings);
   void write_settings (void);
   void connect_visibility_changed (void);
 
   void copyClipboard (void);
@@ -220,17 +220,17 @@ public slots:
   void set_screen_size (int ht, int wd);
 
   // handling the clipboard
   void clipboard_has_changed (QClipboard::Mode);
   void clear_clipboard ();
 
   // get the dockwidgets
   QList<octave_dock_widget *> get_dock_widget_list ()
-    { return dock_widget_list (); }
+  { return dock_widget_list (); }
 
 private slots:
   void disable_menu_shortcuts (bool disable);
 
 protected:
   void closeEvent (QCloseEvent * closeEvent);
 
 private:
@@ -432,8 +432,9 @@ private:
 
   QString base_url;
   QString page;
   int serial;
   bool connect_to_web;
 };
 
 #endif
+
diff --git a/libgui/src/octave-cmd.cc b/libgui/src/octave-cmd.cc
--- a/libgui/src/octave-cmd.cc
+++ b/libgui/src/octave-cmd.cc
@@ -146,8 +146,9 @@ octave_command_queue::execute_command_ca
       delete cmd;
     }
 
   if (repost)  // queue not empty, so repost event for further processing
     octave_link::post_event (this,
                              &octave_command_queue::execute_command_callback);
 
 }
+
diff --git a/libgui/src/octave-cmd.h b/libgui/src/octave-cmd.h
--- a/libgui/src/octave-cmd.h
+++ b/libgui/src/octave-cmd.h
@@ -125,8 +125,9 @@ public:
 private:
 
   QList<octave_cmd *>  _queue;
   QSemaphore   _processing;
   QMutex       _queue_mutex;
 };
 
 #endif
+
diff --git a/libgui/src/octave-dock-widget.cc b/libgui/src/octave-dock-widget.cc
--- a/libgui/src/octave-dock-widget.cc
+++ b/libgui/src/octave-dock-widget.cc
@@ -45,18 +45,20 @@ octave_dock_widget::octave_dock_widget (
   _predecessor_widget = 0;
 
   connect (this, SIGNAL (visibilityChanged (bool)),
            this, SLOT (handle_visibility_changed (bool)));
 
   connect (p, SIGNAL (settings_changed (const QSettings*)),
            this, SLOT (handle_settings (const QSettings*)));
 
-  connect (p, SIGNAL (active_dock_changed (octave_dock_widget*, octave_dock_widget*)),
-           this, SLOT (handle_active_dock_changed (octave_dock_widget*, octave_dock_widget*)));
+  connect (p, SIGNAL (active_dock_changed (octave_dock_widget*,
+                                           octave_dock_widget*)),
+           this, SLOT (handle_active_dock_changed (octave_dock_widget*,
+                                                   octave_dock_widget*)));
 
   QStyle *st = style ();
   _icon_size = 0.75*st->pixelMetric (QStyle::PM_SmallIconSize);
 
 #if defined (Q_OS_WIN32)
   // windows: add an extra title bar that persists when floating
 
   setFeatures (QDockWidget::DockWidgetMovable); // not floatable or closeable
@@ -166,18 +168,18 @@ octave_dock_widget::set_predecessor_widg
   _predecessor_widget = prev_widget;
 }
 
 // set the title in the dockwidgets title bar
 void
 octave_dock_widget::set_title (const QString& title)
 {
 #if defined (Q_OS_WIN32)
-  QHBoxLayout* h_layout =
-    static_cast<QHBoxLayout *> (titleBarWidget ()->layout ());
+  QHBoxLayout* h_layout
+    = static_cast<QHBoxLayout *> (titleBarWidget ()->layout ());
   QLabel *label = new QLabel (title);
   label->setStyleSheet ("background: transparent;");
   h_layout->insertWidget (0,label);
 #endif
   setWindowTitle (title);
 }
 
 // set focus to previously active widget in tabbed widget stack
@@ -204,22 +206,24 @@ octave_dock_widget::make_window ()
   // FIXME: dockWidgetArea always returns 2
   settings->setValue ("DockWidgets/" + objectName () + "_dock_area",
                       _parent->dockWidgetArea (this));
   settings->setValue ("DockWidgets/" + objectName (), saveGeometry ());
   settings->sync ();
 
   // remove parent and adjust the (un)dock icon
   setParent (0, Qt::Window);
-  _dock_action->setIcon (QIcon (":/actions/icons/widget-dock"+_icon_color+".png"));
+  _dock_action->setIcon (QIcon (":/actions/icons/widget-dock" 
+                                + _icon_color + ".png"));
   _dock_action->setToolTip (tr ("Dock widget"));
 
   // restore the last geometry when floating
   setGeometry (settings->value ("DockWidgets/" + objectName ()
-                       + "_floating_geometry",QRect(50,100,480,480)).toRect ());
+                                + "_floating_geometry",
+                                QRect (50,100,480,480)).toRect ());
 
 #else
 
   // non windows: Just set the appripriate window flag
   setWindowFlags (Qt::Window);
 
   QString css = styleSheet ();
   css.replace ("widget-undock","widget-dock");
@@ -246,30 +250,32 @@ octave_dock_widget::make_widget (bool do
   if (_floating)
     settings->setValue ("DockWidgets/" + objectName () + "_floating_geometry",
                         geometry ());
   settings->sync ();
 
   if (dock)
     {
       // add widget to last saved docking area (dock=true is default)
-      int area = settings->value ("DockWidgets/" + objectName () + "_dock_area",
-                                  Qt::TopDockWidgetArea).toInt ();
+      int area
+        = settings->value ("DockWidgets/" + objectName () + "_dock_area",
+                           Qt::TopDockWidgetArea).toInt ();
       _parent->addDockWidget (static_cast<Qt::DockWidgetArea> (area), this);
 
       // FIXME: restoreGeometry is ignored for docked widgets
       //        and its child widget
       restoreGeometry (settings->value
              ("DockWidgets/" + objectName ()).toByteArray ());
     }
   else  // only reparent, no docking
     setParent (_parent);
 
   // adjust the (un)dock icon
-  _dock_action->setIcon (QIcon (":/actions/icons/widget-undock"+_icon_color+".png"));
+  _dock_action->setIcon (QIcon (":/actions/icons/widget-undock"
+                                + _icon_color + ".png"));
   _dock_action->setToolTip (tr ("Undock widget"));
 
 #else
 
   // non windows: just say we are a docked widget again
 
   Q_UNUSED (dock);
 
@@ -413,21 +419,21 @@ octave_dock_widget::set_style (bool acti
 #else
   setStyleSheet (css);
 #endif
 }
 
 void
 octave_dock_widget::handle_settings (const QSettings *settings)
 {
-  _custom_style =
-    settings->value ("DockWidgets/widget_title_custom_style",false).toBool ();
+  _custom_style
+    = settings->value ("DockWidgets/widget_title_custom_style",false).toBool ();
 
-  _title_3d =
-    settings->value ("DockWidgets/widget_title_3d",50).toInt ();
+  _title_3d
+    = settings->value ("DockWidgets/widget_title_3d",50).toInt ();
 
   QColor default_var = QColor (0,0,0);
   _fg_color = settings->value ("Dockwidgets/title_fg_color",
                                default_var).value<QColor> ();
   default_var = QColor (0,0,0);
   _fg_color_active = settings->value ("Dockwidgets/title_fg_color_active",
                                       default_var).value<QColor> ();
 
@@ -487,8 +493,9 @@ octave_dock_widget::handle_active_dock_c
 // close event
 void
 octave_dock_widget::closeEvent (QCloseEvent *e)
 {
   emit active_changed (false);
   set_focus_predecessor ();
   QDockWidget::closeEvent (e);
 }
+
diff --git a/libgui/src/octave-dock-widget.h b/libgui/src/octave-dock-widget.h
--- a/libgui/src/octave-dock-widget.h
+++ b/libgui/src/octave-dock-widget.h
@@ -133,8 +133,9 @@ private:
   QToolButton *_close_button;
   QAction *_dock_action;
   QAction *_close_action;
 #endif
 
 };
 
 #endif
+
diff --git a/libgui/src/octave-gui.cc b/libgui/src/octave-gui.cc
--- a/libgui/src/octave-gui.cc
+++ b/libgui/src/octave-gui.cc
@@ -123,17 +123,18 @@ namespace octave
   }
 
   int gui_application::execute (void)
   {
     octave_thread_manager::block_interrupt_signal ();
 
     set_application_id ();
 
-    std::string show_gui_msgs = octave::sys::env::getenv ("OCTAVE_SHOW_GUI_MESSAGES");
+    std::string show_gui_msgs =
+      octave::sys::env::getenv ("OCTAVE_SHOW_GUI_MESSAGES");
 
     // Installing our handler suppresses the messages.
 
     if (show_gui_msgs.empty ())
       {
 #if defined (HAVE_QT4)
         qInstallMsgHandler (message_handler);
 #else
@@ -233,8 +234,9 @@ namespace octave
         gui_running (true);
       }
     else
       qt_app.setQuitOnLastWindowClosed (false);
 
     return qt_app.exec ();
   }
 }
+
diff --git a/libgui/src/octave-gui.h b/libgui/src/octave-gui.h
--- a/libgui/src/octave-gui.h
+++ b/libgui/src/octave-gui.h
@@ -54,8 +54,9 @@ namespace octave
 
     int m_argc;
     char **m_argv;
     bool m_gui_running;
   };
 }
 
 #endif
+
diff --git a/libgui/src/octave-interpreter.cc b/libgui/src/octave-interpreter.cc
--- a/libgui/src/octave-interpreter.cc
+++ b/libgui/src/octave-interpreter.cc
@@ -50,8 +50,9 @@ octave_interpreter::execute (void)
   m_exit_status = m_app_context->execute_interpreter ();
 }
 
 void
 octave_interpreter::interrupt (void)
 {
   thread_manager.interrupt ();
 }
+
diff --git a/libgui/src/octave-interpreter.h b/libgui/src/octave-interpreter.h
--- a/libgui/src/octave-interpreter.h
+++ b/libgui/src/octave-interpreter.h
@@ -59,8 +59,9 @@ private:
   octave_thread_manager thread_manager;
 
   octave::application *m_app_context;
 
   int m_exit_status;
 };
 
 #endif
+
diff --git a/libgui/src/octave-qt-link.cc b/libgui/src/octave-qt-link.cc
--- a/libgui/src/octave-qt-link.cc
+++ b/libgui/src/octave-qt-link.cc
@@ -137,17 +137,17 @@ octave_qt_link::do_prompt_new_edit_file 
 
   // Lock mutex before signaling.
   uiwidget_creator.mutex.lock ();
 
   uiwidget_creator.signal_dialog (
     tr ("File\n%1\ndoes not exist. Do you want to create it?").
     arg (QDir::currentPath () + QDir::separator ()
          + QString::fromStdString (file)),
-    tr ("Octave Editor"), "quest", btn, tr ("Create"), role );
+    tr ("Octave Editor"), "quest", btn, tr ("Create"), role);
 
   // Wait while the user is responding to message box.
   uiwidget_creator.waitcondition.wait (&uiwidget_creator.mutex);
 
   // The GUI has sent a signal and the thread has been awakened.
 
   QString answer = uiwidget_creator.get_dialog_button ();
 
@@ -408,17 +408,17 @@ octave_qt_link::do_debug_cd_or_addpath_e
   QStringList btn;
   QStringList role;
   btn << cd_txt;
   role << "YesRole";
   if (addpath_option)
     {
       btn << addpath_txt;
       role << "AcceptRole";
-     }
+    }
   btn << cancel_txt;
   role << "RejectRole";
 
   // Lock mutex before signaling.
   uiwidget_creator.mutex.lock ();
 
   uiwidget_creator.signal_dialog (msg, title, "quest", btn, cancel_txt, role);
 
@@ -427,34 +427,34 @@ octave_qt_link::do_debug_cd_or_addpath_e
 
   // The GUI has sent a signal and the thread has been awakened.
 
   QString result = uiwidget_creator.get_dialog_button ();
 
   uiwidget_creator.mutex.unlock ();
 
   if (result == cd_txt)
-     retval = 1;
+    retval = 1;
   else if (result == addpath_txt)
     retval = 2;
 
   return retval;
 }
 
 void
 octave_qt_link::do_change_directory (const std::string& dir)
 {
   _current_directory = QString::fromStdString (dir);
   _new_dir = true;
 }
 
 void
 octave_qt_link::update_directory ()
 {
-   emit change_directory_signal (_current_directory);
+  emit change_directory_signal (_current_directory);
   _new_dir = false;
 }
 
 void
 octave_qt_link::do_execute_command_in_terminal (const std::string& command)
 {
   emit execute_command_in_terminal_signal (QString::fromStdString (command));
 }
@@ -665,8 +665,9 @@ octave_qt_link::do_show_doc (const std::
   emit show_doc_signal (QString::fromStdString (file));
 }
 
 void
 octave_qt_link::terminal_interrupt (void)
 {
   command_interpreter->interrupt ();
 }
+
diff --git a/libgui/src/octave-qt-link.h b/libgui/src/octave-qt-link.h
--- a/libgui/src/octave-qt-link.h
+++ b/libgui/src/octave-qt-link.h
@@ -208,8 +208,9 @@ signals:
   void exit_app_signal (int status);
 
 public slots:
 
   void terminal_interrupt (void);
 };
 
 #endif
+
diff --git a/libgui/src/qtinfo/parser.cc b/libgui/src/qtinfo/parser.cc
--- a/libgui/src/qtinfo/parser.cc
+++ b/libgui/src/qtinfo/parser.cc
@@ -57,17 +57,18 @@ parser::set_info_path (const QString& in
   QFileInfo info (infoPath);
 
   bool info_file_exists = info.exists ();
   QHash<QString, QString>::iterator it;
   for (it = _compressors_map.begin (); it != _compressors_map.end (); it++)
     {
       if (info_file_exists)
         break;
-      info_file_exists = QFileInfo (info.absoluteFilePath () + "." + it.key ()).exists ();
+      info_file_exists = QFileInfo (info.absoluteFilePath () + "." +
+                                    it.key ()).exists ();
     }
 
   if (info_file_exists)
     {
       QString path = info.absolutePath ();
       QString fileName = info.fileName ();
 
       QDir infoDir (path);
@@ -91,17 +92,18 @@ parser::get_info_path ()
 }
 
 QIODevice *
 parser::open_file (QFileInfo & file_info)
 {
   QIODevice *iodevice = 0;
   if (_compressors_map.contains (file_info.suffix ()))
     {
-      QString command = _compressors_map.value (file_info.suffix ()).arg (file_info.absoluteFilePath ());
+      QString command = _compressors_map.value (file_info.suffix ()).arg (
+                          file_info.absoluteFilePath ());
       iprocstream ips (command.toStdString ());
 
       if (ips.bad ())
         return 0;
 
       QByteArray result;
       char buffer[1024];
 
diff --git a/libgui/src/qtinfo/parser.h b/libgui/src/qtinfo/parser.h
--- a/libgui/src/qtinfo/parser.h
+++ b/libgui/src/qtinfo/parser.h
@@ -119,8 +119,9 @@ private:
   QFileInfoList                 _info_files;
   QHash<QString, node_map_item> _node_map;
   QHash<QString, node_position> _ref_map;
   QList<info_file_item>         _info_file_real_size_list;
   QHash<QString, QString>       _compressors_map;
 };
 
 #endif
+
diff --git a/libgui/src/qtinfo/webinfo.cc b/libgui/src/qtinfo/webinfo.cc
--- a/libgui/src/qtinfo/webinfo.cc
+++ b/libgui/src/qtinfo/webinfo.cc
@@ -93,17 +93,18 @@ webinfo::webinfo (QWidget *p)
            SLOT (current_tab_changed (int)));
   connect (_zoom_in_button, SIGNAL (clicked ()), this, SLOT (zoom_in ()));
   connect (_zoom_out_button, SIGNAL (clicked ()), this, SLOT (zoom_out ()));
   connect (_search_line_edit, SIGNAL (returnPressed ()), this, SLOT (search ()));
 
   resize (500, 300);
 
   if (! set_info_path (QString::fromStdString (Vinfo_file)))
-    { // Info file does not exist
+    {
+      // Info file does not exist
       _search_check_box->setEnabled (false);
       _search_line_edit->setEnabled (false);
 
       QTextBrowser *msg = addNewTab (tr ("Error"));
       QString msg_text = QString (
           "<html><body><br><br><center><b>%1</b></center></body></html>").
           arg (tr ("The info file<p>%1<p>or compressed versions do not exist").
           arg(QString::fromStdString (Vinfo_file)));
diff --git a/libgui/src/qtinfo/webinfo.h b/libgui/src/qtinfo/webinfo.h
--- a/libgui/src/qtinfo/webinfo.h
+++ b/libgui/src/qtinfo/webinfo.h
@@ -69,8 +69,9 @@ private:
 
   parser              _parser;
   QFont               _font_web;
 
   QTextBrowser *addNewTab (const QString& name);
 };
 
 #endif
+
diff --git a/libgui/src/resource-manager.cc b/libgui/src/resource-manager.cc
--- a/libgui/src/resource-manager.cc
+++ b/libgui/src/resource-manager.cc
@@ -50,17 +50,18 @@ along with Octave; see the file COPYING.
 resource_manager *resource_manager::instance = 0;
 
 static QString
 default_qt_settings_file (void)
 {
   std::string dsf = octave::sys::env::getenv ("OCTAVE_DEFAULT_QT_SETTINGS");
 
   if (dsf.empty ())
-    dsf = Voct_etc_dir + octave::sys::file_ops::dir_sep_str () + "default-qt-settings";
+    dsf = Voct_etc_dir + octave::sys::file_ops::dir_sep_str () +
+          "default-qt-settings";
 
   return QString::fromStdString (dsf);
 }
 
 resource_manager::resource_manager (void)
   : settings_directory (), settings_file (), settings (0),
     default_settings (0)
 {
@@ -136,17 +137,17 @@ resource_manager::config_translators (QT
 }
 
 bool
 resource_manager::instance_ok (void)
 {
   bool retval = true;
 
   if (! instance)
-      instance = new resource_manager ();
+    instance = new resource_manager ();
 
   if (! instance)
     {
       error ("unable to create resource_manager object!");
 
       retval = false;
     }
 
@@ -370,8 +371,9 @@ resource_manager::do_combo_encoding (QCo
   int idx = combo->findText (enc);
   if (idx >= 0)
     combo->setCurrentIndex (idx);
   else
     combo->setCurrentIndex (0);
 
   combo->setMaxVisibleItems (12);
 }
+
diff --git a/libgui/src/resource-manager.h b/libgui/src/resource-manager.h
--- a/libgui/src/resource-manager.h
+++ b/libgui/src/resource-manager.h
@@ -143,8 +143,9 @@ private:
   bool do_is_first_run (void) const;
 
   QIcon do_icon (const QString& icon, bool fallback);
 
   void do_combo_encoding (QComboBox *combo, QString current);
 };
 
 #endif
+
diff --git a/libgui/src/settings-dialog.cc b/libgui/src/settings-dialog.cc
--- a/libgui/src/settings-dialog.cc
+++ b/libgui/src/settings-dialog.cc
@@ -325,17 +325,17 @@ settings_dialog::settings_dialog (QWidge
   _widget_title_bg_color = new color_picker (bg_color);
   _widget_title_bg_color->setEnabled (false);
   ui->layout_widget_bgtitle->addWidget (_widget_title_bg_color,0);
   connect (ui->cb_widget_custom_style, SIGNAL (toggled (bool)),
            _widget_title_bg_color, SLOT (setEnabled (bool)));
 
   default_var = QColor (192,192,192);
   QColor bg_color_active = settings->value ("Dockwidgets/title_bg_color_active",
-                                      default_var).value<QColor> ();
+                                            default_var).value<QColor> ();
   _widget_title_bg_color_active = new color_picker (bg_color_active);
   _widget_title_bg_color_active->setEnabled (false);
   ui->layout_widget_bgtitle_active->addWidget (_widget_title_bg_color_active,0);
   connect (ui->cb_widget_custom_style, SIGNAL (toggled (bool)),
            _widget_title_bg_color_active, SLOT (setEnabled (bool)));
 
   default_var = QColor (0,0,0);
   QColor fg_color = settings->value ("Dockwidgets/title_fg_color",
@@ -343,17 +343,17 @@ settings_dialog::settings_dialog (QWidge
   _widget_title_fg_color = new color_picker (fg_color);
   _widget_title_fg_color->setEnabled (false);
   ui->layout_widget_fgtitle->addWidget (_widget_title_fg_color,0);
   connect (ui->cb_widget_custom_style, SIGNAL (toggled (bool)),
            _widget_title_fg_color, SLOT (setEnabled (bool)));
 
   default_var = QColor (0,0,0);
   QColor fg_color_active = settings->value ("Dockwidgets/title_fg_color_active",
-                                      default_var).value<QColor> ();
+                                            default_var).value<QColor> ();
   _widget_title_fg_color_active = new color_picker (fg_color_active);
   _widget_title_fg_color_active->setEnabled (false);
   ui->layout_widget_fgtitle_active->addWidget (_widget_title_fg_color_active,0);
   connect (ui->cb_widget_custom_style, SIGNAL (toggled (bool)),
            _widget_title_fg_color_active, SLOT (setEnabled (bool)));
 
   ui->sb_3d_title->setValue (
     settings->value ("DockWidgets/widget_title_3d", 50).toInt ());
@@ -430,33 +430,33 @@ settings_dialog::settings_dialog (QWidge
     settings->value ("editor/codeCompletion_case",true).toBool ());
   ui->editor_checkbox_ac_replace->setChecked (
     settings->value ("editor/codeCompletion_replace",false).toBool ());
   ui->editor_ws_checkbox->setChecked (
     settings->value ("editor/show_white_space", false).toBool ());
   ui->editor_ws_indent_checkbox->setChecked (
     settings->value ("editor/show_white_space_indent",false).toBool ());
   ui->cb_show_eol->setChecked (
-    settings->value ("editor/show_eol_chars",false).toBool () );
+    settings->value ("editor/show_eol_chars",false).toBool ());
   ui->cb_show_hscrollbar->setChecked (
     settings->value ("editor/show_hscroll_bar",true).toBool ());
 
 #if defined (HAVE_QSCINTILLA)
 #  if defined (Q_OS_WIN32)
   int eol_mode = QsciScintilla::EolWindows;
 #elif defined (Q_OS_MAC)
   int eol_mode = QsciScintilla::EolMac;
 #else
   int eol_mode = QsciScintilla::EolUnix;
 #endif
 #else
   int eol_mode = 2;
 #endif
   ui->combo_eol_mode->setCurrentIndex (
-    settings->value ("editor/default_eol_mode",eol_mode).toInt () );
+    settings->value ("editor/default_eol_mode",eol_mode).toInt ());
   ui->editor_auto_ind_checkbox->setChecked (
     settings->value ("editor/auto_indent", true).toBool ());
   ui->editor_tab_ind_checkbox->setChecked (
     settings->value ("editor/tab_indents_line",false).toBool ());
   ui->editor_bs_unind_checkbox->setChecked (
     settings->value ("editor/backspace_unindents_line",false).toBool ());
   ui->editor_ind_guides_checkbox->setChecked (
     settings->value ("editor/show_indent_guides",false).toBool ());
@@ -736,17 +736,17 @@ settings_dialog::write_changed_settings 
   if (language == tr ("System setting"))
     language = "SYSTEM";
   settings->setValue ("language", language);
 
   // dock widget title bar
   settings->setValue ("DockWidgets/widget_title_custom_style",
                       ui->cb_widget_custom_style->isChecked ());
   settings->setValue ("DockWidgets/widget_title_3d",
-                      ui->sb_3d_title->value ( ));
+                      ui->sb_3d_title->value ());
   settings->setValue ("Dockwidgets/title_bg_color",
                       _widget_title_bg_color->color ());
   settings->setValue ("Dockwidgets/title_bg_color_active",
                       _widget_title_bg_color_active->color ());
   settings->setValue ("Dockwidgets/title_fg_color",
                       _widget_title_fg_color->color ());
   settings->setValue ("Dockwidgets/title_fg_color_active",
                       _widget_title_fg_color_active->color ());
@@ -758,17 +758,17 @@ settings_dialog::write_changed_settings 
   else if (ui->icon_size_large->isChecked ())
     icon_size = 1;
   settings->setValue ("toolbar_icon_size", icon_size);
 
   // promp to exit
   settings->setValue ("prompt_to_exit", ui->cb_prompt_to_exit->isChecked ());
 
   // status bar
-  settings->setValue ( "show_status_bar", ui->cb_status_bar->isChecked ());
+  settings->setValue ("show_status_bar", ui->cb_status_bar->isChecked ());
 
   // Octave startup
   settings->setValue ("restore_octave_dir",
                       ui->cb_restore_octave_dir->isChecked ());
   settings->setValue ("octave_startup_dir", ui->le_octave_dir->text ());
 
   //editor
   settings->setValue ("useCustomFileEditor",
@@ -1047,8 +1047,9 @@ settings_dialog::export_shortcut_set ()
   shortcut_manager::import_export (shortcut_manager::OSC_EXPORT);
 }
 
 void
 settings_dialog::default_shortcut_set ()
 {
   shortcut_manager::import_export (shortcut_manager::OSC_DEFAULT);
 }
+
diff --git a/libgui/src/settings-dialog.h b/libgui/src/settings-dialog.h
--- a/libgui/src/settings-dialog.h
+++ b/libgui/src/settings-dialog.h
@@ -73,8 +73,9 @@ private:
   color_picker *_widget_title_bg_color;
   color_picker *_widget_title_bg_color_active;
   color_picker *_widget_title_fg_color;
   color_picker *_widget_title_fg_color_active;
   color_picker *_editor_current_line_color;
 };
 
 #endif
+
diff --git a/libgui/src/shortcut-manager.cc b/libgui/src/shortcut-manager.cc
--- a/libgui/src/shortcut-manager.cc
+++ b/libgui/src/shortcut-manager.cc
@@ -61,17 +61,17 @@ shortcut_manager::~shortcut_manager ()
 }
 
 bool
 shortcut_manager::instance_ok (void)
 {
   bool retval = true;
 
   if (! instance)
-      instance = new shortcut_manager ();
+    instance = new shortcut_manager ();
 
   if (! instance)
     {
       error ("unable to create shortcut_manager object!");
 
       retval = false;
     }
 
@@ -305,19 +305,19 @@ shortcut_manager::do_init_data ()
         QKeySequence ());
   init (tr ("Previous Breakpoint"), "editor_debug:previous_breakpoint",
         QKeySequence ());
   init (tr ("Remove All Breakpoints"), "editor_debug:remove_breakpoints",
         QKeySequence ());
 
   // run
   init (tr ("Run File"), "editor_run:run_file",
-        QKeySequence (prefix + Qt::Key_F5) );
+        QKeySequence (prefix + Qt::Key_F5));
   init (tr ("Run Selection"), "editor_run:run_selection",
-        QKeySequence (prefix + Qt::Key_F9) );
+        QKeySequence (prefix + Qt::Key_F9));
 
   // help
   init (tr ("Help on Keyword"), "editor_help:help_keyword",
         QKeySequence::HelpContents);
   init (tr ("Document on Keyword"), "editor_help:doc_keyword",
         QKeySequence (Qt::SHIFT + Qt::Key_F1));
 
   // tab navigation
@@ -449,25 +449,25 @@ shortcut_manager::do_fill_treewidget (QT
 void
 shortcut_manager::do_write_shortcuts (QSettings* settings,
                                       bool closing)
 {
   bool sc_ctrld = false;
 
   for (int i = 0; i < _sc.count (); i++)  // loop over all shortcuts
     {
-      settings->setValue("shortcuts/"+_sc.at (i).settings_key,
-                             _sc.at (i).actual_sc.toString ());
+      settings->setValue ("shortcuts/"+_sc.at (i).settings_key,
+                          _sc.at (i).actual_sc.toString ());
       // special: check main-window for Ctrl-D (Terminal)
       if (_sc.at (i).settings_key.startsWith ("main_")
           && _sc.at (i).actual_sc == QKeySequence (Qt::ControlModifier+Qt::Key_D))
         sc_ctrld = true;
     }
 
-    settings->setValue ("shortcuts/main_ctrld",sc_ctrld);
+  settings->setValue ("shortcuts/main_ctrld",sc_ctrld);
 
   if (closing)
     {
       delete _dialog;  // the dialog for key sequences can be removed now
       _dialog = 0;     // make sure it is zero again
     }
 
   settings->sync ();    // sync the settings file
@@ -691,25 +691,25 @@ shortcut_manager::do_import_export (int 
   if (action != OSC_DEFAULT)
     {
       QString file;
 
       if (action == OSC_IMPORT)
         file = QFileDialog::getOpenFileName (this,
                     tr ("Import shortcuts from file ..."), QString (),
                     tr ("Octave Shortcut Files (*.osc);;All Files (*)"),
-                    0,QFileDialog::DontUseNativeDialog);
+                    0, QFileDialog::DontUseNativeDialog);
       else if (action == OSC_EXPORT)
         file = QFileDialog::getSaveFileName (this,
                     tr ("Export shortcuts into file ..."), QString (),
                     tr ("Octave Shortcut Files (*.osc);;All Files (*)"),
-                    0,QFileDialog::DontUseNativeDialog);
+                    0, QFileDialog::DontUseNativeDialog);
 
       if (file.isEmpty ())
-          return false;
+        return false;
 
       QSettings *osc_settings = new QSettings (file, QSettings::IniFormat);
 
       if (! osc_settings)
         {
           qWarning () << tr ("Failed to open %1 as octave shortcut file")
                          .arg (file);
           return false;
@@ -733,18 +733,17 @@ shortcut_manager::do_import_export (int 
 // enter_shortcut:
 // class derived from QLineEdit for directly entering key sequences which
 enter_shortcut::enter_shortcut (QWidget *p) : QLineEdit (p)
 {
   _direct_shortcut = true;      // the shortcut is directly entered
 }
 
 enter_shortcut::~enter_shortcut ()
-{
-}
+{ }
 
 // slot for checkbox whether the shortcut is directly entered or not
 void
 enter_shortcut::handle_direct_shortcut (int state)
 {
   if (state)
     _direct_shortcut = true;  // the shortcut is directly entered
   else
@@ -777,8 +776,9 @@ enter_shortcut::keyPressEvent (QKeyEvent
       if (modifiers & Qt::AltModifier)
         key += Qt::ALT;
       if (modifiers & Qt::MetaModifier)
         key += Qt::META;
 
       setText (QKeySequence(key).toString ());
     }
 }
+
diff --git a/libgui/src/shortcut-manager.h b/libgui/src/shortcut-manager.h
--- a/libgui/src/shortcut-manager.h
+++ b/libgui/src/shortcut-manager.h
@@ -185,8 +185,9 @@ private:
   QLabel *_label_default;
   int _handled_index;
 
   QSettings *_settings;
 
 };
 
 #endif
+
diff --git a/libgui/src/terminal-dock-widget.h b/libgui/src/terminal-dock-widget.h
--- a/libgui/src/terminal-dock-widget.h
+++ b/libgui/src/terminal-dock-widget.h
@@ -52,8 +52,9 @@ protected slots:
   void terminal_interrupt (void);
 
 private:
 
   QTerminal *terminal;
 };
 
 #endif
+
diff --git a/libgui/src/thread-manager.cc b/libgui/src/thread-manager.cc
--- a/libgui/src/thread-manager.cc
+++ b/libgui/src/thread-manager.cc
@@ -116,8 +116,9 @@ octave_base_thread_manager *
 octave_thread_manager::create_rep (void)
 {
 #if defined (OCTAVE_USE_WINDOWS_API)
   return new windows_thread_manager ();
 #else
   return new pthread_thread_manager ();
 #endif
 }
+
diff --git a/libgui/src/thread-manager.h b/libgui/src/thread-manager.h
--- a/libgui/src/thread-manager.h
+++ b/libgui/src/thread-manager.h
@@ -89,8 +89,9 @@ public:
 private:
 
   octave_base_thread_manager *rep;
 
   static octave_base_thread_manager *create_rep (void);
 };
 
 #endif
+
diff --git a/libgui/src/welcome-wizard.cc b/libgui/src/welcome-wizard.cc
--- a/libgui/src/welcome-wizard.cc
+++ b/libgui/src/welcome-wizard.cc
@@ -340,8 +340,9 @@ welcome_wizard::accept (void)
       settings->setValue ("news/allow_web_connection",
                           allow_web_connect_state);
 
       settings->sync ();
     }
 
   QDialog::accept ();
 }
+
diff --git a/libgui/src/welcome-wizard.h b/libgui/src/welcome-wizard.h
--- a/libgui/src/welcome-wizard.h
+++ b/libgui/src/welcome-wizard.h
@@ -128,8 +128,9 @@ private:
   QLabel *logo;
   QLabel *links;
   QPushButton *previous;
   QPushButton *finish;
   QPushButton *cancel;
 };
 
 #endif
+
diff --git a/libgui/src/workspace-model.cc b/libgui/src/workspace-model.cc
--- a/libgui/src/workspace-model.cc
+++ b/libgui/src/workspace-model.cc
@@ -287,8 +287,9 @@ workspace_model::notice_settings (const 
     {
       QVariant default_var = default_colors.at (i);
       QColor setting_color = settings->value ("workspaceview/color_"
                                               + class_chars.mid (i,1),
                                               default_var).value<QColor> ();
       _storage_class_colors.replace (i,setting_color);
     }
 }
+
diff --git a/libgui/src/workspace-model.h b/libgui/src/workspace-model.h
--- a/libgui/src/workspace-model.h
+++ b/libgui/src/workspace-model.h
@@ -106,8 +106,9 @@ private:
 
   QStringList _columnNames;
 
   QList<QColor>  _storage_class_colors;
 
 };
 
 #endif
+
diff --git a/libgui/src/workspace-view.cc b/libgui/src/workspace-view.cc
--- a/libgui/src/workspace-view.cc
+++ b/libgui/src/workspace-view.cc
@@ -463,17 +463,17 @@ void
 workspace_view::notice_settings (const QSettings *settings)
 {
   int i;
 
   _model->notice_settings (settings); // update colors of model first
 
   for (i = 0; i < _columns_shown_keys.size (); i++)
     {
-      view->setColumnHidden ( i + 1,
+      view->setColumnHidden (i + 1,
             ! settings->value (_columns_shown_keys.at (i),true).toBool ());
     }
 
   QString tool_tip;
 
   if (! settings->value ("workspaceview/hide_tool_tips",false).toBool ())
     {
       tool_tip  = QString (tr ("View the variables in the active workspace.<br>"));
diff --git a/libgui/src/workspace-view.h b/libgui/src/workspace-view.h
--- a/libgui/src/workspace-view.h
+++ b/libgui/src/workspace-view.h
@@ -105,8 +105,9 @@ private:
   enum { MaxFilterHistory = 10 };
 
   QStringList _columns_shown;
   QStringList _columns_shown_keys;
   QSignalMapper *_sig_mapper;
 };
 
 #endif
+
