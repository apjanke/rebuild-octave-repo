# HG changeset patch
# User Jaroslav Hajek <highegg@gmail.com>
# Date 1263980280 -3600
#      Wed Jan 20 10:38:00 2010 +0100
# Node ID 829e69ec3110baba158af8c4d59b7eae567df802
# Parent  e409546ac0a8891dce8938f0258ddfaa846aba77
make OCTAVE_QUIT a function

diff --git a/libcruft/ChangeLog b/libcruft/ChangeLog
--- a/libcruft/ChangeLog
+++ b/libcruft/ChangeLog
@@ -1,8 +1,13 @@
+2010-01-20  Jaroslav Hajek  <highegg@gmail.com>
+
+	* misc/quit.h: Define inline-function variant of OCTAVE_QUIT in C++
+	mode.
+
 2009-01-13  Rik <octave@nomad.inbox5.com>
 
 	* STOP.patch: Remove unmaintained patch for Fortran code
 
 2009-01-13  Rik <octave@nomad.inbox5.com>
 
 	* ranlib/advnst.f ranlib/genbet.f ranlib/genchi.f ranlib/genexp.f
 	ranlib/genf.f ranlib/gengam.f ranlib/genmul.f ranlib/gennch.f
diff --git a/libcruft/misc/quit.h b/libcruft/misc/quit.h
--- a/libcruft/misc/quit.h
+++ b/libcruft/misc/quit.h
@@ -109,26 +109,41 @@ CRUFT_API extern void octave_handle_sign
 CRUFT_API extern void octave_throw_interrupt_exception (void) GCC_ATTR_NORETURN;
 
 CRUFT_API extern void octave_throw_execution_exception (void) GCC_ATTR_NORETURN;
 
 CRUFT_API extern void octave_throw_bad_alloc (void) GCC_ATTR_NORETURN;
 
 CRUFT_API extern void octave_rethrow_exception (void);
 
+#ifdef __cplusplus
+inline void octave_quit (void)
+{
+  if (octave_signal_caught)
+    {
+      octave_signal_caught = 0;
+      octave_handle_signal ();
+    }
+};
+
+#define OCTAVE_QUIT octave_quit ()
+
+#else
+
 #define OCTAVE_QUIT \
   do \
     { \
       if (octave_signal_caught) \
         { \
           octave_signal_caught = 0; \
           octave_handle_signal (); \
         } \
     } \
   while (0)
+#endif
 
 /* Normally, you just want to use
 
      BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
      ... some code that calls a "foreign" function ...
      END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
    but sometimes it is useful to do something like
diff --git a/liboctave/Array.h b/liboctave/Array.h
--- a/liboctave/Array.h
+++ b/liboctave/Array.h
@@ -654,25 +654,25 @@ public:
     const T *m = data ();
 
     Array<U> result (dims ());
     U *p = result.fortran_vec ();
 
     octave_idx_type i;
     for (i = 0; i < len - 3; i += 4)
       {
-	OCTAVE_QUIT;
+	octave_quit ();
 
         p[i] = fcn (m[i]);
         p[i+1] = fcn (m[i+1]);
         p[i+2] = fcn (m[i+2]);
         p[i+3] = fcn (m[i+3]);
       }
 
-    OCTAVE_QUIT;
+    octave_quit ();
 
     for (; i < len; i++)
       p[i] = fcn (m[i]);
 
     return result;
   }
 
   // Overloads for function references.
diff --git a/liboctave/CMatrix.cc b/liboctave/CMatrix.cc
--- a/liboctave/CMatrix.cc
+++ b/liboctave/CMatrix.cc
@@ -1347,17 +1347,17 @@ ComplexMatrix::fourier (void) const
 
   retval = *this;
   Complex *tmp_data = retval.fortran_vec ();
 
   F77_FUNC (zffti, ZFFTI) (npts, pwsave);
 
   for (octave_idx_type j = 0; j < nsamples; j++)
     {
-      OCTAVE_QUIT;
+      octave_quit ();
 
       F77_FUNC (zfftf, ZFFTF) (npts, &tmp_data[npts*j], pwsave);
     }
 
   return retval;
 }
 
 ComplexMatrix
@@ -1388,17 +1388,17 @@ ComplexMatrix::ifourier (void) const
 
   retval = *this;
   Complex *tmp_data = retval.fortran_vec ();
 
   F77_FUNC (zffti, ZFFTI) (npts, pwsave);
 
   for (octave_idx_type j = 0; j < nsamples; j++)
     {
-      OCTAVE_QUIT;
+      octave_quit ();
 
       F77_FUNC (zfftb, ZFFTB) (npts, &tmp_data[npts*j], pwsave);
     }
 
   for (octave_idx_type j = 0; j < npts*nsamples; j++)
     tmp_data[j] = tmp_data[j] / static_cast<double> (npts);
 
   return retval;
@@ -1432,17 +1432,17 @@ ComplexMatrix::fourier2d (void) const
 
   retval = *this;
   Complex *tmp_data = retval.fortran_vec ();
 
   F77_FUNC (zffti, ZFFTI) (npts, pwsave);
 
   for (octave_idx_type j = 0; j < nsamples; j++)
     {
-      OCTAVE_QUIT;
+      octave_quit ();
 
       F77_FUNC (zfftf, ZFFTF) (npts, &tmp_data[npts*j], pwsave);
     }
 
   npts = nc;
   nsamples = nr;
   nn = 4*npts+15;
 
@@ -1451,17 +1451,17 @@ ComplexMatrix::fourier2d (void) const
 
   Array<Complex> tmp (npts);
   Complex *prow = tmp.fortran_vec ();
 
   F77_FUNC (zffti, ZFFTI) (npts, pwsave);
 
   for (octave_idx_type j = 0; j < nsamples; j++)
     {
-      OCTAVE_QUIT;
+      octave_quit ();
 
       for (octave_idx_type i = 0; i < npts; i++)
 	prow[i] = tmp_data[i*nr + j];
 
       F77_FUNC (zfftf, ZFFTF) (npts, prow, pwsave);
 
       for (octave_idx_type i = 0; i < npts; i++)
 	tmp_data[i*nr + j] = prow[i];
@@ -1498,17 +1498,17 @@ ComplexMatrix::ifourier2d (void) const
 
   retval = *this;
   Complex *tmp_data = retval.fortran_vec ();
 
   F77_FUNC (zffti, ZFFTI) (npts, pwsave);
 
   for (octave_idx_type j = 0; j < nsamples; j++)
     {
-      OCTAVE_QUIT;
+      octave_quit ();
 
       F77_FUNC (zfftb, ZFFTB) (npts, &tmp_data[npts*j], pwsave);
     }
 
   for (octave_idx_type j = 0; j < npts*nsamples; j++)
     tmp_data[j] = tmp_data[j] / static_cast<double> (npts);
 
   npts = nc;
@@ -1520,17 +1520,17 @@ ComplexMatrix::ifourier2d (void) const
 
   Array<Complex> tmp (npts);
   Complex *prow = tmp.fortran_vec ();
 
   F77_FUNC (zffti, ZFFTI) (npts, pwsave);
 
   for (octave_idx_type j = 0; j < nsamples; j++)
     {
-      OCTAVE_QUIT;
+      octave_quit ();
 
       for (octave_idx_type i = 0; i < npts; i++)
 	prow[i] = tmp_data[i*nr + j];
 
       F77_FUNC (zfftb, ZFFTB) (npts, prow, pwsave);
 
       for (octave_idx_type i = 0; i < npts; i++)
 	tmp_data[i*nr + j] = prow[i] / static_cast<double> (npts);
@@ -3881,17 +3881,17 @@ min (const Complex& c, const ComplexMatr
 
   EMPTY_RETURN_CHECK (ComplexMatrix);
 
   ComplexMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
-	OCTAVE_QUIT;
+	octave_quit ();
 	result (i, j) = xmin (c, m (i, j));
       }
 
   return result;
 }
 
 ComplexMatrix
 min (const ComplexMatrix& m, const Complex& c)
@@ -3901,17 +3901,17 @@ min (const ComplexMatrix& m, const Compl
 
   EMPTY_RETURN_CHECK (ComplexMatrix);
 
   ComplexMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
-	OCTAVE_QUIT;
+	octave_quit ();
 	result (i, j) = xmin (m (i, j), c);
       }
 
   return result;
 }
 
 ComplexMatrix
 min (const ComplexMatrix& a, const ComplexMatrix& b)
@@ -3930,34 +3930,34 @@ min (const ComplexMatrix& a, const Compl
 
   ComplexMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     {
       int columns_are_real_only = 1;
       for (octave_idx_type i = 0; i < nr; i++)
 	{
-	  OCTAVE_QUIT;
+	  octave_quit ();
 	  if (std::imag (a (i, j)) != 0.0 || std::imag (b (i, j)) != 0.0)
 	    {
 	      columns_are_real_only = 0;
 	      break;
 	    }
 	}
 
       if (columns_are_real_only)
 	{
 	  for (octave_idx_type i = 0; i < nr; i++)
 	    result (i, j) = xmin (std::real (a (i, j)), std::real (b (i, j)));
 	}
       else
 	{
 	  for (octave_idx_type i = 0; i < nr; i++)
 	    {
-	      OCTAVE_QUIT;
+	      octave_quit ();
 	      result (i, j) = xmin (a (i, j), b (i, j));
 	    }
 	}
     }
 
   return result;
 }
 
@@ -3969,17 +3969,17 @@ max (const Complex& c, const ComplexMatr
 
   EMPTY_RETURN_CHECK (ComplexMatrix);
 
   ComplexMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
-	OCTAVE_QUIT;
+	octave_quit ();
 	result (i, j) = xmax (c, m (i, j));
       }
 
   return result;
 }
 
 ComplexMatrix
 max (const ComplexMatrix& m, const Complex& c)
@@ -3989,17 +3989,17 @@ max (const ComplexMatrix& m, const Compl
 
   EMPTY_RETURN_CHECK (ComplexMatrix);
 
   ComplexMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
-	OCTAVE_QUIT;
+	octave_quit ();
 	result (i, j) = xmax (m (i, j), c);
       }
 
   return result;
 }
 
 ComplexMatrix
 max (const ComplexMatrix& a, const ComplexMatrix& b)
@@ -4018,37 +4018,37 @@ max (const ComplexMatrix& a, const Compl
 
   ComplexMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     {
       int columns_are_real_only = 1;
       for (octave_idx_type i = 0; i < nr; i++)
 	{
-	  OCTAVE_QUIT;
+	  octave_quit ();
 	  if (std::imag (a (i, j)) != 0.0 || std::imag (b (i, j)) != 0.0)
 	    {
 	      columns_are_real_only = 0;
 	      break;
 	    }
 	}
 
       if (columns_are_real_only)
 	{
 	  for (octave_idx_type i = 0; i < nr; i++)
 	    {
-	      OCTAVE_QUIT;
+	      octave_quit ();
 	      result (i, j) = xmax (std::real (a (i, j)), std::real (b (i, j)));
 	    }
 	}
       else
 	{
 	  for (octave_idx_type i = 0; i < nr; i++)
 	    {
-	      OCTAVE_QUIT;
+	      octave_quit ();
 	      result (i, j) = xmax (a (i, j), b (i, j));
 	    }
 	}
     }
 
   return result;
 }
 
diff --git a/liboctave/CNDArray.cc b/liboctave/CNDArray.cc
--- a/liboctave/CNDArray.cc
+++ b/liboctave/CNDArray.cc
@@ -233,17 +233,17 @@ ComplexNDArray::fourier (int dim) const
   octave_idx_type dist = (stride == 1 ? npts : 1);
 
   F77_FUNC (zffti, ZFFTI) (npts, pwsave);
 
   for (octave_idx_type k = 0; k < nloop; k++)
     {
       for (octave_idx_type j = 0; j < howmany; j++)
 	{
-	  OCTAVE_QUIT;
+	  octave_quit ();
 
 	  for (octave_idx_type i = 0; i < npts; i++)
 	    tmp[i] = elem((i + k*npts)*stride + j*dist);
 
 	  F77_FUNC (zfftf, ZFFTF) (npts, tmp, pwsave);
 
 	  for (octave_idx_type i = 0; i < npts; i++)
 	    retval ((i + k*npts)*stride + j*dist) = tmp[i];
@@ -280,17 +280,17 @@ ComplexNDArray::ifourier (int dim) const
   octave_idx_type dist = (stride == 1 ? npts : 1);
 
   F77_FUNC (zffti, ZFFTI) (npts, pwsave);
 
   for (octave_idx_type k = 0; k < nloop; k++)
     {
       for (octave_idx_type j = 0; j < howmany; j++)
 	{
-	  OCTAVE_QUIT;
+	  octave_quit ();
 
 	  for (octave_idx_type i = 0; i < npts; i++)
 	    tmp[i] = elem((i + k*npts)*stride + j*dist);
 
 	  F77_FUNC (zfftb, ZFFTB) (npts, tmp, pwsave);
 
 	  for (octave_idx_type i = 0; i < npts; i++)
 	    retval ((i + k*npts)*stride + j*dist) = tmp[i] /
@@ -326,17 +326,17 @@ ComplexNDArray::fourier2d (void) const
       octave_idx_type dist = (stride == 1 ? npts : 1);
 
       F77_FUNC (zffti, ZFFTI) (npts, pwsave);
 
       for (octave_idx_type k = 0; k < nloop; k++)
 	{
 	  for (octave_idx_type j = 0; j < howmany; j++)
 	    {
-	      OCTAVE_QUIT;
+	      octave_quit ();
 
 	      for (octave_idx_type l = 0; l < npts; l++)
 		prow[l] = retval ((l + k*npts)*stride + j*dist);
 
 	      F77_FUNC (zfftf, ZFFTF) (npts, prow, pwsave);
 
 	      for (octave_idx_type l = 0; l < npts; l++)
 		retval ((l + k*npts)*stride + j*dist) = prow[l];
@@ -374,17 +374,17 @@ ComplexNDArray::ifourier2d (void) const
       octave_idx_type dist = (stride == 1 ? npts : 1);
 
       F77_FUNC (zffti, ZFFTI) (npts, pwsave);
 
       for (octave_idx_type k = 0; k < nloop; k++)
 	{
 	  for (octave_idx_type j = 0; j < howmany; j++)
 	    {
-	      OCTAVE_QUIT;
+	      octave_quit ();
 
 	      for (octave_idx_type l = 0; l < npts; l++)
 		prow[l] = retval ((l + k*npts)*stride + j*dist);
 
 	      F77_FUNC (zfftb, ZFFTB) (npts, prow, pwsave);
 
 	      for (octave_idx_type l = 0; l < npts; l++)
 		retval ((l + k*npts)*stride + j*dist) = prow[l] /
@@ -422,17 +422,17 @@ ComplexNDArray::fourierNd (void) const
       octave_idx_type dist = (stride == 1 ? npts : 1);
 
       F77_FUNC (zffti, ZFFTI) (npts, pwsave);
 
       for (octave_idx_type k = 0; k < nloop; k++)
 	{
 	  for (octave_idx_type j = 0; j < howmany; j++)
 	    {
-	      OCTAVE_QUIT;
+	      octave_quit ();
 
 	      for (octave_idx_type l = 0; l < npts; l++)
 		prow[l] = retval ((l + k*npts)*stride + j*dist);
 
 	      F77_FUNC (zfftf, ZFFTF) (npts, prow, pwsave);
 
 	      for (octave_idx_type l = 0; l < npts; l++)
 		retval ((l + k*npts)*stride + j*dist) = prow[l];
@@ -469,17 +469,17 @@ ComplexNDArray::ifourierNd (void) const
       octave_idx_type dist = (stride == 1 ? npts : 1);
 
       F77_FUNC (zffti, ZFFTI) (npts, pwsave);
 
       for (octave_idx_type k = 0; k < nloop; k++)
 	{
 	  for (octave_idx_type j = 0; j < howmany; j++)
 	    {
-	      OCTAVE_QUIT;
+	      octave_quit ();
 
 	      for (octave_idx_type l = 0; l < npts; l++)
 		prow[l] = retval ((l + k*npts)*stride + j*dist);
 
 	      F77_FUNC (zfftb, ZFFTB) (npts, prow, pwsave);
 
 	      for (octave_idx_type l = 0; l < npts; l++)
 		retval ((l + k*npts)*stride + j*dist) = prow[l] /
@@ -928,17 +928,17 @@ min (const Complex& c, const ComplexNDAr
   int nel = dv.numel ();
 
   EMPTY_RETURN_CHECK (ComplexNDArray);
 
   ComplexNDArray result (dv);
 
   for (int i = 0; i < nel; i++)
     {
-      OCTAVE_QUIT;
+      octave_quit ();
       result (i) = xmin (c, m (i));
     }
 
   return result;
 }
 
 ComplexNDArray
 min (const ComplexNDArray& m, const Complex& c)
@@ -947,17 +947,17 @@ min (const ComplexNDArray& m, const Comp
   int nel = dv.numel ();
 
   EMPTY_RETURN_CHECK (ComplexNDArray);
 
   ComplexNDArray result (dv);
 
   for (int i = 0; i < nel; i++)
     {
-      OCTAVE_QUIT;
+      octave_quit ();
       result (i) = xmin (c, m (i));
     }
 
   return result;
 }
 
 ComplexNDArray
 min (const ComplexNDArray& a, const ComplexNDArray& b)
@@ -973,17 +973,17 @@ min (const ComplexNDArray& a, const Comp
     }
 
   EMPTY_RETURN_CHECK (ComplexNDArray);
 
   ComplexNDArray result (dv);
 
   for (int i = 0; i < nel; i++)
     {
-      OCTAVE_QUIT;
+      octave_quit ();
       result (i) = xmin (a (i), b (i));
     }
 
   return result;
 }
 
 ComplexNDArray
 max (const Complex& c, const ComplexNDArray& m)
@@ -992,17 +992,17 @@ max (const Complex& c, const ComplexNDAr
   int nel = dv.numel ();
 
   EMPTY_RETURN_CHECK (ComplexNDArray);
 
   ComplexNDArray result (dv);
 
   for (int i = 0; i < nel; i++)
     {
-      OCTAVE_QUIT;
+      octave_quit ();
       result (i) = xmax (c, m (i));
     }
 
   return result;
 }
 
 ComplexNDArray
 max (const ComplexNDArray& m, const Complex& c)
@@ -1011,17 +1011,17 @@ max (const ComplexNDArray& m, const Comp
   int nel = dv.numel ();
 
   EMPTY_RETURN_CHECK (ComplexNDArray);
 
   ComplexNDArray result (dv);
 
   for (int i = 0; i < nel; i++)
     {
-      OCTAVE_QUIT;
+      octave_quit ();
       result (i) = xmax (c, m (i));
     }
 
   return result;
 }
 
 ComplexNDArray
 max (const ComplexNDArray& a, const ComplexNDArray& b)
@@ -1037,17 +1037,17 @@ max (const ComplexNDArray& a, const Comp
     }
 
   EMPTY_RETURN_CHECK (ComplexNDArray);
 
   ComplexNDArray result (dv);
 
   for (int i = 0; i < nel; i++)
     {
-      OCTAVE_QUIT;
+      octave_quit ();
       result (i) = xmax (a (i), b (i));
     }
 
   return result;
 }
 
 NDS_CMP_OPS (ComplexNDArray, Complex)
 NDS_BOOL_OPS (ComplexNDArray, Complex)
diff --git a/liboctave/CSparse.cc b/liboctave/CSparse.cc
--- a/liboctave/CSparse.cc
+++ b/liboctave/CSparse.cc
@@ -819,17 +819,17 @@ SparseComplexMatrix::tinverse (MatrixTyp
 	    {
 	      octave_idx_type nz = nnz ();
 	      octave_idx_type cx = 0;
 	      octave_idx_type nz2 = nz;
 	      retval = SparseComplexMatrix (nr, nc, nz2);
 
 	      for (octave_idx_type i = 0; i < nr; i++)
 		{
-		  OCTAVE_QUIT;
+		  octave_quit ();
 		  // place the 1 in the identity position
 		  octave_idx_type cx_colstart = cx;
 	  
 		  if (cx == nz2)
 		    {
 		      nz2 *= 2;
 		      retval.change_capacity (nz2);
 		    }
@@ -852,17 +852,17 @@ SparseComplexMatrix::tinverse (MatrixTyp
 			{
 			  (*current_liboctave_error_handler) 
 			    ("division by zero");
 			  goto inverse_singular;
 			}
 
 		      do
 			{
-			  OCTAVE_QUIT;
+			  octave_quit ();
 			  rpX = retval.xridx(colXp);
 			  rpU = ridx(colUp);
 
 			  if (rpX < rpU) 
 			    colXp++;
 			  else if (rpX > rpU) 
 			    colUp++;
 			  else 
@@ -943,17 +943,17 @@ SparseComplexMatrix::tinverse (MatrixTyp
 		  for (octave_idx_type i = 0; i < nr; i++)
 		    rperm[i] = perm[i];
 		  for (octave_idx_type i = 0; i < nr; i++)
 		    perm[rperm[i]] = i;
 		}
 
 	      for (octave_idx_type i = 0; i < nr; i++)
 		{
-		  OCTAVE_QUIT;
+		  octave_quit ();
 		  octave_idx_type iidx = rperm[i];
 
 		  for (octave_idx_type j = 0; j < nr; j++)
 		    work[j] = 0.;
 
 		  // place the 1 in the identity position
 		  work[iidx] = 1.0;
 
@@ -961,17 +961,17 @@ SparseComplexMatrix::tinverse (MatrixTyp
 		  for (octave_idx_type j = iidx+1; j < nr; j++) 
 		    {
 		      Complex v = 0.;
 		      octave_idx_type jidx = perm[j];
 		      // iterate to calculate sum
 		      for (octave_idx_type k = cidx(jidx); 
 			   k < cidx(jidx+1); k++)
 			{
-			  OCTAVE_QUIT;
+			  octave_quit ();
 			  v -= work[ridx(k)] * data(k);
 			}
 
 		      // get A(m,m)
 		      Complex pivot;
 		      if (typ == MatrixType::Permuted_Upper)
 			pivot = data(cidx(jidx+1) - 1);
 		      else
@@ -7426,17 +7426,17 @@ SparseComplexMatrix::diag (octave_idx_ty
 std::ostream&
 operator << (std::ostream& os, const SparseComplexMatrix& a)
 {
   octave_idx_type nc = a.cols ();
 
    // add one to the printed indices to go from
    //  zero-based to one-based arrays
    for (octave_idx_type j = 0; j < nc; j++)  {
-      OCTAVE_QUIT;
+      octave_quit ();
       for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++) {
 	os << a.ridx(i) + 1 << " "  << j + 1 << " ";
 	octave_write_complex (os, a.data(i));
 	os << "\n";
       }
    }
 
   return os;
@@ -7706,17 +7706,17 @@ min (const SparseComplexMatrix& a, const
 	      bool ja_lt_max= ja < ja_max;
            
 	      octave_idx_type  jb = b.cidx(i);
 	      octave_idx_type  jb_max = b.cidx(i+1);
 	      bool jb_lt_max = jb < jb_max;
            
 	      while (ja_lt_max || jb_lt_max )
 		{
-		  OCTAVE_QUIT;
+		  octave_quit ();
 		  if ((! jb_lt_max) ||
                       (ja_lt_max && (a.ridx(ja) < b.ridx(jb))))
 		    {
 		      Complex tmp = xmin (a.data(ja), 0.);
 		      if (tmp != 0.)
 			{
 			  r.ridx(jx) = a.ridx(ja);
 			  r.data(jx) = tmp;
@@ -7830,17 +7830,17 @@ max (const SparseComplexMatrix& a, const
 	      bool ja_lt_max= ja < ja_max;
            
 	      octave_idx_type  jb = b.cidx(i);
 	      octave_idx_type  jb_max = b.cidx(i+1);
 	      bool jb_lt_max = jb < jb_max;
            
 	      while (ja_lt_max || jb_lt_max )
 		{
-		  OCTAVE_QUIT;
+		  octave_quit ();
 		  if ((! jb_lt_max) ||
                       (ja_lt_max && (a.ridx(ja) < b.ridx(jb))))
 		    {
 		      Complex tmp = xmax (a.data(ja), 0.);
 		      if (tmp != 0.)
 			{
 			  r.ridx(jx) = a.ridx(ja);
 			  r.data(jx) = tmp;
diff --git a/liboctave/ChangeLog b/liboctave/ChangeLog
--- a/liboctave/ChangeLog
+++ b/liboctave/ChangeLog
@@ -1,8 +1,44 @@
+2010-01-20  Jaroslav Hajek  <highegg@gmail.com>
+
+	* Array.h: Substitute OCTAVE_QUIT -> octave_quit ().
+	* CMatrix.cc: Ditto.
+	* CNDArray.cc: Ditto.
+	* CSparse.cc: Ditto.
+	* CmplxGEPBAL.cc: Ditto.
+	* MArrayN.cc: Ditto.
+	* MSparse.cc: Ditto.
+	* Sparse-diag-op-defs.h: Ditto.
+	* Sparse-op-defs.h: Ditto.
+	* Sparse-perm-op-defs.h: Ditto.
+	* Sparse.cc: Ditto.
+	* Sparse.h: Ditto.
+	* SparseCmplxQR.cc: Ditto.
+	* SparseQR.cc: Ditto.
+	* boolSparse.cc: Ditto.
+	* bsxfun-defs.cc: Ditto.
+	* dMatrix.cc: Ditto.
+	* dNDArray.cc: Ditto.
+	* dSparse.cc: Ditto.
+	* dbleGEPBAL.cc: Ditto.
+	* fCMatrix.cc: Ditto.
+	* fCNDArray.cc: Ditto.
+	* fCmplxGEPBAL.cc: Ditto.
+	* fMatrix.cc: Ditto.
+	* fNDArray.cc: Ditto.
+	* file-ops.cc: Ditto.
+	* floatGEPBAL.cc: Ditto.
+	* lo-utils.cc: Ditto.
+	* mx-op-defs.h: Ditto.
+	* oct-fftw.cc: Ditto.
+	* oct-norm.cc: Ditto.
+	* oct-rand.cc: Ditto.
+	* sparse-dmsolve.cc: Ditto.
+
 2010-01-20  Jaroslav Hajek  <highegg@gmail.com>
 
 	* bsxfun-defs.cc (BSXFUN_STDOP_DEFS_MXLOOP): Fix reversed min/max
 	defs.
 
 2010-01-20  John W. Eaton  <jwe@octave.org>
 
 	* glob-match.h: Update copyright.
diff --git a/liboctave/CmplxGEPBAL.cc b/liboctave/CmplxGEPBAL.cc
--- a/liboctave/CmplxGEPBAL.cc
+++ b/liboctave/CmplxGEPBAL.cc
@@ -92,17 +92,17 @@ ComplexGEPBALANCE::init (const ComplexMa
 			     n, p_balanced_mat, n, p_balanced_mat2,
 			     n, ilo, ihi, plscale, prscale, pwork, info
 			     F77_CHAR_ARG_LEN (1)));
 
   balancing_mat = Matrix (n, n, 0.0);
   balancing_mat2 = Matrix (n, n, 0.0);
   for (octave_idx_type i = 0; i < n; i++)
     {
-      OCTAVE_QUIT;
+      octave_quit ();
       balancing_mat.elem (i ,i) = 1.0;
       balancing_mat2.elem (i ,i) = 1.0;
     }
 
   double *p_balancing_mat = balancing_mat.fortran_vec ();
   double *p_balancing_mat2 = balancing_mat2.fortran_vec ();
 
   // first left
diff --git a/liboctave/MArrayN.cc b/liboctave/MArrayN.cc
--- a/liboctave/MArrayN.cc
+++ b/liboctave/MArrayN.cc
@@ -58,17 +58,17 @@ MArrayN<T>::idx_add (const idx_vector& i
   octave_idx_type n = this->length ();
   octave_idx_type ext = idx.extent (n);
   if (ext > n)
     {
       this->resize (ext);
       n = ext;
     }
 
-  OCTAVE_QUIT;
+  octave_quit ();
 
   octave_idx_type len = idx.length (n);
   idx.loop (len, _idxadds_helper<T> (this->fortran_vec (), val));
 }
 
 template <class T>
 void
 MArrayN<T>::idx_add (const idx_vector& idx, const MArrayN<T>& vals)
@@ -76,17 +76,17 @@ MArrayN<T>::idx_add (const idx_vector& i
   octave_idx_type n = this->length ();
   octave_idx_type ext = idx.extent (n);
   if (ext > n)
     {
       this->resize (ext);
       n = ext;
     }
 
-  OCTAVE_QUIT;
+  octave_quit ();
 
   octave_idx_type len = std::min (idx.length (n), vals.length ());
   idx.loop (len, _idxadda_helper<T> (this->fortran_vec (), vals.data ()));
 }
 
 // N-dimensional array with math ops.
 template <class T>
 void
diff --git a/liboctave/MSparse.cc b/liboctave/MSparse.cc
--- a/liboctave/MSparse.cc
+++ b/liboctave/MSparse.cc
@@ -63,17 +63,17 @@ operator += (MSparse<T>& a, const MSpars
             bool ja_lt_max= ja < ja_max;
            
             octave_idx_type  jb = b.cidx(i);
             octave_idx_type  jb_max = b.cidx(i+1);
             bool jb_lt_max = jb < jb_max;
            
             while (ja_lt_max || jb_lt_max )
               {
-                OCTAVE_QUIT;
+                octave_quit ();
                 if ((! jb_lt_max) ||
                       (ja_lt_max && (a.ridx(ja) < b.ridx(jb))))
                   {
                     r.ridx(jx) = a.ridx(ja);
                     r.data(jx) = a.data(ja) + 0.;
                     jx++;
                     ja++;
                     ja_lt_max= ja < ja_max;
@@ -136,17 +136,17 @@ operator -= (MSparse<T>& a, const MSpars
             bool ja_lt_max= ja < ja_max;
            
             octave_idx_type  jb = b.cidx(i);
             octave_idx_type  jb_max = b.cidx(i+1);
             bool jb_lt_max = jb < jb_max;
            
             while (ja_lt_max || jb_lt_max )
               {
-                OCTAVE_QUIT;
+                octave_quit ();
                 if ((! jb_lt_max) ||
                       (ja_lt_max && (a.ridx(ja) < b.ridx(jb))))
                   {
                     r.ridx(jx) = a.ridx(ja);
                     r.data(jx) = a.data(ja) - 0.;
                     jx++;
                     ja++;
                     ja_lt_max= ja < ja_max;
@@ -294,42 +294,42 @@ SPARSE_SA2_OP_2 (/)
         if (a.elem(0,0) == 0.) \
           r =  OP MSparse<T> (b); \
         else \
           { \
 	    r = MSparse<T> (b_nr, b_nc, a.data(0) OP 0.); \
             \
             for (octave_idx_type j = 0 ; j < b_nc ; j++) \
               { \
-                OCTAVE_QUIT; \
+                octave_quit (); \
                 octave_idx_type idxj = j * b_nr; \
                 for (octave_idx_type i = b.cidx(j) ; i < b.cidx(j+1) ; i++) \
                   { \
-                   OCTAVE_QUIT; \
+                   octave_quit (); \
                    r.data(idxj + b.ridx(i)) = a.data(0) OP b.data(i); \
 		  } \
               } \
             r.maybe_compress (); \
           } \
       } \
     else if (b_nr == 1 && b_nc == 1) \
       { \
         if (b.elem(0,0) == 0.) \
           r = MSparse<T> (a); \
         else \
           { \
 	    r = MSparse<T> (a_nr, a_nc, 0. OP b.data(0)); \
             \
             for (octave_idx_type j = 0 ; j < a_nc ; j++) \
               { \
-                OCTAVE_QUIT; \
+                octave_quit (); \
                 octave_idx_type idxj = j * a_nr; \
                 for (octave_idx_type i = a.cidx(j) ; i < a.cidx(j+1) ; i++) \
                   { \
-                    OCTAVE_QUIT; \
+                    octave_quit (); \
                     r.data(idxj + a.ridx(i)) = a.data(i) OP b.data(0); \
 		  } \
               } \
             r.maybe_compress (); \
           } \
       } \
     else if (a_nr != b_nr || a_nc != b_nc) \
       gripe_nonconformant ("operator " # OP, a_nr, a_nc, b_nr, b_nc); \
@@ -346,17 +346,17 @@ SPARSE_SA2_OP_2 (/)
             bool ja_lt_max= ja < ja_max; \
             \
             octave_idx_type  jb = b.cidx(i); \
             octave_idx_type  jb_max = b.cidx(i+1); \
             bool jb_lt_max = jb < jb_max; \
             \
             while (ja_lt_max || jb_lt_max ) \
               { \
-                OCTAVE_QUIT; \
+                octave_quit (); \
                 if ((! jb_lt_max) || \
                       (ja_lt_max && (a.ridx(ja) < b.ridx(jb)))) \
                   { \
                     r.ridx(jx) = a.ridx(ja); \
                     r.data(jx) = a.data(ja) OP 0.; \
                     jx++; \
                     ja++; \
                     ja_lt_max= ja < ja_max; \
@@ -412,34 +412,34 @@ SPARSE_SA2_OP_2 (/)
           r = MSparse<T> (b_nr, b_nc); \
         else \
           { \
 	    r = MSparse<T> (b); \
             octave_idx_type b_nnz = b.nnz(); \
             \
             for (octave_idx_type i = 0 ; i < b_nnz ; i++) \
               { \
-                OCTAVE_QUIT; \
+                octave_quit (); \
                 r.data (i) = a.data(0) OP r.data(i); \
               } \
             r.maybe_compress (); \
           } \
       } \
     else if (b_nr == 1 && b_nc == 1) \
       { \
         if (b.elem(0,0) == 0.) \
           r = MSparse<T> (a_nr, a_nc); \
         else \
           { \
 	    r = MSparse<T> (a); \
             octave_idx_type a_nnz = a.nnz(); \
             \
             for (octave_idx_type i = 0 ; i < a_nnz ; i++) \
               { \
-                OCTAVE_QUIT; \
+                octave_quit (); \
                 r.data (i) = r.data(i) OP b.data(0); \
               } \
             r.maybe_compress (); \
           } \
       } \
     else if (a_nr != b_nr || a_nc != b_nc) \
       gripe_nonconformant (#FCN, a_nr, a_nc, b_nr, b_nc); \
     else \
@@ -455,17 +455,17 @@ SPARSE_SA2_OP_2 (/)
             bool ja_lt_max= ja < ja_max; \
             \
             octave_idx_type  jb = b.cidx(i); \
             octave_idx_type  jb_max = b.cidx(i+1); \
             bool jb_lt_max = jb < jb_max; \
             \
             while (ja_lt_max || jb_lt_max ) \
               { \
-                OCTAVE_QUIT; \
+                octave_quit (); \
                 if ((! jb_lt_max) || \
                       (ja_lt_max && (a.ridx(ja) < b.ridx(jb)))) \
                   { \
                      ja++; ja_lt_max= ja < ja_max; \
                   } \
                 else if (( !ja_lt_max ) || \
                      (jb_lt_max && (b.ridx(jb) < a.ridx(ja)) ) ) \
                   { \
@@ -518,21 +518,21 @@ SPARSE_SA2_OP_2 (/)
               r.data (i) = val OP r.data(i); \
             r.maybe_compress (); \
           } \
         else \
           { \
             r = MSparse<T> (b_nr, b_nc, fill); \
             for (octave_idx_type j = 0 ; j < b_nc ; j++) \
               { \
-                OCTAVE_QUIT; \
+                octave_quit (); \
                 octave_idx_type idxj = j * b_nr; \
                 for (octave_idx_type i = b.cidx(j) ; i < b.cidx(j+1) ; i++) \
                   { \
-                    OCTAVE_QUIT; \
+                    octave_quit (); \
                     r.data(idxj + b.ridx(i)) = val OP b.data(i); \
 		  } \
               } \
             r.maybe_compress (); \
           } \
       } \
     else if (b_nr == 1 && b_nc == 1) \
       { \
@@ -546,21 +546,21 @@ SPARSE_SA2_OP_2 (/)
               r.data (i) = r.data(i) OP val; \
             r.maybe_compress (); \
           } \
         else \
           { \
             r = MSparse<T> (a_nr, a_nc, fill); \
             for (octave_idx_type j = 0 ; j < a_nc ; j++) \
               { \
-                OCTAVE_QUIT; \
+                octave_quit (); \
                 octave_idx_type idxj = j * a_nr; \
                 for (octave_idx_type i = a.cidx(j) ; i < a.cidx(j+1) ; i++) \
                   { \
-                    OCTAVE_QUIT; \
+                    octave_quit (); \
                     r.data(idxj + a.ridx(i)) = a.data(i) OP val; \
 		  } \
               } \
             r.maybe_compress (); \
           } \
       } \
     else if (a_nr != b_nr || a_nc != b_nc) \
       gripe_nonconformant (#FCN, a_nr, a_nc, b_nr, b_nc); \
@@ -575,17 +575,17 @@ SPARSE_SA2_OP_2 (/)
             bool ja_lt_max= ja < ja_max; \
             \
             octave_idx_type  jb = b.cidx(i); \
             octave_idx_type  jb_max = b.cidx(i+1); \
             bool jb_lt_max = jb < jb_max; \
             \
             while (ja_lt_max || jb_lt_max ) \
               { \
-                OCTAVE_QUIT; \
+                octave_quit (); \
                 if ((! jb_lt_max) || \
                       (ja_lt_max && (a.ridx(ja) < b.ridx(jb)))) \
                   { \
 		     r.elem (a.ridx(ja),i) = a.data(ja) OP Zero; \
                      ja++; ja_lt_max= ja < ja_max; \
                   } \
                 else if (( !ja_lt_max ) || \
                      (jb_lt_max && (b.ridx(jb) < a.ridx(ja)) ) ) \
diff --git a/liboctave/Sparse-diag-op-defs.h b/liboctave/Sparse-diag-op-defs.h
--- a/liboctave/Sparse-diag-op-defs.h
+++ b/liboctave/Sparse-diag-op-defs.h
@@ -127,17 +127,17 @@ RT inner_do_add_sm_dm (const SM& a, cons
   const octave_idx_type a_nc = a.cols ();
 
   const octave_idx_type nz = a.nnz ();
   RT r (a_nr, a_nc, nz + n);
   octave_idx_type k = 0;
 
   for (octave_idx_type j = 0; j < nc; ++j)
     {
-      OCTAVE_QUIT;
+      octave_quit ();
       const octave_idx_type colend = a.cidx (j+1);
       r.xcidx (j) = k;
       octave_idx_type k_src = a.cidx (j), k_split;
 
       for (k_split = k_src; k_split < colend; k_split++)
         if (a.ridx (k_split) >= j)
           break;
 
diff --git a/liboctave/Sparse-op-defs.h b/liboctave/Sparse-op-defs.h
--- a/liboctave/Sparse-op-defs.h
+++ b/liboctave/Sparse-op-defs.h
@@ -400,42 +400,42 @@ along with Octave; see the file COPYING.
         if (m1.elem(0,0) == 0.) \
           r = OP R (m2); \
         else \
           { \
 	    r = R (m2_nr, m2_nc, m1.data(0) OP 0.); \
             \
             for (octave_idx_type j = 0 ; j < m2_nc ; j++) \
               { \
-                OCTAVE_QUIT; \
+                octave_quit (); \
                 octave_idx_type idxj = j * m2_nr; \
                 for (octave_idx_type i = m2.cidx(j) ; i < m2.cidx(j+1) ; i++) \
                   { \
-                    OCTAVE_QUIT; \
+                    octave_quit (); \
                     r.data(idxj + m2.ridx(i)) = m1.data(0) OP m2.data(i); \
 		  } \
               } \
             r.maybe_compress (); \
           } \
       } \
     else if (m2_nr == 1 && m2_nc == 1) \
       { \
         if (m2.elem(0,0) == 0.) \
           r = R (m1); \
         else \
           { \
 	    r = R (m1_nr, m1_nc, 0. OP m2.data(0)); \
             \
             for (octave_idx_type j = 0 ; j < m1_nc ; j++) \
               { \
-                OCTAVE_QUIT; \
+                octave_quit (); \
                 octave_idx_type idxj = j * m1_nr; \
                 for (octave_idx_type i = m1.cidx(j) ; i < m1.cidx(j+1) ; i++) \
                   { \
-                    OCTAVE_QUIT; \
+                    octave_quit (); \
                     r.data(idxj + m1.ridx(i)) = m1.data(i) OP m2.data(0); \
 		  } \
               } \
             r.maybe_compress (); \
           } \
       } \
     else if (m1_nr != m2_nr || m1_nc != m2_nc) \
       gripe_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc); \
@@ -452,17 +452,17 @@ along with Octave; see the file COPYING.
             bool ja_lt_max= ja < ja_max; \
             \
             octave_idx_type  jb = m2.cidx(i); \
             octave_idx_type  jb_max = m2.cidx(i+1); \
             bool jb_lt_max = jb < jb_max; \
             \
             while (ja_lt_max || jb_lt_max ) \
               { \
-                OCTAVE_QUIT; \
+                octave_quit (); \
                 if ((! jb_lt_max) || \
                       (ja_lt_max && (m1.ridx(ja) < m2.ridx(jb)))) \
                   { \
                     r.ridx(jx) = m1.ridx(ja); \
                     r.data(jx) = m1.data(ja) OP 0.; \
                     jx++; \
                     ja++; \
                     ja_lt_max= ja < ja_max; \
@@ -517,34 +517,34 @@ along with Octave; see the file COPYING.
           r = R (m2_nr, m2_nc); \
         else \
           { \
 	    r = R (m2); \
             octave_idx_type m2_nnz = m2.nnz(); \
             \
             for (octave_idx_type i = 0 ; i < m2_nnz ; i++) \
               { \
-                OCTAVE_QUIT; \
+                octave_quit (); \
                 r.data (i) = m1.data(0) OP r.data(i); \
               } \
             r.maybe_compress (); \
           } \
       } \
     else if (m2_nr == 1 && m2_nc == 1) \
       { \
         if (m2.elem(0,0) == 0.) \
           r = R (m1_nr, m1_nc); \
         else \
           { \
 	    r = R (m1); \
             octave_idx_type m1_nnz = m1.nnz(); \
             \
             for (octave_idx_type i = 0 ; i < m1_nnz ; i++) \
               { \
-                OCTAVE_QUIT; \
+                octave_quit (); \
                 r.data (i) = r.data(i) OP m2.data(0); \
               } \
             r.maybe_compress (); \
           } \
       } \
     else if (m1_nr != m2_nr || m1_nc != m2_nc) \
       gripe_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc); \
     else \
@@ -560,17 +560,17 @@ along with Octave; see the file COPYING.
             bool ja_lt_max= ja < ja_max; \
             \
             octave_idx_type  jb = m2.cidx(i); \
             octave_idx_type  jb_max = m2.cidx(i+1); \
             bool jb_lt_max = jb < jb_max; \
             \
             while (ja_lt_max || jb_lt_max ) \
               { \
-                OCTAVE_QUIT; \
+                octave_quit (); \
                 if ((! jb_lt_max) || \
                       (ja_lt_max && (m1.ridx(ja) < m2.ridx(jb)))) \
                   { \
                      ja++; ja_lt_max= ja < ja_max; \
                   } \
                 else if (( !ja_lt_max ) || \
                      (jb_lt_max && (m2.ridx(jb) < m1.ridx(ja)) ) ) \
                   { \
@@ -619,21 +619,21 @@ along with Octave; see the file COPYING.
               r.data (i) = m1.elem(0,0) OP r.data(i); \
             r.maybe_compress (); \
           } \
         else \
           { \
             r = R (m2_nr, m2_nc, m1.elem(0,0) OP Complex ()); \
             for (octave_idx_type j = 0 ; j < m2_nc ; j++) \
               { \
-                OCTAVE_QUIT; \
+                octave_quit (); \
                 octave_idx_type idxj = j * m2_nr; \
                 for (octave_idx_type i = m2.cidx(j) ; i < m2.cidx(j+1) ; i++) \
                   { \
-                    OCTAVE_QUIT; \
+                    octave_quit (); \
                     r.data(idxj + m2.ridx(i)) = m1.elem(0,0) OP m2.data(i); \
 		  } \
               } \
             r.maybe_compress (); \
           } \
       } \
     else if (m2_nr == 1 && m2_nc == 1) \
       { \
@@ -645,21 +645,21 @@ along with Octave; see the file COPYING.
               r.data (i) = r.data(i) OP m2.elem(0,0); \
             r.maybe_compress (); \
           } \
         else \
           { \
             r = R (m1_nr, m1_nc, Complex() OP m2.elem(0,0)); \
             for (octave_idx_type j = 0 ; j < m1_nc ; j++) \
               { \
-                OCTAVE_QUIT; \
+                octave_quit (); \
                 octave_idx_type idxj = j * m1_nr; \
                 for (octave_idx_type i = m1.cidx(j) ; i < m1.cidx(j+1) ; i++) \
                   { \
-                    OCTAVE_QUIT; \
+                    octave_quit (); \
                     r.data(idxj + m1.ridx(i)) = m1.data(i) OP m2.elem(0,0); \
 		  } \
               } \
             r.maybe_compress (); \
           } \
       } \
     else if (m1_nr != m2_nr || m1_nc != m2_nc) \
       gripe_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc); \
@@ -676,17 +676,17 @@ along with Octave; see the file COPYING.
             bool ja_lt_max= ja < ja_max; \
             \
             octave_idx_type  jb = m2.cidx(i); \
             octave_idx_type  jb_max = m2.cidx(i+1); \
             bool jb_lt_max = jb < jb_max; \
             \
             while (ja_lt_max || jb_lt_max ) \
               { \
-                OCTAVE_QUIT; \
+                octave_quit (); \
                 if ((! jb_lt_max) || \
                       (ja_lt_max && (m1.ridx(ja) < m2.ridx(jb)))) \
                   { \
 		    /* keep those kludges coming */ \
                     r.elem(m1.ridx(ja),i) = m1.data(ja) OP Complex (); \
                     ja++; \
                     ja_lt_max= ja < ja_max; \
                   } \
@@ -1844,44 +1844,44 @@ along with Octave; see the file COPYING.
   if (nr == 1 && nc == 1) \
    { \
      RET_EL_TYPE s = m.elem(0,0); \
      octave_idx_type nz = a.nnz(); \
      RET_TYPE r (a_nr, a_nc, nz); \
      \
      for (octave_idx_type i = 0; i < nz; i++) \
        { \
-         OCTAVE_QUIT; \
+         octave_quit (); \
 	 r.data(i) = s * a.data(i); \
 	 r.ridx(i) = a.ridx(i); \
        } \
      for (octave_idx_type i = 0; i < a_nc + 1; i++) \
        { \
-         OCTAVE_QUIT; \
+         octave_quit (); \
          r.cidx(i) = a.cidx(i); \
        } \
      \
      r.maybe_compress (true); \
      return r; \
    } \
   else if (a_nr == 1 && a_nc == 1) \
    { \
      RET_EL_TYPE s = a.elem(0,0); \
      octave_idx_type nz = m.nnz(); \
      RET_TYPE r (nr, nc, nz); \
      \
      for (octave_idx_type i = 0; i < nz; i++) \
        { \
-         OCTAVE_QUIT; \
+         octave_quit (); \
 	 r.data(i) = m.data(i) * s; \
 	 r.ridx(i) = m.ridx(i); \
        } \
      for (octave_idx_type i = 0; i < nc + 1; i++) \
        { \
-         OCTAVE_QUIT; \
+         octave_quit (); \
          r.cidx(i) = m.cidx(i); \
        } \
      \
      r.maybe_compress (true); \
      return r; \
    } \
   else if (nc != a_nr) \
     { \
@@ -1905,17 +1905,17 @@ along with Octave; see the file COPYING.
               octave_idx_type  col = a.ridx(j); \
               for (octave_idx_type k = m.cidx(col) ; k < m.cidx(col+1); k++) \
 		{ \
 		  if (w[m.ridx(k)] < i + 1) \
                     { \
 		      w[m.ridx(k)] = i + 1; \
 		      nel++; \
 		    } \
-	          OCTAVE_QUIT; \
+	          octave_quit (); \
 		} \
 	    } \
           retval.xcidx(i+1) = nel; \
 	} \
       \
       if (nel == 0) \
 	return RET_TYPE (nr, a_nc); \
       else \
@@ -1949,17 +1949,17 @@ along with Octave; see the file COPYING.
 		{ \
 		  for (octave_idx_type j = a.cidx(i); j < a.cidx(i+1); j++) \
 		    { \
 		      octave_idx_type col = a.ridx(j); \
 		      EL_TYPE tmpval = a.data(j); \
 		      for (octave_idx_type k = m.cidx(col) ; \
 			   k < m.cidx(col+1); k++) \
 			{ \
-			  OCTAVE_QUIT; \
+			  octave_quit (); \
 			  octave_idx_type row = m.ridx(k); \
 			  if (w[row] < i + 1) \
 			    { \
 			      w[row] = i + 1; \
 			      Xcol[row] = tmpval * m.data(k); \
 			    } \
 			  else \
 			    Xcol[row] += tmpval * m.data(k); \
@@ -1976,17 +1976,17 @@ along with Octave; see the file COPYING.
 		{ \
 		  for (octave_idx_type j = a.cidx(i); j < a.cidx(i+1); j++) \
 		    { \
 		      octave_idx_type col = a.ridx(j); \
 		      EL_TYPE tmpval = a.data(j); \
 		      for (octave_idx_type k = m.cidx(col) ; \
 			  k < m.cidx(col+1); k++) \
 			{ \
-			  OCTAVE_QUIT; \
+			  octave_quit (); \
 			  octave_idx_type row = m.ridx(k); \
 			  if (w[row] < i + 1) \
 			    { \
 			      w[row] = i + 1; \
 			      retval.xridx(ii++) = row;\
 			      Xcol[row] = tmpval * m.data(k); \
 			    } \
 			  else \
@@ -2023,17 +2023,17 @@ along with Octave; see the file COPYING.
   else \
     { \
       RET_TYPE retval (nr, a_nc, ZERO); \
       \
       for (octave_idx_type i = 0; i < a_nc ; i++) \
         { \
           for (octave_idx_type j = 0; j < a_nr; j++) \
             { \
-              OCTAVE_QUIT; \
+              octave_quit (); \
               \
               EL_TYPE tmpval = a.elem(j,i); \
               for (octave_idx_type k = m.cidx(j) ; k < m.cidx(j+1); k++) \
                 retval.elem (m.ridx(k),i) += tmpval * m.data(k); \
             } \
         } \
       return retval; \
     }
@@ -2058,17 +2058,17 @@ along with Octave; see the file COPYING.
   else \
     { \
       RET_TYPE retval (nc, a_nc); \
       \
       for (octave_idx_type i = 0; i < a_nc ; i++) \
         { \
           for (octave_idx_type j = 0; j < nc; j++) \
             { \
-              OCTAVE_QUIT; \
+              octave_quit (); \
               \
               EL_TYPE acc = ZERO; \
               for (octave_idx_type k = m.cidx(j) ; k < m.cidx(j+1); k++) \
                 acc += a.elem (m.ridx(k),i) * CONJ_OP (m.data(k)); \
               retval.xelem (j,i) = acc; \
             } \
         } \
       return retval; \
@@ -2092,17 +2092,17 @@ along with Octave; see the file COPYING.
       return RET_TYPE (); \
     } \
   else \
     { \
       RET_TYPE retval (nr, a_nc, ZERO); \
       \
       for (octave_idx_type i = 0; i < a_nc ; i++) \
         { \
-          OCTAVE_QUIT; \
+          octave_quit (); \
           for (octave_idx_type j = a.cidx(i); j < a.cidx(i+1); j++) \
             { \
               octave_idx_type col = a.ridx(j); \
               EL_TYPE tmpval = a.data(j); \
               \
               for (octave_idx_type k = 0 ; k < nr; k++) \
                 retval.xelem (k,i) += tmpval * m.elem(k,col); \
             } \
@@ -2128,17 +2128,17 @@ along with Octave; see the file COPYING.
       return RET_TYPE (); \
     } \
   else \
     { \
       RET_TYPE retval (nr, a_nr, ZERO); \
       \
       for (octave_idx_type i = 0; i < a_nc ; i++) \
         { \
-          OCTAVE_QUIT; \
+          octave_quit (); \
           for (octave_idx_type j = a.cidx(i); j < a.cidx(i+1); j++) \
             { \
               octave_idx_type col = a.ridx(j); \
               EL_TYPE tmpval = CONJ_OP (a.data(j)); \
               for (octave_idx_type k = 0 ; k < nr; k++) \
                 retval.xelem (k,col) += tmpval * m.elem(k,i); \
             } \
         } \
diff --git a/liboctave/Sparse-perm-op-defs.h b/liboctave/Sparse-perm-op-defs.h
--- a/liboctave/Sparse-perm-op-defs.h
+++ b/liboctave/Sparse-perm-op-defs.h
@@ -31,17 +31,17 @@ SM octinternal_do_mul_colpm_sm (const oc
 {
   const octave_idx_type nr = a.rows ();
   const octave_idx_type nc = a.cols ();
   const octave_idx_type nent = a.nnz ();
   SM r (nr, nc, nent);
 
   for (octave_idx_type k = 0; k < nent; ++k)
     {
-      OCTAVE_QUIT;
+      octave_quit ();
       r.xridx (k) = pcol[a.ridx (k)];
       r.xdata (k) = a.data (k);
     }
   for (octave_idx_type j = 0; j <= nc; ++j)
     r.xcidx (j) = a.cidx (j);
 
   r.maybe_compress (false);
   return r;
@@ -89,17 +89,17 @@ SM octinternal_do_mul_sm_rowpm (const SM
       r.xcidx (j) = k;
       k += tmp;
     }
   r.xcidx (nc) = nent;
 
   octave_idx_type k_src = 0;
   for (octave_idx_type j_src = 0; j_src < nc; ++j_src)
     {
-      OCTAVE_QUIT;
+      octave_quit ();
       const octave_idx_type j = prow[j_src];
       const octave_idx_type kend_src = a.cidx (j_src + 1);
       for (k = r.xcidx (j); k_src < kend_src; ++k, ++k_src)
 	{
 	  r.xridx (k) = a.ridx (k_src);
 	  r.xdata (k) = a.data (k_src);
 	}
     }
@@ -124,17 +124,17 @@ SM octinternal_do_mul_sm_colpm (const SM
       const octave_idx_type j_src = pcol[j];
       r.xcidx (j+1) = r.xcidx (j) + (a.cidx (j_src+1) - a.cidx (j_src));
     }
   assert (r.xcidx (nc) == nent);
 
   octave_idx_type k = 0;
   for (octave_idx_type j = 0; j < nc; ++j)
     {
-      OCTAVE_QUIT;
+      octave_quit ();
       const octave_idx_type j_src = pcol[j];
       octave_idx_type k_src;
       const octave_idx_type kend_src = a.cidx (j_src + 1);
       for (k_src = a.cidx (j_src); k_src < kend_src; ++k_src, ++k)
 	{
 	  r.xridx (k) = a.ridx (k_src);
 	  r.xdata (k) = a.data (k_src);
 	}
diff --git a/liboctave/Sparse.cc b/liboctave/Sparse.cc
--- a/liboctave/Sparse.cc
+++ b/liboctave/Sparse.cc
@@ -340,17 +340,17 @@ Sparse<T>::Sparse (const Array<T>& a, co
 
       OCTAVE_LOCAL_BUFFER (octave_sparse_sort_idxl *, sidx, max_nzmx);
       OCTAVE_LOCAL_BUFFER (octave_sparse_sort_idxl, sidxX, max_nzmx);
 
       for (octave_idx_type i = 0; i < max_nzmx; i++)
 	sidx[i] = &sidxX[i];
 
       octave_idx_type actual_nzmx = 0;
-      OCTAVE_QUIT;
+      octave_quit ();
       for (octave_idx_type i = 0; i < max_nzmx; i++) 
 	{
 	  octave_idx_type rowidx =  (ri_scalar ? r(0) : r(i));
 	  octave_idx_type colidx = (ci_scalar ? c(0) : c(i));
 	  if (rowidx < nr && rowidx >= 0 &&
 	      colidx < nc && colidx >= 0 ) 
 	    {
 	      if ( a (cf_scalar ? 0 : i ) != T ()) 
@@ -371,39 +371,39 @@ Sparse<T>::Sparse (const Array<T>& a, co
 	      return;
 	    }
 	}
   
       if (actual_nzmx == 0)
 	rep = new typename Sparse<T>::SparseRep (nr, nc);
       else
 	{
-	  OCTAVE_QUIT;
+	  octave_quit ();
 	  octave_sort<octave_sparse_sort_idxl *> 
 	    lsort (octave_sparse_sidxl_comp);
 
 	  lsort.sort (sidx, actual_nzmx);
-	  OCTAVE_QUIT;
+	  octave_quit ();
 
 	  // Now count the unique non-zero values
 	  octave_idx_type real_nzmx = 1;
 	  for (octave_idx_type i = 1; i < actual_nzmx; i++) 
 	    if (sidx[i-1]->r != sidx[i]->r || sidx[i-1]->c != sidx[i]->c) 
 	      real_nzmx++;
 
 	  rep = new typename Sparse<T>::SparseRep (nr, nc, real_nzmx);
 
 	  octave_idx_type cx = 0;
 	  octave_idx_type prev_rval = -1;
 	  octave_idx_type prev_cval = -1;
 	  octave_idx_type ii = -1;
 	  xcidx (0) = 0;
 	  for (octave_idx_type i = 0; i < actual_nzmx; i++) 
 	    {
-	      OCTAVE_QUIT;
+	      octave_quit ();
 	      octave_idx_type iidx = sidx[i]->idx;
 	      octave_idx_type rval = sidx[i]->r;
 	      octave_idx_type cval = sidx[i]->c;
 
 	      if (prev_cval < cval || (prev_rval < rval && prev_cval == cval)) 
 		{
 		  octave_idx_type ci = static_cast<octave_idx_type> (c (ci_scalar ? 0 : iidx));
 		  ii++;
@@ -457,17 +457,17 @@ Sparse<T>::Sparse (const Array<T>& a, co
   
       OCTAVE_LOCAL_BUFFER (octave_sparse_sort_idxl *, sidx, max_nzmx);
       OCTAVE_LOCAL_BUFFER (octave_sparse_sort_idxl, sidxX, max_nzmx);
 
       for (octave_idx_type i = 0; i < max_nzmx; i++)
 	sidx[i] = &sidxX[i];
 
       octave_idx_type actual_nzmx = 0;
-      OCTAVE_QUIT;
+      octave_quit ();
 
       for (octave_idx_type i = 0; i < max_nzmx; i++) 
 	{
 	  octave_idx_type rowidx = static_cast<octave_idx_type> (ri_scalar ? r(0) : r(i));
 	  octave_idx_type colidx = static_cast<octave_idx_type> (ci_scalar ? c(0) : c(i));
 	  if (rowidx < nr && rowidx >= 0 &&
 	      colidx < nc && colidx >= 0 ) 
 	    {
@@ -489,39 +489,39 @@ Sparse<T>::Sparse (const Array<T>& a, co
 	      return;
 	    }
 	}
 
       if (actual_nzmx == 0)
 	rep = new typename Sparse<T>::SparseRep (nr, nc);
       else
 	{
-	  OCTAVE_QUIT;
+	  octave_quit ();
 	  octave_sort<octave_sparse_sort_idxl *> 
 	    lsort (octave_sparse_sidxl_comp);
 
 	  lsort.sort (sidx, actual_nzmx);
-	  OCTAVE_QUIT;
+	  octave_quit ();
 
 	  // Now count the unique non-zero values
 	  octave_idx_type real_nzmx = 1;
 	  for (octave_idx_type i = 1; i < actual_nzmx; i++) 
 	    if (sidx[i-1]->r != sidx[i]->r || sidx[i-1]->c != sidx[i]->c) 
 	      real_nzmx++;
 
 	  rep = new typename Sparse<T>::SparseRep (nr, nc, real_nzmx);
 
 	  octave_idx_type cx = 0;
 	  octave_idx_type prev_rval = -1;
 	  octave_idx_type prev_cval = -1;
 	  octave_idx_type ii = -1;
 	  xcidx (0) = 0;
 	  for (octave_idx_type i = 0; i < actual_nzmx; i++) 
 	    {
-	      OCTAVE_QUIT;
+	      octave_quit ();
 	      octave_idx_type iidx = sidx[i]->idx;
 	      octave_idx_type rval = sidx[i]->r;
 	      octave_idx_type cval = sidx[i]->c;
 
 	      if (prev_cval < cval || (prev_rval < rval && prev_cval == cval)) 
 		{
 		  octave_idx_type ci = static_cast<octave_idx_type> (c (ci_scalar ? 0 : iidx));
 		  ii++;
@@ -998,34 +998,34 @@ Sparse<T>::insert (const Sparse<T>& a, o
     }
   for (octave_idx_type i = 0; i < c + 1; i++)
     cidx(i) = tmp.cidx(i);
 
   octave_idx_type ii = cidx(c);
 
   for (octave_idx_type i = c; i < c + a_cols; i++)
     {
-      OCTAVE_QUIT;
+      octave_quit ();
 
       for (octave_idx_type j = tmp.cidx(i); j < tmp.cidx(i+1); j++)
 	if (tmp.ridx(j) < r)
 	  {
 	    data(ii) = tmp.data(j);
 	    ridx(ii++) = tmp.ridx(j);
 	  }
 
-      OCTAVE_QUIT;
+      octave_quit ();
 
       for (octave_idx_type j = a.cidx(i-c); j < a.cidx(i-c+1); j++)
 	{
 	  data(ii) = a.data(j);
 	  ridx(ii++) = r + a.ridx(j);
 	}
 
-      OCTAVE_QUIT;
+      octave_quit ();
 
       for (octave_idx_type j = tmp.cidx(i); j < tmp.cidx(i+1); j++)
 	if (tmp.ridx(j) >= r + a_rows)
 	  {
 	    data(ii) = tmp.data(j);
 	    ridx(ii++) = tmp.ridx(j);
 	  }
 
@@ -1178,17 +1178,17 @@ Sparse<T>::maybe_delete_elements (idx_ve
       octave_idx_type new_nnz = nnz ();
 
       octave_idx_type iidx = 0;
 
       const Sparse<T> tmp (*this);
 
       for (octave_idx_type i = 0; i < n; i++)
 	{
-	  OCTAVE_QUIT;
+	  octave_quit ();
 
 	  if (i == idx_arg.elem (iidx))
 	    {
 	      iidx++;
 	      new_n--;
 
 	      if (tmp.elem (i) != T ())
 		new_nnz--;
@@ -1207,17 +1207,17 @@ Sparse<T>::maybe_delete_elements (idx_ve
 	  else
 	    rep = new typename Sparse<T>::SparseRep (new_n, 1, new_nnz);
 
 	  octave_idx_type ii = 0;
 	  octave_idx_type jj = 0;
 	  iidx = 0;
 	  for (octave_idx_type i = 0; i < n; i++)
 	    {
-	      OCTAVE_QUIT;
+	      octave_quit ();
 
 	      if (iidx < num_to_delete && i == idx_arg.elem (iidx))
 		iidx++;
 	      else
 		{
 		  T el = tmp.elem (i);
 		  if (el != T ())
 		    {
@@ -1231,17 +1231,17 @@ Sparse<T>::maybe_delete_elements (idx_ve
 	  dimensions.resize (2);
 
 	  if (nr == 1)
 	    {
 	      ii = 0;
 	      cidx(0) = 0;
 	      for (octave_idx_type i = 0; i < new_n; i++)
 		{
-		  OCTAVE_QUIT;
+		  octave_quit ();
 		  if (ridx(ii) == i)
 		    ridx(ii++) = 0;
 		  cidx(i+1) = ii;
 		}
 
 	      dimensions(0) = 1;
 	      dimensions(1) = new_n;
 	    }
@@ -1321,17 +1321,17 @@ Sparse<T>::maybe_delete_elements (idx_ve
 		{
 		  octave_idx_type new_nc = nc;
 		  octave_idx_type new_nnz = nnz ();
 
 		  octave_idx_type iidx = 0;
 
 		  for (octave_idx_type j = 0; j < nc; j++)
 		    {
-		      OCTAVE_QUIT;
+		      octave_quit ();
 
 		      if (j == idx_j.elem (iidx))
 			{
 			  iidx++;
 			  new_nc--;
 			  
 			  new_nnz -= cidx(j+1) - cidx(j);
 
@@ -1347,17 +1347,17 @@ Sparse<T>::maybe_delete_elements (idx_ve
 		      rep = new typename Sparse<T>::SparseRep (nr, new_nc, 
 							       new_nnz);
 		      octave_idx_type ii = 0;
 		      octave_idx_type jj = 0;
 		      iidx = 0;
 		      cidx(0) = 0;
 		      for (octave_idx_type j = 0; j < nc; j++)
 			{
-			  OCTAVE_QUIT;
+			  octave_quit ();
 
 			  if (iidx < num_to_delete && j == idx_j.elem (iidx))
 			    iidx++;
 			  else
 			    {
 			      for (octave_idx_type i = tmp.cidx(j); 
 				   i < tmp.cidx(j+1); i++)
 				{
@@ -1396,17 +1396,17 @@ Sparse<T>::maybe_delete_elements (idx_ve
 		{
 		  octave_idx_type new_nr = nr;
 		  octave_idx_type new_nnz = nnz ();
 
 		  octave_idx_type iidx = 0;
 
 		  for (octave_idx_type i = 0; i < nr; i++)
 		    {
-		      OCTAVE_QUIT;
+		      octave_quit ();
 
 		      if (i == idx_i.elem (iidx))
 			{
 			  iidx++;
 			  new_nr--;
 			  
 			  for (octave_idx_type j = 0; j < nnz (); j++)
 			    if (ridx(j) == i)
@@ -1426,17 +1426,17 @@ Sparse<T>::maybe_delete_elements (idx_ve
 
 		      octave_idx_type jj = 0;
 		      cidx(0) = 0;
 		      for (octave_idx_type i = 0; i < nc; i++)
 			{
 			  iidx = 0;
 			  for (octave_idx_type j = tmp.cidx(i); j < tmp.cidx(i+1); j++)
 			    {
-			      OCTAVE_QUIT;
+			      octave_quit ();
 
 			      octave_idx_type ri = tmp.ridx(j);
 
 			      while (iidx < num_to_delete && 
 				     ri > idx_i.elem (iidx))
 				{
 				  iidx++;
 				}
@@ -1531,17 +1531,17 @@ Sparse<T>::index (idx_vector& idx_arg, i
   else if (idx_arg.is_colon ())
     {
       // Fast magic colon processing.
       retval = Sparse<T> (nr * nc, 1, nz);
 
       for (octave_idx_type i = 0; i < nc; i++)
 	for (octave_idx_type j = cidx(i); j < cidx(i+1); j++)
 	  {
-	    OCTAVE_QUIT;
+	    octave_quit ();
 	    retval.xdata(j) = data(j); 
 	    retval.xridx(j) = ridx(j) + i * nr;
 	  }
       retval.xcidx(0) = 0;
       retval.xcidx(1) = nz;
     }
   else if (nr == 1 && nc == 1)
     {
@@ -1573,31 +1573,31 @@ Sparse<T>::index (idx_vector& idx_arg, i
 	  for (octave_idx_type i = 0; i < n; i++)
 	    {
 	      if (i % new_nr == 0)
 		retval.xcidx(i / new_nr) = ic;
 
 	      octave_idx_type ii = idx_arg.elem (i);
 	      if (ii == 0)
 		{
-		  OCTAVE_QUIT;
+		  octave_quit ();
 		  retval.xdata(ic) = el;
 		  retval.xridx(ic++) = i % new_nr;
 		}
 	    }
 	  retval.xcidx (new_nc) = ic;
 	}
       else
 	{
 	  T el = elem (0);
 	  retval = Sparse<T> (n, 1, nz);
   	 
 	  for (octave_idx_type i = 0; i < nz; i++) 
 	    {
-	      OCTAVE_QUIT;
+	      octave_quit ();
 	      retval.xdata(i) = el;
 	      retval.xridx(i) = i;
 	    }
 	  retval.xcidx(0) = 0; 	 
 	  retval.xcidx(1) = n; 	 
 	}
     }
   else if (nr == 1 || nc == 1)
@@ -1620,31 +1620,31 @@ Sparse<T>::index (idx_vector& idx_arg, i
 	  retval = Sparse<T> (idx_orig_dims);
       else
 	{
 
 	  octave_idx_type new_nzmx = 0;
 	  if (nr == 1)
 	    for (octave_idx_type i = 0; i < n; i++)
 	      {
-		OCTAVE_QUIT;
+		octave_quit ();
 
 		octave_idx_type ii = idx_arg.elem (i);
 		if (ii < len)
 		  if (cidx(ii) != cidx(ii+1))
 		    new_nzmx++;
 	      }
 	  else
 	    for (octave_idx_type i = 0; i < n; i++)
 	      {
 		octave_idx_type ii = idx_arg.elem (i);
 		if (ii < len)
 		  for (octave_idx_type j = 0; j < nz; j++)
 		    {
-		      OCTAVE_QUIT;
+		      octave_quit ();
 
 		      if (ridx(j) == ii)
 			new_nzmx++;
 		      if (ridx(j) >= ii)
 			break;
 		    }
 	      }
 
@@ -1652,17 +1652,17 @@ Sparse<T>::index (idx_vector& idx_arg, i
 	    {
 	      if (nr == 1)
 		{
 		  retval = Sparse<T> (1, n, new_nzmx);
 		  octave_idx_type jj = 0;
 		  retval.xcidx(0) = 0;
 		  for (octave_idx_type i = 0; i < n; i++)
 		    {
-		      OCTAVE_QUIT;
+		      octave_quit ();
 
 		      octave_idx_type ii = idx_arg.elem (i);
 		      if (ii < len)
 			if (cidx(ii) != cidx(ii+1))
 			  {
 			    retval.xdata(jj) = data(cidx(ii));
 			    retval.xridx(jj++) = 0;
 			  }
@@ -1676,17 +1676,17 @@ Sparse<T>::index (idx_vector& idx_arg, i
 		  retval.xcidx(1) = new_nzmx;
 		  octave_idx_type jj = 0;
 		  for (octave_idx_type i = 0; i < n; i++)
 		    {
 		      octave_idx_type ii = idx_arg.elem (i);
 		      if (ii < len)
 			for (octave_idx_type j = 0; j < nz; j++)
 			  {
-			    OCTAVE_QUIT;
+			    octave_quit ();
 
 			    if (ridx(j) == ii)
 			      {
 				retval.xdata(jj) = data(j);
 				retval.xridx(jj++) = i;
 			      }
 			    if (ridx(j) >= ii)
 			      break;
@@ -1712,17 +1712,17 @@ Sparse<T>::index (idx_vector& idx_arg, i
 	      retval = Sparse<T> (new_nr, new_nc, new_nzmx);
 
 	      if (nr == 1)
 		{
 		  octave_idx_type jj = 0;
 		  retval.xcidx(0) = 0;
 		  for (octave_idx_type i = 0; i < n; i++)
 		    {
-		      OCTAVE_QUIT;
+		      octave_quit ();
 
 		      octave_idx_type ii = idx_arg.elem (i);
 		      if (ii < len)
 			if (cidx(ii) != cidx(ii+1))
 			  {
 			    retval.xdata(jj) = data(cidx(ii));
 			    retval.xridx(jj++) = 0;
 			  }
@@ -1734,17 +1734,17 @@ Sparse<T>::index (idx_vector& idx_arg, i
 		  octave_idx_type jj = 0;
 		  retval.xcidx(0) = 0;
 		  for (octave_idx_type i = 0; i < n; i++)
 		    {
 		      octave_idx_type ii = idx_arg.elem (i);
 		      if (ii < len)
 			for (octave_idx_type j = 0; j < nz; j++)
 			  {
-			    OCTAVE_QUIT;
+			    octave_quit ();
 
 			    if (ridx(j) == ii)
 			      {
 				retval.xdata(jj) = data(j);
 				retval.xridx(jj++) = i;
 			      }
 			    if (ridx(j) >= ii)
 			      break;
@@ -1776,17 +1776,17 @@ Sparse<T>::index (idx_vector& idx_arg, i
 	    {
 	      // Count number of non-zero elements
 	      octave_idx_type new_nzmx = 0;
 	      octave_idx_type kk = 0;
 	      for (octave_idx_type j = 0; j < result_nc; j++)
 		{
 		  for (octave_idx_type i = 0; i < result_nr; i++)
 		    {
-		      OCTAVE_QUIT;
+		      octave_quit ();
 		      
 		      octave_idx_type ii = idx_arg.elem (kk++);
 		      if (ii < orig_len)
 			{
 			  octave_idx_type fr = ii % nr;
 			  octave_idx_type fc = (ii - fr) / nr;
 			  for (octave_idx_type k = cidx(fc); k < cidx(fc+1); k++)
 			    {
@@ -1803,17 +1803,17 @@ Sparse<T>::index (idx_vector& idx_arg, i
 
 	      kk = 0;
 	      octave_idx_type jj = 0;
 	      retval.xcidx(0) = 0;
 	      for (octave_idx_type j = 0; j < result_nc; j++)
 		{
 		  for (octave_idx_type i = 0; i < result_nr; i++)
 		    {
-		      OCTAVE_QUIT;
+		      octave_quit ();
 
 		      octave_idx_type ii = idx_arg.elem (kk++);
 		      if (ii < orig_len)
 			{
 			  octave_idx_type fr = ii % nr;
 			  octave_idx_type fc = (ii - fr) / nr;
 			  for (octave_idx_type k = cidx(fc); k < cidx(fc+1); k++)
 			    {
@@ -1931,17 +1931,17 @@ Sparse<T>::index (idx_vector& idx_i, idx
 
 		  octave_idx_type kk = 0;
 		  retval.xcidx(0) = 0;
 		  for (octave_idx_type j = 0; j < m; j++)
 		    {
 		      octave_idx_type jj = idx_j.elem (j);
 		      for (octave_idx_type i = cidx(jj); i < cidx(jj+1); i++)
 			{
-			  OCTAVE_QUIT;
+			  octave_quit ();
 
 			  octave_idx_type ii = itmp [ridx(i)];
 			  if (ii >= 0)
 			    {
 			      X [ii] = data (i);
 			      retval.xridx (kk++) = ii;
 			    }
 			}
@@ -1983,17 +1983,17 @@ Sparse<T>::index (idx_vector& idx_i, idx
 		    {
 		      octave_idx_type jj = idx_j.elem (j);
 
 		      if (jj < nc)
 			{
 			  for (octave_idx_type i = cidx(jj); 
 			       i < cidx(jj+1); i++)
 			    {
-			      OCTAVE_QUIT;
+			      octave_quit ();
 
 			      octave_idx_type ii = start_nodes [ridx(i)];
 
 			      if (ii >= 0)
 				{
 				  struct idx_node inode = nodes[ii];
 			      
 				  while (true)
@@ -2019,17 +2019,17 @@ Sparse<T>::index (idx_vector& idx_i, idx
 		  for (octave_idx_type j = 0; j < m; j++)
 		    {
 		      octave_idx_type jj = idx_j.elem (j);
 		      if (jj < nc)
 			{
 			  for (octave_idx_type i = cidx(jj); 
 			       i < cidx(jj+1); i++)
 			    {
-			      OCTAVE_QUIT;
+			      octave_quit ();
 
 			      octave_idx_type ii = start_nodes [ridx(i)];
 
 			      if (ii >= 0)
 				{
 				  struct idx_node inode = nodes[ii];
 			      
 				  while (true)
@@ -2484,17 +2484,17 @@ assign1 (Sparse<LT>& lhs, const Sparse<R
 
 	      for (octave_idx_type i = 0; i < n; i++)
 		{
 		  sidx[i] = &sidxX[i];
 		  sidx[i]->i = lhs_idx.elem(i);
 		  sidx[i]->idx = i;
 		}
 			  
-	      OCTAVE_QUIT;
+	      octave_quit ();
 	      octave_sort<octave_idx_vector_sort *> 
 		sort (octave_idx_vector_comp);
 
 	      sort.sort (sidx, n);
 
 	      intNDArray<octave_idx_type> new_idx (dim_vector (n,1));
 
 	      for (octave_idx_type i = 0; i < n; i++)
@@ -2507,17 +2507,17 @@ assign1 (Sparse<LT>& lhs, const Sparse<R
 	    }
 	  else
 	    for (octave_idx_type i = 0; i < n; i++)
 	      rhs_idx[i] = i;
 
 	  // First count the number of non-zero elements
 	  for (octave_idx_type i = 0; i < n; i++)
 	    {
-	      OCTAVE_QUIT;
+	      octave_quit ();
 
 	      octave_idx_type ii = lhs_idx.elem (i);
 	      if (i < n - 1 && lhs_idx.elem (i + 1) == ii)
 		continue;
 	      if (ii < lhs_len && c_lhs.elem(ii) != LT ())
 		new_nzmx--;
 	      if (rhs.elem(rhs_idx[i]) != RT ())
 		new_nzmx++;
@@ -2643,17 +2643,17 @@ assign1 (Sparse<LT>& lhs, const Sparse<R
 	  lhs_idx.sort (true);
 	  n = lhs_idx.length (n);
 
 	  // First count the number of non-zero elements
 	  if (scalar != RT ())
 	    new_nzmx += n;
 	  for (octave_idx_type i = 0; i < n; i++)
 	    {
-	      OCTAVE_QUIT;
+	      octave_quit ();
 
 	      octave_idx_type ii = lhs_idx.elem (i);
 	      if (ii < lhs_len && c_lhs.elem(ii) != LT ())
 		new_nzmx--;
 	    }
 
 	  if (nr > 1)
 	    {
@@ -2768,17 +2768,17 @@ assign1 (Sparse<LT>& lhs, const Sparse<R
 	  octave_idx_type new_nzmx = rhs.nnz ();
 	  Sparse<LT> tmp (1, rhs_len, new_nzmx);
 
 	  octave_idx_type ii = 0;
 	  octave_idx_type jj = 0;
 	  for (octave_idx_type i = 0; i < rhs.cols(); i++)
 	    for (octave_idx_type j = rhs.cidx(i); j < rhs.cidx(i+1); j++)
 	      {
-		OCTAVE_QUIT;
+		octave_quit ();
 		for (octave_idx_type k = jj; k <= i * rhs.rows() + rhs.ridx(j); k++)
 		  tmp.cidx(jj++) = ii;
 
 		tmp.data(ii) = rhs.data(j);
 		tmp.ridx(ii++) = 0;
 	      }
 
 	  for (octave_idx_type i = jj; i < rhs_len + 1; i++)
@@ -2884,17 +2884,17 @@ assign (Sparse<LT>& lhs, const Sparse<RT
                   octave_idx_type new_nzmx = lhs.nnz ();
                   for (octave_idx_type j = 0; j < m; j++)
                     {
                       octave_idx_type jj = idx_j.elem (j);
                       if (jj < lhs_nc)
                         {
                           for (octave_idx_type i = 0; i < n; i++)
                             {
-                              OCTAVE_QUIT;
+                              octave_quit ();
 
                               octave_idx_type ii = idx_i.elem (i);
 
                               if (ii < lhs_nr)
                                 {
                                   for (octave_idx_type k = c_lhs.cidx(jj); 
                                        k < c_lhs.cidx(jj+1); k++)
                                     {
@@ -3041,17 +3041,17 @@ assign (Sparse<LT>& lhs, const Sparse<RT
 
                       for (octave_idx_type i = 0; i < n; i++)
                         {
                           sidx[i] = &sidxX[i];
                           sidx[i]->i = idx_i.elem(i);
                           sidx[i]->idx = i;
                         }
 
-                      OCTAVE_QUIT;
+                      octave_quit ();
                       octave_sort<octave_idx_vector_sort *> 
                         sort (octave_idx_vector_comp);
 
                       sort.sort (sidx, n);
 
                       intNDArray<octave_idx_type> new_idx (dim_vector (n,1));
 
                       for (octave_idx_type i = 0; i < n; i++)
@@ -3080,17 +3080,17 @@ assign (Sparse<LT>& lhs, const Sparse<RT
 
                       for (octave_idx_type i = 0; i < m; i++)
                         {
                           sidx[i] = &sidxX[i];
                           sidx[i]->i = idx_j.elem(i);
                           sidx[i]->idx = i;
                         }
 
-                      OCTAVE_QUIT;
+                      octave_quit ();
                       octave_sort<octave_idx_vector_sort *> 
                         sort (octave_idx_vector_comp);
 
                       sort.sort (sidx, m);
 
                       intNDArray<octave_idx_type> new_idx (dim_vector (m,1));
 
                       for (octave_idx_type i = 0; i < m; i++)
@@ -3299,17 +3299,17 @@ assign (Sparse<LT>& lhs, const Sparse<RT
 
 		      for (octave_idx_type i = 0; i < len; i++)
 			{
 			  sidx[i] = &sidxX[i];
 			  sidx[i]->i = idx_i.elem(i);
 			  sidx[i]->idx = i;
 			}
 
-		      OCTAVE_QUIT;
+		      octave_quit ();
 		      octave_sort<octave_idx_vector_sort *> 
 			sort (octave_idx_vector_comp);
 
 		      sort.sort (sidx, len);
 
 		      intNDArray<octave_idx_type> new_idx (dim_vector (len,1));
 
 		      for (octave_idx_type i = 0; i < len; i++)
@@ -3322,17 +3322,17 @@ assign (Sparse<LT>& lhs, const Sparse<RT
 		    }
 		  else
 		    for (octave_idx_type i = 0; i < len; i++)
 		      rhs_idx[i] = i;
 
 		  // First count the number of non-zero elements
 		  for (octave_idx_type i = 0; i < len; i++)
 		    {
-		      OCTAVE_QUIT;
+		      octave_quit ();
 		      
 		      octave_idx_type ii = idx_i.elem (i);
 		      if (i < len - 1 && idx_i.elem (i + 1) == ii)
 			continue;
 		      if (ii < lhs_len && c_lhs.elem(ii) != LT ())
 			new_nzmx--;
 		      if (rhs.elem(rhs_idx[i]) != RT ())
 			new_nzmx++;
@@ -3421,17 +3421,17 @@ assign (Sparse<LT>& lhs, const Sparse<RT
 		  idx_i.sort (true);
 		  len = idx_i.length (len);
 
 		  // First count the number of non-zero elements
 		  if (scalar != RT ())
 		    new_nzmx += len;
 		  for (octave_idx_type i = 0; i < len; i++)
 		    {
-		      OCTAVE_QUIT;
+		      octave_quit ();
 		      octave_idx_type ii = idx_i.elem (i);
 		      if (ii < lhs_len && c_lhs.elem(ii) != LT ())
 			new_nzmx--;
 		    }
 
 		  Sparse<LT> stmp (lhs_nr, lhs_nc, new_nzmx);
 
 		  octave_idx_type i = 0;
diff --git a/liboctave/Sparse.h b/liboctave/Sparse.h
--- a/liboctave/Sparse.h
+++ b/liboctave/Sparse.h
@@ -526,17 +526,17 @@ public:
 	octave_idx_type nr = rows ();
 	octave_idx_type nc = cols ();
       
 	result = Sparse<U> (nr, nc, f_zero);
 
 	for (octave_idx_type j = 0; j < nc; j++)
 	  for (octave_idx_type i = cidx(j); i < cidx (j+1); i++)
 	    {
-	      OCTAVE_QUIT;
+	      octave_quit ();
 	      /* Use data instead of elem for better performance.  */
 	      result.data (ridx (i) + j * nr) = fcn (data(i));
 	    }
 
 	result.maybe_compress (true);
       }
     else
       {
@@ -553,17 +553,17 @@ public:
 	    for (octave_idx_type i = cidx(j); i < cidx (j+1); i++)
 	      {
 		U val = fcn (data (i));
 		if (val != 0.0)
 		  {
 		    result.data (ii) = val;
 		    result.ridx (ii++) = ridx (i);
 		  }
-		OCTAVE_QUIT;
+		octave_quit ();
 	      }
 	    result.cidx (j+1) = ii;
 	  }
 
 	result.maybe_compress (false);
       }
 
     return result;
diff --git a/liboctave/SparseCmplxQR.cc b/liboctave/SparseCmplxQR.cc
--- a/liboctave/SparseCmplxQR.cc
+++ b/liboctave/SparseCmplxQR.cc
@@ -200,30 +200,30 @@ SparseComplexQR::SparseComplexQR_rep::C 
     (*current_liboctave_error_handler) ("matrix dimension mismatch");
   else if (nr == 0 || nc == 0 || b_nc == 0)
     ret = ComplexMatrix (nc, b_nc, Complex (0.0, 0.0));
   else
     {
       OCTAVE_LOCAL_BUFFER (Complex, buf, S->m2);
       for (volatile octave_idx_type j = 0, idx = 0; j < b_nc; j++, idx+=b_nr)
 	{
-	  OCTAVE_QUIT;
+	  octave_quit ();
 	  volatile octave_idx_type nm = (nr < nc ? nr : nc);
 	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
 	  CXSPARSE_ZNAME (_ipvec) 
 	    (S->pinv, bvec + idx, reinterpret_cast<cs_complex_t *>(buf), b_nr);
 #else
 	  CXSPARSE_ZNAME (_ipvec) 
 	    (b_nr, S->Pinv, bvec + idx, reinterpret_cast<cs_complex_t *>(buf));
 #endif
 	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	  for (volatile octave_idx_type i = 0; i < nm; i++)
 	    {
-	      OCTAVE_QUIT;
+	      octave_quit ();
 	      BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	      CXSPARSE_ZNAME (_happly) 
 		(N->L, i, N->B[i], reinterpret_cast<cs_complex_t *>(buf));
 	      END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	    }
 	  for (octave_idx_type i = 0; i < b_nr; i++)
 	    vec[i+idx] = buf[i];
 	}
@@ -249,31 +249,31 @@ SparseComplexQR::SparseComplexQR_rep::Q 
   else
     {
       OCTAVE_C99_COMPLEX (bvec, nr);
       for (octave_idx_type i = 0; i < nr; i++)
 	bvec[i] = OCTAVE_C99_ZERO;
       OCTAVE_LOCAL_BUFFER (Complex, buf, S->m2);
       for (volatile octave_idx_type j = 0, idx = 0; j < nr; j++, idx+=nr)
 	{
-	  OCTAVE_QUIT;
+	  octave_quit ();
 	  bvec[j] = OCTAVE_C99_ONE;
 	  volatile octave_idx_type nm = (nr < nc ? nr : nc);
 	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
 	  CXSPARSE_ZNAME (_ipvec) 
 	    (S->pinv, bvec, reinterpret_cast<cs_complex_t *>(buf), nr);
 #else
 	  CXSPARSE_ZNAME (_ipvec) 
 	    (nr, S->Pinv, bvec, reinterpret_cast<cs_complex_t *>(buf));
 #endif
 	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	  for (volatile octave_idx_type i = 0; i < nm; i++)
 	    {
-	      OCTAVE_QUIT;
+	      octave_quit ();
 	      BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	      CXSPARSE_ZNAME (_happly) 
 		(N->L, i, N->B[i], reinterpret_cast<cs_complex_t *>(buf));
 	      END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	    }
 	  for (octave_idx_type i = 0; i < nr; i++)
 	    vec[i+idx] = buf[i];
 	  bvec[j] = OCTAVE_C99_ZERO;
@@ -308,33 +308,33 @@ qrsolve(const SparseComplexMatrix&a, con
 	return ComplexMatrix();
       x.resize(nc, b_nc);
       cs_complex_t *vec = reinterpret_cast<cs_complex_t *>
 	(x.fortran_vec());
       OCTAVE_C99_COMPLEX (buf, q.S()->m2);
       OCTAVE_LOCAL_BUFFER (Complex, Xx, b_nr);
       for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
 	{
-	  OCTAVE_QUIT;
+	  octave_quit ();
 	  for (octave_idx_type j = 0; j < b_nr; j++)
 	    Xx[j] = b.xelem(j,i);
 	  for (octave_idx_type j = nr; j < q.S()->m2; j++)
 	    buf[j] = OCTAVE_C99_ZERO;
 	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
 	  CXSPARSE_ZNAME (_ipvec) 
 	    (q.S()->pinv, reinterpret_cast<cs_complex_t *>(Xx), buf, nr);
 #else
 	  CXSPARSE_ZNAME (_ipvec) 
 	    (nr, q.S()->Pinv, reinterpret_cast<cs_complex_t *>(Xx), buf);
 #endif
 	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	  for (volatile octave_idx_type j = 0; j < nc; j++)
 	    {
-	      OCTAVE_QUIT;
+	      octave_quit ();
 	      BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	      CXSPARSE_ZNAME (_happly) (q.N()->L, j, q.N()->B[j], buf);
 	      END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	    }
 	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	  CXSPARSE_ZNAME (_usolve) (q.N()->U, buf);
 #if defined(CS_VER) && (CS_VER >= 2)
 	  CXSPARSE_ZNAME (_ipvec) (q.S()->q, buf, vec + idx, nc);
@@ -363,34 +363,34 @@ qrsolve(const SparseComplexMatrix&a, con
 	B[i] = q.N()->B [i];
 #else
       OCTAVE_LOCAL_BUFFER (Complex, B, nr);
       for (octave_idx_type i = 0; i < nr; i++)
 	B[i] = conj (reinterpret_cast<Complex *>(q.N()->B) [i]);
 #endif
       for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
 	{
-	  OCTAVE_QUIT;
+	  octave_quit ();
 	  for (octave_idx_type j = 0; j < b_nr; j++)
 	    Xx[j] = b.xelem(j,i);
 	  for (octave_idx_type j = nr; j < nbuf; j++)
 	    buf[j] = OCTAVE_C99_ZERO;
 	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
 	  CXSPARSE_ZNAME (_pvec)
 	    (q.S()->q, reinterpret_cast<cs_complex_t *>(Xx), buf, nr);
 #else
 	  CXSPARSE_ZNAME (_pvec)
 	    (nr, q.S()->Q, reinterpret_cast<cs_complex_t *>(Xx), buf);
 #endif
 	  CXSPARSE_ZNAME (_utsolve) (q.N()->U, buf);
 	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	  for (volatile octave_idx_type j = nr-1; j >= 0; j--)
 	    {
-	      OCTAVE_QUIT;
+	      octave_quit ();
 	      BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
 #if defined(CS_VER) && (((CS_VER == 2) && (CS_SUBVER >= 2)) || (CS_VER > 2))
 	      CXSPARSE_ZNAME (_happly) (q.N()->L, j, B[j], buf);
 #else
 	      CXSPARSE_ZNAME (_happly) 
 		(q.N()->L, j, reinterpret_cast<cs_complex_t *>(B)[j], buf);
 #endif
@@ -438,33 +438,33 @@ qrsolve(const SparseComplexMatrix&a, con
       x = SparseComplexMatrix (nc, b_nc, b.nzmax());
       x.xcidx(0) = 0;
       x_nz = b.nzmax();
       ii = 0;
       OCTAVE_LOCAL_BUFFER (Complex, Xx, (b_nr > nc ? b_nr : nc));
       OCTAVE_C99_COMPLEX (buf, q.S()->m2);
       for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
 	{
-	  OCTAVE_QUIT;
+	  octave_quit ();
 	  for (octave_idx_type j = 0; j < b_nr; j++)
 	    Xx[j] = b.xelem(j,i);
 	  for (octave_idx_type j = nr; j < q.S()->m2; j++)
 	    buf[j] = OCTAVE_C99_ZERO;
 	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
 	  CXSPARSE_ZNAME (_ipvec) 
 	    (q.S()->pinv, reinterpret_cast<cs_complex_t *>(Xx), buf, nr);
 #else
 	  CXSPARSE_ZNAME (_ipvec) 
 	    (nr, q.S()->Pinv, reinterpret_cast<cs_complex_t *>(Xx), buf);
 #endif
 	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	  for (volatile octave_idx_type j = 0; j < nc; j++)
 	    {
-	      OCTAVE_QUIT;
+	      octave_quit ();
 	      BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	      CXSPARSE_ZNAME (_happly) (q.N()->L, j, q.N()->B[j], buf);
 	      END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	    }
 	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	  CXSPARSE_ZNAME (_usolve) (q.N()->U, buf);
 #if defined(CS_VER) && (CS_VER >= 2)
 	  CXSPARSE_ZNAME (_ipvec) 
@@ -516,34 +516,34 @@ qrsolve(const SparseComplexMatrix&a, con
 	B[i] = q.N()->B [i];
 #else
       OCTAVE_LOCAL_BUFFER (Complex, B, nr);
       for (octave_idx_type i = 0; i < nr; i++)
 	B[i] = conj (reinterpret_cast<Complex *>(q.N()->B) [i]);
 #endif
       for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
 	{
-	  OCTAVE_QUIT;
+	  octave_quit ();
 	  for (octave_idx_type j = 0; j < b_nr; j++)
 	    Xx[j] = b.xelem(j,i);
 	  for (octave_idx_type j = nr; j < nbuf; j++)
 	    buf[j] = OCTAVE_C99_ZERO;
 	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
 	  CXSPARSE_ZNAME (_pvec)
 	    (q.S()->q, reinterpret_cast<cs_complex_t *>(Xx), buf, nr);
 #else
 	  CXSPARSE_ZNAME (_pvec)
 	    (nr, q.S()->Q, reinterpret_cast<cs_complex_t *>(Xx), buf);
 #endif
 	  CXSPARSE_ZNAME (_utsolve) (q.N()->U, buf);
 	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	  for (volatile octave_idx_type j = nr-1; j >= 0; j--)
 	    {
-	      OCTAVE_QUIT;
+	      octave_quit ();
 	      BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (((CS_VER == 2) && (CS_SUBVER >= 2)) || (CS_VER > 2))
 	      CXSPARSE_ZNAME (_happly) (q.N()->L, j, B[j], buf);
 #else
 	      CXSPARSE_ZNAME (_happly) 
 		(q.N()->L, j, reinterpret_cast<cs_complex_t *>(B)[j], buf);
 #endif
 	      END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
@@ -612,29 +612,29 @@ qrsolve(const SparseComplexMatrix&a, con
 	return ComplexMatrix();
       x.resize(nc, b_nc);
       cs_complex_t *vec = reinterpret_cast<cs_complex_t *>
 	(x.fortran_vec());
       OCTAVE_C99_COMPLEX (buf, q.S()->m2);
       for (volatile octave_idx_type i = 0, idx = 0, bidx = 0; i < b_nc; 
 	   i++, idx+=nc, bidx+=b_nr)
 	{
-	  OCTAVE_QUIT;
+	  octave_quit ();
 	  for (octave_idx_type j = nr; j < q.S()->m2; j++)
 	    buf[j] = OCTAVE_C99_ZERO;
 	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
 	  CXSPARSE_ZNAME (_ipvec) (q.S()->pinv, bvec + bidx, buf, nr);
 #else
 	  CXSPARSE_ZNAME (_ipvec) (nr, q.S()->Pinv, bvec + bidx, buf);
 #endif
 	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	  for (volatile octave_idx_type j = 0; j < nc; j++)
 	    {
-	      OCTAVE_QUIT;
+	      octave_quit ();
 	      BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	      CXSPARSE_ZNAME (_happly) (q.N()->L, j, q.N()->B[j], buf);
 	      END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	    }
 	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	  CXSPARSE_ZNAME (_usolve) (q.N()->U, buf);
 #if defined(CS_VER) && (CS_VER >= 2)
 	  CXSPARSE_ZNAME (_ipvec) (q.S()->q, buf, vec + idx, nc);
@@ -663,30 +663,30 @@ qrsolve(const SparseComplexMatrix&a, con
 #else
       OCTAVE_LOCAL_BUFFER (Complex, B, nr);
       for (octave_idx_type i = 0; i < nr; i++)
 	B[i] = conj (reinterpret_cast<Complex *>(q.N()->B) [i]);
 #endif
       for (volatile octave_idx_type i = 0, idx = 0, bidx = 0; i < b_nc; 
 	   i++, idx+=nc, bidx+=b_nr)
 	{
-	  OCTAVE_QUIT;
+	  octave_quit ();
 	  for (octave_idx_type j = nr; j < nbuf; j++)
 	    buf[j] = OCTAVE_C99_ZERO;
 	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
 	  CXSPARSE_ZNAME (_pvec) (q.S()->q, bvec + bidx, buf, nr);
 #else
 	  CXSPARSE_ZNAME (_pvec) (nr, q.S()->Q, bvec + bidx, buf);
 #endif
 	  CXSPARSE_ZNAME (_utsolve) (q.N()->U, buf);
 	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	  for (volatile octave_idx_type j = nr-1; j >= 0; j--)
 	    {
-	      OCTAVE_QUIT;
+	      octave_quit ();
 	      BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (((CS_VER == 2) && (CS_SUBVER >= 2)) || (CS_VER > 2))
 	      CXSPARSE_ZNAME (_happly) (q.N()->L, j, B[j], buf);
 #else
 	      CXSPARSE_ZNAME (_happly) 
 		(q.N()->L, j, reinterpret_cast<cs_complex_t *>(B)[j], buf);
 #endif
 	      END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
@@ -733,33 +733,33 @@ qrsolve(const SparseComplexMatrix&a, con
       x = SparseComplexMatrix (nc, b_nc, b.nzmax());
       x.xcidx(0) = 0;
       x_nz = b.nzmax();
       ii = 0;
       OCTAVE_LOCAL_BUFFER (Complex, Xx, (b_nr > nc ? b_nr : nc));
       OCTAVE_C99_COMPLEX (buf, q.S()->m2);
       for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
 	{
-	  OCTAVE_QUIT;
+	  octave_quit ();
 	  for (octave_idx_type j = 0; j < b_nr; j++)
 	    Xx[j] = b.xelem(j,i);
 	  for (octave_idx_type j = nr; j < q.S()->m2; j++)
 	    buf[j] = OCTAVE_C99_ZERO;
 	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
 	  CXSPARSE_ZNAME (_ipvec) 
 	    (q.S()->pinv, reinterpret_cast<cs_complex_t *>(Xx), buf, nr);
 #else
 	  CXSPARSE_ZNAME (_ipvec) 
 	    (nr, q.S()->Pinv, reinterpret_cast<cs_complex_t *>(Xx), buf);
 #endif
 	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	  for (volatile octave_idx_type j = 0; j < nc; j++)
 	    {
-	      OCTAVE_QUIT;
+	      octave_quit ();
 	      BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	      CXSPARSE_ZNAME (_happly) (q.N()->L, j, q.N()->B[j], buf);
 	      END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	    }
 	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	  CXSPARSE_ZNAME (_usolve) (q.N()->U, buf);
 #if defined(CS_VER) && (CS_VER >= 2)
 	  CXSPARSE_ZNAME (_ipvec) 
@@ -810,34 +810,34 @@ qrsolve(const SparseComplexMatrix&a, con
 	B[i] = q.N()->B [i];
 #else
       OCTAVE_LOCAL_BUFFER (Complex, B, nr);
       for (octave_idx_type i = 0; i < nr; i++)
 	B[i] = conj (reinterpret_cast<Complex *>(q.N()->B) [i]);
 #endif
       for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
 	{
-	  OCTAVE_QUIT;
+	  octave_quit ();
 	  for (octave_idx_type j = 0; j < b_nr; j++)
 	    Xx[j] = b.xelem(j,i);
 	  for (octave_idx_type j = nr; j < nbuf; j++)
 	    buf[j] = OCTAVE_C99_ZERO;
 	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
 	  CXSPARSE_ZNAME (_pvec)
 	    (q.S()->q, reinterpret_cast<cs_complex_t *>(Xx), buf, nr);
 #else
 	  CXSPARSE_ZNAME (_pvec)
 	    (nr, q.S()->Q, reinterpret_cast<cs_complex_t *>(Xx), buf);
 #endif
 	  CXSPARSE_ZNAME (_utsolve) (q.N()->U, buf);
 	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	  for (volatile octave_idx_type j = nr-1; j >= 0; j--)
 	    {
-	      OCTAVE_QUIT;
+	      octave_quit ();
 	      BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (((CS_VER == 2) && (CS_SUBVER >= 2)) || (CS_VER > 2))
 	      CXSPARSE_ZNAME (_happly) (q.N()->L, j, B[j], buf);
 #else
 	      CXSPARSE_ZNAME (_happly) 
 		(q.N()->L, j, reinterpret_cast<cs_complex_t *>(B)[j], buf);
 #endif
 	      END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
diff --git a/liboctave/SparseQR.cc b/liboctave/SparseQR.cc
--- a/liboctave/SparseQR.cc
+++ b/liboctave/SparseQR.cc
@@ -181,31 +181,31 @@ SparseQR::SparseQR_rep::C (const Matrix 
     (*current_liboctave_error_handler) ("matrix dimension mismatch");
   else if (nr == 0 || nc == 0 || b_nc == 0)
     ret = Matrix (nc, b_nc, 0.0);
   else
     {
       OCTAVE_LOCAL_BUFFER (double, buf, S->m2);
       for (volatile octave_idx_type j = 0, idx = 0; j < b_nc; j++, idx+=b_nr)
 	{
-	  OCTAVE_QUIT;
+	  octave_quit ();
 	  for (octave_idx_type i = nr; i < S->m2; i++)
 	    buf[i] = 0.;
 	  volatile octave_idx_type nm = (nr < nc ? nr : nc);
 	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
 	  CXSPARSE_DNAME (_ipvec) (S->pinv, bvec + idx, buf, b_nr);
 #else
 	  CXSPARSE_DNAME (_ipvec) (b_nr, S->Pinv, bvec + idx, buf);
 #endif
 	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
 	  for (volatile octave_idx_type i = 0; i < nm; i++)
 	    {
-	      OCTAVE_QUIT;
+	      octave_quit ();
 	      BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	      CXSPARSE_DNAME (_happly) (N->L, i, N->B[i], buf);
 	      END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	    }
 	  for (octave_idx_type i = 0; i < b_nr; i++)
 	    vec[i+idx] = buf[i];
 	}
     }
@@ -230,32 +230,32 @@ SparseQR::SparseQR_rep::Q (void) const
   else
     {
       OCTAVE_LOCAL_BUFFER (double, bvec, nr + 1);
       for (octave_idx_type i = 0; i < nr; i++)
 	bvec[i] = 0.;
       OCTAVE_LOCAL_BUFFER (double, buf, S->m2);
       for (volatile octave_idx_type j = 0, idx = 0; j < nr; j++, idx+=nr)
 	{
-	  OCTAVE_QUIT;
+	  octave_quit ();
 	  bvec[j] = 1.0;
 	  for (octave_idx_type i = nr; i < S->m2; i++)
 	    buf[i] = 0.;
 	  volatile octave_idx_type nm = (nr < nc ? nr : nc);
 	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
 	  CXSPARSE_DNAME (_ipvec) (S->pinv, bvec, buf, nr);
 #else
 	  CXSPARSE_DNAME (_ipvec) (nr, S->Pinv, bvec, buf);
 #endif
 	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
 	  for (volatile octave_idx_type i = 0; i < nm; i++)
 	    {
-	      OCTAVE_QUIT;
+	      octave_quit ();
 	      BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	      CXSPARSE_DNAME (_happly) (N->L, i, N->B[i], buf);
 	      END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	    }
 	  for (octave_idx_type i = 0; i < nr; i++)
 	    vec[i+idx] = buf[i];
 	  bvec[j] = 0.0;
 	}
@@ -289,29 +289,29 @@ qrsolve(const SparseMatrix&a, const Matr
       if (! q.ok ()) 
 	return Matrix();
       x.resize(nc, b_nc);
       double *vec = x.fortran_vec();
       OCTAVE_LOCAL_BUFFER (double, buf, q.S()->m2);
       for (volatile octave_idx_type i = 0, idx = 0, bidx = 0; i < b_nc; 
 	   i++, idx+=nc, bidx+=b_nr)
 	{
-	  OCTAVE_QUIT;
+	  octave_quit ();
 	  for (octave_idx_type j = nr; j < q.S()->m2; j++)
 	    buf[j] = 0.;
 	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
 	  CXSPARSE_DNAME (_ipvec) (q.S()->pinv, bvec + bidx, buf, nr);
 #else
 	  CXSPARSE_DNAME (_ipvec) (nr, q.S()->Pinv, bvec + bidx, buf);
 #endif
 	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	  for (volatile octave_idx_type j = 0; j < nc; j++)
 	    {
-	      OCTAVE_QUIT;
+	      octave_quit ();
 	      BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	      CXSPARSE_DNAME (_happly) (q.N()->L, j, q.N()->B[j], buf);
 	      END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	    }
 	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	  CXSPARSE_DNAME (_usolve) (q.N()->U, buf);
 #if defined(CS_VER) && (CS_VER >= 2)
 	  CXSPARSE_DNAME (_ipvec) (q.S()->q, buf, vec + idx, nc);
@@ -330,30 +330,30 @@ qrsolve(const SparseMatrix&a, const Matr
 	return Matrix();
       x.resize(nc, b_nc);
       double *vec = x.fortran_vec();
       volatile octave_idx_type nbuf = (nc > q.S()->m2 ? nc : q.S()->m2);
       OCTAVE_LOCAL_BUFFER (double, buf, nbuf);
       for (volatile octave_idx_type i = 0, idx = 0, bidx = 0; i < b_nc; 
 	   i++, idx+=nc, bidx+=b_nr)
 	{
-	  OCTAVE_QUIT;
+	  octave_quit ();
 	  for (octave_idx_type j = nr; j < nbuf; j++)
 	    buf[j] = 0.;
 	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
 	  CXSPARSE_DNAME (_pvec) (q.S()->q, bvec + bidx, buf, nr);
 #else
 	  CXSPARSE_DNAME (_pvec) (nr, q.S()->Q, bvec + bidx, buf);
 #endif
 	  CXSPARSE_DNAME (_utsolve) (q.N()->U, buf);
 	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	  for (volatile octave_idx_type j = nr-1; j >= 0; j--)
 	    {
-	      OCTAVE_QUIT;
+	      octave_quit ();
 	      BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	      CXSPARSE_DNAME (_happly) (q.N()->L, j, q.N()->B[j], buf);
 	      END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	    }
 	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
 	  CXSPARSE_DNAME (_pvec) (q.S()->pinv, buf, vec + idx, nc);
 #else
@@ -395,31 +395,31 @@ qrsolve(const SparseMatrix&a, const Spar
       x = SparseMatrix (nc, b_nc, b.nzmax());
       x.xcidx(0) = 0;
       x_nz = b.nzmax();
       ii = 0;
       OCTAVE_LOCAL_BUFFER (double, Xx, (b_nr > nc ? b_nr : nc));
       OCTAVE_LOCAL_BUFFER (double, buf, q.S()->m2);
       for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
 	{
-	  OCTAVE_QUIT;
+	  octave_quit ();
 	  for (octave_idx_type j = 0; j < b_nr; j++)
 	    Xx[j] = b.xelem(j,i);
 	  for (octave_idx_type j = nr; j < q.S()->m2; j++)
 	    buf[j] = 0.;
 	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
 	  CXSPARSE_DNAME (_ipvec) (q.S()->pinv, Xx, buf, nr);
 #else
 	  CXSPARSE_DNAME (_ipvec) (nr, q.S()->Pinv, Xx, buf);
 #endif
 	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	  for (volatile octave_idx_type j = 0; j < nc; j++)
 	    {
-	      OCTAVE_QUIT;
+	      octave_quit ();
 	      BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	      CXSPARSE_DNAME (_happly) (q.N()->L, j, q.N()->B[j], buf);
 	      END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	    }
 	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	  CXSPARSE_DNAME (_usolve) (q.N()->U, buf);
 #if defined(CS_VER) && (CS_VER >= 2)
 	  CXSPARSE_DNAME (_ipvec) (q.S()->q, buf, Xx, nc);
@@ -459,32 +459,32 @@ qrsolve(const SparseMatrix&a, const Spar
       x.xcidx(0) = 0;
       x_nz = b.nzmax();
       ii = 0;
       volatile octave_idx_type nbuf = (nc > q.S()->m2 ? nc : q.S()->m2);
       OCTAVE_LOCAL_BUFFER (double, Xx, (b_nr > nc ? b_nr : nc));
       OCTAVE_LOCAL_BUFFER (double, buf, nbuf);
       for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
 	{
-	  OCTAVE_QUIT;
+	  octave_quit ();
 	  for (octave_idx_type j = 0; j < b_nr; j++)
 	    Xx[j] = b.xelem(j,i);
 	  for (octave_idx_type j = nr; j < nbuf; j++)
 	    buf[j] = 0.;
 	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
 	  CXSPARSE_DNAME (_pvec) (q.S()->q, Xx, buf, nr);
 #else
 	  CXSPARSE_DNAME (_pvec) (nr, q.S()->Q, Xx, buf);
 #endif
 	  CXSPARSE_DNAME (_utsolve) (q.N()->U, buf);
 	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	  for (volatile octave_idx_type j = nr-1; j >= 0; j--)
 	    {
-	      OCTAVE_QUIT;
+	      octave_quit ();
 	      BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	      CXSPARSE_DNAME (_happly) (q.N()->L, j, q.N()->B[j], buf);
 	      END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	    }
 	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
 	  CXSPARSE_DNAME (_pvec) (q.S()->pinv, buf, Xx, nc);
 #else
@@ -544,17 +544,17 @@ qrsolve(const SparseMatrix&a, const Comp
 	return ComplexMatrix();
       x.resize(nc, b_nc);
       Complex *vec = x.fortran_vec();
       OCTAVE_LOCAL_BUFFER (double, Xx, (b_nr > nc ? b_nr : nc));
       OCTAVE_LOCAL_BUFFER (double, Xz, (b_nr > nc ? b_nr : nc));
       OCTAVE_LOCAL_BUFFER (double, buf, q.S()->m2);
       for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
 	{
-	  OCTAVE_QUIT;
+	  octave_quit ();
 	  for (octave_idx_type j = 0; j < b_nr; j++)
 	    {
 	      Complex c = b.xelem (j,i);
 	      Xx[j] = std::real (c);
 	      Xz[j] = std::imag (c);
 	    }
 	  for (octave_idx_type j = nr; j < q.S()->m2; j++)
 	    buf[j] = 0.;
@@ -562,17 +562,17 @@ qrsolve(const SparseMatrix&a, const Comp
 #if defined(CS_VER) && (CS_VER >= 2)
 	  CXSPARSE_DNAME (_ipvec) (q.S()->pinv, Xx, buf, nr);
 #else
 	  CXSPARSE_DNAME (_ipvec) (nr, q.S()->Pinv, Xx, buf);
 #endif
 	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	  for (volatile octave_idx_type j = 0; j < nc; j++)
 	    {
-	      OCTAVE_QUIT;
+	      octave_quit ();
 	      BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	      CXSPARSE_DNAME (_happly) (q.N()->L, j, q.N()->B[j], buf);
 	      END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	    }
 	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	  CXSPARSE_DNAME (_usolve) (q.N()->U, buf);
 #if defined(CS_VER) && (CS_VER >= 2)
 	  CXSPARSE_DNAME (_ipvec) (q.S()->q, buf, Xx, nc);
@@ -584,17 +584,17 @@ qrsolve(const SparseMatrix&a, const Comp
 #if defined(CS_VER) && (CS_VER >= 2)
 	  CXSPARSE_DNAME (_ipvec) (q.S()->pinv, Xz, buf, nr);
 #else
 	  CXSPARSE_DNAME (_ipvec) (nr, q.S()->Pinv, Xz, buf);
 #endif
 	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	  for (volatile octave_idx_type j = 0; j < nc; j++)
 	    {
-	      OCTAVE_QUIT;
+	      octave_quit ();
 	      BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	      CXSPARSE_DNAME (_happly) (q.N()->L, j, q.N()->B[j], buf);
 	      END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	    }
 	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	  CXSPARSE_DNAME (_usolve) (q.N()->U, buf);
 #if defined(CS_VER) && (CS_VER >= 2)
 	  CXSPARSE_DNAME (_ipvec) (q.S()->q, buf, Xz, nc);
@@ -616,17 +616,17 @@ qrsolve(const SparseMatrix&a, const Comp
       x.resize(nc, b_nc);
       Complex *vec = x.fortran_vec();
       volatile octave_idx_type nbuf = (nc > q.S()->m2 ? nc : q.S()->m2);
       OCTAVE_LOCAL_BUFFER (double, Xx, (b_nr > nc ? b_nr : nc));
       OCTAVE_LOCAL_BUFFER (double, Xz, (b_nr > nc ? b_nr : nc));
       OCTAVE_LOCAL_BUFFER (double, buf, nbuf);
       for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
 	{
-	  OCTAVE_QUIT;
+	  octave_quit ();
 	  for (octave_idx_type j = 0; j < b_nr; j++)
 	    {
 	      Complex c = b.xelem (j,i);
 	      Xx[j] = std::real (c);
 	      Xz[j] = std::imag (c);
 	    }
 	  for (octave_idx_type j = nr; j < nbuf; j++)
 	    buf[j] = 0.;
@@ -635,17 +635,17 @@ qrsolve(const SparseMatrix&a, const Comp
 	  CXSPARSE_DNAME (_pvec) (q.S()->q, Xx, buf, nr);
 #else
 	  CXSPARSE_DNAME (_pvec) (nr, q.S()->Q, Xx, buf);
 #endif
 	  CXSPARSE_DNAME (_utsolve) (q.N()->U, buf);
 	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	  for (volatile octave_idx_type j = nr-1; j >= 0; j--)
 	    {
-	      OCTAVE_QUIT;
+	      octave_quit ();
 	      BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	      CXSPARSE_DNAME (_happly) (q.N()->L, j, q.N()->B[j], buf);
 	      END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	    }
 	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
 	  CXSPARSE_DNAME (_pvec) (q.S()->pinv, buf, Xx, nc);
 #else
@@ -659,17 +659,17 @@ qrsolve(const SparseMatrix&a, const Comp
 	  CXSPARSE_DNAME (_pvec) (q.S()->q, Xz, buf, nr);
 #else
 	  CXSPARSE_DNAME (_pvec) (nr, q.S()->Q, Xz, buf);
 #endif
 	  CXSPARSE_DNAME (_utsolve) (q.N()->U, buf);
 	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	  for (volatile octave_idx_type j = nr-1; j >= 0; j--)
 	    {
-	      OCTAVE_QUIT;
+	      octave_quit ();
 	      BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	      CXSPARSE_DNAME (_happly) (q.N()->L, j, q.N()->B[j], buf);
 	      END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	    }
 	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
 	  CXSPARSE_DNAME (_pvec) (q.S()->pinv, buf, Xz, nc);
 #else
@@ -714,17 +714,17 @@ qrsolve(const SparseMatrix&a, const Spar
       x.xcidx(0) = 0;
       x_nz = b.nzmax();
       ii = 0;
       OCTAVE_LOCAL_BUFFER (double, Xx, (b_nr > nc ? b_nr : nc));
       OCTAVE_LOCAL_BUFFER (double, Xz, (b_nr > nc ? b_nr : nc));
       OCTAVE_LOCAL_BUFFER (double, buf, q.S()->m2);
       for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
 	{
-	  OCTAVE_QUIT;
+	  octave_quit ();
 	  for (octave_idx_type j = 0; j < b_nr; j++)
 	    {
 	      Complex c = b.xelem (j,i);
 	      Xx[j] = std::real (c);
 	      Xz[j] = std::imag (c);
 	    }
 	  for (octave_idx_type j = nr; j < q.S()->m2; j++)
 	    buf[j] = 0.;
@@ -732,17 +732,17 @@ qrsolve(const SparseMatrix&a, const Spar
 #if defined(CS_VER) && (CS_VER >= 2)
 	  CXSPARSE_DNAME (_ipvec) (q.S()->pinv, Xx, buf, nr);
 #else
 	  CXSPARSE_DNAME (_ipvec) (nr, q.S()->Pinv, Xx, buf);
 #endif
 	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	  for (volatile octave_idx_type j = 0; j < nc; j++)
 	    {
-	      OCTAVE_QUIT;
+	      octave_quit ();
 	      BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	      CXSPARSE_DNAME (_happly) (q.N()->L, j, q.N()->B[j], buf);
 	      END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	    }
 	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	  CXSPARSE_DNAME (_usolve) (q.N()->U, buf);
 #if defined(CS_VER) && (CS_VER >= 2)
 	  CXSPARSE_DNAME (_ipvec) (q.S()->q, buf, Xx, nc);
@@ -756,17 +756,17 @@ qrsolve(const SparseMatrix&a, const Spar
 #if defined(CS_VER) && (CS_VER >= 2)
 	  CXSPARSE_DNAME (_ipvec) (q.S()->pinv, Xz, buf, nr);
 #else
 	  CXSPARSE_DNAME (_ipvec) (nr, q.S()->Pinv, Xz, buf);
 #endif
 	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	  for (volatile octave_idx_type j = 0; j < nc; j++)
 	    {
-	      OCTAVE_QUIT;
+	      octave_quit ();
 	      BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	      CXSPARSE_DNAME (_happly) (q.N()->L, j, q.N()->B[j], buf);
 	      END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	    }
 	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	  CXSPARSE_DNAME (_usolve) (q.N()->U, buf);
 #if defined(CS_VER) && (CS_VER >= 2)
 	  CXSPARSE_DNAME (_ipvec) (q.S()->q, buf, Xz, nc);
@@ -807,17 +807,17 @@ qrsolve(const SparseMatrix&a, const Spar
       x_nz = b.nzmax();
       ii = 0;
       volatile octave_idx_type nbuf = (nc > q.S()->m2 ? nc : q.S()->m2);
       OCTAVE_LOCAL_BUFFER (double, Xx, (b_nr > nc ? b_nr : nc));
       OCTAVE_LOCAL_BUFFER (double, Xz, (b_nr > nc ? b_nr : nc));
       OCTAVE_LOCAL_BUFFER (double, buf, nbuf);
       for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
 	{
-	  OCTAVE_QUIT;
+	  octave_quit ();
 	  for (octave_idx_type j = 0; j < b_nr; j++)
 	    {
 	      Complex c = b.xelem (j,i);
 	      Xx[j] = std::real (c);
 	      Xz[j] = std::imag (c);
 	    }
 	  for (octave_idx_type j = nr; j < nbuf; j++)
 	    buf[j] = 0.;
@@ -826,17 +826,17 @@ qrsolve(const SparseMatrix&a, const Spar
 	  CXSPARSE_DNAME (_pvec) (q.S()->q, Xx, buf, nr);
 #else
 	  CXSPARSE_DNAME (_pvec) (nr, q.S()->Q, Xx, buf);
 #endif
 	  CXSPARSE_DNAME (_utsolve) (q.N()->U, buf);
 	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	  for (volatile octave_idx_type j = nr-1; j >= 0; j--)
 	    {
-	      OCTAVE_QUIT;
+	      octave_quit ();
 	      BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	      CXSPARSE_DNAME (_happly) (q.N()->L, j, q.N()->B[j], buf);
 	      END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	    }
 	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
 	  CXSPARSE_DNAME (_pvec) (q.S()->pinv, buf, Xx, nc);
 #else
@@ -850,17 +850,17 @@ qrsolve(const SparseMatrix&a, const Spar
 	  CXSPARSE_DNAME (_pvec) (q.S()->q, Xz, buf, nr);
 #else
 	  CXSPARSE_DNAME (_pvec) (nr, q.S()->Q, Xz, buf);
 #endif
 	  CXSPARSE_DNAME (_utsolve) (q.N()->U, buf);
 	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	  for (volatile octave_idx_type j = nr-1; j >= 0; j--)
 	    {
-	      OCTAVE_QUIT;
+	      octave_quit ();
 	      BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	      CXSPARSE_DNAME (_happly) (q.N()->L, j, q.N()->B[j], buf);
 	      END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	    }
 	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
 	  CXSPARSE_DNAME (_pvec) (q.S()->pinv, buf, Xz, nc);
 #else
diff --git a/liboctave/boolSparse.cc b/liboctave/boolSparse.cc
--- a/liboctave/boolSparse.cc
+++ b/liboctave/boolSparse.cc
@@ -164,17 +164,17 @@ std::ostream&
 operator << (std::ostream& os, const SparseBoolMatrix& a)
 {
   octave_idx_type nc = a.cols ();
 
    // add one to the printed indices to go from
    //  zero-based to one-based arrays
    for (octave_idx_type j = 0; j < nc; j++)  
      {
-       OCTAVE_QUIT;
+       octave_quit ();
        for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
 	 os << a.ridx(i) + 1 << " "  << j + 1 << " " << a.data(i) << "\n";
      }
    
   return os;
 }
 
 std::istream&
diff --git a/liboctave/bsxfun-defs.cc b/liboctave/bsxfun-defs.cc
--- a/liboctave/bsxfun-defs.cc
+++ b/liboctave/bsxfun-defs.cc
@@ -112,17 +112,17 @@ do_bsxfun_op (const XNDA& x, const YNDA&
             cdvy(i-1) = 0;
         }
 
       octave_idx_type niter = dvr.numel (start);
       // The index array.
       OCTAVE_LOCAL_BUFFER_INIT (octave_idx_type, idx, nd, 0);
       for (octave_idx_type iter = 0; iter < niter; iter++)
         {
-          OCTAVE_QUIT;
+          octave_quit ();
 
           // Compute indices. 
           // FIXME: performance impact noticeable?
           octave_idx_type xidx = cdvx.cum_compute_index (idx);
           octave_idx_type yidx = cdvy.cum_compute_index (idx);
           octave_idx_type ridx = dvr.compute_index (idx);
 
           // Apply the low-level loop.
diff --git a/liboctave/dMatrix.cc b/liboctave/dMatrix.cc
--- a/liboctave/dMatrix.cc
+++ b/liboctave/dMatrix.cc
@@ -1011,17 +1011,17 @@ Matrix::fourier (void) const
 
   retval = ComplexMatrix (*this);
   Complex *tmp_data = retval.fortran_vec ();
 
   F77_FUNC (zffti, ZFFTI) (npts, pwsave);
 
   for (octave_idx_type j = 0; j < nsamples; j++)
     {
-      OCTAVE_QUIT;
+      octave_quit ();
 
       F77_FUNC (zfftf, ZFFTF) (npts, &tmp_data[npts*j], pwsave);
     }
 
   return retval;
 }
 
 ComplexMatrix
@@ -1052,17 +1052,17 @@ Matrix::ifourier (void) const
 
   retval = ComplexMatrix (*this);
   Complex *tmp_data = retval.fortran_vec ();
 
   F77_FUNC (zffti, ZFFTI) (npts, pwsave);
 
   for (octave_idx_type j = 0; j < nsamples; j++)
     {
-      OCTAVE_QUIT;
+      octave_quit ();
 
       F77_FUNC (zfftb, ZFFTB) (npts, &tmp_data[npts*j], pwsave);
     }
 
   for (octave_idx_type j = 0; j < npts*nsamples; j++)
     tmp_data[j] = tmp_data[j] / static_cast<double> (npts);
 
   return retval;
@@ -1096,17 +1096,17 @@ Matrix::fourier2d (void) const
 
   retval = ComplexMatrix (*this);
   Complex *tmp_data = retval.fortran_vec ();
 
   F77_FUNC (zffti, ZFFTI) (npts, pwsave);
 
   for (octave_idx_type j = 0; j < nsamples; j++)
     {
-      OCTAVE_QUIT;
+      octave_quit ();
 
       F77_FUNC (zfftf, ZFFTF) (npts, &tmp_data[npts*j], pwsave);
     }
 
   npts = nc;
   nsamples = nr;
   nn = 4*npts+15;
 
@@ -1115,17 +1115,17 @@ Matrix::fourier2d (void) const
 
   Array<Complex> tmp (npts);
   Complex *prow = tmp.fortran_vec ();
 
   F77_FUNC (zffti, ZFFTI) (npts, pwsave);
 
   for (octave_idx_type j = 0; j < nsamples; j++)
     {
-      OCTAVE_QUIT;
+      octave_quit ();
 
       for (octave_idx_type i = 0; i < npts; i++)
 	prow[i] = tmp_data[i*nr + j];
 
       F77_FUNC (zfftf, ZFFTF) (npts, prow, pwsave);
 
       for (octave_idx_type i = 0; i < npts; i++)
 	tmp_data[i*nr + j] = prow[i];
@@ -1162,17 +1162,17 @@ Matrix::ifourier2d (void) const
 
   retval = ComplexMatrix (*this);
   Complex *tmp_data = retval.fortran_vec ();
 
   F77_FUNC (zffti, ZFFTI) (npts, pwsave);
 
   for (octave_idx_type j = 0; j < nsamples; j++)
     {
-      OCTAVE_QUIT;
+      octave_quit ();
 
       F77_FUNC (zfftb, ZFFTB) (npts, &tmp_data[npts*j], pwsave);
     }
 
   for (octave_idx_type j = 0; j < npts*nsamples; j++)
     tmp_data[j] = tmp_data[j] / static_cast<double> (npts);
 
   npts = nc;
@@ -1184,17 +1184,17 @@ Matrix::ifourier2d (void) const
 
   Array<Complex> tmp (npts);
   Complex *prow = tmp.fortran_vec ();
 
   F77_FUNC (zffti, ZFFTI) (npts, pwsave);
 
   for (octave_idx_type j = 0; j < nsamples; j++)
     {
-      OCTAVE_QUIT;
+      octave_quit ();
 
       for (octave_idx_type i = 0; i < npts; i++)
 	prow[i] = tmp_data[i*nr + j];
 
       F77_FUNC (zfftb, ZFFTB) (npts, prow, pwsave);
 
       for (octave_idx_type i = 0; i < npts; i++)
 	tmp_data[i*nr + j] = prow[i] / static_cast<double> (npts);
@@ -3291,17 +3291,17 @@ min (double d, const Matrix& m)
 
   EMPTY_RETURN_CHECK (Matrix);
 
   Matrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
-	OCTAVE_QUIT;
+	octave_quit ();
 	result (i, j) = xmin (d, m (i, j));
       }
 
   return result;
 }
 
 Matrix
 min (const Matrix& m, double d)
@@ -3311,17 +3311,17 @@ min (const Matrix& m, double d)
 
   EMPTY_RETURN_CHECK (Matrix);
 
   Matrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
-	OCTAVE_QUIT;
+	octave_quit ();
 	result (i, j) = xmin (m (i, j), d);
       }
 
   return result;
 }
 
 Matrix
 min (const Matrix& a, const Matrix& b)
@@ -3338,17 +3338,17 @@ min (const Matrix& a, const Matrix& b)
 
   EMPTY_RETURN_CHECK (Matrix);
 
   Matrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
-	OCTAVE_QUIT;
+	octave_quit ();
 	result (i, j) = xmin (a (i, j), b (i, j));
       }
 
   return result;
 }
 
 Matrix
 max (double d, const Matrix& m)
@@ -3358,17 +3358,17 @@ max (double d, const Matrix& m)
 
   EMPTY_RETURN_CHECK (Matrix);
 
   Matrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
-	OCTAVE_QUIT;
+	octave_quit ();
 	result (i, j) = xmax (d, m (i, j));
       }
 
   return result;
 }
 
 Matrix
 max (const Matrix& m, double d)
@@ -3378,17 +3378,17 @@ max (const Matrix& m, double d)
 
   EMPTY_RETURN_CHECK (Matrix);
 
   Matrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
-	OCTAVE_QUIT;
+	octave_quit ();
 	result (i, j) = xmax (m (i, j), d);
       }
 
   return result;
 }
 
 Matrix
 max (const Matrix& a, const Matrix& b)
@@ -3405,17 +3405,17 @@ max (const Matrix& a, const Matrix& b)
 
   EMPTY_RETURN_CHECK (Matrix);
 
   Matrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
-	OCTAVE_QUIT;
+	octave_quit ();
 	result (i, j) = xmax (a (i, j), b (i, j));
       }
 
   return result;
 }
 
 Matrix linspace (const ColumnVector& x1, 
                  const ColumnVector& x2, 
diff --git a/liboctave/dNDArray.cc b/liboctave/dNDArray.cc
--- a/liboctave/dNDArray.cc
+++ b/liboctave/dNDArray.cc
@@ -274,17 +274,17 @@ NDArray::fourier (int dim) const
   octave_idx_type dist = (stride == 1 ? npts : 1);
 
   F77_FUNC (zffti, ZFFTI) (npts, pwsave);
 
   for (octave_idx_type k = 0; k < nloop; k++)
     {
       for (octave_idx_type j = 0; j < howmany; j++)
 	{
-	  OCTAVE_QUIT;
+	  octave_quit ();
 
 	  for (octave_idx_type i = 0; i < npts; i++)
 	    tmp[i] = elem((i + k*npts)*stride + j*dist);
 
 	  F77_FUNC (zfftf, ZFFTF) (npts, tmp, pwsave);
 
 	  for (octave_idx_type i = 0; i < npts; i++)
 	    retval ((i + k*npts)*stride + j*dist) = tmp[i];
@@ -321,17 +321,17 @@ NDArray::ifourier (int dim) const
   octave_idx_type dist = (stride == 1 ? npts : 1);
 
   F77_FUNC (zffti, ZFFTI) (npts, pwsave);
 
   for (octave_idx_type k = 0; k < nloop; k++)
     {
       for (octave_idx_type j = 0; j < howmany; j++)
 	{
-	  OCTAVE_QUIT;
+	  octave_quit ();
 
 	  for (octave_idx_type i = 0; i < npts; i++)
 	    tmp[i] = elem((i + k*npts)*stride + j*dist);
 
 	  F77_FUNC (zfftb, ZFFTB) (npts, tmp, pwsave);
 
 	  for (octave_idx_type i = 0; i < npts; i++)
 	    retval ((i + k*npts)*stride + j*dist) = tmp[i] / 
@@ -367,17 +367,17 @@ NDArray::fourier2d (void) const
       octave_idx_type dist = (stride == 1 ? npts : 1);
 
       F77_FUNC (zffti, ZFFTI) (npts, pwsave);
 
       for (octave_idx_type k = 0; k < nloop; k++)
 	{
 	  for (octave_idx_type j = 0; j < howmany; j++)
 	    {
-	      OCTAVE_QUIT;
+	      octave_quit ();
 
 	      for (octave_idx_type l = 0; l < npts; l++)
 		prow[l] = retval ((l + k*npts)*stride + j*dist);
 
 	      F77_FUNC (zfftf, ZFFTF) (npts, prow, pwsave);
 
 	      for (octave_idx_type l = 0; l < npts; l++)
 		retval ((l + k*npts)*stride + j*dist) = prow[l];
@@ -415,17 +415,17 @@ NDArray::ifourier2d (void) const
       octave_idx_type dist = (stride == 1 ? npts : 1);
 
       F77_FUNC (zffti, ZFFTI) (npts, pwsave);
 
       for (octave_idx_type k = 0; k < nloop; k++)
 	{
 	  for (octave_idx_type j = 0; j < howmany; j++)
 	    {
-	      OCTAVE_QUIT;
+	      octave_quit ();
 
 	      for (octave_idx_type l = 0; l < npts; l++)
 		prow[l] = retval ((l + k*npts)*stride + j*dist);
 
 	      F77_FUNC (zfftb, ZFFTB) (npts, prow, pwsave);
 
 	      for (octave_idx_type l = 0; l < npts; l++)
 		retval ((l + k*npts)*stride + j*dist) = prow[l] / 
@@ -463,17 +463,17 @@ NDArray::fourierNd (void) const
       octave_idx_type dist = (stride == 1 ? npts : 1);
 
       F77_FUNC (zffti, ZFFTI) (npts, pwsave);
 
       for (octave_idx_type k = 0; k < nloop; k++)
 	{
 	  for (octave_idx_type j = 0; j < howmany; j++)
 	    {
-	      OCTAVE_QUIT;
+	      octave_quit ();
 
 	      for (octave_idx_type l = 0; l < npts; l++)
 		prow[l] = retval ((l + k*npts)*stride + j*dist);
 
 	      F77_FUNC (zfftf, ZFFTF) (npts, prow, pwsave);
 
 	      for (octave_idx_type l = 0; l < npts; l++)
 		retval ((l + k*npts)*stride + j*dist) = prow[l];
@@ -510,17 +510,17 @@ NDArray::ifourierNd (void) const
       octave_idx_type dist = (stride == 1 ? npts : 1);
 
       F77_FUNC (zffti, ZFFTI) (npts, pwsave);
 
       for (octave_idx_type k = 0; k < nloop; k++)
 	{
 	  for (octave_idx_type j = 0; j < howmany; j++)
 	    {
-	      OCTAVE_QUIT;
+	      octave_quit ();
 
 	      for (octave_idx_type l = 0; l < npts; l++)
 		prow[l] = retval ((l + k*npts)*stride + j*dist);
 
 	      F77_FUNC (zfftb, ZFFTB) (npts, prow, pwsave);
 
 	      for (octave_idx_type l = 0; l < npts; l++)
 		retval ((l + k*npts)*stride + j*dist) = prow[l] /
@@ -995,17 +995,17 @@ min (double d, const NDArray& m)
   octave_idx_type nel = dv.numel ();
 
   EMPTY_RETURN_CHECK (NDArray);
 
   NDArray result (dv);
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
-      OCTAVE_QUIT;
+      octave_quit ();
       result (i) = xmin (d, m (i));
     }
 
   return result;
 }
 
 NDArray
 min (const NDArray& m, double d)
@@ -1014,17 +1014,17 @@ min (const NDArray& m, double d)
   octave_idx_type nel = dv.numel ();
 
   EMPTY_RETURN_CHECK (NDArray);
 
   NDArray result (dv);
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
-      OCTAVE_QUIT;
+      octave_quit ();
       result (i) = xmin (d, m (i));
     }
 
   return result;
 }
 
 NDArray
 min (const NDArray& a, const NDArray& b)
@@ -1040,17 +1040,17 @@ min (const NDArray& a, const NDArray& b)
     }
 
   EMPTY_RETURN_CHECK (NDArray);
 
   NDArray result (dv);
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
-      OCTAVE_QUIT;
+      octave_quit ();
       result (i) = xmin (a (i), b (i));
     }
 
   return result;
 }
 
 NDArray
 max (double d, const NDArray& m)
@@ -1059,17 +1059,17 @@ max (double d, const NDArray& m)
   octave_idx_type nel = dv.numel ();
 
   EMPTY_RETURN_CHECK (NDArray);
 
   NDArray result (dv);
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
-      OCTAVE_QUIT;
+      octave_quit ();
       result (i) = xmax (d, m (i));
     }
 
   return result;
 }
 
 NDArray
 max (const NDArray& m, double d)
@@ -1078,17 +1078,17 @@ max (const NDArray& m, double d)
   octave_idx_type nel = dv.numel ();
 
   EMPTY_RETURN_CHECK (NDArray);
 
   NDArray result (dv);
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
-      OCTAVE_QUIT;
+      octave_quit ();
       result (i) = xmax (d, m (i));
     }
 
   return result;
 }
 
 NDArray
 max (const NDArray& a, const NDArray& b)
@@ -1104,17 +1104,17 @@ max (const NDArray& a, const NDArray& b)
     }
 
   EMPTY_RETURN_CHECK (NDArray);
 
   NDArray result (dv);
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
-      OCTAVE_QUIT;
+      octave_quit ();
       result (i) = xmax (a (i), b (i));
     }
 
   return result;
 }
 
 NDS_CMP_OPS (NDArray, double)
 NDS_BOOL_OPS (NDArray, double)
diff --git a/liboctave/dSparse.cc b/liboctave/dSparse.cc
--- a/liboctave/dSparse.cc
+++ b/liboctave/dSparse.cc
@@ -749,17 +749,17 @@ atan2 (const SparseMatrix& x, const Spar
 	      bool ja_lt_max= ja < ja_max;
            
 	      octave_idx_type  jb = y.cidx(i);
 	      octave_idx_type  jb_max = y.cidx(i+1);
 	      bool jb_lt_max = jb < jb_max;
            
 	      while (ja_lt_max || jb_lt_max )
 		{
-		  OCTAVE_QUIT;
+		  octave_quit ();
 		  if ((! jb_lt_max) ||
                       (ja_lt_max && (x.ridx(ja) < y.ridx(jb))))
 		    {
 		      r.ridx(jx) = x.ridx(ja);
 		      r.data(jx) = atan2 (x.data(ja), 0.);
 		      jx++;
 		      ja++;
 		      ja_lt_max= ja < ja_max;
@@ -917,17 +917,17 @@ SparseMatrix::tinverse (MatrixType &matt
 	    {
 	      octave_idx_type nz = nnz ();
 	      octave_idx_type cx = 0;
 	      octave_idx_type nz2 = nz;
 	      retval = SparseMatrix (nr, nc, nz2);
 
 	      for (octave_idx_type i = 0; i < nr; i++)
 		{
-		  OCTAVE_QUIT;
+		  octave_quit ();
 		  // place the 1 in the identity position
 		  octave_idx_type cx_colstart = cx;
 	  
 		  if (cx == nz2)
 		    {
 		      nz2 *= 2;
 		      retval.change_capacity (nz2);
 		    }
@@ -950,17 +950,17 @@ SparseMatrix::tinverse (MatrixType &matt
 			{
 			  (*current_liboctave_error_handler) 
 			    ("division by zero");
 			  goto inverse_singular;
 			}
 
 		      do
 			{
-			  OCTAVE_QUIT;
+			  octave_quit ();
 			  rpX = retval.xridx(colXp);
 			  rpU = ridx(colUp);
 
 			  if (rpX < rpU) 
 			    colXp++;
 			  else if (rpX > rpU) 
 			    colUp++;
 			  else 
@@ -1040,17 +1040,17 @@ SparseMatrix::tinverse (MatrixType &matt
 		  for (octave_idx_type i = 0; i < nr; i++)
 		    rperm[i] = perm[i];
 		  for (octave_idx_type i = 0; i < nr; i++)
 		    perm[rperm[i]] = i;
 		}
 
 	      for (octave_idx_type i = 0; i < nr; i++)
 		{
-		  OCTAVE_QUIT;
+		  octave_quit ();
 		  octave_idx_type iidx = rperm[i];
 
 		  for (octave_idx_type j = 0; j < nr; j++)
 		    work[j] = 0.;
 
 		  // place the 1 in the identity position
 		  work[iidx] = 1.0;
 
@@ -1058,17 +1058,17 @@ SparseMatrix::tinverse (MatrixType &matt
 		  for (octave_idx_type j = iidx+1; j < nr; j++) 
 		    {
 		      double v = 0.;
 		      octave_idx_type jidx = perm[j];
 		      // iterate to calculate sum
 		      for (octave_idx_type k = cidx(jidx); 
 			   k < cidx(jidx+1); k++)
 			{
-			  OCTAVE_QUIT;
+			  octave_quit ();
 			  v -= work[ridx(k)] * data(k);
 			}
 
 		      // get A(m,m)
 		      double pivot;
 		      if (typ == MatrixType::Permuted_Upper)
 			pivot = data(cidx(jidx+1) - 1);
 		      else
@@ -7568,17 +7568,17 @@ SparseMatrix::matrix_value (void) const
 std::ostream&
 operator << (std::ostream& os, const SparseMatrix& a)
 {
   octave_idx_type nc = a.cols ();
 
    // add one to the printed indices to go from
    //  zero-based to one-based arrays
    for (octave_idx_type j = 0; j < nc; j++)  {
-      OCTAVE_QUIT;
+      octave_quit ();
       for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++) {
 	os << a.ridx(i) + 1 << " "  << j + 1 << " ";
 	octave_write_double (os, a.data(i));
 	os << "\n";
       }
    }
 
   return os;
@@ -7816,17 +7816,17 @@ min (const SparseMatrix& a, const Sparse
 	      bool ja_lt_max= ja < ja_max;
            
 	      octave_idx_type  jb = b.cidx(i);
 	      octave_idx_type  jb_max = b.cidx(i+1);
 	      bool jb_lt_max = jb < jb_max;
            
 	      while (ja_lt_max || jb_lt_max )
 		{
-		  OCTAVE_QUIT;
+		  octave_quit ();
 		  if ((! jb_lt_max) ||
                       (ja_lt_max && (a.ridx(ja) < b.ridx(jb))))
 		    {
 		      double tmp = xmin (a.data(ja), 0.);
 		      if (tmp != 0.)
 			{
 			  r.ridx(jx) = a.ridx(ja);
 			  r.data(jx) = tmp;
@@ -7966,17 +7966,17 @@ max (const SparseMatrix& a, const Sparse
 	      bool ja_lt_max= ja < ja_max;
            
 	      octave_idx_type  jb = b.cidx(i);
 	      octave_idx_type  jb_max = b.cidx(i+1);
 	      bool jb_lt_max = jb < jb_max;
            
 	      while (ja_lt_max || jb_lt_max )
 		{
-		  OCTAVE_QUIT;
+		  octave_quit ();
 		  if ((! jb_lt_max) ||
                       (ja_lt_max && (a.ridx(ja) < b.ridx(jb))))
 		    {
 		      double tmp = xmax (a.data(ja), 0.);
 		      if (tmp != 0.)
 			{
 			  r.ridx(jx) = a.ridx(ja);
 			  r.data(jx) = tmp;
diff --git a/liboctave/dbleGEPBAL.cc b/liboctave/dbleGEPBAL.cc
--- a/liboctave/dbleGEPBAL.cc
+++ b/liboctave/dbleGEPBAL.cc
@@ -92,17 +92,17 @@ GEPBALANCE::init (const Matrix& a, const
 			     n, p_balanced_mat, n, p_balanced_mat2,
 			     n, ilo, ihi, plscale, prscale, pwork, info
 			     F77_CHAR_ARG_LEN  (1)));
 
   balancing_mat = Matrix (n, n, 0.0);
   balancing_mat2 = Matrix (n, n, 0.0);
   for (octave_idx_type i = 0; i < n; i++)
     {
-      OCTAVE_QUIT;
+      octave_quit ();
       balancing_mat.elem (i ,i) = 1.0;
       balancing_mat2.elem (i ,i) = 1.0;
     }
 
   double *p_balancing_mat = balancing_mat.fortran_vec ();
   double *p_balancing_mat2 = balancing_mat2.fortran_vec ();
 
   // first left
diff --git a/liboctave/fCMatrix.cc b/liboctave/fCMatrix.cc
--- a/liboctave/fCMatrix.cc
+++ b/liboctave/fCMatrix.cc
@@ -1341,17 +1341,17 @@ FloatComplexMatrix::fourier (void) const
 
   retval = *this;
   FloatComplex *tmp_data = retval.fortran_vec ();
 
   F77_FUNC (cffti, CFFTI) (npts, pwsave);
 
   for (octave_idx_type j = 0; j < nsamples; j++)
     {
-      OCTAVE_QUIT;
+      octave_quit ();
 
       F77_FUNC (cfftf, CFFTF) (npts, &tmp_data[npts*j], pwsave);
     }
 
   return retval;
 }
 
 FloatComplexMatrix
@@ -1382,17 +1382,17 @@ FloatComplexMatrix::ifourier (void) cons
 
   retval = *this;
   FloatComplex *tmp_data = retval.fortran_vec ();
 
   F77_FUNC (cffti, CFFTI) (npts, pwsave);
 
   for (octave_idx_type j = 0; j < nsamples; j++)
     {
-      OCTAVE_QUIT;
+      octave_quit ();
 
       F77_FUNC (cfftb, CFFTB) (npts, &tmp_data[npts*j], pwsave);
     }
 
   for (octave_idx_type j = 0; j < npts*nsamples; j++)
     tmp_data[j] = tmp_data[j] / static_cast<float> (npts);
 
   return retval;
@@ -1426,17 +1426,17 @@ FloatComplexMatrix::fourier2d (void) con
 
   retval = *this;
   FloatComplex *tmp_data = retval.fortran_vec ();
 
   F77_FUNC (cffti, CFFTI) (npts, pwsave);
 
   for (octave_idx_type j = 0; j < nsamples; j++)
     {
-      OCTAVE_QUIT;
+      octave_quit ();
 
       F77_FUNC (cfftf, CFFTF) (npts, &tmp_data[npts*j], pwsave);
     }
 
   npts = nc;
   nsamples = nr;
   nn = 4*npts+15;
 
@@ -1445,17 +1445,17 @@ FloatComplexMatrix::fourier2d (void) con
 
   Array<FloatComplex> tmp (npts);
   FloatComplex *prow = tmp.fortran_vec ();
 
   F77_FUNC (cffti, CFFTI) (npts, pwsave);
 
   for (octave_idx_type j = 0; j < nsamples; j++)
     {
-      OCTAVE_QUIT;
+      octave_quit ();
 
       for (octave_idx_type i = 0; i < npts; i++)
 	prow[i] = tmp_data[i*nr + j];
 
       F77_FUNC (cfftf, CFFTF) (npts, prow, pwsave);
 
       for (octave_idx_type i = 0; i < npts; i++)
 	tmp_data[i*nr + j] = prow[i];
@@ -1492,17 +1492,17 @@ FloatComplexMatrix::ifourier2d (void) co
 
   retval = *this;
   FloatComplex *tmp_data = retval.fortran_vec ();
 
   F77_FUNC (cffti, CFFTI) (npts, pwsave);
 
   for (octave_idx_type j = 0; j < nsamples; j++)
     {
-      OCTAVE_QUIT;
+      octave_quit ();
 
       F77_FUNC (cfftb, CFFTB) (npts, &tmp_data[npts*j], pwsave);
     }
 
   for (octave_idx_type j = 0; j < npts*nsamples; j++)
     tmp_data[j] = tmp_data[j] / static_cast<float> (npts);
 
   npts = nc;
@@ -1514,17 +1514,17 @@ FloatComplexMatrix::ifourier2d (void) co
 
   Array<FloatComplex> tmp (npts);
   FloatComplex *prow = tmp.fortran_vec ();
 
   F77_FUNC (cffti, CFFTI) (npts, pwsave);
 
   for (octave_idx_type j = 0; j < nsamples; j++)
     {
-      OCTAVE_QUIT;
+      octave_quit ();
 
       for (octave_idx_type i = 0; i < npts; i++)
 	prow[i] = tmp_data[i*nr + j];
 
       F77_FUNC (cfftb, CFFTB) (npts, prow, pwsave);
 
       for (octave_idx_type i = 0; i < npts; i++)
 	tmp_data[i*nr + j] = prow[i] / static_cast<float> (npts);
@@ -3874,17 +3874,17 @@ min (const FloatComplex& c, const FloatC
 
   EMPTY_RETURN_CHECK (FloatComplexMatrix);
 
   FloatComplexMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
-	OCTAVE_QUIT;
+	octave_quit ();
 	result (i, j) = xmin (c, m (i, j));
       }
 
   return result;
 }
 
 FloatComplexMatrix
 min (const FloatComplexMatrix& m, const FloatComplex& c)
@@ -3894,17 +3894,17 @@ min (const FloatComplexMatrix& m, const 
 
   EMPTY_RETURN_CHECK (FloatComplexMatrix);
 
   FloatComplexMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
-	OCTAVE_QUIT;
+	octave_quit ();
 	result (i, j) = xmin (m (i, j), c);
       }
 
   return result;
 }
 
 FloatComplexMatrix
 min (const FloatComplexMatrix& a, const FloatComplexMatrix& b)
@@ -3923,34 +3923,34 @@ min (const FloatComplexMatrix& a, const 
 
   FloatComplexMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     {
       int columns_are_real_only = 1;
       for (octave_idx_type i = 0; i < nr; i++)
 	{
-	  OCTAVE_QUIT;
+	  octave_quit ();
 	  if (std::imag (a (i, j)) != 0.0 || std::imag (b (i, j)) != 0.0)
 	    {
 	      columns_are_real_only = 0;
 	      break;
 	    }
 	}
 
       if (columns_are_real_only)
 	{
 	  for (octave_idx_type i = 0; i < nr; i++)
 	    result (i, j) = xmin (std::real (a (i, j)), std::real (b (i, j)));
 	}
       else
 	{
 	  for (octave_idx_type i = 0; i < nr; i++)
 	    {
-	      OCTAVE_QUIT;
+	      octave_quit ();
 	      result (i, j) = xmin (a (i, j), b (i, j));
 	    }
 	}
     }
 
   return result;
 }
 
@@ -3962,17 +3962,17 @@ max (const FloatComplex& c, const FloatC
 
   EMPTY_RETURN_CHECK (FloatComplexMatrix);
 
   FloatComplexMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
-	OCTAVE_QUIT;
+	octave_quit ();
 	result (i, j) = xmax (c, m (i, j));
       }
 
   return result;
 }
 
 FloatComplexMatrix
 max (const FloatComplexMatrix& m, const FloatComplex& c)
@@ -3982,17 +3982,17 @@ max (const FloatComplexMatrix& m, const 
 
   EMPTY_RETURN_CHECK (FloatComplexMatrix);
 
   FloatComplexMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
-	OCTAVE_QUIT;
+	octave_quit ();
 	result (i, j) = xmax (m (i, j), c);
       }
 
   return result;
 }
 
 FloatComplexMatrix
 max (const FloatComplexMatrix& a, const FloatComplexMatrix& b)
@@ -4011,37 +4011,37 @@ max (const FloatComplexMatrix& a, const 
 
   FloatComplexMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     {
       int columns_are_real_only = 1;
       for (octave_idx_type i = 0; i < nr; i++)
 	{
-	  OCTAVE_QUIT;
+	  octave_quit ();
 	  if (std::imag (a (i, j)) != 0.0 || std::imag (b (i, j)) != 0.0)
 	    {
 	      columns_are_real_only = 0;
 	      break;
 	    }
 	}
 
       if (columns_are_real_only)
 	{
 	  for (octave_idx_type i = 0; i < nr; i++)
 	    {
-	      OCTAVE_QUIT;
+	      octave_quit ();
 	      result (i, j) = xmax (std::real (a (i, j)), std::real (b (i, j)));
 	    }
 	}
       else
 	{
 	  for (octave_idx_type i = 0; i < nr; i++)
 	    {
-	      OCTAVE_QUIT;
+	      octave_quit ();
 	      result (i, j) = xmax (a (i, j), b (i, j));
 	    }
 	}
     }
 
   return result;
 }
 
diff --git a/liboctave/fCNDArray.cc b/liboctave/fCNDArray.cc
--- a/liboctave/fCNDArray.cc
+++ b/liboctave/fCNDArray.cc
@@ -228,17 +228,17 @@ FloatComplexNDArray::fourier (int dim) c
   octave_idx_type dist = (stride == 1 ? npts : 1);
 
   F77_FUNC (cffti, CFFTI) (npts, pwsave);
 
   for (octave_idx_type k = 0; k < nloop; k++)
     {
       for (octave_idx_type j = 0; j < howmany; j++)
 	{
-	  OCTAVE_QUIT;
+	  octave_quit ();
 
 	  for (octave_idx_type i = 0; i < npts; i++)
 	    tmp[i] = elem((i + k*npts)*stride + j*dist);
 
 	  F77_FUNC (cfftf, CFFTF) (npts, tmp, pwsave);
 
 	  for (octave_idx_type i = 0; i < npts; i++)
 	    retval ((i + k*npts)*stride + j*dist) = tmp[i];
@@ -275,17 +275,17 @@ FloatComplexNDArray::ifourier (int dim) 
   octave_idx_type dist = (stride == 1 ? npts : 1);
 
   F77_FUNC (cffti, CFFTI) (npts, pwsave);
 
   for (octave_idx_type k = 0; k < nloop; k++)
     {
       for (octave_idx_type j = 0; j < howmany; j++)
 	{
-	  OCTAVE_QUIT;
+	  octave_quit ();
 
 	  for (octave_idx_type i = 0; i < npts; i++)
 	    tmp[i] = elem((i + k*npts)*stride + j*dist);
 
 	  F77_FUNC (cfftb, CFFTB) (npts, tmp, pwsave);
 
 	  for (octave_idx_type i = 0; i < npts; i++)
 	    retval ((i + k*npts)*stride + j*dist) = tmp[i] /
@@ -321,17 +321,17 @@ FloatComplexNDArray::fourier2d (void) co
       octave_idx_type dist = (stride == 1 ? npts : 1);
 
       F77_FUNC (cffti, CFFTI) (npts, pwsave);
 
       for (octave_idx_type k = 0; k < nloop; k++)
 	{
 	  for (octave_idx_type j = 0; j < howmany; j++)
 	    {
-	      OCTAVE_QUIT;
+	      octave_quit ();
 
 	      for (octave_idx_type l = 0; l < npts; l++)
 		prow[l] = retval ((l + k*npts)*stride + j*dist);
 
 	      F77_FUNC (cfftf, CFFTF) (npts, prow, pwsave);
 
 	      for (octave_idx_type l = 0; l < npts; l++)
 		retval ((l + k*npts)*stride + j*dist) = prow[l];
@@ -369,17 +369,17 @@ FloatComplexNDArray::ifourier2d (void) c
       octave_idx_type dist = (stride == 1 ? npts : 1);
 
       F77_FUNC (cffti, CFFTI) (npts, pwsave);
 
       for (octave_idx_type k = 0; k < nloop; k++)
 	{
 	  for (octave_idx_type j = 0; j < howmany; j++)
 	    {
-	      OCTAVE_QUIT;
+	      octave_quit ();
 
 	      for (octave_idx_type l = 0; l < npts; l++)
 		prow[l] = retval ((l + k*npts)*stride + j*dist);
 
 	      F77_FUNC (cfftb, CFFTB) (npts, prow, pwsave);
 
 	      for (octave_idx_type l = 0; l < npts; l++)
 		retval ((l + k*npts)*stride + j*dist) = prow[l] /
@@ -417,17 +417,17 @@ FloatComplexNDArray::fourierNd (void) co
       octave_idx_type dist = (stride == 1 ? npts : 1);
 
       F77_FUNC (cffti, CFFTI) (npts, pwsave);
 
       for (octave_idx_type k = 0; k < nloop; k++)
 	{
 	  for (octave_idx_type j = 0; j < howmany; j++)
 	    {
-	      OCTAVE_QUIT;
+	      octave_quit ();
 
 	      for (octave_idx_type l = 0; l < npts; l++)
 		prow[l] = retval ((l + k*npts)*stride + j*dist);
 
 	      F77_FUNC (cfftf, CFFTF) (npts, prow, pwsave);
 
 	      for (octave_idx_type l = 0; l < npts; l++)
 		retval ((l + k*npts)*stride + j*dist) = prow[l];
@@ -464,17 +464,17 @@ FloatComplexNDArray::ifourierNd (void) c
       octave_idx_type dist = (stride == 1 ? npts : 1);
 
       F77_FUNC (cffti, CFFTI) (npts, pwsave);
 
       for (octave_idx_type k = 0; k < nloop; k++)
 	{
 	  for (octave_idx_type j = 0; j < howmany; j++)
 	    {
-	      OCTAVE_QUIT;
+	      octave_quit ();
 
 	      for (octave_idx_type l = 0; l < npts; l++)
 		prow[l] = retval ((l + k*npts)*stride + j*dist);
 
 	      F77_FUNC (cfftb, CFFTB) (npts, prow, pwsave);
 
 	      for (octave_idx_type l = 0; l < npts; l++)
 		retval ((l + k*npts)*stride + j*dist) = prow[l] /
@@ -923,17 +923,17 @@ min (const FloatComplex& c, const FloatC
   int nel = dv.numel ();
 
   EMPTY_RETURN_CHECK (FloatComplexNDArray);
 
   FloatComplexNDArray result (dv);
 
   for (int i = 0; i < nel; i++)
     {
-      OCTAVE_QUIT;
+      octave_quit ();
       result (i) = xmin (c, m (i));
     }
 
   return result;
 }
 
 FloatComplexNDArray
 min (const FloatComplexNDArray& m, const FloatComplex& c)
@@ -942,17 +942,17 @@ min (const FloatComplexNDArray& m, const
   int nel = dv.numel ();
 
   EMPTY_RETURN_CHECK (FloatComplexNDArray);
 
   FloatComplexNDArray result (dv);
 
   for (int i = 0; i < nel; i++)
     {
-      OCTAVE_QUIT;
+      octave_quit ();
       result (i) = xmin (c, m (i));
     }
 
   return result;
 }
 
 FloatComplexNDArray
 min (const FloatComplexNDArray& a, const FloatComplexNDArray& b)
@@ -968,17 +968,17 @@ min (const FloatComplexNDArray& a, const
     }
 
   EMPTY_RETURN_CHECK (FloatComplexNDArray);
 
   FloatComplexNDArray result (dv);
 
   for (int i = 0; i < nel; i++)
     {
-      OCTAVE_QUIT;
+      octave_quit ();
       result (i) = xmin (a (i), b (i));
     }
 
   return result;
 }
 
 FloatComplexNDArray
 max (const FloatComplex& c, const FloatComplexNDArray& m)
@@ -987,17 +987,17 @@ max (const FloatComplex& c, const FloatC
   int nel = dv.numel ();
 
   EMPTY_RETURN_CHECK (FloatComplexNDArray);
 
   FloatComplexNDArray result (dv);
 
   for (int i = 0; i < nel; i++)
     {
-      OCTAVE_QUIT;
+      octave_quit ();
       result (i) = xmax (c, m (i));
     }
 
   return result;
 }
 
 FloatComplexNDArray
 max (const FloatComplexNDArray& m, const FloatComplex& c)
@@ -1006,17 +1006,17 @@ max (const FloatComplexNDArray& m, const
   int nel = dv.numel ();
 
   EMPTY_RETURN_CHECK (FloatComplexNDArray);
 
   FloatComplexNDArray result (dv);
 
   for (int i = 0; i < nel; i++)
     {
-      OCTAVE_QUIT;
+      octave_quit ();
       result (i) = xmax (c, m (i));
     }
 
   return result;
 }
 
 FloatComplexNDArray
 max (const FloatComplexNDArray& a, const FloatComplexNDArray& b)
@@ -1032,17 +1032,17 @@ max (const FloatComplexNDArray& a, const
     }
 
   EMPTY_RETURN_CHECK (FloatComplexNDArray);
 
   FloatComplexNDArray result (dv);
 
   for (int i = 0; i < nel; i++)
     {
-      OCTAVE_QUIT;
+      octave_quit ();
       result (i) = xmax (a (i), b (i));
     }
 
   return result;
 }
 
 NDS_CMP_OPS (FloatComplexNDArray, FloatComplex)
 NDS_BOOL_OPS (FloatComplexNDArray, FloatComplex)
diff --git a/liboctave/fCmplxGEPBAL.cc b/liboctave/fCmplxGEPBAL.cc
--- a/liboctave/fCmplxGEPBAL.cc
+++ b/liboctave/fCmplxGEPBAL.cc
@@ -92,17 +92,17 @@ FloatComplexGEPBALANCE::init (const Floa
 			     n, p_balanced_mat, n, p_balanced_mat2,
 			     n, ilo, ihi, plscale,prscale, pwork, info
 			     F77_CHAR_ARG_LEN (1)));
 
   balancing_mat = FloatMatrix (n, n, 0.0);
   balancing_mat2 = FloatMatrix (n, n, 0.0);
   for (octave_idx_type i = 0; i < n; i++)
     {
-      OCTAVE_QUIT;
+      octave_quit ();
       balancing_mat.elem (i ,i) = 1.0;
       balancing_mat2.elem (i ,i) = 1.0;
     }
 
   float *p_balancing_mat = balancing_mat.fortran_vec ();
   float *p_balancing_mat2 = balancing_mat2.fortran_vec ();
 
   // first left
diff --git a/liboctave/fMatrix.cc b/liboctave/fMatrix.cc
--- a/liboctave/fMatrix.cc
+++ b/liboctave/fMatrix.cc
@@ -1010,17 +1010,17 @@ FloatMatrix::fourier (void) const
 
   retval = FloatComplexMatrix (*this);
   FloatComplex *tmp_data = retval.fortran_vec ();
 
   F77_FUNC (cffti, CFFTI) (npts, pwsave);
 
   for (octave_idx_type j = 0; j < nsamples; j++)
     {
-      OCTAVE_QUIT;
+      octave_quit ();
 
       F77_FUNC (cfftf, CFFTF) (npts, &tmp_data[npts*j], pwsave);
     }
 
   return retval;
 }
 
 FloatComplexMatrix
@@ -1051,17 +1051,17 @@ FloatMatrix::ifourier (void) const
 
   retval = FloatComplexMatrix (*this);
   FloatComplex *tmp_data = retval.fortran_vec ();
 
   F77_FUNC (cffti, CFFTI) (npts, pwsave);
 
   for (octave_idx_type j = 0; j < nsamples; j++)
     {
-      OCTAVE_QUIT;
+      octave_quit ();
 
       F77_FUNC (cfftb, CFFTB) (npts, &tmp_data[npts*j], pwsave);
     }
 
   for (octave_idx_type j = 0; j < npts*nsamples; j++)
     tmp_data[j] = tmp_data[j] / static_cast<float> (npts);
 
   return retval;
@@ -1095,17 +1095,17 @@ FloatMatrix::fourier2d (void) const
 
   retval = FloatComplexMatrix (*this);
   FloatComplex *tmp_data = retval.fortran_vec ();
 
   F77_FUNC (cffti, CFFTI) (npts, pwsave);
 
   for (octave_idx_type j = 0; j < nsamples; j++)
     {
-      OCTAVE_QUIT;
+      octave_quit ();
 
       F77_FUNC (cfftf, CFFTF) (npts, &tmp_data[npts*j], pwsave);
     }
 
   npts = nc;
   nsamples = nr;
   nn = 4*npts+15;
 
@@ -1114,17 +1114,17 @@ FloatMatrix::fourier2d (void) const
 
   Array<FloatComplex> tmp (npts);
   FloatComplex *prow = tmp.fortran_vec ();
 
   F77_FUNC (cffti, CFFTI) (npts, pwsave);
 
   for (octave_idx_type j = 0; j < nsamples; j++)
     {
-      OCTAVE_QUIT;
+      octave_quit ();
 
       for (octave_idx_type i = 0; i < npts; i++)
 	prow[i] = tmp_data[i*nr + j];
 
       F77_FUNC (cfftf, CFFTF) (npts, prow, pwsave);
 
       for (octave_idx_type i = 0; i < npts; i++)
 	tmp_data[i*nr + j] = prow[i];
@@ -1161,17 +1161,17 @@ FloatMatrix::ifourier2d (void) const
 
   retval = FloatComplexMatrix (*this);
   FloatComplex *tmp_data = retval.fortran_vec ();
 
   F77_FUNC (cffti, CFFTI) (npts, pwsave);
 
   for (octave_idx_type j = 0; j < nsamples; j++)
     {
-      OCTAVE_QUIT;
+      octave_quit ();
 
       F77_FUNC (cfftb, CFFTB) (npts, &tmp_data[npts*j], pwsave);
     }
 
   for (octave_idx_type j = 0; j < npts*nsamples; j++)
     tmp_data[j] = tmp_data[j] / static_cast<float> (npts);
 
   npts = nc;
@@ -1183,17 +1183,17 @@ FloatMatrix::ifourier2d (void) const
 
   Array<FloatComplex> tmp (npts);
   FloatComplex *prow = tmp.fortran_vec ();
 
   F77_FUNC (cffti, CFFTI) (npts, pwsave);
 
   for (octave_idx_type j = 0; j < nsamples; j++)
     {
-      OCTAVE_QUIT;
+      octave_quit ();
 
       for (octave_idx_type i = 0; i < npts; i++)
 	prow[i] = tmp_data[i*nr + j];
 
       F77_FUNC (cfftb, CFFTB) (npts, prow, pwsave);
 
       for (octave_idx_type i = 0; i < npts; i++)
 	tmp_data[i*nr + j] = prow[i] / static_cast<float> (npts);
@@ -3290,17 +3290,17 @@ min (float d, const FloatMatrix& m)
 
   EMPTY_RETURN_CHECK (FloatMatrix);
 
   FloatMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
-	OCTAVE_QUIT;
+	octave_quit ();
 	result (i, j) = xmin (d, m (i, j));
       }
 
   return result;
 }
 
 FloatMatrix
 min (const FloatMatrix& m, float d)
@@ -3310,17 +3310,17 @@ min (const FloatMatrix& m, float d)
 
   EMPTY_RETURN_CHECK (FloatMatrix);
 
   FloatMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
-	OCTAVE_QUIT;
+	octave_quit ();
 	result (i, j) = xmin (m (i, j), d);
       }
 
   return result;
 }
 
 FloatMatrix
 min (const FloatMatrix& a, const FloatMatrix& b)
@@ -3337,17 +3337,17 @@ min (const FloatMatrix& a, const FloatMa
 
   EMPTY_RETURN_CHECK (FloatMatrix);
 
   FloatMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
-	OCTAVE_QUIT;
+	octave_quit ();
 	result (i, j) = xmin (a (i, j), b (i, j));
       }
 
   return result;
 }
 
 FloatMatrix
 max (float d, const FloatMatrix& m)
@@ -3357,17 +3357,17 @@ max (float d, const FloatMatrix& m)
 
   EMPTY_RETURN_CHECK (FloatMatrix);
 
   FloatMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
-	OCTAVE_QUIT;
+	octave_quit ();
 	result (i, j) = xmax (d, m (i, j));
       }
 
   return result;
 }
 
 FloatMatrix
 max (const FloatMatrix& m, float d)
@@ -3377,17 +3377,17 @@ max (const FloatMatrix& m, float d)
 
   EMPTY_RETURN_CHECK (FloatMatrix);
 
   FloatMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
-	OCTAVE_QUIT;
+	octave_quit ();
 	result (i, j) = xmax (m (i, j), d);
       }
 
   return result;
 }
 
 FloatMatrix
 max (const FloatMatrix& a, const FloatMatrix& b)
@@ -3404,17 +3404,17 @@ max (const FloatMatrix& a, const FloatMa
 
   EMPTY_RETURN_CHECK (FloatMatrix);
 
   FloatMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
-	OCTAVE_QUIT;
+	octave_quit ();
 	result (i, j) = xmax (a (i, j), b (i, j));
       }
 
   return result;
 }
 
 FloatMatrix linspace (const FloatColumnVector& x1, 
                       const FloatColumnVector& x2, 
diff --git a/liboctave/fNDArray.cc b/liboctave/fNDArray.cc
--- a/liboctave/fNDArray.cc
+++ b/liboctave/fNDArray.cc
@@ -232,17 +232,17 @@ FloatNDArray::fourier (int dim) const
   octave_idx_type dist = (stride == 1 ? npts : 1);
 
   F77_FUNC (cffti, CFFTI) (npts, pwsave);
 
   for (octave_idx_type k = 0; k < nloop; k++)
     {
       for (octave_idx_type j = 0; j < howmany; j++)
 	{
-	  OCTAVE_QUIT;
+	  octave_quit ();
 
 	  for (octave_idx_type i = 0; i < npts; i++)
 	    tmp[i] = elem((i + k*npts)*stride + j*dist);
 
 	  F77_FUNC (cfftf, CFFTF) (npts, tmp, pwsave);
 
 	  for (octave_idx_type i = 0; i < npts; i++)
 	    retval ((i + k*npts)*stride + j*dist) = tmp[i];
@@ -279,17 +279,17 @@ FloatNDArray::ifourier (int dim) const
   octave_idx_type dist = (stride == 1 ? npts : 1);
 
   F77_FUNC (cffti, CFFTI) (npts, pwsave);
 
   for (octave_idx_type k = 0; k < nloop; k++)
     {
       for (octave_idx_type j = 0; j < howmany; j++)
 	{
-	  OCTAVE_QUIT;
+	  octave_quit ();
 
 	  for (octave_idx_type i = 0; i < npts; i++)
 	    tmp[i] = elem((i + k*npts)*stride + j*dist);
 
 	  F77_FUNC (cfftb, CFFTB) (npts, tmp, pwsave);
 
 	  for (octave_idx_type i = 0; i < npts; i++)
 	    retval ((i + k*npts)*stride + j*dist) = tmp[i] / 
@@ -325,17 +325,17 @@ FloatNDArray::fourier2d (void) const
       octave_idx_type dist = (stride == 1 ? npts : 1);
 
       F77_FUNC (cffti, CFFTI) (npts, pwsave);
 
       for (octave_idx_type k = 0; k < nloop; k++)
 	{
 	  for (octave_idx_type j = 0; j < howmany; j++)
 	    {
-	      OCTAVE_QUIT;
+	      octave_quit ();
 
 	      for (octave_idx_type l = 0; l < npts; l++)
 		prow[l] = retval ((l + k*npts)*stride + j*dist);
 
 	      F77_FUNC (cfftf, CFFTF) (npts, prow, pwsave);
 
 	      for (octave_idx_type l = 0; l < npts; l++)
 		retval ((l + k*npts)*stride + j*dist) = prow[l];
@@ -373,17 +373,17 @@ FloatNDArray::ifourier2d (void) const
       octave_idx_type dist = (stride == 1 ? npts : 1);
 
       F77_FUNC (cffti, CFFTI) (npts, pwsave);
 
       for (octave_idx_type k = 0; k < nloop; k++)
 	{
 	  for (octave_idx_type j = 0; j < howmany; j++)
 	    {
-	      OCTAVE_QUIT;
+	      octave_quit ();
 
 	      for (octave_idx_type l = 0; l < npts; l++)
 		prow[l] = retval ((l + k*npts)*stride + j*dist);
 
 	      F77_FUNC (cfftb, CFFTB) (npts, prow, pwsave);
 
 	      for (octave_idx_type l = 0; l < npts; l++)
 		retval ((l + k*npts)*stride + j*dist) = prow[l] / 
@@ -421,17 +421,17 @@ FloatNDArray::fourierNd (void) const
       octave_idx_type dist = (stride == 1 ? npts : 1);
 
       F77_FUNC (cffti, CFFTI) (npts, pwsave);
 
       for (octave_idx_type k = 0; k < nloop; k++)
 	{
 	  for (octave_idx_type j = 0; j < howmany; j++)
 	    {
-	      OCTAVE_QUIT;
+	      octave_quit ();
 
 	      for (octave_idx_type l = 0; l < npts; l++)
 		prow[l] = retval ((l + k*npts)*stride + j*dist);
 
 	      F77_FUNC (cfftf, CFFTF) (npts, prow, pwsave);
 
 	      for (octave_idx_type l = 0; l < npts; l++)
 		retval ((l + k*npts)*stride + j*dist) = prow[l];
@@ -468,17 +468,17 @@ FloatNDArray::ifourierNd (void) const
       octave_idx_type dist = (stride == 1 ? npts : 1);
 
       F77_FUNC (cffti, CFFTI) (npts, pwsave);
 
       for (octave_idx_type k = 0; k < nloop; k++)
 	{
 	  for (octave_idx_type j = 0; j < howmany; j++)
 	    {
-	      OCTAVE_QUIT;
+	      octave_quit ();
 
 	      for (octave_idx_type l = 0; l < npts; l++)
 		prow[l] = retval ((l + k*npts)*stride + j*dist);
 
 	      F77_FUNC (cfftb, CFFTB) (npts, prow, pwsave);
 
 	      for (octave_idx_type l = 0; l < npts; l++)
 		retval ((l + k*npts)*stride + j*dist) = prow[l] /
@@ -953,17 +953,17 @@ min (float d, const FloatNDArray& m)
   octave_idx_type nel = dv.numel ();
 
   EMPTY_RETURN_CHECK (FloatNDArray);
 
   FloatNDArray result (dv);
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
-      OCTAVE_QUIT;
+      octave_quit ();
       result (i) = xmin (d, m (i));
     }
 
   return result;
 }
 
 FloatNDArray
 min (const FloatNDArray& m, float d)
@@ -972,17 +972,17 @@ min (const FloatNDArray& m, float d)
   octave_idx_type nel = dv.numel ();
 
   EMPTY_RETURN_CHECK (FloatNDArray);
 
   FloatNDArray result (dv);
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
-      OCTAVE_QUIT;
+      octave_quit ();
       result (i) = xmin (d, m (i));
     }
 
   return result;
 }
 
 FloatNDArray
 min (const FloatNDArray& a, const FloatNDArray& b)
@@ -998,17 +998,17 @@ min (const FloatNDArray& a, const FloatN
     }
 
   EMPTY_RETURN_CHECK (FloatNDArray);
 
   FloatNDArray result (dv);
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
-      OCTAVE_QUIT;
+      octave_quit ();
       result (i) = xmin (a (i), b (i));
     }
 
   return result;
 }
 
 FloatNDArray
 max (float d, const FloatNDArray& m)
@@ -1017,17 +1017,17 @@ max (float d, const FloatNDArray& m)
   octave_idx_type nel = dv.numel ();
 
   EMPTY_RETURN_CHECK (FloatNDArray);
 
   FloatNDArray result (dv);
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
-      OCTAVE_QUIT;
+      octave_quit ();
       result (i) = xmax (d, m (i));
     }
 
   return result;
 }
 
 FloatNDArray
 max (const FloatNDArray& m, float d)
@@ -1036,17 +1036,17 @@ max (const FloatNDArray& m, float d)
   octave_idx_type nel = dv.numel ();
 
   EMPTY_RETURN_CHECK (FloatNDArray);
 
   FloatNDArray result (dv);
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
-      OCTAVE_QUIT;
+      octave_quit ();
       result (i) = xmax (d, m (i));
     }
 
   return result;
 }
 
 FloatNDArray
 max (const FloatNDArray& a, const FloatNDArray& b)
@@ -1062,17 +1062,17 @@ max (const FloatNDArray& a, const FloatN
     }
 
   EMPTY_RETURN_CHECK (FloatNDArray);
 
   FloatNDArray result (dv);
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
-      OCTAVE_QUIT;
+      octave_quit ();
       result (i) = xmax (a (i), b (i));
     }
 
   return result;
 }
 
 NDS_CMP_OPS (FloatNDArray, float)
 NDS_BOOL_OPS (FloatNDArray, float)
diff --git a/liboctave/file-ops.cc b/liboctave/file-ops.cc
--- a/liboctave/file-ops.cc
+++ b/liboctave/file-ops.cc
@@ -325,17 +325,17 @@ file_ops::recursive_rmdir (const std::st
   dir_entry dir (name);
 
   if (dir)
     {
       string_vector dirlist = dir.read ();
 
       for (octave_idx_type i = 0; i < dirlist.length (); i++)
 	{
-	  OCTAVE_QUIT;
+	  octave_quit ();
 
 	  std::string nm = dirlist[i];
 
 	  // Skip current directory and parent.
 	  if (nm == "." || nm == "..")
 	    continue;
 
 	  std::string fullnm = name + file_ops::dir_sep_str () + nm;
diff --git a/liboctave/floatGEPBAL.cc b/liboctave/floatGEPBAL.cc
--- a/liboctave/floatGEPBAL.cc
+++ b/liboctave/floatGEPBAL.cc
@@ -92,17 +92,17 @@ FloatGEPBALANCE::init (const FloatMatrix
 			     n, p_balanced_mat, n, p_balanced_mat2,
 			     n, ilo, ihi, plscale, prscale, pwork, info
 			     F77_CHAR_ARG_LEN  (1)));
 
   balancing_mat = FloatMatrix (n, n, 0.0);
   balancing_mat2 = FloatMatrix (n, n, 0.0);
   for (octave_idx_type i = 0; i < n; i++)
     {
-      OCTAVE_QUIT;
+      octave_quit ();
       balancing_mat.elem (i ,i) = 1.0;
       balancing_mat2.elem (i ,i) = 1.0;
     }
 
   float *p_balancing_mat = balancing_mat.fortran_vec ();
   float *p_balancing_mat2 = balancing_mat2.fortran_vec ();
 
   // first left
diff --git a/liboctave/lo-utils.cc b/liboctave/lo-utils.cc
--- a/liboctave/lo-utils.cc
+++ b/liboctave/lo-utils.cc
@@ -215,17 +215,17 @@ octave_fgets (FILE *f, bool& eof)
 	  break;
 	}
     }
   while (retval.empty ());
 
   if (buf)
     free (buf);
 
-  OCTAVE_QUIT;
+  octave_quit ();
 
   return retval;
 }
 
 std::string
 octave_fgetl (FILE *f)
 {
   bool eof;
diff --git a/liboctave/mx-op-defs.h b/liboctave/mx-op-defs.h
--- a/liboctave/mx-op-defs.h
+++ b/liboctave/mx-op-defs.h
@@ -555,17 +555,17 @@ FCN (octave_ ## T d, const T ## NDArray&
 \
   if (nel == 0)	\
     return T ## NDArray (dv); \
 \
   T ## NDArray result (dv); \
 \
   for (octave_idx_type i = 0; i < nel; i++) \
     { \
-      OCTAVE_QUIT; \
+      octave_quit (); \
       result (i) = d OP m (i) ? d : m(i); \
     } \
 \
   return result; \
 }
 
 #define NDS_MINMAX_FCN(FCN, OP, T) \
 T ## NDArray \
@@ -576,17 +576,17 @@ FCN (const T ## NDArray& m, octave_ ## T
 \
   if (nel == 0)	\
     return T ## NDArray (dv); \
 \
   T ## NDArray result (dv); \
 \
   for (octave_idx_type i = 0; i < nel; i++) \
     { \
-      OCTAVE_QUIT; \
+      octave_quit (); \
       result (i) = m (i) OP d ? m(i) : d; \
     } \
 \
   return result; \
 }
 
 #define NDND_MINMAX_FCN(FCN, OP, T) \
 T ## NDArray \
@@ -604,17 +604,17 @@ FCN (const T ## NDArray& a, const T ## N
 \
   if (nel == 0)	\
     return T ## NDArray (dv); \
 \
   T ## NDArray result (dv); \
 \
   for (octave_idx_type i = 0; i < nel; i++) \
     { \
-      OCTAVE_QUIT; \
+      octave_quit (); \
       result (i) = a(i) OP b(i) ? a(i) : b(i); \
     } \
 \
   return result; \
 }
 
 #define MINMAX_FCNS(T) \
   SND_MINMAX_FCN (min, <, T) \
diff --git a/liboctave/oct-fftw.cc b/liboctave/oct-fftw.cc
--- a/liboctave/oct-fftw.cc
+++ b/liboctave/oct-fftw.cc
@@ -678,64 +678,64 @@ octave_float_fftw_planner::do_method (Ff
   return ret;
 }
 
 template <class T>
 static inline void
 convert_packcomplex_1d (T *out, size_t nr, size_t nc,
 			octave_idx_type stride, octave_idx_type dist)
 {
-  OCTAVE_QUIT;
+  octave_quit ();
 
   // Fill in the missing data.
 
   for (size_t i = 0; i < nr; i++)
     for (size_t j = nc/2+1; j < nc; j++)
       out[j*stride + i*dist] = conj(out[(nc - j)*stride + i*dist]);
 
-  OCTAVE_QUIT;
+  octave_quit ();
 }
 
 template <class T>
 static inline void
 convert_packcomplex_Nd (T *out, const dim_vector &dv)
 {
   size_t nc = dv(0);
   size_t nr = dv(1);
   size_t np = (dv.length () > 2 ? dv.numel () / nc / nr : 1);
   size_t nrp = nr * np;
   T *ptr1, *ptr2;
 
-  OCTAVE_QUIT;
+  octave_quit ();
 
   // Create space for the missing elements.
 
   for (size_t i = 0; i < nrp; i++)
     {
       ptr1 = out + i * (nc/2 + 1) + nrp*((nc-1)/2);
       ptr2 = out + i * nc;
       for (size_t j = 0; j < nc/2+1; j++)
 	*ptr2++ = *ptr1++;
     }
 
-  OCTAVE_QUIT;
+  octave_quit ();
 
   // Fill in the missing data for the rank = 2 case directly for speed.
 
   for (size_t i = 0; i < np; i++)
     {
       for (size_t j = 1; j < nr; j++)
 	for (size_t k = nc/2+1; k < nc; k++)
 	  out[k + (j + i*nr)*nc] = conj(out[nc - k + ((i+1)*nr - j)*nc]);
 
       for (size_t j = nc/2+1; j < nc; j++)
 	out[j + i*nr*nc] = conj(out[(i*nr+1)*nc - j]);
     }
 
-  OCTAVE_QUIT;
+  octave_quit ();
 
   // Now do the permutations needed for rank > 2 cases.
 
   size_t jstart = dv(0) * dv(1);
   size_t kstep = dv(0);
   size_t nel = dv.numel ();
 
   for (int inner = 2; inner < dv.length (); inner++) 
@@ -749,17 +749,17 @@ convert_packcomplex_Nd (T *out, const di
 	      {
 		T tmp = out[i+ j + k + l];
 		out[i + j + k + l] =  out[i + jj + k + l];
 		out[i + jj + k + l] = tmp;
 	      }
       jstart = jmax;
     }
 
-  OCTAVE_QUIT;
+  octave_quit ();
 }
 
 int
 octave_fftw::fft (const double *in, Complex *out, size_t npts, 
 		  size_t nsamples, octave_idx_type stride, octave_idx_type dist)
 {
   dist = (dist < 0 ? npts : dist);
 
diff --git a/liboctave/oct-norm.cc b/liboctave/oct-norm.cc
--- a/liboctave/oct-norm.cc
+++ b/liboctave/oct-norm.cc
@@ -408,17 +408,17 @@ R higham (const MatrixT& m, R p, R tol, 
 {
   x.resize (m.columns (), 1);
   // the OSE part
   VectorT y(m.rows (), 1, 0), z(m.rows (), 1);
   typedef typename VectorT::element_type RR;
   RR lambda = 0, mu = 0;
   for (octave_idx_type k = 0; k < m.columns (); k++)
     {
-      OCTAVE_QUIT;
+      octave_quit ();
       VectorT col (m.column (k));
       if (k > 0)
         higham_subp (y, col, 4*k, p, lambda, mu);
       for (octave_idx_type i = 0; i < k; i++)
         x(i) *= lambda;
       x(k) = mu;
       y = lambda * y + mu * col;
     }
@@ -426,17 +426,17 @@ R higham (const MatrixT& m, R p, R tol, 
   // the PM part
   x = x / vector_norm (x, p);
   R q = p/(p-1);
 
   R gamma = 0, gamma1;
   int iter = 0;
   while (iter < maxiter)
     {
-      OCTAVE_QUIT;
+      octave_quit ();
       y = m*x;
       gamma1 = gamma;
       gamma = vector_norm (y, p);
       z = dual_p (y, p, q);
       z = z.hermitian ();
       z = z * m;
 
       if (iter > 0 && (vector_norm (z, q) <= gamma
diff --git a/liboctave/oct-rand.cc b/liboctave/oct-rand.cc
--- a/liboctave/oct-rand.cc
+++ b/liboctave/oct-rand.cc
@@ -557,17 +557,17 @@ octave_rand::switch_to_generator (int di
 }
 
 #define MAKE_RAND(len) \
   do \
     { \
       double val; \
       for (volatile octave_idx_type i = 0; i < len; i++) \
 	{ \
-	  OCTAVE_QUIT; \
+	  octave_quit (); \
 	  RAND_FUNC (val); \
 	  v[i] = val; \
 	} \
     } \
   while (0)
 
 void
 octave_rand::fill (octave_idx_type len, double *v, double a)
diff --git a/liboctave/sparse-dmsolve.cc b/liboctave/sparse-dmsolve.cc
--- a/liboctave/sparse-dmsolve.cc
+++ b/liboctave/sparse-dmsolve.cc
@@ -53,17 +53,17 @@ dmsolve_extract (const MSparse<T> &A, co
     {
       nz = 0;
       for (octave_idx_type j = cst ; j < cend ; j++)
 	{
 	  octave_idx_type qq = (Q ? Q [j] : j);
 	  B.xcidx (j - cst) = nz;
 	  for (octave_idx_type p = A.cidx(qq) ; p < A.cidx (qq+1) ; p++)
 	    {
-	      OCTAVE_QUIT;
+	      octave_quit ();
 	      octave_idx_type r = (Pinv ? Pinv [A.ridx (p)] : A.ridx (p));
 	      if (r >= rst && r < rend)
 		{
 		  B.xdata (nz) = A.data (p);
 		  B.xridx (nz++) =  r - rst ;
 		}
 	    }
 	}
@@ -76,17 +76,17 @@ dmsolve_extract (const MSparse<T> &A, co
       octave_idx_type *ri = B.xridx();
       nz = 0;
       for (octave_idx_type j = cst ; j < cend ; j++)
 	{
 	  octave_idx_type qq = (Q ? Q [j] : j);
 	  B.xcidx (j - cst) = nz;
 	  for (octave_idx_type p = A.cidx(qq) ; p < A.cidx (qq+1) ; p++)
 	    {
-	      OCTAVE_QUIT;
+	      octave_quit ();
 	      octave_idx_type r = (Pinv ? Pinv [A.ridx (p)] : A.ridx (p));
 	      if (r >= rst && r < rend)
 		{
 		  X [r-rst] = A.data (p);
 		  B.xridx (nz++) =  r - rst ;
 		}
 	    }
 	  sort.sort (ri + B.xcidx (j - cst), nz - B.xcidx (j - cst));
@@ -164,17 +164,17 @@ dmsolve_insert (MArray2<T> &a, const MAr
   octave_idx_type nr = b.rows();
   octave_idx_type nc = b.cols();
   for (octave_idx_type j = 0; j < nc; j++)
     {
       octave_idx_type aoff = (c + j) * anr;
       octave_idx_type boff = j * nr;
       for (octave_idx_type i = 0; i < nr; i++)
 	{
-	  OCTAVE_QUIT;
+	  octave_quit ();
 	  ax [Q [r + i] + aoff] = bx [i + boff];
 	}
     }
 }
 
 #if !defined (CXX_NEW_FRIEND_TEMPLATE_DECL)
 static void
 dmsolve_insert (MArray2<double> &a, const MArray2<double> &b, 
@@ -223,26 +223,26 @@ dmsolve_insert (MSparse<T> &a, const MSp
     }
   for (octave_idx_type i = 0; i < c + 1; i++)
     a.xcidx(i) = tmp.xcidx(i);
 
   octave_idx_type ii = a.xcidx(c);
 
   for (octave_idx_type i = c; i < c + b_cols; i++)
     {
-      OCTAVE_QUIT;
+      octave_quit ();
 
       for (octave_idx_type j = tmp.xcidx(i); j < tmp.xcidx(i+1); j++)
 	if (Qinv [tmp.xridx(j)] < r || 	Qinv [tmp.xridx(j)] >= r + b_rows)
 	  {
 	    X [tmp.xridx(j)] = tmp.xdata(j);
 	    a.xridx(ii++) = tmp.xridx(j);
 	  }
 
-      OCTAVE_QUIT;
+      octave_quit ();
 
       for (octave_idx_type j = b.cidx(i-c); j < b.cidx(i-c+1); j++)
 	{
 	  X [Q [r + b.ridx(j)]] = b.data(j);
 	  a.xridx(ii++) = Q [r + b.ridx(j)];
 	}
 
       sort.sort (ri + a.xcidx (i), ii - a.xcidx (i));
@@ -281,17 +281,17 @@ dmsolve_permute (MArray2<RT> &a, const M
   const T *Bx = b.fortran_vec();
   a.resize(b_nr, b_nc);
   RT *Btx = a.fortran_vec();
   for (octave_idx_type j = 0; j < b_nc; j++)
     {
       octave_idx_type off = j * b_nr;
       for (octave_idx_type i = 0; i < b_nr; i++)
 	{
-	  OCTAVE_QUIT;
+	  octave_quit ();
 	  Btx [p [i] + off] = Bx [ i + off];
 	}
     }
 }
 
 #if !defined (CXX_NEW_FRIEND_TEMPLATE_DECL)
 static void
 dmsolve_permute (MArray2<double> &a, const MArray2<double>& b,
@@ -318,25 +318,25 @@ dmsolve_permute (MSparse<RT> &a, const M
   octave_sort<octave_idx_type> sort;
   octave_idx_type *ri = a.xridx();
   OCTAVE_LOCAL_BUFFER (RT, X, b_nr);
   a.xcidx(0) = 0;
   for (octave_idx_type j = 0; j < b_nc; j++)
     {
       for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
 	{
-	  OCTAVE_QUIT;
+	  octave_quit ();
 	  octave_idx_type r = p [b.ridx (i)];
 	  X [r] = b.data (i);
 	  a.xridx(nz++) = p [b.ridx (i)];
 	}
       sort.sort (ri + a.xcidx (j), nz - a.xcidx (j));
       for (octave_idx_type i = a.cidx (j); i < nz; i++)
 	{
-	  OCTAVE_QUIT;
+	  octave_quit ();
 	  a.xdata (i) = X [a.xridx (i)]; 
 	}
       a.xcidx(j+1) = nz;
     }
 }
 
 #if !defined (CXX_NEW_FRIEND_TEMPLATE_DECL)
 static void
diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,8 +1,33 @@
+2010-01-20  Jaroslav Hajek  <highegg@gmail.com>
+
+	* data.cc: Substitute OCTAVE_QUIT -> octave_quit ().
+	* input.cc: Ditto.
+	* ls-mat-ascii.cc: Ditto.
+	* oct-stream.cc: Ditto.
+	* ov-base-int.cc: Ditto.
+	* ov-base-sparse.cc: Ditto.
+	* ov-bool-sparse.cc: Ditto.
+	* ov-cell.cc: Ditto.
+	* ov-cx-sparse.cc: Ditto.
+	* ov-flt-re-mat.cc: Ditto.
+	* ov-re-mat.cc: Ditto.
+	* ov-re-sparse.cc: Ditto.
+	* pr-output.cc: Ditto.
+	* pt-eval.cc: Ditto.
+	* pt-mat.cc: Ditto.
+	* sighandlers.cc: Ditto.
+	* sparse-xdiv.cc: Ditto.
+	* sparse-xpow.cc: Ditto.
+	* toplev.cc: Ditto.
+	* utils.cc: Ditto.
+	* xdiv.cc: Ditto.
+	* xpow.cc: Ditto.
+
 2010-01-20  Jaroslav Hajek  <highegg@gmail.com>
 
 	* DLD-FUNCTIONS/bsxfun.cc: New tests.
 
 2010-01-20  David Bateman  <dbateman@free.fr>
 
 	* graphics.h.in (string_array_property): New property.
 	(axes::properties): Use it here for the linestyleorder property.
diff --git a/src/data.cc b/src/data.cc
--- a/src/data.cc
+++ b/src/data.cc
@@ -197,17 +197,17 @@ map_d_m (d_dd_fcn f, double x, const NDA
   double *r_data = retval.fortran_vec ();
 
   const double *y_data = y.data ();
 
   octave_idx_type nel = y.numel ();
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
-      OCTAVE_QUIT;
+      octave_quit ();
       r_data[i] = f (x, y_data[i]);
     }
 
   return retval;
 }
 
 static FloatNDArray
 map_f_fm (f_ff_fcn f, float x, const FloatNDArray& y)
@@ -216,17 +216,17 @@ map_f_fm (f_ff_fcn f, float x, const Flo
   float *r_data = retval.fortran_vec ();
 
   const float *y_data = y.data ();
 
   octave_idx_type nel = y.numel ();
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
-      OCTAVE_QUIT;
+      octave_quit ();
       r_data[i] = f (x, y_data[i]);
     }
 
   return retval;
 }
 
 static NDArray
 map_m_d (d_dd_fcn f, const NDArray& x, double y)
@@ -235,17 +235,17 @@ map_m_d (d_dd_fcn f, const NDArray& x, d
   double *r_data = retval.fortran_vec ();
 
   const double *x_data = x.data ();
 
   octave_idx_type nel = x.numel ();
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
-      OCTAVE_QUIT;
+      octave_quit ();
       r_data[i] = f (x_data[i], y);
     }
 
   return retval;
 }
 
 static FloatNDArray
 map_fm_f (f_ff_fcn f, const FloatNDArray& x, float y)
@@ -254,17 +254,17 @@ map_fm_f (f_ff_fcn f, const FloatNDArray
   float *r_data = retval.fortran_vec ();
 
   const float *x_data = x.data ();
 
   octave_idx_type nel = x.numel ();
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
-      OCTAVE_QUIT;
+      octave_quit ();
       r_data[i] = f (x_data[i], y);
     }
 
   return retval;
 }
 
 static NDArray
 map_m_m (d_dd_fcn f, const NDArray& x, const NDArray& y)
@@ -276,17 +276,17 @@ map_m_m (d_dd_fcn f, const NDArray& x, c
 
   const double *x_data = x.data ();
   const double *y_data = y.data ();
 
   octave_idx_type nel = x.numel ();
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
-      OCTAVE_QUIT;
+      octave_quit ();
       r_data[i] = f (x_data[i], y_data[i]);
     }
 
   return retval;
 }
 
 static FloatNDArray
 map_fm_fm (f_ff_fcn f, const FloatNDArray& x, const FloatNDArray& y)
@@ -298,17 +298,17 @@ map_fm_fm (f_ff_fcn f, const FloatNDArra
 
   const float *x_data = x.data ();
   const float *y_data = y.data ();
 
   octave_idx_type nel = x.numel ();
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
-      OCTAVE_QUIT;
+      octave_quit ();
       r_data[i] = f (x_data[i], y_data[i]);
     }
 
   return retval;
 }
 
 static SparseMatrix
 map_d_s (d_dd_fcn f, double x, const SparseMatrix& y)
@@ -320,34 +320,34 @@ map_d_s (d_dd_fcn f, double x, const Spa
 
   if (f_zero != 0)
     {
       retval = SparseMatrix (nr, nc, f_zero);
 
       for (octave_idx_type j = 0; j < nc; j++)
 	for (octave_idx_type i = y.cidx (j); i < y.cidx (j+1); i++)
 	  {
-	    OCTAVE_QUIT;
+	    octave_quit ();
 	    retval.data (y.ridx(i) + j * nr) = f (x, y.data (i));
 	  } 
 
       retval.maybe_compress (true);
     }
   else
     {
       octave_idx_type nz = y.nnz ();
       retval = SparseMatrix (nr, nc, nz);
       octave_idx_type ii = 0;
       retval.cidx (ii) = 0;
 
       for (octave_idx_type j = 0; j < nc; j++)
 	{
 	  for (octave_idx_type i = y.cidx (j); i < y.cidx (j+1); i++)
 	    {
-	      OCTAVE_QUIT;
+	      octave_quit ();
 	      double val = f (x, y.data (i));
 
 	      if (val != 0.0)
 		{
 		  retval.data (ii) = val;
 		  retval.ridx (ii++) = y.ridx (i);
 		}
 	    } 
@@ -370,34 +370,34 @@ map_s_d (d_dd_fcn f, const SparseMatrix&
 
   if (f_zero != 0)
     {
       retval = SparseMatrix (nr, nc, f_zero);
 
       for (octave_idx_type j = 0; j < nc; j++)
 	for (octave_idx_type i = x.cidx (j); i < x.cidx (j+1); i++)
 	  {
-	    OCTAVE_QUIT;
+	    octave_quit ();
 	    retval.data (x.ridx(i) + j * nr) = f (x.data (i), y);
 	  } 
 
       retval.maybe_compress (true);
     }
   else
     {
       octave_idx_type nz = x.nnz ();
       retval = SparseMatrix (nr, nc, nz);
       octave_idx_type ii = 0;
       retval.cidx (ii) = 0;
 
       for (octave_idx_type j = 0; j < nc; j++)
 	{
 	  for (octave_idx_type i = x.cidx (j); i < x.cidx (j+1); i++)
 	    {
-	      OCTAVE_QUIT;
+	      octave_quit ();
 	      double val = f (x.data (i), y);
 
 	      if (val != 0.0)
 		{
 		  retval.data (ii) = val;
 		  retval.ridx (ii++) = x.ridx (i);
 		}
 	    } 
@@ -428,17 +428,17 @@ map_s_s (d_dd_fcn f, const SparseMatrix&
     {
       retval = SparseMatrix (nr, nc, f_zero);
       octave_idx_type k1 = 0, k2 = 0;
 
       for (octave_idx_type j = 0; j < nc; j++)
 	{
 	  while (k1 < x.cidx(j+1) && k2 < y.cidx(j+1))
 	    {
-	      OCTAVE_QUIT;
+	      octave_quit ();
 	      if (k1 >= x.cidx(j+1))
 		{
 		  retval.data (y.ridx(k2) + j * nr) = f (0.0, y.data (k2));
 		  k2++;
 		}
 	      else if (k2 >= y.cidx(j+1))
 		{
 		  retval.data (x.ridx(k1) + j * nr) = f (x.data (k1), 0.0);
@@ -478,17 +478,17 @@ map_s_s (d_dd_fcn f, const SparseMatrix&
       octave_idx_type ii = 0;
       retval.cidx (ii) = 0;
       octave_idx_type k1 = 0, k2 = 0;
 
       for (octave_idx_type j = 0; j < nc; j++)
 	{
 	  while (k1 < x.cidx(j+1) && k2 < y.cidx(j+1))
 	    {
-	      OCTAVE_QUIT;
+	      octave_quit ();
 	      double val;
 	      octave_idx_type r;
 	      if (k1 >= x.cidx(j+1))
 		{
 		  r = y.ridx (k2);
 		  val = f (0.0, y.data (k2++));
 		}
 	      else if (k2 >= y.cidx(j+1))
@@ -1884,17 +1884,17 @@ omitted, it defaults to the first non-si
 #define SINGLE_TYPE_CONCAT(TYPE, EXTRACTOR) \
   do \
     { \
       int dv_len = dv.length (); \
       Array<octave_idx_type> ra_idx (dv_len > 1 ? dv_len : 2, 0); \
       \
       for (int j = 1; j < n_args; j++) \
 	{ \
-	  OCTAVE_QUIT; \
+	  octave_quit (); \
 	  \
 	  TYPE ra = args(j).EXTRACTOR ();	\
 	  \
 	  if (! error_state) \
 	    { \
 	      result.insert (ra, ra_idx); \
 	      \
 	      if (error_state) \
diff --git a/src/input.cc b/src/input.cc
--- a/src/input.cc
+++ b/src/input.cc
@@ -193,17 +193,17 @@ do_input_echo (const std::string& input_
 	    octave_stdout << "\n";
 	}
     }
 }
 
 std::string
 gnu_readline (const std::string& s, bool force_readline)
 {
-  OCTAVE_QUIT;
+  octave_quit ();
 
   std::string retval;
 
   if (line_editing || force_readline)
     {
       bool eof;
 
       retval = command_editor::readline (s, eof);
@@ -253,17 +253,17 @@ interactive_input (const std::string& s,
     }
 
   return gnu_readline (s, force_readline);
 }
 
 static std::string
 octave_gets (void)
 {
-  OCTAVE_QUIT;
+  octave_quit ();
 
   std::string retval;
 
   bool history_skip_auto_repeated_debugging_command = false;
 
   if ((interactive || forced_interactive)
       && (! (reading_fcn_file
 	     || reading_classdef_file
@@ -329,17 +329,17 @@ octave_gets (void)
   return retval;
 }
 
 // Read a line from the input stream.
 
 static std::string
 get_user_input (void)
 {
-  OCTAVE_QUIT;
+  octave_quit ();
 
   std::string retval;
 
   if (get_input_from_eval_string)
     {
       if (input_from_eval_string_pending)
 	{
 	  input_from_eval_string_pending = false;
@@ -766,17 +766,17 @@ get_debug_input (const std::string& prom
               if (octave_completion_matches_called)
                 octave_completion_matches_called = false;
             }
 
           // Unmark forced variables.
           // Restore previous value of global_command.
           frame.run_top (2);
 
-          OCTAVE_QUIT;
+          octave_quit ();
         }
     }
   else
     warning ("invalid attempt to debug script read from stdin");
 }
 
 // If the user simply hits return, this will produce an empty matrix.
 
diff --git a/src/ls-mat-ascii.cc b/src/ls-mat-ascii.cc
--- a/src/ls-mat-ascii.cc
+++ b/src/ls-mat-ascii.cc
@@ -113,17 +113,17 @@ get_lines_and_columns (std::istream& is,
 
   int file_line_number = 0;
 
   nr = 0;
   nc = 0;
 
   while (is && ! error_state)
     {
-      OCTAVE_QUIT;
+      octave_quit ();
 
       std::string buf = get_mat_data_input_line (is);
 
       file_line_number++;
 
       size_t beg = buf.find_first_not_of (", \t");
 
       // If we see a CR as the last character in the buffer, we had a
@@ -230,17 +230,17 @@ read_mat_ascii_data (std::istream& is, c
     {
       octave_idx_type nr = 0;
       octave_idx_type nc = 0;
 
       int total_count = 0;
 
       get_lines_and_columns (is, filename, nr, nc);
 
-      OCTAVE_QUIT;
+      octave_quit ();
 
       if (! error_state && nr > 0 && nc > 0)
 	{
 	  Matrix tmp (nr, nc);
 
 	  if (nr < 1 || nc < 1)
 	    is.clear (std::ios::badbit);
 	  else
@@ -249,17 +249,17 @@ read_mat_ascii_data (std::istream& is, c
 	      for (octave_idx_type i = 0; i < nr; i++)
 		{
 		  std::string buf = get_mat_data_input_line (is);
 
 		  std::istringstream tmp_stream (buf);
 
 		  for (octave_idx_type j = 0; j < nc; j++)
 		    {
-		      OCTAVE_QUIT;
+		      octave_quit ();
 
 		      d = octave_read_value<double> (tmp_stream);
 
 		      if (tmp_stream || tmp_stream.eof ())
 			{
 			  tmp.elem (i, j) = d;
 			  total_count++;
 
diff --git a/src/oct-stream.cc b/src/oct-stream.cc
--- a/src/oct-stream.cc
+++ b/src/oct-stream.cc
@@ -1801,17 +1801,17 @@ octave_base_stream::do_scanf (scanf_form
       std::istream& is = *isp;
 
       const scanf_format_elt *elt = fmt_list.first ();
 
       std::ios::fmtflags flags = is.flags ();
 
       for (;;)
 	{
-	  OCTAVE_QUIT;
+	  octave_quit ();
 
 	  if (elt)
 	    {
 	      if (max_conv > 0 && conversion_count == max_conv)
 		{
 		  if (all_char_conv && one_elt_size_spec)
 		    {
 		      final_nr = 1;
@@ -2618,17 +2618,17 @@ octave_base_stream::do_printf (printf_fo
 
       printf_value_cache val_cache (args, who);
 
       if (error_state)
 	return retval;
 
       for (;;)
 	{
-	  OCTAVE_QUIT;
+	  octave_quit ();
 
 	  if (elt)
 	    {
 	      // NSA is the number of `star' args to convert.
 
 	      int nsa = (elt->fw < 0) + (elt->prec < 0);
 
 	      int sa_1 = 0;
diff --git a/src/ov-base-int.cc b/src/ov-base-int.cc
--- a/src/ov-base-int.cc
+++ b/src/ov-base-int.cc
@@ -138,17 +138,17 @@ octave_base_int_matrix<T>::convert_to_st
   octave_idx_type nel = dv.numel ();
 
   charNDArray chm (dv);
 
   bool warned = false;
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
-      OCTAVE_QUIT;
+      octave_quit ();
 
       typename T::element_type tmp = this->matrix(i);
 
       typedef typename T::element_type::val_type val_type;
 
       val_type ival = tmp.value ();
 
       static const bool is_signed = std::numeric_limits<val_type>::is_signed;
diff --git a/src/ov-base-sparse.cc b/src/ov-base-sparse.cc
--- a/src/ov-base-sparse.cc
+++ b/src/ov-base-sparse.cc
@@ -292,17 +292,17 @@ octave_base_sparse<T>::print_raw (std::o
 
   // add one to the printed indices to go from
   //  zero-based to one-based arrays
 
   if (nz != 0)
     {
       for (octave_idx_type j = 0; j < nc; j++)
 	{
-	  OCTAVE_QUIT;
+	  octave_quit ();
 
 	  // FIXME -- is there an easy way to get the max row
 	  // and column indices so we can set the width appropriately
 	  // and line up the columns here?  Similarly, we should look
 	  // at all the nonzero values and display them with the same
 	  // formatting rules that apply to columns of a matrix.
 
 	  for (octave_idx_type i = matrix.cidx(j); i < matrix.cidx(j+1); i++)
diff --git a/src/ov-bool-sparse.cc b/src/ov-bool-sparse.cc
--- a/src/ov-bool-sparse.cc
+++ b/src/ov-bool-sparse.cc
@@ -232,24 +232,24 @@ octave_sparse_bool_matrix::save_binary (
   
   itmp= nz;
   os.write (reinterpret_cast<char *> (&itmp), 4);
 
   // add one to the printed indices to go from
   // zero-based to one-based arrays
   for (int i = 0; i < nc+1; i++)  
     {
-      OCTAVE_QUIT;
+      octave_quit ();
       itmp = matrix.cidx(i);
       os.write (reinterpret_cast<char *> (&itmp), 4);
     }
 
   for (int i = 0; i < nz; i++) 
     {
-      OCTAVE_QUIT;
+      octave_quit ();
       itmp = matrix.ridx(i); 
       os.write (reinterpret_cast<char *> (&itmp), 4);
     }
 
   OCTAVE_LOCAL_BUFFER (char, htmp, nz);
 
   for (int i = 0; i < nz; i++)
     htmp[i] = (matrix.data (i) ? 1 : 0);
@@ -290,27 +290,27 @@ octave_sparse_bool_matrix::load_binary (
     }
 
   SparseBoolMatrix m (static_cast<octave_idx_type> (nr),
 		      static_cast<octave_idx_type> (nc),
 		      static_cast<octave_idx_type> (nz));
 
   for (int i = 0; i < nc+1; i++) 
     {
-      OCTAVE_QUIT;
+      octave_quit ();
       if (! is.read (reinterpret_cast<char *> (&tmp), 4))
 	return false;
       if (swap)
 	swap_bytes<4> (&tmp);
       m.cidx(i) = tmp;
     }
 
   for (int i = 0; i < nz; i++) 
     {
-      OCTAVE_QUIT;
+      octave_quit ();
       if (! is.read (reinterpret_cast<char *> (&tmp), 4))
 	return false;
       if (swap)
 	swap_bytes<4> (&tmp);
       m.ridx(i) = tmp;
     }
 
   if (error_state || ! is)
diff --git a/src/ov-cell.cc b/src/ov-cell.cc
--- a/src/ov-cell.cc
+++ b/src/ov-cell.cc
@@ -654,17 +654,17 @@ octave_cell::print_raw (std::ostream& os
 	  newline (os);
 
 	  increment_indent_level ();
 
 	  for (octave_idx_type j = 0; j < nc; j++)
 	    {
 	      for (octave_idx_type i = 0; i < nr; i++)
 		{
-		  OCTAVE_QUIT;
+		  octave_quit ();
 
 		  std::ostringstream buf;
 		  buf << "[" << i+1 << "," << j+1 << "]";
 
 		  octave_value val = matrix(i,j);
 
 		  val.print_with_name (os, buf.str ());
 		}
diff --git a/src/ov-cx-sparse.cc b/src/ov-cx-sparse.cc
--- a/src/ov-cx-sparse.cc
+++ b/src/ov-cx-sparse.cc
@@ -288,24 +288,24 @@ octave_sparse_complex_matrix::save_binar
       if (matrix.all_integers (max_val, min_val))
 	st = get_save_type (max_val, min_val);
     }
 
   // add one to the printed indices to go from
   // zero-based to one-based arrays
    for (int i = 0; i < nc+1; i++)  
      {
-       OCTAVE_QUIT;
+       octave_quit ();
        itmp = matrix.cidx(i);
        os.write (reinterpret_cast<char *> (&itmp), 4);
      }
 
    for (int i = 0; i < nz; i++) 
      {
-       OCTAVE_QUIT;
+       octave_quit ();
        itmp = matrix.ridx(i); 
        os.write (reinterpret_cast<char *> (&itmp), 4);
      }
 
    write_doubles (os, reinterpret_cast<const double *> (matrix.data()), st, 2 * nz);
 
   return true;
 }
@@ -343,27 +343,27 @@ octave_sparse_complex_matrix::load_binar
     }
 
   SparseComplexMatrix m (static_cast<octave_idx_type> (nr),
 			 static_cast<octave_idx_type> (nc),
 			 static_cast<octave_idx_type> (nz));
 
   for (int i = 0; i < nc+1; i++) 
     {
-      OCTAVE_QUIT;
+      octave_quit ();
       if (! is.read (reinterpret_cast<char *> (&tmp), 4))
 	return false;
       if (swap)
 	swap_bytes<4> (&tmp);
       m.cidx(i) = tmp;
     }
 
   for (int i = 0; i < nz; i++) 
     {
-      OCTAVE_QUIT;
+      octave_quit ();
       if (! is.read (reinterpret_cast<char *> (&tmp), 4))
 	return false;
       if (swap)
 	swap_bytes<4> (&tmp);
       m.ridx(i) = tmp;
     }
 
   if (! is.read (reinterpret_cast<char *> (&ctmp), 1))
diff --git a/src/ov-flt-re-mat.cc b/src/ov-flt-re-mat.cc
--- a/src/ov-flt-re-mat.cc
+++ b/src/ov-flt-re-mat.cc
@@ -271,17 +271,17 @@ octave_float_matrix::convert_to_str_inte
   octave_idx_type nel = dv.numel ();
 
   charNDArray chm (dv);
 
   bool warned = false;
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
-      OCTAVE_QUIT;
+      octave_quit ();
 
       float d = matrix (i);
 
       if (xisnan (d))
 	{
 	  ::error ("invalid conversion from NaN to character");
 	  return retval;
 	}
@@ -693,33 +693,33 @@ octave_float_matrix::as_mxArray (void) c
 static octave_value
 do_rc_map (const FloatNDArray& a, FloatComplex (&fcn) (float))
 {
   octave_idx_type n = a.numel ();
   NoAlias<FloatNDArray> rr (a.dims ());
 
   for (octave_idx_type i = 0; i < n; i++)
     {
-      OCTAVE_QUIT;
+      octave_quit ();
 
       FloatComplex tmp = fcn (a(i));
       if (tmp.imag () == 0.0)
         rr(i) = tmp.real ();
       else
         {
           NoAlias<FloatComplexNDArray> rc (a.dims ());
 
           for (octave_idx_type j = 0; j < i; j++)
             rc(j) = rr(j);
 
           rc(i) = tmp;
 
           for (octave_idx_type j = i+1; j < n; j++)
             {
-              OCTAVE_QUIT;
+              octave_quit ();
 
               rc(j) = fcn (a(j));
             }
 
           return new octave_float_complex_matrix (rc);
         }
     }
 
diff --git a/src/ov-re-mat.cc b/src/ov-re-mat.cc
--- a/src/ov-re-mat.cc
+++ b/src/ov-re-mat.cc
@@ -279,17 +279,17 @@ octave_matrix::convert_to_str_internal (
   octave_idx_type nel = dv.numel ();
 
   charNDArray chm (dv);
 
   bool warned = false;
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
-      OCTAVE_QUIT;
+      octave_quit ();
 
       double d = matrix (i);
 
       if (xisnan (d))
 	{
 	  ::error ("invalid conversion from NaN to character");
 	  return retval;
 	}
@@ -722,33 +722,33 @@ octave_matrix::as_mxArray (void) const
 static octave_value
 do_rc_map (const NDArray& a, Complex (&fcn) (double))
 {
   octave_idx_type n = a.numel ();
   NoAlias<NDArray> rr (a.dims ());
 
   for (octave_idx_type i = 0; i < n; i++)
     {
-      OCTAVE_QUIT;
+      octave_quit ();
 
       Complex tmp = fcn (a(i));
       if (tmp.imag () == 0.0)
         rr(i) = tmp.real ();
       else
         {
           NoAlias<ComplexNDArray> rc (a.dims ());
 
           for (octave_idx_type j = 0; j < i; j++)
             rc(j) = rr(j);
 
           rc(i) = tmp;
 
           for (octave_idx_type j = i+1; j < n; j++)
             {
-              OCTAVE_QUIT;
+              octave_quit ();
 
               rc(j) = fcn (a(j));
             }
 
           return new octave_complex_matrix (rc);
         }
     }
 
diff --git a/src/ov-re-sparse.cc b/src/ov-re-sparse.cc
--- a/src/ov-re-sparse.cc
+++ b/src/ov-re-sparse.cc
@@ -214,17 +214,17 @@ octave_sparse_matrix::convert_to_str_int
       charNDArray chm (dv, static_cast<char> (0));
 	  
       bool warned = false;
 
       for (octave_idx_type j = 0; j < nc; j++)
 	for (octave_idx_type i = matrix.cidx(j); 
 	     i < matrix.cidx(j+1); i++)
 	  {
-	    OCTAVE_QUIT;
+	    octave_quit ();
 
 	    double d = matrix.data (i);
 
 	      if (xisnan (d))
 		{
 		  ::error ("invalid conversion from NaN to character");
 		  return retval;
 		}
@@ -302,24 +302,24 @@ octave_sparse_matrix::save_binary (std::
       if (matrix.all_integers (max_val, min_val))
 	st = get_save_type (max_val, min_val);
     }
 
   // add one to the printed indices to go from
   // zero-based to one-based arrays
    for (int i = 0; i < nc+1; i++)  
      {
-       OCTAVE_QUIT;
+       octave_quit ();
        itmp = matrix.cidx(i);
        os.write (reinterpret_cast<char *> (&itmp), 4);
      }
 
    for (int i = 0; i < nz; i++) 
      {
-       OCTAVE_QUIT;
+       octave_quit ();
        itmp = matrix.ridx(i); 
        os.write (reinterpret_cast<char *> (&itmp), 4);
      }
 
    write_doubles (os, matrix.data(), st, nz);
 
   return true;
 }
@@ -357,27 +357,27 @@ octave_sparse_matrix::load_binary (std::
     }
 
   SparseMatrix m (static_cast<octave_idx_type> (nr),
 		  static_cast<octave_idx_type> (nc),
 		  static_cast<octave_idx_type> (nz));
 
   for (int i = 0; i < nc+1; i++) 
     {
-      OCTAVE_QUIT;
+      octave_quit ();
       if (! is.read (reinterpret_cast<char *> (&tmp), 4))
 	return false;
       if (swap)
 	swap_bytes<4> (&tmp);
       m.xcidx(i) = tmp;
     }
 
   for (int i = 0; i < nz; i++) 
     {
-      OCTAVE_QUIT;
+      octave_quit ();
       if (! is.read (reinterpret_cast<char *> (&tmp), 4))
 	return false;
       if (swap)
 	swap_bytes<4> (&tmp);
       m.xridx(i) = tmp;
     }
 
   if (! is.read (reinterpret_cast<char *> (&ctmp), 1))
diff --git a/src/pr-output.cc b/src/pr-output.cc
--- a/src/pr-output.cc
+++ b/src/pr-output.cc
@@ -1571,17 +1571,17 @@ octave_print_internal (std::ostream& os,
   if (nr == 0 || nc == 0)
     print_empty_matrix (os, nr, nc, pr_as_read_syntax);
   else if (plus_format && ! pr_as_read_syntax)
     {
       for (octave_idx_type i = 0; i < nr; i++)
 	{
 	  for (octave_idx_type j = 0; j < nc; j++)
 	    {
-	      OCTAVE_QUIT;
+	      octave_quit ();
 
 	      pr_plus_format (os, m(i,j));
 	    }
 
 	  if (i < nr - 1)
 	    os << "\n";
 	}
     }
@@ -1629,17 +1629,17 @@ octave_print_internal (std::ostream& os,
 	    {
 	      octave_idx_type col = 0;
 	      while (col < nc)
 		{
 		  octave_idx_type lim = col + inc < nc ? col + inc : nc;
 
 		  for (octave_idx_type j = col; j < lim; j++)
 		    {
-		      OCTAVE_QUIT;
+		      octave_quit ();
 
 		      if (i == 0 && j == 0)
 			os << "[ ";
 		      else
 			{
 			  if (j > col && j < lim)
 			    os << ", ";
 			  else
@@ -1675,17 +1675,17 @@ octave_print_internal (std::ostream& os,
 				 extra_indent);
 
 	      for (octave_idx_type i = 0; i < nr; i++)
 		{
 		  os << std::setw (extra_indent) << "";
 
 		  for (octave_idx_type j = col; j < lim; j++)
 		    {
-		      OCTAVE_QUIT;
+		      octave_quit ();
 
 		      os << "  ";
 
 		      pr_float (os, m(i,j), fw, scale);
 		    }
 
 		  if (i < nr - 1)
 		    os << "\n";
@@ -1705,17 +1705,17 @@ octave_print_internal (std::ostream& os,
   if (nr == 0 || nc == 0)
     print_empty_matrix (os, nr, nc, pr_as_read_syntax);
   else if (plus_format && ! pr_as_read_syntax)
     {
       for (octave_idx_type i = 0; i < nr; i++)
 	{
 	  for (octave_idx_type j = 0; j < nc; j++)
 	    {
-	      OCTAVE_QUIT;
+	      octave_quit ();
 
 	      pr_plus_format (os, m(i,j));
 	    }
 
 	  if (i < nr - 1)
 	    os << "\n";
 	}
     }
@@ -1763,17 +1763,17 @@ octave_print_internal (std::ostream& os,
 
           octave_idx_type col = 0;
           while (col < nc)
             {
               octave_idx_type lim = col + inc < nc ? col + inc : nc;
 
               for (octave_idx_type j = col; j < lim; j++)
                 {
-                  OCTAVE_QUIT;
+                  octave_quit ();
 
                   if (j == 0)
                     os << "[ ";
                   else
                     {
                       if (j > col && j < lim)
                         os << ", ";
                       else
@@ -1814,17 +1814,17 @@ octave_print_internal (std::ostream& os,
 				 extra_indent);
 
 	      for (octave_idx_type i = 0; i < nr; i++)
 		{
 		  os << std::setw (extra_indent) << "";
 
 		  for (octave_idx_type j = col; j < lim; j++)
 		    {
-		      OCTAVE_QUIT;
+		      octave_quit ();
 
 		      os << "  ";
 
                       if (i == j)
                         pr_float (os, m(i,j), fw, scale);
                       else
                         os << std::setw (zero_fw) << '0';
 
@@ -1856,17 +1856,17 @@ octave_print_internal (std::ostream& os,
           for (int i = 2; i < ndims; i++) \
             m *= dims(i); \
  \
           octave_idx_type nr = dims(0); \
           octave_idx_type nc = dims(1); \
  \
           for (octave_idx_type i = 0; i < m; i++) \
             { \
-	      OCTAVE_QUIT; \
+	      octave_quit (); \
  \
               std::string nm = "ans"; \
  \
               if (m > 1) \
                 { \
                   nm += "(:,:,"; \
  \
 		  std::ostringstream buf; \
@@ -1970,17 +1970,17 @@ octave_print_internal (std::ostream& os,
  if (nr == 0 || nc == 0)
     print_empty_matrix (os, nr, nc, pr_as_read_syntax);
   else if (plus_format && ! pr_as_read_syntax)
     {
       for (octave_idx_type i = 0; i < nr; i++)
 	{
 	  for (octave_idx_type j = 0; j < nc; j++)
 	    {
-	      OCTAVE_QUIT;
+	      octave_quit ();
 
 	      pr_plus_format (os, cm(i,j));
 	    }
 
 	  if (i < nr - 1)
 	    os << "\n";
 	}
     }
@@ -2030,17 +2030,17 @@ octave_print_internal (std::ostream& os,
 	    {
 	      octave_idx_type col = 0;
 	      while (col < nc)
 		{
 		  octave_idx_type lim = col + inc < nc ? col + inc : nc;
 
 		  for (octave_idx_type j = col; j < lim; j++)
 		    {
-		      OCTAVE_QUIT;
+		      octave_quit ();
 
 		      if (i == 0 && j == 0)
 			os << "[ ";
 		      else
 			{
 			  if (j > col && j < lim)
 			    os << ", ";
 			  else
@@ -2076,17 +2076,17 @@ octave_print_internal (std::ostream& os,
 				 extra_indent);
 
 	      for (octave_idx_type i = 0; i < nr; i++)
 		{
 		  os << std::setw (extra_indent) << "";
 
 		  for (octave_idx_type j = col; j < lim; j++)
 		    {
-		      OCTAVE_QUIT;
+		      octave_quit ();
 
 		      os << "  ";
 
 		      pr_complex (os, cm(i,j), r_fw, i_fw, scale);
 		    }
 
 		  if (i < nr - 1) 
 		    os << "\n";
@@ -2106,17 +2106,17 @@ octave_print_internal (std::ostream& os,
  if (nr == 0 || nc == 0)
     print_empty_matrix (os, nr, nc, pr_as_read_syntax);
   else if (plus_format && ! pr_as_read_syntax)
     {
       for (octave_idx_type i = 0; i < nr; i++)
 	{
 	  for (octave_idx_type j = 0; j < nc; j++)
 	    {
-	      OCTAVE_QUIT;
+	      octave_quit ();
 
 	      pr_plus_format (os, cm(i,j));
 	    }
 
 	  if (i < nr - 1)
 	    os << "\n";
 	}
     }
@@ -2166,17 +2166,17 @@ octave_print_internal (std::ostream& os,
 
           octave_idx_type col = 0;
           while (col < nc)
             {
               octave_idx_type lim = col + inc < nc ? col + inc : nc;
 
               for (octave_idx_type j = col; j < lim; j++)
                 {
-                  OCTAVE_QUIT;
+                  octave_quit ();
 
                   if (j == 0)
                     os << "[ ";
                   else
                     {
                       if (j > col && j < lim)
                         os << ", ";
                       else
@@ -2217,17 +2217,17 @@ octave_print_internal (std::ostream& os,
 				 extra_indent);
 
 	      for (octave_idx_type i = 0; i < nr; i++)
 		{
 		  os << std::setw (extra_indent) << "";
 
 		  for (octave_idx_type j = col; j < lim; j++)
 		    {
-		      OCTAVE_QUIT;
+		      octave_quit ();
 
 		      os << "  ";
 
                       if (i == j)
                         pr_complex (os, cm(i,j), r_fw, i_fw, scale);
                       else
                         os << std::setw (zero_fw) << '0';
 		    }
@@ -2250,17 +2250,17 @@ octave_print_internal (std::ostream& os,
   if (nr == 0 || nc == 0)
     print_empty_matrix (os, nr, nc, pr_as_read_syntax);
   else if (plus_format && ! pr_as_read_syntax)
     {
       for (octave_idx_type i = 0; i < nr; i++)
 	{
 	  for (octave_idx_type j = 0; j < nc; j++)
 	    {
-	      OCTAVE_QUIT;
+	      octave_quit ();
 
 	      pr_plus_format (os, m(i,j));
 	    }
 
 	  if (i < nr - 1)
 	    os << "\n";
 	}
     }
@@ -2310,17 +2310,17 @@ octave_print_internal (std::ostream& os,
 
           octave_idx_type col = 0;
           while (col < nc)
             {
               octave_idx_type lim = col + inc < nc ? col + inc : nc;
 
               for (octave_idx_type j = col; j < lim; j++)
                 {
-                  OCTAVE_QUIT;
+                  octave_quit ();
 
                   if (j == 0)
                     os << "[ ";
                   else
                     {
                       if (j > col && j < lim)
                         os << ", ";
                       else
@@ -2352,17 +2352,17 @@ octave_print_internal (std::ostream& os,
 				 extra_indent);
 
 	      for (octave_idx_type i = 0; i < nr; i++)
 		{
 		  os << std::setw (extra_indent) << "";
 
 		  for (octave_idx_type j = col; j < lim; j++)
 		    {
-		      OCTAVE_QUIT;
+		      octave_quit ();
 
 		      os << "  ";
 
                       os << std::setw (fw) << m(i,j);
 		    }
 
 		  if (i < nr - 1)
 		    os << "\n";
@@ -2461,17 +2461,17 @@ octave_print_internal (std::ostream& os,
   double increment = r.inc ();
   double limit = r.limit ();
   octave_idx_type num_elem = r.nelem ();
 
   if (plus_format && ! pr_as_read_syntax)
     {
       for (octave_idx_type i = 0; i < num_elem; i++)
 	{
-	  OCTAVE_QUIT;
+	  octave_quit ();
 
 	  double val = base + i * increment;
 
 	  pr_plus_format (os, val);
 	}
     }
   else
     {
@@ -2534,17 +2534,17 @@ octave_print_internal (std::ostream& os,
 
 	      pr_col_num_header (os, total_width, max_width, lim, col,
 				 extra_indent);
 
 	      os << std::setw (extra_indent) << "";
 
 	      for (octave_idx_type i = col; i < lim; i++)
 		{
-		  OCTAVE_QUIT;
+		  octave_quit ();
 
 		  double val = base + i * increment;
 
 		  if (i == num_elem - 1)
 		    {
 		      // See the comments in Range::matrix_value.
 
 		      if ((increment > 0 && val > limit)
@@ -2603,17 +2603,17 @@ octave_print_internal (std::ostream& os,
 
       if (pr_as_read_syntax && nstr > 1)
 	os << "[ ";
 
       if (nstr != 0)
 	{
 	  for (octave_idx_type i = 0; i < nstr; i++)
 	    {
-	      OCTAVE_QUIT;
+	      octave_quit ();
 
 	      std::string row = chm.row_as_string (i);
 
 	      if (pr_as_read_syntax)
 		{
 		  os << "\"" << undo_string_escapes (row) << "\"";
 
 		  if (i < nstr - 1)
@@ -2994,17 +2994,17 @@ octave_print_internal_template (std::ost
 	    idx(k) = idx_vector (ra_idx(k));
 
 	  Array2<T> page (nda.index (idx), nr, nc);
 
 	  for (octave_idx_type ii = 0; ii < nr; ii++)
 	    {
 	      for (octave_idx_type jj = 0; jj < nc; jj++)
 		{
-		  OCTAVE_QUIT;
+		  octave_quit ();
 
 		  pr_plus_format (os, page(ii,jj));
 		}
 
 	      if ((ii < nr - 1) || (i < m -1))
 		os << "\n";
 	    }
 
@@ -3104,17 +3104,17 @@ octave_print_internal_template (std::ost
 	    {
 	      if (pr_as_read_syntax)
 		os << "[\n";
 
 	      for (octave_idx_type ii = 0; ii < nr; ii++)
 		{
 		  for (octave_idx_type jj = 0; jj < nc; jj++)
 		    {
-		      OCTAVE_QUIT;
+		      octave_quit ();
 		      os << "  ";
 		      os << typename octave_print_conv<T>::print_conv_type (page(ii,jj));
 		    }
 		  os << "\n";
 		}
 
 	      if (pr_as_read_syntax)
 		os << "]";
@@ -3132,17 +3132,17 @@ octave_print_internal_template (std::ost
 				     extra_indent);
 
 		  for (octave_idx_type ii = 0; ii < n_rows; ii++)
 		    {
 		      os << std::setw (extra_indent) << "";
 		      
 		      for (octave_idx_type jj = col; jj < lim; jj++)
 			{
-			  OCTAVE_QUIT;
+			  octave_quit ();
 			  os << "  ";
 			  pr_int (os, page(ii,jj), fw);
 			}
 		      if ((ii < n_rows - 1) || (i < m -1))
 			os << "\n";
 		    }
 		}
 	    }
diff --git a/src/pt-eval.cc b/src/pt-eval.cc
--- a/src/pt-eval.cc
+++ b/src/pt-eval.cc
@@ -235,17 +235,17 @@ tree_evaluator::visit_decl_init_list (tr
 {
   panic_impossible ();
 }
 
 // Decide if it's time to quit a for or while loop.
 static inline bool
 quit_loop_now (void)
 {
-  OCTAVE_QUIT;
+  octave_quit ();
 
   // Maybe handle `continue N' someday...
 
   if (tree_continue_command::continuing)
     tree_continue_command::continuing--;
 
   bool quit = (error_state
 	       || tree_return_command::returning
@@ -715,17 +715,17 @@ tree_evaluator::visit_statement_list (tr
   if (p != lst.end ())
     {
       while (true)
 	{
 	  tree_statement *elt = *p++;
 
 	  if (elt)
 	    {
-	      OCTAVE_QUIT;
+	      octave_quit ();
 
 	      elt->accept (*this);
 
 	      if (error_state)
 		break;
 
 	      if (tree_break_command::breaking
 		  || tree_continue_command::continuing)
diff --git a/src/pt-mat.cc b/src/pt-mat.cc
--- a/src/pt-mat.cc
+++ b/src/pt-mat.cc
@@ -372,33 +372,33 @@ tm_row_const::tm_row_const_rep::init (co
   any_class = false;
 
   bool first_elem = true;
 
   for (tree_argument_list::const_iterator p = row.begin ();
        p != row.end ();
        p++)
     {
-      OCTAVE_QUIT;
+      octave_quit ();
 
       tree_expression *elt = *p;
 
       octave_value tmp = elt->rvalue1 ();
 
       if (error_state || tmp.is_undefined ())
 	break;
       else
 	{
 	  if (tmp.is_cs_list ())
 	    {
 	      octave_value_list tlst = tmp.list_value ();
 
 	      for (octave_idx_type i = 0; i < tlst.length (); i++)
 		{
-		  OCTAVE_QUIT;
+		  octave_quit ();
 
 		  if (! do_init_element (elt, tlst(i), first_elem))
 		    goto done;
 		}
 	    }
 	  else
 	    {
 	      if (! do_init_element (elt, tmp, first_elem))
@@ -518,17 +518,17 @@ tm_const::init (const tree_matrix& tm)
 
   // Just eval and figure out if what we have is complex or all
   // strings.  We can't check columns until we know that this is a
   // numeric matrix -- collections of strings can have elements of
   // different lengths.
 
   for (tree_matrix::const_iterator p = tm.begin (); p != tm.end (); p++)
     {
-      OCTAVE_QUIT;
+      octave_quit ();
 
       tree_argument_list *elt = *p;
 
       tm_row_const tmp (*elt);
 
       if (tmp && ! tmp.empty ())
 	{
 	  if (all_str && ! tmp.all_strings_p ())
@@ -563,17 +563,17 @@ tm_const::init (const tree_matrix& tm)
       else
 	break;
     }
 
   if (! error_state)
     {
       for (iterator p = begin (); p != end (); p++)
 	{
-	  OCTAVE_QUIT;
+	  octave_quit ();
 
 	  tm_row_const elt = *p;
 
 	  octave_idx_type this_elt_nr = elt.rows ();
 	  octave_idx_type this_elt_nc = elt.cols ();
 
 	  std::string this_elt_class_nm = elt.class_name ();
 
@@ -671,33 +671,33 @@ tree_matrix::~tree_matrix (void)
     }
 }
 
 bool
 tree_matrix::has_magic_end (void) const
 {
   for (const_iterator p = begin (); p != end (); p++)
     {
-      OCTAVE_QUIT;
+      octave_quit ();
 
       tree_argument_list *elt = *p;
 
       if (elt && elt->has_magic_end ())
 	return true;
     }
 
   return false;
 }
 
 bool
 tree_matrix::all_elements_are_constant (void) const
 {
   for (const_iterator p = begin (); p != end (); p++)
     {
-      OCTAVE_QUIT;
+      octave_quit ();
 
       tree_argument_list *elt = *p;
 
       if (! elt->all_elements_are_constant ())
 	return false;
     }
 
   return true;
@@ -734,17 +734,17 @@ single_type_concat (TYPE& result,
   for (tm_const::iterator p = tmp.begin (); p != tmp.end (); p++)
     {
       tm_row_const row = *p;
 
       for (tm_row_const::iterator q = row.begin ();
            q != row.end ();
            q++)
         {
-          OCTAVE_QUIT;
+          octave_quit ();
 
           TYPE ra = octave_value_extract<TYPE> (*q);
 
           if (! error_state)
             {
               result.insert (ra, r, c);
 
               if (! error_state)
@@ -821,17 +821,17 @@ tree_matrix::rvalue1 (int)
 
       if (any_class_p)
 	{
 	  octave_value_list tmp3 (tmp.length (), octave_value ());
 
 	  int j = 0;
 	  for (tm_const::iterator p = tmp.begin (); p != tmp.end (); p++)
 	    {
-	      OCTAVE_QUIT;
+	      octave_quit ();
 
 	      tm_row_const row = *p;
 
 	      if (row.length () == 1)
 		tmp3 (j++) = *(row.begin ());
 	      else
 		{
 		  octave_value_list tmp1 (row.length (), octave_value ());
@@ -973,24 +973,24 @@ tree_matrix::rvalue1 (int)
 		ctmp = octave_sparse_matrix ().resize (dv); 
 	      else
 		ctmp = octave_sparse_complex_matrix ().resize (dv); 
 	    }
 	  else
 	    {
 	      for (tm_const::iterator p = tmp.begin (); p != tmp.end (); p++)
 		{
-		  OCTAVE_QUIT;
+		  octave_quit ();
 
 		  tm_row_const row = *p;
 
 		  for (tm_row_const::iterator q = row.begin (); 
 		       q != row.end (); q++)
 		    {
-		      OCTAVE_QUIT;
+		      octave_quit ();
 
 		      ctmp = *q;
 
 		      if (! ctmp.all_zero_dims ())
 			goto found_non_empty;
 		    }
 		}
 
@@ -1007,25 +1007,25 @@ tree_matrix::rvalue1 (int)
 	      // Now, extract the values from the individual elements and
 	      // insert them in the result matrix.
 
 	      int dv_len = dv.length ();
 	      Array<octave_idx_type> ra_idx (dv_len > 1 ? dv_len : 2, 0);
 
 	      for (tm_const::iterator p = tmp.begin (); p != tmp.end (); p++)
 		{
-		  OCTAVE_QUIT;
+		  octave_quit ();
 
 		  tm_row_const row = *p;
 
 		  for (tm_row_const::iterator q = row.begin ();
 		       q != row.end ();
 		       q++)
 		    {
-		      OCTAVE_QUIT;
+		      octave_quit ();
 
 		      octave_value elt = *q;
 
 		      ctmp = do_cat_op (ctmp, elt, ra_idx);
 
 		      if (error_state)
 			goto done;
 
diff --git a/src/sighandlers.cc b/src/sighandlers.cc
--- a/src/sighandlers.cc
+++ b/src/sighandlers.cc
@@ -96,17 +96,17 @@ static bool Vsigterm_dumps_octave_core =
 #else
 #define MAYBE_ACK_SIGNAL(sig) \
   do { } while (0)
 #endif
 
 // List of signals we have caught since last call to octave_signal_handler.
 static bool octave_signals_caught[NSIG];
 
-// Called from OCTAVE_QUIT to actually do something about the signals
+// Called from octave_quit () to actually do something about the signals
 // we have caught.
 
 void
 octave_signal_handler (void)
 {
   // The list of signals is relatively short, so we will just go
   // linearly through the list.
 
diff --git a/src/sparse-xdiv.cc b/src/sparse-xdiv.cc
--- a/src/sparse-xdiv.cc
+++ b/src/sparse-xdiv.cc
@@ -308,17 +308,17 @@ RT do_rightdiv_sm_dm (const SM& a, const
   RT r (a_nr, nc, nz);
 
   typedef typename DM::element_type DM_elt_type;
   const DM_elt_type zero = DM_elt_type ();
 
   octave_idx_type k_result = 0;
   for (octave_idx_type j = 0; j < nc; ++j)
     {
-      OCTAVE_QUIT;
+      octave_quit ();
       const DM_elt_type s = d.dgelem (j);
       const octave_idx_type colend = a.cidx (j+1);
       r.xcidx (j) = k_result;
       if (s != zero)
 	for (octave_idx_type k = a.cidx (j); k < colend; ++k)
 	  {
 	    r.xdata (k_result) = a.data (k) / s;
 	    r.xridx (k_result) = a.ridx (k);
@@ -381,17 +381,17 @@ x_el_div (double a, const SparseMatrix& 
     result = Matrix (nr, nc, octave_Inf);
   else
     result = Matrix (nr, nc, -octave_Inf);
 
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
       {
-	OCTAVE_QUIT;
+	octave_quit ();
 	result.elem (b.ridx(i), j) = a / b.data (i);
       }
 
   return result;
 }
 
 ComplexMatrix
 x_el_div (double a, const SparseComplexMatrix& b)
@@ -399,17 +399,17 @@ x_el_div (double a, const SparseComplexM
   octave_idx_type nr = b.rows ();
   octave_idx_type nc = b.cols ();
 
   ComplexMatrix  result (nr, nc, Complex(octave_NaN, octave_NaN));
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
       {
-	OCTAVE_QUIT;
+	octave_quit ();
 	result.elem (b.ridx(i), j) = a / b.data (i);
       }
 
   return result;
 }
 
 ComplexMatrix
 x_el_div (const Complex a, const SparseMatrix& b)
@@ -417,17 +417,17 @@ x_el_div (const Complex a, const SparseM
   octave_idx_type nr = b.rows ();
   octave_idx_type nc = b.cols ();
 
   ComplexMatrix result (nr, nc, (a / 0.0));
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
       {
-	OCTAVE_QUIT;
+	octave_quit ();
 	result.elem (b.ridx(i), j) = a / b.data (i);
       }
 
   return result;
 }
 
 ComplexMatrix
 x_el_div (const Complex a, const SparseComplexMatrix& b)
@@ -435,17 +435,17 @@ x_el_div (const Complex a, const SparseC
   octave_idx_type nr = b.rows ();
   octave_idx_type nc = b.cols ();
 
   ComplexMatrix result (nr, nc, (a / 0.0));
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
       {
-	OCTAVE_QUIT;
+	octave_quit ();
 	result.elem (b.ridx(i), j) = a / b.data (i);
       }
 
   return result;
 }
 
 // Left division functions.  X \ Y = inv(X) * Y
 //
@@ -575,17 +575,17 @@ RT do_leftdiv_dm_sm (const DM& d, const 
   RT r (nr, a_nc, nz);
 
   typedef typename DM::element_type DM_elt_type;
   const DM_elt_type zero = DM_elt_type ();
 
   octave_idx_type k_result = 0;
   for (octave_idx_type j = 0; j < a_nc; ++j)
     {
-      OCTAVE_QUIT;
+      octave_quit ();
       const octave_idx_type colend = a.cidx (j+1);
       r.xcidx (j) = k_result;
       for (octave_idx_type k = a.cidx (j); k < colend; ++k)
 	{
 	  const octave_idx_type i = a.ridx (k);
 	  if (i < nr)
 	    {
 	      const DM_elt_type s = d.dgelem (i);
diff --git a/src/sparse-xpow.cc b/src/sparse-xpow.cc
--- a/src/sparse-xpow.cc
+++ b/src/sparse-xpow.cc
@@ -244,32 +244,32 @@ elem_xpow (double a, const SparseMatrix&
     {
       Complex atmp (a);
       ComplexMatrix result (nr, nc);
 
       for (octave_idx_type j = 0; j < nc; j++)
 	{
 	  for (octave_idx_type i = 0; i < nr; i++)
 	    {
-	      OCTAVE_QUIT;
+	      octave_quit ();
 	      result (i, j) = std::pow (atmp, b(i,j));
 	    }
 	}
 
       retval = result;
     }
   else
     {
       Matrix result (nr, nc);
 
       for (octave_idx_type j = 0; j < nc; j++)
 	{
 	  for (octave_idx_type i = 0; i < nr; i++)
 	    {
-	      OCTAVE_QUIT;
+	      octave_quit ();
 	      result (i, j) = std::pow (a, b(i,j));
 	    }
 	}
 
       retval = result;
     }
 
   return retval;
@@ -284,17 +284,17 @@ elem_xpow (double a, const SparseComplex
 
   Complex atmp (a);
   ComplexMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     {
       for (octave_idx_type i = 0; i < nr; i++)
 	{
-	  OCTAVE_QUIT;
+	  octave_quit ();
 	  result (i, j) = std::pow (atmp, b(i,j));
 	}
     }
 
   return result;
 }
 
 // -*- 3 -*-
@@ -320,46 +320,46 @@ elem_xpow (const SparseMatrix& a, double
 
 	  // FIXME -- avoid apparent GNU libm bug by
 	  // converting A and B to complex instead of just A.
 	  Complex btmp (b);
 
 	  for (octave_idx_type j = 0; j < nc; j++)
 	    for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
 	      {
-		OCTAVE_QUIT;
+		octave_quit ();
 	      
 		Complex atmp (a.data (i));
 		
 		result (a.ridx(i), j) = std::pow (atmp, btmp);
 	      }
 
 	  retval = octave_value (result);
 	}
       else
 	{
 	  Matrix result (nr, nc, (std::pow (0.0, b)));
 
 	  for (octave_idx_type j = 0; j < nc; j++)
 	    for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
 	      {
-		OCTAVE_QUIT;
+		octave_quit ();
 		result (a.ridx(i), j) = std::pow (a.data (i), b);
 	      }
 
 	  retval = octave_value (result);
 	}
     }
   else if (static_cast<int> (b) != b && a.any_element_is_negative ())
     {
       SparseComplexMatrix result (a);
 
       for (octave_idx_type i = 0; i < nz; i++)
 	{
-	  OCTAVE_QUIT;
+	  octave_quit ();
 
 	  // FIXME -- avoid apparent GNU libm bug by
 	  // converting A and B to complex instead of just A.
 
 	  Complex atmp (a.data (i));
 	  Complex btmp (b);
 
 	  result.data (i) = std::pow (atmp, btmp);
@@ -370,17 +370,17 @@ elem_xpow (const SparseMatrix& a, double
       retval = result;
     }
   else
     {
       SparseMatrix result (a);
 
       for (octave_idx_type i = 0; i < nz; i++)
 	{
-	  OCTAVE_QUIT;
+	  octave_quit ();
 	  result.data (i) = std::pow (a.data (i), b);
 	}
 
       result.maybe_compress (true);
 
       retval = result;
     }
 
@@ -430,33 +430,33 @@ done:
   if (convert_to_complex)
     {
       SparseComplexMatrix complex_result (nr, nc, Complex(1.0, 0.0));
 
       for (octave_idx_type j = 0; j < nc; j++)
 	{
 	  for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
 	    {
-	      OCTAVE_QUIT;
+	      octave_quit ();
 	      complex_result.xelem(a.ridx(i), j) =
 		std::pow (Complex(a.data(i)), Complex(b(a.ridx(i), j)));
 	    }
 	}
       complex_result.maybe_compress (true);
       retval = complex_result;
     }
   else
     {
       SparseMatrix result (nr, nc, 1.0);
 
       for (octave_idx_type j = 0; j < nc; j++)
 	{
 	  for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
 	    {
-	      OCTAVE_QUIT;
+	      octave_quit ();
 	      result.xelem(a.ridx(i), j) = std::pow (a.data(i), 
 						     b (a.ridx(i), j));
 	    }
 	}
       result.maybe_compress (true);
       retval = result;
     }
 
@@ -474,17 +474,17 @@ elem_xpow (const SparseMatrix& a, const 
     retval = octave_value (NDArray (a.dims (), 1));
   else
     {
       octave_idx_type nz = a.nzmax ();
       SparseComplexMatrix result (a);
       
       for (octave_idx_type i = 0; i < nz; i++)
 	{
-	  OCTAVE_QUIT;
+	  octave_quit ();
 	  result.data (i) = std::pow (Complex (a.data (i)), b);
 	}
   
       result.maybe_compress (true);
 
       retval = result;
     }
 
@@ -507,17 +507,17 @@ elem_xpow (const SparseMatrix& a, const 
       return octave_value ();
     }
 
   SparseComplexMatrix result (nr, nc, Complex(1.0, 0.0));
   for (octave_idx_type j = 0; j < nc; j++)
     {
       for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
 	{
-	  OCTAVE_QUIT;
+	  octave_quit ();
 	  result.xelem(a.ridx(i), j) = std::pow (a.data(i), b (a.ridx(i), j));
 	}
     }
 
   result.maybe_compress (true);
 
   return result;
 }
@@ -530,17 +530,17 @@ elem_xpow (const Complex& a, const Spars
   octave_idx_type nc = b.cols ();
 
   ComplexMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     {
       for (octave_idx_type i = 0; i < nr; i++)
 	{
-	  OCTAVE_QUIT;
+	  octave_quit ();
 	  double btmp = b (i, j);
 	  if (xisint (btmp))
 	    result (i, j) = std::pow (a, static_cast<int> (btmp));
 	  else
 	    result (i, j) = std::pow (a, btmp);
 	}
     }
 
@@ -553,17 +553,17 @@ elem_xpow (const Complex& a, const Spars
 {
   octave_idx_type nr = b.rows ();
   octave_idx_type nc = b.cols ();
 
   ComplexMatrix result (nr, nc);
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
-	OCTAVE_QUIT;
+	octave_quit ();
 	result (i, j) = std::pow (a, b (i, j));
       }
 
   return result;
 }
 
 // -*- 9 -*-
 octave_value
@@ -578,52 +578,52 @@ elem_xpow (const SparseComplexMatrix& a,
 
       ComplexMatrix result (nr, nc, Complex (std::pow (0.0, b)));
 
       if (xisint (b))
 	{
 	  for (octave_idx_type j = 0; j < nc; j++)
 	    for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
 	      {
-		OCTAVE_QUIT;
+		octave_quit ();
 		result (a.ridx(i), j) = 
 		  std::pow (a.data (i), static_cast<int> (b));
 	      }
 	}
       else
 	{
 	  for (octave_idx_type j = 0; j < nc; j++)
 	    for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
 	      {
-		OCTAVE_QUIT;
+		octave_quit ();
 		result (a.ridx(i), j) = std::pow (a.data (i), b);
 	      }
 	}  
 
       retval = result;
     }
   else
     {
       octave_idx_type nz = a.nzmax ();
 
       SparseComplexMatrix result (a);
   
       if (xisint (b))
 	{
 	  for (octave_idx_type i = 0; i < nz; i++)
 	    {
-	      OCTAVE_QUIT;
+	      octave_quit ();
 	      result.data (i) = std::pow (a.data (i), static_cast<int> (b));
 	    }
 	}
       else
 	{
 	  for (octave_idx_type i = 0; i < nz; i++)
 	    {
-	      OCTAVE_QUIT;
+	      octave_quit ();
 	      result.data (i) = std::pow (a.data (i), b);
 	    }
 	}  
 
       result.maybe_compress (true);
 
       retval = result;
     }
@@ -647,17 +647,17 @@ elem_xpow (const SparseComplexMatrix& a,
       return octave_value ();
     }
 
   SparseComplexMatrix result (nr, nc, Complex(1.0, 0.0));
   for (octave_idx_type j = 0; j < nc; j++)
     {
       for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
 	{
-	  OCTAVE_QUIT;
+	  octave_quit ();
 	  double btmp = b (a.ridx(i), j);
 	  Complex tmp;
 
 	  if (xisint (btmp))
 	    result.xelem(a.ridx(i), j) = std::pow (a.data (i), 
 					      static_cast<int> (btmp));
 	  else
 	    result.xelem(a.ridx(i), j) = std::pow (a.data (i), btmp);
@@ -682,17 +682,17 @@ elem_xpow (const SparseComplexMatrix& a,
     {
 
       octave_idx_type nz = a.nzmax ();
 
       SparseComplexMatrix result (a);
 
       for (octave_idx_type i = 0; i < nz; i++)
 	{
-	  OCTAVE_QUIT;
+	  octave_quit ();
 	  result.data (i) = std::pow (a.data (i), b);
 	}
 
       result.maybe_compress (true);
       
       retval = result;
     }
 
@@ -715,17 +715,17 @@ elem_xpow (const SparseComplexMatrix& a,
       return octave_value ();
     }
 
   SparseComplexMatrix result (nr, nc, Complex(1.0, 0.0));
   for (octave_idx_type j = 0; j < nc; j++) 
     {
       for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
 	{
-	  OCTAVE_QUIT;
+	  octave_quit ();
 	  result.xelem(a.ridx(i), j) = std::pow (a.data (i), b (a.ridx(i), j));
 	}
     }
   result.maybe_compress (true);
 
   return result;
 }
 
diff --git a/src/toplev.cc b/src/toplev.cc
--- a/src/toplev.cc
+++ b/src/toplev.cc
@@ -574,17 +574,17 @@ main_loop (void)
 	      if (global_command)
 		{
 		  global_command->accept (*current_evaluator);
 
 		  delete global_command;
 
 		  global_command = 0;
 
-		  OCTAVE_QUIT;
+		  octave_quit ();
 
 		  if (! (interactive || forced_interactive))
 		    {
 		      bool quit = (tree_return_command::returning
 				   || tree_break_command::breaking);
 
 		      if (tree_return_command::returning)
 			tree_return_command::returning = 0;
diff --git a/src/utils.cc b/src/utils.cc
--- a/src/utils.cc
+++ b/src/utils.cc
@@ -1340,17 +1340,17 @@ octave_sleep (double seconds)
       unsigned int sec
 	= (t > UINT_MAX) ? UINT_MAX : static_cast<unsigned int> (t);
 
       // Versions of these functions that accept unsigned int args are
       // defined in cutils.c.
       octave_sleep (sec);
       octave_usleep (usec);
 
-      OCTAVE_QUIT;
+      octave_quit ();
     }
 }
 
 DEFUN (isindex, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} isindex (@var{ind}, @var{n})\n\
 Returns true if @var{ind} is a valid index.  Valid indices can be\n\
 either positive integers (though possibly real data), or logical arrays.\n\
@@ -1445,17 +1445,17 @@ do_simple_cellfun (octave_value_list (*f
         rcells[i].clear (dims);
 
       for (octave_idx_type j = 0; j < numel; j++)
         {
           for (int i = 0; i < nargin; i++)
             if (iscell[i])
               new_args(i) = ccells[i](j);
 
-          OCTAVE_QUIT;
+          octave_quit ();
 
           const octave_value_list tmp = fun (new_args, nargout);
 
           if (tmp.length () < nargout)
             {
               error ("%s: do_simple_cellfun: internal error", fun_name);
               break;
             }
diff --git a/src/xdiv.cc b/src/xdiv.cc
--- a/src/xdiv.cc
+++ b/src/xdiv.cc
@@ -208,17 +208,17 @@ x_el_div (double a, const Matrix& b)
   octave_idx_type nr = b.rows ();
   octave_idx_type nc = b.columns ();
 
   Matrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
-	OCTAVE_QUIT;
+	octave_quit ();
 	result (i, j) = a / b (i, j);
       }
 
   return result;
 }
 
 ComplexMatrix
 x_el_div (double a, const ComplexMatrix& b)
@@ -226,17 +226,17 @@ x_el_div (double a, const ComplexMatrix&
   octave_idx_type nr = b.rows ();
   octave_idx_type nc = b.columns ();
 
   ComplexMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
-	OCTAVE_QUIT;
+	octave_quit ();
 	result (i, j) = a / b (i, j);
       }
 
   return result;
 }
 
 ComplexMatrix
 x_el_div (const Complex a, const Matrix& b)
@@ -244,17 +244,17 @@ x_el_div (const Complex a, const Matrix&
   octave_idx_type nr = b.rows ();
   octave_idx_type nc = b.columns ();
 
   ComplexMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
-	OCTAVE_QUIT;
+	octave_quit ();
 	result (i, j) = a / b (i, j);
       }
 
   return result;
 }
 
 ComplexMatrix
 x_el_div (const Complex a, const ComplexMatrix& b)
@@ -262,17 +262,17 @@ x_el_div (const Complex a, const Complex
   octave_idx_type nr = b.rows ();
   octave_idx_type nc = b.columns ();
 
   ComplexMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
-	OCTAVE_QUIT;
+	octave_quit ();
 	result (i, j) = a / b (i, j);
       }
 
   return result;
 }
 
 // Funny element by element division operations.
 //
@@ -285,59 +285,59 @@ x_el_div (const Complex a, const Complex
 
 NDArray
 x_el_div (double a, const NDArray& b)
 {
   NDArray result (b.dims ());
 
   for (octave_idx_type i = 0; i < b.length (); i++)
     {
-      OCTAVE_QUIT;
+      octave_quit ();
       result (i) = a / b (i);
     }
 
   return result;
 }
 
 ComplexNDArray
 x_el_div (double a, const ComplexNDArray& b)
 {
   ComplexNDArray result (b.dims ());
 
   for (octave_idx_type i = 0; i < b.length (); i++)
     {
-      OCTAVE_QUIT;
+      octave_quit ();
       result (i) = a / b (i);
     }
 
   return result;
 }
 
 ComplexNDArray
 x_el_div (const Complex a, const NDArray& b)
 {
   ComplexNDArray result (b.dims ());
 
   for (octave_idx_type i = 0; i < b.length (); i++)
     {
-      OCTAVE_QUIT;
+      octave_quit ();
       result (i) = a / b (i);
     }
 
   return result;
 }
 
 ComplexNDArray
 x_el_div (const Complex a, const ComplexNDArray& b)
 {
   ComplexNDArray result (b.dims ());
 
   for (octave_idx_type i = 0; i < b.length (); i++)
     {
-      OCTAVE_QUIT;
+      octave_quit ();
       result (i) = a / b (i);
     }
 
   return result;
 }
 
 // Left division functions.
 //
@@ -506,17 +506,17 @@ x_el_div (float a, const FloatMatrix& b)
   octave_idx_type nr = b.rows ();
   octave_idx_type nc = b.columns ();
 
   FloatMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
-	OCTAVE_QUIT;
+	octave_quit ();
 	result (i, j) = a / b (i, j);
       }
 
   return result;
 }
 
 FloatComplexMatrix
 x_el_div (float a, const FloatComplexMatrix& b)
@@ -524,17 +524,17 @@ x_el_div (float a, const FloatComplexMat
   octave_idx_type nr = b.rows ();
   octave_idx_type nc = b.columns ();
 
   FloatComplexMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
-	OCTAVE_QUIT;
+	octave_quit ();
 	result (i, j) = a / b (i, j);
       }
 
   return result;
 }
 
 FloatComplexMatrix
 x_el_div (const FloatComplex a, const FloatMatrix& b)
@@ -542,17 +542,17 @@ x_el_div (const FloatComplex a, const Fl
   octave_idx_type nr = b.rows ();
   octave_idx_type nc = b.columns ();
 
   FloatComplexMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
-	OCTAVE_QUIT;
+	octave_quit ();
 	result (i, j) = a / b (i, j);
       }
 
   return result;
 }
 
 FloatComplexMatrix
 x_el_div (const FloatComplex a, const FloatComplexMatrix& b)
@@ -560,17 +560,17 @@ x_el_div (const FloatComplex a, const Fl
   octave_idx_type nr = b.rows ();
   octave_idx_type nc = b.columns ();
 
   FloatComplexMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
-	OCTAVE_QUIT;
+	octave_quit ();
 	result (i, j) = a / b (i, j);
       }
 
   return result;
 }
 
 // Funny element by element division operations.
 //
@@ -583,59 +583,59 @@ x_el_div (const FloatComplex a, const Fl
 
 FloatNDArray
 x_el_div (float a, const FloatNDArray& b)
 {
   FloatNDArray result (b.dims ());
 
   for (octave_idx_type i = 0; i < b.length (); i++)
     {
-      OCTAVE_QUIT;
+      octave_quit ();
       result (i) = a / b (i);
     }
 
   return result;
 }
 
 FloatComplexNDArray
 x_el_div (float a, const FloatComplexNDArray& b)
 {
   FloatComplexNDArray result (b.dims ());
 
   for (octave_idx_type i = 0; i < b.length (); i++)
     {
-      OCTAVE_QUIT;
+      octave_quit ();
       result (i) = a / b (i);
     }
 
   return result;
 }
 
 FloatComplexNDArray
 x_el_div (const FloatComplex a, const FloatNDArray& b)
 {
   FloatComplexNDArray result (b.dims ());
 
   for (octave_idx_type i = 0; i < b.length (); i++)
     {
-      OCTAVE_QUIT;
+      octave_quit ();
       result (i) = a / b (i);
     }
 
   return result;
 }
 
 FloatComplexNDArray
 x_el_div (const FloatComplex a, const FloatComplexNDArray& b)
 {
   FloatComplexNDArray result (b.dims ());
 
   for (octave_idx_type i = 0; i < b.length (); i++)
     {
-      OCTAVE_QUIT;
+      octave_quit ();
       result (i) = a / b (i);
     }
 
   return result;
 }
 
 // Left division functions.
 //
diff --git a/src/xpow.cc b/src/xpow.cc
--- a/src/xpow.cc
+++ b/src/xpow.cc
@@ -644,30 +644,30 @@ elem_xpow (double a, const Matrix& b)
   if (a < 0.0 && ! b.all_integers (d1, d2))
     {
       Complex atmp (a);
       ComplexMatrix result (nr, nc);
 
       for (octave_idx_type j = 0; j < nc; j++)
 	for (octave_idx_type i = 0; i < nr; i++)
 	  {
-	    OCTAVE_QUIT;
+	    octave_quit ();
 	    result (i, j) = std::pow (atmp, b (i, j));
 	  }
 
       retval = result;
     }
   else
     {
       Matrix result (nr, nc);
 
       for (octave_idx_type j = 0; j < nc; j++)
 	for (octave_idx_type i = 0; i < nr; i++)
 	  {
-	    OCTAVE_QUIT;
+	    octave_quit ();
 	    result (i, j) = std::pow (a, b (i, j));
 	  }
 
       retval = result;
     }
 
   return retval;
 }
@@ -680,17 +680,17 @@ elem_xpow (double a, const ComplexMatrix
   octave_idx_type nc = b.cols ();
 
   ComplexMatrix result (nr, nc);
   Complex atmp (a);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
-	OCTAVE_QUIT;
+	octave_quit ();
 	result (i, j) = std::pow (atmp, b (i, j));
       }
 
   return result;
 }
 
 static inline bool 
 same_sign (double a, double b)
@@ -747,33 +747,33 @@ elem_xpow (const Matrix& a, double b)
 
   if (! xisint (b) && a.any_element_is_negative ())
     {
       ComplexMatrix result (nr, nc);
 
       for (octave_idx_type j = 0; j < nc; j++)
 	for (octave_idx_type i = 0; i < nr; i++)
 	  {
-	    OCTAVE_QUIT; 
+	    octave_quit (); 
       
 	    Complex atmp (a (i, j));
 
 	    result (i, j) = std::pow (atmp, b);
 	  }
 
       retval = result;
     }
   else
     {
       Matrix result (nr, nc);
 
       for (octave_idx_type j = 0; j < nc; j++)
 	for (octave_idx_type i = 0; i < nr; i++)
 	  {
-	    OCTAVE_QUIT;
+	    octave_quit ();
 	    result (i, j) = std::pow (a (i, j), b);
 	  }
 
       retval = result;
     }
 
   return retval;
 }
@@ -795,17 +795,17 @@ elem_xpow (const Matrix& a, const Matrix
       gripe_nonconformant ("operator .^", nr, nc, b_nr, b_nc);
       return octave_value ();
     }
 
   int convert_to_complex = 0;
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
-	OCTAVE_QUIT;
+	octave_quit ();
 	double atmp = a (i, j);
 	double btmp = b (i, j);
 	if (atmp < 0.0 && static_cast<int> (btmp) != btmp)
 	  {
 	    convert_to_complex = 1;
 	    goto done;
 	  }
       }
@@ -814,32 +814,32 @@ done:
 
   if (convert_to_complex)
     {
       ComplexMatrix complex_result (nr, nc);
 
       for (octave_idx_type j = 0; j < nc; j++)
 	for (octave_idx_type i = 0; i < nr; i++)
 	  {
-	    OCTAVE_QUIT;
+	    octave_quit ();
 	    Complex atmp (a (i, j));
 	    Complex btmp (b (i, j));
 	    complex_result (i, j) = std::pow (atmp, btmp);
 	  }
 
       retval = complex_result;
     }
   else
     {
       Matrix result (nr, nc);
 
       for (octave_idx_type j = 0; j < nc; j++)
 	for (octave_idx_type i = 0; i < nr; i++)
 	  {
-	    OCTAVE_QUIT;
+	    octave_quit ();
 	    result (i, j) = std::pow (a (i, j), b (i, j));
 	  }
 
       retval = result;
     }
 
   return retval;
 }
@@ -851,17 +851,17 @@ elem_xpow (const Matrix& a, const Comple
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
 
   ComplexMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
-	OCTAVE_QUIT;
+	octave_quit ();
 	result (i, j) = std::pow (Complex (a (i, j)), b);
       }
 
   return result;
 }
 
 // -*- 6 -*-
 octave_value
@@ -879,17 +879,17 @@ elem_xpow (const Matrix& a, const Comple
       return octave_value ();
     }
 
   ComplexMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
-	OCTAVE_QUIT;
+	octave_quit ();
 	result (i, j) = std::pow (Complex (a (i, j)), b (i, j));
       }
 
   return result;
 }
 
 // -*- 7 -*-
 octave_value
@@ -898,17 +898,17 @@ elem_xpow (const Complex& a, const Matri
   octave_idx_type nr = b.rows ();
   octave_idx_type nc = b.cols ();
 
   ComplexMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
-	OCTAVE_QUIT;
+	octave_quit ();
 	double btmp = b (i, j);
 	if (xisint (btmp))
 	  result (i, j) = std::pow (a, static_cast<int> (btmp));
 	else
 	  result (i, j) = std::pow (a, btmp);
       }
 
   return result;
@@ -921,17 +921,17 @@ elem_xpow (const Complex& a, const Compl
   octave_idx_type nr = b.rows ();
   octave_idx_type nc = b.cols ();
 
   ComplexMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
-	OCTAVE_QUIT;
+	octave_quit ();
 	result (i, j) = std::pow (a, b (i, j));
       }
 
   return result;
 }
 
 octave_value
 elem_xpow (const Complex& a, const Range& r)
@@ -982,26 +982,26 @@ elem_xpow (const ComplexMatrix& a, doubl
 
   ComplexMatrix result (nr, nc);
 
   if (xisint (b))
     {
       for (octave_idx_type j = 0; j < nc; j++)
 	for (octave_idx_type i = 0; i < nr; i++)
 	  {
-	    OCTAVE_QUIT;
+	    octave_quit ();
 	    result (i, j) = std::pow (a (i, j), static_cast<int> (b));
 	  }
     }
   else
     {
       for (octave_idx_type j = 0; j < nc; j++)
 	for (octave_idx_type i = 0; i < nr; i++)
 	  {
-	    OCTAVE_QUIT;
+	    octave_quit ();
 	    result (i, j) = std::pow (a (i, j), b);
 	  }
     }
 
   return result;
 }
 
 // -*- 10 -*-
@@ -1020,17 +1020,17 @@ elem_xpow (const ComplexMatrix& a, const
       return octave_value ();
     }
 
   ComplexMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
-	OCTAVE_QUIT;
+	octave_quit ();
 	double btmp = b (i, j);
 	if (xisint (btmp))
 	  result (i, j) = std::pow (a (i, j), static_cast<int> (btmp));
 	else
 	  result (i, j) = std::pow (a (i, j), btmp);
       }
 
   return result;
@@ -1043,17 +1043,17 @@ elem_xpow (const ComplexMatrix& a, const
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
 
   ComplexMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
-	OCTAVE_QUIT;
+	octave_quit ();
 	result (i, j) = std::pow (a (i, j), b);
       }
 
   return result;
 }
 
 // -*- 12 -*-
 octave_value
@@ -1071,17 +1071,17 @@ elem_xpow (const ComplexMatrix& a, const
       return octave_value ();
     }
 
   ComplexMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
-	OCTAVE_QUIT;
+	octave_quit ();
 	result (i, j) = std::pow (a (i, j), b (i, j));
       }
 
   return result;
 }
 
 // Safer pow functions that work elementwise for N-d arrays.
 //
@@ -1121,28 +1121,28 @@ elem_xpow (double a, const NDArray& b)
   double d1, d2;
 
   if (a < 0.0 && ! b.all_integers (d1, d2))
     {
       Complex atmp (a);
       ComplexNDArray result (b.dims ());
       for (octave_idx_type i = 0; i < b.length (); i++)
 	{
-	  OCTAVE_QUIT;
+	  octave_quit ();
 	  result(i) = std::pow (atmp, b(i));
 	}
 
       retval = result;
     }
   else
     {
       NDArray result (b.dims ());
       for (octave_idx_type i = 0; i < b.length (); i++)
 	{
-	  OCTAVE_QUIT;
+	  octave_quit ();
 	  result (i) = std::pow (a, b(i));
 	}
 
       retval = result;
     }
 
   return retval;
 }
@@ -1151,17 +1151,17 @@ elem_xpow (double a, const NDArray& b)
 octave_value
 elem_xpow (double a, const ComplexNDArray& b)
 {
   ComplexNDArray result (b.dims ());
   Complex atmp (a);
 
   for (octave_idx_type i = 0; i < b.length (); i++)
     {
-      OCTAVE_QUIT;
+      octave_quit ();
       result(i) = std::pow (atmp, b(i));
     }
 
   return result;
 }
 
 // -*- 3 -*-
 octave_value
@@ -1172,31 +1172,31 @@ elem_xpow (const NDArray& a, double b)
   if (! xisint (b))
     {
       if (a.any_element_is_negative ())
         {
           ComplexNDArray result (a.dims ());
 
           for (octave_idx_type i = 0; i < a.length (); i++)
             {
-              OCTAVE_QUIT;
+              octave_quit ();
 
               Complex atmp (a (i));
 
               result(i) = std::pow (atmp, b);
             }
 
           retval = result;
         }
       else
         {
           NDArray result (a.dims ());
           for (octave_idx_type i = 0; i < a.length (); i++)
             {
-              OCTAVE_QUIT;
+              octave_quit ();
               result(i) = std::pow (a(i), b);
             }
 
           retval = result;
         }
     }
   else
     {
@@ -1217,17 +1217,17 @@ elem_xpow (const NDArray& a, double b)
         {
           for (octave_idx_type i = 0; i < a.length (); i++)
             result(i) = 1.0 / a(i);
         }
       else
         {
           for (octave_idx_type i = 0; i < a.length (); i++)
             {
-              OCTAVE_QUIT;
+              octave_quit ();
               result(i) = std::pow (a(i), ib);
             }
         }
 
       retval = result;
     }
 
   return retval;
@@ -1249,17 +1249,17 @@ elem_xpow (const NDArray& a, const NDArr
     }
 
   int len = a.length ();
 
   bool convert_to_complex = false;
 
   for (octave_idx_type i = 0; i < len; i++)
     {
-      OCTAVE_QUIT;
+      octave_quit ();
       double atmp = a(i);
       double btmp = b(i);
       if (atmp < 0.0 && static_cast<int> (btmp) != btmp)
 	{
 	  convert_to_complex = true;
 	  goto done;
 	}
     }
@@ -1267,31 +1267,31 @@ elem_xpow (const NDArray& a, const NDArr
 done:
 
   if (convert_to_complex)
     {
       ComplexNDArray complex_result (a_dims);
 
       for (octave_idx_type i = 0; i < len; i++)
 	{
-	  OCTAVE_QUIT;
+	  octave_quit ();
 	  Complex atmp (a(i));
 	  Complex btmp (b(i));
 	  complex_result(i) = std::pow (atmp, btmp);
 	}
 
       retval = complex_result;
     }
   else
     {
       NDArray result (a_dims);
 
       for (octave_idx_type i = 0; i < len; i++)
 	{
-	  OCTAVE_QUIT;
+	  octave_quit ();
 	  result(i) = std::pow (a(i), b(i));
 	}
 
       retval = result;
     }
 
   return retval;
 }
@@ -1299,17 +1299,17 @@ done:
 // -*- 5 -*-
 octave_value
 elem_xpow (const NDArray& a, const Complex& b)
 {
   ComplexNDArray result (a.dims ());
 
   for (octave_idx_type i = 0; i < a.length (); i++)
     {
-      OCTAVE_QUIT;
+      octave_quit ();
       result(i) = std::pow (Complex (a(i)), b);
     }
 
   return result;
 }
 
 // -*- 6 -*-
 octave_value
@@ -1323,32 +1323,32 @@ elem_xpow (const NDArray& a, const Compl
       gripe_nonconformant ("operator .^", a_dims, b_dims);
       return octave_value ();
     }
 
   ComplexNDArray result (a_dims);
 
   for (octave_idx_type i = 0; i < a.length (); i++)
     {
-      OCTAVE_QUIT;
+      octave_quit ();
       result(i) = std::pow (Complex (a(i)), b(i));
     }
 
   return result;
 }
 
 // -*- 7 -*-
 octave_value
 elem_xpow (const Complex& a, const NDArray& b)
 {
   ComplexNDArray result (b.dims ());
 
   for (octave_idx_type i = 0; i < b.length (); i++)
     {
-      OCTAVE_QUIT;
+      octave_quit ();
       double btmp = b(i);
       if (xisint (btmp))
 	result(i) = std::pow (a, static_cast<int> (btmp));
       else
 	result(i) = std::pow (a, btmp);
     }
 
   return result;
@@ -1357,17 +1357,17 @@ elem_xpow (const Complex& a, const NDArr
 // -*- 8 -*-
 octave_value
 elem_xpow (const Complex& a, const ComplexNDArray& b)
 {
   ComplexNDArray result (b.dims ());
 
   for (octave_idx_type i = 0; i < b.length (); i++)
     {
-      OCTAVE_QUIT;
+      octave_quit ();
       result(i) = std::pow (a, b(i));
     }
 
   return result;
 }
 
 // -*- 9 -*-
 octave_value
@@ -1381,26 +1381,26 @@ elem_xpow (const ComplexNDArray& a, doub
         {
           for (octave_idx_type i = 0; i < a.length (); i++)
             result.xelem (i) = std::conj (a(i)) / std::norm (a(i));
         }
       else
         {
           for (octave_idx_type i = 0; i < a.length (); i++)
             {
-              OCTAVE_QUIT;
+              octave_quit ();
               result(i) = std::pow (a(i), static_cast<int> (b));
             }
         }
     }
   else
     {
       for (octave_idx_type i = 0; i < a.length (); i++)
 	{
-	  OCTAVE_QUIT;
+	  octave_quit ();
 	  result(i) = std::pow (a(i), b);
 	}
     }
 
   return result;
 }
 
 // -*- 10 -*-
@@ -1415,17 +1415,17 @@ elem_xpow (const ComplexNDArray& a, cons
       gripe_nonconformant ("operator .^", a_dims, b_dims);
       return octave_value ();
     }
 
   ComplexNDArray result (a_dims);
 
   for (octave_idx_type i = 0; i < a.length (); i++)
     {
-      OCTAVE_QUIT;
+      octave_quit ();
       double btmp = b(i);
       if (xisint (btmp))
 	result(i) = std::pow (a(i), static_cast<int> (btmp));
       else
 	result(i) = std::pow (a(i), btmp);
     }
 
   return result;
@@ -1434,17 +1434,17 @@ elem_xpow (const ComplexNDArray& a, cons
 // -*- 11 -*-
 octave_value
 elem_xpow (const ComplexNDArray& a, const Complex& b)
 {
   ComplexNDArray result (a.dims ());
 
   for (octave_idx_type i = 0; i < a.length (); i++)
     {
-      OCTAVE_QUIT;
+      octave_quit ();
       result(i) = std::pow (a(i), b);
     }
 
   return result;
 }
 
 // -*- 12 -*-
 octave_value
@@ -1458,17 +1458,17 @@ elem_xpow (const ComplexNDArray& a, cons
       gripe_nonconformant ("operator .^", a_dims, b_dims);
       return octave_value ();
     }
 
   ComplexNDArray result (a_dims);
 
   for (octave_idx_type i = 0; i < a.length (); i++)
     {
-      OCTAVE_QUIT;
+      octave_quit ();
       result(i) = std::pow (a(i), b(i));
     }
 
   return result;
 }
 
 static inline int
 xisint (float x)
@@ -2048,30 +2048,30 @@ elem_xpow (float a, const FloatMatrix& b
   if (a < 0.0 && ! b.all_integers (d1, d2))
     {
       FloatComplex atmp (a);
       FloatComplexMatrix result (nr, nc);
 
       for (octave_idx_type j = 0; j < nc; j++)
 	for (octave_idx_type i = 0; i < nr; i++)
 	  {
-	    OCTAVE_QUIT;
+	    octave_quit ();
 	    result (i, j) = std::pow (atmp, b (i, j));
 	  }
 
       retval = result;
     }
   else
     {
       FloatMatrix result (nr, nc);
 
       for (octave_idx_type j = 0; j < nc; j++)
 	for (octave_idx_type i = 0; i < nr; i++)
 	  {
-	    OCTAVE_QUIT;
+	    octave_quit ();
 	    result (i, j) = std::pow (a, b (i, j));
 	  }
 
       retval = result;
     }
 
   return retval;
 }
@@ -2084,17 +2084,17 @@ elem_xpow (float a, const FloatComplexMa
   octave_idx_type nc = b.cols ();
 
   FloatComplexMatrix result (nr, nc);
   FloatComplex atmp (a);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
-	OCTAVE_QUIT;
+	octave_quit ();
 	result (i, j) = std::pow (atmp, b (i, j));
       }
 
   return result;
 }
 
 // -*- 3 -*-
 octave_value
@@ -2107,33 +2107,33 @@ elem_xpow (const FloatMatrix& a, float b
 
   if (! xisint (b) && a.any_element_is_negative ())
     {
       FloatComplexMatrix result (nr, nc);
 
       for (octave_idx_type j = 0; j < nc; j++)
 	for (octave_idx_type i = 0; i < nr; i++)
 	  {
-	    OCTAVE_QUIT; 
+	    octave_quit (); 
       
 	    FloatComplex atmp (a (i, j));
 
 	    result (i, j) = std::pow (atmp, b);
 	  }
 
       retval = result;
     }
   else
     {
       FloatMatrix result (nr, nc);
 
       for (octave_idx_type j = 0; j < nc; j++)
 	for (octave_idx_type i = 0; i < nr; i++)
 	  {
-	    OCTAVE_QUIT;
+	    octave_quit ();
 	    result (i, j) = std::pow (a (i, j), b);
 	  }
 
       retval = result;
     }
 
   return retval;
 }
@@ -2155,17 +2155,17 @@ elem_xpow (const FloatMatrix& a, const F
       gripe_nonconformant ("operator .^", nr, nc, b_nr, b_nc);
       return octave_value ();
     }
 
   int convert_to_complex = 0;
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
-	OCTAVE_QUIT;
+	octave_quit ();
 	float atmp = a (i, j);
 	float btmp = b (i, j);
 	if (atmp < 0.0 && static_cast<int> (btmp) != btmp)
 	  {
 	    convert_to_complex = 1;
 	    goto done;
 	  }
       }
@@ -2174,32 +2174,32 @@ done:
 
   if (convert_to_complex)
     {
       FloatComplexMatrix complex_result (nr, nc);
 
       for (octave_idx_type j = 0; j < nc; j++)
 	for (octave_idx_type i = 0; i < nr; i++)
 	  {
-	    OCTAVE_QUIT;
+	    octave_quit ();
 	    FloatComplex atmp (a (i, j));
 	    FloatComplex btmp (b (i, j));
 	    complex_result (i, j) = std::pow (atmp, btmp);
 	  }
 
       retval = complex_result;
     }
   else
     {
       FloatMatrix result (nr, nc);
 
       for (octave_idx_type j = 0; j < nc; j++)
 	for (octave_idx_type i = 0; i < nr; i++)
 	  {
-	    OCTAVE_QUIT;
+	    octave_quit ();
 	    result (i, j) = std::pow (a (i, j), b (i, j));
 	  }
 
       retval = result;
     }
 
   return retval;
 }
@@ -2211,17 +2211,17 @@ elem_xpow (const FloatMatrix& a, const F
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
 
   FloatComplexMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
-	OCTAVE_QUIT;
+	octave_quit ();
 	result (i, j) = std::pow (FloatComplex (a (i, j)), b);
       }
 
   return result;
 }
 
 // -*- 6 -*-
 octave_value
@@ -2239,17 +2239,17 @@ elem_xpow (const FloatMatrix& a, const F
       return octave_value ();
     }
 
   FloatComplexMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
-	OCTAVE_QUIT;
+	octave_quit ();
 	result (i, j) = std::pow (FloatComplex (a (i, j)), b (i, j));
       }
 
   return result;
 }
 
 // -*- 7 -*-
 octave_value
@@ -2258,17 +2258,17 @@ elem_xpow (const FloatComplex& a, const 
   octave_idx_type nr = b.rows ();
   octave_idx_type nc = b.cols ();
 
   FloatComplexMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
-	OCTAVE_QUIT;
+	octave_quit ();
 	float btmp = b (i, j);
 	if (xisint (btmp))
 	  result (i, j) = std::pow (a, static_cast<int> (btmp));
 	else
 	  result (i, j) = std::pow (a, btmp);
       }
 
   return result;
@@ -2281,17 +2281,17 @@ elem_xpow (const FloatComplex& a, const 
   octave_idx_type nr = b.rows ();
   octave_idx_type nc = b.cols ();
 
   FloatComplexMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
-	OCTAVE_QUIT;
+	octave_quit ();
 	result (i, j) = std::pow (a, b (i, j));
       }
 
   return result;
 }
 
 // -*- 9 -*-
 octave_value
@@ -2302,26 +2302,26 @@ elem_xpow (const FloatComplexMatrix& a, 
 
   FloatComplexMatrix result (nr, nc);
 
   if (xisint (b))
     {
       for (octave_idx_type j = 0; j < nc; j++)
 	for (octave_idx_type i = 0; i < nr; i++)
 	  {
-	    OCTAVE_QUIT;
+	    octave_quit ();
 	    result (i, j) = std::pow (a (i, j), static_cast<int> (b));
 	  }
     }
   else
     {
       for (octave_idx_type j = 0; j < nc; j++)
 	for (octave_idx_type i = 0; i < nr; i++)
 	  {
-	    OCTAVE_QUIT;
+	    octave_quit ();
 	    result (i, j) = std::pow (a (i, j), b);
 	  }
     }
 
   return result;
 }
 
 // -*- 10 -*-
@@ -2340,17 +2340,17 @@ elem_xpow (const FloatComplexMatrix& a, 
       return octave_value ();
     }
 
   FloatComplexMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
-	OCTAVE_QUIT;
+	octave_quit ();
 	float btmp = b (i, j);
 	if (xisint (btmp))
 	  result (i, j) = std::pow (a (i, j), static_cast<int> (btmp));
 	else
 	  result (i, j) = std::pow (a (i, j), btmp);
       }
 
   return result;
@@ -2363,17 +2363,17 @@ elem_xpow (const FloatComplexMatrix& a, 
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
 
   FloatComplexMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
-	OCTAVE_QUIT;
+	octave_quit ();
 	result (i, j) = std::pow (a (i, j), b);
       }
 
   return result;
 }
 
 // -*- 12 -*-
 octave_value
@@ -2391,17 +2391,17 @@ elem_xpow (const FloatComplexMatrix& a, 
       return octave_value ();
     }
 
   FloatComplexMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
-	OCTAVE_QUIT;
+	octave_quit ();
 	result (i, j) = std::pow (a (i, j), b (i, j));
       }
 
   return result;
 }
 
 // Safer pow functions that work elementwise for N-d arrays.
 //
@@ -2441,28 +2441,28 @@ elem_xpow (float a, const FloatNDArray& 
   float d1, d2;
 
   if (a < 0.0 && ! b.all_integers (d1, d2))
     {
       FloatComplex atmp (a);
       FloatComplexNDArray result (b.dims ());
       for (octave_idx_type i = 0; i < b.length (); i++)
 	{
-	  OCTAVE_QUIT;
+	  octave_quit ();
 	  result(i) = std::pow (atmp, b(i));
 	}
 
       retval = result;
     }
   else
     {
       FloatNDArray result (b.dims ());
       for (octave_idx_type i = 0; i < b.length (); i++)
 	{
-	  OCTAVE_QUIT;
+	  octave_quit ();
 	  result (i) = std::pow (a, b(i));
 	}
 
       retval = result;
     }
 
   return retval;
 }
@@ -2471,17 +2471,17 @@ elem_xpow (float a, const FloatNDArray& 
 octave_value
 elem_xpow (float a, const FloatComplexNDArray& b)
 {
   FloatComplexNDArray result (b.dims ());
   FloatComplex atmp (a);
 
   for (octave_idx_type i = 0; i < b.length (); i++)
     {
-      OCTAVE_QUIT;
+      octave_quit ();
       result(i) = std::pow (atmp, b(i));
     }
 
   return result;
 }
 
 // -*- 3 -*-
 octave_value
@@ -2492,31 +2492,31 @@ elem_xpow (const FloatNDArray& a, float 
   if (! xisint (b))
     {
       if (a.any_element_is_negative ())
         {
           FloatComplexNDArray result (a.dims ());
 
           for (octave_idx_type i = 0; i < a.length (); i++)
             {
-              OCTAVE_QUIT;
+              octave_quit ();
 
               FloatComplex atmp (a (i));
 
               result(i) = std::pow (atmp, b);
             }
 
           retval = result;
         }
       else
         {
           FloatNDArray result (a.dims ());
           for (octave_idx_type i = 0; i < a.length (); i++)
             {
-              OCTAVE_QUIT;
+              octave_quit ();
               result(i) = std::pow (a(i), b);
             }
 
           retval = result;
         }
     }
   else
     {
@@ -2537,17 +2537,17 @@ elem_xpow (const FloatNDArray& a, float 
         {
           for (octave_idx_type i = 0; i < a.length (); i++)
             result(i) = 1.0f / a(i);
         }
       else
         {
           for (octave_idx_type i = 0; i < a.length (); i++)
             {
-              OCTAVE_QUIT;
+              octave_quit ();
               result(i) = std::pow (a(i), ib);
             }
         }
 
       retval = result;
     }
 
   return retval;
@@ -2569,17 +2569,17 @@ elem_xpow (const FloatNDArray& a, const 
     }
 
   int len = a.length ();
 
   bool convert_to_complex = false;
 
   for (octave_idx_type i = 0; i < len; i++)
     {
-      OCTAVE_QUIT;
+      octave_quit ();
       float atmp = a(i);
       float btmp = b(i);
       if (atmp < 0.0 && static_cast<int> (btmp) != btmp)
 	{
 	  convert_to_complex = true;
 	  goto done;
 	}
     }
@@ -2587,31 +2587,31 @@ elem_xpow (const FloatNDArray& a, const 
 done:
 
   if (convert_to_complex)
     {
       FloatComplexNDArray complex_result (a_dims);
 
       for (octave_idx_type i = 0; i < len; i++)
 	{
-	  OCTAVE_QUIT;
+	  octave_quit ();
 	  FloatComplex atmp (a(i));
 	  FloatComplex btmp (b(i));
 	  complex_result(i) = std::pow (atmp, btmp);
 	}
 
       retval = complex_result;
     }
   else
     {
       FloatNDArray result (a_dims);
 
       for (octave_idx_type i = 0; i < len; i++)
 	{
-	  OCTAVE_QUIT;
+	  octave_quit ();
 	  result(i) = std::pow (a(i), b(i));
 	}
 
       retval = result;
     }
 
   return retval;
 }
@@ -2619,17 +2619,17 @@ done:
 // -*- 5 -*-
 octave_value
 elem_xpow (const FloatNDArray& a, const FloatComplex& b)
 {
   FloatComplexNDArray result (a.dims ());
 
   for (octave_idx_type i = 0; i < a.length (); i++)
     {
-      OCTAVE_QUIT;
+      octave_quit ();
       result(i) = std::pow (FloatComplex (a(i)), b);
     }
 
   return result;
 }
 
 // -*- 6 -*-
 octave_value
@@ -2643,32 +2643,32 @@ elem_xpow (const FloatNDArray& a, const 
       gripe_nonconformant ("operator .^", a_dims, b_dims);
       return octave_value ();
     }
 
   FloatComplexNDArray result (a_dims);
 
   for (octave_idx_type i = 0; i < a.length (); i++)
     {
-      OCTAVE_QUIT;
+      octave_quit ();
       result(i) = std::pow (FloatComplex (a(i)), b(i));
     }
 
   return result;
 }
 
 // -*- 7 -*-
 octave_value
 elem_xpow (const FloatComplex& a, const FloatNDArray& b)
 {
   FloatComplexNDArray result (b.dims ());
 
   for (octave_idx_type i = 0; i < b.length (); i++)
     {
-      OCTAVE_QUIT;
+      octave_quit ();
       float btmp = b(i);
       if (xisint (btmp))
 	result(i) = std::pow (a, static_cast<int> (btmp));
       else
 	result(i) = std::pow (a, btmp);
     }
 
   return result;
@@ -2677,17 +2677,17 @@ elem_xpow (const FloatComplex& a, const 
 // -*- 8 -*-
 octave_value
 elem_xpow (const FloatComplex& a, const FloatComplexNDArray& b)
 {
   FloatComplexNDArray result (b.dims ());
 
   for (octave_idx_type i = 0; i < b.length (); i++)
     {
-      OCTAVE_QUIT;
+      octave_quit ();
       result(i) = std::pow (a, b(i));
     }
 
   return result;
 }
 
 // -*- 9 -*-
 octave_value
@@ -2701,26 +2701,26 @@ elem_xpow (const FloatComplexNDArray& a,
         {
           for (octave_idx_type i = 0; i < a.length (); i++)
             result.xelem (i) = std::conj (a(i)) / std::norm (a(i));
         }
       else
         {
           for (octave_idx_type i = 0; i < a.length (); i++)
             {
-              OCTAVE_QUIT;
+              octave_quit ();
               result(i) = std::pow (a(i), static_cast<int> (b));
             }
         }
     }
   else
     {
       for (octave_idx_type i = 0; i < a.length (); i++)
 	{
-	  OCTAVE_QUIT;
+	  octave_quit ();
 	  result(i) = std::pow (a(i), b);
 	}
     }
 
   return result;
 }
 
 // -*- 10 -*-
@@ -2735,17 +2735,17 @@ elem_xpow (const FloatComplexNDArray& a,
       gripe_nonconformant ("operator .^", a_dims, b_dims);
       return octave_value ();
     }
 
   FloatComplexNDArray result (a_dims);
 
   for (octave_idx_type i = 0; i < a.length (); i++)
     {
-      OCTAVE_QUIT;
+      octave_quit ();
       float btmp = b(i);
       if (xisint (btmp))
 	result(i) = std::pow (a(i), static_cast<int> (btmp));
       else
 	result(i) = std::pow (a(i), btmp);
     }
 
   return result;
@@ -2754,17 +2754,17 @@ elem_xpow (const FloatComplexNDArray& a,
 // -*- 11 -*-
 octave_value
 elem_xpow (const FloatComplexNDArray& a, const FloatComplex& b)
 {
   FloatComplexNDArray result (a.dims ());
 
   for (octave_idx_type i = 0; i < a.length (); i++)
     {
-      OCTAVE_QUIT;
+      octave_quit ();
       result(i) = std::pow (a(i), b);
     }
 
   return result;
 }
 
 // -*- 12 -*-
 octave_value
@@ -2778,17 +2778,17 @@ elem_xpow (const FloatComplexNDArray& a,
       gripe_nonconformant ("operator .^", a_dims, b_dims);
       return octave_value ();
     }
 
   FloatComplexNDArray result (a_dims);
 
   for (octave_idx_type i = 0; i < a.length (); i++)
     {
-      OCTAVE_QUIT;
+      octave_quit ();
       result(i) = std::pow (a(i), b(i));
     }
 
   return result;
 }
 
 /*
 ;;; Local Variables: ***
