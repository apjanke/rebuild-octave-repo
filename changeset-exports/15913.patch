# HG changeset patch
# User Michael Goffioul <michael.goffioul@gmail.com>
# Date 1357666470 18000
#      Tue Jan 08 12:34:30 2013 -0500
# Branch classdef
# Node ID 8521321604df33d1cb03eadbb5cc113e9415d2b0
# Parent  b18b7e560236e6cab20b2764e2bdb8bcaf266736
Initial support for object array semantic.

* libinterp/octave-value/ov-classdef.h (class cdef_object_array): New class.
(cdef_object_rep::empty_clone, cdef_object_rep::copy,
cdef_object_rep::make_array, cdef_object_rep::is_array,
cdef_object_rep::array_value): New methods.
(cdef_object::empty_clone, cdef_object::make_array, cdef_object::copy,
cdef_object::is_array, cdef_object::array_value): Likewise.
(cdef_object_base::empty_clone, cdef_object_base::make_array): Likewise.
(handle_cdef_object::copy): Likewise.
(value_cdef_object::copy): Likewise.
(cdef_class::cdef_class_rep::copy, cdef_property::cdef_property_rep::copy,
cdef_method::cdef_method_rep::copy, cdef_package::cdef_package_rep::copy):
Likewise.
(handle_cdef_object::handle_cdef_object): New copy constructor.
(cdef_object::make_unique): New method.
(cdef_object::subsasgn): Use it.
(cdef_class::cdef_class_rep::meta): New member.
(cdef_class::cdef_class_rep::cdef_class_rep): Initialize it.
(cdef_class::cdef_class_rep::mark_as_meta_class,
cdef_class::cdef_class_rep::is_meta): Use and manipulate it.
(cdef_class::mark_as_meta_class, cdef_class::is_meta): Likewise.
(cdef_class::cdef_class_rep::construct_object,
cdef_class::cdef_class_rep::is_abstract, cdef_class::cdef_class_rep::is_sealed):
New methods.
(cdef_class::construct_object, cdef_class::is_abstract, cdef_class::is_sealed):
Likewise.
(cdef_class::cdef_class_rep::cdef_class_rep): New copy constructor.
(cdef_property::cdef_property_rep::default_value): Remove member.
(cdef_property::cdef_property_rep::get_value ()): Use "DefaultValue" slot.
(cdef_property::cdef_property_rep::set_value (octave_value)): Remove method.
(cdef_property::set_value (octave_value)): Likewise.
(cdef_property::cdef_property_rep::cdef_property_rep): New copy constructor.
(cdef_method::cdef_method_rep::cdef_method_rep): Likewise.
(cdef_package::cdef_package_rep::cdef_package_rep): Likewise.
(octave_classdef::empty_clone): Call cdef_object::empty_clone.
(octave_classdef::undef_subsasgn): New method.
(class cdef_property, class cdef_method, class cdef_package): Mark cdef_class
as friend.

* libinterp/octave-value/ov-classdef.cc: Include Array.cc.
(make_class): Initialize "Abstract" property. Do not register classes with
empty name.
(make_meta_class): New static function.
(make_method): Check whether function object is valid.
(make_package): Do not register packages with empty name.
(octave_classdef::undef_subsasgn): New method.
(class cdef_object_array): New class.
(cdef_class::cdef_class_rep::cdef_class_rep): Initialize meta.
(cdef_class::cdef_class_rep::find_methods,
cdef_class::cdef_class_rep::find_names): Use cdef_method::is_constructor
instead of relying on the method name.
(cdef_class::cdef_class_rep::construct_object): New method.
(cdef_class::cdef_class_rep::construct): Use it.
(install_classdef): Use make_meta_class. Create "Abstract" property for
class meta.class.

diff --git a/libinterp/octave-value/ov-classdef.cc b/libinterp/octave-value/ov-classdef.cc
--- a/libinterp/octave-value/ov-classdef.cc
+++ b/libinterp/octave-value/ov-classdef.cc
@@ -36,16 +36,18 @@ along with Octave; see the file COPYING.
 #include "pt-classdef.h"
 #include "pt-funcall.h"
 #include "pt-misc.h"
 #include "pt-stmt.h"
 #include "pt-walk.h"
 #include "symtab.h"
 #include "toplev.h"
 
+#include "Array.cc"
+
 static std::map<std::string, cdef_class> all_classes;
 static std::map<std::string, cdef_package> all_packages;
 
 static void
 gripe_method_access (const std::string& from, const cdef_method& meth)
 {
   octave_value acc = meth.get ("Access");
   std::string acc_s;
@@ -606,16 +608,17 @@ handle_delete (const octave_value_list& 
 
 static cdef_class
 make_class (const std::string& name,
             const std::list<cdef_class>& super_list = std::list<cdef_class> ())
 {
   cdef_class cls (name, super_list);
 
   cls.set_class (cdef_class::meta_class ());
+  cls.put ("Abstract", false);
   cls.put ("ConstructOnLoad", false);
   cls.put ("ContainingPackage", Matrix ());
   cls.put ("Description", std::string ());
   cls.put ("DetailedDescription", std::string ());
   cls.put ("Events", Cell ());
   cls.put ("Hidden", false);
   cls.put ("InferiorClasses", Cell ());
   cls.put ("Methods", Cell ());
@@ -652,36 +655,46 @@ make_class (const std::string& name,
           if (has_handle_class)
             cls.mark_as_handle_class ();
         }
     }
 
   if (error_state)
     return cdef_class ();
 
-  all_classes[name] = cls;
+  if (! name.empty ())
+    all_classes[name] = cls;
 
   return cls;
 }
 
 static cdef_class
 make_class (const std::string& name, const cdef_class& super)
 {
   return make_class (name, std::list<cdef_class> (1, super));
 }
 
+static cdef_class
+make_meta_class (const std::string& name, const cdef_class& super)
+{
+  cdef_class cls = make_class (name, super);
+
+  cls.put ("Sealed", true);
+  cls.mark_as_meta_class ();
+
+  return cls;
+}
+
 static cdef_property
 make_property (const cdef_class& cls, const std::string& name,
 	       const octave_value& get_method = Matrix (),
 	       const std::string& get_access = "public",
 	       const octave_value& set_method = Matrix (),
 	       const std::string& set_access = "public")
 {
-  // FIXME: what about default value?
-
   cdef_property prop (name);
 
   prop.set_class (cdef_class::meta_property ());
   prop.put ("Description", std::string ());
   prop.put ("DetailedDescription", std::string ());
   prop.put ("Abstract", false);
   prop.put ("Constant", false);
   prop.put ("GetAccess", get_access);
@@ -725,17 +738,18 @@ make_method (const cdef_class& cls, cons
   meth.put ("Access", m_access);
   meth.put ("DefiningClass", to_ov (cls));
   meth.put ("Description", std::string ());
   meth.put ("DetailedDescription", std::string ());
   meth.put ("Hidden", false);
   meth.put ("Sealed", true);
   meth.put ("Static", is_static);
 
-  make_function_of_class (cls, fcn);
+  if (fcn.is_defined ())
+    make_function_of_class (cls, fcn);
 
   meth.set_function (fcn);
 
   return meth;
 }
 
 inline cdef_method
 make_method (const cdef_class& cls, const std::string& name,
@@ -752,17 +766,18 @@ make_package (const std::string& nm,
               const std::string& parent = std::string ())
 {
   cdef_package pack ("meta.package");
 
   pack.set_class (cdef_class::meta_package ());
   pack.put ("Name", nm);
   pack.put ("ContainingPackage", to_ov (all_packages[parent]));
 
-  all_packages[nm] = pack;
+  if (! nm.empty ())
+    all_packages[nm] = pack;
 
   return pack;
 }
 
 //----------------------------------------------------------------------------
 
 DEFINE_OCTAVE_ALLOCATOR (octave_classdef);
 
@@ -801,16 +816,34 @@ octave_classdef::subsref (const std::str
 octave_value
 octave_classdef::subsasgn (const std::string& type,
                            const std::list<octave_value_list>& idx,
                            const octave_value& rhs)
 {
   return object.subsasgn (type, idx, rhs);
 }
 
+octave_value
+octave_classdef::undef_subsasgn (const std::string& type,
+                                 const std::list<octave_value_list>& idx,
+                                 const octave_value& rhs)
+{
+  if (type.length () == 1 && type[0] == '(')
+    {
+      object = object.make_array ();
+
+      if (! error_state)
+        return subsasgn (type, idx, rhs);
+    }
+  else
+    return octave_base_value::undef_subsasgn (type, idx, rhs);
+
+  return octave_value ();
+}
+
 //----------------------------------------------------------------------------
 
 class octave_classdef_proxy : public octave_function
 {
 public:
   octave_classdef_proxy (const cdef_class& _klass)
     : klass (_klass) { }
 
@@ -1175,16 +1208,181 @@ cdef_object_scalar::mark_for_constructio
   if (! error_state)
     {
       std::list<cdef_class> supcls_list = lookup_classes (supcls);
 
       if (! error_state)
         ctor_list[cls] = supcls_list;
     }
 }
+
+octave_value_list
+cdef_object_array::subsref (const std::string& type,
+                            const std::list<octave_value_list>& idx,
+                            int /* nargout */, size_t& skip,
+                            const cdef_class& /* context */)
+{
+  octave_value_list retval;
+
+  skip = 1;
+
+  switch (type[0])
+    {
+    case '(':
+        {
+          const octave_value_list& ival = idx.front ();
+          bool is_scalar = true;
+          Array<idx_vector> iv (dim_vector (1, ival.length ()));
+
+          for (int i = 0; ! error_state && i < ival.length (); i++)
+            {
+              iv(i) = ival(i).index_vector ();
+              if (! error_state)
+                is_scalar = is_scalar && iv(i).is_scalar ();
+            }
+
+          if (! error_state)
+            {
+              Array<cdef_object> ires = array.index (iv);
+
+              if (! error_state)
+                {
+                  if (is_scalar)
+                    retval(0) = to_ov (ires(0));
+                  else
+                    {
+                      cdef_object array_obj (new cdef_object_array (ires));
+
+                      array_obj.set_class (get_class ());
+
+                      retval(0) = to_ov (array_obj);
+                    }
+                }
+            }
+        }
+      break;
+
+    default:
+      ::error ("can't perform indexing operation on array of %s objects",
+               class_name ().c_str ());
+      break;
+    }
+
+  return retval;
+}
+
+octave_value
+cdef_object_array::subsasgn (const std::string& type,
+                             const std::list<octave_value_list>& idx,
+                             const octave_value& rhs)
+{
+  octave_value retval;
+
+  switch (type[0])
+    {
+    case '(':
+      if (type.length () == 1)
+        {
+          cdef_object rhs_obj = to_cdef (rhs);
+
+          if (! error_state)
+            {
+              if (rhs_obj.get_class () == get_class ())
+                {
+                  const octave_value_list& ival = idx.front ();
+                  bool is_scalar = true;
+                  Array<idx_vector> iv (dim_vector (1, ival.length ()));
+
+                  for (int i = 0; ! error_state && i < ival.length (); i++)
+                    {
+                      iv(i) = ival(i).index_vector ();
+                      if (! error_state)
+                        is_scalar = is_scalar && iv(i).is_scalar ();
+                    }
+
+                  if (! error_state)
+                    {
+                      Array<cdef_object> rhs_mat;
+
+                      if (! rhs_obj.is_array ())
+                        {
+                          rhs_mat = Array<cdef_object> (dim_vector (1, 1));
+                          rhs_mat(0) = rhs_obj;
+                        }
+                      else
+                        rhs_mat = rhs_obj.array_value ();
+
+                      if (! error_state)
+                        {
+                          octave_idx_type n = array.numel ();
+
+                          array.assign (iv, rhs_mat, cdef_object ());
+
+                          if (! error_state)
+                            {
+                              if (array.numel () > n)
+                                fill_empty_values ();
+
+                              if (! error_state)
+                                {
+                                  refcount++;
+                                  retval = to_ov (cdef_object (this));
+                                }
+                            }
+                        }
+                    }
+                }
+              else
+                ::error ("can't assign %s object into array of %s objects.",
+                         rhs_obj.class_name ().c_str (),
+                         class_name ().c_str ());
+            }
+        }
+      else
+        ::error ("can't perform indexing operation on array of %s objects",
+                 class_name ().c_str ());
+      break;
+
+    default:
+      ::error ("can't perform indexing operation on array of %s objects",
+               class_name ().c_str ());
+      break;
+    }
+
+  return retval;
+}
+
+void
+cdef_object_array::fill_empty_values (void)
+{
+  cdef_class cls = get_class ();
+
+  if (! error_state)
+    {
+      cdef_object obj;
+
+      int n = array.numel ();
+
+      for (int i = 0; ! error_state && i < n; i++)
+        {
+          if (! array.xelem (i).ok ())
+            {
+              if (! obj.ok ())
+                {
+                  obj = cls.construct_object (octave_value_list ());
+
+                  if (! error_state)
+                    array.xelem (i) = obj;
+                }
+              else
+                array.xelem (i) = obj.copy ();
+            }
+        }
+    }
+}
   
 bool cdef_object_scalar::is_constructed_for (const cdef_class& cls) const
 {
   return (is_constructed ()
           || ctor_list.find (cls) == ctor_list.end ());
 }
 
 bool cdef_object_scalar::is_partially_constructed_for (const cdef_class& cls) const
@@ -1214,17 +1412,17 @@ handle_cdef_object::~handle_cdef_object 
 value_cdef_object::~value_cdef_object (void)
 {
   gnulib::printf ("deleting %s object (value)\n",
                   get_class ().get_name ().c_str ());
 }
 
 cdef_class::cdef_class_rep::cdef_class_rep (const std::list<cdef_class>& superclasses)
      : handle_cdef_object (), member_count (0), handle_class (false),
-       object_count (0)
+       object_count (0), meta (false)
 {
   put ("SuperClasses", to_ov (superclasses));
   implicit_ctor_list = superclasses;
 }
 
 cdef_method
 cdef_class::cdef_class_rep::find_method (const std::string& nm, bool local)
 {
@@ -1469,24 +1667,22 @@ cdef_class::cdef_class_rep::get_methods 
 void
 cdef_class::cdef_class_rep::find_methods (std::map<std::string, cdef_method>& meths,
                                           bool only_inherited)
 {
   load_all_methods ();
 
   method_const_iterator it;
 
-  std::string cls_name = get_base_name (get_name ());
-
   for (it = method_map.begin (); it != method_map.end (); ++it)
     {
-      std::string nm = it->second.get_name ();
-
-      if (nm != cls_name)
+      if (! it->second.is_constructor ())
         {
+          std::string nm = it->second.get_name ();
+
           if (meths.find (nm) == meths.end ())
             {
               if (only_inherited)
                 {
                   octave_value acc = it->second.get ("Access");
 
                   if (! acc.is_string ()
                       || acc.string_value () == "private")
@@ -1619,25 +1815,23 @@ cdef_class::cdef_class_rep::find_propert
 }
 
 void
 cdef_class::cdef_class_rep::find_names (std::set<std::string>& names,
                                         bool all)
 {
   load_all_methods ();
 
-  std::string cls_name = get_base_name (get_name ());
-
   for (method_const_iterator it = method_map.begin ();
        ! error_state && it != method_map.end(); ++it)
     {
-      std::string nm = it->second.get_name ();
-
-      if (nm != cls_name)
+      if (! it->second.is_constructor ())
         {
+          std::string nm = it->second.get_name ();
+
           if (! all)
             {
               octave_value acc = it->second.get ("Access");
 
               if (! acc.is_string()
                   || acc.string_value () != "public")
                 continue;
             }
@@ -1843,37 +2037,103 @@ cdef_class::cdef_class_rep::run_construc
     }
 
   obj.mark_as_constructed (wrap ());
 }
 
 octave_value
 cdef_class::cdef_class_rep::construct (const octave_value_list& args)
 {
-  cdef_object_rep *r;
-
-  if (is_handle_class ())
-    r = new handle_cdef_object ();
+  cdef_object obj = construct_object (args);
+
+  if (! error_state && obj.ok ())
+    return to_ov (obj);
+
+  return octave_value ();
+}
+
+cdef_object
+cdef_class::cdef_class_rep::construct_object (const octave_value_list& args)
+{
+  if (! is_abstract ())
+    {
+      cdef_object obj;
+
+      if (is_meta_class ())
+        {
+          // This code path is only used to create empty meta objects
+          // as filler for the empty values within a meta object array.
+
+          cdef_class this_cls = wrap ();
+
+          static cdef_object empty_class;
+
+          if (this_cls == cdef_class::meta_class ())
+            {
+              if (! empty_class.ok ())
+                empty_class = make_class ("", std::list<cdef_class> ());
+              obj = empty_class;
+            }
+          else if (this_cls == cdef_class::meta_property ())
+            {
+              static cdef_property empty_property;
+
+              if (! empty_class.ok ())
+                empty_class = make_class ("", std::list<cdef_class> ());
+              if (! empty_property.ok ())
+                empty_property = make_property (empty_class, "");
+              obj = empty_property;
+            }
+          else if (this_cls == cdef_class::meta_method ())
+            {
+              static cdef_method empty_method;
+
+              if (! empty_class.ok ())
+                empty_class = make_class ("", std::list<cdef_class> ());
+              if (! empty_method.ok ())
+                empty_method = make_method (empty_class, "", octave_value ());
+              obj = empty_method;
+            }
+          else if (this_cls == cdef_class::meta_package ())
+            {
+              static cdef_package empty_package;
+
+              if (! empty_package.ok ())
+                empty_package = make_package ("");
+              obj = empty_package;
+            }
+          else
+            panic_impossible ();
+
+          return obj;
+        }
+      else
+        {
+          if (is_handle_class ())
+            obj = cdef_object (new handle_cdef_object ());
+          else
+            obj = cdef_object (new value_cdef_object ());
+          obj.set_class (wrap ());
+
+          initialize_object (obj);
+
+          if (! error_state)
+            {
+              run_constructor (obj, args);
+
+              if (! error_state)
+                return obj;
+            }
+        }
+    }
   else
-    r = new value_cdef_object ();
-  r->set_class (wrap ());
-
-  cdef_object obj (r);
-
-  initialize_object (obj);
-
-  if (! error_state)
-    {
-      run_constructor (obj, args);
-
-      if (! error_state)
-        return to_ov (obj);
-    }
-
-  return octave_value();
+    error ("cannot instantiate object for abstract class `%s'",
+           get_name ().c_str ());
+
+  return cdef_object ();
 }
 
 static octave_value
 compute_attribute_value (tree_classdef_attribute* t)
 {
   if (t->expression ())
     {
       if (t->expression ()->is_identifier ())
@@ -2438,37 +2698,30 @@ cdef_package cdef_package::_meta = cdef_
 
 void
 install_classdef (void)
 {
   octave_classdef::register_type ();
 
   /* bootstrap */
   cdef_class handle = make_class ("handle");
-  cdef_class meta_class = cdef_class::_meta_class = make_class ("meta.class", handle);
+  cdef_class meta_class = cdef_class::_meta_class = make_meta_class ("meta.class", handle);
   handle.set_class (meta_class);
   meta_class.set_class (meta_class);
 
   /* meta classes */
-  cdef_class meta_property = cdef_class::_meta_property = make_class ("meta.property", handle);
-  cdef_class meta_method = cdef_class::_meta_method = make_class ("meta.method", handle);
-  cdef_class meta_package = cdef_class::_meta_package = make_class ("meta.package", handle);
-
-  cdef_class meta_event = make_class ("meta.event", handle);
-  cdef_class meta_dynproperty = make_class ("meta.dynamicproperty", handle);
-
-  /* meta classes are all sealed */
-  meta_class.put ("Sealed", true);
-  meta_property.put ("Sealed", true);
-  meta_method.put ("Sealed", true);
-  meta_package.put ("Sealed", true);
-  meta_event.put ("Sealed", true);
-  meta_dynproperty.put ("Sealed", true);
+  cdef_class meta_property = cdef_class::_meta_property = make_meta_class ("meta.property", handle);
+  cdef_class meta_method = cdef_class::_meta_method = make_meta_class ("meta.method", handle);
+  cdef_class meta_package = cdef_class::_meta_package = make_meta_class ("meta.package", handle);
+
+  cdef_class meta_event = make_meta_class ("meta.event", handle);
+  cdef_class meta_dynproperty = make_meta_class ("meta.dynamicproperty", handle);
 
   /* meta.class properties */
+  meta_class.install_property (make_attribute (meta_class, "Abstract"));
   meta_class.install_property (make_attribute (meta_class, "ConstructOnLoad"));
   meta_class.install_property (make_property  (meta_class, "ContainingPackage"));
   meta_class.install_property (make_property  (meta_class, "Description"));
   meta_class.install_property (make_property  (meta_class, "DetailedDescription"));
   meta_class.install_property (make_property  (meta_class, "Events"));
   meta_class.install_property (make_attribute (meta_class, "HandleCompatible"));
   meta_class.install_property (make_attribute (meta_class, "Hidden"));
   meta_class.install_property
diff --git a/libinterp/octave-value/ov-classdef.h b/libinterp/octave-value/ov-classdef.h
--- a/libinterp/octave-value/ov-classdef.h
+++ b/libinterp/octave-value/ov-classdef.h
@@ -58,24 +58,50 @@ public:
     { gripe_invalid_object ("set_class"); }
 
   virtual cdef_object_rep* clone (void) const
     {
       gripe_invalid_object ("clone");
       return new cdef_object_rep ();
     }
 
+  virtual cdef_object_rep* empty_clone (void) const
+    {
+      gripe_invalid_object ("empty_clone");
+      return new cdef_object_rep ();
+    }
+
+  virtual cdef_object_rep* copy (void) const
+    {
+      gripe_invalid_object ("copy");
+      return new cdef_object_rep ();
+    }
+
+  virtual cdef_object_rep* make_array (void) const
+    {
+      gripe_invalid_object ("make_array");
+      return new cdef_object_rep ();
+    }
+
+  virtual bool is_array (void) const { return false; }
+
   virtual bool is_class (void) const { return false; }
 
   virtual bool is_property (void) const { return false; }
 
   virtual bool is_method (void) const { return false; }
 
   virtual bool is_package (void) const { return false; }
 
+  virtual Array<cdef_object> array_value (void) const
+    {
+      gripe_invalid_object ("array_value");
+      return Array<cdef_object> ();
+    }
+
   virtual void put (const std::string&, const octave_value&)
     { gripe_invalid_object ("put"); }
 
   virtual octave_value get (const std::string&) const
     {
       gripe_invalid_object ("get");
       return octave_value ();
     }
@@ -194,39 +220,55 @@ public:
   void set_class (const cdef_class& cls) { rep->set_class (cls); }
 
   std::string class_name (void) const
     { return rep->class_name (); }
 
   cdef_object clone (void) const
     { return cdef_object (rep->clone ()); }
 
+  cdef_object empty_clone (void) const
+    { return cdef_object (rep->empty_clone ()); }
+
+  cdef_object make_array (void) const
+    { return cdef_object (rep->make_array ()); }
+
+  cdef_object copy (void) const
+    { return cdef_object (rep->copy ()); }
+
+  bool is_array (void) const { return rep->is_array (); }
+
   bool is_class (void) const { return rep->is_class (); }
 
   bool is_property (void) const { return rep->is_property (); }
 
   bool is_method (void) const { return rep->is_method (); }
 
   bool is_package (void) const { return rep->is_package (); }
 
+  Array<cdef_object> array_value (void) const { return rep->array_value (); }
+
   void put (const std::string& pname, const octave_value& val)
     { rep->put (pname, val); }
 
   octave_value get (const std::string& pname) const
     { return rep->get (pname); }
 
   octave_value_list
   subsref (const std::string& type, const std::list<octave_value_list>& idx,
            int nargout, size_t& skip, const cdef_class& context)
     { return rep->subsref (type, idx, nargout, skip, context); }
 
   octave_value
   subsasgn (const std::string& type, const std::list<octave_value_list>& idx,
             const octave_value& rhs)
-    { return rep->subsasgn (type, idx, rhs); }
+    {
+      make_unique ();
+      return rep->subsasgn (type, idx, rhs);
+    }
 
   string_vector map_keys (void) const { return rep->map_keys (); }
 
   const cdef_object_rep* get_rep (void) const { return rep; }
 
   bool ok (void) const { return rep->is_valid (); }
 
   void mark_for_construction (const cdef_class& cls)
@@ -243,16 +285,22 @@ public:
   void mark_as_constructed (void) { rep->mark_as_constructed (); }
 
   void mark_as_constructed (const cdef_class& cls)
     { rep->mark_as_constructed (cls); }
 
 protected:
   cdef_object_rep* get_rep (void) { return rep; }
 
+  void make_unique (void)
+    {
+      if (rep->refcount > 1)
+        *this = clone ();
+    }
+
 private:
   cdef_object_rep *rep;
 };
 
 class
 cdef_object_base : public cdef_object_rep
 {
 public:
@@ -263,16 +311,21 @@ public:
     }
 
   ~cdef_object_base (void) { unregister_object (); }
 
   cdef_class get_class (void) const;
 
   void set_class (const cdef_class& cls);
 
+  cdef_object_rep* empty_clone (void) const
+    { return new cdef_object_base (*this); }
+
+  cdef_object_rep* make_array (void) const;
+
 protected:
   // Restricted copying!
   cdef_object_base (const cdef_object_base& obj)
     : cdef_object_rep (obj), klass (obj.klass)
     {
       register_object ();
     }
 
@@ -286,16 +339,56 @@ private:
   cdef_object klass;
 
 private:
   // No assignment!
   cdef_object_base& operator = (const cdef_object_base&);
 };
 
 class
+cdef_object_array : public cdef_object_base
+{
+public:
+  cdef_object_array (void) : cdef_object_base () { }
+
+  cdef_object_array (const Array<cdef_object>& a)
+    : cdef_object_base (), array (a) { }
+
+  cdef_object_rep* clone (void) const
+    { return new cdef_object_array (*this); }
+
+  bool is_valid (void) const { return true; }
+
+  bool is_array (void) const { return true; }
+
+  Array<cdef_object> array_value (void) const { return array; }
+
+  octave_value_list
+  subsref (const std::string& type, const std::list<octave_value_list>& idx,
+           int nargout, size_t& skip, const cdef_class& context);
+
+  octave_value
+  subsasgn (const std::string& type, const std::list<octave_value_list>& idx,
+            const octave_value& rhs);
+
+private:
+  Array<cdef_object> array;
+
+private:
+  void fill_empty_values (void);
+
+  // Private copying!
+  cdef_object_array (const cdef_object_array& obj)
+    : cdef_object_base (obj), array (obj.array) { }
+
+  // No assignment!
+  cdef_object_array& operator = (const cdef_object_array&);
+};
+
+class
 cdef_object_scalar : public cdef_object_base
 {
 public:
   cdef_object_scalar (void) : cdef_object_base () { }
 
   ~cdef_object_scalar (void) { }
 
   void put (const std::string& pname, const octave_value& val)
@@ -362,38 +455,44 @@ public:
 
   cdef_object_rep* clone (void) const
     {
       handle_cdef_object *obj = const_cast<handle_cdef_object *> (this);
       obj->refcount++;
       return obj;
     }
 
+  cdef_object_rep* copy (void) const
+    { return new handle_cdef_object (*this); }
+
   bool is_valid (void) const { return true; }
 
+protected:
+  // Restricted copying!
+  handle_cdef_object (const handle_cdef_object& obj)
+    : cdef_object_scalar (obj) { }
+
 private:
-  // No copying
-  handle_cdef_object (const handle_cdef_object&);
+  // No assignment
   handle_cdef_object& operator = (const handle_cdef_object&);
 };
 
 class
 value_cdef_object : public cdef_object_scalar
 {
 public:
   value_cdef_object (void)
       : cdef_object_scalar () { }
 
   ~value_cdef_object (void);
 
   cdef_object_rep* clone (void) const
-    {
-      value_cdef_object* obj = new value_cdef_object (*this);
-      return obj;
-    }
+    { return new value_cdef_object (*this); }
+
+  cdef_object_rep* copy (void) const { return clone (); }
 
   bool is_valid (void) const { return true; }
 
 private:
   // Private copying!
   value_cdef_object (const value_cdef_object& obj)
     : cdef_object_scalar (obj) { }
 
@@ -407,27 +506,33 @@ cdef_class : public cdef_object
 private:
 
   class
   cdef_class_rep : public handle_cdef_object
   {
   public:
     cdef_class_rep (void)
 	: handle_cdef_object (), member_count (0), handle_class (false),
-          object_count (0) { }
+          object_count (0), meta (false) { }
 
     cdef_class_rep (const std::list<cdef_class>& superclasses);
 
+    cdef_object_rep* copy (void) const { return new cdef_class_rep (*this); }
+
     bool is_class (void) const { return true; }
 
     std::string get_name (void) const
       { return get ("Name").string_value (); }
 
     void set_name (const std::string& nm) { put ("Name", nm); }
 
+    bool is_abstract (void) const { return get ("Abstract").bool_value (); }
+
+    bool is_sealed (void) const { return get ("Sealed").bool_value (); }
+
     cdef_method find_method (const std::string& nm, bool local = false);
 
     void install_method (const cdef_method& meth);
 
     Cell get_methods (void);
 
     cdef_property find_property (const std::string& nm);
 
@@ -444,16 +549,18 @@ private:
     void delete_object (cdef_object obj);
 
     octave_value_list
     subsref_meta (const std::string& type,
                   const std::list<octave_value_list>& idx, int nargout);
 
     octave_value construct (const octave_value_list& args);
 
+    cdef_object construct_object (const octave_value_list& args);
+
     void initialize_object (cdef_object& obj);
 
     void run_constructor (cdef_object& obj, const octave_value_list& args);
 
     void mark_as_handle_class (void) { handle_class = true; }
 
     bool is_handle_class (void) const { return handle_class; }
 
@@ -473,16 +580,20 @@ private:
             member_count = 0;
             method_map.clear ();
             property_map.clear ();
           }
         else
           delete this;
       }
 
+    void mark_as_meta_class (void) { meta = true; }
+
+    bool is_meta_class (void) const { return meta; }
+
   private:
     void load_all_methods (void);
 
     void find_names (std::set<std::string>& names, bool all);
     
     void find_properties (std::map<std::string,cdef_property>& props,
                           bool only_inherited);
 
@@ -516,21 +627,32 @@ private:
     // The list of super-class constructors that are called implicitly by the
     // the classdef engine when creating an object. These constructors are not
     // called explicitly by the class constructor.
     std::list<cdef_class> implicit_ctor_list;
 
     // The number of objects of this class.
     octave_refcount<octave_idx_type> object_count;
 
+    // TRUE if this class is a built-in meta class.
+    bool meta;
+
     // Utility iterator typedef's.
     typedef std::map<std::string,cdef_method>::iterator method_iterator;
     typedef std::map<std::string,cdef_method>::const_iterator method_const_iterator;
     typedef std::map<std::string,cdef_property>::iterator property_iterator;
     typedef std::map<std::string,cdef_property>::const_iterator property_const_iterator;
+
+  private:
+    cdef_class_rep (const cdef_class_rep& c)
+      : handle_cdef_object (c), directory (c.directory),
+        method_map (c.method_map), property_map (c.property_map),
+        member_count (c.member_count), handle_class (c.handle_class),
+        implicit_ctor_list (c.implicit_ctor_list),
+        object_count (c.object_count), meta (c.meta) { }
   };
 
 public:
   // Create and invalid class object
   cdef_class (void)
       : cdef_object () { }
 
   cdef_class (const std::string& nm,
@@ -579,16 +701,20 @@ public:
   
   void install_property (const cdef_property& prop)
     { get_rep ()->install_property (prop); }
 
   Cell get_properties (void) { return get_rep ()->get_properties (); }
 
   string_vector get_names (void) { return get_rep ()->get_names (); }
 
+  bool is_abstract (void) const { return get_rep ()->is_abstract (); }
+
+  bool is_sealed (void) const { return get_rep ()->is_sealed (); }
+
   void set_directory (const std::string& dir)
     { get_rep ()->set_directory (dir); }
 
   std::string get_directory (void) const
     { return get_rep ()->get_directory (); }
 
   std::string get_name (void) const
     { return get_rep ()->get_name (); }
@@ -609,28 +735,35 @@ public:
   octave_function* get_method_function (const std::string& nm);
 
   octave_function* get_constructor_function (void)
     { return get_method_function (get_name ()); }
 
   octave_value construct (const octave_value_list& args)
     { return get_rep ()->construct (args); }
 
+  cdef_object construct_object (const octave_value_list& args)
+    { return get_rep ()->construct_object (args); }
+
   void initialize_object (cdef_object& obj)
     { get_rep ()->initialize_object (obj); }
 
   void run_constructor (cdef_object& obj, const octave_value_list& args)
     { get_rep ()->run_constructor (obj, args); }
 
   void mark_as_handle_class (void)
     { get_rep ()->mark_as_handle_class (); }
 
   bool is_handle_class (void) const
     { return get_rep ()->is_handle_class (); }
 
+  void mark_as_meta_class (void) { get_rep ()->mark_as_meta_class (); }
+
+  bool is_meta_class (void) const { return get_rep ()->is_meta_class (); }
+
   static const cdef_class& meta_class (void) { return _meta_class; }
   static const cdef_class& meta_property (void) { return _meta_property; }
   static const cdef_class& meta_method (void) { return _meta_method; }
   static const cdef_class& meta_package (void) { return _meta_package; }
 
   void register_object (void) { get_rep ()->register_object (); }
 
   void unregister_object (void) { get_rep ()->unregister_object (); }
@@ -667,46 +800,48 @@ operator != (const cdef_class& clsa, con
 // This is only to be able to use cdef_class as map keys.
 inline bool
 operator < (const cdef_class& clsa, const cdef_class& clsb)
 { return clsa.get_rep () < clsb.get_rep (); }
 
 class
 cdef_property : public cdef_object
 {
+  friend cdef_class;
+
 private:
 
   class
   cdef_property_rep : public handle_cdef_object
   {
   public:
     cdef_property_rep (void)
 	: handle_cdef_object () { }
 
+    cdef_object_rep* copy (void) const { return new cdef_property_rep (*this); }
+
     bool is_property (void) const { return true; }
 
     std::string get_name (void) const { return get("Name").string_value (); }
 
     void set_name (const std::string& nm) { put ("Name", nm); }
 
     bool is_constant (void) const { return get("Constant").bool_value (); }
 
-    octave_value get_value (void) const { return default_value; }
+    octave_value get_value (void) const { return get ("DefaultValue"); }
 
     octave_value get_value (const cdef_object& obj);
 
-    void set_value (const octave_value& val) { default_value = val; }
-
     void set_value (cdef_object& obj, const octave_value& val);
 
   private:
-    bool is_recursive_set (const cdef_object& obj) const;
+    cdef_property_rep (const cdef_property_rep& p)
+      : handle_cdef_object (p) { }
 
-  private:
-    octave_value default_value;
+    bool is_recursive_set (const cdef_object& obj) const;
   };
 
 public:
   cdef_property (void) : cdef_object () { }
 
   cdef_property (const std::string& nm)
       : cdef_object (new cdef_property_rep ())
     { get_rep ()->set_name (nm); }
@@ -733,18 +868,16 @@ public:
   octave_value get_value (const cdef_object& obj)
     { return get_rep ()->get_value (obj); }
 
   octave_value get_value (void) { return get_rep ()->get_value (); }
 
   void set_value (cdef_object& obj, const octave_value& val)
     { get_rep ()->set_value (obj, val); }
 
-  void set_value (const octave_value& val) { get_rep ()->set_value (val); }
- 
   bool check_get_access (void) const;
   
   bool check_set_access (void) const;
 
   std::string get_name (void) const { return get_rep ()->get_name (); }
 
   bool is_constant (void) const { return get_rep ()->is_constant (); }
 
@@ -754,24 +887,28 @@ private:
   
   const cdef_property_rep* get_rep (void) const
     { return dynamic_cast<const cdef_property_rep *> (cdef_object::get_rep ()); }
 };
 
 class
 cdef_method : public cdef_object
 {
+  friend cdef_class;
+
 private:
 
   class
   cdef_method_rep : public handle_cdef_object
   {
   public:
     cdef_method_rep (void) : handle_cdef_object () { }
 
+    cdef_object_rep* copy (void) const { return new cdef_method_rep(*this); }
+
     bool is_method (void) const { return true; }
 
     std::string get_name (void) const { return get("Name").string_value (); }
 
     void set_name (const std::string& nm) { put ("Name", nm); }
 
     bool is_static (void) const { return get("Static").bool_value (); }
 
@@ -782,16 +919,19 @@ private:
     octave_value_list execute (const octave_value_list& args, int nargout);
 
     octave_value_list execute (const cdef_object& obj,
 			       const octave_value_list& args, int nargout);
 
     bool is_constructor (void) const;
 
   private:
+    cdef_method_rep (const cdef_method_rep& m)
+      : handle_cdef_object (m), function (m.function) { }
+
     void check_method (void);
 
   private:
     octave_value function;
   };
 
 public:
   cdef_method (void) : cdef_object () { }
@@ -902,35 +1042,49 @@ cdef_object_base::unregister_object (voi
     {
       cdef_class cls (get_class ());
 
       if (! error_state && cls.ok ())
         cls.unregister_object ();
     }
 }
 
+inline cdef_object_rep*
+cdef_object_base::make_array (void) const
+{
+  cdef_object_rep* r = new cdef_object_array ();
+
+  r->set_class (get_class ());
+
+  return r;
+}
+
 inline cdef_method
 cdef_class::find_method (const std::string& nm, bool local)
 { return get_rep ()->find_method (nm, local); }
 
 inline cdef_property
 cdef_class::find_property (const std::string& nm)
 { return get_rep ()->find_property (nm); }
 
 class
 cdef_package : public cdef_object
 {
+  friend cdef_class;
+
 private:
 
   class
   cdef_package_rep : public handle_cdef_object
   {
   public:
     cdef_package_rep (void) : handle_cdef_object (), member_count (0) { }
 
+    cdef_object_rep* copy (void) const { return new cdef_package_rep (*this); }
+
     bool is_package (void) const { return true; }
 
     std::string get_name (void) const { return get("Name").string_value (); }
 
     void set_name (const std::string& nm) { put ("Name", nm); }
 
     void install_class (const cdef_class& cls, const std::string& nm);
 
@@ -971,16 +1125,22 @@ private:
     octave_idx_type member_count;
 
     typedef std::map<std::string, cdef_class>::iterator class_iterator;
     typedef std::map<std::string, cdef_class>::const_iterator class_const_iterator;
     typedef std::map<std::string, octave_value>::iterator function_iterator;
     typedef std::map<std::string, octave_value>::const_iterator function_const_iterator;
     typedef std::map<std::string, cdef_package>::iterator package_iterator;
     typedef std::map<std::string, cdef_package>::const_iterator package_const_iterator;
+
+  private:
+    cdef_package_rep (const cdef_package_rep& p)
+      : handle_cdef_object (p), class_map (p.class_map),
+        function_map (p.function_map), package_map (p.package_map),
+        member_count (p.member_count) { }
   };
 
 public:
   cdef_package (void) : cdef_object () { }
 
   cdef_package (const std::string& nm)
       : cdef_object (new cdef_package_rep ())
     { get_rep ()->set_name (nm); }
@@ -1048,17 +1208,17 @@ public:
 
   octave_classdef (const octave_classdef& obj)
       : octave_base_value (obj), object (obj.object) { }
 
   octave_base_value* clone (void) const
     { return new octave_classdef (object.clone ()); }
 
   octave_base_value* empty_clone (void) const
-    { return new octave_classdef (); }
+    { return new octave_classdef (object.empty_clone ()); }
 
   cdef_object get_object (void) const { return object; }
 
   cdef_object& get_object_ref (void) { return object; }
 
   bool is_defined (void) const { return true; }
 
   bool is_map (void) const { return true; }
@@ -1086,16 +1246,21 @@ public:
       octave_value_list retval = subsref (type, idx, 1);
       return (retval.length () > 0 ? retval(0) : octave_value ());
     }
 
   octave_value subsasgn (const std::string& type,
                          const std::list<octave_value_list>& idx,
                          const octave_value& rhs);
 
+  octave_value
+  undef_subsasgn (const std::string& type,
+                  const std::list<octave_value_list>& idx,
+                  const octave_value& rhs);
+
   string_vector map_keys (void) const { return object.map_keys (); }
 
   dim_vector dims (void) const { return dim_vector (1, 1); }
 
 private:
   cdef_object object;
 
 private:
