# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1362805378 18000
#      Sat Mar 09 00:02:58 2013 -0500
# Node ID 7b7b1e4968e8d6a914d6c633c3379489fc990d2f
# Parent  e19b1632d7c111f91e05d3f651a4680194aa8c74
use functions instead of token return macros in lexer

* lex.h, lex.ll (DISPLAY_TOK_AND_RETURN, COUNT_TOK_AND_RETURN,
TOK_RETURN, TOK_PUSH_AND_RETURN, BIN_OP_RETURN_INTERNAL,
XBIN_OP_RETURN_INTERNAL, BIN_OP_RETURN, XBIN_OP_RETURN, LEXER_DEBUG):
Delete macros.
(octave_lexer::handle_op, octave_lexer::handle_incompatible_op,
octave_lexer::handle_op_internal, octave_lexer::push_token,
octave_lexer::handle_token, octave_lexer::count_token,
octave_lexer::show_token): New functions.  Use them in place of
deleted macros.
(NOT, POW, EPOW): Delete pattern definitions.
({NOT}, {POW}=, {EPOW}=): Split into separate rules for each pattern.
(octave_lexer::handle_end_of_input, octave_lexer::handle_identifier):
Don't use OCTAVE_YYG here.
(octave_lexer::lexer_debug): Delete text argument.  Use flex_yytext
instead.

diff --git a/libinterp/parse-tree/lex.h b/libinterp/parse-tree/lex.h
--- a/libinterp/parse-tree/lex.h
+++ b/libinterp/parse-tree/lex.h
@@ -480,17 +480,17 @@ public:
   void push_token (token *);
 
   token *current_token (void);
 
   void display_token (int tok);
 
   void fatal_error (const char *msg);
 
-  void lexer_debug (const char *pattern, const char *text);
+  void lexer_debug (const char *pattern);
 
   // Internal state of the flex-generated lexer.
   void *scanner;
 
   // Object that reads and buffers input.
   input_buffer input_buf;
 
   octave_input_reader input_reader;
@@ -528,16 +528,34 @@ public:
   void pop_start_state (void);
 
   void clear_start_state (void);
 
   int start_state (void) const { return start_state_stack.top (); }
 
   void display_start_state (void) const;
 
+  int handle_op (const char *pattern, int tok, bool convert = false,
+                 bool bos = false, bool qit = false);
+
+  int handle_incompatible_op (const char *pattern, int tok,
+                              bool convert = false, bool bos = false,
+                              bool qit = false);
+
+  int handle_op_internal (const char *pattern, int tok, bool convert,
+                          bool bos, bool qit, bool compat);
+
+  int push_token (const std::string& name, int tok);
+
+  int handle_token (int tok);
+
+  int count_token (int tok);
+
+  int show_token (int tok);
+
   // For unwind protect.
   static void cleanup (octave_lexer *lexer) { delete lexer; }
 
 private:
 
   std::stack<int> start_state_stack;
 
   // No copying!
diff --git a/libinterp/parse-tree/lex.ll b/libinterp/parse-tree/lex.ll
--- a/libinterp/parse-tree/lex.ll
+++ b/libinterp/parse-tree/lex.ll
@@ -125,110 +125,16 @@ object) relevant global values before an
 // Try to avoid crashing out completely on fatal scanner errors.
 
 #ifdef YY_FATAL_ERROR
 #undef YY_FATAL_ERROR
 #endif
 #define YY_FATAL_ERROR(msg) \
   (yyget_extra (yyscanner))->fatal_error (msg)
 
-#define DISPLAY_TOK_AND_RETURN(tok) \
-  do \
-    { \
-      int tok_val = tok; \
-      if (Vdisplay_tokens) \
-        curr_lexer->display_token (tok_val); \
-      if (lexer_debug_flag) \
-        { \
-          std::cerr << "R: "; \
-          curr_lexer->display_token (tok_val); \
-          std::cerr << std::endl;  \
-        } \
-      return tok_val; \
-    } \
-  while (0)
-
-#define COUNT_TOK_AND_RETURN(tok) \
-  do \
-    { \
-      if (tok != '\n') \
-        { \
-          Vtoken_count++; \
-          curr_lexer->token_count++; \
-        } \
-      DISPLAY_TOK_AND_RETURN (tok); \
-    } \
-  while (0)
-
-#define TOK_RETURN(tok) \
-  do \
-    { \
-      curr_lexer->current_input_column += yyleng; \
-      curr_lexer->quote_is_transpose = false; \
-      curr_lexer->convert_spaces_to_comma = true; \
-      COUNT_TOK_AND_RETURN (tok); \
-    } \
-  while (0)
-
-#define TOK_PUSH_AND_RETURN(name, tok) \
-  do \
-    { \
-      curr_lexer->push_token \
-        (new token (name, curr_lexer->input_line_number, \
-         curr_lexer->current_input_column)); \
-      TOK_RETURN (tok); \
-    } \
-  while (0)
-
-#define BIN_OP_RETURN_INTERNAL(tok, convert, bos, qit) \
-  do \
-    { \
-      curr_lexer->push_token \
-        (new token (curr_lexer->input_line_number, \
-         curr_lexer->current_input_column)); \
-      curr_lexer->current_input_column += yyleng; \
-      curr_lexer->quote_is_transpose = qit; \
-      curr_lexer->convert_spaces_to_comma = convert; \
-      curr_lexer->looking_for_object_index = false; \
-      curr_lexer->at_beginning_of_statement = bos; \
-      COUNT_TOK_AND_RETURN (tok); \
-    } \
-  while (0)
-
-#define XBIN_OP_RETURN_INTERNAL(tok, convert, bos, qit) \
-  do \
-    { \
-      curr_lexer->gripe_matlab_incompatible_operator (yytext); \
-      BIN_OP_RETURN_INTERNAL (tok, convert, bos, qit); \
-    } \
-  while (0)
-
-#define BIN_OP_RETURN(tok, convert, bos) \
-  do \
-    { \
-      BIN_OP_RETURN_INTERNAL (tok, convert, bos, false); \
-    } \
-  while (0)
-
-#define XBIN_OP_RETURN(tok, convert, bos) \
-  do \
-    { \
-      curr_lexer->gripe_matlab_incompatible_operator (yytext); \
-      BIN_OP_RETURN (tok, convert, bos); \
-    } \
-  while (0)
-
-#define LEXER_DEBUG(pattern) \
-  do \
-    { \
-      if (lexer_debug_flag) \
-        curr_lexer->lexer_debug (pattern, yytext); \
-    } \
-  while (0)
-
 static bool Vdisplay_tokens = false;
 
 static unsigned int Vtoken_count = 0;
 
 // Internal variable for lexer debugging state.
 static bool lexer_debug_flag = false;
 
 // Forward declarations for functions defined at the bottom of this
@@ -244,100 +150,97 @@ NL      ((\n)|(\r)|(\r\n))
 SNL     ({S}|{NL})
 EL      (\.\.\.)
 BS      (\\)
 CONT    ({EL}|{BS})
 Im      [iIjJ]
 CCHAR   [#%]
 COMMENT ({CCHAR}.*{NL})
 SNLCMT  ({SNL}|{COMMENT})
-NOT     ((\~)|(\!))
-POW     ((\*\*)|(\^))
-EPOW    (\.{POW})
 IDENT   ([_$a-zA-Z][_$a-zA-Z0-9]*)
 EXPON   ([DdEe][+-]?{D}+)
 NUMBER  (({D}+\.?{D}*{EXPON}?)|(\.{D}+{EXPON}?)|(0[xX][0-9a-fA-F]+))
 
 ANY_INCLUDING_NL (.|{NL})
 
 %%
 
 %{
 // Make script and function files start with a bogus token. This makes
 // the parser go down a special path.
 %}
 
 <INPUT_FILE_START>{ANY_INCLUDING_NL} {
-    LEXER_DEBUG ("<INPUT_FILE_START>{ANY_INCLUDING_NL}");
+    curr_lexer->lexer_debug ("<INPUT_FILE_START>{ANY_INCLUDING_NL}");
 
     curr_lexer->xunput (yytext[0]);
 
     // May be reset later if we see "function" or "classdef" appears
     // as the first token.
     curr_lexer->reading_script_file = true;
 
     curr_lexer->pop_start_state ();
 
-    DISPLAY_TOK_AND_RETURN (INPUT_FILE);
+    return curr_lexer->show_token (INPUT_FILE);
   }
 
 %{
 // Help and other command-style functions.
 %}
 
 <COMMAND_START>{NL} {
-    LEXER_DEBUG ("<COMMAND_START>{NL}");
+    curr_lexer->lexer_debug ("<COMMAND_START>{NL}");
 
     curr_lexer->input_line_number++;
     curr_lexer->current_input_column = 1;
 
     curr_lexer->quote_is_transpose = false;
     curr_lexer->convert_spaces_to_comma = true;
     curr_lexer->looking_for_object_index = false;
     curr_lexer->at_beginning_of_statement = true;
 
     curr_lexer->pop_start_state ();
 
-    COUNT_TOK_AND_RETURN ('\n');
+    return curr_lexer->count_token ('\n');
   }
 
 <COMMAND_START>[\;\,] {
-    LEXER_DEBUG ("<COMMAND_START>[\\;\\,]");
+    curr_lexer->lexer_debug ("<COMMAND_START>[\\;\\,]");
 
     curr_lexer->looking_for_object_index = false;
     curr_lexer->at_beginning_of_statement = true;
 
     curr_lexer->pop_start_state ();
 
     if (strcmp (yytext, ",") == 0)
-      TOK_RETURN (',');
+      return curr_lexer->handle_token (',');
     else
-      TOK_RETURN (';');
+      return curr_lexer->handle_token (';');
   }
 
 <COMMAND_START>[\"\'] {
-    LEXER_DEBUG ("<COMMAND_START>[\\\"\\']");
+    curr_lexer->lexer_debug ("<COMMAND_START>[\\\"\\']");
 
     curr_lexer->at_beginning_of_statement = false;
 
     curr_lexer->current_input_column++;
     int tok = curr_lexer->handle_string (yytext[0]);
 
-    COUNT_TOK_AND_RETURN (tok);
+    return curr_lexer->count_token (tok);
   }
 
 <COMMAND_START>[^#% \t\r\n\;\,\"\'][^ \t\r\n\;\,]*{S}* {
-    LEXER_DEBUG ("<COMMAND_START>[^#% \\t\\r\\n\\;\\,\\\"\\'][^ \\t\\r\\n\\;\\,]*{S}*");
+    curr_lexer->lexer_debug ("<COMMAND_START>[^#% \\t\\r\\n\\;\\,\\\"\\'][^ \\t\\r\\n\\;\\,]*{S}*");
 
     std::string tok = strip_trailing_whitespace (yytext);
 
     curr_lexer->looking_for_object_index = false;
     curr_lexer->at_beginning_of_statement = false;
 
-    TOK_PUSH_AND_RETURN (tok, SQ_STRING);
+    return curr_lexer->push_token (tok, SQ_STRING);
   }
 
 %{
 // For this and the next two rules, we're looking at ']', and we
 // need to know if the next token is '=' or '=='.
 //
 // It would have been so much easier if the delimiters were simply
 // different for the expression on the left hand side of the equals
@@ -345,17 +248,17 @@ ANY_INCLUDING_NL (.|{NL})
 //
 // It's also a pain in the ass to decide whether to insert a comma
 // after seeing a ']' character...
 
 // FIXME -- we need to handle block comments here.
 %}
 
 <MATRIX_START>{SNLCMT}*\]{S}* {
-    LEXER_DEBUG ("<MATRIX_START>{SNLCMT}*\\]{S}*");
+    curr_lexer->lexer_debug ("<MATRIX_START>{SNLCMT}*\\]{S}*");
 
     curr_lexer->scan_for_comments (yytext);
     curr_lexer->fixup_column_count (yytext);
 
     curr_lexer->looking_at_object_index.pop_front ();
 
     curr_lexer->looking_for_object_index = true;
     curr_lexer->at_beginning_of_statement = false;
@@ -363,25 +266,25 @@ ANY_INCLUDING_NL (.|{NL})
     int c = yytext[yyleng-1];
     bool cont_is_spc = (curr_lexer->eat_continuation () != octave_lexer::NO_WHITESPACE);
     bool spc_gobbled = (cont_is_spc || c == ' ' || c == '\t');
     int tok_to_return = curr_lexer->handle_close_bracket (spc_gobbled, ']');
 
     if (spc_gobbled)
       curr_lexer->xunput (' ');
 
-    COUNT_TOK_AND_RETURN (tok_to_return);
+    return curr_lexer->count_token (tok_to_return);
   }
 
 %{
 // FIXME -- we need to handle block comments here.
 %}
 
 <MATRIX_START>{SNLCMT}*\}{S}* {
-    LEXER_DEBUG ("<MATRIX_START>{SNLCMT}*\\}{S}*");
+    curr_lexer->lexer_debug ("<MATRIX_START>{SNLCMT}*\\}{S}*");
 
     curr_lexer->scan_for_comments (yytext);
     curr_lexer->fixup_column_count (yytext);
 
     curr_lexer->looking_at_object_index.pop_front ();
 
     curr_lexer->looking_for_object_index = true;
     curr_lexer->at_beginning_of_statement = false;
@@ -389,27 +292,27 @@ ANY_INCLUDING_NL (.|{NL})
     int c = yytext[yyleng-1];
     bool cont_is_spc = (curr_lexer->eat_continuation () != octave_lexer::NO_WHITESPACE);
     bool spc_gobbled = (cont_is_spc || c == ' ' || c == '\t');
     int tok_to_return = curr_lexer->handle_close_bracket (spc_gobbled, '}');
 
     if (spc_gobbled)
       curr_lexer->xunput (' ');
 
-    COUNT_TOK_AND_RETURN (tok_to_return);
+    return curr_lexer->count_token (tok_to_return);
   }
 
 %{
 // Commas are element separators in matrix constants.  If we don't
 // check for continuations here we can end up inserting too many
 // commas.
 %}
 
 <MATRIX_START>{S}*\,{S}* {
-    LEXER_DEBUG ("<MATRIX_START>{S}*\\,{S}*");
+    curr_lexer->lexer_debug ("<MATRIX_START>{S}*\\,{S}*");
 
     curr_lexer->current_input_column += yyleng;
 
     int tmp = curr_lexer->eat_continuation ();
 
     curr_lexer->quote_is_transpose = false;
     curr_lexer->convert_spaces_to_comma = true;
     curr_lexer->looking_for_object_index = false;
@@ -420,28 +323,28 @@ ANY_INCLUDING_NL (.|{NL})
         if ((tmp & octave_lexer::NEWLINE) == octave_lexer::NEWLINE)
           {
             curr_lexer->maybe_warn_separator_insert (';');
 
             curr_lexer->xunput (';');
           }
       }
 
-    COUNT_TOK_AND_RETURN (',');
+    return curr_lexer->count_token (',');
   }
 
 %{
 // In some cases, spaces in matrix constants can turn into commas.
 // If commas are required, spaces are not important in matrix
 // constants so we just eat them.  If we don't check for continuations
 // here we can end up inserting too many commas.
 %}
 
 <MATRIX_START>{S}+ {
-    LEXER_DEBUG ("<MATRIX_START>{S}+");
+    curr_lexer->lexer_debug ("<MATRIX_START>{S}+");
 
     curr_lexer->current_input_column += yyleng;
 
     curr_lexer->at_beginning_of_statement = false;
 
     int tmp = curr_lexer->eat_continuation ();
 
     if (! curr_lexer->looking_at_object_index.front ())
@@ -462,55 +365,55 @@ ANY_INCLUDING_NL (.|{NL})
               }
 
             curr_lexer->quote_is_transpose = false;
             curr_lexer->convert_spaces_to_comma = true;
             curr_lexer->looking_for_object_index = false;
 
             curr_lexer->maybe_warn_separator_insert (',');
 
-            COUNT_TOK_AND_RETURN (',');
+            return curr_lexer->count_token (',');
           }
       }
   }
 
 %{
 // Semicolons are handled as row seprators in matrix constants.  If we
 // don't eat whitespace here we can end up inserting too many
 // semicolons.
 
 // FIXME -- we need to handle block comments here.
 %}
 
 <MATRIX_START>{SNLCMT}*;{SNLCMT}* {
-    LEXER_DEBUG ("<MATRIX_START>{SNLCMT}*;{SNLCMT}*");
+    curr_lexer->lexer_debug ("<MATRIX_START>{SNLCMT}*;{SNLCMT}*");
 
     curr_lexer->scan_for_comments (yytext);
     curr_lexer->fixup_column_count (yytext);
     curr_lexer->eat_whitespace ();
 
     curr_lexer->quote_is_transpose = false;
     curr_lexer->convert_spaces_to_comma = true;
     curr_lexer->looking_for_object_index = false;
     curr_lexer->at_beginning_of_statement = false;
 
-    COUNT_TOK_AND_RETURN (';');
+    return curr_lexer->count_token (';');
   }
 
 %{
 // In some cases, new lines can also become row separators.  If we
 // don't eat whitespace here we can end up inserting too many
 // semicolons.
 
 // FIXME -- we need to handle block comments here.
 %}
 
 <MATRIX_START>{S}*{COMMENT}{SNLCMT}* |
 <MATRIX_START>{S}*{NL}{SNLCMT}* {
-    LEXER_DEBUG ("<MATRIX_START>{S}*{COMMENT}{SNLCMT}*|<MATRIX_START>{S}*{NL}{SNLCMT}*");
+    curr_lexer->lexer_debug ("<MATRIX_START>{S}*{COMMENT}{SNLCMT}*|<MATRIX_START>{S}*{NL}{SNLCMT}*");
 
     curr_lexer->scan_for_comments (yytext);
     curr_lexer->fixup_column_count (yytext);
     curr_lexer->eat_whitespace ();
 
     curr_lexer->quote_is_transpose = false;
     curr_lexer->convert_spaces_to_comma = true;
     curr_lexer->at_beginning_of_statement = false;
@@ -518,22 +421,22 @@ ANY_INCLUDING_NL (.|{NL})
     if (curr_lexer->nesting_level.none ())
       return LEXICAL_ERROR;
 
     if (! curr_lexer->looking_at_object_index.front ()
         && curr_lexer->nesting_level.is_bracket_or_brace ())
       {
         curr_lexer->maybe_warn_separator_insert (';');
 
-        COUNT_TOK_AND_RETURN (';');
+        return curr_lexer->count_token (';');
       }
   }
 
 \[{S}* {
-    LEXER_DEBUG ("\\[{S}*");
+    curr_lexer->lexer_debug ("\\[{S}*");
 
     curr_lexer->nesting_level.bracket ();
 
     curr_lexer->looking_at_object_index.push_front (false);
 
     curr_lexer->current_input_column += yyleng;
     curr_lexer->quote_is_transpose = false;
     curr_lexer->convert_spaces_to_comma = true;
@@ -548,65 +451,65 @@ ANY_INCLUDING_NL (.|{NL})
 
     curr_lexer->decrement_promptflag ();
     curr_lexer->eat_whitespace ();
 
     curr_lexer->bracketflag++;
 
     curr_lexer->push_start_state (MATRIX_START);
 
-    COUNT_TOK_AND_RETURN ('[');
+    return curr_lexer->count_token ('[');
   }
 
 \] {
-    LEXER_DEBUG ("\\]");
+    curr_lexer->lexer_debug ("\\]");
 
     curr_lexer->nesting_level.remove ();
 
     curr_lexer->looking_at_object_index.pop_front ();
 
     curr_lexer->looking_for_object_index = true;
     curr_lexer->at_beginning_of_statement = false;
 
-    TOK_RETURN (']');
+    return curr_lexer->handle_token (']');
   }
 
 %{
 // Gobble comments.
 %}
 
 %{
 // Start of a block comment.  If the comment marker appears immediately
 // after a block of full-line comments, finish the full line comment
 // block.
 %}
 
 ^{S}*{CCHAR}\{{S}*{NL} {
-    LEXER_DEBUG ("^{S}*{CCHAR}\{{S}*{NL}");
+    curr_lexer->lexer_debug ("^{S}*{CCHAR}\{{S}*{NL}");
 
     int tok = 0;
 
     if (curr_lexer->start_state () == LINE_COMMENT_START)
       {
         if (! curr_lexer->comment_text.empty ())
           tok = curr_lexer->finish_comment (octave_comment_elt::full_line);
 
         curr_lexer->pop_start_state ();
       }
 
     curr_lexer->push_start_state (BLOCK_COMMENT_START);
 
     yyless (0);
 
     if (tok > 0)
-      COUNT_TOK_AND_RETURN (tok);
+      return curr_lexer->count_token (tok);
   }
 
 <BLOCK_COMMENT_START>^{S}*{CCHAR}\{{S}*{NL} {
-    LEXER_DEBUG ("<BLOCK_COMMENT_START>^{S}*{CCHAR}\{{S}*{NL}");
+    curr_lexer->lexer_debug ("<BLOCK_COMMENT_START>^{S}*{CCHAR}\{{S}*{NL}");
 
     curr_lexer->input_line_number++;
     curr_lexer->current_input_column = 1;
 
     if (curr_lexer->block_comment_nesting_level)
       curr_lexer->comment_text = "\n";
 
     curr_lexer->block_comment_nesting_level++;
@@ -614,60 +517,60 @@ ANY_INCLUDING_NL (.|{NL})
 
 %{
 // End of a block comment.  If this block comment is nested inside
 // another, wait for the outermost block comment block to be closed
 // before storing the comment.
 %}
 
 <BLOCK_COMMENT_START>^{S}*{CCHAR}\}{S}*{NL} {
-    LEXER_DEBUG ("<BLOCK_COMMENT_START>^{S}*{CCHAR}\}{S}*{NL}");
+    curr_lexer->lexer_debug ("<BLOCK_COMMENT_START>^{S}*{CCHAR}\\}{S}*{NL}");
 
     curr_lexer->input_line_number++;
     curr_lexer->current_input_column = 1;
 
     int tok = 0;
 
     if (curr_lexer->block_comment_nesting_level > 1)
       curr_lexer->comment_text = "\n";
     else
       tok = curr_lexer->finish_comment (octave_comment_elt::block);
 
     curr_lexer->block_comment_nesting_level--;
     curr_lexer->pop_start_state ();
 
     if (tok > 0)
-      COUNT_TOK_AND_RETURN (tok);
+      return curr_lexer->count_token (tok);
   }
 
 %{
 // Body of a block comment.
 %}
 
 <BLOCK_COMMENT_START>.*{NL} {
-    LEXER_DEBUG ("<BLOCK_COMMENT_START>.*{NL}");
+    curr_lexer->lexer_debug ("<BLOCK_COMMENT_START>.*{NL}");
 
     curr_lexer->input_line_number++;
     curr_lexer->current_input_column = 1;
     curr_lexer->comment_text += yytext;
   }
 
 %{
 // Full-line or end-of-line comment.
 %}
 
 {S}*{CCHAR}.*{NL} {
-    LEXER_DEBUG ("{S}*{CCHAR}.*{NL}");
+    curr_lexer->lexer_debug ("{S}*{CCHAR}.*{NL}");
 
     curr_lexer->push_start_state (LINE_COMMENT_START);
     yyless (0);
   }
 
 <LINE_COMMENT_START>{S}*{CCHAR}.*{NL} {
-    LEXER_DEBUG ("<LINE_COMMENT_START>{S}*{CCHAR}.*{NL}");
+    curr_lexer->lexer_debug ("<LINE_COMMENT_START>{S}*{CCHAR}.*{NL}");
 
     bool full_line_comment = curr_lexer->current_input_column == 1;
     curr_lexer->input_line_number++;
     curr_lexer->current_input_column = 1;
 
     size_t len = yyleng;
     size_t i = 0;
     while (i < len)
@@ -695,57 +598,57 @@ ANY_INCLUDING_NL (.|{NL})
             // executed next.
 
             tok = 0;
             curr_lexer->xunput ('\n');
           }
       }
 
     if (tok > 0)
-      COUNT_TOK_AND_RETURN (tok);
+      return curr_lexer->count_token (tok);
   }
 
 %{
 // End of a block of full-line comments.
 %}
 
 <LINE_COMMENT_START>{ANY_INCLUDING_NL} {
-    LEXER_DEBUG ("<LINE_COMMENT_START>{ANY_INCLUDING_NL}");
+    curr_lexer->lexer_debug ("<LINE_COMMENT_START>{ANY_INCLUDING_NL}");
 
     curr_lexer->xunput (yytext[0]);
 
     int tok = curr_lexer->finish_comment (octave_comment_elt::full_line);  
 
     curr_lexer->pop_start_state ();
 
     if (tok > 0)
-      COUNT_TOK_AND_RETURN (tok);
+      return curr_lexer->count_token (tok);
   }
 
 %{
 // Imaginary numbers.
 %}
 
 {NUMBER}{Im} {
-    LEXER_DEBUG ("{NUMBER}{Im}");
+    curr_lexer->lexer_debug ("{NUMBER}{Im}");
 
     curr_lexer->handle_number ();
-    COUNT_TOK_AND_RETURN (IMAG_NUM);
+    return curr_lexer->count_token (IMAG_NUM);
   }
 
 %{
 // Real numbers.  Don't grab the '.' part of a dot operator as part of
 // the constant.
 %}
 
 {D}+/\.[\*/\\^\'] |
 {NUMBER} {
-    LEXER_DEBUG ("{D}+/\\.[\\*/\\^\\']|{NUMBER}");
+    curr_lexer->lexer_debug ("{D}+/\\.[\\*/\\^\\']|{NUMBER}");
     curr_lexer->handle_number ();
-    COUNT_TOK_AND_RETURN (NUM);
+    return curr_lexer->count_token (NUM);
   }
 
 %{
 // Eat whitespace.  Whitespace inside matrix constants is handled by
 // the <MATRIX_START> start state code above.
 %}
 
 {S}* {
@@ -753,17 +656,17 @@ ANY_INCLUDING_NL (.|{NL})
   }
 
 %{
 // Continuation lines.  Allow comments after continuations.
 %}
 
 {CONT}{S}*{NL} |
 {CONT}{S}*{COMMENT} {
-    LEXER_DEBUG ("{CONT}{S}*{NL}|{CONT}{S}*{COMMENT}");
+    curr_lexer->lexer_debug ("{CONT}{S}*{NL}|{CONT}{S}*{COMMENT}");
 
     if (yytext[0] == '\\')
       curr_lexer->gripe_matlab_incompatible_continuation ();
     curr_lexer->scan_for_comments (yytext);
     curr_lexer->decrement_promptflag ();
     curr_lexer->input_line_number++;
     curr_lexer->current_input_column = 1;
   }
@@ -777,216 +680,227 @@ ANY_INCLUDING_NL (.|{NL})
   }
 
 %{
 // Identifiers.  Truncate the token at the first space or tab but
 // don't write directly on yytext.
 %}
 
 {IDENT}{S}* {
-    LEXER_DEBUG ("{IDENT}{S}*");
+    curr_lexer->lexer_debug ("{IDENT}{S}*");
 
     int id_tok = curr_lexer->handle_identifier ();
 
     if (id_tok >= 0)
-      COUNT_TOK_AND_RETURN (id_tok);
+      return curr_lexer->count_token (id_tok);
   }
 
 %{
 // Superclass method identifiers.
 %}
 
 {IDENT}@{IDENT}{S}* |
 {IDENT}@{IDENT}.{IDENT}{S}* {
-    LEXER_DEBUG ("{IDENT}@{IDENT}{S}*|{IDENT}@{IDENT}.{IDENT}{S}*");
+    curr_lexer->lexer_debug ("{IDENT}@{IDENT}{S}*|{IDENT}@{IDENT}.{IDENT}{S}*");
 
     int id_tok = curr_lexer->handle_superclass_identifier ();
 
     if (id_tok >= 0)
       {
         curr_lexer->looking_for_object_index = true;
 
-        COUNT_TOK_AND_RETURN (SUPERCLASSREF);
+        return curr_lexer->count_token (SUPERCLASSREF);
       }
   }
 
 %{
 // Metaclass query
 %}
 
 \?{IDENT}{S}* |
 \?{IDENT}\.{IDENT}{S}* {
-    LEXER_DEBUG ("\\?{IDENT}{S}*|\\?{IDENT}\\.{IDENT}{S}*");
+    curr_lexer->lexer_debug ("\\?{IDENT}{S}*|\\?{IDENT}\\.{IDENT}{S}*");
 
     int id_tok = curr_lexer->handle_meta_identifier ();
 
     if (id_tok >= 0)
       {
         curr_lexer->looking_for_object_index = true;
 
-        COUNT_TOK_AND_RETURN (METAQUERY);
+        return curr_lexer->count_token (METAQUERY);
       }
   }
 
 %{
 // Function handles and superclass references
 %}
 
 "@" {
-    LEXER_DEBUG ("@");
+    curr_lexer->lexer_debug ("@");
 
     curr_lexer->current_input_column++;
 
     curr_lexer->quote_is_transpose = false;
     curr_lexer->convert_spaces_to_comma = false;
     curr_lexer->looking_at_function_handle++;
     curr_lexer->looking_for_object_index = false;
     curr_lexer->at_beginning_of_statement = false;
 
-    COUNT_TOK_AND_RETURN ('@');
+    return curr_lexer->count_token ('@');
 
   }
 
 %{
 // A new line character.  New line characters inside matrix constants
 // are handled by the <MATRIX_START> start state code above.  If closest
 // nesting is inside parentheses, don't return a row separator.
 %}
 
 {NL} {
-    LEXER_DEBUG ("{NL}");
+    curr_lexer->lexer_debug ("{NL}");
 
     curr_lexer->input_line_number++;
     curr_lexer->current_input_column = 1;
 
     curr_lexer->quote_is_transpose = false;
     curr_lexer->convert_spaces_to_comma = true;
 
     if (curr_lexer->nesting_level.none ())
       {
         curr_lexer->at_beginning_of_statement = true;
-        COUNT_TOK_AND_RETURN ('\n');
+        return curr_lexer->count_token ('\n');
       }
     else if (curr_lexer->nesting_level.is_paren ())
       {
         curr_lexer->at_beginning_of_statement = false;
         curr_lexer->gripe_matlab_incompatible ("bare newline inside parentheses");
       }
     else if (curr_lexer->nesting_level.is_bracket_or_brace ())
       return LEXICAL_ERROR;
   }
 
 %{
 // Single quote can either be the beginning of a string or a transpose
 // operator.
 %}
 
 "'" {
-    LEXER_DEBUG ("'");
+    curr_lexer->lexer_debug ("'");
 
     curr_lexer->current_input_column++;
     curr_lexer->convert_spaces_to_comma = true;
 
     if (curr_lexer->quote_is_transpose)
       {
         curr_lexer->do_comma_insert_check ();
-        COUNT_TOK_AND_RETURN (QUOTE);
+        return curr_lexer->count_token (QUOTE);
       }
     else
       {
         int tok = curr_lexer->handle_string ('\'');
-        COUNT_TOK_AND_RETURN (tok);
+        return curr_lexer->count_token (tok);
       }
   }
 
 %{
 // Double quotes always begin strings.
 %}
 
 \" {
-    LEXER_DEBUG ("\"");
+    curr_lexer->lexer_debug ("\"");
 
     curr_lexer->current_input_column++;
     int tok = curr_lexer->handle_string ('"');
 
-    COUNT_TOK_AND_RETURN (tok);
+    return curr_lexer->count_token (tok);
 }
 
 %{
 // Other operators.
 %}
 
-":"     { LEXER_DEBUG (":"); BIN_OP_RETURN (':', false, false); }
-
-".+"    { LEXER_DEBUG (".+"); XBIN_OP_RETURN (EPLUS, false, false); }
-".-"    { LEXER_DEBUG (".-"); XBIN_OP_RETURN (EMINUS, false, false); }
-".*"    { LEXER_DEBUG (".*"); BIN_OP_RETURN (EMUL, false, false); }
-"./"    { LEXER_DEBUG ("./"); BIN_OP_RETURN (EDIV, false, false); }
-".\\"   { LEXER_DEBUG (".\\"); BIN_OP_RETURN (ELEFTDIV, false, false); }
-".^"    { LEXER_DEBUG (".^"); BIN_OP_RETURN (EPOW, false, false); }
-".**"   { LEXER_DEBUG (".**"); XBIN_OP_RETURN (EPOW, false, false); }
-".'"    { LEXER_DEBUG (".'"); curr_lexer->do_comma_insert_check (); BIN_OP_RETURN (TRANSPOSE, true, false); }
-"++"    { LEXER_DEBUG ("++"); curr_lexer->do_comma_insert_check (); XBIN_OP_RETURN_INTERNAL (PLUS_PLUS, true, false, true); }
-"--"    { LEXER_DEBUG ("--"); curr_lexer->do_comma_insert_check (); XBIN_OP_RETURN_INTERNAL (MINUS_MINUS, true, false, true); }
-"<="    { LEXER_DEBUG ("<="); BIN_OP_RETURN (EXPR_LE, false, false); }
-"=="    { LEXER_DEBUG ("=="); BIN_OP_RETURN (EXPR_EQ, false, false); }
-"~="    { LEXER_DEBUG ("~="); BIN_OP_RETURN (EXPR_NE, false, false); }
-"!="    { LEXER_DEBUG ("!="); XBIN_OP_RETURN (EXPR_NE, false, false); }
-">="    { LEXER_DEBUG (">="); BIN_OP_RETURN (EXPR_GE, false, false); }
-"&"     { LEXER_DEBUG ("&"); BIN_OP_RETURN (EXPR_AND, false, false); }
-"|"     { LEXER_DEBUG ("|"); BIN_OP_RETURN (EXPR_OR, false, false); }
-"<"     { LEXER_DEBUG ("<"); BIN_OP_RETURN (EXPR_LT, false, false); }
-">"     { LEXER_DEBUG (">"); BIN_OP_RETURN (EXPR_GT, false, false); }
-"+"     { LEXER_DEBUG ("+"); BIN_OP_RETURN ('+', false, false); }
-"-"     { LEXER_DEBUG ("-"); BIN_OP_RETURN ('-', false, false); }
-"*"     { LEXER_DEBUG ("*"); BIN_OP_RETURN ('*', false, false); }
-"/"     { LEXER_DEBUG ("/"); BIN_OP_RETURN ('/', false, false); }
-"\\"    { LEXER_DEBUG ("\\"); BIN_OP_RETURN (LEFTDIV, false, false); }
-";"     { LEXER_DEBUG (";"); BIN_OP_RETURN (';', true, true); }
-","     { LEXER_DEBUG (","); BIN_OP_RETURN (',', true, ! curr_lexer->looking_at_object_index.front ()); }
-"^"     { LEXER_DEBUG ("^"); BIN_OP_RETURN (POW, false, false); }
-"**"    { LEXER_DEBUG ("**"); XBIN_OP_RETURN (POW, false, false); }
-"="     { LEXER_DEBUG ("="); BIN_OP_RETURN ('=', true, false); }
-"&&"    { LEXER_DEBUG ("&&"); BIN_OP_RETURN (EXPR_AND_AND, false, false); }
-"||"    { LEXER_DEBUG ("||"); BIN_OP_RETURN (EXPR_OR_OR, false, false); }
-"<<"    { LEXER_DEBUG ("<<"); XBIN_OP_RETURN (LSHIFT, false, false); }
-">>"    { LEXER_DEBUG (">>"); XBIN_OP_RETURN (RSHIFT, false, false); }
-
-{NOT} {
-    LEXER_DEBUG ("{NOT}");
-
-    if (yytext[0] == '~')
-      BIN_OP_RETURN (EXPR_NOT, false, false);
-    else
-      XBIN_OP_RETURN (EXPR_NOT, false, false);
+":"     { return curr_lexer->handle_op (":", ':'); }
+".+"    { return curr_lexer->handle_incompatible_op (".+", EPLUS); }
+".-"    { return curr_lexer->handle_incompatible_op (".-", EMINUS); }
+".*"    { return curr_lexer->handle_op (".*", EMUL); }
+"./"    { return curr_lexer->handle_op ("./", EDIV); }
+".\\"   { return curr_lexer->handle_op (".\\", ELEFTDIV); }
+".^"    { return curr_lexer->handle_op (".^", EPOW); }
+".**"   { return curr_lexer->handle_incompatible_op (".**", EPOW); }
+"<="    { return curr_lexer->handle_op ("<=", EXPR_LE); }
+"=="    { return curr_lexer->handle_op ("==", EXPR_EQ); }
+"~="    { return curr_lexer->handle_op ("~=", EXPR_NE); }
+"!="    { return curr_lexer->handle_incompatible_op ("!=", EXPR_NE); }
+">="    { return curr_lexer->handle_op (">=", EXPR_GE); }
+"&"     { return curr_lexer->handle_op ("&", EXPR_AND); }
+"|"     { return curr_lexer->handle_op ("|", EXPR_OR); }
+"<"     { return curr_lexer->handle_op ("<", EXPR_LT); }
+">"     { return curr_lexer->handle_op (">", EXPR_GT); }
+"+"     { return curr_lexer->handle_op ("+", '+'); }
+"-"     { return curr_lexer->handle_op ("-", '-'); }
+"*"     { return curr_lexer->handle_op ("*", '*'); }
+"/"     { return curr_lexer->handle_op ("/", '/'); }
+"\\"    { return curr_lexer->handle_op ("\\", LEFTDIV); }
+"^"     { return curr_lexer->handle_op ("^", POW); }
+"**"    { return curr_lexer->handle_incompatible_op ("**", POW); }
+"="     { return curr_lexer->handle_op ("=", '=', true, false); }
+"&&"    { return curr_lexer->handle_op ("&&", EXPR_AND_AND); }
+"||"    { return curr_lexer->handle_op ("||", EXPR_OR_OR); }
+"<<"    { return curr_lexer->handle_incompatible_op ("<<", LSHIFT); }
+">>"    { return curr_lexer->handle_incompatible_op (">>", RSHIFT); }
+"~"     { return curr_lexer->handle_op ("~", EXPR_NOT); }
+"!"     { return curr_lexer->handle_incompatible_op ("!", EXPR_NOT); }
+";"     { return curr_lexer->handle_op (";", ';', true, true); }
+
+"," {
+    return curr_lexer->handle_op
+      (",", ',', true, ! curr_lexer->looking_at_object_index.front ());
+  }
+
+".'" {
+    curr_lexer->do_comma_insert_check ();
+    return curr_lexer->handle_op (".'", TRANSPOSE, true, false);
+  }
+
+"++" {
+    curr_lexer->do_comma_insert_check ();
+    return curr_lexer->handle_incompatible_op
+      ("++", PLUS_PLUS, true, false, true);
+  }
+
+"--" {
+    ;
+    curr_lexer->do_comma_insert_check ();
+    return curr_lexer->handle_incompatible_op
+      ("--", MINUS_MINUS, true, false, true);
   }
 
 "(" {
-    LEXER_DEBUG ("(");
+    curr_lexer->lexer_debug ("(");
 
     // If we are looking for an object index, then push TRUE for
     // looking_at_object_index.  Otherwise, just push whatever state
     // is current (so that we can pop it off the stack when we find
     // the matching close paren).
 
     curr_lexer->looking_at_object_index.push_front
       (curr_lexer->looking_for_object_index);
 
     curr_lexer->looking_at_indirect_ref = false;
     curr_lexer->looking_for_object_index = false;
     curr_lexer->at_beginning_of_statement = false;
 
     curr_lexer->nesting_level.paren ();
     curr_lexer->decrement_promptflag ();
 
-    TOK_RETURN ('(');
+    return curr_lexer->handle_token ('(');
   }
 
 ")" {
-    LEXER_DEBUG (")");
+    curr_lexer->lexer_debug (")");
 
     curr_lexer->nesting_level.remove ();
     curr_lexer->current_input_column++;
 
     curr_lexer->looking_at_object_index.pop_front ();
 
     curr_lexer->quote_is_transpose = true;
     curr_lexer->convert_spaces_to_comma
@@ -995,47 +909,53 @@ ANY_INCLUDING_NL (.|{NL})
     curr_lexer->looking_for_object_index = true;
     curr_lexer->at_beginning_of_statement = false;
 
     if (curr_lexer->looking_at_anon_fcn_args)
       curr_lexer->looking_at_anon_fcn_args = false;
 
     curr_lexer->do_comma_insert_check ();
 
-    COUNT_TOK_AND_RETURN (')');
+    return curr_lexer->count_token (')');
   }
 
 "." {
-    LEXER_DEBUG (".");
+    curr_lexer->lexer_debug (".");
 
     curr_lexer->looking_for_object_index = false;
     curr_lexer->at_beginning_of_statement = false;
 
-    TOK_RETURN ('.');
+    return curr_lexer->handle_token ('.');
   }
 
-"+="    { LEXER_DEBUG ("+="); XBIN_OP_RETURN (ADD_EQ, false, false); }
-"-="    { LEXER_DEBUG ("-="); XBIN_OP_RETURN (SUB_EQ, false, false); }
-"*="    { LEXER_DEBUG ("*="); XBIN_OP_RETURN (MUL_EQ, false, false); }
-"/="    { LEXER_DEBUG ("/="); XBIN_OP_RETURN (DIV_EQ, false, false); }
-"\\="   { LEXER_DEBUG ("\\="); XBIN_OP_RETURN (LEFTDIV_EQ, false, false); }
-".+="   { LEXER_DEBUG (".+="); XBIN_OP_RETURN (ADD_EQ, false, false); }
-".-="   { LEXER_DEBUG (".-="); XBIN_OP_RETURN (SUB_EQ, false, false); }
-".*="   { LEXER_DEBUG (".*="); XBIN_OP_RETURN (EMUL_EQ, false, false); }
-"./="   { LEXER_DEBUG ("./="); XBIN_OP_RETURN (EDIV_EQ, false, false); }
-".\\="  { LEXER_DEBUG (".\\="); XBIN_OP_RETURN (ELEFTDIV_EQ, false, false); }
-{POW}=  { LEXER_DEBUG ("{POW}="); XBIN_OP_RETURN (POW_EQ, false, false); }
-{EPOW}= { LEXER_DEBUG ("{EPOW}="); XBIN_OP_RETURN (EPOW_EQ, false, false); }
-"&="    { LEXER_DEBUG ("&="); XBIN_OP_RETURN (AND_EQ, false, false); }
-"|="    { LEXER_DEBUG ("|="); XBIN_OP_RETURN (OR_EQ, false, false); }
-"<<="   { LEXER_DEBUG ("<<="); XBIN_OP_RETURN (LSHIFT_EQ, false, false); }
-">>="   { LEXER_DEBUG (">>="); XBIN_OP_RETURN (RSHIFT_EQ, false, false); }
+%{
+// op= operators.
+%}
+
+"+="    { return curr_lexer->handle_incompatible_op ("+=", ADD_EQ); }
+"-="    { return curr_lexer->handle_incompatible_op ("-=", SUB_EQ); }
+"*="    { return curr_lexer->handle_incompatible_op ("*=", MUL_EQ); }
+"/="    { return curr_lexer->handle_incompatible_op ("/=", DIV_EQ); }
+"\\="   { return curr_lexer->handle_incompatible_op ("\\=", LEFTDIV_EQ); }
+".+="   { return curr_lexer->handle_incompatible_op (".+=", ADD_EQ); }
+".-="   { return curr_lexer->handle_incompatible_op (".-=", SUB_EQ); }
+".*="   { return curr_lexer->handle_incompatible_op (".*=", EMUL_EQ); }
+"./="   { return curr_lexer->handle_incompatible_op ("./=", EDIV_EQ); }
+".\\="  { return curr_lexer->handle_incompatible_op (".\\=", ELEFTDIV_EQ); }
+"^="    { return curr_lexer->handle_incompatible_op ("^=", POW_EQ); }
+"**="   { return curr_lexer->handle_incompatible_op ("^=", POW_EQ); }
+".^="   { return curr_lexer->handle_incompatible_op (".^=", EPOW_EQ); }
+".**="  { return curr_lexer->handle_incompatible_op (".^=", EPOW_EQ); }
+"&="    { return curr_lexer->handle_incompatible_op ("&=", AND_EQ); }
+"|="    { return curr_lexer->handle_incompatible_op ("|=", OR_EQ); }
+"<<="   { return curr_lexer->handle_incompatible_op ("<<=", LSHIFT_EQ); }
+">>="   { return curr_lexer->handle_incompatible_op (">>=", RSHIFT_EQ); }
 
 \{{S}* {
-    LEXER_DEBUG ("\\{{S}*");
+    curr_lexer->lexer_debug ("\\{{S}*");
 
     curr_lexer->nesting_level.brace ();
 
     curr_lexer->looking_at_object_index.push_front
       (curr_lexer->looking_for_object_index);
 
     curr_lexer->current_input_column += yyleng;
     curr_lexer->quote_is_transpose = false;
@@ -1045,38 +965,38 @@ ANY_INCLUDING_NL (.|{NL})
 
     curr_lexer->decrement_promptflag ();
     curr_lexer->eat_whitespace ();
 
     curr_lexer->braceflag++;
 
     curr_lexer->push_start_state (MATRIX_START);
 
-    COUNT_TOK_AND_RETURN ('{');
+    return curr_lexer->count_token ('{');
   }
 
 "}" {
-    LEXER_DEBUG ("}");
+    curr_lexer->lexer_debug ("}");
 
     curr_lexer->looking_at_object_index.pop_front ();
 
     curr_lexer->looking_for_object_index = true;
     curr_lexer->at_beginning_of_statement = false;
 
     curr_lexer->nesting_level.remove ();
 
-    TOK_RETURN ('}');
+    return curr_lexer->handle_token ('}');
   }
 
 %{
 // Unrecognized input is a lexical error.
 %}
 
 . {
-    LEXER_DEBUG (".");
+    curr_lexer->lexer_debug (".");
 
     curr_lexer->xunput (yytext[0]);
 
     int c = curr_lexer->text_yyinput ();
 
     if (c != EOF)
       {
         curr_lexer->current_input_column++;
@@ -1666,33 +1586,29 @@ octave_lexer::read (char *buf, unsigned 
     }
 
   return status;
 }
 
 int
 octave_lexer::handle_end_of_input (void)
 {
-  // FIXME -- we need this because of the way TOK_RETURN is defined.  DO
-  // something better than that...
-  OCTAVE_YYG;
-
-  LEXER_DEBUG ("<<EOF>>");
+  lexer_debug ("<<EOF>>");
 
   if (block_comment_nesting_level != 0)
     {
       warning ("block comment open at end of input");
 
       if ((reading_fcn_file || reading_script_file || reading_classdef_file)
           && ! fcn_file_name.empty ())
         warning ("near line %d of file '%s.m'",
                  input_line_number, fcn_file_name.c_str ());
     }
 
-  TOK_RETURN (END_OF_INPUT);
+  return handle_token (END_OF_INPUT);
 }
 
 char *
 octave_lexer::flex_yytext (void)
 {
   return yyget_text (scanner);
 }
 
@@ -3216,18 +3132,16 @@ octave_lexer::handle_meta_identifier (vo
 
 // Figure out exactly what kind of token to return when we have seen
 // an identifier.  Handles keywords.  Return -1 if the identifier
 // should be ignored.
 
 int
 octave_lexer::handle_identifier (void)
 {
-  OCTAVE_YYG;
-
   bool at_bos = at_beginning_of_statement;
 
   char *yytxt = flex_yytext ();
 
   std::string tok = strip_trailing_whitespace (yytxt);
 
   int c = yytxt[flex_yyleng()-1];
 
@@ -3365,17 +3279,17 @@ octave_lexer::handle_identifier (void)
   push_token (new token (&(symbol_table::insert (tok)),
                          input_line_number, current_input_column));
 
   // After seeing an identifer, it is ok to convert spaces to a comma
   // (if needed).
 
   convert_spaces_to_comma = true;
 
-  if (! (next_tok_is_eq || YY_START == COMMAND_START))
+  if (! (next_tok_is_eq || start_state () == COMMAND_START))
     {
       quote_is_transpose = true;
 
       do_comma_insert_check ();
 
       maybe_unput_comma (spc_gobbled);
     }
 
@@ -3613,24 +3527,27 @@ octave_lexer::fatal_error (const char *m
   error (msg);
 
   OCTAVE_QUIT;
 
   yy_fatal_error (msg, scanner);
 }
 
 void
-octave_lexer::lexer_debug (const char *pattern, const char *text)
+octave_lexer::lexer_debug (const char *pattern)
 {
-  std::cerr << std::endl;
-
-  display_start_state ();
-
-  std::cerr << "P: " << pattern << std::endl;
-  std::cerr << "T: " << text << std::endl;
+  if (lexer_debug_flag)
+    {
+      std::cerr << std::endl;
+
+      display_start_state ();
+
+      std::cerr << "P: " << pattern << std::endl;
+      std::cerr << "T: " << flex_yytext () << std::endl;
+    }
 }
 
 void
 octave_lexer::push_start_state (int state)
 {
   OCTAVE_YYG;
 
   start_state_stack.push (state);
@@ -3688,8 +3605,88 @@ octave_lexer::display_start_state (void)
       std::cerr << "LINE_COMMENT_START" << std::endl;
       break;
 
     default:
       std::cerr << "UNKNOWN START STATE!" << std::endl;
       break;
     }
 }
+
+int
+octave_lexer::handle_op (const char *pattern, int tok, bool convert,
+                         bool bos, bool qit)
+{
+  return handle_op_internal (pattern, tok, convert, bos, qit, true);
+}
+
+int
+octave_lexer::handle_incompatible_op (const char *pattern, int tok,
+                                      bool convert, bool bos, bool qit)
+{
+  return handle_op_internal (pattern, tok, convert, bos, qit, false);
+}
+
+int
+octave_lexer::handle_op_internal (const char *pattern, int tok, bool convert,
+                                  bool bos, bool qit, bool compat)
+{
+  lexer_debug (pattern);
+
+  if (! compat)
+    gripe_matlab_incompatible_operator (flex_yytext ());
+
+  push_token (new token (input_line_number, current_input_column));
+
+  current_input_column += flex_yyleng ();
+  quote_is_transpose = qit;
+  convert_spaces_to_comma = convert;
+  looking_for_object_index = false;
+  at_beginning_of_statement = bos;
+
+  return count_token (tok);
+}
+
+int
+octave_lexer::push_token (const std::string& name, int tok)
+{
+  push_token (new token (name, input_line_number, current_input_column));
+
+  return handle_token (tok);
+}
+
+int
+octave_lexer::handle_token (int tok)
+{
+  current_input_column += flex_yyleng ();
+  quote_is_transpose = false;
+  convert_spaces_to_comma = true;
+
+  return count_token (tok);
+}
+
+int
+octave_lexer::count_token (int tok)
+{
+  if (tok != '\n')
+    {
+      Vtoken_count++;
+      token_count++;
+    }
+
+  return show_token (tok);
+}
+
+int
+octave_lexer::show_token (int tok)
+{
+  if (Vdisplay_tokens)
+    display_token (tok);
+
+  if (lexer_debug_flag)
+    {
+      std::cerr << "R: ";
+      display_token (tok);
+      std::cerr << std::endl; 
+    }
+
+  return tok;
+}
