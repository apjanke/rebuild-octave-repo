# HG changeset patch
# User jwe
# Date 945290925 0
#      Wed Dec 15 20:48:45 1999 +0000
# Node ID 69b167451491648161ed1127c5c12c8ead0129d6
# Parent  f5edd74bdc6ce3c9344aca5ccbc76cc3570f986a
[project @ 1999-12-15 20:48:10 by jwe]

diff --git a/scripts/control/DEMOcontrol.m b/scripts/control/DEMOcontrol.m
--- a/scripts/control/DEMOcontrol.m
+++ b/scripts/control/DEMOcontrol.m
@@ -1,25 +1,25 @@
-# Copyright (C) 1996 Auburn University. All rights reserved.
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it
-# under the terms of the GNU General Public License as published by the
-# Free Software Foundation; either version 2, or (at your option) any
-# later version.
-#
-# Octave is distributed in the hope that it will be useful, but WITHOUT
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-# for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Octave; see the file COPYING.  If not, write to the Free
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
+## Copyright (C) 1996 Auburn University. All rights reserved.
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
+##
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+## for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File } { } DEMOcontrol 
 ## Octave Control Systems Toolbox demo/tutorial program.  The demo
 ## allows the user to select among several categories of OCST function:
 ## @example
 ## @group
 ## octave:1> DEMOcontrol
diff --git a/scripts/control/abcddim.m b/scripts/control/abcddim.m
--- a/scripts/control/abcddim.m
+++ b/scripts/control/abcddim.m
@@ -1,25 +1,25 @@
-# Copyright (C) 1993, 1994, 1995 Auburn University.  All Rights Reserved.
-# 
-# This file is part of Octave.
-# 
-# Octave is free software; you can redistribute it and/or modify it
-# under the terms of the GNU General Public License as published by the
-# Free Software Foundation; either version 2, or (at your option) any
-# later version.
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License
-# along with Octave; see the file COPYING.  If not, write to the Free
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
+## Copyright (C) 1993, 1994, 1995 Auburn University.  All Rights Reserved.
+## 
+## This file is part of Octave.
+## 
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{n}, @var{m}, @var{p}] =} abcddim (@var{a}, @var{b}, @var{c}, @var{d})
 ## Check for compatibility of the dimensions of the matrices defining
 ## the linear system
 ## @iftex
 ## @tex
 ## $[A, B, C, D]$ corresponding to
@@ -57,18 +57,18 @@
 ## Otherwise @code{abcddim} returns @var{n} = @var{m} = @var{p} = @minus{}1.
 ## 
 ## Note: n = 0 (pure gain block) is returned without warning.
 ## 
 ## See also: is_abcd
 ## @end deftypefn
 
 function [n, m, p] = abcddim (a, b, c, d)
-# Written by A. S. Hodel (scotte@eng.auburn.edu) August 1993.
-# a s hodel: modified to accept pure-gain systems aug 1996
+## Written by A. S. Hodel (scotte@eng.auburn.edu) August 1993.
+## a s hodel: modified to accept pure-gain systems aug 1996
 
   if (nargin != 4)
     error ("abcddim: four arguments required");
   endif
 
   n = m = p = -1;
 
   [a,an,am] = abcddims(a);
diff --git a/scripts/control/abcddims.m b/scripts/control/abcddims.m
--- a/scripts/control/abcddims.m
+++ b/scripts/control/abcddims.m
@@ -1,35 +1,35 @@
-# Copyright (C) 1997 Auburn University.  All Rights Reserved
-# 
-# This file is part of Octave.
-# 
-# Octave is free software; you can redistribute it and/or modify it
-# under the terms of the GNU General Public License as published by the
-# Free Software Foundation; either version 2, or (at your option) any
-# later version.
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License
-# along with Octave; see the file COPYING.  If not, write to the Free
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
+## Copyright (C) 1997 Auburn University.  All Rights Reserved
+## 
+## This file is part of Octave.
+## 
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File } {[@var{y}, @var{my}, @var{ny}] =} abcddims (@var{x})
 ## 
 ## Used internally in @code{abcddim}.  If @var{x} is a zero-size matrix, 
 ## both dimensions are set to 0 in @var{y}.  
 ## @var{my} and @var{ny} are the row and column dimensions of the result.
 ## @end deftypefn
 
 function [y,my,ny] = abcddims (x)
-# Written by A. S. Hodel (scotte@eng.auburn.edu) Feb 1997
+## Written by A. S. Hodel (scotte@eng.auburn.edu) Feb 1997
 
   y = x;
   if(isempty(y))
     y = [];
   endif
   [my,ny] = size(y);
 endfunction
diff --git a/scripts/control/analdemo.m b/scripts/control/analdemo.m
--- a/scripts/control/analdemo.m
+++ b/scripts/control/analdemo.m
@@ -1,34 +1,34 @@
-# Copyright (C) 1996 Auburn University.  All Rights Reserved
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1996 Auburn University.  All Rights Reserved
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
  
 ## -*- texinfo -*-
 ## @deftypefn {Function File } { } analdemo ( ) 
 ##  Octave Controls toolbox demo: State Space analysis demo
 ## @end deftypefn
 
 function analdemo()
-# Written by David Clem August 15, 1994
-# Updated by John Ingram December 1996
+## Written by David Clem August 15, 1994
+## Updated by John Ingram December 1996
   
   while (1)
     clc
     k=0;
     while(k > 8 || k < 1)
       k = menu("Octave State Space Analysis Demo", ...
         "System grammians (gram, dgram)", ...
         "System zeros (tzero)", ...
diff --git a/scripts/control/are.m b/scripts/control/are.m
--- a/scripts/control/are.m
+++ b/scripts/control/are.m
@@ -1,25 +1,25 @@
-# Copyright (C) 1993, 1994, 1995 Auburn University.  All Rights Reserved
-# 
-# This file is part of Octave.
-# 
-# Octave is free software; you can redistribute it and/or modify it
-# under the terms of the GNU General Public License as published by the
-# Free Software Foundation; either version 2, or (at your option) any
-# later version.
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License
-# along with Octave; see the file COPYING.  If not, write to the Free
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
+## Copyright (C) 1993, 1994, 1995 Auburn University.  All Rights Reserved
+## 
+## This file is part of Octave.
+## 
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} are (@var{a}, @var{b}, @var{c}, @var{opt})
 ## Solve the algebraic Riccati equation
 ## @iftex
 ## @tex
 ## $$
 ## A^TX + XA - XBX + C = 0
@@ -57,17 +57,17 @@
 ## Automatic Control, 1979) is applied to the appropriate Hamiltonian
 ## matrix.
 ## 
 ## @end deftypefn
 
 ## See also: balance, dare
 
 function x = are (a, b, c, opt)
-# Written by A. S. Hodel (scotte@eng.auburn.edu) August 1993.
+## Written by A. S. Hodel (scotte@eng.auburn.edu) August 1993.
 
   if (nargin == 3 || nargin == 4)
     if (nargin == 4)
       if (! (strcmp (opt, "N") || strcmp (opt, "P") ...
 	     || strcmp (opt, "S") || strcmp (opt, "B") ...
 	     || strcmp (opt, "n") || strcmp (opt, "p") ...
 	     || strcmp (opt, "s") || strcmp (opt, "b")))
 	warning ("are: opt has an invalid value; setting to B");
@@ -93,21 +93,21 @@ function x = are (a, b, c, opt)
     if ((p = is_square (c)) == 0)
       c = c' * c;
       p = rows (c);
     endif
     if (n != m || n != p)
       error ("are: a, b, c not conformably dimensioned.");
     endif
 
-# Should check for controllability/observability here
-# use Boley-Golub (Syst. Contr. Letters, 1984) method, not the
-#
-#                     n-1
-# rank ([ B A*B ... A^   *B]) method 
+## Should check for controllability/observability here
+## use Boley-Golub (Syst. Contr. Letters, 1984) method, not the
+##
+##                     n-1
+## rank ([ B A*B ... A^   *B]) method 
 
     [d, h] = balance ([a, -b; -c, -a'], opt);
     [u, s] = schur (h, "A");
     u = d * u;
     n1 = n + 1;
     n2 = 2 * n;
     x = u (n1:n2, 1:n) / u (1:n, 1:n);
   else
diff --git a/scripts/control/axis2dlim.m b/scripts/control/axis2dlim.m
--- a/scripts/control/axis2dlim.m
+++ b/scripts/control/axis2dlim.m
@@ -1,25 +1,25 @@
-# Copyright (C) 1998 Auburn University.  All Rights Reserved
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1998 Auburn University.  All Rights Reserved
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
 
 ## -*- texinfo -*-
 ## @deftypefn{Function File } { @var{axvec} =} axis2dlim (@var{axdata})
 ##  determine axis limits for 2-d data(column vectors); leaves a 10% margin 
 ##  around the plots.
 ##  puts in margins of +/- 0.1 if data is one dimensional (or a single point)
 ## 
 ## @strong{Inputs}
@@ -30,32 +30,32 @@
 ## @end deftypefn
 
 function axvec = axis2dlim(axdata)
 
   if(isempty(axdata))
     axdata = 0;
   endif
 
-  # compute axis limits
+  ## compute axis limits
   minv = min(axdata);
   maxv = max(axdata);
   delv = (maxv-minv)/2;      # breadth of the plot
   midv = (minv + maxv)/2;    # midpoint of the plot
   axmid = [midv(1), midv(1), midv(2), midv(2)];
   axdel = [-0.1, 0.1,-0.1,0.1];   # default plot width (if less than 2-d data)
   if(max(delv) == 0)
     if(midv(1) != 0)
       axdel(1:2) = [-0.1*midv(1),0.1*midv(1)];
     endif
     if(midv(2) != 0)
       axdel(3:4) = [-0.1*midv(2),0.1*midv(2)];
     endif
   else
-    # they're at least one-dimensional
+    ## they're at least one-dimensional
     if(delv(1) != 0)
       axdel(1:2) = 1.1*[-delv(1),delv(1)];
     endif
     if(delv(2) != 0)
       axdel(3:4) = 1.1*[-delv(2),delv(2)];
     endif
   endif
   axvec = axmid + axdel; 
diff --git a/scripts/control/bddemo.m b/scripts/control/bddemo.m
--- a/scripts/control/bddemo.m
+++ b/scripts/control/bddemo.m
@@ -1,34 +1,35 @@
-# Copyright (C) 1996 Auburn University.  All Rights Reserved
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1996 Auburn University.  All Rights Reserved
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File } { outputs =} bddemo ( inputs ) 
 ##  Octave Controls toolbox demo: Block Diagram Manipulations demo
 ## @end deftypefn
  
 function bddemo()
-# Written by David Clem August 15, 1994
-# Modified by A S Hodel Summer-Fall 1996
+
+  ## Written by David Clem August 15, 1994
+  ## Modified by A S Hodel Summer-Fall 1996
 
   str_sav = implicit_str_to_num_ok;
   sav_page = page_screen_output;
   implicit_str_to_num_ok = 1;
   page_screen_output = 1;
 
   while (1)
     clc
@@ -306,17 +307,17 @@ function bddemo()
       disp("sys2=")
       sysout(sys2);
       cmd = "sysp = parallel(sys1,sys2);";
       run_cmd
       disp("sysp=")
       sysout(sysp);
       prompt
     elseif (k == 12)
-      # buildssic description
+      ## buildssic description
       disp(" ")
       disp("        ---------------------------------------")
       disp("                    b u i l d s s i c")
       disp("          (BUILD State Space InterConnections)")
       disp("        ---------------------------------------")
       disp(" ")
       disp("buildssic builds a single system from up to 8 systems.")
       disp("It's primary pupose is the forming of interconnections")
diff --git a/scripts/control/bode.m b/scripts/control/bode.m
--- a/scripts/control/bode.m
+++ b/scripts/control/bode.m
@@ -1,25 +1,25 @@
-# Copyright (C) 1996,1998 Auburn University.  All Rights Reserved
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1996,1998 Auburn University.  All Rights Reserved
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File } {[@var{mag}, @var{phase}, @var{w}] =} bode(@var{sys}@{,@var{w}, @var{out_idx}, @var{in_idx}@})
 ## If no output arguments are given: produce Bode plots of a system; otherwise,
 ## compute the frequency response of a system data structure
 ## 
 ## @strong{Inputs}
 ## @table @var
@@ -86,24 +86,25 @@
 ## 
 ## @item If the requested plot is for an MIMO system, mag is set to
 ##  @math{||G(jw)||} or @math{||G(@code{exp}(jwT))||}
 ## and phase information is not computed.
 ## @end enumerate
 ## @end deftypefn 
 
 function [mag_r,phase_r,w_r] = bode(sys,w,outputs,inputs,plot_style)
-# Written by John Ingram  July 10th, 1996
-# Based on previous code
-# By R. Bruce Tenison, July 13, 1994
-# Modified by David Clem November 13, 1994
-# again by A. S. Hodel July 1995 (smart plot range, etc.)
-# Modified by Kai P. Mueller September 28, 1997 (multiplot mode)
 
-  # check number of input arguments given
+  ## Written by John Ingram  July 10th, 1996
+  ## Based on previous code
+  ## By R. Bruce Tenison, July 13, 1994
+  ## Modified by David Clem November 13, 1994
+  ## again by A. S. Hodel July 1995 (smart plot range, etc.)
+  ## Modified by Kai P. Mueller September 28, 1997 (multiplot mode)
+
+  ## check number of input arguments given
   if (nargin < 1 | nargin > 5)
     usage("[mag,phase,w] = bode(sys[,w,outputs,inputs,plot_style])");
   endif
   if(nargin < 2)
     w = [];
   endif
   if(nargin < 3)
     outputs = [];
@@ -123,22 +124,22 @@ function [mag_r,phase_r,w_r] = bode(sys,
     error ("bode: invalid value of plot_style specified");
   endif
 
   [f, w] = bodquist(sys,w,outputs,inputs,"bode");
 
   [stname,inname,outname] = sysgetsignals(sys);
   systsam = sysgettsam(sys);
 
-  # Get the magnitude and phase of f.
+  ## Get the magnitude and phase of f.
   mag = abs(f);
   phase = arg(f)*180.0/pi;
 
   if (nargout < 1),
-    # Plot the information
+    ## Plot the information
     if(gnuplot_has_multiplot)
       oneplot();
     endif
     gset autoscale;
     if(gnuplot_has_multiplot)
       gset nokey;
     endif
     clearplot();
@@ -191,17 +192,17 @@ function [mag_r,phase_r,w_r] = bode(sys,
       axvec(1:2) = wv;
       axis(axvec);
       xlabel(xlstr);
       ylabel("Phase in deg");
       title([ "phase([Y/U]", tistr, ...
 	 "), u=", nth(inname,1),", y=",nth(outname,1)]);
       grid("on");
       semilogx(w,phase);
-      # This should be the default for subsequent plot commands.
+      ## This should be the default for subsequent plot commands.
       if(gnuplot_has_multiplot)
         oneplot();
       endif
     endif
   else
     mag_r = mag;
     phase_r = phase;
     w_r = w;
diff --git a/scripts/control/bode_bounds.m b/scripts/control/bode_bounds.m
--- a/scripts/control/bode_bounds.m
+++ b/scripts/control/bode_bounds.m
@@ -1,72 +1,73 @@
-# Copyright (C) 1996 Auburn University.  All Rights Reserved
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1996 Auburn University.  All Rights Reserved
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File } {[@var{wmin}, @var{wmax}] =} bode_bounds (@var{zer}, @var{pol}, @var{dflg}@{, @var{tsam} @})
 ## Get default range of frequencies based on cutoff frequencies of system
 ## poles and zeros.
 ## Frequency range is the interval [10^wmin,10^wmax]
 ## 
 ## Used internally in freqresp (@code{bode}, @code{nyquist})
 ## @end deftypefn
  
 function [wmin,wmax] = bode_bounds(zer,pol,DIGITAL,tsam)
-  # make sure zer,pol are row vectors
+
+  ## make sure zer,pol are row vectors
   if(!isempty(pol)) pol = reshape(pol,1,length(pol)); endif
   if(!isempty(zer)) zer = reshape(zer,1,length(zer)); endif
 
-# check for natural frequencies away from omega = 0
+  ## check for natural frequencies away from omega = 0
   if (DIGITAL)
-    # The 2nd conditions prevents log(0) in the next log command
+    ## The 2nd conditions prevents log(0) in the next log command
     iiz = find(abs(zer - 1) > norm(zer) * eps && abs(zer) > norm(zer) * eps);
     iip = find(abs(pol - 1) > norm(pol) * eps && abs(pol) > norm(pol) * eps);
 
-    # avoid dividing empty matrices, it would work but looks nasty
+    ## avoid dividing empty matrices, it would work but looks nasty
     if (!isempty(iiz)) czer = log(zer(iiz))/tsam;
     else               czer = [];                 endif
 
     if (!isempty(iip)) cpol = log(pol(iip))/tsam;
     else 	       cpol = [];                 endif
 
   else
-    # continuous
+    ## continuous
     iip = find((abs(pol)) > (norm(pol) * eps));
     iiz = find((abs(zer)) > (norm(zer) * eps));
 
     if(!isempty(zer)) czer = zer(iiz);
     else              czer = [];                endif
     if(!isempty(pol)) cpol = pol(iip);
     else              cpol = [];                endif
   endif
 
   if(max(size(iip)) + max(size(iiz)) )
     wmin = floor(log10(min(abs([cpol,czer]))));
     wmax = ceil(log10(max(abs([cpol,czer]))));
   else
-    # no poles/zeros away from omega = 0; pick defaults
+    ## no poles/zeros away from omega = 0; pick defaults
     wmin = -1;
     wmax = 3;
   endif
 
-  # expand to show the entirety of the "interesting" portion of the plot
+  ## expand to show the entirety of the "interesting" portion of the plot
   wmin--;
   wmax++;
 
-  # run digital frequency all the way to pi
+  ## run digital frequency all the way to pi
   if (DIGITAL) wmax = log10(pi/tsam); endif
 endfunction
diff --git a/scripts/control/bodquist.m b/scripts/control/bodquist.m
--- a/scripts/control/bodquist.m
+++ b/scripts/control/bodquist.m
@@ -1,25 +1,25 @@
-# Copyright (C) 1996,1998 Auburn University.  All Rights Reserved
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1996,1998 Auburn University.  All Rights Reserved
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File } { [@var{f}, @var{w}] =} bodquist (@var{sys}, @var{w}, @var{out_idx}, @var{in_idx})
 ##  used internally by bode, nyquist; compute system frequency response.
 ## 
 ## @strong{Inputs}
 ## @table @var
 ## @item sys
@@ -46,56 +46,57 @@
 ## Both bode and nyquist share the same introduction, so the common parts are 
 ## in bodquist.  It contains the part that finds the number of arguments, 
 ## determines whether or not the system is SISO, and computes the frequency 
 ## response.  Only the way the response is plotted is different between the 
 ## two functions.
 ## @end deftypefn
  
 function [f,w] = bodquist(sys,w,outputs,inputs,rname)
-  # check number of input arguments given
+
+  ## check number of input arguments given
   if (nargin != 5)
     usage("[f,w] = bodquist(sys,w,outputs,inputs,rname)");
   endif
 
-  # check each argument to see if it's in the correct form
+  ## check each argument to see if it's in the correct form
   if (!is_struct(sys))
     error("sys must be a system data structure");
   endif
 	
-  # let freqresp determine w if it's not already given
+  ## let freqresp determine w if it's not already given
   USEW = freqchkw(w);
 
-  # get initial dimensions (revised below if sysprune is called)
+  ## get initial dimensions (revised below if sysprune is called)
   [nn,nz,mm,pp ] = sysdimensions(sys);
 
-  # check for an output vector and to see whether it`s correct
+  ## check for an output vector and to see whether it`s correct
   if (!isempty(outputs))
     if (isempty(inputs))
       inputs = 1:mm;			# use all inputs
       warning([rname,": outputs specified but not inputs"]);
     endif
     sys = sysprune(sys,outputs,inputs);
     [nn,nz,mm,pp ] = sysdimensions(sys);
   endif
 
-  # for speed in computation, convert local copy of 
-  # SISO state space systems to zero-pole  form
+  ## for speed in computation, convert local copy of 
+  ## SISO state space systems to zero-pole  form
   if( is_siso(sys) & strcmp( sysgettype(sys), "ss") )
     [zer,pol,k,tsam,inname,outname] = sys2zp(sys);
     sys = zp2sys(zer,pol,k,tsam,inname,outname);
   endif
 
-  # get system frequency response
+  ## get system frequency response
   [f,w] = freqresp(sys,USEW,w);   
 
   phase = arg(f)*180.0/pi;
 
   if(!USEW)
-    # smooth plots
+    ## smooth plots
     pcnt = 5;		# max number of refinement steps
     dphase = 5;		# desired max change in phase
     dmag = 0.2;		# desired max change in magnitude
     while(pcnt)
       pd = abs(diff(phase));			# phase variation
       pdbig = vec(find(pd > dphase));
 
       lp = length(f);  lp1 = lp-1;		# relative variation
@@ -137,17 +138,17 @@ function [f,w] = bodquist(sys,w,outputs,
           [w,idx] = sort(w);		# sort into order
           f = f(idx);
           phase = arg(f)*180.0/pi;
         endif
       endif
     endwhile
   endif
 
-  # ensure unique frequency values
+  ## ensure unique frequency values
   [w,idx] = sort(w);
   f = f(idx);
 
   w_diff = diff(w);
   w_dup = find(w_diff == 0);
   w_idx = complement(w_dup,1:length(w));
   w = w(w_idx);
   f = f(w_idx);
diff --git a/scripts/control/buildssic.m b/scripts/control/buildssic.m
--- a/scripts/control/buildssic.m
+++ b/scripts/control/buildssic.m
@@ -1,25 +1,25 @@
-# Copyright (C) 1998 Kai P. Mueller
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1998 Kai P. Mueller
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File } {[@var{sys}] =} buildssic(@var{Clst}, @var{Ulst}, @var{Olst}, @var{Ilst}, @var{s1}, @var{s2}, @var{s3}, @var{s4}, @var{s5}, @var{s6}, @var{s7}, @var{s8})
 ## 
 ## Contributed by Kai Mueller.
 ## 
 ##  Form an arbitrary complex (open or closed loop) system in
 ##  state-space form from several systems. "@code{buildssic}" can
@@ -122,17 +122,18 @@
 ## @example
 ## GW = buildssic([1 4;2 4;3 1],[3],[2 3 5],[3 4],G,W1,W2,One);
 ## @end example
 ## where "One" is a unity gain (auxillary) function with order 0.
 ## (e.g. @code{One = ugain(1);})
 ## @end deftypefn
  
 function [sys] = buildssic(Clst,Ulst,Olst,Ilst,s1,s2,s3,s4,s5,s6,s7,s8)
-# Written by Kai Mueller April 1998
+
+  ## Written by Kai Mueller April 1998
 
   if((nargin < 5) || (nargin > 12))
     usage("[sys] = buildssic(Clst,Ulst,Olst,Ilst,s1,s2,s3,s4,s5,s6,s7,s8)");
   endif
   if (nargin >= 5)
     if (!is_struct(s1))
       error("---> s1 must be a structed system.");
     endif
@@ -164,41 +165,41 @@ function [sys] = buildssic(Clst,Ulst,Ols
       endif
       if (tsam != sysgettsam(ss))
 	error("---> sampling time of all systems must match.");
       endif
     endif
     [as,bs,cs,ds] = sys2ss(ss);
     nt1 = n1 + nz1;
     if (!nt1)
-      # pure gain (pad B, C with zeros)
+      ## pure gain (pad B, C with zeros)
       B = [B, zeros(nt,m1)];
       C = [C; zeros(p1,nt)];
     else
       A = [A, zeros(nt,nt1); zeros(nt1,nt), as];
       B = [B, zeros(nt,m1);  zeros(nt1,m),  bs];
       C = [C, zeros(p,nt1);  zeros(p1,nt),  cs];
     endif
     D = [D, zeros(p,m1); zeros(p1,m), ds];
     n = n + n1;
     nz = nz + nz1;
     nt = nt + nt1;
     m = m + m1;
     p = p + p1;
   endfor
 
-  # check maximum dimensions
+  ## check maximum dimensions
   [nx, mx] = size(Clst);
   if (nx > m)
     error("---> more rows in Clst than total number of inputs.");
   endif
   if (mx > p+1)
     error("---> more cols in Clst than total number of outputs.");
   endif
-  # empty vector Ulst is OK
+  ## empty vector Ulst is OK
   lul = length(Ulst);
   if (lul)
     if (!is_vector(Ulst))
       error("---> Input u list Ulst must be a vector.");
     endif
     if (lul > m)
       error("---> more values in Ulst than number of inputs.");
     endif
@@ -207,17 +208,17 @@ function [sys] = buildssic(Clst,Ulst,Ols
   if (!length(Ilst))  Ilst = [1:m];        endif
   if (!is_vector(Olst))
     error("---> Output list Olst must be a vector.");
   endif
   if (!is_vector(Ilst))
     error("---> Input list Ilst must be a vector.");
   endif
 
-  # build the feedback "K" from the interconnection data Clst
+  ## build the feedback "K" from the interconnection data Clst
   K = zeros(m, p);
   inp_used = zeros(m,1);
   for ii = 1:nx
     xx = Clst(ii,:);
     iu = xx(1);
     if ((iu < 1) || (iu > m))
       error("---> Illegal value in first col of Clst.");
     endif
@@ -230,49 +231,49 @@ function [sys] = buildssic(Clst,Ulst,Ols
       if (abs(it) > p)
       	error("---> Illegal row value in Clst.");
       elseif (it)
 	K(iu,abs(it)) = sign(it);
       endif
     endfor
   endfor
 
-  # form the "closed loop", i.e replace u in
-  # .
-  # x = Ax + Bu
-  #                            ~
-  # y = Cx + Du   by   u = K*y+u
-  #
-  #            -1
-  # R = (I-D*K)   must exist.
-  # 
+  ## form the "closed loop", i.e replace u in
+  ## .
+  ## x = Ax + Bu
+  ##                            ~
+  ## y = Cx + Du   by   u = K*y+u
+  ##
+  ##            -1
+  ## R = (I-D*K)   must exist.
+
   R = eye(p) - D*K;
   if (rank(R) < p)
     error("---> singularity in algebraic loop.");
   else
     R = inv(R);
   endif
   A = A + B*K*R*C;
   B = B + B*K*R*D;
   C = R*C;
   D = R*D;
 
-  # append old inputs u to the outputs (if lul > 0)
+  ## append old inputs u to the outputs (if lul > 0)
   kc = K*C;
   kdi = eye(m) + K*D;
   for ii = 1:lul
     it = Ulst(ii);
     if ((it < 1) || (it > m))
       error("---> Illegal value in Ulst.");
     endif
     C = [C; kc(it,:)];
     D = [D; kdi(it,:)];
   endfor
 
-  # select and rearrange outputs
+  ## select and rearrange outputs
   nn = length(A);
   lol = length(Olst);
   Cnew = zeros(lol,nn);
   Dnew = zeros(lol,m);
   for ii = 1:lol
     iu = Olst(ii);
     if (!iu || (abs(iu) > p+lul))
       error("---> Illegal value in Olst.");
diff --git a/scripts/control/c2d.m b/scripts/control/c2d.m
--- a/scripts/control/c2d.m
+++ b/scripts/control/c2d.m
@@ -1,25 +1,25 @@
-# Copyright (C) 1993, 1994, 1995 John W. Eaton
-# 
-# This file is part of Octave.
-# 
-# Octave is free software; you can redistribute it and/or modify it
-# under the terms of the GNU General Public License as published by the
-# Free Software Foundation; either version 2, or (at your option) any
-# later version.
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License
-# along with Octave; see the file COPYING.  If not, write to the Free
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
+## Copyright (C) 1993, 1994, 1995 John W. Eaton
+## 
+## This file is part of Octave.
+## 
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File } { @var{dsys} =} c2d (@var{sys}@{, @var{opt}, @var{T}@})
 ## @deftypefnx {Function File } { @var{dsys} =} c2d (@var{sys}@{, @var{T}@})
 ## 
 ## @strong{Inputs}
 ## @table @var
 ## @item sys
@@ -62,36 +62,37 @@
 ## @end example
 ## via the matrix exponential or bilinear transform
 ## 
 ## @strong{Note} This function adds the suffix  @code{_d}
 ## to the names of the new discrete states.   
 ## @end deftypefn
 
 function dsys = c2d (sys, opt, T)
-# Written by R.B. Tenison (btenison@eng.auburn.edu)
-# October 1993
-# Updated by John Ingram for system data structure August 1996
+
+  ## Written by R.B. Tenison (btenison@eng.auburn.edu)
+  ## October 1993
+  ## Updated by John Ingram for system data structure August 1996
 
   save_val = implicit_str_to_num_ok;	# save for later
   implicit_str_to_num_ok = 1;
 
-# parse input arguments
+  ## parse input arguments
   if(nargin < 1 | nargin > 3)
     usage("dsys=c2d(sys[,T])");
   elseif (!is_struct(sys))
     error("sys must be a system data structure");
   elseif (nargin == 1)
     opt = "ex";
   elseif (nargin == 2 & !isstr(opt) )
     T = opt;
     opt = "ex";
   endif
 
-  # check if sampling period T was passed.
+  ## check if sampling period T was passed.
   Ts = sysgettsam(sys);
   if(!exist("T"))
     T = Ts;
     if(T == 0)
       error("sys is purely continuous; no sampling period T provided");
     endif
   elseif (T != Ts & Ts > 0)
     warning(["c2d: T=",num2str(T),", system tsam==",num2str(Ts), ...
@@ -107,17 +108,17 @@ function dsys = c2d (sys, opt, T)
 
   sys = sysupdate(sys,"ss");
   [n,nz,m,p] = sysdimensions(sys);
 
   if (n == 0)
     warning("c2d: sys has no continuous states; setting outputs to discrete");
     dsys = syssetsignals(sys,"yd",ones(1:p));
   elseif(strcmp(opt,"ex"))
-    # construct new state-space (a,b,c,d) for continuous subsystem
+    ## construct new state-space (a,b,c,d) for continuous subsystem
     [csys,Acd] = syscont(sys);   	# extract continuous subsystem
     [csys_a, csys_b, csys_c, csys_d] = sys2ss(csys);
     [ sys_a,  sys_b,  sys_c,  sys_d] = sys2ss( sys);
     if(isempty(Acd))                Bmat = sys_b;
     elseif(isempty(csys_b))         Bmat = Acd;
     else                            Bmat = [Acd, csys_b];     endif
     
     row_zer = columns(Bmat);
@@ -137,27 +138,27 @@ function dsys = c2d (sys, opt, T)
     Abar = matexp( 1:csysn , 1:(csysn + columns(Acd)) );  
     Bbar = matexp( 1:csysn , (columns(Abar) + 1):columns(matexp) );
 
     newnz = rows(Abar);
     outlist = ones(1,rows(csysc));
     [stnames,innames,outnames] = sysgetsignals(csys);
     dsys = ss2sys(Abar,Bbar,csysc,csysd,T,0,newnz,stnames,innames, ...
 	outnames,outlist);
-    # rename states
+    ## rename states
     for ii=1:newnz
       strval = sprintf("%s_d",sysgetsignals(dsys,"st",ii,1));
       dsys = syssetsignals(dsys,"st",strval,ii);
     endfor
 
   elseif(strcmp(opt,"bi"))
     if(is_digital(sys))
       error("c2d: system is already digital")
     else
-      # convert with bilinear transform
+      ## convert with bilinear transform
       [a,b,c,d,tsam,n,nz,stname,inname,outname,yd] = sys2ss(sys);
       IT = (2/T)*eye(size(a));
       A = (IT+a)/(IT-a);
       iab = (IT-a)\b;
       tk=2/sqrt(T);
       B = tk*iab;
       C = tk*(c/(IT-a));
       D = d + (c*iab);
diff --git a/scripts/control/com2str.m b/scripts/control/com2str.m
--- a/scripts/control/com2str.m
+++ b/scripts/control/com2str.m
@@ -1,35 +1,35 @@
-# Copyright (C) 1998 Auburn University.  All Rights Reserved
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1998 Auburn University.  All Rights Reserved
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
  
+## usage retval = com2str(zz{,flg})
+##  
+## convert complex number to a string
+## zz: complex number
+## flg: format flag
+##      0 (default):            -1, 0, 1,   1i,   1 + 0.5i
+##      1 (for use with zpout): -1, 0, + 1, + 1i, + 1 + 0.5i
+
 function retval = com2str(zz,flg)
-# usage retval = com2str(zz{,flg})
-#  
-# convert complex number to a string
-# zz: complex number
-# flg: format flag
-#      0 (default):            -1, 0, 1,   1i,   1 + 0.5i
-#      1 (for use with zpout): -1, 0, + 1, + 1i, + 1 + 0.5i
-#
 
   if (nargin < 1 | nargin > 2)
     usage("com2str(zz{,flg})");
   endif
   if(nargin == 1)
     flg = 0;
   endif
  
@@ -41,34 +41,34 @@ function retval = com2str(zz,flg)
     error(["Illegal flg value: ",num2str(flg)]);
   endif
 
   sgns = "+-";
   rz = real(zz);
   iz = imag(zz);
   az = abs(zz);
   if(iz == 0)
-    # strictly a real number
+    ## strictly a real number
     switch(flg)
     case(0)
       retval = num2str(rz);
     case(1)
       retval = [ sgns(1+(rz< 0))," ", num2str(abs(rz))];
     endswitch
   elseif(rz == 0)
-    # strictly an imaginary number
+    ## strictly an imaginary number
     switch(flg)
     case(0)
       retval = num2str(iz);
     case(1)
       retval = [ sgns(1+(iz< 0))," ", num2str(abs(iz)),"i"];
     endswitch
   else
-    # complex number
-    # strictly an imaginary number
+    ## complex number
+    ## strictly an imaginary number
     switch(flg)
     case(0)
       retval = [num2str(rz)," ",com2str(i*iz,1)];
     case(1)
       retval = [ sgns(1+(rz< 0))," ", num2str(abs(rz))," ",com2str(i*iz,1)];
     endswitch
   endif
   
diff --git a/scripts/control/controldemo.m b/scripts/control/controldemo.m
--- a/scripts/control/controldemo.m
+++ b/scripts/control/controldemo.m
@@ -1,31 +1,31 @@
-# Copyright (C) 1996 Auburn University.  All Rights Reserved
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it
-# under the terms of the GNU General Public License as published by the
-# Free Software Foundation; either version 2, or (at your option) any
-# later version.
-#
-# Octave is distributed in the hope that it will be useful, but WITHOUT
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-# for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Octave; see the file COPYING.  If not, write to the Free
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
+## Copyright (C) 1996 Auburn University.  All Rights Reserved
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
+##
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+## for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 function DEMOcontrol()
-# Controls toolbox demo.
-# Demo programs: bddemo.m, frdemo.m, analdemo.m, moddmeo.m, rldemo.m
-#  
-# Written by David Clem August 15, 1994
+## Controls toolbox demo.
+## Demo programs: bddemo.m, frdemo.m, analdemo.m, moddmeo.m, rldemo.m
+##  
+## Written by David Clem August 15, 1994
 
   disp(' O C T A V E    C O N T R O L   S Y S T E M S   T O O L B O X')
 
   while (1)
     clc
     k = 0;
     while (k > 8 || k < 1),
       k = menu("Octave Controls System Toolbox Demo", ...
diff --git a/scripts/control/ctrb.m b/scripts/control/ctrb.m
--- a/scripts/control/ctrb.m
+++ b/scripts/control/ctrb.m
@@ -1,25 +1,25 @@
-# Copyright (C) 1997 Kai P. Mueller
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1997 Kai P. Mueller
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File } {@var{Qs} =} ctrb(@var{sys} @{, @var{b}@})
 ## @deftypefnx {Function File } {@var{Qs} =} ctrb(@var{A}, @var{B})
 ## Build controllability matrix
 ## @example
 ##              2       n-1
 ## Qs = [ B AB A B ... A   B ]
@@ -28,35 +28,36 @@
 ##  of a system data structure or the pair (@var{A}, @var{B}).
 ## 
 ## @strong{Note} @code{ctrb} forms the controllability matrix.
 ##        The numerical properties of @code{is_controllable}
 ##        are much better for controllability tests.
 ## @end deftypefn
 
 function Qs = ctrb(sys, b)
-  # Written by Kai P. Mueller November 4, 1997
-  # based on is_controllable.m of Scottedward Hodel
-  # modified by
+
+  ## Written by Kai P. Mueller November 4, 1997
+  ## based on is_controllable.m of Scottedward Hodel
+  ## modified by
 
   if (nargin == 2)
     a = sys;
   elseif (nargin == 1 && is_struct(sys))
     sysupdate(sys,"ss");
     [a,b] = sys2ss(sys);
   else
     usage("ctrb(sys [, b])")
   endif
 
   if (!is_abcd(a,b))
     Qs = [];
   else
-    # no need to check dimensions, we trust is_abcd().
+    ## no need to check dimensions, we trust is_abcd().
     [na, ma] = size(a);
-    # using imb avoids name conflict with the "mb" function
+    ## using imb avoids name conflict with the "mb" function
     [inb, imb] = size(b);
     Qs = zeros(na, ma*imb);
     for i = 1:na
       Qs(:, (i-1)*imb+1:i*imb) = b;
       b = a * b;
     endfor
   endif
 endfunction
diff --git a/scripts/control/d2c.m b/scripts/control/d2c.m
--- a/scripts/control/d2c.m
+++ b/scripts/control/d2c.m
@@ -1,25 +1,25 @@
-# Copyright (C) 1996,1998 Auburn University.  All Rights Reserved
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1996,1998 Auburn University.  All Rights Reserved
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File } {@var{csys} =} d2c (@var{sys}@{,@var{tol}@})
 ## @deftypefnx {Function File } {@var{csys} =} d2c (@var{sys}, @var{opt})
 ## Convert discrete (sub)system to a purely continuous system.  Sampling
 ## time used is @code{sysgettsam(@var{sys})}
 ## 
 ## @strong{Inputs}
@@ -52,19 +52,20 @@
 ## @end table
 ## @strong{Outputs} @var{csys} continuous time system (same dimensions and
 ## signal names as in @var{sys}).
 ## @end deftypefn
 ## 
 
  
 function csys = d2c(sys,opt)
-# Written by R. Bruce Tenison August 23, 1994
-# Updated by John Ingram for system data structure  August 1996
-# SYS_INTERNAL accesses members of system data structure
+
+  ## Written by R. Bruce Tenison August 23, 1994
+  ## Updated by John Ingram for system data structure  August 1996
+  ## SYS_INTERNAL accesses members of system data structure
 
   save_val = implicit_str_to_num_ok;	# save for later
   implicit_str_to_num_ok = 1;
 
   if( (nargin != 1) & (nargin != 2) )
     usage("csys = d2c(sys[,tol]), csys = d2c(sys,opt)");
   elseif (!is_struct(sys))
     error("sys must be in system data structure");
@@ -83,18 +84,18 @@ function csys = d2c(sys,opt)
 	", intended c2d call?"])
   else
     tol = opt;
     opt = "log";
   endif
   T = sysgettsam(sys);
 
   if(strcmp(opt,"bi"))
-    # bilinear transform
-    # convert with bilinear transform
+    ## bilinear transform
+    ## convert with bilinear transform
     if (! is_digital(sys) )
        error("d2c requires a discrete time system for input")
     endif
     [a,b,c,d,tsam,n,nz,stname,inname,outname,yd] = sys2ss(sys);
 
     poles = eig(a);
     if( find(abs(poles-1) < 200*(n+nz)*eps) )
       warning("d2c: some poles very close to one.  May get bad results.");
@@ -141,28 +142,28 @@ function csys = d2c(sys,opt)
       warning("d2c: some poles very close to one.  May get bad results.");
       logmat = real(logm(Amat)/T);
       Mtop = logmat(1:na,:);
     else
       logmat = real(logm(Amat)/T);
       Mtop = logmat(1:na,:);
     endif
   
-    # perform simplistic, stupid optimization approach.
-    # should re-write with a Davidson-Fletcher CG approach
+    ## perform simplistic, stupid optimization approach.
+    ## should re-write with a Davidson-Fletcher CG approach
     mxthresh = norm(Mtop);
     if(mxthresh == 0)
       mxthresh = 1;
     endif
     eps1 = mxthresh;	#gradient descent step size
     cnt = max(20,(n*nz)*4);	#max number of iterations
     newgrad=1;	#signal for new gradient
     while( (eps1/mxthresh > tol) & cnt)
       cnt = cnt-1;
-      # calculate the gradient of error with respect to Amat...
+      ## calculate the gradient of error with respect to Amat...
       geps = norm(Mtop)*1e-8;
       if(geps == 0)
         geps = 1e-8;
       endif
       DMtop = Mtop;
       if(isempty(b))
         Mall = Mtop;
         DMall = DMtop;
@@ -180,17 +181,17 @@ function csys = d2c(sys,opt)
   	    - norm(Amat-expm(Mall*T),'fro');
       	  DMall(ii,jj) = Mall(ii,jj);
           endfor
         endfor
         GrMall = GrMall/norm(GrMall,1);
         newgrad = 0;
       endif
   
-      #got a gradient, now try to use it
+      ## got a gradient, now try to use it
       DMall = Mall-eps1*GrMall;
   
       FMall = expm(Mall*T);
       FDMall = expm(DMall*T);
       FmallErr = norm(Amat - FMall);
       FdmallErr = norm(Amat - FDMall);
       if( FdmallErr < FmallErr)
         Mtop = DMall(1:na,:);
@@ -208,17 +209,17 @@ function csys = d2c(sys,opt)
   
     [aa,bb,cc,dd,tsam,nn,nz,stnam,innam,outnam,yd] = sys2ss(sys);
     aa = Mall(1:na,1:na);
     if(!isempty(b))
       bb = Mall(1:na,(na+1):(na+nb));
     endif
     csys = ss2sys(aa,bb,cc,dd,0,na,0,stnam,innam,outnam);
     
-    # update names
+    ## update names
     nn = sysdimensions(sys);
     for ii = (nn+1):na
       strval = sprintf("%s_c",sysgetsignals(csys,"st",ii,1));
       csys = syssetsignals(csys,"st",strval,ii);
     endfor
   endif
 
   implicit_str_to_num_ok = save_val;	# restore value
diff --git a/scripts/control/damp.m b/scripts/control/damp.m
--- a/scripts/control/damp.m
+++ b/scripts/control/damp.m
@@ -1,43 +1,44 @@
-# Copyright (C) 1993, 1994, 1995 John W. Eaton
-# 
-# This file is part of Octave.
-# 
-# Octave is free software; you can redistribute it and/or modify it
-# under the terms of the GNU General Public License as published by the
-# Free Software Foundation; either version 2, or (at your option) any
-# later version.
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License
-# along with Octave; see the file COPYING.  If not, write to the Free
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
+## Copyright (C) 1993, 1994, 1995 John W. Eaton
+## 
+## This file is part of Octave.
+## 
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File } {} damp(@var{p}@{, @var{tsam}@})
 ##       Displays eigenvalues, natural frequencies and damping ratios
 ##       of the eigenvalues of a matrix @var{p} or the @var{A}-matrix of a
 ##       system @var{p}, respectively.
 ##       If @var{p} is a system, @var{tsam} must not be specified.
 ##       If @var{p} is a matrix and @var{tsam} is specified, eigenvalues
 ##       of @var{p} are assumed to be in @var{z}-domain.
 ## 
 ## See also: @code{eig}
 ## @end deftypefn
 
 function damp(p, tsam)
-# Written by Kai P. Mueller September 29, 1997.
-# Update
 
-  # assume a continuous system
+  ## Written by Kai P. Mueller September 29, 1997.
+  ## Update
+
+  ## assume a continuous system
   DIGITAL = 0;
   if(nargin < 1 || nargin > 2)
     usage("damp(p,[ tsamp])")
   endif
   if(is_struct(p))
     if (nargin != 1)
       error("damp: when p is a system, tsamp parameter is not allowed.");
     endif
@@ -52,17 +53,17 @@ function damp(p, tsam)
   endif
   if (!is_square(aa))
     error("damp: Matrix p is not square.")
   endif
   if (DIGITAL && t_samp <= 0.0)
     error("damp: Sampling time tsam must not be <= 0.")
   endif
 
-  # all checks done.
+  ## all checks done.
   e = eig(aa);
   [n, m] = size(aa);
   if (DIGITAL)
     printf("  (discrete system with sampling time %f)\n", t_samp);
   endif
   printf("............... Eigenvalue ...........     Damping     Frequency\n");
   printf("--------[re]---------[im]--------[abs]----------------------[Hz]\n");
   for i = 1:n
diff --git a/scripts/control/dare.m b/scripts/control/dare.m
--- a/scripts/control/dare.m
+++ b/scripts/control/dare.m
@@ -82,17 +82,17 @@ function x = dare (a, b, c, r, opt)
       if (opt != "N" || opt != "P" || opt != "S" || opt != "B")
 	warning ("dare: opt has an invalid value -- setting to B");
 	opt = "B";
       endif
     else
       opt = "B";
     endif
 
-    # dimension checks are done in is_controllable, is_observable
+    ## dimension checks are done in is_controllable, is_observable
     if (is_controllable (a, b) == 0)
       warning ("dare: a,b are not controllable");
     elseif (is_observable (a, c) == 0)
       warning ("dare: a,c are not observable");
     endif
 
     if ((p = is_square (c)) == 0)
       c = c'*c;
diff --git a/scripts/control/dcgain.m b/scripts/control/dcgain.m
--- a/scripts/control/dcgain.m
+++ b/scripts/control/dcgain.m
@@ -1,36 +1,36 @@
-# Copyright (C) 1993, 1994, 1995 John W. Eaton
-# 
-# This file is part of Octave.
-# 
-# Octave is free software; you can redistribute it and/or modify it
-# under the terms of the GNU General Public License as published by the
-# Free Software Foundation; either version 2, or (at your option) any
-# later version.
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License
-# along with Octave; see the file COPYING.  If not, write to the Free
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
+## Copyright (C) 1993, 1994, 1995 John W. Eaton
+## 
+## This file is part of Octave.
+## 
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File } {@var{gm} =} dcgain(@var{sys}@{, tol@})
 ##       Returns dc-gain matrix. If dc-gain is infinite
 ##       an empty matrix is returned.
 ##       The argument @var{tol} is an optional tolerance for the condition
 ##       number of @var{A}-Matrix in @var{sys} (default @var{tol} = 1.0e-10)
 ## @end deftypefn
 
 function gm = dcgain(sys, tol)
-# Written by Kai P Mueller (mueller@ifr.ing.tu-bs.de) October 1, 1997
+## Written by Kai P Mueller (mueller@ifr.ing.tu-bs.de) October 1, 1997
 
   if((nargin < 1) || (nargin > 2) || (nargout > 1))
     usage("[gm, ok] = dcgain(sys[, tol])");
   endif
   if(!is_struct(sys))
     error("dcgain: first argument is not a system data structure.")
   endif
   sys = sysupdate(sys, "ss");
diff --git a/scripts/control/demomarsyas.m b/scripts/control/demomarsyas.m
--- a/scripts/control/demomarsyas.m
+++ b/scripts/control/demomarsyas.m
@@ -1,25 +1,25 @@
-# Copyright (C) 1996 Auburn University.  All Rights Reserved
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1996 Auburn University.  All Rights Reserved
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
  
 page_screen_output = 1;
 opt = 0;
 QUITOPT = 7;
 while (opt != QUITOPT)
   opt = menu("Marsyas interface update demo:", ...
 	"run Marsyas on the magnetically suspended ball example", ...
         "load continuous time marsyas example system", ...
diff --git a/scripts/control/dezero.m b/scripts/control/dezero.m
--- a/scripts/control/dezero.m
+++ b/scripts/control/dezero.m
@@ -24,17 +24,17 @@
 ## Author: Kurt Hornik <Kurt.Hornik@ci.tuwien.ac.at>
 ## Adapted-By: jwe
 ## Adapted from deblank by A. S. Hodel (a.s.hodel@eng.auburn.edu)
 ## 	(the name dezero is a reference to the Fermilab D0 experiment,
 ##      where my sister did her PhD research) 
 
 function t = dezero (s)
 
-  # delete the next line if you're stubbornly going to use dezero.
+  ## delete the next line if you're stubbornly going to use dezero.
   error("dezero is no longer supported.");
 
   if (nargin != 1)
     usage ("dezero (s)");
   elseif (isstr (s))
 
     save_val = implicit_str_to_num_ok;
     implicit_str_to_num_ok = 1;
@@ -43,17 +43,17 @@ function t = dezero (s)
     len = nr * nc;
 
     if (len == 0)
       t = s;
     else
 
       s = reshape (s, 1, len);
 
-      # need to remove zeros first, then call deblank
+      ## need to remove zeros first, then call deblank
       s = 1*s;
       t = deblank(setstr(s(find(s != 0) )));
     endif
 
     implicit_str_to_num_ok = save_val;
 
   else
     error ("dezero: expecting string argument");
diff --git a/scripts/control/dgkfdemo.m b/scripts/control/dgkfdemo.m
--- a/scripts/control/dgkfdemo.m
+++ b/scripts/control/dgkfdemo.m
@@ -1,33 +1,33 @@
-# Copyright (C) 1996 Auburn University.  All Rights Reserved
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1996 Auburn University.  All Rights Reserved
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
 
 ## -*- texinfo -*-
 ##@deftypefn {Function File } { } dgkfdemo ( ) 
 ## Octave Controls toolbox demo: H2/Hinfinity options demos
 ##@end deftypefn
  
 function dgkfdemo()
-# Written by A. S. Hodel June 1995
+## Written by A. S. Hodel June 1995
  
   save_val = page_screen_output;
   page_screen_output = 1;
   while (1)
     clc
     menuopt=0;
     while(menuopt > 10 || menuopt < 1)
       menuopt = menu('Octave H2/Hinfinity options demo', ...
diff --git a/scripts/control/dgram.m b/scripts/control/dgram.m
--- a/scripts/control/dgram.m
+++ b/scripts/control/dgram.m
@@ -1,25 +1,25 @@
-# Copyright (C) 1996 Auburn University.  All Rights Reserved
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1996 Auburn University.  All Rights Reserved
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
  
 ## -*- texinfo -*-
 ## @deftypefn {Function File } { @var{m} =} dgram ( @var{a}, @var{b})
 ##  Return controllability grammian of discrete time system
 ## @example
 ##   x(k+1) = a x(k) + b u(k)
 ## @end example
 ## 
@@ -35,13 +35,14 @@
 ## @var{m} (@var{n} by @var{n}) satisfies
 ## @example
 ##  a m a' - m + b*b' = 0 
 ## @end example
 ## 
 ## @end deftypefn
 
 function m = dgram(a,b)
-  # Written by A. S. Hodel July 1995
 
-  # let dlyap do the error checking...
+  ## Written by A. S. Hodel July 1995
+
+  ## let dlyap do the error checking...
   m = dlyap(a,b*b');
 endfunction
diff --git a/scripts/control/dhinfdemo.m b/scripts/control/dhinfdemo.m
--- a/scripts/control/dhinfdemo.m
+++ b/scripts/control/dhinfdemo.m
@@ -1,68 +1,68 @@
-# Copyright (C) 1996,1998 Kai Mueller
-#
-# This file is part of Octave.
-#
-# Octave is free software; you can redistribute it and/or modify it
-# under the terms of the GNU General Public License as published by the
-# Free Software Foundation; either version 2, or (at your option) any
-# later version.
-#
-# Octave is distributed in the hope that it will be useful, but WITHOUT
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-# for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Octave; see the file COPYING.  If not, write to the Free
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
+## Copyright (C) 1996,1998 Kai Mueller
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
+##
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+## for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
-# ------------------------------------------------------------
-# dhinfdemo   Design of a discrete H_infinity controller.
-#             This is not a true discrete design. The design
-#             is carried out in continuous time while the
-#             effect of sampling is described by a bilinear
-#             transformation of the sampled system.
-#             This method works quite well if the sampling
-#             period is "small" compared to the plant time
-#             constants.
-#
-# This is a script file for OCTAVE.
-# ------------------------------------------------------------
-#
-# continuous plant:
-#	             1
-#	G(s) = --------------
-#	       (s + 2)(s + 1)
-#
-# discretised plant with ZOH (Sampling period = Ts = 1 second)
-#
-#	           0.39958z + 0.14700
-#	G(s) = --------------------------
-#	       (z - 0.36788)(z - 0.13533)
-#
-#	                         +----+
-#	    -------------------->| W1 |---> v1
-#	z   |                    +----+
-#	----|-------------+                   || T   ||     => min.
-#	    |             |                       vz   infty
-#	    |    +---+    v      +----+
-#	    *--->| G |--->O--*-->| W2 |---> v2
-#	    |    +---+       |   +----+
-#	    |                |
-#	    |    +---+       |
-#	    -----| K |<-------
-#	         +---+
-#
-#	W1 and W2 are the robustness and performancs weighting
-#       functions
+## ------------------------------------------------------------
+## dhinfdemo   Design of a discrete H_infinity controller.
+##             This is not a true discrete design. The design
+##             is carried out in continuous time while the
+##             effect of sampling is described by a bilinear
+##             transformation of the sampled system.
+##             This method works quite well if the sampling
+##             period is "small" compared to the plant time
+##             constants.
+##
+## This is a script file for OCTAVE.
+## ------------------------------------------------------------
+##
+## continuous plant:
+##	             1
+##	G(s) = --------------
+##	       (s + 2)(s + 1)
+##
+## discretised plant with ZOH (Sampling period = Ts = 1 second)
+##
+##	           0.39958z + 0.14700
+##	G(s) = --------------------------
+##	       (z - 0.36788)(z - 0.13533)
+##
+##	                         +----+
+##	    -------------------->| W1 |---> v1
+##	z   |                    +----+
+##	----|-------------+                   || T   ||     => min.
+##	    |             |                       vz   infty
+##	    |    +---+    v      +----+
+##	    *--->| G |--->O--*-->| W2 |---> v2
+##	    |    +---+       |   +----+
+##	    |                |
+##	    |    +---+       |
+##	    -----| K |<-------
+##	         +---+
+##
+##	W1 and W2 are the robustness and performancs weighting
+##       functions
 
-# K. Mueller, <mueller@ifr.ing.tu-bs.de>
-# Technical University of Braunschweig, IfR
+## K. Mueller, <mueller@ifr.ing.tu-bs.de>
+## Technical University of Braunschweig, IfR
 
 echo off
 disp(" ");
 disp("    --------------------------------------------------");
 disp("    Discrete H_infinity optimal control for the plant:");
 disp(" ");
 disp("	                   0.39958z + 0.14700");
 disp("	        G(s) = --------------------------");
@@ -77,31 +77,31 @@ eval(cmd);
 disp("weighting on actuator value u");
 cmd = "W1 = wgt1o(0.1, 200.0, 50.0);";
 disp(cmd);
 eval(cmd);
 disp("weighting on controlled variable y");
 cmd = "W2 = wgt1o(350.0, 0.05, 0.0002);";
 disp(cmd);
 eval(cmd);
-# omega axis (column vector)
+## omega axis (column vector)
 ww = vec(logspace(-4.99, 3.99, 100));
 
 disp("Create ZOH equivalent model of a continuous plant");
 cmd = "G = tf2sys(2,[1 3 2]);  Gd = c2d(G, Ts);";
 run_cmd
 
-# w-plane (continuous representation of the sampled system)
+## w-plane (continuous representation of the sampled system)
 disp("W-plane transform of discrete time system:");
 cmd = "Gw = d2c(Gd, \"bi\");";
 run_cmd
 
 disp(" ");
 disp(" o building P...");
-# need One as the pseudo transfer function One = 1
+## need One as the pseudo transfer function One = 1
 cmd = "One = ugain(1);";
 disp(cmd);
 eval(cmd);
 cmd = " psys = buildssic([1 4;2 4;3 1],[3],[2 3 5],[3 4],Gw,W1,W2,One);";
 run_cmd;
 disp(" o controller design...");
 cmd = "[K, gfin, GWC] = hinfsyn(psys, 1, 1, 0.1, 10.0, 0.02);";
 run_cmd
@@ -135,9 +135,9 @@ yn = input(" * Plot closed loop step res
 if (length(yn) >= 1)
   if ((yn(1) == "y") || (yn(1) == 'Y'))
     disp(" o step responses of T and KS...");
     figure(fig_n)
     step(GG, 1, 10);
   endif
 endif
 
-# --------- End of dhinfdemo/kpm
+## --------- End of dhinfdemo/kpm
diff --git a/scripts/control/dlqe.m b/scripts/control/dlqe.m
--- a/scripts/control/dlqe.m
+++ b/scripts/control/dlqe.m
@@ -1,25 +1,25 @@
-# Copyright (C) 1993, 1994, 1995 Auburn University.  All Rights Reserved.
-# 
-# This file is part of Octave.
-# 
-# Octave is free software; you can redistribute it and/or modify it
-# under the terms of the GNU General Public License as published by the
-# Free Software Foundation; either version 2, or (at your option) any
-# later version.
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License
-# along with Octave; see the file COPYING.  If not, write to the Free
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
+## Copyright (C) 1993, 1994, 1995 Auburn University.  All Rights Reserved.
+## 
+## This file is part of Octave.
+## 
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{l}, @var{m}, @var{p}, @var{e}] =} dlqe (@var{a}, @var{g}, @var{c}, @var{sigw}, @var{sigv}, @var{z})
 ## Construct the linear quadratic estimator (Kalman filter) for the
 ## discrete time system
 ## @iftex
 ## @tex
 ## $$
@@ -91,25 +91,25 @@
 ## @end iftex
 ## @ifinfo
 ## (@var{a} - @var{a}@var{l}@var{c}).
 ## @end ifinfo
 ## @end table
 ## @end deftypefn
 
 function [l, m, p, e] = dlqe (a, g, c, sigw, sigv, s)
-# Written by A. S. Hodel (scotte@eng.auburn.edu) August, 1993.
-# Modified for discrete time by R. Bruce Tenison (btenison@eng.auburn.edu)
-# October, 1993
+## Written by A. S. Hodel (scotte@eng.auburn.edu) August, 1993.
+## Modified for discrete time by R. Bruce Tenison (btenison@eng.auburn.edu)
+## October, 1993
 
   if (nargin != 5 && nargin != 6)
     error ("dlqe: invalid number of arguments");
   endif
 
-# The problem is dual to the regulator design, so transform to dlqr call.
+## The problem is dual to the regulator design, so transform to dlqr call.
 
   if (nargin == 5)
     [k, p, e] = dlqr (a', c', g*sigw*g', sigv);
     m = p;
     l = k';
   else
     [k, p, e] = dlqr (a', c', g*sigw*g', sigv, g*s);
     m = p;
diff --git a/scripts/control/dlqg.m b/scripts/control/dlqg.m
--- a/scripts/control/dlqg.m
+++ b/scripts/control/dlqg.m
@@ -1,124 +1,123 @@
-# Copyright (C) 1996 Auburn University.  All Rights Reserved
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1996 Auburn University.  All Rights Reserved
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
  
+##  O B S O L E T E * * * D O   N O T   U S E!
+##
+##  Use lqg instead.
+##
+## function [K,Q,P,Ee,Er] = dlqg(A,B,C,G,Sigw,Sigv,Q,R)
+## function [K,Q,P,Ee,Er] = dlqg(Sys,Sigw,Sigv,Q,R)
+## 
+## design a discrete-time linear quadratic gaussian optimal controller
+## for the system
+##
+##  x(k+1) = A x(k) + B u(k) + G w(k)       [w]=N(0,[Sigw 0    ])
+##    y(k) = C x(k) + v(k)                  [v]  (    0   Sigv ])
+##
+## Outputs:
+##    K: system data structure format LQG optimal controller
+##    P: Solution of control (state feedback) algebraic Riccati equation
+##    Q: Solution of estimation algebraic Riccati equation
+##    Ee: estimator poles
+##    Es: controller poles
+## inputs:
+##  A,B,C,G, or Sys: state space representation of system.  
+##  Sigw, Sigv: covariance matrices of independent Gaussian noise processes 
+##      (as above)
+##  Q, R: state, control weighting matrices for dlqr call respectively.  
+##
+## See also: lqg, dlqe, dlqr
+
 function [K,Q,P,Ee,Er] = dlqg(A,B,C,G,Sigw, Sigv,Q,R)
-#
-#
-#  O B S O L E T E * * * D O   N O T   U S E!
-#
-#  Use lqg instead.
-#
-# function [K,Q,P,Ee,Er] = dlqg(A,B,C,G,Sigw,Sigv,Q,R)
-# function [K,Q,P,Ee,Er] = dlqg(Sys,Sigw,Sigv,Q,R)
-# 
-# design a discrete-time linear quadratic gaussian optimal controller
-# for the system
-#
-#  x(k+1) = A x(k) + B u(k) + G w(k)       [w]=N(0,[Sigw 0    ])
-#    y(k) = C x(k) + v(k)                  [v]  (    0   Sigv ])
-#
-# Outputs:
-#    K: system data structure format LQG optimal controller
-#    P: Solution of control (state feedback) algebraic Riccati equation
-#    Q: Solution of estimation algebraic Riccati equation
-#    Ee: estimator poles
-#    Es: controller poles
-# inputs:
-#  A,B,C,G, or Sys: state space representation of system.  
-#  Sigw, Sigv: covariance matrices of independent Gaussian noise processes 
-#      (as above)
-#  Q, R: state, control weighting matrices for dlqr call respectively.  
-#
-# See also: lqg, dlqe, dlqr
+
+  ## Written by A. S. Hodel August 1995
+
+  warning("dlqg: obsolete. use lqg instead (system data structure format)");
+
+  if (nargin == 5)
+    ## system data structure format
+
+    ## check that it really is system data structure
+    if(! is_struct(A) )
+      error("dlqg: 5 arguments, first argument is not a system data structure structure")
+    endif
+
+    sys = sysupdate(sys,"ss");    # make sure in proper form
+    [ncstates,ndstates,nin,nout] = sysdimensions(sys);
+    if(ndstates == -1)
+      error("this message should never appear: bad system dimensions");
+    endif
 
-# Written by A. S. Hodel August 1995
-
-warning("dlqg: obsolete. use lqg instead (system data structure format)");
+    if(ncstates)
+      error("dlqg: system has continuous-time states (try lqg?)")
+    elseif(ndstates < 1)
+      error("dlqg: system has no discrete time states")
+    elseif(nin <= columns(Sigw))
+      error(["dlqg: ",num2str(nin)," inputs provided, noise dimension is ", ...
+	  num2str(columns(Sigw))])
+    elseif(nout != columns(Sigv))
+      error(["dlqg: number of outputs (",num2str(nout),") incompatible with ", ...
+	  "dimension of Sigv (",num2str(columns(Sigv)),")"])
+    endif
 
-if (nargin == 5)
-  # system data structure format
-  
-  # check that it really is system data structure
-  if(! is_struct(A) )
-    error("dlqg: 5 arguments, first argument is not a system data structure structure")
+    ## put parameters into correct variables
+    R = Sigw;
+    Q = G;
+    Sigv = C;
+    Sigw = B;
+    [A,B,C,D] = sys2ss(Sys)
+    [n,m] = size(B)
+    m1 = columns(Sigw);
+    m2 = m1+1;
+    G = B(:,1:m1);
+    B = B(:,m2:m);
+
+  elseif (nargin == 8)
+    ## state-space format
+    m = columns(B);
+    m1 = columns(G);
+    p = rows(C);
+    n = abcddim(A,B,C,zeros(p,m));
+    n1 = abcddim(A,G,C,zeros(p,m1));
+    if( (n == -1) || (n1 == -1))
+      error("dlqg: A,B,C,G incompatibly dimensioned");
+    elseif(p != columns(Sigv))
+      error("dlqg: C, Sigv incompatibly dimensioned");
+    elseif(m1 != columns(Sigw))
+      error("dlqg: G, Sigw incompatibly dimensioned");
+    endif
+  else
+    error("dlqg: illegal number of arguments")
   endif
 
-  sys = sysupdate(sys,"ss");    # make sure in proper form
-  [ncstates,ndstates,nin,nout] = sysdimensions(sys);
-  if(ndstates == -1)
-    error("this message should never appear: bad system dimensions");
-  endif
-
-  if(ncstates)
-    error("dlqg: system has continuous-time states (try lqg?)")
-  elseif(ndstates < 1)
-    error("dlqg: system has no discrete time states")
-  elseif(nin <= columns(Sigw))
-    error(["dlqg: ",num2str(nin)," inputs provided, noise dimension is ", ...
-	num2str(columns(Sigw))])
-  elseif(nout != columns(Sigv))
-    error(["dlqg: number of outputs (",num2str(nout),") incompatible with ", ...
-	"dimension of Sigv (",num2str(columns(Sigv)),")"])
+  if (! (is_square(Sigw) && is_square(Sigv) ) )
+    error("dlqg: Sigw, Sigv must be square");
   endif
 
-  # put parameters into correct variables
-  R = Sigw;
-  Q = G;
-  Sigv = C;
-  Sigw = B;
-  [A,B,C,D] = sys2ss(Sys)
-  [n,m] = size(B)
-  m1 = columns(Sigw);
-  m2 = m1+1;
-  G = B(:,1:m1);
-  B = B(:,m2:m);
-
-elseif (nargin == 8)
-  # state-space format
-  m = columns(B);
-  m1 = columns(G);
-  p = rows(C);
-  n = abcddim(A,B,C,zeros(p,m));
-  n1 = abcddim(A,G,C,zeros(p,m1));
-  if( (n == -1) || (n1 == -1))
-    error("dlqg: A,B,C,G incompatibly dimensioned");
-  elseif(p != columns(Sigv))
-    error("dlqg: C, Sigv incompatibly dimensioned");
-  elseif(m1 != columns(Sigw))
-    error("dlqg: G, Sigw incompatibly dimensioned");
-  endif
-else
-  error("dlqg: illegal number of arguments")
-endif
-
-if (! (is_square(Sigw) && is_square(Sigv) ) )
-  error("dlqg: Sigw, Sigv must be square");
-endif
-
-# now we can just do the design; call dlqr and dlqe, since all matrices
-# are not given in Cholesky factor form (as in h2syn case)
-[Ks, P, Er] = dlqr(A,B,Q,R);
-[Ke, Q, jnk, Ee] = dlqe(A,G,C,Sigw,Sigv);
-Ac = A - Ke*C - B*Ks;
-Bc = Ke;
-Cc = -Ks;
-Dc = zeros(rows(Cc),columns(Bc));
-K = ss2sys(Ac,Bc,Cc,Dc,1);
-disp("HODEL: need to add names to this guy!")
+  ## now we can just do the design; call dlqr and dlqe, since all matrices
+  ## are not given in Cholesky factor form (as in h2syn case)
+  [Ks, P, Er] = dlqr(A,B,Q,R);
+  [Ke, Q, jnk, Ee] = dlqe(A,G,C,Sigw,Sigv);
+  Ac = A - Ke*C - B*Ks;
+  Bc = Ke;
+  Cc = -Ks;
+  Dc = zeros(rows(Cc),columns(Bc));
+  K = ss2sys(Ac,Bc,Cc,Dc,1);
+  disp("HODEL: need to add names to this guy!")
 
 endfunction
diff --git a/scripts/control/dlqr.m b/scripts/control/dlqr.m
--- a/scripts/control/dlqr.m
+++ b/scripts/control/dlqr.m
@@ -1,25 +1,25 @@
-# Copyright (C) 1993, 1994, 1995 Auburn University.  All Rights Reserved.
-# 
-# This file is part of Octave.
-# 
-# Octave is free software; you can redistribute it and/or modify it
-# under the terms of the GNU General Public License as published by the
-# Free Software Foundation; either version 2, or (at your option) any
-# later version.
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License
-# along with Octave; see the file COPYING.  If not, write to the Free
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
+## Copyright (C) 1993, 1994, 1995 Auburn University.  All Rights Reserved.
+## 
+## This file is part of Octave.
+## 
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{k}, @var{p}, @var{e}] =} dlqr (@var{a}, @var{b}, @var{q}, @var{r}, @var{z})
 ## Construct the linear quadratic regulator for the discrete time system
 ## @iftex
 ## @tex
 ## $$
 ##  x_{k+1} = A x_k + B u_k
@@ -100,64 +100,64 @@
 ## @item Anderson and Moore, Optimal Control: Linear Quadratic Methods,
 ##      Prentice-Hall, 1990, pp. 56-58
 ## @item  Kuo, Digital Control Systems, Harcourt Brace Jovanovich, 1992, 
 ##      section 11-5-2.
 ## @end enumerate
 ## @end deftypefn
 
 function [k, p, e] = dlqr (a, b, q, r, s)
-# Written by A. S. Hodel (scotte@eng.auburn.edu) August 1993.
-# Converted to discrete time by R. B. Tenison
-# (btenison@eng.auburn.edu) October 1993
+## Written by A. S. Hodel (scotte@eng.auburn.edu) August 1993.
+## Converted to discrete time by R. B. Tenison
+## (btenison@eng.auburn.edu) October 1993
 
   if (nargin != 4 && nargin != 5)
     error ("dlqr: invalid number of arguments");
   endif
 
-# Check a.
+## Check a.
   if ((n = is_square (a)) == 0)
     error ("dlqr: requires 1st parameter(a) to be square");
   endif
 
-# Check b.
+## Check b.
   [n1, m] = size (b);
   if (n1 != n)
     error ("dlqr: a,b not conformal");
   endif
 
-# Check q.
+## Check q.
   
   if ((n1 = is_square (q)) == 0 || n1 != n)
     error ("dlqr: q must be square and conformal with a");
   endif
 
-# Check r.
+## Check r.
   if((m1 = is_square(r)) == 0 || m1 != m)
     error ("dlqr: r must be square and conformal with column dimension of b");
   endif
 
-# Check if n is there.
+## Check if n is there.
   if (nargin == 5)
     [n1, m1] = size (s);
     if (n1 != n || m1 != m)
       error ("dlqr: z must be identically dimensioned with b");
     endif
 
-# Incorporate cross term into a and q.
+## Incorporate cross term into a and q.
 
     ao = a - (b/r)*s';
     qo = q - (s/r)*s';
   else
     s = zeros (n, m);
     ao = a;
     qo = q;
   endif
 
-# Check that q, (r) are symmetric, positive (semi)definite
+## Check that q, (r) are symmetric, positive (semi)definite
 
   if (is_symmetric (q) && is_symmetric (r) ...
       && all (eig (q) >= 0) && all (eig (r) > 0))
     p = dare (ao, b, qo, r);
     k = (r+b'*p*b)\b'*p*a + r\s';
     e = eig (a - b*k);
   else
     error ("dlqr: q (r) must be symmetric positive (semi) definite");
diff --git a/scripts/control/dlyap.m b/scripts/control/dlyap.m
--- a/scripts/control/dlyap.m
+++ b/scripts/control/dlyap.m
@@ -1,25 +1,25 @@
-# Copyright (C) 1993, 1994, 1995 Auburn University.  All Rights Reserved.
-# 
-# This file is part of Octave.
-# 
-# Octave is free software; you can redistribute it and/or modify it
-# under the terms of the GNU General Public License as published by the
-# Free Software Foundation; either version 2, or (at your option) any
-# later version.
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License
-# along with Octave; see the file COPYING.  If not, write to the Free
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
+## Copyright (C) 1993, 1994, 1995 Auburn University.  All Rights Reserved.
+## 
+## This file is part of Octave.
+## 
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{x} = } dlyap (@var{a}, @var{b})
 ## Solve the discrete-time Lyapunov equation
 ## 
 ##   @strong{Inputs}
 ##   @table @var
 ##     @item a
@@ -56,17 +56,18 @@
 ## Column-by-column solution method as suggested in
 ##   Hammarling, @cite{Numerical Solution of the Stable, Non-Negative
 ##   Definite Lyapunov Equation}, IMA Journal of Numerical Analysis, Volume
 ##   2, pages 303--323 (1982).
 ## 
 ## @end deftypefn
  
 function x = dlyap (a, b)
-# Written by A. S. Hodel (scotte@eng.auburn.edu) August 1993.
+
+  ## Written by A. S. Hodel (scotte@eng.auburn.edu) August 1993.
 
   if ((n = is_square (a)) == 0)
     warning ("dlyap: a must be square");
   endif
 
   if ((m = is_square (b)) == 0)
     [n1, m] = size (b);
     if (n1 == n)
@@ -77,26 +78,26 @@ function x = dlyap (a, b)
       a = a';
     endif
   endif
 
   if (n != m)
     warning ("dlyap: a,b not conformably dimensioned");
   endif
 
-  # Solve the equation column by column.
+  ## Solve the equation column by column.
 
   [u, s] = schur (a);
   b = u'*b*u;
 
   j = n;
   while (j > 0)
     j1 = j;
 
-# Check for Schur block.
+    ## Check for Schur block.
 
     if (j == 1)
       blksiz = 1;
     elseif (s (j, j-1) != 0)
       blksiz = 2;
       j = j - 1;
     else
       blksiz = 1;
@@ -117,13 +118,13 @@ function x = dlyap (a, b)
     if(blksiz == 2)
       x (:, j1) = v ((n+1):blksiz*n);
     endif
 
     j = j - 1;
 
   endwhile
 
-# Back-transform to original coordinates.
+  ## Back-transform to original coordinates.
 
   x = u*x*u';
 
 endfunction
diff --git a/scripts/control/dmr2d.m b/scripts/control/dmr2d.m
--- a/scripts/control/dmr2d.m
+++ b/scripts/control/dmr2d.m
@@ -1,25 +1,25 @@
-# Copyright (C) 1998 Auburn University.  All Rights Reserved
-# 
-# This file is part of Octave.
-# 
-# Octave is free software; you can redistribute it and/or modify it
-# under the terms of the GNU General Public License as published by the
-# Free Software Foundation; either version 2, or (at your option) any
-# later version.
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License
-# along with Octave; see the file COPYING.  If not, write to the Free
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
+## Copyright (C) 1998 Auburn University.  All Rights Reserved
+## 
+## This file is part of Octave.
+## 
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File } {[@var{dsys}, @var{fidx}] =} dmr2d (@var{sys}, @var{idx}, @var{sprefix}, @var{Ts2} @{,@var{cuflg}@})
 ##  convert a multirate digital system to a single rate digital system
 ##  states specified by @var{idx}, @var{sprefix} are sampled at @var{Ts2}, all 
 ##   others are assumed sampled at @var{Ts1} = @code{sysgettsam(@var{sys})}.
 ## 
 ## @strong{Inputs}
@@ -66,22 +66,23 @@
 ## these states are updated to the new (slower) sampling interval @var{Ts2}.
 ## @end table
 ## 
 ## @strong{WARNING} Not thoroughly tested yet; especially when @var{cuflg} == 0.
 ## 
 ## @end deftypefn
 
 function [dsys,fidx] = dmr2d (sys, idx, sprefix, Ts2,cuflg)
-# Adapted from c2d by a.s.hodel@eng.auburn.edu
+
+  ## Adapted from c2d by a.s.hodel@eng.auburn.edu
 
   save_val = implicit_str_to_num_ok;	# save for later
   implicit_str_to_num_ok = 1;
 
-  # parse input arguments
+  ## parse input arguments
   if(nargin != 4 | nargout > 2)
     usage("[dsys,fidx] = dmr2d (sys, idx, sprefix, Ts2 {,cuflg})");
 
   elseif (!is_struct(sys))
     error("sys must be in system data structure form");
 
   elseif(!is_digital(sys))
     error("sys must be discrete-time; continuous time passed");
@@ -99,29 +100,29 @@ function [dsys,fidx] = dmr2d (sys, idx, 
   elseif(!(is_signal_list(sprefix) | isempty(sprefix)))
     error("sprefix must be a signal list (see is_signal_list) or empty");
 
   elseif(!is_sample(Ts2))
     error(["Ts2=",num2str(Ts2),"; invalid sampling time"]);
 
   endif
 
-  # optional argument: cuflg
+  ## optional argument: cuflg
   if(nargin <= 4)
     cuflg = 1;		# default: constant inputs over Ts2 sampling interv.
   elseif( !is_scalar(cuflg) )
     error("cuflg must be a scalar")
   elseif( cuflg != 0 | cuflg != 1)
     error(["cuflg = ",num2str(cuflg),", should be 0 or 1"]);
   endif
 
-  # extract  state space information
+  ## extract  state space information
   [da,db,dc,dd,Ts1,nc,nz,stname,inname,outname,yd] = sys2ss(sys);
 
-  # compute number of steps
+  ## compute number of steps
   if(Ts1 > Ts2)
     error(["Current sampling time=",num2str(Ts1),"< Ts2=",num2str(Ts2)]);
   endif
   nstp = floor(Ts2/Ts1+0.5);
   if(abs((Ts2 - Ts1*nstp)/Ts1) > 1e-12)
     warning(["dmr2d: Ts1=",num2str(Ts1),", Ts2=",num2str(Ts2), ...
       ", selecting nsteps=",num2str(nstp),"; mismatch"]);
   endif
@@ -130,136 +131,133 @@ function [dsys,fidx] = dmr2d (sys, idx, 
     warning("both sprefix and idx are empty; returning dsys=sys");
     fidx = [];
     dsys = sys;
     return
   elseif(isempty(sprefix))
     fidx = idx;
   else
     fidx = reshape(idx,1,length(idx));
-    # find states whose name begins with any strings in sprefix.
+    ## find states whose name begins with any strings in sprefix.
     ns = length(sprefix);
     for kk=1:ns
       spk = nth(sprefix,kk);  # get next prefix and length
       spl = length(spk);
 
-      # check each state name
+      ## check each state name
       for ii=1:nz
         sti = nth(stname,ii);  # compare spk with this state name
         if(length(sti) >= spl)
-          # if the prefix matches and ii isn't already in the list, add ii
+          ## if the prefix matches and ii isn't already in the list, add ii
           if(strcmp(sti(1:spl),spk) & !any(fidx == ii) ) 
             fidx = sort([fidx,ii]);
           endif
         endif
       endfor
     endfor
   endif
 
   if(nstp == 0)
     warning("dmr2d: nstp = 0; setting tsam and returning");
     dsys = syschtsam(sys,Ts2);
     return
   elseif(nstp < 0)
     error(["nstp = ", num2str(nstp)," < 0; this shouldn't be!"]);
   endif
 
-  # permute system matrices
+  ## permute system matrices
   pv = sysreorder(nz,fidx);
   pv = pv(nz:-1:1);          # reverse order to put fast modes in leading block
 
-  # construct inverse permutation
+  ## construct inverse permutation
   Inz = eye(nz);
   pvi = (Inz(pv,:)'*[1:nz]')';
 
-  # permute A, B (stname permuted for debugging only)
+  ## permute A, B (stname permuted for debugging only)
   da = da(pv,pv);
   db = db(pv,:);
   stname = stname(pv,:);
 
-  # partition A, B:
+  ## partition A, B:
   lfidx = length(fidx);
   bki = 1:lfidx;
   a11 = da(bki,bki);
   b1 = db(bki,:);
 
   if(lfidx < nz)
     lfidx1 = lfidx+1;
     bki2 = (lfidx1):nz;
     a12 = da(bki,bki2);
     b2 = db(bki2,:);
   else
     warning("dmr2d: converting entire A,B matrices to new sampling rate");
     lfidx1 = -1;
     bki2 = [];
   endif
 
-  #####################################
-  # begin system conversion: nstp steps
-  #####################################
+  ## begin system conversion: nstp steps
 
-  # compute abar_{n-1}*a12 and appropriate b matrix stuff
+  ## compute abar_{n-1}*a12 and appropriate b matrix stuff
   a12b = a12;      # running  total of abar_{n-1}*a12
   a12w = a12;      # current a11^n*a12  (start with n = 0)
   if(cuflg)
     b1b = b1;
     b1w = b1;
   else
-    # cuflg == 0, need to keep track of intersample inputs too
+    ## cuflg == 0, need to keep track of intersample inputs too
     nzdx = find(max(abs(b1)) != 0);  # FIXME: check tolerance relative to ||b1||
     b1w = b1(nzdx);
     innamenz = inname(nzdx);
     b1b = b1;                        # initial b1 must match columns in b2
   endif
 
-  ######################################
-  # compute a11h = a11^nstp by squaring
+  ## compute a11h = a11^nstp by squaring
   a11h = eye(size(a11));
   p2 = 1;
   a11p2 = a11;        #a11^p2
 
   nstpw = nstp;       # workspace for computing a11^nstp
   while(nstpw > 0.5)
     oddv = rem(nstpw,2);
     if(oddv)
       a11h = a11h*a11p2;
     endif
     nstpw = (nstpw-oddv)/2;
     if(nstpw > 0.5)
       a11p2 = a11p2*a11p2;    # a11^(next power of 2)
     endif
   endwhile
   
-  # FIXME: this part should probably also use squaring, but
-  # that would require exponentially growing memory.  What do do?
+  ## FIXME: this part should probably also use squaring, but
+  ## that would require exponentially growing memory.  What do do?
   for kk=2:nstp
-    # update a12 block to sum(a12 + ... + a11^(kk-1)*a12)
+    ## update a12 block to sum(a12 + ... + a11^(kk-1)*a12)
     a12w = a11*a12w;
     a12b = a12b + a12w;
 
-    # similar for b1 block (checking for cuflg first!)
+    ## similar for b1 block (checking for cuflg first!)
     b1w = a11*b1w;
     if(cuflg)
       b1b = b1b + b1w;        # update b1 block just like we did a12
     else
       b1b = [b1b, b1w];       # append new inputs
       newin = strappend(innamenz,["_d",num2str(kk-1)]);
       inname = append(inname,newin);
     endif
   endfor
 
-  # reconstruct system and return
+  ## reconstruct system and return
   da(bki,bki) = a11h;
   db(bki,1:columns(b1b)) = b1b;
   if(!isempty(bki2))
     da(bki,bki2) = a12b;
   endif
 
   da = da(pvi,pvi);
   db = db(pvi,:);
   stname = stname(pvi,:);
 
-  # construct new system and return
+  ## construct new system and return
   dsys = ss2sys(da,db,dc,dd,Ts2,0,nz,stname,inname,outname,find(yd == 1));
 
   implicit_str_to_num_ok = save_val;	# restore value
 
 endfunction
diff --git a/scripts/control/dre.m b/scripts/control/dre.m
--- a/scripts/control/dre.m
+++ b/scripts/control/dre.m
@@ -1,126 +1,125 @@
-# Copyright (C) 1998 Auburn University.  All Rights Reserved
-#
-# This file is part of Octave.
-#
-# Octave is free software; you can redistribute it and/or modify it
-# under the terms of the GNU General Public License as published by the
-# Free Software Foundation; either version 2, or (at your option) any
-# later version.
-#
-# Octave is distributed in the hope that it will be useful, but WITHOUT
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-# for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Octave; see the file COPYING.  If not, write to the Free
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
+## Copyright (C) 1998 Auburn University.  All Rights Reserved
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
+##
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+## for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
+
+## [tvals,Plist] = dre(sys,Q,R,Qf,t0,tf{,Ptol,maxits});
+## Solve the differential Riccati equation
+##   -d P/dt = A'P + P A - P B inv(R) B' P + Q
+##   P(tf) = Qf
+## for the LTI system sys.  Solution of standard LTI
+## state feedback optimization
+##   min \int_{t_0}^{t_f} x' Q x + u' R u dt + x(t_f)' Qf x(t_f)
+## optimal input is
+##   u = - inv(R) B' P(t) x
+## inputs:
+##   sys: continuous time system data structure
+##   Q: state integral penalty
+##   R: input integral penalty
+##   Qf: state terminal penalty
+##   t0,tf: limits on the integral
+##   Ptol: tolerance (used to select time samples; see below); default = 0.1
+##   max number of refinement iterations (default=10)
+## outputs:
+##   tvals: time values at which P(t) is computed
+##   Plist: list values of P(t); nth(Plist,ii) is P(tvals(ii)).
+##
+##   tvals is selected so that || nth(Plist,ii) - nth(Plist,ii-1) || < Ptol
+##     for ii=2:length(tvals)
 
 function [tvals,Plist] = dre(sys,Q,R,Qf,t0,tf,Ptol,maxits)
-# [tvals,Plist] = dre(sys,Q,R,Qf,t0,tf{,Ptol,maxits});
-# Solve the differential Riccati equation
-#   -d P/dt = A'P + P A - P B inv(R) B' P + Q
-#   P(tf) = Qf
-# for the LTI system sys.  Solution of standard LTI
-# state feedback optimization
-#   min \int_{t_0}^{t_f} x' Q x + u' R u dt + x(t_f)' Qf x(t_f)
-# optimal input is
-#   u = - inv(R) B' P(t) x
-# inputs:
-#   sys: continuous time system data structure
-#   Q: state integral penalty
-#   R: input integral penalty
-#   Qf: state terminal penalty
-#   t0,tf: limits on the integral
-#   Ptol: tolerance (used to select time samples; see below); default = 0.1
-#   max number of refinement iterations (default=10)
-# outputs:
-#   tvals: time values at which P(t) is computed
-#   Plist: list values of P(t); nth(Plist,ii) is P(tvals(ii)).
-#
-#   tvals is selected so that || nth(Plist,ii) - nth(Plist,ii-1) || < Ptol
-#     for ii=2:length(tvals)
-#
-# Reference:
+
+  if(nargin < 6 | nargin > 8 | nargout != 2)
+    usage("[tvals,Plist] = dre(sys,Q,R,Qf,t0,tf{,Ptol})");
+  elseif(!is_struct(sys))
+    error("sys must be a system data structure")
+  elseif(is_digital(sys))
+    error("sys must be a continuous time system")
+  elseif(!is_matrix(Q) | !is_matrix(R) | !is_matrix(Qf))
+    error("Q, R, and Qf must be matrices.");
+  elseif(!is_scalar(t0) | !is_scalar(tf))
+    error("t0 and tf must be scalars")
+  elseif(t0 >= tf)		error("t0=%e >= tf=%e",t0,tf);
+  elseif(nargin == 6)		Ptol = 0.1;
+  elseif(!is_scalar(Ptol))	error("Ptol must be a scalar");
+  elseif(Ptol <= 0)		error("Ptol must be positive");
+  endif
 
-if(nargin < 6 | nargin > 8 | nargout != 2)
-  usage("[tvals,Plist] = dre(sys,Q,R,Qf,t0,tf{,Ptol})");
-elseif(!is_struct(sys))
-  error("sys must be a system data structure")
-elseif(is_digital(sys))
-  error("sys must be a continuous time system")
-elseif(!is_matrix(Q) | !is_matrix(R) | !is_matrix(Qf))
-  error("Q, R, and Qf must be matrices.");
-elseif(!is_scalar(t0) | !is_scalar(tf))
-  error("t0 and tf must be scalars")
-elseif(t0 >= tf)		error("t0=%e >= tf=%e",t0,tf);
-elseif(nargin == 6)		Ptol = 0.1;
-elseif(!is_scalar(Ptol))	error("Ptol must be a scalar");
-elseif(Ptol <= 0)		error("Ptol must be positive");
-endif
+  if(nargin < 8) maxits = 10;
+  elseif(!is_scalar(maxits))	error("maxits must be a scalar");
+  elseif(maxits <= 0)		error("maxits must be positive");
+  endif
+  maxits = ceil(maxits);
+
+  [aa,bb] = sys2ss(sys);
+  nn = sysdimensions(sys,"cst");
+  mm = sysdimensions(sys,"in");
+  pp = sysdimensions(sys,"out");
 
-if(nargin < 8) maxits = 10;
-elseif(!is_scalar(maxits))	error("maxits must be a scalar");
-elseif(maxits <= 0)		error("maxits must be positive");
-endif
-maxits = ceil(maxits);
+  if(size(Q) != [nn, nn])
+    error("Q(%dx%d); sys has %d states",rows(Q),columns(Q),nn);
+  elseif(size(Qf) != [nn, nn])
+    error("Qf(%dx%d); sys has %d states",rows(Qf),columns(Qf),nn);
+  elseif(size(R) != [mm, mm])
+    error("R(%dx%d); sys has %d inputs",rows(R),columns(R),mm);
+  endif
 
-[aa,bb] = sys2ss(sys);
-nn = sysdimensions(sys,"cst");
-mm = sysdimensions(sys,"in");
-pp = sysdimensions(sys,"out");
+  ## construct Hamiltonian matrix
+  H = [aa , -(bb/R)*bb' ; -Q, -aa'];
 
-if(size(Q) != [nn, nn])
-  error("Q(%dx%d); sys has %d states",rows(Q),columns(Q),nn);
-elseif(size(Qf) != [nn, nn])
-  error("Qf(%dx%d); sys has %d states",rows(Qf),columns(Qf),nn);
-elseif(size(R) != [mm, mm])
-  error("R(%dx%d); sys has %d inputs",rows(R),columns(R),mm);
-endif
-
-# construct Hamiltonian matrix
-H = [aa , -(bb/R)*bb' ; -Q, -aa'];
+  ## select time step to avoid numerical overflow
+  fast_eig = max(abs(eig(H)));
+  tc = log(10)/fast_eig;
+  nst = ceil((tf-t0)/tc);
+  tvals = -linspace(-tf,-t0,nst);
+  Plist = list(Qf);
+  In = eye(nn);
+  n1 = nn+1;
+  n2 = nn+nn;
+  done = 0;
+  while(!done)
+    done = 1;      # assume this pass will do the job
+    ## sort time values in reverse order
+    tvals = -sort(-tvals);
+    tvlen = length(tvals);
+    maxerr = 0;
+    ## compute new values of P(t); recompute old values just in case
+    for ii=2:tvlen
+      uv_i_minus_1 = [ In ; nth(Plist,ii-1) ];
+      delta_t = tvals(ii-1) - tvals(ii);
+      uv = expm(-H*delta_t)*uv_i_minus_1;
+      Qi = uv(n1:n2,1:nn)/uv(1:nn,1:nn);
+      Plist(ii) = (Qi+Qi')/2;
+      ## check error
+      Perr = norm(nth(Plist,ii) - nth(Plist,ii-1))/norm(nth(Plist,ii));
+      maxerr = max(maxerr,Perr);
+      if(Perr > Ptol)
+	new_t = mean(tvals([ii,ii-1]));
+	tvals = [tvals, new_t];
+	done = 0;
+      endif
+    endfor
 
-# select time step to avoid numerical overflow
-fast_eig = max(abs(eig(H)));
-tc = log(10)/fast_eig;
-nst = ceil((tf-t0)/tc);
-tvals = -linspace(-tf,-t0,nst);
-Plist = list(Qf);
-In = eye(nn);
-n1 = nn+1;
-n2 = nn+nn;
-done = 0;
-while(!done)
-  done = 1;      # assume this pass will do the job
-  # sort time values in reverse order
-  tvals = -sort(-tvals);
-  tvlen = length(tvals);
-  maxerr = 0;
-  # compute new values of P(t); recompute old values just in case
-  for ii=2:tvlen
-    uv_i_minus_1 = [ In ; nth(Plist,ii-1) ];
-    delta_t = tvals(ii-1) - tvals(ii);
-    uv = expm(-H*delta_t)*uv_i_minus_1;
-    Qi = uv(n1:n2,1:nn)/uv(1:nn,1:nn);
-    Plist(ii) = (Qi+Qi')/2;
-    # check error
-    Perr = norm(nth(Plist,ii) - nth(Plist,ii-1))/norm(nth(Plist,ii));
-    maxerr = max(maxerr,Perr);
-    if(Perr > Ptol)
-      new_t = mean(tvals([ii,ii-1]));
-      tvals = [tvals, new_t];
-      done = 0;
-    endif
-  endfor
-
-  # check number of iterations
-  maxits = maxits - 1;
-  done = done+(maxits==0);
-endwhile
-if(maxerr > Ptol)
-  warning("dre: \n\texiting with%4d points, max rel chg. =%e, Ptol=%e\n", ...
-	tvlen,maxerr,Ptol);
-  tvals = tvals(1:length(Plist));
-endif
+    ## check number of iterations
+    maxits = maxits - 1;
+    done = done+(maxits==0);
+  endwhile
+  if(maxerr > Ptol)
+    warning("dre: \n\texiting with%4d points, max rel chg. =%e, Ptol=%e\n", ...
+	  tvlen,maxerr,Ptol);
+    tvals = tvals(1:length(Plist));
+  endif
 endfunction
diff --git a/scripts/control/fir2sys.m b/scripts/control/fir2sys.m
--- a/scripts/control/fir2sys.m
+++ b/scripts/control/fir2sys.m
@@ -1,25 +1,25 @@
-# Copyright (C) 1996,1998 Auburn University.  All Rights Reserved
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1996,1998 Auburn University.  All Rights Reserved
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File } { @var{sys} =} fir2sys ( @var{num}@{, @var{tsam}, @var{inname}, @var{outname} @} )
 ##  construct a system data structure from FIR description
 ## 
 ## @strong{Inputs:}
 ## @table @var
 ## @item num
@@ -63,49 +63,39 @@
 ## transfer function form:
 ## 1*z^3 - 1*z^2 + 2*z^1 + 4
 ## -------------------------
 ## 1*z^3 + 0*z^2 + 0*z^1 + 0
 ## @end example
 ## @end deftypefn
  
 function sys = fir2sys (num,tsam,inname,outname)
-  #
-  # outsys = fir2sys(num,{tsam,inname,outname})
-  # construct a system data structure from FIR description
-  # inputs:
-  #   num: vector of coefficients [c0 c1 ... cn] of the SISO FIR transfer
-  #        function C(z) = c0 + c1*z^{-1} + c2*z^{-2} + ... + znz^{-n}
-  #   tsam: sampling time (default: 1)
-  #   inname: name of input signal 
-  #   outname: name of output signal
-  # outputs:  sys (system data structure)
-   
-  #  Written by R. Bruce Tenison  July 29, 1994
-  #  Name changed to TF2SYS July 1995
-  #  updated for new system data structure format July 1996
-  # adapted from tf2sys july 1996
+
+  ## Written by R. Bruce Tenison  July 29, 1994
+  ## Name changed to TF2SYS July 1995
+  ## updated for new system data structure format July 1996
+  ## adapted from tf2sys july 1996
 
   save_val = implicit_str_to_num_ok;
   implicit_str_to_num_ok = 1;
 
-  #  Test for the correct number of input arguments
+  ## Test for the correct number of input arguments
   if (nargin < 1 | nargin > 4)
     usage('sys=fir2sys(num[,tsam,inname,outname])');
   endif
 
-  # let tf2sys do the argument checking
+  ## let tf2sys do the argument checking
   den = [1,zeros(1,length(num)-1)];
 
-  # check sampling interval (if any)
+  ## check sampling interval (if any)
   if(nargin <= 1)               tsam = 1;		# default 
   elseif (isempty(tsam))        tsam = 1;		endif
 
-  #  Set name of input
+  ## Set name of input
   if(nargin < 3)  inname = sysdefioname(1,"u");        endif
 
-  #  Set name of output
+  ## Set name of output
   if(nargin < 4)  outname = sysdefioname(1,"y"); 	endif
 
   sys = tf2sys(num,den,tsam,inname,outname);
   
   implicit_str_to_num_ok = save_val;
 endfunction
diff --git a/scripts/control/frdemo.m b/scripts/control/frdemo.m
--- a/scripts/control/frdemo.m
+++ b/scripts/control/frdemo.m
@@ -1,36 +1,37 @@
-# Copyright (C) 1996,1998 Auburn University.  All Rights Reserved
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-#  
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1996,1998 Auburn University.  All Rights Reserved
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+##  
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
 
 ## -*- texinfo -*- 
 ## @deftypefn {Function File } { } frdemo ( ) 
 ## Octave Controls toolbox demo: Frequency Response demo
 ## @end deftypefn
 
 function frdemo()
-# Written by David Clem August 15, 1994 
+
+  ## Written by David Clem August 15, 1994 
 
-# a s hodel: updated to match new order of ss2zp outputs
-# J Ingram:  updated for system data structure format August 1996
+  ## a s hodel: updated to match new order of ss2zp outputs
+  ## J Ingram:  updated for system data structure format August 1996
 
   disp("")
   clc
   j = 0;
   while (j != 4)
     disp("");
     j = menu("Octave Controls Systems Toolbox Frequency Response Demo",...
              'Bode analysis (bode)',...
@@ -561,30 +562,30 @@ function frdemo()
           run_cmd
           prompt
 
 
           disp("")
           clc
           disp("MIMO SYSTEM:  Nyquist cannot be used for discrete MIMO systems");
           disp("at this time.");
-#	  cmd = "dsys_mimo = sysgroup(sys2,dsys3);";
-#          disp(cmd);
-#	  eval(cmd);
-#	  cmd = "sysout(dsys_mimo);";
-#	  disp(cmd);
-#	  eval(cmd);
-#	  disp("\nTo view the system's nyquist plot, execute the following command:\n")
-#      	  cmd = "nyquist(dsys_mimo);";
-#	  run_cmd; 	  
-#    	  prompt
-# 	  disp("\nTo view the nyquist plots for selected  channels, the command form changes:")
-#          cmd = "nyquist(dsys_mimo,[],1,1);";
-#	  run_cmd;
-#	  disp("\nNotice that this bode plot is the same as the plot from example 2.");         
+	  ## cmd = "dsys_mimo = sysgroup(sys2,dsys3);";
+	  ## disp(cmd);
+	  ## eval(cmd);
+	  ## cmd = "sysout(dsys_mimo);";
+	  ## disp(cmd);
+	  ## eval(cmd);
+	  ## disp("\nTo view the system's nyquist plot, execute the following command:\n")
+	  ## cmd = "nyquist(dsys_mimo);";
+	  ## run_cmd; 	  
+	  ## prompt
+	  ## disp("\nTo view the nyquist plots for selected  channels, the command form changes:")
+	  ## cmd = "nyquist(dsys_mimo,[],1,1);";
+	  ## run_cmd;
+	  ## disp("\nNotice that this bode plot is the same as the plot from example 2.");         
           prompt
           closeplot
 
                
         elseif( k2 == 3 )
           disp("\nMixed system nyquist analysis\n");
           disp("Nyquist exits with an error if it is passed a ""mixed"" system (one")
           disp("with both continuous and discrete states).  Use c2d or d2c to")
diff --git a/scripts/control/freqchkw.m b/scripts/control/freqchkw.m
--- a/scripts/control/freqchkw.m
+++ b/scripts/control/freqchkw.m
@@ -1,34 +1,35 @@
-# Copyright (C) 1996 Auburn University.  All Rights Reserved
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1996 Auburn University.  All Rights Reserved
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
  
 ## -*- texinfo -*-
 ## @deftypefn {Function File } { @var{retval} =} freqchkw ( @var{w} ) 
 ## Used by @code{freqresp} to check that input frequency vector @var{w} is legal.
 ## Returns boolean value.
 ## @end deftypefn
 
 function USEW = freqchkw(w)
-  # A S Hodel July 1996
+
+  ## A S Hodel July 1996
 
   if(isempty(w))
     USEW = 0;
   elseif(!is_vector(w))
     error(["w (",num2str(rows(w)),"x",num2str(columns(w)), ...
       "): must be [], a vector or a scalar"]);
   elseif( (max(abs(imag(w))) != 0) && (min(real(w)) <= 0) )
     error("w must have real positive entries");
diff --git a/scripts/control/freqresp.m b/scripts/control/freqresp.m
--- a/scripts/control/freqresp.m
+++ b/scripts/control/freqresp.m
@@ -1,25 +1,25 @@
-# Copyright (C) 1996,1998 Auburn University.  All Rights Reserved
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1996,1998 Auburn University.  All Rights Reserved
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
  
 ## -*- texinfo -*-
 ## @deftypefn {Function File } { @var{out} =} freqresp (@var{sys},@var{USEW}@{,@var{w}@});
 ##  Frequency response function - used internally by @code{bode}, @code{nyquist}.
 ##  minimal argument checking; "do not attempt to do this at home"
 ## 
 ## @strong{Inputs}
 ## @table @var
@@ -35,96 +35,97 @@
 ## @item @var{out} 
 ## vector of finite @math{G(j*w)} entries (or @math{||G(j*w)||} for MIMO)
 ## @item w 
 ## vector of corresponding frequencies 
 ## @end table
 ## @end deftypefn
 
 function [ff,w] = freqresp(sys,USEW,w);
-  #  Written by: R. Bruce Tenison July 11, 1994
-  # SYS_INTERNAL accesses members of system data structure
+
+  ## Written by: R. Bruce Tenison July 11, 1994
+  ## SYS_INTERNAL accesses members of system data structure
 
   save_val = empty_list_elements_ok;
   empty_list_elements_ok = 1;
 
-  # Check Args
+  ## Check Args
   if( (nargin < 2) || (nargin > 4) )
     usage ("[ff,w] = freqresp(sys,USEW{,w})");
   elseif( USEW & (nargin < 3) )
     error("USEW=1 but w was not passed.");
   elseif( USEW & isempty(w))
     warning("USEW=1 but w is empty; setting USEW=0");
     USEW=0;
   endif
 
   DIGITAL = is_digital(sys);
 
-  # compute default w if needed
+  ## compute default w if needed
   if(!USEW)
     if(is_siso(sys))
       sys = sysupdate(sys,"zp");
       [zer,pol] = sys2zp(sys);
     else
       zer = tzero(sys);
       pol = eig(sys2ss(sys));
     endif
 
-    # get default frequency range
+    ## get default frequency range
     [wmin,wmax] = bode_bounds(zer,pol,DIGITAL,sysgettsam(sys));
     w = logspace(wmin,wmax,50);
   else
     w = reshape(w,1,length(w)); 	# make sure it's a row vector
   endif
 
-  # now get complex values of s or z
+  ## now get complex values of s or z
   if(DIGITAL)
     jw = exp(i*w*sysgettsam(sys));
   else
     jw = i*w;
   endif
 
   [nn,nz,mm,pp] = sysdimensions(sys);
 
-  # now compute the frequency response - divide by zero yields a warning
+  ## now compute the frequency response - divide by zero yields a warning
   if (strcmp(sysgettype(sys),"zp"))
-    # zero-pole form (preferred)
+    ## zero-pole form (preferred)
     [zer,pol,sysk] = sys2zp(sys);
     ff = ones(size(jw));
     l1 = min(length(zer)*(1-isempty(zer)),length(pol)*(1-isempty(pol)));
     for ii=1:l1
       ff = ff .* (jw - zer(ii)) ./ (jw - pol(ii));
     endfor
 
-    # require proper  transfer function, so now just get poles.
+    ## require proper  transfer function, so now just get poles.
     for ii=(l1+1):length(pol)
       ff = ff ./ (jw - pol(ii));
     endfor
     ff = ff*sysk;
 
   elseif (strcmp(sysgettype(sys),"tf"))
-    # transfer function form 
+    ## transfer function form 
     [num,den] = sys2tf(sys);
     ff = polyval(num,jw)./polyval(den,jw);
   elseif (mm==pp)
-    # The system is square; do state-space form bode plot
+    ## The system is square; do state-space form bode plot
     [sysa,sysb,sysc,sysd,tsam,sysn,sysnz] = sys2ss(sys);
     n = sysn + sysnz;
     for ii=1:length(jw);
       ff(ii) = det(sysc*((jw(ii).*eye(n)-sysa)\sysb)+sysd);
     endfor;
   else
-    # Must be state space... bode                            
+    ## Must be state space... bode                            
     [sysa,sysb,sysc,sysd,tsam,sysn,sysnz] = sys2ss(sys);
     n = sysn + sysnz;
     for ii=1:length(jw);
       ff(ii) = norm(sysc*((jw(ii)*eye(n)-sysa)\sysb)+sysd);
     endfor
     
   endif
 
   w = reshape(w,1,length(w));
   ff = reshape(ff,1,length(ff));
 
-  # restore global variable
+  ## restore global variable
   empty_list_elements_ok = save_val;
 endfunction
 
diff --git a/scripts/control/gram.m b/scripts/control/gram.m
--- a/scripts/control/gram.m
+++ b/scripts/control/gram.m
@@ -1,32 +1,33 @@
-# Copyright (C) 1996 Auburn University.  All Rights Reserved
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1996 Auburn University.  All Rights Reserved
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File } { @var{m} =} gram (@var{a}, @var{b})
 ##  Return controllability grammian @var{m} of the continuous time system
 ## @math{ dx/dt = a x + b u}.  
 ## 
 ## @var{m} satisfies @math{ a m + m a' + b b' = 0 }.
 ## @end deftypefn
 
 function m = gram(a,b)
-  # Written by A. S. Hodel 
 
-  # let lyap do the error checking...
+  ## Written by A. S. Hodel 
+
+  ## let lyap do the error checking...
   m = lyap(a,b*b');
 endfunction
diff --git a/scripts/control/h2norm.m b/scripts/control/h2norm.m
--- a/scripts/control/h2norm.m
+++ b/scripts/control/h2norm.m
@@ -1,52 +1,52 @@
-# Copyright (C) 1996,1998 Auburn University.  All Rights Reserved
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1996,1998 Auburn University.  All Rights Reserved
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File } {@var{retval} =} h2norm(@var{sys})
 ## Computes the H2 norm of a system data structure (continuous time only)
 ## 
 ## Reference:
 ##  Doyle, Glover, Khargonekar, Francis, ``State Space Solutions to Standard
 ##  H2 and Hinf Control Problems", IEEE TAC August 1989
 ## @end deftypefn
 
+function h2gain = h2norm(sys)
 
-function h2gain = h2norm(sys)
-  # A. S. Hodel Aug 1995
-  # updated for system data structure by John Ingram November 1996
+  ## A. S. Hodel Aug 1995
+  ## updated for system data structure by John Ingram November 1996
 
   if((nargin != 1))
     usage("h2gain = h2norm(sys)");
   elseif(!is_struct(sys))
     error("Sys must be in system data structure");
   end
   dflg = is_digital(sys);
 
   if(!is_stable(sys))
     warning("h2norm: unstable input system; returning Inf");
     h2gain = Inf;
   else
-    # compute gain
+    ## compute gain
     [a,b,c,d] = sys2ss(sys);
     if(dflg)
       M = dlyap(a,b*b');
     else
       M = lyap (a,b*b');
     endif
     if( min(real(eig(M))) < 0)
       error("h2norm: grammian not >= 0 (lightly damped modes?)")
diff --git a/scripts/control/h2syn.m b/scripts/control/h2syn.m
--- a/scripts/control/h2syn.m
+++ b/scripts/control/h2syn.m
@@ -1,25 +1,25 @@
-# Copyright (C) 1996,1998 Auburn University.  All Rights Reserved
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1996,1998 Auburn University.  All Rights Reserved
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File } {[K}, @var{gain}, @var{Kc}, @var{Kf}, @var{Pc}, @var{Pf}] = h2syn(@var{Asys}, @var{nu}, @var{ny}, @var{tol})
 ##  Design H2 optimal controller per procedure in 
 ##  Doyle, Glover, Khargonekar, Francis, "State Space Solutions to Standard
 ##  H2 and Hinf Control Problems", IEEE TAC August 1989
 ## 
 ##  Discrete time control per Zhou, Doyle, and Glover, ROBUST AND OPTIMAL
@@ -54,47 +54,48 @@
 ## @item    Pc
 ## ARE solution matrix for regulator subproblem
 ## @item    Pf
 ## ARE solution matrix for filter subproblem
 ## @end table
 ## @end deftypefn
  
 function [K,gain, Kc, Kf, Pc,  Pf] = h2syn(Asys,nu,ny,tol)
-  # Updated for System structure December 1996 by John Ingram
+
+  ## Updated for System structure December 1996 by John Ingram
 
   if ((nargin < 3) | (nargin > 4))
     usage("[K,gain, Kc, Kf, Pc, Pf] = h2syn(Asys,nu,ny[,tol])");
   elseif(nargin == 3 )
     [chkdgkf,dgs] = is_dgkf(Asys,nu,ny);
   elseif(nargin == 4)
     [chkdgkf,dgs] = is_dgkf(Asys,nu,ny,tol);
   endif
 
   if (!chkdgkf )
     disp("h2syn: system does not meet required assumptions")
     help is_dgkf
     error("h2syn: exit");
   endif
 
-  # extract dgs information
+  ## extract dgs information
   			nw = dgs.nw; 	nu = dgs.nu;
   A = dgs.A;            Bw = dgs.Bw;    Bu = dgs.Bu;
   Cz = dgs.Cz;          Dzw = dgs.Dzw;  Dzu = dgs.Dzu;	nz = dgs.nz;
   Cy = dgs.Cy;          Dyw = dgs.Dyw;  Dyu = dgs.Dyu;	ny = dgs.ny;
   d22nz = dgs.Dyu_nz;
   dflg = dgs.dflg;
 
   if(norm(Dzw,Inf) > norm([Dzw, Dzu ; Dyw, Dyu],Inf)*1e-12)
     warning("h2syn: Dzw nonzero; feedforward not implemented")
     Dzw
     D = [Dzw, Dzu ; Dyw, Dyu]
   endif
 
-  # recover i/o transformations
+  ## recover i/o transformations
   Ru = dgs.Ru;         Ry = dgs.Ry;
   [ncstates, ndstates, nout, nin] = sysdimensions(Asys);
   Atsam = sysgettsam(Asys);
   [Ast, Ain, Aout] = sysgetsignals(Asys);
 
   if(dgs.dflg == 0)
     Pc = are(A,Bu*Bu',Cz'*Cz);    # solve control, filtering ARE's
     Pf = are(A',Cy'*Cy,Bw*Bw');
@@ -102,67 +103,67 @@ function [K,gain, Kc, Kf, Pc,  Pf] = h2s
     L2 = -Pf*Cy';
 
     AF2 = A + Bu*F2;
     AL2 = A + L2*Cy;
     CzF2 = Cz + (Dzu/Ru)*F2;
     BwL2 = Bw+L2*(Ry\Dyw);
 
   else
-    # discrete time solution
+    ## discrete time solution
     error("h2syn: discrete-time case not yet implemented")
     Pc = dare(A,Bu*Bu',Cz'*Cz);
     Pf = dare(A',Cy'*Cy,Bw*Bw');
   endif
 
   nn = ncstates + ndstates;
   In = eye(nn);
   KA = A + Bu*F2 + L2*Cy;
   Kc1 = ss2sys(AF2,Bw,CzF2,zeros(nz,nw));
   Kf1 = ss2sys(AL2,BwL2,F2,zeros(nu,nw));
 
   g1 = h2norm(Kc1);
   g2 = h2norm(Kf1);
   
-  # compute optimal closed loop gain
+  ## compute optimal closed loop gain
   gain = sqrt ( g1*g1 + g2*g2 );
 
   if(nargout)
     Kst = strappend(Ast,"_K");
     Kin = strappend(Aout((nout-ny+1):(nout)),"_K");
     Kout = strappend(Ain((nin-nu+1):(nin)),"_K");
 
-    # compute systems for return
+    ## compute systems for return
     K = ss2sys(KA,-L2/Ru,Ry\F2,zeros(nu,ny),Atsam,ncstates,ndstates,Kst,Kin,Kout);
   endif
 
   if (nargout > 2)
-    #system full information control state names
+    ## system full information control state names
     stname2 = strappend(Ast,"_FI");
 
-   #system full information control input names
+   ## system full information control input names
    inname2 = strappend(Ast,"_FI_in");
  
-    #system full information control output names
+    ## system full information control output names
     outname2 = strappend(Aout(1:(nout-ny)),"_FI_out");
 
     nz = rows (Cz);
     nw = columns (Bw);
 
     Kc = ss2sys(AF2, In, CzF2, zeros(nz,nn), Atsam, ...
 	ncstates, ndstates, stname2, inname2, outname2);
   endif
 
   if (nargout >3)
-    #fix system state estimator state names
+    ## fix system state estimator state names
     stname3 = strappend(Ast,"_Kf");
 
-    #fix system state estimator input names
+    ## fix system state estimator input names
     inname3 = strappend(Ast,"_Kf_noise");
 
-    #fix system state estimator output names
+    ## fix system state estimator output names
     outname3 = strappend(Ast,"_est");
 
     Kf = ss2sys(AL2, BwL2, In, zeros(nn,nw),Atsam,  ...
       ncstates, ndstates, stname3, inname3,outname3);
   endif
 
 endfunction
diff --git a/scripts/control/hinf_ctr.m b/scripts/control/hinf_ctr.m
--- a/scripts/control/hinf_ctr.m
+++ b/scripts/control/hinf_ctr.m
@@ -1,25 +1,25 @@
-# Copyright (C) 1996 Auburn University.  All Rights Reserved
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1996 Auburn University.  All Rights Reserved
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File } {@var{K} =} hinf_ctr(@var{dgs}, @var{F}, @var{H}, @var{Z}, @var{g})
 ## Called by @code{hinfsyn} to compute the H_inf optimal controller.
 ## 
 ## @strong{Inputs}
 ## @table @var
 ## @item dgs
@@ -31,20 +31,21 @@
 ## @end table
 ## @strong{Outputs}
 ## controller K (system data structure)
 ## 
 ## Do not attempt to use this at home; no argument checking performed.
 ## @end deftypefn
   
 function K = hinf_ctr(dgs,F,H,Z,g)
-  # A. S. Hodel August 1995
-  # Revised by Kai P Mueller April 1998 to solve the general H_infinity
-  # problem using unitary transformations Q (on w and z)
-  # and non-singular transformations R (on u and y).
+
+  ## A. S. Hodel August 1995
+  ## Revised by Kai P Mueller April 1998 to solve the general H_infinity
+  ## problem using unitary transformations Q (on w and z)
+  ## and non-singular transformations R (on u and y).
 
   nw = dgs.nw;
   nu = dgs.nu;
   nz = dgs.nz;
   ny = dgs.ny;
   d22nz = dgs.Dyu_nz;
   
   B1  = dgs.Bw;
@@ -66,23 +67,23 @@ function K = hinf_ctr(dgs,F,H,Z,g)
 
   F11 = F(1:(nw-ny),:);
   F12 = F((nw-ny+1):nw,:);
   F2  = F((nw+1):nin,:);
   H11 = H(:,1:(nz-nu));
   H12 = H(:,(nz-nu+1):nz);
   H2  = H(:,(nz+1):nout);
 
-  # D11 partitions
+  ## D11 partitions
   D1111 = D11(1:(nz-nu),1:(nw-ny));
   D1112 = D11(1:(nz-nu),(nw-ny+1):nw);
   D1121 = D11((nz-nu+1):nz,1:(nw-ny));
   D1122 = D11((nz-nu+1):nz,(nw-ny+1):nw);
 
-  # D11ik may be the empty matrix, don't calculate with empty matrices
+  ## D11ik may be the empty matrix, don't calculate with empty matrices
   [nd1111,md1111] = size(D1111);
   md1112 = length(D1112);
   md1121 = length(D1121);
 
   if ((nd1111 == 0) || (md1112 == 0))
     d11hat = -D1122;
   else
     xx = inv(g*g*eye(nz-nu) - D1111*D1111');
@@ -108,24 +109,24 @@ function K = hinf_ctr(dgs,F,H,Z,g)
   endif
 
   b2hat = (B2+H12)*d12hat;
   c2hat = -d21hat*(C2+F12)*Z;
   b1hat = -H2 + (b2hat/d12hat)*d11hat;
   c1hat =  F2*Z + (d11hat/d21hat)*c2hat;
   ahat  =  A + H*C + (b2hat/d12hat)*c1hat;
 
-  # rescale controller by Ru and Ry
+  ## rescale controller by Ru and Ry
   b1hat = b1hat/Ry;
   c1hat = Ru\c1hat;
   bhat  = [b1hat, b2hat];
   chat  = [c1hat; c2hat];
   dhat  = [Ru\d11hat/Ry, Ru\d12hat; d21hat/Ry, 0*d11hat'];
 
-  # non-zero D22 is a special case
+  ## non-zero D22 is a special case
   if (d22nz)
     if (rank(eye(nu) + d11hat*D22) < nu)
       error(" *** cannot compute controller for D22 non-zero.");
     endif
 
     d22new = [D22, zeros(ny,ny); zeros(nu,nu), 0*D22'];
     xx = inv(eye(nu+ny) + d22new*dhat);
     mhat = inv(eye(nu+ny) + dhat*d22new);
diff --git a/scripts/control/hinfdemo.m b/scripts/control/hinfdemo.m
--- a/scripts/control/hinfdemo.m
+++ b/scripts/control/hinfdemo.m
@@ -1,25 +1,25 @@
-# Copyright (C) 1996,1998 Kai Mueller
-#
-# This file is part of Octave.
-#
-# Octave is free software; you can redistribute it and/or modify it
-# under the terms of the GNU General Public License as published by the
-# Free Software Foundation; either version 2, or (at your option) any
-# later version.
-#
-# Octave is distributed in the hope that it will be useful, but WITHOUT
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-# for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Octave; see the file COPYING.  If not, write to the Free
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
+## Copyright (C) 1996,1998 Kai Mueller
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
+##
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+## for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
 ## hinfdemo  H_infinity design demos for continuous SISO and MIMO
 ##           systems and a discrete system.
 ##           The SISO system is difficult to control because
 ##           it is non minimum phase and unstable. The second
 ##           design example controls the "jet707" plant, the
 ##           linearized state space model of a Boeing 707-321
@@ -120,17 +120,17 @@
 ##	    |    +---+       |
 ##	    -----| K |<-------
 ##	         +---+
 ## @end group
 ##	W1 and W2 are the robustness and performancs weighting
 ##       functions
 ## @end deftypefn
 
-# Kai P. Mueller 30-APR-1998 <mueller@ifr.ing.tu-bs.de
+## Kai P. Mueller 30-APR-1998 <mueller@ifr.ing.tu-bs.de
 
 yn = [];
 while (length(yn) < 1)
   yn = input(" * [s]iso, [m]imo, or [d]iscrete design? [no default]: ","S");
 endwhile
 if ((yn(1) == "s") | (yn(1) == 'S'))
   sys_type = 1;
 elseif ((yn(1) == "m") | (yn(1) == 'M'))
@@ -141,78 +141,78 @@ else
   disp(" *** no system type specified, hinfdemo terminated.");
   return;
 endif
 
 echo off
 switch (sys_type)
 
   case (1)
-    # siso
+    ## siso
     disp(" ");
     disp("    ----------------------------------------------");
     disp("    H_infinity optimal control for the SISO plant:");
     disp(" ");
     disp("		            s - 2");
     disp("		G(s) = --------------");
     disp("		       (s + 2)(s - 1)");
     disp(" ");
     disp("    ----------------------------------------------");
     disp(" ");
 
-    # weighting on actuator u
+    ## weighting on actuator u
     W1 = wgt1o(0.05, 100.0, 425.0);
-    # weighting on controlled variable y
+    ## weighting on controlled variable y
     W2 = wgt1o(10.0, 0.05, 0.001);
-    # plant
+    ## plant
     G = tf2sys([1 -2],[1 1 -2]);
 
-    # need One as the pseudo transfer function One = 1
+    ## need One as the pseudo transfer function One = 1
     One = ugain(1);
     disp(" o forming P...");
     psys = buildssic([1 4;2 4;3 1],[3],[2 3 5],[3 4],G,W1,W2,One);
     disp(" ");
     disp(" o controller design...");
     [K, gfin, GW]=hinfsyn(psys, 1, 1, 0.1, 10.0, 0.02);
     disp(" ");
     disp("-- OK ----------------------------------------------");
 
     disp("  Closed loop poles:");
     damp(GW);
-    # disp(" o Testing H_infinity norm: (hinfnorm does not work)");
-    # hinfnorm(GW);
+    ## disp(" o Testing H_infinity norm: (hinfnorm does not work)");
+    ## hinfnorm(GW);
 
     disp(" ");
     yn = input(" * Plot closed loop step response? [n]: ","S");
     if (length(yn) >= 1)
       if ((yn(1) == "y") || (yn(1) == 'Y'))
       	disp(" o step responses of T and KS...");
       	GW = buildssic([1 2; 2 1], [], [1 2], [-2], G, K);
       	figure(1);
       	step(GW, 1, 10);
       endif
     endif
 
   case (2)
-    # mimo
+    ## mimo
     disp(" ");
     disp("    -----------------------------------------------");
     disp("      H_inf optimal control for the jet707 plant");
     disp("    -----------------------------------------------");
     disp(" ");
 
-    # Weighting function on u (robustness weight)
+    ## Weighting function on u (robustness weight)
     ww1 = wgt1o(0.01,5,0.9);
     ww2 = wgt1o(0.01,5,2.2);
     W1 = buildssic([1 0;2 0],[],[1 2],[1 2],ww1,ww2);
-    # Weighting function on y (performance weight)
+    ## Weighting function on y (performance weight)
     ww1 = wgt1o(250,0.1,0.0001);
     ww2 = wgt1o(250,0.1,0.0002);
     W2 = buildssic([1 0;2 0],[],[1 2],[1 2],ww1,ww2);
-    # plant (2 x 2 system)
+    ## plant (2 x 2 system)
     G = jet707;
 
     disp(" o forming P...");
     One = ugain(2);
     Clst = [1 7; 2 8; 3 7; 4 8; 5 1; 6 2];
     P = buildssic(Clst,[5 6],[3:6 9 10],[1 2 5:8],G,W1,W2,One);
 
     disp(" ");
@@ -244,47 +244,47 @@ switch (sys_type)
       	figure(1)
       	step(GW);
       	figure(2)
       	step(GW,2);
       endif
     endif
 
   case (3)
-    # discrete
+    ## discrete
     disp(" ");
     disp("    --------------------------------------------------");
     disp("    Discrete H_infinity optimal control for the plant:");
     disp(" ");
     disp("	                   0.199788z + 0.073498");
     disp("	        G(s) = --------------------------");
     disp("	               (z - 0.36788)(z - 0.13533)");
     disp("    --------------------------------------------------");
     disp(" ");
 
-    # sampling time
+    ## sampling time
     Ts = 1.0;
-    # weighting on actuator value u
+    ## weighting on actuator value u
     W1 = wgt1o(0.1, 200.0, 50.0);
-    # weighting on controlled variable y
+    ## weighting on controlled variable y
     W2 = wgt1o(350.0, 0.05, 0.0002);
-    # omega axis
+    ## omega axis
     ww = logspace(-4.99, 3.99, 100);
     if (columns(ww) > 1);  ww = ww';  endif
 
-    # continuous plant
+    ## continuous plant
     G = tf2sys(2,[1 3 2]);
-    # discrete plant with zoh
+    ## discrete plant with zoh
     Gd = c2d(G, Ts);
-    # w-plane (continuous representation of the sampled system)
+    ## w-plane (continuous representation of the sampled system)
     Gw = d2c(Gd, "bi");
 
     disp(" ");
     disp(" o building P...");
-    # need One as the pseudo transfer function One = 1
+    ## need One as the pseudo transfer function One = 1
     One = ugain(1);
     psys = buildssic([1 4;2 4;3 1],[3],[2 3 5],[3 4],Gw,W1,W2,One);
     disp(" o controller design...");
     [K, gfin, GWC] = hinfsyn(psys, 1, 1, 0.1, 10.0, 0.02);
 
     disp(" ");
     fig_n = 1;
     yn = input(" * Plot magnitudes of W1KS and W2S? [n]: ","S");
@@ -318,9 +318,9 @@ switch (sys_type)
     	step(GG, 1, 10);
       endif
     endif
 
 endswitch
 
 disp(" o hinfdemo terminated successfully.");
 
-# KPM-hinfdemo/End
+## KPM-hinfdemo/End
diff --git a/scripts/control/hinfnorm.m b/scripts/control/hinfnorm.m
--- a/scripts/control/hinfnorm.m
+++ b/scripts/control/hinfnorm.m
@@ -1,25 +1,25 @@
-# Copyright (C) 1996,1998 Auburn University.  All Rights Reserved
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1996,1998 Auburn University.  All Rights Reserved
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File } {[@var{g}, @var{gmin}, @var{gmax}] =} hinfnorm(@var{sys}@{, @var{tol}, @var{gmin}, @var{gmax}, @var{ptol}@})
 ##  Computes the H infinity norm of a system data structure.
 ## 
 ## @strong{Inputs}
 ## @table @var
 ## @item sys 
@@ -66,30 +66,30 @@
 function [g, gmin, gmax] = hinfnorm(sys,tol,gmin,gmax,ptol)
 
   if((nargin == 0) || (nargin > 4))
     usage("[g gmin gmax] = hinfnorm(sys[,tol,gmin,gmax,ptol])");
   elseif(!is_struct(sys))
     error("Sys must be a system data structure");
   endif
 
-  # set defaults where applicable
+  ## set defaults where applicable
   if(nargin < 5)
     ptol = 1e-9;	# pole tolerance
   endif
   if(nargin < 4)
     gmax = 1e9;		# max gain value
   endif
 
   dflg = is_digital(sys);
   sys = sysupdate(sys,"ss");
   [A,B,C,D] = sys2ss(sys);
   [n,nz,m,p] = sysdimensions(sys);
 
-  # eigenvalues of A must all be stable
+  ## eigenvalues of A must all be stable
   if(!is_stable(sys))
     warning(["hinfnorm: unstable system (is_stable, ptol=",num2str(ptol), ...
       "), returning Inf"]);
     g = Inf;
   endif
 
   Dnrm = norm(D);
   if(nargin < 3)
@@ -97,58 +97,58 @@ function [g, gmin, gmax] = hinfnorm(sys,
   elseif(gmin < Dnrm)
     warning(["hinfnorm: setting Gmin=||D||=",num2str(Dnrm)]);
   endif
 
   if(nargin < 2)
     tol = 0.001;	# convergence measure for gmin, gmax
   endif
 
-  # check for scalar input arguments 2...5
+  ## check for scalar input arguments 2...5
   if( ! (is_scalar(tol) && is_scalar(gmin) 
 	&& is_scalar(gmax) && is_scalar(ptol)) )
     error("hinfnorm: tol, gmin, gmax, ptol must be scalars");
   endif
 
   In = eye(n+nz);
   Im = eye(m);
   Ip = eye(p);
-  # find the Hinf norm via binary search
+  ## find the Hinf norm via binary search
   while((gmax/gmin - 1) > tol)
     g = (gmax+gmin)/2;
 
     if(dflg)
-      # multiply g's through in formulas to avoid extreme magnitudes...
+      ## multiply g's through in formulas to avoid extreme magnitudes...
       Rg = g^2*Im - D'*D;
       Ak = A + (B/Rg)*D'*C;
       Ck = g^2*C'*((g^2*Ip-D*D')\C);
 
-      # set up symplectic generalized eigenvalue problem per Iglesias & Glover
+      ## set up symplectic generalized eigenvalue problem per Iglesias & Glover
       s1 = [Ak , zeros(nz) ; -Ck, In ];
       s2 = [In, -(B/Rg)*B' ; zeros(nz) , Ak' ];
 
-      # guard against roundoff again: zero out extremely small values
-      # prior to balancing
+      ## guard against roundoff again: zero out extremely small values
+      ## prior to balancing
       s1 = s1 .* (abs(s1) > ptol*norm(s1,"inf"));
       s2 = s2 .* (abs(s2) > ptol*norm(s2,"inf"));
       [cc,dd,s1,s2] = balance(s1,s2);
       [qza,qzb,zz,pls] = qz(s1,s2,"S");	# ordered qz decomposition
       eigerr = abs(abs(pls)-1);
       normH = norm([s1,s2]);
       Hb = [s1, s2];
 
-      # check R - B' X B condition (Iglesias and Glover's paper)
+      ## check R - B' X B condition (Iglesias and Glover's paper)
       X = zz((nz+1):(2*nz),1:nz)/zz(1:nz,1:nz);
       dcondfailed = min(real( eig(Rg - B'*X*B)) < ptol);
     else
       Rinv = inv(g*g*Im - (D' * D));
       H = [A + B*Rinv*D'*C,        B*Rinv*B'; ...
            -C'*(Ip + D*Rinv*D')*C, -(A + B*Rinv*D'*C)'];
-      # guard against roundoff: zero out extremely small values prior 
-      # to balancing
+      ## guard against roundoff: zero out extremely small values prior 
+      ## to balancing
       H = H .* (abs(H) > ptol*norm(H,"inf"));
       [DD,Hb] = balance(H);
       pls = eig(Hb);
       eigerr = abs(real(pls));
       normH = norm(H);
       dcondfailed = 0;		# digital condition; doesn't apply here
     endif
     if( (min(eigerr) <= ptol * normH) | dcondfailed)
diff --git a/scripts/control/hinfsyn.m b/scripts/control/hinfsyn.m
--- a/scripts/control/hinfsyn.m
+++ b/scripts/control/hinfsyn.m
@@ -1,25 +1,25 @@
-# Copyright (C) 1996,1998 Auburn University.  All Rights Reserved
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1996,1998 Auburn University.  All Rights Reserved
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File } {[@var{K}, @var{g}, @var{GW}, @var{Xinf}, @var{Yinf}] =} hinfsyn(@var{Asys}, @var{nu}, @var{ny}, @var{gmin}, @var{gmax}, @var{gtol}@{, @var{ptol}, @var{tol}@})
 ## 
 ## @strong{Inputs} input system is passed as either
 ## @table @var
 ## @item Asys
 ## system data structure (see ss2sys, sys2ss)
@@ -71,27 +71,28 @@
 ## @item Keith Glover and John C. Doyle, "State-space formulae for all
 ##      stabilizing controllers that satisfy and h-infinity-norm bound
 ##      and relations to risk sensitivity,"
 ##      Systems & Control Letters 11, Oct. 1988, pp 167-172.
 ## @end enumerate
 ## @end deftypefn
  
 function [K,g,GW,Xinf,Yinf] = hinfsyn(Asys,nu,ny,gmin,gmax,gtol,ptol,tol)
-  # A. S. Hodel August 1995
-  # Updated for Packed system structures December 1996 by John Ingram
-  #
-  # Revised by Kai P Mueller April 1998 to solve the general H_infinity
-  # problem using unitary transformations Q (on w and z)
-  # and non-singular transformations R (on u and y).
+
+  ## A. S. Hodel August 1995
+  ## Updated for Packed system structures December 1996 by John Ingram
+  ## 
+  ## Revised by Kai P Mueller April 1998 to solve the general H_infinity
+  ## problem using unitary transformations Q (on w and z)
+  ## and non-singular transformations R (on u and y).
 
   if( (nargin < 1) | (nargin > 8) )
     usage("[K,g,GW,Xinf,Yinf] = hinfsyn(Asys,nu,ny,gmin,gmax,gtol,ptol,tol)");
   endif
-  # set default arguments
+  ## set default arguments
   if(nargin < 8)
     tol = 200*eps;
   elseif(!is_sample(tol))
     error("tol must be a positive scalar.")
   endif
   if(nargin < 7)
     ptol = 1e-9;
   elseif(!is_sample(ptol))
@@ -106,39 +107,39 @@ function [K,g,GW,Xinf,Yinf] = hinfsyn(As
   [chkdgkf,dgs] = is_dgkf(Asys,nu,ny,tol);
 
   if (! chkdgkf )
     disp("hinfsyn: system does not meet required assumptions")
     help is_dgkf
     error("hinfsyn: exit");
   endif
 
-  # extract dgs information
+  ## extract dgs information
   			nw = dgs.nw;	nu = dgs.nu;
   A = dgs.A;		B1 = dgs.Bw;	B2 = dgs.Bu;
   C1 = dgs.Cz;		D11 = dgs.Dzw;	D12 = dgs.Dzu;		nz = dgs.nz;
   C2 = dgs.Cy;		D21 = dgs.Dyw;	D22 = dgs.Dyu;		ny = dgs.ny;
   d22nz = dgs.Dyu_nz;
   dflg = dgs.dflg;
 
-  # recover i/o transformations
+  ## recover i/o transformations
   R12 = dgs.Ru;		R21 = dgs.Ry;
   [ncstates, ndstates, nin, nout] = sysdimensions(Asys);
   Atsam = sysgettsam(Asys);
   [Ast, Ain, Aout] = sysgetsignals(Asys);
 
   BB = [B1, B2];
   CC = [C1 ; C2];
   DD = [D11, D12 ; D21,  D22];
 
   if (dflg == 0)
     n = ncstates;
-    # perform binary search to find gamma min
+    ## perform binary search to find gamma min
     ghi = gmax;
-    # derive a lower lower bound for gamma from D matrices
+    ## derive a lower lower bound for gamma from D matrices
     xx1 = norm((eye(nz) - (D12/(D12'*D12))*D12')*D11);
     xx2 = norm(D11*(eye(nw)-(D21'/(D21*D21'))*D21));
     glo = max(xx1, xx2);
     if (glo > gmin)
       disp(" *** D matrices indicate a greater value of gamma min.");
       fprintf("     gamma min (%f) superseeded by %f.", gmin, glo);
       glo = xx1;
     else
@@ -155,25 +156,25 @@ function [K,g,GW,Xinf,Yinf] = hinfsyn(As
     g = glo;
     search_state = 0;
     iteration_finished = 0;
     disp(" o structural tests passed, start of iteration...");
     disp("        o <-> test passed   # <-> test failed   - <-> cannot test");
     printf("----------------------------------------");
     printf("--------------------------------------\n");
 
-    # ------123456789012345678901234567890123456789012345678901234567890
+    ## ------123456789012345678901234567890123456789012345678901234567890
     printf("           .........X......... .........Y......... ");
     printf(".Z. PASS REMARKS\n");
     printf("        ga iax nev ene sym pos iax nev ene sym pos ");
     printf("rho  y/n ======>\n");
     printf("----------------------------------------");
     printf("--------------------------------------\n");
 
-    # set up error messages
+    ## set up error messages
     errmesg = list(" o   o   o   o   o  ", ...
 	" #   -   -   -   -  ", ...
 	" o   #   -   -   -  ", ...
 	" o   o   #   -   -  ", ...
 	" o   o   o   #   -  ", ...
 	" o   o   o   o   #  ", ...
 	" -   -   -   -   -  ");
     errdesx = list("", ...
@@ -188,47 +189,47 @@ function [K,g,GW,Xinf,Yinf] = hinfsyn(As
 	"Y im eig.", ...
 	"Hy not Ham.", ...
 	"Y inf.eig", ...
 	"Y not symm.", ...
 	"Y not pos", ...
 	"Rtilde singular");
 
 
-    # now do the search
+    ## now do the search
     while (!iteration_finished)
       switch (search_state)
         case (0) 	g = ghi;
         case (1) 	g = glo;
         case (2) 	g = 0.5 * (ghi + glo);
         otherwise 	error(" *** This should never happen!");
       endswitch
       printf("%10.4f ", g);
 
-      # computing R and R~
+      ## computing R and R~
       d1dot = [D11, D12];
       R = zeros(nin, nin);
       R(1:nw,1:nw) = -g*g*eye(nw);
       R = R + d1dot' * d1dot;
       ddot1 = [D11; D21];
       Rtilde = zeros(nout, nout);
       Rtilde(1:nz,1:nz) = -g*g*eye(nz);
       Rtilde = Rtilde + ddot1 * ddot1';
 
       [Xinf,x_ha_err] = hinfsyn_ric(A,BB,C1,d1dot,R,ptol);
       [Yinf,y_ha_err] = hinfsyn_ric(A',CC',B1',ddot1',Rtilde,ptol);
 
-      # assume failure for this gamma
+      ## assume failure for this gamma
       passed = 0;
       rerr="";
       if (!x_ha_err && !y_ha_err)
-	# test spectral radius condition
+	## test spectral radius condition
 	rho = max(abs(eig(Xinf * Yinf)));
 	if (rho < g*g)
-	  # spectral radius condition passed
+	  ## spectral radius condition passed
 	  passed = 1;
         else
           rerr = sprintf("rho=%f",rho);
 	endif
       endif
 
       if(x_ha_err >= 0 & x_ha_err <= 6)
         printf("%s",nth(errmesg,x_ha_err+1));
@@ -249,45 +250,45 @@ function [K,g,GW,Xinf,Yinf] = hinfsyn(As
 
       if (passed && (de/g < gtol))
 	search_state = 3;
       endif
 
       switch (search_state)
         case (0)
 	  if (!passed)
-	    # upper bound must pass but did not
+	    ## upper bound must pass but did not
 	    fprintf(" *** the upper bound of gamma (%f) is too small.\n", g);
 	    iteration_finished = 2;
 	  else
             search_state = 1;
 	  endif
         case (1)
 	  if (!passed)      search_state = 2;
 	  else
-	    # lower bound must not pass but passed
+	    ## lower bound must not pass but passed
 	    fprintf(" *** the lower bound of gamma (%f) passed.\n", g);
 	    iteration_finished = 3;
 	  endif
         case (2)
-          # Normal case; must check that singular R, Rtilde wasn't the problem.
+          ## Normal case; must check that singular R, Rtilde wasn't the problem.
 	  if ((!passed) & (x_ha_err != 6) & (y_ha_err != 6) ) glo = g;
 	  else         ghi = g;        endif
 	  de = ghi - glo;
         case (3)       iteration_finished = 1;        # done
         otherwise      error(" *** This should never happen!");
       endswitch
     endwhile
 
     printf("----------------------------------------");
     printf("--------------------------------------\n");
     if (iteration_finished != 1)
       K = [];
     else
-      # success: compute controller
+      ## success: compute controller
       fprintf("   hinfsyn final: glo=%f ghi=%f, test gain g=%f\n", \
               glo, ghi, g);
       printf("----------------------------------------");
       printf("--------------------------------------\n");
       Z = inv(eye(ncstates) - Yinf*Xinf/g/g);
       F = -R \ (d1dot'*C1 + BB'*Xinf);
       H = -(B1*ddot1' + Yinf*CC') / Rtilde;
       K = hinf_ctr(dgs,F,H,Z,g);
@@ -299,14 +300,14 @@ function [K,g,GW,Xinf,Yinf] = hinfsyn(As
       K = ss2sys(Ac,Bc,Cc,Dc,Atsam,ncstates,ndstates,Kst,Kin,Kout);
       if (nargout >= 3)
 	GW = starp(Asys, K);
       endif
     endif
     
   elseif(ndstates)
 
-    # discrete time solution
+    ## discrete time solution
     error("hinfsyn: discrete-time case not yet implemented")
 
   endif
 
 endfunction
diff --git a/scripts/control/hinfsyn_chk.m b/scripts/control/hinfsyn_chk.m
--- a/scripts/control/hinfsyn_chk.m
+++ b/scripts/control/hinfsyn_chk.m
@@ -1,25 +1,25 @@
-# Copyright (C) 1996 Auburn University.  All Rights Reserved
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1996 Auburn University.  All Rights Reserved
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{retval}, @var{Pc}, @var{Pf}] =} hinfsyn_chk(@var{A}, @var{B1}, @var{B2}, @var{C1}, @var{C2}, @var{D12}, @var{D21}, @var{g}, @var{ptol})
 ##  Called by @code{hinfsyn} to see if gain @var{g} satisfies conditions in 
 ## Theorem 3 of
 ##  Doyle, Glover, Khargonekar, Francis, "State Space Solutions to Standard
 ##  H2 and Hinf Control Problems", IEEE TAC August 1989
 ##  
@@ -41,40 +41,41 @@
 ##  solution of "regulator" H-inf ARE
 ## @item Pf
 ##  solution of "filter" H-inf ARE
 ## @end table
 ## Do not attempt to use this at home; no argument checking performed.
 ## @end deftypefn 
 
 function [retval,Pc,Pf] = hinfsyn_chk(A,B1,B2,C1,C2,D12,D21,g,ptol)
-  # A. S. Hodel August 1995
+
+  ## A. S. Hodel August 1995
 
   Pc = Pf = [];
 
-  # Construct the two Hamiltonians
+  ## Construct the two Hamiltonians
   g2 = 1/(g*g);
   Hc = [ A ,  g2*B1*B1' - B2*B2'; -C1'*C1 , -A'];
   Hf = [ A' , g2*C1'*C1 - C2'*C2; -B1*B1' , -A];
 
-  # check if Hc, Hf are in dom(Ric)
+  ## check if Hc, Hf are in dom(Ric)
   Hcminval = min(abs(real(eig(Hc))));
   Hfminval = min(abs(real(eig(Hf))));
   if(Hcminval < ptol);
     disp("hinfsyn_chk: Hc is not in dom(Ric)");
     retval = 0;
     return
   endif
   if(Hfminval < ptol)
     disp("hinfsyn_chk: Hf is not in dom(Ric)");
     retval = 0;
     return
   endif
 
-  #Solve ARE's
+  ## Solve ARE's
   Pc = are(A, B2*B2'-g2*B1*B1',C1'*C1);
   Pf = are(A',C2'*C2-g2*C1'*C1,B1*B1');
 
   Pceig = eig(Pc);
   Pfeig = eig(Pf);
   Pcfeig = eig(Pc*Pf);
 
   if(min(Pceig) < -ptol)
@@ -88,12 +89,12 @@ function [retval,Pc,Pf] = hinfsyn_chk(A,
     return
   endif
   if(max(abs(Pcfeig)) >= g*g)
     disp("hinfsyn_chk: rho(Pf*Pc) is not < g^2");
     retval = 0;
     return
   endif
  
-  # all conditions met.
+  ## all conditions met.
   retval = 1;
 
 endfunction
diff --git a/scripts/control/hinfsyn_ric.m b/scripts/control/hinfsyn_ric.m
--- a/scripts/control/hinfsyn_ric.m
+++ b/scripts/control/hinfsyn_ric.m
@@ -1,72 +1,75 @@
-# Copyright (C) 1996,1998 Auburn University.  All Rights Reserved
-#
-# This file is part of Octave.
-#
-# Octave is free software; you can redistribute it and/or modify it
-# under the terms of the GNU General Public License as published by the
-# Free Software Foundation; either version 2, or (at your option) any
-# later version.
-#
-# Octave is distributed in the hope that it will be useful, but WITHOUT
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-# for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Octave; see the file COPYING.  If not, write to the Free
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
+## Copyright (C) 1996,1998 Auburn University.  All Rights Reserved
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
+##
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+## for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
+
+## usage: [Xinf,x_ha_err] = hinfsyn_ric(A,BB,C1,d1dot,R,ptol)
+##
+## forms
+##        xx = ([BB; -C1'*d1dot]/R) * [d1dot'*C1 BB'];
+##        Ha = [A 0*A; -C1'*C1 -A'] - xx;
+## and solves associated Riccati equation
+## returns error code
+##  x_ha_err:
+##    0: successful
+##    1: Xinf has imaginary eigenvalues
+##    2: Hx not Hamiltonian
+##    3: Xinf has inf. eigenvalues (numerical overflow)
+##    4: Xinf not symmetric
+##    5: Xinf not positive definite
+##    6: R is singular
 
 function [Xinf,x_ha_err] = hinfsyn_ric(A,BB,C1,d1dot,R,ptol)
-#
-# forms
-#        xx = ([BB; -C1'*d1dot]/R) * [d1dot'*C1 BB'];
-#        Ha = [A 0*A; -C1'*C1 -A'] - xx;
-# and solves associated Riccati equation
-# returns error code
-#  x_ha_err:
-#    0: successful
-#    1: Xinf has imaginary eigenvalues
-#    2: Hx not Hamiltonian
-#    3: Xinf has inf. eigenvalues (numerical overflow)
-#    4: Xinf not symmetric
-#    5: Xinf not positive definite
-#    6: R is singular
+
+  x_ha_err = 0;        # assume success
+  Xinf = [];		     # default return value
+  n = is_square(A);
+  nw = is_square(R);
+  if(rank(R) != nw)    x_ha_err = 6;
+  else                 # build hamiltonian Ha for X_inf
+    xx = ([BB; -C1'*d1dot]/R) * [d1dot'*C1, BB'];
+    Ha = [A, 0*A; -C1'*C1, -A'] - xx;
+    x_ha_err = 0;
+    [d, Ha] = balance(Ha);
+    [u, s] = schur(Ha, "A");
+    rev = real(eig(s));
 
-x_ha_err = 0;        # assume success
-Xinf = [];		     # default return value
-n = is_square(A);
-nw = is_square(R);
-if(rank(R) != nw)    x_ha_err = 6;
-else                 # build hamiltonian Ha for X_inf
-  xx = ([BB; -C1'*d1dot]/R) * [d1dot'*C1, BB'];
-  Ha = [A, 0*A; -C1'*C1, -A'] - xx;
-  x_ha_err = 0;
-  [d, Ha] = balance(Ha);
-  [u, s] = schur(Ha, "A");
-  rev = real(eig(s));
-
-  if (any(abs(rev) <= ptol))	# eigenvalues near the imaginary axis
-    x_ha_err = 1;
-  elseif (sum(rev > 0) != sum(rev < 0))
-    # unequal number of positive and negative eigenvalues
-    x_ha_err = 2;
-  else
-    # compute positive Riccati equation solution
-    u = d * u;
-    Xinf = u(n+1:2*n,1:n) / u(1:n,1:n);
-    if (!all(all(finite(Xinf))))
-      x_ha_err = 3;
-    elseif (norm(Xinf-Xinf') >= 10*ptol)
-      # solution not symmetric
-      x_ha_err = 4;
+    if (any(abs(rev) <= ptol))	# eigenvalues near the imaginary axis
+      x_ha_err = 1;
+    elseif (sum(rev > 0) != sum(rev < 0))
+      ## unequal number of positive and negative eigenvalues
+      x_ha_err = 2;
     else
-      # positive semidefinite?
-      # force symmetry (faster, avoids some convergence problems)
-      Xinf = (Xinf + Xinf')/2;
-      rev = eig(Xinf);
-      if (any(rev <= -ptol))
-        x_ha_err = 5;
+      ## compute positive Riccati equation solution
+      u = d * u;
+      Xinf = u(n+1:2*n,1:n) / u(1:n,1:n);
+      if (!all(all(finite(Xinf))))
+	x_ha_err = 3;
+      elseif (norm(Xinf-Xinf') >= 10*ptol)
+	## solution not symmetric
+	x_ha_err = 4;
+      else
+	## positive semidefinite?
+	## force symmetry (faster, avoids some convergence problems)
+	Xinf = (Xinf + Xinf')/2;
+	rev = eig(Xinf);
+	if (any(rev <= -ptol))
+	  x_ha_err = 5;
+	endif
       endif
     endif
   endif
-endif
+endfunction
diff --git a/scripts/control/impulse.m b/scripts/control/impulse.m
--- a/scripts/control/impulse.m
+++ b/scripts/control/impulse.m
@@ -1,25 +1,25 @@
-# Copyright (C) 1996 Auburn University.  All Rights Reserved
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1996 Auburn University.  All Rights Reserved
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File } {[@var{y}, @var{t}] =} impulse (@var{sys}@{, @var{inp},@var{tstop}, @var{n}@})
 ## Impulse response for a linear system.
 ##        The system can be discrete or multivariable (or both).
 ## If no output arguments are specified, @code{impulse}
 ##  produces a plot or the impulse response data for system @var{sys}.
 ## 
@@ -41,19 +41,19 @@
 ## @strong{Outputs}
 ## @var{y}, @var{t}: impulse response
 ## @end deftypefn
  
 ## See also:  step, stepimp
 
 function [y, t] = impulse(sys, inp, tstop, n)
 
-# Written by Kai P. Mueller October 2, 1997
-# based on lsim.m of Scottedward Hodel
-# modified by
+## Written by Kai P. Mueller October 2, 1997
+## based on lsim.m of Scottedward Hodel
+## modified by
 
   if((nargin < 1) || (nargin > 4))
     usage("[y, u] = impulse(sys[, inp, tstop, n])");
   endif
 
   if(nargout > 2)
     usage("[y, u] = impulse(sys[, inp, tstop, n])");
   endif
diff --git a/scripts/control/is_abcd.m b/scripts/control/is_abcd.m
--- a/scripts/control/is_abcd.m
+++ b/scripts/control/is_abcd.m
@@ -1,76 +1,77 @@
-# Copyright (C) 1997 Kai P. Mueller
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1997 Kai P. Mueller
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File } { @var{retval} =} is_abcd( @var{a}@{, @var{b}, @var{c}, @var{d}@})
 ##  Returns @var{retval} = 1 if the dimensions of @var{a}, @var{b}, @var{c}, @var{d}
 ##  are compatible, otherwise @var{retval} = 0 with an appropriate diagnostic
 ##  message printed to the screen.  The matrices b, c, or d may be omitted.
 ## @end deftypefn
 
 ## See also: abcddim
 
 function retval = is_abcd(a, b, c, d)
-  # Written by Kai P. Mueller November 4, 1997
-  # based on is_controllable.m of Scottedward Hodel
-  # modified by
+
+  ## Written by Kai P. Mueller November 4, 1997
+  ## based on is_controllable.m of Scottedward Hodel
+  ## modified by
 
   retval = 0;
   switch (nargin)
     case (1)
-      # A only
+      ## A only
       [na, ma] = size(a);
       if (na != ma)
         disp("Matrix A ist not square.")
       endif
     case (2)
-      # A, B only
+      ## A, B only
       [na, ma] = size(a);  [nb, mb] = size(b);
       if (na != ma)
         disp("Matrix A ist not square.")
 	return;
       endif
       if (na != nb)
         disp("A and B column dimension different.")
         return;
       endif
     case (3)
-      # A, B, C only
+      ## A, B, C only
       [na, ma] = size(a);  [nb, mb] = size(b);  [nc, mc] = size(c);
       if (na != ma)
         disp("Matrix A ist not square.")
 	return;
       endif
       if (na != nb)
         disp("A and B column dimensions not compatible.")
 	return;
       endif
       if (ma != mc)
         disp("A and C row dimensions not compatible.")
 	return;
       endif
     case (4)
-      # all matrices A, B, C, D
+      ## all matrices A, B, C, D
       [na, ma] = size(a);  [nb, mb] = size(b);
       [nc, mc] = size(c);  [nd, md] = size(d);
       if (na != ma)
         disp("Matrix A ist not square.")
 	return;
       endif
       if (na != nb)
         disp("A and B column dimensions not compatible.")
@@ -86,11 +87,11 @@ function retval = is_abcd(a, b, c, d)
       endif
       if (nc != nd)
         disp("C and D column dimensions not compatible.")
 	return;
       endif
     otherwise
       usage("retval = is_abcd(a [, b, c, d])")
   endswitch
-  # all tests passed, signal ok.
+  ## all tests passed, signal ok.
   retval = 1;
 endfunction
diff --git a/scripts/control/is_controllable.m b/scripts/control/is_controllable.m
--- a/scripts/control/is_controllable.m
+++ b/scripts/control/is_controllable.m
@@ -1,25 +1,25 @@
-# Copyright (C) 1993, 1994, 1995 Auburn University.  All Rights Reserved
-# 
-# This file is part of Octave.
-# 
-# Octave is free software; you can redistribute it and/or modify it
-# under the terms of the GNU General Public License as published by the
-# Free Software Foundation; either version 2, or (at your option) any
-# later version.
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License
-# along with Octave; see the file COPYING.  If not, write to the Free
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
+## Copyright (C) 1993, 1994, 1995 Auburn University.  All Rights Reserved
+## 
+## This file is part of Octave.
+## 
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File } {[@var{retval}, @var{U}] =} is_controllable (@var{sys}@{, @var{tol}@})
 ## @deftypefnx {Function File } {[@var{retval}, @var{U}] =} is_controllable (@var{a}@{, @var{b} ,@var{tol}@})
 ## Logical check for system controllability.
 ## 
 ## @strong{Inputs}
 ## @table @var
@@ -50,65 +50,66 @@
 ## The Arnoldi iteration is executed with @code{krylov} if the system has a single input; otherwise a block Arnoldi iteration is performed with @code{krylovb}.
 ## 
 ## @strong{See also}
 ## @code{is_observable}, @code{is_stabilizable}, @code{is_detectable}, 
 ## 	@code{krylov}, @code{krylovb}
 ## 
 ## @end deftypefn
 
-# See also: size, rows, columns, length, is_matrix, is_scalar, is_vector
-#     is_observable, is_stabilizable, is_detectable, krylov, krylovb
+## See also: size, rows, columns, length, is_matrix, is_scalar, is_vector
+##     is_observable, is_stabilizable, is_detectable, krylov, krylovb
 
 function [retval,U] = is_controllable (a, b, tol)
-# Written by A. S. Hodel (scotte@eng.auburn.edu) August, 1993.
-# Updated by A. S. Hodel (scotte@eng.auburn.edu) Aubust, 1995 to use krylovb 
-# Updated by John Ingram (ingraje@eng.auburn.edu) July, 1996 for packed systems
+
+  ## Written by A. S. Hodel (scotte@eng.auburn.edu) August, 1993.
+  ## Updated by A. S. Hodel (scotte@eng.auburn.edu) Aubust, 1995 to use krylovb 
+  ## Updated by John Ingram (ingraje@eng.auburn.edu) July, 1996 for packed systems
 
   deftol = 1;    # assume default tolerance
   if(nargin < 1 | nargin > 3)
     usage("[retval,U] = %s\n\t%s", "is_controllable(a {, b ,tol})", ...
 	"is_controllable(sys{,tol})");
   elseif(is_struct(a))
-    # system structure passed.
+    ## system structure passed.
     sys = sysupdate(a,"ss");
     [a,bs] = sys2ss(sys);
     if(nargin > 2)
       usage("[retval,U] = is_controllable(sys{,tol})");
     elseif(nargin == 2)
       tol = b;		% get tolerance
       deftol = 0;
     endif
     b = bs;
   else
-    # a,b arguments sent directly.
+    ## a,b arguments sent directly.
     if(nargin < 2)
       usage("[retval,U] = is_controllable(a {, b ,tol})");
     else
       deftol = 1;
     endif
   endif
 
-  # check for default tolerance
+  ## check for default tolerance
   if(deftol) tol = 1000*eps; endif
 
-  # check tol dimensions
+  ## check tol dimensions
   if( !is_scalar(tol) )
     error("is_controllable: tol(%dx%d) must be a scalar", ...
 	rows(tol),columns(tol));
   elseif( !is_sample(tol) )
     error("is_controllable: tol=%e must be positive",tol);
   endif
 
-  # check dimensions compatibility
+  ## check dimensions compatibility
   n = is_square (a);
   [nr, nc] = size (b);
 
   if (n == 0 | n != nr | nc == 0)
     warning("is_controllable: a=(%dx%d), b(%dx%d)",rows(a),columns(a),nr,nc);
     retval = 0;
   else
-    # call block-krylov subspace routine to get an orthogonal basis
-    # of the controllable subspace.
+    ## call block-krylov subspace routine to get an orthogonal basis
+    ## of the controllable subspace.
     [U,H,Ucols] = krylov(a,b,n,tol,1);
     retval = (Ucols == n);
   endif
 endfunction
diff --git a/scripts/control/is_detectable.m b/scripts/control/is_detectable.m
--- a/scripts/control/is_detectable.m
+++ b/scripts/control/is_detectable.m
@@ -1,25 +1,25 @@
-# Copyright (C) 1993, 1994, 1995 Auburn University.  All Rights Reserved
-# 
-# This file is part of Octave.
-# 
-# Octave is free software; you can redistribute it and/or modify it
-# under the terms of the GNU General Public License as published by the
-# Free Software Foundation; either version 2, or (at your option) any
-# later version.
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License
-# along with Octave; see the file COPYING.  If not, write to the Free
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
+## Copyright (C) 1993, 1994, 1995 Auburn University.  All Rights Reserved
+## 
+## This file is part of Octave.
+## 
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File } { [@var{retval}, @var{U}] =} is_detectable (@var{a}, @var{c}@{, @var{tol}@})
 ## @deftypefnx {Function File } { [@var{retval}, @var{U}] =} is_detectable (@var{sys}@{, @var{tol}@})
 ## Test for detactability (observability of unstable modes) of (@var{a},@var{c}).  
 ## 
 ##  Returns 1 if the system @var{a} or the pair (@var{a},@var{c})is 
 ##  detectable, 0 if not.
@@ -29,23 +29,24 @@
 ## 
 ##  Default: tol = 10*norm(a,'fro')*eps 
 ## 
 ## @end deftypefn
 
 ## See also: size, rows, columns, length, is_matrix, is_scalar, is_vector.
 
 function [retval,U] = is_detectable (a,c,tol)
-# Written by A. S. Hodel (scotte@eng.auburn.edu) August 1993.
-# Updated by John Ingram (ingraje@eng.auburn.edu) July 1996.
+
+  ## Written by A. S. Hodel (scotte@eng.auburn.edu) August 1993.
+  ## Updated by John Ingram (ingraje@eng.auburn.edu) July 1996.
 
   if( nargin < 1) 
     usage("[retval,U] = is_detectable(a , c {, tol})");
   elseif(is_struct(a))
-    # system form
+    ## system form
     if(nargin == 2)
       tol = c;
     elseif(nargin > 2)
       usage("[retval,U] = is_detectable(sys {, tol})");
     endif
     [a,b,c] = sys2ss(a);
   elseif(nargin > 3)
     usage("[retval,U] = is_detectable(a , c {, tol})");
diff --git a/scripts/control/is_dgkf.m b/scripts/control/is_dgkf.m
--- a/scripts/control/is_dgkf.m
+++ b/scripts/control/is_dgkf.m
@@ -1,25 +1,25 @@
-# Copyright (C) 1996,1998 Auburn University.  All Rights Reserved
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1996,1998 Auburn University.  All Rights Reserved
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File } { [@var{retval}, @var{dgkf_struct} ] =} is_dgkf (@var{Asys}, @var{nu}, @var{ny}, @var{tol} )
 ##  Determine whether a continuous time state space system meets
 ##  assumptions of DGKF algorithm.  
 ##  Partitions system into: 
 ## @example
 ## [dx/dt] = [A  | Bw  Bu  ][w] 
@@ -90,39 +90,40 @@
 ##      to Standard H2 and Hinf Control Problems," IEEE TAC August 1989
 ## @item [2]
 ##  Maciejowksi, J.M.: "Multivariable feedback design,"
 ## @end table
 ## 
 ## @end deftypefn
  
 function [retval,dgkf_struct] = is_dgkf(Asys,nu,ny,tol)
-  #  Written by A. S. Hodel
-  #  Updated by John Ingram July 1996 to accept structured systems
-  #
-  # Revised by Kai P Mueller April 1998 to solve the general H_infinity
-  # problem using unitary transformations Q (on w and z)
-  # and non-singular transformations R (on u and y) such
-  # that the Dzu and Dyw matrices of the transformed plant
-  #
-  #    ~
-  #    P  (the variable Asys here)
-  #
-  # become
-  #
-  #    ~            -1         T
-  #    D  = Q   D   R   = [ 0 I ]  or [ I ],
-  #     12   12  12  12
-  #
-  #    ~            T
-  #    D  = R   D   Q   = [ 0 I ] or [ I ].
-  #     21   21  21  21
-  #
-  # This transformation together with the algorithm in [1] solves
-  # the general problem (see [2] for example). 
+
+  ## Written by A. S. Hodel
+  ## Updated by John Ingram July 1996 to accept structured systems
+
+  ## Revised by Kai P Mueller April 1998 to solve the general H_infinity
+  ## problem using unitary transformations Q (on w and z)
+  ## and non-singular transformations R (on u and y) such
+  ## that the Dzu and Dyw matrices of the transformed plant
+  ## 
+  ##    ~
+  ##    P  (the variable Asys here)
+  ##
+  ## become
+  ##
+  ##    ~            -1         T
+  ##    D  = Q   D   R   = [ 0 I ]  or [ I ],
+  ##     12   12  12  12
+  ##
+  ##    ~            T
+  ##    D  = R   D   Q   = [ 0 I ] or [ I ].
+  ##     21   21  21  21
+  ##
+  ## This transformation together with the algorithm in [1] solves
+  ## the general problem (see [2] for example). 
 
   if (nargin < 3) | (nargin > 4)
     usage("[retval,dgkf_struct] = is_dgkf(Asys,nu,ny{,tol})");
   elseif (! is_scalar(nu) | ! is_scalar(ny) )
     error("is_dgkf: arguments 2 and 3 must be scalars")
   elseif (! is_struct(Asys) )
     error("Argument 1 must be a system data structure");
   endif
@@ -144,101 +145,101 @@ function [retval,dgkf_struct] = is_dgkf(
   elseif( ny >= nout )
     error("is_dgkf: insufficient number of regulated outputs");
   endif
 
   nw = nin - nu;           nw1 = nw + 1;
   nz = nout - ny;          nz1 = nz + 1;
 
   [A,B,C,D] = sys2ss(Asys);
-  # scale input/output for numerical reasons
+  ## scale input/output for numerical reasons
   if(norm(C,'fro')*norm(B,'fro') == 0)
     error("||C||*||B|| = 0; no dynamic connnection from inputs to outputs");
   endif
   xx = sqrt(norm(B, Inf) / norm(C, Inf));
   B = B / xx;  C = C * xx;
 
-  # partition matrices
+  ## partition matrices
   			Bw = B(:,1:nw);		Bu = B(:,nw1:nin);
   Cz = C(1:nz,:);	Dzw = D(1:nz,1:nw);	Dzu = D(1:nz,nw1:nin);
   Cy = C(nz1:nout,:);	Dyw = D(nz1:nout,1:nw);	Dyu = D(nz1:nout,nw1:nin);
 
-  # Check for loopo shifting
+  ## Check for loopo shifting
   Dyu_nz = (norm(Dyu,Inf) != 0);
   if (Dyu_nz)
     warning("is_dgkf: D22 nonzero; performing loop shifting");
   endif
 
-  # 12 - rank condition at w = 0
+  ## 12 - rank condition at w = 0
   xx =[A, Bu; Cz, Dzu];
   [nr, nc] = size(xx);
   irank = rank(xx);
   if (irank != nc)
     retval = 0;
     warning(sprintf("rank([A Bu; Cz Dzu]) = %d, need %d; n=%d, nz=%d, nu=%d", ...
 	irank,nc,(Anc+Anz),nz,nu));
     warning(" *** 12-rank condition violated at w = 0.");
   endif
 
-  # 21 - rank condition at w = 0
+  ## 21 - rank condition at w = 0
   xx =[A, Bw; Cy, Dyw];
   [nr, nc] = size(xx);
   irank = rank(xx);
   if (irank != nr)
     retval = 0;
     warning(sprintf("rank([A Bw; Cy Dyw]) = %d, need %d; n=%d, ny=%d, nw=%d", ...
 	irank,nr,(Anc+Anz),ny,nw));
     warning(" *** 21-rank condition violated at w = 0.");
   endif
 
-  # can Dzu be transformed to become [0 I]' or [I]?
-  # This ensures a normalized weight
+  ## can Dzu be transformed to become [0 I]' or [I]?
+  ## This ensures a normalized weight
   [Qz, Ru] = qr(Dzu);
   irank = rank(Ru);
   if (irank != nu)
     retval = 0;
     warning(sprintf("*** rank(Dzu(%d x %d) = %d", nz, nu, irank));
     warning(" *** Dzu does not have full column rank.");
   endif
   if (nu >= nz)
     Qz = Qz(:,1:nu)';
   else
     Qz = [Qz(:,(nu+1):nz), Qz(:,1:nu)]';
   endif
   Ru = Ru(1:nu,:);
 
-  # can Dyw be transformed to become [0 I] or [I]?
-  # This ensures a normalized weight
+  ## can Dyw be transformed to become [0 I] or [I]?
+  ## This ensures a normalized weight
   [Qw, Ry] = qr(Dyw');
   irank = rank(Ry);
   if (irank != ny)
     retval = 0;
     warning(sprintf("*** rank(Dyw(%d x %d) = %d", ny, nw, irank));
     warning(" *** Dyw does not have full row rank.");
   endif
 
   if (ny >= nw)
     Qw = Qw(:,1:ny);
   else
     Qw = [Qw(:,(ny+1):nw), Qw(:,1:ny)];
   endif
   Ry = Ry(1:ny,:)';
 
-  # transform P by Qz/Ru and Qw/Ry
+  ## transform P by Qz/Ru and Qw/Ry
   Bw  = Bw*Qw;
   Bu  = Bu/Ru;
   B   = [Bw, Bu];
   Cz  = Qz*Cz;
   Cy  = Ry\Cy;
   C   = [Cz; Cy];
   Dzw = Qz*Dzw*Qw;
   Dzu = Qz*Dzu/Ru;
   Dyw = Ry\Dyw*Qw;
 
-  # pack the return structure
+  ## pack the return structure
   dgkf_struct.nw	= nw;
   dgkf_struct.nu	= nu;
   dgkf_struct.nz	= nz;
   dgkf_struct.ny	= ny;
   dgkf_struct.A		= A;
   dgkf_struct.Bw	= Bw;
   dgkf_struct.Bu	= Bu;
   dgkf_struct.Cz	= Cz;
diff --git a/scripts/control/is_digital.m b/scripts/control/is_digital.m
--- a/scripts/control/is_digital.m
+++ b/scripts/control/is_digital.m
@@ -1,25 +1,25 @@
-# Copyright (C) 1996, 1999 Auburn University.  All Rights Reserved
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1996, 1999 Auburn University.  All Rights Reserved
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
  
 ## -*- texinfo -*-
 ## @deftypefn {Function File } { @var{retval} =} is_digital ( @var{sys})
 ## Return nonzero if system is digital;
 ##  inputs:
 ##    sys: system data structure
 ##    eflg: 0 [default] exit with an error if system is mixed (continuous and
 ##            discrete components)
@@ -28,37 +28,38 @@
 ##  outputs:
 ##    DIGITAL:  0: system is purely continuous
 ##           :  1: system is purely discrete
 ##           : -1: system is mixed continuous and discrete
 ## Exits with an error of sys is a mixed (continuous and discrete) system
 ## @end deftypefn
 
 function DIGITAL = is_digital(sys,eflg)
-# a s hodel July 1996
+
+  ## a s hodel July 1996
 
   switch(nargin)
   case(1),  eflg = 0;
   case(2),  
     if( isempty(find(eflg == [0, 1, 2])) )
       error("Illegal value of eflg=%d (%e)",eflg,eflg);
     endif
   otherwise,
     usage("DIGITAL = is_digital(sys{,eflg})");
   endswitch
 
-  # checked for sampled data system (mixed)
-  # discrete system
+  ## checked for sampled data system (mixed)
+  ## discrete system
   sysyd = sysgetsignals(sys,"yd");
   [nn,nz] = sysdimensions(sys);
   cont = sum(sysyd == 0) + nn;
   tsam = sysgettsam(sys);
   dig = sum(sysyd != 0) + nz + tsam;
 
-  # check for mixed system
+  ## check for mixed system
   if( cont*dig != 0)
    switch(eflg)
    case(0),
      error("continuous/discrete system; use syscont, sysdisc, or c2d first");
    case(1),
      warning("is_digital: mixed continuous/discrete system");
    endswitch
    dig_sign = -1;
diff --git a/scripts/control/is_observable.m b/scripts/control/is_observable.m
--- a/scripts/control/is_observable.m
+++ b/scripts/control/is_observable.m
@@ -1,25 +1,25 @@
-# Copyright (C) 1993, 1994, 1995 Auburn University.  All Rights Reserved
-# 
-# This file is part of Octave.
-# 
-# Octave is free software; you can redistribute it and/or modify it
-# under the terms of the GNU General Public License as published by the
-# Free Software Foundation; either version 2, or (at your option) any
-# later version.
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License
-# along with Octave; see the file COPYING.  If not, write to the Free
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
+## Copyright (C) 1993, 1994, 1995 Auburn University.  All Rights Reserved
+## 
+## This file is part of Octave.
+## 
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File } { [@var{retval},@var{U}] =} is_observable (@var{a}, @var{c}@{,@var{tol}@})
 ## @deftypefnx {Function File } { [@var{retval},@var{U}] =} is_observable (@var{sys}@{, @var{tol}@})
 ## Logical check for system observability.  
 ##  
 ##  Default: tol = 10*norm(a,'fro')*eps
 ## 
@@ -29,33 +29,23 @@
 ## @strong{See} @code{is_controllable} for detailed description of arguments
 ## and default values.
 ## @end deftypefn
 
 ## See also: size, rows, columns, length, is_matrix, is_scalar, is_vector.
 
 function [retval,U] = is_observable (a,c,tol)
 
-# [retval,U] = is_observable (a,c,tol)
-# usage: is_observable (a , c {,tol})
-#     or is_observable (sys {,tol})
-#
-#
-# Returns 1 if the system, a, is observable, 1 if the pair (a, c) is 
-# observable, or 0 if not.
-#
-
-
-# Written by A. S. Hodel (scotte@eng.auburn.edu) August 1993.
-# Updated by John Ingram (ingraje@eng.auburn.edu) July 1996.
+  ## Written by A. S. Hodel (scotte@eng.auburn.edu) August 1993.
+  ## Updated by John Ingram (ingraje@eng.auburn.edu) July 1996.
 
   if( nargin < 1) 
     usage("[retval,U] = is_observable(a , c {, tol})");
   elseif(is_struct(a))
-    # system form
+    ## system form
     if(nargin == 2)
       tol = c;
     elseif(nargin > 2)
       usage("[retval,U] = is_observable(sys {, tol})");
     endif
     [a,b,c] = sys2ss(a);
   elseif(nargin > 3)
     usage("[retval,U] = is_observable(a , c {, tol})");
diff --git a/scripts/control/is_sample.m b/scripts/control/is_sample.m
--- a/scripts/control/is_sample.m
+++ b/scripts/control/is_sample.m
@@ -1,30 +1,30 @@
-# Copyright (C) 1996 Auburn University.  All Rights Reserved
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1996 Auburn University.  All Rights Reserved
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File } { @var{retval} =} is_sample (@var{Ts}) 
 ##  return true if @var{Ts} is a legal sampling time
 ##  (real,scalar, > 0)
 ## @end deftypefn
  
 function out = is_sample(Ts)
-# A. S. Hodel July 1995
+## A. S. Hodel July 1995
 
 out = (is_scalar(Ts) && (Ts == abs(Ts)) && (Ts != 0) );
 
 endfunction
diff --git a/scripts/control/is_signal_list.m b/scripts/control/is_signal_list.m
--- a/scripts/control/is_signal_list.m
+++ b/scripts/control/is_signal_list.m
@@ -1,25 +1,25 @@
-# Copyright (C) 1996,1998 Auburn University.  All Rights Reserved
-#
-# This file is part of Octave.
-#
-# Octave is free software; you can redistribute it and/or modify it
-# under the terms of the GNU General Public License as published by the
-# Free Software Foundation; either version 2, or (at your option) any
-# later version.
-#
-# Octave is distributed in the hope that it will be useful, but WITHOUT
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-# for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Octave; see the file COPYING.  If not, write to the Free
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
+## Copyright (C) 1996,1998 Auburn University.  All Rights Reserved
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
+##
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+## for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File } {@var{flg} =} is_signal_list (@var{mylist})
 ## Returns true if mylist is a list of individual strings (legal for input
 ## to @var{syssetsignals}).
 ## @end deftypefn
 
 function flg = is_signal_list(mylist)
diff --git a/scripts/control/is_siso.m b/scripts/control/is_siso.m
--- a/scripts/control/is_siso.m
+++ b/scripts/control/is_siso.m
@@ -1,37 +1,37 @@
-# Copyright (C) 1996 Auburn University.  All Rights Reserved
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1996 Auburn University.  All Rights Reserved
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File } { @var{retval} =} is_siso (@var{sys}) 
 ## return nonzero if the system data structure 
 ## @var{sys} is single-input, single-output.
 ## @end deftypefn
  
 function  SISO = is_siso(sys)
-# function SISO = is_siso(sys)
-# return nonzero if the system sys is single-input, single-output.
+## function SISO = is_siso(sys)
+## return nonzero if the system sys is single-input, single-output.
 
-# a s hodel July 1996, 1998
+## a s hodel July 1996, 1998
 
   if(nargin != 1)
     usage("SISO = is_siso(sys)");
   elseif( !is_struct(sys))
     error("input must be a system structure (see ss2sys, tf2sys, zp2sys)");
   endif
 
   [n,nz,m,p] = sysdimensions(sys);
diff --git a/scripts/control/is_stabilizable.m b/scripts/control/is_stabilizable.m
--- a/scripts/control/is_stabilizable.m
+++ b/scripts/control/is_stabilizable.m
@@ -1,25 +1,25 @@
-# Copyright (C) 1993, 1994, 1995 Auburn University.  All Rights Reserved
-# 
-# This file is part of Octave.
-# 
-# Octave is free software; you can redistribute it and/or modify it
-# under the terms of the GNU General Public License as published by the
-# Free Software Foundation; either version 2, or (at your option) any
-# later version.
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License
-# along with Octave; see the file COPYING.  If not, write to the Free
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
+## Copyright (C) 1993, 1994, 1995 Auburn University.  All Rights Reserved
+## 
+## This file is part of Octave.
+## 
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File } {[@var{retval}, @var{U}] =} is_stabilizable (@var{sys}@{, @var{tol}@})
 ## @deftypefnx {Function File } {[@var{retval}, @var{U}] =} is_stabilizable (@var{a}@{, @var{b} ,@var{tol}@})
 ## Logical check for system stabilizability (i.e., all unstable modes are controllable).
 ## 
 ## 
 ## Test for stabilizability is performed via an ordered Schur decomposition
@@ -37,52 +37,53 @@
 ## @end example
 ## tol is a roundoff paramter, set to 200*eps if omitted.
 ## @end deftypefn
 
 ## See also: size, rows, columns, length, is_matrix, is_scalar, is_vector
 ##     is_observable, is_stabilizable, is_detectable
 
 function [retval,U] = is_stabilizable (a, b, tol)
-# Written by A. S. Hodel (scotte@eng.auburn.edu) August, 1993.
-# Updated by A. S. Hodel (scotte@eng.auburn.edu) Aubust, 1995 to use krylovb 
-# Updated by John Ingram (ingraje@eng.auburn.edu) July, 1996 to accept systems
+
+  ## Written by A. S. Hodel (scotte@eng.auburn.edu) August, 1993.
+  ## Updated by A. S. Hodel (scotte@eng.auburn.edu) Aubust, 1995 to use krylovb 
+  ## Updated by John Ingram (ingraje@eng.auburn.edu) July, 1996 to accept systems
 
   if(nargin < 1)        usage("[retval,U] = is_stabilizable(a {, b ,tol})");
   elseif(is_struct(a))
-    # sustem passed.
+    ## sustem passed.
     if(nargin == 2)
       tol = b;          % get tolerance
     elseif(nargin > 2)
       usage("[retval,U] = is_stabilizable(sys{,tol})");
     endif
     [a,b] = sys2ss(sys);
   else
-    # a,b arguments sent directly.
+    ## a,b arguments sent directly.
     if(nargin > 3)
       usage("[retval,U] = is_stabilizable(a {, b ,tol})");
     endif
   endif
 
   if(exist("tol"))
     [retval,U] = is_controllable(a,b,tol);
   else
     [retval,U] = is_controllable(a,b);
     tol = 1e2*rows(b)*eps;
   endif
   
   if( !retval & columns(U) > 0)
-    # now use an ordered Schur decomposition to get an orthogonal
-    # basis of the unstable subspace...
+    ## now use an ordered Schur decomposition to get an orthogonal
+    ## basis of the unstable subspace...
     n = rows(a);
     [ua,s] = schur(-(a+eye(n)*tol),'A');
     k = sum( real(eig(a)) >= 0 );	# count unstable poles 
 
     if( k > 0 )
       ua = ua(:,1:k);
-      # now see if span(ua) is contained in span(U)
+      ## now see if span(ua) is contained in span(U)
       retval = (norm(ua - U*U'*ua) < tol);
     else
       retval = 1;			# all poles stable
     endif
   endif
 
 endfunction
diff --git a/scripts/control/is_stable.m b/scripts/control/is_stable.m
--- a/scripts/control/is_stable.m
+++ b/scripts/control/is_stable.m
@@ -1,25 +1,25 @@
-# Copyright (C) 1993, 1994, 1995 Auburn University.  All Rights Reserved
-# 
-# This file is part of Octave.
-# 
-# Octave is free software; you can redistribute it and/or modify it
-# under the terms of the GNU General Public License as published by the
-# Free Software Foundation; either version 2, or (at your option) any
-# later version.
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License
-# along with Octave; see the file COPYING.  If not, write to the Free
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
+## Copyright (C) 1993, 1994, 1995 Auburn University.  All Rights Reserved
+## 
+## This file is part of Octave.
+## 
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File } { @var{retval} =} is_stable (@var{a}@{,@var{tol},@var{dflg}@})
 ## @deftypefnx {Function File } { @var{retval} =} is_stable (@var{sys}@{,@var{tol}@})
 ##  Returns retval = 1 if the matrix @var{a} or the system @var{sys}
 ## is stable, or 0 if not.
 ## 
 ## @strong{Inputs}
@@ -37,23 +37,24 @@
 ## @end table
 ## @end table
 ## @end deftypefn
 
 ## See also: size, rows, columns, length, is_matrix, is_scalar, is_vector
 ##     is_observable, is_stabilizable, is_detectable, krylov, krylovb
 
 function retval = is_stable (a, tol, disc)
-# Written by A. S. Hodel (scotte@eng.auburn.edu) August, 1993.
-# Updated by John Ingram (ingraje@eng.auburn.edu) July, 1996 for systems
-# Updated to simpler form by a.s.hodel 1998
+
+  ## Written by A. S. Hodel (scotte@eng.auburn.edu) August, 1993.
+  ## Updated by John Ingram (ingraje@eng.auburn.edu) July, 1996 for systems
+  ## Updated to simpler form by a.s.hodel 1998
 
   if( (nargin < 1) | (nargin > 3) )   usage("is_stable(a {,tol,disc})");
   elseif(is_struct(a))
-    # system was passed
+    ## system was passed
     if(nargin < 3)			disc = is_digital(a);
     elseif(disc != is_digital(a))
       warning("is_stable: disc =%d does not match system",disc)
     endif
     sys = sysupdate(a,"ss");
     a = sys2ss(sys);
   else
     if(nargin < 3)		disc = 0;		endif
diff --git a/scripts/control/jet707.m b/scripts/control/jet707.m
--- a/scripts/control/jet707.m
+++ b/scripts/control/jet707.m
@@ -1,43 +1,43 @@
-# Copyright (C) 1997 Kai P. Mueller
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1997 Kai P. Mueller
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File } { @var{outsys}  =} jet707 ( ) 
 ##  Creates linearized state space model of a Boeing 707-321 aircraft
 ##  at v=80m/s. (M = 0.26, Ga0 = -3 deg, alpha0 = 4 deg, kappa = 50 deg)
 ##  System inputs:   (1) thrust   and (2) elevator angle
 ##  System outputs:  (1) airspeed and (2) pitch angle
 ##  Ref: R. Brockhaus: Flugregelung (Flight Control), Springer, 1994
 ## 
 ##  see also: ord2
 ## 
 ## Contributed by Kai Mueller
 ## @end deftypefn
-
  
 function outsys = jet707()
-  # Written by Kai P. Mueller September 28, 1997
-  # Updates
+
+  ## Written by Kai P. Mueller September 28, 1997
+  ## Updates
 
   if (nargin != 0)
     usage("outsys = jet707()")
   endif
   if (nargin > 1)
     usage("outsys = jet707()")
   endif
 
diff --git a/scripts/control/lqe.m b/scripts/control/lqe.m
--- a/scripts/control/lqe.m
+++ b/scripts/control/lqe.m
@@ -1,25 +1,25 @@
-# Copyright (C) 1993, 1994, 1995 Auburn University.  All Rights Reserved
-# 
-# This file is part of Octave.
-# 
-# Octave is free software; you can redistribute it and/or modify it
-# under the terms of the GNU General Public License as published by the
-# Free Software Foundation; either version 2, or (at your option) any
-# later version.
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License
-# along with Octave; see the file COPYING.  If not, write to the Free
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
+## Copyright (C) 1993, 1994, 1995 Auburn University.  All Rights Reserved
+## 
+## This file is part of Octave.
+## 
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{k}, @var{p}, @var{e}] =} lqe (@var{a}, @var{g}, @var{c}, @var{sigw}, @var{sigv}, @var{z})
 ## Construct the linear quadratic estimator (Kalman filter) for the
 ## continuous time system
 ## @iftex
 ## @tex
 ## $$
@@ -82,24 +82,24 @@
 ## @end iftex
 ## @ifinfo
 ## (@var{a} - @var{k}@var{c}).
 ## @end ifinfo
 ## @end table
 ## @end deftypefn
 
 function [k, p, e] = lqe (a, g, c, sigw, sigv, zz)
-# Written by A. S. Hodel (scotte@eng.auburn.edu) August, 1993.
+## Written by A. S. Hodel (scotte@eng.auburn.edu) August, 1993.
 
   if ( (nargin != 5) && (nargin != 6))
     error ("lqe: invalid number of arguments");
   endif
 
-# The problem is dual to the regulator design, so transform to lqr
-# call.
+## The problem is dual to the regulator design, so transform to lqr
+## call.
 
   if (nargin == 5)
     [k, p, e] = lqr (a', c', g*sigw*g', sigv);
   else
     [k, p, e] = lqr (a', c', g*sigw*g', sigv, g*zz);
   endif
 
   k = k';
diff --git a/scripts/control/lqg.m b/scripts/control/lqg.m
--- a/scripts/control/lqg.m
+++ b/scripts/control/lqg.m
@@ -1,25 +1,25 @@
-# Copyright (C) 1996, 1997 Auburn University.  All Rights Reserved
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1996, 1997 Auburn University.  All Rights Reserved
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
  
 ## -*- texinfo -*-
 ## @deftypefn {Function File } {[@var{K}, @var{Q}, @var{P}, @var{Ee}, @var{Er}] =} lqg(@var{sys}, @var{Sigw}, @var{Sigv}, @var{Q}, @var{R}, @var{in_idx})
 ## Design a linear-quadratic-gaussian optimal controller for the system
 ## @example
 ## dx/dt = A x + B u + G w       [w]=N(0,[Sigw 0    ])
 ##     y = C x + v               [v]  (    0   Sigv ])
 ## @end example
@@ -57,94 +57,95 @@
 ## @item    Es
 ## controller poles
 ## @end table
 ## @end deftypefn
 
 ## See also:  h2syn, lqe, lqr
 
 function [K,Q1,P1,Ee,Er] = lqg(sys,Sigw,Sigv,Q,R,input_list)
-# Written by A. S. Hodel August 1995; revised for new system format
-# August 1996
 
-sav_val = implicit_str_to_num_ok;
-implicit_str_to_num_ok = 1;
+  ## Written by A. S. Hodel August 1995; revised for new system format
+  ## August 1996
 
-if ( (nargin < 5) | (nargin > 6))
-  usage("[K,Q1,P1,Ee,Er] = lqg(sys,Sigw, Sigv,Q,R{,input_list})");
+  sav_val = implicit_str_to_num_ok;
+  implicit_str_to_num_ok = 1;
 
-elseif(!is_struct(sys) )
-  error("sys must be in system data structure");
-endif
+  if ( (nargin < 5) | (nargin > 6))
+    usage("[K,Q1,P1,Ee,Er] = lqg(sys,Sigw, Sigv,Q,R{,input_list})");
 
-DIG = is_digital(sys);
-[A,B,C,D,tsam,n,nz,stname,inname,outname] = sys2ss(sys);
-[n,nz,nin,nout] = sysdimensions(sys);
-if(nargin == 5)
-  #construct default input_list
-  input_list = (columns(Sigw)+1):nin;
-endif
+  elseif(!is_struct(sys) )
+    error("sys must be in system data structure");
+  endif
 
-if( !(n+nz) )
-    error(["lqg: 0 states in system"]);
+  DIG = is_digital(sys);
+  [A,B,C,D,tsam,n,nz,stname,inname,outname] = sys2ss(sys);
+  [n,nz,nin,nout] = sysdimensions(sys);
+  if(nargin == 5)
+    ## construct default input_list
+    input_list = (columns(Sigw)+1):nin;
+  endif
 
-elseif(nin != columns(Sigw)+ columns(R))
-  error(["lqg: sys has ",num2str(nin)," inputs, dim(Sigw)=", ...
-	num2str(columns(Sigw)),", dim(u)=",num2str(columns(R))])
+  if( !(n+nz) )
+      error(["lqg: 0 states in system"]);
 
-elseif(nout != columns(Sigv))
-  error(["lqg: sys has ",num2str(nout)," outputs, dim(Sigv)=", ...
-	num2str(columns(Sigv)),")"])
-elseif(length(input_list) != columns(R))
-  error(["lqg: length(input_list)=",num2str(length(input_list)), ...
-	", columns(R)=", num2str(columns(R))]);
-endif
+  elseif(nin != columns(Sigw)+ columns(R))
+    error(["lqg: sys has ",num2str(nin)," inputs, dim(Sigw)=", ...
+	  num2str(columns(Sigw)),", dim(u)=",num2str(columns(R))])
 
-varname = list("Sigw","Sigv","Q","R");
-for kk=1:length(varname);
-  eval(sprintf("chk = is_square(%s);",nth(varname,kk)));
-  if(! chk ) error("lqg: %s is not square",nth(varname,kk)); endif
-endfor
+  elseif(nout != columns(Sigv))
+    error(["lqg: sys has ",num2str(nout)," outputs, dim(Sigv)=", ...
+	  num2str(columns(Sigv)),")"])
+  elseif(length(input_list) != columns(R))
+    error(["lqg: length(input_list)=",num2str(length(input_list)), ...
+	  ", columns(R)=", num2str(columns(R))]);
+  endif
+
+  varname = list("Sigw","Sigv","Q","R");
+  for kk=1:length(varname);
+    eval(sprintf("chk = is_square(%s);",nth(varname,kk)));
+    if(! chk ) error("lqg: %s is not square",nth(varname,kk)); endif
+  endfor
 
-# permute (if need be)
-if(nargin == 6)
-  all_inputs = sysreorder(nin,input_list);
-  B = B(:,all_inputs);
-  inname = inname(all_inputs);
-endif
+  ## permute (if need be)
+  if(nargin == 6)
+    all_inputs = sysreorder(nin,input_list);
+    B = B(:,all_inputs);
+    inname = inname(all_inputs);
+  endif
 
-# put parameters into correct variables
-m1 = columns(Sigw);
-m2 = m1+1;
-G = B(:,1:m1);
-B = B(:,m2:nin);
+  ## put parameters into correct variables
+  m1 = columns(Sigw);
+  m2 = m1+1;
+  G = B(:,1:m1);
+  B = B(:,m2:nin);
 
-# now we can just do the design; call dlqr and dlqe, since all matrices
-# are not given in Cholesky factor form (as in h2syn case)
-if(DIG)
-  [Ks, P1, Er] = dlqr(A,B,Q,R);
-  [Ke, Q1, jnk, Ee] = dlqe(A,G,C,Sigw,Sigv);
-else
-  [Ks, P1, Er] = lqr(A,B,Q,R);
-  [Ke, Q1, Ee] = lqe(A,G,C,Sigw,Sigv);
-endif
-Ac = A - Ke*C - B*Ks;
-Bc = Ke;
-Cc = -Ks;
-Dc = zeros(rows(Cc),columns(Bc));
+  ## now we can just do the design; call dlqr and dlqe, since all matrices
+  ## are not given in Cholesky factor form (as in h2syn case)
+  if(DIG)
+    [Ks, P1, Er] = dlqr(A,B,Q,R);
+    [Ke, Q1, jnk, Ee] = dlqe(A,G,C,Sigw,Sigv);
+  else
+    [Ks, P1, Er] = lqr(A,B,Q,R);
+    [Ke, Q1, Ee] = lqe(A,G,C,Sigw,Sigv);
+  endif
+  Ac = A - Ke*C - B*Ks;
+  Bc = Ke;
+  Cc = -Ks;
+  Dc = zeros(rows(Cc),columns(Bc));
 
-# fix state names
-stname1 = strappend(stname,"_e");
+  ## fix state names
+  stname1 = strappend(stname,"_e");
 
-# fix controller output names
-outname1 = strappend(inname(m2:nin),"_K");
+  ## fix controller output names
+  outname1 = strappend(inname(m2:nin),"_K");
 
-# fix controller input names
-inname1 = strappend(outname,"_K");
+  ## fix controller input names
+  inname1 = strappend(outname,"_K");
 
-if(DIG)
-  K = ss2sys(Ac,Bc,Cc,Dc,tsam,n,nz,stname1,inname1,outname1,1:rows(Cc));
-else
-  K = ss2sys(Ac,Bc,Cc,Dc,tsam,n,nz,stname,inname1,outname1);
-endif
+  if(DIG)
+    K = ss2sys(Ac,Bc,Cc,Dc,tsam,n,nz,stname1,inname1,outname1,1:rows(Cc));
+  else
+    K = ss2sys(Ac,Bc,Cc,Dc,tsam,n,nz,stname,inname1,outname1);
+  endif
 
-implicit_str_to_num_ok = sav_val;
+  implicit_str_to_num_ok = sav_val;
 endfunction
diff --git a/scripts/control/lqr.m b/scripts/control/lqr.m
--- a/scripts/control/lqr.m
+++ b/scripts/control/lqr.m
@@ -1,25 +1,25 @@
-# Copyright (C) 1993, 1994, 1995 Auburn University.  All Rights Reserved
-# 
-# This file is part of Octave.
-# 
-# Octave is free software; you can redistribute it and/or modify it
-# under the terms of the GNU General Public License as published by the
-# Free Software Foundation; either version 2, or (at your option) any
-# later version.
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License
-# along with Octave; see the file COPYING.  If not, write to the Free
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
+## Copyright (C) 1993, 1994, 1995 Auburn University.  All Rights Reserved
+## 
+## This file is part of Octave.
+## 
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{k}, @var{p}, @var{e}] =} lqr (@var{a}, @var{b}, @var{q}, @var{r}, @var{z})
 ## construct the linear quadratic regulator for the continuous time system
 ## @iftex
 ## @tex
 ## $$
 ##  {dx\over dt} = A x + B u
@@ -107,67 +107,67 @@
 ## @end table
 ##
 ## @strong{Reference} 
 ## Anderson and Moore, OPTIMAL CONTROL: LINEAR QUADRATIC METHODS,
 ## Prentice-Hall, 1990, pp. 56-58
 ## @end deftypefn
 
 function [k, p, e] = lqr (a, b, q, r, s)
-# Written by A. S. Hodel (scotte@eng.auburn.edu) August 1993.
 
-  # disp("lqr: entry");
+  ## Written by A. S. Hodel (scotte@eng.auburn.edu) August 1993.
+
+  ## disp("lqr: entry");
 
   if ((nargin != 4) && (nargin != 5))
     error ("lqr: invalid number of arguments");
   endif
 
-# Check a.
+  ## Check a.
   if ((n = is_square (a)) == 0)
     error ("lqr: requires 1st parameter(a) to be square");
   endif
 
-# Check b.
+  ## Check b.
   [n1, m] = size (b);
   if (n1 != n)
     error ("lqr: a,b not conformal");
   endif
 
-# Check q.
-  
+  ## Check q.
   if ( ((n1 = is_square (q)) == 0) || (n1 != n))
     error ("lqr: q must be square and conformal with a");
   endif
 
-# Check r.
+  ## Check r.
   if ( ((m1 = is_square(r)) == 0) || (m1 != m))
     error ("lqr: r must be square and conformal with column dimension of b");
   endif
 
-# Check if n is there.
+  ## Check if n is there.
   if (nargin == 5)
     [n1, m1] = size (s);
     if ( (n1 != n) || (m1 != m))
       error ("lqr: z must be identically dimensioned with b");
     endif
 
-# Incorporate cross term into a and q.
+    ## Incorporate cross term into a and q.
     ao = a - (b/r)*s';
     qo = q - (s/r)*s';
   else
     s = zeros (n, m);
     ao = a;
     qo = q;
   endif
 
-# Check that q, (r) are symmetric, positive (semi)definite
+  ## Check that q, (r) are symmetric, positive (semi)definite
 
   if (is_symmetric (q) && is_symmetric (r) ...
       && all (eig (q) >= 0) && all (eig (r) > 0))
     p = are (ao, (b/r)*b', qo);
     k = r\(b'*p + s');
     e = eig (a - b*k);
   else
     error ("lqr: q (r) must be symmetric positive (semi) definite");
   endif
 
-  # disp("lqr: exit");
+  ## disp("lqr: exit");
 endfunction
diff --git a/scripts/control/lsim.m b/scripts/control/lsim.m
--- a/scripts/control/lsim.m
+++ b/scripts/control/lsim.m
@@ -1,25 +1,25 @@
-# Copyright (C) 1996 Auburn University.  All Rights Reserved
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1996 Auburn University.  All Rights Reserved
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File } { } lsim (@var{sys}, @var{u}, @var{t}@{,@var{x0}@})
 ## Produce output for a linear simulation of a system
 ## 
 ## Produces a plot for the output of the system, sys.
 ## 
 ## U is an array that contains the system's inputs.  Each column in u 
@@ -30,19 +30,19 @@
 ## 
 ## When the lsim function is invoked with output parameters:
 ## [y,x] = lsim(sys,u,t,[x0])
 ## a plot is not displayed, however, the data is returned in y = system output
 ## and x = system states.
 ## @end deftypefn
  
 function [y,x] = lsim(sys,u,t,x0)
-# Written by David Clem, A. S. Hodel July 1995
-# modified by John Ingram for system format August 1996
 
+  ## Written by David Clem, A. S. Hodel July 1995
+  ## modified by John Ingram for system format August 1996
 
   if((nargin < 3)||(nargin > 4))
     usage("[y,x] = lsim(sys,u,t[,x0])");
   endif
 
   if(!is_struct(sys))
     error("sys must be in system data structure");
   endif
@@ -68,29 +68,29 @@ function [y,x] = lsim(sys,u,t,x0)
   endif
 
   Ts = 0;
   t(2)-t(1);
   u=u';
   n = max(size(t));
   for ii = 1:(n-1)
 
-    # check if step size changed
+    ## check if step size changed
     if (t(ii+1) - t(ii) != Ts)
       Ts = t(ii+1) - t(ii);
-      # [F,G] = c2d(a,b,Ts);
+      ## [F,G] = c2d(a,b,Ts);
       dsys = c2d(sys, Ts);
       [F,G] = sys2ss(dsys);
     endif
 
     x(:,ii) = x0;
     x0 = F*x0 + G*u(:,ii);
   endfor
 
-  # pick up last point
+  ## pick up last point
   x(:,n) = x0;
 
   y = c*x + d*u;
   if(nargout == 0)
    plot(t,y);
    y=[];
    x=[];
   endif
diff --git a/scripts/control/ltifr.m b/scripts/control/ltifr.m
--- a/scripts/control/ltifr.m
+++ b/scripts/control/ltifr.m
@@ -1,25 +1,25 @@
-# Copyright (C) 1996 Auburn University.  All Rights Reserved
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1996 Auburn University.  All Rights Reserved
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
  
 ## -*- texinfo -*-
 ## @deftypefn {Function File } {@var{out} =} ltifr (@var{A}, @var{B}, @var{w})
 ## @deftypefnx {Function File } {@var{out} =} ltifr (@var{sys}, @var{w})
 ## Linear time invariant frequency response of single input systems
 ## @strong{Inputs}
 ## @table @var
 ## @item A, B
@@ -34,18 +34,19 @@
 ## @example
 ##                            -1
 ##             G(s) = (jw I-A) B
 ## @end example
 ## for complex frequencies @math{s = jw}.
 ## @end deftypefn
 
 function out = ltifr(a,b,w)
-  # R. B. Tenison, D. Clem, A. S. Hodel, July 1995
-  # updated by John Ingram August 1996 for system format
+
+  ## R. B. Tenison, D. Clem, A. S. Hodel, July 1995
+  ## updated by John Ingram August 1996 for system format
   
   if ((nargin < 2) || (nargin > 3))
     error("incorrect number of input arguments");
   endif
 
   if (nargin == 2)
     sys = a;
     w = b;
diff --git a/scripts/control/mb.m b/scripts/control/mb.m
--- a/scripts/control/mb.m
+++ b/scripts/control/mb.m
@@ -1,28 +1,28 @@
-# Copyright (C) 1996,1998 Auburn University.  All Rights Reserved
-#
-# This file is part of Octave.
-#
-# Octave is free software; you can redistribute it and/or modify it
-# under the terms of the GNU General Public License as published by the
-# Free Software Foundation; either version 2, or (at your option) any
-# later version.
-#
-# Octave is distributed in the hope that it will be useful, but WITHOUT
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-# for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Octave; see the file COPYING.  If not, write to the Free
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
+## Copyright (C) 1996,1998 Auburn University.  All Rights Reserved
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
+##
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+## for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
-# I think that this m-file can be deleted
-# a.s.hodel@eng.auburn.edu - 4 Dec. 1998
+## I think that this m-file can be deleted
+## a.s.hodel@eng.auburn.edu - 4 Dec. 1998
 
 Ap = [0, 1;1960, 0];
 Bp = [0;-6261];
 Cp = [1, 0];
 Dp = 0;
 
 Gp = ss2sys(Ap,Bp,Cp,Dp,0,2,0,[],"delta_i","delta_y");
 Gp = syssetsignals(Gp,"st","delta_x1",1);
@@ -35,27 +35,27 @@ Dk = 0;
 
 Gk = ss2sys(Ak,Bk,Ck,Dk,0,2,0,[],"y","i");
 Gk = syssetsignals(Gk,"st","x1",1);
 Gk = syssetsignals(Gk,"st","x2",2);
 
 Gc = sysgroup(Gp,Gk);
 
 Gc = sysdup(Gc,[],[1, 2]);
-# Gc = sysscale(Gc,[],diag([1,1,1,1]));
+## Gc = sysscale(Gc,[],diag([1,1,1,1]));
 
 Gc = sysconnect(Gc,[1, 2],[4, 3]);
 Gc = sysprune(Gc,1,[1, 2]);
 
 disp("after pruning, closed loop system is")
 sysout(Gc)
 
-# Gc = sysdup(Gc,[],2);
-# Gc = sysconnect(Gc,1,3);
-# Gc = sysprune(Gc,1,1);
+## Gc = sysdup(Gc,[],2);
+## Gc = sysconnect(Gc,1,3);
+## Gc = sysprune(Gc,1,1);
 
 is_stable(Gc)
 Gca = sys2ss(Gc);
 eig(Gca)
 
 [Gpa,Gpb,Gpc,Gpd] = sys2ss(Gp);
 [Gka,Gkb,Gkc,Gkd] = sys2ss(Gk);
 Acl = [Gpa, -Gpb*Gkc; Gkb*Gpc, Gka]
diff --git a/scripts/control/minfo.m b/scripts/control/minfo.m
--- a/scripts/control/minfo.m
+++ b/scripts/control/minfo.m
@@ -1,84 +1,85 @@
-# Copyright (C) 1996 Auburn University.  All Rights Reserved
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1996 Auburn University.  All Rights Reserved
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
  
+##  function [systype, nout, nin, ncstates, ndstates] = minfo(inmat)
+##
+## MINFO:  Determines the type of system matrix.  INMAT can be
+##         a varying(*), system, constant, and empty matrix.
+##
+##    Returns:
+##      systype can be one of:
+##            varying, system, constant, and empty
+##      nout is the number of outputs of the system
+##      nin is the number of inputs of the system
+##      ncstates is the number of continuous states of the system
+##	 ndstates is the number of discrete states of the system
+
 function [systype, nout, nin, ncstates, ndstates] = minfo(inmat)
-  #  function [systype, nout, nin, ncstates, ndstates] = minfo(inmat)
-  #
-  # MINFO:  Determines the type of system matrix.  INMAT can be
-  #         a varying(*), system, constant, and empty matrix.
-  #
-  #    Returns:
-  #      systype can be one of:
-  #            varying, system, constant, and empty
-  #      nout is the number of outputs of the system
-  #      nin is the number of inputs of the system
-  #      ncstates is the number of continuous states of the system
-  #	 ndstates is the number of discrete states of the system
 
-  # Written by R. Bruce Tenison July 29, 1994
-  # Modified by David Clem November 13, 1994
-  # Modified by A. S. Hodel July 1995
+  ## Written by R. Bruce Tenison July 29, 1994
+  ## Modified by David Clem November 13, 1994
+  ## Modified by A. S. Hodel July 1995
 
   warning("minfo: obsolete.  Use sys2ss, sys2tf, or sys2zp.");
     
   if (nargin ~= 1 )
     disp('MINFO: Wrong number of arguments')
     systype = nout = nin = ncstates = ndstates = [];
   endif
   
   [rr,cc] = size(inmat);
   
-  # Check for empty matrix first!
+  ## Check for empty matrix first!
   if (isempty(inmat))
     systype = "empty";
     nout = nin = ncstates = ndstates = 0;
     return
   
-  # Check for Constant matrix
+  ## Check for Constant matrix
 
   elseif (rr == 1 || cc == 1)
     systype = "constant";
     nout = nin = ncstates = ndstates = 1;
     return
   
-  # Check for system type matrix
+  ## Check for system type matrix
   elseif (inmat(rr,cc) == -Inf)
     systype = "system";
     ncstates = inmat(1,cc);
     ndstates = inmat(rr,1);
     nstates = ncstates + ndstates;
     nout = rr - nstates - 1;
     nin = cc - nstates - 1;
   
-  # Check for Varying type matrix
+  ## Check for Varying type matrix
   elseif (inmat(rr,cc) == Inf)
     systype = "varying";
     npoints = inmat(rr,cc-1);
     nin = cc - 1;
     nout = rr / npoints;
     nstates = 0;
 
-    # Must be a standard matrix
+    ## Must be a standard matrix
   else
     systype = "constant";
     nin = cc;
     nout = rr;
     ncstates = 0;
     ndstates = 0;
   endif
 endfunction
diff --git a/scripts/control/moddemo.m b/scripts/control/moddemo.m
--- a/scripts/control/moddemo.m
+++ b/scripts/control/moddemo.m
@@ -1,38 +1,38 @@
-# Copyright (C) 1996 Auburn University.  All Rights Reserved
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1996 Auburn University.  All Rights Reserved
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File } { outputs =} moddemo ( inputs ) 
 ## @format
 ##  Octave Controls toolbox demo: Model Manipulations demo
 ##  Written by David Clem August 15, 1994
 ## 
 ## @end format
 ## @end deftypefn
  
 function moddemo()
-# Written by David Clem August 15, 1994
-# a s hodel: updated to reflect updated output order in ss2zp
+## Written by David Clem August 15, 1994
+## a s hodel: updated to reflect updated output order in ss2zp
 
   while (1)
     clc
     disp('Octave Model Manipulations Demo')
     disp('=======================================')
     disp('  1)  Perform continuous to discrete time conversion (c2d)')
     disp('  2)  Convert from state space to zero / pole form (ss2zp)')
     disp('      Convert from zero / pole to state space form (zp2ss)')
diff --git a/scripts/control/nichols.m b/scripts/control/nichols.m
--- a/scripts/control/nichols.m
+++ b/scripts/control/nichols.m
@@ -1,62 +1,63 @@
-# Copyright (C) 1998 Auburn University.  All Rights Reserved
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1998 Auburn University.  All Rights Reserved
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
  
-function [mag,phase,w] = nichols(sys,w,outputs,inputs)
-# [mag,phase,w] = nichols(sys[,w,outputs,inputs])
-# Produce Nichols plot of a system
-#
-# Compute the frequency response of a system.
-# inputs:
-#   sys: system data structure (must be either purely continuous or discrete;
+## [mag,phase,w] = nichols(sys[,w,outputs,inputs])
+## Produce Nichols plot of a system
+##
+## Compute the frequency response of a system.
+## inputs:
+##   sys: system data structure (must be either purely continuous or discrete;
 #	 see is_digital)
-#   w: frequency values for evaluation.
-#      if sys is continuous, then nichols evaluates G(jw)
-#      if sys is discrete, then nichols evaluates G(exp(jwT)), where T=sys.tsam
-#         (the system sampling time)
-#      default: the default frequency range is selected as follows: (These
-#        steps are NOT performed if w is specified)
-#          (1) via routine bodquist, isolate all poles and zeros away from
-#              w=0 (jw=0 or exp(jwT)=1) and select the frequency
-#             range based on the breakpoint locations of the frequencies.
-#          (2) if sys is discrete time, the frequency range is limited
-#              to jwT in [0,2p*pi]
-#          (3) A "smoothing" routine is used to ensure that the plot phase does
-#              not change excessively from point to point and that singular
-#              points (e.g., crossovers from +/- 180) are accurately shown.
-#   outputs, inputs: the indices of the output(s) and input(s) to be used in
-#     the frequency response; see sysprune.
-# outputs:
-#    mag, phase: the magnitude and phase of the frequency response
-#       G(jw) or G(exp(jwT)) at the selected frequency values.
-#    w: the vector of frequency values used
-# If no output arguments are given, nichols plots the results to the screen.
-# Descriptive labels are automatically placed.  See xlabel, ylable, title,
-# and replot.
-#
-# Note: if the requested plot is for an MIMO system, mag is set to
-# ||G(jw)|| or ||G(exp(jwT))|| and phase information is not computed.
+##   w: frequency values for evaluation.
+##      if sys is continuous, then nichols evaluates G(jw)
+##      if sys is discrete, then nichols evaluates G(exp(jwT)), where T=sys.tsam
+##         (the system sampling time)
+##      default: the default frequency range is selected as follows: (These
+##        steps are NOT performed if w is specified)
+##          (1) via routine bodquist, isolate all poles and zeros away from
+##              w=0 (jw=0 or exp(jwT)=1) and select the frequency
+##             range based on the breakpoint locations of the frequencies.
+##          (2) if sys is discrete time, the frequency range is limited
+##              to jwT in [0,2p*pi]
+##          (3) A "smoothing" routine is used to ensure that the plot phase does
+##              not change excessively from point to point and that singular
+##              points (e.g., crossovers from +/- 180) are accurately shown.
+##   outputs, inputs: the indices of the output(s) and input(s) to be used in
+##     the frequency response; see sysprune.
+## outputs:
+##    mag, phase: the magnitude and phase of the frequency response
+##       G(jw) or G(exp(jwT)) at the selected frequency values.
+##    w: the vector of frequency values used
+## If no output arguments are given, nichols plots the results to the screen.
+## Descriptive labels are automatically placed.  See xlabel, ylable, title,
+## and replot.
+##
+## Note: if the requested plot is for an MIMO system, mag is set to
+## ||G(jw)|| or ||G(exp(jwT))|| and phase information is not computed.
 
-  # check number of input arguments given
+function [mag,phase,w] = nichols(sys,w,outputs,inputs)
+
+  ## check number of input arguments given
   if (nargin < 1 | nargin > 4)
     usage("[mag,phase,w] = nichols(sys[,w,outputs,inputs])");
   endif
   if(nargin < 2)
     w = [];
   endif
   if(nargin < 3)
     outputs = [];
@@ -65,22 +66,22 @@ function [mag,phase,w] = nichols(sys,w,o
     inputs = [];
   endif
 
   [f, w] = bodquist(sys,w,outputs,inputs,"nichols");
 
   [stname,inname,outname] = sysgetsignals(sys);
   systsam = sysgettsam(sys);
 
-  # Get the magnitude and phase of f.
+  ## Get the magnitude and phase of f.
   mag = abs(f);
   phase = arg(f)*180.0/pi;
 
   if (nargout < 1),
-    # Plot the information
+    ## Plot the information
     if(gnuplot_has_multiplot)
       oneplot();
     endif
     gset autoscale;
     if(gnuplot_has_multiplot)
       gset nokey;
     endif
     clearplot();
diff --git a/scripts/control/nyquist.m b/scripts/control/nyquist.m
--- a/scripts/control/nyquist.m
+++ b/scripts/control/nyquist.m
@@ -1,154 +1,111 @@
-# Copyright (C) 1996,1998 Auburn University.  All Rights Reserved
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1996,1998 Auburn University.  All Rights Reserved
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
 
 ## -*- texinfo -*-
-##@deftypefn {Function File } {[@var{realp}, @var{imagp}, @var{w}] =} nyquist (@var{sys}@{, @var{w}, @var{out_idx}, @var{in_idx}, @var{atol}@})
-##@deftypefnx {Function File } {} nyquist (@var{sys}@{, @var{w}, @var{out_idx}, @var{in_idx}, @var{atol}@})
-##Produce Nyquist plots of a system; if no output arguments are given, Nyquist
-##plot is printed to the screen.
-##
-##Compute the frequency response of a system.
-##@strong{Inputs} (pass as empty to get default values)
-##@table
-##@item sys
-##       system data structure (must be either purely continuous or discrete;
-##       see is_digital)
-##@item w 
-##     frequency values for evaluation.
-##     if sys is continuous, then bode evaluates @math{G(jw)}
-##     if sys is discrete, then bode evaluates @math{G(exp(jwT))}, where 
-##        @math{@var{T}=sysgettsam(@var{sys})} (the system sampling time)
-##@item default
-##     the default frequency range is selected as follows: (These
-##     steps are NOT performed if @var{w} is specified)
-##@end table
-##@enumerate 
-##@item via routine bodquist, isolate all poles and zeros away from 
-##@var{w}=0 (@var{jw}=0 or @math{exp(@var{jwT})=1}) and select the frequency
-##range based on the breakpoint locations of the frequencies.
-##@item if @var{sys} is discrete time, the frequency range is limited
-##to @var{jwT} in 
-##@ifinfo
-##[0,2p*pi]
-##@end ifinfo
-##@iftex
-##$[0,2p*\pi]$
-##@end iftex
-##@item A "smoothing" routine is used to ensure that the plot phase does
-##             not change excessively from point to point and that singular
-##             points (e.g., crossovers from +/- 180) are accurately shown.
-##@end enumerate
-##  outputs, inputs: the indices of the output(s) and input(s) to be used in
-##    the frequency response; see sysprune.
-##
-##@strong{Inputs} (pass as empty to get default values)
-##@table @var
-##@item   atol
-##for interactive nyquist plots: atol is a change-in-slope tolerance 
-##for the of asymptotes (default = 0; 1e-2 is a good choice).  This allows
-##the user to ``zoom in'' on portions of the Nyquist plot too small to be
-##seen with large asymptotes.
-##@end table
-##@strong{Outputs}
-##@table @var
-##@item    realp, imagp
-##the real and imaginary parts of the frequency response
-##       @math{G(jw)} or @math{G(exp(jwT))} at the selected frequency values.
-##@item    w
-## the vector of frequency values used
-##@end table
-##
-## If no output arguments are given, nyquist plots the results to the screen.
-## If @var{atol} != 0 and asymptotes are detected then the user is asked 
-##    interactively if they wish to zoom in (remove asymptotes)
-## Descriptive labels are automatically placed.
-##
-## Note: if the requested plot is for an MIMO system, a warning message is
-## presented; the returned information is of the magnitude 
-## ||G(jw)|| or ||G(exp(jwT))|| only; phase information is not computed.
-##
-##@end deftypefn
+## @deftypefn {Function File } {[@var{realp}, @var{imagp}, @var{w}] =} nyquist (@var{sys}@{, @var{w}, @var{out_idx}, @var{in_idx}, @var{atol}@})
+## @deftypefnx {Function File } {} nyquist (@var{sys}@{, @var{w}, @var{out_idx}, @var{in_idx}, @var{atol}@})
+## Produce Nyquist plots of a system; if no output arguments are given, Nyquist
+## plot is printed to the screen.
+## 
+## Compute the frequency response of a system.
+## @strong{Inputs} (pass as empty to get default values)
+## @table
+## @item sys
+##        system data structure (must be either purely continuous or discrete;
+##        see is_digital)
+## @item w 
+##      frequency values for evaluation.
+##      if sys is continuous, then bode evaluates @math{G(jw)}
+##      if sys is discrete, then bode evaluates @math{G(exp(jwT))}, where 
+##         @math{@var{T}=sysgettsam(@var{sys})} (the system sampling time)
+## @item default
+##      the default frequency range is selected as follows: (These
+##      steps are NOT performed if @var{w} is specified)
+## @end table
+## @enumerate 
+## @item via routine bodquist, isolate all poles and zeros away from 
+## @var{w}=0 (@var{jw}=0 or @math{exp(@var{jwT})=1}) and select the frequency
+## range based on the breakpoint locations of the frequencies.
+## @item if @var{sys} is discrete time, the frequency range is limited
+## to @var{jwT} in 
+## @ifinfo
+## [0,2p*pi]
+## @end ifinfo
+## @iftex
+## $[0,2p*\pi]$
+## @end iftex
+## @item A "smoothing" routine is used to ensure that the plot phase does
+##              not change excessively from point to point and that singular
+##              points (e.g., crossovers from +/- 180) are accurately shown.
+## @end enumerate
+##   outputs, inputs: the indices of the output(s) and input(s) to be used in
+##     the frequency response; see sysprune.
+## 
+## @strong{Inputs} (pass as empty to get default values)
+## @table @var
+## @item   atol
+## for interactive nyquist plots: atol is a change-in-slope tolerance 
+## for the of asymptotes (default = 0; 1e-2 is a good choice).  This allows
+## the user to ``zoom in'' on portions of the Nyquist plot too small to be
+## seen with large asymptotes.
+## @end table
+## @strong{Outputs}
+## @table @var
+## @item    realp, imagp
+## the real and imaginary parts of the frequency response
+##        @math{G(jw)} or @math{G(exp(jwT))} at the selected frequency values.
+## @item    w
+##  the vector of frequency values used
+## @end table
+## 
+##  If no output arguments are given, nyquist plots the results to the screen.
+##  If @var{atol} != 0 and asymptotes are detected then the user is asked 
+##     interactively if they wish to zoom in (remove asymptotes)
+##  Descriptive labels are automatically placed.
+## 
+##  Note: if the requested plot is for an MIMO system, a warning message is
+##  presented; the returned information is of the magnitude 
+##  ||G(jw)|| or ||G(exp(jwT))|| only; phase information is not computed.
+## 
+## @end deftypefn
  
 function [realp,imagp,w] = nyquist(sys,w,outputs,inputs,atol)
-# [realp,imagp,w] = nyquist(sys[,w,outputs,inputs,atol])
-# Produce Nyquist plots of a system
-#
-# Compute the frequency response of a system.
-# inputs: (pass as empty to get default values
-#   sys: system data structure (must be either purely continuous or discrete;
-#        see is_digital)
-#   w: frequency values for evaluation.
-#      if sys is continuous, then bode evaluates G(jw)
-#      if sys is discrete, then bode evaluates G(exp(jwT)), where 
-#         T=sysgettsam(sys) (the system sampling time)
-#      default: the default frequency range is selected as follows: (These
-#        steps are NOT performed if w is specified)
-#          (1) via routine bodquist, isolate all poles and zeros away from 
-#              w=0 (jw=0 or exp(jwT)=1) and select the frequency
-#             range based on the breakpoint locations of the frequencies.
-#          (2) if sys is discrete time, the frequency range is limited
-#              to jwT in [0,2p*pi]
-#          (3) A "smoothing" routine is used to ensure that the plot phase does
-#              not change excessively from point to point and that singular
-#              points (e.g., crossovers from +/- 180) are accurately shown.
-#   outputs, inputs: the indices of the output(s) and input(s) to be used in
-#     the frequency response; see sysprune.
-#   atol: for interactive nyquist plots: atol is a change-in-angle tolerance 
-#     (in degrees) for the of asymptotes (default = 0; 1e-2 is a good choice).
-#     Consecutive points along the asymptotes whose angle is within atol of
-#     the angle between the largest two points are omitted for "zooming in"
-#
-# outputs:
-#    realp, imagp: the real and imaginary parts of the frequency response
-#       G(jw) or G(exp(jwT)) at the selected frequency values.
-#    w: the vector of frequency values used
-#
-# If no output arguments are given, nyquist plots the results to the screen.
-# If atol != 0 and asymptotes are detected then the user is asked 
-#    interactively if they wish to zoom in (remove asymptotes)
-# Descriptive labels are automatically placed.  See xlabel, ylable, title,
-# and replot.
-#
-# Note: if the requested plot is for an MIMO system, a warning message is
-# presented; the returned information is of the magnitude 
-# ||G(jw)|| or ||G(exp(jwT))|| only; phase information is not computed.
    
-  # By R. Bruce Tenison, July 13, 1994
-  # A. S. Hodel July 1995 (adaptive frequency spacing, 
-  #     remove acura parameter, etc.)
-  # Revised by John Ingram July 1996 for system format
-  #
+  ## By R. Bruce Tenison, July 13, 1994
+  ## A. S. Hodel July 1995 (adaptive frequency spacing, 
+  ##     remove acura parameter, etc.)
+  ## Revised by John Ingram July 1996 for system format
 
-  # Both bode and nyquist share the same introduction, so the common parts are 
-  # in a file called bodquist.m.  It contains the part that finds the 
-  # number of arguments, determines whether or not the system is SISO, and 
-  # computes the frequency response.  Only the way the response is plotted is
-  # different between the two functions.
+  ## Both bode and nyquist share the same introduction, so the common
+  ## parts are in a file called bodquist.m.  It contains the part that
+  ## finds the number of arguments, determines whether or not the system
+  ## is SISO, andd computes the frequency response.  Only the way the
+  ## response is plotted is different between the two functions.
 
   save_val = implicit_str_to_num_ok;	# save for later
   implicit_str_to_num_ok = 1;
 
-  # check number of input arguments given
+  ## check number of input arguments given
   if (nargin < 1 | nargin > 5)
     usage("[realp,imagp,w] = nyquist(sys[,w,outputs,inputs,atol])");
   endif
   if(nargin < 2)
     w = [];
   endif
   if(nargin < 3)
     outputs = [];
@@ -157,25 +114,25 @@ function [realp,imagp,w] = nyquist(sys,w
     inputs = [];
   endif
   if(nargin < 5)
     atol = 0;
   elseif(!(is_sample(atol) | atol == 0))
     error("atol must be a nonnegative scalar.")
   endif
 
-  # signal to bodquist who's calling
+  ## signal to bodquist who's calling
    
   [f,w] = bodquist(sys,w,outputs,inputs,"nyquist");
 
-  # Get the real and imaginary part of f.
+  ## Get the real and imaginary part of f.
   realp = real(f);
   imagp = imag(f);
 
-  # No output arguments, then display plot, otherwise return data.
+  ## No output arguments, then display plot, otherwise return data.
   if (nargout == 0)
     dnplot = 0;
     while(!dnplot)
       if(gnuplot_has_multiplot)
         oneplot();
         gset key;
       endif
       clearplot();
@@ -196,37 +153,37 @@ function [realp,imagp,w] = nyquist(sys,w
 	  nth(inn,1), nth(outn,1), w(1), w(length(w))) )
       endif
   
       gset nologscale xy;
 
       axis(axis2dlim([[vec(realp),vec(imagp)];[vec(realp),-vec(imagp)]]));
       plot(realp,imagp,"- ;+w;",realp,-imagp,"-@ ;-w;");
 
-      # check for interactive plots
+      ## check for interactive plots
       dnplot = 1; # assume done; will change later if atol is satisfied
       if(atol > 0 & length(f) > 2)
 
-        # check for asymptotes
+        ## check for asymptotes
         fmax = max(abs(f));
         fi = max(find(abs(f) == fmax));
         
-        # compute angles from point to point
+        ## compute angles from point to point
         df = diff(f);
         th = atan2(real(df),imag(df))*180/pi;
 
-        # get angle at fmax
+        ## get angle at fmax
         if(fi == length(f)) fi = fi-1; endif
         thm = th(fi);
     
-        # now locate consecutive angles within atol of thm
+        ## now locate consecutive angles within atol of thm
         ith_same = find(abs(th - thm) < atol);
         ichk = union(fi,find(diff(ith_same) == 1));
 
-        #locate max, min consecutive indices in ichk
+        ## locate max, min consecutive indices in ichk
         loval = max(complement(ichk,1:fi));
         if(isempty(loval)) loval = fi;
         else               loval = loval + 1;   endif
 
         hival = min(complement(ichk,fi:length(th)));
         if(isempty(hival))  hival = fi+1;      endif
 
         keep_idx = complement(loval:hival,1:length(w));
diff --git a/scripts/control/obsv.m b/scripts/control/obsv.m
--- a/scripts/control/obsv.m
+++ b/scripts/control/obsv.m
@@ -1,25 +1,25 @@
-# Copyright (C) 1997 Kai P. Mueller
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1997 Kai P. Mueller
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
 
 ## -*- texinfo -*-
 ##@deftypefn {Function File } { @var{Qb} =} obsv (@var{sys}@{, @var{c}@})
 ## Build observability matrix
 ## @example
 ## @group
 ##      | C        |
 ##      | CA       |
@@ -32,32 +32,33 @@
 ## 
 ## Note: @code{obsv()} forms the observability matrix.
 ## 
 ##        The numerical properties of is_observable()
 ##        are much better for observability tests.
 ## @end deftypefn
 
 function Qb = obsv(sys, c)
-  # Written by Kai P. Mueller November 4, 1997
-  # modified by
+
+  ## Written by Kai P. Mueller November 4, 1997
+  ## modified by
 
   if (nargin == 2)
     a = sys;
   elseif (nargin == 1 && is_struct(sys))
     sysupdate(sys,"ss");
     [a,b,c] = sys2ss(sys);
   else
     usage("obsv(sys [, c])")
   endif
 
   if (!is_abcd(a,c'))
     Qb = [];
   else
-    # no need to check dimensions, we trust is_abcd().
+    ## no need to check dimensions, we trust is_abcd().
     [na, ma] = size(a);
     [nc, mc] = size(c);
     Qb = zeros(na*nc, ma);
     for i = 1:na
       Qb((i-1)*nc+1:i*nc, :) = c;
       c = c * a;
     endfor
   endif
diff --git a/scripts/control/ord2.m b/scripts/control/ord2.m
--- a/scripts/control/ord2.m
+++ b/scripts/control/ord2.m
@@ -1,25 +1,25 @@
-# Copyright (C) 1997 Kai P. Mueller
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1997 Kai P. Mueller
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
  
 ## -*- texinfo -*-
 ## @deftypefn {Function File } { @var{outsys} =} ord2 (@var{nfreq}, @var{damp}@{[, @var{gain}@})
 ##  Creates a continuous 2nd order system with parameters:
 ## @strong{Inputs}
 ## @table @var
 ## @item  nfreq:   natural frequency [Hz]. (not in rad/s)
 ## @item      damp:    damping coefficient
@@ -38,18 +38,19 @@
 ##     \                                        /
 ## @end example
 ## @strong{See also} @code{jet707} (MIMO example, Boeing 707-321 aircraft model)
 ## @end deftypefn
 
 ## See also: jet707 (MIMO example, Boeing 707-321 aircraft model)
 
 function outsys = ord2(nfreq, damp, gain)
-  # Written by Kai P. Mueller September 28, 1997
-  # Updates
+
+  ## Written by Kai P. Mueller September 28, 1997
+  ## Updates
 
   if(nargin != 2 & nargin != 3)
     usage("outsys = ord2(nfreq, damp[, gain])")
   endif
   if (nargout > 1)
     usage("outsys = ord2(nfreq, damp[, gain])")
   endif
   if (nargin == 2)
diff --git a/scripts/control/outlist.m b/scripts/control/outlist.m
--- a/scripts/control/outlist.m
+++ b/scripts/control/outlist.m
@@ -1,25 +1,25 @@
-# Copyright (C) 1996, 1998 Auburn University.  All Rights Reserved.
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1996, 1998 Auburn University.  All Rights Reserved.
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
 
 ## -*- texinfo -*- 
 ## @deftypefn {Function File } { } outlist (@var{lmat}@{, @var{tabchar}, @var{yd}, @var{ilist} @})
 ##  Prints an enumerated list of strings.
 ##  internal use only; minimal argument checking performed
 ## 
 ## @strong{Inputs}
 ## @table @var
@@ -38,41 +38,43 @@
 ## @end table
 ## 
 ## @strong{Outputs}
 ##    prints the list to the screen, numbering each string in order.
 ## 
 ## @end deftypefn
 
 function str_val = outlist(name_list,tabchar,yd,ilist)
-# A. S. Hodel Dec. 1995, 1998
+
+  ## A. S. Hodel Dec. 1995, 1998
 
-#save for restore later
-save_empty = empty_list_elements_ok;
-empty_list_elements_ok = 1;
+  ## save for restore later
+  save_empty = empty_list_elements_ok;
+  empty_list_elements_ok = 1;
 
-if( nargin < 1 | nargin > 4 )
-  usage("str_val = outlist(x[,tabchar,yd,ilist])");
-endif
+  if( nargin < 1 | nargin > 4 )
+    usage("str_val = outlist(x[,tabchar,yd,ilist])");
+  endif
 
-m = length(name_list);
-if(nargin < 4)           ilist = 1:m;          endif
-if(nargin ==1)
-  empty_list_elements_ok = 1;
-  tabchar = "";
-endif
+  m = length(name_list);
+  if(nargin < 4)           ilist = 1:m;          endif
+  if(nargin ==1)
+    empty_list_elements_ok = 1;
+    tabchar = "";
+  endif
 
-if(nargin < 3)             yd = zeros(1,m);
-elseif(isempty(yd))        yd = zeros(1,m);          endif
+  if(nargin < 3)             yd = zeros(1,m);
+  elseif(isempty(yd))        yd = zeros(1,m);          endif
 
-str_val = "";
-dstr = list(""," (discrete)");
-if((m >= 1) && (is_list(name_list)))
-  for ii=1:m
-    str_val = sprintf("%s%s%d: %s%s\n",str_val,tabchar, ilist(ii), ...
-	nth(name_list,ii),nth(dstr,yd(ii)+1));
-  endfor
-else
-  str_val = sprintf("%sNone",tabchar);
-endif
+  str_val = "";
+  dstr = list(""," (discrete)");
+  if((m >= 1) && (is_list(name_list)))
+    for ii=1:m
+      str_val = sprintf("%s%s%d: %s%s\n",str_val,tabchar, ilist(ii), ...
+	  nth(name_list,ii),nth(dstr,yd(ii)+1));
+    endfor
+  else
+    str_val = sprintf("%sNone",tabchar);
+  endif
 
-empty_list_elements_ok = save_empty;
+  empty_list_elements_ok = save_empty;
+
 endfunction
diff --git a/scripts/control/packedform.m b/scripts/control/packedform.m
--- a/scripts/control/packedform.m
+++ b/scripts/control/packedform.m
@@ -1,25 +1,25 @@
-# Copyright (C) 1996,1998 Auburn University.  All Rights Reserved.
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1996,1998 Auburn University.  All Rights Reserved.
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
  
 save_var = page_screen_output;
 page_screen_output = 1;
 disp("Description of system data structure:")
 disp("A linear system is stored in a structure, and may be represented in")
 disp("ss (state space), tf (transfer function),  and/or zp (zero-pole-gain)")
 disp("form.")
 disp(" ")
diff --git a/scripts/control/packsys.m b/scripts/control/packsys.m
--- a/scripts/control/packsys.m
+++ b/scripts/control/packsys.m
@@ -1,65 +1,66 @@
-# Copyright (C) 1996 Auburn University.  All Rights Reserved.
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1996 Auburn University.  All Rights Reserved.
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
  
+## O B S O L E T E: use ss2sys instead.
+## function Asys = packsys(a,b,c[,d,dflg])
+## 
+##   dflg: 0 for continuous time system, 1 for discrete-time system.
+## 
+## defaults:
+##      D: 0 matrix of appropriate dimension.
+##   dflg: 0 (continuous time)
+## 
+## Note: discrete-state sampling time is not included!
+
 function Asys = packsys(a,b,c,d,dflg)
-  # O B S O L E T E: use ss2sys instead.
-  # function Asys = packsys(a,b,c[,d,dflg])
-  #
-  # dflg: 0 for continuous time system, 1 for discrete-time system.
-  # 
-  # defaults:
-  #   D: 0 matrix of appropriate dimension.
-  #   dflg: 0 (continuous time)
-  #
-  # Note: discrete-state sampling time is not included!
-  #
+
   
-  # Written by R. Bruce Tenison  July 29, 1994
-  # Modified by David Clem November 13, 1994
-  # Modified by A. S. Hodel April 1995
+  ## Written by R. Bruce Tenison  July 29, 1994
+  ## Modified by David Clem November 13, 1994
+  ## Modified by A. S. Hodel April 1995
 
   warning("packsys is obsolete!  Use ss2sys instead.");
   
   if (nargin < 3 || nargin > 5)
     disp("packsys: Invalid number of arguments")
   endif
 
-  # check dflg
+  ## check dflg
   if(nargin == 5)
     if( !is_scalar(dflg))
       [m,n] = size(dflg);
       error(["packsys: dflg (",num2str(m),",",num2str(n), ...
 	") must be a scalar."]);
     elseif( (dflg != 0) && (dflg != 1))
       error(["packsys: dflg=",num2str(dflg),"must be 0 or 1"]);
     endif
   else
-    #default condition
+    ## default condition
     dflg = 0;
   endif
 
   if (nargin == 3)
-    # No D matrix.  Form a zero one!
+    ## No D matrix.  Form a zero one!
     [brows,bcols] = size(b);
     [crows,ccols] = size(c);
     d = zeros(crows,bcols);
   endif
 
   [n,m,p] = abcddim(a,b,c,d);
   if (n == -1 || m == -1 || p == -1)
     error("packsys: incompatible dimensions")
diff --git a/scripts/control/parallel.m b/scripts/control/parallel.m
--- a/scripts/control/parallel.m
+++ b/scripts/control/parallel.m
@@ -1,62 +1,63 @@
-# Copyright (C) 1996 Auburn University.  All Rights Reserved.
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1996 Auburn University.  All Rights Reserved.
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
  
+## function sysp = parallel(Asys,Bsys)
+## Forms the parallel connection of two systems.
+##
+##              ____________________
+##              |      ________    |
+##     u  ----->|----> | Asys |--->|----> y1
+##         |    |      --------    |
+##         |    |      ________    |
+##         |--->|----> | Bsys |--->|----> y2
+##              |      --------    |
+##              --------------------
+##                   Ksys
+
 function sysp = parallel(Asys,Bsys)
-# function sysp = parallel(Asys,Bsys)
-# Forms the parallel connection of two systems.
-#
-#              ____________________
-#              |      ________    |
-#     u  ----->|----> | Asys |--->|----> y1
-#         |    |      --------    |
-#         |    |      ________    |
-#         |--->|----> | Bsys |--->|----> y2
-#              |      --------    |
-#              --------------------
-#                   Ksys
 
-# Written by David Clem August 15, 1994
-# completely rewritten Oct 1996 a s hodel
-# SYS_INTERNAL accesses members of system structure
+  ## Written by David Clem August 15, 1994
+  ## completely rewritten Oct 1996 a s hodel
+  ## SYS_INTERNAL accesses members of system structure
 
   if(nargin != 2)
     usage("sysp = parallel(Asys,Bsys)");
   endif
   if(! is_struct(Asys) )
     error("1st input argument is not a system data structure")
   elseif (! is_struct(Bsys) )
     error("2nd input argument is not a system data structure")
   endif
   [Ann,Anz,mA] = sysdimensions(Asys);
   [Bnn,Bnz,mB] = sysdimensions(Bsys);
   if(mA != mB)
     error(["Asys has ",num2str(mA)," inputs, Bsys has ",num2str(mB)," inputs"]);
   endif
 
-  # save signal names
+  ## save signal names
   Ain = sysgetsignals(Asys,"in");
 
-  # change signal names to avoid warning messages from sysgroup
+  ## change signal names to avoid warning messages from sysgroup
   Asys = syssetsignals(Asys,"in",sysdefioname(length(Ain),"Ain_u"));
   Bsys = syssetsignals(Bsys,"in",sysdefioname(length(Ain),"Bin_u"));
 
   sysp = sysgroup(Asys,Bsys);
   sysD = ss2sys([],[],[],[eye(mA);eye(mA)]);
   
   sysp = sysmult(sysp,sysD);
   sysp = syssetsignals(sysp,"in",Ain);
diff --git a/scripts/control/place.m b/scripts/control/place.m
--- a/scripts/control/place.m
+++ b/scripts/control/place.m
@@ -1,121 +1,122 @@
-# Copyright (C) 1997 Jose Daniel Munoz Frias
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1997 Jose Daniel Munoz Frias
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File } { @var{K} =} place (@var{sys}, @var{P})
 ## Computes the matrix  K such that if the state
 ## is feedback with gain K, then the eigenvalues  of the closed loop
 ## system (i.e. A-BK) are those specified in the vector P.
 ## 
 ## Version: Beta (May-1997): If you have any comments, please let me know.
 ## 			    (see the file place.m for my address)
 ## 
 ## Written by: Jose Daniel Munoz Frias.
 ## @end deftypefn
  
 function K = place(sys, P) 
-%	      Universidad Pontificia Comillas
-%	      ICAIdea
-%	      Alberto Aguilera, 23
-%	      28015 Madrid, Spain
-%
-%	      E-Mail: daniel@dea.icai.upco.es
-%
-%	      Phone: 34-1-5422800   Fax: 34-1-5596569
-%
-% Algorithm taken from "The Control Handbook", IEEE press pp. 209-212
-#
-# code adaped by A.S.Hodel (a.s.hodel@eng.auburn.edu) for use in controls
-# toolbox
+
+  ## Universidad Pontificia Comillas
+  ## ICAIdea
+  ## Alberto Aguilera, 23
+  ## 28015 Madrid, Spain
+  ##
+  ## E-Mail: daniel@dea.icai.upco.es
+  ##
+  ## Phone: 34-1-5422800   Fax: 34-1-5596569
+  ##
+  ## Algorithm taken from "The Control Handbook", IEEE press pp. 209-212
+  ##
+  ## code adaped by A.S.Hodel (a.s.hodel@eng.auburn.edu) for use in controls
+  ## toolbox
 
   sav_val = empty_list_elements_ok;
   empty_list_elements_ok = 1;
-  #
-  # check arguments
-  #
+
+  ## check arguments
+
   if(!is_struct(sys))
     error("sys must be in system data structure format (see ss2sys)");
   endif
   sys = sysupdate(sys,"ss");	# make sure it has state space form up to date
   if(!is_controllable(sys))
     error("sys is not controllable.");
   elseif( min(size(P)) != 1)
     error("P must be a vector")
   else
     P = reshape(P,length(P),1);	# make P a column vector
   endif
-  # system must be purely continuous or discrete
+  ## system must be purely continuous or discrete
   is_digital(sys);
   [n,nz,m,p] = sysdimensions(sys);
   nx = n+nz;	# already checked that it's not a mixed system.
   if(m != 1)
     error(["sys has ", num2str(m)," inputs; need only 1"]);
   endif
 
-  # takes the A and B matrix from the system representation
+  ## takes the A and B matrix from the system representation
   [A,B]=sys2ss(sys);
   sp = length(P);
   if(nx == 0)
     error("place: A matrix is empty (0x0)");
   elseif(nx != length(P))
     error(["A=(",num2str(nx),"x",num2str(nx),", P has ", num2str(length(P)), ...
 	"entries."])
   endif
 
-  # arguments appear to be compatible; let's give it a try!
-  %The second step is the calculation of the characteristic polynomial ofA
+  ## arguments appear to be compatible; let's give it a try!
+  ## The second step is the calculation of the characteristic polynomial ofA
   PC=poly(A);
 
-  %Third step: Calculate the transformation matrix T that transforms the state
-  %equation in the controllable canonical form.
+  ## Third step: Calculate the transformation matrix T that transforms the state
+  ## equation in the controllable canonical form.
 
-  %first we must calculate the controllability matrix M:
+  ## first we must calculate the controllability matrix M:
   M=B;
   AA=A;
   for n = 2:nx
     M(:,n)=AA*B;
     AA=AA*A;
   endfor
 
-  %second, construct the matrix W
+  ## second, construct the matrix W
   PCO=PC(nx:-1:1);
-  PC1=PCO; 	%Matrix to shift and create W row by row
+  PC1=PCO; 	# Matrix to shift and create W row by row
 
   for n = 1:nx
     W(n,:) = PC1;
     PC1=[PCO(n+1:nx),zeros(1,n)];
   endfor
 
   T=M*W;
 
-  %finaly the matrix K is calculated 
-  PD = poly(P); %The desired characteristic polynomial
+  ## finaly the matrix K is calculated 
+  PD = poly(P); # The desired characteristic polynomial
   PD = PD(nx+1:-1:2);
   PC = PC(nx+1:-1:2);
   
   K = (PD-PC)/T;
 
-  %Check if the eigenvalues of (A-BK) are the same specified in P
+  ## Check if the eigenvalues of (A-BK) are the same specified in P
   Pcalc = eig(A-B*K);
 
   Pcalc = sortcom(Pcalc);
   P = sortcom(P);
 
   if(max( (abs(Pcalc)-abs(P))./abs(P) ) > 0.1)
     disp("Place: Pole placed at more than 10% relative error from specified");
   endif
diff --git a/scripts/control/polyout.m b/scripts/control/polyout.m
--- a/scripts/control/polyout.m
+++ b/scripts/control/polyout.m
@@ -1,43 +1,43 @@
-# Copyright (C) 1995,1998 Auburn University.  All Rights Reserved.
-#
-# This file is part of Octave.
-#
-# Octave is free software; you can redistribute it and/or modify it
-# under the terms of the GNU General Public License as published by the
-# Free Software Foundation; either version 2, or (at your option) any
-# later version.
-#
-# Octave is distributed in the hope that it will be useful, but WITHOUT
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-# for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Octave; see the file COPYING.  If not, write to the Free
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
+## Copyright (C) 1995,1998 Auburn University.  All Rights Reserved.
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
+##
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+## for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File } { @var{y} =} polyout ( @var{c}@{, @var{x}@})
 ## write formatted polynomial 
 ## @example
 ##    c(x) = c(1) * x^n + ... + c(n) x + c(n+1)
 ## @end example
 ##  to string @var{y} or to the screen (if @var{y} is omitted)
 ##  @var{x} defaults to the string @code{"s"}
 ## @end deftypefn
 
 ##  See also: polyval, polyvalm, poly, roots, conv, deconv, residue, 
 ##	filter, polyderiv, polyinteg
 
 function y = polyout(c,x)
 
-# Written by A. Scottedward Hodel (scotte@eng.auburn.edu) May 1995)
-# Nov 1998: Correctly handles complex coefficients
+## Written by A. Scottedward Hodel (scotte@eng.auburn.edu) May 1995)
+## Nov 1998: Correctly handles complex coefficients
   
   if (nargin < 1 ) || (nargin > 2) || (nargout < 0 ) || (nargout > 1)
     usage("[y = ] polyout(c,[x])");
   endif
 
   if (!is_vector(c))
     error("polyout: first argument must be a vector");
   endif
diff --git a/scripts/control/prompt.m b/scripts/control/prompt.m
--- a/scripts/control/prompt.m
+++ b/scripts/control/prompt.m
@@ -1,25 +1,25 @@
-# Copyright (C) 1996 Auburn University.  All Rights Reserved.
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1996 Auburn University.  All Rights Reserved.
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File } { outputs =} prompt ( inputs ) 
 ## @format
 ##  function prompt([str])
 ##  Prompt user to continue
 ##  str: input string. Default value: "\n ---- Press a key to continue ---"
 ##  Written by David Clem August 15, 1994
diff --git a/scripts/control/pzmap.m b/scripts/control/pzmap.m
--- a/scripts/control/pzmap.m
+++ b/scripts/control/pzmap.m
@@ -1,25 +1,25 @@
-# Copyright (C) 1996,1998 Auburn University.  All Rights Reserved.
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1996,1998 Auburn University.  All Rights Reserved.
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File } {[@var{zer}, @var{pol}]=} pzmap (@var{sys})
 ##  Plots the zeros and poles of a system in the complex plane.
 ## @strong{Inputs}
 ##  @var{sys} system data structure
 ## 
 ## @strong{Outputs}
@@ -39,45 +39,45 @@ function [zer,pol]=pzmap(sys)
   if(nargin != 1)
     usage("pzmap(sys) or [zer,pol] = pzmap(sys)"); 
   elseif (!is_struct(sys));
     error("sys must be in system format");
   endif
 
   [zer,pol] = sys2zp(sys);
 
-  # force to column vectors, split into real, imaginary parts
+  ## force to column vectors, split into real, imaginary parts
   zerdata = poldata = [];
   if(length(zer))
     zer = reshape(zer,length(zer),1);
     zerdata = [real(zer(:,1)), imag(zer(:,1))];
   endif
   if(length(pol))
     pol = reshape(pol,length(pol),1);
     poldata = [real(pol(:,1)), imag(pol(:,1))];
   endif
 
-  # determine continuous or discrete plane
+  ## determine continuous or discrete plane
   vars = "sz";
   varstr = vars(is_digital(sys) + 1);
 
-  # Plot the data
+  ## Plot the data
   gset nologscale xy;
   if(is_siso(sys))
     title(sprintf("Pole-zero map from %s to %s", ...
        sysgetsignals(sys,"in",1,1), sysgetsignals(sys,"out",1,1) ));
   endif
   xlabel(["Re(",varstr,")"]);
   ylabel(["Im(",varstr,")"]);
   grid;
 
-  # compute axis limits
+  ## compute axis limits
   axis(axis2dlim([zerdata;poldata]));
   grid
-  # finally, plot the data
+  ## finally, plot the data
   if(length(zer) == 0)
     plot(poldata(:,1), poldata(:,2),"@12 ;poles (no zeros);");
   elseif(length(pol) == 0)
     plot(zerdata(:,1), zerdata(:,2),"@31 ;zeros (no poles);");
   else
     plot(zerdata(:,1), zerdata(:,2),"@31 ;zeros;", ...
       poldata(:,1), poldata(:,2),"@12 ;poles;");
   endif
diff --git a/scripts/control/qzval.m b/scripts/control/qzval.m
--- a/scripts/control/qzval.m
+++ b/scripts/control/qzval.m
@@ -1,25 +1,25 @@
-# Copyright (C) 1998 Auburn University.  All Rights Reserved.
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1998 Auburn University.  All Rights Reserved.
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File } { @var{x} =} qzval (@var{A}, @var{B})
 ## Compute generalized eigenvalues of the matrix pencil 
 ## @ifinfo
 ## @example
 ## (A - lambda B).
 ## @end example
@@ -31,14 +31,14 @@
 ## @end iftex
 ## 
 ## @var{A} and @var{B} must be real matrices.
 ##  
 ## @strong{Note} @code{qzval} is obsolete; use @code{qz} instead.
 ## @end deftypefn
  
 function lam = qzval(A,B)
-# A. S. Hodel July 1998
+## A. S. Hodel July 1998
 
   warning("qzval is obsolete; calling qz instead")
   lam = qz(A,B);
 endfunction
 
diff --git a/scripts/control/rldemo.m b/scripts/control/rldemo.m
--- a/scripts/control/rldemo.m
+++ b/scripts/control/rldemo.m
@@ -1,34 +1,34 @@
-# Copyright (C) 1996 Auburn University.  All Rights Reserved.
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1996 Auburn University.  All Rights Reserved.
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
 
 ## -*- texinfo -*-
 ##@deftypefn {Function File } { outputs =} rldemo ( inputs ) 
 ##Octave Controls toolbox demo: Root Locus demo
 ##@end deftypefn
  
 function rldemo()
-# Written by David Clem August 15, 1994
-# Updated by John Ingram December 1996
+## Written by David Clem August 15, 1994
+## Updated by John Ingram December 1996
 
   while (1)
     clc
     k = menu("Octave Root Locus Demo", ...
     	"Display continuous system's open loop poles and zeros (pzmap)", ...
     	"Display discrete system's open loop poles and zeros (pzmap)", ...
     	"Display root locus diagram of SISO continuous system (rlocus)", ...
     	"Display root locus diagram of SISO discrete system (rlocus)", ...	
diff --git a/scripts/control/rlocus.m b/scripts/control/rlocus.m
--- a/scripts/control/rlocus.m
+++ b/scripts/control/rlocus.m
@@ -1,25 +1,25 @@
-# Copyright (C) 1996 Auburn University.  All Rights Reserved.
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1996 Auburn University.  All Rights Reserved.
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File } { outputs =} rlocus ( inputs ) 
 ## @format
 ##  [rldata, k] = rlocus(sys[,increment,min_k,max_k])
 ##  Displays root locus plot of the specified SISO system.
 ##  
 ##        -----   ---     -------- 
@@ -36,115 +36,116 @@
 ##            values)
 ##    k: gains for real axis break points.
 ## 
 ## 
 ## @end format
 ## @end deftypefn
 
 function [rldata,k_break,rlpol,gvec,real_ax_pts] = rlocus(sys,increment,min_k,max_k)
-  # Convert the input to a transfer function if necessary
-  # Written by Clem and Tenison
-  # Updated by Kristi McGowan July 1996 for intelligent gain selection
-  # Updated by John Ingram July 1996 for systems
+
+  ## Convert the input to a transfer function if necessary
+  ## Written by Clem and Tenison
+  ## Updated by Kristi McGowan July 1996 for intelligent gain selection
+  ## Updated by John Ingram July 1996 for systems
   
   if (nargin < 1) | (nargin > 4)
     usage("rlocus(sys[,inc,mink,maxk])");
   endif
   
   [num,den] = sys2tf(sys);		# extract numerator/denom polyomials
   lnum = length(num);      lden = length(den);
   if(lden < 2)
     error(sprintf("length of derivative=%d, doesn't make sense",lden));
   elseif(lnum == 1)
     num = [0, num];     # so that derivative is shortened by one
   endif
 
-  # root locus plot axis limits
+  ## root locus plot axis limits
   
-  # compute real axis locus breakpoints
-  # compute the derivative of the numerator and the denominator 
+  ## compute real axis locus breakpoints
+  ## compute the derivative of the numerator and the denominator 
   dern=polyderiv(num);        derd=polyderiv(den);
   
-  # compute real axis breakpoints
+  ## compute real axis breakpoints
   real_ax_pol = conv(den,dern) - conv(num,derd);
   real_ax_pts = roots(real_ax_pol);
   if(isempty(real_ax_pts))
     k_break = [];
     maxk = 0;
   else
-    # compute gains that achieve the breakpoints
+    ## compute gains that achieve the breakpoints
     c1 = polyval(num,real_ax_pts);
     c2 = polyval(den,real_ax_pts);
     k_break = -real(c2 ./ c1);
     maxk = max(max(k_break,0));
   endif
 
-  # compute gain ranges based on computed K values
+  ## compute gain ranges based on computed K values
   if(maxk == 0)     maxk = 1; 
   else              maxk = 1.1*maxk;        endif
   mink = 0;
   ngain = 20;
 
-  # check for input arguments:
+  ## check for input arguments:
   if (nargin > 2)       mink = min_k;          endif
   if (nargin > 3)       maxk = max_k;          endif
   if (nargin > 1)
     if(increment <= 0)  error("increment must be positive");
     else
       ngain = (maxk-mink)/increment;
     endif
   endif
 
-  # vector of gains
+  ## vector of gains
   ngain = max(3,ngain);
   gvec = linspace(mink,maxk,ngain);
   
-  # Find the open loop zeros and the initial poles
+  ## Find the open loop zeros and the initial poles
   rlzer = roots(num);
 
-  # update num to be the same length as den
+  ## update num to be the same length as den
   lnum = length(num);  if(lnum < lden) num = [zeros(1,lden - lnum),num];  endif
 
-  # compute preliminary pole sets
+  ## compute preliminary pole sets
   nroots = lden-1;
   for ii=1:ngain
    gain = gvec(ii);
    rlpol(1:nroots,ii)  = vec(sortcom(roots(den + gain*num)));
   endfor
 
-  # compute axis limits (isolate asymptotes)
+  ## compute axis limits (isolate asymptotes)
   olpol = roots(den);
   real_axdat = union(real(rlzer), real(union(olpol,real_ax_pts)) );
   rmin = min(real_axdat);      rmax = max(real_axdat);
 
   rlpolv = [vec(rlpol); vec(real_axdat)];
   idx = find(real(rlpolv) >= rmin & real(rlpolv) <= rmax);
   axlim = axis2dlim([real(rlpolv(idx)),imag(rlpolv(idx))]);
   xmin = axlim(1);
   xmax = axlim(2);
   
-  # set smoothing tolerance per axis limits
+  ## set smoothing tolerance per axis limits
   smtol = 0.01*max(abs(axlim));
   
-  # smooth poles if necessary, up to maximum of 1000 gain points
-  # only smooth points within the axis limit window
-  # smoothing done if max_k not specified as a command argument
+  ## smooth poles if necessary, up to maximum of 1000 gain points
+  ## only smooth points within the axis limit window
+  ## smoothing done if max_k not specified as a command argument
   done=(nargin == 4);    # perform a smoothness check
   while((!done) & ngain < 1000)
     done = 1 ;      # assume done
     dp = abs(diff(rlpol'))';
     maxd = max(dp);
-    # search for poles in the real axis limits whose neighbors are distant
+    ## search for poles in the real axis limits whose neighbors are distant
     idx = find(maxd > smtol);
     for ii=1:length(idx)
       i1 = idx(ii);      g1 = gvec(i1);       p1 = rlpol(:,i1);
       i2 = idx(ii)+1;    g2 = gvec(i2);       p2 = rlpol(:,i2);
     
-      # isolate poles in p1, p2 that are inside the real axis limits
+      ## isolate poles in p1, p2 that are inside the real axis limits
       bidx = find( (real(p1) >= xmin & real(p1) <= xmax)  ...
           | (real(p2) >= xmin & real(p2) <= xmax) );
       if(!isempty(bidx))
         p1 = p1(bidx);
         p2 = p2(bidx);
         if( max(abs(p2-p1)) > smtol) 
           newg = linspace(g1,g2,5);
           newg = newg(2:4);
@@ -160,29 +161,29 @@ function [rldata,k_break,rlpol,gvec,real
             prompt
           endif
           gvec =  [gvec,newg];
           done = 0;             # need to process new gains
         endif
       endif
     endfor
     
-    # process new gain values
+    ## process new gain values
     ngain1 = length(gvec);
     for ii=(ngain+1):ngain1
       gain = gvec(ii);
       rlpol(1:nroots,ii)  = vec(sortcom(roots(den + gain*num)));
     endfor
 
     [gvec,idx] = sort(gvec);
     rlpol = rlpol(:,idx);
     ngain = length(gvec);
   endwhile
    
-  # Plot the data
+  ## Plot the data
   if(nargout  == 0)
     rlpolv = vec(rlpol);
     idx = find(real(rlpolv) >= xmin & real(rlpolv) <= xmax);
     axdata = [real(rlpolv(idx)),imag(rlpolv(idx))];
     axlim = axis2dlim(axdata);
     axlim(1:2) = [xmin, xmax];
     gset nologscale xy;
     grid("on");
diff --git a/scripts/control/rotg.m b/scripts/control/rotg.m
--- a/scripts/control/rotg.m
+++ b/scripts/control/rotg.m
@@ -1,26 +1,27 @@
-# Copyright (C) 1996 Auburn University.  All Rights Reserved.
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1996 Auburn University.  All Rights Reserved.
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
  
+## function [c,s] = rotg(a,b)
+## givens rotation calculation
+##
+## NOTE: Use [c,s] = givens(a,b) instead.
+
 function [c,s] = rotg(a,b)
-  #function [c,s] = rotg(a,b)
-  # givens rotation calculation
-  #
-  # NOTE: Use [c,s] = givens(a,b) instead.
 
   [c,s] = givens(a,b);
 endfunction
diff --git a/scripts/control/run_cmd.m b/scripts/control/run_cmd.m
--- a/scripts/control/run_cmd.m
+++ b/scripts/control/run_cmd.m
@@ -1,28 +1,28 @@
-# Copyright (C) 1996,1998 Auburn University.  All Rights Reserved.
-#
-# This file is part of Octave.
-#
-# Octave is free software; you can redistribute it and/or modify it
-# under the terms of the GNU General Public License as published by the
-# Free Software Foundation; either version 2, or (at your option) any
-# later version.
-#
-# Octave is distributed in the hope that it will be useful, but WITHOUT
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-# for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Octave; see the file COPYING.  If not, write to the Free
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
+## Copyright (C) 1996,1998 Auburn University.  All Rights Reserved.
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
+##
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+## for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
-# run_cmd: short script used in demos
-# prints string cmd to the screen, then executes after a pause
+## run_cmd: short script used in demos
+## prints string cmd to the screen, then executes after a pause
 
 disp(["Command: ",cmd])
 puts("Press a key to execute command");
 fflush(stdout);
 kbhit();
 disp("  executing");
 fflush(stdout);
 eval(cmd);
diff --git a/scripts/control/series.m b/scripts/control/series.m
--- a/scripts/control/series.m
+++ b/scripts/control/series.m
@@ -1,95 +1,95 @@
-# Copyright (C) 1996 Auburn University.  All Rights Reserved.
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1996 Auburn University.  All Rights Reserved.
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
  
 function [a,b,c,d] = series(a1,b1,c1,d1,a2,b2,c2,d2)
-# Forms the series connection of two systems.
-#
-# Superseded by sysmult.  Do not use this routine!
-# used internally in zp2ss
-#
-# Type of input: Transfer functions
-# Command:       [num,den]=series(num1,den1,num2,den2)
-# Forms the series representation of the two transfer functions.
-#
-# Type of input: State space systems
-# Command:       [a,b,c,d]=series(a1,b1,c1,d1,a2,b2,c2,d2)
-# Forms the series representation of the two state space system arguments.
-# The series connected system will have the inputs of system 1 and the 
-# outputs of system 2.
-#
-# Type of input: system data structure
-# Command:       syst=series(syst1,syst2)
-# Forms the series representation of the two mu system arguments.
-# Written by David Clem August 15, 1994
+## Forms the series connection of two systems.
+##
+## Superseded by sysmult.  Do not use this routine!
+## used internally in zp2ss
+##
+## Type of input: Transfer functions
+## Command:       [num,den]=series(num1,den1,num2,den2)
+## Forms the series representation of the two transfer functions.
+##
+## Type of input: State space systems
+## Command:       [a,b,c,d]=series(a1,b1,c1,d1,a2,b2,c2,d2)
+## Forms the series representation of the two state space system arguments.
+## The series connected system will have the inputs of system 1 and the 
+## outputs of system 2.
+##
+## Type of input: system data structure
+## Command:       syst=series(syst1,syst2)
+## Forms the series representation of the two mu system arguments.
+## Written by David Clem August 15, 1994
 
-# If two arguments input, take care of mu system case
+## If two arguments input, take care of mu system case
 
   warning("series is superseded by sysmult; use sysmult instead.")
 
   muflag = 0;
   if(nargin == 2)
     temp=b1;
     [a1,b1,c1,d1]=sys2ss(a1);
     [a2,b2,c2,d2]=sys2ss(temp);
     muflag = 1;
   endif
 
-# If four arguments input, put two transfer functions in series
+## If four arguments input, put two transfer functions in series
 
   if(nargin == 4)
     a = conv(a1,c1);	% was conv1
     b = conv(b1,d1);	% was conv1
     c = 0;
     d = 0;
 
-# Find series combination of 2 state space systems
+## Find series combination of 2 state space systems
 
   elseif((nargin == 8)||(muflag == 1))
 
-# check matrix dimensions
+## check matrix dimensions
   
     [n1,m1,p1] = abcddim(a1,b1,c1,d1);
     [n2,m2,p2] = abcddim(a2,b2,c2,d2);
 
     if((n1 == -1) || (n2 == -1))
       error("Incorrect matrix dimensions");
     endif
 
-# check to make sure the number of outputs of system1 equals the number
-# of inputs of system2
+## check to make sure the number of outputs of system1 equals the number
+## of inputs of system2
 
    if(p1 ~= m2)
      error("System 1 output / System 2 input connection sizes do not match");
    endif
 
-# put the two state space systems in series
+## put the two state space systems in series
 
     a = [a1, zeros(rows(a1),columns(a2));b2*c1, a2];
     b = [b1;b2*d1];
     c = [d2*c1, c2];
     d = [d2*d1];
 
-# take care of mu output
+## take care of mu output
 
     if(muflag == 1)
       a=ss2sys(a,b,c,d);
       b=c=d=0;
     endif 
   endif
 
 endfunction
diff --git a/scripts/control/sortcom.m b/scripts/control/sortcom.m
--- a/scripts/control/sortcom.m
+++ b/scripts/control/sortcom.m
@@ -1,25 +1,25 @@
-# Copyright (C) 1996 Auburn University.  All Rights Reserved.
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1996 Auburn University.  All Rights Reserved.
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
  
 ## -*- texinfo -*-
 ## @deftypefn {Function File } { outputs =} sortcom ( inputs ) 
 ## @format
 ##  [yy,idx] = sortcom(xx[,opt]): sort a complex vector
 ##  xx: complex vector
 ##  opt: sorting option:
 ## 	"re": real part (default)
@@ -31,17 +31,18 @@
 ##  yy: sorted values
 ##  idx: permutation vector: yy = xx(idx)
 ## 
 ## 
 ## @end format
 ## @end deftypefn
 
 function [yy,idx] = sortcom(xx,opt)
-# Written by A. S. Hodel June 1995
+
+  ## Written by A. S. Hodel June 1995
 
   if( nargin < 1 | nargin > 2 )
      usage("yy = sortcom(xx[,opt]");
   elseif( !(is_vector(xx) | isempty(xx) ))
     error("sortcom: first argument must be a vector");
   endif
 
   if(nargin == 1)         opt = "re";
@@ -59,22 +60,22 @@ function [yy,idx] = sortcom(xx,opt)
     elseif(strcmp(opt,"mag"))   datavec = abs(xx);
     else                        error(["sortcom: illegal option = ", opt])
     endif
   
     [datavec,idx] = sort(datavec);
     yy= xx(idx);
     
     if(strcmp(opt,"re") | strcmp(opt,"mag"))
-      # sort so that complex conjugate pairs appear together
+      ## sort so that complex conjugate pairs appear together
       
       ddiff = diff(datavec);
       zidx = find(ddiff == 0);
   
-      # sort common datavec values
+      ## sort common datavec values
       if(!isempty(zidx))
         for iv=create_set(datavec(zidx))
           vidx = find(datavec == iv);
           [vals,imidx] = sort(imag(yy(vidx)));
           yy(vidx)  = yy(vidx(imidx));
           idx(vidx) = idx(vidx(imidx));
         endfor
       endif
diff --git a/scripts/control/ss2sys.m b/scripts/control/ss2sys.m
--- a/scripts/control/ss2sys.m
+++ b/scripts/control/ss2sys.m
@@ -1,25 +1,25 @@
-# Copyright (C) 1996,1998 Auburn University.  All Rights Reserved.
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1996,1998 Auburn University.  All Rights Reserved.
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File } { @var{sys} =} ss2sys  (@var{a},@var{b},@var{c}@{,@var{d}, @var{tsam}, @var{n}, @var{nz}, @var{stname}, @var{inname}, @var{outname}, @var{outlist}@})
 ##  Create system structure from state-space data.   May be continous,
 ##  discrete, or mixed (sampeled-data)
 ## 
 ## @strong{Inputs}
 ## @table @var
@@ -181,118 +181,117 @@
 ##   0  0
 ##   0  0
 ## @end example
 ## Notice that the @var{D} matrix is constructed  by default to the 
 ## correct dimensions.  Default input and output signals names were assigned
 ## since none were given.
 ## 
 ## @end deftypefn
-## 
 
 function  retsys = ss2sys  (a,b,c,d,tsam,n,nz,stname,inname,outname,outlist)
 
-  #  Written by John Ingram (ingraje@eng.auburn.edu)  July 20, 1996
+  ## Written by John Ingram (ingraje@eng.auburn.edu)  July 20, 1996
 
   save_val = implicit_str_to_num_ok;	# save for later
   implicit_str_to_num_ok = 1;
 
-  #  Test for correct number of inputs
+  ## Test for correct number of inputs
   if ((nargin < 3) | (nargin > 11))
     usage("retsys = ss2sys  (a,b,c{,d,tsam,n,nz,stname,inname,outname,outlist})");
   endif
 
-  # verify A, B, C, D arguments
-  #  If D is not specified, set it to a zero matrix of appriate dimension.
+  ## verify A, B, C, D arguments
+  ## If D is not specified, set it to a zero matrix of appriate dimension.
   if (nargin == 3)          d = zeros(rows(c) , columns(b));
   elseif (isempty(d))       d = zeros(rows(c) , columns(b));      endif
 
-  #  Check the dimensions
+  ## Check the dimensions
   [na,m,p] = abcddim(a,b,c,d);
 
-  #  If dimensions are wrong, exit function
+  ## If dimensions are wrong, exit function
   if (m == -1)
     error("a(%dx%d), b(%dx%d), c(%dx%d), d(%dx%d); incompatible", ...
       rows(a), columns(a), rows(b), columns(b), rows(c), columns(c), ...
       rows(d), columns(d));
   endif
 
-  # check for tsam input
+  ## check for tsam input
   if(nargin < 5) tsam = 0;
   elseif( !( is_sample(tsam) | (tsam == 0) ) )
     error("tsam must be a nonnegative real scalar");
   endif
 
-  # check for continuous states
+  ## check for continuous states
   if( (nargin < 6) & (tsam == 0) )               n = na;
   elseif(nargin < 6)                             n = 0;
   elseif((!is_matrix(n)) | isstr(n))
     error("Parameter n is not a numerical value.");
   elseif( (!is_scalar(n)) | (n < 0 ) | (n != round(n)) )
     if(is_scalar(n))     error("illegal value of n=%d,%e",n,n);
     else                 error("illegal value of n=(%dx%d)", ...
 			   rows(n), columns(n));		endif
   endif
 
-  # check for num discrete states
+  ## check for num discrete states
   if( (nargin < 7) & (tsam == 0)) 		nz = 0;
   elseif(nargin < 7)				nz = na - n;
   elseif((!is_matrix(nz)) | isstr(nz))
     error("Parameter nz is not a numerical value.");
   elseif( (!is_scalar(nz)) | (nz < 0 ) | (nz != round(nz)) )
     if(is_scalar(nz))
       error(["illegal value of nz=",num2str(nz)]);
     else
       error(["illegal value of nz=(",num2str(rows(nz)),"x", ...
 	num2str(columns(nz)),")"]);
     endif
   endif
 
-  #check for total number of states
+  ## check for total number of states
   if( (n + nz) != na )
     error(["Illegal: a is ",num2str(na),"x",num2str(na),", n=", ...
 	num2str(n),", nz=",num2str(nz)]);
   endif
 
-  # construct system with default names
+  ## construct system with default names
   retsys.a = a;
   retsys.b = b; 
   retsys.c = c; 
   retsys.d = d;
 
   retsys.n = n;
   retsys.nz = nz;
   retsys.tsam = tsam;
   retsys.yd = zeros(1,p);     # default value entered below
 
-  #  Set the system vector:  active = 2(ss), updated = [0 0 1];
+  ## Set the system vector:  active = 2(ss), updated = [0 0 1];
   retsys.sys = [2, 0, 0, 1]; 
 
   retsys.stname = sysdefstname(n,nz);
   retsys.inname = sysdefioname(m,"u");
   retsys.outname = sysdefioname(p,"y");
 
-  # check for state names
+  ## check for state names
   if(nargin >= 8)
     if(!isempty(stname)) retsys = syssetsignals(retsys,"st",stname); endif
   endif
 
-  #check for input names
+  ## check for input names
   if(nargin >= 9)
     if(!isempty(inname)) retsys = syssetsignals(retsys,"in",inname); endif
   endif
 
-  #check for output names
+  ## check for output names
   if(nargin >= 10)
     if(!isempty(outname)) retsys = syssetsignals(retsys,"out",outname); endif
   endif
 
-  # set up yd
+  ## set up yd
   if(nargin < 11)
     retsys = syssetsignals(retsys,"yd",ones(1,p)*(tsam > 0));
   else
     if(!isempty(outlist)) 
       retsys = syssetsignals(retsys,"yd",ones(size(outlist)),outlist);
     endif
   endif
 
-  implicit_str_to_num_ok = save_val;	# restore value
+  implicit_str_to_num_ok = save_val;	## restore value
 endfunction
diff --git a/scripts/control/ss2tf.m b/scripts/control/ss2tf.m
--- a/scripts/control/ss2tf.m
+++ b/scripts/control/ss2tf.m
@@ -1,25 +1,25 @@
-# Copyright (C) 1996 Auburn University.  All Rights Reserved.
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1996 Auburn University.  All Rights Reserved.
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
 
 ## -*- texinfo -*- 
 ## @deftypefn {Function File } { outputs =} ss2tf ( inputs ) 
 ## @format
 ##  [num,den] = ss2tf(a,b,c,d)
 ##  Conversion from tranfer function to state-space.
 ##  The state space system
 ##       . 
@@ -34,47 +34,48 @@
 ## 
 ##  used internally in system data structure format manipulations
 ## 
 ## 
 ## @end format
 ## @end deftypefn
  
 function [num,den] = ss2tf(a,b,c,d)
-# Written by R. Bruce Tenison (June 24, 1994) btenison@eng.auburn.edu
-# a s hodel: modified to allow for pure gain blocks Aug 1996
 
-# Check args
+  ## Written by R. Bruce Tenison (June 24, 1994) btenison@eng.auburn.edu
+  ## a s hodel: modified to allow for pure gain blocks Aug 1996
+
+  ## Check args
   [n,m,p] = abcddim(a,b,c,d);
   if (n == -1)
     num = [];
     den = [];
     error("ss2tf: Non compatible matrix arguments");
   elseif ( (m != 1) | (p != 1))
     num = [];
     den = [];
     error(["ss2tf: not SISO system: m=",num2str(m)," p=",num2str(p)]);
   endif
   
   if(n == 0)
-    # gain block only
+    ## gain block only
     num = d;
     den = 1;
   else
-    # First, get the denominator coefficients
+    ## First, get the denominator coefficients
     den = poly(a);
   
-    # Get the zeros of the system
+    ## Get the zeros of the system
     [zz,g] = tzero(a,b,c,d);
 
-    # Form the Numerator (and include the gain)
+    ## Form the Numerator (and include the gain)
     if (!isempty(zz))
       num = g * poly(zz);
     else
       num = g;
     endif
   
-    # the coefficients must be real
+    ## the coefficients must be real
     den = real(den);
     num = real(num);
   endif
 endfunction
 
diff --git a/scripts/control/ss2zp.m b/scripts/control/ss2zp.m
--- a/scripts/control/ss2zp.m
+++ b/scripts/control/ss2zp.m
@@ -1,25 +1,25 @@
-# Copyright (C) 1996 Auburn University.  All Rights Reserved.
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1996 Auburn University.  All Rights Reserved.
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File } { outputs =} ss2zp ( inputs ) 
 ## @format
 ##  Converts a state space representation to a set of poles and zeros.
 ## 
 ##  [pol,zer,k] = ss2zp(a,b,c,d) returns the poles and zeros of the state space 
 ##  system (a,b,c,d).  K is a gain associated with the zeros.
@@ -27,34 +27,35 @@
 ##  used internally in system data structure format manipulations
 ## 
 ## 
 ## @end format
 ## @end deftypefn
 
  
 function [zer,pol,k] = ss2zp(a,b,c,d)
-# Written by David Clem August 15, 1994
-# Hodel: changed order of output arguments to zer, pol, k. July 1996
-# a s hodel: added argument checking, allow for pure gain blocks aug 1996
+
+  ## Written by David Clem August 15, 1994
+  ## Hodel: changed order of output arguments to zer, pol, k. July 1996
+  ## a s hodel: added argument checking, allow for pure gain blocks aug 1996
 
   if(nargin != 4)
     usage("[zer,pol,k] = ss2zp(a,b,c,d)");
   endif
 
   [n,m,p] = abcddim(a,b,c,d);
   if (n == -1)
     error("ss2tf: Non compatible matrix arguments");
   elseif ( (m != 1) | (p != 1))
     error(["ss2tf: not SISO system: m=",num2str(m)," p=",num2str(p)]);
   endif
  
   if(n == 0)
-    # gain block only
+    ## gain block only
     k = d;
     zer = pol = [];
   else
-    # First, get the denominator coefficients
+    ## First, get the denominator coefficients
     [zer,k] = tzero(a,b,c,d);
     pol = eig(a);
   endif
 endfunction
 
diff --git a/scripts/control/starp.m b/scripts/control/starp.m
--- a/scripts/control/starp.m
+++ b/scripts/control/starp.m
@@ -1,25 +1,25 @@
-# Copyright (C) 1996 Auburn University.  All Rights Reserved.
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1996 Auburn University.  All Rights Reserved.
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
  
 ## -*- texinfo -*-
 ## @deftypefn {Function File } { outputs =} starp ( inputs ) 
 ## @format
 ## 
 ##  [sys] = starp(P, K, ny, nu)
 ## 
 ##  Redheffer star product or upper/lower LFT, respectively.
@@ -45,17 +45,18 @@
 ##  inputs and outputs of P then the result is an upper fractional
 ##  transformation.
 ## 
 ##  ny and/or nu may be negative (= negative feedback)
 ## @end format
 ## @end deftypefn
 
 function [sys] = starp(P, K, ny, nu);
-# Written by Kai Mueller May 1998
+
+  ## Written by Kai Mueller May 1998
 
   if((nargin != 2) && (nargin != 4))
     usage("[sys] = starp(P, K, ny, nu)");
   endif
   if (!is_struct(P))
     error("---> P must be in system data structure");
   endif
   if (!is_struct(K))
@@ -66,17 +67,17 @@ function [sys] = starp(P, K, ny, nu);
   [n, nz, mp, pp] = sysdimensions(P);
   np = n + nz;
   K = sysupdate(K, "ss");
   [n, nz, mk, pk] = sysdimensions(K);
   nk = n + nz;
   ny_sign = 1;
   nu_sign = 1;
   if (nargin == 2)
-    # perform a LFT of P and K (upper or lower)
+    ## perform a LFT of P and K (upper or lower)
     ny = min([pp, mk]);
     nu = min([pk, mp]);
   else
     if (ny < 0)
       ny = -ny;
       ny_sign = -1;
     endif
     if (nu < 0)
@@ -102,17 +103,17 @@ function [sys] = starp(P, K, ny, nu);
   nzk  = pk - nu;
   if ((nwp + nwk) < 1)
     error("---> no inputs left for star product.");
   endif
   if ((nzp + nzk) < 1)
     error("---> no outputs left for star product.");
   endif
 
-  # checks done, form sys
+  ## checks done, form sys
   if (nzp)  Olst = [1:nzp];  endif
   if (nzk)  Olst = [Olst, pp+nu+1:pp+pk];  endif
   if (nwp)  Ilst = [1:nwp];  endif
   if (nwk)  Ilst = [Ilst, mp+ny+1:mp+mk];  endif
   Clst = zeros(ny+nu,2);
   for ii = 1:nu
     Clst(ii,:) = [nwp+ii, nu_sign*(pp+ii)];
   endfor
diff --git a/scripts/control/step.m b/scripts/control/step.m
--- a/scripts/control/step.m
+++ b/scripts/control/step.m
@@ -1,25 +1,25 @@
-# Copyright (C) 1996 Auburn University.  All Rights Reserved.
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1996 Auburn University.  All Rights Reserved.
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File } {[@var{y}, @var{t}] =} impulse (@var{sys}@{, @var{inp},@var{tstop}, @var{n}@})
 ## Step response for a linear system.
 ##        The system can be discrete or multivariable (or both).
 ## If no output arguments are specified, @code{impulse}
 ##  produces a plot or the step response data for system @var{sys}.
 ## 
@@ -41,36 +41,36 @@
 ## @strong{Outputs}
 ## @var{y}, @var{t}: impulse response
 ## 
 ## When invoked with the output paramter y the plot is not displayed.  
 ## @end deftypefn
  
 ## See also:  impulse, stepimp
 
-# step: Step response for a linear system.
-#       The system can be discrete or multivariable (or both).
-#
-# [y, t] = step(sys[, inp, tstop, n])
-# Produces a plot or the step response data for system sys.
-#
-# The argument tstop (scalar value) denotes the time when the
-# simulation should end. The Parameter n is the number of data values.
-# Both parameters tstop and n can be ommitted and will be
-# computed from the eigenvalues of the A-Matrix.
-#
-# When the step function is invoked with the output parameter y
-# a plot is not displayed.
-#
-# See also: impulse, stepimp
+## step: Step response for a linear system.
+##       The system can be discrete or multivariable (or both).
+##
+## [y, t] = step(sys[, inp, tstop, n])
+## Produces a plot or the step response data for system sys.
+##
+## The argument tstop (scalar value) denotes the time when the
+## simulation should end. The Parameter n is the number of data values.
+## Both parameters tstop and n can be ommitted and will be
+## computed from the eigenvalues of the A-Matrix.
+##
+## When the step function is invoked with the output parameter y
+## a plot is not displayed.
+##
+## See also: impulse, stepimp
 
 function [y, t] = step(sys, inp, tstop, n)
-# Written by Kai P. Mueller September 30, 1997
-# based on lsim.m of Scottedward Hodel
-# modified by
+## Written by Kai P. Mueller September 30, 1997
+## based on lsim.m of Scottedward Hodel
+## modified by
 
   if((nargin < 1) || (nargin > 4))
     usage("[y, u] = step(sys[, inp, tstop, n])");
   endif
 
   if(nargout > 2)
     usage("[y, u] = step(sys[, inp, tstop, n])");
   endif
diff --git a/scripts/control/stepimp.m b/scripts/control/stepimp.m
--- a/scripts/control/stepimp.m
+++ b/scripts/control/stepimp.m
@@ -1,58 +1,59 @@
-# Copyright (C) 1996,1998 Auburn University.  All Rights Reserved.
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1996,1998 Auburn University.  All Rights Reserved.
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File } {[y, t] = } stepimp(@var{sitype},@var{sys}[, @var{inp}, @var{tstop}, @var{n}]) 
 ## Impulse or step response for a linear system.
 ##       The system can be discrete or multivariable (or both).
 ##       This m-file contains the "common code" of step and impulse.
 ## 
 ## Produces a plot or the response data for system sys.
 ## 
 ## Limited argument checking; "do not attempt to do this at home".
 ## Used internally in @code{impulse}, @code{step}. Use @code{step}
 ## or @code{impulse} instead.
 ## 
 ## @end deftypefn
-##  
-## ## See also: step, impulse
+
+## See also: step, impulse
 
 function [y, t] = stepimp(sitype, sys, inp, tstop, n)
-# Written by Kai P. Mueller October 2, 1997
-# based on lsim.m of Scottedward Hodel
+
+  ## Written by Kai P. Mueller October 2, 1997
+  ## based on lsim.m of Scottedward Hodel
 
   if (sitype == 1)         IMPULSE = 0;
   elseif (sitype == 2)     IMPULSE = 1;
   else		   	   error("stepimp: illegal sitype argument.")
   endif
   sys = sysupdate(sys,"ss");
 
   USE_DEF = 0;   # default tstop and n if we have to give up
   N_MIN = 50;    # minimum number of points
   N_MAX = 2000;  # maximum number of points
   T_DEF = 10.0;  # default simulation time
 
-  # collect useful information about the system
+  ## collect useful information about the system
   [ncstates,ndstates,NIN,NOUT] = sysdimensions(sys);
   TSAMPLE = sysgettsam(sys);
 
   if (nargin < 3)                      inp = 1;
   elseif (inp < 1 | inp > NIN)         error("Argument inp out of range")
   endif
 
   DIGITAL = is_digital(sys);
@@ -61,67 +62,67 @@ function [y, t] = stepimp(sitype, sys, i
     if (TSAMPLE < eps)
       error("stepimp: sampling time of discrete system too small.")
     endif
   else        NSTATES = ncstates;       endif
   if (NSTATES < 1)
     error("step: pure gain block (n_states < 1), step response is trivial");
   endif
   if (nargin < 5)
-    # we have to compute the time when the system reaches steady state
-    # and the step size
+    ## we have to compute the time when the system reaches steady state
+    ## and the step size
     ev = eig(sys2ss(sys));
     if (DIGITAL)
-      # perform bilinear transformation on poles in z
+      ## perform bilinear transformation on poles in z
       for i = 1:NSTATES
         pole = ev(i);
 	if (abs(pole + 1) < 1.0e-10)
 	  ev(i) = 0;
 	else
 	  ev(i) = 2 / TSAMPLE * (pole - 1) / (pole + 1);
 	endif
       endfor
     endif
-    # remove poles near zero from eigenvalue array ev
+    ## remove poles near zero from eigenvalue array ev
     nk = NSTATES;
     for i = 1:NSTATES
       if (abs(ev(i)) < 1.0e-10)
         ev(i) = 0;
         nk = nk - 1;
       endif
     endfor
     if (nk == 0)
       USE_DEF = 1;
-      #printf("##STEPIMP-DEBUG: using defaults.\n");
+      ## printf("##STEPIMP-DEBUG: using defaults.\n");
     else
       ev = ev(find(ev));
       x = max(abs(ev));
       t_step = 0.2 * pi / x;
       x = min(abs(real(ev)));
       t_sim = 5.0 / x;
-      # round up
+      ## round up
       yy = 10^(ceil(log10(t_sim)) - 1);
       t_sim = yy * ceil(t_sim / yy);
-      #printf("##STEPIMP-DEBUG: nk=%d   t_step=%f  t_sim=%f\n",
-      #       nk, t_step, t_sim);  
+      ## printf("##STEPIMP-DEBUG: nk=%d   t_step=%f  t_sim=%f\n",
+      ##   nk, t_step, t_sim);  
     endif
   endif
 
   if (DIGITAL)
-    # ---- sampled system
+    ## ---- sampled system
     if (nargin == 5)
       n = round(n);
       if (n < 2)
         error("stepimp: n must not be less than 2.")
       endif
     else
       if (nargin == 4)
-        # n is unknown
+        ## n is unknown
       elseif (nargin >= 1)
-        # tstop and n are unknown
+        ## tstop and n are unknown
         if (USE_DEF)
           tstop = (N_MIN - 1) * TSAMPLE;
         else
           tstop = t_sim;
         endif
       endif
       n = floor(tstop / TSAMPLE) + 1;
       if (n < 2)  n = 2;  endif
@@ -130,34 +131,34 @@ function [y, t] = stepimp(sitype, sys, i
 	printf("Hint: number of samples limited to %d by default.\n", \
 	       N_MAX);
 	printf("  ==> increase \"n\" parameter for longer simulations.\n");
       endif
     endif
     tstop = (n - 1) * TSAMPLE;
     t_step = TSAMPLE;
   else
-    # ---- continuous system
+    ## ---- continuous system
     if (nargin == 5)
       n = round(n);
       if (n < 2)
         error("step: n must not be less than 2.")
       endif
       t_step = tstop / (n - 1);
     else
       if (nargin == 4)
-        # only n in unknown
+        ## only n in unknown
         if (USE_DEF)
           n = N_MIN;
 	  t_step = tstop / (n - 1);
         else
           n = floor(tstop / t_step) + 1;
         endif
       else
-        # tstop and n are unknown
+        ## tstop and n are unknown
         if (USE_DEF)
           tstop = T_DEF;
 	  n = N_MIN;
 	  t_step = tstop / (n - 1);
         else
           tstop = t_sim;
           n = floor(tstop / t_step) + 1;
         endif
@@ -172,17 +173,17 @@ function [y, t] = stepimp(sitype, sys, i
 	n = N_MAX;
       endif
     endif
     tstop = (n - 1) * t_step;
     [jnk,B] = sys2ss(sys);
     B = B(:,inp);
     sys = c2d(sys, t_step);
   endif
-  #printf("##STEPIMP-DEBUG: t_step=%f n=%d  tstop=%f\n", t_step, n, tstop);
+  ## printf("##STEPIMP-DEBUG: t_step=%f n=%d  tstop=%f\n", t_step, n, tstop);
 
   F = sys.a;
   G = sys.b(:,inp);
   C = sys.c;
   D = sys.d(:,inp);
   y = zeros(NOUT, n);
   t = linspace(0, tstop, n);
 
@@ -206,17 +207,17 @@ function [y, t] = stepimp(sitype, sys, i
     x = zeros(NSTATES, 1);
     for i = 1:n
       y(:,i) = C * x + D;
       x = F * x + G;
     endfor
   endif
 
   if(nargout == 0)
-    # Plot the information
+    ## Plot the information
     oneplot();
     gset nogrid
     gset nologscale
     gset autoscale
     gset nokey
     clearplot();
     if (gnuplot_has_multiplot)
       if (IMPULSE)
@@ -252,28 +253,28 @@ function [y, t] = stepimp(sitype, sys, i
 	    yy = y(i,:);
 	  endif
 	  grid("on");
 	  xlabel("time [s]");
 	  ylabel("y(t)");
 	  plot(t, yy);
 	endif
       endfor
-      # leave gnuplot in multiplot mode is bad style
+      ## leave gnuplot in multiplot mode is bad style
       oneplot();
     else
-      # plot everything in one diagram
+      ## plot everything in one diagram
       title([tt, " response | ", sysgetsignals(sys,"in",inp,1), ...
 	" -> all outputs"]);
       if (DIGITAL)
         stairs(t, y(i,:));
       else
 	grid("on");
 	xlabel("time [s]");
 	ylabel("y(t)");
 	plot(t, y(i,:));
       endif
     endif
     y=[];
     t=[];
   endif
-  #printf("##STEPIMP-DEBUG: gratulations, successfull completion.\n");
+  ## printf("##STEPIMP-DEBUG: gratulations, successfull completion.\n");
 endfunction
diff --git a/scripts/control/strappend.m b/scripts/control/strappend.m
--- a/scripts/control/strappend.m
+++ b/scripts/control/strappend.m
@@ -1,29 +1,30 @@
-# Copyright (C) 1998 Auburn University.  All Rights Reserved.
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1998 Auburn University.  All Rights Reserved.
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
  
 function retval = strappend(strlist,suffix);
-  # retval = strappend(strlist,suffix);
-  # append string suffix to each string in the list of strings strlist
+
+  ## retval = strappend(strlist,suffix);
+  ## append string suffix to each string in the list of strings strlist
   
   if(nargin != 2 | nargout > 1)
     usage(" retval = strappend(strlist,suffix)");
   elseif(!is_signal_list(strlist))
     strlist
     error("strlist must be a list of strings (see is_signal_list)");
   elseif(!(isstr(suffix) & rows(suffix) == 1))
     suffix
diff --git a/scripts/control/susball.m b/scripts/control/susball.m
--- a/scripts/control/susball.m
+++ b/scripts/control/susball.m
@@ -1,25 +1,25 @@
-# Copyright (C) 1996 Auburn University.  All Rights Reserved.
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1996 Auburn University.  All Rights Reserved.
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File } { outputs =} susball ( inputs ) 
 ## @format
 ## 
 ## @end format
 ## @end deftypefn
 ## @deftypefn {Function File } { outputs =} swap ( inputs ) 
@@ -100,20 +100,20 @@
     run_cmd;
     sysout(closed_loop);
 
     disp("\nduplicating the plant input");
     cmd = "closed_loop = sysdup(closed_loop,[],1);"
     run_cmd;
     sysout(closed_loop);
 
-#    disp("\nscaling the duplicated input by -1");
-#    cmd = "closed_loop = sysscale(closed_loop,[],diag([1,1,1]));"
-#    run_cmd;
-#    sysout(closed_loop);
+##    disp("\nscaling the duplicated input by -1");
+##    cmd = "closed_loop = sysscale(closed_loop,[],diag([1,1,1]));"
+##    run_cmd;
+##    sysout(closed_loop);
 
     disp("\nconnecting plant output to controller input and controller output");
     disp("to the duplicated plant input");
     cmd = "closed_loop = sysconnect(closed_loop,[1 2],[2 3]);"
     run_cmd;
     sysout(closed_loop);
 
     disp("\nkeeping only the original plant input and plant output");
diff --git a/scripts/control/swap.m b/scripts/control/swap.m
--- a/scripts/control/swap.m
+++ b/scripts/control/swap.m
@@ -1,29 +1,30 @@
-# Copyright (C) 1996 Auburn University.  All Rights Reserved.
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1996 Auburn University.  All Rights Reserved.
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
  
+## usage: [a1,b1] = swap(a,b)
+## interchange a and b
+
 function [a1,b1] = swap(a,b)
-  # [a1,b1] = swap(a,b)
-  # interchange a and b
 
-  # A. S. Hodel July 24 1992
-  # Conversion to Octave R. Bruce Tenison July 4, 1994
+  ## A. S. Hodel July 24 1992
+  ## Conversion to Octave R. Bruce Tenison July 4, 1994
 
   a1 = b;
   b1 = a;
 endfunction
 
diff --git a/scripts/control/swapcols.m b/scripts/control/swapcols.m
--- a/scripts/control/swapcols.m
+++ b/scripts/control/swapcols.m
@@ -1,30 +1,31 @@
-# Copyright (C) 1996 Auburn University.  All Rights Reserved.
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1996 Auburn University.  All Rights Reserved.
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
  
+## usage: B = swapcols(A)
+## permute columns of A into reverse order
+
 function B = swapcols(A)
-  # function B = swapcols(A)
-  # permute columns of A into reverse order
   
-  # A. S. Hodel July 23, 1992
-  # Conversion to Octave R. Bruce Tenison July 4, 1994
+  ## A. S. Hodel July 23, 1992
+  ## Conversion to Octave R. Bruce Tenison July 4, 1994
 
   m = length(A(1,:));
   idx = m:-1:1;
   B = A(:,idx);
 endfunction
 
diff --git a/scripts/control/swaprows.m b/scripts/control/swaprows.m
--- a/scripts/control/swaprows.m
+++ b/scripts/control/swaprows.m
@@ -1,30 +1,31 @@
-# Copyright (C) 1996 Auburn University.  All Rights Reserved.
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1996 Auburn University.  All Rights Reserved.
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
  
+## usage: B = swaprows(A)
+## permute rows of A into reverse order
+
 function B = swaprows(A)
-  # function B = swaprows(A)
-  # permute rows of A into reverse order
 
-  # A. S. Hodel July 23, 1992
-  # Conversion to Octave R. Bruce Tenison July 4, 1994
+  ## A. S. Hodel July 23, 1992
+  ## Conversion to Octave R. Bruce Tenison July 4, 1994
   
   m = rows(A);
   idx = m:-1:1;
   B = A(idx,:);
 endfunction
 
diff --git a/scripts/control/sys2fir.m b/scripts/control/sys2fir.m
--- a/scripts/control/sys2fir.m
+++ b/scripts/control/sys2fir.m
@@ -1,40 +1,41 @@
-# Copyright (C) 1996 Auburn University.  All Rights Reserved.
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1996 Auburn University.  All Rights Reserved.
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File } {[@var{c}, @var{tsam}, @var{input}, @var{output}] =} sys2fir (@var{sys})
 ## 
 ## Extract FIR data from system data structure; see @ref{fir2sys} for
 ## parameter descriptions.
 ## 
 ## @end deftypefn
 
 ## See also: fir2sys
  
 function [c,tsam,inname,outname] = sys2fir(sys)
-# a s hodel July 1996
 
-  # let sys2tf do most of the work
+  ## a s hodel July 1996
+
+  ## let sys2tf do most of the work
 
   [num,den,tsam,inname,outname] = sys2tf(sys);
 
   alph = den(1);			# scale to get monic denominator
   den = den/alph;
   num = num/alph;
   l = length(den);
   m = length(num);
diff --git a/scripts/control/sys2ss.m b/scripts/control/sys2ss.m
--- a/scripts/control/sys2ss.m
+++ b/scripts/control/sys2ss.m
@@ -1,25 +1,25 @@
-# Copyright (C) 1996, 1998 Auburn University.  All Rights Reserved.
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1996, 1998 Auburn University.  All Rights Reserved.
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File } {[@var{a},@var{b},@var{c},@var{d},@var{tsam},@var{n},@var{nz},@var{stname},@var{inname},@var{outname},@var{yd}] =} sys2ss (@var{sys})
 ## Extract state space representation from system data structure.  
 ## 
 ## @strong{Inputs}
 ## @var{sys} system data structure (@xref{sysstruct})
 ## 
@@ -59,18 +59,18 @@
 ##   1
 ## c = 0.66667  0.33333
 ## d = 0
 ## @end example
 ## @end deftypefn
  
 function [a,b,c,d,tsam,n,nz,stname,inname,outname,yd] = sys2ss(sys)
 
-  # Written by David Clem August 19, 1994
-  # Updates by John Ingram July 14, 1996
+  ## Written by David Clem August 19, 1994
+  ## Updates by John Ingram July 14, 1996
 
   if(nargin != 1)
     usage("[a,b,c,d,tsam,n,nz,stname,inname,outname,yd] = sys2ss(sys)")
   endif
 
   if (nargout > 11)
     warning(["sys2ss: ",num2str(nargout)," out arguments exceeds max=11"])
     usage("[a,b,c,d,tsam,n,nz,stname,inname,outname,yd] = sys2ss(sys)")
diff --git a/scripts/control/sys2tf.m b/scripts/control/sys2tf.m
--- a/scripts/control/sys2tf.m
+++ b/scripts/control/sys2tf.m
@@ -1,25 +1,25 @@
-# Copyright (C) 1996 Auburn University.  All Rights Reserved.
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1996 Auburn University.  All Rights Reserved.
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
  
 ## -*- texinfo -*-
 ## @deftypefn {Function File } {[@var{num},@var{den},@var{tsam},@var{inname},@var{outname}] =} sys2tf (@var{sys})
 ## Extract transfer function data from a system data structure
 ## 
 ## See @ref{tf2sys} for parameter descriptions.
 ## 
 ## @strong{Example}
@@ -27,19 +27,19 @@
 ## octave:1> sys=ss2sys([1 -2; -1.1,-2.1],[0;1],[1 1]);
 ## octave:2> [num,den] = sys2tf(sys)
 ## num = 1.0000  -3.0000
 ## den = 1.0000   1.1000  -4.3000
 ## @end example
 ## @end deftypefn
 
 function [num,den,tsam,inname,outname] = sys2tf(Asys)
-# Written by R. Bruce Tenison (June 24, 1994) btenison@eng.auburn.edu
-# modified to make sys2tf by A. S. Hodel Aug 1995
-# modified again for updated system format by John Ingram July 1996
+## Written by R. Bruce Tenison (June 24, 1994) btenison@eng.auburn.edu
+## modified to make sys2tf by A. S. Hodel Aug 1995
+## modified again for updated system format by John Ingram July 1996
 
   if(nargin != 1)
     usage("[num,den,tsam,inname,outname] = sys2tf(Asys)");
   endif
 
   if( !is_struct(Asys))
     error("Asys must be a system data structure (see ss2sys, tf2sys, zp2sys)");
   elseif (! is_siso(Asys) )
diff --git a/scripts/control/sys2zp.m b/scripts/control/sys2zp.m
--- a/scripts/control/sys2zp.m
+++ b/scripts/control/sys2zp.m
@@ -1,25 +1,25 @@
-# Copyright (C) 1996 Auburn University.  All Rights Reserved.
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1996 Auburn University.  All Rights Reserved.
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
 
 ## -*- texinfo -*-
 ##@deftypefn {Function File } {[@var{zer}, @var{pol}, @var{k}, @var{tsam}, @var{inname}, @var{outname}] =} sys2zp (@var{sys})
 ## Extract zero/pole/leading coefficient information from a system data
 ## structure
 ## 
 ## See @ref{zp2sys} for parameter descriptions.
 ## 
@@ -31,29 +31,30 @@
 ## pol =
 ##   -2.6953
 ##    1.5953
 ## k = 1
 ## @end example
 ## @end deftypefn
  
 function [zer,pol,k,tsam,inname,outname] = sys2zp(sys)
-# Created by John Ingram July 15 1996
+
+  ## Created by John Ingram July 15 1996
 
   if(nargin != 1)
     usage("[zer,pol,k,tsam,inname,outname] = sys2zp(sys)");
   elseif( !is_struct(sys))
     error("sysconnect: sys must be in system data structure form")
   elseif (! is_siso(sys) )
     [n, nz, m, p] = sysdimensions(sys);
     error(["system is not SISO (",num2str(m)," inputs, ...
 	", num2str(p)," outputs"]);
   endif
 
-  # update zero-pole form
+  ## update zero-pole form
   sys = sysupdate(sys,"zp");
 
   zer = sys.zer;
   pol = sys.pol;
   k = sys.k;
   tsam    = sysgettsam(sys);
   inname  = sysgetsignals(sys,"in");
   outname = sysgetsignals(sys,"out");
diff --git a/scripts/control/sysadd.m b/scripts/control/sysadd.m
--- a/scripts/control/sysadd.m
+++ b/scripts/control/sysadd.m
@@ -1,25 +1,25 @@
-# Copyright (C) 1996,1999 Auburn University.  All Rights Reserved.
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1996,1999 Auburn University.  All Rights Reserved.
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File } { @var{sys} =}  sysadd ( @var{Gsys},@var{Hsys})
 ## returns @var{sys} = @var{Gsys} + @var{Hsys}.  
 ## @itemize @bullet
 ## @item Exits with
 ## an error if @var{Gsys} and @var{Hsys} are not compatibly dimensioned.
 ## @item Prints a warning message is system states have identical names;
@@ -35,84 +35,85 @@
 ##     |     ________   +|
 ##      ----|  Hsys  |---
 ##           --------
 ## @end group
 ## @end example
 ## @end deftypefn
  
 function sys = sysadd(...)
-# Written by John Ingram July 1996
-# Updated for variable number of arguments July 1999 A. S. Hodel
+
+  ## Written by John Ingram July 1996
+  ## Updated for variable number of arguments July 1999 A. S. Hodel
 
   save_val = implicit_str_to_num_ok;	# save for later
   implicit_str_to_num_ok = 1;
 
   if(nargin < 1)
     usage("sysadd: sys = sysysadd(Gsys{,Hsys, ...})");
   endif
 
-  # collect all arguments
+  ## collect all arguments
   arglist = list();
   va_start();
   for kk=1:nargin
     arglist(kk) = va_arg();
     if(!is_struct(nth(arglist,kk)))
       error("sysadd: argument %d is not a data structure",kk);
     endif
   endfor
 
-  # check system dimensions
+  ## check system dimensions
   [n,nz,mg,pg,Gyd] = sysdimensions(nth(arglist,1));
   for kk=2:nargin
     [n,nz,mh,ph,Hyd] = sysdimensions(nth(arglist,kk));
     if(mg != mh)
       error("arg 1 has %d inputs; arg %d has vs %d inputs",mg,kk,mh);
     elseif(pg != ph)
       error("arg 1 has %d outputs; arg %d has vs %d outputs",pg,kk,ph);
     elseif(norm(Gyd - Hyd))
       warning("cannot add a discrete output to a continuous output");
       error("Output type mismatch: arguments 1 and %d\n",kk);
     endif
   endfor
 
-  # perform the add
+  ## perform the add
   if(nargin == 2)
     Gsys = nth(arglist,1);   Hsys = nth(arglist,2);
     if( strcmp(sysgettype(Gsys),"tf") | strcmp(sysgettype(Hsys),"tf") )
-      # see if adding  transfer functions with identical denominators
+      ## see if adding  transfer functions with identical denominators
       [Gnum,Gden,GT,Gin,Gout] = sys2tf(Gsys);
       [Hnum,Hden,HT,Hin,Hout] = sys2tf(Hsys);
       if(length(Hden) == length(Gden) )
         if( (Hden == Gden) & (HT == GT) )
           sys = tf2sys(Gnum+Hnum,Gden,GT,Gin,Gout);
           return
         endif
-        # if not, we go on and do the usual thing...
+        ## if not, we go on and do the usual thing...
       endif
     endif
   
-    # make sure in ss form
+    ## make sure in ss form
     Gsys = sysupdate(Gsys,"ss");
     Hsys = sysupdate(Hsys,"ss");
   
-    # change signal names to avoid warning messages from sysgroup
+    ## change signal names to avoid warning messages from sysgroup
     Gsys = syssetsignals(Gsys,"in",sysdefioname(length(Gin),"Gin_u"));
     Gsys = syssetsignals(Gsys,"out",sysdefioname(length(Gout),"Gout_u"));
     Hsys = syssetsignals(Hsys,"in",sysdefioname(length(Hin),"Hin_u"));
     Hsys = syssetsignals(Hsys,"out",sysdefioname(length(Hout),"Hout_u"));
     
     sys = sysgroup(Gsys,Hsys);
   
     eyin = eye(mg);
     eyout = eye(pg);
   
     sys = sysscale(sys,[eyout, eyout],[eyin;eyin],Gout,Gin);
   
   else
-    # multiple systems (or a single system); combine together one by one
+    ## multiple systems (or a single system); combine together one by one
     sys = nth(arglist,1);
     for kk=2:length(arglist)
       sys = sysadd(sys,nth(arglist,kk));
     endfor
   endif
 endfunction
 
diff --git a/scripts/control/sysappend.m b/scripts/control/sysappend.m
--- a/scripts/control/sysappend.m
+++ b/scripts/control/sysappend.m
@@ -1,25 +1,25 @@
-# Copyright (C) 1996,1998 Auburn University.  All Rights Reserved.
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1996,1998 Auburn University.  All Rights Reserved.
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
  
 ## -*- texinfo -*-
 ## @deftypefn {Function File } {@var{retsys} =} sysappend (@var{sys},@var{b}@{, @var{c}, @var{d}, @var{outname}, @var{inname}, @var{yd}@})
 ## appends new inputs and/or outputs to a system
 ## 
 ## @strong{Inputs}
 ## @table @var
 ## @item sys
@@ -70,125 +70,124 @@
 ## @item @var{sys} = discrete
 ## @var{yd} = @code{ones(1,rows(c))}
 ## 
 ## @end itemize
 ## 
 ## @end deftypefn
 
 function retsys = sysappend(sys,b,c,d,outname,inname,yd)
-  # written by John Ingram August 1996
+
+  ## written by John Ingram August 1996
   
   sav_implicit_str_to_num_ok = implicit_str_to_num_ok;	# save for later
   sav_empty_list_elements_ok = empty_list_elements_ok;
 
   empty_list_elements_ok = 1;                implicit_str_to_num_ok = 1;
   
-  # check input arguments
+  ## check input arguments
   if ( (nargin < 2) | (nargin > 7) | (!is_struct(sys)))
     usage("retsys = sysappend(sys,b,c[,d,outname,inname,yd]) ");
   elseif(!is_struct(sys))
     error("sys must be a system data structure");
   endif
   
-  # default system type must be state space form
+  ## default system type must be state space form
   [Aa,Ab,Ac,Ad,Ats,Ann,Anz,Ast,Ain,Aout,Ayd] = sys2ss(sys);
   [Ann,Anz,Am,Ap] = sysdimensions(sys);
 
-  #default c
+  ## default c
   if(nargin < 3)      c = [];                                endif
   
-  #default d
+  ## default d
   if(nargin < 4)     make_d = 1;
   elseif(isempty(d)) make_d = 1;
   else               make_d = 0;                             endif
   if(make_d)         d = zeros(rows(c)+Ap,columns(b) + Am);  endif
 
-  #
-  # Append new input(s) if any
+  ## Append new input(s) if any
   Bm = max(columns(d),columns(b)+Am);
   if(Bm != Am)    
-    # construct new signal names
+    ## construct new signal names
     if(nargin >= 6)   # new names were passed
       if(!isstr(inname))
         error("inname must be a string");
       elseif(rows(inname) != (Bm - Am))
         error(sprintf("%d new inputs requested; inname(%dx%d)", ...
 	  (Bm-Am),rows(inname),columns(inname)));
       endif
     else
       inname = sysdefioname(Bm,"u",(Am+1));
     endif
     if(Am)   Ain = append(Ain,inname);
     else     Ain = inname;		endif
 
-    # default b matrix
+    ## default b matrix
     if(isempty(b))     b  = zeros(Ann+Anz,(Bm-Am));          
     elseif(rows(b) != Ann+Anz | columns(b) != (Bm-Am))
         error(sprintf("b(%dx%d); should be (%dx%d)", rows(b), columns(b), ...
           (Ann+Anz), (Bm-Am)));
     endif
 
-    # append new b matrix
+    ## append new b matrix
     Ab = [Ab,b];    # empty_list_elements_ok=1 makes this ok
   endif
 
-  #
-  # Append new output(s) if any
+  ## Append new output(s) if any
   Bp = max(rows(d),rows(c)+Ap);
   if(Bp != Ap)  
 
-    # construct new signal names, output classification
+    ## construct new signal names, output classification
     if(nargin >= 5)  # new names were passed
       if(!isstr(outname))
         error("outname must be a string");
       elseif(rows(outname) != (Bp - Ap))
         error(sprintf("%d new outputs requested; outname(%dx%d)", ...
           (Bp-Ap),rows(outname),columns(outname)));
       endif
     else
       outname = sysdefioname(Bp,"y",(Ap+1));
     endif
     if(Ap)   Aout = append(Aout,outname);
     else     Aout = outname;                endif
 
-    # construct new yd entries
+    ## construct new yd entries
     if(nargin == 7)
       if(!is_vector(yd))
         error(sprintf("yd(%dx%d) must be a vector",rows(yd),columns(yd)))
       elseif(rows(c) != length(yd) & rows(d) != length(yd))
         error(sprintf("length(yd) = %d; c(%dx%d), d(%dx%d); mismatch", ...
 	  length(yd), rows(c), columns(c),rows(d),columns(d)));
       endif
     else
-      # default yd values
+      ## default yd values
       yd = ones(1,Bp)*( (Ats > 0) & (Ann == 0)  & isempty(find(Ayd == 0)) ) ;
     endif
     Ayd = [vec(Ayd);vec(yd)];
 
-    # default c matrix
+    ## default c matrix
     if(isempty(c))      c = zeros((Bp-Ap),Ann+Anz);          
     elseif(columns(c) != Ann+Anz | rows(c) != (Bp-Ap))
         error(sprintf("c(%dx%d); should be (%dx%d)", rows(c), columns(c), ...
           (Bp-Ap), (Ann+Anz) ));
     endif
 
-    # append new c matrix
+    ## append new c matrix
     Ac = [Ac;c];    # empty_list_elements_ok=1 makes this ok
   endif
 
-  # check d matrix
+  ## check d matrix
   if(isempty(d)) d = zeros(Bp,Bm);
   elseif(rows(d) != Bp | columns(d) != Bm)
     error(sprintf("d(%dx%d) should be (%dx%d)",rows(d), columns(d), Bp, Bp));
   endif
 
-  # Splice in original D matrix  
+  ## Splice in original D matrix  
   if(Am & Ap)          d(1:Ap, 1:Am) = Ad;       endif
   Ad = d;
   
-  # construct return system
+  ## construct return system
   retsys = ss2sys(Aa,Ab,Ac,Ad,Ats,Ann,Anz,Ast,Ain,Aout,find(Ayd == 1));
   
   implicit_str_to_num_ok = sav_implicit_str_to_num_ok;	# restore value
   empty_list_elements_ok = sav_empty_list_elements_ok;
 
 endfunction
diff --git a/scripts/control/syschnames.m b/scripts/control/syschnames.m
--- a/scripts/control/syschnames.m
+++ b/scripts/control/syschnames.m
@@ -1,29 +1,29 @@
-# Copyright (C) 1996,1998 Auburn University.  All Rights Reserved.
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1996,1998 Auburn University.  All Rights Reserved.
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
 
 ## -*- texinfo -*- 
 ## @deftypefn {Function File } {@var{retsys} =} syschnames (@var{sys}, @var{opt}, @var{list}, @var{names})
 ## Superseded by @code{syssetsignals}
 ## @end deftypefn
 
 function retsys = syschnames(sys,opt,list,names)
-# Written by John Ingram August 1996; updated by A. S. Hodel 1998
+## Written by John Ingram August 1996; updated by A. S. Hodel 1998
 
   retsys = syssetsignals(sys,opt,names,list);
 
 endfunction
diff --git a/scripts/control/syschnamesl.m b/scripts/control/syschnamesl.m
--- a/scripts/control/syschnamesl.m
+++ b/scripts/control/syschnamesl.m
@@ -1,67 +1,66 @@
-# Copyright (C) 1996 Auburn University.  All Rights Reserved.
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1996 Auburn University.  All Rights Reserved.
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File } { } syschnamesl 
 ##  used internally in syschnames
 ##  item olist: index list 
 ##  old_names: original list names
 ##  inames: new names
 ##  listname: name of index list
 ## 
 ##  combines the two string lists old_names and inames
 ## @end deftypefn
  
 function old_names = syschnamesl(olist,old_names,inames,listname)
-  # $Revision: 2.1.14.5 $
-  # $Log: syschnamesl.m,v $
-# Revision 2.1.14.5  1999/09/22  21:55:46  scotte
-# Auburn copyright fixed; krylov.m patched to fix bug
-#
-# Revision 2.1.14.4  1999/07/21  19:49:21  scotte
-# sysgroup, sysadd, sysmult, syssub accept variable # of input args
-#
-  # Revision 1.3  1998/07/17 15:08:50  hodelas
-  # use isempty instead of max(size(...))
-  #
-  # Revision 1.2  1998/07/01 16:23:39  hodelas
-  # Updated c2d, d2c to perform bilinear transforms.
-  # Updated several files per bug updates from users.
-  #
-  # Revision 1.5  1997/02/28 23:47:26  hodel
-  # fixed bug in checking parameters; (inames dimension not checked against olist)
-  # a.s.hodel@eng.auburn.edu
-  #
-  # Revision 1.4  1997/02/13 15:56:37  hodel
-  # added code to convert zeros in the name matrix to blanks
-  # a.s.hodel@eng.auburn.edu
-  #
-  # Revision 1.3  1997/02/13 15:11:17  hodel
-  # fixed bug when len_my < len_out a.s.hodel@eng.auburn.edu
-  #
-  # Revision 1.2  1997/02/12 22:54:50  hodel
-  # fixed string matrix <-> numerical matrix problem
-  #
+  ## $Revision: 2.1.14.5 $
+  ## $Log: syschnamesl.m,v $
+  ## Revision 2.1.14.5  1999/09/22  21:55:46  scotte
+  ## Auburn copyright fixed; krylov.m patched to fix bug
+  ##
+  ## Revision 2.1.14.4  1999/07/21  19:49:21  scotte
+  ## sysgroup, sysadd, sysmult, syssub accept variable # of input args
+  ##
+  ## Revision 1.3  1998/07/17 15:08:50  hodelas
+  ## use isempty instead of max(size(...))
+  ## 
+  ## Revision 1.2  1998/07/01 16:23:39  hodelas
+  ## Updated c2d, d2c to perform bilinear transforms.
+  ## Updated several files per bug updates from users.
+  ## 
+  ## Revision 1.5  1997/02/28 23:47:26  hodel
+  ## fixed bug in checking parameters; (inames dimension not checked against olist)
+  ## a.s.hodel@eng.auburn.edu
+  ## 
+  ## Revision 1.4  1997/02/13 15:56:37  hodel
+  ## added code to convert zeros in the name matrix to blanks
+  ## a.s.hodel@eng.auburn.edu
+  ## 
+  ## Revision 1.3  1997/02/13 15:11:17  hodel
+  ## fixed bug when len_my < len_out a.s.hodel@eng.auburn.edu
+  ## 
+  ## Revision 1.2  1997/02/12 22:54:50  hodel
+  ## fixed string matrix <-> numerical matrix problem
   
   probstr = [];
   if( max(olist) > rows(old_names) )
     probstr = ["index list value(s) exceed(s) number of signals (", ...
       num2str(rows(old_names)),")"];
 
   elseif( length(olist) > rows(inames) )
     probstr = ["index list dimension exceeds number of replacement names (", ...
@@ -101,45 +100,45 @@ function old_names = syschnamesl(olist,o
 	  len_my = len_out;
         endif
 
         old_names(olist(ii),1:len_my) = mystr;
       endfor
     endif
   endif
   if(!isempty(probstr))
-    # the following lines are NOT debugging code!
+    ## the following lines are NOT debugging code!
     disp("Problem in syschnames: old names are")
     outlist(old_names,"	")
     disp("new names are")
     outlist(inames,"	")
     disp("list indices are")
     disp(olist)
     error(sprintf("syschnames: \"%s\" dim=(%d x %d)--\n\t%s\n", ...
 	listname, rows(olist), columns(olist),probstr));
   endif
 
-  # change zeros  to blanks
+  ## change zeros  to blanks
   if( find(old_names == 0) )
-    #disp("syschnamesl: old_names contains zeros ")
-    #old_names
-    #disp("/syschnamesl");
+    ## disp("syschnamesl: old_names contains zeros ")
+    ## old_names
+    ## disp("/syschnamesl");
 
     [ii,jj] = find(old_names == 0);
     for idx=1:length(ii)
       old_names(ii(idx),jj(idx)) = " ";
     endfor
 
-    #disp("syschnamesl: old_names fixed zeros ")
-    #old_names
-    #disp("/syschnamesl");
+    ## disp("syschnamesl: old_names fixed zeros ")
+    ## old_names
+    ## disp("/syschnamesl");
   endif
 
-  # just in case it's not a string anymore
+  ## just in case it's not a string anymore
   if( !isstr(old_names) )
     old_names = setstr(old_names);
   endif
   
-  #disp("syschnamesl: exit, old_names=")
-  #old_names
-  #disp("/syschnamesl: exiting")
+  ## disp("syschnamesl: exit, old_names=")
+  ## old_names
+  ## disp("/syschnamesl: exiting")
   
 endfunction
diff --git a/scripts/control/syschtsam.m b/scripts/control/syschtsam.m
--- a/scripts/control/syschtsam.m
+++ b/scripts/control/syschtsam.m
@@ -1,34 +1,34 @@
-# Copyright (C) 1996 Auburn University.  All Rights Reserved.
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1996 Auburn University.  All Rights Reserved.
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File } { retsys =} syschtsam ( sys,tsam ) 
 ## This function changes the sampling time (tsam) of the system.  Exits with
 ## an error if sys is purely continuous time.
 ## @end deftypefn
  
 function retsys = syschtsam(sys,tsam)
-# Written by John Ingram August 1996
+## Written by John Ingram August 1996
 
   if (nargin != 2)
     usage("retsys = syschtsam(sys,tsam)");
   elseif (!is_struct(sys))
     error("sys must be in system data structure form");
   elseif(!is_scalar(tsam))
     disp("syschtsam:")
     tsam
diff --git a/scripts/control/sysconnect.m b/scripts/control/sysconnect.m
--- a/scripts/control/sysconnect.m
+++ b/scripts/control/sysconnect.m
@@ -1,25 +1,25 @@
-# Copyright (C) 1996,1998 Auburn University.  All Rights Reserved.
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1996,1998 Auburn University.  All Rights Reserved.
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
 
 ## -*- texinfo -*- 
 ## @deftypefn {Function File } {@var{retsys} =} sysconnect (@var{sys}, @var{out_idx},@var{in_idx}@{,@var{order}, @var{tol}@})
 ## Close the loop from specified outputs to respective specified inputs
 ## 
 ## @strong{Inputs}
 ## @table @var
 ## @item   sys
@@ -59,43 +59,44 @@
 ## @end group
 ## @end example
 ## The input that has the summing junction added to it has an * added to the end 
 ## of the input name.
 ## 
 ## @end deftypefn
 
 function sys = sysconnect(sys,output_list,input_list,order,tol)
-# A. S. Hodel August 1995
-# modified by John Ingram July 1996
+
+  ## A. S. Hodel August 1995
+  ## modified by John Ingram July 1996
 
   save_val = implicit_str_to_num_ok;	# save for later
   implicit_str_to_num_ok = 1;
 
   if( (nargin < 3) | (nargin > 5) )
     usage("retsys = sysconnect(sys,output_list,input_list[,order,tol])");
   endif
 
-  # check order
+  ## check order
   if(nargin <= 3)
     order = 0;
   elseif( (order != 0) & (order != 1) )
     error("sysconnect: order must be either 0 or 1")
   endif
 
   if (nargin <= 4)
     tol = 200*eps;
   elseif( !is_sample(tol) )
     error("sysconnect: tol must be a positive scalar");
   elseif(tol > 1e2*sqrt(eps))
     warning(["sysconnect: tol set to large value=",num2str(tol), ...
 	", eps=",num2str(eps)])
   endif
 
-  # verify sizes,format of input, output lists
+  ## verify sizes,format of input, output lists
   if( min(size(output_list))*min(size(input_list)) != 1)
     error("output_list and input_list must be vectors");
   else
     lo = length(output_list);
     li = length(input_list);
     if(lo != li)
       error("output_list and input_list must be of the same length")
     endif
@@ -113,50 +114,50 @@ function sys = sysconnect(sys,output_lis
   elseif(pp < li)
     error(["length(output_list)=",num2str(li),", sys has only ", ...
 	num2str(pp),"system outputs"])
   elseif(mm < li)
     error(["length(input_list)=",num2str(li),", sys has only ", ...
 	num2str(mm),"system inputs"])
   endif
 
-  # check that there are enough inputs/outputs in the system for the lists
+  ## check that there are enough inputs/outputs in the system for the lists
   if(max(input_list) > mm) 
     error("max(input_list) exceeds the number of inputs");
   elseif(max(output_list) > pp)
     error("max(output_list) exceeds the number of outputs");
   endif
 
   output_list = reshape(output_list,1,length(output_list));
 
-  # make sure we're in state space form
+  ## make sure we're in state space form
   sys = sysupdate(sys,'ss');
 
-  # permute rows and columns of B,C,D matrices into pseudo-dgkf form...
+  ## permute rows and columns of B,C,D matrices into pseudo-dgkf form...
   all_inputs = sysreorder(mm,input_list);
   all_outputs = sysreorder(pp,output_list);
 
   [aa,bb,cc,dd] = sys2ss(sys);
   bb = bb(:,all_inputs);
   cc = cc(all_outputs,:);
   dd = dd(all_outputs,all_inputs);
 
   yd = sysgetsignals(sys,"yd");
   yd = yd(all_outputs);
 
-  # m1, p1 = number of inputs, outputs that are not being connected
+  ## m1, p1 = number of inputs, outputs that are not being connected
   m1 = mm-li;
   p1 = pp-li;
 
-  # m2, p2: 1st column, row of B, C that is being connected
+  ## m2, p2: 1st column, row of B, C that is being connected
   m2 = m1+1;
   p2 = p1+1;
 
-  # partition system into a DGKF-like form; the loop is closed around
-  # B2, C2
+  ## partition system into a DGKF-like form; the loop is closed around
+  ## B2, C2
   if(m1 > 0)
     B1 = bb(:,1:m1);
     D21= dd(p2:pp,1:m1);
   endif
   B2 = bb(:,m2:mm);
   if(p1 > 0)
     C1 = cc(1:p1,:);
     D12= dd(1:p1,m2:mm);
@@ -179,23 +180,23 @@ function sys = sysconnect(sys,output_lis
     C2h = C2;
     if(m1 > 0)
       D21h = D21;
     endif
     D22h = D22;
 
   endif
 
-  # check cont state -> disc output -> cont state
+  ## check cont state -> disc output -> cont state
   dyi = find(yd(p2:pp));
 
-  #disp("sysconnect: dyi=")
-  #dyi
-  #nc
-  #disp("/sysconnect");
+  ## disp("sysconnect: dyi=")
+  ## dyi
+  ## nc
+  ## disp("/sysconnect");
 
   if( (nc > 0) & find(dyi > 0) )
     B2con = B2(1:nc,dyi);	# connection to cont states
     C2hd = C2h(dyi,1:nc);	# cont states -> outputs
   else
     B2con = C2hd = [];
   endif
 
@@ -214,17 +215,17 @@ function sys = sysconnect(sys,output_lis
   if(p1*m1 > 0)
     D11c = D11 + D12*D21h;
   endif
   if(p1 > 0)
     C1c  = C1+D12*C2h;
     D12c = D12*(eye(size(D22h))+D22h);
   endif
 
-  # construct system data structure
+  ## construct system data structure
   if(m1 > 0)
    Bc = [B1c, B2c];
   else
    Bc = B2c;
   endif
 
   if(p1 > 0)
     Cc = [C1c;C2h];
@@ -237,42 +238,42 @@ function sys = sysconnect(sys,output_lis
   elseif(m1 > 0)
     Dc = [D21h, D22h];
   elseif(p1 > 0)
     Dc = [D12c; D22h];
   else
     Dc = D22h;
   endif 
 
-  # permute rows and columns of Bc, Cc, Dc back into original order
+  ## permute rows and columns of Bc, Cc, Dc back into original order
   Im = eye(mm,mm);
   Pi = Im(:,all_inputs);
   back_inputs = Pi*[1:mm]';
 
   Ip = eye(pp,pp);
   Po = Ip(:,all_outputs);
   back_outputs = Po*[1:pp]';
 
   Bc = Bc(:,back_inputs);
   Cc = Cc(back_outputs,:);
   Dc = Dc(back_outputs,back_inputs);
   yd = yd(back_outputs);
 
-  # rebuild system
+  ## rebuild system
   Ts = sysgettsam(sys);
   [stnam,innam,outnam] = sysgetsignals(sys);
   sys = ss2sys(Ac,Bc,Cc,Dc,Ts,nc,nz,stnam,innam,outnam,find(yd));
 
-  # update connected input names
+  ## update connected input names
   for ii = 1:length(input_list)
     idx = input_list(ii);
     strval = sprintf("%s*",nth(sysgetsignals(sys,"in",idx),1) );
     sys = syssetsignals(sys,"in",strval,idx);
   endfor
   
-  # maintain original system type if it was SISO
+  ## maintain original system type if it was SISO
   if    (strcmp(sysgettype(sys),"tf") )       sysupdate(sys,'tf');
   elseif(strcmp(sysgettype(sys),"zp") )       sysupdate(sys,'zp');
   endif
 
   implicit_str_to_num_ok = save_val;	# restore value  
 
 endfunction
diff --git a/scripts/control/syscont.m b/scripts/control/syscont.m
--- a/scripts/control/syscont.m
+++ b/scripts/control/syscont.m
@@ -1,25 +1,25 @@
-# Copyright (C) 1996 Auburn University.  All Rights Reserved.
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1996 Auburn University.  All Rights Reserved.
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} { [@var{csys}, @var{Acd}, @var{Ccd}] = } syscont (@var{sys})
 ## Extract the purely continuous subsystem of an input system.
 ## 
 ## @strong{Inputs}
 ## @var{sys} is a system data structure
 ## 
@@ -32,32 +32,33 @@
 ##                discrete states to continuous outputs, respectively.
 ## 
 ##  returns @var{csys} empty if no continuous/continous path exists
 ## @end table
 ## 
 ## @end deftypefn
  
 function [csys,Acd,Ccd] = syscont(sys)
-# Written by John Ingram August 1996
+
+  ## Written by John Ingram August 1996
 
   save_val = implicit_str_to_num_ok;	# save for later
   save_empty = empty_list_elements_ok;
   empty_list_elements_ok = implicit_str_to_num_ok = 1;
 
   if (nargin != 1)
     usage("[csys,Acd,Ccd,Dcd] = syscont(sys)");
   elseif (!is_struct(sys))
     error("sys must be in system data structure form");
   endif
 
   sys = sysupdate(sys,"ss");
   [n_tot,st_c,st_d,y_c,y_d] = syscont_disc(sys);	# get ranges
 
-  # assume there's nothing there; build partitions as appropriate
+  ## assume there's nothing there; build partitions as appropriate
   Acc = Acd = Bcc = Ccc = Ccd = Dcc = [];
 
   if(isempty(st_c) & isempty(y_c))
     error("syscont: expecting continous states and/or continous outputs");
   elseif (isempty(st_c))
     warning("syscont: no continuous states");
   elseif(isempty(y_c))
     warning("syscont: no continuous outputs");
diff --git a/scripts/control/syscont_disc.m b/scripts/control/syscont_disc.m
--- a/scripts/control/syscont_disc.m
+++ b/scripts/control/syscont_disc.m
@@ -1,25 +1,25 @@
-# Copyright (C) 1996,1998 Auburn University.  All Rights Reserved.
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1996,1998 Auburn University.  All Rights Reserved.
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File } { [@var{n_tot}, @var{st_c}, @var{st_d}, @var{y_c}, @var{y_d}] =} syscont_disc(@var{sys})
 ## Used internally in syscont and sysdisc.
 ## 
 ## @strong{Inputs}
 ## @var{ sys} is a system data structure.
 ## 
@@ -35,19 +35,20 @@
 ## vector of continuous output indices
 ## @item y_d
 ## vector of discrete output indices
 ## @end table
 ## 
 ## @end deftypefn
  
 function [n_tot,st_c,st_d,y_c,y_d] = syscont_disc(sys)
-# Written by A. S. Hodel (a.s.hodel@eng.auburn.edu) Feb 1997
 
-  # get ranges for discrete/continuous states and outputs
+  ## Written by A. S. Hodel (a.s.hodel@eng.auburn.edu) Feb 1997
+
+  ## get ranges for discrete/continuous states and outputs
   [nn,nz,mm,pp,yd] = sysdimensions(sys);
   n_tot = nn + nz;
   st_c = 1:(nn);
   st_d = nn + (1:nz);
   y_c = find(yd == 0);		# y_c, y_d will be empty if there are none.
   y_d = find(yd == 1);
 
 endfunction
diff --git a/scripts/control/sysdefioname.m b/scripts/control/sysdefioname.m
--- a/scripts/control/sysdefioname.m
+++ b/scripts/control/sysdefioname.m
@@ -1,25 +1,25 @@
-# Copyright (C) 1996,1998 Auburn University.  All Rights Reserved.
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1996,1998 Auburn University.  All Rights Reserved.
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File } { @var{ioname} =} sysdefioname (@var{n},@var{str} @{,@var{m}@})
 ## return default input or output names given @var{n}, @var{str}, @var{m}.
 ##  @var{n} is the final value, @var{str} is the string prefix, and @var{m}
 ## is start value
 ## 
 ##  used internally, minimal argument checking
diff --git a/scripts/control/sysdefstname.m b/scripts/control/sysdefstname.m
--- a/scripts/control/sysdefstname.m
+++ b/scripts/control/sysdefstname.m
@@ -1,25 +1,25 @@
-# Copyright (C) 1996 Auburn University.  All Rights Reserved.
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1996 Auburn University.  All Rights Reserved.
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
 
 ## -*- texinfo -*- 
 ## @deftypefn {Function File } { @var{stname} =} sysdefstname (@var{n}, @var{nz}) 
 ##  return default state names given @var{n}, @var{nz}
 ## 
 ##  used internally, minimal argument checking
 ## @end deftypefn
 
@@ -27,16 +27,16 @@ function stname = sysdefstname(n,nz)
 
   stname = list();
   if(n > 0)
     for ii = 1:n
       stname(ii) = sprintf("x_%d",ii);
     endfor
   endif
  
-  # Set default names for discrete states
+  ## Set default names for discrete states
   if(nz > 0)
     for ii = (n+1):(n+nz)
       stname(ii) = sprintf("xd_%d",ii);
     endfor
   endif
 
 endfunction
diff --git a/scripts/control/sysdimensions.m b/scripts/control/sysdimensions.m
--- a/scripts/control/sysdimensions.m
+++ b/scripts/control/sysdimensions.m
@@ -1,25 +1,25 @@
-# Copyright (C) 1996,1998 Auburn University.  All Rights Reserved.
-#
-# This file is part of Octave.
-#
-# Octave is free software; you can redistribute it and/or modify it
-# under the terms of the GNU General Public License as published by the
-# Free Software Foundation; either version 2, or (at your option) any
-# later version.
-#
-# Octave is distributed in the hope that it will be useful, but WITHOUT
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-# for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Octave; see the file COPYING.  If not, write to the Free
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
+## Copyright (C) 1996,1998 Auburn University.  All Rights Reserved.
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
+##
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+## for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File } { [@var{n}, @var{nz}, @var{m}, @var{p},@var{yd}] =} sysdimensions (@var{sys}@{, @var{opt}@})
 ##  return the number of states, inputs, and/or outputs in the system @var{sys}.
 ## 
 ## @strong{Inputs}
 ## @table @var
 ## @item sys
diff --git a/scripts/control/sysdisc.m b/scripts/control/sysdisc.m
--- a/scripts/control/sysdisc.m
+++ b/scripts/control/sysdisc.m
@@ -1,25 +1,25 @@
-# Copyright (C) 1996 Auburn University.  All Rights Reserved.
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1996 Auburn University.  All Rights Reserved.
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File } { [@var{dsys}, @var{Adc}, @var{Cdc}] =} sysdisc (@var{sys})
 ## 
 ## @strong{Inputs}
 ## @var{sys} = system data structure
 ## 
 ## @strong{Outputs}
@@ -30,40 +30,41 @@
 ## @item    Adc, Cdc
 ##  connections from continuous states to discrete states and discrete
 ##     outputs, respectively.
 ## @end table
 ## 
 ## @end deftypefn
  
 function [dsys,Adc,Cdc] = sysdisc(sys)
-# function [dsys,Adc,Cdc] = sysdisc(sys)
-# inputs: sys = system data structure
-# outputs:
-#    dsys: purely discrete portion of sys (returned empty if there is
-#          no purely discrete path from inputs to outputs)
-#    Adc, Cdc: connections from continuous states to discrete states/discrete
-#    outputs, respectively.
-#
+
+  ## function [dsys,Adc,Cdc] = sysdisc(sys)
+  ## inputs: sys = system data structure
+  ## outputs:
+  ##    dsys: purely discrete portion of sys (returned empty if there is
+  ##          no purely discrete path from inputs to outputs)
+  ##    Adc, Cdc: connections from continuous states to discrete states/discrete
+  ##    outputs, respectively.
+  ##
 
   save_val = implicit_str_to_num_ok;	# save for later
   save_empty = empty_list_elements_ok;
   empty_list_elements_ok = implicit_str_to_num_ok = 1;
 
 
   if (nargin != 1)
     usage("[dsys,Adc,Cdc] = sysdisc(sys)");
   elseif (!is_struct(sys))
     error("sys must be in system data structure form");
   endif
 
   sys = sysupdate(sys,"ss");
   [n_tot,st_c,st_d,y_c,y_d] = syscont_disc(sys);	# get ranges
 
-  # assume there's nothing there; build partitions as appropriate
+  ## assume there's nothing there; build partitions as appropriate
   Add = Adc = Bdd = Cdd = Cdc = Ddd = [];
   
   if(isempty(st_d) & isempty(y_d))
     error("sysdisc: expecting discrete states and/or continous outputs");
   elseif (isempty(st_d))
     warning("sysdisc: no discrete states");
   elseif(isempty(y_d))
     warning("sysdisc: no discrete outputs");
diff --git a/scripts/control/sysdup.m b/scripts/control/sysdup.m
--- a/scripts/control/sysdup.m
+++ b/scripts/control/sysdup.m
@@ -1,25 +1,25 @@
-# Copyright (C) 1996,1998 Auburn University.  All Rights Reserved.
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1996,1998 Auburn University.  All Rights Reserved.
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
  
 ## -*- texinfo -*-
 ## @deftypefn {Function File } { @var{retsys} =} sysdup (@var{Asys}, @var{out_idx}, @var{in_idx})
 ##  Duplicate specified input/output connections of a system
 ## 
 ## @strong{Inputs}
 ## @table @var
 ## @item Asys
@@ -47,74 +47,75 @@
 ## u2 ------>|                  |----->y2 
 ## (in_idx)  -------------------| (out_idx)
 ## @end group
 ## @end example
 ## 
 ## @end deftypefn
 
 function retsys = sysdup(Asys,output_list,input_list)
-# A. S. Hodel August 1995
-# modified by John Ingram July 1996
+
+  ## A. S. Hodel August 1995
+  ## modified by John Ingram July 1996
 
   save_val = implicit_str_to_num_ok;	# save for later
   implicit_str_to_num_ok = 1;
 
   if( nargin != 3)
     usage("retsys = sysdup(Asys,output_list,input_list)");
   endif
 
   if( !is_struct(Asys))
     error("Asys must be a system data structure (see ss2sys, tf2sys, or zp2sys)")
   endif
 
   Asys = sysupdate(Asys,"ss");
   [nn,nz,mm,pp] = sysdimensions(Asys);
   [aa,bb,cc,dd] = sys2ss(Asys);
 
-  # first duplicate inputs
+  ## first duplicate inputs
   if(is_vector(input_list))
     for ii=1:length(input_list);
       bb(:,mm+ii) = bb(:,input_list(ii));
       dd(:,mm+ii) = dd(:,input_list(ii));
     end
   elseif(!isempty(input_list))
     error("input_list must be a vector or empty");
   endif
 
 
-  # now duplicate outputs
+  ## now duplicate outputs
   osize = min(size(output_list));
   if(osize == 1)
     for ii=1:length(output_list);
       cc(pp+ii,:) = cc(output_list(ii),:);
       dd(pp+ii,:) = dd(output_list(ii),:);
     end
   elseif(osize != 0)
     error("output_list must be a vector or empty");
   endif
   
   [stnam,innam,outnam,yd] = sysgetsignals(Asys);
   tsam = sysgettsam(Asys);
 
-  # pack system and then rename signals
+  ## pack system and then rename signals
   retsys = ss2sys(aa,bb,cc,dd,tsam,nn,nz);
   retsys = syssetsignals(retsys,"in",innam,1:mm);
   retsys = syssetsignals(retsys,"out",outnam,1:pp);
   retsys = syssetsignals(retsys,"yd",yd,1:pp);
 
-  # update added input names
+  ## update added input names
   for ii=(mm+1):(mm+length(input_list))
     onum = input_list(ii-mm);
     strval = sprintf("%s(dup)",sysgetsignals(retsys,"in",onum,1) );
     retsys = syssetsignals(retsys,"in",strval,ii);
   endfor
 
-  # update added output names/discrete flags
-  # give default names to the added outputs
+  ## update added output names/discrete flags
+  ## give default names to the added outputs
   for jj=(pp+1):(pp+length(output_list))
     onum = output_list(jj-pp);
     strval = sprintf("%s(dup)",sysgetsignals(retsys,"out",onum,1) );
     retsys = syssetsignals(retsys,"out",strval,jj);
     dflg = sysgetsignals(retsys,"yd",onum);
     retsys = syssetsignals(retsys,"yd",dflg,jj);
   endfor
 
diff --git a/scripts/control/sysgetsignals.m b/scripts/control/sysgetsignals.m
--- a/scripts/control/sysgetsignals.m
+++ b/scripts/control/sysgetsignals.m
@@ -1,25 +1,25 @@
-# Copyright (C) 1998 Auburn University.  All Rights Reserved.
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1998 Auburn University.  All Rights Reserved.
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
  
 ## -*- texinfo -*-
 ## @deftypefn {Function File } {[@var{stname}, @var{inname}, @var{outname}, @var{yd}] =} sysgetsignals (@var{sys})
 ## @deftypefnx{Function File } { @var{siglist} =} sysgetsignals (@var{sys},@var{sigid})
 ## @deftypefnx{Function File } { @var{signame} =} sysgetsignals (@var{sys},@var{sigid},@var{signum}@{, @var{strflg}@})
 ##  Get signal names from a system
 ## 
 ## @strong{Inputs}
@@ -132,17 +132,17 @@
 ## octave> Aout = sysgetsignals(sys,"out",2,1)  # get name of output 2 (as string)
 ## Aout = y_2
 ## @end example
 ## 
 ## @end deftypefn
 
 function [stname,inname,outname,yd] = sysgetsignals(sys,sigid,signum,strflg)
 
-  # Adapted from ss2sys
+  ## Adapted from ss2sys
 
   if(nargin < 1 | nargin > 4 | nargout > 4)
     usage("[stname{,inname,outname,yd}] = sysgetsignals(sys{,sigid,signum})")
   elseif(nargin > 1 & nargout > 1)
     usage("sig = sysgetsignals(sys,sigid{,signum,strflg})")
   elseif( ! is_struct(sys) )
     error("input argument must be a system data structure");
   endif
diff --git a/scripts/control/sysgettsam.m b/scripts/control/sysgettsam.m
--- a/scripts/control/sysgettsam.m
+++ b/scripts/control/sysgettsam.m
@@ -1,29 +1,29 @@
-# Copyright (C) 1996,1998 Auburn University.  All Rights Reserved.
-#
-# This file is part of Octave.
-#
-# Octave is free software; you can redistribute it and/or modify it
-# under the terms of the GNU General Public License as published by the
-# Free Software Foundation; either version 2, or (at your option) any
-# later version.
-#
-# Octave is distributed in the hope that it will be useful, but WITHOUT
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-# for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Octave; see the file COPYING.  If not, write to the Free
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
+## Copyright (C) 1996,1998 Auburn University.  All Rights Reserved.
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
+##
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+## for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 function T = sysgettsam(sys)
-# T = sysgettsam(sys)
-# return the sampling time of the system
+## T = sysgettsam(sys)
+## return the sampling time of the system
 
 if(!is_struct(sys))
   usage("T = sysgettsam(sys)");
 endif
 
 T = sys.tsam;
 
 endfunction
diff --git a/scripts/control/sysgettype.m b/scripts/control/sysgettype.m
--- a/scripts/control/sysgettype.m
+++ b/scripts/control/sysgettype.m
@@ -1,25 +1,25 @@
-# Copyright (C) 1998 Auburn University.  All Rights Reserved.
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1998 Auburn University.  All Rights Reserved.
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File } { @var{systype} =} sysgettype ( @var{sys} ) 
 ##  return the initial system type of the system
 ## 
 ## @strong{Inputs}
 ##    @var{sys}: system data structure
 ## 
diff --git a/scripts/control/sysgroup.m b/scripts/control/sysgroup.m
--- a/scripts/control/sysgroup.m
+++ b/scripts/control/sysgroup.m
@@ -1,25 +1,25 @@
-# Copyright (C) 1996, 1998, 1999 Auburn University.  All Rights Reserved.
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1996, 1998, 1999 Auburn University.  All Rights Reserved.
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File } { @var{sys} =} sysgroup ( @var{Asys}, @var{Bsys})
 ## Combines two systems into a single system
 ## 
 ## @strong{Inputs}
 ## @var{Asys}, @var{Bsys}: system data structures
 ## 
@@ -42,47 +42,48 @@
 ## so that the
 ##  continuous states come first and the discrete states come last.
 ##  If there are duplicate names, the second name has a unique suffix appended
 ##  on to the end of the name.
 ## 
 ## @end deftypefn
  
 function sys = sysgroup(...)
-# A. S. Hodel August 1995
-# modified by John Ingram July 1996
-# A. S. Hodel: modified for variable number of arguments 1999
+
+  ## A. S. Hodel August 1995
+  ## modified by John Ingram July 1996
+  ## A. S. Hodel: modified for variable number of arguments 1999
 
   save_val = implicit_str_to_num_ok;	# save for later
   implicit_str_to_num_ok = 1;
 
   save_emp = empty_list_elements_ok;
   empty_list_elements_ok = 1;
 
     
   if(nargin < 1)
     usage("sys = sysgroup(Asys{,Bsys,...})");
   endif
 
-  # collect all arguments
+  ## collect all arguments
   arglist = list();
   va_start();
   for kk=1:nargin
     arglist(kk) = va_arg();
     if(!is_struct(nth(arglist,kk)))
       error("sysgroup: argument %d is not a data structure",kk);
     endif
   endfor
 
   if(nargin == 2)
-    # the usual case; group the two systems together
+    ## the usual case; group the two systems together
     Asys = nth(arglist,1);
     Bsys = nth(arglist,2);
   
-    # extract information from Asys, Bsys to consruct sys
+    ## extract information from Asys, Bsys to consruct sys
     Asys = sysupdate(Asys,"ss");
     Bsys = sysupdate(Bsys,"ss");
     [n1,nz1,m1,p1] = sysdimensions(Asys);
     [n2,nz2,m2,p2] = sysdimensions(Bsys);
     [Aa,Ab,Ac,Ad,Atsam,An,Anz,Ast,Ain,Aout,Ayd] = sys2ss(Asys);
     [Ba,Bb,Bc,Bd,Btsam,Bn,Bnz,Bst,Bin,Bout,Byd] = sys2ss(Bsys);
     nA = An + Anz;
     nB = Bn + Bnz;
@@ -98,54 +99,54 @@ function sys = sysgroup(...)
     endif
   
     A = [Aa,zeros(nA,nB); zeros(nB,nA),Ba];
     B = [Ab,zeros(nA,m2); zeros(nB,m1),Bb];
     C = [Ac,zeros(p1,nB); zeros(p2,nA),Bc];
     D = [Ad,zeros(p1,m2); zeros(p2,m1),Bd];
     tsam = max(Atsam,Btsam);
   
-    # construct combined signal names; stnames must check for pure gain blocks
+    ## construct combined signal names; stnames must check for pure gain blocks
     if(isempty(Ast))
       stname = Bst;
     elseif(isempty(Bst))
       stname = Ast;
     else
       stname  = append(Ast, Bst);
     endif
     inname  = append(Ain, Bin);
     outname = append(Aout,Bout);
   
-    # Sort states into continous first, then discrete
+    ## Sort states into continous first, then discrete
     dstates = ones(1,(nA+nB));
     if(An)
       dstates(1:(An)) = zeros(1,An);
     endif
     if(Bn)
       dstates((nA+1):(nA+Bn)) = zeros(1,Bn);
     endif
     [tmp,pv] = sort(dstates);
     A = A(pv,pv);
     B = B(pv,:);
     C = C(:,pv);
     stname = stname(pv);
   
-    # check for duplicate signal names
+    ## check for duplicate signal names
     inname = sysgroupn(inname,"input");
     stname = sysgroupn(stname,"state");
     outname = sysgroupn(outname,"output");
   
-    # mark discrete outputs
+    ## mark discrete outputs
     outlist = find([Ayd, Byd]);
   
-    # build new system
+    ## build new system
     sys = ss2sys(A,B,C,D,tsam,An+Bn,Anz+Bnz,stname,inname,outname);
 
   else
-    # multiple systems (or a single system); combine together one by one
+    ## multiple systems (or a single system); combine together one by one
     sys = nth(arglist,1);
     for kk=2:length(arglist)
       printf("sysgroup: kk=%d\n",kk);
       sys = sysgroup(sys,nth(arglist,kk));
     endfor
   endif
   
   implicit_str_to_num_ok = save_val;	# restore value  
diff --git a/scripts/control/sysgroupn.m b/scripts/control/sysgroupn.m
--- a/scripts/control/sysgroupn.m
+++ b/scripts/control/sysgroupn.m
@@ -1,25 +1,25 @@
-# Copyright (C) 1996,1998 Auburn University.  All Rights Reserved.
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1996,1998 Auburn University.  All Rights Reserved.
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File } { @var{names} =} sysgroupn (@var{names})
 ## names = sysgroupn(names)
 ## Locate and mark duplicate names
 ## inputs:
 ##   names: list of signal names
 ##   kind: kind of signal name (used for diagnostic message purposes only)
@@ -28,31 +28,31 @@
 ##      message is printed to inform the user of the new signal name
 ##
 ##  used internally in sysgroup and elsewhere. 
 ## 
 ## @end deftypefn
  
 function names = sysgroupn(names,kind)
 
-  # check for duplicate names
+  ## check for duplicate names
   l = length(names);
   ii = 1;
   while(ii <= l-1)
     st1 = nth(names,ii);
     jj = ii+1;
     while ( jj <= l)
       st2 = nth(names,jj);
       if(strcmp(st1,st2))
         suffix = ["_",num2str(jj)];
         warning("sysgroup: %s name(%d) = %s name(%d) = %s", ...
 	  kind,ii,kind,jj,st1);
         strval = sprintf("%s%s",st2,suffix);
         names(jj) = strval;
         warning("sysgroup:     changed %s name %d to %s",kind,jj,strval);
-        # restart the check (just to be sure there's no further duplications)
+        ## restart the check (just to be sure there's no further duplications)
         ii = 0; jj = l;
       endif
       jj = jj+1;
     endwhile
     ii = ii+1;
   endwhile
 endfunction
diff --git a/scripts/control/sysidx.m b/scripts/control/sysidx.m
--- a/scripts/control/sysidx.m
+++ b/scripts/control/sysidx.m
@@ -1,74 +1,75 @@
-# Copyright (C) 1999 Auburn University. All rights reserved.
-#
-# This file is part of Octave.
-#
-# Octave is free software; you can redistribute it and/or modify it
-# under the terms of the GNU General Public License as published by the
-# Free Software Foundation; either version 2, or (at your option) any
-# later version.
-#
-# Octave is distributed in the hope that it will be useful, but WITHOUT
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-# for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Octave; see the file COPYING.  If not, write to the Free
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
-#
-# Written by A. S. Hodel, a.s.hodel@eng.auburn.edu
+## Copyright (C) 1999 Auburn University. All rights reserved.
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
+##
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+## for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
+##
+## Written by A. S. Hodel, a.s.hodel@eng.auburn.edu
 
 
 function idxvec = sysidx(sys,sigtype,signamelist)
-# idxvec = sysidx(sys,sigtype,signamelist)
-# return indices of signals with specified signal names
-# inputs:
-#   sys:         OCST system data structure
-#   sigtype:     signal type to be selected: "in", "out", "st"
-#   signamelist: list of desired signal names
-# outputs:
-#   idxvec: vector of signal indices (appropriate for use with sysprune)
+
+  ## idxvec = sysidx(sys,sigtype,signamelist)
+  ## return indices of signals with specified signal names
+  ## inputs:
+  ##   sys:         OCST system data structure
+  ##   sigtype:     signal type to be selected: "in", "out", "st"
+  ##   signamelist: list of desired signal names
+  ## outputs:
+  ##   idxvec: vector of signal indices (appropriate for use with sysprune)
 
-if(nargin != 3)         usage("idxvec = sysidx(sys,sigtype,signamelist)");
-elseif(!is_struct(sys)) error("sys must be a system data structure");
-elseif(!isstr(sigtype)) error("sigtype must be a string");
-elseif(rows(sigtype) != 1) 
-                        error("sigtype (%d x %d) must be a single string", ...
-	                  rows(sigtype),columns(sigtype));
-elseif(!is_signal_list(signamelist)) 
-                        error("signamelist must be a list of strings");
-endif
+  if(nargin != 3)         usage("idxvec = sysidx(sys,sigtype,signamelist)");
+  elseif(!is_struct(sys)) error("sys must be a system data structure");
+  elseif(!isstr(sigtype)) error("sigtype must be a string");
+  elseif(rows(sigtype) != 1) 
+			  error("sigtype (%d x %d) must be a single string", ...
+			    rows(sigtype),columns(sigtype));
+  elseif(!is_signal_list(signamelist)) 
+			  error("signamelist must be a list of strings");
+  endif
 
-sigtype_list = list("input","output","state");
-sigtnum = 0;
-for idx = 1:length(sigtype_list)
-  thistype = nth(sigtype_list,idx);
-  if(strcmp(sigtype, thistype(1:length(sigtype)) )) sigtnum = idx; endif
-endfor
-if(sigtnum == 0)  error("Illegal sigtype value = %s\n",sigtype); endif
+  sigtype_list = list("input","output","state");
+  sigtnum = 0;
+  for idx = 1:length(sigtype_list)
+    thistype = nth(sigtype_list,idx);
+    if(strcmp(sigtype, thistype(1:length(sigtype)) )) sigtnum = idx; endif
+  endfor
+  if(sigtnum == 0)  error("Illegal sigtype value = %s\n",sigtype); endif
 
-syssiglist = sysgetsignals(sys,sigtype);
+  syssiglist = sysgetsignals(sys,sigtype);
 
-for idx = 1:length(signamelist)
-  signame = nth(signamelist,idx);
-  idxvec(idx) = 0;
-  nsigs = sysdimensions(sys,sigtype);
-  for jdx = 1:nsigs
-    #printf("idx=%d jdx=%d signame=-%s- thissig=-%s-\n",idx,jdx,signame, ...
-    #  sysgetsignals(sys,sigtype,jdx,1));
-    if(strcmp(signame,sysgetsignals(sys,sigtype,jdx,1)))
-      if(idxvec(idx) != 0)
-        warning("Duplicate system input %s (%d,%d)\n", ...
-          sysgetsignals(sys,sigtype,jdx,1),jdx,idxvec(idx));
-      else
-        idxvec(idx) = jdx;
+  for idx = 1:length(signamelist)
+    signame = nth(signamelist,idx);
+    idxvec(idx) = 0;
+    nsigs = sysdimensions(sys,sigtype);
+    for jdx = 1:nsigs
+      ## printf("idx=%d jdx=%d signame=-%s- thissig=-%s-\n",idx,jdx,signame, ...
+      ##   sysgetsignals(sys,sigtype,jdx,1));
+      if(strcmp(signame,sysgetsignals(sys,sigtype,jdx,1)))
+	if(idxvec(idx) != 0)
+	  warning("Duplicate system input %s (%d,%d)\n", ...
+	    sysgetsignals(sys,sigtype,jdx,1),jdx,idxvec(idx));
+	else
+	  idxvec(idx) = jdx;
+	endif
       endif
+    endfor
+    if(idxvec(idx) == 0)
+      error("Did not find %s %s",nth(sigtype_list,sigtnum),signame);
     endif
   endfor
-  if(idxvec(idx) == 0)
-    error("Did not find %s %s",nth(sigtype_list,sigtnum),signame);
-  endif
-endfor
 
 
 endfunction
diff --git a/scripts/control/sysmin.m b/scripts/control/sysmin.m
--- a/scripts/control/sysmin.m
+++ b/scripts/control/sysmin.m
@@ -1,60 +1,61 @@
-# Copyright (C) 1996 Auburn University. All rights reserved.
-#
-# This file is part of Octave.
-#
-# Octave is free software; you can redistribute it and/or modify it
-# under the terms of the GNU General Public License as published by the
-# Free Software Foundation; either version 2, or (at your option) any
-# later version.
-#
-# Octave is distributed in the hope that it will be useful, but WITHOUT
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-# for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Octave; see the file COPYING.  If not, write to the Free
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
-#
-# Written by A. S. Hodel a.s.hodel@eng.auburn.edu
+## Copyright (C) 1996 Auburn University. All rights reserved.
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
+##
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+## for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
+##
+## Written by A. S. Hodel a.s.hodel@eng.auburn.edu
 
 function [retsys,nc,no,cflg,oflg] = sysmin(sys,flg);
-  # [retsys,nc,no] = sysmin(sys{,flg});
-  # return a minimal (or reduced order) system
-  # inputs:
-  #   sys: system data structure
-  #   flg: 0 [default] return minimal system; state names lost
-  #      : 1           return system with physical states removed that
-  #                    are either uncontrollable or unobservable
-  #                    (cannot reduce further without discarding physical
-  #                    meaning of states)
-  # outputs:
-  #   retsys: returned system
-  #   nc: number of controllable states in the returned system
-  #   no: number of observable states in the returned system
-  #   cflg: is_controllable(retsys)
-  #   oflg: is_observable(retsys)
+
+  ## [retsys,nc,no] = sysmin(sys{,flg});
+  ## return a minimal (or reduced order) system
+  ## inputs:
+  ##   sys: system data structure
+  ##   flg: 0 [default] return minimal system; state names lost
+  ##      : 1           return system with physical states removed that
+  ##                    are either uncontrollable or unobservable
+  ##                    (cannot reduce further without discarding physical
+  ##                    meaning of states)
+  ## outputs:
+  ##   retsys: returned system
+  ##   nc: number of controllable states in the returned system
+  ##   no: number of observable states in the returned system
+  ##   cflg: is_controllable(retsys)
+  ##   oflg: is_observable(retsys)
   
   switch(nargin)
   case(1), flg = 0;
   case(2), jnk = flg;    # dummy operation
   otherwise,
     usage("[retsys,nc,no] = sysmin(sys{,flg})");
   endswitch
   dflg = is_digital(sys,flg);
   Ts = sysgettsam(sys);
   switch(flg)
   case(0),
-    # reduce to a minimal system
+    ## reduce to a minimal system
     [aa,bb,cc,dd] = sys2ss(sys);
     [cflg,Uc] = is_controllable(aa,bb); 
     if(!cflg)
-      # reduce to controllable states
+      ## reduce to controllable states
       if(!isempty(Uc))
         aa = Uc'*aa*Uc;
         bb = Uc'*bb;
         cc = cc*Uc;
       else
         aa = bb = cc = [];
       endif
     endif
@@ -77,17 +78,17 @@ function [retsys,nc,no,cflg,oflg] = sysm
     case(1),
       nc = no = nz = columns(aa);
       nn = 0;
     endswitch
     inname = sysgetsignals(sys,"in");
     outname= sysgetsignals(sys,"out");
     retsys = ss2sys(aa,bb,cc,dd,Ts,nn,nz,[],inname,outname);
   case(1),
-    # reduced model with physical states
+    ## reduced model with physical states
     [cflg,Uc] = is_controllable(sys); xc = find(max(abs(Uc')) != 0);
     [oflg,Uo] = is_observable(sys);   xo = find(max(abs(Uo')) != 0);
     xx = intersection(xc,xo);
     if(isempty(xx)) xx = 0;  endif    # signal no states in reduced model
     retsys = sysprune(sys,[],[],xx);
   otherwise,
     error("illegal value of flg=%d",flg);
   endswitch
diff --git a/scripts/control/sysmult.m b/scripts/control/sysmult.m
--- a/scripts/control/sysmult.m
+++ b/scripts/control/sysmult.m
@@ -1,25 +1,25 @@
-# Copyright (C) 1996,1999 Auburn University.  All Rights Reserved
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1996,1999 Auburn University.  All Rights Reserved
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
 
 ## -*- texinfo -*- 
 ## @deftypefn {Function File } { @var{sys} =} sysmult( @var{Asys}, @var{Bsys})
 ## Compute @math{sys = Asys*Bsys} (series connection):
 ## @example
 ## @group
 ## u   ----------     ----------
 ## --->|  Bsys  |---->|  Asys  |--->
@@ -28,88 +28,89 @@
 ## @end example
 ## A warning occurs if there is direct feed-through
 ## from an input of Bsys or a continuous state of Bsys through a discrete 
 ## output of Bsys to a continuous state or output in Asys (system data structure
 ## does not recognize discrete inputs).
 ## @end deftypefn
 
 function sys = sysmult(...)
-# Written by John Ingram July 1996
-# updated for variable number of arguments by A. S. Hodel July 1999
+
+  ## Written by John Ingram July 1996
+  ## updated for variable number of arguments by A. S. Hodel July 1999
 
   save_val = implicit_str_to_num_ok;	# save for later
   implicit_str_to_num_ok = 1;
 
   if(nargin < 1)
     usage("sysmult: sys = sysmult(Asys{,Bsys,...})");
   endif
 
-  # collect all arguments
+  ## collect all arguments
   arglist = list();
   va_start();
   for kk=1:nargin
     arglist(kk) = va_arg();
     if(!is_struct(nth(arglist,kk)))
       error("sysadd: argument %d is not a data structure",kk);
     endif
   endfor
 
-  # check system dimensions
+  ## check system dimensions
   [n,nz,mg,pg,Gyd] = sysdimensions(nth(arglist,1));
   for kk=2:nargin
     [n,nz,mh,ph,Hyd] = sysdimensions(nth(arglist,kk));
     if(mh != pg)
       error("arg %d has %d outputs; arg %d has vs %d inputs",kk,ph,kk-1,mg);
     endif
     [n,nz,mg,pg,Gyd] = sysdimensions(nth(arglist,kk));   # for next iteration
   endfor
 
-  # perform the multiply
+  ## perform the multiply
   if(nargin == 2)
     Asys = nth(arglist,1);   Bsys = nth(arglist,2);
  
     [An,Anz,Am,Ap] = sysdimensions(Asys);
     [Bn,Bnz,Bm,Bp] = sysdimensions(Bsys);
 
     [Aa,Ab,Ac,Ad,Atsam,An,Anz,Astname,Ainname,Aoutname,Ayd] = sys2ss(Asys);
     [Ba,Bb,Bc,Bd,Btsam,Bn,Bnz,Bstname,Binname,Boutname,Byd] = sys2ss(Bsys);
   
     if(Byd)
-      # check direct feed-through of inputs through discrete outputs
+      ## check direct feed-through of inputs through discrete outputs
       alist = find(Byd);
       if(An)
         bd = Ab(1:An)* Bd(alist,:);	
         if(norm(bd,1))
           warning("sysmult: inputs -> Bsys discrete outputs -> continous states of Asys");
         endif
       endif
-      # check direct feed-through of continuous state through discrete outputs
+      ## check direct feed-through of continuous state through discrete outputs
       if(Bn)
         bc = Ab(1:An)* Bc(alist,1:(Bn));	
         if( norm(bc,1) )
           warning("sysmult: Bsys states -> Bsys discrete outputs -> continuous states of Asys");
         endif
       endif
     endif
   
-    # change signal names to avoid spurious warnings from sysgroup
+    ## change signal names to avoid spurious warnings from sysgroup
     Asys = syssetsignals(Asys,"in",sysdefioname(Am,"A_sysmult_tmp_name"));
     Bsys = syssetsignals(Bsys,"out",sysdefioname(Bp,"B_sysmult_tmp_name"));
   
     sys = sysgroup(Asys,Bsys);
   
-    # connect outputs of B to inputs of A
+    ## connect outputs of B to inputs of A
     sys = sysconnect(sys,Ap+(1:Bp),1:Am);
    
-    # now keep only  outputs of A and inputs of B
+    ## now keep only  outputs of A and inputs of B
     sys = sysprune(sys,1:Ap,Am+(1:Bm));
 
   else
-    # multiple systems (or a single system); combine together one by one
+    ## multiple systems (or a single system); combine together one by one
     sys = nth(arglist,1);
     for kk=2:length(arglist)
       sys = sysmult(sys,nth(arglist,kk));
     endfor
   endif
   implicit_str_to_num_ok = save_val;	# restore value  
 endfunction  
   
diff --git a/scripts/control/sysout.m b/scripts/control/sysout.m
--- a/scripts/control/sysout.m
+++ b/scripts/control/sysout.m
@@ -1,25 +1,25 @@
-# Copyright (C) 1996 Auburn University.  All Rights Reserved
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1996 Auburn University.  All Rights Reserved
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
  
 ## -*- texinfo -*-
 ## @deftypefn {Function File } { } sysout ( @var{sys}@{, @var{opt}@}) 
 ##  print out a system data structure in desired format
 ## @table @var
 ## @item  sys
 ##  system data structure
 ## @item  opt
@@ -35,116 +35,121 @@
 ##  zero-pole form
 ## @item      "all"
 ##  all of the above
 ## @end table
 ## @end table
 ## @end deftypefn
  
 function retsys = sysout(sys,opt)
-# Written by A S Hodel: 1995-1996
+
+  ## Written by A S Hodel: 1995-1996
 
-# save for restoring at end of routine
-save_val = implicit_str_to_num_ok;
-implicit_str_to_num_ok = 1;
-
-if( (nargin < 1) || (nargin > 2) )
-  usage("sysout(sys[,opt])");
-endif
+  ## save for restoring at end of routine
+  save_val = implicit_str_to_num_ok;
+  implicit_str_to_num_ok = 1;
 
-if(isempty(sys))
-  retsys = sys;
-  warning("sysout: empty system")
-  return;
-endif
-
-if(! is_struct(sys))
-  disp("sysout: input must be a system structure")
-endif
+  if( (nargin < 1) || (nargin > 2) )
+    usage("sysout(sys[,opt])");
+  endif
 
-# set up output type array
-if( nargin == 1 )
-  opt = sysgettype(sys);
-else
-  if( ! (strcmp(opt,"ss") + strcmp(opt,"tf") + ...
-    strcmp(opt,"zp") + strcmp(opt,"all") ) )
-    error("opt must be one of [], \"ss\", \"tf\", \"zp\", or \"all\"");
+  if(isempty(sys))
+    retsys = sys;
+    warning("sysout: empty system")
+    return;
   endif
-endif
+
+  if(! is_struct(sys))
+    disp("sysout: input must be a system structure")
+  endif
 
-# now check output for each form:
-[nn,nz,mm,pp] = sysdimensions(sys);
-if( mm > 0)
-  disp("Input(s)")
-  disp(outlist(sysgetsignals(sys,"in"),"	"));
-else
-  disp("Input(s): none");
-endif
-if (pp > 0)
-  disp("Output(s):")
-  disp(outlist(sysgetsignals(sys,"out"), ...
-	"	",sysgetsignals(sys,"yd")) );
-else
-  disp("Output(s): none");
-endif
-if(sysgettsam(sys) > 0)
-  disp(["Sampling interval: ",num2str(sysgettsam(sys))]);
-  str = "z";
-else
-  str = "s";
-endif
+  ## set up output type array
+  if( nargin == 1 )
+    opt = sysgettype(sys);
+  else
+    if( ! (strcmp(opt,"ss") + strcmp(opt,"tf") + ...
+      strcmp(opt,"zp") + strcmp(opt,"all") ) )
+      error("opt must be one of [], \"ss\", \"tf\", \"zp\", or \"all\"");
+    endif
+  endif
 
-# transfer function form
-if( strcmp(opt,"tf") + strcmp(opt,"all") )
-  sys = sysupdate(sys,"tf");		#make sure tf is up to date
-  disp("transfer function form:")
-  [num,den] = sys2tf(sys);
-  tfout(num,den,str);
-endif
-
-if( strcmp(opt,"zp") + strcmp(opt,"all") )
-  sys = sysupdate(sys,"zp");		#make sure zp is up to date
-  disp("zero-pole form:")
-  [zer,pol,kk] = sys2zp(sys);
-  zpout(zer, pol, kk,str)
-endif
-
-if( strcmp(opt,"ss") + strcmp(opt,"all") )
-  sys = sysupdate(sys,"ss");
-  disp("state-space form:");
-  disp([num2str(nn)," continuous states, ", num2str(nz)," discrete states"]);
-  if( nn+nz > 0)
-    disp("State(s):")
-    xi = (nn+1):(nn+nz);
-    xd = zeros(1,nn+nz);
-    if(!isempty(xi))
-      xd(xi) = 1;
-    endif
-    disp(outlist(sysgetsignals(sys,"st"),"	",xd));
+  ## now check output for each form:
+  [nn,nz,mm,pp] = sysdimensions(sys);
+  if( mm > 0)
+    disp("Input(s)")
+    disp(outlist(sysgetsignals(sys,"in"),"	"));
   else
-    disp("State(s): none");
+    disp("Input(s): none");
+  endif
+  if (pp > 0)
+    disp("Output(s):")
+    disp(outlist(sysgetsignals(sys,"out"), ...
+	  "	",sysgetsignals(sys,"yd")) );
+  else
+    disp("Output(s): none");
+  endif
+  if(sysgettsam(sys) > 0)
+    disp(["Sampling interval: ",num2str(sysgettsam(sys))]);
+    str = "z";
+  else
+    str = "s";
   endif
 
-  # display matrix values?
-  dmat = (max( [ (nn+nz), mm, pp ] ) <= 32);
+  ## transfer function form
+  if( strcmp(opt,"tf") + strcmp(opt,"all") )
+    sys = sysupdate(sys,"tf");		#make sure tf is up to date
+    disp("transfer function form:")
+    [num,den] = sys2tf(sys);
+    tfout(num,den,str);
+  endif
 
-  printf("A matrix: %d x %d\n",sysdimensions(sys,"st"),sysdimensions(sys,"st"));
-  [aa,bb,cc,dd] = sys2ss(sys);
-  if(dmat) 	disp(aa); 	endif
-
-  printf("B matrix: %d x %d\n",sysdimensions(sys,"st"),sysdimensions(sys,"in"));
-  if(dmat)     disp(bb);              endif
+  if( strcmp(opt,"zp") + strcmp(opt,"all") )
+    sys = sysupdate(sys,"zp");		#make sure zp is up to date
+    disp("zero-pole form:")
+    [zer,pol,kk] = sys2zp(sys);
+    zpout(zer, pol, kk,str)
+  endif
 
-  printf("C matrix: %d x %d\n",sysdimensions(sys,"out"),sysdimensions(sys,"st"));
-  if(dmat) disp(cc);		endif
+  if( strcmp(opt,"ss") + strcmp(opt,"all") )
+    sys = sysupdate(sys,"ss");
+    disp("state-space form:");
+    disp([num2str(nn)," continuous states, ", num2str(nz)," discrete states"]);
+    if( nn+nz > 0)
+      disp("State(s):")
+      xi = (nn+1):(nn+nz);
+      xd = zeros(1,nn+nz);
+      if(!isempty(xi))
+	xd(xi) = 1;
+      endif
+      disp(outlist(sysgetsignals(sys,"st"),"	",xd));
+    else
+      disp("State(s): none");
+    endif
 
-  printf("D matrix: %d x %d\n",sysdimensions(sys,"out"),sysdimensions(sys,"in"));
-  if(dmat)       disp(dd);         endif
-endif
+    ## display matrix values?
+    dmat = (max( [ (nn+nz), mm, pp ] ) <= 32);
 
-if(nargout >= 1)
-  retsys = sys;
-endif 
-  
-# restore global variable
-implicit_str_to_num_ok = save_val;
+    printf("A matrix: %d x %d\n",sysdimensions(sys,"st"),
+	   sysdimensions(sys,"st"));
+    [aa,bb,cc,dd] = sys2ss(sys);
+    if(dmat) 	disp(aa); 	endif
+
+    printf("B matrix: %d x %d\n",sysdimensions(sys,"st"),
+	   sysdimensions(sys,"in"));
+    if(dmat)     disp(bb);              endif
+
+    printf("C matrix: %d x %d\n",sysdimensions(sys,"out"),
+	   sysdimensions(sys,"st"));
+    if(dmat) disp(cc);		endif
+
+    printf("D matrix: %d x %d\n",sysdimensions(sys,"out"),
+	   sysdimensions(sys,"in"));
+    if(dmat)       disp(dd);         endif
+  endif
+
+  if(nargout >= 1)
+    retsys = sys;
+  endif 
+
+  ## restore global variable
+  implicit_str_to_num_ok = save_val;
 
 endfunction
diff --git a/scripts/control/sysprune.m b/scripts/control/sysprune.m
--- a/scripts/control/sysprune.m
+++ b/scripts/control/sysprune.m
@@ -1,25 +1,25 @@
-# Copyright (C) 1996,1998 Auburn University.  All Rights Reserved
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1996,1998 Auburn University.  All Rights Reserved
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File } { @var{retsys} =} sysprune ( @var{Asys}, @var{out_idx}, @var{in_idx})
 ## Extract specified inputs/outputs from a system
 ## 
 ## @strong{Inputs}
 ## @table @var
 ## @item   Asys
@@ -41,32 +41,33 @@
 ##   (deleted)-------------------- (deleted)   
 ## @end group
 ## @end example
 ## 
 ## @end deftypefn
 ## 
  
 function sys = sysprune(sys,output_idx,input_idx,state_idx)
-# A. S. Hodel August 1995
-# Updated by John Ingram 7-15-96
+
+  ## A. S. Hodel August 1995
+  ## Updated by John Ingram 7-15-96
 
   if( nargin < 3 | nargin > 4  )
     usage("retsys = sysprune(sys,output_idx,input_idx{,state_idx})");
   elseif(nargin < 4)
     state_idx = [];
   endif
 
-  # default: no action
+  ## default: no action
   [nn,nz,mm,pp] = sysdimensions(sys);
   if(isempty(output_idx)) output_idx = 1:pp; endif
   if(isempty(input_idx)) input_idx = 1:mm; endif
   if(isempty(state_idx)) state_idx = 1:(nn+nz); endif
 
-  # check dimensions
+  ## check dimensions
   if( !(is_vector(output_idx) | isempty(output_idx) )  )
     if(!is_matrix(output_idx)) 
       error("sysprune: bad argument passed for output_idx");
     else 
       error("sysprune: output_idx (%d x %d) must be a vector or empty", ...
         rows(output_idx),columns(output_idx));
     endif
   elseif(is_duplicate_entry(output_idx))
@@ -111,17 +112,17 @@ function sys = sysprune(sys,output_idx,i
 	num2str(mm)," inputs"]);
   elseif(nn+nz < lst)
     error([num2str(lst)," state_idx entries, system has only ", ...
 	num2str(nn+nz)," states"]);
   endif
 
   [aa,bb,cc,dd,tsam,nn,nz,stnam,innam,outnam,yd] = sys2ss(sys);
 
-  # check for legal state permutation
+  ## check for legal state permutation
   if(nn & nz)
     c_idx = find(state_idx <= nn);
     if(!isempty(c_idx)) max_c = max(c_idx);
     else	        max_c = 0;            endif
     d_idx = find(state_idx > nn);
     if(!isempty(d_idx)) min_d = min(d_idx);
     else	        min_d = nn+nz;            endif
     if(max_c > min_d)
diff --git a/scripts/control/sysreorder.m b/scripts/control/sysreorder.m
--- a/scripts/control/sysreorder.m
+++ b/scripts/control/sysreorder.m
@@ -1,47 +1,48 @@
-# Copyright (C) 1996 Auburn University.  All Rights Reserved
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1996 Auburn University.  All Rights Reserved
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File } { @var{pv} =} sysreorder( @var{vlen}, @{var{list})
 ## 
 ## @strong{Inputs}
 ## @var{vlen}=vector length, @var{list}= a subset of @code{[1:vlen]},
 ## 
 ## @strong{Outputs}
 ##  @var{pv}: a permutation vector to order elements of @code{[1:vlen]} in 
 ## @code{list} to the end of a vector.
 ## 
 ##  Used internally by @code{sysconnect} to permute vector elements to their
 ##  desired locations.  
 ## @end deftypefn
  
 function pv = sysreorder(vlen,list)
-# A. S. Hodel, Aug 1995
+
+  ## A. S. Hodel, Aug 1995
   
-  #disp('sysreorder: entry')
+  ## disp('sysreorder: entry')
   
   pv = 1:vlen;
-  # make it a row vector
+  ## make it a row vector
   list = reshape(list,1,length(list));
   A = pv'*ones(size(list));
   B = ones(size(pv'))*list;
   X = (A != B);
   if(!is_vector(X))
     y = min(X');
   else
    y = X';
diff --git a/scripts/control/sysrepdemo.m b/scripts/control/sysrepdemo.m
--- a/scripts/control/sysrepdemo.m
+++ b/scripts/control/sysrepdemo.m
@@ -1,34 +1,34 @@
-# Copyright (C) 1996,1998 Auburn University.  All Rights Reserved
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1996,1998 Auburn University.  All Rights Reserved
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File } {} sysrepdemo 
 ## Tutorial for the use of the system data structure functions.
 ## @end deftypefn
 
-# Octave Controls toolbox demo: System representation
-# Written by A. S. Hodel June 1995
-# Revised Aug 1995 for system data structure format
+## Octave Controls toolbox demo: System representation
+## Written by A. S. Hodel June 1995
+## Revised Aug 1995 for system data structure format
 function sysrepdemo()
 
 
 
   save_val = page_screen_output;
   page_screen_output = 1;
 
   disp('System representation demo:')
diff --git a/scripts/control/sysscale.m b/scripts/control/sysscale.m
--- a/scripts/control/sysscale.m
+++ b/scripts/control/sysscale.m
@@ -1,25 +1,25 @@
-# Copyright (C) 1996,1998 Auburn University.  All Rights Reserved
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1996,1998 Auburn University.  All Rights Reserved
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File } {@var{sys} =} sysscale (@var{sys}, @var{outscale}, @var{inscale}@{, @var{outname}, @var{inname}@})
 ## scale inputs/outputs of a system.
 ## 
 ## @strong{Inputs}
 ##    sys: structured system
 ##    outscale, inscale: constant matrices of appropriate dimension
@@ -37,32 +37,33 @@
 ##  outputs.
 ## 
 ## A warning message is printed if outscale attempts to add continuous
 ## system outputs to discrete system outputs; otherwise @var{yd} is 
 ## set appropriately in the returned value of @var{sys}.
 ## @end deftypefn
 
 function sys = sysscale(sys,outscale,inscale,outname,inname)
-# A. S. Hodel August 1995
-# modified by John Ingram 7-15-96
+
+  ## A. S. Hodel August 1995
+  ## modified by John Ingram 7-15-96
 
   if( (nargin < 3) || (nargin > 5)  )
     usage("retsys = sysscale(Asys,output_list,input_list{,inname,outname})");
   elseif (!is_struct(sys))
     error("sys must be a structured system");
   endif
 
   [nn,nz,mm,pp] = sysdimensions(sys);
  
-  # check for omitted scales
+  ## check for omitted scales
   if(isempty(outscale))    outscale = eye(pp);     endif 
   if(isempty(inscale))     inscale = eye(mm);      endif 
 
-  # check dimensions of scaling matrices
+  ## check dimensions of scaling matrices
   if(mm!=rows(inscale))
     error("inscale(%dx%d) should have %d rows(# system inputs)", ...
       rows(inscale),columns(inscale),mm);
   elseif( pp != columns(outscale) )
     error("outscale(%dx%d) should have %d columns(# system outputs)", ...
       rows(outscale), columns(outscale),pp);
   endif
 
@@ -81,51 +82,51 @@ function sys = sysscale(sys,outscale,ins
       else
         sysyd(ii) = (ndi != 0);
       endif
     endfor
   else
     sysyd = ones(1,rows(outscale))*( length(outd) > 0);
   endif
 
-  # check for SISO system type
+  ## check for SISO system type
   if strcmp(sysgettype(sys),"tf")
     [num,den,tsam,innam,outnam] = sys2tf(sys);
     num = num*inscale*outscale;
     sys = tf2sys(num,den,tsam,innam,outnam,find(sysyd));
     return
   elseif strcmp(sysgettype(sys),"zp")
     [zer,pol,kk,tsam,innam,outnam] = sys2zp(sys);
     kk = kk*inscale*outscale;
     sys = zp2sys(zer,pol,k,tsam,innam,outnam,find(sysyd));
     return
   endif
 
-  # it's a state space system...
+  ## it's a state space system...
 
   [sysa,sysb,sysc,sysd,systsam, ...
     sysn,sysnz,sysstname,sysinname,sysoutname,oldyd] = sys2ss(sys);
 
   sysb = sysb*inscale;
   sysc = outscale*sysc;
   sysd = outscale*sysd*inscale;
 
   if( !is_square(outscale) )
-    # strip extra output names (if any)
+    ## strip extra output names (if any)
     sysoutname = sysoutname(1:min(rows(outscale),columns(outscale)));
     if( nargin < 4)
       warning("sysscale: outscale not square, outname not specified");
       warning("sysscale:  using default output names");
       outname = sysdefioname(rows(sysc),"y");
     endif
   else
     outname = sysoutname;
   endif
   if( !is_square(inscale) )
-    # strip extra output names (if any)
+    ## strip extra output names (if any)
     sysinname = sysinname(1:min(rows(inscale),columns(inscale)));
     if(nargin < 5)
       warning("sysscale: inscale not square, inname not specified");
       warning("sysscale:  using default input names");
       inname = sysdefioname(columns(sysb),"u");
     endif
   else
     inname = sysgetsignals(sys,"in");
diff --git a/scripts/control/syssetsignals.m b/scripts/control/syssetsignals.m
--- a/scripts/control/syssetsignals.m
+++ b/scripts/control/syssetsignals.m
@@ -1,25 +1,25 @@
-# Copyright (C) 1996,1998 Auburn University.  All Rights Reserved
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1996,1998 Auburn University.  All Rights Reserved
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
  
 ## -*- texinfo -*-
 ## @deftypefn {Function File } {@var{retsys} =} syssetsignals (@var{sys}, @var{opt}, @var{names}@{, @var{sig_idx}@})
 ##  change the names of selected inputs, outputs and states.
 ## @strong{Inputs}
 ## @table @var
 ## @item sys
 ##  system data structure
@@ -82,17 +82,18 @@
 ##   7  8
 ## D matrix: 1 x 1
 ## 0
 ## @end example
 ## 
 ## @end deftypefn
 
 function retsys = syssetsignals(sys,opt,names,sig_idx)
-# Written by John Ingram August 1996
+
+  ## Written by John Ingram August 1996
 
   save_val = implicit_str_to_num_ok;	# save for later
   implicit_str_to_num_ok = 1;
 
   if (nargin < 3 | nargin > 4)
     usage("retsys=syssetsignals(sys,opt,names{,sig_idx})");
   elseif (!is_struct(sys))
     error("sys must be a system data structure");
@@ -108,21 +109,21 @@ function retsys = syssetsignals(sys,opt,
       disp("syssetsignals: sig_idx=")
       disp(sig_idx);
       error("sig_idx must be a vector")
     endif
   endif
 
   sig_vals = sysgetsignals(sys,opt);
 
-  # make sure it's in state space form if state names are given
+  ## make sure it's in state space form if state names are given
   if(strcmp(opt,"st"))    sys = sysupdate(sys,"ss");    endif
 
   if(strcmp(opt,"yd") == 0)
-    # it's a signal name list we're changing
+    ## it's a signal name list we're changing
     if(!is_list(names))
       names = list(names);
     endif
     if(!is_signal_list(names))
       if(isstr(nth(names,1)))
         warning("syssetsignals(opt=%s): converting string matrix \"names\" to a list of strings",opt);
         tmpstr = nth(names,1);
         for ii=1:rows(tmpstr)
@@ -131,40 +132,40 @@ function retsys = syssetsignals(sys,opt,
       else
         names
         error("parameter \"names\" must be a list of strings");
       endif
     endif
     nsigs = length(sig_vals);
 
     if(nargin == 3)
-      # replace all signal names
+      ## replace all signal names
       if(length(names) != nsigs)
         error("opt=%s, sig_idx omitted: names(len=%d) should have %d entries ", ...
           opt,length(names),nsigs);
       endif
       sig_idx = 1:nsigs;
     elseif(length(names) != length(sig_idx))
-      # replace specified signal names
+      ## replace specified signal names
       error("opt=%s, sig_idx(len=%d), names(len=%d) mismatch",opt, ...
         length(sig_idx), length(names));
     endif
 
     for ii=1:length(sig_idx)
       jj = sig_idx(ii);
       if(jj < 1 | jj > nsigs | jj != floor(jj+0.5))
         error("opt=%s, sig_idx(%d)=%d, %e: must be an integer between 1 and %d", ...
           opt, ii, jj, jj, nsigs);
       endif
       sig_vals(jj) = nth(names,ii);
     endfor
 
   else
-    # update yd
-    # 1st check pathological case: no outputs
+    ## update yd
+    ## 1st check pathological case: no outputs
     nout = sysdimensions(sys,"out");
     if(nout == 0)
       if(nargin != 3)
         error("opt=%s, %d outputs, sysgetsignals cannot take 4 arguments", ...
           yd,nout);
       endif
       if(!isempty(names))
         error("opt=%s, %d outputs, names is not empty");
diff --git a/scripts/control/syssub.m b/scripts/control/syssub.m
--- a/scripts/control/syssub.m
+++ b/scripts/control/syssub.m
@@ -1,25 +1,25 @@
-# Copyright (C) 1996,1999 Auburn University.  All Rights Reserved
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1996,1999 Auburn University.  All Rights Reserved
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File } { @var{sys} =} syssub (@var{Gsys}, @var{Hsys})
 ##  returns @math{sys = Gsys - Hsys}
 ## 
 ##  Method: @var{Gsys} and @var{Hsys} are connected in parallel
 ##  The input vector is connected to both systems; the outputs are
 ##  subtracted.  Returned system names are those of @var{Gsys}.
@@ -32,84 +32,85 @@
 ##     |     ________   -|
 ##      ----|  Hsys  |---
 ##           --------
 ## @end group
 ## @end example
 ## @end deftypefn
  
 function sys = syssub(...)
-# Written by John Ingram July 1996
-# updated for variable numbers of input arguments by July 1999 A. S. Hodel
+
+  ## Written by John Ingram July 1996
+  ## updated for variable numbers of input arguments by July 1999 A. S. Hodel
 
   save_val = implicit_str_to_num_ok;	# save for later
   implicit_str_to_num_ok = 1;
 
   if(nargin < 1)
     usage("syssub: sys = syssub(Gsys{,Hsys,...})");
   endif
 
-  # collect all arguments
+  ## collect all arguments
   arglist = list();
   va_start();
   for kk=1:nargin
     arglist(kk) = va_arg();
     if(!is_struct(nth(arglist,kk)))
       error("syssub: argument %d is not a data structure",kk);
     endif
   endfor           
 
-  # check system dimensions
+  ## check system dimensions
   [n,nz,mg,pg,Gyd] = sysdimensions(nth(arglist,1));
   for kk=2:nargin
     [n,nz,mh,ph,Hyd] = sysdimensions(nth(arglist,kk));
     if(mg != mh)
       error("arg 1 has %d inputs; arg %d has vs %d inputs",mg,kk,mh);
     elseif(pg != ph)
       error("arg 1 has %d outputs; arg %d has vs %d outputs",pg,kk,ph);
     elseif(norm(Gyd - Hyd))
       warning("cannot add a discrete output to a continuous output");
       error("Output type mismatch: arguments 1 and %d\n",kk);
     endif
   endfor
 
-  # perform the subtract
+  ## perform the subtract
   if(nargin == 2)
     Gsys = nth(arglist,1);   Hsys = nth(arglist,2);
     if( strcmp(sysgettype(Gsys),"tf") | strcmp(sysgettype(Hsys),"tf") )
-      # see if subtracting  transfer functions with identical denominators
+      ## see if subtracting  transfer functions with identical denominators
       [Gnum,Gden,GT,Gin,Gout] = sys2tf(Gsys);
       [Hnum,Hden,HT,Hin,Hout] = sys2tf(Hsys);
       if(length(Hden) == length(Gden) )
         if( (Hden == Gden) & (HT == GT) )
           sys = tf2sys(Gnum+Hnum,Gden,GT,Gin,Gout);
           return
         endif
-        # if not, we go on and do the usual thing...
+        ## if not, we go on and do the usual thing...
       endif
     endif
   
-    # make sure in ss form
+    ## make sure in ss form
     Gsys = sysupdate(Gsys,"ss");
     Hsys = sysupdate(Hsys,"ss");
   
-    # change signal names to avoid warning messages from sysgroup
+    ## change signal names to avoid warning messages from sysgroup
     Gsys = syssetsignals(Gsys,"in",sysdefioname(length(Gin),"Gin_u"));
     Gsys = syssetsignals(Gsys,"out",sysdefioname(length(Gout),"Gout_u"));
     Hsys = syssetsignals(Hsys,"in",sysdefioname(length(Hin),"Hin_u"));
     Hsys = syssetsignals(Hsys,"out",sysdefioname(length(Hout),"Hout_u"));
     
     sys = sysgroup(Gsys,Hsys);
   
     eyin = eye(mg);
     eyout = eye(pg);
   
     sys = sysscale(sys,[eyout -eyout],[eyin;eyin],Gout,Gin);
   
   else
-    # multiple systems (or a single system); combine together one by one
+    ## multiple systems (or a single system); combine together one by one
     sys = nth(arglist,1);
     for kk=2:length(arglist)
       sys = syssub(sys,nth(arglist,kk));
     endfor
   endif
   
 endfunction
diff --git a/scripts/control/sysupdate.m b/scripts/control/sysupdate.m
--- a/scripts/control/sysupdate.m
+++ b/scripts/control/sysupdate.m
@@ -1,25 +1,25 @@
-# Copyright (C) 1996 Auburn University.  All Rights Reserved
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 0211
+## Copyright (C) 1996 Auburn University.  All Rights Reserved
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 0211
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File } { @var{sys} =} sysupdate ( @var{sys}, @var{opt} ) 
 ##  Update the internal representation of a system.
 ## 
 ## @strong{Inputs}
 ## @table @var
 ## @item sys:
@@ -44,79 +44,80 @@
 ## 
 ## Conversion to @code{tf} or @code{zp} exits with an error if the system is 
 ##  mixed continuous/digital.
 ## @end deftypefn
 
 ## See also: tf2sys, ss2sys, zp2sys, sysout, sys2ss, sys2tf, sys2zp
 
 function sys = sysupdate(sys,opt)
-# Written by John Ingram  7-9-96
 
-  # check for correct number of inputs 
+  ## Written by John Ingram  7-9-96
+
+  ## check for correct number of inputs 
   if (nargin != 2)
     usage("newsys = sysupdate(sys,opt)");
   elseif(! is_struct(sys) )
    error("1st argument must be system data structure")
   elseif(! (strcmp(opt,"tf") + strcmp(opt,"zp") + ...
 	strcmp(opt,"ss") + strcmp(opt,"all")) )
     error("2nd argument must be \"tf\", \"zp\", \"ss\", or \"all\"");
   endif
 
-  # check to make sure not trying to make a SISO system out of a MIMO sys
+  ## check to make sure not trying to make a SISO system out of a MIMO sys
   if ( (strcmp(opt,"tf") + strcmp(opt,"zp") + strcmp(opt,"all")) ...
 	& strcmp(sysgettype(sys),"ss") &  (! is_siso(sys) ) )
     error("MIMO -> SISO update requested");
   endif
 
-  # update transfer function if desired
+  ## update transfer function if desired
   if ( (strcmp(opt, "tf") + strcmp(opt,"all"))&&  (!sys.sys(2)))
-    # check to make sure the system is not discrete and continuous
+    ## check to make sure the system is not discrete and continuous
     is_digital(sys);
 
-    # if original system zero-pole
+    ## if original system zero-pole
     if strcmp(sysgettype(sys),"zp")
       [sys.num,sys.den] = zp2tf(sys.zer,sys.pol,sys.k);
       sys.sys(2) = 1;
-    # if original system is state-space
+    ## if original system is state-space
     elseif(sys.sys(1) == 2)
       [sys.num,sys.den] = ss2tf(sys.a,sys.b,sys.c,sys.d);
       sys.sys(2) = 1; 
     endif
   endif
 
 
-  # update zero-pole if desired
+  ## update zero-pole if desired
   if ( (strcmp(opt, "zp") + strcmp(opt,"all")) && (! sys.sys(3)) )
-    # check to make sure the system is not discrete and continuous
+    ## check to make sure the system is not discrete and continuous
     is_digital(sys);
 
-    # original system is transfer function
+    ## original system is transfer function
     if (sys.sys(1) == 0)
       [sys.zer,sys.pol,sys.k] = tf2zp(sys.num,sys.den);
       sys.sys(3) = 1;
-    # original system is state-space
+    ## original system is state-space
 
     elseif(sys.sys(1) == 2)
       [sys.zer,sys.pol,sys.k] = ss2zp(sys.a,sys.b,sys.c,sys.d);
       sys.sys(3) = 1; 
     endif
 
   endif
 
-  # update state-space if desired
+  ## update state-space if desired
   if ( (strcmp(opt, "ss") + strcmp(opt,"all")) && (! sys.sys(4)) )
-    # original system is transfer function
+    ## original system is transfer function
     if (sys.sys(1) == 0)
       [sys.a,sys.b,sys.c,sys.d] = tf2ss(sys.num,sys.den);
       sys.sys(4) = 1;
-    # original system is zero-pole
+    ## original system is zero-pole
     elseif(sys.sys(1) == 1)
       [sys.a,sys.b,sys.c,sys.d] = zp2ss(sys.zer,sys.pol,sys.k);
       sys.sys(4) = 1; 
     endif
 
-    # create new state names
+    ## create new state names
     sys.stname = sysdefstname(sys.n, sys.nz);
   endif
   
 
 endfunction
diff --git a/scripts/control/tf2ss.m b/scripts/control/tf2ss.m
--- a/scripts/control/tf2ss.m
+++ b/scripts/control/tf2ss.m
@@ -1,25 +1,25 @@
-# Copyright (C) 1996,1998 Auburn University.  All Rights Reserved
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1996,1998 Auburn University.  All Rights Reserved
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
  
 ## -*- texinfo -*-
 ## @deftypefn {Function File } { outputs =} tf2ss ( inputs ) 
 ## @format
 ##  Conversion from tranfer function to state-space.
 ##  The state space system
 ##       .
 ##       x = Ax + Bu
@@ -38,59 +38,59 @@
 ##  in controllable canonical form as described in "Modern Control Theory",
 ##  [Brogan, 1991].
 ## 
 ## 
 ## @end format
 ## @end deftypefn
 
 function [a,b,c,d] = tf2ss(num,den)
-  # Written by R. Bruce Tenison (June 22, 1994) btenison@eng.auburn.edu
-  # mod A S Hodel July, Aug  1995
+  ## Written by R. Bruce Tenison (June 22, 1994) btenison@eng.auburn.edu
+  ## mod A S Hodel July, Aug  1995
 
   if(nargin != 2)        error("tf2ss: wrong number of input arguments")
   elseif(isempty(num))   error("tf2ss: empty numerator");
   elseif(isempty(den))   error("tf2ss: empy denominator");
   elseif(!is_vector(num)) 
     error(sprintf("num(%dx%d) must be a vector",rows(num),columns(num)));
   elseif(!is_vector(den)) 
     error(sprintf("den(%dx%d) must be a vector",rows(den),columns(den)));
   endif
 
-  # strip leading zeros from num, den
+  ## strip leading zeros from num, den
   nz = find(num != 0);
   if(isempty(nz)) num = 0;
   else num = num(nz(1):length(num));         endif
   nz = find(den != 0);
   if(isempty(nz)) error("denominator is 0.");
   else den = den(nz(1):length(den));         endif
 
-  # force num, den to be row vectors
+  ## force num, den to be row vectors
   num = vec(num)';        den = vec(den)';
   nn = length(num);       nd = length(den);
   if(nn > nd) error(sprintf("deg(num)=%d > deg(den)= %d",nn,nd)); endif
 
-   # Check sizes
+   ## Check sizes
    if (nd == 1)      a = []; b = []; c = []; d = num(:,1) / den(1); 
    else
-    # Pad num so that length(num) = length(den)
+    ## Pad num so that length(num) = length(den)
     if (nd-nn > 0) num = [zeros(1,nd-nn), num]; endif
 
-    # Normalize the numerator and denominator vector w.r.t. the leading 
-    # coefficient
+    ## Normalize the numerator and denominator vector w.r.t. the leading 
+    ## coefficient
     d1 = den(1);    num = num / d1;    den = den(2:nd)/d1;
     sw = nd-1:-1:1;
 
-    # Form the A matrix
+    ## Form the A matrix
     if(nd > 2)      a = [zeros(nd-2,1),eye(nd-2,nd-2);-den(sw)];
     else            a = -den(sw);                                endif
 
-    # Form the B matrix
+    ## Form the B matrix
     b = zeros(nd-1,1);           b(nd-1,1) = 1;
 
-    # Form the C matrix
+    ## Form the C matrix
     c = num(:,2:nd)-num(:,1)*den;        c = c(:,sw);
 
-    # Form the D matrix
+    ## Form the D matrix
     d = num(:,1);
   endif
 
 endfunction
diff --git a/scripts/control/tf2sys.m b/scripts/control/tf2sys.m
--- a/scripts/control/tf2sys.m
+++ b/scripts/control/tf2sys.m
@@ -1,25 +1,25 @@
-# Copyright (C) 1996,1998 Auburn University.  All Rights Reserved
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1996,1998 Auburn University.  All Rights Reserved
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File } { @var{sys} = } tf2sys( @var{num}, @var{den} @{, @var{tsam}, @var{inname}, @var{outname} @})
 ##  build system data structure from transfer function format data
 ## 
 ## @strong{Inputs}
 ## @table @var
 ## @item  num, den
@@ -46,90 +46,90 @@
 ## transfer function form:
 ## 2*z^1 + 1
 ## -----------------
 ## 1*z^2 + 2*z^1 + 1
 ## @end example
 ## @end deftypefn
 
 function outsys = tf2sys(num,den,tsam,inname,outname)
-  #  Written by R. Bruce Tenison  July 29, 1994
-  #  Name changed to TF2SYS July 1995
-  #  updated for new system data structure format July 1996
+  ## Written by R. Bruce Tenison  July 29, 1994
+  ## Name changed to TF2SYS July 1995
+  ## updated for new system data structure format July 1996
 
   save_val = implicit_str_to_num_ok;
   implicit_str_to_num_ok = 1;
 
-  #  Test for the correct number of input arguments
+  ## Test for the correct number of input arguments
   if ((nargin < 2) || (nargin > 5))
     usage('outsys=tf2sys(num,den[,tsam,inname,outname])');
     return
   endif
 
-  # check input format 
+  ## check input format 
   if( ! ( (is_vector(num) || is_scalar(num)) && ...
 	(is_vector(den) || is_scalar(den))) )
     error(['num (',num2str(rows(num)),'x',num2str(columns(num)), ...
       ') and den (',num2str(rows(den)),'x',num2str(columns(den)), ...
       ') must be vectors'])
   endif
   
-  # strip leading zero coefficients
+  ## strip leading zero coefficients
   num = tf2sysl(num);
   den = tf2sysl(den);
 
   if (length(num) >  length(den))
     error("# of poles (%d) < # of zeros (%d)",length(den)-1, length(num)-1);
   endif
 
-  # check sampling interval (if any)
+  ## check sampling interval (if any)
   if(nargin <= 2)           tsam = 0;		# default
   elseif (isempty(tsam))    tsam = 0;           endif
   if ( (! (is_scalar(tsam) && (imag(tsam) == 0) )) || (tsam < 0) )
     error('tsam must be a positive real scalar')
   endif
 
   outsys.num = num;
   outsys.den = den;
 
-  #  Set the system vector:  active = 0(tf), updated = [1 0 0];
+  ## Set the system vector:  active = 0(tf), updated = [1 0 0];
   outsys.sys = [0, 1, 0, 0];
 
-  #  Set defaults
+  ## Set defaults
   outsys.tsam = tsam;
   outsys.n = length(den)-1;
   outsys.nz = 0;
   outsys.yd = 0;	# assume discrete-time
-  # check discrete time
+  ## check discrete time
   if(tsam > 0)
     [outsys.n,outsys.nz] = swap(outsys.n, outsys.nz);
     outsys.yd = 1;
   endif
 
   outsys.inname  = sysdefioname(1,"u");
   outsys.outname = sysdefioname(1,"y");
   outsys.stname  = sysdefstname(outsys.n,outsys.nz);
 
-  #  Set name of input
+  ## Set name of input
   if (nargin > 3)
-    # make sure its a list of a single string
+    ## make sure its a list of a single string
     if(!isempty(inname))
       if(!is_list(inname))  inname = list(inname);  endif
       if( !is_signal_list(inname) )
         error("inname must be a string or list of strings");
       endif
       if(length(inname) > 1)
         warning("tf2sys: %d input names provided; first used",length(inname));
         inname = inname(1);
       endif
       outsys = syssetsignals(outsys,"in",inname);
     endif
   endif
 
-  #  Set name of output
+  ## Set name of output
   if (nargin > 4)
     if(!isempty(outname))
       if(!is_list(outname))  outname = list(outname);  endif
       if(!is_signal_list(outname))
         error("outname must be a string or a list of strings");
       endif
       if(length(outname) > 1)
         warning("tf2sys: %d output names provided; first used",length(outname));
diff --git a/scripts/control/tf2sysl.m b/scripts/control/tf2sysl.m
--- a/scripts/control/tf2sysl.m
+++ b/scripts/control/tf2sysl.m
@@ -1,37 +1,37 @@
-# Copyright (C) 1996 Auburn University.  All Rights Reserved
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1996 Auburn University.  All Rights Reserved
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
  
 ## -*- texinfo -*-
 ## @deftypefn {Function File } { @var{vec} = } tf2sysl (@var{vec})
 ##  used internally in @ref{tf2sys}.
 ##  strip leading zero coefficients to get the true polynomial length
 ## @end deftypefn
 
 function vec = tf2sysl(vec)
-# vec = tf2sysl(vec)
-#
-# used internally in tf2sys
-# strip leading zero coefficients to get the true polynomial length
+## vec = tf2sysl(vec)
+##
+## used internally in tf2sys
+## strip leading zero coefficients to get the true polynomial length
 
 
 while( (length(vec) > 1) & (vec(1) == 0) )
   vec = vec(2:length(vec));
 endwhile
 if(vec(1) == 0)
   warning("tf2sys: polynomial has no nonzero coefficients!")
 endif
diff --git a/scripts/control/tf2zp.m b/scripts/control/tf2zp.m
--- a/scripts/control/tf2zp.m
+++ b/scripts/control/tf2zp.m
@@ -1,40 +1,40 @@
-# Copyright (C) 1996,1998 Auburn University.  All Rights Reserved
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1996,1998 Auburn University.  All Rights Reserved
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
  
 ## -*- texinfo -*-
 ## @deftypefn {Function File } { outputs =} tf2zp ( inputs ) 
 ## @format
 ##  Converts transfer functions to poles / zeros.
 ## 
 ##  [zer,pol,k] = tf2zp(num,den) returns the zeros and poles of the SISO system
 ##  defined by num/den.  K is a gain associated with the system zeros.
 ## 
 ## 
 ## @end format
 ## @end deftypefn
 
 function [zer,pol,k] = tf2zp(num,den)
-# Written by A. S. Hodel, etc.
+## Written by A. S. Hodel, etc.
 
   if(nargin == 2)
     if(length(den) > 1)          pol = roots(den);
     else                         pol=[];                   endif
     if(length(num) > 1)         zer = roots(num);
     else                        zer=[];                    endif
   else                    error("Incorrect number of input arguments");
   endif
diff --git a/scripts/control/tfout.m b/scripts/control/tfout.m
--- a/scripts/control/tfout.m
+++ b/scripts/control/tfout.m
@@ -1,37 +1,37 @@
-# Copyright (C) 1996 Auburn University.  All Rights Reserved
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1996 Auburn University.  All Rights Reserved
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
  
 ## -*- texinfo -*-
 ## @deftypefn {Function File } { } tfout (@var{num}, @var{denom}@{, @var{x}@})
 ##  print formatted transfer function @math{n(s)/d(s) } to the screen
 ##  @var{x} defaults to the string @code{"s"}
 ## @end deftypefn
 
 ##  See also: polyval, polyvalm, poly, roots, conv, deconv, residue, 
 ##	filter, polyderiv, polyinteg, polyout
 
 function tfout(num,denom,x)
-# Written by A. Scottedward Hodel (scotte@eng.auburn.edu) June 1995)
+## Written by A. Scottedward Hodel (scotte@eng.auburn.edu) June 1995)
   
   save_val = implicit_str_to_num_ok;
   save_empty = empty_list_elements_ok;
   empty_list_elements_ok = implicit_str_to_num_ok = 1;
   
   if (nargin < 2 ) | (nargin > 3) | (nargout != 0 ) 
     usage("tfout(num,denom[,x])");
   endif
diff --git a/scripts/control/tzero.m b/scripts/control/tzero.m
--- a/scripts/control/tzero.m
+++ b/scripts/control/tzero.m
@@ -1,120 +1,121 @@
-# Copyright (C) 1996 Auburn University.  All Rights Reserved
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1996 Auburn University.  All Rights Reserved
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
  
-## -*- texinfo -*-
-##@deftypefn {Function File} {} tzero (@var{a}, @var{b}, @var{c}, @var{d}@{, @var{opt}@})
-##@deftypefnx {Function File} {} tzero (@var{sys}@{,@var{opt}@})
-## Compute transmission zeros of a continuous
-##@example
-##.
-##x = Ax + Bu
-##y = Cx + Du
-##@end example
-##or discrete
-##@example
-##x(k+1) = A x(k) + B u(k)
-##y(k)   = C x(k) + D u(k)
-##@end example
-##system.
-##@strong{Outputs}
-##@table @var
-##@item zer
-## transmission zeros of the system
-##@item gain
-##leading coefficient (pole-zero form) of SISO transfer function
-##returns gain=0 if system is multivariable
-##@end table
-##@strong{References}
-##@enumerate
-##@item Emami-Naeini and Van Dooren, Automatica, 1982.
-##@item Hodel, "Computation of Zeros with Balancing," 1992 Lin. Alg. Appl.
-##@end enumerate
-##@end deftypefn
+##  -*- texinfo -*-
+## @deftypefn {Function File} {} tzero (@var{a}, @var{b}, @var{c}, @var{d}@{, @var{opt}@})
+## @deftypefnx {Function File} {} tzero (@var{sys}@{,@var{opt}@})
+##  Compute transmission zeros of a continuous
+## @example
+## .
+## x = Ax + Bu
+## y = Cx + Du
+## @end example
+## or discrete
+## @example
+## x(k+1) = A x(k) + B u(k)
+## y(k)   = C x(k) + D u(k)
+## @end example
+## system.
+## @strong{Outputs}
+## @table @var
+## @item zer
+##  transmission zeros of the system
+## @item gain
+## leading coefficient (pole-zero form) of SISO transfer function
+## returns gain=0 if system is multivariable
+## @end table
+## @strong{References}
+## @enumerate
+## @item Emami-Naeini and Van Dooren, Automatica, 1982.
+## @item Hodel, "Computation of Zeros with Balancing," 1992 Lin. Alg. Appl.
+## @end enumerate
+## @end deftypefn
 
 
 function [zer, gain] = tzero(A,B,C,D)
-  # R. Bruce Tenison July 4, 1994
-  # A. S. Hodel Aug 1995: allow for MIMO and system data structures
 
-  # get A,B,C,D and Asys variables, regardless of initial form
+  ## R. Bruce Tenison July 4, 1994
+  ## A. S. Hodel Aug 1995: allow for MIMO and system data structures
+
+  ## get A,B,C,D and Asys variables, regardless of initial form
   if(nargin == 4)
     Asys = ss2sys(A,B,C,D);
   elseif( (nargin == 1) && (! is_struct(A)))
     usage("[zer,gain] = tzero(A,B,C,D) or zer = tzero(Asys)");
   elseif(nargin != 1)
     usage("[zer,gain] = tzero(A,B,C,D) or zer = tzero(Asys)");
   else
     Asys = A;
     [A,B,C,D] = sys2ss(Asys);
   endif
 
   Ao = Asys;			# save for leading coefficient
   siso = is_siso(Asys);
   digital = is_digital(Asys);	# check if it's mixed or not
 
-  # see if it's a gain block
+  ## see if it's a gain block
   if(isempty(A))
     zer = [];
     gain = D;
     return;
   endif
 
-  # First, balance the system via the zero computation generalized eigenvalue
-  # problem balancing method (Hodel and Tiller, Linear Alg. Appl., 1992)
+  ## First, balance the system via the zero computation generalized eigenvalue
+  ## problem balancing method (Hodel and Tiller, Linear Alg. Appl., 1992)
 
   Asys = zgpbal(Asys); [A,B,C,D] = sys2ss(Asys);   # balance coefficients
   meps = 2*eps*norm([A, B; C, D],'fro');
   Asys = zgreduce(Asys,meps);  [A, B, C, D] = sys2ss(Asys); # ENVD algorithm
   if(!isempty(A))
-    # repeat with dual system
+    ## repeat with dual system
     Asys = ss2sys(A', C', B', D');   Asys = zgreduce(Asys,meps);
 
-    # transform back
+    ## transform back
     [A,B,C,D] = sys2ss(Asys);    Asys = ss2sys(A', C', B', D');
   endif
 
   zer = [];			# assume none
   [A,B,C,D] = sys2ss(Asys);
   if( !isempty(C) )
     [W,r,Pi] = qr([C, D]');
     [nonz,ztmp] = zgrownorm(r,meps);
     if(nonz)
-      # We can now solve the generalized eigenvalue problem.
+      ## We can now solve the generalized eigenvalue problem.
       [pp,mm] = size(D);
       nn = rows(A);
       Afm = [A , B ; C, D] * W';
       Bfm = [eye(nn), zeros(nn,mm); zeros(pp,nn+mm)]*W';
 
       jdx = (mm+1):(mm+nn);
       Af = Afm(1:nn,jdx);
       Bf = Bfm(1:nn,jdx);
       zer = qz(Af,Bf);
     endif
   endif
   
   mz = length(zer);
   [A,B,C,D] = sys2ss(Ao);		# recover original system
-  #compute leading coefficient
+  ## compute leading coefficient
   if ( (nargout == 2) && siso)
     n = rows(A);
     if ( mz == n)
       gain = D;
     elseif ( mz < n )
       gain = C*(A^(n-1-mz))*B;
     endif
   else
diff --git a/scripts/control/tzero2.m b/scripts/control/tzero2.m
--- a/scripts/control/tzero2.m
+++ b/scripts/control/tzero2.m
@@ -1,38 +1,38 @@
-# Copyright (C) 1993 Auburn University.  All Rights Reserved
-# 
-# This file is part of Octave.
-# 
-# Octave is free software; you can redistribute it and/or modify it
-# under the terms of the GNU General Public License as published by the
-# Free Software Foundation; either version 2, or (at your option) any
-# later version.
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License
-# along with Octave; see the file COPYING.  If not, write to the Free
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
+## Copyright (C) 1993 Auburn University.  All Rights Reserved
+## 
+## This file is part of Octave.
+## 
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
 ##@deftypefn {Function File } { @var{zr} =} tzero2 (@var{a}, @var{b}, @var{c}, @var{d}, @var{bal})
 ##Compute the transmission zeros of a, b, c, d.
 ##
 ##bal = balancing option (see balance); default is "B".
 ##
 ##Needs to incorporate @code{mvzero} algorithm to isolate finite zeros; use
 ##@code{tzero} instead.
 ##@end deftypefn
 
 function zr = tzero2 (a, b, c, d, bal)
-# Written by A. S. Hodel (scotte@eng.auburn.edu) August 1993.
+## Written by A. S. Hodel (scotte@eng.auburn.edu) August 1993.
 
   if (nargin == 4)
     bal = "B";
   elseif (nargin != 5)
     error ("tzero: illegal number of arguments");
   endif
 
   [n, m, p] = abcddim (a, b, c, d);
diff --git a/scripts/control/ugain.m b/scripts/control/ugain.m
--- a/scripts/control/ugain.m
+++ b/scripts/control/ugain.m
@@ -1,39 +1,40 @@
-# Copyright (C) 1997 Kai P. Mueller
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1997 Kai P. Mueller
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
  
 ## -*- texinfo -*-
 ## @deftypefn {Function File } { @var{outsys} =} ugain(n)
 ##  Creates a system with unity gain, no states.
 ##  This trivial system is sometimes needed to create arbitrary
 ##  complex systems from simple systems with buildssic.
 ##  Watch out if you are forming sampled systems since "ugain"
 ##  does not contain a sampling period.  
 ## 
 ## See also: hinfdemo (MIMO H_infinty example, Boeing 707-321 aircraft model)
 ## 
 ## @end deftypefn
 
 function outsys = ugain(n)
-  # Written by Kai P. Mueller April, 1998
-  # Updates
+
+  ## Written by Kai P. Mueller April, 1998
+  ## Updates
 
   if((nargin != 1) || (nargout > 1))
     usage("outsys = ugain(n)")
   endif
   outsys = ss2sys([],[],[],eye(n));
 endfunction
diff --git a/scripts/control/unpacksys.m b/scripts/control/unpacksys.m
--- a/scripts/control/unpacksys.m
+++ b/scripts/control/unpacksys.m
@@ -1,29 +1,30 @@
-# Copyright (C) 1996 Auburn University.  All Rights Reserved
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1996 Auburn University.  All Rights Reserved
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
  
 function [a,b,c,d] = unpacksys(syst)
-  # [a,b,c,d] = unpacksys(sys)
-  # Obsolete.  Use sys2ss instead.
 
-  # Written by David Clem August 19, 1994
+  ## [a,b,c,d] = unpacksys(sys)
+  ## Obsolete.  Use sys2ss instead.
+
+  ## Written by David Clem August 19, 1994
 
   warning("unpacksys obsolete; calling sys2ss");
   [a,b,c,d] = sys2ss(syst);
 
 endfunction
 
diff --git a/scripts/control/wgt1o.m b/scripts/control/wgt1o.m
--- a/scripts/control/wgt1o.m
+++ b/scripts/control/wgt1o.m
@@ -1,25 +1,25 @@
-# Copyright (C) 1998 Kai P. Mueller
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1998 Kai P. Mueller
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File } { @var{wsys} =} wgt1o (@var{vl}, @var{vh}, @var{fc})
 ## State space description of a first order weighting function.
 ## 
 ##  Weighting function are needed by the H2/H_infinity design procedure.
 ##  These function are part of thye augmented plant P (see hinfdemo
 ##  for an applicattion example).
@@ -27,17 +27,17 @@
 ##  vl = Gain @@ low frequencies
 ## 
 ##  vh = Gain @@ high frequencies
 ## 
 ##  fc = Corner frequency (in Hz, *not* in rad/sec)
 ## @end deftypefn
  
 function wsys = wgt1o(vl, vh, fc)
-# Written by Kai P. Mueller September 30, 1997
+## Written by Kai P. Mueller September 30, 1997
 
   if (nargin != 3)
     usage("wsys = wgt1o(vl, vh, fc)");
   endif
 
   if(nargout > 1)
     usage("wsys = wgt1o(vl, vh, fc)");
   endif
diff --git a/scripts/control/zgfmul.m b/scripts/control/zgfmul.m
--- a/scripts/control/zgfmul.m
+++ b/scripts/control/zgfmul.m
@@ -1,52 +1,53 @@
-# Copyright (C) 1996,1998 Auburn University.  All Rights Reserved
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1996,1998 Auburn University.  All Rights Reserved
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File } @var{y} = zgfmul(@var{a},@var{b},@var{c},@var{d},@var{x})
 ## 
 ## Compute product of zgep incidence matrix @var{F} with vector @var{x}.
 ## Used by zgepbal (in zgscal) as part of generalized conjugate gradient
 ## iteration.
 ## @end deftypefn
    
 ## References:
 ## ZGEP: Hodel, "Computation of Zeros with Balancing," 1992, submitted to  LAA
 ## Generalized CG: Golub and Van Loan, "Matrix Computations, 2nd ed" 1989
 
 function y = zgfmul(a,b,c,d,x)
-  # A. S. Hodel July 24 1992
-  # Conversion to Octave July 3, 1994
+
+  ## A. S. Hodel July 24 1992
+  ## Conversion to Octave July 3, 1994
   
   [n,m] = size(b);
   [p,m1] = size(c);
   nm = n+m;
   y = zeros(nm+p,1);
 
-  # construct F column by column
+  ## construct F column by column
   for jj=1:n
     Fj = zeros(nm+p,1);
 
-    #rows 1:n: F1
+    ## rows 1:n: F1
     aridx = complement(jj,find(a(jj,:) != 0)); 
     acidx = complement(jj,find(a(:,jj) != 0));
     bidx = find(b(jj,:) != 0);
     cidx = find(c(:,jj) != 0);
 
     Fj(aridx) = Fj(aridx) - 1;      # off diagonal entries of F1
     Fj(acidx) = Fj(acidx) - 1;
     # diagonal entry of F1
diff --git a/scripts/control/zgfslv.m b/scripts/control/zgfslv.m
--- a/scripts/control/zgfslv.m
+++ b/scripts/control/zgfslv.m
@@ -1,66 +1,66 @@
-# Copyright (C) 1996,1998 Auburn University.  All Rights Reserved
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1996,1998 Auburn University.  All Rights Reserved
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File } {x =} zgfslv(@var{n},@var{m},@var{p},@var{b})
 ## solve system of equations for dense zgep problem
 ## @end deftypefn
  
 function x = zgfslv(n,m,p,b)
-  # Written by A. Scotte Hodel
-  # Converted to Octave by R Bruce Tenison, July 3, 1994
+  ## Written by A. Scotte Hodel
+  ## Converted to Octave by R Bruce Tenison, July 3, 1994
 
   nmp = n+m+p;
   gam1 = (2*n)+m+p;    gam2 = n+p;     gam3 = n+m;
 
   G1 = givens(sqrt(m),-sqrt(p))';
   G2 = givens(m+p,sqrt(n*(m+p)))';
 
   x = b;
 
-  # 1) U1 e^n = sqrt(n)e_1^n
-  # 2) U2 e^m = sqrt(m)e_1^m
-  # 3) U3 e^p = sqrt(p)e_1^p
+  ## 1) U1 e^n = sqrt(n)e_1^n
+  ## 2) U2 e^m = sqrt(m)e_1^m
+  ## 3) U3 e^p = sqrt(p)e_1^p
   xdx1 = 1:n; xdx2 = n+(1:m); xdx3 = n+m+(1:p);
   x(xdx1,1) = zgshsr(x(xdx1,1));
   x(xdx2,1) = zgshsr(x(xdx2,1));
   x(xdx3,1) = zgshsr(x(xdx3,1));
 
-  # 4) Givens rotations to reduce stray non-zero elements
+  ## 4) Givens rotations to reduce stray non-zero elements
   idx1 = [n+1,n+m+1];     idx2 = [1,n+1];
   x(idx1) = G1'*x(idx1);
   x(idx2) = G2'*x(idx2);
 
-  # 6) Scale x, then back-transform to get x
+  ## 6) Scale x, then back-transform to get x
   en = ones(n,1);  em = ones(m,1);   ep = ones(p,1);
   lam = [gam1*en;gam2*em;gam3*ep]; 
   lam(1) = n+m+p; 
   lam(n+1) = 1;       # dummy value to avoid divide by zero
   lam(n+m+1)=n+m+p;
 
   x = x ./ lam;       x(n+1) = 0;  # minimum norm solution
 
-  # back transform now.
+  ## back transform now.
   x(idx2) = G2*x(idx2);
   x(idx1) = G1*x(idx1);
   x(xdx3,1) = zgshsr(x(xdx3,1));
   x(xdx2,1) = zgshsr(x(xdx2,1));
   x(xdx1,1) = zgshsr(x(xdx1,1));
 
 endfunction
 
diff --git a/scripts/control/zginit.m b/scripts/control/zginit.m
--- a/scripts/control/zginit.m
+++ b/scripts/control/zginit.m
@@ -1,90 +1,91 @@
-# Copyright (C) 1996,1998 Auburn University.  All Rights Reserved
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1996,1998 Auburn University.  All Rights Reserved
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File } {zz =} zginit(@var{a},@var{b},@var{c},@var{d})
 ## construct right hand side vector zz
 ## for the zero-computation generalized eigenvalue problem
 ## balancing procedure
 ## called by zgepbal
 ## 
 ## @end deftypefn 
 
 ## References:
 ## ZGEP: Hodel, "Computation of Zeros with Balancing," 1992, submitted to  LAA
 ## Generalized CG: Golub and Van Loan, "Matrix Computations, 2nd ed" 1989
 
 function zz = zginit(a,b,c,d)
-  # A. S. Hodel July 24 1992
-  # Conversion to Octave by R. Bruce Tenison, July 3, 1994
+
+  ## A. S. Hodel July 24 1992
+  ## Conversion to Octave by R. Bruce Tenison, July 3, 1994
 
   [nn,mm] = size(b);
   [pp,mm] = size(d);
 
   nmp = nn+mm+pp;
 
-  # set up log vector zz
+  ## set up log vector zz
   zz = zeros(nmp,1);
 
-  # zz part 1:
+  ## zz part 1:
   for i=1:nn
-    # nonzero off diagonal entries of a
+    ## nonzero off diagonal entries of a
     if(nn > 1)
       nidx = complement(i,1:nn);
       a_row_i = a(i,nidx);                 a_col_i = a(nidx,i);
       arnz = a_row_i(find(a_row_i != 0));  acnz = a_col_i(find(a_col_i != 0));
     else
       arnz = acnz = [];
     endif
 
-    # row of b
+    ## row of b
     bidx = find(b(i,:) != 0);
     b_row_i = b(i,bidx);
 
-    # column of c
+    ## column of c
     cidx = find(c(:,i) != 0);
     c_col_i = c(cidx,i);
    
-    # sum the entries
+    ## sum the entries
     zz(i) = sum(log(abs(acnz))) - sum(log(abs(arnz))) ...
             - sum(log(abs(b_row_i))) + sum(log(abs(c_col_i)));
   endfor
 
-  # zz part 2:
+  ## zz part 2:
   bd = [b;d];
   for i=1:mm
     i1 = i+nn;
 
-    # column of [b;d]
+    ## column of [b;d]
     bdidx = find(bd(:,i) != 0);
     bd_col_i = bd(bdidx,i);
     zz(i1) = sum(log(abs(bd_col_i)));
   endfor
 
-  # zz part 3:
+  ## zz part 3:
   cd = [c, d];
   for i=1:pp
     i1 = i+nn+mm;
     cdidx = find(cd(i,:) != 0);
     cd_row_i = cd(i,cdidx);
     zz(i1) = -sum(log(abs(cd_row_i)));
   endfor
 
-  # now set zz as log base 2
+  ## now set zz as log base 2
   zz = zz*(1/log(2));
 endfunction
diff --git a/scripts/control/zgpbal.m b/scripts/control/zgpbal.m
--- a/scripts/control/zgpbal.m
+++ b/scripts/control/zgpbal.m
@@ -1,25 +1,25 @@
-# Copyright (C) 1996 Auburn University.  All Rights Reserved
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1996 Auburn University.  All Rights Reserved
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File } {[retsys] =} zgpbal(Asys)
 ##
 ## used internally in @code{tzero}; minimal argument checking performed
 ##
 ## implementation of zero computation generalized eigenvalue problem 
 ## balancing method (Hodel and Tiller, Allerton Conference, 1991)
@@ -34,70 +34,70 @@
 ##
 ## @end deftypefn
 
 ## References:
 ## ZGEP: Hodel, "Computation of Zeros with Balancing," 1992, submitted to  LAA
 ## Generalized CG: Golub and Van Loan, "Matrix Computations, 2nd ed" 1989
 
 function [retsys] = zgpbal(Asys)  
-  # A. S. Hodel July 24 1992
-  # Conversion to Octave by R. Bruce Tenison July 3, 1994
+  ## A. S. Hodel July 24 1992
+  ## Conversion to Octave by R. Bruce Tenison July 3, 1994
 
   if( (nargin != 1) | (!is_struct(Asys)))
     usage("retsys = zgpbal(Asys)");
   endif
 
   Asys = sysupdate(Asys,"ss");
   [a,b,c,d] = sys2ss(Asys);
 
   [nn,mm,pp] = abcddim(a,b,c,d);
   
   np1 = nn+1;
   nmp = nn+mm+pp;
 
-  # set up log vector zz, incidence matrix ff
+  ## set up log vector zz, incidence matrix ff
   zz = zginit(a,b,c,d);
 
-  #disp("zgpbal: zginit returns")
-  #zz
-  #disp("/zgpbal")
+  ## disp("zgpbal: zginit returns")
+  ## zz
+  ## disp("/zgpbal")
 
   if (norm(zz))
-    # generalized conjugate gradient approach
+    ## generalized conjugate gradient approach
     xx = zgscal(a,b,c,d,zz,nn,mm,pp);
     
     for i=1:nmp
       xx(i) = floor(xx(i)+0.5);
       xx(i) = 2.0^xx(i);
     endfor
     
-    # now scale a
-    # block 1: a = sigma a inv(sigma)
+    ## now scale a
+    ## block 1: a = sigma a inv(sigma)
     for i=1:nn
       a(i,1:nn) = a(i,1:nn)*xx(i);
       a(1:nn,i) = a(1:nn,i)/xx(i);
     endfor
-    # block 2: b= sigma a phi
+    ## block 2: b= sigma a phi
     for j=1:mm
       j1 = j+nn;
       b(1:nn,j) = b(1:nn,j)*xx(j1);
     endfor
     for i=1:nn
       b(i,1:mm) = b(i,1:mm)*xx(i);
     endfor
     for i=1:pp
       i1 = i+nn+mm;
-      #   block 3: c = psi C inv(sigma)
+      ## block 3: c = psi C inv(sigma)
       c(i,1:nn) = c(i,1:nn)*xx(i1);
     endfor
     for j=1:nn
       c(1:pp,j) = c(1:pp,j)/xx(j);
     endfor
-    #   block 4: d = psi D phi
+    ## block 4: d = psi D phi
     for j=1:mm
       j1 = j+nn;
       d(1:pp,j) = d(1:pp,j)*xx(j1);
     endfor
     for i=1:pp
       i1 = i + nn + mm;
       d(i,1:mm) = d(i,1:mm)*xx(i1);
     endfor
diff --git a/scripts/control/zgreduce.m b/scripts/control/zgreduce.m
--- a/scripts/control/zgreduce.m
+++ b/scripts/control/zgreduce.m
@@ -1,141 +1,142 @@
-# Copyright (C) 1996 Auburn University.  All Rights Reserved
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1996 Auburn University.  All Rights Reserved
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File } { retsys = } zgreduce(@var{Asys},@var{meps})
 ## Implementation of procedure REDUCE in (Emami-Naeini and Van Dooren, 
 ## Automatica, # 1982).
 ## @end deftypefn
  
 function retsys = zgreduce(Asys,meps)
-# SYS_INTERNAL accesses members of system data structure
 
-is_digital(Asys);		# make sure it's pure digital/continuous
+  ## SYS_INTERNAL accesses members of system data structure
+
+  is_digital(Asys);		# make sure it's pure digital/continuous
 
-exit_1 = 0;			# exit_1 = 1 or 2 on exit of loop
+  exit_1 = 0;			# exit_1 = 1 or 2 on exit of loop
 
-if(Asys.n + Asys.nz == 0)
-  exit_1 = 2;			# there are no finite zeros
-endif
+  if(Asys.n + Asys.nz == 0)
+    exit_1 = 2;			# there are no finite zeros
+  endif
 
-while (! exit_1)
-  [Q,R,Pi] = qr(Asys.d);		# compress rows of D
-  Asys.d = Q'*Asys.d;
-  Asys.c = Q'*Asys.c;
+  while (! exit_1)
+    [Q,R,Pi] = qr(Asys.d);		# compress rows of D
+    Asys.d = Q'*Asys.d;
+    Asys.c = Q'*Asys.c;
 
-  # check row norms of Asys.d
-  [sig,tau] = zgrownorm(Asys.d,meps);
+    ## check row norms of Asys.d
+    [sig,tau] = zgrownorm(Asys.d,meps);
 
-  #disp("=======================================")
-  #disp(["zgreduce: meps=",num2str(meps), ", sig=",num2str(sig), ...
-  #	", tau=",num2str(tau)])
-  #sysout(Asys)
+    ## disp("=======================================")
+    ## disp(["zgreduce: meps=",num2str(meps), ", sig=",num2str(sig), ...
+    ##	 ", tau=",num2str(tau)])
+    ## sysout(Asys)
 
-  if(tau == 0)
-    exit_1 = 1;		# exit_1 - reduction complete and correct
-  else
-    Cb = Db = [];
-    if(sig)
-      Cb = Asys.c(1:sig,:);
-      Db = Asys.d(1:sig,:);
-    endif
-    Ct =Asys.c(sig+(1:tau),:);
+    if(tau == 0)
+      exit_1 = 1;		# exit_1 - reduction complete and correct
+    else
+      Cb = Db = [];
+      if(sig)
+	Cb = Asys.c(1:sig,:);
+	Db = Asys.d(1:sig,:);
+      endif
+      Ct =Asys.c(sig+(1:tau),:);
 
-    # compress columns of Ct
-    [pp,nn] = size(Ct);
-    rvec = nn:-1:1;
-    [V,Sj,Pi] = qr(Ct');
-    V = V(:,rvec);
-    [rho,gnu] = zgrownorm(Sj,meps);
+      ## compress columns of Ct
+      [pp,nn] = size(Ct);
+      rvec = nn:-1:1;
+      [V,Sj,Pi] = qr(Ct');
+      V = V(:,rvec);
+      [rho,gnu] = zgrownorm(Sj,meps);
 
-    #disp(["zgreduce: rho=",num2str(rho),", gnu=",num2str(gnu)])
-    #Cb
-    #Db
-    #Ct
-    #Sj'
+      ## disp(["zgreduce: rho=",num2str(rho),", gnu=",num2str(gnu)])
+      ## Cb
+      ## Db
+      ## Ct
+      ## Sj'
 
-    if(rho == 0)
-      exit_1 = 1;	# exit_1 - reduction complete and correct
-    elseif(gnu == 0)
-      exit_1 = 2;	# there are no zeros at all
-    else
-      mu = rho + sig;
+      if(rho == 0)
+	exit_1 = 1;	# exit_1 - reduction complete and correct
+      elseif(gnu == 0)
+	exit_1 = 2;	# there are no zeros at all
+      else
+	mu = rho + sig;
 
-      # update system with Q
-      M = [Asys.a , Asys.b ];
-      [nn,mm] = size(Asys.b);
+	## update system with Q
+	M = [Asys.a , Asys.b ];
+	[nn,mm] = size(Asys.b);
 
-      pp = rows(Asys.d);
-      Vm =[V,zeros(nn,mm) ; zeros(mm,nn), eye(mm)];
-      if(sig)
-        M = [M; Cb, Db];
-        Vs =[V',zeros(nn,sig) ; zeros(sig,nn), eye(sig)];
-      else
-        Vs = V';
-      endif
-      #disp("zgreduce: before transform: M=");
-      #M
-      #Vs   
-      #Vm
+	pp = rows(Asys.d);
+	Vm =[V,zeros(nn,mm) ; zeros(mm,nn), eye(mm)];
+	if(sig)
+	  M = [M; Cb, Db];
+	  Vs =[V',zeros(nn,sig) ; zeros(sig,nn), eye(sig)];
+	else
+	  Vs = V';
+	endif
+	## disp("zgreduce: before transform: M=");
+	## M
+	## Vs   
+	## Vm
 
-      M = Vs*M*Vm;
-      
-      #disp("zgreduce: after transform: M=");
-      #M
+	M = Vs*M*Vm;
+
+	## disp("zgreduce: after transform: M=");
+	## M
 
-      #disp("debugging code:")
-      #Mtmp = [Asys.a Asys.b; Asys.c Asys.d]
-      #Vl = [V', zeros(nn,mm); zeros(mm,nn),Q]
-      #Vr =[V,zeros(nn,mm) ; zeros(mm,nn), eye(mm)];
-      #Mtmpf = Vl*Mtmp*Vr
+	## disp("debugging code:")
+	## Mtmp = [Asys.a Asys.b; Asys.c Asys.d]
+	## Vl = [V', zeros(nn,mm); zeros(mm,nn),Q]
+	## Vr =[V,zeros(nn,mm) ; zeros(mm,nn), eye(mm)];
+	## Mtmpf = Vl*Mtmp*Vr
 
-      idx = 1:gnu;
-      jdx = nn + (1:mm);
-      sdx = gnu + (1:mu);
+	idx = 1:gnu;
+	jdx = nn + (1:mm);
+	sdx = gnu + (1:mu);
 
-      Asys.a = M(idx,idx);
-      Asys.b = M(idx,jdx);
-      Asys.c = M(sdx,idx);
-      Asys.d = M(sdx,jdx);
+	Asys.a = M(idx,idx);
+	Asys.b = M(idx,jdx);
+	Asys.c = M(sdx,idx);
+	Asys.d = M(sdx,jdx);
 
-      #disp(["zgreduce: resulting system: nn =",num2str(nn)," mu=",num2str(mu)])
-      #sysout(Asys)
-      #idx
-      #jdx
-      #sdx
+	## disp(["zgreduce: resulting system: nn =",num2str(nn)," mu=",num2str(mu)])
+	## sysout(Asys)
+	## idx
+	## jdx
+	## sdx
+      endif
     endif
-  endif
-endwhile
+  endwhile
 
-#disp(["zgreduce: while loop done: exit_1=",num2str(exit_1)]);
+  ## disp(["zgreduce: while loop done: exit_1=",num2str(exit_1)]);
 
-if(exit_1 == 2)
-  # there are no zeros at all!
-  Asys.a = Asys.b = Asys.c = [];
-endif
+  if(exit_1 == 2)
+    ## there are no zeros at all!
+    Asys.a = Asys.b = Asys.c = [];
+  endif
 
-# update dimensions
-if(is_digital(Asys))
-  Asys.nz = rows(Asys.a);
-else
-  Asys.n = rows(Asys.a);
-endif
+  ## update dimensions
+  if(is_digital(Asys))
+    Asys.nz = rows(Asys.a);
+  else
+    Asys.n = rows(Asys.a);
+  endif
 
-retsys = Asys;
+  retsys = Asys;
 
 endfunction
diff --git a/scripts/control/zgrownorm.m b/scripts/control/zgrownorm.m
--- a/scripts/control/zgrownorm.m
+++ b/scripts/control/zgrownorm.m
@@ -1,25 +1,25 @@
-# Copyright (C) 1996 Auburn University.  All Rights Reserved
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1996 Auburn University.  All Rights Reserved
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File } { [@var{nonz}, @var{zer}] =} zgrownorm (@var{mat}, @var{meps})
 ## returns @var{nonz} = number of rows of @var{mat} whose two norm exceeds @var{meps}
 ##         @var{zer} = number of rows of mat whose two norm is less than meps
 ## @end deftypefn
 
 function [sig, tau] = zgrownorm(mat,meps)
diff --git a/scripts/control/zgscal.m b/scripts/control/zgscal.m
--- a/scripts/control/zgscal.m
+++ b/scripts/control/zgscal.m
@@ -1,57 +1,56 @@
-# Copyright (C) 1996,1998 Auburn University.  All Rights Reserved
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1996,1998 Auburn University.  All Rights Reserved
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
  
 ## -*- texinfo -*-
 ## @deftypefn {Function File } { x =} zgscal (@var{f}, @var{z}, @var{n}, @var{m}, @var{p})
 ## Generalized conjugate gradient iteration to 
 ## solve zero-computation generalized eigenvalue problem balancing equation 
 ## @math{fx=z};
 ## called by @code{zgepbal}
 ## @end deftypefn
 
 ## References:
 ## ZGEP: Hodel, "Computation of Zeros with Balancing," 1992, submitted to  LAA
 ## Generalized CG: Golub and Van Loan, "Matrix Computations, 2nd ed" 1989
 
 function x = zgscal(a,b,c,d,z,n,m,p)
-  # A. S. Hodel July 24 1992
-  # Conversion to Octave R. Bruce Tenison July 3, 1994
 
+  ## A. S. Hodel July 24 1992
+  ## Conversion to Octave R. Bruce Tenison July 3, 1994
 
-  #**************************************************************************
-  #initialize parameters:
-  #  Givens rotations, diagonalized 2x2 block of F, gcg vector initialization
-  #**************************************************************************
+  ## initialize parameters:
+  ## Givens rotations, diagonalized 2x2 block of F, gcg vector initialization
+
   nmp = n+m+p;
   
-  #x_0 = x_{-1} = 0, r_0 = z
+  ## x_0 = x_{-1} = 0, r_0 = z
   x = zeros(nmp,1);
   xk1 = x;
   xk2 = x;
   rk1 = z;
   k = 0;
 
-  # construct balancing least squares problem
+  ## construct balancing least squares problem
   F = eye(nmp);
   for kk=1:nmp
     F(1:nmp,kk) = zgfmul(a,b,c,d,F(:,kk));
   endfor
 
   [U,H,k1] = krylov(F,z,nmp,1e-12,1);
   if(!is_square(H))
     if(columns(H) != k1) 
@@ -61,85 +60,85 @@ function x = zgscal(a,b,c,d,z,n,m,p)
     elseif ( norm(H(k1+1,:)) > 1e-12*norm(H,"inf") )
       zgscal_last_row_of_H = H(k1+1,:)
       error("zgscal: last row of H nonzero (norm(H)=%e)",norm(H,"inf"))
     endif
     H = H(1:k1,1:k1);
     U = U(:,1:k1);
   endif
 
-  # tridiagonal H can still be rank deficient, so do permuted qr 
-  # factorization
+  ## tridiagonal H can still be rank deficient, so do permuted qr 
+  ## factorization
   [qq,rr,pp] = qr(H);	# H = qq*rr*pp'
   nn = rank(rr);
   qq = qq(:,1:nn);
   rr = rr(1:nn,:);            # rr may not be square, but "\" does least
   xx = U*pp*(rr\qq'*(U'*z));  # squares solution, so this works
-  #xx1 = pinv(F)*z;
-  #zgscal_x_xx1_err = [xx,xx1,xx-xx1]
+  ## xx1 = pinv(F)*z;
+  ## zgscal_x_xx1_err = [xx,xx1,xx-xx1]
   return;
 
-  # the rest of this is left from the original zgscal;
-  # I've had some numerical problems with the GCG algorithm,
-  # so for now I'm solving it with the krylov routine.
+  ## the rest of this is left from the original zgscal;
+  ## I've had some numerical problems with the GCG algorithm,
+  ## so for now I'm solving it with the krylov routine.
 
-  #initialize residual error norm
+  ## initialize residual error norm
   rnorm = norm(rk1,1);
 
   xnorm = 0;
   fnorm = 1e-12 * norm([a,b;c,d],1);
 
-  # dummy defines for MATHTOOLS compiler
+  ## dummy defines for MATHTOOLS compiler
   gamk2 = 0;      omega1 = 0;      ztmz2 = 0;
 
-  #do until small changes to x
+  ## do until small changes to x
   len_x = length(x);
   while ((k < 2*len_x) & (xnorm> 0.5) & (rnorm>fnorm))|(k == 0)
     k = k+1;
     
-    #  solve F_d z_{k-1} = r_{k-1}
+    ## solve F_d z_{k-1} = r_{k-1}
     zk1= zgfslv(n,m,p,rk1);
 
-    # Generalized CG iteration
-    # gamk1 = (zk1'*F_d*zk1)/(zk1'*F*zk1);
+    ## Generalized CG iteration
+    ## gamk1 = (zk1'*F_d*zk1)/(zk1'*F*zk1);
     ztMz1 = zk1'*rk1;
     gamk1 = ztMz1/(zk1'*zgfmul(a,b,c,d,zk1));
 
     if(rem(k,len_x) == 1) omega = 1;
     else                  omega = 1/(1-gamk1*ztMz1/(gamk2*omega1*ztmz2));
     endif
 
-    # store x in xk2 to save space
+    ## store x in xk2 to save space
     xk2 = xk2 + omega*(gamk1*zk1 + xk1 - xk2);
 
-    # compute new residual error: rk = z - F xk, check end conditions
+    ## compute new residual error: rk = z - F xk, check end conditions
     rk1 = z - zgfmul(a,b,c,d,xk2);
     rnorm = norm(rk1);
     xnorm = max(abs(xk1 - xk2));
 
-    #printf("zgscal: k=%d, gamk1=%e, gamk2=%e, \nztMz1=%e ztmz2=%e\n", ...
-    #	k,gamk1, gamk2, ztMz1, ztmz2);
-    # xk2_1_zk1 = [xk2 xk1 zk1]
-    # ABCD = [a,b;c,d]
-    # prompt
+    ## printf("zgscal: k=%d, gamk1=%e, gamk2=%e, \nztMz1=%e ztmz2=%e\n", ...
+    ##   k,gamk1, gamk2, ztMz1, ztmz2);
+    ## xk2_1_zk1 = [xk2 xk1 zk1]
+    ## ABCD = [a,b;c,d]
+    ## prompt
 
-    #  get ready for next iteration
+    ## get ready for next iteration
     gamk2 = gamk1;
     omega1 = omega;
     ztmz2 = ztMz1;
     [xk1,xk2] = swap(xk1,xk2);
   endwhile
   x = xk2;
 
-  # check convergence
+  ## check convergence
   if (xnorm> 0.5 & rnorm>fnorm) 
     warning("zgscal(tzero): GCG iteration failed; solving with pinv");
 
-    # perform brute force least squares; construct F
+    ## perform brute force least squares; construct F
     Am = eye(nmp);
     for ii=1:nmp
       Am(:,ii) = zgfmul(a,b,c,d,Am(:,ii));
     endfor
 
-    # now solve with qr factorization
+    ## now solve with qr factorization
     x = pinv(Am)*z;
   endif
 endfunction
diff --git a/scripts/control/zgsgiv.m b/scripts/control/zgsgiv.m
--- a/scripts/control/zgsgiv.m
+++ b/scripts/control/zgsgiv.m
@@ -1,33 +1,33 @@
-# Copyright (C) 1996,1998 Auburn University.  All Rights Reserved
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1996,1998 Auburn University.  All Rights Reserved
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File } {[a ,b ] =} zgsgiv(@var{c},@var{s},@var{a},@var{b})
 ## apply givens rotation c,s to row vectors @var{a},@var{b}
 ## No longer used in zero-balancing (zgpbal); kept for backward compatibility
 ## @end deftypefn
 
 function [a,b] = zgsgiv(c,s,a,b)
-  # A. S. Hodel July 29, 1992
-  # Convertion to Octave by R. Bruce Tenison July 3, 1994
+  ## A. S. Hodel July 29, 1992
+  ## Convertion to Octave by R. Bruce Tenison July 3, 1994
 
   t1 = c*a + s*b;
   t2 = -s*a + c*b;
   a = t1;
   b = t2;
 endfunction
diff --git a/scripts/control/zgshsr.m b/scripts/control/zgshsr.m
--- a/scripts/control/zgshsr.m
+++ b/scripts/control/zgshsr.m
@@ -1,36 +1,36 @@
-# Copyright (C) 1996 Auburn University.  All Rights Reserved
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1996 Auburn University.  All Rights Reserved
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
  
 ## -*- texinfo -*-
 ## @deftypefn {Function File } { @var{x} =} zgshsr( @var{y})
 ## apply householder vector based on @math{e^(m)} to 
 ## (column vector) y.
 ## Called by zgfslv
 ## @end deftypefn
 
 function x = zgshsr(y)
-  # A. S. Hodel July 24, 1992
-  # Conversion to Octave by R. Bruce Tenison July 3, 1994
+  ## A. S. Hodel July 24, 1992
+  ## Conversion to Octave by R. Bruce Tenison July 3, 1994
 
   if(!is_vector(y))
     error(sprintf("y(%dx%d) must be a vector",rows(y),columns(y)));
   endif
   x = vec(y);
   m = length(x);
   if (m>1)
     beta = (1 + sqrt(m))*x(1) + sum(x(2:m));
diff --git a/scripts/control/zp2ss.m b/scripts/control/zp2ss.m
--- a/scripts/control/zp2ss.m
+++ b/scripts/control/zp2ss.m
@@ -1,25 +1,25 @@
-# Copyright (C) 1996 Auburn University.  All Rights Reserved
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1996 Auburn University.  All Rights Reserved
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File } {[@var{A}, @var{B}, @var{C}, @var{D}] =} zp2ss (@var{zer}, @var{pol}, @var{k})
 ## Conversion from zero / pole to state space.
 ## @strong{Inputs}
 ## @table 
 ## @item zer, pol
 ## vectors of (possibly) complex poles and zeros of a transfer
@@ -41,17 +41,18 @@
 ## The vectors @samp{zer} and 
 ## @samp{pol} may either be row or column vectors.  Each zero and pole that
 ## has an imaginary part must have a conjugate in the list.
 ## The number of zeros must not exceed the number of poles.
 ## @samp{k} is @code{zp}-form leading coefficient.
 ## @end deftypefn
  
 function [a,b,c,d] = zp2ss(zer,pol,k)
-# Written by David Clem August 15, 1994
+
+  ## Written by David Clem August 15, 1994
 
   sav_val = empty_list_elements_ok;
   empty_list_elements_ok = 1;
 
   if(nargin != 3)
     error("Incorrect number of input arguments");
   endif
  
@@ -65,38 +66,38 @@ function [a,b,c,d] = zp2ss(zer,pol,k)
     error(["k(",num2str(rows(k)),",",num2str(columns(k)), ...
 	") should be a scalar"]);
   elseif( k != real(k))
     warning("zp2ss: k is complex")
   endif
 
   zpsys = ss2sys([],[],[],k);
 
-  # Find the number of zeros and the number of poles
+  ## Find the number of zeros and the number of poles
   nzer=length(zer);
   npol =length(pol);
 
   if(nzer > npol)
     error([num2str(nzer)," zeros, exceeds number of poles=",num2str(npol)]);
   endif
 
-  # Sort to place complex conjugate pairs together
+  ## Sort to place complex conjugate pairs together
   zer=sortcom(zer);
   pol=sortcom(pol);
 
-  # construct the system as a series connection of poles and zeros
-  # problem: poles and zeros may come in conjugate pairs, and not
-  # matched up!
+  ## construct the system as a series connection of poles and zeros
+  ## problem: poles and zeros may come in conjugate pairs, and not
+  ## matched up!
 
-  # approach: remove poles/zeros from the list as they are included in
-  # the ss system
+  ## approach: remove poles/zeros from the list as they are included in
+  ## the ss system
  
   while(length(pol))
 
-    # search for complex poles, zeros
+    ## search for complex poles, zeros
     cpol=[];    czer = [];
     if(!isempty(pol))
       cpol = find(imag(pol) != 0);
     endif
     if(!isempty(zer))
       czer = find(imag(zer) != 0);
     endif
 
@@ -104,40 +105,40 @@ function [a,b,c,d] = zp2ss(zer,pol,k)
       pcnt = 1;
     else 
       pcnt = 2;
     endif
 
     num=1;	# assume no zeros left.
     switch(pcnt)
     case(1)
-      # real pole/zero combination
+      ## real pole/zero combination
       if(length(zer))
         num = [1 -zer(1)];  
         zer = zer(2:length(zer));
       endif
       den = [1 -pol(1)];
       pol = pol(2:length(pol));
     case(2)
-      # got a complex pole or zero, need two roots (if available)
+      ## got a complex pole or zero, need two roots (if available)
       if(length(zer) > 1)
         [num,zer] = zp2ssg2(zer);	# get two zeros
       elseif(length(zer) == 1)
         num = [1 -zer];			# use last zero (better be real!)
         zer = [];
       endif
       [den,pol] = zp2ssg2(pol);		# get two poles
     otherwise
       error(["pcnt = ",num2str(pcnt)])
     endswitch
 
-    # pack tf into system form and put in series with earlier realization
+    ## pack tf into system form and put in series with earlier realization
     zpsys1 = tf2sys(num,den,0,"u","yy");
 
-    # change names to avoid warning messages from sysgroup
+    ## change names to avoid warning messages from sysgroup
     zpsys  = syssetsignals(zpsys,"in","u1",1);
     zpsys1 = sysupdate(zpsys1,"ss");
     nn     = sysdimensions(zpsys);        # working with continuous system
     zpsys  = syssetsignals(zpsys,"st", sysdefioname(nn,"x"));
     nn1    = sysdimensions(zpsys1);
     zpsys1 = syssetsignals(zpsys1,"st",sysdefioname(nn1,"xx"));
 
     zpsys = sysmult(zpsys,zpsys1);
diff --git a/scripts/control/zp2ssg2.m b/scripts/control/zp2ssg2.m
--- a/scripts/control/zp2ssg2.m
+++ b/scripts/control/zp2ssg2.m
@@ -1,66 +1,67 @@
-# Copyright (C) 1996,1998 Auburn University.  All Rights Reserved
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1996,1998 Auburn University.  All Rights Reserved
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File } { [@var{poly}, @var{rvals}] =} zp2ssg2 (@var{rvals})
 ## Used internally in @code{zp2ss}
 ## Extract 2 values from @var{rvals} (if possible) and construct
 ##  a polynomial with those roots.
 ## @end deftypefn
 
 function [poly,rvals] = zp2ssg2(rvals)
-# A. S. Hodel Aug 1996
+
+  ## A. S. Hodel Aug 1996
 
-# locate imaginary roots (if any)
-cidx = find(imag(rvals));
+  ## locate imaginary roots (if any)
+  cidx = find(imag(rvals));
 
-if(!isempty(cidx))
-  # select first complex root, omit from cidx
-  r1i = cidx(1);      r1 = rvals(r1i);     cidx = complement(r1i,cidx);
+  if(!isempty(cidx))
+    ## select first complex root, omit from cidx
+    r1i = cidx(1);      r1 = rvals(r1i);     cidx = complement(r1i,cidx);
 
-  # locate conjugate root (must be in cidx list, just in case there's
-  # roundoff)
-  err = abs(rvals(cidx) - r1');
-  minerr = min(err);
-  c2i = find(err == minerr);
-  r2i = cidx(c2i);
-  r2 = rvals(r2i);
-  cidx = complement(r2i,cidx);
+    ## locate conjugate root (must be in cidx list, just in case there's
+    ## roundoff)
+    err = abs(rvals(cidx) - r1');
+    minerr = min(err);
+    c2i = find(err == minerr);
+    r2i = cidx(c2i);
+    r2 = rvals(r2i);
+    cidx = complement(r2i,cidx);
 
-  # don't check for divide by zero, since 0 is not complex.
-  if(abs(r2 - r1')/abs(r1) > 1e-12)
-    error(sprintf("r1=(%f,%f); r2=(%f,%f), not conjugates.", ...
-      real(r1),imag(r1),real(r2),imag(r2)));
+    ## don't check for divide by zero, since 0 is not complex.
+    if(abs(r2 - r1')/abs(r1) > 1e-12)
+      error(sprintf("r1=(%f,%f); r2=(%f,%f), not conjugates.", ...
+	real(r1),imag(r1),real(r2),imag(r2)));
+    endif
+
+    ## complex conjugate pair
+    poly = [1, -2*real(r1), real(r1)^2+imag(r1)^2];
+  else
+    ## select two roots (they're all real)
+    r1 = rvals(1);
+    r2 = rvals(2);
+    poly = [1, -(r1+r2), (r1*r2)];
+    r1i = 1;  r2i = 2;
   endif
 
-  # complex conjugate pair
-  poly = [1, -2*real(r1), real(r1)^2+imag(r1)^2];
-else
-  # select two roots (they're all real)
-  r1 = rvals(1);
-  r2 = rvals(2);
-  poly = [1, -(r1+r2), (r1*r2)];
-  r1i = 1;  r2i = 2;
-endif
-
-# remove roots used
-idx = complement([r1i, r2i],1:length(rvals));
-rvals = rvals(idx);
+  ## remove roots used
+  idx = complement([r1i, r2i],1:length(rvals));
+  rvals = rvals(idx);
 
 endfunction
 
diff --git a/scripts/control/zp2sys.m b/scripts/control/zp2sys.m
--- a/scripts/control/zp2sys.m
+++ b/scripts/control/zp2sys.m
@@ -1,25 +1,25 @@
-# Copyright (C) 1996,1998 Auburn University.  All Rights Reserved
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1996,1998 Auburn University.  All Rights Reserved
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File } { @var{sys} =} zp2sys (@var{zer},@var{pol},@var{k}@{,@var{tsam},@var{inname},@var{outname}@})
 ##  Create system data structure from zero-pole data
 ## 
 ## @strong{Inputs}
 ## @table @var
 ## @item   zer
@@ -48,27 +48,28 @@
 ## zero-pole form:
 ## 1 (s - 1) (s + 1)
 ## -----------------
 ## s (s + 2) (s + 2)
 ## @end example
 ## @end deftypefn
  
 function  outsys = zp2sys (zer,pol,k,tsam,inname,outname)
-  #  Modified by John Ingram  July 20, 1996  
+
+  ## Modified by John Ingram  July 20, 1996  
 
   save_val = implicit_str_to_num_ok;	# save for restoring later
   implicit_str_to_num_ok = 1;
 
-  #  Test for the correct number of input arguments
+  ## Test for the correct number of input arguments
   if ((nargin < 3) || (nargin > 6))
     usage("outsys = zp2sys(zer,pol,k[,tsam,inname,outname])");
   endif
 
-  # check input format 
+  ## check input format 
   if( ! (is_vector(zer) | isempty(zer) ) )
     error("zer must be a vector or empty");
   endif
   if(!isempty(zer))
     zer = reshape(zer,1,length(zer));		# make it a row vector
   endif
 
   if( ! (is_vector(pol) | isempty(pol)))
@@ -77,38 +78,38 @@ function  outsys = zp2sys (zer,pol,k,tsa
   if(!isempty(pol))
     pol = reshape(pol,1,length(pol));
   endif
 
   if (! is_scalar(k))
      error('k must be a scalar');
   endif
 
-  #  Test proper numbers of poles and zeros.  The number of poles must be 
-  #  greater than or equal to the number of zeros.
+  ## Test proper numbers of poles and zeros.  The number of poles must be 
+  ## greater than or equal to the number of zeros.
   if (length(zer) >  length(pol))
     error(["number of poles (", num2str(length(pol)), ...
 	") < number of zeros (", num2str(length(zer)),")"]);
   endif
 
-  #  Set the system transfer function
+  ## Set the system transfer function
   outsys.zer = zer;
   outsys.pol = pol;
   outsys.k = k;
 
-  #  Set the system vector:  active = 1, updated = [0 1 0];
+  ## Set the system vector:  active = 1, updated = [0 1 0];
   outsys.sys = [1, 0, 1, 0];
 
-  #  Set defaults
+  ## Set defaults
   outsys.tsam = 0;
-   outsys.n = length(pol);
+  outsys.n = length(pol);
   outsys.nz = 0;
   outsys.yd = 0;	# assume (for now) continuous time outputs
 
-  #  Set the type of system
+  ## Set the type of system
   if (nargin > 3)
     if( !is_scalar(tsam) )
       error("tsam must be a nonnegative scalar");
     endif
     if (tsam < 0)
       error("sampling time must be positve")
     elseif (tsam > 0)
       [outsys.n,outsys.nz] = swap(outsys.n, outsys.nz);
@@ -117,29 +118,29 @@ function  outsys = zp2sys (zer,pol,k,tsa
 
     outsys.tsam = tsam;
   endif
 
   outsys.inname = sysdefioname(1,"u");
   outsys.outname = sysdefioname(1,"y");
   outsys.stname = sysdefstname(outsys.n,outsys.nz);
 
-  #  Set name of input
+  ## Set name of input
   if (nargin > 4)
-    # make sure its a string
+    ## make sure its a string
     if(!isempty(inname))
       if(!is_list(inname))  inname = list(inname); endif
       if(!is_signal_list(inname))
         error("inname must be a single signal name");
       endif
       outsys.inname = inname(1);
     endif
   endif
 
-  #  Set name of output
+  ## Set name of output
   if (nargin > 5)
     if(!isempty(outname))
       if(!is_list(outname))        outname = list(outname);    endif
       if(!is_signal_list(outname))
         error("outname must be a single signal name");
       endif
       outsys.outname = outname(1);
     endif
diff --git a/scripts/control/zp2tf.m b/scripts/control/zp2tf.m
--- a/scripts/control/zp2tf.m
+++ b/scripts/control/zp2tf.m
@@ -1,25 +1,25 @@
-# Copyright (C) 1996,1998 Auburn University.  All Rights Reserved
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1996,1998 Auburn University.  All Rights Reserved
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File } {[@var{num}, @var{den}] =} zp2tf (@var{zer}, @var{pol}, @var{k})
 ##  Converts zeros / poles to a transfer function.
 ## @strong{Inputs}
 ## @table
 ## @item zer, pol
 ## vectors of (possibly complex) poles and zeros of a transfer
@@ -27,37 +27,41 @@
 ## @item k
 ## real scalar (leading coefficient)
 ## @end table
 ## @code{[num,den] = zp2tf(zer,pol,k)} forms the transfer function 
 ## @code{num/den} from the vectors of poles and zeros.
 ## @end deftypefn
 
 function [num,den] = zp2tf(zer,pol,k)
-# Find out whether data was entered as a row or a column vector and
-# convert to a column vector if necessary
-# Written by A. S. Hodel with help from students Ingram, McGowan.
-# a.s.hodel@eng.auburn.edu
-#
+
+  ## Find out whether data was entered as a row or a column vector and
+  ## convert to a column vector if necessary
+  ## Written by A. S. Hodel with help from students Ingram, McGowan.
+  ## a.s.hodel@eng.auburn.edu
+
 
   [rp,cp] = size(pol);
   [rz,cz] = size(zer);
 
   if(!(is_vector(zer) | isempty(zer)) )
     error(sprintf("zer(%dx%d) must be a vector",rz,cz));
   elseif(!(is_vector(pol) | isempty(pol)) )
     error(sprintf("pol(%dx%d) must be a vector",rp,cp));
   elseif(length(zer) > length(pol))
     error(sprintf("zer(%dx%d) longer than pol(%dx%d)",rz,cz,rp,cp));
   endif
 
-  num = k;  den = 1;		# initialize converted polynomials
+  ## initialize converted polynomials
+
+  num = k;  den = 1;
 
-  # call zp2ssg2 if there are complex conjugate pairs left, otherwise
-  # construct real zeros one by one.  Repeat for poles.
+  ## call zp2ssg2 if there are complex conjugate pairs left, otherwise
+  ## construct real zeros one by one.  Repeat for poles.
+
   while(!isempty(zer))
     if( max(abs(imag(zer))) )     [poly,zer] = zp2ssg2(zer);
     else                          poly = [1 -zer(1)];  
                                   zer = zer(2:length(zer));      endif
     num = conv(num,poly);
   endwhile
 
   while(!isempty(pol))
diff --git a/scripts/control/zpout.m b/scripts/control/zpout.m
--- a/scripts/control/zpout.m
+++ b/scripts/control/zpout.m
@@ -1,37 +1,38 @@
-# Copyright (C) 1996 Auburn University.  All Rights Reserved
-#
-# This file is part of Octave. 
-#
-# Octave is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the 
-# Free Software Foundation; either version 2, or (at your option) any 
-# later version. 
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License 
-# along with Octave; see the file COPYING.  If not, write to the Free 
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+## Copyright (C) 1996 Auburn University.  All Rights Reserved
+##
+## This file is part of Octave. 
+##
+## Octave is free software; you can redistribute it and/or modify it 
+## under the terms of the GNU General Public License as published by the 
+## Free Software Foundation; either version 2, or (at your option) any 
+## later version. 
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT 
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License 
+## along with Octave; see the file COPYING.  If not, write to the Free 
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File } { } zpout (@var{zer}, @var{pol}, @var{k}@{, @var{x}@})
 ##  print formatted zero-pole form to the screen.  
 ## @var{x} defaults to the string @code{"s"}
 ## @end deftypefn
 
 ##  See also: polyval, polyvalm, poly, roots, conv, deconv, residue, 
 ##	filter, polyderiv, polyinteg, polyout 
 
 function zpout(zer,pol,k,x)
-# Written by A. Scottedward Hodel (scotte@eng.auburn.edu) June 1995)
+
+  ## Written by A. Scottedward Hodel (scotte@eng.auburn.edu) June 1995)
 
   save_val = implicit_str_to_num_ok;
   save_empty = empty_list_elements_ok;
   empty_list_elements_ok = 1;
 
   implicit_str_to_num_ok = 1;
 
   if (nargin < 3 ) | (nargin > 4) | (nargout != 0 )
@@ -50,17 +51,17 @@ function zpout(zer,pol,k,x)
     x = 's';
   elseif( ! isstr(x) )
     error("zpout: third argument must be a string");
   endif
  
   numstring = num2str(k);
 
   if(length(zer))
-    # find roots at z,s = 0
+    ## find roots at z,s = 0
     nzr = sum(zer == 0);
     if(nzr)
       if(nzr > 1)
         numstring = [numstring,sprintf(" %s^%d",x,nzr)];
       else
         numstring = [numstring,sprintf(" %s",x)];
       endif
     endif
@@ -68,17 +69,17 @@ function zpout(zer,pol,k,x)
     for ii=1:length(zer)
       if(zer(ii) != 0)
         numstring = [numstring,sprintf(" (%s %s)",x,com2str(zer(ii),1) ) ];
       endif
     endfor
   endif
 
   if(length(pol))
-    # find roots at z,s = 0
+    ## find roots at z,s = 0
     nzr = sum(pol == 0);
     if(nzr)
       if(nzr > 1)
         denomstring = [sprintf("%s^%d",x,nzr)];
       else
         denomstring = [sprintf("%s",x)];
       endif
     else
diff --git a/scripts/general/columns.m b/scripts/general/columns.m
--- a/scripts/general/columns.m
+++ b/scripts/general/columns.m
@@ -12,16 +12,17 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
+## -*- texinfo -*-
 ## @deftypefn {Function File} {} columns (@var{a})
 ## Return the number of columns of @var{a}.
 ## @end deftypefn
 
 ## See also: size, rows, length, is_scalar, is_vector, is_matrix
 
 ## Author: jwe
 
diff --git a/scripts/general/perror.m b/scripts/general/perror.m
--- a/scripts/general/perror.m
+++ b/scripts/general/perror.m
@@ -12,16 +12,17 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
+## -*- texinfo -*-
 ## @deftypefn {Function File} {} perror (@var{name}, @var{num})
 ## Print the error message for function @var{name} corresponding to the
 ## error number @var{num}.  This function is intended to be used to print
 ## useful error messages for those functions that return numeric error
 ## codes.
 ## @end deftypefn
 
 ## See also: strerror
diff --git a/scripts/general/rows.m b/scripts/general/rows.m
--- a/scripts/general/rows.m
+++ b/scripts/general/rows.m
@@ -12,16 +12,17 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
+## -*- texinfo -*-
 ## @deftypefn {Function File} {} rows (@var{a})
 ## Return the number of rows of @var{a}.
 ## @end deftypefn
 
 ## See also: size, columns, length, is_scalar, is_vector, is_matrix
 
 ## Author: jwe
 
diff --git a/scripts/general/strerror.m b/scripts/general/strerror.m
--- a/scripts/general/strerror.m
+++ b/scripts/general/strerror.m
@@ -12,16 +12,17 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
+## -*- texinfo -*-
 ## @deftypefn {Function File} {} strerror (@var{name}, @var{num})
 ## Return the text of an error message for function @var{name}
 ## corresponding to the error number @var{num}.  This function is intended
 ## to be used to print useful error messages for those functions that
 ## return numeric error codes.
 ## @end deftypefn
 
 ## Author: jwe
diff --git a/scripts/image/colormap.m b/scripts/image/colormap.m
--- a/scripts/image/colormap.m
+++ b/scripts/image/colormap.m
@@ -12,16 +12,17 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
+## -*- texinfo -*-
 ## @deftypefn {Function File} {} colormap (@var{map})
 ## @deftypefnx {Function File} {} colormap ("default")
 ## Set the current colormap.
 ## 
 ## @code{colormap (@var{map})} sets the current colormap to @var{map}.  The
 ## color map should be an @var{n} row by 3 column matrix.  The columns
 ## contain red, green, and blue intensities respectively.  All entries
 ## should be between 0 and 1 inclusive.  The new colormap is returned.
diff --git a/scripts/image/gray.m b/scripts/image/gray.m
--- a/scripts/image/gray.m
+++ b/scripts/image/gray.m
@@ -12,16 +12,17 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
+## -*- texinfo -*-
 ## @deftypefn {Function File} {} gray (@var{n})
 ## Return a gray colormap with @var{n} entries corresponding to values from
 ## 0 to @var{n}-1.  The argument @var{n} should be a scalar.  If it is
 ## omitted, 64 is assumed.
 ## @end deftypefn
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: July 1994
diff --git a/scripts/image/gray2ind.m b/scripts/image/gray2ind.m
--- a/scripts/image/gray2ind.m
+++ b/scripts/image/gray2ind.m
@@ -12,16 +12,17 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
+## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{img}, @var{map}] =} gray2ind (@var{})
 ## Convert a gray scale intensity image to an Octave indexed image.
 ## @end deftypefn
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: July 1994
 ## Adapted-By: jwe
 
diff --git a/scripts/image/image.m b/scripts/image/image.m
--- a/scripts/image/image.m
+++ b/scripts/image/image.m
@@ -12,16 +12,17 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
+## -*- texinfo -*-
 ## @deftypefn {Function File} {} image (@var{x}, @var{zoom})
 ## Display a matrix as a color image.  The elements of @var{x} are indices
 ## into the current colormap and should have values between 1 and the
 ## length of the colormap.  If @var{zoom} is omitted, a value of 4 is
 ## assumed. 
 ## @end deftypefn
 
 ## SEE ALSO: imshow, imagesc, colormap.
diff --git a/scripts/image/imagesc.m b/scripts/image/imagesc.m
--- a/scripts/image/imagesc.m
+++ b/scripts/image/imagesc.m
@@ -12,16 +12,17 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
+## -*- texinfo -*-
 ## @deftypefn {Function File} {} imagesc (@var{x}, @var{zoom})
 ## Display a scaled version of the matrix @var{x} as a color image.  The
 ## matrix is scaled so that its entries are indices into the current
 ## colormap.  The scaled matrix is returned.  If @var{zoom} is omitted, a
 ## value of 4 is assumed.
 ## @end deftypefn
 
 ## SEE ALSO: image, imshow
diff --git a/scripts/image/imshow.m b/scripts/image/imshow.m
--- a/scripts/image/imshow.m
+++ b/scripts/image/imshow.m
@@ -12,16 +12,17 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
+## -*- texinfo -*-
 ## @deftypefn {Function File} {} imshow (@var{x}, @var{map})
 ## @deftypefnx {Function File} {} imshow (@var{x}, @var{n})
 ## @deftypefnx {Function File} {} imshow (@var{i}, @var{n})
 ## @deftypefnx {Function File} {} imshow (@var{r}, @var{g}, @var{b})
 ## Display images.
 ## 
 ## @code{imshow (@var{x})} displays an indexed image using the current
 ## colormap.
diff --git a/scripts/image/ind2gray.m b/scripts/image/ind2gray.m
--- a/scripts/image/ind2gray.m
+++ b/scripts/image/ind2gray.m
@@ -12,16 +12,17 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
+## -*- texinfo -*-
 ## @deftypefn {Function File} {} ind2gray (@var{x}, @var{map})
 ## Convert an Octave indexed image to a gray scale intensity image.
 ## If @var{map} is omitted, the current colormap is used to determine the
 ## intensities.
 ## @end deftypefn
 
 ## SEE ALSO: gray2ind, rgb2ntsc, image, colormap
 
diff --git a/scripts/image/ind2rgb.m b/scripts/image/ind2rgb.m
--- a/scripts/image/ind2rgb.m
+++ b/scripts/image/ind2rgb.m
@@ -12,16 +12,17 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
+## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{r}, @var{g}, @var{b}] =} ind2rgb (@var{x}, @var{map})
 ## Convert an indexed image to red, green, and blue color components.
 ## If @var{map} is omitted, the current colormap is used for the conversion.
 ## @end deftypefn
 
 ## SEE ALSO: rgb2ind, image, imshow, ind2gray, gray2ind.
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
diff --git a/scripts/image/loadimage.m b/scripts/image/loadimage.m
--- a/scripts/image/loadimage.m
+++ b/scripts/image/loadimage.m
@@ -12,16 +12,17 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
+## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{x}, @var{map}] =} loadimage (@var{file})
 ## Load an image file and it's associated color map from the specified
 ## @var{file}.  The image must be stored in Octave's image format.
 ## @end deftypefn
 
 ## SEE ALSO: saveimage, load, save
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
diff --git a/scripts/image/ntsc2rgb.m b/scripts/image/ntsc2rgb.m
--- a/scripts/image/ntsc2rgb.m
+++ b/scripts/image/ntsc2rgb.m
@@ -12,16 +12,17 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
+## -*- texinfo -*-
 ## @deftypefn {Function File} {} ntsc2rgb (@var{yiq})
 ## Image format conversion.
 ## @end deftypefn
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: July 1994
 ## Adapted-By: jwe
 
diff --git a/scripts/image/ocean.m b/scripts/image/ocean.m
--- a/scripts/image/ocean.m
+++ b/scripts/image/ocean.m
@@ -12,16 +12,17 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
+## -*- texinfo -*-
 ## @deftypefn {Function File} {} ocean (@var{n})
 ## Create color colormap.  The argument @var{n} should be a scalar.  If it
 ## is omitted, 64 is assumed.
 ## @end deftypefn
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: July 1994
 ## Adapted-By: jwe
diff --git a/scripts/image/rgb2ind.m b/scripts/image/rgb2ind.m
--- a/scripts/image/rgb2ind.m
+++ b/scripts/image/rgb2ind.m
@@ -12,16 +12,17 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
+## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{x}, @var{map}] =} rgb2ind (@var{r}, @var{g}, @var{b})
 ## Convert and RGB image to an Octave indexed image.
 ## @end deftypefn
 
 ## SEE ALSO: ind2rgb, rgb2ntsc.
 ##
 ## Bugs: The color map may have duplicate entries.
 
diff --git a/scripts/image/rgb2ntsc.m b/scripts/image/rgb2ntsc.m
--- a/scripts/image/rgb2ntsc.m
+++ b/scripts/image/rgb2ntsc.m
@@ -12,16 +12,17 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
+## -*- texinfo -*-
 ## @deftypefn {Function File} {} rgb2ntsc (@var{rgb})
 ## Image format conversion.
 ## @end deftypefn
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: July 1994
 ## Adapted-By: jwe
 
diff --git a/scripts/io/printf.m b/scripts/io/printf.m
--- a/scripts/io/printf.m
+++ b/scripts/io/printf.m
@@ -12,17 +12,17 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
-## -*texinfo -*-
+## -*- texinfo -*-
 ## @deftypefn {Function File} {} printf (@var{template}, @dots{})
 ## The @code{printf} function prints the optional arguments under the
 ## control of the template string @var{template} to the stream
 ## @code{stdout}.
 ## @end deftypefn
 
 ## See also: fprintf sprintf
 
diff --git a/scripts/miscellaneous/menu.m b/scripts/miscellaneous/menu.m
--- a/scripts/miscellaneous/menu.m
+++ b/scripts/miscellaneous/menu.m
@@ -12,17 +12,17 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
-## -*texinfo -*-
+## -*- texinfo -*-
 ## @deftypefn {Function File} {} menu (@var{title}, @var{opt1}, @dots{})
 ## Print a title string followed by a series of options.  Each option will
 ## be printed along with a number.  The return value is the number of the
 ## option selected by the user.  This function is useful for interactive
 ## programs.  There is no limit to the number of options that may be passed
 ## in, but it may be confusing to present more than will fit easily on one
 ## screen.
 ## @end deftypefn
diff --git a/scripts/miscellaneous/tic.m b/scripts/miscellaneous/tic.m
--- a/scripts/miscellaneous/tic.m
+++ b/scripts/miscellaneous/tic.m
@@ -12,16 +12,17 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
+## -*- texinfo -*-
 ## @deftypefn {Function File} {} tic ()
 ## @deftypefnx {Function File} {} toc ()
 ## These functions set and check a wall-clock timer.  For example,
 ## 
 ## @example
 ## tic ();
 ## # many computations later...
 ## elapsed_time = toc ();
diff --git a/scripts/signal/detrend.m b/scripts/signal/detrend.m
--- a/scripts/signal/detrend.m
+++ b/scripts/signal/detrend.m
@@ -9,16 +9,17 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details. 
 ## 
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
+## -*- texinfo -*-
 ## @deftypefn {Function File} {} detrend (@var{x}, @var{p})
 ## If @var{x} is a vector, @code{detrend (@var{x}, @var{p})} removes the
 ## best fit of a polynomial of order @var{p} from the data @var{x}.
 ## 
 ## If @var{x} is a matrix, @code{detrend (@var{x}, @var{p})} does the same
 ## for each column in @var{x}.
 ## 
 ## The second argument is optional.  If it is not specified, a value of 1
diff --git a/scripts/specfun/beta.m b/scripts/specfun/beta.m
--- a/scripts/specfun/beta.m
+++ b/scripts/specfun/beta.m
@@ -12,16 +12,17 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
+## -*- texinfo -*-
 ## @deftypefn {Mapping Function} {} beta (@var{a}, @var{b})
 ## Return the Beta function,
 ## @iftex
 ## @tex
 ## $$
 ##  B (a, b) = {\Gamma (a) \Gamma (b) \over \Gamma (a + b)}.
 ## $$
 ## @end tex
diff --git a/scripts/statistics/base/gls.m b/scripts/statistics/base/gls.m
--- a/scripts/statistics/base/gls.m
+++ b/scripts/statistics/base/gls.m
@@ -12,16 +12,17 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
+## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{beta}, @var{v}, @var{r}] =} gls (@var{y}, @var{x}, @var{o})
 ## Generalized least squares estimation for the multivariate model
 ## @iftex
 ## @tex
 ## $y = x b + e$
 ## with $\bar{e} = 0$ and cov(vec($e$)) = $(s^2)o$,
 ## @end tex
 ## @end iftex
diff --git a/src/file-io.cc b/src/file-io.cc
--- a/src/file-io.cc
+++ b/src/file-io.cc
@@ -1426,17 +1426,17 @@ endwhile\n\
     }
   else
     print_usage ("popen");
 
   return retval;
 }
 
 DEFUN (pclose, args, ,
-  "-*- texifno -*-\n\
+  "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} pclose (@var{fid})\n\
 Close a file identifier that was opened by @code{popen}.  You may also\n\
 use @code{fclose} for the same purpose.\n\
 @end deftypefn")
 {
   double retval = -1.0;
 
   int nargin = args.length ();
diff --git a/src/mappers.cc b/src/mappers.cc
--- a/src/mappers.cc
+++ b/src/mappers.cc
@@ -222,17 +222,17 @@ atanh (X): compute the inverse hyperboli
   DEFUN_MAPPER (ceil, 0, 0, 0, ceil, 0, ceil, 0.0, 0.0, 0,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} ceil (@var{x})\n\
 Return the smallest integer not less than @var{x}.  If @var{x} is\n\
 complex, return @code{ceil (real (@var{x})) + ceil (imag (@var{x})) * I}.\n\
 @end deftypefn");
 
   DEFUN_MAPPER (conj, 0, 0, 0, conj, 0, conj, 0.0, 0.0, 0,
-    "-* texinfo -*-\n\
+    "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} conj (@var{z})\n\
 Return the complex conjugate of @var{z}, defined as\n\
 @iftex\n\
 @tex\n\
 $\\bar{z} = x - iy$.\n\
 @end tex\n\
 @end iftex\n\
 @ifinfo\n\
@@ -488,17 +488,17 @@ See also: log2, log10, logspace, exp");
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} log10 (@var{x})\n\
 Compute the base-10 logarithm for each element of @var{x}.\n\
 @end deftypefn\n\
 \n\
 See also: log, log2, logspace, exp");
 
   DEFUN_MAPPER (real, 0, 0, 0, real, real, 0, 0.0, 0.0, 0,
-    "-*-texinfo -*-\n\
+    "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} real (@var{z})\n\
 Return the real part of @var{z}.\n\
 @end deftypefn\n\
 \n\
 See also: imag, conj");
 
   DEFUN_MAPPER (round, 0, 0, 0, round, 0, round, 0.0, 0.0, 0,
     "-*- texinfo -*-\n\
