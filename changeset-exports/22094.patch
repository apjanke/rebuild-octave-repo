# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1468274753 14400
#      Mon Jul 11 18:05:53 2016 -0400
# Node ID 9203833cab7d22467783837ee0b8d0f6de2a7566
# Parent  6457ff946024798e719e8f3b92e75f791ea1367f
move new interpreter class to separate file

* libinterp/corefcn/interpreter.cc, libinterp/corefcn/interpreter.h:
New files.  Move interpreter class and some supporting functions here
from octave.h, octave.cc, toplev.h, and toplev.cc.  Move main_loop
into the interpreter class.  Handle exiting with a separate exception
object from interrupts, passing the exit status with the object.
Update other files as needed to remove toplev.h or include
interpreter.h instead of toplev.h.

* libinterp/corefcn/module.mk: Update.

* toplev.h: Deprecate.

diff --git a/libgui/graphics/__init_qt__.cc b/libgui/graphics/__init_qt__.cc
--- a/libgui/graphics/__init_qt__.cc
+++ b/libgui/graphics/__init_qt__.cc
@@ -27,17 +27,17 @@ along with Octave; see the file COPYING.
 #include <QApplication>
 #include <QDir>
 #include <QFileDialog>
 #include <QMetaType>
 #include <QPalette>
 #include <QRegExp>
 
 #include "graphics.h"
-#include "toplev.h"
+#include "interpreter.h"
 #include "defun.h"
 
 #include "Backend.h"
 #include "QtHandlesUtils.h"
 
 namespace QtHandles
 {
 
diff --git a/libinterp/corefcn/cellfun.cc b/libinterp/corefcn/cellfun.cc
--- a/libinterp/corefcn/cellfun.cc
+++ b/libinterp/corefcn/cellfun.cc
@@ -34,21 +34,21 @@ along with Octave; see the file COPYING.
 
 #include "caseless-str.h"
 #include "lo-mappers.h"
 #include "oct-locbuf.h"
 
 #include "Cell.h"
 #include "oct-map.h"
 #include "defun.h"
+#include "interpreter.h"
 #include "parse.h"
 #include "variables.h"
 #include "unwind-prot.h"
 #include "errwarn.h"
-#include "toplev.h"
 #include "utils.h"
 
 #include "ov-bool.h"
 #include "ov-class.h"
 #include "ov-colon.h"
 #include "ov-complex.h"
 #include "ov-float.h"
 #include "ov-flt-complex.h"
diff --git a/libinterp/corefcn/debug.cc b/libinterp/corefcn/debug.cc
--- a/libinterp/corefcn/debug.cc
+++ b/libinterp/corefcn/debug.cc
@@ -54,17 +54,17 @@ along with Octave; see the file COPYING.
 #include "ov-fcn.h"
 #include "ov-struct.h"
 #include "pt-pr-code.h"
 #include "pt-bp.h"
 #include "pt-eval.h"
 #include "pt-exp.h"
 #include "pt-stmt.h"
 #include "sighandlers.h"
-#include "toplev.h"
+#include "interpreter.h"
 #include "unwind-prot.h"
 #include "utils.h"
 #include "variables.h"
 
 #include "debug.h"
 
 // Initialize the singleton object
 bp_table *bp_table::instance = 0;
diff --git a/libinterp/corefcn/defaults.cc b/libinterp/corefcn/defaults.cc
--- a/libinterp/corefcn/defaults.cc
+++ b/libinterp/corefcn/defaults.cc
@@ -42,17 +42,17 @@ along with Octave; see the file COPYING.
 #include "file-ops.h"
 #include "errwarn.h"
 #include "help.h"
 #include "input.h"
 #include "load-path.h"
 #include "ovl.h"
 #include "ov.h"
 #include "parse.h"
-#include "toplev.h"
+#include "interpreter.h"
 #include "unwind-prot.h"
 #include "variables.h"
 #include <version.h>
 
 std::string Voctave_home;
 
 std::string Vbin_dir;
 std::string Vinfo_dir;
diff --git a/libinterp/corefcn/defun.cc b/libinterp/corefcn/defun.cc
--- a/libinterp/corefcn/defun.cc
+++ b/libinterp/corefcn/defun.cc
@@ -38,17 +38,17 @@ along with Octave; see the file COPYING.
 #include "ov-dld-fcn.h"
 #include "ov-fcn.h"
 #include "ov-mex-fcn.h"
 #include "ov-usr-fcn.h"
 #include "ovl.h"
 #include "oct-lvalue.h"
 #include "pager.h"
 #include "symtab.h"
-#include "toplev.h"
+#include "interpreter.h"
 #include "variables.h"
 #include "parse.h"
 
 // Print the usage part of the doc string of FCN (user-defined or DEFUN).
 void
 print_usage (void)
 {
   const octave_function *cur = octave_call_stack::current ();
diff --git a/libinterp/corefcn/dirfns.cc b/libinterp/corefcn/dirfns.cc
--- a/libinterp/corefcn/dirfns.cc
+++ b/libinterp/corefcn/dirfns.cc
@@ -49,17 +49,17 @@ along with Octave; see the file COPYING.
 #include "input.h"
 #include "load-path.h"
 #include "octave.h"
 #include "octave-link.h"
 #include "ovl.h"
 #include "pager.h"
 #include "procstream.h"
 #include "sysdep.h"
-#include "toplev.h"
+#include "interpreter.h"
 #include "unwind-prot.h"
 #include "utils.h"
 #include "variables.h"
 
 // TRUE means we ask for confirmation before recursively removing a
 // directory tree.
 static bool Vconfirm_recursive_rmdir = true;
 
diff --git a/libinterp/corefcn/error.cc b/libinterp/corefcn/error.cc
--- a/libinterp/corefcn/error.cc
+++ b/libinterp/corefcn/error.cc
@@ -42,17 +42,17 @@ along with Octave; see the file COPYING.
 #include "ovl.h"
 #include "oct-map.h"
 #include "utils.h"
 #include "ov.h"
 #include "ov-usr-fcn.h"
 #include "pt-eval.h"
 #include "pt-pr-code.h"
 #include "pt-stmt.h"
-#include "toplev.h"
+#include "interpreter.h"
 #include "unwind-prot.h"
 #include "variables.h"
 
 // TRUE means that Octave will try to beep obnoxiously before printing
 // error messages.
 static bool Vbeep_on_error = false;
 
 // TRUE means that Octave will try to enter the debugger when an error
diff --git a/libinterp/corefcn/graphics.cc b/libinterp/corefcn/graphics.cc
--- a/libinterp/corefcn/graphics.cc
+++ b/libinterp/corefcn/graphics.cc
@@ -43,24 +43,24 @@ along with Octave; see the file COPYING.
 #include "singleton-cleanup.h"
 
 #include "builtins.h"
 #include "defun.h"
 #include "display.h"
 #include "error.h"
 #include "graphics.h"
 #include "input.h"
+#include "interpreter.h"
 #include "ov.h"
 #include "ovl.h"
 #include "oct-map.h"
 #include "ov-fcn-handle.h"
 #include "pager.h"
 #include "parse.h"
 #include "text-renderer.h"
-#include "toplev.h"
 #include "unwind-prot.h"
 #include "utils.h"
 #include "octave-default-image.h"
 
 // forward declarations
 static octave_value xget (const graphics_handle& h, const caseless_str& name);
 
 OCTAVE_NORETURN static
diff --git a/libinterp/corefcn/help.cc b/libinterp/corefcn/help.cc
--- a/libinterp/corefcn/help.cc
+++ b/libinterp/corefcn/help.cc
@@ -55,17 +55,17 @@ along with Octave; see the file COPYING.
 #include "ov-fcn-handle.h"
 #include "pager.h"
 #include "parse.h"
 #include "pathsearch.h"
 #include "procstream.h"
 #include "pt-pr-code.h"
 #include "sighandlers.h"
 #include "symtab.h"
-#include "toplev.h"
+#include "interpreter.h"
 #include "unwind-prot.h"
 #include "utils.h"
 #include "variables.h"
 #include "version.h"
 #include "quit.h"
 
 // Name of the doc cache file specified on the command line.
 // (--doc-cache-file file)
diff --git a/libinterp/corefcn/input.cc b/libinterp/corefcn/input.cc
--- a/libinterp/corefcn/input.cc
+++ b/libinterp/corefcn/input.cc
@@ -44,36 +44,37 @@ along with Octave; see the file COPYING.
 #include "debug.h"
 #include "defun.h"
 #include "dirfns.h"
 #include "error.h"
 #include "errwarn.h"
 #include "help.h"
 #include "hook-fcn.h"
 #include "input.h"
+#include "interpreter.h"
 #include "lex.h"
 #include "load-path.h"
 #include "octave.h"
 #include "octave-link.h"
 #include "oct-map.h"
 #include "oct-hist.h"
-#include "toplev.h"
+#include "interpreter.h"
 #include "octave-link.h"
 #include "ovl.h"
 #include "ov-fcn-handle.h"
 #include "pager.h"
 #include "parse.h"
 #include "pt.h"
 #include "pt-const.h"
 #include "pt-eval.h"
 #include "pt-stmt.h"
 #include "sighandlers.h"
 #include "symtab.h"
 #include "sysdep.h"
-#include "toplev.h"
+#include "interpreter.h"
 #include "unwind-prot.h"
 #include "utils.h"
 #include "variables.h"
 
 // Primary prompt string.
 static std::string VPS1;
 
 // Secondary prompt string.
diff --git a/libinterp/corefcn/interpreter.cc b/libinterp/corefcn/interpreter.cc
new file mode 100644
--- /dev/null
+++ b/libinterp/corefcn/interpreter.cc
@@ -0,0 +1,1097 @@
+/*
+
+Copyright (C) 1993-2015 John W. Eaton
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 3 of the License, or (at your
+option) any later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, see
+<http://www.gnu.org/licenses/>.
+
+*/
+
+#if defined (HAVE_CONFIG_H)
+#  include "config.h"
+#endif
+
+#include <string>
+#include <iostream>
+
+#include "cmd-edit.h"
+#include "f77-fcn.h"
+#include "file-ops.h"
+#include "file-stat.h"
+#include "fpucw-wrappers.h"
+#include "lo-error.h"
+#include "oct-env.h"
+#include "str-vec.h"
+#include "signal-wrappers.h"
+#include "unistd-wrappers.h"
+
+#include "builtins.h"
+#include "defaults.h"
+#include "Cell.h"
+#include "defun.h"
+#include "display.h"
+#include "error.h"
+#include "file-io.h"
+#include "graphics.h"
+#include "interpreter.h"
+#include "load-path.h"
+#include "load-save.h"
+#include "octave-link.h"
+#include "octave.h"
+#include "oct-hist.h"
+#include "oct-map.h"
+#include "oct-mutex.h"
+#include "ops.h"
+#include "ovl.h"
+#include "ov.h"
+#include "ov-classdef.h"
+#include "parse.h"
+#include "pt-eval.h"
+#include "pt-jump.h"
+#include "pt-stmt.h"
+#include "sighandlers.h"
+#include "sysdep.h"
+#include "unwind-prot.h"
+#include "utils.h"
+#include "variables.h"
+#include <version.h>
+
+void (*octave_exit) (int) = ::exit;
+
+// TRUE means the quit() call is allowed.
+bool quit_allowed = true;
+
+// TRUE means we are ready to interpret commands, but not everything
+// is ready for interactive use.
+bool octave_interpreter_ready = false;
+
+// TRUE means we've processed all the init code and we are good to go.
+bool octave_initialized = false;
+
+// Kluge.
+extern "C" F77_RET_T
+F77_FUNC (xerbla, XERBLA) (F77_CONST_CHAR_ARG_DECL,
+                           const octave_idx_type&
+                           F77_CHAR_ARG_LEN_DECL);
+
+DEFUN (__version_info__, args, ,
+       doc: /* -*- texinfo -*-
+@deftypefn {} {retval =} __version_info__ (@var{name}, @var{version}, @var{release}, @var{date})
+Undocumented internal function.
+@end deftypefn */)
+{
+  static octave_map vinfo;
+
+  int nargin = args.length ();
+
+  if (nargin != 0 && nargin != 4)
+    print_usage ();
+
+  octave_value retval;
+
+  if (nargin == 0)
+    retval = vinfo;
+  else if (nargin == 4)
+    {
+      if (vinfo.nfields () == 0)
+        {
+          vinfo.assign ("Name", args(0));
+          vinfo.assign ("Version", args(1));
+          vinfo.assign ("Release", args(2));
+          vinfo.assign ("Date", args(3));
+        }
+      else
+        {
+          octave_idx_type n = vinfo.numel () + 1;
+
+          vinfo.resize (dim_vector (n, 1));
+
+          octave_value idx (n);
+
+          vinfo.assign (idx, "Name", Cell (octave_value (args(0))));
+          vinfo.assign (idx, "Version", Cell (octave_value (args(1))));
+          vinfo.assign (idx, "Release", Cell (octave_value (args(2))));
+          vinfo.assign (idx, "Date", Cell (octave_value (args(3))));
+        }
+    }
+
+  return retval;
+}
+
+static void
+initialize_version_info (void)
+{
+  octave_value_list args;
+
+  args(3) = OCTAVE_RELEASE_DATE;
+  args(2) = OCTAVE_RELEASE;
+  args(1) = OCTAVE_VERSION;
+  args(0) = "GNU Octave";
+
+  F__version_info__ (args, 0);
+}
+
+OCTAVE_NORETURN static void
+lo_error_handler (const char *fmt, ...)
+{
+  va_list args;
+  va_start (args, fmt);
+  verror_with_cfn (fmt, args);
+  va_end (args);
+
+  octave_throw_execution_exception ();
+}
+
+OCTAVE_NORETURN static void
+lo_error_with_id_handler (const char *id, const char *fmt, ...)
+{
+  va_list args;
+  va_start (args, fmt);
+  verror_with_id_cfn (id, fmt, args);
+  va_end (args);
+
+  octave_throw_execution_exception ();
+}
+
+static void
+initialize_error_handlers ()
+{
+  set_liboctave_error_handler (lo_error_handler);
+  set_liboctave_error_with_id_handler (lo_error_with_id_handler);
+  set_liboctave_warning_handler (warning);
+  set_liboctave_warning_with_id_handler (warning_with_id);
+}
+
+// What internal options get configured by --traditional.
+
+static void
+maximum_braindamage (void)
+{
+  FPS1 (octave_value (">> "));
+  FPS2 (octave_value (""));
+  FPS4 (octave_value (""));
+  Fbeep_on_error (octave_value (true));
+  Fconfirm_recursive_rmdir (octave_value (false));
+  Fcrash_dumps_octave_core (octave_value (false));
+  Fdisable_diagonal_matrix (octave_value (true));
+  Fdisable_permutation_matrix (octave_value (true));
+  Fdisable_range (octave_value (true));
+  Ffixed_point_format (octave_value (true));
+  Fhistory_timestamp_format_string (octave_value ("%%-- %D %I:%M %p --%%"));
+  Fpage_screen_output (octave_value (false));
+  Fprint_empty_dimensions (octave_value (false));
+  Fsave_default_options (octave_value ("-mat-binary"));
+  Fstruct_levels_to_print (octave_value (0));
+
+  disable_warning ("Octave:abbreviated-property-match");
+  disable_warning ("Octave:data-file-in-path");
+  disable_warning ("Octave:function-name-clash");
+  disable_warning ("Octave:possible-matlab-short-circuit-operator");
+}
+
+void
+recover_from_exception (void)
+{
+  octave::can_interrupt = true;
+  octave_interrupt_immediately = 0;
+  octave_interrupt_state = 0;
+  octave_signal_caught = 0;
+  octave_exception_state = octave_no_exception;
+  octave_restore_signal_mask ();
+  octave::catch_interrupts ();
+}
+
+// Fix up things before exiting.
+
+static std::list<std::string> octave_atexit_functions;
+
+DEFUN (quit, args, ,
+       doc: /* -*- texinfo -*-
+@deftypefn  {} {} exit
+@deftypefnx {} {} exit (@var{status})
+@deftypefnx {} {} quit
+@deftypefnx {} {} quit (@var{status})
+Exit the current Octave session.
+
+If the optional integer value @var{status} is supplied, pass that value to
+the operating system as Octave's exit status.  The default value is zero.
+
+When exiting, Octave will attempt to run the m-file @file{finish.m} if it
+exists.  User commands to save the workspace or clean up temporary files
+may be placed in that file.  Alternatively, another m-file may be scheduled
+to run using @code{atexit}.
+@seealso{atexit}
+@end deftypefn */)
+{
+  // Confirm OK to shutdown.  Note: A dynamic function installation similar
+  // to overriding polymorphism for which the GUI can install its own "quit"
+  // yet call this base "quit" could be nice.  No link would be needed here.
+  if (! octave_link::confirm_shutdown ())
+    return ovl ();
+
+  if (! quit_allowed)
+    error ("quit: not supported in embedded mode");
+
+  int exit_status = 0;
+
+  if (args.length () > 0)
+    exit_status = args(0).nint_value ();
+
+  // Instead of simply calling exit, we thrown an exception so that no
+  // matter where the call to quit occurs, we will run the
+  // unwind_protect stack, clear the OCTAVE_LOCAL_BUFFER allocations,
+  // etc. before exiting.
+
+  clean_up_and_exit (exit_status);
+
+  return ovl ();
+}
+
+DEFALIAS (exit, quit);
+
+void
+octave_add_atexit_function (const std::string& fname)
+{
+  octave_atexit_functions.push_front (fname);
+}
+
+bool
+octave_remove_atexit_function (const std::string& fname)
+{
+  bool found = false;
+
+  for (std::list<std::string>::iterator p = octave_atexit_functions.begin ();
+       p != octave_atexit_functions.end (); p++)
+    {
+      if (*p == fname)
+        {
+          octave_atexit_functions.erase (p);
+          found = true;
+          break;
+        }
+    }
+
+  return found;
+}
+
+DEFUN (atexit, args, nargout,
+       doc: /* -*- texinfo -*-
+@deftypefn  {} {} atexit (@var{fcn})
+@deftypefnx {} {} atexit (@var{fcn}, @var{flag})
+Register a function to be called when Octave exits.
+
+For example,
+
+@example
+@group
+function last_words ()
+  disp ("Bye bye");
+endfunction
+atexit ("last_words");
+@end group
+@end example
+
+@noindent
+will print the message @qcode{"Bye bye"} when Octave exits.
+
+The additional argument @var{flag} will register or unregister @var{fcn}
+from the list of functions to be called when Octave exits.  If @var{flag} is
+true, the function is registered, and if @var{flag} is false, it is
+unregistered.  For example, after registering the function @code{last_words}
+above,
+
+@example
+atexit ("last_words", false);
+@end example
+
+@noindent
+will remove the function from the list and Octave will not call
+@code{last_words} when it exits.
+
+Note that @code{atexit} only removes the first occurrence of a function
+from the list, so if a function was placed in the list multiple times with
+@code{atexit}, it must also be removed from the list multiple times.
+@seealso{quit}
+@end deftypefn */)
+{
+  int nargin = args.length ();
+
+  if (nargin < 1 || nargin > 2)
+    print_usage ();
+
+  std::string arg = args(0).xstring_value ("atexit: FCN argument must be a string");
+
+  bool add_mode = (nargin == 2)
+    ? args(1).xbool_value ("atexit: FLAG argument must be a logical value")
+    : true;
+
+  octave_value_list retval;
+
+  if (add_mode)
+    octave_add_atexit_function (arg);
+  else
+    {
+      bool found = octave_remove_atexit_function (arg);
+
+      if (nargout > 0)
+        retval = ovl (found);
+    }
+
+  return retval;
+}
+
+// Execute commands from a file and catch potential exceptions in a consistent
+// way.  This function should be called anywhere we might parse and execute
+// commands from a file before before we have entered the main loop in
+// toplev.cc.
+
+static void
+safe_source_file (const std::string& file_name,
+                  const std::string& context = "",
+                  bool verbose = false, bool require_file = true,
+                  const std::string& warn_for = "")
+{
+  try
+    {
+      source_file (file_name, context, verbose, require_file, warn_for);
+    }
+  catch (const index_exception& e)
+    {
+      recover_from_exception ();
+
+      std::cerr << "error: index exception in " << file_name << ": "
+                << e.message () << std::endl;
+    }
+  catch (const octave_exit_exception& ex)
+    {
+      recover_from_exception ();
+
+      clean_up_and_exit (ex.exit_status (), ex.safe_to_return ());
+    }
+  catch (const octave_interrupt_exception&)
+    {
+      recover_from_exception ();
+    }
+  catch (const octave_execution_exception&)
+    {
+      recover_from_exception ();
+
+      std::cerr << "error: execution exception in " << file_name << std::endl;
+    }
+}
+
+static void
+execute_pkg_add (const std::string& dir)
+{
+  std::string file_name = octave::sys::file_ops::concat (dir, "PKG_ADD");
+
+  try
+    {
+      load_path::execute_pkg_add (dir);
+    }
+  catch (const index_exception& e)
+    {
+      recover_from_exception ();
+
+      std::cerr << "error: index exception in " << file_name << ": "
+                << e.message () << std::endl;
+    }
+  catch (const octave_exit_exception& ex)
+    {
+      recover_from_exception ();
+
+      clean_up_and_exit (ex.exit_status (), ex.safe_to_return ());
+    }
+  catch (const octave_interrupt_exception&)
+    {
+      recover_from_exception ();
+    }
+  catch (const octave_execution_exception&)
+    {
+      recover_from_exception ();
+
+      std::cerr << "error: execution exception in " << file_name << std::endl;
+    }
+}
+
+static void
+initialize_load_path (bool set_initial_path)
+{
+  // Temporarily set the execute_pkg_add function to one that catches
+  // exceptions.  This is better than wrapping load_path::initialize in
+  // a try-catch block because it will not stop executing PKG_ADD files
+  // at the first exception.  It's also better than changing the default
+  // execute_pkg_add function to use safe_source file because that will
+  // normally be evaluated from the normal intepreter loop where
+  // exceptions are already handled.
+
+  octave::unwind_protect frame;
+
+  frame.add_fcn (load_path::set_add_hook, load_path::get_add_hook ());
+
+  load_path::set_add_hook (execute_pkg_add);
+
+  load_path::initialize (set_initial_path);
+}
+
+// Initialize by reading startup files.
+
+static void
+execute_startup_files (bool read_site_files, bool read_init_files,
+                       bool verbose_flag, bool inhibit_startup_message)
+{
+  octave::unwind_protect frame;
+
+  std::string context;
+
+  bool verbose = (verbose_flag && ! inhibit_startup_message);
+
+  bool require_file = false;
+
+  if (read_site_files)
+    {
+      // Execute commands from the site-wide configuration file.
+      // First from the file $(prefix)/lib/octave/site/m/octaverc
+      // (if it exists), then from the file
+      // $(prefix)/share/octave/$(version)/m/octaverc (if it exists).
+
+      safe_source_file (Vlocal_site_defaults_file, context, verbose,
+                        require_file);
+
+      safe_source_file (Vsite_defaults_file, context, verbose, require_file);
+    }
+
+  if (read_init_files)
+    {
+      // Try to execute commands from $HOME/$OCTAVE_INITFILE and
+      // $OCTAVE_INITFILE.  If $OCTAVE_INITFILE is not set,
+      // .octaverc is assumed.
+
+      bool home_rc_already_executed = false;
+
+      std::string initfile = octave::sys::env::getenv ("OCTAVE_INITFILE");
+
+      if (initfile.empty ())
+        initfile = ".octaverc";
+
+      std::string home_dir = octave::sys::env::get_home_directory ();
+
+      std::string home_rc = octave::sys::env::make_absolute (initfile, home_dir);
+
+      std::string local_rc;
+
+      if (! home_rc.empty ())
+        {
+          safe_source_file (home_rc, context, verbose, require_file);
+
+          // Names alone are not enough.
+
+          octave::sys::file_stat fs_home_rc (home_rc);
+
+          if (fs_home_rc)
+            {
+              // We want to check for curr_dir after executing home_rc
+              // because doing that may change the working directory.
+
+              local_rc = octave::sys::env::make_absolute (initfile);
+
+              home_rc_already_executed = same_file (home_rc, local_rc);
+            }
+        }
+
+      if (! home_rc_already_executed)
+        {
+          if (local_rc.empty ())
+            local_rc = octave::sys::env::make_absolute (initfile);
+
+          safe_source_file (local_rc, context, verbose, require_file);
+        }
+    }
+}
+
+namespace octave
+{
+  interpreter::interpreter (application *app_context, bool embedded)
+    : m_app_context (app_context), m_embedded (embedded),
+      m_interactive (false), m_quitting_gracefully (false)
+  {
+    cmdline_options options = m_app_context->options ();
+
+    sysdep_init ();
+
+    install_defaults ();
+
+    // Matlab uses "C" locale for LC_NUMERIC class regardless of local setting
+    setlocale (LC_NUMERIC, "C");
+    setlocale (LC_TIME, "C");
+    octave::sys::env::putenv ("LC_NUMERIC", "C");
+    octave::sys::env::putenv ("LC_TIME", "C");
+
+    // Initialize the default floating point unit control state.
+    octave_set_default_fpucw ();
+
+    string_vector all_args = options.all_args ();
+
+    octave_thread::init ();
+
+    set_default_prompts ();
+
+    // Initialize default warning state before --traditional option
+    // that may reset them.
+
+    initialize_default_warning_state ();
+
+    if (options.traditional ())
+      maximum_braindamage ();
+
+    octave_ieee_init ();
+
+    // The idea here is to force xerbla to be referenced so that we will link to
+    // our own version instead of the one provided by the BLAS library.  But
+    // octave::numeric_limits<double>::NaN () should never be -1, so we
+    // should never actually call xerbla.  FIXME (again!):  If this
+    // becomes a constant expression the test might be optimized away and
+    // then the reference to the function might also disappear.
+
+    if (octave::numeric_limits<double>::NaN () == -1)
+      F77_FUNC (xerbla, XERBLA) ("octave", 13 F77_CHAR_ARG_LEN (6));
+
+    initialize_error_handlers ();
+
+    if (! m_embedded)
+      octave::install_signal_handlers ();
+    else
+      quit_allowed = false;
+
+    initialize_file_io ();
+
+    install_types ();
+
+    install_ops ();
+
+    install_builtins ();
+
+    install_classdef ();
+
+    std::list<std::string> command_line_path = options.command_line_path ();
+
+    for (std::list<std::string>::const_iterator it = command_line_path.begin ();
+         it != command_line_path.end (); it++)
+      load_path::set_command_line_path (*it);
+
+    std::string exec_path = options.exec_path ();
+    if (! exec_path.empty ())
+      set_exec_path (exec_path);
+
+    std::string image_path = options.image_path ();
+    if (! image_path.empty ())
+      set_image_path (image_path);
+
+    if (options.no_window_system ())
+      display_info::no_window_system ();
+
+    // Is input coming from a terminal?  If so, we are probably interactive.
+
+    // If stdin is not a tty, then we are reading commands from a pipe or
+    // a redirected file.
+    bool stdin_is_tty = octave_isatty_wrapper (fileno (stdin));
+
+    m_interactive = (! m_embedded
+                     && ! m_app_context->is_octave_program ()
+                     && stdin_is_tty
+                     && octave_isatty_wrapper (fileno (stdout)));
+
+    // Check if the user forced an interactive session.  If he
+    // unnecessarily did so, reset forced_interactive to false.
+    if (options.forced_interactive ())
+      {
+        if (m_interactive)
+          options.forced_interactive (false);
+        else
+          m_interactive = true;
+      }
+
+    if ((! m_interactive || options.forced_interactive ())
+        && ! options.forced_line_editing ())
+      options.line_editing (false);
+
+    // Also skip start-up message unless session is interactive.
+    if (! m_interactive)
+      options.inhibit_startup_message (true);
+
+    // Force default line editor if we don't want readline editing.
+    if (! options.line_editing ())
+      octave::command_editor::force_default_editor ();
+
+    // These can come after command line args since none of them set any
+    // defaults that might be changed by command line options.
+
+    if (options.line_editing ())
+      initialize_command_input ();
+
+    octave_interpreter_ready = true;
+
+    initialize_version_info ();
+
+    // Make all command-line arguments available to startup files,
+    // including PKG_ADD files.
+
+    app_context->intern_argv (options.all_args ());
+
+    initialize_load_path (options.set_initial_path ());
+
+    initialize_history (options.read_history_file ());
+  }
+
+  int interpreter::execute (void)
+  {
+    cmdline_options options = m_app_context->options ();
+
+    if (! options.inhibit_startup_message ())
+      std::cout << octave_startup_message () << "\n" << std::endl;
+
+    octave_prepare_hdf5 ();
+
+    execute_startup_files (options.read_site_files (),
+                           options.read_init_files (),
+                           options.verbose_flag (),
+                           options.inhibit_startup_message ());
+
+    if (! options.inhibit_startup_message ()
+        && reading_startup_message_printed)
+      std::cout << std::endl;
+
+    // Execute any code specified with --eval 'CODE'
+    std::string code_to_eval = options.code_to_eval ();
+
+    if (! code_to_eval.empty ())
+      {
+        int parse_status = 0;
+
+        try
+          {
+            parse_status = execute_eval_option_code (code_to_eval);
+          }
+        catch (const octave_execution_exception&)
+          {
+            recover_from_exception ();
+
+            parse_status = 1;
+          }
+
+        if (! options.persist ())
+          {
+            m_quitting_gracefully = true;
+
+            clean_up_and_exit (parse_status);
+          }
+      }
+
+    // If there is an extra argument, see if it names a file to read.
+    // Additional arguments are taken as command line options for the script.
+
+    if (m_app_context->have_script_file ())
+      {
+        // If we are running an executable script (#! /bin/octave) then
+        // we should only see the args passed to the script.
+
+        int exit_status = 0;
+
+        try
+          {
+            string_vector script_args = options.remaining_args ();
+
+            m_app_context->intern_argv (script_args);
+
+            execute_command_line_file (script_args[0]);
+          }
+        catch (const octave_execution_exception&)
+          {
+            recover_from_exception ();
+
+            exit_status = 1;
+          }
+
+        // Restore full set of args.
+        m_app_context->intern_argv (options.all_args ());
+
+        if (! options.persist ())
+          {
+            m_quitting_gracefully = true;
+
+            clean_up_and_exit (exit_status);
+          }
+      }
+
+    // Avoid counting commands executed from startup or script files.
+
+    octave::command_editor::reset_current_command_number (1);
+
+    // Force input to be echoed if not really interactive,
+    // but the user has forced interactive behavior.
+
+    if (options.forced_interactive ())
+      {
+        octave::command_editor::blink_matching_paren (false);
+
+        // FIXME: is this the right thing to do?
+        Fecho_executing_commands (octave_value (ECHO_CMD_LINE));
+      }
+
+    if (m_embedded)
+      {
+        // FIXME: Do we need to do any cleanup here before returning?
+        // If we don't, what will happen to Octave functions that have been
+        // registered to execute with atexit, for example?
+
+        return 1;
+      }
+
+    int retval = main_loop ();
+
+    m_quitting_gracefully = true;
+
+    clean_up_and_exit (retval, true);
+
+    return retval;
+  }
+
+  int interpreter::execute_eval_option_code (const std::string& code)
+  {
+    octave::unwind_protect frame;
+
+    octave_save_signal_mask ();
+
+    octave::can_interrupt = true;
+
+    octave_signal_hook = octave::signal_handler;
+    octave_interrupt_hook = 0;
+    octave_bad_alloc_hook = 0;
+
+    octave::catch_interrupts ();
+
+    octave_initialized = true;
+
+    frame.add_method (this, &interpreter::interactive, m_interactive);
+
+    m_interactive = false;
+
+    int parse_status = 0;
+
+    try
+      {
+        eval_string (code, false, parse_status, 0);
+      }
+    catch (const octave_exit_exception& ex)
+      {
+        recover_from_exception ();
+
+        clean_up_and_exit (ex.exit_status (), ex.safe_to_return ());
+      }
+    catch (const octave_interrupt_exception&)
+      {
+        recover_from_exception ();
+      }
+    catch (const octave_execution_exception&)
+      {
+        recover_from_exception ();
+
+        std::cerr << "error: unhandled execution exception -- eval failed"
+                  << std::endl;
+      }
+
+    return parse_status;
+  }
+
+  void interpreter::execute_command_line_file (const std::string& fname)
+  {
+    octave::unwind_protect frame;
+
+    octave_save_signal_mask ();
+
+    octave::can_interrupt = true;
+
+    octave_signal_hook = octave::signal_handler;
+    octave_interrupt_hook = 0;
+    octave_bad_alloc_hook = 0;
+
+    octave::catch_interrupts ();
+
+    octave_initialized = true;
+
+    frame.add_method (this, &interpreter::interactive, m_interactive);
+
+    frame.add_method (m_app_context,
+                      &application::program_invocation_name,
+                      application::program_invocation_name ());
+
+    frame.add_method (m_app_context,
+                      &application::program_name,
+                      application::program_name ());
+
+    m_interactive = false;
+
+    m_app_context->set_program_names (fname);
+
+    std::string context;
+    bool verbose = false;
+    bool require_file = true;
+
+    safe_source_file (fname, context, verbose, require_file, "octave");
+  }
+
+  int interpreter::main_loop (void)
+  {
+    octave_save_signal_mask ();
+
+    octave::can_interrupt = true;
+
+    octave_signal_hook = octave::signal_handler;
+    octave_interrupt_hook = 0;
+    octave_bad_alloc_hook = 0;
+
+    octave::catch_interrupts ();
+
+    octave_initialized = true;
+
+    // The big loop.
+
+    octave_lexer *lxr = (octave::application::interactive ()
+                         ? new octave_lexer ()
+                         : new octave_lexer (stdin));
+
+    octave_parser parser (*lxr);
+
+    int retval = 0;
+    do
+      {
+        try
+          {
+            reset_error_handler ();
+
+            parser.reset ();
+
+            if (symbol_table::at_top_level ())
+              tree_evaluator::reset_debug_state ();
+
+            retval = parser.run ();
+
+            if (retval == 0)
+              {
+                if (parser.stmt_list)
+                  {
+                    parser.stmt_list->accept (*current_evaluator);
+
+                    octave_quit ();
+
+                    if (! octave::application::interactive ())
+                      {
+                        bool quit = (tree_return_command::returning
+                                     || tree_break_command::breaking);
+
+                        if (tree_return_command::returning)
+                          tree_return_command::returning = 0;
+
+                        if (tree_break_command::breaking)
+                          tree_break_command::breaking--;
+
+                        if (quit)
+                          break;
+                      }
+
+                    if (octave_completion_matches_called)
+                      octave_completion_matches_called = false;
+                    else
+                      octave::command_editor::increment_current_command_number ();
+                  }
+                else if (parser.lexer.end_of_input)
+                  break;
+              }
+          }
+        catch (const octave_exit_exception& ex)
+          {
+            recover_from_exception ();
+
+            clean_up_and_exit (ex.exit_status (), ex.safe_to_return ());
+          }
+        catch (const octave_interrupt_exception&)
+          {
+            recover_from_exception ();
+
+            // Required newline when the user does Ctrl+C at the prompt.
+            if (octave::application::interactive ())
+              octave_stdout << "\n";
+          }
+        catch (const index_exception& e)
+          {
+            recover_from_exception ();
+
+            std::cerr << "error: unhandled index exception: "
+                      << e.message () << " -- trying to return to prompt"
+                      << std::endl;
+          }
+        catch (const octave_execution_exception& e)
+          {
+            std::string stack_trace = e.info ();
+
+            if (! stack_trace.empty ())
+              std::cerr << stack_trace;
+
+            if (octave::application::interactive ())
+              recover_from_exception ();
+            else
+              {
+                // We should exit with a nonzero status.
+                retval = 1;
+                break;
+              }
+          }
+        catch (const std::bad_alloc&)
+          {
+            recover_from_exception ();
+
+            std::cerr << "error: out of memory -- trying to return to prompt"
+                      << std::endl;
+          }
+
+#if defined (DBSTOP_NANINF)
+        if (Vdebug_on_naninf)
+          {
+            if (setjump (naninf_jump) != 0)
+              debug_or_throw_exception (true);  // true = stack trace
+          }
+#endif
+      }
+    while (retval == 0);
+
+    if (octave::application::interactive ())
+      octave_stdout << "\n";
+
+    if (retval == EOF)
+      retval = 0;
+
+    return retval;
+  }
+
+  void interpreter::clean_up_and_exit (int status, bool safe_to_return)
+  {
+    static bool deja_vu = false;
+
+    OCTAVE_SAFE_CALL (remove_input_event_hook_functions, ());
+
+    while (! octave_atexit_functions.empty ())
+      {
+        std::string fcn = octave_atexit_functions.front ();
+
+        octave_atexit_functions.pop_front ();
+
+        OCTAVE_SAFE_CALL (reset_error_handler, ());
+
+        OCTAVE_SAFE_CALL (feval, (fcn, octave_value_list (), 0));
+
+        OCTAVE_SAFE_CALL (flush_octave_stdout, ());
+      }
+
+    if (! deja_vu)
+      {
+        deja_vu = true;
+
+        // Process pending events and disasble octave_link event
+        // processing with this call.
+
+        octave_link::process_events (true);
+
+        // Do this explicitly so that destructors for mex file objects
+        // are called, so that functions registered with mexAtExit are
+        // called.
+        OCTAVE_SAFE_CALL (clear_mex_functions, ());
+
+        OCTAVE_SAFE_CALL (octave::command_editor::restore_terminal_state, ());
+
+        // FIXME: is this needed?  Can it cause any trouble?
+        OCTAVE_SAFE_CALL (raw_mode, (0));
+
+        OCTAVE_SAFE_CALL (octave_history_write_timestamp, ());
+
+        if (! octave::command_history::ignoring_entries ())
+          OCTAVE_SAFE_CALL (octave::command_history::clean_up_and_save, ());
+
+        OCTAVE_SAFE_CALL (gh_manager::close_all_figures, ());
+
+        OCTAVE_SAFE_CALL (gtk_manager::unload_all_toolkits, ());
+
+        OCTAVE_SAFE_CALL (close_files, ());
+
+        OCTAVE_SAFE_CALL (cleanup_tmp_files, ());
+
+        OCTAVE_SAFE_CALL (symbol_table::cleanup, ());
+
+        OCTAVE_SAFE_CALL (sysdep_cleanup, ());
+
+        OCTAVE_SAFE_CALL (octave_finalize_hdf5, ());
+
+        OCTAVE_SAFE_CALL (flush_octave_stdout, ());
+
+        if (! m_quitting_gracefully && octave::application::interactive ())
+          {
+            octave_stdout << "\n";
+
+            // Yes, we want this to be separate from the call to
+            // flush_octave_stdout above.
+
+            OCTAVE_SAFE_CALL (flush_octave_stdout, ());
+          }
+
+        // Don't call singleton_cleanup_list::cleanup until we have the
+        // problems with registering/unregistering types worked out.  For
+        // example, uncomment the following line, then use the make_int
+        // function from the examples directory to create an integer
+        // object and then exit Octave.  Octave should crash with a
+        // segfault when cleaning up the typinfo singleton.  We need some
+        // way to force new octave_value_X types that are created in
+        // .oct files to be unregistered when the .oct file shared library
+        // is unloaded.
+        //
+        // OCTAVE_SAFE_CALL (singleton_cleanup_list::cleanup, ());
+
+        OCTAVE_SAFE_CALL (octave_chunk_buffer::clear, ());
+      }
+
+    if (octave_link::exit (status))
+      {
+        if (safe_to_return)
+          return;
+        else
+          {
+            // What should we do here?  We might be called from some
+            // location other than the end of octave_execute_interpreter,
+            // so it might not be safe to return.
+
+            // We have nothing else to do at this point, and the
+            // octave_link::exit function is supposed to take care of
+            // exiting for us.  Assume that job won't take more than a
+            // day...
+
+            octave_sleep (86400); // FIXME: really needed?
+          }
+      }
+    else
+      {
+        if (octave_exit)
+          (*octave_exit) (status);
+      }
+  }
+}
diff --git a/libinterp/corefcn/interpreter.h b/libinterp/corefcn/interpreter.h
new file mode 100644
--- /dev/null
+++ b/libinterp/corefcn/interpreter.h
@@ -0,0 +1,135 @@
+/*
+
+Copyright (C) 2002-2015 John W. Eaton
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 3 of the License, or (at your
+option) any later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, see
+<http://www.gnu.org/licenses/>.
+
+*/
+
+#if ! defined (octave_interpreter_h)
+#define octave_interpreter_h 1
+
+#include "octave-config.h"
+
+#include <string>
+
+#include "quit.h"
+#include "str-vec.h"
+
+typedef void (*octave_exit_func) (int);
+extern OCTINTERP_API octave_exit_func octave_exit;
+
+extern OCTINTERP_API bool quit_allowed;
+
+extern OCTINTERP_API bool quitting_gracefully;
+
+extern OCTINTERP_API void recover_from_exception (void);
+
+extern OCTINTERP_API void
+octave_add_atexit_function (const std::string& fname);
+
+extern OCTINTERP_API bool
+octave_remove_atexit_function (const std::string& fname);
+
+// TRUE means we are ready to interpret commands, but not everything
+// is ready for interactive use.
+extern OCTINTERP_API bool octave_interpreter_ready;
+
+// TRUE means we've processed all the init code and we are good to go.
+extern OCTINTERP_API bool octave_initialized;
+
+// Call a function with exceptions handled to avoid problems with
+// errors while shutting down.
+
+#define OCTAVE_IGNORE_EXCEPTION(E) \
+  catch (E) \
+    { \
+      std::cerr << "error: ignoring " #E " while preparing to exit" << std::endl; \
+      recover_from_exception (); \
+    }
+
+#define OCTAVE_SAFE_CALL(F, ARGS) \
+  do \
+    { \
+      try \
+        { \
+          octave::unwind_protect frame; \
+ \
+          frame.protect_var (Vdebug_on_error); \
+          frame.protect_var (Vdebug_on_warning); \
+ \
+          Vdebug_on_error = false; \
+          Vdebug_on_warning = false; \
+ \
+          F ARGS; \
+        } \
+      OCTAVE_IGNORE_EXCEPTION (const octave_interrupt_exception&) \
+      OCTAVE_IGNORE_EXCEPTION (const octave_execution_exception&) \
+      OCTAVE_IGNORE_EXCEPTION (const std::bad_alloc&) \
+    } \
+  while (0)
+
+namespace octave
+{
+  // The application object contains a pointer to the current
+  // interpreter and the interpreter contains a pointer back to the
+  // application context so we need a forward declaration for one (or
+  // both) of them...
+
+  class application;
+
+  class OCTINTERP_API interpreter
+  {
+  public:
+
+    interpreter (application *app_context = 0, bool embedded = false);
+
+    ~interpreter (void) { }
+
+    int execute (void);
+
+    int execute_eval_option_code (const std::string& code);
+
+    void execute_command_line_file (const std::string& fname);
+
+    bool interactive (void) const { return m_interactive; }
+    void interactive (bool arg) { m_interactive = arg; }
+
+  private:
+
+    // No copying, at least not yet...
+
+    interpreter (const interpreter&);
+
+    interpreter& operator = (const interpreter&);
+
+    int main_loop (void);
+
+    void clean_up_and_exit (int status, bool safe_to_return = false);
+    
+    application *m_app_context;
+
+    bool m_embedded;
+
+    // TRUE means this is an interactive interpreter (forced or not).
+    bool m_interactive;
+
+    bool m_quitting_gracefully;
+  };
+}
+
+#endif
diff --git a/libinterp/corefcn/load-path.cc b/libinterp/corefcn/load-path.cc
--- a/libinterp/corefcn/load-path.cc
+++ b/libinterp/corefcn/load-path.cc
@@ -32,21 +32,21 @@ along with Octave; see the file COPYING.
 #include "file-stat.h"
 #include "oct-env.h"
 #include "pathsearch.h"
 #include "singleton-cleanup.h"
 
 #include "defaults.h"
 #include "defun.h"
 #include "input.h"
+#include "interpreter.h"
 #include "load-path.h"
 #include "ov-usr-fcn.h"
 #include "pager.h"
 #include "parse.h"
-#include "toplev.h"
 #include "unwind-prot.h"
 #include "utils.h"
 
 load_path *load_path::instance = 0;
 load_path::hook_fcn_ptr load_path::add_hook = load_path::execute_pkg_add;
 load_path::hook_fcn_ptr load_path::remove_hook = load_path::execute_pkg_del;
 std::string load_path::command_line_path;
 std::string load_path::sys_path;
diff --git a/libinterp/corefcn/ls-mat-ascii.cc b/libinterp/corefcn/ls-mat-ascii.cc
--- a/libinterp/corefcn/ls-mat-ascii.cc
+++ b/libinterp/corefcn/ls-mat-ascii.cc
@@ -44,27 +44,27 @@ along with Octave; see the file COPYING.
 #include "oct-time.h"
 #include "quit.h"
 #include "str-vec.h"
 
 #include "Cell.h"
 #include "defun.h"
 #include "error.h"
 #include "errwarn.h"
+#include "interpreter.h"
 #include "lex.h"
 #include "load-save.h"
 #include "ls-ascii-helper.h"
 #include "ls-mat-ascii.h"
 #include "ovl.h"
 #include "oct-map.h"
 #include "ov-cell.h"
 #include "pager.h"
 #include "pt-exp.h"
 #include "sysdep.h"
-#include "toplev.h"
 #include "unwind-prot.h"
 #include "utils.h"
 #include "variables.h"
 #include "version.h"
 #include "dMatrix.h"
 
 static std::string
 get_mat_data_input_line (std::istream& is)
diff --git a/libinterp/corefcn/ls-mat5.cc b/libinterp/corefcn/ls-mat5.cc
--- a/libinterp/corefcn/ls-mat5.cc
+++ b/libinterp/corefcn/ls-mat5.cc
@@ -60,17 +60,17 @@ along with Octave; see the file COPYING.
 #include "ovl.h"
 #include "oct-map.h"
 #include "ov-cell.h"
 #include "ov-class.h"
 #include "ov-fcn-inline.h"
 #include "pager.h"
 #include "pt-exp.h"
 #include "sysdep.h"
-#include "toplev.h"
+#include "interpreter.h"
 #include "unwind-prot.h"
 #include "utils.h"
 #include "variables.h"
 #include "version.h"
 #include "dMatrix.h"
 
 #include "ls-utils.h"
 #include "ls-mat5.h"
diff --git a/libinterp/corefcn/mex.cc b/libinterp/corefcn/mex.cc
--- a/libinterp/corefcn/mex.cc
+++ b/libinterp/corefcn/mex.cc
@@ -35,27 +35,27 @@ along with Octave; see the file COPYING.
 
 #include "f77-fcn.h"
 #include "lo-ieee.h"
 #include "oct-locbuf.h"
 
 #include "Cell.h"
 #include "call-stack.h"
 #include "error.h"
+#include "interpreter.h"
 // mxArray must be declared as a class before including mexproto.h.
 #include "mxarray.h"
 #include "mexproto.h"
 #include "oct-map.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-mex-fcn.h"
 #include "ov-usr-fcn.h"
 #include "pager.h"
 #include "parse.h"
-#include "toplev.h"
 #include "unwind-prot.h"
 #include "utils.h"
 #include "variables.h"
 #include "graphics.h"
 
 // #define DEBUG 1
 
 static void
diff --git a/libinterp/corefcn/module.mk b/libinterp/corefcn/module.mk
--- a/libinterp/corefcn/module.mk
+++ b/libinterp/corefcn/module.mk
@@ -43,16 +43,17 @@ COREFCN_INC = \
   libinterp/corefcn/file-io.h \
   libinterp/corefcn/ft-text-renderer.h \
   libinterp/corefcn/gl-render.h \
   libinterp/corefcn/gl2ps-print.h \
   libinterp/corefcn/gripes.h \
   libinterp/corefcn/help.h \
   libinterp/corefcn/hook-fcn.h \
   libinterp/corefcn/input.h \
+  libinterp/corefcn/interpreter.h \
   libinterp/corefcn/load-path.h \
   libinterp/corefcn/load-save.h \
   libinterp/corefcn/ls-ascii-helper.h \
   libinterp/corefcn/ls-hdf5.h \
   libinterp/corefcn/ls-mat-ascii.h \
   libinterp/corefcn/ls-mat4.h \
   libinterp/corefcn/ls-mat5.h \
   libinterp/corefcn/ls-oct-text.h \
@@ -174,16 +175,17 @@ COREFCN_SRC = \
   libinterp/corefcn/gripes.cc \
   libinterp/corefcn/hash.cc \
   libinterp/corefcn/help.cc \
   libinterp/corefcn/hess.cc \
   libinterp/corefcn/hex2num.cc \
   libinterp/corefcn/hook-fcn.cc \
   libinterp/corefcn/input.cc \
   libinterp/corefcn/inv.cc \
+  libinterp/corefcn/interpreter.cc \
   libinterp/corefcn/kron.cc \
   libinterp/corefcn/load-path.cc \
   libinterp/corefcn/load-save.cc \
   libinterp/corefcn/lookup.cc \
   libinterp/corefcn/ls-ascii-helper.cc \
   libinterp/corefcn/ls-hdf5.cc \
   libinterp/corefcn/ls-mat-ascii.cc \
   libinterp/corefcn/ls-mat4.cc \
diff --git a/libinterp/corefcn/oct-hist.cc b/libinterp/corefcn/oct-hist.cc
--- a/libinterp/corefcn/oct-hist.cc
+++ b/libinterp/corefcn/oct-hist.cc
@@ -56,17 +56,17 @@ Software Foundation, Inc.
 #include "errwarn.h"
 #include "input.h"
 #include "oct-hist.h"
 #include "ovl.h"
 #include "pager.h"
 #include "parse.h"
 #include "sighandlers.h"
 #include "sysdep.h"
-#include "toplev.h"
+#include "interpreter.h"
 #include "unwind-prot.h"
 #include "utils.h"
 #include "variables.h"
 
 // TRUE means input is coming from temporary history file.
 bool input_from_tmp_history_file = false;
 
 static std::string
diff --git a/libinterp/corefcn/oct-stream.cc b/libinterp/corefcn/oct-stream.cc
--- a/libinterp/corefcn/oct-stream.cc
+++ b/libinterp/corefcn/oct-stream.cc
@@ -45,22 +45,22 @@ along with Octave; see the file COPYING.
 #include "oct-locbuf.h"
 #include "quit.h"
 #include "singleton-cleanup.h"
 #include "str-vec.h"
 
 #include "error.h"
 #include "errwarn.h"
 #include "input.h"
+#include "interpreter.h"
 #include "octave.h"
 #include "oct-stdstrm.h"
 #include "oct-stream.h"
 #include "ov.h"
 #include "ovl.h"
-#include "toplev.h"
 #include "utils.h"
 
 // Programming Note: There are two very different error functions used
 // in the stream code.  When invoked with "error (...)" the member
 // function from octave_stream or octave_base_stream is called.  This
 // function sets the error state on the stream AND returns control to
 // the caller.  The caller must then return a value at the end of the
 // function.  When invoked with "::error (...)" the exception-based
diff --git a/libinterp/corefcn/octave-link.cc b/libinterp/corefcn/octave-link.cc
--- a/libinterp/corefcn/octave-link.cc
+++ b/libinterp/corefcn/octave-link.cc
@@ -27,17 +27,17 @@ along with Octave; see the file COPYING.
 #endif
 
 #include "cmd-edit.h"
 #include "defun.h"
 #include "oct-env.h"
 #include "oct-mutex.h"
 #include "pager.h"
 #include "singleton-cleanup.h"
-#include "toplev.h"
+#include "interpreter.h"
 
 #include "octave-link.h"
 
 static int
 octave_readline_hook (void)
 {
   octave_link::entered_readline_hook ();
   octave_link::generate_events ();
diff --git a/libinterp/corefcn/sighandlers.cc b/libinterp/corefcn/sighandlers.cc
--- a/libinterp/corefcn/sighandlers.cc
+++ b/libinterp/corefcn/sighandlers.cc
@@ -40,25 +40,25 @@ along with Octave; see the file COPYING.
 #include "quit.h"
 #include "singleton-cleanup.h"
 #include "signal-wrappers.h"
 
 #include "debug.h"
 #include "defun.h"
 #include "error.h"
 #include "input.h"
+#include "interpreter.h"
 #include "load-save.h"
 #include "octave.h"
 #include "oct-map.h"
 #include "pager.h"
 #include "pt-bp.h"
 #include "pt-eval.h"
 #include "sighandlers.h"
 #include "sysdep.h"
-#include "toplev.h"
 #include "utils.h"
 #include "variables.h"
 
 namespace octave
 {
   // Nonzero means we have already printed a message for this series of
   // SIGPIPES.  We assume that the writer will eventually give up.
   int pipe_handler_error_count = 0;
diff --git a/libinterp/corefcn/sysdep.cc b/libinterp/corefcn/sysdep.cc
--- a/libinterp/corefcn/sysdep.cc
+++ b/libinterp/corefcn/sysdep.cc
@@ -80,17 +80,17 @@ along with Octave; see the file COPYING.
 #include "input.h"
 #include "octave.h"
 #include "ov.h"
 #include "ovl.h"
 #include "pager.h"
 #include "parse.h"
 #include "sighandlers.h"
 #include "sysdep.h"
-#include "toplev.h"
+#include "interpreter.h"
 #include "utils.h"
 #include "file-stat.h"
 
 #if ! defined (STDIN_FILENO)
 #  define STDIN_FILENO 1
 #endif
 
 #if defined (__386BSD__) || defined (__FreeBSD__) || defined (__NetBSD__)
diff --git a/libinterp/corefcn/toplev.cc b/libinterp/corefcn/toplev.cc
--- a/libinterp/corefcn/toplev.cc
+++ b/libinterp/corefcn/toplev.cc
@@ -19,414 +19,58 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
-#include <cassert>
 #include <cerrno>
 #include <cstdlib>
-#include <cstring>
 #include <new>
 
-#include <fstream>
-#include <iostream>
 #include <sstream>
 #include <string>
 
 #if defined (OCTAVE_USE_WINDOWS_API)
 #  define WIN32_LEAN_AND_MEAN 1
 #  include <windows.h>
 #endif
 
-#include "cmd-edit.h"
-#include "cmd-hist.h"
-#include "file-ops.h"
+#include "child-list.h"
 #include "lo-error.h"
-#include "lo-mappers.h"
-#include "oct-env.h"
 #include "oct-fftw.h"
 #include "oct-locbuf.h"
 #include "oct-syscalls.h"
-#include "quit.h"
-#include "signal-wrappers.h"
-#include "singleton-cleanup.h"
 #include "str-vec.h"
 #include "wait-for-input.h"
 
 #include "build-env.h"
 #include "liboctinterp-build-info.h"
 #include "call-stack.h"
 #include "defaults.h"
 #include "defun.h"
 #include "error.h"
 #include "file-io.h"
-#include "graphics.h"
-#include "input.h"
-#include "lex.h"
-#include "load-save.h"
 #include "octave.h"
-#include "octave-link.h"
-#include "oct-hist.h"
 #include "oct-map.h"
 #include "ovl.h"
 #include "ov.h"
 #include "pager.h"
-#include "parse.h"
-#include "pathsearch.h"
 #include "procstream.h"
-#include "pt-eval.h"
-#include "pt-jump.h"
-#include "pt-stmt.h"
-#include "sighandlers.h"
 #include "sysdep.h"
-#include "toplev.h"
 #include "unwind-prot.h"
 #include "utils.h"
-#include "variables.h"
-#include "version.h"
+#include <version.h>
 
 #if ! defined (SHELL_PATH)
 #  define SHELL_PATH "/bin/sh"
 #endif
 
-void (*octave_exit) (int) = ::exit;
-
-// TRUE means the quit() call is allowed.
-bool quit_allowed = true;
-
-// TRUE means we are exiting via the builtin exit or quit functions.
-bool quitting_gracefully = false;
-// This stores the exit status.
-int exit_status = 0;
-
-// TRUE means we are ready to interpret commands, but not everything
-// is ready for interactive use.
-bool octave_interpreter_ready = false;
-
-// TRUE means we've processed all the init code and we are good to go.
-bool octave_initialized = false;
-
-void
-recover_from_exception (void)
-{
-  octave::can_interrupt = true;
-  octave_interrupt_immediately = 0;
-  octave_interrupt_state = 0;
-  octave_signal_caught = 0;
-  octave_exception_state = octave_no_exception;
-  octave_restore_signal_mask ();
-  octave::catch_interrupts ();
-}
-
-int
-main_loop (void)
-{
-  octave_save_signal_mask ();
-
-  octave::can_interrupt = true;
-
-  octave_signal_hook = octave::signal_handler;
-  octave_interrupt_hook = 0;
-  octave_bad_alloc_hook = 0;
-
-  octave::catch_interrupts ();
-
-  octave_initialized = true;
-
-  // The big loop.
-
-  octave_lexer *lxr = (octave::application::interactive ()
-                       ? new octave_lexer ()
-                       : new octave_lexer (stdin));
-
-  octave_parser parser (*lxr);
-
-  int retval = 0;
-  do
-    {
-      try
-        {
-          reset_error_handler ();
-
-          parser.reset ();
-
-          if (symbol_table::at_top_level ())
-            tree_evaluator::reset_debug_state ();
-
-          retval = parser.run ();
-
-          if (retval == 0)
-            {
-              if (parser.stmt_list)
-                {
-                  parser.stmt_list->accept (*current_evaluator);
-
-                  octave_quit ();
-
-                  if (! octave::application::interactive ())
-                    {
-                      bool quit = (tree_return_command::returning
-                                   || tree_break_command::breaking);
-
-                      if (tree_return_command::returning)
-                        tree_return_command::returning = 0;
-
-                      if (tree_break_command::breaking)
-                        tree_break_command::breaking--;
-
-                      if (quit)
-                        break;
-                    }
-
-                  if (octave_completion_matches_called)
-                    octave_completion_matches_called = false;
-                  else
-                    octave::command_editor::increment_current_command_number ();
-                }
-              else if (parser.lexer.end_of_input)
-                break;
-            }
-        }
-      catch (const octave_interrupt_exception&)
-        {
-          recover_from_exception ();
-
-          if (quitting_gracefully)
-            return exit_status;
-
-          // Required newline when the user does Ctrl+C at the prompt.
-          if (octave::application::interactive ())
-            octave_stdout << "\n";
-        }
-      catch (const index_exception& e)
-        {
-          recover_from_exception ();
-
-          std::cerr << "error: unhandled index exception: "
-                    << e.message () << " -- trying to return to prompt"
-                    << std::endl;
-        }
-      catch (const octave_execution_exception& e)
-        {
-          std::string stack_trace = e.info ();
-
-          if (! stack_trace.empty ())
-            std::cerr << stack_trace;
-
-          if (octave::application::interactive ())
-            recover_from_exception ();
-          else
-            {
-              // We should exit with a nonzero status.
-              retval = 1;
-              break;
-            }
-        }
-      catch (const std::bad_alloc&)
-        {
-          recover_from_exception ();
-
-          std::cerr << "error: out of memory -- trying to return to prompt"
-                    << std::endl;
-        }
-
-#if defined (DBSTOP_NANINF)
-      if (Vdebug_on_naninf)
-        {
-          if (setjump (naninf_jump) != 0)
-            debug_or_throw_exception (true);  // true = stack trace
-        }
-#endif
-    }
-  while (retval == 0);
-
-  if (octave::application::interactive ())
-    octave_stdout << "\n";
-
-  if (retval == EOF)
-    retval = 0;
-
-  return retval;
-}
-
-// Fix up things before exiting.
-
-static std::list<std::string> octave_atexit_functions;
-
-static void
-do_octave_atexit (void)
-{
-  static bool deja_vu = false;
-
-  OCTAVE_SAFE_CALL (remove_input_event_hook_functions, ());
-
-  while (! octave_atexit_functions.empty ())
-    {
-      std::string fcn = octave_atexit_functions.front ();
-
-      octave_atexit_functions.pop_front ();
-
-      OCTAVE_SAFE_CALL (reset_error_handler, ());
-
-      OCTAVE_SAFE_CALL (feval, (fcn, octave_value_list (), 0));
-
-      OCTAVE_SAFE_CALL (flush_octave_stdout, ());
-    }
-
-  if (! deja_vu)
-    {
-      deja_vu = true;
-
-      // Process pending events and disasble octave_link event
-      // processing with this call.
-
-      octave_link::process_events (true);
-
-      // Do this explicitly so that destructors for mex file objects
-      // are called, so that functions registered with mexAtExit are
-      // called.
-      OCTAVE_SAFE_CALL (clear_mex_functions, ());
-
-      OCTAVE_SAFE_CALL (octave::command_editor::restore_terminal_state, ());
-
-      // FIXME: is this needed?  Can it cause any trouble?
-      OCTAVE_SAFE_CALL (raw_mode, (0));
-
-      OCTAVE_SAFE_CALL (octave_history_write_timestamp, ());
-
-      if (! octave::command_history::ignoring_entries ())
-        OCTAVE_SAFE_CALL (octave::command_history::clean_up_and_save, ());
-
-      OCTAVE_SAFE_CALL (gh_manager::close_all_figures, ());
-
-      OCTAVE_SAFE_CALL (gtk_manager::unload_all_toolkits, ());
-
-      OCTAVE_SAFE_CALL (close_files, ());
-
-      OCTAVE_SAFE_CALL (cleanup_tmp_files, ());
-
-      OCTAVE_SAFE_CALL (symbol_table::cleanup, ());
-
-      OCTAVE_SAFE_CALL (sysdep_cleanup, ());
-
-      OCTAVE_SAFE_CALL (octave_finalize_hdf5, ());
-
-      OCTAVE_SAFE_CALL (flush_octave_stdout, ());
-
-      if (! quitting_gracefully && octave::application::interactive ())
-        {
-          octave_stdout << "\n";
-
-          // Yes, we want this to be separate from the call to
-          // flush_octave_stdout above.
-
-          OCTAVE_SAFE_CALL (flush_octave_stdout, ());
-        }
-
-      // Don't call singleton_cleanup_list::cleanup until we have the
-      // problems with registering/unregistering types worked out.  For
-      // example, uncomment the following line, then use the make_int
-      // function from the examples directory to create an integer
-      // object and then exit Octave.  Octave should crash with a
-      // segfault when cleaning up the typinfo singleton.  We need some
-      // way to force new octave_value_X types that are created in
-      // .oct files to be unregistered when the .oct file shared library
-      // is unloaded.
-      //
-      // OCTAVE_SAFE_CALL (singleton_cleanup_list::cleanup, ());
-
-      OCTAVE_SAFE_CALL (octave_chunk_buffer::clear, ());
-    }
-}
-
-void
-clean_up_and_exit (int status, bool safe_to_return)
-{
-  do_octave_atexit ();
-
-  if (octave_link::exit (status))
-    {
-      if (safe_to_return)
-        return;
-      else
-        {
-          // What should we do here?  We might be called from some
-          // location other than the end of octave_execute_interpreter,
-          // so it might not be safe to return.
-
-          // We have nothing else to do at this point, and the
-          // octave_link::exit function is supposed to take care of
-          // exiting for us.  Assume that job won't take more than a
-          // day...
-
-          octave_sleep (86400); // FIXME: really needed?
-        }
-    }
-  else
-    {
-      if (octave_exit)
-        (*octave_exit) (status);
-    }
-}
-
-DEFUN (quit, args, ,
-       doc: /* -*- texinfo -*-
-@deftypefn  {} {} exit
-@deftypefnx {} {} exit (@var{status})
-@deftypefnx {} {} quit
-@deftypefnx {} {} quit (@var{status})
-Exit the current Octave session.
-
-If the optional integer value @var{status} is supplied, pass that value to
-the operating system as Octave's exit status.  The default value is zero.
-
-When exiting, Octave will attempt to run the m-file @file{finish.m} if it
-exists.  User commands to save the workspace or clean up temporary files
-may be placed in that file.  Alternatively, another m-file may be scheduled
-to run using @code{atexit}.
-@seealso{atexit}
-@end deftypefn */)
-{
-  // Confirm OK to shutdown.  Note: A dynamic function installation similar
-  // to overriding polymorphism for which the GUI can install its own "quit"
-  // yet call this base "quit" could be nice.  No link would be needed here.
-  if (! octave_link::confirm_shutdown ())
-    return ovl ();
-
-  if (! quit_allowed)
-    error ("quit: not supported in embedded mode");
-
-  if (args.length () > 0)
-    {
-      int tmp = args(0).nint_value ();
-
-      exit_status = tmp;
-    }
-
-  // Instead of simply calling exit, we simulate an interrupt
-  // with a request to exit cleanly so that no matter where the
-  // call to quit occurs, we will run the unwind_protect stack,
-  // clear the OCTAVE_LOCAL_BUFFER allocations, etc. before
-  // exiting.
-
-  quitting_gracefully = true;
-
-  octave_interrupt_state = -1;
-
-  octave_throw_interrupt_exception ();
-
-  return ovl ();
-}
-
-DEFALIAS (exit, quit);
-
 DEFUN (warranty, , ,
        doc: /* -*- texinfo -*-
 @deftypefn {} {} warranty ()
 Describe the conditions for copying and distributing Octave.
 @end deftypefn */)
 {
   octave_stdout << "\n" << octave_name_version_and_copyright () << "\n\
 \n\
@@ -664,107 +308,16 @@ command shell that is started to run the
 %! assert (status, 0);
 %! assert (ischar (output));
 %! assert (! isempty (output));
 
 %!error system ()
 %!error system (1, 2, 3)
 */
 
-void
-octave_add_atexit_function (const std::string& fname)
-{
-  octave_atexit_functions.push_front (fname);
-}
-
-bool
-octave_remove_atexit_function (const std::string& fname)
-{
-  bool found = false;
-
-  for (std::list<std::string>::iterator p = octave_atexit_functions.begin ();
-       p != octave_atexit_functions.end (); p++)
-    {
-      if (*p == fname)
-        {
-          octave_atexit_functions.erase (p);
-          found = true;
-          break;
-        }
-    }
-
-  return found;
-}
-
-DEFUN (atexit, args, nargout,
-       doc: /* -*- texinfo -*-
-@deftypefn  {} {} atexit (@var{fcn})
-@deftypefnx {} {} atexit (@var{fcn}, @var{flag})
-Register a function to be called when Octave exits.
-
-For example,
-
-@example
-@group
-function last_words ()
-  disp ("Bye bye");
-endfunction
-atexit ("last_words");
-@end group
-@end example
-
-@noindent
-will print the message @qcode{"Bye bye"} when Octave exits.
-
-The additional argument @var{flag} will register or unregister @var{fcn}
-from the list of functions to be called when Octave exits.  If @var{flag} is
-true, the function is registered, and if @var{flag} is false, it is
-unregistered.  For example, after registering the function @code{last_words}
-above,
-
-@example
-atexit ("last_words", false);
-@end example
-
-@noindent
-will remove the function from the list and Octave will not call
-@code{last_words} when it exits.
-
-Note that @code{atexit} only removes the first occurrence of a function
-from the list, so if a function was placed in the list multiple times with
-@code{atexit}, it must also be removed from the list multiple times.
-@seealso{quit}
-@end deftypefn */)
-{
-  int nargin = args.length ();
-
-  if (nargin < 1 || nargin > 2)
-    print_usage ();
-
-  std::string arg = args(0).xstring_value ("atexit: FCN argument must be a string");
-
-  bool add_mode = (nargin == 2)
-    ? args(1).xbool_value ("atexit: FLAG argument must be a logical value")
-    : true;
-
-  octave_value_list retval;
-
-  if (add_mode)
-    octave_add_atexit_function (arg);
-  else
-    {
-      bool found = octave_remove_atexit_function (arg);
-
-      if (nargout > 0)
-        retval = ovl (found);
-    }
-
-  return retval;
-}
-
 static octave_value
 find_config_info (const octave_scalar_map& m, const std::string& key)
 {
   if (m.isfield (key))
     {
       Cell c = m.contents (key);
 
       if (! c.is_empty ())
diff --git a/libinterp/corefcn/toplev.h b/libinterp/corefcn/toplev.h
--- a/libinterp/corefcn/toplev.h
+++ b/libinterp/corefcn/toplev.h
@@ -20,73 +20,13 @@ along with Octave; see the file COPYING.
 
 */
 
 #if ! defined (octave_toplev_h)
 #define octave_toplev_h 1
 
 #include "octave-config.h"
 
-#include <string>
-
-#include "quit.h"
-
-typedef void (*octave_exit_func) (int);
-extern OCTINTERP_API octave_exit_func octave_exit;
-
-extern OCTINTERP_API bool quit_allowed;
-
-extern OCTINTERP_API bool quitting_gracefully;
-
-extern OCTINTERP_API int exit_status;
-
-extern OCTINTERP_API void
-clean_up_and_exit (int status, bool safe_to_return = false);
-
-extern OCTINTERP_API void recover_from_exception (void);
-
-extern OCTINTERP_API int main_loop (void);
-
-extern OCTINTERP_API void
-octave_add_atexit_function (const std::string& fname);
-
-extern OCTINTERP_API bool
-octave_remove_atexit_function (const std::string& fname);
-
-// TRUE means we are ready to interpret commands, but not everything
-// is ready for interactive use.
-extern OCTINTERP_API bool octave_interpreter_ready;
+#warning "toplev.h has been deprecated; use interpreter.h instead"
 
-// TRUE means we've processed all the init code and we are good to go.
-extern OCTINTERP_API bool octave_initialized;
-
-// Call a function with exceptions handled to avoid problems with
-// errors while shutting down.
-
-#define OCTAVE_IGNORE_EXCEPTION(E) \
-  catch (E) \
-    { \
-      std::cerr << "error: ignoring " #E " while preparing to exit" << std::endl; \
-      recover_from_exception (); \
-    }
-
-#define OCTAVE_SAFE_CALL(F, ARGS) \
-  do \
-    { \
-      try \
-        { \
-          octave::unwind_protect frame; \
- \
-          frame.protect_var (Vdebug_on_error); \
-          frame.protect_var (Vdebug_on_warning); \
- \
-          Vdebug_on_error = false; \
-          Vdebug_on_warning = false; \
- \
-          F ARGS; \
-        } \
-      OCTAVE_IGNORE_EXCEPTION (const octave_interrupt_exception&) \
-      OCTAVE_IGNORE_EXCEPTION (const octave_execution_exception&) \
-      OCTAVE_IGNORE_EXCEPTION (const std::bad_alloc&) \
-    } \
-  while (0)
+#include "interpreter.h"
 
 #endif
diff --git a/libinterp/corefcn/utils.cc b/libinterp/corefcn/utils.cc
--- a/libinterp/corefcn/utils.cc
+++ b/libinterp/corefcn/utils.cc
@@ -49,26 +49,26 @@ along with Octave; see the file COPYING.
 
 #include "Cell.h"
 #include <defaults.h>
 #include "defun.h"
 #include "dirfns.h"
 #include "error.h"
 #include "errwarn.h"
 #include "input.h"
+#include "interpreter.h"
 #include "lex.h"
 #include "load-path.h"
 #include "oct-errno.h"
 #include "oct-hist.h"
 #include "ovl.h"
 #include "ov-range.h"
 #include "pager.h"
 #include "parse.h"
 #include "sysdep.h"
-#include "toplev.h"
 #include "unwind-prot.h"
 #include "utils.h"
 #include "variables.h"
 
 // Return TRUE if S is a valid identifier.
 
 bool
 valid_identifier (const char *s)
diff --git a/libinterp/corefcn/variables.cc b/libinterp/corefcn/variables.cc
--- a/libinterp/corefcn/variables.cc
+++ b/libinterp/corefcn/variables.cc
@@ -43,29 +43,29 @@ along with Octave; see the file COPYING.
 #include <defaults.h>
 #include "Cell.h"
 #include "defun.h"
 #include "dirfns.h"
 #include "error.h"
 #include "errwarn.h"
 #include "help.h"
 #include "input.h"
+#include "interpreter.h"
 #include "lex.h"
 #include "load-path.h"
 #include "octave-link.h"
 #include "octave-preserve-stream-state.h"
 #include "oct-map.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-class.h"
 #include "ov-usr-fcn.h"
 #include "pager.h"
 #include "parse.h"
 #include "symtab.h"
-#include "toplev.h"
 #include "unwind-prot.h"
 #include "utils.h"
 #include "variables.h"
 
 // Defines layout for the whos/who -long command
 static std::string Vwhos_line_format
   = "  %a:4; %ln:6; %cs:16:6:1;  %rb:12;  %lc:-1;\n";
 
diff --git a/libinterp/dldfcn/__init_fltk__.cc b/libinterp/dldfcn/__init_fltk__.cc
--- a/libinterp/dldfcn/__init_fltk__.cc
+++ b/libinterp/dldfcn/__init_fltk__.cc
@@ -84,17 +84,17 @@ To initialize:
 #include "oct-env.h"
 
 #include "display.h"
 #include "file-ops.h"
 #include "gl-render.h"
 #include "gl2ps-print.h"
 #include "graphics.h"
 #include "parse.h"
-#include "toplev.h"
+#include "interpreter.h"
 #include "variables.h"
 
 #define FLTK_GRAPHICS_TOOLKIT_NAME "fltk"
 
 const char* help_text = "\
 Keyboard Shortcuts\n\
 a - autoscale\n\
 p - pan/zoom\n\
diff --git a/libinterp/octave-value/ov-base.cc b/libinterp/octave-value/ov-base.cc
--- a/libinterp/octave-value/ov-base.cc
+++ b/libinterp/octave-value/ov-base.cc
@@ -49,17 +49,17 @@ along with Octave; see the file COPYING.
 #include "ov-range.h"
 #include "ov-re-mat.h"
 #include "ov-scalar.h"
 #include "ov-str-mat.h"
 #include "ov-fcn-handle.h"
 #include "parse.h"
 #include "pr-output.h"
 #include "utils.h"
-#include "toplev.h"
+#include "interpreter.h"
 #include "variables.h"
 
 builtin_type_t btyp_mixed_numeric (builtin_type_t x, builtin_type_t y)
 {
   builtin_type_t retval = btyp_unknown;
 
   if (x == btyp_bool)
     x = btyp_double;
diff --git a/libinterp/octave-value/ov-builtin.cc b/libinterp/octave-value/ov-builtin.cc
--- a/libinterp/octave-value/ov-builtin.cc
+++ b/libinterp/octave-value/ov-builtin.cc
@@ -26,17 +26,17 @@ along with Octave; see the file COPYING.
 
 #include "call-stack.h"
 #include "error.h"
 #include "errwarn.h"
 #include "ovl.h"
 #include "ov-builtin.h"
 #include "ov.h"
 #include "profiler.h"
-#include "toplev.h"
+#include "interpreter.h"
 #include "unwind-prot.h"
 
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_builtin,
                                      "built-in function",
                                      "built-in function");
 
 octave_value_list
diff --git a/libinterp/octave-value/ov-class.cc b/libinterp/octave-value/ov-class.cc
--- a/libinterp/octave-value/ov-class.cc
+++ b/libinterp/octave-value/ov-class.cc
@@ -33,31 +33,31 @@ along with Octave; see the file COPYING.
 #include "lo-mappers.h"
 
 #include "Cell.h"
 #include "call-stack.h"
 #include "defun.h"
 #include "error.h"
 #include "file-ops.h"
 #include "errwarn.h"
+#include "interpreter.h"
 #include "load-path.h"
 #include "ls-hdf5.h"
 #include "ls-oct-text.h"
 #include "ls-oct-binary.h"
 #include "ls-utils.h"
 #include "mxarray.h"
 #include "oct-lvalue.h"
 #include "oct-hdf5.h"
 #include "ov-class.h"
 #include "ov-fcn.h"
 #include "ov-usr-fcn.h"
 #include "pager.h"
 #include "parse.h"
 #include "pr-output.h"
-#include "toplev.h"
 #include "unwind-prot.h"
 #include "variables.h"
 
 
 int octave_class::t_id (-1);
 
 const std::string octave_class::t_name ("class");
 
diff --git a/libinterp/octave-value/ov-classdef.cc b/libinterp/octave-value/ov-classdef.cc
--- a/libinterp/octave-value/ov-classdef.cc
+++ b/libinterp/octave-value/ov-classdef.cc
@@ -37,17 +37,17 @@ along with Octave; see the file COPYING.
 #include "pt-assign.h"
 #include "pt-classdef.h"
 #include "pt-funcall.h"
 #include "pt-misc.h"
 #include "pt-stmt.h"
 #include "pt-walk.h"
 #include "singleton-cleanup.h"
 #include "symtab.h"
-#include "toplev.h"
+#include "interpreter.h"
 
 // Define to 1 to enable debugging statements.
 #define DEBUG_TRACE 0
 
 OCTAVE_NORETURN static
 void
 err_method_access (const std::string& from, const cdef_method& meth)
 {
diff --git a/libinterp/octave-value/ov-fcn-handle.cc b/libinterp/octave-value/ov-fcn-handle.cc
--- a/libinterp/octave-value/ov-fcn-handle.cc
+++ b/libinterp/octave-value/ov-fcn-handle.cc
@@ -34,16 +34,17 @@ along with Octave; see the file COPYING.
 #include "file-ops.h"
 #include "oct-locbuf.h"
 
 #include "call-stack.h"
 #include "defun.h"
 #include "error.h"
 #include "errwarn.h"
 #include "input.h"
+#include "interpreter.h"
 #include "oct-hdf5.h"
 #include "oct-map.h"
 #include "ov-base.h"
 #include "ov-fcn-handle.h"
 #include "ov-usr-fcn.h"
 #include "pr-output.h"
 #include "pt-pr-code.h"
 #include "pt-misc.h"
diff --git a/libinterp/octave-value/ov-fcn-inline.cc b/libinterp/octave-value/ov-fcn-inline.cc
--- a/libinterp/octave-value/ov-fcn-inline.cc
+++ b/libinterp/octave-value/ov-fcn-inline.cc
@@ -42,17 +42,17 @@ Open Source Initiative (www.opensource.o
 #include "oct-hdf5.h"
 #include "oct-map.h"
 #include "ov-base.h"
 #include "ov-fcn-inline.h"
 #include "ov-usr-fcn.h"
 #include "pr-output.h"
 #include "variables.h"
 #include "parse.h"
-#include "toplev.h"
+#include "interpreter.h"
 
 #include "byte-swap.h"
 #include "ls-ascii-helper.h"
 #include "ls-oct-text.h"
 #include "ls-hdf5.h"
 #include "ls-utils.h"
 
 
diff --git a/libinterp/octave-value/ov-mex-fcn.cc b/libinterp/octave-value/ov-mex-fcn.cc
--- a/libinterp/octave-value/ov-mex-fcn.cc
+++ b/libinterp/octave-value/ov-mex-fcn.cc
@@ -30,17 +30,17 @@ along with Octave; see the file COPYING.
 #include <defaults.h>
 #include "dynamic-ld.h"
 #include "error.h"
 #include "errwarn.h"
 #include "ovl.h"
 #include "ov-mex-fcn.h"
 #include "ov.h"
 #include "profiler.h"
-#include "toplev.h"
+#include "interpreter.h"
 #include "unwind-prot.h"
 
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_mex_function,
                                      "mex function", "mex function");
 
 octave_mex_function::octave_mex_function
   (void *fptr, bool fmex, const octave::dynamic_library& shl,
diff --git a/libinterp/octave-value/ov-oncleanup.cc b/libinterp/octave-value/ov-oncleanup.cc
--- a/libinterp/octave-value/ov-oncleanup.cc
+++ b/libinterp/octave-value/ov-oncleanup.cc
@@ -20,21 +20,21 @@ along with Octave; see the file COPYING.
 
 */
 
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
 #include "defun.h"
+#include "interpreter.h"
 #include "ov-oncleanup.h"
 #include "ov-fcn.h"
 #include "ov-usr-fcn.h"
 #include "pt-misc.h"
-#include "toplev.h"
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_oncleanup, "onCleanup",
                                      "onCleanup");
 
 octave_oncleanup::octave_oncleanup (const octave_value& f)
   : fcn (f)
 {
   if (f.is_function_handle ())
diff --git a/libinterp/octave-value/ov-usr-fcn.cc b/libinterp/octave-value/ov-usr-fcn.cc
--- a/libinterp/octave-value/ov-usr-fcn.cc
+++ b/libinterp/octave-value/ov-usr-fcn.cc
@@ -43,17 +43,17 @@ along with Octave; see the file COPYING.
 #include "pt-eval.h"
 #include "pt-jit.h"
 #include "pt-jump.h"
 #include "pt-misc.h"
 #include "pt-pr-code.h"
 #include "pt-stmt.h"
 #include "pt-walk.h"
 #include "symtab.h"
-#include "toplev.h"
+#include "interpreter.h"
 #include "unwind-prot.h"
 #include "utils.h"
 #include "parse.h"
 #include "profiler.h"
 #include "variables.h"
 #include "ov-fcn-handle.h"
 
 // Whether to optimize subsasgn method calls.
diff --git a/libinterp/octave.cc b/libinterp/octave.cc
--- a/libinterp/octave.cc
+++ b/libinterp/octave.cc
@@ -21,356 +21,38 @@ along with Octave; see the file COPYING.
 */
 
 // Born February 20, 1992.
 
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
-#include <cassert>
-#include <clocale>
-#include <cstdlib>
-#include <cstring>
-#include <ctime>
+#include <string>
 
-#include <iostream>
-
-#include "cmd-edit.h"
-#include "f77-fcn.h"
 #include "file-ops.h"
-#include "file-stat.h"
-#include "fpucw-wrappers.h"
 #include "getopt-wrapper.h"
 #include "lo-error.h"
 #include "oct-env.h"
 #include "str-vec.h"
-#include "signal-wrappers.h"
-#include "unistd-wrappers.h"
 
-#include "build-env.h"
-#include "builtins.h"
-#include "defaults.h"
+#include "builtin-defun-decls.h"
 #include "Cell.h"
 #include "defun.h"
 #include "display.h"
 #include "error.h"
-#include "file-io.h"
-#include "help.h"
 #include "input.h"
-#include "lex.h"
-#include "load-path.h"
-#include "load-save.h"
+#include "interpreter.h"
 #include "octave.h"
 #include "oct-hist.h"
 #include "oct-map.h"
-#include "oct-mutex.h"
 #include "ovl.h"
-#include "ops.h"
 #include "options-usage.h"
 #include "ov.h"
-#include "ov-classdef.h"
-#include "ov-range.h"
-#include "toplev.h"
 #include "parse.h"
-#include "procstream.h"
-#include "sighandlers.h"
-#include "sysdep.h"
-#include "unwind-prot.h"
-#include "utils.h"
-#include "variables.h"
-#include <version.h>
-
-// Kluge.
-extern "C" F77_RET_T
-F77_FUNC (xerbla, XERBLA) (F77_CONST_CHAR_ARG_DECL,
-                           const octave_idx_type&
-                           F77_CHAR_ARG_LEN_DECL);
-
-extern void install_builtins (void);
-
-// Store the command-line options for later use.
-
-static void
-execute_pkg_add (const std::string& dir)
-{
-  std::string file_name = octave::sys::file_ops::concat (dir, "PKG_ADD");
-
-  try
-    {
-      load_path::execute_pkg_add (dir);
-    }
-  catch (const index_exception& e)
-    {
-      recover_from_exception ();
-
-      std::cerr << "error: index exception in " << file_name << ": "
-                << e.message () << std::endl;
-    }
-  catch (const octave_interrupt_exception&)
-    {
-      recover_from_exception ();
-
-      if (quitting_gracefully)
-        clean_up_and_exit (exit_status);
-    }
-  catch (const octave_execution_exception&)
-    {
-      recover_from_exception ();
-
-      std::cerr << "error: execution exception in " << file_name << std::endl;
-    }
-}
-
-static void
-initialize_load_path (bool set_initial_path)
-{
-  // Temporarily set the execute_pkg_add function to one that catches
-  // exceptions.  This is better than wrapping load_path::initialize in
-  // a try-catch block because it will not stop executing PKG_ADD files
-  // at the first exception.  It's also better than changing the default
-  // execute_pkg_add function to use safe_source file because that will
-  // normally be evaluated from the normal intepreter loop where
-  // exceptions are already handled.
-
-  octave::unwind_protect frame;
-
-  frame.add_fcn (load_path::set_add_hook, load_path::get_add_hook ());
-
-  load_path::set_add_hook (execute_pkg_add);
-
-  load_path::initialize (set_initial_path);
-}
-
-DEFUN (__version_info__, args, ,
-       doc: /* -*- texinfo -*-
-@deftypefn {} {retval =} __version_info__ (@var{name}, @var{version}, @var{release}, @var{date})
-Undocumented internal function.
-@end deftypefn */)
-{
-  static octave_map vinfo;
-
-  int nargin = args.length ();
-
-  if (nargin != 0 && nargin != 4)
-    print_usage ();
-
-  octave_value retval;
-
-  if (nargin == 0)
-    retval = vinfo;
-  else if (nargin == 4)
-    {
-      if (vinfo.nfields () == 0)
-        {
-          vinfo.assign ("Name", args(0));
-          vinfo.assign ("Version", args(1));
-          vinfo.assign ("Release", args(2));
-          vinfo.assign ("Date", args(3));
-        }
-      else
-        {
-          octave_idx_type n = vinfo.numel () + 1;
-
-          vinfo.resize (dim_vector (n, 1));
-
-          octave_value idx (n);
-
-          vinfo.assign (idx, "Name", Cell (octave_value (args(0))));
-          vinfo.assign (idx, "Version", Cell (octave_value (args(1))));
-          vinfo.assign (idx, "Release", Cell (octave_value (args(2))));
-          vinfo.assign (idx, "Date", Cell (octave_value (args(3))));
-        }
-    }
-
-  return retval;
-}
-
-static void
-initialize_version_info (void)
-{
-  octave_value_list args;
-
-  args(3) = OCTAVE_RELEASE_DATE;
-  args(2) = OCTAVE_RELEASE;
-  args(1) = OCTAVE_VERSION;
-  args(0) = "GNU Octave";
-
-  F__version_info__ (args, 0);
-}
-
-// Execute commands from a file and catch potential exceptions in a consistent
-// way.  This function should be called anywhere we might parse and execute
-// commands from a file before before we have entered the main loop in
-// toplev.cc.
-
-static void
-safe_source_file (const std::string& file_name,
-                  const std::string& context = "",
-                  bool verbose = false, bool require_file = true,
-                  const std::string& warn_for = "")
-{
-  try
-    {
-      source_file (file_name, context, verbose, require_file, warn_for);
-    }
-  catch (const index_exception& e)
-    {
-      recover_from_exception ();
-
-      std::cerr << "error: index exception in " << file_name << ": "
-                << e.message () << std::endl;
-    }
-  catch (const octave_interrupt_exception&)
-    {
-      recover_from_exception ();
-
-      if (quitting_gracefully)
-        clean_up_and_exit (exit_status);
-    }
-  catch (const octave_execution_exception&)
-    {
-      recover_from_exception ();
-
-      std::cerr << "error: execution exception in " << file_name << std::endl;
-    }
-}
-
-// Initialize by reading startup files.
-
-static void
-execute_startup_files (bool read_site_files, bool read_init_files,
-                       bool verbose_flag, bool inhibit_startup_message)
-{
-  octave::unwind_protect frame;
-
-  std::string context;
-
-  bool verbose = (verbose_flag && ! inhibit_startup_message);
-
-  bool require_file = false;
-
-  if (read_site_files)
-    {
-      // Execute commands from the site-wide configuration file.
-      // First from the file $(prefix)/lib/octave/site/m/octaverc
-      // (if it exists), then from the file
-      // $(prefix)/share/octave/$(version)/m/octaverc (if it exists).
-
-      safe_source_file (Vlocal_site_defaults_file, context, verbose,
-                        require_file);
-
-      safe_source_file (Vsite_defaults_file, context, verbose, require_file);
-    }
-
-  if (read_init_files)
-    {
-      // Try to execute commands from $HOME/$OCTAVE_INITFILE and
-      // $OCTAVE_INITFILE.  If $OCTAVE_INITFILE is not set,
-      // .octaverc is assumed.
-
-      bool home_rc_already_executed = false;
-
-      std::string initfile = octave::sys::env::getenv ("OCTAVE_INITFILE");
-
-      if (initfile.empty ())
-        initfile = ".octaverc";
-
-      std::string home_dir = octave::sys::env::get_home_directory ();
-
-      std::string home_rc = octave::sys::env::make_absolute (initfile, home_dir);
-
-      std::string local_rc;
-
-      if (! home_rc.empty ())
-        {
-          safe_source_file (home_rc, context, verbose, require_file);
-
-          // Names alone are not enough.
-
-          octave::sys::file_stat fs_home_rc (home_rc);
-
-          if (fs_home_rc)
-            {
-              // We want to check for curr_dir after executing home_rc
-              // because doing that may change the working directory.
-
-              local_rc = octave::sys::env::make_absolute (initfile);
-
-              home_rc_already_executed = same_file (home_rc, local_rc);
-            }
-        }
-
-      if (! home_rc_already_executed)
-        {
-          if (local_rc.empty ())
-            local_rc = octave::sys::env::make_absolute (initfile);
-
-          safe_source_file (local_rc, context, verbose, require_file);
-        }
-    }
-}
-
-OCTAVE_NORETURN static void
-lo_error_handler (const char *fmt, ...)
-{
-  va_list args;
-  va_start (args, fmt);
-  verror_with_cfn (fmt, args);
-  va_end (args);
-
-  octave_throw_execution_exception ();
-}
-
-OCTAVE_NORETURN static void
-lo_error_with_id_handler (const char *id, const char *fmt, ...)
-{
-  va_list args;
-  va_start (args, fmt);
-  verror_with_id_cfn (id, fmt, args);
-  va_end (args);
-
-  octave_throw_execution_exception ();
-}
-
-static void
-initialize_error_handlers ()
-{
-  set_liboctave_error_handler (lo_error_handler);
-  set_liboctave_error_with_id_handler (lo_error_with_id_handler);
-  set_liboctave_warning_handler (warning);
-  set_liboctave_warning_with_id_handler (warning_with_id);
-}
-
-// What internal options get configured by --traditional.
-
-static void
-maximum_braindamage (void)
-{
-  FPS1 (octave_value (">> "));
-  FPS2 (octave_value (""));
-  FPS4 (octave_value (""));
-  Fbeep_on_error (octave_value (true));
-  Fconfirm_recursive_rmdir (octave_value (false));
-  Fcrash_dumps_octave_core (octave_value (false));
-  Fdisable_diagonal_matrix (octave_value (true));
-  Fdisable_permutation_matrix (octave_value (true));
-  Fdisable_range (octave_value (true));
-  Ffixed_point_format (octave_value (true));
-  Fhistory_timestamp_format_string (octave_value ("%%-- %D %I:%M %p --%%"));
-  Fpage_screen_output (octave_value (false));
-  Fprint_empty_dimensions (octave_value (false));
-  Fsave_default_options (octave_value ("-mat-binary"));
-  Fstruct_levels_to_print (octave_value (0));
-
-  disable_warning ("Octave:abbreviated-property-match");
-  disable_warning ("Octave:data-file-in-path");
-  disable_warning ("Octave:function-name-clash");
-  disable_warning ("Octave:possible-matlab-short-circuit-operator");
-}
 
 namespace octave
 {
   cmdline_options::cmdline_options (void)
   {
     m_all_args.resize (1);
     m_all_args[0] = "";
   }
@@ -738,342 +420,16 @@ namespace octave
   }
 
   int embedded_application::execute (void)
   {
     create_interpreter ();
 
     return execute_interpreter ();
   }
-
-  interpreter::interpreter (application *app_context, bool embedded)
-    : m_app_context (app_context), m_embedded (embedded),
-      m_interactive (false)
-  {
-    cmdline_options options = m_app_context->options ();
-
-    sysdep_init ();
-
-    install_defaults ();
-
-    // Matlab uses "C" locale for LC_NUMERIC class regardless of local setting
-    setlocale (LC_NUMERIC, "C");
-    setlocale (LC_TIME, "C");
-    octave::sys::env::putenv ("LC_NUMERIC", "C");
-    octave::sys::env::putenv ("LC_TIME", "C");
-
-    // Initialize the default floating point unit control state.
-    octave_set_default_fpucw ();
-
-    string_vector all_args = options.all_args ();
-
-    octave_thread::init ();
-
-    set_default_prompts ();
-
-    // Initialize default warning state before --traditional option
-    // that may reset them.
-
-    initialize_default_warning_state ();
-
-    if (options.traditional ())
-      maximum_braindamage ();
-
-    octave_ieee_init ();
-
-    // The idea here is to force xerbla to be referenced so that we will link to
-    // our own version instead of the one provided by the BLAS library.  But
-    // octave::numeric_limits<double>::NaN () should never be -1, so we
-    // should never actually call xerbla.  FIXME (again!):  If this
-    // becomes a constant expression the test might be optimized away and
-    // then the reference to the function might also disappear.
-
-    if (octave::numeric_limits<double>::NaN () == -1)
-      F77_FUNC (xerbla, XERBLA) ("octave", 13 F77_CHAR_ARG_LEN (6));
-
-    initialize_error_handlers ();
-
-    if (! m_embedded)
-      octave::install_signal_handlers ();
-    else
-      quit_allowed = false;
-
-    initialize_file_io ();
-
-    install_types ();
-
-    install_ops ();
-
-    install_builtins ();
-
-    install_classdef ();
-
-    std::list<std::string> command_line_path = options.command_line_path ();
-
-    for (std::list<std::string>::const_iterator it = command_line_path.begin ();
-         it != command_line_path.end (); it++)
-      load_path::set_command_line_path (*it);
-
-    std::string exec_path = options.exec_path ();
-    if (! exec_path.empty ())
-      set_exec_path (exec_path);
-
-    std::string image_path = options.image_path ();
-    if (! image_path.empty ())
-      set_image_path (image_path);
-
-    if (options.no_window_system ())
-      display_info::no_window_system ();
-
-    // Is input coming from a terminal?  If so, we are probably interactive.
-
-    // If stdin is not a tty, then we are reading commands from a pipe or
-    // a redirected file.
-    bool stdin_is_tty = octave_isatty_wrapper (fileno (stdin));
-
-    m_interactive = (! m_embedded
-                     && ! m_app_context->is_octave_program ()
-                     && stdin_is_tty
-                     && octave_isatty_wrapper (fileno (stdout)));
-
-    // Check if the user forced an interactive session.  If he
-    // unnecessarily did so, reset forced_interactive to false.
-    if (options.forced_interactive ())
-      {
-        if (m_interactive)
-          options.forced_interactive (false);
-        else
-          m_interactive = true;
-      }
-
-    if ((! m_interactive || options.forced_interactive ())
-        && ! options.forced_line_editing ())
-      options.line_editing (false);
-
-    // Also skip start-up message unless session is interactive.
-    if (! m_interactive)
-      options.inhibit_startup_message (true);
-
-    // Force default line editor if we don't want readline editing.
-    if (! options.line_editing ())
-      octave::command_editor::force_default_editor ();
-
-    // These can come after command line args since none of them set any
-    // defaults that might be changed by command line options.
-
-    if (options.line_editing ())
-      initialize_command_input ();
-
-    octave_interpreter_ready = true;
-
-    initialize_version_info ();
-
-    // Make all command-line arguments available to startup files,
-    // including PKG_ADD files.
-
-    app_context->intern_argv (options.all_args ());
-
-    initialize_load_path (options.set_initial_path ());
-
-    initialize_history (options.read_history_file ());
-  }
-
-  int interpreter::execute (void)
-  {
-    cmdline_options options = m_app_context->options ();
-
-    if (! options.inhibit_startup_message ())
-      std::cout << octave_startup_message () << "\n" << std::endl;
-
-    octave_prepare_hdf5 ();
-
-    execute_startup_files (options.read_site_files (),
-                           options.read_init_files (),
-                           options.verbose_flag (),
-                           options.inhibit_startup_message ());
-
-    if (! options.inhibit_startup_message ()
-        && reading_startup_message_printed)
-      std::cout << std::endl;
-
-    // Execute any code specified with --eval 'CODE'
-    std::string code_to_eval = options.code_to_eval ();
-
-    if (! code_to_eval.empty ())
-      {
-        int parse_status = 0;
-
-        try
-          {
-            parse_status = execute_eval_option_code (code_to_eval);
-          }
-        catch (const octave_execution_exception&)
-          {
-            recover_from_exception ();
-
-            parse_status = 1;
-          }
-
-        if (! options.persist ())
-          {
-            quitting_gracefully = true;
-
-            clean_up_and_exit (parse_status);
-          }
-      }
-
-    // If there is an extra argument, see if it names a file to read.
-    // Additional arguments are taken as command line options for the script.
-
-    if (m_app_context->have_script_file ())
-      {
-        // If we are running an executable script (#! /bin/octave) then
-        // we should only see the args passed to the script.
-
-        exit_status = 0;
-
-        try
-          {
-            string_vector script_args = options.remaining_args ();
-
-            m_app_context->intern_argv (script_args);
-
-            execute_command_line_file (script_args[0]);
-          }
-        catch (const octave_execution_exception&)
-          {
-            recover_from_exception ();
-
-            exit_status = 1;
-          }
-
-        // Restore full set of args.
-        m_app_context->intern_argv (options.all_args ());
-
-        if (! options.persist ())
-          {
-            quitting_gracefully = true;
-
-            clean_up_and_exit (exit_status);
-          }
-      }
-
-    // Avoid counting commands executed from startup or script files.
-
-    octave::command_editor::reset_current_command_number (1);
-
-    // Force input to be echoed if not really interactive,
-    // but the user has forced interactive behavior.
-
-    if (options.forced_interactive ())
-      {
-        octave::command_editor::blink_matching_paren (false);
-
-        // FIXME: is this the right thing to do?
-        Fecho_executing_commands (octave_value (ECHO_CMD_LINE));
-      }
-
-    if (m_embedded)
-      {
-        // FIXME: Do we need to do any cleanup here before returning?
-        // If we don't, what will happen to Octave functions that have been
-        // registered to execute with atexit, for example?
-
-        return 1;
-      }
-
-    int retval = main_loop ();
-
-    quitting_gracefully = true;
-
-    clean_up_and_exit (retval, true);
-
-    return retval;
-  }
-
-  int interpreter::execute_eval_option_code (const std::string& code)
-  {
-    octave::unwind_protect frame;
-
-    octave_save_signal_mask ();
-
-    octave::can_interrupt = true;
-
-    octave_signal_hook = octave::signal_handler;
-    octave_interrupt_hook = 0;
-    octave_bad_alloc_hook = 0;
-
-    octave::catch_interrupts ();
-
-    octave_initialized = true;
-
-    frame.add_method (this, &interpreter::interactive, m_interactive);
-
-    m_interactive = false;
-
-    int parse_status = 0;
-
-    try
-      {
-        eval_string (code, false, parse_status, 0);
-      }
-    catch (const octave_interrupt_exception&)
-      {
-        recover_from_exception ();
-
-        if (quitting_gracefully)
-          clean_up_and_exit (exit_status);
-      }
-    catch (const octave_execution_exception&)
-      {
-        recover_from_exception ();
-
-        std::cerr << "error: unhandled execution exception -- eval failed"
-                  << std::endl;
-      }
-
-    return parse_status;
-  }
-
-  void interpreter::execute_command_line_file (const std::string& fname)
-  {
-    octave::unwind_protect frame;
-
-    octave_save_signal_mask ();
-
-    octave::can_interrupt = true;
-
-    octave_signal_hook = octave::signal_handler;
-    octave_interrupt_hook = 0;
-    octave_bad_alloc_hook = 0;
-
-    octave::catch_interrupts ();
-
-    octave_initialized = true;
-
-    frame.add_method (this, &interpreter::interactive, m_interactive);
-
-    frame.add_method (m_app_context,
-                      &application::program_invocation_name,
-                      application::program_invocation_name ());
-
-    frame.add_method (m_app_context,
-                      &application::program_name,
-                      application::program_name ());
-
-    m_interactive = false;
-
-    m_app_context->set_program_names (fname);
-
-    std::string context;
-    bool verbose = false;
-    bool require_file = true;
-
-    safe_source_file (fname, context, verbose, require_file, "octave");
-  }
 }
 
 // embedded is int here because octave_main is extern "C".
 
 int
 octave_main (int argc, char **argv, int embedded)
 {
   octave::sys::env::set_program_name (argv[0]);
diff --git a/libinterp/octave.h b/libinterp/octave.h
--- a/libinterp/octave.h
+++ b/libinterp/octave.h
@@ -168,18 +168,18 @@ namespace octave
     string_vector m_all_args;
 
     // Arguments remaining after parsing.
     string_vector m_remaining_args;
   };
 
   // The application object contains a pointer to the current
   // interpreter and the interpreter contains a pointer back to the
-  // application context so we need a forward declaration for one of
-  // them...
+  // application context so we need a forward declaration for one (or
+  // both) of them...
 
   class interpreter;
 
   // Base class for an Octave application.
 
   class OCTINTERP_API application
   {
   public:
@@ -325,49 +325,16 @@ namespace octave
   private:
 
     // No copying, at least not yet...
 
     embedded_application (const embedded_application&);
 
     embedded_application& operator = (const embedded_application&);
   };
-
-  class OCTINTERP_API interpreter
-  {
-  public:
-
-    interpreter (application *app_context = 0, bool embedded = false);
-
-    ~interpreter (void) { }
-
-    int execute (void);
-
-    int execute_eval_option_code (const std::string& code);
-
-    void execute_command_line_file (const std::string& fname);
-
-    bool interactive (void) const { return m_interactive; }
-    void interactive (bool arg) { m_interactive = arg; }
-
-  private:
-
-    // No copying, at least not yet...
-
-    interpreter (const interpreter&);
-
-    interpreter& operator = (const interpreter&);
-
-    application *m_app_context;
-
-    bool m_embedded;
-
-    // TRUE means this is an interactive interpreter (forced or not).
-    bool m_interactive = false;
-  };
 }
 
 #endif
 
 #if defined  (__cplusplus)
 extern "C" {
 #endif
 
diff --git a/libinterp/parse-tree/lex.ll b/libinterp/parse-tree/lex.ll
--- a/libinterp/parse-tree/lex.ll
+++ b/libinterp/parse-tree/lex.ll
@@ -101,24 +101,24 @@ object) relevant global values before an
 // times.
 
 #include "Cell.h"
 #include "comment-list.h"
 #include "defun.h"
 #include "error.h"
 #include "errwarn.h"
 #include "input.h"
+#include "interpreter.h"
 #include "lex.h"
 #include "octave.h"
 #include "ov.h"
 #include "parse.h"
 #include "pt-all.h"
 #include "symtab.h"
 #include "token.h"
-#include "toplev.h"
 #include "utils.h"
 #include "variables.h"
 #include <oct-parse.h>
 #include <oct-gperf.h>
 
 // FIXME: with bison 3.x, OCTAVE_STYPE appears in the generated
 // oct-parse.h file, but there is no definition for YYSTYPE, which is
 // needed by the code that is generated by flex.  I can't seem to find a
@@ -2316,18 +2316,17 @@ octave_base_lexer::reset (void)
   symtab_context.clear ();
 
   // We do want a prompt by default.
   promptflag (1);
 
   // Only ask for input from stdin if we are expecting interactive
   // input.
 
-  if (! quitting_gracefully
-      && octave::application::interactive ()
+  if (octave::application::interactive ()
       && ! (reading_fcn_file
             || reading_classdef_file
             || reading_script_file
             || input_from_eval_string ()))
     yyrestart (stdin, scanner);
 
   lexical_feedback::reset ();
 
diff --git a/libinterp/parse-tree/oct-parse.in.yy b/libinterp/parse-tree/oct-parse.in.yy
--- a/libinterp/parse-tree/oct-parse.in.yy
+++ b/libinterp/parse-tree/oct-parse.in.yy
@@ -56,25 +56,25 @@ along with Octave; see the file COPYING.
 #include "call-stack.h"
 #include "comment-list.h"
 #include "defaults.h"
 #include "defun.h"
 #include "dirfns.h"
 #include "dynamic-ld.h"
 #include "error.h"
 #include "input.h"
+#include "interpreter.h"
 #include "lex.h"
 #include "load-path.h"
 #include "oct-hist.h"
 #include "oct-map.h"
 #include "ov-classdef.h"
 #include "ov-fcn-handle.h"
 #include "ov-usr-fcn.h"
 #include "ov-null-mat.h"
-#include "toplev.h"
 #include "pager.h"
 #include "parse.h"
 #include "pt-all.h"
 #include "pt-eval.h"
 #include "pt-funcall.h"
 #include "symtab.h"
 #include "token.h"
 #include "unwind-prot.h"
diff --git a/libinterp/parse-tree/pt-arg-list.cc b/libinterp/parse-tree/pt-arg-list.cc
--- a/libinterp/parse-tree/pt-arg-list.cc
+++ b/libinterp/parse-tree/pt-arg-list.cc
@@ -36,17 +36,17 @@ along with Octave; see the file COPYING.
 #include "ov.h"
 #include "ov-usr-fcn.h"
 #include "parse.h"
 #include "pt-arg-list.h"
 #include "pt-exp.h"
 #include "pt-id.h"
 #include "pt-pr-code.h"
 #include "pt-walk.h"
-#include "toplev.h"
+#include "interpreter.h"
 #include "unwind-prot.h"
 
 // Argument lists.
 
 tree_argument_list::~tree_argument_list (void)
 {
   while (! empty ())
     {
diff --git a/libinterp/parse-tree/pt-bp.h b/libinterp/parse-tree/pt-bp.h
--- a/libinterp/parse-tree/pt-bp.h
+++ b/libinterp/parse-tree/pt-bp.h
@@ -24,17 +24,17 @@ along with Octave; see the file COPYING.
 #define octave_pt_bp_h 1
 
 #include "octave-config.h"
 
 #include "input.h"
 #include "ov-usr-fcn.h"
 #include "pt-walk.h"
 #include "pt-pr-code.h"
-#include "toplev.h"
+#include "interpreter.h"
 
 class tree;
 class tree_decl_command;
 
 static std::string pt_bp_empty_string ("");
 class
 tree_breakpoint : public tree_walker
 {
diff --git a/libinterp/parse-tree/pt-eval.cc b/libinterp/parse-tree/pt-eval.cc
--- a/libinterp/parse-tree/pt-eval.cc
+++ b/libinterp/parse-tree/pt-eval.cc
@@ -32,23 +32,23 @@ along with Octave; see the file COPYING.
 #include <typeinfo>
 
 #include "call-stack.h"
 #include "debug.h"
 #include "defun.h"
 #include "error.h"
 #include "errwarn.h"
 #include "input.h"
+#include "interpreter.h"
 #include "ov-fcn-handle.h"
 #include "ov-usr-fcn.h"
 #include "variables.h"
 #include "pt-all.h"
 #include "pt-eval.h"
 #include "symtab.h"
-#include "toplev.h"
 #include "unwind-prot.h"
 
 //FIXME: This should be part of tree_evaluator
 #include "pt-jit.h"
 
 static tree_evaluator std_evaluator;
 
 tree_evaluator *current_evaluator = &std_evaluator;
diff --git a/liboctave/cruft/misc/cquit.c b/liboctave/cruft/misc/cquit.c
--- a/liboctave/cruft/misc/cquit.c
+++ b/liboctave/cruft/misc/cquit.c
@@ -54,9 +54,13 @@ octave_jump_to_enclosing_context (void)
 }
 
 sig_atomic_t octave_interrupt_immediately = 0;
 
 sig_atomic_t octave_interrupt_state = 0;
 
 sig_atomic_t octave_exception_state = 0;
 
+sig_atomic_t octave_exit_exception_status = 0;
+
+sig_atomic_t octave_exit_exception_safe_to_return = 0;
+
 volatile sig_atomic_t octave_signal_caught = 0;
diff --git a/liboctave/cruft/misc/quit.cc b/liboctave/cruft/misc/quit.cc
--- a/liboctave/cruft/misc/quit.cc
+++ b/liboctave/cruft/misc/quit.cc
@@ -43,16 +43,24 @@ octave_handle_signal (void)
 
   if (octave_interrupt_state > 0)
     {
       octave_interrupt_state = -1;
       octave_throw_interrupt_exception ();
     }
 }
 
+extern OCTAVE_API void
+clean_up_and_exit (int exit_status, bool safe_to_return)
+{
+  octave_exception_state = octave_quit_exception;
+
+  throw octave_exit_exception (exit_status, safe_to_return);
+}
+
 void
 octave_throw_interrupt_exception (void)
 {
   if (octave_interrupt_hook)
     octave_interrupt_hook ();
 
   throw octave_interrupt_exception ();
 }
@@ -93,13 +101,18 @@ octave_rethrow_exception (void)
         case octave_exec_exception:
           octave_throw_execution_exception ();
           break;
 
         case octave_alloc_exception:
           octave_throw_bad_alloc ();
           break;
 
+        case octave_quit_exception:
+          clean_up_and_exit (octave_exit_exception_status,
+                             octave_exit_exception_safe_to_return);
+          break;
+
         default:
           break;
         }
     }
 }
diff --git a/liboctave/cruft/misc/quit.h b/liboctave/cruft/misc/quit.h
--- a/liboctave/cruft/misc/quit.h
+++ b/liboctave/cruft/misc/quit.h
@@ -54,16 +54,17 @@ OCTAVE_API extern octave_jmp_buf current
 
 OCTAVE_API extern void octave_save_current_context (void *);
 
 OCTAVE_API extern void octave_restore_current_context (void *);
 
 OCTAVE_NORETURN OCTAVE_API extern void octave_jump_to_enclosing_context (void);
 
 #if defined (__cplusplus)
+
 class
 octave_execution_exception
 {
 public:
 
   octave_execution_exception (void) : m_stack_trace () { }
 
   octave_execution_exception (const octave_execution_exception& x)
@@ -95,52 +96,99 @@ public:
   }
 
 private:
 
   std::string m_stack_trace;
 };
 
 class
+octave_exit_exception
+{
+public:
+
+  octave_exit_exception (int exit_status = 0, bool safe_to_return = false)
+    : m_exit_status (exit_status), m_safe_to_return (safe_to_return)
+  { }
+
+  octave_exit_exception (const octave_exit_exception& ex)
+    : m_exit_status (ex.m_exit_status), m_safe_to_return (ex.m_safe_to_return)
+  { }
+
+  octave_exit_exception& operator = (octave_exit_exception& ex)
+  {
+    if (this != &ex)
+      {
+        m_exit_status = ex.m_exit_status;
+        m_safe_to_return = ex.m_safe_to_return;
+      }
+
+    return *this;
+  }
+
+  ~octave_exit_exception (void) { }
+
+  int exit_status (void) const { return m_exit_status; }
+
+  bool safe_to_return (void) const { return m_safe_to_return; }
+
+private:
+
+  int m_exit_status;
+
+  bool m_safe_to_return;
+};
+
+class
 octave_interrupt_exception
 {
 };
+
 #endif
 
 enum octave_exception
 {
   octave_no_exception = 0,
   octave_exec_exception = 1,
-  octave_alloc_exception = 2
+  octave_alloc_exception = 3,
+  octave_quit_exception = 4
 };
 
 OCTAVE_API extern sig_atomic_t octave_interrupt_immediately;
 
 /*
   > 0: interrupt pending
     0: no interrupt pending
   < 0: handling interrupt
 */
 OCTAVE_API extern sig_atomic_t octave_interrupt_state;
 
 OCTAVE_API extern sig_atomic_t octave_exception_state;
 
+OCTAVE_API extern sig_atomic_t octave_exit_exception_status;
+
+OCTAVE_API extern sig_atomic_t octave_exit_exception_safe_to_return;
+
 OCTAVE_API extern volatile sig_atomic_t octave_signal_caught;
 
 OCTAVE_API extern void octave_handle_signal (void);
 
 OCTAVE_NORETURN OCTAVE_API extern void octave_throw_interrupt_exception (void);
 
 OCTAVE_NORETURN OCTAVE_API extern void octave_throw_execution_exception (void);
 
 OCTAVE_NORETURN OCTAVE_API extern void octave_throw_bad_alloc (void);
 
 OCTAVE_API extern void octave_rethrow_exception (void);
 
 #if defined (__cplusplus)
+
+extern OCTAVE_API void
+clean_up_and_exit (int exit_status, bool safe_to_return = false);
+
 inline void octave_quit (void)
 {
   if (octave_signal_caught)
     {
       octave_signal_caught = 0;
       octave_handle_signal ();
     }
 };
@@ -229,16 +277,24 @@ inline void octave_quit (void)
       octave_jump_to_enclosing_context (); \
     } \
   catch (const std::bad_alloc&) \
     { \
       octave_interrupt_immediately = saved_octave_interrupt_immediately; \
       octave_exception_state = octave_alloc_exception; \
       octave_jump_to_enclosing_context (); \
     } \
+  catch (const octave_exit_exception& ex) \
+    { \
+      octave_interrupt_immediately = saved_octave_interrupt_immediately; \
+      octave_exception_state = octave_quit_exception; \
+      octave_exit_exception_status = ex.exit_status (); \
+      octave_exit_exception_safe_to_return = ex.safe_to_return (); \
+      octave_jump_to_enclosing_context (); \
+    } \
  \
   octave_interrupt_immediately = saved_octave_interrupt_immediately
 #endif
 
 #if defined (__cplusplus)
 }
 
 /* These should only be declared for C++ code, and should also be
