# HG changeset patch
# User jwe
# Date 859790368 0
#      Mon Mar 31 06:39:28 1997 +0000
# Node ID 8c516da3c1f75aeef57e09413d5d6083266fab3d
# Parent  1bb7dc230a4befe55ac6273c71649bc5fe165b07
[project @ 1997-03-31 06:37:21 by jwe]

diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,8 +1,16 @@
+Mon Mar 31 00:37:48 1997  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* symtab.h, symtab.cc: Use bool instead of int in more places.
+	* variables.h, variables.cc: Likewise.
+	* help.cc, input.cc, lex.l, load-save.cc, parse.y, pt-fcn.cc:
+	Change callers of symbol_table::lookup to use bool instead of int,
+	and to make use of default arguments.
+
 Fri Mar 28 15:33:11 1997  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* parse.y (Vwarn_comma_in_declaration): Delete.
 	(symbols_of_parse): Delete DEFVAR for warn_comma_in_declaration.
 	(decl1): Don't allow commas in declarations.
 
 	* lsode.cc (struct LSODE_OPTIONS): Handle integer options.
 	(print_lsode_option_list, set_lsode_option, show_lsode_option): Ditto.
diff --git a/src/help.cc b/src/help.cc
--- a/src/help.cc
+++ b/src/help.cc
@@ -343,17 +343,17 @@ static void
 additional_help_message (ostream&)
 {
 }
 #endif
 
 void
 print_usage (const string& nm, int just_usage)
 {
-  symbol_record *sym_rec = global_sym_tab->lookup (nm, 0, 0);
+  symbol_record *sym_rec = global_sym_tab->lookup (nm);
   if (sym_rec)
     {
       string h = sym_rec->help ();
 
       if (h.length () > 0)
 	{
 	  octave_stdout << "\n*** " << nm << ":\n\n"
 	    << h << "\n";
diff --git a/src/input.cc b/src/input.cc
--- a/src/input.cc
+++ b/src/input.cc
@@ -668,33 +668,33 @@ generate_struct_completions (const char 
 
   prefix = strsave (text);
   ptr = strrchr (prefix, '.');
   *ptr = '\0';
 
   delete [] hint;
   hint = strsave (ptr + 1);
 
-  symbol_record *sr = curr_sym_tab->lookup (id, 0, 0);
+  symbol_record *sr = curr_sym_tab->lookup (id);
   if (! sr)
-    sr = global_sym_tab->lookup (id, 0, 0);
+    sr = global_sym_tab->lookup (id);
 
   if (sr && sr->is_defined ())
     {
       tree_fvc *tmp_fvc = sr->def ();
 
       tree_constant *def = 0;
       if (tmp_fvc->is_constant ())
 	def = static_cast<tree_constant *> (tmp_fvc);
 
       if (def && def->is_map ())
 	{
 	  if (elts && *elts)
 	    {
-	      octave_value ult = def->lookup_map_element (elts, 0, 1);
+	      octave_value ult = def->lookup_map_element (elts, false, true);
 
 	      if (ult.is_map ())
 		{
 		  Octave_map m = ult.map_value ();
 		  names = m.make_name_list ();
 		}
 	    }
 	  else
@@ -762,33 +762,33 @@ looks_like_struct (const char *nm)
   char *elts = 0;
   char *ptr = strchr (id, '.');
   if (ptr)
     {
       *ptr = '\0';
       elts = ptr + 1;
     }
 
-  symbol_record *sr = curr_sym_tab->lookup (id, 0, 0);
+  symbol_record *sr = curr_sym_tab->lookup (id);
   if (! sr)
-    sr = global_sym_tab->lookup (id, 0, 0);
+    sr = global_sym_tab->lookup (id);
 
   if (sr && sr->is_defined ())
     {
       tree_fvc *tmp_fvc = sr->def ();
 
       tree_constant *def = 0;
       if (tmp_fvc->is_constant ())
 	def = static_cast<tree_constant *> (tmp_fvc);
 
       if (def && def->is_map ())
 	{
 	  if (elts && *elts)
 	    {
-	      octave_value ult = def->lookup_map_element (elts, 0, 1);
+	      octave_value ult = def->lookup_map_element (elts, false, true);
 
 	      if (ult.is_map ())
 		retval = 1;
 	    }
 	  else
 	    retval = 1;
 	}
     }
diff --git a/src/lex.l b/src/lex.l
--- a/src/lex.l
+++ b/src/lex.l
@@ -1074,31 +1074,31 @@ is_keyword (const string& s)
 }
 
 // Try to find an identifier.  All binding to global or builtin
 // variables occurs when expressions are evaluated.
 
 static symbol_record *
 lookup_identifier (const string& name)
 {
-  return curr_sym_tab->lookup (name, 1, 0);
+  return curr_sym_tab->lookup (name, true);
 }
 
 static bool
 is_variable (const string& name)
 {
-  symbol_record *sr = curr_sym_tab->lookup (name, 0, 0);
+  symbol_record *sr = curr_sym_tab->lookup (name);
 
   return sr && sr->is_variable ();
 }
 
 static void
 force_local_variable (const string& name)
 {
-  symbol_record *sr = curr_sym_tab->lookup (name, 1, 0);
+  symbol_record *sr = curr_sym_tab->lookup (name, true);
 
   if (sr)
     sr->define (octave_value ());
 }
 
 // Grab the help text from an function file.  Always overwrites the
 // current contents of help_buf.
 
diff --git a/src/load-save.cc b/src/load-save.cc
--- a/src/load-save.cc
+++ b/src/load-save.cc
@@ -88,17 +88,17 @@ enum load_save_format
 // Assumes TC is defined.
 
 static void
 install_loaded_variable (int force, char *name, const octave_value& val,
 			 int global, char *doc)
 {
   // Is there already a symbol by this name?  If so, what is it?
 
-  symbol_record *lsr = curr_sym_tab->lookup (name, 0, 0);
+  symbol_record *lsr = curr_sym_tab->lookup (name);
 
   int is_undefined = 1;
   int is_variable = 0;
   int is_function = 0;
   int is_global = 0;
 
   if (lsr)
     {
@@ -111,45 +111,45 @@ install_loaded_variable (int force, char
   symbol_record *sr = 0;
 
   if (global)
     {
       if (is_global || is_undefined)
 	{
 	  if (force || is_undefined)
 	    {
-	      lsr = curr_sym_tab->lookup (name, 1, 0);
+	      lsr = curr_sym_tab->lookup (name, true);
 	      link_to_global_variable (lsr);
 	      sr = lsr;
 	    }
 	  else
 	    {
 	      warning ("load: global variable name `%s' exists.", name);
 	      warning ("use `load -force' to overwrite");
 	    }
 	}
       else if (is_function)
 	{
 	  if (force)
 	    {
-	      lsr = curr_sym_tab->lookup (name, 1, 0);
+	      lsr = curr_sym_tab->lookup (name, true);
 	      link_to_global_variable (lsr);
 	      sr = lsr;
 	    }
 	  else
 	    {
 	      warning ("load: `%s' is currently a function in this scope", name);
 	      warning ("`load -force' will load variable and hide function");
 	    }
 	}
       else if (is_variable)
 	{
 	  if (force)
 	    {
-	      lsr = curr_sym_tab->lookup (name, 1, 0);
+	      lsr = curr_sym_tab->lookup (name, true);
 	      link_to_global_variable (lsr);
 	      sr = lsr;
 	    }
 	  else
 	    {
 	      warning ("load: local variable name `%s' exists.", name);
 	      warning ("use `load -force' to overwrite");
 	    }
@@ -158,45 +158,45 @@ install_loaded_variable (int force, char
 	error ("load: unable to load data for unknown symbol type");
     }
   else
     {
       if (is_global)
 	{
 	  if (force || is_undefined)
 	    {
-	      lsr = curr_sym_tab->lookup (name, 1, 0);
+	      lsr = curr_sym_tab->lookup (name, true);
 	      link_to_global_variable (lsr);
 	      sr = lsr;
 	    }
 	  else
 	    {
 	      warning ("load: global variable name `%s' exists.", name);
 	      warning ("use `load -force' to overwrite");
 	    }
 	}
       else if (is_function)
 	{
 	  if (force)
 	    {
-	      lsr = curr_sym_tab->lookup (name, 1, 0);
+	      lsr = curr_sym_tab->lookup (name, true);
 	      link_to_global_variable (lsr);
 	      sr = lsr;
 	    }
 	  else
 	    {
 	      warning ("load: `%s' is currently a function in this scope", name);
 	      warning ("`load -force' will load variable and hide function");
 	    }
 	}
       else if (is_variable || is_undefined)
 	{
 	  if (force || is_undefined)
 	    {
-	      lsr = curr_sym_tab->lookup (name, 1, 0);
+	      lsr = curr_sym_tab->lookup (name, true);
 	      sr = lsr;
 	    }
 	  else
 	    {
 	      warning ("load: local variable name `%s' exists.", name);
 	      warning ("use `load -force' to overwrite");
 	    }
 	}
diff --git a/src/parse.y b/src/parse.y
--- a/src/parse.y
+++ b/src/parse.y
@@ -1373,17 +1373,17 @@ maybe_convert_to_ans_assign (tree_expres
       return expr;
     }
   else
     {
       // XXX FIXME XXX -- making ans_id static, passing its address to
       // tree_simple_assignment_expression along with a flag to not
       // delete it seems to create a memory leak.  Hmm.
 
-      static symbol_record *sr = global_sym_tab->lookup ("ans", 1, 0);
+      static symbol_record *sr = global_sym_tab->lookup ("ans", true);
       tree_identifier *ans_id = new tree_identifier (sr);
 
       int l = expr->line ();
       int c = expr->column ();
 
       return new tree_simple_assignment_expression (ans_id, expr, 0, 1, l, c);
     }
 }
@@ -2187,17 +2187,17 @@ frob_function_def (tree_identifier *id, 
 	   && curr_fcn_file_name == id_name)
     {
       warning ("function `%s' defined within script file `%s'",
 	       id_name.c_str (), curr_fcn_file_full_name.c_str ());
     }
 
   top_level_sym_tab->clear (id_name);
 
-  symbol_record *sr = global_sym_tab->lookup (id_name, 0, 0);
+  symbol_record *sr = global_sym_tab->lookup (id_name);
 
   if (sr)
     fcn->stash_symtab_ptr (sr);
   else
     panic_impossible ();
 
   id->define (fcn);
 
diff --git a/src/pt-fcn.cc b/src/pt-fcn.cc
--- a/src/pt-fcn.cc
+++ b/src/pt-fcn.cc
@@ -67,18 +67,18 @@ extern int breaking;
 // Nonzero means we're returning from a function.
 extern int returning;
 
 // User defined functions.
 
 void
 tree_function::install_nargin_and_nargout (void)
 {
-  nargin_sr = sym_tab->lookup ("nargin", 1, 0);
-  nargout_sr = sym_tab->lookup ("nargout", 1, 0);
+  nargin_sr = sym_tab->lookup ("nargin", true);
+  nargout_sr = sym_tab->lookup ("nargout", true);
 }
 
 void
 tree_function::bind_nargin_and_nargout (int nargin, int nargout)
 {
   nargin_sr->define (static_cast<double> (nargin));
   nargout_sr->define (static_cast<double> (nargout));
 }
diff --git a/src/symtab.cc b/src/symtab.cc
--- a/src/symtab.cc
+++ b/src/symtab.cc
@@ -81,66 +81,66 @@ symbol_def::init_state (void)
   count = 0;
 }
 
 symbol_def::~symbol_def (void)
 {
   delete definition;
 }
 
-int
+bool
 symbol_def::is_variable (void) const
 {
   return (type & USER_VARIABLE || type & BUILTIN_VARIABLE);
 }
 
-int
+bool
 symbol_def::is_function (void) const
 {
   return (type & USER_FUNCTION || type & BUILTIN_FUNCTION);
 }
 
-int
+bool
 symbol_def::is_user_variable (void) const
 {
   return (type & USER_VARIABLE);
 }
 
-int
+bool
 symbol_def::is_text_function (void) const
 {
   return (type & TEXT_FUNCTION);
 }
 
-int
+bool
 symbol_def::is_mapper_function (void) const
 {
   return (type & MAPPER_FUNCTION);
 }
 
-int
+bool
 symbol_def::is_user_function (void) const
 {
   return (type & USER_FUNCTION);
 }
 
-int
+bool
 symbol_def::is_builtin_variable (void) const
 {
   return (type & BUILTIN_VARIABLE);
 }
 
-int
+bool
 symbol_def::is_builtin_function (void) const
 {
   return (type & BUILTIN_FUNCTION);
 }
 
 // XXX FIXME XXX
-int
+bool
 symbol_def::is_map_element (const string& /* elts */) const
 {
   return 0;
 }
 
 void
 symbol_def::define (tree_constant *t)
 {
@@ -256,102 +256,102 @@ symbol_record::help (void) const
   if (definition)
     retval = definition->help ();
   return retval;
 }
 
 tree_fvc *
 symbol_record::def (void) const
 {
-  return definition ? definition->def () : 0;
+  return definition ? definition->def () : false;
 }
 
 void
 symbol_record::rename (const string& new_name)
 {
   if (! read_only_error ("rename"))
     nm = new_name;
 }
 
-int
+bool
 symbol_record::is_function (void) const
 {
-  return definition ? definition->is_function () : 0;
+  return definition ? definition->is_function () : false;
 }
 
-int
+bool
 symbol_record::is_text_function (void) const
 {
-  return definition ? definition->is_text_function () : 0;
+  return definition ? definition->is_text_function () : false;
 }
 
-int
+bool
 symbol_record::is_mapper_function (void) const
 {
-  return definition ? definition->is_mapper_function () : 0;
+  return definition ? definition->is_mapper_function () : false;
 }
 
-int
+bool
 symbol_record::is_user_function (void) const
 {
-  return definition ? definition->is_user_function () : 0;
+  return definition ? definition->is_user_function () : false;
 }
 
-int
+bool
 symbol_record::is_builtin_function (void) const
 {
-  return definition ? definition->is_builtin_function () : 0;
+  return definition ? definition->is_builtin_function () : false;
 }
 
-int
+bool
 symbol_record::is_variable (void) const
 {
-  return definition ? definition->is_variable () : 0;
+  return definition ? definition->is_variable () : false;
 }
 
-int
+bool
 symbol_record::is_user_variable (void) const
 {
-  return definition ? definition->is_user_variable () : 0;
+  return definition ? definition->is_user_variable () : false;
 }
 
-int
+bool
 symbol_record::is_builtin_variable (void) const
 {
-  return definition ? definition->is_builtin_variable () : 0;
+  return definition ? definition->is_builtin_variable () : false;
 }
 
-int
+bool
 symbol_record::is_map_element (const string& elts) const
 {
-  return definition ? definition->is_map_element (elts) : 0;
+  return definition ? definition->is_map_element (elts) : false;
 }
 
 unsigned
 symbol_record::type (void) const
 {
-  return definition ? definition->type : 0;
+  return definition ? definition->type : false;
 }
 
-int
+bool
 symbol_record::is_defined (void) const
 {
-  return definition ? (definition->def () != 0) : 0;
+  return definition ? (definition->def () != 0) : false;
 }
 
-int
+bool
 symbol_record::is_read_only (void) const
 {
-  return definition ? definition->read_only : 0;
+  return definition ? definition->read_only : false;
 }
 
-int
+bool
 symbol_record::is_eternal (void) const
 {
-  return definition ? definition->eternal : 0;
+  return definition ? definition->eternal : false;
 }
 
 void
 symbol_record::protect (void)
 {
   if (definition)
     {
       definition->protect ();
@@ -428,17 +428,17 @@ symbol_record::define (tree_constant *t)
 int
 symbol_record::define (const octave_value& v)
 {
   tree_constant *t = new tree_constant (v);
   return define (t);
 }
 
 int
-symbol_record::define (tree_builtin *t, int text_fcn)
+symbol_record::define (tree_builtin *t, bool text_fcn)
 {
   if (read_only_error ("redefine"))
     return 0;
 
   if (is_variable ())
     {
       symbol_def *old_def = pop_def ();
       maybe_delete (old_def);
@@ -457,17 +457,17 @@ symbol_record::define (tree_builtin *t, 
   symbol_def *new_def = new symbol_def (t, fcn_type);
   push_def (new_def);
   definition->count = 1;
 
   return 1;
 }
 
 int
-symbol_record::define (tree_function *t, int text_fcn)
+symbol_record::define (tree_function *t, bool text_fcn)
 {
   if (read_only_error ("redefine"))
     return 0;
 
   if (is_variable ())
     {
       symbol_def *old_def = pop_def ();
       maybe_delete (old_def);
@@ -552,17 +552,17 @@ symbol_record::clear (void)
     {
       symbol_def *old_def = pop_def ();
       count = maybe_delete (old_def);
     }
   return count;
 }
 
 void
-symbol_record::alias (symbol_record *s, int force)
+symbol_record::alias (symbol_record *s, bool force)
 {
   sv_fcn = s->sv_fcn;
 
   if (force && ! s->definition)
     {
       s->definition = new symbol_def ();
       definition = s->definition;
       definition->count = 2; // Yes, this is correct.
@@ -575,46 +575,46 @@ symbol_record::alias (symbol_record *s, 
 }
 
 void
 symbol_record::mark_as_formal_parameter (void)
 {
   formal_param = 1;
 }
 
-int
+bool
 symbol_record::is_formal_parameter (void) const
 {
   return formal_param;
 }
 
 void
 symbol_record::mark_as_linked_to_global (void)
 {
   linked_to_global = 1;
 }
 
-int
+bool
 symbol_record::is_linked_to_global (void) const
 {
   return linked_to_global;
 }
 
 void
 symbol_record::mark_as_static (void)
 {
   if (is_linked_to_global ())
     error ("can't make global variable static");
   else if (is_formal_parameter ())
     error ("can't make formal parameter static");
   else
     tagged_static = 1;
 }
 
-int
+bool
 symbol_record::is_static (void) const
 {
   return tagged_static;
 }
 
 octave_value
 symbol_record::variable_value (void) const
 {
@@ -807,41 +807,41 @@ symbol_record_info::operator = (const sy
       eternal = s.eternal;
       read_only = s.read_only;
       nm = s.nm;
       const_type = s.const_type;
     }
   return *this;
 }
 
-int
+bool
 symbol_record_info::is_defined (void) const
 {
   return initialized;
 }
 
-int
+bool
 symbol_record_info::is_read_only (void) const
 {
   return read_only;
 }
 
-int
+bool
 symbol_record_info::is_eternal (void) const
 {
   return eternal;
 }
 
-int
+bool
 symbol_record_info::hides_fcn (void) const
 {
   return (hides & SR_INFO_USER_FUNCTION);
 }
 
-int
+bool
 symbol_record_info::hides_builtin (void) const
 {
   return (hides & SR_INFO_BUILTIN_FUNCTION);
 }
 
 string
 symbol_record_info::type_name (void) const
 {
@@ -859,17 +859,17 @@ symbol_record_info::type_name (void) con
 	retval = "builtin function";
     }
   else
     retval = const_type;
 
   return retval;
 }
 
-int
+bool
 symbol_record_info::is_function (void) const
 {
   return (type == symbol_def::USER_FUNCTION
 	  || type == symbol_def::BUILTIN_FUNCTION
 	  || symbol_def::TEXT_FUNCTION
 	  || symbol_def::MAPPER_FUNCTION);
 }
 
@@ -893,17 +893,17 @@ symbol_record_info::name (void) const
 
 // A symbol table.
 
 symbol_table::symbol_table (void)
 {
 }
 
 symbol_record *
-symbol_table::lookup (const string& nm, int insert, int warn)
+symbol_table::lookup (const string& nm, bool insert, bool warn)
 {
   int index = hash (nm) & HASH_MASK;
 
   symbol_record *ptr = table[index].next ();
 
   while (ptr)
     {
       if (ptr->name () == nm)
@@ -955,17 +955,17 @@ symbol_table::rename (const string& old_
       ptr = ptr->next ();
     }
 
   error ("unable to rename `%s' to `%s'", old_name.c_str (),
 	 new_name.c_str ());
 }
 
 void
-symbol_table::clear (int clear_user_functions)
+symbol_table::clear (bool clear_user_functions)
 {
   for (int i = 0; i < HASH_TABLE_SIZE; i++)
     {
       symbol_record *ptr = table[i].next ();
 
       while (ptr)
 	{
 	  if (ptr->is_user_variable ()
@@ -975,17 +975,17 @@ symbol_table::clear (int clear_user_func
 	    }
 
 	  ptr = ptr->next ();
 	}
     }
 }
 
 int
-symbol_table::clear (const string& nm, int clear_user_functions)
+symbol_table::clear (const string& nm, bool clear_user_functions)
 {
   int index = hash (nm) & HASH_MASK;
 
   symbol_record *ptr = table[index].next ();
 
   while (ptr)
     {
       if (ptr->name () == nm
@@ -1042,17 +1042,17 @@ matches_patterns (const string& name, co
   return 0;
 }
 
 // This function should probably share code with symbol_table::list.
 // XXX FIXME XXX
 
 symbol_record_info *
 symbol_table::long_list (int& count, const string_vector& pats,
-			 int npats, int sort, unsigned type,
+			 int npats, bool sort, unsigned type,
 			 unsigned scope) const 
 {
   count = 0;
   int n = size ();
   if (n == 0)
     return 0;
 
   symbol_record_info *symbols = new symbol_record_info [n+1];
@@ -1082,17 +1082,17 @@ symbol_table::long_list (int& count, con
     qsort (symbols, count, sizeof (symbol_record_info),
 	   symbol_record_info_cmp);
 
   return symbols;
 }
 
 string_vector
 symbol_table::list (int& count, const string_vector& pats, int npats,
-		    int sort, unsigned type, unsigned scope) const
+		    bool sort, unsigned type, unsigned scope) const
 {
   count = 0;
   int n = size ();
   if (n == 0)
     return 0;
 
   string_vector symbols (n);
 
@@ -1200,30 +1200,30 @@ symbol_table::hash (const string& str)
   unsigned h = 0;
   for (unsigned i = 0; i < str.length (); i++)
     h = h * 33 + str[i];
   return h;
 }
 
 // Return nonzero if S is a valid identifier.
 
-int
+bool
 valid_identifier (const char *s)
 {
   if (! s || ! (isalnum (*s) || *s == '_'))
-     return 0;
+     return false;
 
   while (*++s != '\0')
     if (! (isalnum (*s) || *s == '_'))
-      return 0;
+      return false;
 
-  return 1;
+  return true;
 }
 
-int
+bool
 valid_identifier (const string& s)
 {
   return valid_identifier (s.c_str ());
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
diff --git a/src/symtab.h b/src/symtab.h
--- a/src/symtab.h
+++ b/src/symtab.h
@@ -63,25 +63,25 @@ public:
 
   symbol_def (void);
   symbol_def (tree_constant *t);
   symbol_def (tree_builtin *t, unsigned fcn_type = 0);
   symbol_def (tree_function *t, unsigned fcn_type = 0);
 
   ~symbol_def (void);
 
-  int is_variable (void) const;
-  int is_function (void) const;
-  int is_text_function (void) const;
-  int is_mapper_function (void) const;
-  int is_user_variable (void) const;
-  int is_user_function (void) const;
-  int is_builtin_variable (void) const;
-  int is_builtin_function (void) const;
-  int is_map_element (const string& elts) const;
+  bool is_variable (void) const;
+  bool is_function (void) const;
+  bool is_text_function (void) const;
+  bool is_mapper_function (void) const;
+  bool is_user_variable (void) const;
+  bool is_user_function (void) const;
+  bool is_builtin_variable (void) const;
+  bool is_builtin_function (void) const;
+  bool is_map_element (const string& elts) const;
 
   void define (tree_constant *t);
   void define (tree_builtin *t, unsigned fcn_type = 0);
   void define (tree_function *t, unsigned fcn_type = 0);
 
   void protect (void);
   void unprotect (void);
   void make_eternal (void);
@@ -134,59 +134,59 @@ public:
   ~symbol_record (void) { }
 
   string name (void) const;
   string help (void) const; 
   tree_fvc *def (void) const;
 
   void rename (const string& new_name);
 
-  int is_function (void) const;
-  int is_user_function (void) const;
-  int is_text_function (void) const;
-  int is_mapper_function (void) const;
-  int is_builtin_function (void) const;
-  int is_variable (void) const;
-  int is_user_variable (void) const;
-  int is_builtin_variable (void) const;
-  int is_map_element (const string& elts) const;
+  bool is_function (void) const;
+  bool is_user_function (void) const;
+  bool is_text_function (void) const;
+  bool is_mapper_function (void) const;
+  bool is_builtin_function (void) const;
+  bool is_variable (void) const;
+  bool is_user_variable (void) const;
+  bool is_builtin_variable (void) const;
+  bool is_map_element (const string& elts) const;
 
   unsigned type (void) const;
 
-  int is_defined (void) const;
-  int is_read_only (void) const;
-  int is_eternal (void) const;
+  bool is_defined (void) const;
+  bool is_read_only (void) const;
+  bool is_eternal (void) const;
 
   void protect (void);
   void unprotect (void);
   void make_eternal (void);
 
   void set_sv_function (sv_Function f);
 
   int define (tree_constant *t);
   int define (const octave_value& v);
-  int define (tree_builtin *t, int text_fcn = 0);
-  int define (tree_function *t, int text_fcn = 0);
+  int define (tree_builtin *t, bool text_fcn = false);
+  int define (tree_function *t, bool text_fcn = false);
   int define_as_fcn (const octave_value& v);
   int define_builtin_var (const octave_value& v);
 
   void document (const string& h);
 
   int clear (void);
 
-  void alias (symbol_record *s, int force = 0);
+  void alias (symbol_record *s, bool force = false);
 
   void mark_as_formal_parameter (void);
-  int is_formal_parameter (void) const;
+  bool is_formal_parameter (void) const;
 
   void mark_as_linked_to_global (void);
-  int is_linked_to_global (void) const;
+  bool is_linked_to_global (void) const;
 
   void mark_as_static (void);
-  int is_static (void) const;
+  bool is_static (void) const;
 
   octave_value variable_value (void) const;
   octave_value& variable_reference (void);
 
   symbol_record *next (void) const;
 
   void chain (symbol_record *s);
 
@@ -230,37 +230,37 @@ public:
   symbol_record_info (const symbol_record& s);
 
   symbol_record_info (const symbol_record_info& s);
 
   ~symbol_record_info (void) { }
 
   symbol_record_info& operator = (const symbol_record_info& s);
 
-  int is_defined (void) const;
-  int is_read_only (void) const;
-  int is_eternal (void) const;
-  int hides_fcn (void) const;
-  int hides_builtin (void) const;
+  bool is_defined (void) const;
+  bool is_read_only (void) const;
+  bool is_eternal (void) const;
+  bool hides_fcn (void) const;
+  bool hides_builtin (void) const;
   string type_name (void) const;
-  int is_function (void) const;
+  bool is_function (void) const;
   int rows (void) const;
   int columns (void) const;
   string name (void) const;
 
   enum HIDES
     {
       SR_INFO_NONE = 0,
       SR_INFO_USER_FUNCTION = 1,
       SR_INFO_BUILTIN_FUNCTION = 2
     };
 
 private:
 
-  int initialized;
+  bool initialized;
   int nr;
   int nc;
   unsigned type : 6;
   unsigned hides : 2;
   unsigned eternal : 1;
   unsigned read_only : 1;
   string nm;
   string const_type;
@@ -285,52 +285,54 @@ private:
 
 class
 symbol_table
 {
 public:
 
   symbol_table (void);
 
-  symbol_record *lookup (const string& nm, int insert = 0, int warn = 0);
+  symbol_record *lookup (const string& nm, bool insert = false,
+			 bool warn = false);
 
   void rename (const string& old_name, const string& new_name);
 
-  void clear (int clear_user_functions = 1);
-  int clear (const string& nm, int clear_user_functions = 1);
+  void clear (bool clear_user_functions = true);
+  int clear (const string& nm, bool clear_user_functions = true);
 
   int size (void) const;
 
   symbol_record_info *
   long_list (int& count, const string_vector& pats = string_vector (),
-	     int npats = 0, int sort = 0, unsigned type = SYMTAB_ALL_TYPES,
+	     int npats = 0, bool sort = false,
+	     unsigned type = SYMTAB_ALL_TYPES,
 	     unsigned scope = SYMTAB_ALL_SCOPES) const;
 
   string_vector
   list (int& count, const string_vector& pats = string_vector (),
-	int npats = 0, int sort = 0, unsigned type = SYMTAB_ALL_TYPES,
+	int npats = 0, bool sort = false, unsigned type = SYMTAB_ALL_TYPES,
 	unsigned scope = SYMTAB_ALL_SCOPES) const;
 
   symbol_record **glob (int& count, const string& pat = string ("*"),
 			unsigned type = SYMTAB_ALL_TYPES,
 			unsigned scope = SYMTAB_ALL_SCOPES) const;
 
   void push_context (void);
   void pop_context (void);
 
 private:
 
   unsigned int hash (const string& s);
 
   symbol_record table[HASH_TABLE_SIZE];
 };
 
-extern int valid_identifier (const char *s);
+extern bool valid_identifier (const char *s);
 
-extern int valid_identifier (const string& s);
+extern bool valid_identifier (const string& s);
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/variables.cc b/src/variables.cc
--- a/src/variables.cc
+++ b/src/variables.cc
@@ -188,17 +188,17 @@ initialize_symbol_tables (void)
 
 // Attributes of variables and functions.
 
 // Is this variable a builtin?
 
 bool
 is_builtin_variable (const string& name)
 {
-  symbol_record *sr = global_sym_tab->lookup (name, 0, 0);
+  symbol_record *sr = global_sym_tab->lookup (name);
   return (sr && sr->is_builtin_variable ());
 }
 
 // Is this a text-style function?
 
 bool
 is_text_function_name (const string& s)
 {
@@ -224,24 +224,24 @@ is_mapper_function_name (const string& s
   return (sr && sr->is_mapper_function ());
 }
 
 // Is this function globally in this scope?
 
 bool
 is_globally_visible (const string& name)
 {
-  symbol_record *sr = curr_sym_tab->lookup (name, 0, 0);
+  symbol_record *sr = curr_sym_tab->lookup (name);
   return (sr && sr->is_linked_to_global ());
 }
 
 // Is this octave_value a valid function?
 
 tree_fvc *
-is_valid_function (const octave_value& arg, const string& warn_for, int warn)
+is_valid_function (const octave_value& arg, const string& warn_for, bool warn)
 {
   tree_fvc *ans = 0;
 
   string fcn_name;
 
   if (arg.is_string ())
     fcn_name = arg.string_value ();
 
@@ -336,17 +336,17 @@ otherwise, return 0.")
   string name = args(0).string_value ();
 
   if (error_state)
     {
       error ("is_global: expecting string argument");
       return retval;
     }
 
-  symbol_record *sr = curr_sym_tab->lookup (name, 0, 0);
+  symbol_record *sr = curr_sym_tab->lookup (name);
 
   retval = static_cast<double> (sr && sr->is_linked_to_global ());
 
   return retval;
 }
 
 DEFUN (exist, args, ,
   "exist (NAME): check if variable or file exists\n\
@@ -383,19 +383,19 @@ returns:\n\
   size_t pos = name.find ('.');
 
   if (pos != NPOS && pos > 0)
     {
       struct_elts = name.substr (pos+1);
       symbol_name = name.substr (0, pos);
     }
 
-  symbol_record *sr = curr_sym_tab->lookup (symbol_name, 0, 0);
+  symbol_record *sr = curr_sym_tab->lookup (symbol_name);
   if (! sr)
-    sr = global_sym_tab->lookup (symbol_name, 0, 0);
+    sr = global_sym_tab->lookup (symbol_name);
 
   retval = 0.0;
 
   if (sr && sr->is_variable () && sr->is_defined ())
     {
       if (struct_elts.empty () || sr->is_map_element (struct_elts))
 	retval = 1.0;
     }
@@ -641,17 +641,17 @@ restore_command_history (void *)
 static void
 safe_fclose (void *f)
 {
   if (f)
     fclose (static_cast<FILE *> (f));
 }
 
 static int
-parse_fcn_file (int exec_script, const string& ff)
+parse_fcn_file (bool exec_script, const string& ff)
 {
   begin_unwind_frame ("parse_fcn_file");
 
   int script_file_executed = 0;
 
   // Open function file and parse.
 
   int old_reading_fcn_file_state = reading_fcn_file;
@@ -749,17 +749,17 @@ parse_fcn_file (int exec_script, const s
     }
 
   run_unwind_frame ("parse_fcn_file");
 
   return script_file_executed;
 }
 
 static bool
-load_fcn_from_file (symbol_record *sym_rec, int exec_script)
+load_fcn_from_file (symbol_record *sym_rec, bool exec_script)
 {
   bool script_file_executed = false;
 
   string nm = sym_rec->name ();
 
   if (load_octave_oct_file (nm))
     {
       force_link_to_function (nm);
@@ -786,17 +786,17 @@ load_fcn_from_file (symbol_record *sym_r
 
       run_unwind_frame ("load_fcn_from_file");
     }
 
   return script_file_executed;
 }
 
 bool
-lookup (symbol_record *sym_rec, int exec_script)
+lookup (symbol_record *sym_rec, bool exec_script)
 {
   bool script_executed = false;
 
   if (! sym_rec->is_linked_to_global ())
     {
       if (sym_rec->is_defined ())
 	{
 	  if (sym_rec->is_function () && symbol_out_of_date (sym_rec))
@@ -818,19 +818,19 @@ lookup (symbol_record *sym_rec, int exec
 
 // Get the symbol record for the given name that is visible in the
 // current scope.  Reread any function definitions that appear to be
 // out of date.  If a function is available in a file but is not
 // currently loaded, this will load it and insert the name in the
 // current symbol table.
 
 symbol_record *
-lookup_by_name (const string& nm, int exec_script)
+lookup_by_name (const string& nm, bool exec_script)
 {
-  symbol_record *sym_rec = curr_sym_tab->lookup (nm, 1, 0);
+  symbol_record *sym_rec = curr_sym_tab->lookup (nm, true);
 
   lookup (sym_rec, exec_script);
 
   return sym_rec;
 }
 
 octave_value
 get_global_value (const string& nm)
@@ -854,17 +854,17 @@ get_global_value (const string& nm)
     error ("get_global_by_name: unknown symbol `%s'", nm.c_str ());
 
   return retval;
 }
 
 void
 set_global_value (const string& nm, const octave_value& val)
 {
-  symbol_record *sr = global_sym_tab->lookup (nm, 1);
+  symbol_record *sr = global_sym_tab->lookup (nm, true);
 
   if (sr)
     sr->define (val);
   else
     panic_impossible ();
 }
 
 string
@@ -892,17 +892,17 @@ get_help_from_file (const string& path)
 // Variable values.
 
 // Look for the given name in the global symbol table.  If it refers
 // to a string, return a new copy.  If not, return 0;
 
 string
 builtin_string_variable (const string& name)
 {
-  symbol_record *sr = global_sym_tab->lookup (name, 0, 0);
+  symbol_record *sr = global_sym_tab->lookup (name);
 
   // It is a prorgramming error to look for builtins that aren't.
 
   assert (sr);
 
   string retval;
 
   tree_fvc *defn = sr->def ();
@@ -921,17 +921,17 @@ builtin_string_variable (const string& n
 // Look for the given name in the global symbol table.  If it refers
 // to a real scalar, place the value in d and return 1.  Otherwise,
 // return 0.
 
 int
 builtin_real_scalar_variable (const string& name, double& d)
 {
   int status = 0;
-  symbol_record *sr = global_sym_tab->lookup (name, 0, 0);
+  symbol_record *sr = global_sym_tab->lookup (name);
 
   // It is a prorgramming error to look for builtins that aren't.
 
   assert (sr);
 
   tree_fvc *defn = sr->def ();
 
   if (defn)
@@ -950,17 +950,17 @@ builtin_real_scalar_variable (const stri
 
 // Look for the given name in the global symbol table.
 
 octave_value
 builtin_any_variable (const string& name)
 {
   octave_value retval;
 
-  symbol_record *sr = global_sym_tab->lookup (name, 0, 0);
+  symbol_record *sr = global_sym_tab->lookup (name);
 
   // It is a prorgramming error to look for builtins that aren't.
 
   assert (sr);
 
   tree_fvc *defn = sr->def ();
 
   if (defn)
@@ -978,17 +978,17 @@ builtin_any_variable (const string& name
 void
 link_to_global_variable (symbol_record *sr)
 {
   if (sr->is_linked_to_global ())
     return;
 
   string nm = sr->name ();
 
-  symbol_record *gsr = global_sym_tab->lookup (nm, 1, 0);
+  symbol_record *gsr = global_sym_tab->lookup (nm, true);
 
   if (sr->is_formal_parameter ())
     {
       error ("can't make function parameter `%s' global", nm.c_str ());
       return;
     }
 
   if (sr->is_static ())
@@ -1024,31 +1024,31 @@ link_to_global_variable (symbol_record *
 }
 
 // Make the definition of the symbol record sr be the same as the
 // definition of the builtin variable of the same name.
 
 void
 link_to_builtin_variable (symbol_record *sr)
 {
-  symbol_record *tmp_sym = global_sym_tab->lookup (sr->name (), 0, 0);
+  symbol_record *tmp_sym = global_sym_tab->lookup (sr->name ());
 
   if (tmp_sym && tmp_sym->is_builtin_variable ())
     sr->alias (tmp_sym);
 }
 
 // Make the definition of the symbol record sr be the same as the
 // definition of the builtin variable or function, or user function of
 // the same name, provided that the name has not been used as a formal
 // parameter.
 
 void
 link_to_builtin_or_function (symbol_record *sr)
 {
-  symbol_record *tmp_sym = global_sym_tab->lookup (sr->name (), 0, 0);
+  symbol_record *tmp_sym = global_sym_tab->lookup (sr->name ());
 
   if (tmp_sym
       && (tmp_sym->is_builtin_variable () || tmp_sym->is_function ())
       && ! tmp_sym->is_formal_parameter ())
     sr->alias (tmp_sym);
 }
 
 // Force a link to a function in the current symbol table.  This is
@@ -1057,21 +1057,21 @@ link_to_builtin_or_function (symbol_reco
 // being defined.
 //
 // Return without doing anything if there isn't a function with the
 // given name defined in the global symbol table.
 
 void
 force_link_to_function (const string& id_name)
 {
-  symbol_record *gsr = global_sym_tab->lookup (id_name, 1, 0);
+  symbol_record *gsr = global_sym_tab->lookup (id_name, true);
   if (gsr->is_function ())
     {
       curr_sym_tab->clear (id_name);
-      symbol_record *csr = curr_sym_tab->lookup (id_name, 1, 0);
+      symbol_record *csr = curr_sym_tab->lookup (id_name, true);
       csr->alias (gsr);
     }
 }
 
 // Help stuff.  Shouldn't this go in help.cc?
 
 // It's not likely that this does the right thing now.  XXX FIXME XXX
 
@@ -1171,17 +1171,17 @@ print_long_listing (ostream& os, symbol_
     {
       print_symbol_info_line (os, *ptr);
       ptr++;
     }
 }
 
 static int
 maybe_list (const char *header, const string_vector& argv, int argc,
-	    ostream& os, int show_verbose, symbol_table
+	    ostream& os, bool show_verbose, symbol_table
 	    *sym_tab, unsigned type, unsigned scope)
 {
   int count;
   int status = 0;
   if (show_verbose)
     {
       symbol_record_info *symbols;
       symbols = sym_tab->long_list (count, argv, argc, 1, type, scope);
@@ -1231,17 +1231,17 @@ Associate a cryptic message with a varia
 	    {
 	      if (is_builtin_variable (name)
 		  || is_text_function_name (name)
 		  || is_mapper_function_name (name)
 		  || is_builtin_function_name (name))
 		error ("document: can't redefine help for built-in variables and functions");
 	      else
 		{
-		  symbol_record *sym_rec = curr_sym_tab->lookup (name, 0);
+		  symbol_record *sym_rec = curr_sym_tab->lookup (name);
 
 		  if (sym_rec)
 		    sym_rec->document (help);
 		  else
 		    error ("document: no such symbol `%s'", name.c_str ());
 		}
 	    }
 	}
@@ -1255,46 +1255,46 @@ Associate a cryptic message with a varia
 // XXX FIXME XXX -- this should take a list of regular expressions
 // naming the variables to look for.
 
 static octave_value_list
 do_who (int argc, const string_vector& argv)
 {
   octave_value_list retval;
 
-  int show_builtins = 0;
-  int show_functions = (curr_sym_tab == top_level_sym_tab);
-  int show_variables = 1;
-  int show_verbose = 0;
+  bool show_builtins = false;
+  bool show_functions = (curr_sym_tab == top_level_sym_tab);
+  bool show_variables = true;
+  bool show_verbose = false;
 
   string my_name = argv[0];
 
   if (argc > 1)
     {
-      show_functions = 0;
-      show_variables = 0;
+      show_functions = false;
+      show_variables = false;
     }
 
   int i;
   for (i = 1; i < argc; i++)
     {
       if (argv[i] == "-all" || argv[i] == "-a")
 	{
-	  show_builtins++;
-	  show_functions++;
-	  show_variables++;
+	  show_builtins = true;
+	  show_functions = true;
+	  show_variables = true;
 	}
       else if (argv[i] == "-builtins" || argv[i] == "-b")
-	show_builtins++;
+	show_builtins = true;
       else if (argv[i] == "-functions" || argv[i] == "-f")
-	show_functions++;
+	show_functions = true;
       else if (argv[i] == "-long" || argv[i] == "-l")
-	show_verbose++;
+	show_verbose = true;
       else if (argv[i] == "-variables" || argv[i] == "-v")
-	show_variables++;
+	show_variables = true;
       else if (argv[i][0] == '-')
 	warning ("%s: unrecognized option `%s'", my_name.c_str (),
 		 argv[i].c_str ());
       else
 	break;
     }
 
   int npats = argc - i;
@@ -1400,32 +1400,32 @@ character, but may not be combined.")
   return retval;
 }
 
 // Install variables and functions in the symbol tables.
 
 void
 install_builtin_mapper (const builtin_mapper_function& mf)
 {
-  symbol_record *sym_rec = global_sym_tab->lookup (mf.name, 1);
+  symbol_record *sym_rec = global_sym_tab->lookup (mf.name, true);
   sym_rec->unprotect ();
 
   tree_builtin *def = new tree_builtin (mf, mf.name);
 
   sym_rec->define (def);
 
   sym_rec->document (mf.help_string);
   sym_rec->make_eternal ();
   sym_rec->protect ();
 }
 
 void
 install_builtin_function (const builtin_function& f)
 {
-  symbol_record *sym_rec = global_sym_tab->lookup (f.name, 1);
+  symbol_record *sym_rec = global_sym_tab->lookup (f.name, true);
   sym_rec->unprotect ();
 
   tree_builtin *def = new tree_builtin (f.fcn, f.name);
 
   sym_rec->define (def, f.is_text_fcn);
 
   sym_rec->document (f.help_string);
   sym_rec->make_eternal ();
@@ -1441,20 +1441,20 @@ install_builtin_variable (const builtin_
   else
     bind_builtin_variable (v.name, v.value, v.protect, v.eternal,
 			   v.sv_function, v.help_string);
 }
 
 void
 install_builtin_variable_as_function (const string& name,
 				      const octave_value& val,
-				      int protect, int eternal,
+				      bool protect, bool eternal,
 				      const string& help)
 {
-  symbol_record *sym_rec = global_sym_tab->lookup (name, 1);
+  symbol_record *sym_rec = global_sym_tab->lookup (name, true);
   sym_rec->unprotect ();
 
   string tmp_help = help.empty () ? sym_rec->help () : help;
 
   sym_rec->define_as_fcn (val);
 
   sym_rec->document (tmp_help);
 
@@ -1463,36 +1463,36 @@ install_builtin_variable_as_function (co
 
   if (eternal)
     sym_rec->make_eternal ();
 }
 
 void
 alias_builtin (const string& alias, const string& name)
 {
-  symbol_record *sr_name = global_sym_tab->lookup (name, 0, 0);
+  symbol_record *sr_name = global_sym_tab->lookup (name);
 
   if (! sr_name)
     panic ("can't alias to undefined name!");
 
-  symbol_record *sr_alias = global_sym_tab->lookup (alias, 1, 0);
+  symbol_record *sr_alias = global_sym_tab->lookup (alias, true);
 
   if (sr_alias)
     sr_alias->alias (sr_name);
   else
     panic ("can't find symbol record for builtin function `%s'",
 	   alias.c_str ());
 }
 
 // Defining variables.
 
 void
-bind_ans (const octave_value& val, int print)
+bind_ans (const octave_value& val, bool print)
 {
-  static symbol_record *sr = global_sym_tab->lookup ("ans", 1, 0);
+  static symbol_record *sr = global_sym_tab->lookup ("ans", true);
 
   tree_identifier *ans_id = new tree_identifier (sr);
   tree_constant *tmp = new tree_constant (val);
 
   // XXX FIXME XXX -- making ans_id static, passing its address to
   // tree_simple_assignment_expression along with a flag to not delete
   // it seems to create a memory leak.  Hmm.
 
@@ -1529,20 +1529,20 @@ clear_global_error_variable (void *)
 // Give a global variable a definition.  This will insert the symbol
 // in the global table if necessary.
 
 // How is this different than install_builtin_variable?  Are both
 // functions needed?
 
 void
 bind_builtin_variable (const string& varname, const octave_value& val,
-		       int protect, int eternal, sv_Function sv_fcn,
+		       bool protect, bool eternal, sv_Function sv_fcn,
 		       const string& help)
 {
-  symbol_record *sr = global_sym_tab->lookup (varname, 1, 0);
+  symbol_record *sr = global_sym_tab->lookup (varname, true);
 
   // It is a programming error for a builtin symbol to be missing.
   // Besides, we just inserted it, so it must be there.
 
   assert (sr);
 
   sr->unprotect ();
 
@@ -1735,17 +1735,17 @@ With -x, exclude the named variables")
 
   if (error_state)
     return retval;
 
   // Always clear the local table, but don't clear currently compiled
   // functions unless we are at the top level.  (Allowing that to
   // happen inside functions would result in pretty odd behavior...)
 
-  int clear_user_functions = (curr_sym_tab == top_level_sym_tab);
+  bool clear_user_functions = (curr_sym_tab == top_level_sym_tab);
 
   if (argc == 1)
     {
       curr_sym_tab->clear ();
       global_sym_tab->clear (clear_user_functions);
     }
   else
     {
diff --git a/src/variables.h b/src/variables.h
--- a/src/variables.h
+++ b/src/variables.h
@@ -38,26 +38,26 @@ class string_vector;
 #include "ov.h"
 
 struct builtin_mapper_function;
 
 typedef int (*sv_Function)(void);
 
 struct builtin_variable
 {
-  builtin_variable (const string& n, const octave_value& v, int iaf, int p,
-		    int e, sv_Function svf, const string& h)
+  builtin_variable (const string& n, const octave_value& v, bool iaf,
+		    bool p, bool e, sv_Function svf, const string& h)
     : name (n), value (v), install_as_function (iaf), protect (p),
       eternal (e), sv_function (svf), help_string (h) { }
 
   string name;
   octave_value value;
-  int install_as_function;
-  int protect;
-  int eternal;
+  bool install_as_function;
+  bool protect;
+  bool eternal;
   sv_Function sv_function;
   string help_string;
 };
 
 class
 octave_variable_reference
 {
 public:
@@ -86,31 +86,32 @@ private:
 
   octave_variable_reference& operator = (const octave_variable_reference&);
 };
 
 typedef octave_value_list (*Octave_builtin_fcn)(const octave_value_list&, int);
 
 struct builtin_function
 {
-  builtin_function (const string& n, int itf, Octave_builtin_fcn f,
+  builtin_function (const string& n, bool itf, Octave_builtin_fcn f,
 		    const string& h)
     : name (n), is_text_fcn (itf), fcn (f), help_string (h) { }
 
   string name;
-  int is_text_fcn;
+  bool is_text_fcn;
   Octave_builtin_fcn fcn;
   string help_string;
 };
 
 extern void initialize_symbol_tables (void);
 
-extern bool lookup (symbol_record *s, int exec_script = 1);
+extern bool lookup (symbol_record *s, bool exec_script = true);
 
-extern symbol_record *lookup_by_name (const string& nm, int exec_script = 1);
+extern symbol_record *lookup_by_name (const string& nm,
+				      bool exec_script = true);
 
 extern octave_value get_global_value (const string& nm);
 
 extern void set_global_value (const string& nm, const octave_value& val);
 
 extern string get_help_from_file (const string& f);
 
 extern string builtin_string_variable (const string&);
@@ -125,46 +126,48 @@ extern void force_link_to_function (cons
 
 extern bool is_builtin_variable (const string&);
 extern bool is_text_function_name (const string&);
 extern bool is_mapper_function_name (const string&);
 extern bool is_builtin_function_name (const string&);
 extern bool is_globally_visible (const string&);
 
 extern tree_fvc *is_valid_function (const octave_value&, const string&,
-				    int warn = 0); 
+				    bool warn = false); 
 
 tree_fvc *extract_function (const octave_value& arg, const string& warn_for,
 			    const string& fname, const string& header,
 			    const string& trailer);
 
 extern string_vector make_name_list (void);
 
 extern void install_builtin_mapper (const builtin_mapper_function& mf);
 
 extern void install_builtin_function (const builtin_function& gf);
 
 extern void install_builtin_variable (const builtin_variable& v);
 
 extern void
 install_builtin_variable_as_function (const string& name,
 				      const octave_value& val,
-				      int protect = 0, int eternal = 0,
+				      bool protect = false,
+				      bool eternal = false,
 				      const string& help = string ());
 
 extern void alias_builtin (const string& alias, const string& name);
 
-extern void bind_ans (const octave_value& val, int print);
+extern void bind_ans (const octave_value& val, bool print);
 
 extern void bind_global_error_variable (void);
 
 extern void clear_global_error_variable (void *);
 
 extern void bind_builtin_variable (const string&, const octave_value&,
-				   int protect = 0, int eternal = 0,
+				   bool protect = false,
+				   bool eternal = false,
 				   sv_Function f = (sv_Function) 0,
 				   const string& help = string ());
 
 extern void install_builtin_variables (void);
 
 // Symbol table for symbols at the top level.
 extern symbol_table *top_level_sym_tab;
 
