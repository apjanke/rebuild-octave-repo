# HG changeset patch
# User Jaroslav Hajek <highegg@gmail.com>
# Date 1255336969 -7200
#      Mon Oct 12 10:42:49 2009 +0200
# Node ID 7918eb15040c8e44aad6596fc284e52448125390
# Parent  25e1e368618ca92a9985231ecabe790209b7e1d7
refactor the QR classes onto a templated base

diff --git a/liboctave/ChangeLog b/liboctave/ChangeLog
--- a/liboctave/ChangeLog
+++ b/liboctave/ChangeLog
@@ -1,8 +1,29 @@
+2009-10-12  Jaroslav Hajek  <highegg@gmail.com>
+
+	* base-qr.h: New source.
+	* base-qr.cc: New source.
+	* dbleQR.h (QR): Rebase on base_qr<Matrix>.
+	* dbleQR.cc: Ditto.
+	* floatQR.h (QR): Rebase on base_qr<FloatMatrix>.
+	* floatQR.cc: Ditto.
+	* CmplxQR.h (QR): Rebase on base_qr<ComplexMatrix>.
+	* CmplxQR.cc: Ditto.
+	* fCmplxQR.h (QR): Rebase on base_qr<FloatComplexMatrix>.
+	* fCmplxQR.cc: Ditto.
+	* dbleQRP.h (QR): Update.
+	* dbleQRP.cc: Ditto.
+	* floatQRP.h (QR): Update.
+	* floatQRP.cc: Ditto.
+	* CmplxQRP.h (QR): Update.
+	* CmplxQRP.cc: Ditto.
+	* fCmplxQRP.h (QR): Update.
+	* fCmplxQRP.cc: Ditto.
+
 2009-10-08  Jaroslav Hajek  <highegg@gmail.com>
 
 	* PermMatrix.cc (PermMatrix::eye): New method.
 	* PermMatrix.h: Declare it.
 	* dbleLU.cc (LU::update, LU::update_piv): New overloaded methods.
 	* dbleLU.h: Declare them.
 	* floatLU.cc (FloatLU::update, FloatLU::update_piv): New overloaded
 	methods.
diff --git a/liboctave/CmplxQR.cc b/liboctave/CmplxQR.cc
--- a/liboctave/CmplxQR.cc
+++ b/liboctave/CmplxQR.cc
@@ -29,16 +29,20 @@ along with Octave; see the file COPYING.
 
 #include "CmplxQR.h"
 #include "f77-fcn.h"
 #include "lo-error.h"
 #include "Range.h"
 #include "idx-vector.h"
 #include "oct-locbuf.h"
 
+#include "base-qr.cc"
+
+template class base_qr<ComplexMatrix>;
+
 extern "C"
 {
   F77_RET_T
   F77_FUNC (zgeqrf, ZGEQRF) (const octave_idx_type&, const octave_idx_type&, Complex*,
 			     const octave_idx_type&, Complex*, Complex*,
 			     const octave_idx_type&, octave_idx_type&); 
 
   F77_RET_T
@@ -77,35 +81,34 @@ extern "C"
   F77_FUNC (zqrshc, ZQRSHC) (const octave_idx_type&, const octave_idx_type&, const octave_idx_type&,
                              Complex*, const octave_idx_type&, Complex*, const octave_idx_type&,
                              const octave_idx_type&, const octave_idx_type&,
                              Complex*, double*);
 
 #endif
 }
 
-ComplexQR::ComplexQR (const ComplexMatrix& a, QR::type qr_type)
-  : q (), r ()
+ComplexQR::ComplexQR (const ComplexMatrix& a, qr_type_t qr_type)
 {
   init (a, qr_type);
 }
 
 void
-ComplexQR::init (const ComplexMatrix& a, QR::type qr_type)
+ComplexQR::init (const ComplexMatrix& a, qr_type_t qr_type)
 {
   octave_idx_type m = a.rows ();
   octave_idx_type n = a.cols ();
 
   octave_idx_type min_mn = m < n ? m : n;
   OCTAVE_LOCAL_BUFFER (Complex, tau, min_mn);
 
   octave_idx_type info = 0;
 
   ComplexMatrix afact = a;
-  if (m > n && qr_type == QR::std)
+  if (m > n && qr_type == qr_type_std)
     afact.resize (m, m);
 
   if (m > 0)
     {
       // workspace query.
       Complex clwork;
       F77_XFCN (zgeqrf, ZGEQRF, (m, n, afact.fortran_vec (), m, tau, &clwork, -1, info));
 
@@ -115,22 +118,22 @@ ComplexQR::init (const ComplexMatrix& a,
       OCTAVE_LOCAL_BUFFER (Complex, work, lwork);
       F77_XFCN (zgeqrf, ZGEQRF, (m, n, afact.fortran_vec (), m, tau, work, lwork, info));
     }
 
   form (n, afact, tau, qr_type);
 }
 
 void ComplexQR::form (octave_idx_type n, ComplexMatrix& afact, 
-                      Complex *tau, QR::type qr_type)
+                      Complex *tau, qr_type_t qr_type)
 {
   octave_idx_type m = afact.rows (), min_mn = std::min (m, n);
   octave_idx_type info;
 
-  if (qr_type == QR::raw)
+  if (qr_type == qr_type_raw)
     {
       for (octave_idx_type j = 0; j < min_mn; j++)
 	{
 	  octave_idx_type limit = j < min_mn - 1 ? j : min_mn - 1;
 	  for (octave_idx_type i = limit + 1; i < m; i++)
 	    afact.elem (i, j) *= tau[j];
 	}
 
@@ -138,17 +141,17 @@ void ComplexQR::form (octave_idx_type n,
     }
   else
     {
       // Attempt to minimize copying.
       if (m >= n)
         {
           // afact will become q.
           q = afact;
-          octave_idx_type k = qr_type == QR::economy ? n : m;
+          octave_idx_type k = qr_type == qr_type_economy ? n : m;
           r = ComplexMatrix (k, n);
           for (octave_idx_type j = 0; j < n; j++)
             {
               octave_idx_type i = 0;
               for (; i <= j; i++)
                 r.xelem (i, j) = afact.xelem (i, j);
               for (;i < k; i++)
                 r.xelem (i, j) = 0;
@@ -182,42 +185,16 @@ void ComplexQR::form (octave_idx_type n,
 	  lwork = std::max (lwork, static_cast<octave_idx_type> (1));
           OCTAVE_LOCAL_BUFFER (Complex, work, lwork);
           F77_XFCN (zungqr, ZUNGQR, (m, k, min_mn, q.fortran_vec (), m, tau,
                                      work, lwork, info));
         }
     }
 }
 
-ComplexQR::ComplexQR (const ComplexMatrix& q_arg, const ComplexMatrix& r_arg)
-{
-  octave_idx_type qr = q_arg.rows (), qc = q_arg.columns ();
-  octave_idx_type rr = r_arg.rows (), rc = r_arg.columns ();
-  if (qc == rr && (qr == qc || (qr > qc && rr == rc)))
-    {
-      q = q_arg;
-      r = r_arg;
-    }
-  else
-    (*current_liboctave_error_handler) ("QR dimensions mismatch");
-}
-
-QR::type
-ComplexQR::get_type (void) const
-{
-  QR::type retval;
-  if (!q.is_empty () && q.is_square ())
-    retval = QR::std;
-  else if (q.rows () > q.columns () && r.is_square ())
-    retval = QR::economy;
-  else
-    retval = QR::raw;
-  return retval;
-}
-
 #ifdef HAVE_QRUPDATE
 
 void
 ComplexQR::update (const ComplexColumnVector& u, const ComplexColumnVector& v)
 {
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
   octave_idx_type k = q.columns ();
diff --git a/liboctave/CmplxQR.h b/liboctave/CmplxQR.h
--- a/liboctave/CmplxQR.h
+++ b/liboctave/CmplxQR.h
@@ -25,52 +25,35 @@ along with Octave; see the file COPYING.
 #if !defined (octave_ComplexQR_h)
 #define octave_ComplexQR_h 1
 
 #include <iosfwd>
 
 #include "CMatrix.h"
 #include "CColVector.h"
 #include "CRowVector.h"
-#include "dbleQR.h"
+#include "base-qr.h"
 
 
 class
 OCTAVE_API
-ComplexQR
+ComplexQR : public base_qr<ComplexMatrix>
 {
 public:
 
-  ComplexQR (void) : q (), r () { }
-
-  ComplexQR (const ComplexMatrix&, QR::type = QR::std);
+  ComplexQR (void) : base_qr<ComplexMatrix> () { }
 
-  ComplexQR (const ComplexMatrix& q, const ComplexMatrix& r);
-
-  ComplexQR (const ComplexQR& a) : q (a.q), r (a.r) { }
+  ComplexQR (const ComplexMatrix&, qr_type_t = qr_type_std);
 
-  ComplexQR& operator = (const ComplexQR& a)
-    {
-      if (this != &a)
-	{
-	  q = a.q;
-	  r = a.r;
-	}
-      return *this;
-    }
+  ComplexQR (const ComplexMatrix& qx, const ComplexMatrix& rx) 
+    : base_qr<ComplexMatrix> (qx, rx) { }
 
-  ~ComplexQR (void) { }
-
-  void init (const ComplexMatrix&, QR::type = QR::std);
+  ComplexQR (const ComplexQR& a) : base_qr<ComplexMatrix> (a) { }
 
-  ComplexMatrix Q (void) const { return q; }
-
-  ComplexMatrix R (void) const { return r; }
-
-  QR::type get_type (void) const;
+  void init (const ComplexMatrix&, qr_type_t = qr_type_std);
 
   void update (const ComplexColumnVector& u, const ComplexColumnVector& v);
 
   void update (const ComplexMatrix& u, const ComplexMatrix& v);
 
   void insert_col (const ComplexColumnVector& u, octave_idx_type j);
 
   void insert_col (const ComplexMatrix& u, const Array<octave_idx_type>& j);
@@ -80,25 +63,20 @@ public:
   void delete_col (const Array<octave_idx_type>& j);
 
   void insert_row (const ComplexRowVector& u, octave_idx_type j);
 
   void delete_row (octave_idx_type j);
 
   void shift_cols (octave_idx_type i, octave_idx_type j);
 
-  friend std::ostream&  operator << (std::ostream&, const ComplexQR&);
-
 protected:
 
   void form (octave_idx_type n, ComplexMatrix& afact, 
-             Complex *tau, QR::type qr_type);
-
-  ComplexMatrix q;
-  ComplexMatrix r;
+             Complex *tau, qr_type_t qr_type);
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/liboctave/CmplxQRP.cc b/liboctave/CmplxQRP.cc
--- a/liboctave/CmplxQRP.cc
+++ b/liboctave/CmplxQRP.cc
@@ -37,37 +37,37 @@ extern "C"
   F77_RET_T
   F77_FUNC (zgeqp3, ZGEQP3) (const octave_idx_type&, const octave_idx_type&, Complex*,
 			     const octave_idx_type&, octave_idx_type*, Complex*, Complex*,
 			     const octave_idx_type&, double*, octave_idx_type&);
 }
 
 // It would be best to share some of this code with ComplexQR class...
 
-ComplexQRP::ComplexQRP (const ComplexMatrix& a, QR::type qr_type)
+ComplexQRP::ComplexQRP (const ComplexMatrix& a, qr_type_t qr_type)
   : ComplexQR (), p ()
 {
   init (a, qr_type);
 }
 
 void
-ComplexQRP::init (const ComplexMatrix& a, QR::type qr_type)
+ComplexQRP::init (const ComplexMatrix& a, qr_type_t qr_type)
 {
-  assert (qr_type != QR::raw);
+  assert (qr_type != qr_type_raw);
 
   octave_idx_type m = a.rows ();
   octave_idx_type n = a.cols ();
 
   octave_idx_type min_mn = m < n ? m : n;
   OCTAVE_LOCAL_BUFFER (Complex, tau, min_mn);
 
   octave_idx_type info = 0;
 
   ComplexMatrix afact = a;
-  if (m > n && qr_type == QR::std)
+  if (m > n && qr_type == qr_type_std)
     afact.resize (m, m);
 
   MArray<octave_idx_type> jpvt (n, 0);
 
   if (m > 0)
     {
       OCTAVE_LOCAL_BUFFER (double, rwork, 2*n);
 
diff --git a/liboctave/CmplxQRP.h b/liboctave/CmplxQRP.h
--- a/liboctave/CmplxQRP.h
+++ b/liboctave/CmplxQRP.h
@@ -33,33 +33,33 @@ along with Octave; see the file COPYING.
 class
 OCTAVE_API
 ComplexQRP : public ComplexQR
 {
 public:
 
   ComplexQRP (void) : ComplexQR (), p () { }
 
-  ComplexQRP (const ComplexMatrix&, QR::type = QR::std);
+  ComplexQRP (const ComplexMatrix&, qr_type_t = qr_type_std);
 
   ComplexQRP (const ComplexQRP& a) : ComplexQR (a), p (a.p) { }
 
   ComplexQRP& operator = (const ComplexQRP& a)
     {
       if (this != &a)
 	{
 	  ComplexQR::operator = (a);
 	  p = a.p;
 	}
       return *this;
     }
 
   ~ComplexQRP (void) { }
 
-  void init (const ComplexMatrix&, QR::type = QR::std);
+  void init (const ComplexMatrix&, qr_type_t = qr_type_std);
 
   PermMatrix P (void) const { return p; }
 
   ColumnVector Pvec (void) const;
 
   friend std::ostream&  operator << (std::ostream&, const ComplexQRP&);
 
 private:
diff --git a/liboctave/base-qr.cc b/liboctave/base-qr.cc
new file mode 100644
--- /dev/null
+++ b/liboctave/base-qr.cc
@@ -0,0 +1,56 @@
+/*
+
+Copyright (C) 2009 Jaroslav Hajek
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 3 of the License, or (at your
+option) any later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, see
+<http://www.gnu.org/licenses/>.
+
+*/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include "base-qr.h"
+
+template <class qr_type>
+base_qr<qr_type>::base_qr (const qr_type& q_arg, const qr_type& r_arg)
+{
+  octave_idx_type qr = q_arg.rows (), qc = q_arg.columns ();
+  octave_idx_type rr = r_arg.rows (), rc = r_arg.columns ();
+  if (qc == rr && (qr == qc || (qr > qc && rr == rc)))
+    {
+      q = q_arg;
+      r = r_arg;
+    }
+  else
+    (*current_liboctave_error_handler) ("QR dimensions mismatch");
+}
+
+template <class qr_type>
+qr_type_t
+base_qr<qr_type>::get_type (void) const
+{
+  qr_type_t retval;
+  if (!q.is_empty () && q.is_square ())
+    retval = qr_type_std;
+  else if (q.rows () > q.columns () && r.is_square ())
+    retval = qr_type_economy;
+  else
+    retval = qr_type_raw;
+  return retval;
+}
+
diff --git a/liboctave/base-qr.h b/liboctave/base-qr.h
new file mode 100644
--- /dev/null
+++ b/liboctave/base-qr.h
@@ -0,0 +1,77 @@
+/*
+
+Copyright (C) 2009 Jaroslav Hajek
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 3 of the License, or (at your
+option) any later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, see
+<http://www.gnu.org/licenses/>.
+
+*/
+
+#if !defined (octave_base_qr_h)
+#define octave_base_qr_h 1
+
+#include "MArray.h"
+#include "dColVector.h"
+#include "PermMatrix.h"
+
+enum qr_type_t
+{
+  qr_type_std,
+  qr_type_raw,
+  qr_type_economy
+};
+
+template <class qr_type>
+class
+base_qr
+{
+public:
+
+  typedef typename qr_type::element_type qr_elt_type;
+
+  base_qr (void) { }
+
+  base_qr (const qr_type& q, const qr_type& r);
+
+  base_qr (const base_qr& a) : 
+    q (a.q), r (a.r) { }
+
+  base_qr& operator = (const base_qr& a)
+    {
+      if (this != &a)
+	{
+	  q = a.q;
+	  r = a.r;
+	}
+      return *this;
+    }
+
+  qr_type Q (void) const { return q; }
+
+  qr_type R (void) const { return r; }
+
+  qr_type_t get_type (void) const;
+
+protected:
+
+  qr_type q, r;
+};
+
+#ifndef HAVE_QRUPDATE
+void warn_qrupdate_once (void);
+#endif
+
+#endif
diff --git a/liboctave/dbleQR.cc b/liboctave/dbleQR.cc
--- a/liboctave/dbleQR.cc
+++ b/liboctave/dbleQR.cc
@@ -29,16 +29,20 @@ along with Octave; see the file COPYING.
 
 #include "dbleQR.h"
 #include "f77-fcn.h"
 #include "lo-error.h"
 #include "Range.h"
 #include "idx-vector.h"
 #include "oct-locbuf.h"
 
+#include "base-qr.cc"
+
+template class base_qr<Matrix>;
+
 extern "C"
 {
   F77_RET_T
   F77_FUNC (dgeqrf, DGEQRF) (const octave_idx_type&, const octave_idx_type&, double*, const octave_idx_type&,
 			     double*, double*, const octave_idx_type&, octave_idx_type&); 
 
   F77_RET_T
   F77_FUNC (dorgqr, DORGQR) (const octave_idx_type&, const octave_idx_type&, const octave_idx_type&, double*,
@@ -75,35 +79,34 @@ extern "C"
   F77_FUNC (dqrshc, DQRSHC) (const octave_idx_type&, const octave_idx_type&, const octave_idx_type&,
                              double*, const octave_idx_type&, double*, const octave_idx_type&,
                              const octave_idx_type&, const octave_idx_type&,
                              double*);
 
 #endif
 }
 
-QR::QR (const Matrix& a, QR::type qr_type)
-  : q (), r ()
+QR::QR (const Matrix& a, qr_type_t qr_type)
 {
   init (a, qr_type);
 }
 
 void
-QR::init (const Matrix& a, QR::type qr_type)
+QR::init (const Matrix& a, qr_type_t qr_type)
 {
   octave_idx_type m = a.rows ();
   octave_idx_type n = a.cols ();
 
   octave_idx_type min_mn = m < n ? m : n;
   OCTAVE_LOCAL_BUFFER (double, tau, min_mn);
 
   octave_idx_type info = 0;
 
   Matrix afact = a;
-  if (m > n && qr_type == QR::std)
+  if (m > n && qr_type == qr_type_std)
     afact.resize (m, m);
 
   if (m > 0)
     {
       // workspace query.
       double rlwork;
       F77_XFCN (dgeqrf, DGEQRF, (m, n, afact.fortran_vec (), m, tau, &rlwork, -1, info));
 
@@ -113,22 +116,22 @@ QR::init (const Matrix& a, QR::type qr_t
       OCTAVE_LOCAL_BUFFER (double, work, lwork);
       F77_XFCN (dgeqrf, DGEQRF, (m, n, afact.fortran_vec (), m, tau, work, lwork, info));
     }
 
   form (n, afact, tau, qr_type);
 }
 
 void QR::form (octave_idx_type n, Matrix& afact, 
-               double *tau, QR::type qr_type)
+               double *tau, qr_type_t qr_type)
 {
   octave_idx_type m = afact.rows (), min_mn = std::min (m, n);
   octave_idx_type info;
 
-  if (qr_type == QR::raw)
+  if (qr_type == qr_type_raw)
     {
       for (octave_idx_type j = 0; j < min_mn; j++)
 	{
 	  octave_idx_type limit = j < min_mn - 1 ? j : min_mn - 1;
 	  for (octave_idx_type i = limit + 1; i < m; i++)
 	    afact.elem (i, j) *= tau[j];
 	}
 
@@ -136,17 +139,17 @@ void QR::form (octave_idx_type n, Matrix
     }
   else
     {
       // Attempt to minimize copying.
       if (m >= n)
         {
           // afact will become q.
           q = afact;
-          octave_idx_type k = qr_type == QR::economy ? n : m;
+          octave_idx_type k = qr_type == qr_type_economy ? n : m;
           r = Matrix (k, n);
           for (octave_idx_type j = 0; j < n; j++)
             {
               octave_idx_type i = 0;
               for (; i <= j; i++)
                 r.xelem (i, j) = afact.xelem (i, j);
               for (;i < k; i++)
                 r.xelem (i, j) = 0;
@@ -180,42 +183,16 @@ void QR::form (octave_idx_type n, Matrix
 	  lwork = std::max (lwork, static_cast<octave_idx_type> (1));
           OCTAVE_LOCAL_BUFFER (double, work, lwork);
           F77_XFCN (dorgqr, DORGQR, (m, k, min_mn, q.fortran_vec (), m, tau,
                                      work, lwork, info));
         }
     }
 }
 
-QR::QR (const Matrix& q_arg, const Matrix& r_arg)
-{
-  octave_idx_type qr = q_arg.rows (), qc = q_arg.columns ();
-  octave_idx_type rr = r_arg.rows (), rc = r_arg.columns ();
-  if (qc == rr && (qr == qc || (qr > qc && rr == rc)))
-    {
-      q = q_arg;
-      r = r_arg;
-    }
-  else
-    (*current_liboctave_error_handler) ("QR dimensions mismatch");
-}
-
-QR::type
-QR::get_type (void) const
-{
-  QR::type retval;
-  if (!q.is_empty () && q.is_square ())
-    retval = QR::std;
-  else if (q.rows () > q.columns () && r.is_square ())
-    retval = QR::economy;
-  else
-    retval = QR::raw;
-  return retval;
-}
-
 #ifdef HAVE_QRUPDATE
 
 void
 QR::update (const ColumnVector& u, const ColumnVector& v)
 {
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
   octave_idx_type k = q.columns ();
diff --git a/liboctave/dbleQR.h b/liboctave/dbleQR.h
--- a/liboctave/dbleQR.h
+++ b/liboctave/dbleQR.h
@@ -25,57 +25,41 @@ along with Octave; see the file COPYING.
 #if !defined (octave_QR_h)
 #define octave_QR_h 1
 
 #include <iosfwd>
 
 #include "dMatrix.h"
 #include "dColVector.h"
 #include "dRowVector.h"
+#include "base-qr.h"
 
 class
 OCTAVE_API
-QR
+QR : public base_qr<Matrix>
 {
 public:
 
-  enum type
-    {
-      std,
-      raw,
-      economy
-    };
+  // Import them here to allow the QR:: prefix.
+  typedef qr_type_t type;
 
-  QR (void) : q (), r () { }
-
-  QR (const Matrix&, QR::type = QR::std);
+  static const type std = qr_type_std;
+  static const type raw = qr_type_raw;
+  static const type economy = qr_type_economy;
 
-  QR (const Matrix& q, const Matrix& r);
-
-  QR (const QR& a) : q (a.q), r (a.r) { }
+  QR (void) : base_qr<Matrix> () { }
 
-  QR& operator = (const QR& a)
-    {
-      if (this != &a)
-	{
-	  q = a.q;
-	  r = a.r;
-	}
-      return *this;
-    }
+  QR (const Matrix&, qr_type_t = qr_type_std);
 
-  ~QR (void) { }
-
-  void init (const Matrix&, QR::type);
+  QR (const Matrix& qx, const Matrix& rx) 
+    : base_qr<Matrix> (qx, rx) { }
 
-  Matrix Q (void) const { return q; }
+  QR (const QR& a) : base_qr<Matrix> (a) { }
 
-  Matrix R (void) const { return r; }
-
-  QR::type get_type (void) const;
+  void init (const Matrix&, qr_type_t);
 
   void update (const ColumnVector& u, const ColumnVector& v);
 
   void update (const Matrix& u, const Matrix& v);
 
   void insert_col (const ColumnVector& u, octave_idx_type j);
 
   void insert_col (const Matrix& u, const Array<octave_idx_type>& j);
@@ -85,30 +69,21 @@ public:
   void delete_col (const Array<octave_idx_type>& j);
 
   void insert_row (const RowVector& u, octave_idx_type j);
 
   void delete_row (octave_idx_type j);
 
   void shift_cols (octave_idx_type i, octave_idx_type j);
 
-  friend std::ostream&  operator << (std::ostream&, const QR&);
-
 protected:
 
   void form (octave_idx_type n, Matrix& afact, 
-             double *tau, QR::type qr_type);
-
-  Matrix q;
-  Matrix r;
+             double *tau, qr_type_t qr_type);
 };
 
-#ifndef HAVE_QRUPDATE
-void warn_qrupdate_once (void);
-#endif
-
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/dbleQRP.cc b/liboctave/dbleQRP.cc
--- a/liboctave/dbleQRP.cc
+++ b/liboctave/dbleQRP.cc
@@ -37,37 +37,37 @@ extern "C"
   F77_RET_T
   F77_FUNC (dgeqp3, DGEQP3) (const octave_idx_type&, const octave_idx_type&, double*,
 			     const octave_idx_type&, octave_idx_type*, double*, double*,
                              const octave_idx_type&, octave_idx_type&);
 }
 
 // It would be best to share some of this code with QR class...
 
-QRP::QRP (const Matrix& a, QR::type qr_type)
+QRP::QRP (const Matrix& a, qr_type_t qr_type)
   : QR (), p ()
 {
   init (a, qr_type);
 }
 
 void
-QRP::init (const Matrix& a, QR::type qr_type)
+QRP::init (const Matrix& a, qr_type_t qr_type)
 {
-  assert (qr_type != QR::raw);
+  assert (qr_type != qr_type_raw);
 
   octave_idx_type m = a.rows ();
   octave_idx_type n = a.cols ();
 
   octave_idx_type min_mn = m < n ? m : n;
   OCTAVE_LOCAL_BUFFER (double, tau, min_mn);
 
   octave_idx_type info = 0;
 
   Matrix afact = a;
-  if (m > n && qr_type == QR::std)
+  if (m > n && qr_type == qr_type_std)
     afact.resize (m, m);
 
   MArray<octave_idx_type> jpvt (n, 0);
 
   if (m > 0)
     {
       // workspace query.
       double rlwork;
diff --git a/liboctave/dbleQRP.h b/liboctave/dbleQRP.h
--- a/liboctave/dbleQRP.h
+++ b/liboctave/dbleQRP.h
@@ -33,34 +33,34 @@ along with Octave; see the file COPYING.
 class
 OCTAVE_API
 QRP : public QR
 {
 public:
 
   QRP (void) : QR (), p () { }
 
-  QRP (const Matrix&, QR::type = QR::std);
+  QRP (const Matrix&, qr_type_t = qr_type_std);
 
   QRP (const QRP& a) : QR (a), p (a.p) { }
 
   QRP& operator = (const QRP& a)
     {
       if (this != &a)
 	{
 	  QR::operator = (a);
 	  p = a.p;
 	}
 
       return *this;
     }
 
   ~QRP (void) { }
 
-  void init (const Matrix&, QR::type = QR::std);
+  void init (const Matrix&, qr_type_t = qr_type_std);
 
   PermMatrix P (void) const { return p; }
 
   ColumnVector Pvec (void) const;
 
   friend std::ostream&  operator << (std::ostream&, const QRP&);
 
 protected:
diff --git a/liboctave/fCmplxQR.cc b/liboctave/fCmplxQR.cc
--- a/liboctave/fCmplxQR.cc
+++ b/liboctave/fCmplxQR.cc
@@ -29,16 +29,20 @@ along with Octave; see the file COPYING.
 
 #include "fCmplxQR.h"
 #include "f77-fcn.h"
 #include "lo-error.h"
 #include "Range.h"
 #include "idx-vector.h"
 #include "oct-locbuf.h"
 
+#include "base-qr.cc"
+
+template class base_qr<FloatComplexMatrix>;
+
 extern "C"
 {
   F77_RET_T
   F77_FUNC (cgeqrf, CGEQRF) (const octave_idx_type&, const octave_idx_type&, FloatComplex*,
 			     const octave_idx_type&, FloatComplex*, FloatComplex*,
 			     const octave_idx_type&, octave_idx_type&); 
 
   F77_RET_T
@@ -77,35 +81,34 @@ extern "C"
   F77_FUNC (cqrshc, CQRSHC) (const octave_idx_type&, const octave_idx_type&, const octave_idx_type&,
                              FloatComplex*, const octave_idx_type&, FloatComplex*, const octave_idx_type&,
                              const octave_idx_type&, const octave_idx_type&,
                              FloatComplex*, float*);
 
 #endif
 }
 
-FloatComplexQR::FloatComplexQR (const FloatComplexMatrix& a, QR::type qr_type)
-  : q (), r ()
+FloatComplexQR::FloatComplexQR (const FloatComplexMatrix& a, qr_type_t qr_type)
 {
   init (a, qr_type);
 }
 
 void
-FloatComplexQR::init (const FloatComplexMatrix& a, QR::type qr_type)
+FloatComplexQR::init (const FloatComplexMatrix& a, qr_type_t qr_type)
 {
   octave_idx_type m = a.rows ();
   octave_idx_type n = a.cols ();
 
   octave_idx_type min_mn = m < n ? m : n;
   OCTAVE_LOCAL_BUFFER (FloatComplex, tau, min_mn);
 
   octave_idx_type info = 0;
 
   FloatComplexMatrix afact = a;
-  if (m > n && qr_type == QR::std)
+  if (m > n && qr_type == qr_type_std)
     afact.resize (m, m);
 
   if (m > 0)
     {
       // workspace query.
       FloatComplex clwork;
       F77_XFCN (cgeqrf, CGEQRF, (m, n, afact.fortran_vec (), m, tau, &clwork, -1, info));
 
@@ -115,22 +118,22 @@ FloatComplexQR::init (const FloatComplex
       OCTAVE_LOCAL_BUFFER (FloatComplex, work, lwork);
       F77_XFCN (cgeqrf, CGEQRF, (m, n, afact.fortran_vec (), m, tau, work, lwork, info));
     }
 
   form (n, afact, tau, qr_type);
 }
 
 void FloatComplexQR::form (octave_idx_type n, FloatComplexMatrix& afact, 
-                           FloatComplex *tau, QR::type qr_type)
+                           FloatComplex *tau, qr_type_t qr_type)
 {
   octave_idx_type m = afact.rows (), min_mn = std::min (m, n);
   octave_idx_type info;
 
-  if (qr_type == QR::raw)
+  if (qr_type == qr_type_raw)
     {
       for (octave_idx_type j = 0; j < min_mn; j++)
 	{
 	  octave_idx_type limit = j < min_mn - 1 ? j : min_mn - 1;
 	  for (octave_idx_type i = limit + 1; i < m; i++)
 	    afact.elem (i, j) *= tau[j];
 	}
 
@@ -138,17 +141,17 @@ void FloatComplexQR::form (octave_idx_ty
     }
   else
     {
       // Attempt to minimize copying.
       if (m >= n)
         {
           // afact will become q.
           q = afact;
-          octave_idx_type k = qr_type == QR::economy ? n : m;
+          octave_idx_type k = qr_type == qr_type_economy ? n : m;
           r = FloatComplexMatrix (k, n);
           for (octave_idx_type j = 0; j < n; j++)
             {
               octave_idx_type i = 0;
               for (; i <= j; i++)
                 r.xelem (i, j) = afact.xelem (i, j);
               for (;i < k; i++)
                 r.xelem (i, j) = 0;
@@ -182,42 +185,16 @@ void FloatComplexQR::form (octave_idx_ty
 	  lwork = std::max (lwork, static_cast<octave_idx_type> (1));
           OCTAVE_LOCAL_BUFFER (FloatComplex, work, lwork);
           F77_XFCN (cungqr, CUNGQR, (m, k, min_mn, q.fortran_vec (), m, tau,
                                      work, lwork, info));
         }
     }
 }
 
-FloatComplexQR::FloatComplexQR (const FloatComplexMatrix& q_arg, const FloatComplexMatrix& r_arg)
-{
-  octave_idx_type qr = q_arg.rows (), qc = q_arg.columns ();
-  octave_idx_type rr = r_arg.rows (), rc = r_arg.columns ();
-  if (qc == rr && (qr == qc || (qr > qc && rr == rc)))
-    {
-      q = q_arg;
-      r = r_arg;
-    }
-  else
-    (*current_liboctave_error_handler) ("QR dimensions mismatch");
-}
-
-QR::type
-FloatComplexQR::get_type (void) const
-{
-  QR::type retval;
-  if (!q.is_empty () && q.is_square ())
-    retval = QR::std;
-  else if (q.rows () > q.columns () && r.is_square ())
-    retval = QR::economy;
-  else
-    retval = QR::raw;
-  return retval;
-}
-
 #ifdef HAVE_QRUPDATE
 
 void
 FloatComplexQR::update (const FloatComplexColumnVector& u, const FloatComplexColumnVector& v)
 {
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
   octave_idx_type k = q.columns ();
diff --git a/liboctave/fCmplxQR.h b/liboctave/fCmplxQR.h
--- a/liboctave/fCmplxQR.h
+++ b/liboctave/fCmplxQR.h
@@ -27,51 +27,34 @@ along with Octave; see the file COPYING.
 #if !defined (octave_FloatComplexQR_h)
 #define octave_FloatComplexQR_h 1
 
 #include <iosfwd>
 
 #include "fCMatrix.h"
 #include "fCColVector.h"
 #include "fCRowVector.h"
-#include "dbleQR.h"
+#include "base-qr.h"
 
 class
 OCTAVE_API
-FloatComplexQR
+FloatComplexQR : public base_qr<FloatComplexMatrix>
 {
 public:
 
-  FloatComplexQR (void) : q (), r () { }
-
-  FloatComplexQR (const FloatComplexMatrix&, QR::type = QR::std);
+  FloatComplexQR (void) : base_qr<FloatComplexMatrix> () { }
 
-  FloatComplexQR (const FloatComplexMatrix& q, const FloatComplexMatrix& r);
-
-  FloatComplexQR (const FloatComplexQR& a) : q (a.q), r (a.r) { }
+  FloatComplexQR (const FloatComplexMatrix&, qr_type_t = qr_type_std);
 
-  FloatComplexQR& operator = (const FloatComplexQR& a)
-    {
-      if (this != &a)
-	{
-	  q = a.q;
-	  r = a.r;
-	}
-      return *this;
-    }
+  FloatComplexQR (const FloatComplexMatrix& qx, const FloatComplexMatrix& rx) 
+    : base_qr<FloatComplexMatrix> (qx, rx) { }
 
-  ~FloatComplexQR (void) { }
-
-  void init (const FloatComplexMatrix&, QR::type = QR::std);
+  FloatComplexQR (const FloatComplexQR& a) : base_qr<FloatComplexMatrix> (a) { }
 
-  FloatComplexMatrix Q (void) const { return q; }
-
-  FloatComplexMatrix R (void) const { return r; }
-
-  QR::type get_type (void) const;
+  void init (const FloatComplexMatrix&, qr_type_t = qr_type_std);
 
   void update (const FloatComplexColumnVector& u, const FloatComplexColumnVector& v);
 
   void update (const FloatComplexMatrix& u, const FloatComplexMatrix& v);
 
   void insert_col (const FloatComplexColumnVector& u, octave_idx_type j);
 
   void insert_col (const FloatComplexMatrix& u, const Array<octave_idx_type>& j);
@@ -81,25 +64,20 @@ public:
   void delete_col (const Array<octave_idx_type>& j);
 
   void insert_row (const FloatComplexRowVector& u, octave_idx_type j);
 
   void delete_row (octave_idx_type j);
 
   void shift_cols (octave_idx_type i, octave_idx_type j);
 
-  friend std::ostream&  operator << (std::ostream&, const FloatComplexQR&);
-
 protected:
 
   void form (octave_idx_type n, FloatComplexMatrix& afact, 
-             FloatComplex *tau, QR::type qr_type);
-
-  FloatComplexMatrix q;
-  FloatComplexMatrix r;
+             FloatComplex *tau, qr_type_t qr_type);
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/liboctave/fCmplxQRP.cc b/liboctave/fCmplxQRP.cc
--- a/liboctave/fCmplxQRP.cc
+++ b/liboctave/fCmplxQRP.cc
@@ -37,37 +37,37 @@ extern "C"
   F77_RET_T
   F77_FUNC (cgeqp3, CGEQP3) (const octave_idx_type&, const octave_idx_type&, FloatComplex*,
 			     const octave_idx_type&, octave_idx_type*, FloatComplex*, FloatComplex*,
 			     const octave_idx_type&, float*, octave_idx_type&);
 }
 
 // It would be best to share some of this code with FloatComplexQR class...
 
-FloatComplexQRP::FloatComplexQRP (const FloatComplexMatrix& a, QR::type qr_type)
+FloatComplexQRP::FloatComplexQRP (const FloatComplexMatrix& a, qr_type_t qr_type)
   : FloatComplexQR (), p ()
 {
   init (a, qr_type);
 }
 
 void
-FloatComplexQRP::init (const FloatComplexMatrix& a, QR::type qr_type)
+FloatComplexQRP::init (const FloatComplexMatrix& a, qr_type_t qr_type)
 {
-  assert (qr_type != QR::raw);
+  assert (qr_type != qr_type_raw);
 
   octave_idx_type m = a.rows ();
   octave_idx_type n = a.cols ();
 
   octave_idx_type min_mn = m < n ? m : n;
   OCTAVE_LOCAL_BUFFER (FloatComplex, tau, min_mn);
 
   octave_idx_type info = 0;
 
   FloatComplexMatrix afact = a;
-  if (m > n && qr_type == QR::std)
+  if (m > n && qr_type == qr_type_std)
     afact.resize (m, m);
 
   MArray<octave_idx_type> jpvt (n, 0);
 
   if (m > 0)
     {
       OCTAVE_LOCAL_BUFFER (float, rwork, 2*n);
 
diff --git a/liboctave/fCmplxQRP.h b/liboctave/fCmplxQRP.h
--- a/liboctave/fCmplxQRP.h
+++ b/liboctave/fCmplxQRP.h
@@ -33,33 +33,33 @@ along with Octave; see the file COPYING.
 class
 OCTAVE_API
 FloatComplexQRP : public FloatComplexQR
 {
 public:
 
   FloatComplexQRP (void) : FloatComplexQR (), p () { }
 
-  FloatComplexQRP (const FloatComplexMatrix&, QR::type = QR::std);
+  FloatComplexQRP (const FloatComplexMatrix&, qr_type_t = qr_type_std);
 
   FloatComplexQRP (const FloatComplexQRP& a) : FloatComplexQR (a), p (a.p) { }
 
   FloatComplexQRP& operator = (const FloatComplexQRP& a)
     {
       if (this != &a)
 	{
 	  FloatComplexQR::operator = (a);
 	  p = a.p;
 	}
       return *this;
     }
 
   ~FloatComplexQRP (void) { }
 
-  void init (const FloatComplexMatrix&, QR::type = QR::std);
+  void init (const FloatComplexMatrix&, qr_type_t = qr_type_std);
 
   PermMatrix P (void) const { return p; }
 
   FloatColumnVector Pvec (void) const;
 
   friend std::ostream&  operator << (std::ostream&, const FloatComplexQRP&);
 
 private:
diff --git a/liboctave/floatQR.cc b/liboctave/floatQR.cc
--- a/liboctave/floatQR.cc
+++ b/liboctave/floatQR.cc
@@ -29,16 +29,20 @@ along with Octave; see the file COPYING.
 
 #include "floatQR.h"
 #include "f77-fcn.h"
 #include "lo-error.h"
 #include "Range.h"
 #include "idx-vector.h"
 #include "oct-locbuf.h"
 
+#include "base-qr.cc"
+
+template class base_qr<FloatMatrix>;
+
 extern "C"
 {
   F77_RET_T
   F77_FUNC (sgeqrf, SGEQRF) (const octave_idx_type&, const octave_idx_type&, float*, const octave_idx_type&,
 			     float*, float*, const octave_idx_type&, octave_idx_type&); 
 
   F77_RET_T
   F77_FUNC (sorgqr, SORGQR) (const octave_idx_type&, const octave_idx_type&, const octave_idx_type&, float*,
@@ -75,35 +79,34 @@ extern "C"
   F77_FUNC (sqrshc, SQRSHC) (const octave_idx_type&, const octave_idx_type&, const octave_idx_type&,
                              float*, const octave_idx_type&, float*, const octave_idx_type&,
                              const octave_idx_type&, const octave_idx_type&,
                              float*);
 
 #endif
 }
 
-FloatQR::FloatQR (const FloatMatrix& a, QR::type qr_type)
-  : q (), r ()
+FloatQR::FloatQR (const FloatMatrix& a, qr_type_t qr_type)
 {
   init (a, qr_type);
 }
 
 void
-FloatQR::init (const FloatMatrix& a, QR::type qr_type)
+FloatQR::init (const FloatMatrix& a, qr_type_t qr_type)
 {
   octave_idx_type m = a.rows ();
   octave_idx_type n = a.cols ();
 
   octave_idx_type min_mn = m < n ? m : n;
   OCTAVE_LOCAL_BUFFER (float, tau, min_mn);
 
   octave_idx_type info = 0;
 
   FloatMatrix afact = a;
-  if (m > n && qr_type == QR::std)
+  if (m > n && qr_type == qr_type_std)
     afact.resize (m, m);
 
   if (m > 0)
     {
       // workspace query.
       float rlwork;
       F77_XFCN (sgeqrf, SGEQRF, (m, n, afact.fortran_vec (), m, tau, &rlwork, -1, info));
 
@@ -113,22 +116,22 @@ FloatQR::init (const FloatMatrix& a, QR:
       OCTAVE_LOCAL_BUFFER (float, work, lwork);
       F77_XFCN (sgeqrf, SGEQRF, (m, n, afact.fortran_vec (), m, tau, work, lwork, info));
     }
 
   form (n, afact, tau, qr_type);
 }
 
 void FloatQR::form (octave_idx_type n, FloatMatrix& afact, 
-                    float *tau, QR::type qr_type)
+                    float *tau, qr_type_t qr_type)
 {
   octave_idx_type m = afact.rows (), min_mn = std::min (m, n);
   octave_idx_type info;
 
-  if (qr_type == QR::raw)
+  if (qr_type == qr_type_raw)
     {
       for (octave_idx_type j = 0; j < min_mn; j++)
 	{
 	  octave_idx_type limit = j < min_mn - 1 ? j : min_mn - 1;
 	  for (octave_idx_type i = limit + 1; i < m; i++)
 	    afact.elem (i, j) *= tau[j];
 	}
 
@@ -136,17 +139,17 @@ void FloatQR::form (octave_idx_type n, F
     }
   else
     {
       // Attempt to minimize copying.
       if (m >= n)
         {
           // afact will become q.
           q = afact;
-          octave_idx_type k = qr_type == QR::economy ? n : m;
+          octave_idx_type k = qr_type == qr_type_economy ? n : m;
           r = FloatMatrix (k, n);
           for (octave_idx_type j = 0; j < n; j++)
             {
               octave_idx_type i = 0;
               for (; i <= j; i++)
                 r.xelem (i, j) = afact.xelem (i, j);
               for (;i < k; i++)
                 r.xelem (i, j) = 0;
@@ -180,42 +183,16 @@ void FloatQR::form (octave_idx_type n, F
 	  lwork = std::max (lwork, static_cast<octave_idx_type> (1));
           OCTAVE_LOCAL_BUFFER (float, work, lwork);
           F77_XFCN (sorgqr, SORGQR, (m, k, min_mn, q.fortran_vec (), m, tau,
                                      work, lwork, info));
         }
     }
 }
 
-FloatQR::FloatQR (const FloatMatrix& q_arg, const FloatMatrix& r_arg)
-{
-  octave_idx_type qr = q_arg.rows (), qc = q_arg.columns ();
-  octave_idx_type rr = r_arg.rows (), rc = r_arg.columns ();
-  if (qc == rr && (qr == qc || (qr > qc && rr == rc)))
-    {
-      q = q_arg;
-      r = r_arg;
-    }
-  else
-    (*current_liboctave_error_handler) ("QR dimensions mismatch");
-}
-
-QR::type
-FloatQR::get_type (void) const
-{
-  QR::type retval;
-  if (!q.is_empty () && q.is_square ())
-    retval = QR::std;
-  else if (q.rows () > q.columns () && r.is_square ())
-    retval = QR::economy;
-  else
-    retval = QR::raw;
-  return retval;
-}
-
 #ifdef HAVE_QRUPDATE
 
 void
 FloatQR::update (const FloatColumnVector& u, const FloatColumnVector& v)
 {
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
   octave_idx_type k = q.columns ();
diff --git a/liboctave/floatQR.h b/liboctave/floatQR.h
--- a/liboctave/floatQR.h
+++ b/liboctave/floatQR.h
@@ -25,51 +25,34 @@ along with Octave; see the file COPYING.
 #if !defined (octave_FloatQR_h)
 #define octave_FloatQR_h 1
 
 #include <iosfwd>
 
 #include "fMatrix.h"
 #include "fColVector.h"
 #include "fRowVector.h"
-#include "dbleQR.h"
+#include "base-qr.h"
 
 class
 OCTAVE_API
-FloatQR
+FloatQR : public base_qr<FloatMatrix>
 {
 public:
 
-  FloatQR (void) : q (), r () { }
-
-  FloatQR (const FloatMatrix&, QR::type = QR::std);
+  FloatQR (void) : base_qr<FloatMatrix> () { }
 
-  FloatQR (const FloatMatrix& q, const FloatMatrix& r);
-
-  FloatQR (const FloatQR& a) : q (a.q), r (a.r) { }
+  FloatQR (const FloatMatrix&, qr_type_t = qr_type_std);
 
-  FloatQR& operator = (const FloatQR& a)
-    {
-      if (this != &a)
-	{
-	  q = a.q;
-	  r = a.r;
-	}
-      return *this;
-    }
+  FloatQR (const FloatMatrix& qx, const FloatMatrix& rx) 
+    : base_qr<FloatMatrix> (qx, rx) { }
 
-  ~FloatQR (void) { }
-
-  void init (const FloatMatrix&, QR::type);
+  FloatQR (const FloatQR& a) : base_qr<FloatMatrix> (a) { }
 
-  FloatMatrix Q (void) const { return q; }
-
-  FloatMatrix R (void) const { return r; }
-
-  QR::type get_type (void) const;
+  void init (const FloatMatrix&, qr_type_t);
 
   void update (const FloatColumnVector& u, const FloatColumnVector& v);
 
   void update (const FloatMatrix& u, const FloatMatrix& v);
 
   void insert_col (const FloatColumnVector& u, octave_idx_type j);
 
   void insert_col (const FloatMatrix& u, const Array<octave_idx_type>& j);
@@ -79,25 +62,20 @@ public:
   void delete_col (const Array<octave_idx_type>& j);
 
   void insert_row (const FloatRowVector& u, octave_idx_type j);
 
   void delete_row (octave_idx_type j);
 
   void shift_cols (octave_idx_type i, octave_idx_type j);
 
-  friend std::ostream&  operator << (std::ostream&, const FloatQR&);
-
 protected:
 
   void form (octave_idx_type n, FloatMatrix& afact, 
-             float *tau, QR::type qr_type);
-
-  FloatMatrix q;
-  FloatMatrix r;
+             float *tau, qr_type_t qr_type);
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/liboctave/floatQRP.cc b/liboctave/floatQRP.cc
--- a/liboctave/floatQRP.cc
+++ b/liboctave/floatQRP.cc
@@ -37,37 +37,37 @@ extern "C"
   F77_RET_T
   F77_FUNC (sgeqp3, SGEQP3) (const octave_idx_type&, const octave_idx_type&, float*,
 			     const octave_idx_type&, octave_idx_type*, float*, float*,
                              const octave_idx_type&, octave_idx_type&);
 }
 
 // It would be best to share some of this code with QR class...
 
-FloatQRP::FloatQRP (const FloatMatrix& a, QR::type qr_type)
+FloatQRP::FloatQRP (const FloatMatrix& a, qr_type_t qr_type)
   : FloatQR (), p ()
 {
   init (a, qr_type);
 }
 
 void
-FloatQRP::init (const FloatMatrix& a, QR::type qr_type)
+FloatQRP::init (const FloatMatrix& a, qr_type_t qr_type)
 {
-  assert (qr_type != QR::raw);
+  assert (qr_type != qr_type_raw);
 
   octave_idx_type m = a.rows ();
   octave_idx_type n = a.cols ();
 
   octave_idx_type min_mn = m < n ? m : n;
   OCTAVE_LOCAL_BUFFER (float, tau, min_mn);
 
   octave_idx_type info = 0;
 
   FloatMatrix afact = a;
-  if (m > n && qr_type == QR::std)
+  if (m > n && qr_type == qr_type_std)
     afact.resize (m, m);
 
   MArray<octave_idx_type> jpvt (n, 0);
 
   if (m > 0)
     {
       // workspace query.
       float rlwork;
diff --git a/liboctave/floatQRP.h b/liboctave/floatQRP.h
--- a/liboctave/floatQRP.h
+++ b/liboctave/floatQRP.h
@@ -33,34 +33,34 @@ along with Octave; see the file COPYING.
 class
 OCTAVE_API
 FloatQRP : public FloatQR
 {
 public:
 
   FloatQRP (void) : FloatQR (), p () { }
 
-  FloatQRP (const FloatMatrix&, QR::type = QR::std);
+  FloatQRP (const FloatMatrix&, qr_type_t = qr_type_std);
 
   FloatQRP (const FloatQRP& a) : FloatQR (a), p (a.p) { }
 
   FloatQRP& operator = (const FloatQRP& a)
     {
       if (this != &a)
 	{
 	  FloatQR::operator = (a);
 	  p = a.p;
 	}
 
       return *this;
     }
 
   ~FloatQRP (void) { }
 
-  void init (const FloatMatrix&, QR::type = QR::std);
+  void init (const FloatMatrix&, qr_type_t = qr_type_std);
 
   PermMatrix P (void) const { return p; }
 
   FloatColumnVector Pvec (void) const;
 
   friend std::ostream&  operator << (std::ostream&, const FloatQRP&);
 
 protected:
