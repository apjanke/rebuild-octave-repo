# HG changeset patch
# User jwe
# Date 1067287083 0
#      Mon Oct 27 20:38:03 2003 +0000
# Node ID 6f3382e08a527c3718545f651d8390a585c89f61
# Parent  2c619e5138fd2f3dd0dd5f9060d8c9d505de676c
[project @ 2003-10-27 20:38:02 by jwe]

diff --git a/configure.in b/configure.in
--- a/configure.in
+++ b/configure.in
@@ -17,17 +17,17 @@ dnl Copyright (C) 1996, 1997 John W. Eat
 ### for more details.
 ### 
 ### You should have received a copy of the GNU General Public License
 ### along with Octave; see the file COPYING.  If not, write to the Free
 ### Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ### 02111-1307, USA. 
 
 AC_INIT
-AC_REVISION($Revision: 1.434 $)
+AC_REVISION($Revision: 1.435 $)
 AC_PREREQ(2.57)
 AC_CONFIG_SRCDIR([src/octave.cc])
 AC_CONFIG_HEADER(config.h)
 
 AC_DEFINE(OCTAVE_SOURCE, 1, [Define if this is Octave.])
   
 OCTAVE_HOST_TYPE
 
@@ -1407,16 +1407,24 @@ typedef int sig_atomic_t;
 #define OCTAVE_LOCAL_BUFFER(T, buf, size) \
   std::auto_ptr<T> buf ## _auto_ptr (new T [size]); \
   T *buf = buf ## _auto_ptr.get ()
 /* #endif */
 
 #if defined (__DECCXX)
 #define __USE_STD_IOSTREAM
 #endif
+
+#if defined (_UNICOS)
+#define F77_USES_CRAY_CALLING_CONVENTION
+#endif
+
+#if 0
+#define F77_USES_VISUAL_FORTRAN_CALLING_CONVENTION
+#endif
 ])
 
 ### Do the substitutions in all the Makefiles.
 
 AC_CONFIG_FILES([Makefile octMakefile Makeconf install-octave \
   test/Makefile dlfcn/Makefile \
   doc/Makefile doc/faq/Makefile doc/interpreter/Makefile \
   doc/liboctave/Makefile doc/refcard/Makefile emacs/Makefile \
diff --git a/libcruft/ChangeLog b/libcruft/ChangeLog
--- a/libcruft/ChangeLog
+++ b/libcruft/ChangeLog
@@ -1,10 +1,20 @@
 2003-10-27  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
+	* misc/f77-fcn.c (xstopx): Return type is now F77_RET_T.
+	Use F77_RETURN.
+	* misc/machar.c (machar): Likewise.
+
+	* misc/f77-fcn.h (F77_CHAR_ARG, F77_CONST_CHAR_ARG, F77_CHAR_ARG2,
+	F77_CONST_CHAR_ARG2, F77_CXX_STRING_ARG, F77_CHAR_ARG_LEN,
+	F77_CHAR_ARG_DECL, F77_CONST_CHAR_ARG_DECL, F77_CHAR_ARG_LEN_DECL,
+	F77_RET_T, F77_RETURN): New macros.
+	[F77_USES_CRAY_CALLING_CONVENTION]: New data conversion functions.
+
 	* misc/quit.h (octave_interrupt_hook, octave_bad_alloc_hook):
 	Move function pointer declarations inside __cplusplus section.
 
 2003-07-29  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* Makefile.in (install-lib): Use $(INSTALL), not
 	$(INSTALL_PROGRAM) for $(SHLLIB) files.
 
diff --git a/libcruft/misc/f77-fcn.c b/libcruft/misc/f77-fcn.c
--- a/libcruft/misc/f77-fcn.c
+++ b/libcruft/misc/f77-fcn.c
@@ -33,25 +33,27 @@ Software Foundation, 59 Temple Place - S
 
 /* All the STOP statements in the Fortran routines have been replaced
    with a call to XSTOPX.
 
    XSTOPX jumps back to the entry point for the Fortran function that
    called us.  Then the calling function should do whatever cleanup
    is necessary.  */
 
-void
+F77_RET_T
 F77_FUNC (xstopx, XSTOPX) (const char *s, long int slen)
 {
   f77_exception_encountered = 1;
 
   /* Skip printing message if it is just a single blank character.  */
   if (s && slen > 0 && ! (slen == 1 && *s == ' '))
     (*current_liboctave_error_handler) ("%.*s", slen, s);
 
   octave_jump_to_enclosing_context ();
+
+  F77_RETURN (0)
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/libcruft/misc/f77-fcn.h b/libcruft/misc/f77-fcn.h
--- a/libcruft/misc/f77-fcn.h
+++ b/libcruft/misc/f77-fcn.h
@@ -72,23 +72,110 @@ extern "C" {
           octave_restore_current_context ((char *) saved_context); \
         } \
     } \
   while (0)
 
 /* So we can check to see if an exception has occurred. */
 extern int f77_exception_encountered;
 
-extern void
-F77_FUNC (xstopx, XSTOPX) (const char *s, long int slen) GCC_ATTR_NORETURN;
-
 #if !defined (F77_FCN)
 #define F77_FCN(f, F) F77_FUNC (f, F)
 #endif
 
+#if defined (F77_USES_CRAY_CALLING_CONVENTION)
+
+#include <fortran.h>
+#define F77_CHAR_ARG(x) octave_make_cray_ftn_ch_dsc (x, strlen (x))
+#define F77_CONST_CHAR_ARG(x) \
+  octave_make_cray_const_ftn_ch_dsc (x, strlen (x))
+#define F77_CHAR_ARG2(x, l) octave_make_cray_fcd (x, l)
+#define F77_CONST_CHAR_ARG2(x, l) octave_make_cray_const_fcd (x, l)
+#define F77_CXX_STRING_ARG(x) \
+  octave_make_cray_const_ftn_ch_dsc (x.c_str (), x.length ())
+#define F77_CHAR_ARG_LEN(l)
+#define F77_CHAR_ARG_DECL octave_cray_fcd
+#define F77_CONST_CHAR_ARG_DECL octave_cray_fcd
+#define F77_CHAR_ARG_LEN_DECL
+#define F77_RET_T int
+#define F77_RETURN(retval) return retval;
+
+// XXX FIXME XXX -- these should work for SV1 or Y-MP systems but will
+// need to be changed for others.
+
+union octave_cray_descriptor
+{
+  union
+  {
+    const char *const_ptr;
+    const char *ptr;
+  };
+  struct
+  {
+    unsigned off : 6;
+    unsigned len : 26;
+    unsigned add : 32;
+  } mask;
+};
+
+typedef void *octave_cray_ftn_ch_dsc;
+
+static inline octave_cray_ftn_ch_dsc
+octave_make_cray_ftn_ch_dsc (char *ptr_arg, unsigned long len_arg)
+{
+  octave_cray_descriptor desc;
+  desc.ptr = ptr_arg;
+  desc.mask.len = len_arg << 3;
+  return *((octave_cray_fortran_character_descriptor *) &f);
+}
+
+static inline octave_cray_ftn_ch_dsc
+octave_make_cray_const_ftn_ch_dsc (const char *ptr_arg, unsigned long len_arg)
+{
+  octave_cray_descriptor desc;
+  desc.const_ptr = ptr_arg;
+  desc.mask.len = len_arg << 3;
+  return *((octave_cray_fcd *) &f);
+}
+
+#elif defined (F77_USES_VISUAL_FORTRAN_CALLING_CONVENTION)
+
+#define F77_CHAR_ARG(x) x, strlen (x)
+#define F77_CONST_CHAR_ARG(x) F77_CHAR_ARG (x)
+#define F77_CHAR_ARG2(x, l) x, l
+#define F77_CONST_CHAR_ARG2(x, l) F77_CHAR_ARG2 (x, l)
+#define F77_CXX_STRING_ARG(x) F77_CONST_CHAR_ARG2 (x.c_str (), x.length ())
+#define F77_CHAR_ARG_LEN(l)
+#define F77_CHAR_ARG_DECL char *, int
+#define F77_CONST_CHAR_ARG_DECL const char *, int
+#define F77_CHAR_ARG_LEN_DECL
+#define F77_RET_T void
+#define F77_RETURN(retval)
+
+#else
+
+// Assume f2c-compatible calling convention
+
+#define F77_CHAR_ARG(x) x
+#define F77_CONST_CHAR_ARG(x) F77_CHAR_ARG (x)
+#define F77_CHAR_ARG2(x, l) x
+#define F77_CONST_CHAR_ARG2(x, l) F77_CHAR_ARG2 (x, l)
+#define F77_CXX_STRING_ARG(x) F77_CONST_CHAR_ARG2 (x.c_str (), x.length ())
+#define F77_CHAR_ARG_LEN(l) , (long) l
+#define F77_CHAR_ARG_DECL char *
+#define F77_CONST_CHAR_ARG_DECL const char *
+#define F77_CHAR_ARG_LEN_DECL , long
+#define F77_RET_T int
+#define F77_RETURN(retval) return retval;
+
+#endif
+
+extern F77_RET_T
+F77_FUNC (xstopx, XSTOPX) (const char *s, long int slen) GCC_ATTR_NORETURN;
+
 #ifdef __cplusplus
 }
 #endif
 
 #endif
 
 /*
 ;;; Local Variables: ***
diff --git a/libcruft/misc/machar.c b/libcruft/misc/machar.c
--- a/libcruft/misc/machar.c
+++ b/libcruft/misc/machar.c
@@ -359,18 +359,21 @@ rmachar(ibeta,it,irnd,ngrd,machep,negep,
          }
 
       }
 
     return;
 
 }
 
-void
-F77_FUNC(machar,MACHAR) (REAL *xmin, REAL *xmax, REAL *epsneg, REAL *eps, REAL *log10_ibeta)
+F77_RET_T
+F77_FUNC (machar, MACHAR) (REAL *xmin, REAL *xmax, REAL *epsneg,
+			   REAL *eps, REAL *log10_ibeta)
 {
   int ibeta, iexp, irnd, it, machep, maxexp, minexp, negep, ngrd;
 
   rmachar (&ibeta, &it, &irnd, &ngrd, &machep, &negep, &iexp, &minexp,
 	   &maxexp, eps, epsneg, xmin, xmax);
 
   *log10_ibeta = log10 ((REAL) ibeta);
+
+  F77_RETURN (0)
 }
diff --git a/liboctave/CColVector.cc b/liboctave/CColVector.cc
--- a/liboctave/CColVector.cc
+++ b/liboctave/CColVector.cc
@@ -36,21 +36,22 @@ Software Foundation, 59 Temple Place - S
 #include "mx-base.h"
 #include "mx-inlines.cc"
 #include "oct-cmplx.h"
 
 // Fortran functions we call.
 
 extern "C"
 {
-  int F77_FUNC (zgemv, ZGEMV) (const char*, const int&, const int&,
-			      const Complex&, const Complex*,
-			      const int&, const Complex*, const int&,
-			      const Complex&, Complex*, const int&,
-			      long);
+  F77_RET_T
+  F77_FUNC (zgemv, ZGEMV) (F77_CONST_CHAR_ARG_DECL,
+			   const int&, const int&, const Complex&,
+			   const Complex*, const int&, const Complex*,
+			   const int&, const Complex&, Complex*, const int&
+			   F77_CHAR_ARG_LEN_DECL);
 }
 
 // Complex Column Vector class
 
 ComplexColumnVector::ComplexColumnVector (const ColumnVector& a)
    : MArray<Complex> (a.length ())
 {
   for (int i = 0; i < length (); i++)
@@ -345,18 +346,20 @@ operator * (const ComplexMatrix& m, cons
 	retval.resize (nr, 0.0);
       else
 	{
 	  int ld = nr;
 
 	  retval.resize (nr);
 	  Complex *y = retval.fortran_vec ();
 
-	  F77_XFCN (zgemv, ZGEMV, ("N", nr, nc, 1.0, m.data (), ld,
-				   a.data (), 1, 0.0, y, 1, 1L));
+	  F77_XFCN (zgemv, ZGEMV, (F77_CONST_CHAR_ARG2 ("N", 1),
+				   nr, nc, 1.0, m.data (), ld,
+				   a.data (), 1, 0.0, y, 1
+				   F77_CHAR_ARG_LEN (1)));
 
 	  if (f77_exception_encountered)
 	    (*current_liboctave_error_handler)
 	      ("unrecoverable error in zgemv");
 	}
     }
 
   return retval;
diff --git a/liboctave/CMatrix.cc b/liboctave/CMatrix.cc
--- a/liboctave/CMatrix.cc
+++ b/liboctave/CMatrix.cc
@@ -58,75 +58,100 @@ Software Foundation, 59 Temple Place - S
 #ifdef HAVE_FFTW
 #include "oct-fftw.h"
 #endif
 
 // Fortran functions we call.
 
 extern "C"
 {
-  int F77_FUNC (zgebal, ZGEBAL) (const char*, const int&, Complex*,
-                                const int&, int&, int&, double*, int&,
-                                long, long);
-
-  int F77_FUNC (dgebak, DGEBAK) (const char*, const char*, const int&,
-                                const int&, const int&, double*,
-                                const int&, double*, const int&,
-                                int&, long, long);
-
-  int F77_FUNC (zgemm, ZGEMM) (const char*, const char*, const int&,
-			      const int&, const int&, const Complex&,
-			      const Complex*, const int&,
-			      const Complex*, const int&,
-			      const Complex&, Complex*, const int&, 
-			      long, long);
-
-  int F77_FUNC (zgetrf, ZGETRF) (const int&, const int&, Complex*, const int&,
-			      int*, int&);
-
-  int F77_FUNC (zgetrs, ZGETRS) (const char*, const int&, const int&, 
-			      Complex*, const int&,
-			      const int*, Complex*, const int&, int&);
-
-  int F77_FUNC (zgetri, ZGETRI) (const int&, Complex*, const int&, const int*,
-			      Complex*, const int&, int&);
-
-  int F77_FUNC (zgecon, ZGECON) (const char*, const int&, Complex*, 
-				 const int&, const double&, double&, 
-				 Complex*, double*, int&);
-
-  int F77_FUNC (zgelss, ZGELSS) (const int&, const int&, const int&,
-				Complex*, const int&, Complex*,
-				const int&, double*, double&, int&,
-				Complex*, const int&, double*, int&);
+  F77_RET_T
+  F77_FUNC (zgebal, ZGEBAL) (F77_CONST_CHAR_ARG_DECL,
+			     const int&, Complex*, const int&, int&,
+			     int&, double*, int&
+			     F77_CHAR_ARG_LEN_DECL);
+
+  F77_RET_T
+  F77_FUNC (dgebak, DGEBAK) (F77_CONST_CHAR_ARG_DECL,
+			     F77_CONST_CHAR_ARG_DECL,
+			     const int&, const int&, const int&, double*,
+			     const int&, double*, const int&, int&
+			     F77_CHAR_ARG_LEN_DECL
+			     F77_CHAR_ARG_LEN_DECL);
+
+  F77_RET_T
+  F77_FUNC (zgemm, ZGEMM) (F77_CONST_CHAR_ARG_DECL,
+			   F77_CONST_CHAR_ARG_DECL,
+			   const int&, const int&, const int&,
+			   const Complex&, const Complex*, const int&,
+			   const Complex*, const int&, const Complex&,
+			   Complex*, const int&
+			   F77_CHAR_ARG_LEN_DECL
+			   F77_CHAR_ARG_LEN_DECL);
+
+  F77_RET_T
+  F77_FUNC (zgetrf, ZGETRF) (const int&, const int&, Complex*, const int&,
+			     int*, int&);
+
+  F77_RET_T
+  F77_FUNC (zgetrs, ZGETRS) (F77_CONST_CHAR_ARG_DECL,
+			     const int&, const int&, Complex*, const int&,
+			     const int*, Complex*, const int&, int&
+			     F77_CHAR_ARG_LEN_DECL);
+
+  F77_RET_T
+  F77_FUNC (zgetri, ZGETRI) (const int&, Complex*, const int&, const int*,
+			     Complex*, const int&, int&);
+
+  F77_RET_T
+  F77_FUNC (zgecon, ZGECON) (F77_CONST_CHAR_ARG_DECL,
+			     const int&, Complex*, 
+			     const int&, const double&, double&, 
+			     Complex*, double*, int&
+			     F77_CHAR_ARG_LEN_DECL);
+
+  F77_RET_T
+  F77_FUNC (zgelss, ZGELSS) (const int&, const int&, const int&,
+			     Complex*, const int&, Complex*,
+			     const int&, double*, double&, int&,
+			     Complex*, const int&, double*, int&);
 
   // Note that the original complex fft routines were not written for
   // double complex arguments.  They have been modified by adding an
   // implicit double precision (a-h,o-z) statement at the beginning of
   // each subroutine.
 
-  int F77_FUNC (cffti, CFFTI) (const int&, Complex*);
-
-  int F77_FUNC (cfftf, CFFTF) (const int&, Complex*, Complex*);
-
-  int F77_FUNC (cfftb, CFFTB) (const int&, Complex*, Complex*);
-
-  int F77_FUNC (zlartg, ZLARTG) (const Complex&, const Complex&,
-				double&, Complex&, Complex&);
-
-  int F77_FUNC (ztrsyl, ZTRSYL) (const char*, const char*, const int&,
-				const int&, const int&,
-				const Complex*, const int&,
-				const Complex*, const int&, 
-				const Complex*, const int&, double&,
-				int&, long, long);
-
-  int F77_FUNC (xzlange, XZLANGE) (const char*, const int&,
-				  const int&, const Complex*,
-				  const int&, double*, double&); 
+  F77_RET_T
+  F77_FUNC (cffti, CFFTI) (const int&, Complex*);
+
+  F77_RET_T
+  F77_FUNC (cfftf, CFFTF) (const int&, Complex*, Complex*);
+
+  F77_RET_T
+  F77_FUNC (cfftb, CFFTB) (const int&, Complex*, Complex*);
+
+  F77_RET_T
+  F77_FUNC (zlartg, ZLARTG) (const Complex&, const Complex&,
+			     double&, Complex&, Complex&);
+
+  F77_RET_T
+  F77_FUNC (ztrsyl, ZTRSYL) (F77_CONST_CHAR_ARG_DECL,
+			     F77_CONST_CHAR_ARG_DECL,
+			     const int&, const int&, const int&,
+			     const Complex*, const int&,
+			     const Complex*, const int&,
+			     const Complex*, const int&, double&, int&
+			     F77_CHAR_ARG_LEN_DECL
+			     F77_CHAR_ARG_LEN_DECL);
+
+  F77_RET_T
+  F77_FUNC (xzlange, XZLANGE) (F77_CONST_CHAR_ARG_DECL,
+			       const int&, const int&, const Complex*,
+			       const int&, double*, double&
+			       F77_CHAR_ARG_LEN_DECL);
 }
 
 static const Complex Complex_NaN_result (octave_NaN, octave_NaN);
 
 // Complex Matrix class
 
 ComplexMatrix::ComplexMatrix (const Matrix& a)
   : MArray2<Complex> (a.rows (), a.cols ())
@@ -997,33 +1022,35 @@ ComplexMatrix::inverse (int& info, doubl
 	  if (info != 0) 
 	    info = -1;
 	  else if (calc_cond) 
 	    {
 	      // Now calculate the condition number for non-singular matrix.
 	      char job = '1';
 	      Array<double> rz (2 * nc);
 	      double *prz = rz.fortran_vec ();
-	      F77_XFCN (zgecon, ZGECON, (&job, nc, tmp_data, nr, anorm, 
-					 rcond, pz, prz, info));
+	      F77_XFCN (zgecon, ZGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
+					 nc, tmp_data, nr, anorm, 
+					 rcond, pz, prz, info
+					 F77_CHAR_ARG_LEN (1)));
 
 	      if (f77_exception_encountered)
 		(*current_liboctave_error_handler) 
 		  ("unrecoverable error in zgecon");
 
 	      if (info != 0) 
 		info = -1;
 	    }
 
 	  if (info == -1 && ! force)
 	    retval = *this;  // Restore contents.
 	  else
 	    {
 	      F77_XFCN (zgetri, ZGETRI, (nc, tmp_data, nr, pipvt,
-				       pz, lwork, info));
+					 pz, lwork, info));
 
 	      if (f77_exception_encountered)
 		(*current_liboctave_error_handler)
 		  ("unrecoverable error in zgetri");
 
 	      if (info != 0) 
 		info = -1;
 	    }
@@ -1460,18 +1487,20 @@ ComplexMatrix::determinant (int& info, d
 		{
 		  // Now calc the condition number for non-singular matrix.
 		  char job = '1';
 		  Array<Complex> z (2*nr);
 		  Complex *pz = z.fortran_vec ();
 		  Array<double> rz (2*nr);
 		  double *prz = rz.fortran_vec ();
 		  
-		  F77_XFCN (zgecon, ZGECON, (&job, nc, tmp_data, nr, anorm, 
-					     rcond, pz, prz, info));
+		  F77_XFCN (zgecon, ZGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
+					     nc, tmp_data, nr, anorm, 
+					     rcond, pz, prz, info
+					     F77_CHAR_ARG_LEN (1)));
 
 		  if (f77_exception_encountered)
 		    (*current_liboctave_error_handler) 
 		      ("unrecoverable error in zgecon");
 		}
 
 	      if (info != 0) 
 		{
@@ -1604,18 +1633,20 @@ ComplexMatrix::solve (const ComplexMatri
 		(*current_liboctave_error_handler)
 		  ("matrix singular to machine precision");
 
 	    } 
 	  else 
 	    {
 	      // Now calculate the condition number for non-singular matrix.
 	      char job = '1';
-	      F77_XFCN (zgecon, ZGECON, (&job, nc, tmp_data, nr, anorm, 
-					 rcond, pz, prz, info));
+	      F77_XFCN (zgecon, ZGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
+					 nc, tmp_data, nr, anorm, 
+					 rcond, pz, prz, info
+					 F77_CHAR_ARG_LEN (1)));
 
 	      if (f77_exception_encountered)
 		(*current_liboctave_error_handler) 
 		  ("unrecoverable error in zgecon");
 
 	      if (info != 0) 
 		info = -2;
 
@@ -1635,18 +1666,20 @@ ComplexMatrix::solve (const ComplexMatri
 	      else
 		{
 		  retval = b;
 		  Complex *result = retval.fortran_vec ();
 
 		  int b_nc = b.cols ();
 
 		  char job = 'N';
-		  F77_XFCN (zgetrs, ZGETRS, (&job, nr, b_nc, tmp_data, nr,
-					     pipvt, result, b.rows(), info)); 
+		  F77_XFCN (zgetrs, ZGETRS, (F77_CONST_CHAR_ARG2 (&job, 1),
+					     nr, b_nc, tmp_data, nr,
+					     pipvt, result, b.rows(), info
+					     F77_CHAR_ARG_LEN (1))); 
 
 		  if (f77_exception_encountered)
 		    (*current_liboctave_error_handler)
 		      ("unrecoverable error in zgetrs");
 		}
 	    }
 	}
     }
@@ -1753,18 +1786,20 @@ ComplexMatrix::solve (const ComplexColum
 		(*current_liboctave_error_handler)
 		  ("matrix singular to machine precision, rcond = %g",
 		   rcond);
 	    } 
 	  else 
 	    {
 	      // Now calculate the condition number for non-singular matrix.
 	      char job = '1';
-	      F77_XFCN (zgecon, ZGECON, (&job, nc, tmp_data, nr, anorm, 
-					 rcond, pz, prz, info));
+	      F77_XFCN (zgecon, ZGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
+					 nc, tmp_data, nr, anorm,
+					 rcond, pz, prz, info
+					 F77_CHAR_ARG_LEN (1)));
 
 	      if (f77_exception_encountered)
 		(*current_liboctave_error_handler) 
 		  ("unrecoverable error in zgecon");
 
 	      if (info != 0) 
 		info = -2;
 
@@ -1782,18 +1817,20 @@ ComplexMatrix::solve (const ComplexColum
 		       rcond);
 		}
 	      else
 		{
 		  retval = b;
 		  Complex *result = retval.fortran_vec ();
 
 		  char job = 'N';
-		  F77_XFCN (zgetrs, ZGETRS, (&job, nr, 1, tmp_data, nr, pipvt,
-					     result, b.length(), info)); 
+		  F77_XFCN (zgetrs, ZGETRS, (F77_CONST_CHAR_ARG2 (&job, 1),
+					     nr, 1, tmp_data, nr, pipvt,
+					     result, b.length(), info
+					     F77_CHAR_ARG_LEN (1))); 
 
 		  if (f77_exception_encountered)
 		    (*current_liboctave_error_handler)
 		      ("unrecoverable error in zgetrs");
 
 		}
 	    }
 	}
@@ -2074,43 +2111,49 @@ ComplexMatrix::expm (void) const
   int info, ilo, ihi,ilos,ihis;
   Array<double> dpermute (nc);
   Array<double> dscale (nc);
 
   // XXX FIXME XXX -- should pass job as a parameter in expm
 
   // Permute first
   char job = 'P';
-  F77_XFCN (zgebal, ZGEBAL, (&job, nc, mp, nc, ilo, ihi,
-            dpermute.fortran_vec (), info, 1L, 1L));
+  F77_XFCN (zgebal, ZGEBAL, (F77_CONST_CHAR_ARG2 (&job, 1),
+			     nc, mp, nc, ilo, ihi,
+			     dpermute.fortran_vec (), info
+			     F77_CHAR_ARG_LEN (1)));
 
   if (f77_exception_encountered)
     {
       (*current_liboctave_error_handler) ("unrecoverable error in zgebal");
       return retval;
     }
 
   // then scale
   job = 'S';
-  F77_XFCN (zgebal, ZGEBAL, (&job, nc, mp, nc, ilos, ihis,
-            dscale.fortran_vec (), info, 1L, 1L));
+  F77_XFCN (zgebal, ZGEBAL, (F77_CONST_CHAR_ARG2 (&job, 1),
+			     nc, mp, nc, ilos, ihis,
+			     dscale.fortran_vec (), info
+			     F77_CHAR_ARG_LEN (1)));
 
   if (f77_exception_encountered)
     {
       (*current_liboctave_error_handler) ("unrecoverable error in zgebal");
       return retval;
     }
 
   // Preconditioning step 3: scaling.
 
   ColumnVector work (nc);
   double inf_norm;
 
-  F77_XFCN (xzlange, XZLANGE, ("I", nc, nc, m.fortran_vec (), nc,
-			       work.fortran_vec (), inf_norm));
+  F77_XFCN (xzlange, XZLANGE, (F77_CONST_CHAR_ARG2 ("I", 1),
+			       nc, nc, m.fortran_vec (), nc,
+			       work.fortran_vec (), inf_norm
+			       F77_CHAR_ARG_LEN (1)));
 
   if (f77_exception_encountered)
     {
       (*current_liboctave_error_handler) ("unrecoverable error in zlange");
       return retval;
     }
 
   int sqpow = (inf_norm > 0.0
@@ -2241,19 +2284,22 @@ operator * (const ComplexColumnVector& v
 
   if (len != 0)
     {
       int a_len = a.length ();
 
       retval.resize (len, a_len);
       Complex *c = retval.fortran_vec ();
 
-      F77_XFCN (zgemm, ZGEMM, ("N", "N", len, a_len, 1, 1.0,
-			       v.data (), len, a.data (), 1, 0.0,
-			       c, len, 1L, 1L)); 
+      F77_XFCN (zgemm, ZGEMM, (F77_CONST_CHAR_ARG2 ("N", 1),
+			       F77_CONST_CHAR_ARG2 ("N", 1),
+			       len, a_len, 1, 1.0, v.data (), len,
+			       a.data (), 1, 0.0, c, len
+			       F77_CHAR_ARG_LEN (1)
+			       F77_CHAR_ARG_LEN (1)));
 
       if (f77_exception_encountered)
 	(*current_liboctave_error_handler)
 	  ("unrecoverable error in zgemm");
     }
 
   return retval;
 }
@@ -3125,19 +3171,22 @@ Sylvester (const ComplexMatrix& a, const
 
   double scale;
   int info;
 
   Complex *pa = sch_a.fortran_vec ();
   Complex *pb = sch_b.fortran_vec ();
   Complex *px = cx.fortran_vec ();
   
-  F77_XFCN (ztrsyl, ZTRSYL, ("N", "N", 1, a_nr, b_nr, pa, a_nr, pb,
-			     b_nr, px, a_nr, scale,
-			     info, 1L, 1L));
+  F77_XFCN (ztrsyl, ZTRSYL, (F77_CONST_CHAR_ARG2 ("N", 1),
+			     F77_CONST_CHAR_ARG2 ("N", 1),
+			     1, a_nr, b_nr, pa, a_nr, pb,
+			     b_nr, px, a_nr, scale, info
+			     F77_CHAR_ARG_LEN (1)
+			     F77_CHAR_ARG_LEN (1)));
 
   if (f77_exception_encountered)
     (*current_liboctave_error_handler) ("unrecoverable error in ztrsyl");
   else
     {
       // XXX FIXME XXX -- check info?
 
       retval = -ua * cx * ub.hermitian ();
@@ -3180,19 +3229,22 @@ operator * (const ComplexMatrix& m, cons
       else
 	{
 	  int ld  = nr;
 	  int lda = a.rows ();
 
 	  retval.resize (nr, a_nc);
 	  Complex *c = retval.fortran_vec ();
 
-	  F77_XFCN (zgemm, ZGEMM, ("N", "N", nr, a_nc, nc, 1.0,
-				   m.data (), ld, a.data (), lda, 0.0,
-				   c, nr, 1L, 1L));
+	  F77_XFCN (zgemm, ZGEMM, (F77_CONST_CHAR_ARG2 ("N", 1),
+				   F77_CONST_CHAR_ARG2 ("N", 1),
+				   nr, a_nc, nc, 1.0, m.data (),
+				   ld, a.data (), lda, 0.0, c, nr
+				   F77_CHAR_ARG_LEN (1)
+				   F77_CHAR_ARG_LEN (1)));
 
 	  if (f77_exception_encountered)
 	    (*current_liboctave_error_handler)
 	      ("unrecoverable error in zgemm");
 	}
     }
 
   return retval;
diff --git a/liboctave/CRowVector.cc b/liboctave/CRowVector.cc
--- a/liboctave/CRowVector.cc
+++ b/liboctave/CRowVector.cc
@@ -36,21 +36,22 @@ Software Foundation, 59 Temple Place - S
 #include "mx-base.h"
 #include "mx-inlines.cc"
 #include "oct-cmplx.h"
 
 // Fortran functions we call.
 
 extern "C"
 {
-  int F77_FUNC (zgemv, ZGEMV) (const char*, const int&, const int&,
-			      const Complex&, const Complex*,
-			      const int&, const Complex*, const int&,
-			      const Complex&, Complex*, const int&,
-			      long);
+  F77_RET_T
+  F77_FUNC (zgemv, ZGEMV) (F77_CONST_CHAR_ARG_DECL,
+			   const int&, const int&, const Complex&,
+			   const Complex*, const int&, const Complex*,
+			   const int&, const Complex&, Complex*, const int&
+			   F77_CHAR_ARG_LEN_DECL);
 }
 
 // Complex Row Vector class
 
 ComplexRowVector::ComplexRowVector (const RowVector& a)
   : MArray<Complex> (a.length ())
 {
   for (int i = 0; i < length (); i++)
@@ -342,18 +343,20 @@ operator * (const ComplexRowVector& v, c
 	{
 	  // Transpose A to form A'*x == (x'*A)'
 
 	  int ld = a_nr;
 
 	  retval.resize (a_nc);
 	  Complex *y = retval.fortran_vec ();
 
-	  F77_XFCN (zgemv, ZGEMV, ("T", a_nr, a_nc, 1.0, a.data (),
-				   ld, v.data (), 1, 0.0, y, 1, 1L));
+	  F77_XFCN (zgemv, ZGEMV, (F77_CONST_CHAR_ARG2 ("T", 1),
+				   a_nr, a_nc, 1.0, a.data (),
+				   ld, v.data (), 1, 0.0, y, 1
+				   F77_CHAR_ARG_LEN (1)));
 
 	  if (f77_exception_encountered)
 	    (*current_liboctave_error_handler)
 	      ("unrecoverable error in zgemv");
 	}
     }
 
   return retval;
diff --git a/liboctave/ChangeLog b/liboctave/ChangeLog
--- a/liboctave/ChangeLog
+++ b/liboctave/ChangeLog
@@ -1,8 +1,20 @@
+2003-10-27  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* oct-rand.cc, CColVector.cc, CMatrix.cc, CRowVector.cc,
+	CmplxAEPBAL.cc CmplxCHOL.cc, CmplxHESS.cc, CmplxLU.cc, CmplxQR.cc,
+	CmplxQRP.cc, CmplxSCHUR.cc, CmplxSVD.cc, CollocWt.cc, DASPK.cc,
+	DASRT.cc, DASSL.cc, EIG.cc, LSODE.cc,  NLEqn.cc, ODESSA.cc,
+	Quad.cc, dColVector.cc, dMatrix.cc, dRowVector.cc, dbleAEPBAL.cc,
+	dbleCHOL.cc, dbleHESS.cc, dbleLU.cc, dbleQR.cc, dbleQRP.cc,
+	dbleSCHUR.cc, dbleSVD.cc, lo-specfun.cc:
+	Use new F77 arg macros in declarations of external Fortran
+	subroutines and for calling them.
+
 2003-10-25  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* Array.cc (Array<T>::resize_no_fill (const dim_vector&)):
 	Allow number of dimensions to change.
 	(Array<T>::resize_no_fill (int, int)): Require ndims to be 0 or 2.
 	(Array<T>::resize_and_fill (int, int, const T&)): Likewise.
 	(Array<T>::resize_no_fill (int, int, int)): Require ndims to be 0 or 3.
 	(Array<T>::resize_and_fill (int, int, int, const T&)): Likewise.
diff --git a/liboctave/CmplxAEPBAL.cc b/liboctave/CmplxAEPBAL.cc
--- a/liboctave/CmplxAEPBAL.cc
+++ b/liboctave/CmplxAEPBAL.cc
@@ -31,24 +31,29 @@ Software Foundation, 59 Temple Place - S
 #include <string>
 
 #include "CmplxAEPBAL.h"
 #include "dMatrix.h"
 #include "f77-fcn.h"
 
 extern "C"
 {
-  int F77_FUNC (zgebal, ZGEBAL) (const char*, const int&, Complex*,
-				const int&, int&, int&, double*, int&,
-				long, long);
+  F77_RET_T
+  F77_FUNC (zgebal, ZGEBAL) (F77_CONST_CHAR_ARG_DECL,
+			     const int&, Complex*, const int&, int&,
+			     int&, double*, int&
+			     F77_CHAR_ARG_LEN_DECL);
  
-  int F77_FUNC (zgebak, ZGEBAK) (const char*, const char*, const int&,
-				const int&, const int&, double*, const
-				int&, Complex*, const int&, int&,
-				long, long);
+  F77_RET_T
+  F77_FUNC (zgebak, ZGEBAK) (F77_CONST_CHAR_ARG_DECL,
+			     F77_CONST_CHAR_ARG_DECL,
+			     const int&, const int&, const int&, double*,
+			     const int&, Complex*, const int&, int&
+			     F77_CHAR_ARG_LEN_DECL
+			     F77_CHAR_ARG_LEN_DECL);
 }
 
 int
 ComplexAEPBALANCE::init (const ComplexMatrix& a,
 			 const std::string& balance_job)
 {
   int n = a.cols ();
 
@@ -65,33 +70,39 @@ ComplexAEPBALANCE::init (const ComplexMa
   Array<double> scale (n);
   double *pscale = scale.fortran_vec ();
 
   balanced_mat = a;
   Complex *p_balanced_mat = balanced_mat.fortran_vec ();
 
   char job = balance_job[0];
 
-  F77_XFCN (zgebal, ZGEBAL, (&job, n, p_balanced_mat, n, ilo, ihi,
-			     pscale, info, 1L, 1L));
+  F77_XFCN (zgebal, ZGEBAL, (F77_CONST_CHAR_ARG2 (&job, 1),
+			     n, p_balanced_mat, n, ilo, ihi,
+			     pscale, info
+			     F77_CHAR_ARG_LEN (1)));
 
   if (f77_exception_encountered)
     (*current_liboctave_error_handler) ("unrecoverable error in zgebal");
   else
     {
       balancing_mat = ComplexMatrix (n, n, 0.0);
       for (int i = 0; i < n; i++)
 	balancing_mat.elem (i, i) = 1.0;
 
       Complex *p_balancing_mat = balancing_mat.fortran_vec ();
 
       char side = 'R';
 
-      F77_XFCN (zgebak, ZGEBAK, (&job, &side, n, ilo, ihi, pscale, n,
-				 p_balancing_mat, n, info, 1L, 1L));
+      F77_XFCN (zgebak, ZGEBAK, (F77_CONST_CHAR_ARG2 (&job, 1),
+				 F77_CONST_CHAR_ARG2 (&side, 1),
+				 n, ilo, ihi, pscale, n,
+				 p_balancing_mat, n, info
+				 F77_CHAR_ARG_LEN (1)
+				 F77_CHAR_ARG_LEN (1)));
 
       if (f77_exception_encountered)
 	(*current_liboctave_error_handler) ("unrecoverable error in zgebak");
     }
 
   return info;
 }
 
diff --git a/liboctave/CmplxCHOL.cc b/liboctave/CmplxCHOL.cc
--- a/liboctave/CmplxCHOL.cc
+++ b/liboctave/CmplxCHOL.cc
@@ -29,18 +29,20 @@ Software Foundation, 59 Temple Place - S
 #endif
 
 #include "CmplxCHOL.h"
 #include "f77-fcn.h"
 #include "lo-error.h"
 
 extern "C"
 {
-  int F77_FUNC (zpotrf, ZPOTRF) (const char*, const int&, Complex*,
-				const int&, int&, long);
+  F77_RET_T
+  F77_FUNC (zpotrf, ZPOTRF) (F77_CONST_CHAR_ARG_DECL,
+			     const int&, Complex*, const int&, int&
+			     F77_CHAR_ARG_LEN_DECL);
 }
 
 int
 ComplexCHOL::init (const ComplexMatrix& a)
 {
   int a_nr = a.rows ();
   int a_nc = a.cols ();
 
@@ -52,17 +54,18 @@ ComplexCHOL::init (const ComplexMatrix& 
     }
 
   int n = a_nc;
   int info;
 
   chol_mat = a;
   Complex *h = chol_mat.fortran_vec ();
 
-  F77_XFCN (zpotrf, ZPOTRF, ("U", n, h, n, info, 1L));
+  F77_XFCN (zpotrf, ZPOTRF, (F77_CONST_CHAR_ARG2 ("U", 1), n, h, n, info
+			     F77_CHAR_ARG_LEN (1)));
 
   if (f77_exception_encountered)
     (*current_liboctave_error_handler) ("unrecoverable error in zpotrf");
   else
     {
       // If someone thinks of a more graceful way of doing this (or
       // faster for that matter :-)), please let me know!
 
diff --git a/liboctave/CmplxHESS.cc b/liboctave/CmplxHESS.cc
--- a/liboctave/CmplxHESS.cc
+++ b/liboctave/CmplxHESS.cc
@@ -29,33 +29,39 @@ Software Foundation, 59 Temple Place - S
 #endif
 
 #include "CmplxHESS.h"
 #include "f77-fcn.h"
 #include "lo-error.h"
 
 extern "C"
 {
-  int F77_FUNC (zgebal, ZGEBAL) (const char*, const int&, Complex*,
-				const int&, int&, int&, double*, int&,
-				long, long);
+  F77_RET_T
+  F77_FUNC (zgebal, ZGEBAL) (F77_CONST_CHAR_ARG_DECL,
+			     const int&, Complex*, const int&,
+			     int&, int&, double*, int&
+			     F77_CHAR_ARG_LEN_DECL);
  
-  int F77_FUNC (zgehrd, ZGEHRD) (const int&, const int&, const int&,
-				Complex*, const int&, Complex*,
-				Complex*, const int&, int&, long,
-				long);
+  F77_RET_T
+  F77_FUNC (zgehrd, ZGEHRD) (const int&, const int&, const int&,
+			     Complex*, const int&, Complex*,
+			     Complex*, const int&, int&);
  
-  int F77_FUNC (zunghr, ZUNGHR) (const int&, const int&, const int&,
-				Complex*, const int&, Complex*,
-				Complex*, const int&, int&, long, long);
+  F77_RET_T
+  F77_FUNC (zunghr, ZUNGHR) (const int&, const int&, const int&,
+			     Complex*, const int&, Complex*,
+			     Complex*, const int&, int&);
 
-  int F77_FUNC (zgebak, ZGEBAK) (const char*, const char*, const int&,
-				const int&, const int&, double*,
-				const int&, Complex*, const int&,
-				int&, long, long);
+  F77_RET_T
+  F77_FUNC (zgebak, ZGEBAK) (F77_CONST_CHAR_ARG_DECL,
+			     F77_CONST_CHAR_ARG_DECL,
+			     const int&, const int&, const int&, double*,
+			     const int&, Complex*, const int&, int&
+			     F77_CHAR_ARG_LEN_DECL
+			     F77_CHAR_ARG_LEN_DECL);
 }
 
 int
 ComplexHESS::init (const ComplexMatrix& a)
 {
   int a_nr = a.rows ();
   int a_nc = a.cols ();
 
@@ -76,49 +82,52 @@ ComplexHESS::init (const ComplexMatrix& 
   int ihi;
 
   hess_mat = a;
   Complex *h = hess_mat.fortran_vec ();
 
   Array<double> scale (n);
   double *pscale = scale.fortran_vec ();
 
-  F77_XFCN (zgebal, ZGEBAL, (&job, n, h, n, ilo, ihi, pscale, info,
-			     1L, 1L));
+  F77_XFCN (zgebal, ZGEBAL, (F77_CONST_CHAR_ARG2 (&job, 1),
+			     n, h, n, ilo, ihi, pscale, info
+			     F77_CHAR_ARG_LEN (1)));
 
   if (f77_exception_encountered)
     (*current_liboctave_error_handler) ("unrecoverable error in zgebal");
   else
     {
       Array<Complex> tau (n-1);
       Complex *ptau = tau.fortran_vec ();
 
       Array<Complex> work (lwork);
       Complex *pwork = work.fortran_vec ();
 
-      F77_XFCN (zgehrd, ZGEHRD, (n, ilo, ihi, h, n, ptau, pwork, lwork,
-				 info, 1L, 1L));
+      F77_XFCN (zgehrd, ZGEHRD, (n, ilo, ihi, h, n, ptau, pwork, lwork, info));
 
       if (f77_exception_encountered)
 	(*current_liboctave_error_handler) ("unrecoverable error in zgehrd");
       else
 	{
 	  unitary_hess_mat = hess_mat;
 	  Complex *z = unitary_hess_mat.fortran_vec ();
 
 	  F77_XFCN (zunghr, ZUNGHR, (n, ilo, ihi, z, n, ptau, pwork,
-				     lwork, info, 1L, 1L));
+				     lwork, info));
 
 	  if (f77_exception_encountered)
 	    (*current_liboctave_error_handler)
 	      ("unrecoverable error in zunghr");
 	  else
 	    {
-	      F77_XFCN (zgebak, ZGEBAK, (&job, &side, n, ilo, ihi,
-					 pscale, n, z, n, info, 1L, 1L));
+	      F77_XFCN (zgebak, ZGEBAK, (F77_CONST_CHAR_ARG2 (&job, 1),
+					 F77_CONST_CHAR_ARG2 (&side, 1),
+					 n, ilo, ihi, pscale, n, z, n, info
+					 F77_CHAR_ARG_LEN (1)
+					 F77_CHAR_ARG_LEN (1)));
 
 	      if (f77_exception_encountered)
 		(*current_liboctave_error_handler)
 		  ("unrecoverable error in zgebak");
 	      else
 		{
 		  // If someone thinks of a more graceful way of
 		  // doing this (or faster for that matter :-)),
diff --git a/liboctave/CmplxLU.cc b/liboctave/CmplxLU.cc
--- a/liboctave/CmplxLU.cc
+++ b/liboctave/CmplxLU.cc
@@ -38,18 +38,19 @@ Software Foundation, 59 Temple Place - S
 #include <base-lu.cc>
 
 template class base_lu <ComplexMatrix, Complex, Matrix, double>;
 
 // Define the constructor for this particular derivation.
 
 extern "C"
 {
-  int F77_FUNC (zgetrf, ZGETRF) (const int&, const int&, Complex*,
-				const int&, int*, int&);
+  F77_RET_T
+  F77_FUNC (zgetrf, ZGETRF) (const int&, const int&, Complex*,
+			     const int&, int*, int&);
 }
 
 ComplexLU::ComplexLU (const ComplexMatrix& a)
 {
   int a_nr = a.rows ();
   int a_nc = a.cols ();
   int mn = (a_nr < a_nc ? a_nr : a_nc);
 
diff --git a/liboctave/CmplxQR.cc b/liboctave/CmplxQR.cc
--- a/liboctave/CmplxQR.cc
+++ b/liboctave/CmplxQR.cc
@@ -29,23 +29,25 @@ Software Foundation, 59 Temple Place - S
 #endif
 
 #include "CmplxQR.h"
 #include "f77-fcn.h"
 #include "lo-error.h"
 
 extern "C"
 {
-  int F77_FUNC (zgeqrf, ZGEQRF) (const int&, const int&, Complex*,
-				const int&, Complex*, Complex*,
-				const int&, int&); 
+  F77_RET_T
+  F77_FUNC (zgeqrf, ZGEQRF) (const int&, const int&, Complex*,
+			     const int&, Complex*, Complex*,
+			     const int&, int&); 
 
-  int F77_FUNC (zungqr, ZUNGQR) (const int&, const int&, const int&,
-				Complex*, const int&, Complex*,
-				Complex*, const int&, int&);
+  F77_RET_T
+  F77_FUNC (zungqr, ZUNGQR) (const int&, const int&, const int&,
+			     Complex*, const int&, Complex*,
+			     Complex*, const int&, int&);
 }
 
 ComplexQR::ComplexQR (const ComplexMatrix& a, QR::type qr_type)
   : q (), r ()
 {
   init (a, qr_type);
 }
 
diff --git a/liboctave/CmplxQRP.cc b/liboctave/CmplxQRP.cc
--- a/liboctave/CmplxQRP.cc
+++ b/liboctave/CmplxQRP.cc
@@ -31,23 +31,25 @@ Software Foundation, 59 Temple Place - S
 #include <cassert>
 
 #include "CmplxQRP.h"
 #include "f77-fcn.h"
 #include "lo-error.h"
 
 extern "C"
 {
-  int F77_FUNC (zgeqpf, ZGEQPF) (const int&, const int&, Complex*,
-				const int&, int*, Complex*, Complex*,
-				double*, int&);
+  F77_RET_T
+  F77_FUNC (zgeqpf, ZGEQPF) (const int&, const int&, Complex*,
+			     const int&, int*, Complex*, Complex*,
+			     double*, int&);
 
-  int F77_FUNC (zungqr, ZUNGQR) (const int&, const int&, const int&,
-				Complex*, const int&, Complex*,
-				Complex*, const int&, int&);
+  F77_RET_T
+  F77_FUNC (zungqr, ZUNGQR) (const int&, const int&, const int&,
+			     Complex*, const int&, Complex*,
+			     Complex*, const int&, int&);
 }
 
 // It would be best to share some of this code with ComplexQR class...
 
 ComplexQRP::ComplexQRP (const ComplexMatrix& a, QR::type qr_type)
   : ComplexQR (), p ()
 {
   init (a, qr_type);
diff --git a/liboctave/CmplxSCHUR.cc b/liboctave/CmplxSCHUR.cc
--- a/liboctave/CmplxSCHUR.cc
+++ b/liboctave/CmplxSCHUR.cc
@@ -29,23 +29,28 @@ Software Foundation, 59 Temple Place - S
 #endif
 
 #include "CmplxSCHUR.h"
 #include "f77-fcn.h"
 #include "lo-error.h"
 
 extern "C"
 {
-  int F77_FUNC (zgeesx, ZGEESX) (const char*, const char*,
-				ComplexSCHUR::select_function,
-				const char*, const int&, Complex*,
-				const int&, int&, Complex*, Complex*,
-				const int&, double&, double&,
-				Complex*, const int&, double*, int*,
-				int&, long, long, long);
+  F77_RET_T
+  F77_FUNC (zgeesx, ZGEESX) (F77_CONST_CHAR_ARG_DECL,
+			     F77_CONST_CHAR_ARG_DECL,
+			     ComplexSCHUR::select_function,
+			     F77_CONST_CHAR_ARG_DECL,
+			     const int&, Complex*, const int&, int&,
+			     Complex*, Complex*, const int&, double&,
+			     double&, Complex*, const int&, double*, int*,
+			     int&
+			     F77_CHAR_ARG_LEN_DECL
+			     F77_CHAR_ARG_LEN_DECL
+			     F77_CHAR_ARG_LEN_DECL);
 }
 
 static int
 select_ana (const Complex& a)
 {
   return a.real () < 0.0;
 }
 
@@ -108,19 +113,25 @@ ComplexSCHUR::init (const ComplexMatrix&
 
   Array<Complex> work (lwork);
   Complex *pwork = work.fortran_vec ();
 
   // BWORK is not referenced for non-ordered Schur.
   Array<int> bwork ((ord_char == 'N' || ord_char == 'n') ? 0 : n);
   int *pbwork = bwork.fortran_vec ();
 
-  F77_XFCN (zgeesx, ZGEESX, (&jobvs, &sort, selector, &sense, n, s, n,
-			     sdim, pw, q, n, rconde, rcondv, pwork,
-			     lwork, prwork, pbwork, info, 1L, 1L, 1L));
+  F77_XFCN (zgeesx, ZGEESX, (F77_CONST_CHAR_ARG2 (&jobvs, 1),
+			     F77_CONST_CHAR_ARG2 (&sort, 1),
+			     selector,
+			     F77_CONST_CHAR_ARG2 (&sense, 1),
+			     n, s, n, sdim, pw, q, n, rconde, rcondv,
+			     pwork, lwork, prwork, pbwork, info
+			     F77_CHAR_ARG_LEN (1)
+			     F77_CHAR_ARG_LEN (1)
+			     F77_CHAR_ARG_LEN (1)));
 
   if (f77_exception_encountered)
     (*current_liboctave_error_handler) ("unrecoverable error in zgeesx");
 
   return info;
 }
 
 /*
diff --git a/liboctave/CmplxSVD.cc b/liboctave/CmplxSVD.cc
--- a/liboctave/CmplxSVD.cc
+++ b/liboctave/CmplxSVD.cc
@@ -29,22 +29,25 @@ Software Foundation, 59 Temple Place - S
 #endif
 
 #include "CmplxSVD.h"
 #include "f77-fcn.h"
 #include "lo-error.h"
 
 extern "C"
 {
-  int F77_FUNC (zgesvd, ZGESVD) (const char*, const char*, const int&,
-				const int&, Complex*, const int&,
-				double*, Complex*, const int&,
-				Complex*, const int&, Complex*,
-				const int&, double*, int&, long,
-				long);
+  F77_RET_T
+  F77_FUNC (zgesvd, ZGESVD) (F77_CONST_CHAR_ARG_DECL,
+			     F77_CONST_CHAR_ARG_DECL,
+			     const int&, const int&, Complex*,
+			     const int&, double*, Complex*, const int&,
+			     Complex*, const int&, Complex*, const int&,
+			     double*, int&
+			     F77_CHAR_ARG_LEN_DECL
+			     F77_CHAR_ARG_LEN_DECL);
 }
 
 ComplexMatrix
 ComplexSVD::left_singular_matrix (void) const
 {
   if (type_computed == SVD::sigma_only)
     {
       (*current_liboctave_error_handler)
@@ -136,33 +139,38 @@ ComplexSVD::init (const ComplexMatrix& a
   Array<double> rwork (lrwork);
 
   // Ask ZGESVD what the dimension of WORK should be.
 
   int lwork = -1;
 
   Array<Complex> work (1);
 
-  F77_XFCN (zgesvd, ZGESVD, (&jobu, &jobv, m, n, tmp_data, m, s_vec,
-			     u, m, vt, nrow_vt, work.fortran_vec (),
-			     lwork, rwork.fortran_vec (), info, 1L,
-			     1L));
+  F77_XFCN (zgesvd, ZGESVD, (F77_CONST_CHAR_ARG2 (&jobu, 1),
+			     F77_CONST_CHAR_ARG2 (&jobv, 1),
+			     m, n, tmp_data, m, s_vec, u, m, vt,
+			     nrow_vt, work.fortran_vec (), lwork,
+			     rwork.fortran_vec (), info
+			     F77_CHAR_ARG_LEN (1)
+			     F77_CHAR_ARG_LEN (1)));
 
   if (f77_exception_encountered)
     (*current_liboctave_error_handler) ("unrecoverable error in zgesvd");
   else
     {
       lwork = static_cast<int> (work(0).real ());
       work.resize (lwork);
 
-      F77_XFCN (zgesvd, ZGESVD, (&jobu, &jobv, m, n, tmp_data, m,
-				 s_vec, u, m, vt, nrow_vt,
-				 work.fortran_vec (), lwork,
-				 rwork.fortran_vec (),
-				 info, 1L, 1L));
+      F77_XFCN (zgesvd, ZGESVD, (F77_CONST_CHAR_ARG2 (&jobu, 1),
+				 F77_CONST_CHAR_ARG2 (&jobv, 1),
+				 m, n, tmp_data, m, s_vec, u, m, vt,
+				 nrow_vt, work.fortran_vec (), lwork,
+				 rwork.fortran_vec (), info
+				 F77_CHAR_ARG_LEN (1)
+				 F77_CHAR_ARG_LEN (1)));
 
       if (f77_exception_encountered)
 	(*current_liboctave_error_handler) ("unrecoverable error in zgesvd");
       else
 	{
 	  if (! (jobv == 'N' || jobv == 'O'))
 	    right_sm = right_sm.hermitian ();
 	}
diff --git a/liboctave/CollocWt.cc b/liboctave/CollocWt.cc
--- a/liboctave/CollocWt.cc
+++ b/liboctave/CollocWt.cc
@@ -31,23 +31,25 @@ Software Foundation, 59 Temple Place - S
 #include <iostream>
 
 #include "CollocWt.h"
 #include "f77-fcn.h"
 #include "lo-error.h"
 
 extern "C"
 {
-  int F77_FUNC (jcobi, JCOBI) (int&, int&, int&, int&, double&,
-			      double&, double*, double*, double*,
-			      double*);
+  F77_RET_T
+  F77_FUNC (jcobi, JCOBI) (int&, int&, int&, int&, double&,
+			   double&, double*, double*, double*,
+			   double*);
 
-  int F77_FUNC (dfopr, DFOPR) (int&, int&, int&, int&, int&, int&,
-			      double*, double*, double*, double*,
-			      double*);
+  F77_RET_T
+  F77_FUNC (dfopr, DFOPR) (int&, int&, int&, int&, int&, int&,
+			   double*, double*, double*, double*,
+			   double*);
 }
 
 // Error handling.
 
 void
 CollocWt::error (const char* msg)
 {
   (*current_liboctave_error_handler) ("fatal CollocWt error: %s", msg);
diff --git a/liboctave/DASPK.cc b/liboctave/DASPK.cc
--- a/liboctave/DASPK.cc
+++ b/liboctave/DASPK.cc
@@ -48,22 +48,25 @@ typedef int (*daspk_jac_ptr) (const doub
 typedef int (*daspk_psol_ptr) (const int&, const double&,
 			       const double*, const double*,
 			       const double*, const double&,
 			       const double*, double*, int*,
 			       double*, const double&, int&,
 			       double*, int*);
 
 extern "C"
-int F77_FUNC (ddaspk, DDASPK) (daspk_fcn_ptr, const int&, double&,
-			      double*, double*, double&, const int*,
-			      const double*, const double*, int&,
-			      double*, const int&, int*, const int&,
-			      const double*, const int*,
-			      daspk_jac_ptr, daspk_psol_ptr);
+{
+  F77_RET_T
+  F77_FUNC (ddaspk, DDASPK) (daspk_fcn_ptr, const int&, double&,
+			     double*, double*, double&, const int*,
+			     const double*, const double*, int&,
+			     double*, const int&, int*, const int&,
+			     const double*, const int*,
+			     daspk_jac_ptr, daspk_psol_ptr);
+}
 
 static DAEFunc::DAERHSFunc user_fun;
 static DAEFunc::DAEJacFunc user_jac;
 static int nn;
 
 static int
 ddaspk_f (const double& time, const double *state, const double *deriv,
 	  const double&, double *delta, int& ires, double *, int *)
diff --git a/liboctave/DASRT.cc b/liboctave/DASRT.cc
--- a/liboctave/DASRT.cc
+++ b/liboctave/DASRT.cc
@@ -42,22 +42,25 @@ typedef int (*dasrt_fcn_ptr) (const doub
 
 typedef int (*dasrt_jac_ptr) (const double&, const double*, const double*,
 			      double*, const double&, double*, int*);
 
 typedef int (*dasrt_constr_ptr) (const int&, const double&, const double*,
 				 const int&, double*, double*, int*);
 
 extern "C"
-int F77_FUNC (ddasrt, DASRT) (dasrt_fcn_ptr, const int&, double&,
-			      double*, double*, const double&, int*,
-			      const double*, const double*, int&, double*,
-			      const int&, int*, const int&, double*,
-			      int*, dasrt_jac_ptr, dasrt_constr_ptr,
-			      const int&, int*);
+{
+  F77_RET_T
+  F77_FUNC (ddasrt, DASRT) (dasrt_fcn_ptr, const int&, double&,
+			    double*, double*, const double&, int*,
+			    const double*, const double*, int&, double*,
+			    const int&, int*, const int&, double*,
+			    int*, dasrt_jac_ptr, dasrt_constr_ptr,
+			    const int&, int*);
+}
 
 static DAEFunc::DAERHSFunc user_fsub;
 static DAEFunc::DAEJacFunc user_jsub;
 static DAERTFunc::DAERTConstrFunc user_csub;
 
 static int nn;
 
 static int
diff --git a/liboctave/DASSL.cc b/liboctave/DASSL.cc
--- a/liboctave/DASSL.cc
+++ b/liboctave/DASSL.cc
@@ -39,22 +39,25 @@ Software Foundation, 59 Temple Place - S
 
 typedef int (*dassl_fcn_ptr) (const double&, const double*, const double*,
 			      double*, int&, double*, int*);
 
 typedef int (*dassl_jac_ptr) (const double&, const double*, const double*,
 			      double*, const double&, double*, int*);
 
 extern "C"
-int F77_FUNC (ddassl, DDASSL) (dassl_fcn_ptr, const int&, double&,
-			       double*, double*, double&, const int*,
-			       const double*, const double*, int&,
-			       double*, const int&, int*, const int&,
-			       const double*, const int*,
-			       dassl_jac_ptr);
+{
+  F77_RET_T
+  F77_FUNC (ddassl, DDASSL) (dassl_fcn_ptr, const int&, double&,
+			     double*, double*, double&, const int*,
+			     const double*, const double*, int&,
+			     double*, const int&, int*, const int&,
+			     const double*, const int*,
+			     dassl_jac_ptr);
+}
 
 static DAEFunc::DAERHSFunc user_fun;
 static DAEFunc::DAEJacFunc user_jac;
 
 static int nn;
 
 static int
 ddassl_f (const double& time, const double *state, const double *deriv,
diff --git a/liboctave/EIG.cc b/liboctave/EIG.cc
--- a/liboctave/EIG.cc
+++ b/liboctave/EIG.cc
@@ -30,35 +30,49 @@ Software Foundation, 59 Temple Place - S
 
 #include "EIG.h"
 #include "dColVector.h"
 #include "f77-fcn.h"
 #include "lo-error.h"
 
 extern "C"
 {
-  int F77_FUNC (dgeev, DGEEV) (const char*, const char*, const int&,
-			      double*, const int&, double*, double*,
-			      double*, const int&, double*,
-			      const int&, double*, const int&, int&,
-			      long, long);
+  F77_RET_T
+  F77_FUNC (dgeev, DGEEV) (F77_CONST_CHAR_ARG_DECL,
+			   F77_CONST_CHAR_ARG_DECL,
+			   const int&, double*, const int&, double*,
+			   double*, double*, const int&, double*,
+			   const int&, double*, const int&, int&
+			   F77_CHAR_ARG_LEN_DECL
+			   F77_CHAR_ARG_LEN_DECL);
 
-  int F77_FUNC (zgeev, ZGEEV) (const char*, const char*, const int&,
-			      Complex*, const int&, Complex*,
-			      Complex*, const int&, Complex*,
-			      const int&, Complex*, const int&,
-			      double*, int&, long, long);
+  F77_RET_T
+  F77_FUNC (zgeev, ZGEEV) (F77_CONST_CHAR_ARG_DECL,
+			   F77_CONST_CHAR_ARG_DECL,
+			   const int&, Complex*, const int&, Complex*,
+			   Complex*, const int&, Complex*, const int&,
+			   Complex*, const int&, double*, int&
+			   F77_CHAR_ARG_LEN_DECL
+			   F77_CHAR_ARG_LEN_DECL);
 
-  int F77_FUNC (dsyev, DSYEV) (const char*, const char*, const int&,
-			      double*, const int&, double*, double*,
-			      const int&, int&, long, long);
+  F77_RET_T
+  F77_FUNC (dsyev, DSYEV) (F77_CONST_CHAR_ARG_DECL,
+			   F77_CONST_CHAR_ARG_DECL,
+			   const int&, double*, const int&, double*,
+			   double*, const int&, int&
+			   F77_CHAR_ARG_LEN_DECL
+			   F77_CHAR_ARG_LEN_DECL);
 
-  int F77_FUNC (zheev, ZHEEV) (const char*, const char*, const int&,
-			      Complex*, const int&, double*, Complex*,
-			      const int&, double*, int&, long, long);
+  F77_RET_T
+  F77_FUNC (zheev, ZHEEV) (F77_CONST_CHAR_ARG_DECL,
+			   F77_CONST_CHAR_ARG_DECL,
+			   const int&, Complex*, const int&, double*,
+			   Complex*, const int&, double*, int&
+			   F77_CHAR_ARG_LEN_DECL
+			   F77_CHAR_ARG_LEN_DECL);
 }
 
 int
 EIG::init (const Matrix& a)
 {
   if (a.is_symmetric ())
     return symmetric_init (a);
 
@@ -89,18 +103,22 @@ EIG::init (const Matrix& a)
 
   int lwork = 8*n;
   Array<double> work (lwork);
   double *pwork = work.fortran_vec ();
 
   double *dummy = 0;
   int idummy = 1;
 
-  F77_XFCN (dgeev, DGEEV, ("N", "V", n, tmp_data, n, pwr, pwi, dummy,
-			   idummy, pvr, n, pwork, lwork, info, 1L, 1L));
+  F77_XFCN (dgeev, DGEEV, (F77_CONST_CHAR_ARG2 ("N", 1),
+			   F77_CONST_CHAR_ARG2 ("V", 1),
+			   n, tmp_data, n, pwr, pwi, dummy,
+			   idummy, pvr, n, pwork, lwork, info
+			   F77_CHAR_ARG_LEN (1)
+			   F77_CHAR_ARG_LEN (1)));
 
   if (f77_exception_encountered || info < 0)
     (*current_liboctave_error_handler) ("unrecoverable error in dgeev");
   else
     {
       if (info > 0)
 	(*current_liboctave_error_handler) ("dgeev failed to converge");
       else
@@ -165,18 +183,21 @@ EIG::symmetric_init (const Matrix& a)
 
   // XXX FIXME XXX -- it might be possible to choose a better value of
   // lwork that would result in more efficient computations.
 
   int lwork = 8*n;
   Array<double> work (lwork);
   double *pwork = work.fortran_vec ();
 
-  F77_XFCN (dsyev, DSYEV, ("V", "U", n, tmp_data, n, pwr, pwork,
-			   lwork, info, 1L, 1L));
+  F77_XFCN (dsyev, DSYEV, (F77_CONST_CHAR_ARG2 ("V", 1),
+			   F77_CONST_CHAR_ARG2 ("U", 1),
+			   n, tmp_data, n, pwr, pwork, lwork, info
+			   F77_CHAR_ARG_LEN (1)
+			   F77_CHAR_ARG_LEN (1)));
 
   if (f77_exception_encountered || info < 0)
     (*current_liboctave_error_handler) ("unrecoverable error in dsyev");
   else if (info > 0)
     (*current_liboctave_error_handler) ("dsyev failed to converge");
   else
     {
       lambda = ComplexColumnVector (wr);
@@ -220,18 +241,22 @@ EIG::init (const ComplexMatrix& a)
 
   int lrwork = 2*n;
   Array<double> rwork (lrwork);
   double *prwork = rwork.fortran_vec ();
 
   Complex *dummy = 0;
   int idummy = 1;
 
-  F77_XFCN (zgeev, ZGEEV, ("N", "V", n, tmp_data, n, pw, dummy, idummy,
-			   pv, n, pwork, lwork, prwork, info, 1L, 1L));
+  F77_XFCN (zgeev, ZGEEV, (F77_CONST_CHAR_ARG2 ("N", 1),
+			   F77_CONST_CHAR_ARG2 ("V", 1),
+			   n, tmp_data, n, pw, dummy, idummy,
+			   pv, n, pwork, lwork, prwork, info
+			   F77_CHAR_ARG_LEN (1)
+			   F77_CHAR_ARG_LEN (1)));
 
   if (f77_exception_encountered || info < 0)
     (*current_liboctave_error_handler) ("unrecoverable error in zgeev");
   else if (info > 0)
     (*current_liboctave_error_handler) ("zgeev failed to converge");
   else
     {
       lambda = w;
@@ -266,18 +291,21 @@ EIG::hermitian_init (const ComplexMatrix
   int lwork = 8*n;
   Array<Complex> work (lwork);
   Complex *pwork = work.fortran_vec ();
 
   int lrwork = 3*n;
   Array<double> rwork (lrwork);
   double *prwork = rwork.fortran_vec ();
 
-  F77_XFCN (zheev, ZHEEV, ("V", "U", n, tmp_data, n, pwr, pwork,
-			   lwork, prwork, info, 1L, 1L));
+  F77_XFCN (zheev, ZHEEV, (F77_CONST_CHAR_ARG2 ("V", 1),
+			   F77_CONST_CHAR_ARG2 ("U", 1),
+			   n, tmp_data, n, pwr, pwork, lwork, prwork, info
+			   F77_CHAR_ARG_LEN (1)
+			   F77_CHAR_ARG_LEN (1)));
 
   if (f77_exception_encountered || info < 0)
     (*current_liboctave_error_handler) ("unrecoverable error in zheev");
   else if (info > 0)
     (*current_liboctave_error_handler) ("zheev failed to converge");
   else
     {
       lambda = ComplexColumnVector (wr);
diff --git a/liboctave/LSODE.cc b/liboctave/LSODE.cc
--- a/liboctave/LSODE.cc
+++ b/liboctave/LSODE.cc
@@ -40,20 +40,23 @@ Software Foundation, 59 Temple Place - S
 typedef int (*lsode_fcn_ptr) (const int&, const double&, double*,
 			      double*, int&);
 
 typedef int (*lsode_jac_ptr) (const int&, const double&, double*,
 			      const int&, const int&, double*, const
 			      int&);
 
 extern "C"
-int F77_FUNC (lsode, LSODE) (lsode_fcn_ptr, int&, double*, double&,
-			     double&, int&, double&, const double*, int&,
-			     int&, int&, double*, int&, int*, int&,
-			     lsode_jac_ptr, int&);
+{
+  F77_RET_T
+  F77_FUNC (lsode, LSODE) (lsode_fcn_ptr, int&, double*, double&,
+			   double&, int&, double&, const double*, int&,
+			   int&, int&, double*, int&, int*, int&,
+			   lsode_jac_ptr, int&);
+}
 
 static ODEFunc::ODERHSFunc user_fun;
 static ODEFunc::ODEJacFunc user_jac;
 static ColumnVector *tmp_x;
 
 static int
 lsode_f (const int& neq, const double& time, double *,
 	 double *deriv, int& ierr) 
diff --git a/liboctave/NLEqn.cc b/liboctave/NLEqn.cc
--- a/liboctave/NLEqn.cc
+++ b/liboctave/NLEqn.cc
@@ -31,27 +31,31 @@ Software Foundation, 59 Temple Place - S
 #include "NLEqn.h"
 #include "dMatrix.h"
 #include "f77-fcn.h"
 #include "lo-error.h"
 #include "quit.h"
 
 typedef int (*hybrd1_fcn_ptr) (int*, double*, double*, int*);
 
-extern "C"
-int F77_FUNC (hybrd1, HYBRD1) (hybrd1_fcn_ptr, const int&, double*,
-			      double*, const double&, int&, double*,
-			      const int&);
-
 typedef int (*hybrj1_fcn_ptr) (int*, double*, double*, double*, int*, int*);
 
 extern "C"
-int F77_FUNC (hybrj1, HYBRJ1) (hybrj1_fcn_ptr, const int&, double*,
-			      double*, double*, const int&, const
-			      double&, int&, double*, const int&);
+{
+  F77_RET_T
+  F77_FUNC (hybrd1, HYBRD1) (hybrd1_fcn_ptr, const int&, double*,
+			     double*, const double&, int&, double*,
+			     const int&);
+
+
+  F77_RET_T
+  F77_FUNC (hybrj1, HYBRJ1) (hybrj1_fcn_ptr, const int&, double*,
+			     double*, double*, const int&, const
+			     double&, int&, double*, const int&);
+}
 
 static NLFunc::nonlinear_fcn user_fun;
 static NLFunc::jacobian_fcn user_jac;
 
 // error handling
 
 void
 NLEqn::error (const char* msg)
diff --git a/liboctave/ODESSA.cc b/liboctave/ODESSA.cc
--- a/liboctave/ODESSA.cc
+++ b/liboctave/ODESSA.cc
@@ -48,21 +48,24 @@ typedef int (*odessa_jac_ptr) (int*, con
 			       double*, const int&, const int&,
 			       double*, const int&);
 
 typedef int (*odessa_dfdp_ptr) (int*, const double&, double*,
 				double*, double*, const int&);
 
 
 extern "C"
-int F77_FUNC (odessa, ODESSA) (odessa_fcn_ptr, odessa_dfdp_ptr, int*,
-                               double*, double*, double&, double&,
-                               int&, double&, const double*, int&, 
-                               int&, int*, double*, int&, int*, int&,
-                               odessa_jac_ptr, int&);
+{
+  F77_RET_T
+  F77_FUNC (odessa, ODESSA) (odessa_fcn_ptr, odessa_dfdp_ptr, int*,
+			     double*, double*, double&, double&,
+			     int&, double&, const double*, int&, 
+			     int&, int*, double*, int&, int*, int&,
+			     odessa_jac_ptr, int&);
+}
 
 template class Array<Matrix>;
 
 static ODESFunc::ODES_fsub user_fsub;
 static ODESFunc::ODES_bsub user_bsub;
 static ODESFunc::ODES_jsub user_jsub;
 
 
diff --git a/liboctave/Quad.cc b/liboctave/Quad.cc
--- a/liboctave/Quad.cc
+++ b/liboctave/Quad.cc
@@ -40,27 +40,30 @@ static integrand_fcn user_fcn;
 // variable.
 // Nonzero means an error occurred in the calculation of the integrand
 // function, and the user wants us to quit.
 int quad_integration_error = 0;
 
 typedef int (*quad_fcn_ptr) (double*, int&, double*);
 			      
 extern "C"
-int F77_FUNC (dqagp, DQAGP) (quad_fcn_ptr, const double&, const double&,
-			    const int&, const double*, const double&,
-			    const double&, double&, double&, int&,
-			    int&, const int&, const int&, int&, int*,
-			    double*);
+{
+  F77_RET_T
+  F77_FUNC (dqagp, DQAGP) (quad_fcn_ptr, const double&, const double&,
+			   const int&, const double*, const double&,
+			   const double&, double&, double&, int&,
+			   int&, const int&, const int&, int&, int*,
+			   double*);
 
-extern "C"
-int F77_FUNC (dqagi, DQAGI) (quad_fcn_ptr, const double&, const int&,
-			    const double&, const double&, double&,
-			    double&, int&, int&, const int&,
-			    const int&, int&, int*, double*); 
+  F77_RET_T
+  F77_FUNC (dqagi, DQAGI) (quad_fcn_ptr, const double&, const int&,
+			   const double&, const double&, double&,
+			   double&, int&, int&, const int&,
+			   const int&, int&, int*, double*); 
+}
 
 static int
 user_function (double *x, int& ierr, double *result)
 {
   BEGIN_INTERRUPT_WITH_EXCEPTIONS;
 
 #if defined (sun) && defined (__GNUC__)
   double xx = access_double (x);
diff --git a/liboctave/dColVector.cc b/liboctave/dColVector.cc
--- a/liboctave/dColVector.cc
+++ b/liboctave/dColVector.cc
@@ -36,21 +36,23 @@ Software Foundation, 59 Temple Place - S
 #include "mx-base.h"
 #include "mx-inlines.cc"
 #include "oct-cmplx.h"
 
 // Fortran functions we call.
 
 extern "C"
 {
-  int F77_FUNC (dgemv, DGEMV) (const char*, const int&, const int&,
-			      const double&, const double*,
-			      const int&, const double*, const int&,
-			      const double&, double*, const int&,
-			      long);
+  F77_RET_T
+  F77_FUNC (dgemv, DGEMV) (F77_CONST_CHAR_ARG_DECL,
+			   const int&, const int&, const double&,
+			   const double*, const int&, const double*,
+			   const int&, const double&, double*,
+			   const int&
+			   F77_CHAR_ARG_LEN_DECL);
 }
 
 // Column Vector class.
 
 bool
 ColumnVector::operator == (const ColumnVector& a) const
 {
   int len = length ();
@@ -212,18 +214,20 @@ operator * (const Matrix& m, const Colum
 	retval.resize (nr, 0.0);
       else
 	{
 	  int ld = nr;
 
 	  retval.resize (nr);
 	  double *y = retval.fortran_vec ();
 
-	  F77_XFCN (dgemv, DGEMV, ("N", nr, nc, 1.0, m.data (), ld,
-				   a.data (), 1, 0.0, y, 1, 1L));
+	  F77_XFCN (dgemv, DGEMV, (F77_CONST_CHAR_ARG2 ("N", 1),
+				   nr, nc, 1.0, m.data (), ld,
+				   a.data (), 1, 0.0, y, 1
+				   F77_CHAR_ARG_LEN (1)));
 
 	  if (f77_exception_encountered)
 	    (*current_liboctave_error_handler)
 	      ("unrecoverable error in dgemv");
 	}
     }
 
   return retval;
diff --git a/liboctave/dMatrix.cc b/liboctave/dMatrix.cc
--- a/liboctave/dMatrix.cc
+++ b/liboctave/dMatrix.cc
@@ -54,74 +54,100 @@ Software Foundation, 59 Temple Place - S
 #ifdef HAVE_FFTW
 #include "oct-fftw.h"
 #endif
 
 // Fortran functions we call.
 
 extern "C"
 {
-  int F77_FUNC (dgebal, DGEBAL) (const char*, const int&, double*,
-                                const int&, int&, int&, double*,
-                                int&, long, long);
-
-  int F77_FUNC (dgebak, DGEBAK) (const char*, const char*, const int&,
-                                const int&, const int&, double*,
-                                const int&, double*, const int&,
-                                int&, long, long);
-
-  int F77_FUNC (dgemm, DGEMM) (const char*, const char*, const int&,
-			      const int&, const int&, const double&,
-			      const double*, const int&,
-			      const double*, const int&,
-			      const double&, double*, const int&,
-			      long, long);
-
-  int F77_FUNC (dgetrf, DGETRF) (const int&, const int&, double*, const int&,
+  F77_RET_T
+  F77_FUNC (dgebal, DGEBAL) (F77_CONST_CHAR_ARG_DECL,
+			     const int&, double*, const int&, int&,
+			     int&, double*, int&
+			     F77_CHAR_ARG_LEN_DECL);
+
+  F77_RET_T
+  F77_FUNC (dgebak, DGEBAK) (F77_CONST_CHAR_ARG_DECL,
+			     F77_CONST_CHAR_ARG_DECL,
+			     const int&, const int&, const int&, double*,
+			     const int&, double*, const int&, int&
+			     F77_CHAR_ARG_LEN_DECL
+			     F77_CHAR_ARG_LEN_DECL);
+
+
+  F77_RET_T
+  F77_FUNC (dgemm, DGEMM) (F77_CONST_CHAR_ARG_DECL,
+			   F77_CONST_CHAR_ARG_DECL,
+			   const int&, const int&, const int&,
+			   const double&, const double*, const int&,
+			   const double*, const int&, const double&,
+			   double*, const int&
+			   F77_CHAR_ARG_LEN_DECL
+			   F77_CHAR_ARG_LEN_DECL);
+
+  F77_RET_T
+  F77_FUNC (dgetrf, DGETRF) (const int&, const int&, double*, const int&,
 		      int*, int&);
 
-  int F77_FUNC (dgetrs, DGETRS) (const char*, const int&, const int&, 
-				const double*, const int&,
-				const int*, double*, const int&, int&);
-
-  int F77_FUNC (dgetri, DGETRI) (const int&, double*, const int&, const int*,
-				double*, const int&, int&);
-
-  int F77_FUNC (dgecon, DGECON) (const char*, const int&, double*, 
-				 const int&, const double&, double&, 
-				 double*, int*, int&);
-
-  int F77_FUNC (dgelss, DGELSS) (const int&, const int&, const int&,
-				double*, const int&, double*,
-				const int&, double*, double&, int&,
-				double*, const int&, int&);
+  F77_RET_T
+  F77_FUNC (dgetrs, DGETRS) (F77_CONST_CHAR_ARG_DECL, const int&, const int&, 
+			     const double*, const int&,
+			     const int*, double*, const int&, int&
+			     F77_CHAR_ARG_LEN_DECL);
+
+  F77_RET_T
+  F77_FUNC (dgetri, DGETRI) (const int&, double*, const int&, const int*,
+			     double*, const int&, int&);
+
+  F77_RET_T
+  F77_FUNC (dgecon, DGECON) (F77_CONST_CHAR_ARG_DECL, const int&, double*, 
+			     const int&, const double&, double&, 
+			     double*, int*, int&
+			     F77_CHAR_ARG_LEN_DECL);
+
+  F77_RET_T
+  F77_FUNC (dgelss, DGELSS) (const int&, const int&, const int&,
+			     double*, const int&, double*,
+			     const int&, double*, double&, int&,
+			     double*, const int&, int&);
 
   // Note that the original complex fft routines were not written for
   // double complex arguments.  They have been modified by adding an
   // implicit double precision (a-h,o-z) statement at the beginning of
   // each subroutine.
 
-  int F77_FUNC (cffti, CFFTI) (const int&, Complex*);
-
-  int F77_FUNC (cfftf, CFFTF) (const int&, Complex*, Complex*);
-
-  int F77_FUNC (cfftb, CFFTB) (const int&, Complex*, Complex*);
-
-  int F77_FUNC (dlartg, DLARTG) (const double&, const double&, double&,
-				double&, double&);
-
-  int F77_FUNC (dtrsyl, DTRSYL) (const char*, const char*, const int&,
-				const int&, const int&, const double*,
-				const int&, const double*, const int&,
-				const double*, const int&, double&,
-				int&, long, long);
-
-  int F77_FUNC (xdlange, XDLANGE) (const char*, const int&,
-				  const int&, const double*,
-				  const int&, double*, double&); 
+  F77_RET_T
+  F77_FUNC (cffti, CFFTI) (const int&, Complex*);
+
+  F77_RET_T
+  F77_FUNC (cfftf, CFFTF) (const int&, Complex*, Complex*);
+
+  F77_RET_T
+  F77_FUNC (cfftb, CFFTB) (const int&, Complex*, Complex*);
+
+  F77_RET_T
+  F77_FUNC (dlartg, DLARTG) (const double&, const double&, double&,
+			     double&, double&);
+
+  F77_RET_T
+  F77_FUNC (dtrsyl, DTRSYL) (F77_CONST_CHAR_ARG_DECL,
+			     F77_CONST_CHAR_ARG_DECL,
+			     const int&, const int&, const int&,
+			     const double*, const int&, const double*,
+			     const int&, const double*, const int&,
+			     double&, int&
+			     F77_CHAR_ARG_LEN_DECL
+			     F77_CHAR_ARG_LEN_DECL);
+
+  F77_RET_T
+  F77_FUNC (xdlange, XDLANGE) (F77_CONST_CHAR_ARG_DECL, const int&,
+			       const int&, const double*,
+			       const int&, double*, double&
+			       F77_CHAR_ARG_LEN_DECL); 
 }
 
 // Matrix class.
 
 Matrix::Matrix (const RowVector& rv)
   : MArray2<double> (1, rv.length (), 0.0)
 {
   for (int i = 0; i < rv.length (); i++)
@@ -664,33 +690,35 @@ Matrix::inverse (int& info, double& rcon
 	  if (info != 0) 
 	    info = -1;
 	  else if (calc_cond) 
 	    {
 	      // Now calculate the condition number for non-singular matrix.
 	      char job = '1';
 	      Array<int> iz (nc);
 	      int *piz = iz.fortran_vec ();
-	      F77_XFCN (dgecon, DGECON, (&job, nc, tmp_data, nr, anorm, 
-					 rcond, pz, piz, info));
+	      F77_XFCN (dgecon, DGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
+					 nc, tmp_data, nr, anorm, 
+					 rcond, pz, piz, info
+					 F77_CHAR_ARG_LEN (1)));
 
 	      if (f77_exception_encountered)
 		(*current_liboctave_error_handler) 
 		  ("unrecoverable error in dgecon");
 
 	      if (info != 0) 
 		info = -1;
 	    }
 
 	  if (info == -1 && ! force)
 	    retval = *this; // Restore matrix contents.
 	  else
 	    {
 	      F77_XFCN (dgetri, DGETRI, (nc, tmp_data, nr, pipvt,
-				       pz, lwork, info));
+					 pz, lwork, info));
 
 	      if (f77_exception_encountered)
 		(*current_liboctave_error_handler)
 		  ("unrecoverable error in dgetri");
 
 	      if (info != 0) 
 		info = -1;
 	    }
@@ -1125,18 +1153,20 @@ Matrix::determinant (int& info, double& 
 		{
 		  // Now calc the condition number for non-singular matrix.
 		  char job = '1';
 		  Array<double> z (4 * nc);
 		  double *pz = z.fortran_vec ();
 		  Array<int> iz (nc);
 		  int *piz = iz.fortran_vec ();
 
-		  F77_XFCN (dgecon, DGECON, (&job, nc, tmp_data, nr, anorm, 
-					     rcond, pz, piz, info));
+		  F77_XFCN (dgecon, DGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
+					     nc, tmp_data, nr, anorm, 
+					     rcond, pz, piz, info
+					     F77_CHAR_ARG_LEN (1)));
 
 		  if (f77_exception_encountered)
 		    (*current_liboctave_error_handler) 
 		      ("unrecoverable error in dgecon");
 		}
 
 	      if (info != 0) 
 		{
@@ -1240,18 +1270,20 @@ Matrix::solve (const Matrix& b, int& inf
 		(*current_liboctave_error_handler)
 		  ("matrix singular to machine precision");
 
 	    } 
 	  else 
 	    {
 	      // Now calculate the condition number for non-singular matrix.
 	      char job = '1';
-	      F77_XFCN (dgecon, DGECON, (&job, nc, tmp_data, nr, anorm, 
-					 rcond, pz, piz, info));
+	      F77_XFCN (dgecon, DGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
+					 nc, tmp_data, nr, anorm, 
+					 rcond, pz, piz, info
+					 F77_CHAR_ARG_LEN (1)));
 	      
 	      if (f77_exception_encountered)
 		(*current_liboctave_error_handler) 
 		  ("unrecoverable error in dgecon");
 	      
 	      if (info != 0) 
 		info = -2;
 
@@ -1271,18 +1303,20 @@ Matrix::solve (const Matrix& b, int& inf
 	      else
 		{
 		  retval = b;
 		  double *result = retval.fortran_vec ();
 
 		  int b_nc = b.cols ();
 
 		  char job = 'N';
-		  F77_XFCN (dgetrs, DGETRS, (&job, nr, b_nc, tmp_data, nr,
-					     pipvt, result, b.rows(), info)); 
+		  F77_XFCN (dgetrs, DGETRS, (F77_CONST_CHAR_ARG2 (&job, 1),
+					     nr, b_nc, tmp_data, nr,
+					     pipvt, result, b.rows(), info
+					     F77_CHAR_ARG_LEN (1)));
 		
 		  if (f77_exception_encountered)
 		    (*current_liboctave_error_handler)
 		      ("unrecoverable error in dgetrs");
 		}
 	    }
 	}
     }
@@ -1387,18 +1421,20 @@ Matrix::solve (const ColumnVector& b, in
 		(*current_liboctave_error_handler)
 		  ("matrix singular to machine precision");
 
 	    } 
 	  else 
 	    {
 	      // Now calculate the condition number for non-singular matrix.
 	      char job = '1';
-	      F77_XFCN (dgecon, DGECON, (&job, nc, tmp_data, nr, anorm, 
-					 rcond, pz, piz, info));
+	      F77_XFCN (dgecon, DGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
+					 nc, tmp_data, nr, anorm, 
+					 rcond, pz, piz, info
+					 F77_CHAR_ARG_LEN (1)));
 	      
 	      if (f77_exception_encountered)
 		(*current_liboctave_error_handler) 
 		  ("unrecoverable error in dgecon");
 
 	      if (info != 0) 
 		info = -2;
 
@@ -1416,18 +1452,20 @@ Matrix::solve (const ColumnVector& b, in
 		       rcond);
 		}
 	      else
 		{
 		  retval = b;
 		  double *result = retval.fortran_vec ();
 
 		  char job = 'N';
-		  F77_XFCN (dgetrs, DGETRS, (&job, nr, 1, tmp_data, nr, pipvt,
-					     result, b.length(), info)); 
+		  F77_XFCN (dgetrs, DGETRS, (F77_CONST_CHAR_ARG2 (&job, 1),
+					     nr, 1, tmp_data, nr, pipvt,
+					     result, b.length(), info
+					     F77_CHAR_ARG_LEN (1)));
 
 		  if (f77_exception_encountered)
 		    (*current_liboctave_error_handler)
 		      ("unrecoverable error in dgetrs");
 		}
 	    }
 	}
     }
@@ -1723,37 +1761,43 @@ Matrix::expm (void) const
   double *p_m = m.fortran_vec ();
 
   int info, ilo, ihi, ilos, ihis;
   Array<double> dpermute (nc);
   Array<double> dscale (nc);
 
   // permutation first
   char job = 'P';
-  F77_XFCN (dgebal, DGEBAL, (&job, nc, p_m, nc, ilo, ihi,
-			     dpermute.fortran_vec (), info, 1L, 1L));
+  F77_XFCN (dgebal, DGEBAL, (F77_CONST_CHAR_ARG2 (&job, 1),
+			     nc, p_m, nc, ilo, ihi,
+			     dpermute.fortran_vec (), info
+			     F77_CHAR_ARG_LEN (1)));
 
   // then scaling
   job = 'S';
-  F77_XFCN (dgebal, DGEBAL, (&job, nc, p_m, nc, ilos, ihis,
-			     dscale.fortran_vec (), info, 1L, 1L));
+  F77_XFCN (dgebal, DGEBAL, (F77_CONST_CHAR_ARG2 (&job, 1),
+			     nc, p_m, nc, ilos, ihis,
+			     dscale.fortran_vec (), info
+			     F77_CHAR_ARG_LEN (1)));
 
   if (f77_exception_encountered)
     {
       (*current_liboctave_error_handler) ("unrecoverable error in dgebal");
       return retval;
     }
 
   // Preconditioning step 3: scaling.
   
   ColumnVector work(nc);
   double inf_norm;
   
-  F77_XFCN (xdlange, XDLANGE, ("I", nc, nc, m.fortran_vec (), nc,
-			       work.fortran_vec (), inf_norm));
+  F77_XFCN (xdlange, XDLANGE, (F77_CONST_CHAR_ARG2 ("I", 1),
+			       nc, nc, m.fortran_vec (), nc,
+			       work.fortran_vec (), inf_norm
+			       F77_CHAR_ARG_LEN (1)));
   
   if (f77_exception_encountered)
     {
       (*current_liboctave_error_handler) ("unrecoverable error in dlange");
       return retval;
     }
 
   int sqpow = (int) (inf_norm > 0.0
@@ -1931,19 +1975,22 @@ operator * (const ColumnVector& v, const
 
   if (len != 0)
     {
       int a_len = a.length ();
 
       retval.resize (len, a_len);
       double *c = retval.fortran_vec ();
 	  
-      F77_XFCN (dgemm, DGEMM, ("N", "N", len, a_len, 1, 1.0,
-			       v.data (), len, a.data (), 1, 0.0,
-			       c, len, 1L, 1L));
+      F77_XFCN (dgemm, DGEMM, (F77_CONST_CHAR_ARG2 ("N", 1),
+			       F77_CONST_CHAR_ARG2 ("N", 1),
+			       len, a_len, 1, 1.0, v.data (), len,
+			       a.data (), 1, 0.0, c, len
+			       F77_CHAR_ARG_LEN (1)
+			       F77_CHAR_ARG_LEN (1)));
 
       if (f77_exception_encountered)
 	(*current_liboctave_error_handler)
 	  ("unrecoverable error in dgemm");
     }
 
   return retval;
 }
@@ -3015,18 +3062,22 @@ Sylvester (const Matrix& a, const Matrix
 
   double scale;
   int info;
 
   double *pa = sch_a.fortran_vec ();
   double *pb = sch_b.fortran_vec ();
   double *px = cx.fortran_vec ();
 
-  F77_XFCN (dtrsyl, DTRSYL, ("N", "N", 1, a_nr, b_nr, pa, a_nr, pb,
-			     b_nr, px, a_nr, scale, info, 1L, 1L));
+  F77_XFCN (dtrsyl, DTRSYL, (F77_CONST_CHAR_ARG2 ("N", 1),
+			     F77_CONST_CHAR_ARG2 ("N", 1),
+			     1, a_nr, b_nr, pa, a_nr, pb,
+			     b_nr, px, a_nr, scale, info
+			     F77_CHAR_ARG_LEN (1)
+			     F77_CHAR_ARG_LEN (1)));
 
 
   if (f77_exception_encountered)
     (*current_liboctave_error_handler) ("unrecoverable error in dtrsyl");
   else
     {
       // XXX FIXME XXX -- check info?
   
@@ -3058,19 +3109,22 @@ operator * (const Matrix& m, const Matri
       else
 	{
 	  int ld  = nr;
 	  int lda = a_nr;
 
 	  retval.resize (nr, a_nc);
 	  double *c = retval.fortran_vec ();
 
-	  F77_XFCN (dgemm, DGEMM, ("N", "N", nr, a_nc, nc, 1.0,
-				   m.data (), ld, a.data (), lda, 0.0,
-				   c, nr, 1L, 1L));
+	  F77_XFCN (dgemm, DGEMM, (F77_CONST_CHAR_ARG2 ("N", 1),
+				   F77_CONST_CHAR_ARG2 ("N", 1),
+				   nr, a_nc, nc, 1.0, m.data (),
+				   ld, a.data (), lda, 0.0, c, nr
+				   F77_CHAR_ARG_LEN (1)
+				   F77_CHAR_ARG_LEN (1)));
 
 	  if (f77_exception_encountered)
 	    (*current_liboctave_error_handler)
 	      ("unrecoverable error in dgemm");
 	}
     }
 
   return retval;
diff --git a/liboctave/dRowVector.cc b/liboctave/dRowVector.cc
--- a/liboctave/dRowVector.cc
+++ b/liboctave/dRowVector.cc
@@ -36,24 +36,25 @@ Software Foundation, 59 Temple Place - S
 #include "mx-base.h"
 #include "mx-inlines.cc"
 #include "oct-cmplx.h"
 
 // Fortran functions we call.
 
 extern "C"
 {
-  int F77_FUNC (dgemv, DGEMV) (const char*, const int&, const int&,
-			      const double&, const double*,
-			      const int&, const double*, const int&,
-			      const double&, double*, const int&,
-			      long);
+  F77_RET_T
+  F77_FUNC (dgemv, DGEMV) (F77_CONST_CHAR_ARG_DECL,
+			   const int&, const int&, const double&,
+			   const double*, const int&, const double*,
+			   const int&, const double&, double*, const int&
+			   F77_CHAR_ARG_LEN_DECL);
 
   double F77_FUNC (ddot, DDOT) (const int&, const double*, const int&,
-			       const double*, const int&);
+				const double*, const int&);
 }
 
 // Row Vector class.
 
 bool
 RowVector::operator == (const RowVector& a) const
 {
   int len = length ();
@@ -218,18 +219,20 @@ operator * (const RowVector& v, const Ma
 	{
 	  // Transpose A to form A'*x == (x'*A)'
 
 	  int ld = a_nr;
 
 	  retval.resize (a_nc);
 	  double *y = retval.fortran_vec ();
 
-	  F77_XFCN (dgemv, DGEMV, ("T", a_nr, a_nc, 1.0, a.data (),
-				   ld, v.data (), 1, 0.0, y, 1, 1L));
+	  F77_XFCN (dgemv, DGEMV, (F77_CONST_CHAR_ARG2 ("T", 1),
+				   a_nr, a_nc, 1.0, a.data (),
+				   ld, v.data (), 1, 0.0, y, 1
+				   F77_CHAR_ARG_LEN (1)));
 
 	  if (f77_exception_encountered)
 	    (*current_liboctave_error_handler)
 	      ("unrecoverable error in dgemv");
 	}
     }
 
   return retval;
diff --git a/liboctave/dbleAEPBAL.cc b/liboctave/dbleAEPBAL.cc
--- a/liboctave/dbleAEPBAL.cc
+++ b/liboctave/dbleAEPBAL.cc
@@ -30,24 +30,29 @@ Software Foundation, 59 Temple Place - S
 
 #include <string>
 
 #include "dbleAEPBAL.h"
 #include "f77-fcn.h"
 
 extern "C"
 {
-  int F77_FUNC (dgebal, DGEBAL) (const char*, const int&, double*,
-				const int&, int&, int&, double*,
-				int&, long, long);
+  F77_RET_T
+  F77_FUNC (dgebal, DGEBAL) (F77_CONST_CHAR_ARG_DECL,
+			     const int&, double*, const int&, int&,
+			     int&, double*, int&
+			     F77_CHAR_ARG_LEN_DECL);
 
-  int F77_FUNC (dgebak, DGEBAK) (const char*, const char*, const int&,
-				const int&, const int&, double*,
-				const int&, double*, const int&,
-				int&, long, long);
+  F77_RET_T
+  F77_FUNC (dgebak, DGEBAK) (F77_CONST_CHAR_ARG_DECL,
+			     F77_CONST_CHAR_ARG_DECL,
+			     const int&, const int&, const int&, double*,
+			     const int&, double*, const int&, int&
+			     F77_CHAR_ARG_LEN_DECL
+			     F77_CHAR_ARG_LEN_DECL);
 }
 
 int
 AEPBALANCE::init (const Matrix& a, const std::string& balance_job)
 {
   int n = a.cols ();
 
   if (a.rows () != n)
@@ -63,33 +68,38 @@ AEPBALANCE::init (const Matrix& a, const
   Array<double> scale (n);
   double *pscale = scale.fortran_vec ();
 
   balanced_mat = a;
   double *p_balanced_mat = balanced_mat.fortran_vec ();
 
   char job = balance_job[0];
 
-  F77_XFCN (dgebal, DGEBAL, (&job, n, p_balanced_mat, n, ilo, ihi,
-			     pscale, info, 1L, 1L));
+  F77_XFCN (dgebal, DGEBAL, (F77_CONST_CHAR_ARG2 (&job, 1),
+			     n, p_balanced_mat, n, ilo, ihi, pscale, info
+			     F77_CHAR_ARG_LEN (1)));
 
   if (f77_exception_encountered)
     (*current_liboctave_error_handler) ("unrecoverable error in dgebal");
   else
     {
       balancing_mat = Matrix (n, n, 0.0);
       for (int i = 0; i < n; i++)
 	balancing_mat.elem (i ,i) = 1.0;
 
       double *p_balancing_mat = balancing_mat.fortran_vec ();
 
       char side = 'R';
 
-      F77_XFCN (dgebak, DGEBAK, (&job, &side, n, ilo, ihi, pscale, n,
-				 p_balancing_mat, n, info, 1L, 1L));
+      F77_XFCN (dgebak, DGEBAK, (F77_CONST_CHAR_ARG2 (&job, 1),
+				 F77_CONST_CHAR_ARG2 (&side, 1),
+				 n, ilo, ihi, pscale, n,
+				 p_balancing_mat, n, info
+				 F77_CHAR_ARG_LEN (1)
+				 F77_CHAR_ARG_LEN (1)));
 
       if (f77_exception_encountered)
 	(*current_liboctave_error_handler) ("unrecoverable error in dgebak");
     }
 
   return info;
 }
 
diff --git a/liboctave/dbleCHOL.cc b/liboctave/dbleCHOL.cc
--- a/liboctave/dbleCHOL.cc
+++ b/liboctave/dbleCHOL.cc
@@ -29,18 +29,20 @@ Software Foundation, 59 Temple Place - S
 #endif
 
 #include "dbleCHOL.h"
 #include "f77-fcn.h"
 #include "lo-error.h"
 
 extern "C"
 {
-  int F77_FUNC (dpotrf, DPOTRF) (const char*, const int&, double*,
-				const int&, int&, long);
+  F77_RET_T
+  F77_FUNC (dpotrf, DPOTRF) (F77_CONST_CHAR_ARG_DECL, const int&,
+			     double*, const int&, int&
+			     F77_CHAR_ARG_LEN_DECL);
 }
 
 int
 CHOL::init (const Matrix& a)
 {
   int a_nr = a.rows ();
   int a_nc = a.cols ();
 
@@ -51,17 +53,19 @@ CHOL::init (const Matrix& a)
     }
 
   int n = a_nc;
   int info;
 
   chol_mat = a;
   double *h = chol_mat.fortran_vec ();
 
-  F77_XFCN (dpotrf, DPOTRF, ("U", n, h, n, info, 1L));
+  F77_XFCN (dpotrf, DPOTRF, (F77_CONST_CHAR_ARG2 ("U", 1),
+			     n, h, n, info
+			     F77_CHAR_ARG_LEN (1)));
 
   if (f77_exception_encountered)
     (*current_liboctave_error_handler) ("unrecoverable error in dpotrf");
   else
     {
       // If someone thinks of a more graceful way of doing this (or
       // faster for that matter :-)), please let me know!
 
diff --git a/liboctave/dbleHESS.cc b/liboctave/dbleHESS.cc
--- a/liboctave/dbleHESS.cc
+++ b/liboctave/dbleHESS.cc
@@ -29,32 +29,39 @@ Software Foundation, 59 Temple Place - S
 #endif
 
 #include "dbleHESS.h"
 #include "f77-fcn.h"
 #include "lo-error.h"
 
 extern "C"
 {
-  int F77_FUNC (dgebal, DGEBAL) (const char*, const int&, double*,
-				const int&, int&, int&, double*,
-				int&, long, long);
+  F77_RET_T
+  F77_FUNC (dgebal, DGEBAL) (F77_CONST_CHAR_ARG_DECL,
+			     const int&, double*, const int&, int&,
+			     int&, double*, int&
+			     F77_CHAR_ARG_LEN_DECL);
 
-  int F77_FUNC (dgehrd, DGEHRD) (const int&, const int&, const int&,
-				double*, const int&, double*, double*,
-				const int&, int&, long, long);
+  F77_RET_T
+  F77_FUNC (dgehrd, DGEHRD) (const int&, const int&, const int&,
+			     double*, const int&, double*, double*,
+			     const int&, int&);
 
-  int F77_FUNC (dorghr, DORGHR) (const int&, const int&, const int&,
-				double*, const int&, double*, double*,
-				const int&, int&, long, long);
+  F77_RET_T
+  F77_FUNC (dorghr, DORGHR) (const int&, const int&, const int&,
+			     double*, const int&, double*, double*,
+			     const int&, int&);
 
-  int F77_FUNC (dgebak, DGEBAK) (const char*, const char*, const int&,
-				const int&, const int&, double*,
-				const int&, double*, const int&, int&,
-				long, long);
+  F77_RET_T
+  F77_FUNC (dgebak, DGEBAK) (F77_CONST_CHAR_ARG_DECL,
+			     F77_CONST_CHAR_ARG_DECL,
+			     const int&, const int&, const int&, double*,
+			     const int&, double*, const int&, int&
+			     F77_CHAR_ARG_LEN_DECL
+			     F77_CHAR_ARG_LEN_DECL);
 }
 
 int
 HESS::init (const Matrix& a)
 {
   int a_nr = a.rows ();
   int a_nc = a.cols ();
 
@@ -74,49 +81,54 @@ HESS::init (const Matrix& a)
   int ihi;
 
   hess_mat = a;
   double *h = hess_mat.fortran_vec ();
 
   Array<double> scale (n);
   double *pscale = scale.fortran_vec ();
 
-  F77_XFCN (dgebal, DGEBAL, (&job, n, h, n, ilo, ihi, pscale, info,
-			     1L, 1L));
+  F77_XFCN (dgebal, DGEBAL, (F77_CONST_CHAR_ARG2 (&job, 1),
+			     n, h, n, ilo, ihi, pscale, info
+			     F77_CHAR_ARG_LEN (1)));
 
   if (f77_exception_encountered)
     (*current_liboctave_error_handler) ("unrecoverable error in dgebal");
   else
     {
       Array<double> tau (n-1);
       double *ptau = tau.fortran_vec ();
 
       Array<double> work (lwork);
       double *pwork = work.fortran_vec ();
 
       F77_XFCN (dgehrd, DGEHRD, (n, ilo, ihi, h, n, ptau, pwork,
-				 lwork, info, 1L, 1L));
+				 lwork, info));
 
       if (f77_exception_encountered)
 	(*current_liboctave_error_handler) ("unrecoverable error in dgehrd");
       else
 	{
 	  unitary_hess_mat = hess_mat;
 	  double *z = unitary_hess_mat.fortran_vec ();
 
 	  F77_XFCN (dorghr, DORGHR, (n, ilo, ihi, z, n, ptau, pwork,
-				     lwork, info, 1L, 1L));
+				     lwork, info));
 
 	  if (f77_exception_encountered)
 	    (*current_liboctave_error_handler)
 	      ("unrecoverable error in dorghr");
 	  else
 	    {
-	      F77_XFCN (dgebak, DGEBAK, (&job, &side, n, ilo, ihi,
-					 pscale, n, z, n, info, 1L, 1L));
+	      F77_XFCN (dgebak, DGEBAK, (F77_CONST_CHAR_ARG2 (&job, 1),
+					 F77_CONST_CHAR_ARG2 (&side, 1),
+					 n, ilo, ihi, pscale, n, z,
+					 n, info
+					 F77_CHAR_ARG_LEN (1)
+					 F77_CHAR_ARG_LEN (1)));
 
 	      if (f77_exception_encountered)
 		(*current_liboctave_error_handler)
 		  ("unrecoverable error in dgebak");
 	      else
 		{
 		  // If someone thinks of a more graceful way of doing
 		  // this (or faster for that matter :-)), please let
diff --git a/liboctave/dbleLU.cc b/liboctave/dbleLU.cc
--- a/liboctave/dbleLU.cc
+++ b/liboctave/dbleLU.cc
@@ -38,18 +38,19 @@ Software Foundation, 59 Temple Place - S
 #include <base-lu.cc>
 
 template class base_lu <Matrix, double, Matrix, double>;
 
 // Define the constructor for this particular derivation.
 
 extern "C"
 {
-  int F77_FUNC (dgetrf, DGETRF) (const int&, const int&, double*,
-				const int&, int*, int&);
+  F77_RET_T
+  F77_FUNC (dgetrf, DGETRF) (const int&, const int&, double*,
+			     const int&, int*, int&);
 }
 
 LU::LU (const Matrix& a)
 {
   int a_nr = a.rows ();
   int a_nc = a.cols ();
   int mn = (a_nr < a_nc ? a_nr : a_nc);
 
diff --git a/liboctave/dbleQR.cc b/liboctave/dbleQR.cc
--- a/liboctave/dbleQR.cc
+++ b/liboctave/dbleQR.cc
@@ -29,23 +29,23 @@ Software Foundation, 59 Temple Place - S
 #endif
 
 #include "dbleQR.h"
 #include "f77-fcn.h"
 #include "lo-error.h"
 
 extern "C"
 {
-  int F77_FUNC (dgeqrf, DGEQRF) (const int&, const int&, double*,
-				const int&, double*, double*,
-				const int&, int&); 
+  F77_RET_T
+  F77_FUNC (dgeqrf, DGEQRF) (const int&, const int&, double*, const int&,
+			     double*, double*, const int&, int&); 
 
-  int F77_FUNC (dorgqr, DORGQR) (const int&, const int&, const int&,
-				double*, const int&, double*, double*,
-				const int&, int&);
+  F77_RET_T
+  F77_FUNC (dorgqr, DORGQR) (const int&, const int&, const int&, double*,
+			     const int&, double*, double*, const int&, int&);
 }
 
 QR::QR (const Matrix& a, QR::type qr_type)
   : q (), r ()
 {
   init (a, qr_type);
 }
 
diff --git a/liboctave/dbleQRP.cc b/liboctave/dbleQRP.cc
--- a/liboctave/dbleQRP.cc
+++ b/liboctave/dbleQRP.cc
@@ -31,23 +31,24 @@ Software Foundation, 59 Temple Place - S
 #include <cassert>
 
 #include "dbleQRP.h"
 #include "f77-fcn.h"
 #include "lo-error.h"
 
 extern "C"
 {
-  int F77_FUNC (dgeqpf, DGEQPF) (const int&, const int&, double*,
-				const int&, int*, double*, double*,
-				int&);
+  F77_RET_T
+  F77_FUNC (dgeqpf, DGEQPF) (const int&, const int&, double*,
+			     const int&, int*, double*, double*, int&);
 
-  int F77_FUNC (dorgqr, DORGQR) (const int&, const int&, const int&,
-				double*, const int&, double*, double*,
-				const int&, int&); 
+  F77_RET_T
+  F77_FUNC (dorgqr, DORGQR) (const int&, const int&, const int&,
+			     double*, const int&, double*, double*,
+			     const int&, int&);
 }
 
 // It would be best to share some of this code with QR class...
 
 QRP::QRP (const Matrix& a, QR::type qr_type)
   : QR (), p ()
 {
   init (a, qr_type);
diff --git a/liboctave/dbleSCHUR.cc b/liboctave/dbleSCHUR.cc
--- a/liboctave/dbleSCHUR.cc
+++ b/liboctave/dbleSCHUR.cc
@@ -31,23 +31,28 @@ Software Foundation, 59 Temple Place - S
 #include <iostream>
 
 #include "dbleSCHUR.h"
 #include "f77-fcn.h"
 #include "lo-error.h"
 
 extern "C"
 {
-  int F77_FUNC (dgeesx, DGEESX) (const char*, const char*,
-				SCHUR::select_function, const char*,
-				const int&, double*, const int&,
-				int&, double*, double*, double*,
-				const int&, double&, double&, double*,
-				const int&, int*, const int&, int*,
-				int&, long, long, long);
+  F77_RET_T
+  F77_FUNC (dgeesx, DGEESX) (F77_CONST_CHAR_ARG_DECL,
+			     F77_CONST_CHAR_ARG_DECL,
+			     SCHUR::select_function,
+			     F77_CONST_CHAR_ARG_DECL,
+			     const int&, double*, const int&, int&,
+			     double*, double*, double*, const int&,
+			     double&, double&, double*, const int&,
+			     int*, const int&, int*, int&
+			     F77_CHAR_ARG_LEN_DECL
+			     F77_CHAR_ARG_LEN_DECL
+			     F77_CHAR_ARG_LEN_DECL);
 }
 
 static int
 select_ana (const double& a, const double&)
 {
    return (a < 0.0);
 }
 
@@ -113,20 +118,25 @@ SCHUR::init (const Matrix& a, const std:
 
   // BWORK is not referenced for the non-ordered Schur routine.
   Array<int> bwork ((ord_char == 'N' || ord_char == 'n') ? 0 : n);
   int *pbwork = bwork.fortran_vec ();
 
   Array<int> iwork (liwork);
   int *piwork = iwork.fortran_vec ();
 
-  F77_XFCN (dgeesx, DGEESX, (&jobvs, &sort, selector, &sense, n, s,
-			     n, sdim, pwr, pwi, q, n, rconde, rcondv,
-			     pwork, lwork, piwork, liwork, pbwork,
-			     info, 1L, 1L, 1L));
+  F77_XFCN (dgeesx, DGEESX, (F77_CONST_CHAR_ARG2 (&jobvs, 1),
+			     F77_CONST_CHAR_ARG2 (&sort, 1),
+			     selector,
+			     F77_CONST_CHAR_ARG2 (&sense, 1),
+			     n, s, n, sdim, pwr, pwi, q, n, rconde, rcondv,
+			     pwork, lwork, piwork, liwork, pbwork, info
+			     F77_CHAR_ARG_LEN (1)
+			     F77_CHAR_ARG_LEN (1)
+			     F77_CHAR_ARG_LEN (1)));
 
   if (f77_exception_encountered)
     (*current_liboctave_error_handler) ("unrecoverable error in dgeesx");
 
   return info;
 }
 
 std::ostream&
diff --git a/liboctave/dbleSVD.cc b/liboctave/dbleSVD.cc
--- a/liboctave/dbleSVD.cc
+++ b/liboctave/dbleSVD.cc
@@ -30,21 +30,25 @@ Software Foundation, 59 Temple Place - S
 
 #include <iostream>
 
 #include "dbleSVD.h"
 #include "f77-fcn.h"
 
 extern "C"
 {
-  int F77_FUNC (dgesvd, DGESVD) (const char*, const char*, const int&,
-				const int&, double*, const int&,
-				double*, double*, const int&, double*,
-				const int&, double*, const int&, int&,
-				long, long);
+  F77_RET_T
+  F77_FUNC (dgesvd, DGESVD) (F77_CONST_CHAR_ARG_DECL,
+			     F77_CONST_CHAR_ARG_DECL,
+			     const int&, const int&, double*,
+			     const int&, double*, double*,
+			     const int&, double*, const int&,
+			     double*, const int&, int&
+			     F77_CHAR_ARG_LEN_DECL
+			     F77_CHAR_ARG_LEN_DECL);
 }
 
 Matrix
 SVD::left_singular_matrix (void) const
 {
   if (type_computed == SVD::sigma_only)
     {
       (*current_liboctave_error_handler)
@@ -131,31 +135,36 @@ SVD::init (const Matrix& a, SVD::type sv
   double *vt = right_sm.fortran_vec ();
 
   // Ask DGESVD what the dimension of WORK should be.
 
   int lwork = -1;
 
   Array<double> work (1);
 
-  F77_XFCN (dgesvd, DGESVD, (&jobu, &jobv, m, n, tmp_data, m, s_vec,
-			     u, m, vt, nrow_vt, work.fortran_vec (),
-			     lwork, info, 1L, 1L));
+  F77_XFCN (dgesvd, DGESVD, (F77_CONST_CHAR_ARG2 (&jobu, 1),
+			     F77_CONST_CHAR_ARG2 (&jobv, 1),
+			     m, n, tmp_data, m, s_vec, u, m, vt,
+			     nrow_vt, work.fortran_vec (), lwork, info
+			     F77_CHAR_ARG_LEN (1)
+			     F77_CHAR_ARG_LEN (1)));
 
   if (f77_exception_encountered)
     (*current_liboctave_error_handler) ("unrecoverable error in dgesvd");
   else
     {
       lwork = static_cast<int> (work(0));
       work.resize (lwork);
 
-      F77_XFCN (dgesvd, DGESVD, (&jobu, &jobv, m, n, tmp_data, m,
-				 s_vec, u, m, vt, nrow_vt,
-				 work.fortran_vec (), lwork, info, 1L,
-				 1L));
+      F77_XFCN (dgesvd, DGESVD, (F77_CONST_CHAR_ARG2 (&jobu, 1),
+				 F77_CONST_CHAR_ARG2 (&jobv, 1),
+				 m, n, tmp_data, m, s_vec, u, m, vt,
+				 nrow_vt, work.fortran_vec (), lwork, info
+				 F77_CHAR_ARG_LEN (1)
+				 F77_CHAR_ARG_LEN (1)));
 
       if (f77_exception_encountered)
 	(*current_liboctave_error_handler) ("unrecoverable error in dgesvd");
       else
 	{
 	  if (! (jobv == 'N' || jobv == 'O'))
 	    right_sm = right_sm.transpose ();
 	}
diff --git a/liboctave/lo-specfun.cc b/liboctave/lo-specfun.cc
--- a/liboctave/lo-specfun.cc
+++ b/liboctave/lo-specfun.cc
@@ -36,63 +36,76 @@ Software Foundation, 59 Temple Place - S
 #include "mx-inlines.cc"
 
 #ifndef M_PI
 #define M_PI 3.14159265358979323846
 #endif
 
 extern "C"
 {
-  int F77_FUNC (zbesj, ZBESJ) (const double&, const double&,
-			       const double&, const int&, const int&,
-			       double*, double*, int&, int&);
+  F77_RET_T
+  F77_FUNC (zbesj, ZBESJ) (const double&, const double&, const double&,
+			   const int&, const int&, double*, double*,
+			   int&, int&);
 
-  int F77_FUNC (zbesy, ZBESY) (const double&, const double&,
-			       const double&, const int&, const int&,
-			       double*, double*, int&,
-			       double*, double*, int&);
+  F77_RET_T
+  F77_FUNC (zbesy, ZBESY) (const double&, const double&, const double&,
+			   const int&, const int&, double*, double*,
+			   int&, double*, double*, int&);
 
-  int F77_FUNC (zbesi, ZBESI) (const double&, const double&,
-			       const double&, const int&, const int&,
-			       double*, double*, int&, int&);
+  F77_RET_T
+  F77_FUNC (zbesi, ZBESI) (const double&, const double&, const double&,
+			   const int&, const int&, double*, double*,
+			   int&, int&);
 
-  int F77_FUNC (zbesk, ZBESK) (const double&, const double&,
-			       const double&, const int&, const int&,
-			       double*, double*, int&, int&);
+  F77_RET_T
+  F77_FUNC (zbesk, ZBESK) (const double&, const double&, const double&,
+			   const int&, const int&, double*, double*,
+			   int&, int&);
 
-  int F77_FUNC (zbesh, ZBESH) (const double&, const double&,
-			       const double&, const int&, const int&,
-			       const int&, double*, double*, int&, int&);
+  F77_RET_T
+  F77_FUNC (zbesh, ZBESH) (const double&, const double&, const double&,
+			   const int&, const int&, const int&, double*,
+			   double*, int&, int&);
+
+  F77_RET_T
+  F77_FUNC (zairy, ZAIRY) (const double&, const double&, const int&,
+			   const int&, double&, double&, int&, int&);
 
-  int F77_FUNC (zairy, ZAIRY) (const double&, const double&,
-			       const int&, const int&,
-			       double&, double&, int&, int&);
+  F77_RET_T
+  F77_FUNC (zbiry, ZBIRY) (const double&, const double&, const int&,
+			   const int&, double&, double&, int&);
+
+  F77_RET_T
+  F77_FUNC (xdacosh, XDACOSH) (const double&, double&);
 
-  int F77_FUNC (zbiry, ZBIRY) (const double&, const double&,
-			       const int&, const int&,
-			       double&, double&, int&);
+  F77_RET_T
+  F77_FUNC (xdasinh, XDASINH) (const double&, double&);
 
-  int F77_FUNC (xdacosh, XDACOSH) (const double&, double&);
+  F77_RET_T
+  F77_FUNC (xdatanh, XDATANH) (const double&, double&);
 
-  int F77_FUNC (xdasinh, XDASINH) (const double&, double&);
+  F77_RET_T
+  F77_FUNC (xderf, XDERF) (const double&, double&);
 
-  int F77_FUNC (xdatanh, XDATANH) (const double&, double&);
+  F77_RET_T
+  F77_FUNC (xderfc, XDERFC) (const double&, double&);
 
-  int F77_FUNC (xderf, XDERF) (const double&, double&);
-
-  int F77_FUNC (xderfc, XDERFC) (const double&, double&);
+  F77_RET_T
+  F77_FUNC (xdbetai, XDBETAI) (const double&, const double&,
+			       const double&, double&);
 
-  int F77_FUNC (xdbetai, XDBETAI) (const double&, const double&,
-				   const double&, double&);
+  F77_RET_T
+  F77_FUNC (xdgamma, XDGAMMA) (const double&, double&);
 
-  int F77_FUNC (xdgamma, XDGAMMA) (const double&, double&);
+  F77_RET_T
+  F77_FUNC (xgammainc, XGAMMAINC) (const double&, const double&, double&);
 
-  int F77_FUNC (xgammainc, XGAMMAINC) (const double&, const double&, double&);
-
-  int F77_FUNC (dlgams, DLGAMS) (const double&, double&, double&);
+  F77_RET_T
+  F77_FUNC (dlgams, DLGAMS) (const double&, double&, double&);
 }
 
 #if !defined (HAVE_ACOSH)
 double
 acosh (double x)
 {
   double retval;
   F77_FUNC (xdacosh, XDACOSH) (x, retval);
diff --git a/liboctave/oct-rand.cc b/liboctave/oct-rand.cc
--- a/liboctave/oct-rand.cc
+++ b/liboctave/oct-rand.cc
@@ -37,29 +37,33 @@ Software Foundation, 59 Temple Place - S
 // Current distribution of random numbers.
 static int current_distribution = uniform_dist;
 
 // Has the seed been set yet?
 static bool initialized = false;
 
 extern "C"
 {
-  int F77_FUNC (dgennor, DGENNOR) (const double&, const double&,
-				  double&);
+  F77_RET_T
+  F77_FUNC (dgennor, DGENNOR) (const double&, const double&, double&);
 
-  int F77_FUNC (dgenunf, DGENUNF) (const double&, const double&,
-				  double&);
+  F77_RET_T
+  F77_FUNC (dgenunf, DGENUNF) (const double&, const double&, double&);
+
+  F77_RET_T
+  F77_FUNC (setall, SETALL) (const int&, const int&);
 
-  int F77_FUNC (setall, SETALL) (const int&, const int&);
-
-  int F77_FUNC (getsd, GETSD) (int&, int&);
+  F77_RET_T
+  F77_FUNC (getsd, GETSD) (int&, int&);
 
-  int F77_FUNC (setsd, SETSD) (const int&, const int&);
+  F77_RET_T
+  F77_FUNC (setsd, SETSD) (const int&, const int&);
 
-  int F77_FUNC (setcgn, SETCGN) (const int&);
+  F77_RET_T
+  F77_FUNC (setcgn, SETCGN) (const int&);
 }
 
 static int
 force_to_fit_range (int i, int lo, int hi)
 {
   assert (hi > lo && lo >= 0 && hi > lo);
 
   i = i > 0 ? i : -i;
diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,10 +1,14 @@
 2003-10-27  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
+	* DLD-FUNCTIONS/balance.cc, DLD-FUNCTIONS/qz.cc:
+	Use new F77 arg macros in declarations of external Fortran
+	subroutines and for calling them.
+
 	* ops.h (DEFNDUNOP_OP, DEFNDUNOP_FN): New arg e, to name value
 	extractor function prefix.
 	* OPERATORS/op-bm-bm.cc, OPERATORS/op-cm-cm.cc,	OPERATORS/op-m-m.cc:
 	Change all uses.
 
 	* ov-cx-mat.h (octave_complex_matrix::complex_array_value,
 	octave_char_matrix::char_array_value,
 	octave_bool_matrix::bool_array_value): Rename from array_value.
diff --git a/src/DLD-FUNCTIONS/balance.cc b/src/DLD-FUNCTIONS/balance.cc
--- a/src/DLD-FUNCTIONS/balance.cc
+++ b/src/DLD-FUNCTIONS/balance.cc
@@ -38,33 +38,41 @@ Software Foundation, 59 Temple Place - S
 #include "error.h"
 #include "f77-fcn.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "utils.h"
 
 extern "C"
 {
-  int F77_FUNC (dggbal, DGGBAL) (const char* JOB, const int& N,
-				double* A, const int& LDA, double* B,
-				const int& LDB, int& ILO, int& IHI,
-				double* LSCALE, double* RSCALE,
-				double* WORK, int& INFO, long);
+  F77_RET_T
+  F77_FUNC (dggbal, DGGBAL) (F77_CONST_CHAR_ARG_DECL, const int& N,
+			     double* A, const int& LDA, double* B,
+			     const int& LDB, int& ILO, int& IHI,
+			     double* LSCALE, double* RSCALE,
+			     double* WORK, int& INFO
+			     F77_CHAR_ARG_LEN_DECL);
 
-  int F77_FUNC (dggbak, DGGBAK) (const char* JOB, const char* SIDE,
-				const int& N, const int& ILO,
-				const int& IHI, double* LSCALE,
-				double* RSCALE, int& M,	double* V,
-				const int& LDV, int& INFO, long, long);
+  F77_RET_T
+  F77_FUNC (dggbak, DGGBAK) (F77_CONST_CHAR_ARG_DECL,
+			     F77_CONST_CHAR_ARG_DECL,
+			     const int& N, const int& ILO,
+			     const int& IHI, double* LSCALE,
+			     double* RSCALE, int& M,	double* V,
+			     const int& LDV, int& INFO
+			     F77_CHAR_ARG_LEN_DECL
+			     F77_CHAR_ARG_LEN_DECL);
 
-  int F77_FUNC (zggbal, ZGGBAL) (const char* JOB, const int& N,
-				Complex* A, const int& LDA, Complex* B,
-				const int& LDB, int& ILO, int& IHI,
-				double* LSCALE, double* RSCALE,
-				double* WORK, int& INFO, long);
+  F77_RET_T
+  F77_FUNC (zggbal, ZGGBAL) (F77_CONST_CHAR_ARG_DECL, const int& N,
+			     Complex* A, const int& LDA, Complex* B,
+			     const int& LDB, int& ILO, int& IHI,
+			     double* LSCALE, double* RSCALE,
+			     double* WORK, int& INFO
+			     F77_CHAR_ARG_LEN_DECL);
 }
 
 DEFUN_DLD (balance, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{aa} =} balance (@var{a}, @var{opt})\n\
 @deftypefnx {Loadable Function} {[@var{dd}, @var{aa}] =} balance (@var{a}, @var{opt})\n\
 @deftypefnx {Loadable Function} {[@var{cc}, @var{dd}, @var{aa}, @var{bb}] =} balance (@var{a}, @var{b}, @var{opt})\n\
 \n\
@@ -234,35 +242,38 @@ Generalized eigenvalue problem balancing
 	{
 	  if (args(0).is_real_type ())
 	    caa = ComplexMatrix (aa);
 
 	  if (args(1).is_real_type ())
 	    cbb = ComplexMatrix (bb);
   
 	  F77_XFCN (zggbal, ZGGBAL,
-		    (&job, nn, caa.fortran_vec(), nn,
-		     cbb.fortran_vec(), nn, ilo, ihi,
-		     lscale.fortran_vec(), rscale.fortran_vec(),
-		     work.fortran_vec(), info, 1L));
+		    (F77_CONST_CHAR_ARG2 (&job, 1),
+		     nn, caa.fortran_vec (), nn, cbb.fortran_vec (),
+		     nn, ilo, ihi, lscale.fortran_vec (),
+		     rscale.fortran_vec (), work.fortran_vec (), info
+		     F77_CHAR_ARG_LEN (1)));
 
 	  if (f77_exception_encountered)
 	    {
 	      error ("unrecoverable error in balance GEP");
 	      return retval;
 	    }
 	}
       else
 	{
 	  // real matrices case
 
 	  F77_XFCN (dggbal, DGGBAL,
-		    (&job,  nn, aa.fortran_vec(), nn, bb.fortran_vec(),
-		     nn, ilo, ihi, lscale.fortran_vec(),
-		     rscale.fortran_vec(), work.fortran_vec(), info, 1L));
+		    (F77_CONST_CHAR_ARG2 (&job, 1),
+		     nn, aa.fortran_vec (), nn, bb.fortran_vec (),
+		     nn, ilo, ihi, lscale.fortran_vec (),
+		     rscale.fortran_vec (), work.fortran_vec (), info
+		     F77_CHAR_ARG_LEN  (1)));
       
 	  if (f77_exception_encountered)
 	    {
 	      error ("unrecoverable error in balance GEP");
 	      return retval;
 	    }
 	}
       
@@ -276,31 +287,37 @@ Generalized eigenvalue problem balancing
 	  {
 	    OCTAVE_QUIT;
 
 	    Pl(ii,jj) = Pr(ii,jj) = (ii == jj ? 1.0 : 0.0);
 	  }
   
       // left first
       F77_XFCN (dggbak, DGGBAK,
-		(&job, "L", nn, ilo, ihi, lscale.fortran_vec(),
-		 rscale.fortran_vec(), nn, Pl.fortran_vec(),
-		 nn, info, 1L, 1L));
+		(F77_CONST_CHAR_ARG2 (&job, 1),
+		 F77_CONST_CHAR_ARG2 ("L", 1),
+		 nn, ilo, ihi, lscale.fortran_vec (),
+		 rscale.fortran_vec(), nn, Pl.fortran_vec (), nn, info
+		 F77_CHAR_ARG_LEN (1)
+		 F77_CHAR_ARG_LEN (1)));
       
       if (f77_exception_encountered)
 	{
 	  error ("unrecoverable error in balance GEP(L)");
 	  return retval;
 	}
       
       // then right
       F77_XFCN (dggbak, DGGBAK,
-		(&job, "R", nn, ilo, ihi, lscale.fortran_vec(),
-		 rscale.fortran_vec(), nn, Pr.fortran_vec(),
-		 nn, info, 1L, 1L));
+		(F77_CONST_CHAR_ARG2 (&job, 1),
+		 F77_CONST_CHAR_ARG2 ("R", 1),
+		 nn, ilo, ihi, lscale.fortran_vec (),
+		 rscale.fortran_vec (), nn, Pr.fortran_vec (), nn, info
+		 F77_CHAR_ARG_LEN (1)
+		 F77_CHAR_ARG_LEN (1)));
 
       if (f77_exception_encountered)
 	{
 	  error ("unrecoverable error in balance GEP(R)");
 	  return retval;
 	}
 
       switch (nargout)
diff --git a/src/DLD-FUNCTIONS/qz.cc b/src/DLD-FUNCTIONS/qz.cc
--- a/src/DLD-FUNCTIONS/qz.cc
+++ b/src/DLD-FUNCTIONS/qz.cc
@@ -56,76 +56,100 @@ Software Foundation, 59 Temple Place - S
 #include "variables.h"
 
 typedef int (*sort_function) (const int& LSIZE, const double& ALPHA,
 			      const double& BETA, const double& S,
 			      const double& P);
 
 extern "C"
 {
-  int F77_FUNC (dggbal, DGGBAL) (const char* JOB, const int& N,
-				double* A, const int& LDA, double* B,
-				const int& LDB, int& ILO, int& IHI,
-				double* LSCALE, double* RSCALE,
-				double* WORK, int& INFO, long);
+  F77_RET_T
+  F77_FUNC (dggbal, DGGBAL) (F77_CONST_CHAR_ARG_DECL,
+			     const int& N, double* A, const int& LDA,
+			     double* B, const int& LDB, int& ILO,
+			     int& IHI, double* LSCALE, double* RSCALE,
+			     double* WORK, int& INFO
+			     F77_CHAR_ARG_LEN_DECL);
 
-  int F77_FUNC (dggbak, DGGBAK) (const char* JOB, const char* SIDE,
-				const int& N, const int& ILO,
-				const int& IHI, double* LSCALE,
-				double* RSCALE, int& M, double* V,
-				const int& LDV, int& INFO, long, long);
+  F77_RET_T
+  F77_FUNC (dggbak, DGGBAK) (F77_CONST_CHAR_ARG_DECL,
+			     F77_CONST_CHAR_ARG_DECL,
+			     const int& N, const int& ILO,
+			     const int& IHI, double* LSCALE,
+			     double* RSCALE, int& M, double* V,
+			     const int& LDV, int& INFO
+			     F77_CHAR_ARG_LEN_DECL
+			     F77_CHAR_ARG_LEN_DECL);
 
-  int F77_FUNC (dgghrd, DGGHRD) (const char* COMPQ, const char* COMPZ,
-				const int& N, const int& ILO,
-				const int& IHI, double* A,
-				const int& LDA, double* B,
-				const int& LDB, double* Q,
-				const int& LDQ, double* Z,
-				const int& LDZ, int& INFO, long, long);
+  F77_RET_T
+  F77_FUNC (dgghrd, DGGHRD) (F77_CONST_CHAR_ARG_DECL,
+			     F77_CONST_CHAR_ARG_DECL,
+			     const int& N, const int& ILO,
+			     const int& IHI, double* A,
+			     const int& LDA, double* B,
+			     const int& LDB, double* Q,
+			     const int& LDQ, double* Z,
+			     const int& LDZ, int& INFO
+			     F77_CHAR_ARG_LEN_DECL
+			     F77_CHAR_ARG_LEN_DECL);
 
-  int F77_FUNC (dhgeqz, DHGEQZ) (const char* JOB, const char* COMPQ,
-				const char* COMPZ, const int& N,
-				const int& ILO, const int& IHI,
-				double* A, const int& LDA, double* B,
-				const int& LDB, double* ALPHAR,
-				double* ALPHAI, double* BETA, double* Q,
-				const int& LDQ, double* Z,
-				const int& LDZ, double* WORK,
-				const int& LWORK, int& INFO,
-				long, long, long);
+  F77_RET_T
+  F77_FUNC (dhgeqz, DHGEQZ) (F77_CONST_CHAR_ARG_DECL,
+			     F77_CONST_CHAR_ARG_DECL,
+			     F77_CONST_CHAR_ARG_DECL,
+			     const int& N, const int& ILO, const int& IHI,
+			     double* A, const int& LDA, double* B,
+			     const int& LDB, double* ALPHAR,
+			     double* ALPHAI, double* BETA, double* Q,
+			     const int& LDQ, double* Z,
+			     const int& LDZ, double* WORK,
+			     const int& LWORK, int& INFO
+			     F77_CHAR_ARG_LEN_DECL
+			     F77_CHAR_ARG_LEN_DECL
+			     F77_CHAR_ARG_LEN_DECL);
 
-  int F77_FUNC (dlag2, DLAG2) (double* A, const int& LDA, double* B,
-			      const int& LDB, const double& SAFMIN,
-			      double& SCALE1, double& SCALE2,
-			      double& WR1, double& WR2, double& WI);
+  F77_RET_T
+  F77_FUNC (dlag2, DLAG2) (double* A, const int& LDA, double* B,
+			   const int& LDB, const double& SAFMIN,
+			   double& SCALE1, double& SCALE2,
+			   double& WR1, double& WR2, double& WI);
 
   // Van Dooren's code (netlib.org: toms/590) for reordering
   // GEP.  Only processes Z, not Q.
-  int F77_FUNC (dsubsp, DSUBSP) (const int& NMAX, const int& N, double* A,
-				double* B, double* Z, sort_function,
-				const double& EPS, int& NDIM, int& FAIL,
-				int* IND);
+  F77_RET_T
+  F77_FUNC (dsubsp, DSUBSP) (const int& NMAX, const int& N, double* A,
+			     double* B, double* Z, sort_function,
+			     const double& EPS, int& NDIM, int& FAIL,
+			     int* IND);
 
   // documentation for DTGEVC incorrectly states that VR, VL are
   // complex*16; they are declared in DTGEVC as double precision
   // (probably a cut and paste problem fro ZTGEVC)
-  int F77_FUNC (dtgevc, DTGEVC) (const char* SIDE, const char* HOWMNY,
-				int* SELECT, const int& N, double* A,
-				const int& LDA, double* B,
-				const int& LDB, double* VL,
-				const int& LDVL, double* VR,
-				const int& LDVR, const int& MM,
-				int& M, double* WORK, int& INFO,
-				long, long);
+  F77_RET_T
+  F77_FUNC (dtgevc, DTGEVC) (F77_CONST_CHAR_ARG_DECL,
+			     F77_CONST_CHAR_ARG_DECL,
+			     int* SELECT, const int& N, double* A,
+			     const int& LDA, double* B,
+			     const int& LDB, double* VL,
+			     const int& LDVL, double* VR,
+			     const int& LDVR, const int& MM,
+			     int& M, double* WORK, int& INFO
+			     F77_CHAR_ARG_LEN_DECL
+			     F77_CHAR_ARG_LEN_DECL);
 
-  int F77_FUNC (xdlamch, XDLAMCH) (const char* cmach, double& retval, long);
+  F77_RET_T
+  F77_FUNC (xdlamch, XDLAMCH) (F77_CONST_CHAR_ARG_DECL,
+			       double& retval
+			       F77_CHAR_ARG_LEN_DECL);
 
-  int F77_FUNC (xdlange, XDLANGE) (const char*, const int&,
-                                  const int&, const double*,
-                                  const int&, double*, double&);
+  F77_RET_T
+  F77_FUNC (xdlange, XDLANGE) (F77_CONST_CHAR_ARG_DECL,
+			       const int&, const int&, const double*,
+			       const int&, double*, double&
+			       F77_CHAR_ARG_LEN_DECL);
 }
 
 // fcrhp, fin, fout, folhp:
 // routines for ordering of generalized eigenvalues
 // return 1 if  test is passed, 0 otherwise
 //    fin: |lambda| < 1
 //    fout: |lambda| >= 1
 //    fcrhp: real(lambda) >= 0
@@ -281,32 +305,36 @@ See also: balance, dare, eig, schur\n\
 	  && ord_job[0] != '+'
 	  && ord_job[0] != '-')
 	{
 	  error ("qz: invalid order option");
 	  return retval;
 	}
 
       // overflow constant required by dlag2
-      F77_FUNC (xdlamch, XDLAMCH) ("S", safmin, 1L);
+      F77_FUNC (xdlamch, XDLAMCH) (F77_CONST_CHAR_ARG2 ("S", 1),
+				   safmin
+				   F77_CHAR_ARG_LEN (1));
 
 #ifdef DEBUG_EIG
       std::cout << "qz: initial value of safmin=" << setiosflags (std::ios::scientific)
 	   << safmin << std::endl;
 #endif
 
       // some machines (e.g., DEC alpha) get safmin = 0;
       // for these, use eps instead to avoid problems in dlag2
       if (safmin == 0)
 	{
 #ifdef DEBUG_EIG
 	  std::cout << "qz: DANGER WILL ROBINSON: safmin is 0!" << std::endl;
 #endif
 
-	  F77_FUNC (xdlamch, XDLAMCH) ("E", safmin, 1L);
+	  F77_FUNC (xdlamch, XDLAMCH) (F77_CONST_CHAR_ARG2 ("E", 1),
+				       safmin
+				       F77_CHAR_ARG_LEN (1));
 
 #ifdef DEBUG_EIG
 	  std::cout << "qz: safmin set to " << setiosflags (std::ios::scientific)
 	       << safmin << std::endl;
 #endif
 	}
     }
 
@@ -400,73 +428,83 @@ See also: balance, dare, eig, schur\n\
     for (int ii = 0; ii < nn; ii++)
       for (int jj = 0; jj < nn; jj++)
 	{
 	  OCTAVE_QUIT;
 	  QQ(ii,jj) = ZZ(ii,jj) = (ii == jj ? 1.0 : 0.0);
 	}
 
   // always perform permutation balancing
-  char bal_job = 'P';
+  const char bal_job = 'P';
   RowVector lscale(nn), rscale(nn), work(6*nn);
 
   if (complex_case)
     {
       error ("Complex case not implemented yet");
       return retval;
     }
   else
     {
 #ifdef DEBUG
       if (compq == 'V')
 	std::cout << "qz: performing balancing; QQ=" << std::endl << QQ << std::endl;
 #endif
 
       F77_XFCN (dggbal, DGGBAL,
-		(&bal_job,  nn, aa.fortran_vec(), nn, bb.fortran_vec(),
-		 nn, ilo, ihi, lscale.fortran_vec(),
-		 rscale.fortran_vec(), work.fortran_vec(), info, 1L));
+		(F77_CONST_CHAR_ARG2 (&bal_job, 1),
+		 nn, aa.fortran_vec (), nn, bb.fortran_vec (),
+		 nn, ilo, ihi, lscale.fortran_vec (),
+		 rscale.fortran_vec (), work.fortran_vec (), info
+		 F77_CHAR_ARG_LEN (1)));
 
       if (f77_exception_encountered)
 	{
 	  error ("unrecoverable error in qz (bal)");
 	  return retval;
 	}
     }
 
   // Since we just want the balancing matrices, we can use dggbal
   // for both the real and complex cases;
   // left first
 
   if (compq == 'V')
     {
       F77_XFCN (dggbak, DGGBAK,
-		(&bal_job, "L", nn, ilo, ihi, lscale.fortran_vec(),
-		 rscale.fortran_vec(), nn, QQ.fortran_vec(),
-		 nn, info, 1L, 1L));
+		(F77_CONST_CHAR_ARG2 (&bal_job, 1),
+		 F77_CONST_CHAR_ARG2 ("L", 1),
+		 nn, ilo, ihi, lscale.fortran_vec (),
+		 rscale.fortran_vec (), nn, QQ.fortran_vec (),
+		 nn, info
+		 F77_CHAR_ARG_LEN (1)
+		 F77_CHAR_ARG_LEN (1)));
 
 #ifdef DEBUG
       if (compq == 'V')
 	std::cout << "qz: balancing done; QQ=" << std::endl << QQ << std::endl;
 #endif
 
     if (f77_exception_encountered)
       {
 	error ("unrecoverable error in qz (bal-L)");
 	return retval;
       }
   }
 
   // then right
   if (compz == 'V')
     {
-      F77_XFCN (dggbak, DGGBAK, (&bal_job, "R",
-				 nn, ilo, ihi, lscale.fortran_vec(),
-				 rscale.fortran_vec(), nn, ZZ.fortran_vec(),
-				 nn, info, 1L, 1L));
+      F77_XFCN (dggbak, DGGBAK,
+		(F77_CONST_CHAR_ARG2 (&bal_job, 1),
+		 F77_CONST_CHAR_ARG2 ("R", 1),
+		 nn, ilo, ihi, lscale.fortran_vec (),
+		 rscale.fortran_vec (), nn, ZZ.fortran_vec (),
+		 nn, info
+		 F77_CHAR_ARG_LEN (1)
+		 F77_CHAR_ARG_LEN (1)));
 
 #ifdef DEBUG
       if (compz == 'V')
 	std::cout << "qz: balancing done; ZZ=" << std::endl << ZZ << std::endl;
 #endif
 
       if (f77_exception_encountered)
 	{
@@ -533,37 +571,45 @@ See also: balance, dare, eig, schur\n\
 #endif
 
 #ifdef DEBUG
       std::cout << "qz: compq = " << compq << ", compz = " << compz << std::endl;
 #endif
 
       // reduce  to generalized hessenberg form
       F77_XFCN (dgghrd, DGGHRD,
-		(&compq, &compz, nn, ilo, ihi, aa.fortran_vec(),
-		 nn, bb.fortran_vec(), nn, QQ.fortran_vec(), nn,
-		 ZZ.fortran_vec(), nn, info, 1L, 1L));
+		(F77_CONST_CHAR_ARG2 (&compq, 1),
+		 F77_CONST_CHAR_ARG2 (&compz, 1),
+		 nn, ilo, ihi, aa.fortran_vec (),
+		 nn, bb.fortran_vec (), nn, QQ.fortran_vec (), nn,
+		 ZZ.fortran_vec (), nn, info
+		 F77_CHAR_ARG_LEN (1)
+		 F77_CHAR_ARG_LEN (1)));
 
       if (f77_exception_encountered)
 	{
 	  error ("unrecoverable error in qz (dgghrd)");
 	  return retval;
 	}
 
       // check if just computing generalized eigenvalues or if we're
       // actually computing the decomposition
 
       // reduce to generalized Schur form
       F77_XFCN (dhgeqz, DHGEQZ,
-		(&qz_job, &compq, &compz, nn, ilo, ihi,
-		 aa.fortran_vec(), nn, bb.fortran_vec(), nn,
-		 alphar.fortran_vec(), alphai.fortran_vec(),
-		 betar.fortran_vec(), QQ.fortran_vec(), nn,
-		 ZZ.fortran_vec(), nn, work.fortran_vec(), nn, info,
-		 1L, 1L, 1L));
+		(F77_CONST_CHAR_ARG2 (&qz_job, 1),
+		 F77_CONST_CHAR_ARG2 (&compq, 1),
+		 F77_CONST_CHAR_ARG2 (&compz, 1),
+		 nn, ilo, ihi, aa.fortran_vec (), nn, bb.fortran_vec (),
+		 nn, alphar.fortran_vec (), alphai.fortran_vec (),
+		 betar.fortran_vec (), QQ.fortran_vec (), nn,
+		 ZZ.fortran_vec (), nn, work.fortran_vec (), nn, info
+		 F77_CHAR_ARG_LEN (1)
+		 F77_CHAR_ARG_LEN (1)
+		 F77_CHAR_ARG_LEN (1)));
 
       if (f77_exception_encountered)
 	{
 	  error ("unrecoverable error in qz (dhgeqz)");
 	  return retval;
 	}
     }
 
@@ -610,18 +656,20 @@ See also: balance, dare, eig, schur\n\
 	      panic_impossible ();
 	      break;
 	    }
 
 	  int ndim, fail;
 	  double inf_norm;
 
 	  F77_XFCN (xdlange, XDLANGE,
-		    ("I", nn, nn, aa.fortran_vec (), nn,
-		     work.fortran_vec (), inf_norm));
+		    (F77_CONST_CHAR_ARG2 ("I", 1),
+		     nn, nn, aa.fortran_vec (), nn,
+		     work.fortran_vec (), inf_norm
+		     F77_CHAR_ARG_LEN (1)));
 
 	  double eps = DBL_EPSILON*inf_norm*nn;
 
 #ifdef DEBUG_SORT
 	  std::cout << "qz: calling dsubsp: aa=" << std::endl;
 	  octave_print_internal (std::cout, aa, 0);
 	  std::cout << std::endl << "bb="  << std::endl;
 	  octave_print_internal (std::cout, bb, 0);
@@ -638,18 +686,18 @@ See also: balance, dare, eig, schur\n\
 	  std::cout << std::endl << "beta = " << std::endl;
 	  octave_print_internal (std::cout, (Matrix) betar, 0);
 	  std::cout << std::endl;
 #endif
 
 	  Array<int> ind (nn);
 
 	  F77_XFCN (dsubsp, DSUBSP,
-		    (nn, nn, aa.fortran_vec(), bb.fortran_vec(),
-		     ZZ.fortran_vec(), sort_test, eps, ndim, fail,
+		    (nn, nn, aa.fortran_vec (), bb.fortran_vec (),
+		     ZZ.fortran_vec (), sort_test, eps, ndim, fail,
 		     ind.fortran_vec ()));
 
 #ifdef DEBUG
 	  std::cout << "qz: back from dsubsp: aa=" << std::endl;
 	  octave_print_internal (std::cout, aa, 0);
 	  std::cout << std::endl << "bb="  << std::endl;
 	  octave_print_internal (std::cout, bb, 0);
 	  if (compz == 'V')
@@ -820,20 +868,23 @@ See also: balance, dare, eig, schur\n\
 #ifdef DEBUG
 	  std::cout << "qz: computing  generalized eigenvectors" << std::endl;
 #endif
 
 	  VL = QQ;
 	  VR = ZZ;
 
 	  F77_XFCN (dtgevc, DTGEVC,
-		    (&side, &howmny, select, nn, aa.fortran_vec(),
-		     nn, bb.fortran_vec(), nn, VL.fortran_vec(), nn,
-		     VR.fortran_vec(), nn, nn, m, work.fortran_vec(),
-		     info, 1L, 1L));
+		    (F77_CONST_CHAR_ARG2 (&side, 1),
+		     F77_CONST_CHAR_ARG2 (&howmny, 1),
+		     select, nn, aa.fortran_vec (), nn, bb.fortran_vec (),
+		     nn, VL.fortran_vec (), nn, VR.fortran_vec (), nn, nn,
+		     m, work.fortran_vec (), info
+		     F77_CHAR_ARG_LEN (1)
+		     F77_CHAR_ARG_LEN (1)));
 
 	  if (f77_exception_encountered)
 	    {
 	      error ("unrecoverable error in qz (dtgevc)");
 	      return retval;
 	    }
 
 	  // now construct the complex form of VV, WW
