# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1265908603 18000
#      Thu Feb 11 12:16:43 2010 -0500
# Node ID f3b65e1ae35568b4561c9686a36fb632f505fa40
# Parent  cbc402e64d83faa370dc21ceb99bda46ee16b01c
untabify src header files

diff --git a/src/Cell.h b/src/Cell.h
--- a/src/Cell.h
+++ b/src/Cell.h
@@ -43,17 +43,17 @@ public:
     : Array<octave_value> (dim_vector (0, 0)) { }
 
   Cell (const octave_value& val)
     : Array<octave_value> (dim_vector (1, 1), val) { }
 
   Cell (const octave_value_list& ovl);
 
   Cell (octave_idx_type n, octave_idx_type m,
-	const octave_value& val = resize_fill_value ())
+        const octave_value& val = resize_fill_value ())
     : Array<octave_value> (dim_vector (n, m), val) { }
 
   Cell (const dim_vector& dv, const octave_value& val = resize_fill_value ())
     : Array<octave_value> (dv, val) { }
 
   Cell (const Array<octave_value>& c)
     : Array<octave_value> (c) { }
 
@@ -73,17 +73,17 @@ public:
 
   Array<std::string> cellstr_value (void) const;
 
   Cell index (const octave_value_list& idx, bool resize_ok = false) const;
 
   Cell& delete_elements (const octave_value_list& idx);
 
   Cell& assign (const octave_value_list& idx, const Cell& rhs,
-		const octave_value& fill_val = resize_fill_value ());
+                const octave_value& fill_val = resize_fill_value ());
 
   Cell reshape (const dim_vector& new_dims) const
     { return Array<octave_value>::reshape (new_dims); }
 
   octave_idx_type nnz (void) const;
 
   Cell column (octave_idx_type i) const;
 
diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,8 +1,35 @@
+2010-02-11  John W. Eaton  <jwe@octave.org>
+
+	* Cell.h, base-list.h, c-file-ptr-stream.h, comment-list.h,
+	debug.h, defun-int.h, dynamic-ld.h, error.h, gl-render.h,
+	gl2ps-renderer.h, gripes.h, load-path.h, load-save.h, ls-hdf5.h,
+	ls-mat-ascii.h, ls-mat4.h, ls-mat5.h, ls-oct-ascii.h,
+	ls-oct-binary.h, oct-fstrm.h, oct-iostrm.h, oct-lvalue.h,
+	oct-map.h, oct-obj.h, oct-prcstrm.h, oct-stdstrm.h,
+	oct-stream.h, oct-strstrm.h, octave.h, ops.h, ov-base-diag.h,
+	ov-base-int.h, ov-base-mat.h, ov-base-scalar.h,
+	ov-base-sparse.h, ov-base.h, ov-bool-mat.h, ov-bool-sparse.h,
+	ov-bool.h, ov-builtin.h, ov-cell.h, ov-class.h, ov-complex.h,
+	ov-cx-diag.h, ov-cx-mat.h, ov-cx-sparse.h, ov-dld-fcn.h,
+	ov-fcn-handle.h, ov-fcn-inline.h, ov-fcn.h, ov-float.h,
+	ov-flt-complex.h, ov-flt-cx-diag.h, ov-flt-cx-mat.h,
+	ov-flt-re-diag.h, ov-flt-re-mat.h, ov-intx.h, ov-mex-fcn.h,
+	ov-perm.h, ov-range.h, ov-re-diag.h, ov-re-mat.h,
+	ov-re-sparse.h, ov-scalar.h, ov-str-mat.h, ov-struct.h,
+	ov-type-conv.h, ov-typeinfo.h, ov-usr-fcn.h, ov.h, parse.h,
+	pr-output.h, pt-arg-list.h, pt-assign.h, pt-binop.h, pt-cell.h,
+	pt-cmd.h, pt-colon.h, pt-const.h, pt-decl.h, pt-eval.h,
+	pt-except.h, pt-exp.h, pt-fcn-handle.h, pt-id.h, pt-idx.h,
+	pt-jump.h, pt-loop.h, pt-mat.h, pt-misc.h, pt-pr-code.h,
+	pt-select.h, pt-stmt.h, pt-unop.h, sighandlers.h, sparse-xdiv.h,
+	sparse-xpow.h, symtab.h, token.h, toplev.h, txt-eng-ft.h,
+	txt-eng.h, utils.h, variables.h, xdiv.h: Untabify.
+
 2010-02-11  John W. Eaton  <jwe@octave.org>
 
 	* DLD-FUNCTIONS/qz.cc: Untabify.
 	(Fqz): Declare complex_case volatile to avoid GCC warning.
 
 2010-02-11  John W. Eaton  <jwe@octave.org>
 
 	* DLD-FUNCTIONS/qz.cc: Style fixes.
diff --git a/src/base-list.h b/src/base-list.h
--- a/src/base-list.h
+++ b/src/base-list.h
@@ -50,21 +50,21 @@ public:
     // but the Sun Studio compiler chokes on that.
     //
     // FIXME -- this kluge should be removed at some point.
 
     iterator b = lst.begin ();
     iterator e = lst.end ();
     while (b != e)
       {
-	iterator n = b;
-	n++;
-	if (pred (*b))
-	  lst.erase (b);
-	b = n;
+        iterator n = b;
+        n++;
+        if (pred (*b))
+          lst.erase (b);
+        b = n;
       }
   }
 
   void clear (void) { lst.clear (); }
 
   iterator begin (void) { return iterator (lst.begin ()); }
   const_iterator begin (void) const { return const_iterator (lst.begin ()); }
 
diff --git a/src/c-file-ptr-stream.h b/src/c-file-ptr-stream.h
--- a/src/c-file-ptr-stream.h
+++ b/src/c-file-ptr-stream.h
@@ -57,20 +57,20 @@ public:
 
   int_type pbackfail (int_type);
 
   std::streamsize xsputn (const char*, std::streamsize);
 
   std::streamsize xsgetn (char *, std::streamsize);
 
   std::streampos seekoff (std::streamoff, std::ios::seekdir,
-			  std::ios::openmode = std::ios::in | std::ios::out);
+                          std::ios::openmode = std::ios::in | std::ios::out);
   
   std::streampos seekpos (std::streampos,
-			  std::ios::openmode = std::ios::in | std::ios::out);
+                          std::ios::openmode = std::ios::in | std::ios::out);
 
   int sync (void);
 
   int flush (void);
 
   int buf_close (void);
 
   int file_number () const { return f ? fileno (f) : -1; }
@@ -164,20 +164,20 @@ public:
 
   int_type pbackfail (int_type);
 
   std::streamsize xsputn (const char*, std::streamsize);
 
   std::streamsize xsgetn (char *, std::streamsize);
 
   std::streampos seekoff (std::streamoff, std::ios::seekdir,
-			  std::ios::openmode = std::ios::in | std::ios::out);
+                          std::ios::openmode = std::ios::in | std::ios::out);
   
   std::streampos seekpos (std::streampos,
-			  std::ios::openmode = std::ios::in | std::ios::out);
+                          std::ios::openmode = std::ios::in | std::ios::out);
 
   int sync (void);
 
   int flush (void);
 
   int buf_close (void);
 
   int file_number () const { return -1; }
diff --git a/src/comment-list.h b/src/comment-list.h
--- a/src/comment-list.h
+++ b/src/comment-list.h
@@ -43,29 +43,29 @@ public:
     unknown,
     block,
     end_of_line,
     doc_string,
     copyright
   };
 
   octave_comment_elt (const std::string& s = std::string (),
-		      comment_type t = unknown)
+                      comment_type t = unknown)
     : txt (s), typ (t) { }
 
   octave_comment_elt (const octave_comment_elt& oc)
     : txt (oc.txt), typ (oc.typ) { }
 
   octave_comment_elt& operator = (const octave_comment_elt& oc)
     {
       if (this != &oc)
-	{
-	  txt = oc.txt;
-	  typ = oc.typ;
-	}
+        {
+          txt = oc.txt;
+          typ = oc.typ;
+        }
 
       return *this;
     }
 
   std::string text (void) const { return txt; }
 
   comment_type type (void) const { return typ; }
 
@@ -86,17 +86,17 @@ octave_comment_list : public octave_base
 public:
 
   octave_comment_list (void) { }
 
   void append (const octave_comment_elt& elt)
     { octave_base_list<octave_comment_elt>::append (elt); }
 
   void append (const std::string& s,
-	       octave_comment_elt::comment_type t = octave_comment_elt::unknown)
+               octave_comment_elt::comment_type t = octave_comment_elt::unknown)
     { append (octave_comment_elt (s, t)); }
 
   octave_comment_list *dup (void) const;
 };
 
 class
 octave_comment_buffer
 {
diff --git a/src/debug.h b/src/debug.h
--- a/src/debug.h
+++ b/src/debug.h
@@ -68,33 +68,33 @@ public:
         retval = false;
       }
     
     return retval;
   }
 
   // Add a breakpoint at the nearest executable line.
   static intmap add_breakpoint (const std::string& fname = "", 
-				const intmap& lines = intmap ())
+                                const intmap& lines = intmap ())
   {
     return instance_ok ()
       ? instance->do_add_breakpoint (fname, lines) : intmap ();
   }
 
   // Remove a breakpoint from a line in file.
   static int remove_breakpoint (const std::string& fname = "", 
-				const intmap& lines = intmap ())
+                                const intmap& lines = intmap ())
   {
     return instance_ok ()
       ? instance->do_remove_breakpoint (fname, lines) : 0;
   }
 
   // Remove all the breakpoints in a specified file.
   static intmap remove_all_breakpoints_in_file (const std::string& fname,
-						bool silent = false)
+                                                bool silent = false)
   {
     return instance_ok ()
       ? instance->do_remove_all_breakpoints_in_file (fname, silent) : intmap ();
   }
   
   // Remove all the breakpoints registered with octave.
   static void remove_all_breakpoints (void)
   {
@@ -127,17 +127,17 @@ private:
 
   static bp_table *instance;
 
   intmap do_add_breakpoint (const std::string& fname, const intmap& lines);
 
   int do_remove_breakpoint (const std::string&, const intmap& lines);
 
   intmap do_remove_all_breakpoints_in_file (const std::string& fname, 
-					    bool silent);
+                                            bool silent);
 
   void do_remove_all_breakpoints (void);
 
   fname_line_map do_get_breakpoint_list (const octave_value_list& fname_list);
 
   bool do_have_breakpoints (void) { return (! bp_set.empty ()); }
 };
 
diff --git a/src/defun-int.h b/src/defun-int.h
--- a/src/defun-int.h
+++ b/src/defun-int.h
@@ -35,27 +35,27 @@ class octave_value;
 
 extern OCTINTERP_API void print_usage (void);
 extern OCTINTERP_API void print_usage (const std::string&);
 
 extern OCTINTERP_API void check_version (const std::string& version, const std::string& fcn);
 
 extern OCTINTERP_API void
 install_builtin_function (octave_builtin::fcn f, const std::string& name,
-			  const std::string& doc,
-			  bool can_hide_function = true);
+                          const std::string& doc,
+                          bool can_hide_function = true);
 
 extern OCTINTERP_API void
 install_dld_function (octave_dld_function::fcn f, const std::string& name,
-		      const octave_shlib& shl, const std::string& doc, 
-		      bool relative = false);
+                      const octave_shlib& shl, const std::string& doc, 
+                      bool relative = false);
 
 extern OCTINTERP_API void
 install_mex_function (void *fptr, bool fmex, const std::string& name,
-		      const octave_shlib& shl, bool relative = false);
+                      const octave_shlib& shl, bool relative = false);
 
 extern OCTINTERP_API void
 alias_builtin (const std::string& alias, const std::string& name);
 
 // Gets the shlib of the currently executing DLD function, if any.
 extern OCTINTERP_API octave_shlib
 get_current_shlib (void);
 
@@ -96,17 +96,17 @@ typedef octave_function * (*octave_dld_f
   gname (const octave_shlib& shl, bool relative) \
   { \
     octave_function *retval = 0; \
  \
     check_version (OCTAVE_API_VERSION, name); \
  \
     if (! error_state) \
       { \
-	octave_dld_function *fcn = octave_dld_function::create (fname, shl, name, doc); \
+        octave_dld_function *fcn = octave_dld_function::create (fname, shl, name, doc); \
  \
         if (relative) \
           fcn->mark_relative (); \
  \
         retval = fcn; \
       } \
  \
     return retval; \
diff --git a/src/dynamic-ld.h b/src/dynamic-ld.h
--- a/src/dynamic-ld.h
+++ b/src/dynamic-ld.h
@@ -38,23 +38,23 @@ protected:
   octave_dynamic_loader (void) { }
 
 public:
 
   virtual ~octave_dynamic_loader (void) { }
 
   static octave_function *
   load_oct (const std::string& fcn_name,
-	     const std::string& file_name = std::string (),
-	     bool relative = false);
+             const std::string& file_name = std::string (),
+             bool relative = false);
 
   static octave_function *
   load_mex (const std::string& fcn_name,
-	     const std::string& file_name = std::string (),
-	     bool relative = false);
+             const std::string& file_name = std::string (),
+             bool relative = false);
 
   static bool remove_oct (const std::string& fcn_name, octave_shlib& shl);
 
   static bool remove_mex (const std::string& fcn_name, octave_shlib& shl);
 
 private:
 
   // No copying!
@@ -64,23 +64,23 @@ private:
   octave_dynamic_loader& operator = (const octave_dynamic_loader&);
 
   static octave_dynamic_loader *instance;
 
   static bool instance_ok (void);
 
   octave_function *
   do_load_oct (const std::string& fcn_name,
-		const std::string& file_name = std::string (),
-		bool relative = false);
+                const std::string& file_name = std::string (),
+                bool relative = false);
 
   octave_function *
   do_load_mex (const std::string& fcn_name,
-		const std::string& file_name = std::string (),
-		bool relative = false);
+                const std::string& file_name = std::string (),
+                bool relative = false);
 
   bool do_remove_oct (const std::string& fcn_name, octave_shlib& shl);
 
   bool do_remove_mex (const std::string& fcn_name, octave_shlib& shl);
 
   static bool doing_load;
 
 protected:
diff --git a/src/error.h b/src/error.h
--- a/src/error.h
+++ b/src/error.h
@@ -24,17 +24,17 @@ along with Octave; see the file COPYING.
 #if !defined (octave_error_h)
 #define octave_error_h 1
 
 #include <cstdarg>
 #include <string>
 
 #define panic_impossible() \
   panic ("impossible state reached in file `%s' at line %d", \
-	 __FILE__, __LINE__)
+         __FILE__, __LINE__)
 
 extern OCTINTERP_API void reset_error_handler (void);
 
 extern OCTINTERP_API int warning_enabled (const std::string& id);
 
 extern OCTINTERP_API void vmessage (const char *name, const char *fmt, va_list args);
 extern OCTINTERP_API void message (const char *name, const char *fmt, ...);
 
diff --git a/src/gl-render.h b/src/gl-render.h
--- a/src/gl-render.h
+++ b/src/gl-render.h
@@ -60,22 +60,22 @@ public:
 
   virtual void draw (const graphics_object& go);
 
   virtual void draw (const Matrix& hlist)
     {
       int len = hlist.length ();
 
       for (int i = len-1; i >= 0; i--)
-	{
-	  graphics_handle h = gh_manager::lookup (hlist(i));
+        {
+          graphics_handle h = gh_manager::lookup (hlist(i));
 
-	  if (h.ok ())
-	    draw (h);
-	}
+          if (h.ok ())
+            draw (h);
+        }
     }
 
   virtual void set_viewport (int w, int h);
 
 protected:
   virtual void draw_figure (const figure::properties& props);
   virtual void draw_axes (const axes::properties& props);
   virtual void draw_line (const line::properties& props);
@@ -85,63 +85,63 @@ protected:
   virtual void draw_text (const text::properties& props);
   virtual void draw_image (const image::properties& props);
 
   virtual void set_color (const Matrix& c);
   virtual void set_polygon_offset (bool on, double offset = 0.0);
   virtual void set_linewidth (float w);
   virtual void set_linestyle (const std::string& s, bool stipple = false);
   virtual void set_clipbox (double x1, double x2, double y1, double y2,
-			    double z1, double z2);
+                            double z1, double z2);
   virtual void set_clipping (bool on);
   virtual void set_font (const base_properties& props);
 
   virtual void init_marker (const std::string& m, double size, float width);
   virtual void end_marker (void);
   virtual void draw_marker (double x, double y, double z,
-			    const Matrix& lc, const Matrix& fc);
+                            const Matrix& lc, const Matrix& fc);
 
   virtual void text_to_pixels (const std::string& txt,
-			       double rotation,
-			       uint8NDArray& pixels,
-			       Matrix& bbox,
-			       int& rot_mode);
+                               double rotation,
+                               uint8NDArray& pixels,
+                               Matrix& bbox,
+                               int& rot_mode);
 
   virtual Matrix render_text (const std::string& txt,
-			      double x, double y, double z,
-			      int halign, int valign, double rotation = 0.0);
+                              double x, double y, double z,
+                              int halign, int valign, double rotation = 0.0);
 
   virtual void draw_pixels (GLsizei w, GLsizei h, GLenum format, 
-			    GLenum type, const GLvoid *data);
+                            GLenum type, const GLvoid *data);
 
 private:
   opengl_renderer (const opengl_renderer&) { }
 
   opengl_renderer& operator = (const opengl_renderer&)
     { return *this; }
 
   bool is_nan_or_inf (double x, double y, double z) const
     {
       return (xisnan (x) || xisnan (y) || xisnan (z)
-	      || xisinf (x) || xisinf (y) || xisinf (z));
+              || xisinf (x) || xisinf (y) || xisinf (z));
     }
 
   octave_uint8 clip_code (double x, double y, double z) const
     {
       return ((x < xmin ? 1 : 0)
-	      | (x > xmax ? 1 : 0) << 1
-	      | (y < ymin ? 1 : 0) << 2
-	      | (y > ymax ? 1 : 0) << 3
-	      | (z < zmin ? 1 : 0) << 4
-	      | (z > zmax ? 1 : 0) << 5
-	      | (is_nan_or_inf (x, y, z) ? 0 : 1) << 6);
+              | (x > xmax ? 1 : 0) << 1
+              | (y < ymin ? 1 : 0) << 2
+              | (y > ymax ? 1 : 0) << 3
+              | (z < zmin ? 1 : 0) << 4
+              | (z > zmax ? 1 : 0) << 5
+              | (is_nan_or_inf (x, y, z) ? 0 : 1) << 6);
     }
 
   unsigned int make_marker_list (const std::string& m, double size,
-				 bool filled) const;
+                                 bool filled) const;
 
 private:
   // the backend associated with the figure being rendered
   graphics_backend backend;
 
   // axes transformation data
   graphics_xform xform;
 
diff --git a/src/gl2ps-renderer.h b/src/gl2ps-renderer.h
--- a/src/gl2ps-renderer.h
+++ b/src/gl2ps-renderer.h
@@ -36,24 +36,24 @@ public:
 
   ~glps_renderer (void) { }
 
   virtual void draw (const graphics_object& go);
 
 protected:
 
   virtual Matrix render_text (const std::string& txt,
-			      double x, double y, double z,
-			      int halign, int valign, double rotation = 0.0);
+                              double x, double y, double z,
+                              int halign, int valign, double rotation = 0.0);
 
 
   virtual void set_font (const base_properties& props);
 
   virtual void draw_pixels (GLsizei w, GLsizei h, GLenum format, 
-			    GLenum type, const GLvoid *data);
+                            GLenum type, const GLvoid *data);
 
   virtual void set_linestyle (const std::string& s, bool use_stipple)
   {
     opengl_renderer::set_linestyle (s, use_stipple);
     if (use_stipple)
       gl2psEnable (GL2PS_LINE_STIPPLE);
     else
       gl2psDisable (GL2PS_LINE_STIPPLE);
diff --git a/src/gripes.h b/src/gripes.h
--- a/src/gripes.h
+++ b/src/gripes.h
@@ -73,42 +73,42 @@ gripe_unrecognized_float_fmt (void);
 extern OCTINTERP_API void
 gripe_unrecognized_data_fmt (const char *warn_for);
 
 extern OCTINTERP_API void
 gripe_data_conversion (const char *from, const char *to);
 
 extern OCTINTERP_API void
 gripe_wrong_type_arg (const char *name, const char *s,
-		      bool is_error = true);
+                      bool is_error = true);
 
 extern OCTINTERP_API void
 gripe_wrong_type_arg (const char *name, const std::string& s,
-		      bool is_error = true);
+                      bool is_error = true);
 
 extern OCTINTERP_API void
 gripe_wrong_type_arg (const char *name, const octave_value& tc,
-		      bool is_error = true);
+                      bool is_error = true);
 
 extern OCTINTERP_API void
 gripe_wrong_type_arg (const std::string& name, const octave_value& tc,
-		      bool is_error = true);
+                      bool is_error = true);
 
 extern OCTINTERP_API void
 gripe_wrong_type_arg_for_unary_op (const octave_value& op);
 
 extern OCTINTERP_API void
 gripe_wrong_type_arg_for_binary_op (const octave_value& op);
 
 extern OCTINTERP_API void
 gripe_implicit_conversion (const char *id, const char *from, const char *to);
 
 extern OCTINTERP_API void
 gripe_implicit_conversion (const std::string& id, const std::string& from,
-			   const std::string& to);
+                           const std::string& to);
 
 extern OCTINTERP_API void
 gripe_truncated_conversion (const char *srctype, const char *desttype);
 
 extern OCTINTERP_API void
 gripe_binop_integer_math_truncated (const char *op, const char *type1, const char *type2);
 
 extern OCTINTERP_API void
diff --git a/src/load-path.h b/src/load-path.h
--- a/src/load-path.h
+++ b/src/load-path.h
@@ -83,25 +83,25 @@ public:
 
   static void update (void)
   {
     if (instance_ok ())
       instance->do_update ();
   }
 
   static std::string find_method (const std::string& class_name,
-				  const std::string& meth,
-				  std::string& dir_name)
+                                  const std::string& meth,
+                                  std::string& dir_name)
   {
     return instance_ok ()
       ? instance->do_find_method (class_name, meth, dir_name) : std::string ();
   }
 
   static std::string find_method (const std::string& class_name,
-				  const std::string& meth)
+                                  const std::string& meth)
   {
     std::string dir_name;
     return find_method (class_name, meth, dir_name);
   }
 
   static std::list<std::string> methods (const std::string& class_name)
   {
     return instance_ok ()
@@ -122,17 +122,17 @@ public:
 
   static std::string find_fcn (const std::string& fcn)
   {
     std::string dir_name;
     return find_fcn (fcn, dir_name);
   }
 
   static std::string find_private_fcn (const std::string& dir,
-				       const std::string& fcn)
+                                       const std::string& fcn)
   {
     return instance_ok ()
       ? instance->do_find_private_fcn (dir, fcn) : std::string ();
   }
 
   static std::string find_fcn_file (const std::string& fcn)
   {
     std::string dir_name;
@@ -274,39 +274,39 @@ private:
     // std::map of dir_info objects.  You should not use this
     // constructor for any other purpose.
     dir_info (void) { }
 
     dir_info (const std::string& d) : dir_name (d) { initialize (); }
 
     dir_info (const dir_info& di)
       : dir_name (di.dir_name), abs_dir_name (di.abs_dir_name),
-	is_relative (di.is_relative),
-	dir_mtime (di.dir_mtime),
-	dir_time_last_checked (di.dir_time_last_checked), 
-	all_files (di.all_files), fcn_files (di.fcn_files),
-	private_file_map (di.private_file_map),
-	method_file_map (di.method_file_map) { }
+        is_relative (di.is_relative),
+        dir_mtime (di.dir_mtime),
+        dir_time_last_checked (di.dir_time_last_checked), 
+        all_files (di.all_files), fcn_files (di.fcn_files),
+        private_file_map (di.private_file_map),
+        method_file_map (di.method_file_map) { }
 
     ~dir_info (void) { }
 
     dir_info& operator = (const dir_info& di)
     {
       if (&di != this)
-	{
-	  dir_name = di.dir_name;
-	  abs_dir_name = di.abs_dir_name;
-	  is_relative = di.is_relative;
-	  dir_mtime = di.dir_mtime;
-	  dir_time_last_checked = di.dir_time_last_checked;
-	  all_files = di.all_files;
-	  fcn_files = di.fcn_files;
-	  private_file_map = di.private_file_map;
-	  method_file_map = di.method_file_map;
-	}
+        {
+          dir_name = di.dir_name;
+          abs_dir_name = di.abs_dir_name;
+          is_relative = di.is_relative;
+          dir_mtime = di.dir_mtime;
+          dir_time_last_checked = di.dir_time_last_checked;
+          all_files = di.all_files;
+          fcn_files = di.fcn_files;
+          private_file_map = di.private_file_map;
+          method_file_map = di.method_file_map;
+        }
 
       return *this;
     }
 
     void update (void);
 
     std::string dir_name;
     std::string abs_dir_name;
@@ -322,17 +322,17 @@ private:
 
     void initialize (void);
 
     void get_file_list (const std::string& d);
 
     void get_private_file_map (const std::string& d);
 
     void get_method_file_map (const std::string& d,
-			      const std::string& class_name);
+                              const std::string& class_name);
 
     friend fcn_file_map_type get_fcn_files (const std::string& d);
   };
 
   class file_info
   {
   public:
 
@@ -341,20 +341,20 @@ private:
     file_info (const file_info& fi)
       : dir_name (fi.dir_name), types (fi.types) { }
 
     ~file_info (void) { }
 
     file_info& operator = (const file_info& fi)
     {
       if (&fi != this)
-	{
-	  dir_name = fi.dir_name;
-	  types = fi.types;
-	}
+        {
+          dir_name = fi.dir_name;
+          types = fi.types;
+        }
 
       return *this;
     }
 
     std::string dir_name;
     int types;
   };
 
@@ -427,17 +427,17 @@ private:
   static bool instance_ok (void);
 
   const_dir_info_list_iterator find_dir_info (const std::string& dir) const;
   dir_info_list_iterator find_dir_info (const std::string& dir);
 
   bool contains (const std::string& dir) const;
 
   void move_fcn_map (const std::string& dir,
-		     const string_vector& fcn_files, bool at_end);
+                     const string_vector& fcn_files, bool at_end);
 
   void move_method_map (const std::string& dir, bool at_end);
 
   void move (std::list<dir_info>::iterator i, bool at_end);
 
   void do_initialize (bool set_initial_path);
 
   void do_clear (void);
@@ -457,30 +457,30 @@ private:
   void remove_method_map (const std::string& dir);
 
   bool do_remove (const std::string& dir);
 
   void do_update (void) const;
 
   static bool
   check_file_type (std::string& fname, int type, int possible_types,
-		   const std::string& fcn, const char *who);
+                   const std::string& fcn, const char *who);
 
   std::string do_find_fcn (const std::string& fcn,
-			   std::string& dir_name,
-			   int type = M_FILE | OCT_FILE | MEX_FILE) const;
+                           std::string& dir_name,
+                           int type = M_FILE | OCT_FILE | MEX_FILE) const;
 
   std::string do_find_private_fcn (const std::string& dir,
-				   const std::string& fcn,
-				   int type = M_FILE | OCT_FILE | MEX_FILE) const;
+                                   const std::string& fcn,
+                                   int type = M_FILE | OCT_FILE | MEX_FILE) const;
 
   std::string do_find_method (const std::string& class_name,
-			      const std::string& meth,
-			      std::string& dir_name,
-			      int type = M_FILE | OCT_FILE | MEX_FILE) const;
+                              const std::string& meth,
+                              std::string& dir_name,
+                              int type = M_FILE | OCT_FILE | MEX_FILE) const;
 
   std::list<std::string> do_methods (const std::string& class_name) const;
 
   bool do_any_class_method (const std::string& meth) const;
 
   std::string do_find_file (const std::string& file) const;
 
   std::string do_find_dir (const std::string& dir) const;
diff --git a/src/load-save.h b/src/load-save.h
--- a/src/load-save.h
+++ b/src/load-save.h
@@ -67,25 +67,25 @@ public:
     { return type; }
   int type, opts;
 };
 
 extern void dump_octave_core (void);
 
 extern int
 read_binary_file_header (std::istream& is, bool& swap,
-			 oct_mach_info::float_format& flt_fmt,
-			 bool quiet = false);
+                         oct_mach_info::float_format& flt_fmt,
+                         bool quiet = false);
 
 extern octave_value
 do_load (std::istream& stream, const std::string& orig_fname, bool force,
-	 load_save_format format, oct_mach_info::float_format flt_fmt,
-	 bool list_only, bool swap, bool verbose,
-	 const string_vector& argv, int argv_idx, int argc, int nargout);
+         load_save_format format, oct_mach_info::float_format flt_fmt,
+         bool list_only, bool swap, bool verbose,
+         const string_vector& argv, int argv_idx, int argc, int nargout);
 
 extern void
 do_save (std::ostream& os, const symbol_table::symbol_record& sr,
-	 load_save_format fmt, bool save_as_floats);
+         load_save_format fmt, bool save_as_floats);
 
 extern void
 write_header (std::ostream& os, load_save_format format);
 
 #endif
diff --git a/src/ls-hdf5.h b/src/ls-hdf5.h
--- a/src/ls-hdf5.h
+++ b/src/ls-hdf5.h
@@ -45,92 +45,92 @@ public:
 
   hdf5_fstreambase () { file_id = -1; }
 
   ~hdf5_fstreambase () { close (); }
 
   hdf5_fstreambase (const char *name, int mode, int /* prot */ = 0)
     {
       if (mode & std::ios::in)
-	file_id = H5Fopen (name, H5F_ACC_RDONLY, H5P_DEFAULT);
+        file_id = H5Fopen (name, H5F_ACC_RDONLY, H5P_DEFAULT);
       else if (mode & std::ios::out)
-	{
-	  if (mode & std::ios::app && H5Fis_hdf5 (name) > 0)
-	    file_id = H5Fopen (name, H5F_ACC_RDWR, H5P_DEFAULT);
-	  else
-	    file_id = H5Fcreate (name, H5F_ACC_TRUNC, H5P_DEFAULT, 
-				 H5P_DEFAULT);
-	}
+        {
+          if (mode & std::ios::app && H5Fis_hdf5 (name) > 0)
+            file_id = H5Fopen (name, H5F_ACC_RDWR, H5P_DEFAULT);
+          else
+            file_id = H5Fcreate (name, H5F_ACC_TRUNC, H5P_DEFAULT, 
+                                 H5P_DEFAULT);
+        }
       if (file_id < 0)
-	std::ios::setstate (std::ios::badbit);
+        std::ios::setstate (std::ios::badbit);
 
       current_item = 0;
     }
 
   void close ()
     { 
       if (file_id >= 0)
-	{
-	  if (H5Fclose (file_id) < 0)
-	    std::ios::setstate (std::ios::badbit);
-	  file_id = -1;
-	}
+        {
+          if (H5Fclose (file_id) < 0)
+            std::ios::setstate (std::ios::badbit);
+          file_id = -1;
+        }
     }
 
   void open (const char *name, int mode, int)
     {
       clear ();
 
       if (mode & std::ios::in)
-	file_id = H5Fopen (name, H5F_ACC_RDONLY, H5P_DEFAULT);
+        file_id = H5Fopen (name, H5F_ACC_RDONLY, H5P_DEFAULT);
       else if (mode & std::ios::out)
-	{
-	  if (mode & std::ios::app && H5Fis_hdf5 (name) > 0)
-	    file_id = H5Fopen (name, H5F_ACC_RDWR, H5P_DEFAULT);
-	  else
-	    file_id = H5Fcreate (name, H5F_ACC_TRUNC, H5P_DEFAULT, 
-				 H5P_DEFAULT);
-	}
+        {
+          if (mode & std::ios::app && H5Fis_hdf5 (name) > 0)
+            file_id = H5Fopen (name, H5F_ACC_RDWR, H5P_DEFAULT);
+          else
+            file_id = H5Fcreate (name, H5F_ACC_TRUNC, H5P_DEFAULT, 
+                                 H5P_DEFAULT);
+        }
       if (file_id < 0)
-	std::ios::setstate (std::ios::badbit);
+        std::ios::setstate (std::ios::badbit);
 
       current_item = 0;
     }
 };
 
 // input and output streams, subclassing istream and ostream
 // so that we can pass them for stream parameters in the functions below.
 
 class hdf5_ifstream : public hdf5_fstreambase, public std::istream
 {
 public:
 
   hdf5_ifstream () : hdf5_fstreambase (), std::istream (0) { }
 
   hdf5_ifstream (const char *name, int mode = std::ios::in|std::ios::binary,
-		 int prot = 0)
+                 int prot = 0)
     : hdf5_fstreambase (name, mode, prot), std::istream (0) { }
 
   void open (const char *name, int mode = std::ios::in|std::ios::binary,
-	     int prot = 0)
+             int prot = 0)
     { hdf5_fstreambase::open (name, mode, prot); }
 };
 
 class hdf5_ofstream : public hdf5_fstreambase, public std::ostream
 {
 public:
 
   hdf5_ofstream () : hdf5_fstreambase (), std::ostream (0) { }
 
   hdf5_ofstream (const char *name, int mode = std::ios::out|std::ios::binary,
-		 int prot = 0)
+                 int prot = 0)
     : hdf5_fstreambase (name, mode, prot), std::ostream (0) { }
 
   void open (const char *name, int mode = std::ios::out|std::ios::binary,
-	     int prot = 0)
+             int prot = 0)
     { hdf5_fstreambase::open (name, mode, prot); }
 };
 
 // Callback data structure for passing data to hdf5_read_next_data, below.
 
 struct
 hdf5_callback_data
 {
@@ -163,33 +163,33 @@ hdf5_make_complex_type (hid_t num_type);
 extern OCTINTERP_API bool
 hdf5_types_compatible (hid_t t1, hid_t t2);
 
 extern OCTINTERP_API herr_t
 hdf5_read_next_data (hid_t group_id, const char *name, void *dv);
 
 extern OCTINTERP_API bool
 add_hdf5_data (hid_t loc_id, const octave_value& tc,
-	       const std::string& name, const std::string& doc,
-	       bool mark_as_global, bool save_as_floats);
+               const std::string& name, const std::string& doc,
+               bool mark_as_global, bool save_as_floats);
 
 extern OCTINTERP_API int
 save_hdf5_empty (hid_t loc_id, const char *name, const dim_vector d);
 
 extern OCTINTERP_API int
 load_hdf5_empty (hid_t loc_id, const char *name, dim_vector &d);
 
 extern OCTINTERP_API std::string
 read_hdf5_data (std::istream& is,  const std::string& filename, bool& global,
-		octave_value& tc, std::string& doc);
+                octave_value& tc, std::string& doc);
 
 extern OCTINTERP_API bool
 save_hdf5_data (std::ostream& os, const octave_value& tc,
-		const std::string& name, const std::string& doc,
-		bool mark_as_global, bool save_as_floats);
+                const std::string& name, const std::string& doc,
+                bool mark_as_global, bool save_as_floats);
 
 #ifdef IDX_TYPE_LONG
 #define H5T_NATIVE_IDX H5T_NATIVE_LONG
 #else
 #define H5T_NATIVE_IDX H5T_NATIVE_INT
 #endif
 
 #endif
diff --git a/src/ls-mat-ascii.h b/src/ls-mat-ascii.h
--- a/src/ls-mat-ascii.h
+++ b/src/ls-mat-ascii.h
@@ -20,15 +20,15 @@ along with Octave; see the file COPYING.
 
 */
 
 #if !defined (octave_ls_mat_ascii_h)
 #define octave_ls_mat_ascii_h 1
 
 extern std::string
 read_mat_ascii_data (std::istream& is, const std::string& filename,
-		     octave_value& tc);
+                     octave_value& tc);
 
 extern bool
 save_mat_ascii_data (std::ostream& os, const octave_value& val_arg,
-		     int precision, bool tabs = false);
+                     int precision, bool tabs = false);
 
 #endif
diff --git a/src/ls-mat4.h b/src/ls-mat4.h
--- a/src/ls-mat4.h
+++ b/src/ls-mat4.h
@@ -26,20 +26,20 @@ along with Octave; see the file COPYING.
 extern oct_mach_info::float_format
 mopt_digit_to_float_format (int mach);
 
 extern int
 float_format_to_mopt_digit (oct_mach_info::float_format flt_fmt);
 
 extern int
 read_mat_file_header (std::istream& is, bool& swap, int32_t& mopt, 
-		      int32_t& nr, int32_t& nc, int32_t& imag,
-		      int32_t& len, int quiet = 0);
+                      int32_t& nr, int32_t& nc, int32_t& imag,
+                      int32_t& len, int quiet = 0);
 
 extern std::string
 read_mat_binary_data (std::istream& is, const std::string& filename,
-		      octave_value& tc);
+                      octave_value& tc);
 
 extern bool
 save_mat_binary_data (std::ostream& os, const octave_value& tc,
-		      const std::string& name) ;
+                      const std::string& name) ;
 
 #endif
diff --git a/src/ls-mat5.h b/src/ls-mat5.h
--- a/src/ls-mat5.h
+++ b/src/ls-mat5.h
@@ -20,42 +20,42 @@ along with Octave; see the file COPYING.
 
 */
 
 #if !defined (octave_ls_mat5_h)
 #define octave_ls_mat5_h 1
 
 enum mat5_data_type
   {
-    miINT8 = 1,			// 8 bit signed
-    miUINT8,			// 8 bit unsigned
-    miINT16,			// 16 bit signed
-    miUINT16,			// 16 bit unsigned
-    miINT32,			// 32 bit signed
-    miUINT32,			// 32 bit unsigned
-    miSINGLE,			// IEEE 754 single precision float
+    miINT8 = 1,                 // 8 bit signed
+    miUINT8,                    // 8 bit unsigned
+    miINT16,                    // 16 bit signed
+    miUINT16,                   // 16 bit unsigned
+    miINT32,                    // 32 bit signed
+    miUINT32,                   // 32 bit unsigned
+    miSINGLE,                   // IEEE 754 single precision float
     miRESERVE1,
-    miDOUBLE,			// IEEE 754 double precision float
+    miDOUBLE,                   // IEEE 754 double precision float
     miRESERVE2,
     miRESERVE3,
-    miINT64,			// 64 bit signed
-    miUINT64,			// 64 bit unsigned
-    miMATRIX,			// MATLAB array
-    miCOMPRESSED,		// Compressed data
-    miUTF8,			// Unicode UTF-8 Encoded Character Data
-    miUTF16,			// Unicode UTF-16 Encoded Character Data
-    miUTF32			// Unicode UTF-32 Encoded Character Data
+    miINT64,                    // 64 bit signed
+    miUINT64,                   // 64 bit unsigned
+    miMATRIX,                   // MATLAB array
+    miCOMPRESSED,               // Compressed data
+    miUTF8,                     // Unicode UTF-8 Encoded Character Data
+    miUTF16,                    // Unicode UTF-16 Encoded Character Data
+    miUTF32                     // Unicode UTF-32 Encoded Character Data
   };
 
 extern int
 read_mat5_binary_file_header (std::istream& is, bool& swap,
-			      bool quiet = false,
-			      const std::string& filename = std::string());
+                              bool quiet = false,
+                              const std::string& filename = std::string());
 extern std::string
 read_mat5_binary_element (std::istream& is, const std::string& filename,
-			  bool swap, bool& global, octave_value& tc);
+                          bool swap, bool& global, octave_value& tc);
 extern bool
 save_mat5_binary_element (std::ostream& os,
-			  const octave_value& tc, const std::string& name,
-			  bool mark_as_global, bool mat7_format,
-			  bool save_as_floats, bool compressing = false);
+                          const octave_value& tc, const std::string& name,
+                          bool mark_as_global, bool mat7_format,
+                          bool save_as_floats, bool compressing = false);
 
 #endif
diff --git a/src/ls-oct-ascii.h b/src/ls-oct-ascii.h
--- a/src/ls-oct-ascii.h
+++ b/src/ls-oct-ascii.h
@@ -38,152 +38,152 @@ along with Octave; see the file COPYING.
 // Used when converting Inf to something that gnuplot can read.
 
 #ifndef OCT_RBV
 #define OCT_RBV DBL_MAX / 100.0
 #endif
 
 extern OCTINTERP_API std::string
 extract_keyword (std::istream& is, const char *keyword, 
-		 const bool next_only = false);
+                 const bool next_only = false);
 
 extern OCTINTERP_API std::string
 read_ascii_data (std::istream& is, const std::string& filename, bool& global,
-		 octave_value& tc, octave_idx_type count);
+                 octave_value& tc, octave_idx_type count);
 
 extern OCTINTERP_API bool
 save_ascii_data (std::ostream& os, const octave_value& val_arg,
-		 const std::string& name, bool mark_as_global, int precision);
+                 const std::string& name, bool mark_as_global, int precision);
 
 extern OCTINTERP_API bool
 save_ascii_data_for_plotting (std::ostream& os, const octave_value& t,
-			      const std::string& name);
+                              const std::string& name);
 
 extern OCTINTERP_API bool
 save_three_d (std::ostream& os, const octave_value& t,
-	      bool parametric = false);
+              bool parametric = false);
 
 // Match KEYWORD on stream IS, placing the associated value in VALUE,
 // returning TRUE if successful and FALSE otherwise.
 //
 // Input should look something like:
 //
 //  [%#][ \t]*keyword[ \t]*int-value.*\n
 
 template <class T>
 bool
 extract_keyword (std::istream& is, const char *keyword, T& value, 
-		 const bool next_only = false)
+                 const bool next_only = false)
 {
   bool status = false;
   value = T();
 
   char c;
   while (is.get (c))
     {
       if (c == '%' || c == '#')
-	{
-	  std::ostringstream buf;
+        {
+          std::ostringstream buf;
 
-	  while (is.get (c) && (c == ' ' || c == '\t' || c == '%' || c == '#'))
-	    ; // Skip whitespace and comment characters.
+          while (is.get (c) && (c == ' ' || c == '\t' || c == '%' || c == '#'))
+            ; // Skip whitespace and comment characters.
 
-	  if (isalpha (c))
-	    buf << c;
+          if (isalpha (c))
+            buf << c;
 
-	  while (is.get (c) && isalpha (c))
-	    buf << c;
+          while (is.get (c) && isalpha (c))
+            buf << c;
 
-	  std::string tmp = buf.str ();
-	  bool match = (tmp.compare (0, strlen (keyword), keyword) == 0);
+          std::string tmp = buf.str ();
+          bool match = (tmp.compare (0, strlen (keyword), keyword) == 0);
 
-	  if (match)
-	    {
-	      while (is.get (c) && (c == ' ' || c == '\t' || c == ':'))
-		; // Skip whitespace and the colon.
+          if (match)
+            {
+              while (is.get (c) && (c == ' ' || c == '\t' || c == ':'))
+                ; // Skip whitespace and the colon.
 
-	      is.putback (c);
-	      if (c != '\n' && c != '\r')
-		is >> value;
-	      if (is)
-		status = true;
-	      skip_until_newline (is, false);
-	      break;
-	    }
-	  else if (next_only)
-	    break;
-	}
+              is.putback (c);
+              if (c != '\n' && c != '\r')
+                is >> value;
+              if (is)
+                status = true;
+              skip_until_newline (is, false);
+              break;
+            }
+          else if (next_only)
+            break;
+        }
     }
   return status;
 }
 
 template <class T>
 bool
 extract_keyword (std::istream& is, const std::string& kw, T& value, 
-		 const bool next_only = false)
+                 const bool next_only = false)
 {
   return extract_keyword (is, kw.c_str (), value, next_only);
 }
 
 // Match one of the elements in KEYWORDS on stream IS, placing the
 // matched keyword in KW and the associated value in VALUE,
 // returning TRUE if successful and FALSE otherwise.
 //
 // Input should look something like:
 //
 //  [%#][ \t]*keyword[ \t]*int-value.*\n
 
 template <class T>
 bool
 extract_keyword (std::istream& is, const string_vector& keywords,
-		 std::string& kw, T& value, const bool next_only = false)
+                 std::string& kw, T& value, const bool next_only = false)
 {
   bool status = false;
   kw = "";
   value = 0;
 
   char c;
   while (is.get (c))
     {
       if (c == '%' || c == '#')
-	{
-	  std::ostringstream buf;
+        {
+          std::ostringstream buf;
 
-	  while (is.get (c) && (c == ' ' || c == '\t' || c == '%' || c == '#'))
-	    ; // Skip whitespace and comment characters.
+          while (is.get (c) && (c == ' ' || c == '\t' || c == '%' || c == '#'))
+            ; // Skip whitespace and comment characters.
 
-	  if (isalpha (c))
-	    buf << c;
+          if (isalpha (c))
+            buf << c;
 
-	  while (is.get (c) && isalpha (c))
-	    buf << c;
+          while (is.get (c) && isalpha (c))
+            buf << c;
 
-	  std::string tmp = buf.str ();
+          std::string tmp = buf.str ();
 
-	  for (int i = 0; i < keywords.length (); i++)
-	    {
-	      int match = (tmp == keywords[i]);
+          for (int i = 0; i < keywords.length (); i++)
+            {
+              int match = (tmp == keywords[i]);
 
-	      if (match)
-		{
-		  kw = keywords[i];
+              if (match)
+                {
+                  kw = keywords[i];
 
-		  while (is.get (c) && (c == ' ' || c == '\t' || c == ':'))
-		    ; // Skip whitespace and the colon.
+                  while (is.get (c) && (c == ' ' || c == '\t' || c == ':'))
+                    ; // Skip whitespace and the colon.
 
-		  is.putback (c);
-		  if (c != '\n' && c != '\r')
-		    is >> value;
-		  if (is)
-		    status = true;
-		  skip_until_newline (is, false);
-		  return status;
-		}
-	    }
+                  is.putback (c);
+                  if (c != '\n' && c != '\r')
+                    is >> value;
+                  if (is)
+                    status = true;
+                  skip_until_newline (is, false);
+                  return status;
+                }
+            }
 
-	  if (next_only)
-	    break;
-	}
+          if (next_only)
+            break;
+        }
     }
   return status;
 }
 
 #endif
diff --git a/src/ls-oct-binary.h b/src/ls-oct-binary.h
--- a/src/ls-oct-binary.h
+++ b/src/ls-oct-binary.h
@@ -20,18 +20,18 @@ along with Octave; see the file COPYING.
 
 */
 
 #if !defined (octave_ls_oct_binary_h)
 #define octave_ls_oct_binary_h 1
 
 extern OCTINTERP_API bool
 save_binary_data (std::ostream& os, const octave_value& tc,
-		  const std::string& name, const std::string& doc,
-		  bool mark_as_global, bool save_as_floats);
+                  const std::string& name, const std::string& doc,
+                  bool mark_as_global, bool save_as_floats);
 
 extern OCTINTERP_API std::string
 read_binary_data (std::istream& is, bool swap,
-		  oct_mach_info::float_format fmt,
-		  const std::string& filename, bool& global,
-		  octave_value& tc, std::string& doc);
+                  oct_mach_info::float_format fmt,
+                  const std::string& filename, bool& global,
+                  octave_value& tc, std::string& doc);
 
 #endif
diff --git a/src/oct-fstrm.h b/src/oct-fstrm.h
--- a/src/oct-fstrm.h
+++ b/src/oct-fstrm.h
@@ -30,25 +30,25 @@ along with Octave; see the file COPYING.
 #include "oct-stream.h"
 
 class
 octave_fstream : public octave_base_stream
 {
 public:
 
   octave_fstream (const std::string& nm_arg,
-		  std::ios::openmode arg_md = std::ios::in|std::ios::out,
-		  oct_mach_info::float_format flt_fmt
-		    = oct_mach_info::native_float_format ());
+                  std::ios::openmode arg_md = std::ios::in|std::ios::out,
+                  oct_mach_info::float_format flt_fmt
+                    = oct_mach_info::native_float_format ());
 
   static octave_stream
   create (const std::string& nm_arg,
-	  std::ios::openmode arg_md = std::ios::in|std::ios::out,
-	  oct_mach_info::float_format flt_fmt
-	    = oct_mach_info::native_float_format ());
+          std::ios::openmode arg_md = std::ios::in|std::ios::out,
+          oct_mach_info::float_format flt_fmt
+            = oct_mach_info::native_float_format ());
 
   // Position a stream at OFFSET relative to ORIGIN.
 
   int seek (long offset, int origin);
 
   // Return current stream position.
 
   long tell (void);
diff --git a/src/oct-iostrm.h b/src/oct-iostrm.h
--- a/src/oct-iostrm.h
+++ b/src/oct-iostrm.h
@@ -29,19 +29,19 @@ along with Octave; see the file COPYING.
 #include "oct-stream.h"
 
 class
 octave_base_iostream : public octave_base_stream
 {
 public:
 
   octave_base_iostream (const std::string& n = std::string (),
-			std::ios::openmode m = std::ios::in|std::ios::out,
-			oct_mach_info::float_format ff
-			  = oct_mach_info::native_float_format ())
+                        std::ios::openmode m = std::ios::in|std::ios::out,
+                        oct_mach_info::float_format ff
+                          = oct_mach_info::native_float_format ())
     : octave_base_stream (m, ff), nm (n) { }
 
   // Position a stream at OFFSET relative to ORIGIN.
 
   int seek (long offset, int origin);
 
   // Return current stream position.
 
@@ -76,17 +76,17 @@ private:
 
 class
 octave_istream : public octave_base_iostream
 {
 public:
 
   octave_istream (std::istream *arg = 0, const std::string& n = std::string ())
     : octave_base_iostream (n, std::ios::in,
-			    oct_mach_info::native_float_format ()),
+                            oct_mach_info::native_float_format ()),
       is (arg)
   { }
 
   static octave_stream
   create (std::istream *arg = 0, const std::string& n = std::string ());
 
   // Return non-zero if EOF has been reached on this stream.
 
@@ -115,17 +115,17 @@ private:
 
 class
 octave_ostream : public octave_base_iostream
 {
 public:
 
   octave_ostream (std::ostream *arg, const std::string& n = std::string ())
     : octave_base_iostream (n, std::ios::out,
-			    oct_mach_info::native_float_format ()),
+                            oct_mach_info::native_float_format ()),
       os (arg)
   { }
 
   static octave_stream
   create (std::ostream *arg, const std::string& n = std::string ());
 
   // Return non-zero if EOF has been reached on this stream.
 
diff --git a/src/oct-lvalue.h b/src/oct-lvalue.h
--- a/src/oct-lvalue.h
+++ b/src/oct-lvalue.h
@@ -44,22 +44,22 @@ public:
   octave_lvalue (const octave_lvalue& vr)
     : val (vr.val), type (vr.type), idx (vr.idx), nel (vr.nel) 
     { 
     }
 
   octave_lvalue& operator = (const octave_lvalue& vr)
     {
       if (this != &vr)
-	{
-	  val = vr.val;
-	  type = vr.type;
-	  idx = vr.idx;
-	  nel = vr.nel;
-	}
+        {
+          val = vr.val;
+          type = vr.type;
+          idx = vr.idx;
+          nel = vr.nel;
+        }
 
       return *this;
     }
 
   ~octave_lvalue (void) { }
 
   bool is_black_hole (void) const { return val == 0; }
 
diff --git a/src/oct-map.h b/src/oct-map.h
--- a/src/oct-map.h
+++ b/src/oct-map.h
@@ -42,33 +42,33 @@ Octave_map
   typedef std::map<std::string, Cell>::const_iterator const_iterator;
 
   typedef std::list<std::string>::iterator key_list_iterator;
   typedef std::list<std::string>::const_iterator const_key_list_iterator;
 
   // Warning!  You should always use at least two dimensions.
 
   Octave_map (const dim_vector& dv = dim_vector (0, 0),
-	      const Cell& key_vals = Cell ());
+              const Cell& key_vals = Cell ());
 
   Octave_map (const std::string& k, const octave_value& value)
     : map (), key_list (), dimensions (1, 1)
   {
     map[k] = value;
     key_list.push_back (k);
   }
 
   Octave_map (const string_vector& sv)
     : map (), key_list (), dimensions (0, 0)
   {
     for (octave_idx_type i = 0; i < sv.length (); i++)
       {
-	std::string k = sv[i];
-	map[k] = Cell ();
-	key_list.push_back (k);
+        std::string k = sv[i];
+        map[k] = Cell ();
+        key_list.push_back (k);
       }
   }
 
   Octave_map (const std::string& k, const Cell& vals)
     : map (), key_list (), dimensions (vals.dims ())
   {
     map[k] = vals;
     key_list.push_back (k);
@@ -82,21 +82,21 @@ Octave_map
   }
 
   Octave_map (const Octave_map& m)
     : map (m.map), key_list (m.key_list), dimensions (m.dimensions) { }
 
   Octave_map& operator = (const Octave_map& m)
     {
       if (this != &m)
-	{
-	  map = m.map;
-	  key_list = m.key_list;
-	  dimensions = m.dimensions;
-	}
+        {
+          map = m.map;
+          key_list = m.key_list;
+          dimensions = m.dimensions;
+        }
 
       return *this;
     }
 
   ~Octave_map (void) { }
 
   Octave_map squeeze (void) const; 
 
@@ -105,26 +105,26 @@ Octave_map
   // This is the number of keys.
   octave_idx_type nfields (void) const { return map.size (); }
 
   void del (const std::string& k)
     {
       iterator p = map.find (k);
 
       if (p != map.end ())
-	{
-	  map.erase (p);
+        {
+          map.erase (p);
 
-	  key_list_iterator q
-	    = std::find (key_list.begin (), key_list.end (), k);
+          key_list_iterator q
+            = std::find (key_list.begin (), key_list.end (), k);
 
-	  assert (q != key_list.end ());
+          assert (q != key_list.end ());
 
-	  key_list.erase (q);
-	}
+          key_list.erase (q);
+        }
     }
 
   iterator begin (void) { return iterator (map.begin ()); }
   const_iterator begin (void) const { return const_iterator (map.begin ()); }
 
   iterator end (void) { return iterator (map.end ()); }
   const_iterator end (void) const { return const_iterator (map.end ()); }
 
@@ -137,17 +137,17 @@ Octave_map
     { return p->second; }
 
   Cell contents (const_iterator p) const
     { return p->second; }
 
   int intfield (const std::string& k, int def_val = 0) const;
 
   std::string stringfield (const std::string& k,
-			   const std::string& def_val = std::string ()) const;
+                           const std::string& def_val = std::string ()) const;
 
   iterator seek (const std::string& k) { return map.find (k); }
   const_iterator seek (const std::string& k) const { return map.find (k); }
 
   bool contains (const std::string& k) const
     { return (seek (k) != map.end ()); }
 
   void clear (void)
@@ -176,37 +176,37 @@ Octave_map
 
   Octave_map concat (const Octave_map& rb, const Array<octave_idx_type>& ra_idx);
 
   Octave_map& maybe_delete_elements (const octave_value_list& idx);
 
   Octave_map& assign (const octave_value_list& idx, const Octave_map& rhs);
 
   Octave_map& assign (const octave_value_list& idx, const std::string& k,
-		      const Cell& rhs);
+                      const Cell& rhs);
 
   Octave_map& assign (const std::string& k, const octave_value& rhs);
 
   Octave_map& assign (const std::string& k, const Cell& rhs);
 
   Octave_map index (const octave_value_list& idx, 
-		    bool resize_ok = false) const;
+                    bool resize_ok = false) const;
 
 private:
 
   // The map of names to values.
   std::map<std::string, Cell> map;
 
   // An extra list of keys, so we can keep track of the order the keys
   // are added for compatibility with you know what.
   std::list<std::string> key_list;
 
   // The current size.
   mutable dim_vector dimensions;
 
   void maybe_add_to_key_list (const std::string& k)
     {
       if (! contains (k))
-	key_list.push_back (k);
+        key_list.push_back (k);
     }
 };
 
 #endif
diff --git a/src/oct-obj.h b/src/oct-obj.h
--- a/src/oct-obj.h
+++ b/src/oct-obj.h
@@ -85,20 +85,20 @@ public:
 #else
       ::operator delete (p);
 #endif
     }
 
   octave_value_list& operator = (const octave_value_list& obj)
     {
       if (this != &obj)
-	{
-	  data = obj.data;
-	  names = obj.names;
-	}
+        {
+          data = obj.data;
+          names = obj.names;
+        }
 
       return *this;
     }
 
   Array<octave_value> array_value (void) const { return data; }
 
   Cell cell_value (void) const { return array_value (); }
 
@@ -126,17 +126,17 @@ public:
   octave_value_list& reverse (void);
 
   octave_value_list
   slice (octave_idx_type offset, octave_idx_type len) const
     { return data.index (idx_vector (offset, offset + len)); }
 
   octave_value_list
   splice (octave_idx_type offset, octave_idx_type len,
-	  const octave_value_list& lst = octave_value_list ()) const;
+          const octave_value_list& lst = octave_value_list ()) const;
 
   bool all_strings_p (void) const;
 
   bool all_scalars (void) const;
 
   bool any_cell (void) const;
 
   bool has_magic_colon (void) const;
@@ -167,17 +167,17 @@ private:
 
   // This list of strings can be used to tag each element of data with
   // a name.  By default, it is empty.
   string_vector names;
 
   octave_value& elem (octave_idx_type n)
     {
       if (n >= length ())
-	resize (n + 1);
+        resize (n + 1);
 
       return data(n);
     }
 
   const octave_value& elem (octave_idx_type n) const
     { return data(n); }
 };
 
diff --git a/src/oct-prcstrm.h b/src/oct-prcstrm.h
--- a/src/oct-prcstrm.h
+++ b/src/oct-prcstrm.h
@@ -30,24 +30,24 @@ along with Octave; see the file COPYING.
 // oprocstream, which in turn use the octave_procbuf class?
 
 class
 octave_iprocstream : public octave_stdiostream
 {
 public:
 
   octave_iprocstream (const std::string& n,
-		      std::ios::openmode arg_md = std::ios::in,
-		      oct_mach_info::float_format flt_fmt
-		        = oct_mach_info::native_float_format ());
+                      std::ios::openmode arg_md = std::ios::in,
+                      oct_mach_info::float_format flt_fmt
+                        = oct_mach_info::native_float_format ());
 
   static octave_stream
   create (const std::string& n, std::ios::openmode arg_md = std::ios::in,
-	  oct_mach_info::float_format flt_fmt
-	    = oct_mach_info::native_float_format ());
+          oct_mach_info::float_format flt_fmt
+            = oct_mach_info::native_float_format ());
 
 protected:
 
   ~octave_iprocstream (void);
 
 private:
 
   // No copying!
@@ -58,24 +58,24 @@ private:
 };
 
 class
 octave_oprocstream : public octave_stdiostream
 {
 public:
 
   octave_oprocstream (const std::string& n,
-		      std::ios::openmode arg_md = std::ios::out,
-		      oct_mach_info::float_format flt_fmt
-		        = oct_mach_info::native_float_format ());
+                      std::ios::openmode arg_md = std::ios::out,
+                      oct_mach_info::float_format flt_fmt
+                        = oct_mach_info::native_float_format ());
 
   static octave_stream
   create (const std::string& n, std::ios::openmode arg_md = std::ios::out,
-	  oct_mach_info::float_format flt_fmt
-	    = oct_mach_info::native_float_format ());
+          oct_mach_info::float_format flt_fmt
+            = oct_mach_info::native_float_format ());
 
 protected:
 
   ~octave_oprocstream (void);
 
 private:
 
   // No copying!
diff --git a/src/oct-stdstrm.h b/src/oct-stdstrm.h
--- a/src/oct-stdstrm.h
+++ b/src/oct-stdstrm.h
@@ -29,30 +29,30 @@ along with Octave; see the file COPYING.
 
 template <typename BUF_T, typename STREAM_T, typename FILE_T>
 class
 octave_tstdiostream : public octave_base_stream
 {
 public:
 
   octave_tstdiostream (const std::string& n, FILE_T f = 0,
-		       std::ios::openmode m = std::ios::in|std::ios::out,
-		       oct_mach_info::float_format ff
-		         = oct_mach_info::native_float_format (),
-		       typename BUF_T::close_fcn cf = BUF_T::file_close)
+                       std::ios::openmode m = std::ios::in|std::ios::out,
+                       oct_mach_info::float_format ff
+                         = oct_mach_info::native_float_format (),
+                       typename BUF_T::close_fcn cf = BUF_T::file_close)
     : octave_base_stream (m, ff), nm (n), md (m),
       s (f ? new STREAM_T (f, cf) : 0)
   { }
 
   static octave_stream
   create (const std::string& n, FILE_T f = 0,
-	  std::ios::openmode m = std::ios::in|std::ios::out,
-	  oct_mach_info::float_format ff
-	    = oct_mach_info::native_float_format (),
-	  typename BUF_T::close_fcn cf = BUF_T::file_close)
+          std::ios::openmode m = std::ios::in|std::ios::out,
+          oct_mach_info::float_format ff
+            = oct_mach_info::native_float_format (),
+          typename BUF_T::close_fcn cf = BUF_T::file_close)
   {
     return octave_stream (new octave_tstdiostream (n, f, m, ff, cf));
   }
 
   // Position a stream at OFFSET relative to ORIGIN.
 
   int seek (long offset, int origin)
     { return s ? s->seek (offset, origin) : -1; }
diff --git a/src/oct-stream.h b/src/oct-stream.h
--- a/src/oct-stream.h
+++ b/src/oct-stream.h
@@ -47,36 +47,36 @@ public:
 
   enum special_conversion
     {
       whitespace_conversion = 1,
       literal_conversion = 2
     };
 
   scanf_format_elt (const char *txt = 0, int w = 0, bool d = false,
-		    char typ = '\0', char mod = '\0',
-		    const std::string& ch_class = std::string ())
+                    char typ = '\0', char mod = '\0',
+                    const std::string& ch_class = std::string ())
     : text (strsave (txt)), width (w), discard (d), type (typ),
       modifier (mod), char_class (ch_class) { }
 
   scanf_format_elt (const scanf_format_elt& e)
     : text (strsave (e.text)), width (e.width), discard (e.discard),
       type (e.type), modifier (e.modifier), char_class (e.char_class) { }
 
   scanf_format_elt& operator = (const scanf_format_elt& e)
     {
       if (this != &e)
-	{
-	  text = strsave (e.text);
-	  width = e.width;
-	  discard = e.discard;
-	  type = e.type;
-	  modifier = e.modifier;
-	  char_class = e.char_class;
-	}
+        {
+          text = strsave (e.text);
+          width = e.width;
+          discard = e.discard;
+          type = e.type;
+          modifier = e.modifier;
+          char_class = e.char_class;
+        }
 
       return *this;
     }
 
   ~scanf_format_elt (void) { delete [] text; }
 
   // The C-style format string.
   const char *text;
@@ -126,22 +126,22 @@ public:
   const scanf_format_elt *current (void) const
     { return list.length () > 0 ? list.elem (curr_idx) : 0; }
 
   const scanf_format_elt *next (bool cycle = true)
     {
       curr_idx++;
 
       if (curr_idx >= list.length ())
-	{
-	  if (cycle)
-	    curr_idx = 0;
-	  else
-	    return 0;
-	}
+        {
+          if (cycle)
+            curr_idx = 0;
+          else
+            return 0;
+        }
       return current ();
     }
 
   void printme (void) const;
 
   bool ok (void) const { return (nconv >= 0); }
 
   operator bool () const { return ok (); }
@@ -161,18 +161,18 @@ private:
 
   // List of format elements.
   Array<scanf_format_elt*> list;
 
   // Temporary buffer.
   std::ostringstream *buf;
 
   void add_elt_to_list (int width, bool discard, char type, char modifier,
-			octave_idx_type& num_elts,
-			const std::string& char_class = std::string ()); 
+                        octave_idx_type& num_elts,
+                        const std::string& char_class = std::string ()); 
 
   void process_conversion (const std::string& s, size_t& i, size_t n,
                            int& width, bool& discard, char& type,
                            char& modifier, octave_idx_type& num_elts);
 
   int finish_conversion (const std::string& s, size_t& i, size_t n,
                          int& width, bool discard, char& type,
                          char modifier, octave_idx_type& num_elts);
@@ -184,37 +184,37 @@ private:
 };
 
 class
 printf_format_elt
 {
 public:
 
   printf_format_elt (const char *txt = 0, int n = 0, int w = 0,
-		     int p = 0, const std::string& f = std::string (),
-		     char typ = '\0', char mod = '\0')
+                     int p = 0, const std::string& f = std::string (),
+                     char typ = '\0', char mod = '\0')
     : text (strsave (txt)), args (n), fw (w), prec (p), flags (f),
       type (typ), modifier (mod) { }
 
   printf_format_elt (const printf_format_elt& e)
     : text (strsave (e.text)), args (e.args), fw (e.fw), prec (e.prec),
       flags (e.flags), type (e.type), modifier (e.modifier) { }
 
   printf_format_elt& operator = (const printf_format_elt& e)
     {
       if (this != &e)
-	{
-	  text = strsave (e.text);
-	  args = e.args;
-	  fw = e.fw;
-	  prec = e.prec;
-	  flags = e.flags;
-	  type = e.type;
-	  modifier = e.modifier;
-	}
+        {
+          text = strsave (e.text);
+          args = e.args;
+          fw = e.fw;
+          prec = e.prec;
+          flags = e.flags;
+          type = e.type;
+          modifier = e.modifier;
+        }
 
       return *this;
     }
 
   ~printf_format_elt (void) { delete [] text; }
  
   // The C-style format string.
   const char *text;
@@ -260,22 +260,22 @@ public:
   const printf_format_elt *current (void) const
     { return list.length () > 0 ? list.elem (curr_idx) : 0; }
 
   const printf_format_elt *next (bool cycle = true)
     {
       curr_idx++;
 
       if (curr_idx >= list.length ())
-	{
-	  if (cycle)
-	    curr_idx = 0;
-	  else
-	    return 0;
-	}
+        {
+          if (cycle)
+            curr_idx = 0;
+          else
+            return 0;
+        }
 
       return current ();
     }
 
   bool last_elt_p (void) { return (curr_idx + 1 == list.length ()); }
 
   void printme (void) const;
 
@@ -294,27 +294,27 @@ private:
 
   // List of format elements.
   Array<printf_format_elt*> list;
 
   // Temporary buffer.
   std::ostringstream *buf;
 
   void add_elt_to_list (int args, const std::string& flags, int fw,
-			int prec, char type, char modifier,
- 			octave_idx_type& num_elts);
+                        int prec, char type, char modifier,
+                        octave_idx_type& num_elts);
  
   void process_conversion (const std::string& s, size_t& i, size_t n,
-			   int& args, std::string& flags, int& fw,
-			   int& prec, char& modifier, char& type,
-			   octave_idx_type& num_elts); 
+                           int& args, std::string& flags, int& fw,
+                           int& prec, char& modifier, char& type,
+                           octave_idx_type& num_elts); 
  
   void finish_conversion (const std::string& s, size_t& i, int args,
-			  const std::string& flags, int fw, int prec,
-			  char modifier, char& type,
+                          const std::string& flags, int fw, int prec,
+                          char modifier, char& type,
                           octave_idx_type& num_elts);
 
   // No copying!
 
   printf_format_list (const printf_format_list&);
 
   printf_format_list& operator = (const printf_format_list&);
 };
@@ -325,18 +325,18 @@ class
 OCTINTERP_API
 octave_base_stream
 {
 friend class octave_stream;
 
 public:
 
   octave_base_stream (std::ios::openmode arg_md = std::ios::in|std::ios::out,
-		      oct_mach_info::float_format ff
-		        = oct_mach_info::native_float_format ())
+                      oct_mach_info::float_format ff
+                        = oct_mach_info::native_float_format ())
     : count (0), md (arg_md), flt_fmt (ff), fail (false), open_state (true)
   { }
 
   virtual ~octave_base_stream (void) { }
 
   // The remaining functions are not specific to input or output only,
   // and must be provided by the derived classes.
 
@@ -372,20 +372,20 @@ public:
 
   bool is_open (void) const { return open_state; }
 
   virtual void do_close (void) { }
 
   void close (void)
     {
       if (is_open ())
-	{
-	  open_state = false;
-	  do_close ();
-	}
+        {
+          open_state = false;
+          do_close ();
+        }
     }
 
   int file_number (void);
 
   bool ok (void) const { return ! fail; }
 
   // Return current error message for this stream.
 
@@ -430,45 +430,45 @@ private:
 
   // Should contain error message if fail is TRUE.
   std::string errmsg;
 
   // Functions that are defined for all input streams (input streams
   // are those that define is).
 
   std::string do_gets (octave_idx_type max_len, bool& err, bool strip_newline,
-		       const std::string& who /* = "gets" */);
+                       const std::string& who /* = "gets" */);
 
   std::string getl (octave_idx_type max_len, bool& err, const std::string& who /* = "getl" */);
   std::string gets (octave_idx_type max_len, bool& err, const std::string& who /* = "gets" */);
   long skipl (long count, bool& err, const std::string& who /* = "skipl" */);
 
   octave_value do_scanf (scanf_format_list& fmt_list, octave_idx_type nr, octave_idx_type nc,
-			 bool one_elt_size_spec, octave_idx_type& count,
-			 const std::string& who /* = "scanf" */);
+                         bool one_elt_size_spec, octave_idx_type& count,
+                         const std::string& who /* = "scanf" */);
 
   octave_value scanf (const std::string& fmt, const Array<double>& size,
-		      octave_idx_type& count, const std::string& who /* = "scanf" */);
+                      octave_idx_type& count, const std::string& who /* = "scanf" */);
 
   bool do_oscanf (const scanf_format_elt *elt, octave_value&,
-		  const std::string& who /* = "scanf" */);
+                  const std::string& who /* = "scanf" */);
 
   octave_value_list oscanf (const std::string& fmt,
-			    const std::string& who /* = "scanf" */);
+                            const std::string& who /* = "scanf" */);
 
   // Functions that are defined for all output streams (output streams
   // are those that define os).
 
   int flush (void);
 
   int do_printf (printf_format_list& fmt_list, const octave_value_list& args,
-		 const std::string& who /* = "printf" */);
+                 const std::string& who /* = "printf" */);
 
   int printf (const std::string& fmt, const octave_value_list& args,
-	      const std::string& who /* = "printf" */);
+              const std::string& who /* = "printf" */);
 
   int puts (const std::string& s, const std::string& who /* = "puts" */);
 
   // We can always do this in terms of seek(), so the derived class
   // only has to provide that.
 
   void invalid_operation (const std::string& who, const char *rw);
 
@@ -492,68 +492,68 @@ public:
   octave_stream (const octave_stream&);
 
   octave_stream& operator = (const octave_stream&);
 
   int flush (void);
 
   std::string getl (octave_idx_type max_len, bool& err, const std::string& who /* = "getl" */);
   std::string getl (const octave_value& max_len, bool& err,
-		    const std::string& who /* = "getl" */);
+                    const std::string& who /* = "getl" */);
 
   std::string gets (octave_idx_type max_len, bool& err, const std::string& who /* = "gets" */);
   std::string gets (const octave_value& max_len, bool& err,
-		    const std::string& who /* = "gets" */);
+                    const std::string& who /* = "gets" */);
 
   long skipl (long count, bool& err, const std::string& who /* = "skipl" */);
   long skipl (const octave_value& count, bool& err, const std::string& who /* = "skipl" */);
 
   int seek (long offset, int origin);
   int seek (const octave_value& offset, const octave_value& origin);
 
   long tell (void);
 
   int rewind (void);
 
   bool is_open (void) const;
 
   void close (void);
 
   octave_value read (const Array<double>& size, octave_idx_type block_size,
-		     oct_data_conv::data_type input_type,
-		     oct_data_conv::data_type output_type,
-		     octave_idx_type skip, oct_mach_info::float_format flt_fmt,
-		     octave_idx_type& count);
+                     oct_data_conv::data_type input_type,
+                     oct_data_conv::data_type output_type,
+                     octave_idx_type skip, oct_mach_info::float_format flt_fmt,
+                     octave_idx_type& count);
 
   octave_idx_type write (const octave_value& data, octave_idx_type block_size,
-	     oct_data_conv::data_type output_type,
-	     octave_idx_type skip, oct_mach_info::float_format flt_fmt);
+             oct_data_conv::data_type output_type,
+             octave_idx_type skip, oct_mach_info::float_format flt_fmt);
 
   template <class T>
   octave_idx_type write (const Array<T>&, octave_idx_type block_size,
-	     oct_data_conv::data_type output_type,
-	     octave_idx_type skip, oct_mach_info::float_format flt_fmt);
+             oct_data_conv::data_type output_type,
+             octave_idx_type skip, oct_mach_info::float_format flt_fmt);
 
   octave_value scanf (const std::string& fmt, const Array<double>& size,
-		      octave_idx_type& count, const std::string& who /* = "scanf" */);
+                      octave_idx_type& count, const std::string& who /* = "scanf" */);
 
   octave_value scanf (const octave_value& fmt, const Array<double>& size,
-		      octave_idx_type& count, const std::string& who /* = "scanf" */);
+                      octave_idx_type& count, const std::string& who /* = "scanf" */);
 
   octave_value_list oscanf (const std::string& fmt,
-			    const std::string& who /* = "scanf" */);
+                            const std::string& who /* = "scanf" */);
 
   octave_value_list oscanf (const octave_value& fmt,
-			    const std::string& who /* = "scanf" */);
+                            const std::string& who /* = "scanf" */);
 
   int printf (const std::string& fmt, const octave_value_list& args,
-	      const std::string& who /* = "printf" */);
+              const std::string& who /* = "printf" */);
 
   int printf (const octave_value& fmt, const octave_value_list& args,
-	      const std::string& who /* = "printf" */);
+              const std::string& who /* = "printf" */);
 
   int puts (const std::string& s, const std::string& who /* = "puts" */);
   int puts (const octave_value& s, const std::string& who /* = "puts" */);
 
   bool eof (void) const;
 
   std::string error (bool clear, int& err_num);
 
@@ -563,17 +563,17 @@ public:
       return error (clear, err_num);
     }
 
   // Set the error message and state.
 
   void error (const std::string& msg)
     {
       if (rep)
-	rep->error (msg);
+        rep->error (msg);
     }
 
   void error (const char *msg) { error (std::string (msg)); }
 
   int file_number (void) { return rep ? rep->file_number () : -1; }
 
   bool is_valid (void) const { return (rep != 0); }
 
@@ -606,30 +606,30 @@ private:
   // The actual representation of this stream.
   octave_base_stream *rep;
 
   bool stream_ok (bool clear = true) const
     {
       bool retval = true;
 
       if (rep)
-	{
-	  if (clear)
-	    rep->clear ();
-	}
+        {
+          if (clear)
+            rep->clear ();
+        }
       else
-	retval = false;
+        retval = false;
 
       return retval;
     }
 
   void invalid_operation (const std::string& who, const char *rw)
     {
       if (rep)
-	rep->invalid_operation (who, rw);
+        rep->invalid_operation (who, rw);
     }
 };
 
 class
 OCTINTERP_API
 octave_stream_list
 {
 protected:
@@ -647,17 +647,17 @@ public:
   static octave_stream
   lookup (int fid, const std::string& who = std::string ());
 
   static octave_stream
   lookup (const octave_value& fid, const std::string& who = std::string ());
 
   static int remove (int fid, const std::string& who = std::string ());
   static int remove (const octave_value& fid,
-		     const std::string& who = std::string ());
+                     const std::string& who = std::string ());
 
   static void clear (bool flush = true);
 
   static string_vector get_info (int fid);
   static string_vector get_info (const octave_value& fid);
 
   static std::string list_open_files (void);
 
@@ -674,17 +674,17 @@ private:
   mutable ostrl_map::const_iterator lookup_cache;
 
   static octave_stream_list *instance;
 
   int do_insert (octave_stream& os);
 
   octave_stream do_lookup (int fid, const std::string& who = std::string ()) const;
   octave_stream do_lookup (const octave_value& fid,
-			   const std::string& who = std::string ()) const;
+                           const std::string& who = std::string ()) const;
 
   int do_remove (int fid, const std::string& who = std::string ());
   int do_remove (const octave_value& fid, const std::string& who = std::string ());
 
   void do_clear (bool flush = true);
 
   string_vector do_get_info (int fid) const;
   string_vector do_get_info (const octave_value& fid) const;
diff --git a/src/oct-strstrm.h b/src/oct-strstrm.h
--- a/src/oct-strstrm.h
+++ b/src/oct-strstrm.h
@@ -30,18 +30,18 @@ along with Octave; see the file COPYING.
 #include "oct-stream.h"
 
 class
 octave_base_strstream : public octave_base_stream
 {
 public:
 
   octave_base_strstream (std::ios::openmode m = std::ios::out,
-			 oct_mach_info::float_format ff
-			   = oct_mach_info::native_float_format ())
+                         oct_mach_info::float_format ff
+                           = oct_mach_info::native_float_format ())
     : octave_base_stream (m, ff) { }
 
   // Position a stream at OFFSET relative to ORIGIN.
 
   int seek (long, int);
 
   // Return current stream position.
 
@@ -71,36 +71,36 @@ private:
 };
 
 class
 octave_istrstream : public octave_base_strstream
 {
 public:
 
   octave_istrstream (const char *data,
-		     std::ios::openmode arg_md = std::ios::out,
-		     oct_mach_info::float_format ff
-		       = oct_mach_info::native_float_format ())
+                     std::ios::openmode arg_md = std::ios::out,
+                     oct_mach_info::float_format ff
+                       = oct_mach_info::native_float_format ())
     : octave_base_strstream (arg_md, ff), is (data) { }
 
   octave_istrstream (const std::string& data,
-		     std::ios::openmode arg_md = std::ios::out,
-		     oct_mach_info::float_format ff
-		       = oct_mach_info::native_float_format ())
+                     std::ios::openmode arg_md = std::ios::out,
+                     oct_mach_info::float_format ff
+                       = oct_mach_info::native_float_format ())
     : octave_base_strstream (arg_md, ff), is (data.c_str ()) { }
 
   static octave_stream
   create (const char *data, std::ios::openmode arg_md = std::ios::out,
-	  oct_mach_info::float_format ff
-	    = oct_mach_info::native_float_format ());
+          oct_mach_info::float_format ff
+            = oct_mach_info::native_float_format ());
 
   static octave_stream
   create (const std::string& data, std::ios::openmode arg_md = std::ios::out,
-	  oct_mach_info::float_format ff
-	    = oct_mach_info::native_float_format ());
+          oct_mach_info::float_format ff
+            = oct_mach_info::native_float_format ());
 
   // Return non-zero if EOF has been reached on this stream.
 
   bool eof (void) const { return is.eof (); }
 
   std::istream *input_stream (void) { return &is; }
 
   std::ostream *output_stream (void) { return 0; }
@@ -129,24 +129,24 @@ private:
 };
 
 class
 octave_ostrstream : public octave_base_strstream
 {
 public:
 
   octave_ostrstream (std::ios::openmode arg_md = std::ios::out,
-		     oct_mach_info::float_format ff
-		       = oct_mach_info::native_float_format ())
+                     oct_mach_info::float_format ff
+                       = oct_mach_info::native_float_format ())
     : octave_base_strstream (arg_md, ff) { }
 
   static octave_stream
   create (std::ios::openmode arg_md = std::ios::out,
-	  oct_mach_info::float_format ff
-	    = oct_mach_info::native_float_format ());
+          oct_mach_info::float_format ff
+            = oct_mach_info::native_float_format ());
 
   // Return non-zero if EOF has been reached on this stream.
 
   bool eof (void) const { return os.eof (); }
 
   std::istream *input_stream (void) { return 0; }
 
   std::ostream *output_stream (void) { return &os; }
diff --git a/src/octave.h b/src/octave.h
--- a/src/octave.h
+++ b/src/octave.h
@@ -18,19 +18,19 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, see
 <http://www.gnu.org/licenses/>.
 
 */
 
 #if !defined (octave_octave_h)
 #define octave_octave_h 1
 
-#ifdef	__cplusplus
+#ifdef  __cplusplus
 extern "C" {
 #endif
 
 extern OCTINTERP_API int octave_main (int argc, char **argv, int embedded);
 
-#ifdef	__cplusplus
+#ifdef  __cplusplus
 }
 #endif
 
 #endif
diff --git a/src/ops.h b/src/ops.h
--- a/src/ops.h
+++ b/src/ops.h
@@ -73,39 +73,39 @@ extern void install_ops (void);
 #define INSTALL_WIDENOP(t1, t2, f) \
   octave_value_typeinfo::register_widening_op \
     (t1::static_type_id (), t2::static_type_id (), CONCAT2(oct_conv_, f));
 
 #define CAST_UNOP_ARG(t) \
   t v = dynamic_cast<t> (a)
 
 #define CAST_BINOP_ARGS(t1, t2) \
-  t1 v1 = dynamic_cast<t1> (a1);		\
+  t1 v1 = dynamic_cast<t1> (a1);                \
   t2 v2 = dynamic_cast<t2> (a2)
 
 #define CAST_CONV_ARG(t) \
   t v = dynamic_cast<t> (a)
 
 #define ASSIGNOPDECL(name) \
   static octave_value \
   CONCAT2(oct_assignop_, name) (octave_base_value& a1, \
-			 const octave_value_list& idx, \
-			 const octave_base_value& a2)
+                         const octave_value_list& idx, \
+                         const octave_base_value& a2)
 
 #define NULLASSIGNOPDECL(name) \
   static octave_value \
   CONCAT2(oct_assignop_, name) (octave_base_value& a, \
-			 const octave_value_list& idx, \
-			 const octave_base_value&)
+                         const octave_value_list& idx, \
+                         const octave_base_value&)
 
 #define ASSIGNANYOPDECL(name) \
   static octave_value \
   CONCAT2(oct_assignop_, name) (octave_base_value& a1, \
-			 const octave_value_list& idx, \
-			 const octave_value& a2)
+                         const octave_value_list& idx, \
+                         const octave_value& a2)
 
 #define DEFASSIGNOP(name, t1, t2) \
   ASSIGNOPDECL (name)
 
 #define DEFASSIGNOP_FN(name, t1, t2, f) \
   ASSIGNOPDECL (name) \
   { \
     CAST_BINOP_ARGS (CONCAT2(octave_, t1)&, const CONCAT2(octave_, t2)&); \
@@ -339,29 +339,29 @@ extern void install_ops (void);
   BINOPDECL (name, a1, a2) \
   { \
     CAST_BINOP_ARGS (const CONCAT2(octave_, t1)&, const CONCAT2(octave_, t2)&); \
     return octave_value (f (v1.CONCAT2(e1, _value) (), v2.CONCAT2(e2, _value) ())); \
   }
 
 #define BINOP_NONCONFORMANT(msg) \
   gripe_nonconformant (msg, \
-		       a1.rows (), a1.columns (), \
-		       a2.rows (), a2.columns ()); \
+                       a1.rows (), a1.columns (), \
+                       a2.rows (), a2.columns ()); \
   return octave_value ()
 
-#define CATOPDECL(name, a1, a2)	\
+#define CATOPDECL(name, a1, a2) \
   static octave_value \
   CONCAT2(oct_catop_, name) (octave_base_value& a1, const octave_base_value& a2, \
-		      const Array<octave_idx_type>& ra_idx)
+                      const Array<octave_idx_type>& ra_idx)
 
-#define DEFCATOPX(name, t1, t2)	\
+#define DEFCATOPX(name, t1, t2) \
   CATOPDECL (name, , )
 
-#define DEFCATOP(name, t1, t2)	\
+#define DEFCATOP(name, t1, t2)  \
   CATOPDECL (name, a1, a2)
 
 // FIXME -- in some cases, the constructor isn't necessary.
 
 #define DEFCATOP_FN(name, t1, t2, f) \
   CATOPDECL (name, a1, a2) \
   { \
     CAST_BINOP_ARGS (CONCAT2(octave_, t1)&, const CONCAT2(octave_, t2)&); \
@@ -376,29 +376,29 @@ extern void install_ops (void);
   }
 
 #define DEFNDCHARCATOP_FN(name, t1, t2, f) \
   CATOPDECL (name, a1, a2) \
   { \
     CAST_BINOP_ARGS (CONCAT2(octave_, t1)&, const CONCAT2(octave_, t2)&); \
  \
     return octave_value (v1.char_array_value () . f (v2.char_array_value (), ra_idx), \
-			 ((a1.is_sq_string () || a2.is_sq_string ()) \
-			  ? '\'' : '"')); \
+                         ((a1.is_sq_string () || a2.is_sq_string ()) \
+                          ? '\'' : '"')); \
   }
 
 // For compatibility, the second arg is always converted to the type
 // of the first.  Hmm.
 
 #define DEFNDCATOP_FN2(name, t1, t2, tc1, tc2, e1, e2, f) \
   CATOPDECL (name, a1, a2) \
   { \
     CAST_BINOP_ARGS (CONCAT2(octave_, t1)&, const CONCAT2(octave_, t2)&); \
     return octave_value (tc1 (v1.CONCAT2(e1, _value) ()) . f (tc2 (v2.CONCAT2(e2, _value) ()), ra_idx)); \
   }
 
 #define CATOP_NONCONFORMANT(msg) \
   gripe_nonconformant (msg, \
-		       a1.rows (), a1.columns (), \
-		       a2.rows (), a2.columns ()); \
+                       a1.rows (), a1.columns (), \
+                       a2.rows (), a2.columns ()); \
   return octave_value ()
 
 #endif
diff --git a/src/ov-base-diag.h b/src/ov-base-diag.h
--- a/src/ov-base-diag.h
+++ b/src/ov-base-diag.h
@@ -60,28 +60,28 @@ public:
 
   size_t byte_size (void) const { return matrix.byte_size (); }
 
   octave_value squeeze (void) const { return matrix; }
 
   octave_value full_value (void) const { return to_dense (); }
 
   octave_value subsref (const std::string& type,
-			const std::list<octave_value_list>& idx);
+                        const std::list<octave_value_list>& idx);
 
   octave_value_list subsref (const std::string& type,
-			     const std::list<octave_value_list>& idx, int)
+                             const std::list<octave_value_list>& idx, int)
     { return subsref (type, idx); }
 
   octave_value do_index_op (const octave_value_list& idx,
-			    bool resize_ok = false);
+                            bool resize_ok = false);
 
   octave_value subsasgn (const std::string& type,
-			 const std::list<octave_value_list>& idx,
-			 const octave_value& rhs);
+                         const std::list<octave_value_list>& idx,
+                         const octave_value& rhs);
 
   dim_vector dims (void) const { return matrix.dims (); }
 
   octave_idx_type nnz (void) const { return to_dense ().nnz (); }
 
   octave_value reshape (const dim_vector& new_dims) const
     { return to_dense ().reshape (new_dims); }
 
@@ -98,17 +98,17 @@ public:
     { return matrix_type (); }
 
   octave_value diag (octave_idx_type k = 0) const
     { return octave_value (matrix.diag (k)); }
 
   octave_value sort (octave_idx_type dim = 0, sortmode mode = ASCENDING) const
     { return to_dense ().sort (dim, mode); }
   octave_value sort (Array<octave_idx_type> &sidx, octave_idx_type dim = 0,
-		     sortmode mode = ASCENDING) const
+                     sortmode mode = ASCENDING) const
     { return to_dense ().sort (sidx, dim, mode); }
 
   sortmode is_sorted (sortmode mode = UNSORTED) const
     { return to_dense ().is_sorted (mode); }
 
   Array<octave_idx_type> sort_rows_idx (sortmode mode = ASCENDING) const
     { return to_dense ().sort_rows_idx (mode); }
 
@@ -192,18 +192,18 @@ public:
 
   void print_raw (std::ostream& os, bool pr_as_read_syntax = false) const;
 
   bool save_ascii (std::ostream& os);
 
   bool load_ascii (std::istream& is);
 
   int write (octave_stream& os, int block_size,
-	     oct_data_conv::data_type output_type, int skip,
-	     oct_mach_info::float_format flt_fmt) const;
+             oct_data_conv::data_type output_type, int skip,
+             oct_mach_info::float_format flt_fmt) const;
 
   mxArray *as_mxArray (void) const;
 
   bool print_as_scalar (void) const;
 
   void print (std::ostream& os, bool pr_as_read_syntax = false) const;
 
   void print_info (std::ostream& os, const std::string& prefix) const;
diff --git a/src/ov-base-int.h b/src/ov-base-int.h
--- a/src/ov-base-int.h
+++ b/src/ov-base-int.h
@@ -69,17 +69,17 @@ public:
 
   bool save_ascii (std::ostream& os);
 
   bool load_ascii (std::istream& is);
 
   bool save_binary (std::ostream& os, bool& );
 
   bool load_binary (std::istream& is, bool swap, 
-		    oct_mach_info::float_format );
+                    oct_mach_info::float_format );
 
 #if defined (HAVE_HDF5)
   bool save_hdf5 (hid_t loc_id, const char *name, bool);
 
   bool load_hdf5 (hid_t loc_id, const char *name);
 #endif
 };
 
@@ -112,17 +112,17 @@ public:
 
   bool save_ascii (std::ostream& os);
 
   bool load_ascii (std::istream& is);
 
   bool save_binary (std::ostream& os, bool& );
 
   bool load_binary (std::istream& is, bool swap, 
-		    oct_mach_info::float_format );
+                    oct_mach_info::float_format );
 
 #if defined (HAVE_HDF5)
   bool save_hdf5 (hid_t loc_id, const char *name, bool );
 
   bool load_hdf5 (hid_t loc_id, const char *name);
 #endif
 };
 
diff --git a/src/ov-base-mat.h b/src/ov-base-mat.h
--- a/src/ov-base-mat.h
+++ b/src/ov-base-mat.h
@@ -76,28 +76,28 @@ public:
 
   octave_value squeeze (void) const { return MT (matrix.squeeze ()); }
 
   octave_value full_value (void) const { return matrix; }
 
   void maybe_economize (void) { matrix.maybe_economize (); }
 
   octave_value subsref (const std::string& type,
-			const std::list<octave_value_list>& idx);
+                        const std::list<octave_value_list>& idx);
 
   octave_value_list subsref (const std::string& type,
-			     const std::list<octave_value_list>& idx, int)
+                             const std::list<octave_value_list>& idx, int)
     { return subsref (type, idx); }
 
   octave_value subsasgn (const std::string& type,
-			 const std::list<octave_value_list>& idx,
-			 const octave_value& rhs);
+                         const std::list<octave_value_list>& idx,
+                         const octave_value& rhs);
 
   octave_value do_index_op (const octave_value_list& idx,
-			    bool resize_ok = false);
+                            bool resize_ok = false);
 
   void assign (const octave_value_list& idx, const MT& rhs);
 
   void assign (const octave_value_list& idx, typename MT::element_type rhs);
 
   void delete_elements (const octave_value_list& idx);
 
   dim_vector dims (void) const { return matrix.dims (); }
@@ -121,17 +121,17 @@ public:
   MatrixType matrix_type (const MatrixType& _typ) const;
 
   octave_value diag (octave_idx_type k = 0) const
     { return octave_value (matrix.diag (k)); }
 
   octave_value sort (octave_idx_type dim = 0, sortmode mode = ASCENDING) const
     { return octave_value (matrix.sort (dim, mode)); }
   octave_value sort (Array<octave_idx_type> &sidx, octave_idx_type dim = 0,
-		     sortmode mode = ASCENDING) const
+                     sortmode mode = ASCENDING) const
     { return octave_value (matrix.sort (sidx, dim, mode)); }
 
   sortmode is_sorted (sortmode mode = UNSORTED) const
     { return matrix.is_sorted (mode); }
 
   Array<octave_idx_type> sort_rows_idx (sortmode mode = ASCENDING) const
     { return matrix.sort_rows_idx (mode); }
 
diff --git a/src/ov-base-scalar.h b/src/ov-base-scalar.h
--- a/src/ov-base-scalar.h
+++ b/src/ov-base-scalar.h
@@ -60,25 +60,25 @@ public:
   octave_base_value *clone (void) const { return new octave_base_scalar (*this); }
   octave_base_value *empty_clone (void) const { return new octave_base_scalar (); }
 
   octave_value squeeze (void) const { return scalar; }
 
   octave_value full_value (void) const { return scalar; }
 
   octave_value subsref (const std::string& type,
-			const std::list<octave_value_list>& idx);
+                        const std::list<octave_value_list>& idx);
 
   octave_value_list subsref (const std::string& type,
-			     const std::list<octave_value_list>& idx, int)
+                             const std::list<octave_value_list>& idx, int)
     { return subsref (type, idx); }
 
   octave_value subsasgn (const std::string& type,
-			 const std::list<octave_value_list>& idx,
-			 const octave_value& rhs);
+                         const std::list<octave_value_list>& idx,
+                         const octave_value& rhs);
 
   bool is_constant (void) const { return true; }
 
   bool is_defined (void) const { return true; }
 
   dim_vector dims (void) const { static dim_vector dv (1, 1); return dv; }
 
   octave_idx_type nnz (void) const { return (scalar != ST ()) ? 1 : 0; }
@@ -96,17 +96,17 @@ public:
   octave_value any (int = 0) const { return (scalar != ST ()); }
 
   octave_value diag (octave_idx_type k = 0) const 
     { return octave_value (matrix_value (). diag (k)); }
 
   octave_value sort (octave_idx_type, sortmode) const
     { return octave_value (scalar); }
   octave_value sort (Array<octave_idx_type> &sidx, octave_idx_type,
-		     sortmode) const
+                     sortmode) const
     { 
       sidx.resize (dim_vector (1, 1)); 
       sidx(0) = 0; 
       return octave_value (scalar); 
     }
 
   sortmode is_sorted (sortmode mode = UNSORTED) const
     { return mode ? mode : ASCENDING; }
diff --git a/src/ov-base-sparse.h b/src/ov-base-sparse.h
--- a/src/ov-base-sparse.h
+++ b/src/ov-base-sparse.h
@@ -49,24 +49,24 @@ template <class T>
 class
 octave_base_sparse : public octave_base_value
 {
  public:
  
   octave_base_sparse (void) : octave_base_value (), typ (MatrixType ()) { }
 
   octave_base_sparse (const T& a) : octave_base_value (), matrix (a),
-				    typ (MatrixType ())
+                                    typ (MatrixType ())
   {
     if (matrix.ndims () == 0)
       matrix.resize (dim_vector (0, 0));
   }
 
   octave_base_sparse (const T& a, const MatrixType& t) : octave_base_value (), 
-				matrix (a), typ (t)
+                                matrix (a), typ (t)
   {
     if (matrix.ndims () == 0)
       matrix.resize (dim_vector (0, 0));
   }
 
   octave_base_sparse (const octave_base_sparse& a) : 
     octave_base_value (), matrix (a.matrix), typ (a.typ) { }
 
@@ -82,34 +82,34 @@ octave_base_sparse : public octave_base_
 
   size_t byte_size (void) const { return matrix.byte_size (); }
 
   octave_value squeeze (void) const { return matrix.squeeze (); }
 
   octave_value full_value (void) const { return matrix.matrix_value (); }
 
   octave_value subsref (const std::string& type,
-			const std::list<octave_value_list>& idx);
+                        const std::list<octave_value_list>& idx);
 
   octave_value_list subsref (const std::string& type,
-			     const std::list<octave_value_list>& idx, int)
+                             const std::list<octave_value_list>& idx, int)
     { return subsref (type, idx); }
 
   octave_value subsasgn (const std::string& type,
-			 const std::list<octave_value_list>& idx,
-			 const octave_value& rhs);
+                         const std::list<octave_value_list>& idx,
+                         const octave_value& rhs);
 
   void assign (const octave_value_list& idx, const T& rhs);
 
   void delete_elements (const octave_value_list& idx);
 
   dim_vector dims (void) const { return matrix.dims (); }
 
   octave_value do_index_op (const octave_value_list& idx,
-			    bool resize_ok = false);
+                            bool resize_ok = false);
 
   octave_value reshape (const dim_vector& new_dims) const
     { return T (matrix.reshape (new_dims)); }
 
   octave_value permute (const Array<int>& vec, bool inv = false) const
     { return T (matrix.permute (vec, inv)); }
 
   octave_value resize (const dim_vector& dv, bool = false) const;
@@ -118,17 +118,17 @@ octave_base_sparse : public octave_base_
   octave_value any (int dim = 0) const { return matrix.any (dim); }
 
   octave_value diag (octave_idx_type k = 0) const
     { return octave_value (matrix.diag (k)); }
 
   octave_value sort (octave_idx_type dim = 0, sortmode mode = ASCENDING) const
     { return octave_value (matrix.sort (dim, mode)); }
   octave_value sort (Array<octave_idx_type> &sidx, octave_idx_type dim = 0,
-		     sortmode mode = ASCENDING) const
+                     sortmode mode = ASCENDING) const
     { return octave_value (matrix.sort (sidx, dim, mode)); }
 
   sortmode is_sorted (sortmode mode = UNSORTED) const
     { return full_value ().is_sorted (mode); }
 
   MatrixType matrix_type (void) const { return typ; }
   MatrixType matrix_type (const MatrixType& _typ) const
     { MatrixType ret = typ; typ = _typ; return ret; }
diff --git a/src/ov-base.h b/src/ov-base.h
--- a/src/ov-base.h
+++ b/src/ov-base.h
@@ -162,18 +162,18 @@ DEF_CLASS_TO_BTYP (char, btyp_char);
 
 #define DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA(t, n, c) \
   int t::t_id (-1); \
   const std::string t::t_name (n); \
   const std::string t::c_name (c); \
   void t::register_type (void) \
     { \
       t_id = octave_value_typeinfo::register_type (t::t_name, \
-						   t::c_name, \
-						   octave_value (new t ())); \
+                                                   t::c_name, \
+                                                   octave_value (new t ())); \
     }
 
 // A base value type, so that derived types only have to redefine what
 // they need (if they are derived from octave_base_value instead of
 // octave_value).
 
 class
 OCTINTERP_API
@@ -240,40 +240,40 @@ public:
   virtual void maybe_economize (void) { }
 
   virtual Matrix size (void); 
 
   virtual octave_idx_type numel (const octave_value_list&);
 
   virtual octave_value
   subsref (const std::string& type,
-	   const std::list<octave_value_list>& idx);
+           const std::list<octave_value_list>& idx);
 
   virtual octave_value_list
   subsref (const std::string& type,
-	   const std::list<octave_value_list>& idx,
-	   int nargout);
+           const std::list<octave_value_list>& idx,
+           int nargout);
 
   virtual octave_value
   subsref (const std::string& type,
-	   const std::list<octave_value_list>& idx,
+           const std::list<octave_value_list>& idx,
            bool auto_add);
 
   virtual octave_value
   do_index_op (const octave_value_list& idx, bool resize_ok = false);
 
   virtual octave_value_list
   do_multi_index_op (int nargout, const octave_value_list& idx);
 
   virtual void assign (const std::string&, const octave_value&) { }
 
   virtual octave_value
   subsasgn (const std::string& type,
-	    const std::list<octave_value_list>& idx,
-	    const octave_value& rhs);
+            const std::list<octave_value_list>& idx,
+            const octave_value& rhs);
 
   virtual idx_vector index_vector (void) const;
 
   virtual dim_vector dims (void) const { return dim_vector (); }
 
   octave_idx_type rows (void) const
     {
       dim_vector dv = dims ();
@@ -566,17 +566,17 @@ public:
 
   virtual octave_fcn_handle *fcn_handle_value (bool silent = false);
 
   virtual octave_fcn_inline *fcn_inline_value (bool silent = false);
 
   virtual octave_value_list list_value (void) const;
 
   virtual octave_value convert_to_str (bool pad = false, bool force = false,
-				       char type = '\'') const;
+                                       char type = '\'') const;
   virtual octave_value
   convert_to_str_internal (bool pad, bool force, char type) const;
 
   virtual void convert_to_row_or_column_vector (void);
 
   virtual bool print_as_scalar (void) const { return false; }
 
   virtual void print (std::ostream& os, bool pr_as_read_syntax = false) const;
@@ -584,57 +584,57 @@ public:
   virtual void
   print_raw (std::ostream& os, bool pr_as_read_syntax = false) const;
 
   virtual bool
   print_name_tag (std::ostream& os, const std::string& name) const;
 
   virtual void
   print_with_name (std::ostream& output_buf, const std::string& name, 
-		   bool print_padding = true);
+                   bool print_padding = true);
 
   virtual void print_info (std::ostream& os, const std::string& prefix) const;
 
   virtual bool save_ascii (std::ostream& os);
 
   virtual bool load_ascii (std::istream& is);
 
   virtual bool save_binary (std::ostream& os, bool& save_as_floats);
 
   virtual bool load_binary (std::istream& is, bool swap, 
-			    oct_mach_info::float_format fmt);
+                            oct_mach_info::float_format fmt);
 
 #if defined (HAVE_HDF5)
   virtual bool
   save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
 
   virtual bool
   load_hdf5 (hid_t loc_id, const char *name);
 #endif
 
   virtual int
   write (octave_stream& os, int block_size,
-	 oct_data_conv::data_type output_type, int skip,
-	 oct_mach_info::float_format flt_fmt) const;
+         oct_data_conv::data_type output_type, int skip,
+         oct_mach_info::float_format flt_fmt) const;
 
   virtual void *mex_get_data (void) const { return 0; }
 
   virtual octave_idx_type *mex_get_ir (void) const { return 0; }
 
   virtual octave_idx_type *mex_get_jc (void) const { return 0; }
 
   virtual mxArray *as_mxArray (void) const;
 
   virtual octave_value diag (octave_idx_type k = 0) const;
 
   virtual octave_value sort (octave_idx_type dim = 0, 
-			     sortmode mode = ASCENDING) const;
+                             sortmode mode = ASCENDING) const;
   virtual octave_value sort (Array<octave_idx_type> &sidx, 
-			     octave_idx_type dim = 0,
-			     sortmode mode = ASCENDING) const;
+                             octave_idx_type dim = 0,
+                             sortmode mode = ASCENDING) const;
 
   virtual sortmode is_sorted (sortmode mode = UNSORTED) const;
 
   virtual Array<octave_idx_type>
   sort_rows_idx (sortmode mode = ASCENDING) const;
 
   virtual sortmode is_sorted_rows (sortmode mode = UNSORTED) const;
 
@@ -710,18 +710,18 @@ public:
 
   virtual octave_value map (unary_mapper_t) const;
 
 protected:
 
   // This should only be called for derived types.
 
   octave_value numeric_assign (const std::string& type,
-			       const std::list<octave_value_list>& idx,
-			       const octave_value& rhs);
+                               const std::list<octave_value_list>& idx,
+                               const octave_value& rhs);
 
   void reset_indent_level (void) const
     { curr_print_indent_level = 0; }
 
   void increment_indent_level (void) const
     { curr_print_indent_level += 2; }
 
   void decrement_indent_level (void) const
diff --git a/src/ov-bool-mat.h b/src/ov-bool-mat.h
--- a/src/ov-bool-mat.h
+++ b/src/ov-bool-mat.h
@@ -192,27 +192,27 @@ public:
 
   bool save_ascii (std::ostream& os);
 
   bool load_ascii (std::istream& is);
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap, 
-		    oct_mach_info::float_format fmt);
+                    oct_mach_info::float_format fmt);
 
 #if defined (HAVE_HDF5)
   bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
 
   bool load_hdf5 (hid_t loc_id, const char *name);
 #endif
 
   int write (octave_stream& os, int block_size,
-	     oct_data_conv::data_type output_type, int skip,
-	     oct_mach_info::float_format flt_fmt) const
+             oct_data_conv::data_type output_type, int skip,
+             oct_mach_info::float_format flt_fmt) const
     { return os.write (matrix, block_size, output_type, skip, flt_fmt); }
 
   // Unsafe.  This function exists to support the MEX interface.
   // You should not use it anywhere else.
   void *mex_get_data (void) const { return matrix.mex_get_data (); }
 
   mxArray *as_mxArray (void) const;
 
diff --git a/src/ov-bool-sparse.h b/src/ov-bool-sparse.h
--- a/src/ov-bool-sparse.h
+++ b/src/ov-bool-sparse.h
@@ -55,17 +55,17 @@ public:
 
   octave_sparse_bool_matrix (void)
     : octave_base_sparse<SparseBoolMatrix> () { }
 
   octave_sparse_bool_matrix (const SparseBoolMatrix& bnda)
     : octave_base_sparse<SparseBoolMatrix> (bnda) { }
 
   octave_sparse_bool_matrix (const SparseBoolMatrix& bnda,
-			     const MatrixType& t)
+                             const MatrixType& t)
     : octave_base_sparse<SparseBoolMatrix> (bnda, t) { }
 
   octave_sparse_bool_matrix (const boolNDArray& m)
     : octave_base_sparse<SparseBoolMatrix> (SparseBoolMatrix (m)) { }
 
   octave_sparse_bool_matrix (const boolMatrix& m)
     : octave_base_sparse<SparseBoolMatrix> (SparseBoolMatrix (m)) { }
 
@@ -124,17 +124,17 @@ public:
   SparseBoolMatrix sparse_bool_matrix_value (bool = false) const
     { return matrix; }
 
   octave_value convert_to_str_internal (bool pad, bool force, char type) const;
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap, 
-		    oct_mach_info::float_format fmt);
+                    oct_mach_info::float_format fmt);
 
 #if defined (HAVE_HDF5)
   bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
 
   bool load_hdf5 (hid_t loc_id, const char *name);
 #endif
 
   mxArray *as_mxArray (void) const;
diff --git a/src/ov-bool.h b/src/ov-bool.h
--- a/src/ov-bool.h
+++ b/src/ov-bool.h
@@ -64,17 +64,17 @@ public:
   ~octave_bool (void) { }
 
   octave_base_value *clone (void) const { return new octave_bool (*this); }
   octave_base_value *empty_clone (void) const { return new octave_bool (); }
 
   type_conv_info numeric_conversion_function (void) const;
 
   octave_value do_index_op (const octave_value_list& idx,
-			    bool resize_ok = false);
+                            bool resize_ok = false);
 
   idx_vector index_vector (void) const { return idx_vector (scalar); }
 
   builtin_type_t builtin_type (void) const { return btyp_bool; }
 
   bool is_real_scalar (void) const { return true; }
 
   bool is_bool_scalar (void) const { return true; }
@@ -187,30 +187,30 @@ public:
 
   bool save_ascii (std::ostream& os);
 
   bool load_ascii (std::istream& is);
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap, 
-		    oct_mach_info::float_format fmt);
+                    oct_mach_info::float_format fmt);
 
 #if defined (HAVE_HDF5)
   bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
 
   bool load_hdf5 (hid_t loc_id, const char *name);
 #endif
 
   int write (octave_stream& os, int block_size,
-	     oct_data_conv::data_type output_type, int skip,
-	     oct_mach_info::float_format flt_fmt) const
+             oct_data_conv::data_type output_type, int skip,
+             oct_mach_info::float_format flt_fmt) const
     {
       return os.write (bool_array_value (), block_size, output_type,
-		       skip, flt_fmt);
+                       skip, flt_fmt);
     }
 
   mxArray *as_mxArray (void) const;
 
   // Mapper functions are converted to double for treatment
   octave_value map (unary_mapper_t umap) const
     {
       octave_scalar m (scalar_value ());
diff --git a/src/ov-builtin.h b/src/ov-builtin.h
--- a/src/ov-builtin.h
+++ b/src/ov-builtin.h
@@ -40,31 +40,31 @@ octave_builtin : public octave_function
 {
 public:
 
   octave_builtin (void) : octave_function (), f (0) { }
 
   typedef octave_value_list (*fcn) (const octave_value_list&, int);
 
   octave_builtin (fcn ff, const std::string& nm = std::string (),
-		  const std::string& ds = std::string ())
+                  const std::string& ds = std::string ())
     : octave_function (nm, ds), f (ff) { }
 
   ~octave_builtin (void) { }
 
   octave_value subsref (const std::string& type,
-			const std::list<octave_value_list>& idx)
+                        const std::list<octave_value_list>& idx)
     {
       octave_value_list tmp = subsref (type, idx, 1);
       return tmp.length () > 0 ? tmp(0) : octave_value ();
     }
 
   octave_value_list subsref (const std::string& type,
-			     const std::list<octave_value_list>& idx,
-			     int nargout);
+                             const std::list<octave_value_list>& idx,
+                             int nargout);
 
   octave_function *function_value (bool = false) { return this; }
 
   bool is_builtin_function (void) const { return true; }
 
   octave_value_list
   do_multi_index_op (int nargout, const octave_value_list& args);
 
diff --git a/src/ov-cell.h b/src/ov-cell.h
--- a/src/ov-cell.h
+++ b/src/ov-cell.h
@@ -68,45 +68,45 @@ public:
   octave_base_value *clone (void) const { return new octave_cell (*this); }
   octave_base_value *empty_clone (void) const { return new octave_cell (); }
 
 #if 0
   octave_base_value *try_narrowing_conversion (void);
 #endif
 
   octave_value subsref (const std::string& type,
-			const std::list<octave_value_list>& idx)
+                        const std::list<octave_value_list>& idx)
     {
       octave_value_list tmp = subsref (type, idx, 1);
       return tmp.length () > 0 ? tmp(0) : octave_value ();
     }
 
   octave_value_list subsref (const std::string& type,
-			     const std::list<octave_value_list>& idx, int);
+                             const std::list<octave_value_list>& idx, int);
 
   octave_value subsref (const std::string& type,
-			const std::list<octave_value_list>& idx,
+                        const std::list<octave_value_list>& idx,
                         bool auto_add);
 
   octave_value subsasgn (const std::string& type,
-			 const std::list<octave_value_list>& idx,
-			 const octave_value& rhs);
+                         const std::list<octave_value_list>& idx,
+                         const octave_value& rhs);
 
   void assign (const octave_value_list& idx, const Cell& rhs);
 
   void assign (const octave_value_list& idx, const octave_value& rhs);
 
   void delete_elements (const octave_value_list& idx);
 
   size_t byte_size (void) const;
 
   octave_value sort (octave_idx_type dim = 0, sortmode mode = ASCENDING) const;
 
   octave_value sort (Array<octave_idx_type> &sidx, octave_idx_type dim = 0,
-		     sortmode mode = ASCENDING) const;
+                     sortmode mode = ASCENDING) const;
 
   sortmode is_sorted (sortmode mode = UNSORTED) const;
 
   Array<octave_idx_type> sort_rows_idx (sortmode mode = ASCENDING) const;
 
   sortmode is_sorted_rows (sortmode mode = UNSORTED) const;
 
   bool is_matrix_type (void) const { return false; }
@@ -145,17 +145,17 @@ public:
 
   bool save_ascii (std::ostream& os);
 
   bool load_ascii (std::istream& is);
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap, 
-		    oct_mach_info::float_format fmt);
+                    oct_mach_info::float_format fmt);
 
 #if defined (HAVE_HDF5)
   bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
 
   bool load_hdf5 (hid_t loc_id, const char *name);
 #endif
 
   octave_value map (unary_mapper_t umap) const;
diff --git a/src/ov-class.h b/src/ov-class.h
--- a/src/ov-class.h
+++ b/src/ov-class.h
@@ -74,35 +74,35 @@ public:
 
   Cell dotref (const octave_value_list& idx);
 
   Matrix size (void);
 
   octave_idx_type numel (const octave_value_list&); 
 
   octave_value subsref (const std::string& type,
-			const std::list<octave_value_list>& idx)
+                        const std::list<octave_value_list>& idx)
     {
       octave_value_list tmp = subsref (type, idx, 1);
       return tmp.length () > 0 ? tmp(0) : octave_value ();
     }
 
   octave_value_list subsref (const std::string& type,
-			     const std::list<octave_value_list>& idx,
-			     int nargout);
+                             const std::list<octave_value_list>& idx,
+                             int nargout);
 
   static octave_value numeric_conv (const Cell& val,
-				    const std::string& type);
+                                    const std::string& type);
 
   void assign(const std::string& k, const octave_value& rhs)
   { map.assign (k, rhs); };
 
   octave_value subsasgn (const std::string& type,
-			 const std::list<octave_value_list>& idx,
-			 const octave_value& rhs);
+                         const std::list<octave_value_list>& idx,
+                         const octave_value& rhs);
 
   idx_vector index_vector (void) const;
 
   dim_vector dims (void) const { return map.dims (); }
 
   size_t byte_size (void) const;
 
   // This is the number of elements in each field.  The total number
@@ -145,32 +145,32 @@ public:
 
   void print (std::ostream& os, bool pr_as_read_syntax = false) const;
 
   void print_raw (std::ostream& os, bool pr_as_read_syntax = false) const;
 
   bool print_name_tag (std::ostream& os, const std::string& name) const;
 
   void print_with_name (std::ostream& os, const std::string& name, 
-			bool print_padding = true);
+                        bool print_padding = true);
 
   bool reconstruct_exemplar (void);
 
   static void clear_exemplar_map (void);
 
   bool reconstruct_parents (void);
 
   bool save_ascii (std::ostream& os);
 
   bool load_ascii (std::istream& is);
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap, 
-		    oct_mach_info::float_format fmt);
+                    oct_mach_info::float_format fmt);
 
 #if defined (HAVE_HDF5)
   bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
 
   bool load_hdf5 (hid_t loc_id, const char *name);
 #endif
 
   mxArray *as_mxArray (void) const;
@@ -210,25 +210,25 @@ public:
   public:
 
     exemplar_info (void) : field_names (), parent_class_names () { }
 
     exemplar_info (const octave_value& obj);
 
     exemplar_info (const exemplar_info& x)
       : field_names (x.field_names),
-	parent_class_names (x.parent_class_names) { }
+        parent_class_names (x.parent_class_names) { }
 
     exemplar_info& operator = (const exemplar_info& x)
     {
       if (&x != this)
-	{
-	  field_names = x.field_names;
-	  parent_class_names = x.parent_class_names;
-	}
+        {
+          field_names = x.field_names;
+          parent_class_names = x.parent_class_names;
+        }
       return *this;
     }
 
     octave_idx_type nfields (void) const { return field_names.length (); }
 
     size_t nparents (void) const { return parent_class_names.size (); }
 
     string_vector fields (void) const { return field_names; }
diff --git a/src/ov-complex.h b/src/ov-complex.h
--- a/src/ov-complex.h
+++ b/src/ov-complex.h
@@ -74,23 +74,23 @@ public:
   octave_base_value *empty_clone (void) const
     { return new octave_complex_matrix (); }
 
   type_conv_info numeric_demotion_function (void) const;
 
   octave_base_value *try_narrowing_conversion (void);
 
   octave_value do_index_op (const octave_value_list& idx,
-			    bool resize_ok = false);
+                            bool resize_ok = false);
 
   octave_value any (int = 0) const
     {
       return (scalar != Complex (0, 0)
-	      && ! (lo_ieee_isnan (std::real (scalar))
-		    || lo_ieee_isnan (std::imag (scalar))));
+              && ! (lo_ieee_isnan (std::real (scalar))
+                    || lo_ieee_isnan (std::imag (scalar))));
     }
 
   builtin_type_t builtin_type (void) const { return btyp_complex; }
 
   bool is_complex_scalar (void) const { return true; }
 
   bool is_complex_type (void) const { return true; }
 
@@ -162,31 +162,31 @@ public:
 
   bool save_ascii (std::ostream& os);
 
   bool load_ascii (std::istream& is);
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap, 
-		    oct_mach_info::float_format fmt);
+                    oct_mach_info::float_format fmt);
 
 #if defined (HAVE_HDF5)
   bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
 
   bool load_hdf5 (hid_t loc_id, const char *name);
 #endif
 
   int write (octave_stream& os, int block_size,
-	     oct_data_conv::data_type output_type, int skip,
-	     oct_mach_info::float_format flt_fmt) const
+             oct_data_conv::data_type output_type, int skip,
+             oct_mach_info::float_format flt_fmt) const
     {
       // Yes, for compatibility, we drop the imaginary part here.
       return os.write (array_value (true), block_size, output_type,
-		       skip, flt_fmt);
+                       skip, flt_fmt);
     }
 
   mxArray *as_mxArray (void) const;
 
   octave_value map (unary_mapper_t umap) const;
 
 private:
 
diff --git a/src/ov-cx-diag.h b/src/ov-cx-diag.h
--- a/src/ov-cx-diag.h
+++ b/src/ov-cx-diag.h
@@ -73,17 +73,17 @@ public:
 
   ComplexDiagMatrix complex_diag_matrix_value (bool = false) const;
 
   FloatComplexDiagMatrix float_complex_diag_matrix_value (bool = false) const;
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap, 
-		    oct_mach_info::float_format fmt);
+                    oct_mach_info::float_format fmt);
 
   octave_value map (unary_mapper_t umap) const;
 
 private:
 
   bool chk_valid_scalar (const octave_value&, 
                          Complex&) const;
 
diff --git a/src/ov-cx-mat.h b/src/ov-cx-mat.h
--- a/src/ov-cx-mat.h
+++ b/src/ov-cx-mat.h
@@ -144,31 +144,31 @@ public:
 
   bool save_ascii (std::ostream& os);
 
   bool load_ascii (std::istream& is);
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap, 
-		    oct_mach_info::float_format fmt);
+                    oct_mach_info::float_format fmt);
 
 #if defined (HAVE_HDF5)
   bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
 
   bool load_hdf5 (hid_t loc_id, const char *name);
 #endif
 
   int write (octave_stream& os, int block_size,
-	     oct_data_conv::data_type output_type, int skip,
-	     oct_mach_info::float_format flt_fmt) const
+             oct_data_conv::data_type output_type, int skip,
+             oct_mach_info::float_format flt_fmt) const
     {
       // Yes, for compatibility, we drop the imaginary part here.
       return os.write (matrix_value (true), block_size, output_type,
-		       skip, flt_fmt);
+                       skip, flt_fmt);
     }
 
   void print_raw (std::ostream& os, bool pr_as_read_syntax = false) const;
 
   mxArray *as_mxArray (void) const;
 
   octave_value map (unary_mapper_t umap) const;
 
diff --git a/src/ov-cx-sparse.h b/src/ov-cx-sparse.h
--- a/src/ov-cx-sparse.h
+++ b/src/ov-cx-sparse.h
@@ -61,28 +61,28 @@ public:
 
   octave_sparse_complex_matrix (const ComplexMatrix& m)
     : octave_base_sparse<SparseComplexMatrix> (SparseComplexMatrix (m)) { }
 
   octave_sparse_complex_matrix (const SparseComplexMatrix& m)
     : octave_base_sparse<SparseComplexMatrix> (m) { }
 
   octave_sparse_complex_matrix (const SparseComplexMatrix& m, 
-				const MatrixType &t)
+                                const MatrixType &t)
     : octave_base_sparse<SparseComplexMatrix> (m, t) { }
 
   octave_sparse_complex_matrix (const MSparse<Complex>& m)
     : octave_base_sparse<SparseComplexMatrix> (m) { }
 
   octave_sparse_complex_matrix (const MSparse<Complex>& m, 
-				const MatrixType &t)
+                                const MatrixType &t)
     : octave_base_sparse<SparseComplexMatrix> (m, t) { }
 
   octave_sparse_complex_matrix (const Sparse<Complex>& m, 
-				const MatrixType &t)
+                                const MatrixType &t)
     : octave_base_sparse<SparseComplexMatrix> (SparseComplexMatrix (m), t) { }
 
   octave_sparse_complex_matrix (const Sparse<Complex>& m)
     : octave_base_sparse<SparseComplexMatrix> (SparseComplexMatrix (m)) { }
 
   octave_sparse_complex_matrix (const octave_sparse_complex_matrix& cm)
     : octave_base_sparse<SparseComplexMatrix> (cm) { }
 
@@ -126,29 +126,29 @@ public:
 
   SparseComplexMatrix sparse_complex_matrix_value (bool = false) const
     { return matrix; }
 
   SparseBoolMatrix sparse_bool_matrix_value (bool warn = false) const;
 
 #if 0
   int write (octave_stream& os, int block_size,
-	     oct_data_conv::data_type output_type, int skip,
-	     oct_mach_info::float_format flt_fmt) const
+             oct_data_conv::data_type output_type, int skip,
+             oct_mach_info::float_format flt_fmt) const
     {
       // Yes, for compatibility, we drop the imaginary part here.
       return os.write (matrix_value (true), block_size, output_type,
-		       skip, flt_fmt);
+                       skip, flt_fmt);
     }
 #endif
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap, 
-		    oct_mach_info::float_format fmt);
+                    oct_mach_info::float_format fmt);
 
 #if defined (HAVE_HDF5)
   bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
 
   bool load_hdf5 (hid_t loc_id, const char *name);
 #endif
 
   mxArray *as_mxArray (void) const;
diff --git a/src/ov-dld-fcn.h b/src/ov-dld-fcn.h
--- a/src/ov-dld-fcn.h
+++ b/src/ov-dld-fcn.h
@@ -43,18 +43,18 @@ class
 OCTINTERP_API
 octave_dld_function : public octave_builtin
 {
 public:
 
   octave_dld_function (void) { }
 
   octave_dld_function (octave_builtin::fcn ff, const octave_shlib& shl,
-		       const std::string& nm = std::string (),
-		       const std::string& ds = std::string ());
+                       const std::string& nm = std::string (),
+                       const std::string& ds = std::string ());
 
   ~octave_dld_function (void);
 
   void mark_fcn_file_up_to_date (const octave_time& t) { t_checked = t; }
 
   std::string fcn_file_name (void) const;
 
   octave_time time_parsed (void) const;
diff --git a/src/ov-fcn-handle.h b/src/ov-fcn-handle.h
--- a/src/ov-fcn-handle.h
+++ b/src/ov-fcn-handle.h
@@ -68,25 +68,25 @@ public:
    }
 
   ~octave_fcn_handle (void) { }
 
   octave_base_value *clone (void) const { return new octave_fcn_handle (*this); }
   octave_base_value *empty_clone (void) const { return new octave_fcn_handle (); }
 
   octave_value subsref (const std::string& type,
-			const std::list<octave_value_list>& idx)
+                        const std::list<octave_value_list>& idx)
     {
       octave_value_list tmp = subsref (type, idx, 1);
       return tmp.length () > 0 ? tmp(0) : octave_value ();
     }
 
   octave_value_list subsref (const std::string& type,
-			     const std::list<octave_value_list>& idx,
-			     int nargout);
+                             const std::list<octave_value_list>& idx,
+                             int nargout);
 
   octave_value_list
   do_multi_index_op (int nargout, const octave_value_list& args);
 
   bool is_defined (void) const { return true; }
 
   bool is_function_handle (void) const { return true; }
 
@@ -110,17 +110,17 @@ public:
 
   bool save_ascii (std::ostream& os);
 
   bool load_ascii (std::istream& is);
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap, 
-		    oct_mach_info::float_format fmt);
+                    oct_mach_info::float_format fmt);
 
 #if defined (HAVE_HDF5)
   bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
 
   bool load_hdf5 (hid_t loc_id, const char *name);
 #endif
 
   void print (std::ostream& os, bool pr_as_read_syntax = false) const;
diff --git a/src/ov-fcn-inline.h b/src/ov-fcn-inline.h
--- a/src/ov-fcn-inline.h
+++ b/src/ov-fcn-inline.h
@@ -42,17 +42,17 @@ OCTINTERP_API
 octave_fcn_inline : public octave_fcn_handle
 {
 public:
 
   octave_fcn_inline (void)
     : octave_fcn_handle (), iftext (), ifargs () { }
 
   octave_fcn_inline (const std::string& f, const string_vector& a, 
-		     const std::string& n = std::string ());
+                     const std::string& n = std::string ());
 
   octave_fcn_inline (const octave_fcn_inline& fi)
     : octave_fcn_handle (fi), iftext (fi.iftext), ifargs (fi.ifargs) { }
 
   ~octave_fcn_inline (void) { }
 
   octave_base_value *clone (void) const { return new octave_fcn_inline (*this); }
   octave_base_value *empty_clone (void) const { return new octave_fcn_inline (); }
@@ -71,17 +71,17 @@ public:
 
   bool save_ascii (std::ostream& os);
 
   bool load_ascii (std::istream& is);
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap, 
-		    oct_mach_info::float_format fmt);
+                    oct_mach_info::float_format fmt);
 
 #if defined (HAVE_HDF5)
   bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
 
   bool load_hdf5 (hid_t loc_id, const char *name);
 #endif
 
   void print (std::ostream& os, bool pr_as_read_syntax = false) const;
diff --git a/src/ov-fcn.h b/src/ov-fcn.h
--- a/src/ov-fcn.h
+++ b/src/ov-fcn.h
@@ -135,17 +135,17 @@ public:
 
   virtual void unload (void) { }
 
   virtual void accept (tree_walker&) { }
 
 protected:
 
   octave_function (const std::string& nm,
-		   const std::string& ds = std::string ())
+                   const std::string& ds = std::string ())
     : relative (false), locked (false), private_function (false),
       xdispatch_class (), my_name (nm), my_dir_name (), doc (ds) { }
 
   // TRUE if this function was found from a relative path element.
   bool relative;
 
   // TRUE if this function is tagged so that it can't be cleared.
   bool locked;
diff --git a/src/ov-float.h b/src/ov-float.h
--- a/src/ov-float.h
+++ b/src/ov-float.h
@@ -70,17 +70,17 @@ public:
   octave_base_value *clone (void) const { return new octave_float_scalar (*this); }
 
   // We return an octave_matrix here instead of an octave_float_scalar so
   // that in expressions like A(2,2,2) = 2 (for A previously
   // undefined), A will be empty instead of a 1x1 object.
   octave_base_value *empty_clone (void) const { return new octave_matrix (); }
 
   octave_value do_index_op (const octave_value_list& idx,
-			    bool resize_ok = false);
+                            bool resize_ok = false);
 
   idx_vector index_vector (void) const { return idx_vector (scalar); }
 
   octave_value any (int = 0) const
     { return (scalar != 0 && ! lo_ieee_isnan (scalar)); }
 
   builtin_type_t builtin_type (void) const { return btyp_float; }
 
@@ -221,30 +221,30 @@ public:
 
   bool save_ascii (std::ostream& os);
 
   bool load_ascii (std::istream& is);
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap, 
-		    oct_mach_info::float_format fmt);
+                    oct_mach_info::float_format fmt);
 
 #if defined (HAVE_HDF5)
   bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
 
   bool load_hdf5 (hid_t loc_id, const char *name);
 #endif
 
   int write (octave_stream& os, int block_size,
-	     oct_data_conv::data_type output_type, int skip,
-	     oct_mach_info::float_format flt_fmt) const
+             oct_data_conv::data_type output_type, int skip,
+             oct_mach_info::float_format flt_fmt) const
     {
       return os.write (array_value (), block_size, output_type,
-		       skip, flt_fmt);
+                       skip, flt_fmt);
     }
 
   mxArray *as_mxArray (void) const;
 
   octave_value map (unary_mapper_t umap) const;
 
 private:
 
diff --git a/src/ov-flt-complex.h b/src/ov-flt-complex.h
--- a/src/ov-flt-complex.h
+++ b/src/ov-flt-complex.h
@@ -72,23 +72,23 @@ public:
   // (for A previously undefined), A will be empty instead of a 1x1
   // object.
   octave_base_value *empty_clone (void) const
     { return new octave_float_complex_matrix (); }
 
   octave_base_value *try_narrowing_conversion (void);
 
   octave_value do_index_op (const octave_value_list& idx,
-			    bool resize_ok = false);
+                            bool resize_ok = false);
 
   octave_value any (int = 0) const
     {
       return (scalar != FloatComplex (0, 0)
-	      && ! (lo_ieee_isnan (std::real (scalar))
-		    || lo_ieee_isnan (std::imag (scalar))));
+              && ! (lo_ieee_isnan (std::real (scalar))
+                    || lo_ieee_isnan (std::imag (scalar))));
     }
 
   builtin_type_t builtin_type (void) const { return btyp_float_complex; }
 
   bool is_complex_scalar (void) const { return true; }
 
   bool is_complex_type (void) const { return true; }
 
@@ -160,31 +160,31 @@ public:
 
   bool save_ascii (std::ostream& os);
 
   bool load_ascii (std::istream& is);
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap, 
-		    oct_mach_info::float_format fmt);
+                    oct_mach_info::float_format fmt);
 
 #if defined (HAVE_HDF5)
   bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
 
   bool load_hdf5 (hid_t loc_id, const char *name);
 #endif
 
   int write (octave_stream& os, int block_size,
-	     oct_data_conv::data_type output_type, int skip,
-	     oct_mach_info::float_format flt_fmt) const
+             oct_data_conv::data_type output_type, int skip,
+             oct_mach_info::float_format flt_fmt) const
     {
       // Yes, for compatibility, we drop the imaginary part here.
       return os.write (array_value (true), block_size, output_type,
-		       skip, flt_fmt);
+                       skip, flt_fmt);
     }
 
   mxArray *as_mxArray (void) const;
 
   octave_value map (unary_mapper_t umap) const;
 
 private:
 
diff --git a/src/ov-flt-cx-diag.h b/src/ov-flt-cx-diag.h
--- a/src/ov-flt-cx-diag.h
+++ b/src/ov-flt-cx-diag.h
@@ -71,17 +71,17 @@ public:
 
   ComplexDiagMatrix complex_diag_matrix_value (bool = false) const;
 
   FloatComplexDiagMatrix float_complex_diag_matrix_value (bool = false) const;
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap, 
-		    oct_mach_info::float_format fmt);
+                    oct_mach_info::float_format fmt);
 
   octave_value map (unary_mapper_t umap) const;
 
 private:
 
   bool chk_valid_scalar (const octave_value&, 
                          FloatComplex&) const;
 
diff --git a/src/ov-flt-cx-mat.h b/src/ov-flt-cx-mat.h
--- a/src/ov-flt-cx-mat.h
+++ b/src/ov-flt-cx-mat.h
@@ -142,31 +142,31 @@ public:
 
   bool save_ascii (std::ostream& os);
 
   bool load_ascii (std::istream& is);
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap, 
-		    oct_mach_info::float_format fmt);
+                    oct_mach_info::float_format fmt);
 
 #if defined (HAVE_HDF5)
   bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
 
   bool load_hdf5 (hid_t loc_id, const char *name);
 #endif
 
   int write (octave_stream& os, int block_size,
-	     oct_data_conv::data_type output_type, int skip,
-	     oct_mach_info::float_format flt_fmt) const
+             oct_data_conv::data_type output_type, int skip,
+             oct_mach_info::float_format flt_fmt) const
     {
       // Yes, for compatibility, we drop the imaginary part here.
       return os.write (matrix_value (true), block_size, output_type,
-		       skip, flt_fmt);
+                       skip, flt_fmt);
     }
 
   void print_raw (std::ostream& os, bool pr_as_read_syntax = false) const;
 
   mxArray *as_mxArray (void) const;
 
   octave_value map (unary_mapper_t umap) const;
 
diff --git a/src/ov-flt-re-diag.h b/src/ov-flt-re-diag.h
--- a/src/ov-flt-re-diag.h
+++ b/src/ov-flt-re-diag.h
@@ -71,17 +71,17 @@ public:
 
   ComplexDiagMatrix complex_diag_matrix_value (bool = false) const;
 
   FloatComplexDiagMatrix float_complex_diag_matrix_value (bool = false) const;
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap, 
-		    oct_mach_info::float_format fmt);
+                    oct_mach_info::float_format fmt);
 
   octave_value map (unary_mapper_t umap) const;
 
 private:
 
   bool chk_valid_scalar (const octave_value&, 
                          float&) const;
 
diff --git a/src/ov-flt-re-mat.h b/src/ov-flt-re-mat.h
--- a/src/ov-flt-re-mat.h
+++ b/src/ov-flt-re-mat.h
@@ -178,27 +178,27 @@ public:
 
   bool save_ascii (std::ostream& os);
 
   bool load_ascii (std::istream& is);
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap, 
-		    oct_mach_info::float_format fmt);
+                    oct_mach_info::float_format fmt);
 
 #if defined (HAVE_HDF5)
   bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
 
   bool load_hdf5 (hid_t loc_id, const char *name);
 #endif
 
   int write (octave_stream& os, int block_size,
-	     oct_data_conv::data_type output_type, int skip,
-	     oct_mach_info::float_format flt_fmt) const
+             oct_data_conv::data_type output_type, int skip,
+             oct_mach_info::float_format flt_fmt) const
     { return os.write (matrix, block_size, output_type, skip, flt_fmt); }
 
   // Unsafe.  This function exists to support the MEX interface.
   // You should not use it anywhere else.
   void *mex_get_data (void) const { return matrix.mex_get_data (); }
 
   mxArray *as_mxArray (void) const;
 
diff --git a/src/ov-intx.h b/src/ov-intx.h
--- a/src/ov-intx.h
+++ b/src/ov-intx.h
@@ -75,18 +75,18 @@ private:
   template <class IM>
   IM convert_gripe () const
     {
       typedef typename IM::element_type dest_el_type;
       typedef intNDArray<OCTAVE_INT_T>::element_type src_el_type;
       dest_el_type::clear_conv_flag ();
       IM retval (matrix);
       if (dest_el_type::get_trunc_flag ())
-	gripe_truncated_conversion (src_el_type::type_name (),
-				    dest_el_type::type_name ());
+        gripe_truncated_conversion (src_el_type::type_name (),
+                                    dest_el_type::type_name ());
       dest_el_type::clear_conv_flag ();
       return retval;
     }
 
 public:
 
   int8NDArray
   int8_array_value (void) const { return convert_gripe<int8NDArray> (); }
@@ -113,121 +113,121 @@ public:
   uint64_array_value (void) const { return convert_gripe<uint64NDArray> (); }
 
   double
   double_value (bool = false) const
     {
       double retval = lo_ieee_nan_value ();
 
       if (numel () > 0)
-	{
-	  gripe_implicit_conversion ("Octave:array-as-scalar",
-				     type_name (), "real scalar");
+        {
+          gripe_implicit_conversion ("Octave:array-as-scalar",
+                                     type_name (), "real scalar");
 
-	  retval = matrix(0).double_value ();
-	}
+          retval = matrix(0).double_value ();
+        }
       else
-	gripe_invalid_conversion (type_name (), "real scalar");
+        gripe_invalid_conversion (type_name (), "real scalar");
 
       return retval;
       
     }
 
   float
   float_value (bool = false) const
     {
       float retval = lo_ieee_float_nan_value ();
 
       if (numel () > 0)
-	{
-	  gripe_implicit_conversion ("Octave:array-as-scalar",
-				     type_name (), "real scalar");
+        {
+          gripe_implicit_conversion ("Octave:array-as-scalar",
+                                     type_name (), "real scalar");
 
-	  retval = matrix(0).float_value ();
-	}
+          retval = matrix(0).float_value ();
+        }
       else
-	gripe_invalid_conversion (type_name (), "real scalar");
+        gripe_invalid_conversion (type_name (), "real scalar");
 
       return retval;
       
     }
 
   double scalar_value (bool = false) const { return double_value (); }
 
   float float_scalar_value (bool = false) const { return float_value (); }
 
   Matrix
   matrix_value (bool = false) const
     {
       Matrix retval;
       dim_vector dv = dims ();
       if (dv.length () > 2)
-	error ("invalid conversion of %s to Matrix", type_name().c_str ());
+        error ("invalid conversion of %s to Matrix", type_name().c_str ());
       else
-	{
-	  retval = Matrix (dv(0), dv(1));
-	  double *vec = retval.fortran_vec ();
-	  octave_idx_type nel = matrix.numel ();
-	  for (octave_idx_type i = 0; i < nel; i++)
-	    vec[i] = matrix(i).double_value ();
-	}
+        {
+          retval = Matrix (dv(0), dv(1));
+          double *vec = retval.fortran_vec ();
+          octave_idx_type nel = matrix.numel ();
+          for (octave_idx_type i = 0; i < nel; i++)
+            vec[i] = matrix(i).double_value ();
+        }
       return retval;
     }
 
   FloatMatrix
   float_matrix_value (bool = false) const
     {
       FloatMatrix retval;
       dim_vector dv = dims ();
       if (dv.length () > 2)
-	error ("invalid conversion of %s to FloatMatrix", type_name().c_str ());
+        error ("invalid conversion of %s to FloatMatrix", type_name().c_str ());
       else
-	{
-	  retval = FloatMatrix (dv(0), dv(1));
-	  float *vec = retval.fortran_vec ();
-	  octave_idx_type nel = matrix.numel ();
-	  for (octave_idx_type i = 0; i < nel; i++)
-	    vec[i] = matrix(i).float_value ();
-	}
+        {
+          retval = FloatMatrix (dv(0), dv(1));
+          float *vec = retval.fortran_vec ();
+          octave_idx_type nel = matrix.numel ();
+          for (octave_idx_type i = 0; i < nel; i++)
+            vec[i] = matrix(i).float_value ();
+        }
       return retval;
     }
 
   ComplexMatrix
   complex_matrix_value (bool = false) const
     {
       ComplexMatrix retval;
       dim_vector dv = dims();
       if (dv.length () > 2)
-	error ("invalid conversion of %s to Matrix", type_name().c_str ());
+        error ("invalid conversion of %s to Matrix", type_name().c_str ());
       else
-	{
-	  retval = ComplexMatrix (dv(0), dv(1));
-	  Complex *vec = retval.fortran_vec ();
-	  octave_idx_type nel = matrix.numel ();
-	  for (octave_idx_type i = 0; i < nel; i++)
-	    vec[i] = Complex (matrix(i).double_value ());
-	}
+        {
+          retval = ComplexMatrix (dv(0), dv(1));
+          Complex *vec = retval.fortran_vec ();
+          octave_idx_type nel = matrix.numel ();
+          for (octave_idx_type i = 0; i < nel; i++)
+            vec[i] = Complex (matrix(i).double_value ());
+        }
       return retval;
     }
 
   FloatComplexMatrix
   float_complex_matrix_value (bool = false) const
     {
       FloatComplexMatrix retval;
       dim_vector dv = dims();
       if (dv.length () > 2)
-	error ("invalid conversion of %s to FloatMatrix", type_name().c_str ());
+        error ("invalid conversion of %s to FloatMatrix", type_name().c_str ());
       else
-	{
-	  retval = FloatComplexMatrix (dv(0), dv(1));
-	  FloatComplex *vec = retval.fortran_vec ();
-	  octave_idx_type nel = matrix.numel ();
-	  for (octave_idx_type i = 0; i < nel; i++)
-	    vec[i] = FloatComplex (matrix(i).float_value ());
-	}
+        {
+          retval = FloatComplexMatrix (dv(0), dv(1));
+          FloatComplex *vec = retval.fortran_vec ();
+          octave_idx_type nel = matrix.numel ();
+          for (octave_idx_type i = 0; i < nel; i++)
+            vec[i] = FloatComplex (matrix(i).float_value ());
+        }
       return retval;
     }
 
   NDArray
   array_value (bool = false) const
     { 
       NDArray retval (matrix.dims ()); 
       double *vec = retval.fortran_vec ();
@@ -326,18 +326,18 @@ public:
        gripe_unop_integer_math_truncated ("-", type_name (). c_str ());
       OCTAVE_INT_T::clear_conv_flag ();
    }
 
   idx_vector index_vector (void) const 
     { return idx_cache ? *idx_cache : set_idx_cache (idx_vector (matrix)); }
 
   int write (octave_stream& os, int block_size,
-	     oct_data_conv::data_type output_type, int skip,
-	     oct_mach_info::float_format flt_fmt) const
+             oct_data_conv::data_type output_type, int skip,
+             oct_mach_info::float_format flt_fmt) const
     { return os.write (matrix, block_size, output_type, skip, flt_fmt); }
 
   // Unsafe.  This function exists to support the MEX interface.
   // You should not use it anywhere else.
   void *mex_get_data (void) const { return matrix.mex_get_data (); }
 
   mxArray *as_mxArray (void) const
   {
@@ -411,17 +411,17 @@ public:
 
   octave_base_value *clone (void) const
     { return new OCTAVE_VALUE_INT_SCALAR_T (*this); }
 
   octave_base_value *empty_clone (void) const
     { return new OCTAVE_VALUE_INT_MATRIX_T (); }
 
   octave_value do_index_op (const octave_value_list& idx,
-			    bool resize_ok = false)
+                            bool resize_ok = false)
     {
       // FIXME -- this doesn't solve the problem of
       //
       //   a = 1; a([1,1], [1,1], [1,1])
       //
       // and similar constructions.  Hmm...
 
       // FIXME -- using this constructor avoids narrowing the
@@ -447,18 +447,18 @@ private:
   IS convert_gripe () const
     {
       typedef IS dest_el_type;
       typedef OCTAVE_INT_T src_el_type;
       dest_el_type::clear_conv_flag ();
       IS retval (scalar);
 
       if (dest_el_type::get_trunc_flag ())
-	gripe_truncated_conversion (src_el_type::type_name (),
-				    dest_el_type::type_name ());
+        gripe_truncated_conversion (src_el_type::type_name (),
+                                    dest_el_type::type_name ());
       dest_el_type::clear_conv_flag ();
       return retval;
     }
 
 public:
 
   octave_int8
   int8_scalar_value (void) const { return convert_gripe<octave_int8> (); }
@@ -514,29 +514,29 @@ public:
 
   uint64NDArray
   uint64_array_value (void) const
     { return uint64NDArray (dim_vector (1, 1), uint64_scalar_value ()); }
 
   octave_value resize (const dim_vector& dv, bool fill = false) const
     {
       if (fill)
-	{
-	  intNDArray<OCTAVE_INT_T> retval (dv, 0);
-	  if (dv.numel())
-	    retval(0) = scalar;
-	  return retval;
-	}
+        {
+          intNDArray<OCTAVE_INT_T> retval (dv, 0);
+          if (dv.numel())
+            retval(0) = scalar;
+          return retval;
+        }
       else
-	{
-	  intNDArray<OCTAVE_INT_T> retval (dv);
-	  if (dv.numel())
-	    retval(0) = scalar;
-	  return retval;
-	}
+        {
+          intNDArray<OCTAVE_INT_T> retval (dv);
+          if (dv.numel())
+            retval(0) = scalar;
+          return retval;
+        }
     }
 
   double double_value (bool = false) const { return scalar.double_value (); }
 
   float float_value (bool = false) const { return scalar.float_value (); }
 
   double scalar_value (bool = false) const { return scalar.double_value (); }
 
@@ -641,21 +641,21 @@ public:
      if (OCTAVE_INT_T::get_math_trunc_flag ())
        gripe_unop_integer_math_truncated ("--", type_name (). c_str ());
       OCTAVE_INT_T::clear_conv_flag ();
    }
 
   idx_vector index_vector (void) const { return idx_vector (scalar); }
 
   int write (octave_stream& os, int block_size,
-	     oct_data_conv::data_type output_type, octave_idx_type skip,
-	     oct_mach_info::float_format flt_fmt) const
+             oct_data_conv::data_type output_type, octave_idx_type skip,
+             oct_mach_info::float_format flt_fmt) const
     {
       return os.write (OCTAVE_VALUE_INT_NDARRAY_EXTRACTOR_FUNCTION (),
-		       block_size, output_type, skip, flt_fmt);
+                       block_size, output_type, skip, flt_fmt);
     }
 
   // Unsafe.  This function exists to support the MEX interface.
   // You should not use it anywhere else.
   void *mex_get_data (void) const { return scalar.mex_get_data (); }
 
   mxArray *as_mxArray (void) const
   {
diff --git a/src/ov-mex-fcn.h b/src/ov-mex-fcn.h
--- a/src/ov-mex-fcn.h
+++ b/src/ov-mex-fcn.h
@@ -41,30 +41,30 @@ class octave_value_list;
 class
 octave_mex_function : public octave_function
 {
 public:
 
   octave_mex_function (void) { }
 
   octave_mex_function (void *fptr, bool fmex, const octave_shlib& shl,
-		       const std::string& nm = std::string ());
+                       const std::string& nm = std::string ());
 
   ~octave_mex_function (void);
 
   octave_value subsref (const std::string& type,
-			const std::list<octave_value_list>& idx)
+                        const std::list<octave_value_list>& idx)
     {
       octave_value_list tmp = subsref (type, idx, 1);
       return tmp.length () > 0 ? tmp(0) : octave_value ();
     }
 
   octave_value_list subsref (const std::string& type,
-			     const std::list<octave_value_list>& idx,
-			     int nargout);
+                             const std::list<octave_value_list>& idx,
+                             int nargout);
 
   octave_function *function_value (bool = false) { return this; }
 
   const octave_function *function_value (bool = false) const { return this; }
 
   void mark_fcn_file_up_to_date (const octave_time& t) { t_checked = t; }
 
   std::string fcn_file_name (void) const;
diff --git a/src/ov-perm.h b/src/ov-perm.h
--- a/src/ov-perm.h
+++ b/src/ov-perm.h
@@ -48,24 +48,24 @@ public:
 
   size_t byte_size (void) const { return matrix.byte_size (); }
 
   octave_value squeeze (void) const { return matrix; }
 
   octave_value full_value (void) const { return to_dense (); }
 
   octave_value subsref (const std::string& type,
-			const std::list<octave_value_list>& idx);
+                        const std::list<octave_value_list>& idx);
 
   octave_value_list subsref (const std::string& type,
-			     const std::list<octave_value_list>& idx, int)
+                             const std::list<octave_value_list>& idx, int)
     { return subsref (type, idx); }
 
   octave_value do_index_op (const octave_value_list& idx,
-			    bool resize_ok = false);
+                            bool resize_ok = false);
 
   dim_vector dims (void) const { return matrix.dims (); }
 
   octave_idx_type nnz (void) const { return matrix.rows (); }
 
   octave_value reshape (const dim_vector& new_dims) const
     { return to_dense ().reshape (new_dims); }
 
@@ -83,17 +83,17 @@ public:
     { return matrix_type (); }
 
   octave_value diag (octave_idx_type k = 0) const
     { return to_dense () .diag (k); }
 
   octave_value sort (octave_idx_type dim = 0, sortmode mode = ASCENDING) const
     { return to_dense ().sort (dim, mode); }
   octave_value sort (Array<octave_idx_type> &sidx, octave_idx_type dim = 0,
-		     sortmode mode = ASCENDING) const
+                     sortmode mode = ASCENDING) const
     { return to_dense ().sort (sidx, dim, mode); }
 
   sortmode is_sorted (sortmode mode = UNSORTED) const
     { return to_dense ().is_sorted (mode); }
 
   Array<octave_idx_type> sort_rows_idx (sortmode mode = ASCENDING) const
     { return to_dense ().sort_rows_idx (mode); }
 
@@ -192,21 +192,21 @@ public:
 
   bool save_ascii (std::ostream& os);
 
   bool load_ascii (std::istream& is);
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap, 
-		    oct_mach_info::float_format fmt);
+                    oct_mach_info::float_format fmt);
 
   int write (octave_stream& os, int block_size,
-	     oct_data_conv::data_type output_type, int skip,
-	     oct_mach_info::float_format flt_fmt) const;
+             oct_data_conv::data_type output_type, int skip,
+             oct_mach_info::float_format flt_fmt) const;
 
   mxArray *as_mxArray (void) const;
 
   bool print_as_scalar (void) const;
 
   void print (std::ostream& os, bool pr_as_read_syntax = false) const;
 
   void print_info (std::ostream& os, const std::string& prefix) const;
diff --git a/src/ov-range.h b/src/ov-range.h
--- a/src/ov-range.h
+++ b/src/ov-range.h
@@ -56,25 +56,25 @@ octave_range : public octave_base_value
 public:
 
   octave_range (void)
     : octave_base_value (), idx_cache () { }
 
   octave_range (double base, double limit, double inc)
     : octave_base_value (), range (base, limit, inc), idx_cache ()
       {
-	if (range.nelem () < 0)
-	  ::error ("invalid range");
+        if (range.nelem () < 0)
+          ::error ("invalid range");
       }
 
   octave_range (const Range& r)
     : octave_base_value (), range (r), idx_cache ()
       {
-	if (range.nelem () < 0 && range.nelem () != -2)
-	  ::error ("invalid range");
+        if (range.nelem () < 0 && range.nelem () != -2)
+          ::error ("invalid range");
       }
 
   octave_range (const octave_range& r)
     : octave_base_value (), range (r.range), 
       idx_cache (r.idx_cache ? new idx_vector (*r.idx_cache) : 0)
     { }
 
   octave_range (const Range& r, const idx_vector& cache)
@@ -92,24 +92,24 @@ public:
   // to create an empty matrix (0x0) instead of an empty range (1x0).
   octave_base_value *empty_clone (void) const { return new octave_matrix (); }
 
   type_conv_info numeric_conversion_function (void) const;
 
   octave_base_value *try_narrowing_conversion (void);
 
   octave_value subsref (const std::string& type,
-			const std::list<octave_value_list>& idx);
+                        const std::list<octave_value_list>& idx);
 
   octave_value_list subsref (const std::string& type,
-			     const std::list<octave_value_list>& idx, int)
+                             const std::list<octave_value_list>& idx, int)
     { return subsref (type, idx); }
 
   octave_value do_index_op (const octave_value_list& idx,
-			    bool resize_ok = false);
+                            bool resize_ok = false);
 
   idx_vector index_vector (void) const 
     { return idx_cache ? *idx_cache : set_idx_cache (idx_vector (range)); }
 
   dim_vector dims (void) const
     { 
       octave_idx_type n = range.nelem ();
       return dim_vector (n > 0, n);
@@ -141,17 +141,17 @@ public:
   octave_value any (int dim = 0) const;
 
   octave_value diag (octave_idx_type k = 0) const;
 
   octave_value sort (octave_idx_type dim = 0, sortmode mode = ASCENDING) const
     { return range.sort (dim, mode); }
 
   octave_value sort (Array<octave_idx_type>& sidx, octave_idx_type dim = 0,
-		     sortmode mode = ASCENDING) const
+                     sortmode mode = ASCENDING) const
     { return range.sort (sidx, dim, mode); }
 
   sortmode is_sorted (sortmode mode = UNSORTED) const
     { return range.is_sorted (mode); }
 
   Array<octave_idx_type> sort_rows_idx (sortmode) const
     { return Array<octave_idx_type> (1, 0); }
 
@@ -268,33 +268,33 @@ public:
 
   bool save_ascii (std::ostream& os);
 
   bool load_ascii (std::istream& is);
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap, 
-		    oct_mach_info::float_format fmt);
+                    oct_mach_info::float_format fmt);
 
 #if defined (HAVE_HDF5)
   bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
 
   bool load_hdf5 (hid_t loc_id, const char *name);
 #endif
 
   int write (octave_stream& os, int block_size,
-	     oct_data_conv::data_type output_type, int skip,
-	     oct_mach_info::float_format flt_fmt) const
+             oct_data_conv::data_type output_type, int skip,
+             oct_mach_info::float_format flt_fmt) const
     {
       // FIXME -- could be more memory efficient by having a
       // special case of the octave_stream::write method for ranges.
 
       return os.write (matrix_value (), block_size, output_type, skip,
-		       flt_fmt);
+                       flt_fmt);
     }
 
   mxArray *as_mxArray (void) const;
 
   octave_value map (unary_mapper_t umap) const
     {
       octave_matrix m (matrix_value ());
       return m.map (umap);
diff --git a/src/ov-re-diag.h b/src/ov-re-diag.h
--- a/src/ov-re-diag.h
+++ b/src/ov-re-diag.h
@@ -53,17 +53,17 @@ public:
 
   type_conv_info numeric_conversion_function (void) const;
 
   type_conv_info numeric_demotion_function (void) const;
 
   octave_base_value *try_narrowing_conversion (void);
 
   octave_value do_index_op (const octave_value_list& idx,
-			    bool resize_ok = false);
+                            bool resize_ok = false);
 
   builtin_type_t builtin_type (void) const { return btyp_double; }
 
   bool is_real_matrix (void) const { return true; }
 
   bool is_real_type (void) const { return true; }
 
   bool is_double_type (void) const { return true; }
@@ -76,17 +76,17 @@ public:
 
   ComplexDiagMatrix complex_diag_matrix_value (bool = false) const;
 
   FloatComplexDiagMatrix float_complex_diag_matrix_value (bool = false) const;
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap, 
-		    oct_mach_info::float_format fmt);
+                    oct_mach_info::float_format fmt);
 
   octave_value map (unary_mapper_t umap) const;
 
 private:
 
   bool chk_valid_scalar (const octave_value&, 
                          double&) const;
 
diff --git a/src/ov-re-mat.h b/src/ov-re-mat.h
--- a/src/ov-re-mat.h
+++ b/src/ov-re-mat.h
@@ -176,17 +176,17 @@ public:
   SparseMatrix sparse_matrix_value (bool = false) const;
 
   SparseComplexMatrix sparse_complex_matrix_value (bool = false) const;
 
   octave_value diag (octave_idx_type k = 0) const;
 
   octave_value sort (octave_idx_type dim = 0, sortmode mode = ASCENDING) const;
   octave_value sort (Array<octave_idx_type> &sidx, octave_idx_type dim = 0,
-		     sortmode mode = ASCENDING) const;
+                     sortmode mode = ASCENDING) const;
 
   // Use matrix_ref here to clear index cache.
   void increment (void) { matrix_ref () += 1.0; }
 
   void decrement (void) { matrix_ref () -= 1.0; }
 
   void changesign (void) { matrix_ref ().changesign (); }
 
@@ -196,27 +196,27 @@ public:
 
   bool save_ascii (std::ostream& os);
 
   bool load_ascii (std::istream& is);
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap, 
-		    oct_mach_info::float_format fmt);
+                    oct_mach_info::float_format fmt);
 
 #if defined (HAVE_HDF5)
   bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
 
   bool load_hdf5 (hid_t loc_id, const char *name);
 #endif
 
   int write (octave_stream& os, int block_size,
-	     oct_data_conv::data_type output_type, int skip,
-	     oct_mach_info::float_format flt_fmt) const
+             oct_data_conv::data_type output_type, int skip,
+             oct_mach_info::float_format flt_fmt) const
     { return os.write (matrix, block_size, output_type, skip, flt_fmt); }
 
   // Unsafe.  This function exists to support the MEX interface.
   // You should not use it anywhere else.
   void *mex_get_data (void) const { return matrix.mex_get_data (); }
 
   mxArray *as_mxArray (void) const;
 
diff --git a/src/ov-re-sparse.h b/src/ov-re-sparse.h
--- a/src/ov-re-sparse.h
+++ b/src/ov-re-sparse.h
@@ -129,25 +129,25 @@ public:
     { return SparseComplexMatrix (matrix); }
 
   SparseBoolMatrix sparse_bool_matrix_value (bool warn = false) const;
 
   octave_value convert_to_str_internal (bool pad, bool force, char type) const;
 
 #if 0
   int write (octave_stream& os, int block_size,
-	     oct_data_conv::data_type output_type, int skip,
-	     oct_mach_info::float_format flt_fmt) const
+             oct_data_conv::data_type output_type, int skip,
+             oct_mach_info::float_format flt_fmt) const
     { return os.write (matrix, block_size, output_type, skip, flt_fmt); }
 #endif
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap, 
-		    oct_mach_info::float_format fmt);
+                    oct_mach_info::float_format fmt);
 
 #if defined (HAVE_HDF5)
   bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
 
   bool load_hdf5 (hid_t loc_id, const char *name);
 #endif
 
   mxArray *as_mxArray (void) const;
diff --git a/src/ov-scalar.h b/src/ov-scalar.h
--- a/src/ov-scalar.h
+++ b/src/ov-scalar.h
@@ -69,17 +69,17 @@ public:
   octave_base_value *clone (void) const { return new octave_scalar (*this); }
 
   // We return an octave_matrix here instead of an octave_scalar so
   // that in expressions like A(2,2,2) = 2 (for A previously
   // undefined), A will be empty instead of a 1x1 object.
   octave_base_value *empty_clone (void) const { return new octave_matrix (); }
 
   octave_value do_index_op (const octave_value_list& idx,
-			    bool resize_ok = false);
+                            bool resize_ok = false);
 
   type_conv_info numeric_demotion_function (void) const;
 
   idx_vector index_vector (void) const { return idx_vector (scalar); }
 
   octave_value any (int = 0) const
     { return (scalar != 0 && ! lo_ieee_isnan (scalar)); }
 
@@ -222,30 +222,30 @@ public:
 
   bool save_ascii (std::ostream& os);
 
   bool load_ascii (std::istream& is);
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap, 
-		    oct_mach_info::float_format fmt);
+                    oct_mach_info::float_format fmt);
 
 #if defined (HAVE_HDF5)
   bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
 
   bool load_hdf5 (hid_t loc_id, const char *name);
 #endif
 
   int write (octave_stream& os, int block_size,
-	     oct_data_conv::data_type output_type, int skip,
-	     oct_mach_info::float_format flt_fmt) const
+             oct_data_conv::data_type output_type, int skip,
+             oct_mach_info::float_format flt_fmt) const
     {
       return os.write (array_value (), block_size, output_type,
-		       skip, flt_fmt);
+                       skip, flt_fmt);
     }
 
   mxArray *as_mxArray (void) const;
 
   octave_value map (unary_mapper_t umap) const;
 
 private:
 
diff --git a/src/ov-str-mat.h b/src/ov-str-mat.h
--- a/src/ov-str-mat.h
+++ b/src/ov-str-mat.h
@@ -83,17 +83,17 @@ public:
   ~octave_char_matrix_str (void) { }
 
   octave_base_value *clone (void) const { return new octave_char_matrix_str (*this); }
   octave_base_value *empty_clone (void) const { return new octave_char_matrix_str (); }
 
   type_conv_info numeric_conversion_function (void) const;
 
   octave_value do_index_op (const octave_value_list& idx,
-			    bool resize_ok = false)
+                            bool resize_ok = false)
     { return do_index_op_internal (idx, resize_ok); }
 
   octave_value squeeze (void) const
     { return octave_value (charNDArray (matrix.squeeze ())); }
 
   octave_value reshape (const dim_vector& new_dims) const
     { return octave_value (charNDArray (matrix.reshape (new_dims))); }
 
@@ -124,47 +124,47 @@ public:
   string_vector all_strings (bool pad = false) const;
 
   std::string string_value (bool force = false) const;
 
   octave_value sort (octave_idx_type dim = 0, sortmode mode = ASCENDING) const
     { return octave_value (matrix.sort (dim, mode)); }
 
   octave_value sort (Array<octave_idx_type> &sidx, octave_idx_type dim = 0,
-		     sortmode mode = ASCENDING) const
+                     sortmode mode = ASCENDING) const
     { return octave_value (matrix.sort (sidx, dim, mode)); }
 
   bool print_as_scalar (void) const { return (rows () <= 1); }
 
   void print_raw (std::ostream& os, bool pr_as_read_syntax = false) const;
 
   bool save_ascii (std::ostream& os);
 
   bool load_ascii (std::istream& is);
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap, 
-		    oct_mach_info::float_format fmt);
+                    oct_mach_info::float_format fmt);
 
 #if defined (HAVE_HDF5)
   bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
 
   bool load_hdf5 (hid_t loc_id, const char *name);
 #endif
 
   int write (octave_stream& os, int block_size,
-	     oct_data_conv::data_type output_type, int skip,
-	     oct_mach_info::float_format flt_fmt) const
+             oct_data_conv::data_type output_type, int skip,
+             oct_mach_info::float_format flt_fmt) const
     { return os.write (matrix, block_size, output_type, skip, flt_fmt); }
 
 protected:
 
   octave_value do_index_op_internal (const octave_value_list& idx,
-				     bool resize_ok, char type = '"');
+                                     bool resize_ok, char type = '"');
 
 private:
 
   DECLARE_OCTAVE_ALLOCATOR
 
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
@@ -224,25 +224,25 @@ public:
     }
 
   octave_value diag (octave_idx_type k = 0) const
     { return octave_value (matrix.diag (k), '\''); }
 
   bool is_sq_string (void) const { return true; }
 
   octave_value do_index_op (const octave_value_list& idx,
-			    bool resize_ok = false)
+                            bool resize_ok = false)
     { return do_index_op_internal (idx, resize_ok, '\''); }
 
 
   octave_value sort (octave_idx_type dim = 0, sortmode mode = ASCENDING) const
     { return octave_value (matrix.sort (dim, mode), '\''); }
 
   octave_value sort (Array<octave_idx_type> &sidx, octave_idx_type dim = 0,
-		     sortmode mode = ASCENDING) const
+                     sortmode mode = ASCENDING) const
     { return octave_value (matrix.sort (sidx, dim, mode), '\''); }
 
 private:
 
   DECLARE_OCTAVE_ALLOCATOR
 
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
diff --git a/src/ov-struct.h b/src/ov-struct.h
--- a/src/ov-struct.h
+++ b/src/ov-struct.h
@@ -61,43 +61,43 @@ public:
   ~octave_struct (void) { }
 
   octave_base_value *clone (void) const { return new octave_struct (*this); }
   octave_base_value *empty_clone (void) const { return new octave_struct (); }
 
   Cell dotref (const octave_value_list& idx, bool auto_add = false);
 
   octave_value subsref (const std::string& type,
-			const std::list<octave_value_list>& idx)
+                        const std::list<octave_value_list>& idx)
     {
       octave_value_list tmp = subsref (type, idx, 1);
       return tmp.length () > 0 ? tmp(0) : octave_value ();
     }
 
   octave_value_list subsref (const std::string&,
-			     const std::list<octave_value_list>&, int);
+                             const std::list<octave_value_list>&, int);
 
   octave_value subsref (const std::string& type,
-			const std::list<octave_value_list>& idx,
+                        const std::list<octave_value_list>& idx,
                         bool auto_add);
 
   static octave_value numeric_conv (const octave_value& val,
-				    const std::string& type);
+                                    const std::string& type);
 
   octave_value subsasgn (const std::string& type,
-			 const std::list<octave_value_list>& idx,
-			 const octave_value& rhs);
+                         const std::list<octave_value_list>& idx,
+                         const octave_value& rhs);
 
   octave_value squeeze (void) const { return map.squeeze (); }
 
   octave_value permute (const Array<int>& vec, bool inv = false) const
     { return map.permute (vec, inv); }
 
   octave_value do_index_op (const octave_value_list& idx,
-			    bool resize_ok = false);
+                            bool resize_ok = false);
 
   dim_vector dims (void) const { return map.dims (); }
 
   size_t byte_size (void) const;
 
   // This is the number of elements in each field.  The total number
   // of elements is numel () * nfields ().
   octave_idx_type numel (void) const
@@ -134,17 +134,17 @@ public:
 
   bool save_ascii (std::ostream& os);
 
   bool load_ascii (std::istream& is);
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap, 
-		    oct_mach_info::float_format fmt);
+                    oct_mach_info::float_format fmt);
 
 #if defined (HAVE_HDF5)
   bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
 
   bool load_hdf5 (hid_t loc_id, const char *name);
 #endif
 
   mxArray *as_mxArray (void) const;
diff --git a/src/ov-type-conv.h b/src/ov-type-conv.h
--- a/src/ov-type-conv.h
+++ b/src/ov-type-conv.h
@@ -99,11 +99,11 @@ octave_type_conv_body (const octave_valu
     } \
   else \
     print_usage (); \
  \
   return retval
 
 #define OCTAVE_TYPE_CONV_BODY(NAME) \
   OCTAVE_TYPE_CONV_BODY3 (NAME, octave_ ## NAME ## _matrix, \
-			  octave_ ## NAME ## _scalar)
+                          octave_ ## NAME ## _scalar)
 
 #endif
diff --git a/src/ov-typeinfo.h b/src/ov-typeinfo.h
--- a/src/ov-typeinfo.h
+++ b/src/ov-typeinfo.h
@@ -59,45 +59,45 @@ public:
     (octave_base_value&, const octave_value_list&, const octave_base_value&);
 
   typedef octave_value (*assignany_op_fcn)
     (octave_base_value&, const octave_value_list&, const octave_value&);
 
   static bool instance_ok (void);
 
   static int register_type (const std::string&, const std::string&,
-			    const octave_value&);
+                            const octave_value&);
 
   static bool register_unary_class_op (octave_value::unary_op,
-				       unary_class_op_fcn);
+                                       unary_class_op_fcn);
 
   static bool register_unary_op (octave_value::unary_op, int, unary_op_fcn);
 
   static bool register_non_const_unary_op (octave_value::unary_op, int,
-					   non_const_unary_op_fcn);
+                                           non_const_unary_op_fcn);
 
   static bool register_binary_class_op (octave_value::binary_op,
-					binary_class_op_fcn);
+                                        binary_class_op_fcn);
 
   static bool register_binary_op (octave_value::binary_op, int, int,
-				  binary_op_fcn);
+                                  binary_op_fcn);
 
   static bool register_binary_class_op (octave_value::compound_binary_op,
-					binary_class_op_fcn);
+                                        binary_class_op_fcn);
 
   static bool register_binary_op (octave_value::compound_binary_op, int, int,
-				  binary_op_fcn);
+                                  binary_op_fcn);
 
   static bool register_cat_op (int, int, cat_op_fcn);
 
   static bool register_assign_op (octave_value::assign_op, int, int,
-				  assign_op_fcn);
+                                  assign_op_fcn);
 
   static bool register_assignany_op (octave_value::assign_op, int,
-				     assignany_op_fcn);
+                                     assignany_op_fcn);
 
   static bool register_pref_assign_conv (int, int, int);
 
   static bool
   register_type_conv_op (int, int, octave_base_value::type_conv_fcn);
 
   static bool
   register_widening_op (int, int, octave_base_value::type_conv_fcn);
@@ -242,44 +242,44 @@ private:
 
   Array2<int> pref_assign_conv;
 
   Array2<void *> type_conv_ops;
 
   Array2<void *> widening_ops;
 
   int do_register_type (const std::string&, const std::string&,
-			const octave_value&);
+                        const octave_value&);
 
   bool do_register_unary_class_op (octave_value::unary_op, unary_class_op_fcn);
 
   bool do_register_unary_op (octave_value::unary_op, int, unary_op_fcn);
 
   bool do_register_non_const_unary_op (octave_value::unary_op, int,
-				       non_const_unary_op_fcn);
+                                       non_const_unary_op_fcn);
 
   bool do_register_binary_class_op (octave_value::binary_op,
-				    binary_class_op_fcn);
+                                    binary_class_op_fcn);
 
   bool do_register_binary_op (octave_value::binary_op, int, int,
-			      binary_op_fcn);
+                              binary_op_fcn);
 
   bool do_register_binary_class_op (octave_value::compound_binary_op,
-				    binary_class_op_fcn);
+                                    binary_class_op_fcn);
 
   bool do_register_binary_op (octave_value::compound_binary_op, int, int,
-			      binary_op_fcn);
+                              binary_op_fcn);
 
   bool do_register_cat_op (int, int, cat_op_fcn);
 
   bool do_register_assign_op (octave_value::assign_op, int, int,
-			      assign_op_fcn);
+                              assign_op_fcn);
 
   bool do_register_assignany_op (octave_value::assign_op, int,
-				 assignany_op_fcn);
+                                 assignany_op_fcn);
 
   bool do_register_pref_assign_conv (int, int, int);
 
   bool do_register_type_conv_op (int, int, octave_base_value::type_conv_fcn);
 
   bool do_register_widening_op (int, int, octave_base_value::type_conv_fcn);
 
   octave_value do_lookup_type (const std::string& nm);
diff --git a/src/ov-usr-fcn.h b/src/ov-usr-fcn.h
--- a/src/ov-usr-fcn.h
+++ b/src/ov-usr-fcn.h
@@ -54,17 +54,17 @@ public:
 
   bool is_user_code (void) const { return true; }
 
   virtual tree_statement_list *body (void) = 0;
 
 protected:
 
   octave_user_code (const std::string& nm,
-		    const std::string& ds = std::string ())
+                    const std::string& ds = std::string ())
     : octave_function (nm, ds) { }
 
 private:
 
   // No copying!
 
   octave_user_code (const octave_user_code& f);
 
@@ -76,21 +76,21 @@ private:
 class
 octave_user_script : public octave_user_code
 {
 public:
 
   octave_user_script (void);
 
   octave_user_script (const std::string& fnm, const std::string& nm,
-		      tree_statement_list *cmds,
-		      const std::string& ds = std::string ());
+                      tree_statement_list *cmds,
+                      const std::string& ds = std::string ());
 
   octave_user_script (const std::string& fnm, const std::string& nm,
-		      const std::string& ds = std::string ());
+                      const std::string& ds = std::string ());
 
   ~octave_user_script (void);
 
   octave_function *function_value (bool = false) { return this; }
 
   octave_user_script *user_script_value (bool = false) { return this; }
 
   octave_user_code *user_code_value (bool = false) { return this; }
@@ -112,25 +112,25 @@ public:
 
   std::string fcn_file_name (void) const { return file_name; }
 
   octave_time time_parsed (void) const { return t_parsed; }
 
   octave_time time_checked (void) const { return t_checked; }
 
   octave_value subsref (const std::string& type,
-			const std::list<octave_value_list>& idx)
+                        const std::list<octave_value_list>& idx)
     {
       octave_value_list tmp = subsref (type, idx, 1);
       return tmp.length () > 0 ? tmp(0) : octave_value ();
     }
 
   octave_value_list subsref (const std::string& type,
-			     const std::list<octave_value_list>& idx,
-			     int nargout);
+                             const std::list<octave_value_list>& idx,
+                             int nargout);
 
   octave_value_list
   do_multi_index_op (int nargout, const octave_value_list& args);
 
   tree_statement_list *body (void) { return cmd_list; }
 
   void accept (tree_walker& tw);
 
@@ -166,19 +166,19 @@ private:
 // User-defined functions.
 
 class
 octave_user_function : public octave_user_code
 {
 public:
 
   octave_user_function (symbol_table::scope_id sid = -1,
-			tree_parameter_list *pl = 0,
-			tree_parameter_list *rl = 0,
-			tree_statement_list *cl = 0);
+                        tree_parameter_list *pl = 0,
+                        tree_parameter_list *rl = 0,
+                        tree_statement_list *cl = 0);
 
   ~octave_user_function (void);
 
   octave_function *function_value (bool = false) { return this; }
 
   octave_user_function *user_function_value (bool = false) { return this; }
 
   octave_user_code *user_code_value (bool = false) { return this; }
@@ -252,25 +252,25 @@ public:
 
   bool is_class_constructor (void) const { return class_constructor; }
 
   void mark_as_class_method (void) { class_method = true; }
 
   bool is_class_method (void) const { return class_method; }
 
   octave_value subsref (const std::string& type,
-			const std::list<octave_value_list>& idx)
+                        const std::list<octave_value_list>& idx)
     {
       octave_value_list tmp = subsref (type, idx, 1);
       return tmp.length () > 0 ? tmp(0) : octave_value ();
     }
 
   octave_value_list subsref (const std::string& type,
-			     const std::list<octave_value_list>& idx,
-			     int nargout);
+                             const std::list<octave_value_list>& idx,
+                             int nargout);
 
   octave_value_list
   do_multi_index_op (int nargout, const octave_value_list& args);
 
   tree_parameter_list *parameter_list (void) { return param_list; }
 
   tree_parameter_list *return_list (void) { return ret_list; }
 
@@ -361,17 +361,17 @@ private:
   octave_value& varargin_varref;
 #endif
 
   void print_code_function_header (void);
 
   void print_code_function_trailer (void);
 
   void bind_automatic_vars (const string_vector& arg_names, int nargin,
-			    int nargout, const octave_value_list& va_args);
+                            int nargout, const octave_value_list& va_args);
 
   // No copying!
 
   octave_user_function (const octave_user_function& fn);
 
   octave_user_function& operator = (const octave_user_function& fn);
 
   DECLARE_OCTAVE_ALLOCATOR
diff --git a/src/ov.h b/src/ov.h
--- a/src/ov.h
+++ b/src/ov.h
@@ -151,17 +151,17 @@ public:
   static std::string binary_op_as_string (binary_op);
   static std::string binary_op_fcn_name (binary_op);
 
   static std::string binary_op_fcn_name (compound_binary_op);
 
   static std::string assign_op_as_string (assign_op);
 
   static octave_value empty_conv (const std::string& type,
-				  const octave_value& rhs = octave_value ());
+                                  const octave_value& rhs = octave_value ());
 
   enum magic_colon { magic_colon_t };
 
   octave_value (void)
     {
       static octave_base_value nil_rep;
       rep = &nil_rep;
       rep->count++;
@@ -222,32 +222,32 @@ public:
   octave_value (bool b);
   octave_value (const boolMatrix& bm, const MatrixType& t = MatrixType());
   octave_value (const boolNDArray& bnda);
   octave_value (const Array<bool>& bnda);
   octave_value (char c, char type = '\'');
   octave_value (const char *s, char type = '\'');
   octave_value (const std::string& s, char type = '\'');
   octave_value (const string_vector& s, char type = '\'');
-  octave_value (const charMatrix& chm, 	char type = '\'');
+  octave_value (const charMatrix& chm,  char type = '\'');
   octave_value (const charNDArray& chnda, char type = '\'');
   octave_value (const Array<char>& chnda, char type = '\'');
   octave_value (const charMatrix& chm, bool is_string,
-		char type = '\'') GCC_ATTR_DEPRECATED;
+                char type = '\'') GCC_ATTR_DEPRECATED;
   octave_value (const charNDArray& chnda, bool is_string,
-		char type = '\'') GCC_ATTR_DEPRECATED;
+                char type = '\'') GCC_ATTR_DEPRECATED;
   octave_value (const Array<char>& chnda, bool is_string,
-		char type = '\'') GCC_ATTR_DEPRECATED;
+                char type = '\'') GCC_ATTR_DEPRECATED;
   octave_value (const SparseMatrix& m, const MatrixType& t = MatrixType ());
   octave_value (const Sparse<double>& m, const MatrixType& t = MatrixType ());
   octave_value (const SparseComplexMatrix& m, 
-		const MatrixType& t = MatrixType ());
+                const MatrixType& t = MatrixType ());
   octave_value (const Sparse<Complex>& m, const MatrixType& t = MatrixType ());
   octave_value (const SparseBoolMatrix& bm, 
-		const MatrixType& t = MatrixType ());
+                const MatrixType& t = MatrixType ());
   octave_value (const Sparse<bool>& m, const MatrixType& t = MatrixType ());
   octave_value (const octave_int8& i);
   octave_value (const octave_int16& i);
   octave_value (const octave_int32& i);
   octave_value (const octave_int64& i);
   octave_value (const octave_uint8& i);
   octave_value (const octave_uint16& i);
   octave_value (const octave_uint32& i);
@@ -304,46 +304,46 @@ public:
   {
     if (--rep->count == 0)
       delete rep;
   }
 
   void make_unique (void)
     {
       if (rep->count > 1)
-	{
-	  --rep->count;
-	  rep = rep->unique_clone ();
-	}
+        {
+          --rep->count;
+          rep = rep->unique_clone ();
+        }
     }
 
   // This uniquifies the value if it is referenced by more than a certain
   // number of shallow copies. This is useful for optimizations where we
   // know a certain copy, typically within a cell array, to be obsolete.
   void make_unique (int obsolete_copies)
     {
       if (rep->count > obsolete_copies + 1)
-	{
-	  --rep->count;
-	  rep = rep->unique_clone ();
-	}
+        {
+          --rep->count;
+          rep = rep->unique_clone ();
+        }
     }
 
   // Simple assignment.
 
   octave_value& operator = (const octave_value& a)
     {
       if (rep != a.rep)
-	{
-	  if (--rep->count == 0)
-	    delete rep;
+        {
+          if (--rep->count == 0)
+            delete rep;
 
-	  rep = a.rep;
-	  rep->count++;
-	}
+          rep = a.rep;
+          rep->count++;
+        }
 
       return *this;
     }
 
   octave_idx_type get_count (void) const { return rep->count; }
 
   octave_base_value::type_conv_info numeric_conversion_function (void) const
     { return rep->numeric_conversion_function (); }
@@ -366,58 +366,58 @@ public:
   // Close to dims (), but can be overloaded for classes.
   Matrix size (void)
     { return rep->size (); }
 
   octave_idx_type numel (const octave_value_list& idx)
     { return rep->numel (idx); }
 
   octave_value single_subsref (const std::string& type,
-			       const octave_value_list& idx);
+                               const octave_value_list& idx);
 
   octave_value subsref (const std::string& type,
                         const std::list<octave_value_list>& idx)
     { return rep->subsref (type, idx); }
 
   octave_value subsref (const std::string& type,
                         const std::list<octave_value_list>& idx,
                         bool auto_add)
     { return rep->subsref (type, idx, auto_add); }
 
   octave_value_list subsref (const std::string& type,
                              const std::list<octave_value_list>& idx,
                              int nargout);
 
   octave_value next_subsref (const std::string& type, const
-			     std::list<octave_value_list>& idx,
-			     size_t skip = 1);
+                             std::list<octave_value_list>& idx,
+                             size_t skip = 1);
 
   octave_value_list next_subsref (int nargout,
-				  const std::string& type, const
-				  std::list<octave_value_list>& idx,
-				  size_t skip = 1);
+                                  const std::string& type, const
+                                  std::list<octave_value_list>& idx,
+                                  size_t skip = 1);
 
   octave_value next_subsref (bool auto_add, const std::string& type, const
-			     std::list<octave_value_list>& idx,
-			     size_t skip = 1);
+                             std::list<octave_value_list>& idx,
+                             size_t skip = 1);
 
   octave_value do_index_op (const octave_value_list& idx,
-			    bool resize_ok = false)
+                            bool resize_ok = false)
     { return rep->do_index_op (idx, resize_ok); }
 
   octave_value_list
   do_multi_index_op (int nargout, const octave_value_list& idx);
 
   octave_value subsasgn (const std::string& type,
-				 const std::list<octave_value_list>& idx,
-				 const octave_value& rhs);
+                                 const std::list<octave_value_list>& idx,
+                                 const octave_value& rhs);
 
   octave_value assign (assign_op op, const std::string& type,
-		       const std::list<octave_value_list>& idx,
-		       const octave_value& rhs);
+                       const std::list<octave_value_list>& idx,
+                       const octave_value& rhs);
 
   const octave_value& assign (assign_op, const octave_value& rhs);
 
   idx_vector index_vector (void) const
     { return rep->index_vector (); }
 
   // Size.
 
@@ -867,67 +867,67 @@ public:
 
   octave_fcn_handle *fcn_handle_value (bool silent = false) const;
 
   octave_fcn_inline *fcn_inline_value (bool silent = false) const;
 
   octave_value_list list_value (void) const;
 
   ColumnVector column_vector_value (bool frc_str_conv = false,
-			     bool frc_vec_conv = false) const;
+                             bool frc_vec_conv = false) const;
 
   ComplexColumnVector
   complex_column_vector_value (bool frc_str_conv = false,
-			bool frc_vec_conv = false) const;
+                        bool frc_vec_conv = false) const;
 
   RowVector row_vector_value (bool frc_str_conv = false,
-			      bool frc_vec_conv = false) const;
+                              bool frc_vec_conv = false) const;
 
   ComplexRowVector
   complex_row_vector_value (bool frc_str_conv = false,
-			    bool frc_vec_conv = false) const;
+                            bool frc_vec_conv = false) const;
 
 
   FloatColumnVector float_column_vector_value (bool frc_str_conv = false,
-			     bool frc_vec_conv = false) const;
+                             bool frc_vec_conv = false) const;
 
   FloatComplexColumnVector
   float_complex_column_vector_value (bool frc_str_conv = false,
-			bool frc_vec_conv = false) const;
+                        bool frc_vec_conv = false) const;
 
   FloatRowVector float_row_vector_value (bool frc_str_conv = false,
-			      bool frc_vec_conv = false) const;
+                              bool frc_vec_conv = false) const;
 
   FloatComplexRowVector
   float_complex_row_vector_value (bool frc_str_conv = false,
-			    bool frc_vec_conv = false) const;
+                            bool frc_vec_conv = false) const;
 
 
 
 
   Array<int> int_vector_value (bool req_int = false,
-			       bool frc_str_conv = false,
-			       bool frc_vec_conv = false) const;
+                               bool frc_str_conv = false,
+                               bool frc_vec_conv = false) const;
 
   Array<octave_idx_type>
   octave_idx_type_vector_value (bool req_int = false,
-				bool frc_str_conv = false,
-				bool frc_vec_conv = false) const;
+                                bool frc_str_conv = false,
+                                bool frc_vec_conv = false) const;
 
   Array<double> vector_value (bool frc_str_conv = false,
-			      bool frc_vec_conv = false) const;
+                              bool frc_vec_conv = false) const;
 
   Array<Complex> complex_vector_value (bool frc_str_conv = false,
-				       bool frc_vec_conv = false) const;
+                                       bool frc_vec_conv = false) const;
 
   Array<float> float_vector_value (bool frc_str_conv = false,
-			      bool frc_vec_conv = false) const;
+                              bool frc_vec_conv = false) const;
 
   Array<FloatComplex> float_complex_vector_value (bool frc_str_conv = false,
-				       bool frc_vec_conv = false) const;
+                                       bool frc_vec_conv = false) const;
 
   // Possibly economize a lazy-indexed value.
 
   void maybe_economize (void)
     { rep->maybe_economize (); }
 
   // The following two hook conversions are called on any octave_value prior to
   // storing it to a "permanent" location, like a named variable, a cell or a
@@ -940,102 +940,102 @@ public:
 
   void make_storable_value (void);
 
   // Conversions.  These should probably be private.  If a user of this
   // class wants a certain kind of constant, he should simply ask for
   // it, and we should convert it if possible.
 
   octave_value convert_to_str (bool pad = false, bool force = false,
-			       char type = '\'') const
+                               char type = '\'') const
     { return rep->convert_to_str (pad, force, type); }
 
   octave_value
   convert_to_str_internal (bool pad, bool force, char type) const
     { return rep->convert_to_str_internal (pad, force, type); }
 
   void convert_to_row_or_column_vector (void)
     { rep->convert_to_row_or_column_vector (); }
 
   bool print_as_scalar (void) const
     { return rep->print_as_scalar (); }
 
   void print (std::ostream& os, bool pr_as_read_syntax = false) const
     { rep->print (os, pr_as_read_syntax); }
 
   void print_raw (std::ostream& os,
-			  bool pr_as_read_syntax = false) const
+                          bool pr_as_read_syntax = false) const
     { rep->print_raw (os, pr_as_read_syntax); }
 
   bool print_name_tag (std::ostream& os, const std::string& name) const
     { return rep->print_name_tag (os, name); }
 
   void print_with_name (std::ostream& os, const std::string& name,
-			bool print_padding = true) const
+                        bool print_padding = true) const
     { rep->print_with_name (os, name, print_padding); }
 
   int type_id (void) const { return rep->type_id (); }
 
   std::string type_name (void) const { return rep->type_name (); }
 
   std::string class_name (void) const { return rep->class_name (); }
 
   // Unary and binary operations.
 
   friend OCTINTERP_API octave_value do_unary_op (unary_op op,
-				   const octave_value& a);
+                                   const octave_value& a);
 
   const octave_value& do_non_const_unary_op (unary_op op);
 
   void do_non_const_unary_op (unary_op op, const octave_value_list& idx);
 
   octave_value do_non_const_unary_op (unary_op op, const std::string& type,
-				      const std::list<octave_value_list>& idx);
+                                      const std::list<octave_value_list>& idx);
 
   friend OCTINTERP_API octave_value do_binary_op (binary_op op,
-				    const octave_value& a,
-				    const octave_value& b);
+                                    const octave_value& a,
+                                    const octave_value& b);
 
   friend OCTINTERP_API octave_value do_binary_op (compound_binary_op op,
                                                   const octave_value& a,
                                                   const octave_value& b);
 
   friend OCTINTERP_API octave_value do_cat_op (const octave_value& a,
-				 const octave_value& b,
-				 const Array<octave_idx_type>& ra_idx);
+                                 const octave_value& b,
+                                 const Array<octave_idx_type>& ra_idx);
 
   const octave_base_value& get_rep (void) const { return *rep; }
 
   bool is_copy_of (const octave_value &val) const { return rep == val.rep; }
 
   void print_info (std::ostream& os,
-			   const std::string& prefix = std::string ()) const;
+                           const std::string& prefix = std::string ()) const;
 
   bool save_ascii (std::ostream& os) { return rep->save_ascii (os); }
 
   bool load_ascii (std::istream& is) { return rep->load_ascii (is); }
 
   bool save_binary (std::ostream& os, bool& save_as_floats)
     { return rep->save_binary (os, save_as_floats); }
 
   bool load_binary (std::istream& is, bool swap,
-			    oct_mach_info::float_format fmt)
+                            oct_mach_info::float_format fmt)
     { return rep->load_binary (is, swap, fmt); }
 
 #if defined (HAVE_HDF5)
   bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats)
     { return rep->save_hdf5 (loc_id, name, save_as_floats); }
 
   bool load_hdf5 (hid_t loc_id, const char *name)
     { return rep->load_hdf5 (loc_id, name); }
 #endif
 
   int write (octave_stream& os, int block_size,
-		     oct_data_conv::data_type output_type, int skip,
-		     oct_mach_info::float_format flt_fmt) const;
+                     oct_data_conv::data_type output_type, int skip,
+                     oct_mach_info::float_format flt_fmt) const;
 
   octave_base_value *internal_rep (void) const { return rep; }
 
   // Unsafe.  These functions exist to support the MEX interface.
   // You should not use them anywhere else.
   void *mex_get_data (void) const { return rep->mex_get_data (); }
 
   octave_idx_type *mex_get_ir (void) const { return rep->mex_get_ir (); }
@@ -1045,17 +1045,17 @@ public:
   mxArray *as_mxArray (void) const { return rep->as_mxArray (); }
 
   octave_value diag (octave_idx_type k = 0) const
     { return rep->diag (k); }
 
   octave_value sort (octave_idx_type dim = 0, sortmode mode = ASCENDING) const
     { return rep->sort (dim, mode); } 
   octave_value sort (Array<octave_idx_type> &sidx, octave_idx_type dim = 0,
-		 sortmode mode = ASCENDING) const
+                 sortmode mode = ASCENDING) const
     { return rep->sort (sidx, dim, mode); } 
 
   sortmode is_sorted (sortmode mode = UNSORTED) const
     { return rep->is_sorted (mode); }
 
   Array<octave_idx_type> sort_rows_idx (sortmode mode = ASCENDING) const
     { return rep->sort_rows_idx (mode); }
 
@@ -1158,17 +1158,17 @@ private:
 
 // Publish externally used friend functions.
 
 extern OCTINTERP_API octave_value
 do_unary_op (octave_value::unary_op op, const octave_value& a);
 
 extern OCTINTERP_API octave_value
 do_binary_op (octave_value::binary_op op,
-	      const octave_value& a, const octave_value& b);
+              const octave_value& a, const octave_value& b);
 
 extern OCTINTERP_API octave_value
 do_binary_op (octave_value::compound_binary_op op,
               const octave_value& a, const octave_value& b);
 
 #define OV_UNOP_FN(name) \
   inline octave_value \
   name (const octave_value& a) \
diff --git a/src/parse.h b/src/parse.h
--- a/src/parse.h
+++ b/src/parse.h
@@ -66,39 +66,39 @@ extern bool input_from_startup_file;
 extern std::stack<symbol_table::scope_id> symtab_context;
 
 // Name of the current class when we are parsing class methods or
 // constructors.
 extern std::string current_class_name;
 
 extern OCTINTERP_API std::string
 get_help_from_file (const std::string& nm, bool& symbol_found,
-		    std::string& file);
+                    std::string& file);
 
 extern OCTINTERP_API std::string
 get_help_from_file (const std::string& nm, bool& symbol_found);
 
 extern OCTINTERP_API std::string lookup_autoload (const std::string& nm);
 
 extern OCTINTERP_API string_vector autoloaded_functions (void);
 
 extern OCTINTERP_API string_vector reverse_lookup_autoload (const std::string& nm);
 
 extern OCTINTERP_API octave_function *
 load_fcn_from_file (const std::string& file_name,
-		    const std::string& dir_name = std::string (),
-		    const std::string& dispatch_type = std::string (),
-		    const std::string& fcn_name = std::string (),
-		    bool autoload = false);
+                    const std::string& dir_name = std::string (),
+                    const std::string& dispatch_type = std::string (),
+                    const std::string& fcn_name = std::string (),
+                    bool autoload = false);
 
 extern OCTINTERP_API void
 source_file (const std::string& file_name,
-	     const std::string& context = std::string (),
-	     bool verbose = false, bool require_file = true,
-	     const std::string& warn_for = std::string ());
+             const std::string& context = std::string (),
+             bool verbose = false, bool require_file = true,
+             const std::string& warn_for = std::string ());
 
 extern OCTINTERP_API octave_value_list
 feval (const std::string& name,
        const octave_value_list& args = octave_value_list (),
        int nargout = 0);
 
 extern OCTINTERP_API octave_value_list
 feval (octave_function *fcn,
diff --git a/src/pr-output.h b/src/pr-output.h
--- a/src/pr-output.h
+++ b/src/pr-output.h
@@ -50,213 +50,213 @@ class PermMatrix;
 class Cell;
 
 #include "intNDArray.h"
 #include "oct-inttypes.h"
 
 
 extern OCTINTERP_API void
 octave_print_internal (std::ostream& os, bool d,
-		       bool pr_as_read_syntax = false);
+                       bool pr_as_read_syntax = false);
 
 extern OCTINTERP_API void
 octave_print_internal (std::ostream& os, double d,
-		       bool pr_as_read_syntax = false);
+                       bool pr_as_read_syntax = false);
 
 extern OCTINTERP_API void
 octave_print_internal (std::ostream& os, float d,
-		       bool pr_as_read_syntax = false);
+                       bool pr_as_read_syntax = false);
 
 extern OCTINTERP_API void
 octave_print_internal (std::ostream& os, const Matrix& m,
-		       bool pr_as_read_syntax = false,
-		       int extra_indent = 0);
+                       bool pr_as_read_syntax = false,
+                       int extra_indent = 0);
 
 extern OCTINTERP_API void
 octave_print_internal (std::ostream& os, const DiagMatrix& m,
-		       bool pr_as_read_syntax = false,
-		       int extra_indent = 0);
+                       bool pr_as_read_syntax = false,
+                       int extra_indent = 0);
 
 extern OCTINTERP_API void
 octave_print_internal (std::ostream& os, const FloatMatrix& m,
-		       bool pr_as_read_syntax = false,
-		       int extra_indent = 0);
+                       bool pr_as_read_syntax = false,
+                       int extra_indent = 0);
 
 extern OCTINTERP_API void
 octave_print_internal (std::ostream& os, const FloatDiagMatrix& m,
-		       bool pr_as_read_syntax = false,
-		       int extra_indent = 0);
+                       bool pr_as_read_syntax = false,
+                       int extra_indent = 0);
 
 extern OCTINTERP_API void
 octave_print_internal (std::ostream& os, const NDArray& nda,
-		       bool pr_as_read_syntax = false,
-		       int extra_indent = 0);
+                       bool pr_as_read_syntax = false,
+                       int extra_indent = 0);
 
 extern OCTINTERP_API void
 octave_print_internal (std::ostream& os, const FloatNDArray& nda,
-		       bool pr_as_read_syntax = false,
-		       int extra_indent = 0);
+                       bool pr_as_read_syntax = false,
+                       int extra_indent = 0);
 
 extern OCTINTERP_API void
 octave_print_internal (std::ostream& os, const Complex& c,
-		       bool pr_as_read_syntax = false);
+                       bool pr_as_read_syntax = false);
 
 extern OCTINTERP_API void
 octave_print_internal (std::ostream& os, const FloatComplex& c,
-		       bool pr_as_read_syntax = false);
+                       bool pr_as_read_syntax = false);
 
 extern OCTINTERP_API void
 octave_print_internal (std::ostream& os, const ComplexMatrix& cm,
-		       bool pr_as_read_syntax = false,
-		       int extra_indent = 0);
+                       bool pr_as_read_syntax = false,
+                       int extra_indent = 0);
 
 extern OCTINTERP_API void
 octave_print_internal (std::ostream& os, const ComplexDiagMatrix& cm,
-		       bool pr_as_read_syntax = false,
-		       int extra_indent = 0);
+                       bool pr_as_read_syntax = false,
+                       int extra_indent = 0);
 
 extern OCTINTERP_API void
 octave_print_internal (std::ostream& os, const FloatComplexMatrix& cm,
-		       bool pr_as_read_syntax = false,
-		       int extra_indent = 0);
+                       bool pr_as_read_syntax = false,
+                       int extra_indent = 0);
 
 extern OCTINTERP_API void
 octave_print_internal (std::ostream& os, const FloatComplexDiagMatrix& cm,
-		       bool pr_as_read_syntax = false,
-		       int extra_indent = 0);
+                       bool pr_as_read_syntax = false,
+                       int extra_indent = 0);
 
 extern OCTINTERP_API void
 octave_print_internal (std::ostream& os, const ComplexNDArray& nda,
-		       bool pr_as_read_syntax = false,
-		       int extra_indent = 0);
+                       bool pr_as_read_syntax = false,
+                       int extra_indent = 0);
 
 extern OCTINTERP_API void
 octave_print_internal (std::ostream& os, const FloatComplexNDArray& nda,
-		       bool pr_as_read_syntax = false,
-		       int extra_indent = 0);
+                       bool pr_as_read_syntax = false,
+                       int extra_indent = 0);
 
 extern OCTINTERP_API void
 octave_print_internal (std::ostream& os, const PermMatrix& m,
-		       bool pr_as_read_syntax = false,
-		       int extra_indent = 0);
+                       bool pr_as_read_syntax = false,
+                       int extra_indent = 0);
 
 extern OCTINTERP_API void
 octave_print_internal (std::ostream& os, const Range& r,
-		       bool pr_as_read_syntax = false,
-		       int extra_indent = 0);
+                       bool pr_as_read_syntax = false,
+                       int extra_indent = 0);
 
 extern OCTINTERP_API void
 octave_print_internal (std::ostream& os, const boolMatrix& m,
-		       bool pr_as_read_syntax = false,
-		       int extra_indent = 0);
+                       bool pr_as_read_syntax = false,
+                       int extra_indent = 0);
 
 extern OCTINTERP_API void
 octave_print_internal (std::ostream& os, const boolNDArray& m,
-		       bool pr_as_read_syntax = false,
-		       int extra_indent = 0);
+                       bool pr_as_read_syntax = false,
+                       int extra_indent = 0);
 
 extern OCTINTERP_API void
 octave_print_internal (std::ostream& os, const charMatrix& chm,
-		       bool pr_as_read_syntax = false,
-		       int extra_indent = 0,
-		       bool pr_as_string = false);
+                       bool pr_as_read_syntax = false,
+                       int extra_indent = 0,
+                       bool pr_as_string = false);
 
 extern OCTINTERP_API void
 octave_print_internal (std::ostream& os, const charNDArray& nda,
-		       bool pr_as_read_syntax = false,
-		       int extra_indent = 0,
-		       bool pr_as_string = false);
+                       bool pr_as_read_syntax = false,
+                       int extra_indent = 0,
+                       bool pr_as_string = false);
 
 extern OCTINTERP_API void
 octave_print_internal (std::ostream& os, const std::string& s,
-		       bool pr_as_read_syntax = false,
-		       int extra_indent = 0);
+                       bool pr_as_read_syntax = false,
+                       int extra_indent = 0);
 
 extern OCTINTERP_API void
 octave_print_internal (std::ostream& os, const Array<std::string>& sa,
-		       bool pr_as_read_syntax = false,
-		       int extra_indent = 0);
+                       bool pr_as_read_syntax = false,
+                       int extra_indent = 0);
 
 extern OCTINTERP_API void
 octave_print_internal (std::ostream& os, const intNDArray<octave_int8>& sa,
-		       bool pr_as_read_syntax = false,
-		       int extra_indent = 0);
+                       bool pr_as_read_syntax = false,
+                       int extra_indent = 0);
 
 extern OCTINTERP_API void
 octave_print_internal (std::ostream& os, const intNDArray<octave_uint8>& sa,
-		       bool pr_as_read_syntax = false,
-		       int extra_indent = 0);
+                       bool pr_as_read_syntax = false,
+                       int extra_indent = 0);
 
 extern OCTINTERP_API void
 octave_print_internal (std::ostream& os, const intNDArray<octave_int16>& sa,
-		       bool pr_as_read_syntax = false,
-		       int extra_indent = 0);
+                       bool pr_as_read_syntax = false,
+                       int extra_indent = 0);
 
 extern OCTINTERP_API void
 octave_print_internal (std::ostream& os, const intNDArray<octave_uint16>& sa,
-		       bool pr_as_read_syntax = false,
-		       int extra_indent = 0);
+                       bool pr_as_read_syntax = false,
+                       int extra_indent = 0);
 
 extern OCTINTERP_API void
 octave_print_internal (std::ostream& os, const intNDArray<octave_int32>& sa,
-		       bool pr_as_read_syntax = false,
-		       int extra_indent = 0);
+                       bool pr_as_read_syntax = false,
+                       int extra_indent = 0);
 
 extern OCTINTERP_API void
 octave_print_internal (std::ostream& os, const intNDArray<octave_uint32>& sa,
-		       bool pr_as_read_syntax = false,
-		       int extra_indent = 0);
+                       bool pr_as_read_syntax = false,
+                       int extra_indent = 0);
 
 extern OCTINTERP_API void
 octave_print_internal (std::ostream& os, const intNDArray<octave_int64>& sa,
-		       bool pr_as_read_syntax = false,
-		       int extra_indent = 0);
+                       bool pr_as_read_syntax = false,
+                       int extra_indent = 0);
 
 extern OCTINTERP_API void
 octave_print_internal (std::ostream& os, const intNDArray<octave_uint64>& sa,
-		       bool pr_as_read_syntax = false,
-		       int extra_indent = 0);
+                       bool pr_as_read_syntax = false,
+                       int extra_indent = 0);
 
 extern OCTINTERP_API void
 octave_print_internal (std::ostream& os, const octave_int<int8_t>& sa,
-		       bool pr_as_read_syntax = false);
+                       bool pr_as_read_syntax = false);
 
 extern OCTINTERP_API void
 octave_print_internal (std::ostream& os, const octave_int<uint8_t>& sa,
-		       bool pr_as_read_syntax = false);
+                       bool pr_as_read_syntax = false);
 
 extern OCTINTERP_API void
 octave_print_internal (std::ostream& os, const octave_int<int16_t>& sa,
-		       bool pr_as_read_syntax = false);
+                       bool pr_as_read_syntax = false);
 
 extern OCTINTERP_API void
 octave_print_internal (std::ostream& os, const octave_int<uint16_t>& sa,
-		       bool pr_as_read_syntax = false);
+                       bool pr_as_read_syntax = false);
 
 extern OCTINTERP_API void
 octave_print_internal (std::ostream& os, const octave_int<int32_t>& sa,
-		       bool pr_as_read_syntax = false);
+                       bool pr_as_read_syntax = false);
 
 extern OCTINTERP_API void
 octave_print_internal (std::ostream& os, const octave_int<uint32_t>& sa,
-		       bool pr_as_read_syntax = false);
+                       bool pr_as_read_syntax = false);
 
 extern OCTINTERP_API void
 octave_print_internal (std::ostream& os, const octave_int<int64_t>& sa,
-		       bool pr_as_read_syntax = false);
+                       bool pr_as_read_syntax = false);
 
 extern OCTINTERP_API void
 octave_print_internal (std::ostream& os, const octave_int<uint64_t>& sa,
-		       bool pr_as_read_syntax = false);
+                       bool pr_as_read_syntax = false);
 
 extern OCTINTERP_API void
 octave_print_internal (std::ostream& os, const Cell& cell,
-		       bool pr_as_read_syntax = false,
-		       int extra_indent = 0,
-		       bool pr_as_string = false);
+                       bool pr_as_read_syntax = false,
+                       int extra_indent = 0,
+                       bool pr_as_string = false);
 
 // TRUE means that the dimensions of empty objects should be printed
 // like this: x = [](2x0).
 extern bool Vprint_empty_dimensions;
 
 // How many levels of structure elements should we print?
 extern OCTINTERP_API int Vstruct_levels_to_print;
 
diff --git a/src/pt-arg-list.h b/src/pt-arg-list.h
--- a/src/pt-arg-list.h
+++ b/src/pt-arg-list.h
@@ -79,17 +79,17 @@ public:
 
   octave_value_list convert_to_const_vector (const octave_value *object = 0);
 
   std::list<octave_lvalue> lvalue_list (void);
 
   string_vector get_arg_names (void) const;
 
   tree_argument_list *dup (symbol_table::scope_id scope,
-			   symbol_table::context_id context) const;
+                           symbol_table::context_id context) const;
 
   void accept (tree_walker& tw);
 
 private:
 
   bool list_includes_magic_end;
 
   bool list_includes_magic_tilde;
diff --git a/src/pt-assign.h b/src/pt-assign.h
--- a/src/pt-assign.h
+++ b/src/pt-assign.h
@@ -41,23 +41,23 @@ class octave_lvalue;
 // Simple assignment expressions.
 
 class
 tree_simple_assignment : public tree_expression
 {
 public:
 
   tree_simple_assignment (bool plhs = false, int l = -1, int c = -1,
-			  octave_value::assign_op t = octave_value::op_asn_eq)
+                          octave_value::assign_op t = octave_value::op_asn_eq)
     : tree_expression (l, c), lhs (0), rhs (0), preserve (plhs), etype (t),
       first_execution (true) { }
 
   tree_simple_assignment (tree_expression *le, tree_expression *re,
-			  bool plhs = false, int l = -1, int c = -1,
-			  octave_value::assign_op t = octave_value::op_asn_eq);
+                          bool plhs = false, int l = -1, int c = -1,
+                          octave_value::assign_op t = octave_value::op_asn_eq);
 
   ~tree_simple_assignment (void);
 
   bool has_magic_end (void) const { return (rhs && rhs->has_magic_end ()); }
 
   bool rvalue_ok (void) const { return true; }
 
   octave_value rvalue1 (int nargout = 1);
@@ -68,26 +68,26 @@ public:
 
   std::string oper (void) const;
 
   tree_expression *left_hand_side (void) { return lhs; }
 
   tree_expression *right_hand_side (void) { return rhs; }
 
   tree_expression *dup (symbol_table::scope_id scope,
-			symbol_table::context_id context) const;
+                        symbol_table::context_id context) const;
 
   void accept (tree_walker& tw);
 
   octave_value::assign_op op_type (void) const { return etype; }
 
 private:
 
   void do_assign (octave_lvalue& ult, const octave_value_list& args,
-		  const octave_value& rhs_val);
+                  const octave_value& rhs_val);
 
   void do_assign (octave_lvalue& ult, const octave_value& rhs_val);
 
   // The left hand side of the assignment.
   tree_expression *lhs;
 
   // The right hand side of the assignment.
   tree_expression *rhs;
@@ -118,17 +118,17 @@ tree_multi_assignment : public tree_expr
 {
 public:
 
   tree_multi_assignment (bool plhs = false, int l = -1, int c = -1)
     : tree_expression (l, c), lhs (0), rhs (0), preserve (plhs),
       first_execution (true) { }
 
   tree_multi_assignment (tree_argument_list *lst, tree_expression *r,
-			 bool plhs = false, int l = -1, int c = -1);
+                         bool plhs = false, int l = -1, int c = -1);
 
   ~tree_multi_assignment (void);
 
   bool has_magic_end (void) const { return (rhs && rhs->has_magic_end ()); }
 
   bool is_assignment_expression (void) const { return true; }
 
   bool rvalue_ok (void) const { return true; }
@@ -139,17 +139,17 @@ public:
 
   std::string oper (void) const;
 
   tree_argument_list *left_hand_side (void) { return lhs; }
 
   tree_expression *right_hand_side (void) { return rhs; }
 
   tree_expression *dup (symbol_table::scope_id scope,
-			symbol_table::context_id context) const;
+                        symbol_table::context_id context) const;
 
   void accept (tree_walker& tw);
   
   octave_value::assign_op op_type (void) const { return octave_value::op_asn_eq; }
 
 private:
 
   // The left hand side of the assignment.
diff --git a/src/pt-binop.h b/src/pt-binop.h
--- a/src/pt-binop.h
+++ b/src/pt-binop.h
@@ -39,36 +39,36 @@ class octave_lvalue;
 // Binary expressions.
 
 class
 tree_binary_expression : public tree_expression
 {
 public:
 
   tree_binary_expression (int l = -1, int c = -1,
-			  octave_value::binary_op t
-			    = octave_value::unknown_binary_op)
+                          octave_value::binary_op t
+                            = octave_value::unknown_binary_op)
     : tree_expression (l, c), op_lhs (0), op_rhs (0), etype (t) { }
 
   tree_binary_expression (tree_expression *a, tree_expression *b,
-			  int l = -1, int c = -1,
-			  octave_value::binary_op t
-			    = octave_value::unknown_binary_op)
+                          int l = -1, int c = -1,
+                          octave_value::binary_op t
+                            = octave_value::unknown_binary_op)
     : tree_expression (l, c), op_lhs (a), op_rhs (b), etype (t) { }
 
   ~tree_binary_expression (void)
     {
       delete op_lhs;
       delete op_rhs;
     }
 
   bool has_magic_end (void) const
     {
       return ((op_lhs && op_lhs->has_magic_end ())
-	      || (op_rhs && op_rhs->has_magic_end ()));
+              || (op_rhs && op_rhs->has_magic_end ()));
     }
 
   bool is_binary_expression (void) const { return true; }
 
   bool rvalue_ok (void) const { return true; }
 
   octave_value rvalue1 (int nargout = 1);
 
@@ -77,17 +77,17 @@ public:
   std::string oper (void) const;
 
   octave_value::binary_op op_type (void) const { return etype; }
 
   tree_expression *lhs (void) { return op_lhs; }
   tree_expression *rhs (void) { return op_rhs; }
 
   tree_expression *dup (symbol_table::scope_id scope,
-			symbol_table::context_id context) const;
+                        symbol_table::context_id context) const;
 
   void accept (tree_walker& tw);
 
 protected:
 
   // The operands for the expression.
   tree_expression *op_lhs;
   tree_expression *op_rhs;
@@ -117,17 +117,17 @@ public:
       bool_and,
       bool_or
     };
 
   tree_boolean_expression (int l = -1, int c = -1, type t = unknown)
     : tree_binary_expression (l, c), etype (t) { }
 
   tree_boolean_expression (tree_expression *a, tree_expression *b,
-			   int l = -1, int c = -1, type t = unknown)
+                           int l = -1, int c = -1, type t = unknown)
     : tree_binary_expression (a, b, l, c), etype (t) { }
 
   ~tree_boolean_expression (void) { }
 
   bool is_boolean_expression (void) const { return true; }
 
   bool rvalue_ok (void) const { return true; }
 
@@ -135,17 +135,17 @@ public:
 
   octave_value_list rvalue (int nargout);
 
   std::string oper (void) const;
 
   type op_type (void) const { return etype; }
 
   tree_expression *dup (symbol_table::scope_id scope,
-			symbol_table::context_id context) const;
+                        symbol_table::context_id context) const;
 
 private:
 
   // The type of the expression.
   type etype;
 
   // No copying!
 
diff --git a/src/pt-cell.h b/src/pt-cell.h
--- a/src/pt-cell.h
+++ b/src/pt-cell.h
@@ -49,17 +49,17 @@ public:
 
   bool rvalue_ok (void) const { return true; }
 
   octave_value rvalue1 (int nargout = 1);
 
   octave_value_list rvalue (int);
 
   tree_expression *dup (symbol_table::scope_id scope,
-			symbol_table::context_id context) const;
+                        symbol_table::context_id context) const;
 
   void accept (tree_walker& tw);
 
 private:
 
   // No copying!
 
   tree_cell (const tree_cell&);
diff --git a/src/pt-cmd.h b/src/pt-cmd.h
--- a/src/pt-cmd.h
+++ b/src/pt-cmd.h
@@ -41,17 +41,17 @@ tree_command : public tree
 public:
 
   tree_command (int l = -1, int c = -1)
     : tree (l, c) { }
 
   virtual ~tree_command (void) { }
 
   virtual tree_command *dup (symbol_table::scope_id,
-			     symbol_table::context_id context) const = 0;
+                             symbol_table::context_id context) const = 0;
 
 private:
 
   // No copying!
 
   tree_command (const tree_command&);
 
   tree_command& operator = (const tree_command&);
@@ -66,17 +66,17 @@ public:
 
   tree_no_op_command (const std::string& cmd = "no_op", int l = -1, int c = -1)
     : tree_command (l, c), eof (cmd == "endfunction" || cmd == "endscript"),
       orig_cmd (cmd) { }
 
   ~tree_no_op_command (void) { }
 
   tree_command *dup (symbol_table::scope_id scope,
-		     symbol_table::context_id context) const;
+                     symbol_table::context_id context) const;
 
   void accept (tree_walker& tw);
 
   bool is_end_of_fcn_or_script (void) const { return eof; }
 
   std::string original_command (void) { return orig_cmd; }
 
 private:
@@ -100,17 +100,17 @@ tree_function_def : public tree_command
 public:
 
   tree_function_def (octave_function *f, int l = -1, int c = -1)
     : tree_command (l, c), fcn (f) { }
 
   ~tree_function_def (void) { }
 
   tree_command *dup (symbol_table::scope_id scope,
-		     symbol_table::context_id context) const;
+                     symbol_table::context_id context) const;
 
   void accept (tree_walker& tw);
 
   octave_value function (void) { return fcn; }
 
 private:
 
   octave_value fcn;
diff --git a/src/pt-colon.h b/src/pt-colon.h
--- a/src/pt-colon.h
+++ b/src/pt-colon.h
@@ -46,34 +46,34 @@ public:
     : tree_expression (l, c), op_base (0), op_limit (0),
       op_increment (0), save_base (false) { }
 
   tree_colon_expression (tree_expression *e, int l = -1, int c = -1)
     : tree_expression (l, c), op_base (e), op_limit (0),
       op_increment (0), save_base (false) { }
 
   tree_colon_expression (tree_expression *bas, tree_expression *lim,
-			 tree_expression *inc, int l = -1, int c = -1)
+                         tree_expression *inc, int l = -1, int c = -1)
     : tree_expression (l, c), op_base (bas), op_limit (lim),
       op_increment (inc), save_base (false) { }
 
   ~tree_colon_expression (void)
     {
       if (! save_base)
-	delete op_base;
+        delete op_base;
 
       delete op_limit;
       delete op_increment;
     }
 
   bool has_magic_end (void) const
     {
       return ((op_base && op_base->has_magic_end ())
-	      || (op_limit && op_limit->has_magic_end ())
-	      || (op_increment && op_increment->has_magic_end ()));
+              || (op_limit && op_limit->has_magic_end ())
+              || (op_increment && op_increment->has_magic_end ()));
     }
 
   void preserve_base (void) { save_base = true; }
 
   tree_colon_expression *append (tree_expression *t);
 
   bool rvalue_ok (void) const { return true; }
 
@@ -88,37 +88,37 @@ public:
   tree_expression *limit (void) { return op_limit; }
 
   tree_expression *increment (void) { return op_increment; }
 
   int line (void) const;
   int column (void) const;
 
   tree_expression *dup (symbol_table::scope_id scope,
-			symbol_table::context_id context) const;
+                        symbol_table::context_id context) const;
 
   void accept (tree_walker& tw);
 
 private:
 
   // The components of the expression.
   tree_expression *op_base;
   tree_expression *op_limit;
   tree_expression *op_increment;
 
   bool save_base;
 
   octave_value
   make_range (const Matrix& m_base, const Matrix& m_limit,
-	      const Matrix& m_increment, bool result_is_str,
-	      bool dq_str) const;
+              const Matrix& m_increment, bool result_is_str,
+              bool dq_str) const;
 
   octave_value
   make_range (const octave_value& ov_base, const octave_value& ov_limit,
-	      const octave_value& ov_increment) const;
+              const octave_value& ov_increment) const;
 
   // No copying!
 
   tree_colon_expression (const tree_colon_expression&);
 
   tree_colon_expression& operator = (const tree_colon_expression&);
 };
 
diff --git a/src/pt-const.h b/src/pt-const.h
--- a/src/pt-const.h
+++ b/src/pt-const.h
@@ -44,17 +44,17 @@ public:
 
   tree_constant (int l = -1, int c = -1)
     : tree_expression (l, c), val (), orig_text () { }
 
   tree_constant (const octave_value& v, int l = -1, int c = -1)
     : tree_expression (l, c), val (v), orig_text () { }
 
   tree_constant (const octave_value& v, const std::string& ot,
-		 int l = -1, int c = -1)
+                 int l = -1, int c = -1)
     : tree_expression (l, c), val (v), orig_text (ot) { }
 
   ~tree_constant (void) { }
 
   bool has_magic_end (void) const { return false; }
 
   void *operator new (size_t size) { return allocator.alloc (size); }
 
@@ -62,29 +62,29 @@ public:
 
   // Type.  It would be nice to eliminate the need for this.
 
   bool is_constant (void) const { return true; }
 
   void maybe_mutate (void) { val.maybe_mutate (); }
 
   void print (std::ostream& os, bool pr_as_read_syntax = false,
-	      bool pr_orig_txt = true);
+              bool pr_orig_txt = true);
 
   void print_raw (std::ostream& os, bool pr_as_read_syntax = false,
-		  bool pr_orig_txt = true);
+                  bool pr_orig_txt = true);
 
   bool rvalue_ok (void) const { return true; }
 
   octave_value rvalue1 (int = 1) { return val; }
 
   octave_value_list rvalue (int nargout);
 
   tree_expression *dup (symbol_table::scope_id scope,
-			symbol_table::context_id context) const;
+                        symbol_table::context_id context) const;
 
   void accept (tree_walker& tw);
 
   // Store the original text corresponding to this constant for later
   // pretty printing.
 
   void stash_original_text (const std::string& s) { orig_text = s; }
 
diff --git a/src/pt-decl.h b/src/pt-decl.h
--- a/src/pt-decl.h
+++ b/src/pt-decl.h
@@ -83,17 +83,17 @@ public:
 
   octave_lvalue lvalue (void) { return id ? id->lvalue () : octave_lvalue (); }
 
   tree_identifier *ident (void) { return id; }
 
   tree_expression *expression (void) { return expr; }
 
   tree_decl_elt *dup (symbol_table::scope_id scope,
-		      symbol_table::context_id context) const;
+                      symbol_table::context_id context) const;
 
   void accept (tree_walker& tw);
 
 private:
 
   // An identifier to tag with the declared property.
   tree_identifier *id;
 
@@ -114,25 +114,25 @@ public:
 
   tree_decl_init_list (void) { }
 
   tree_decl_init_list (tree_decl_elt *t) { append (t); }
 
   ~tree_decl_init_list (void)
     {
       while (! empty ())
-	{
-	  iterator p = begin ();
-	  delete *p;
-	  erase (p);
-	}
+        {
+          iterator p = begin ();
+          delete *p;
+          erase (p);
+        }
     }
 
   tree_decl_init_list *dup (symbol_table::scope_id scope,
-			    symbol_table::context_id context) const;
+                            symbol_table::context_id context) const;
 
   void accept (tree_walker& tw);
 
 private:
 
   // No copying!
 
   tree_decl_init_list (const tree_decl_init_list&);
@@ -146,17 +146,17 @@ class
 tree_decl_command : public tree_command
 {
 public:
 
   tree_decl_command (const std::string& n, int l = -1, int c = -1)
     : tree_command (l, c), cmd_name (n), init_list (0) { }
 
   tree_decl_command (const std::string& n, tree_decl_init_list *t,
-		     int l = -1, int c = -1)
+                     int l = -1, int c = -1)
     : tree_command (l, c), cmd_name (n), init_list (t) { }
 
   ~tree_decl_command (void);
 
   tree_decl_init_list *initializer_list (void) { return init_list; }
 
   std::string name (void) { return cmd_name; }
 
@@ -188,17 +188,17 @@ public:
     : tree_decl_command ("global", l, c) { }
 
   tree_global_command (tree_decl_init_list *t, int l = -1, int c = -1)
     : tree_decl_command ("global", t, l, c) { }
 
   ~tree_global_command (void) { }
 
   tree_command *dup (symbol_table::scope_id scope,
-		     symbol_table::context_id context) const;
+                     symbol_table::context_id context) const;
 
   void accept (tree_walker& tw);
 
 private:
 
   static void do_init (tree_decl_elt& elt);
 
   // No copying!
@@ -219,17 +219,17 @@ public:
     : tree_decl_command ("static", l, c) { }
 
   tree_static_command (tree_decl_init_list *t, int l = -1, int c = -1)
     : tree_decl_command ("static", t, l, c) { }
 
   ~tree_static_command (void) { }
 
   tree_command *dup (symbol_table::scope_id scope,
-		     symbol_table::context_id context) const;
+                     symbol_table::context_id context) const;
 
   void accept (tree_walker& tw);
 
 private:
 
   static void do_init (tree_decl_elt& elt);
 
   // No copying!
diff --git a/src/pt-eval.h b/src/pt-eval.h
--- a/src/pt-eval.h
+++ b/src/pt-eval.h
@@ -151,22 +151,22 @@ public:
   static bool in_fcn_or_script_body;
 
   // TRUE means we are evaluating some kind of looping construct.
   static bool in_loop_command;
 
 private:
 
   void do_decl_init_list (decl_elt_init_fcn fcn,
-			  tree_decl_init_list *init_list);
+                          tree_decl_init_list *init_list);
 
   void do_breakpoint (tree_statement& stmt) const;
 
   void do_breakpoint (bool is_breakpoint,
-		      bool is_end_of_fcn_or_script = false) const;
+                      bool is_end_of_fcn_or_script = false) const;
 
   virtual octave_value
   do_keyboard (const octave_value_list& args = octave_value_list ()) const;
 
   // No copying!
 
   tree_evaluator (const tree_evaluator&);
 
diff --git a/src/pt-except.h b/src/pt-except.h
--- a/src/pt-except.h
+++ b/src/pt-except.h
@@ -39,37 +39,37 @@ tree_try_catch_command : public tree_com
 {
 public:
 
   tree_try_catch_command (int l = -1, int c = -1)
     : tree_command (l, c), try_code (0), catch_code (0), lead_comm (0),
       mid_comm (0), trail_comm (0) { }
 
   tree_try_catch_command (tree_statement_list *tc, tree_statement_list *cc,
-			  octave_comment_list *cl = 0,
-			  octave_comment_list *cm = 0,
-			  octave_comment_list *ct = 0,
-			  int l = -1, int c = -1)
+                          octave_comment_list *cl = 0,
+                          octave_comment_list *cm = 0,
+                          octave_comment_list *ct = 0,
+                          int l = -1, int c = -1)
     : tree_command (l, c), try_code (tc), catch_code (cc),
       lead_comm (cl), mid_comm (cm), trail_comm (ct) { }
 
   ~tree_try_catch_command (void);
 
   tree_statement_list *body (void) { return try_code; }
 
   tree_statement_list *cleanup (void) { return catch_code; }
 
   octave_comment_list *leading_comment (void) { return lead_comm; }
 
   octave_comment_list *middle_comment (void) { return mid_comm; }
 
   octave_comment_list *trailing_comment (void) { return trail_comm; }
 
   tree_command *dup (symbol_table::scope_id scope,
-		     symbol_table::context_id context) const;
+                     symbol_table::context_id context) const;
 
   void accept (tree_walker& tw);
 
 private:
 
   // The first block of code to attempt to execute.
   tree_statement_list *try_code;
 
@@ -99,38 +99,38 @@ tree_unwind_protect_command : public tre
 {
 public:
 
   tree_unwind_protect_command (int l = -1, int c = -1)
     : tree_command (l, c), unwind_protect_code (0), cleanup_code (0),
       lead_comm (0), mid_comm (0), trail_comm (0) { }
 
   tree_unwind_protect_command (tree_statement_list *tc,
-			       tree_statement_list *cc,
-			       octave_comment_list *cl = 0,
-			       octave_comment_list *cm = 0,
-			       octave_comment_list *ct = 0,
-			       int l = -1, int c = -1)
+                               tree_statement_list *cc,
+                               octave_comment_list *cl = 0,
+                               octave_comment_list *cm = 0,
+                               octave_comment_list *ct = 0,
+                               int l = -1, int c = -1)
     : tree_command (l, c), unwind_protect_code (tc), cleanup_code (cc),
       lead_comm (cl), mid_comm (cm), trail_comm (ct) { }
 
   ~tree_unwind_protect_command (void);
 
   tree_statement_list *body (void) { return unwind_protect_code; }
 
   tree_statement_list *cleanup (void) { return cleanup_code; }
 
   octave_comment_list *leading_comment (void) { return lead_comm; }
 
   octave_comment_list *middle_comment (void) { return mid_comm; }
 
   octave_comment_list *trailing_comment (void) { return trail_comm; }
 
   tree_command *dup (symbol_table::scope_id scope,
-		     symbol_table::context_id context) const;
+                     symbol_table::context_id context) const;
 
   void accept (tree_walker& tw);
 
 private:
 
   // The first body of code to attempt to execute.
   tree_statement_list *unwind_protect_code;
 
diff --git a/src/pt-exp.h b/src/pt-exp.h
--- a/src/pt-exp.h
+++ b/src/pt-exp.h
@@ -43,17 +43,17 @@ public:
     : tree (l, c), num_parens (0), postfix_indexed (false),
       print_flag (false) { }
 
   virtual ~tree_expression (void) { }
 
   virtual bool has_magic_end (void) const = 0;
 
   virtual tree_expression *dup (symbol_table::scope_id,
-				symbol_table::context_id context) const = 0;
+                                symbol_table::context_id context) const = 0;
 
   virtual bool is_constant (void) const { return false; }
 
   virtual bool is_matrix_constant (void) const { return false; }
 
   virtual bool is_identifier (void) const { return false; }
 
   virtual bool is_index_expression (void) const { return false; }
diff --git a/src/pt-fcn-handle.h b/src/pt-fcn-handle.h
--- a/src/pt-fcn-handle.h
+++ b/src/pt-fcn-handle.h
@@ -51,31 +51,31 @@ public:
   tree_fcn_handle (const std::string& n, int l = -1, int c = -1)
     : tree_expression (l, c), nm (n) { }
 
   ~tree_fcn_handle (void) { }
 
   bool has_magic_end (void) const { return false; }
 
   void print (std::ostream& os, bool pr_as_read_syntax = false,
-	      bool pr_orig_txt = true);
+              bool pr_orig_txt = true);
 
   void print_raw (std::ostream& os, bool pr_as_read_syntax = false,
-		  bool pr_orig_txt = true);
+                  bool pr_orig_txt = true);
 
   std::string name (void) const { return nm; }
 
   bool rvalue_ok (void) const { return true; }
 
   octave_value rvalue1 (int nargout = 1);
 
   octave_value_list rvalue (int nargout);
 
   tree_expression *dup (symbol_table::scope_id scope,
-			symbol_table::context_id context) const;
+                        symbol_table::context_id context) const;
 
   void accept (tree_walker& tw);
 
 private:
 
   // The name of this function handle.
   std::string nm;
 
@@ -90,18 +90,18 @@ class
 tree_anon_fcn_handle : public tree_expression
 {
 public:
 
   tree_anon_fcn_handle (int l = -1, int c = -1)
     : tree_expression (l, c), fcn (0) { }
 
   tree_anon_fcn_handle (tree_parameter_list *pl, tree_parameter_list *rl,
-			tree_statement_list *cl, symbol_table::scope_id sid,
-			int l = -1, int c = -1)
+                        tree_statement_list *cl, symbol_table::scope_id sid,
+                        int l = -1, int c = -1)
     : tree_expression (l, c),
       fcn (new octave_user_function (sid, pl, rl, cl)) { }
 
   ~tree_anon_fcn_handle (void) { delete fcn; }
 
   bool has_magic_end (void) const { return false; }
 
   bool rvalue_ok (void) const { return true; }
@@ -126,17 +126,17 @@ public:
   }
 
   symbol_table::scope_id scope (void) const
   {
     return fcn ? fcn->scope () : -1;
   }
 
   tree_expression *dup (symbol_table::scope_id scope,
-			symbol_table::context_id context) const;
+                        symbol_table::context_id context) const;
 
   void accept (tree_walker& tw);
 
 private:
 
   // The function.
   octave_user_function *fcn;
 
diff --git a/src/pt-id.h b/src/pt-id.h
--- a/src/pt-id.h
+++ b/src/pt-id.h
@@ -45,18 +45,18 @@ tree_identifier : public tree_expression
   friend class tree_index_expression;
 
 public:
 
   tree_identifier (int l = -1, int c = -1)
     : tree_expression (l, c), sym (), scope (-1) { }
 
   tree_identifier (const symbol_table::symbol_record& s,
-		   int l = -1, int c = -1,
-		   symbol_table::scope_id sc = symbol_table::current_scope ())
+                   int l = -1, int c = -1,
+                   symbol_table::scope_id sc = symbol_table::current_scope ())
     : tree_expression (l, c), sym (s), scope (sc) { }
 
   ~tree_identifier (void) { }
 
   bool has_magic_end (void) const { return (name () == "__end__"); }
 
   bool is_identifier (void) const { return true; }
 
@@ -106,17 +106,17 @@ public:
 
   octave_value_list rvalue (int nargout);
 
   octave_lvalue lvalue (void);
 
   void eval_undefined_error (void);
 
   tree_identifier *dup (symbol_table::scope_id scope,
-			symbol_table::context_id context) const;
+                        symbol_table::context_id context) const;
 
   void accept (tree_walker& tw);
 
 private:
 
   // The symbol record that this identifier references.
   symbol_table::symbol_record sym;
 
@@ -126,18 +126,18 @@ private:
   // different from the one we are in now, update sym to be from the
   // new scope.
   symbol_table::symbol_record& xsym (void)
   {
     symbol_table::scope_id curr_scope = symbol_table::current_scope ();
 
     if (scope != curr_scope)
       {
-	scope = curr_scope;
-	sym = symbol_table::insert (sym.name ());
+        scope = curr_scope;
+        sym = symbol_table::insert (sym.name ());
       }
 
     return sym;
   }
 
   // No copying!
 
   tree_identifier (const tree_identifier&);
diff --git a/src/pt-idx.h b/src/pt-idx.h
--- a/src/pt-idx.h
+++ b/src/pt-idx.h
@@ -43,23 +43,23 @@ class octave_lvalue;
 // Index expressions.
 
 class
 tree_index_expression : public tree_expression
 {
 public:
 
   tree_index_expression (tree_expression *e = 0, tree_argument_list *lst = 0,
-			 int l = -1, int c = -1, char t = '(');
+                         int l = -1, int c = -1, char t = '(');
 
   tree_index_expression (tree_expression *e, const std::string& n,
-			 int l = -1, int c = -1);
+                         int l = -1, int c = -1);
 
   tree_index_expression (tree_expression *e, tree_expression* df,
-			 int l = -1, int c = -1);
+                         int l = -1, int c = -1);
 
   ~tree_index_expression (void);
 
   bool has_magic_end (void) const;
 
   void append (tree_argument_list *lst = 0, char t = '(');
 
   void append (const std::string& n);
@@ -84,17 +84,17 @@ public:
 
   octave_value rvalue1 (int nargout = 1);
 
   octave_value_list rvalue (int nargout);
 
   octave_lvalue lvalue (void);
 
   tree_index_expression *dup (symbol_table::scope_id scope,
-			      symbol_table::context_id context) const;
+                              symbol_table::context_id context) const;
 
   void accept (tree_walker& tw);
 
 private:
 
   // The LHS of this index expression.
   tree_expression *expr;
 
diff --git a/src/pt-jump.h b/src/pt-jump.h
--- a/src/pt-jump.h
+++ b/src/pt-jump.h
@@ -37,17 +37,17 @@ tree_break_command : public tree_command
 public:
 
   tree_break_command (int l = -1, int c = -1)
     : tree_command (l, c) { }
 
   ~tree_break_command (void) { }
 
   tree_command *dup (symbol_table::scope_id scope,
-		     symbol_table::context_id context) const;
+                     symbol_table::context_id context) const;
 
   void accept (tree_walker& tw);
 
   static int breaking;
 
 private:
 
   // No copying!
@@ -65,17 +65,17 @@ tree_continue_command : public tree_comm
 public:
 
   tree_continue_command (int l = -1, int c = -1)
     : tree_command (l, c) { }
 
   ~tree_continue_command (void) { }
 
   tree_command *dup (symbol_table::scope_id scope,
-		     symbol_table::context_id context) const;
+                     symbol_table::context_id context) const;
 
   void accept (tree_walker& tw);
 
   static int continuing;
 
 private:
 
   // No copying!
@@ -93,17 +93,17 @@ tree_return_command : public tree_comman
 public:
 
   tree_return_command (int l = -1, int c = -1)
     : tree_command (l, c) { }
 
   ~tree_return_command (void) { }
 
   tree_command *dup (symbol_table::scope_id scope,
-		     symbol_table::context_id context) const;
+                     symbol_table::context_id context) const;
 
   void accept (tree_walker& tw);
 
   static int returning;
 
 private:
 
   // No copying!
diff --git a/src/pt-loop.h b/src/pt-loop.h
--- a/src/pt-loop.h
+++ b/src/pt-loop.h
@@ -44,41 +44,41 @@ tree_while_command : public tree_command
 {
 public:
 
   tree_while_command (int l = -1, int c = -1)
     : tree_command (l, c), expr (0), list (0), lead_comm (0),
       trail_comm (0) { }
 
   tree_while_command (tree_expression *e,
-		      octave_comment_list *lc = 0,
-		      octave_comment_list *tc = 0,
-		      int l = -1, int c = -1)
+                      octave_comment_list *lc = 0,
+                      octave_comment_list *tc = 0,
+                      int l = -1, int c = -1)
     : tree_command (l, c), expr (e), list (0), lead_comm (lc),
       trail_comm (tc) { }
 
   tree_while_command (tree_expression *e, tree_statement_list *lst,
-		      octave_comment_list *lc = 0,
-		      octave_comment_list *tc = 0,
-		      int l = -1, int c = -1)
+                      octave_comment_list *lc = 0,
+                      octave_comment_list *tc = 0,
+                      int l = -1, int c = -1)
     : tree_command (l, c), expr (e), list (lst), lead_comm (lc),
       trail_comm (tc) { }
 
   ~tree_while_command (void);
 
   tree_expression *condition (void) { return expr; }
 
   tree_statement_list *body (void) { return list; }
 
   octave_comment_list *leading_comment (void) { return lead_comm; }
 
   octave_comment_list *trailing_comment (void) { return trail_comm; }
 
   tree_command *dup (symbol_table::scope_id scope,
-		     symbol_table::context_id context) const;
+                     symbol_table::context_id context) const;
 
   void accept (tree_walker& tw);
 
 protected:
 
   // Expression to test.
   tree_expression *expr;
 
@@ -106,31 +106,31 @@ class
 tree_do_until_command : public tree_while_command
 {
 public:
 
   tree_do_until_command (int l = -1, int c = -1)
     : tree_while_command (l, c) { }
 
   tree_do_until_command (tree_expression *e,
-			 octave_comment_list *lc = 0,
-			 octave_comment_list *tc = 0,
-			 int l = -1, int c = -1)
+                         octave_comment_list *lc = 0,
+                         octave_comment_list *tc = 0,
+                         int l = -1, int c = -1)
     : tree_while_command (e, lc, tc, l, c) { }
 
   tree_do_until_command (tree_expression *e, tree_statement_list *lst,
-			 octave_comment_list *lc = 0,
-			 octave_comment_list *tc = 0,
-			 int l = -1, int c = -1)
+                         octave_comment_list *lc = 0,
+                         octave_comment_list *tc = 0,
+                         int l = -1, int c = -1)
     : tree_while_command (e, lst, lc, tc, l, c) { }
 
   ~tree_do_until_command (void) { }
 
   tree_command *dup (symbol_table::scope_id scope,
-		     symbol_table::context_id context) const;
+                     symbol_table::context_id context) const;
 
   void accept (tree_walker& tw);
 
 private:
 
   // No copying!
 
   tree_do_until_command (const tree_do_until_command&);
@@ -145,37 +145,37 @@ tree_simple_for_command : public tree_co
 {
 public:
 
   tree_simple_for_command (int l = -1, int c = -1)
     : tree_command (l, c), lhs (0), expr (0), list (0), lead_comm (0),
       trail_comm (0) { }
 
   tree_simple_for_command (tree_expression *le, tree_expression *re,
-			   tree_statement_list *lst,
-			   octave_comment_list *lc = 0,
-			   octave_comment_list *tc = 0,
-			   int l = -1, int c = -1)
+                           tree_statement_list *lst,
+                           octave_comment_list *lc = 0,
+                           octave_comment_list *tc = 0,
+                           int l = -1, int c = -1)
     : tree_command (l, c), lhs (le), expr (re), list (lst),
       lead_comm (lc), trail_comm (tc) { }
 
   ~tree_simple_for_command (void);
 
   tree_expression *left_hand_side (void) { return lhs; }
 
   tree_expression *control_expr (void) { return expr; }
 
   tree_statement_list *body (void) { return list; }
 
   octave_comment_list *leading_comment (void) { return lead_comm; }
 
   octave_comment_list *trailing_comment (void) { return trail_comm; }
 
   tree_command *dup (symbol_table::scope_id scope,
-		     symbol_table::context_id context) const;
+                     symbol_table::context_id context) const;
 
   void accept (tree_walker& tw);
 
 private:
 
   // Expression to modify.
   tree_expression *lhs;
 
@@ -203,37 +203,37 @@ tree_complex_for_command : public tree_c
 {
 public:
 
   tree_complex_for_command (int l = -1, int c = -1)
     : tree_command (l, c), lhs (0), expr (0), list (0), lead_comm (0),
       trail_comm (0) { }
 
   tree_complex_for_command (tree_argument_list *le, tree_expression *re,
-			    tree_statement_list *lst,
-			    octave_comment_list *lc = 0,
-			    octave_comment_list *tc = 0,
-			    int l = -1, int c = -1)
+                            tree_statement_list *lst,
+                            octave_comment_list *lc = 0,
+                            octave_comment_list *tc = 0,
+                            int l = -1, int c = -1)
     : tree_command (l, c), lhs (le), expr (re), list (lst),
       lead_comm (lc), trail_comm (tc) { }
 
   ~tree_complex_for_command (void);
 
   tree_argument_list *left_hand_side (void) { return lhs; }
 
   tree_expression *control_expr (void) { return expr; }
 
   tree_statement_list *body (void) { return list; }
 
   octave_comment_list *leading_comment (void) { return lead_comm; }
 
   octave_comment_list *trailing_comment (void) { return trail_comm; }
 
   tree_command *dup (symbol_table::scope_id scope,
-		     symbol_table::context_id context) const;
+                     symbol_table::context_id context) const;
 
   void accept (tree_walker& tw);
 
 private:
 
   // Expression to modify.
   tree_argument_list *lhs;
 
diff --git a/src/pt-mat.h b/src/pt-mat.h
--- a/src/pt-mat.h
+++ b/src/pt-mat.h
@@ -36,17 +36,17 @@ class tree_walker;
 #include "pt-exp.h"
 #include "symtab.h"
 
 // General matrices.  This allows us to construct matrices from
 // other matrices, variables, and functions.
 
 class
 tree_matrix : public tree_expression,
-	      public octave_base_list<tree_argument_list *>
+              public octave_base_list<tree_argument_list *>
 {
 public:
 
   tree_matrix (tree_argument_list *row = 0, int l = -1, int c = -1)
     : tree_expression (l, c)
   {
     if (row)
       append (row);
@@ -60,17 +60,17 @@ public:
 
   bool rvalue_ok (void) const { return true; }
 
   octave_value rvalue1 (int nargout = 1);
 
   octave_value_list rvalue (int nargout);
 
   tree_expression *dup (symbol_table::scope_id scope,
-			symbol_table::context_id context) const;
+                        symbol_table::context_id context) const;
 
   void accept (tree_walker& tw);
 
 private:
 
   // No copying!
 
   tree_matrix (const tree_matrix&);
diff --git a/src/pt-misc.h b/src/pt-misc.h
--- a/src/pt-misc.h
+++ b/src/pt-misc.h
@@ -66,28 +66,28 @@ public:
 
   bool validate (in_or_out type);
 
   bool takes_varargs (void) const { return marked_for_varargs != 0; }
 
   bool varargs_only (void) { return (marked_for_varargs < 0); }
 
   void initialize_undefined_elements (const std::string& warnfor,
-				      int nargout, const octave_value& val);
+                                      int nargout, const octave_value& val);
 
   void define_from_arg_vector (const octave_value_list& args);
 
   void undefine (void);
 
   bool is_defined (void);
 
   octave_value_list convert_to_const_vector (int nargout, const Cell& varargout);
 
   tree_parameter_list *dup (symbol_table::scope_id scope,
-			    symbol_table::context_id context) const;
+                            symbol_table::context_id context) const;
 
   void accept (tree_walker& tw);
 
 private:
 
   int marked_for_varargs;
 
   void mark_varargs (void) { marked_for_varargs = 1; }
@@ -111,17 +111,17 @@ public:
 
   tree_return_list (void) { }
 
   tree_return_list (tree_index_expression *t) { append (t); }
 
   ~tree_return_list (void);
 
   tree_return_list *dup (symbol_table::scope_id scope,
-			 symbol_table::context_id context) const;
+                         symbol_table::context_id context) const;
 
   void accept (tree_walker& tw);
 
 private:
 
   // No copying!
 
   tree_return_list (const tree_return_list&);
diff --git a/src/pt-pr-code.h b/src/pt-pr-code.h
--- a/src/pt-pr-code.h
+++ b/src/pt-pr-code.h
@@ -36,18 +36,18 @@ class tree_expression;
 // How to print the code that the parse trees represent.
 
 class
 tree_print_code : public tree_walker
 {
 public:
 
   tree_print_code (std::ostream& os_arg,
-		   const std::string& pfx = std::string (),
-		   bool pr_orig_txt = true)
+                   const std::string& pfx = std::string (),
+                   bool pr_orig_txt = true)
     : os (os_arg), prefix (pfx), nesting (),
       print_original_text (pr_orig_txt),
       curr_print_indent_level (0), beginning_of_line (true),
       printing_newlines (true)
   {
     // For "none".
     nesting.push ('n');
   }
diff --git a/src/pt-select.h b/src/pt-select.h
--- a/src/pt-select.h
+++ b/src/pt-select.h
@@ -40,36 +40,36 @@ class
 tree_if_clause : public tree
 {
 public:
 
   tree_if_clause (int l = -1, int c = -1)
     : tree (l, c), expr (0), list (0), lead_comm (0) { }
 
   tree_if_clause (tree_statement_list *sl, octave_comment_list *lc = 0,
-		  int l = -1, int c = -1)
+                  int l = -1, int c = -1)
     : tree (l, c), expr (0), list (sl), lead_comm (lc) { }
 
   tree_if_clause (tree_expression *e, tree_statement_list *sl,
-		  octave_comment_list *lc = 0,
-		  int l = -1, int c = -1)
+                  octave_comment_list *lc = 0,
+                  int l = -1, int c = -1)
     : tree (l, c), expr (e), list (sl), lead_comm (lc) { }
 
   ~tree_if_clause (void);
 
   bool is_else_clause (void) { return ! expr; }
 
   tree_expression *condition (void) { return expr; }
 
   tree_statement_list *commands (void) { return list; }
 
   octave_comment_list *leading_comment (void) { return lead_comm; }
 
   tree_if_clause *dup (symbol_table::scope_id scope,
-		       symbol_table::context_id context) const;
+                       symbol_table::context_id context) const;
 
   void accept (tree_walker& tw);
 
 private:
 
   // The condition to test.
   tree_expression *expr;
 
@@ -93,25 +93,25 @@ public:
 
   tree_if_command_list (void) { }
 
   tree_if_command_list (tree_if_clause *t) { append (t); }
 
   ~tree_if_command_list (void)
     {
       while (! empty ())
-	{
-	  iterator p = begin ();
-	  delete *p;
-	  erase (p);
-	}
+        {
+          iterator p = begin ();
+          delete *p;
+          erase (p);
+        }
     }
 
   tree_if_command_list *dup (symbol_table::scope_id scope,
-			     symbol_table::context_id context) const;
+                             symbol_table::context_id context) const;
 
   void accept (tree_walker& tw);
 
 private:
 
   // No copying!
 
   tree_if_command_list (const tree_if_command_list&);
@@ -123,33 +123,33 @@ class
 tree_if_command : public tree_command
 {
 public:
 
   tree_if_command (int l = -1, int c = -1)
     : tree_command (l, c), list (0), lead_comm (0), trail_comm (0) { }
 
   tree_if_command (tree_if_command_list *lst, octave_comment_list *lc,
-		   octave_comment_list *tc, int l = -1, int c = -1)
+                   octave_comment_list *tc, int l = -1, int c = -1)
     : tree_command (l, c), list (lst), lead_comm (lc), trail_comm (tc) { }
 
   ~tree_if_command (void);
 
   void set_breakpoint (void);
 
   void delete_breakpoint (void);
 
   tree_if_command_list *cmd_list (void) { return list; }
 
   octave_comment_list *leading_comment (void) { return lead_comm; }
 
   octave_comment_list *trailing_comment (void) { return trail_comm; }
 
   tree_command *dup (symbol_table::scope_id scope,
-		     symbol_table::context_id context) const;
+                     symbol_table::context_id context) const;
 
   void accept (tree_walker& tw);
 
 private:
 
   // List of if commands (if, elseif, elseif, ... else, endif)
   tree_if_command_list *list;
 
@@ -172,38 +172,38 @@ class
 tree_switch_case : public tree
 {
 public:
 
   tree_switch_case (int l = -1, int c = -1)
     : tree (l, c), label (0), list (0), lead_comm (0) { }
 
   tree_switch_case (tree_statement_list *sl, octave_comment_list *lc = 0,
-		    int l = -1, int c = -1)
+                    int l = -1, int c = -1)
     : tree (l, c), label (0), list (sl), lead_comm (lc) { }
 
   tree_switch_case (tree_expression *e, tree_statement_list *sl,
-		    octave_comment_list *lc = 0,
-		    int l = -1, int c = -1)
+                    octave_comment_list *lc = 0,
+                    int l = -1, int c = -1)
     : tree (l, c), label (e), list (sl), lead_comm (lc) { }
 
   ~tree_switch_case (void);
 
   bool is_default_case (void) { return ! label; }
 
   bool label_matches (const octave_value& val);
 
   tree_expression *case_label (void) { return label; }
 
   tree_statement_list *commands (void) { return list; }
 
   octave_comment_list *leading_comment (void) { return lead_comm; }
 
   tree_switch_case *dup (symbol_table::scope_id scope,
-			 symbol_table::context_id context) const;
+                         symbol_table::context_id context) const;
 
   void accept (tree_walker& tw);
 
 private:
 
   // The case label.
   tree_expression *label;
 
@@ -227,25 +227,25 @@ public:
 
   tree_switch_case_list (void) { }
 
   tree_switch_case_list (tree_switch_case *t) { append (t); }
 
   ~tree_switch_case_list (void)
     {
       while (! empty ())
-	{
-	  iterator p = begin ();
-	  delete *p;
-	  erase (p);
-	}
+        {
+          iterator p = begin ();
+          delete *p;
+          erase (p);
+        }
     }
 
   tree_switch_case_list *dup (symbol_table::scope_id scope,
-			      symbol_table::context_id context) const;
+                              symbol_table::context_id context) const;
 
   void accept (tree_walker& tw);
 
 private:
 
   // No copying!
 
   tree_switch_case_list (const tree_switch_case_list&);
@@ -258,18 +258,18 @@ tree_switch_command : public tree_comman
 {
 public:
 
   tree_switch_command (int l = -1, int c = -1)
     : tree_command (l, c), expr (0), list (0), lead_comm (0),
       trail_comm (0) { }
 
   tree_switch_command (tree_expression *e, tree_switch_case_list *lst,
-		       octave_comment_list *lc, octave_comment_list *tc, 
-		       int l = -1, int c = -1)
+                       octave_comment_list *lc, octave_comment_list *tc, 
+                       int l = -1, int c = -1)
     : tree_command (l, c), expr (e), list (lst), lead_comm (lc),
       trail_comm (tc) { }
 
   ~tree_switch_command (void);
 
   void set_breakpoint (void);
 
   void delete_breakpoint (void);
@@ -278,17 +278,17 @@ public:
 
   tree_switch_case_list *case_list (void) { return list; }
 
   octave_comment_list *leading_comment (void) { return lead_comm; }
 
   octave_comment_list *trailing_comment (void) { return trail_comm; }
 
   tree_command *dup (symbol_table::scope_id scope,
-		     symbol_table::context_id context) const;
+                     symbol_table::context_id context) const;
 
   void accept (tree_walker& tw);
 
 private:
 
   // Value on which to switch.
   tree_expression *expr;
 
diff --git a/src/pt-stmt.h b/src/pt-stmt.h
--- a/src/pt-stmt.h
+++ b/src/pt-stmt.h
@@ -89,17 +89,17 @@ public:
   // checking.  If you use these, are you sure you knwo what you are
   // doing?
 
   void set_command (tree_command *c) { cmd = c; }
 
   void set_expression (tree_expression *e) { expr = e; }
 
   tree_statement *dup (symbol_table::scope_id scope,
-		       symbol_table::context_id context) const;
+                       symbol_table::context_id context) const;
 
   void accept (tree_walker& tw);
 
 private:
 
   // Only one of cmd or expr can be valid at once.
 
   // Command to execute.
@@ -130,21 +130,21 @@ public:
 
   tree_statement_list (tree_statement *s)
     : function_body (false), anon_function_body (false),
       script_body (false) { append (s); }
 
   ~tree_statement_list (void)
     {
       while (! empty ())
-	{
-	  iterator p = begin ();
-	  delete *p;
-	  erase (p);
-	}
+        {
+          iterator p = begin ();
+          delete *p;
+          erase (p);
+        }
     }
 
   void mark_as_function_body (void) { function_body = true; }
 
   void mark_as_anon_function_body (void) { anon_function_body = true; }
 
   void mark_as_script_body (void) { script_body = true; }
 
@@ -156,17 +156,17 @@ public:
 
   int set_breakpoint (int line);
 
   void delete_breakpoint (int line);
 
   octave_value_list list_breakpoints (void);
 
   tree_statement_list *dup (symbol_table::scope_id scope,
-			    symbol_table::context_id context) const;
+                            symbol_table::context_id context) const;
 
   void accept (tree_walker& tw);
 
 private:
 
   // Does this list of statements make up the body of a function?
   bool function_body;
 
diff --git a/src/pt-unop.h b/src/pt-unop.h
--- a/src/pt-unop.h
+++ b/src/pt-unop.h
@@ -38,23 +38,23 @@ class octave_lvalue;
 // Unary expressions.
 
 class
 tree_unary_expression : public tree_expression
 {
 public:
 
   tree_unary_expression (int l = -1, int c = -1,
-			 octave_value::unary_op t
-			   = octave_value::unknown_unary_op)
+                         octave_value::unary_op t
+                           = octave_value::unknown_unary_op)
     : tree_expression (l, c), op (0), etype (t)  { }
 
   tree_unary_expression (tree_expression *e, int l = -1, int c = -1,
-			 octave_value::unary_op t
-			   = octave_value::unknown_unary_op)
+                         octave_value::unary_op t
+                           = octave_value::unknown_unary_op)
     : tree_expression (l, c), op (e), etype (t) { }
 
   ~tree_unary_expression (void) { delete op; }
 
   bool is_unary_expression (void) const { return true; }
 
   bool has_magic_end (void) const { return (op && op->has_magic_end ()); }
 
@@ -87,30 +87,30 @@ class
 tree_prefix_expression : public tree_unary_expression
 {
 public:
 
   tree_prefix_expression (int l = -1, int c = -1)
     : tree_unary_expression (l, c, octave_value::unknown_unary_op) { }
 
   tree_prefix_expression (tree_expression *e, int l = -1, int c = -1,
-			  octave_value::unary_op t
-			    = octave_value::unknown_unary_op)
+                          octave_value::unary_op t
+                            = octave_value::unknown_unary_op)
     : tree_unary_expression (e, l, c, t) { }
 
   ~tree_prefix_expression (void) { }
 
   bool rvalue_ok (void) const { return true; }
 
   octave_value rvalue1 (int nargout = 1);
 
   octave_value_list rvalue (int nargout);
 
   tree_expression *dup (symbol_table::scope_id scope,
-			symbol_table::context_id context) const;
+                        symbol_table::context_id context) const;
 
   void accept (tree_walker& tw);
 
 private:
 
   // No copying!
 
   tree_prefix_expression (const tree_prefix_expression&);
@@ -124,30 +124,30 @@ class
 tree_postfix_expression : public tree_unary_expression
 {
 public:
 
   tree_postfix_expression (int l = -1, int c = -1)
     : tree_unary_expression (l, c, octave_value::unknown_unary_op) { }
 
   tree_postfix_expression (tree_expression *e, int l = -1, int c = -1,
-			   octave_value::unary_op t
-			     = octave_value::unknown_unary_op)
+                           octave_value::unary_op t
+                             = octave_value::unknown_unary_op)
     : tree_unary_expression (e, l, c, t) { }
 
   ~tree_postfix_expression (void) { }
 
   bool rvalue_ok (void) const { return true; }
 
   octave_value rvalue1 (int nargout = 1);
 
   octave_value_list rvalue (int nargout);
 
   tree_expression *dup (symbol_table::scope_id scope,
-			symbol_table::context_id context) const;
+                        symbol_table::context_id context) const;
 
   void accept (tree_walker& tw);
 
 private:
 
   // No copying!
 
   tree_postfix_expression (const tree_postfix_expression&);
diff --git a/src/sighandlers.h b/src/sighandlers.h
--- a/src/sighandlers.h
+++ b/src/sighandlers.h
@@ -85,29 +85,29 @@ octave_interrupt_handler
 // Nonzero means we have already printed a message for this series of
 // SIGPIPES.  We assume that the writer will eventually give up.
 extern int pipe_handler_error_count;
 
 // TRUE means we can be interrupted.
 extern OCTINTERP_API bool can_interrupt;
 
 extern OCTINTERP_API sig_handler *octave_set_signal_handler (int, sig_handler *,
-					       bool restart_syscalls = true);
+                                               bool restart_syscalls = true);
 
 extern OCTINTERP_API void install_signal_handlers (void);
 
 extern OCTINTERP_API void octave_signal_handler (void);
 
 extern OCTINTERP_API octave_interrupt_handler octave_catch_interrupts (void);
 
 extern OCTINTERP_API octave_interrupt_handler octave_ignore_interrupts (void);
 
 extern OCTINTERP_API octave_interrupt_handler
 octave_set_interrupt_handler (const volatile octave_interrupt_handler&,
-			      bool restart_syscalls = true);
+                              bool restart_syscalls = true);
 
 // extern void ignore_sigchld (void);
 
 // Maybe this should be in a separate file?
 
 class
 OCTINTERP_API
 octave_child
@@ -127,22 +127,22 @@ public:
 
   octave_child (const octave_child& oc)
     : pid (oc.pid), handler (oc.handler),
       have_status (oc.have_status), status (oc.status) { }
  
   octave_child& operator = (const octave_child& oc)
     {
       if (&oc != this)
-	{
-	  pid = oc.pid;
-	  handler = oc.handler;
-	  have_status = oc.have_status;
-	  status = oc.status;
-	}
+        {
+          pid = oc.pid;
+          handler = oc.handler;
+          have_status = oc.have_status;
+          status = oc.status;
+        }
       return *this;
     }
 
   ~octave_child (void) { }
 
   // The process id of this child.
   pid_t pid;
 
diff --git a/src/sparse-xdiv.h b/src/sparse-xdiv.h
--- a/src/sparse-xdiv.h
+++ b/src/sparse-xdiv.h
@@ -29,65 +29,65 @@ along with Octave; see the file COPYING.
 
 class DiagMatrix;
 class ComplexDiagMatrix;
 class SparseMatrix;
 class SparseComplexMatrix;
 
 extern Matrix xdiv (const Matrix& a, const SparseMatrix& b, MatrixType &typ);
 extern ComplexMatrix xdiv (const Matrix& a, const SparseComplexMatrix& b,
-			   MatrixType &typ);
+                           MatrixType &typ);
 extern ComplexMatrix xdiv (const ComplexMatrix& a, const SparseMatrix& b,
-			   MatrixType &typ);
+                           MatrixType &typ);
 extern ComplexMatrix xdiv (const ComplexMatrix& a, 
-			   const SparseComplexMatrix& b, MatrixType &typ);
+                           const SparseComplexMatrix& b, MatrixType &typ);
 
 extern SparseMatrix xdiv (const SparseMatrix& a, const SparseMatrix& b,
-			  MatrixType &typ);
+                          MatrixType &typ);
 extern SparseComplexMatrix xdiv (const SparseMatrix& a, 
-				 const SparseComplexMatrix& b, MatrixType &typ);
+                                 const SparseComplexMatrix& b, MatrixType &typ);
 extern SparseComplexMatrix xdiv (const SparseComplexMatrix& a, 
-				 const SparseMatrix& b, MatrixType &typ);
+                                 const SparseMatrix& b, MatrixType &typ);
 extern SparseComplexMatrix xdiv (const SparseComplexMatrix& a, 
-				 const SparseComplexMatrix& b, MatrixType &typ);
+                                 const SparseComplexMatrix& b, MatrixType &typ);
 
 extern SparseMatrix xdiv (const SparseMatrix& a, 
-			  const DiagMatrix& b, MatrixType &typ);
+                          const DiagMatrix& b, MatrixType &typ);
 extern SparseComplexMatrix xdiv (const SparseMatrix& a, 
-				 const ComplexDiagMatrix& b, MatrixType &typ);
+                                 const ComplexDiagMatrix& b, MatrixType &typ);
 extern SparseComplexMatrix xdiv (const SparseComplexMatrix& a, 
-				 const DiagMatrix& b, MatrixType &typ);
+                                 const DiagMatrix& b, MatrixType &typ);
 extern SparseComplexMatrix xdiv (const SparseComplexMatrix& a, 
-				 const ComplexDiagMatrix& b, MatrixType &typ);
+                                 const ComplexDiagMatrix& b, MatrixType &typ);
 
 extern Matrix x_el_div (double a, const SparseMatrix& b);
 extern ComplexMatrix x_el_div (double a, const SparseComplexMatrix& b);
 extern ComplexMatrix x_el_div (const Complex a, const SparseMatrix& b);
 extern ComplexMatrix x_el_div (const Complex a, 
-			       const SparseComplexMatrix& b);
+                               const SparseComplexMatrix& b);
 
 extern Matrix xleftdiv (const SparseMatrix& a, const Matrix& b, 
-			MatrixType& typ);
+                        MatrixType& typ);
 extern ComplexMatrix xleftdiv (const SparseMatrix& a, const ComplexMatrix& b,
-			       MatrixType &typ);
+                               MatrixType &typ);
 extern ComplexMatrix xleftdiv (const SparseComplexMatrix& a, const Matrix& b,
-			       MatrixType &typ);
+                               MatrixType &typ);
 extern ComplexMatrix xleftdiv (const SparseComplexMatrix& a, 
-			       const ComplexMatrix& b, MatrixType &typ);
+                               const ComplexMatrix& b, MatrixType &typ);
 
 extern SparseMatrix xleftdiv (const SparseMatrix& a, const SparseMatrix& b,
-			      MatrixType &typ);
+                              MatrixType &typ);
 extern SparseComplexMatrix xleftdiv (const SparseMatrix& a, 
-				     const SparseComplexMatrix& b, MatrixType &typ);
+                                     const SparseComplexMatrix& b, MatrixType &typ);
 extern SparseComplexMatrix xleftdiv (const SparseComplexMatrix& a, 
-				     const SparseMatrix& b, MatrixType &typ);
+                                     const SparseMatrix& b, MatrixType &typ);
 extern SparseComplexMatrix xleftdiv (const SparseComplexMatrix& a, 
-				     const SparseComplexMatrix& b, MatrixType &typ);
+                                     const SparseComplexMatrix& b, MatrixType &typ);
 
 extern SparseMatrix xleftdiv (const DiagMatrix&, const SparseMatrix&, MatrixType&);
 extern SparseComplexMatrix xleftdiv (const ComplexDiagMatrix&, const SparseMatrix&, 
-				     MatrixType&);
+                                     MatrixType&);
 extern SparseComplexMatrix xleftdiv (const DiagMatrix&, const SparseComplexMatrix&, 
-				     MatrixType&);
+                                     MatrixType&);
 extern SparseComplexMatrix xleftdiv (const ComplexDiagMatrix&, const SparseComplexMatrix&, 
-				     MatrixType&);
+                                     MatrixType&);
 
 #endif
diff --git a/src/sparse-xpow.h b/src/sparse-xpow.h
--- a/src/sparse-xpow.h
+++ b/src/sparse-xpow.h
@@ -35,23 +35,23 @@ extern octave_value xpow (const SparseCo
 
 extern octave_value elem_xpow (double a, const SparseMatrix& b);
 extern octave_value elem_xpow (double a, const SparseComplexMatrix& b);
 
 extern octave_value elem_xpow (const SparseMatrix& a, double b);
 extern octave_value elem_xpow (const SparseMatrix& a, const SparseMatrix& b);
 extern octave_value elem_xpow (const SparseMatrix& a, const Complex& b);
 extern octave_value elem_xpow (const SparseMatrix& a, 
-			       const SparseComplexMatrix& b);
+                               const SparseComplexMatrix& b);
 
 extern octave_value elem_xpow (const Complex& a, const SparseMatrix& b);
 extern octave_value elem_xpow (const Complex& a, 
-			       const SparseComplexMatrix& b);
+                               const SparseComplexMatrix& b);
 
 extern octave_value elem_xpow (const SparseComplexMatrix& a, double b);
 extern octave_value elem_xpow (const SparseComplexMatrix& a, 
-			       const SparseMatrix& b);
+                               const SparseMatrix& b);
 extern octave_value elem_xpow (const SparseComplexMatrix& a, 
-			       const Complex& b);
+                               const Complex& b);
 extern octave_value elem_xpow (const SparseComplexMatrix& a, 
-			       const SparseComplexMatrix& b);
+                               const SparseComplexMatrix& b);
 
 #endif
diff --git a/src/symtab.h b/src/symtab.h
--- a/src/symtab.h
+++ b/src/symtab.h
@@ -68,37 +68,37 @@ public:
     static scope_id alloc (void)
     {
       return instance_ok () ? instance->do_alloc () : -1;
     }
 
     static void free (scope_id scope)
     {
       if (instance_ok ())
-	return instance->do_free (scope);
+        return instance->do_free (scope);
     }
 
     static std::list<scope_id> scopes (void)
     {
       return instance_ok () ? instance->do_scopes () : std::list<scope_id> ();
     }
 
     static bool instance_ok (void)
     {
       bool retval = true;
 
       if (! instance)
-	instance = new scope_id_cache ();
+        instance = new scope_id_cache ();
 
       if (! instance)
-	{
-	  ::error ("unable to create scope_id_cache object!");
-
-	  retval = false;
-	}
+        {
+          ::error ("unable to create scope_id_cache object!");
+
+          retval = false;
+        }
 
       return retval;
     }
 
   private:
 
     static scope_id_cache *instance;
 
@@ -113,47 +113,47 @@ public:
 
     scope_id do_alloc (void)
     {
       scope_id retval;
 
       set_iterator p = free_list.begin ();
 
       if (p != free_list.end ())
-	{
-	  retval = *p;
-	  free_list.erase (p);
-	}
+        {
+          retval = *p;
+          free_list.erase (p);
+        }
       else
-	retval = next_available++;
+        retval = next_available++;
 
       in_use.insert (retval);
 
       return retval;
     }
 
     void do_free (scope_id scope)
     {
       set_iterator p = in_use.find (scope);
 
       if (p != in_use.end ())
-	{
-	  in_use.erase (p);
-	  free_list.insert (scope);
-	}
+        {
+          in_use.erase (p);
+          free_list.insert (scope);
+        }
       else
-	error ("free_scope: scope %d not found!", scope);
+        error ("free_scope: scope %d not found!", scope);
     }
 
     std::list<scope_id> do_scopes (void) const
     {
       std::list<scope_id> retval;
 
       for (set_const_iterator p = in_use.begin (); p != in_use.end (); p++)
-	retval.push_back (*p);
+        retval.push_back (*p);
 
       retval.sort ();
 
       return retval;
     }
   };
 
   class fcn_info;
@@ -191,65 +191,65 @@ public:
   private:
 
     class
     symbol_record_rep
     {
     public:
 
       symbol_record_rep (const std::string& nm, const octave_value& v,
-			 unsigned int sc)
-	: name (nm), value_stack (), storage_class (sc), finfo (), count (1)
+                         unsigned int sc)
+        : name (nm), value_stack (), storage_class (sc), finfo (), count (1)
       {
-	value_stack.push_back (v);
+        value_stack.push_back (v);
       }
 
       void force_variable (context_id context)
       {
-	octave_value& val = varref (context);
-
-	if (! val.is_defined ())
-	  mark_forced ();
+        octave_value& val = varref (context);
+
+        if (! val.is_defined ())
+          mark_forced ();
       }
 
       octave_value& varref (context_id context)
       {
-	if (is_global ())
-	  return symbol_table::global_varref (name);
-	else if (is_persistent ())
-	  return symbol_table::persistent_varref (name);
-	else
-	  {
-	    context_id n = value_stack.size ();
-	    while (n++ <= context)
-	      value_stack.push_back (octave_value ());
-
-	    return value_stack[context];
-	  }
+        if (is_global ())
+          return symbol_table::global_varref (name);
+        else if (is_persistent ())
+          return symbol_table::persistent_varref (name);
+        else
+          {
+            context_id n = value_stack.size ();
+            while (n++ <= context)
+              value_stack.push_back (octave_value ());
+
+            return value_stack[context];
+          }
       }
 
       octave_value varval (context_id context) const
       {
-	if (is_global ())
-	  return symbol_table::global_varval (name);
-	else if (is_persistent ())
-	  return symbol_table::persistent_varval (name);
-	else
-	  {
-	    if (context < value_stack.size ())
-	      return value_stack[context];
-	    else
-	      return octave_value ();
-	  }
+        if (is_global ())
+          return symbol_table::global_varval (name);
+        else if (is_persistent ())
+          return symbol_table::persistent_varval (name);
+        else
+          {
+            if (context < value_stack.size ())
+              return value_stack[context];
+            else
+              return octave_value ();
+          }
       }
 
       void push_context (void)
       {
-	if (! (is_persistent () || is_global ()))
-	  value_stack.push_back (octave_value ());
+        if (! (is_persistent () || is_global ()))
+          value_stack.push_back (octave_value ());
       }
 
       // If pop_context returns 0, we are out of values and this element
       // of the symbol table should be deleted.  This can happen for
       // functions like
       //
       //   function foo (n)
       //     if (n > 0)
@@ -258,54 +258,54 @@ public:
       //       eval ("x = 1");
       //     endif
       //   endfunction
       //
       // Here, X should only exist in the final stack frame.
 
       size_t pop_context (void)
       {
-	size_t retval = 1;
-
-	if (! (is_persistent () || is_global ()))
-	  {
-	    value_stack.pop_back ();
-	    retval = value_stack.size ();
-	  }
-
-	return retval;
+        size_t retval = 1;
+
+        if (! (is_persistent () || is_global ()))
+          {
+            value_stack.pop_back ();
+            retval = value_stack.size ();
+          }
+
+        return retval;
       }
 
       void clear (void)
       {
-	if (! (is_hidden () || is_inherited ()))
-	  {
-	    if (is_global ())
-	      unmark_global ();
-
-	    if (is_persistent ())
-	      {
-		symbol_table::persistent_varref (name)
-		  = varval (xcurrent_context);
-
-		unmark_persistent ();
-	      }
-
-	    varref (xcurrent_context) = octave_value ();
-	  }
+        if (! (is_hidden () || is_inherited ()))
+          {
+            if (is_global ())
+              unmark_global ();
+
+            if (is_persistent ())
+              {
+                symbol_table::persistent_varref (name)
+                  = varval (xcurrent_context);
+
+                unmark_persistent ();
+              }
+
+            varref (xcurrent_context) = octave_value ();
+          }
       }
 
       bool is_defined (context_id context) const
       {
-	return varval (context).is_defined ();
+        return varval (context).is_defined ();
       }
 
       bool is_variable (context_id context) const
       {
-	return (! is_local () || is_defined (context) || is_forced ());
+        return (! is_local () || is_defined (context) || is_forced ());
       }
 
       bool is_local (void) const { return storage_class & local; }
       bool is_automatic (void) const { return storage_class & automatic; }
       bool is_formal (void) const { return storage_class & formal; }
       bool is_hidden (void) const { return storage_class & hidden; }
       bool is_inherited (void) const { return storage_class & inherited; }
       bool is_global (void) const { return storage_class & global; }
@@ -314,62 +314,62 @@ public:
 
       void mark_local (void) { storage_class |= local; }
       void mark_automatic (void) { storage_class |= automatic; }
       void mark_formal (void) { storage_class |= formal; }
       void mark_hidden (void) { storage_class |= hidden; }
       void mark_inherited (void) { storage_class |= inherited; }
       void mark_global (void)
       {
-	if (is_persistent ())
-	  error ("can't make persistent variable %s global", name.c_str ());
-	else
-	  storage_class |= global;
+        if (is_persistent ())
+          error ("can't make persistent variable %s global", name.c_str ());
+        else
+          storage_class |= global;
       }
       void mark_persistent (void)
       {
-	if (is_global ())
-	  error ("can't make global variable %s persistent", name.c_str ());
-	else
-	  storage_class |= persistent;
+        if (is_global ())
+          error ("can't make global variable %s persistent", name.c_str ());
+        else
+          storage_class |= persistent;
       }
       void mark_forced (void) { storage_class |= forced; }
 
       void unmark_local (void) { storage_class &= ~local; }
       void unmark_automatic (void) { storage_class &= ~automatic; }
       void unmark_formal (void) { storage_class &= ~formal; }
       void unmark_hidden (void) { storage_class &= ~hidden; }
       void unmark_inherited (void) { storage_class &= ~inherited; }
       void unmark_global (void) { storage_class &= ~global; }
       void unmark_persistent (void) { storage_class &= ~persistent; }
       void unmark_forced (void) { storage_class &= ~forced; }
 
       void init_persistent (void)
       {
-	if (! is_defined (xcurrent_context))
-	  {
-	    mark_persistent ();
-
-	    varref (xcurrent_context) = symbol_table::persistent_varval (name);
-	  }
-	// FIXME -- this causes trouble with recursive calls.
-	// else
-	//   error ("unable to declare existing variable persistent");
+        if (! is_defined (xcurrent_context))
+          {
+            mark_persistent ();
+
+            varref (xcurrent_context) = symbol_table::persistent_varval (name);
+          }
+        // FIXME -- this causes trouble with recursive calls.
+        // else
+        //   error ("unable to declare existing variable persistent");
       }
 
       void erase_persistent (void)
       {
-	unmark_persistent ();
-	symbol_table::erase_persistent (name);
+        unmark_persistent ();
+        symbol_table::erase_persistent (name);
       }
 
       symbol_record_rep *dup (void) const
       {
-	return new symbol_record_rep (name, varval (xcurrent_context),
-				      storage_class);
+        return new symbol_record_rep (name, varval (xcurrent_context),
+                                      storage_class);
       }
 
       void dump (std::ostream& os, const std::string& prefix) const;
 
       std::string name;
 
       std::deque<octave_value> value_stack;
 
@@ -386,44 +386,44 @@ public:
       symbol_record_rep (const symbol_record_rep& ov);
 
       symbol_record_rep& operator = (const symbol_record_rep&);
     };
 
   public:
 
     symbol_record (const std::string& nm = std::string (),
-		   const octave_value& v = octave_value (),
-		   unsigned int sc = local)
+                   const octave_value& v = octave_value (),
+                   unsigned int sc = local)
       : rep (new symbol_record_rep (nm, v, sc)) { }
 
     symbol_record (const symbol_record& sr)
       : rep (sr.rep)
     { 
       rep->count++;
     }
 
     symbol_record& operator = (const symbol_record& sr)
     {
       if (this != &sr)
-	{
-	  if (--rep->count == 0)
-	    delete rep;
-
-	  rep = sr.rep;
-	  rep->count++;
-	}
+        {
+          if (--rep->count == 0)
+            delete rep;
+
+          rep = sr.rep;
+          rep->count++;
+        }
 
       return *this;
     }
 
     ~symbol_record (void)
     {
       if (--rep->count == 0)
-	delete rep;
+        delete rep;
     }
 
     symbol_record dup (void) const { return symbol_record (rep->dup ()); }
 
     std::string name (void) const { return rep->name; }
 
     octave_value find (const octave_value_list& args = octave_value_list ()) const;
 
@@ -523,20 +523,20 @@ public:
   private:
 
     class
     fcn_info_rep
     {
     public:
 
       fcn_info_rep (const std::string& nm)
-	: name (nm), subfunctions (), private_functions (),
-	  class_constructors (), class_methods (), cmdline_function (),
-	  autoload_function (), function_on_path (), built_in_function (),
-	  count (1) { }
+        : name (nm), subfunctions (), private_functions (),
+          class_constructors (), class_methods (), cmdline_function (),
+          autoload_function (), function_on_path (), built_in_function (),
+          count (1) { }
 
       octave_value load_private_function (const std::string& dir_name);
 
       octave_value load_class_constructor (void);
 
       octave_value load_class_method (const std::string& dispatch_type);
 
       octave_value find (const octave_value_list& args, bool local_funcs);
@@ -546,145 +546,145 @@ public:
       octave_value find_method (const std::string& dispatch_type);
 
       octave_value find_autoload (void);
 
       octave_value find_user_function (void);
 
       bool is_user_function_defined (void) const
       {
-	return function_on_path.is_defined ();
+        return function_on_path.is_defined ();
       }
 
       octave_value find_function (const octave_value_list& args, bool local_funcs)
       {
-	return find (args, local_funcs);
+        return find (args, local_funcs);
       }
 
       void lock_subfunction (scope_id scope)
       {
-	scope_val_iterator p = subfunctions.find (scope);
-
-	if (p != subfunctions.end ())
-	  p->second.lock ();
+        scope_val_iterator p = subfunctions.find (scope);
+
+        if (p != subfunctions.end ())
+          p->second.lock ();
       }
 
       void unlock_subfunction (scope_id scope)
       {
-	scope_val_iterator p = subfunctions.find (scope);
-
-	if (p != subfunctions.end ())
-	  p->second.unlock ();
+        scope_val_iterator p = subfunctions.find (scope);
+
+        if (p != subfunctions.end ())
+          p->second.unlock ();
       }
 
       std::pair<std::string, octave_value>
       subfunction_defined_in_scope (scope_id scope) const
       {
-	scope_val_const_iterator p = subfunctions.find (scope);
-
-	return p == subfunctions.end ()
-	  ? std::pair<std::string, octave_value> ()
-	  : std::pair<std::string, octave_value> (name, p->second);
-      }	     
+        scope_val_const_iterator p = subfunctions.find (scope);
+
+        return p == subfunctions.end ()
+          ? std::pair<std::string, octave_value> ()
+          : std::pair<std::string, octave_value> (name, p->second);
+      }      
 
       void erase_subfunction (scope_id scope)
       {
-	scope_val_iterator p = subfunctions.find (scope);
-
-	if (p != subfunctions.end ())
-	  subfunctions.erase (p);
+        scope_val_iterator p = subfunctions.find (scope);
+
+        if (p != subfunctions.end ())
+          subfunctions.erase (p);
       }
 
       void install_cmdline_function (const octave_value& f)
       {
-	cmdline_function = f;
+        cmdline_function = f;
       }
 
       void install_subfunction (const octave_value& f, scope_id scope)
       {
-	subfunctions[scope] = f;
+        subfunctions[scope] = f;
       }
 
       void install_user_function (const octave_value& f)
       {
-	function_on_path = f;
+        function_on_path = f;
       }
 
       void install_built_in_function (const octave_value& f)
       {
-	built_in_function = f;
+        built_in_function = f;
       }
 
       template <class T>
       void
       clear_unlocked (std::map<T, octave_value>& map)
       {
-	typename std::map<T, octave_value>::iterator p = map.begin ();
-
-	while (p != map.end ())
-	  {
-	    if (p->second.islocked ())
-	      p++;
-	    else
-	      map.erase (p++);
-	  }
+        typename std::map<T, octave_value>::iterator p = map.begin ();
+
+        while (p != map.end ())
+          {
+            if (p->second.islocked ())
+              p++;
+            else
+              map.erase (p++);
+          }
       }
 
       void clear_cmdline_function (void)
       {
-	if (! cmdline_function.islocked ())
-	  cmdline_function = octave_value ();
+        if (! cmdline_function.islocked ())
+          cmdline_function = octave_value ();
       }
 
       void clear_autoload_function (void)
       {
-	if (! autoload_function.islocked ())
-	  autoload_function = octave_value ();
+        if (! autoload_function.islocked ())
+          autoload_function = octave_value ();
       }
 
       // FIXME -- should this also clear the cmdline and other "user
       // defined" functions?
       void clear_user_function (void)
       {
-	if (! function_on_path.islocked ())
-	  {
-	    function_on_path.erase_subfunctions ();
-
-	    function_on_path = octave_value ();
-	  }
+        if (! function_on_path.islocked ())
+          {
+            function_on_path.erase_subfunctions ();
+
+            function_on_path = octave_value ();
+          }
       }
 
       void clear_mex_function (void)
       {
-	if (function_on_path.is_mex_function ())
-	  clear_user_function ();
+        if (function_on_path.is_mex_function ())
+          clear_user_function ();
       }
 
       void clear (void)
       {
-	clear_unlocked (subfunctions);
-	clear_unlocked (private_functions);
-	clear_unlocked (class_constructors);
-	clear_unlocked (class_methods);
-	clear_cmdline_function ();
-	clear_autoload_function ();
-	clear_user_function ();
+        clear_unlocked (subfunctions);
+        clear_unlocked (private_functions);
+        clear_unlocked (class_constructors);
+        clear_unlocked (class_methods);
+        clear_cmdline_function ();
+        clear_autoload_function ();
+        clear_user_function ();
       }
 
       void add_dispatch (const std::string& type, const std::string& fname)
       {
-	dispatch_map[type] = fname;
+        dispatch_map[type] = fname;
       }
 
       void clear_dispatch (const std::string& type)
       {
-	dispatch_map_iterator p = dispatch_map.find (type);
-
-	if (p != dispatch_map.end ())
-	  dispatch_map.erase (p);
+        dispatch_map_iterator p = dispatch_map.find (type);
+
+        if (p != dispatch_map.end ())
+          dispatch_map.erase (p);
       }
 
       void print_dispatch (std::ostream& os) const;
 
       std::string help_for_dispatch (void) const;
 
       dispatch_map_type get_dispatch (void) const { return dispatch_map; }
 
@@ -738,31 +738,31 @@ public:
     fcn_info (const fcn_info& fi) : rep (fi.rep)
     { 
       rep->count++;
     }
 
     fcn_info& operator = (const fcn_info& fi)
     {
       if (this != &fi)
-	{
-	  if (--rep->count == 0)
-	    delete rep;
-
-	  rep = fi.rep;
-	  rep->count++;
-	}
+        {
+          if (--rep->count == 0)
+            delete rep;
+
+          rep = fi.rep;
+          rep->count++;
+        }
 
       return *this;
     }
 
     ~fcn_info (void)
     {
       if (--rep->count == 0)
-	delete rep;
+        delete rep;
     }
 
     octave_value find (const octave_value_list& args = octave_value_list (),
                        bool local_funcs = true)
     {
       return rep->find (args, local_funcs);
     }
 
@@ -811,17 +811,17 @@ public:
     {
       rep->unlock_subfunction (scope);
     }
 
     std::pair<std::string, octave_value>
     subfunction_defined_in_scope (scope_id scope = xcurrent_scope) const
     {
       return rep->subfunction_defined_in_scope (scope);
-    }	     
+    }        
 
     void erase_subfunction (scope_id scope)
     {
       rep->erase_subfunction (scope);
     }
 
     void install_cmdline_function (const octave_value& f)
     {
@@ -894,102 +894,102 @@ public:
   static scope_id alloc_scope (void) { return scope_id_cache::alloc (); }
 
   static void set_scope (scope_id scope)
   {
     if (scope == xglobal_scope)
       error ("can't set scope to global");
     else if (scope != xcurrent_scope)
       {
-	all_instances_iterator p = all_instances.find (scope);
-
-	if (p == all_instances.end ())
-	  {
-	    symbol_table *inst = new symbol_table ();
-
-	    if (inst)
-	      all_instances[scope] = instance = inst;
-	  }
-	else
-	  instance = p->second;
-
-	xcurrent_scope = scope;
-	xcurrent_context = 0;
+        all_instances_iterator p = all_instances.find (scope);
+
+        if (p == all_instances.end ())
+          {
+            symbol_table *inst = new symbol_table ();
+
+            if (inst)
+              all_instances[scope] = instance = inst;
+          }
+        else
+          instance = p->second;
+
+        xcurrent_scope = scope;
+        xcurrent_context = 0;
       }
   }
 
   static void set_scope_and_context (scope_id scope, context_id context)
   {
     if (scope == xglobal_scope)
       error ("can't set scope to global");
     else
       {
-	if (scope != xcurrent_scope)
-	  {
-	    all_instances_iterator p = all_instances.find (scope);
-
-	    if (p == all_instances.end ())
-	      error ("scope not found!");
-	    else
-	      {
-		instance = p->second;
-
-		xcurrent_scope = scope;
+        if (scope != xcurrent_scope)
+          {
+            all_instances_iterator p = all_instances.find (scope);
+
+            if (p == all_instances.end ())
+              error ("scope not found!");
+            else
+              {
+                instance = p->second;
+
+                xcurrent_scope = scope;
 
                 xcurrent_context = context;
-	      }
-	  }
+              }
+          }
         else
           xcurrent_context = context;
       }
   }
 
   static void erase_scope (scope_id scope)
   {
     assert (scope != xglobal_scope);
 
     all_instances_iterator p = all_instances.find (scope);
 
     if (p != all_instances.end ())
       {
-	delete p->second;
-
-	all_instances.erase (p);
-
-	free_scope (scope);
+        delete p->second;
+
+        all_instances.erase (p);
+
+        free_scope (scope);
       }
   }
 
   static void erase_subfunctions_in_scope (scope_id scope)
   {
     for (fcn_table_iterator q = fcn_table.begin ();
-	 q != fcn_table.end (); q++)
+         q != fcn_table.end (); q++)
       q->second.erase_subfunction (scope);
   }
 
   static scope_id dup_scope (scope_id scope)
   {
     scope_id retval = -1;
 
     symbol_table *inst = get_instance (scope);
 
     if (inst)
       {
-	scope_id new_scope = alloc_scope ();
-
-	symbol_table *new_symbol_table = new symbol_table ();
-
-	if (new_symbol_table)
-	  {
-	    all_instances[new_scope] = new_symbol_table;
-
-	    inst->do_dup_scope (*new_symbol_table);
-
-	    retval = new_scope;
-	  }
+        scope_id new_scope = alloc_scope ();
+
+        symbol_table *new_symbol_table = new symbol_table ();
+
+        if (new_symbol_table)
+          {
+            all_instances[new_scope] = new_symbol_table;
+
+            inst->do_dup_scope (*new_symbol_table);
+
+            retval = new_scope;
+          }
       }
 
     return retval;
   }
 
   static std::list<scope_id> scopes (void)
   {
     return scope_id_cache::scopes ();
@@ -1005,68 +1005,68 @@ public:
 
   static void
   inherit (scope_id scope, scope_id donor_scope, context_id donor_context)
   {
     symbol_table *inst = get_instance (scope);
 
     if (inst)
       {
-	symbol_table *donor_symbol_table = get_instance (donor_scope);
-
-	if (donor_symbol_table)
-	  inst->do_inherit (*donor_symbol_table, donor_context);
+        symbol_table *donor_symbol_table = get_instance (donor_scope);
+
+        if (donor_symbol_table)
+          inst->do_inherit (*donor_symbol_table, donor_context);
       }
   }
 
   static bool at_top_level (void) { return xcurrent_scope == xtop_scope; }
 
   // Find a value corresponding to the given name in the table.
   static octave_value
   find (const std::string& name, 
         const octave_value_list& args = octave_value_list (),
-	bool skip_variables = false,
+        bool skip_variables = false,
         bool local_funcs = true);
 
   static octave_value builtin_find (const std::string& name);
 
   // Insert a new name in the table.
   static symbol_record& insert (const std::string& name)
   {
     static symbol_record foobar;
 
     symbol_table *inst = get_instance (xcurrent_scope);
 
     return inst ? inst->do_insert (name) : foobar;
   }
 
   static void force_variable (const std::string& name,
-			      scope_id scope = xcurrent_scope,
-			      context_id context = xcurrent_context)
+                              scope_id scope = xcurrent_scope,
+                              context_id context = xcurrent_context)
   {
     symbol_table *inst = get_instance (scope);
 
     if (inst)
       inst->do_force_variable (name, context);
   }
 
   static octave_value& varref (const std::string& name,
-			       scope_id scope = xcurrent_scope,
-			       context_id context = xcurrent_context)
+                               scope_id scope = xcurrent_scope,
+                               context_id context = xcurrent_context)
   {
     static octave_value foobar;
 
     symbol_table *inst = get_instance (scope);
 
     return inst ? inst->do_varref (name, context) : foobar;
   }
 
   static octave_value varval (const std::string& name,
-			      scope_id scope = xcurrent_scope,
-			      context_id context = xcurrent_context)
+                              scope_id scope = xcurrent_scope,
+                              context_id context = xcurrent_context)
   {
     symbol_table *inst = get_instance (scope);
 
     return inst ? inst->do_varval (name, context) : octave_value ();
   }
 
   static octave_value&
   global_varref (const std::string& name)
@@ -1139,24 +1139,24 @@ public:
   find_method (const std::string& name, const std::string& dispatch_type)
   {
     fcn_table_const_iterator p = fcn_table.find (name);
 
     if (p != fcn_table.end ())
       return p->second.find_method (dispatch_type);
     else
       {
-	fcn_info finfo (name);
-
-	octave_value fcn = finfo.find_method (dispatch_type);
-
-	if (fcn.is_defined ())
-	  fcn_table[name] = finfo;
-
-	return fcn;
+        fcn_info finfo (name);
+
+        octave_value fcn = finfo.find_method (dispatch_type);
+
+        if (fcn.is_defined ())
+          fcn_table[name] = finfo;
+
+        return fcn;
       }
   }
 
   static octave_value
   find_built_in_function (const std::string& name)
   {
     fcn_table_const_iterator p = fcn_table.find (name);
 
@@ -1182,97 +1182,97 @@ public:
   {
     fcn_table_iterator p = fcn_table.find (name);
 
     return (p != fcn_table.end ())
       ? p->second.find_user_function () : octave_value ();
   }
 
   static void install_cmdline_function (const std::string& name,
-					const octave_value& fcn)
+                                        const octave_value& fcn)
   {
     fcn_table_iterator p = fcn_table.find (name);
 
     if (p != fcn_table.end ())
       {
-	fcn_info& finfo = p->second;
-
-	finfo.install_cmdline_function (fcn);
+        fcn_info& finfo = p->second;
+
+        finfo.install_cmdline_function (fcn);
       }
     else
       {
-	fcn_info finfo (name);
-
-	finfo.install_cmdline_function (fcn);
-
-	fcn_table[name] = finfo;
+        fcn_info finfo (name);
+
+        finfo.install_cmdline_function (fcn);
+
+        fcn_table[name] = finfo;
       }
   }
 
   static void install_subfunction (const std::string& name,
-				   const octave_value& fcn,
-				   scope_id scope)
+                                   const octave_value& fcn,
+                                   scope_id scope)
   {
     fcn_table_iterator p = fcn_table.find (name);
 
     if (p != fcn_table.end ())
       {
-	fcn_info& finfo = p->second;
-
-	finfo.install_subfunction (fcn, scope);
+        fcn_info& finfo = p->second;
+
+        finfo.install_subfunction (fcn, scope);
       }
     else
       {
-	fcn_info finfo (name);
-
-	finfo.install_subfunction (fcn, scope);
-
-	fcn_table[name] = finfo;
+        fcn_info finfo (name);
+
+        finfo.install_subfunction (fcn, scope);
+
+        fcn_table[name] = finfo;
       }
   }
 
   static void install_user_function (const std::string& name,
-				     const octave_value& fcn)
+                                     const octave_value& fcn)
   {
     fcn_table_iterator p = fcn_table.find (name);
 
     if (p != fcn_table.end ())
       {
-	fcn_info& finfo = p->second;
-
-	finfo.install_user_function (fcn);
+        fcn_info& finfo = p->second;
+
+        finfo.install_user_function (fcn);
       }
     else
       {
-	fcn_info finfo (name);
-
-	finfo.install_user_function (fcn);
-
-	fcn_table[name] = finfo;
+        fcn_info finfo (name);
+
+        finfo.install_user_function (fcn);
+
+        fcn_table[name] = finfo;
       }
   }
 
   static void install_built_in_function (const std::string& name,
-					 const octave_value& fcn)
+                                         const octave_value& fcn)
   {
     fcn_table_iterator p = fcn_table.find (name);
 
     if (p != fcn_table.end ())
       {
-	fcn_info& finfo = p->second;
-
-	finfo.install_built_in_function (fcn);
+        fcn_info& finfo = p->second;
+
+        finfo.install_built_in_function (fcn);
       }
     else
       {
-	fcn_info finfo (name);
-
-	finfo.install_built_in_function (fcn);
-
-	fcn_table[name] = finfo;
+        fcn_info finfo (name);
+
+        finfo.install_built_in_function (fcn);
+
+        fcn_table[name] = finfo;
       }
   }
 
   static void clear (const std::string& name)
   {
     clear_variable (name);
   }
 
@@ -1349,18 +1349,18 @@ public:
   }
 
   static void clear_function_pattern (const std::string& pat)
   {
     glob_match pattern (pat);
 
     for (fcn_table_iterator p = fcn_table.begin (); p != fcn_table.end (); p++)
       {
-	if (pattern.match (p->first))
-	  p->second.clear_user_function ();
+        if (pattern.match (p->first))
+          p->second.clear_user_function ();
       }
   }
 
   static void clear_global_pattern (const std::string& pat)
   {
     symbol_table *inst = get_instance (xcurrent_scope);
 
     if (inst)
@@ -1392,171 +1392,171 @@ public:
   }
 
   static void clear_user_function (const std::string& name)
   {
     fcn_table_iterator p = fcn_table.find (name);
 
     if (p != fcn_table.end ())
       {
-	fcn_info& finfo = p->second;
-
-	finfo.clear_user_function ();
+        fcn_info& finfo = p->second;
+
+        finfo.clear_user_function ();
       }
     // FIXME -- is this necessary, or even useful?
     // else
     //   error ("clear: no such function `%s'", name.c_str ());
   }
 
   // This clears oct and mex files, incl. autoloads.
   static void clear_dld_function (const std::string& name)
   {
     fcn_table_iterator p = fcn_table.find (name);
 
     if (p != fcn_table.end ())
       {
-	fcn_info& finfo = p->second;
-
-	finfo.clear_autoload_function ();
-	finfo.clear_user_function ();
+        fcn_info& finfo = p->second;
+
+        finfo.clear_autoload_function ();
+        finfo.clear_user_function ();
       }
   }
 
   static void clear_mex_functions (void)
   {
     for (fcn_table_iterator p = fcn_table.begin (); p != fcn_table.end (); p++)
       {
-	fcn_info& finfo = p->second;
-
-	finfo.clear_mex_function ();
+        fcn_info& finfo = p->second;
+
+        finfo.clear_mex_function ();
       }
   }
 
   static bool set_class_relationship (const std::string& sup_class,
-				      const std::string& inf_class);
+                                      const std::string& inf_class);
 
   static bool is_superiorto (const std::string& a, const std::string& b);
     
   static void alias_built_in_function (const std::string& alias,
-				       const std::string& name)
+                                       const std::string& name)
   {
     octave_value fcn = find_built_in_function (name);
 
     if (fcn.is_defined ())
       {
-	fcn_info finfo (alias);
-
-	finfo.install_built_in_function (fcn);
-
-	fcn_table[alias] = finfo;
+        fcn_info finfo (alias);
+
+        finfo.install_built_in_function (fcn);
+
+        fcn_table[alias] = finfo;
       }
     else
       panic ("alias: `%s' is undefined", name.c_str ());
   }
 
   static void add_dispatch (const std::string& name, const std::string& type,
-			    const std::string& fname)
+                            const std::string& fname)
   {
     fcn_table_iterator p = fcn_table.find (name);
 
     if (p != fcn_table.end ())
       {
-	fcn_info& finfo = p->second;
-
-	finfo.add_dispatch (type, fname);
+        fcn_info& finfo = p->second;
+
+        finfo.add_dispatch (type, fname);
       }
     else
       {
-	fcn_info finfo (name);
-
-	finfo.add_dispatch (type, fname);
-
-	fcn_table[name] = finfo;
+        fcn_info finfo (name);
+
+        finfo.add_dispatch (type, fname);
+
+        fcn_table[name] = finfo;
       }
   }
 
   static void clear_dispatch (const std::string& name, const std::string& type)
   {
     fcn_table_iterator p = fcn_table.find (name);
 
     if (p != fcn_table.end ())
       {
-	fcn_info& finfo = p->second;
-
-	finfo.clear_dispatch (type);
+        fcn_info& finfo = p->second;
+
+        finfo.clear_dispatch (type);
       }
   }
 
   static void print_dispatch (std::ostream& os, const std::string& name)
   {
     fcn_table_iterator p = fcn_table.find (name);
 
     if (p != fcn_table.end ())
       {
-	fcn_info& finfo = p->second;
-
-	finfo.print_dispatch (os);
+        fcn_info& finfo = p->second;
+
+        finfo.print_dispatch (os);
       }
   }
 
   static fcn_info::dispatch_map_type get_dispatch (const std::string& name)
   {
     fcn_info::dispatch_map_type retval;
 
     fcn_table_iterator p = fcn_table.find (name);
 
     if (p != fcn_table.end ())
       {
-	fcn_info& finfo = p->second;
-
-	retval = finfo.get_dispatch ();
+        fcn_info& finfo = p->second;
+
+        retval = finfo.get_dispatch ();
       }
 
     return retval;
   }
 
   static std::string help_for_dispatch (const std::string& name)
   {
     std::string retval;
 
     fcn_table_iterator p = fcn_table.find (name);
 
     if (p != fcn_table.end ())
       {
-	fcn_info& finfo = p->second;
-
-	retval = finfo.help_for_dispatch ();
+        fcn_info& finfo = p->second;
+
+        retval = finfo.help_for_dispatch ();
       }
 
     return retval;
   }
 
   static void push_context (void)
   {
     if (xcurrent_scope == xglobal_scope || xcurrent_scope == xtop_scope)
       error ("invalid call to xymtab::push_context");
     else
       {
-	symbol_table *inst = get_instance (xcurrent_scope);
-
-	if (inst)
-	  inst->do_push_context ();
+        symbol_table *inst = get_instance (xcurrent_scope);
+
+        if (inst)
+          inst->do_push_context ();
       }
   }
 
   static void pop_context (void)
   {
     if (xcurrent_scope == xglobal_scope || xcurrent_scope == xtop_scope)
       error ("invalid call to xymtab::pop_context");
     else
       {
-	symbol_table *inst = get_instance (xcurrent_scope);
-
-	if (inst)
-	  inst->do_pop_context ();
+        symbol_table *inst = get_instance (xcurrent_scope);
+
+        if (inst)
+          inst->do_pop_context ();
       }
   }
 
   // For unwind_protect.
   static void pop_context (void *) { pop_context (); }
 
   static void mark_hidden (const std::string& name)
   {
@@ -1571,18 +1571,18 @@ public:
     symbol_table *inst = get_instance (xcurrent_scope);
 
     if (inst)
       inst->do_mark_global (name);
   }
 
   static std::list<symbol_record>
   all_variables (scope_id scope = xcurrent_scope,
-		 context_id context = xcurrent_context,
-		 bool defined_only = true)
+                 context_id context = xcurrent_context,
+                 bool defined_only = true)
   {
     symbol_table *inst = get_instance (scope);
 
     return inst
       ? inst->do_all_variables (context, defined_only) : std::list<symbol_record> ();
   }
 
   static std::list<symbol_record> glob (const std::string& pattern)
@@ -1616,108 +1616,108 @@ public:
   static std::list<symbol_record>
   glob_global_variables (const std::string& pattern)
   {
     std::list<symbol_record> retval;
 
     glob_match pat (pattern);
 
     for (global_table_const_iterator p = global_table.begin ();
-	 p != global_table.end (); p++)
+         p != global_table.end (); p++)
       {
-	// We generate a list of symbol_record objects so that
-	// the results from glob_variables and glob_global_variables
-	// may be handled the same way.
-
-	if (pat.match (p->first))
-	  retval.push_back (symbol_record (p->first, p->second,
-					   symbol_record::global));
+        // We generate a list of symbol_record objects so that
+        // the results from glob_variables and glob_global_variables
+        // may be handled the same way.
+
+        if (pat.match (p->first))
+          retval.push_back (symbol_record (p->first, p->second,
+                                           symbol_record::global));
       }
 
     return retval;
   }
 
   static std::list<symbol_record>
   regexp_global_variables (const std::string& pattern)
   {
     std::list<symbol_record> retval;
 
     regex_match pat (pattern);
 
     for (global_table_const_iterator p = global_table.begin ();
-	 p != global_table.end (); p++)
+         p != global_table.end (); p++)
       {
-	// We generate a list of symbol_record objects so that
-	// the results from regexp_variables and regexp_global_variables
-	// may be handled the same way.
-
-	if (pat.match (p->first))
-	  retval.push_back (symbol_record (p->first, p->second,
-					   symbol_record::global));
+        // We generate a list of symbol_record objects so that
+        // the results from regexp_variables and regexp_global_variables
+        // may be handled the same way.
+
+        if (pat.match (p->first))
+          retval.push_back (symbol_record (p->first, p->second,
+                                           symbol_record::global));
       }
 
     return retval;
   }
 
   static std::list<symbol_record> glob_variables (const string_vector& patterns)
   {
     std::list<symbol_record> retval;
 
     size_t len = patterns.length ();
 
     for (size_t i = 0; i < len; i++)
       {
-	std::list<symbol_record> tmp = glob_variables (patterns[i]);
-
-	retval.insert (retval.begin (), tmp.begin (), tmp.end ());
+        std::list<symbol_record> tmp = glob_variables (patterns[i]);
+
+        retval.insert (retval.begin (), tmp.begin (), tmp.end ());
       }
 
     return retval;
   }
 
   static std::list<symbol_record> regexp_variables 
     (const string_vector& patterns)
   {
     std::list<symbol_record> retval;
 
     size_t len = patterns.length ();
 
     for (size_t i = 0; i < len; i++)
       {
-	std::list<symbol_record> tmp = regexp_variables (patterns[i]);
-
-	retval.insert (retval.begin (), tmp.begin (), tmp.end ());
+        std::list<symbol_record> tmp = regexp_variables (patterns[i]);
+
+        retval.insert (retval.begin (), tmp.begin (), tmp.end ());
       }
 
     return retval;
   }
 
   static std::list<std::string> user_function_names (void)
   {
     std::list<std::string> retval;
 
     for (fcn_table_iterator p = fcn_table.begin ();
-	 p != fcn_table.end (); p++)
+         p != fcn_table.end (); p++)
       {
-	if (p->second.is_user_function_defined ())
-	  retval.push_back (p->first);
+        if (p->second.is_user_function_defined ())
+          retval.push_back (p->first);
       }
 
     if (! retval.empty ())
       retval.sort ();
 
     return retval;
   }
 
   static std::list<std::string> global_variable_names (void)
   {
     std::list<std::string> retval;
 
     for (global_table_const_iterator p = global_table.begin ();
-	 p != global_table.end (); p++)
+         p != global_table.end (); p++)
       retval.push_back (p->first);
 
     retval.sort ();
 
     return retval;
   }
 
   static std::list<std::string> top_level_variable_names (void)
@@ -1734,51 +1734,51 @@ public:
     return inst ? inst->do_variable_names () : std::list<std::string> ();
   }
 
   static std::list<std::string> built_in_function_names (void)
   {
     std::list<std::string> retval;
 
     for (fcn_table_const_iterator p = fcn_table.begin ();
-	 p != fcn_table.end (); p++)
+         p != fcn_table.end (); p++)
       {
-	octave_value fcn = p->second.find_built_in_function ();
-
-	if (fcn.is_defined ())
-	  retval.push_back (p->first);
+        octave_value fcn = p->second.find_built_in_function ();
+
+        if (fcn.is_defined ())
+          retval.push_back (p->first);
       }
 
     if (! retval.empty ())
       retval.sort ();
 
     return retval;
   }
 
   static bool is_local_variable (const std::string& name)
   {
     if (xcurrent_scope == xglobal_scope)
       return false;
     else
       {
-	symbol_table *inst = get_instance (xcurrent_scope);
-
-	return inst ? inst->do_is_local_variable (name) : false;
+        symbol_table *inst = get_instance (xcurrent_scope);
+
+        return inst ? inst->do_is_local_variable (name) : false;
       }
   }
 
   static bool is_global (const std::string& name)
   {
     if (xcurrent_scope == xglobal_scope)
       return true;
     else
       {
-	symbol_table *inst = get_instance (xcurrent_scope);
-
-	return inst ? inst->do_is_global (name) : false;
+        symbol_table *inst = get_instance (xcurrent_scope);
+
+        return inst ? inst->do_is_global (name) : false;
       }
   }
 
   static void dump (std::ostream& os, scope_id scope = xcurrent_scope);
 
   static void dump_global (std::ostream& os);
 
   static void dump_functions (std::ostream& os);
@@ -1789,40 +1789,40 @@ public:
 
     if (inst)
       inst->do_cache_name (name);
   }
 
   static void lock_subfunctions (scope_id scope = xcurrent_scope)
   {
     for (fcn_table_iterator p = fcn_table.begin ();
-	 p != fcn_table.end (); p++)
+         p != fcn_table.end (); p++)
       p->second.lock_subfunction (scope);
   }    
 
   static void unlock_subfunctions (scope_id scope = xcurrent_scope)
   {
     for (fcn_table_iterator p = fcn_table.begin ();
-	 p != fcn_table.end (); p++)
+         p != fcn_table.end (); p++)
       p->second.unlock_subfunction (scope);
   }    
 
   static void free_scope (scope_id scope)
   {
     if (scope == xglobal_scope || scope == xtop_scope)
       error ("can't free global or top-level scopes!");
     else
       symbol_table::scope_id_cache::free (scope);
   }
 
   static void stash_dir_name_for_subfunctions (scope_id scope,
-					       const std::string& dir_name);
+                                               const std::string& dir_name);
 
   static void add_to_parent_map (const std::string& classname,
-				 const std::list<std::string>& parent_list)
+                                 const std::list<std::string>& parent_list)
   {
     parent_map[classname] = parent_list;
   }
 
   static octave_user_function *get_curr_fcn (scope_id scope = xcurrent_scope)
     {
       symbol_table *inst = get_instance (scope);
       return inst->curr_fcn;
@@ -1913,62 +1913,62 @@ private:
   static symbol_table *get_instance (scope_id scope, bool create = true)
   {
     symbol_table *retval = 0;
 
     bool ok = true;
 
     if (scope != xglobal_scope)
       {
-	if (scope == xcurrent_scope)
-	  {
-	    if (! instance && create)
-	      {
-		symbol_table *inst = new symbol_table ();
-
-		if (inst)
-		  {
-		    all_instances[scope] = instance = inst;
-
-		    if (scope == xtop_scope)
-		      instance->do_cache_name ("top-level");
-		  }
-	      }
-
-	    if (! instance)
-	      ok = false;
-
-	    retval = instance;
-	  }
-	else
-	  {
-	    all_instances_iterator p = all_instances.find (scope);
-
-	    if (p == all_instances.end ())
-	      {
-		if (create)
-		  {
-		    retval = new symbol_table ();
-
-		    if (retval)
-		      all_instances[scope] = retval;
-		    else
-		      ok = false;
-		  }
-		else
-		  ok = false;
-	      }
-	    else
-	      retval = p->second;
-	  }
+        if (scope == xcurrent_scope)
+          {
+            if (! instance && create)
+              {
+                symbol_table *inst = new symbol_table ();
+
+                if (inst)
+                  {
+                    all_instances[scope] = instance = inst;
+
+                    if (scope == xtop_scope)
+                      instance->do_cache_name ("top-level");
+                  }
+              }
+
+            if (! instance)
+              ok = false;
+
+            retval = instance;
+          }
+        else
+          {
+            all_instances_iterator p = all_instances.find (scope);
+
+            if (p == all_instances.end ())
+              {
+                if (create)
+                  {
+                    retval = new symbol_table ();
+
+                    if (retval)
+                      all_instances[scope] = retval;
+                    else
+                      ok = false;
+                  }
+                else
+                  ok = false;
+              }
+            else
+              retval = p->second;
+          }
       }
 
     if (! ok)
       error ("unable to %s symbol_table object for scope %d!",
-	     create ? "create" : "find", scope);
+             create ? "create" : "find", scope);
 
     return retval;
   }
 
   void insert_symbol_record (const symbol_record& sr)
   {
     table[sr.name ()] = sr;
   }
@@ -1989,34 +1989,34 @@ private:
     else
       return p->second;
   }
 
   void do_inherit (symbol_table& donor_table, context_id donor_context)
   {
     for (table_iterator p = table.begin (); p != table.end (); p++)
       {
-	symbol_record& sr = p->second;
-
-	if (! (sr.is_automatic () || sr.is_formal ()))
-	  {
-	    std::string nm = sr.name ();
-
-	    if (nm != "__retval__")
-	      {
-		octave_value val = donor_table.do_varval (nm, donor_context);
-
-		if (val.is_defined ())
-		  {
-		    sr.varref (0) = val;
-
-		    sr.mark_inherited ();
-		  }
-	      }
-	  }
+        symbol_record& sr = p->second;
+
+        if (! (sr.is_automatic () || sr.is_formal ()))
+          {
+            std::string nm = sr.name ();
+
+            if (nm != "__retval__")
+              {
+                octave_value val = donor_table.do_varval (nm, donor_context);
+
+                if (val.is_defined ())
+                  {
+                    sr.varref (0) = val;
+
+                    sr.mark_inherited ();
+                  }
+              }
+          }
       }
   }
 
   static fcn_info *get_fcn_info (const std::string& name)
     {
       fcn_table_iterator p = fcn_table.find (name);
       return p != fcn_table.end () ? &p->second : 0;
     }
@@ -2036,33 +2036,33 @@ private:
   }
 
   void do_force_variable (const std::string& name, context_id context)
   {
     table_iterator p = table.find (name);
 
     if (p == table.end ())
       {
-	symbol_record& sr = do_insert (name);
-
-	sr.force_variable (context);
+        symbol_record& sr = do_insert (name);
+
+        sr.force_variable (context);
       }
     else
       p->second.force_variable (context);
   }
 
   octave_value& do_varref (const std::string& name, context_id context)
   {
     table_iterator p = table.find (name);
 
     if (p == table.end ())
       {
-	symbol_record& sr = do_insert (name);
-
-	return sr.varref (context);
+        symbol_record& sr = do_insert (name);
+
+        return sr.varref (context);
       }
     else
       return p->second.varref (context);
   }
 
   octave_value do_varval (const std::string& name, context_id context) const
   {
     table_const_iterator p = table.find (name);
@@ -2096,73 +2096,73 @@ private:
   bool do_is_variable (const std::string& name) const
   {
     bool retval = false;
 
     table_const_iterator p = table.find (name);
 
     if (p != table.end ())
       {
-	const symbol_record& sr = p->second;
-
-	retval = sr.is_variable ();
+        const symbol_record& sr = p->second;
+
+        retval = sr.is_variable ();
       }
 
     return retval;
   }
 
   void do_push_context (void)
   {
     for (table_iterator p = table.begin (); p != table.end (); p++)
       p->second.push_context ();
   }
 
   void do_pop_context (void)
   {
     for (table_iterator p = table.begin (); p != table.end (); )
       {
-	if (p->second.pop_context () == 0)
-	  table.erase (p++);
-	else
-	  p++;
+        if (p->second.pop_context () == 0)
+          table.erase (p++);
+        else
+          p++;
       }
   }
 
   void do_clear_variables (void)
   {
     for (table_iterator p = table.begin (); p != table.end (); p++)
       p->second.clear ();
   }
 
   void do_clear_objects (void)
   {
     for (table_iterator p = table.begin (); p != table.end (); p++)
       {
-	symbol_record& sr = p->second;
-	octave_value& val = sr.varref ();
-	if (val.is_object())
-	  p->second.clear ();
+        symbol_record& sr = p->second;
+        octave_value& val = sr.varref ();
+        if (val.is_object())
+          p->second.clear ();
       }
   }
 
  void do_unmark_forced_variables (void)
   {
     for (table_iterator p = table.begin (); p != table.end (); p++)
       p->second.unmark_forced ();
   }
 
   void do_clear_global (const std::string& name)
   {
     table_iterator p = table.find (name);
 
     if (p != table.end ())
       {
-	symbol_record& sr = p->second;
-
-	if (sr.is_global ())
+        symbol_record& sr = p->second;
+
+        if (sr.is_global ())
           sr.unmark_global ();
       }
 
     global_table_iterator q = global_table.find (name);
 
     if (q != global_table.end ())
       global_table.erase (q);
 
@@ -2177,61 +2177,61 @@ private:
   }
 
   void do_clear_global_pattern (const std::string& pat)
   {
     glob_match pattern (pat);
 
     for (table_iterator p = table.begin (); p != table.end (); p++)
       {
-	symbol_record& sr = p->second;
-
-	if (sr.is_global () && pattern.match (sr.name ()))
+        symbol_record& sr = p->second;
+
+        if (sr.is_global () && pattern.match (sr.name ()))
           sr.unmark_global ();
       }
 
     for (global_table_iterator q = global_table.begin (); 
          q != global_table.end (); q++)
       {
-	if (pattern.match (q->first))
+        if (pattern.match (q->first))
           global_table.erase (q);
       }
 
 
   }
 
   void do_clear_variable_pattern (const std::string& pat)
   {
     glob_match pattern (pat);
 
     for (table_iterator p = table.begin (); p != table.end (); p++)
       {
-	symbol_record& sr = p->second;
-
-	if (sr.is_defined () || sr.is_global ())
-	  {
-	    if (pattern.match (sr.name ()))
-	      sr.clear ();
-	  }
+        symbol_record& sr = p->second;
+
+        if (sr.is_defined () || sr.is_global ())
+          {
+            if (pattern.match (sr.name ()))
+              sr.clear ();
+          }
       }
   }
 
   void do_clear_variable_regexp (const std::string& pat)
   {
     regex_match pattern (pat);
 
     for (table_iterator p = table.begin (); p != table.end (); p++)
       {
-	symbol_record& sr = p->second;
-
-	if (sr.is_defined () || sr.is_global ())
-	  {
-	    if (pattern.match (sr.name ()))
-	      sr.clear ();
-	  }
+        symbol_record& sr = p->second;
+
+        if (sr.is_defined () || sr.is_global ())
+          {
+            if (pattern.match (sr.name ()))
+              sr.clear ();
+          }
       }
   }
 
   void do_mark_hidden (const std::string& name)
   {
     table_iterator p = table.find (name);
 
     if (p != table.end ())
@@ -2248,115 +2248,115 @@ private:
 
   std::list<symbol_record>
   do_all_variables (context_id context, bool defined_only) const
   {
     std::list<symbol_record> retval;
 
     for (table_const_iterator p = table.begin (); p != table.end (); p++)
       {
-	const symbol_record& sr = p->second;
-
-	if (defined_only && ! sr.is_defined (context))
-	  continue;
-
-	retval.push_back (sr);
+        const symbol_record& sr = p->second;
+
+        if (defined_only && ! sr.is_defined (context))
+          continue;
+
+        retval.push_back (sr);
       }
 
     return retval;
   }
 
   std::list<symbol_record> do_glob (const std::string& pattern,
-				    bool vars_only = false) const
+                                    bool vars_only = false) const
   {
     std::list<symbol_record> retval;
 
     glob_match pat (pattern);
 
     for (table_const_iterator p = table.begin (); p != table.end (); p++)
       {
-	if (pat.match (p->first))
-	  {
-	    const symbol_record& sr = p->second;
-
-	    if (vars_only && ! sr.is_variable ())
-	      continue;
-
-	    retval.push_back (sr);
-	  }
+        if (pat.match (p->first))
+          {
+            const symbol_record& sr = p->second;
+
+            if (vars_only && ! sr.is_variable ())
+              continue;
+
+            retval.push_back (sr);
+          }
       }
 
     return retval;
   }
 
   std::list<symbol_record> do_regexp (const std::string& pattern,
-				      bool vars_only = false) const
+                                      bool vars_only = false) const
   {
     std::list<symbol_record> retval;
 
     regex_match pat (pattern);
 
     for (table_const_iterator p = table.begin (); p != table.end (); p++)
       {
-	if (pat.match (p->first))
-	  {
-	    const symbol_record& sr = p->second;
-
-	    if (vars_only && ! sr.is_variable ())
-	      continue;
-
-	    retval.push_back (sr);
-	  }
+        if (pat.match (p->first))
+          {
+            const symbol_record& sr = p->second;
+
+            if (vars_only && ! sr.is_variable ())
+              continue;
+
+            retval.push_back (sr);
+          }
       }
 
     return retval;
   }
 
   std::list<std::string> do_variable_names (void)
   {
     std::list<std::string> retval;
 
     for (table_const_iterator p = table.begin (); p != table.end (); p++)
       {
-	if (p->second.is_variable ())
-	  retval.push_back (p->first);
+        if (p->second.is_variable ())
+          retval.push_back (p->first);
       }
 
     retval.sort ();
 
     return retval;
   }
 
   static std::map<std::string, octave_value>
   subfunctions_defined_in_scope (scope_id scope = xcurrent_scope)
   {
     std::map<std::string, octave_value> retval;
 
     for (fcn_table_const_iterator p = fcn_table.begin ();
-	 p != fcn_table.end (); p++)
+         p != fcn_table.end (); p++)
       {
-	std::pair<std::string, octave_value> tmp
-	  = p->second.subfunction_defined_in_scope (scope);
-
-	std::string nm = tmp.first;
-
-	if (! nm.empty ())
-	  retval[nm] = tmp.second;
+        std::pair<std::string, octave_value> tmp
+          = p->second.subfunction_defined_in_scope (scope);
+
+        std::string nm = tmp.first;
+
+        if (! nm.empty ())
+          retval[nm] = tmp.second;
       }
 
     return retval;
   }
 
   bool do_is_local_variable (const std::string& name) const
   {
     table_const_iterator p = table.find (name);
 
     return (p != table.end ()
-	    && ! p->second.is_global ()
-	    && p->second.is_defined ());
+            && ! p->second.is_global ()
+            && p->second.is_defined ());
   }
 
   bool do_is_global (const std::string& name) const
   {
     table_const_iterator p = table.find (name);
 
     return p != table.end () && p->second.is_global ();
   }
diff --git a/src/token.h b/src/token.h
--- a/src/token.h
+++ b/src/token.h
@@ -64,17 +64,17 @@ public:
       replot = 1,
       two_dee = 2,
       three_dee = 3
     };
 
   token (int l = -1, int c = -1);
   token (const std::string& s, int l = -1, int c = -1);
   token (double d, const std::string& s = std::string (),
-	 int l = -1, int c = -1);
+         int l = -1, int c = -1);
   token (end_tok_type t, int l = -1, int c = -1);
   token (plot_tok_type t, int l = -1, int c = -1);
   token (symbol_table::symbol_record *s, int l = -1, int c = -1);
   token (symbol_table::symbol_record *cls,
          symbol_table::symbol_record *pkg, int l = -1, int c = -1);
   token (symbol_table::symbol_record *mth,
          symbol_table::symbol_record *cls,
          symbol_table::symbol_record *pkg, int l = -1, int c = -1);
diff --git a/src/toplev.h b/src/toplev.h
--- a/src/toplev.h
+++ b/src/toplev.h
@@ -82,22 +82,22 @@ class
 OCTINTERP_API
 octave_call_stack
 {
 private:
 
   struct call_stack_elt
   {
     call_stack_elt (octave_function *f, symbol_table::scope_id s,
-		    symbol_table::context_id c, size_t p = 0)
+                    symbol_table::context_id c, size_t p = 0)
       : fcn (f), stmt (0), scope (s), context (c), prev (p) { }
 
     call_stack_elt (const call_stack_elt& elt)
       : fcn (elt.fcn), stmt (elt.stmt), scope (elt.scope),
-	context (elt.context), prev (elt.prev) { }
+        context (elt.context), prev (elt.prev) { }
 
     octave_function *fcn;
     tree_statement *stmt;
     symbol_table::scope_id scope;
     symbol_table::context_id context;
     size_t prev;
   };
 
@@ -114,26 +114,26 @@ public:
   typedef std::deque<call_stack_elt>::const_reverse_iterator const_reverse_iterator;
 
   static bool instance_ok (void)
   {
     bool retval = true;
 
     if (! instance)
       {
-	instance = new octave_call_stack ();
+        instance = new octave_call_stack ();
 
-	if (instance)
-	  instance->do_push (0, symbol_table::top_scope (), 0);
-	else
-	  {
-	    ::error ("unable to create call stack object!");
+        if (instance)
+          instance->do_push (0, symbol_table::top_scope (), 0);
+        else
+          {
+            ::error ("unable to create call stack object!");
 
-	    retval = false;
-	  }
+            retval = false;
+          }
       }
 
     return retval;
   }
 
   // Current function (top of stack).
   static octave_function *current (void)
   {
@@ -212,26 +212,26 @@ public:
   // First user-defined function on the stack.
   static octave_user_code *caller_user_code (size_t nskip = 0)
   {
     return instance_ok () ? instance->do_caller_user_code (nskip) : 0;
   }
 
   static void
   push (octave_function *f,
-	symbol_table::scope_id scope = symbol_table::current_scope (),
-	symbol_table::context_id context = symbol_table::current_context ())
+        symbol_table::scope_id scope = symbol_table::current_scope (),
+        symbol_table::context_id context = symbol_table::current_context ())
   {
     if (instance_ok ())
       instance->do_push (f, scope, context);
   }
 
   static void
   push (symbol_table::scope_id scope = symbol_table::current_scope (),
-	symbol_table::context_id context = symbol_table::current_context ())
+        symbol_table::context_id context = symbol_table::current_context ())
   {
     if (instance_ok ())
       instance->do_push (0, scope, context);
   }
 
   static void set_statement (tree_statement *s)
   {
     if (instance_ok ())
@@ -331,89 +331,89 @@ private:
   }
 
   octave_function *do_element (size_t n)
   {
     octave_function *retval = 0;
 
     if (cs.size () > n)
       {
-	call_stack_elt& elt = cs[n];
-	retval = elt.fcn;
+        call_stack_elt& elt = cs[n];
+        retval = elt.fcn;
       }
 
     return retval;
   }
 
   octave_user_code *do_caller_user_code (size_t nskip) const; 
 
   void do_push (octave_function *f, symbol_table::scope_id scope,
-		symbol_table::context_id context)
+                symbol_table::context_id context)
   {
     size_t prev_frame = curr_frame;
     curr_frame = cs.size ();
     cs.push_back (call_stack_elt (f, scope, context, prev_frame));
     symbol_table::set_scope_and_context (scope, context);
   }
 
   octave_function *do_current (void) const
   {
     octave_function *retval = 0;
 
     if (! cs.empty ())
       {
-	const call_stack_elt& elt = cs[curr_frame];
-	retval = elt.fcn;
+        const call_stack_elt& elt = cs[curr_frame];
+        retval = elt.fcn;
       }
 
     return retval;
   }
 
   tree_statement *do_current_statement (void) const
   {
     tree_statement *retval = 0;
 
     if (! cs.empty ())
       {
-	const call_stack_elt& elt = cs[curr_frame];
-	retval = elt.stmt;
+        const call_stack_elt& elt = cs[curr_frame];
+        retval = elt.stmt;
       }
 
     return retval;
   }
 
   void do_set_statement (tree_statement *s)
   {
     if (! cs.empty ())
       {
-	call_stack_elt& elt = cs.back ();
-	elt.stmt = s;
+        call_stack_elt& elt = cs.back ();
+        elt.stmt = s;
       }
   }
 
   Octave_map do_backtrace (size_t nskip,
-			   octave_idx_type& curr_user_frame) const;
+                           octave_idx_type& curr_user_frame) const;
 
   bool do_goto_frame (size_t n, bool verbose);
 
   bool do_goto_frame_relative (int n, bool verbose);
 
   void do_goto_caller_frame (void);
 
   void do_goto_base_frame (void);
 
   void do_pop (void)
   {
     if (cs.size () > 1)
       {
-	const call_stack_elt& elt = cs.back ();
-	curr_frame = elt.prev;
-	cs.pop_back ();
-	const call_stack_elt& new_elt = cs[curr_frame];
-	symbol_table::set_scope_and_context (new_elt.scope, new_elt.context);
+        const call_stack_elt& elt = cs.back ();
+        curr_frame = elt.prev;
+        cs.pop_back ();
+        const call_stack_elt& new_elt = cs[curr_frame];
+        symbol_table::set_scope_and_context (new_elt.scope, new_elt.context);
       }
   }
 
   void do_clear (void) { cs.clear (); }
 
   void do_backtrace_error_message (void) const;
 };
 
diff --git a/src/txt-eng-ft.h b/src/txt-eng-ft.h
--- a/src/txt-eng-ft.h
+++ b/src/txt-eng-ft.h
@@ -59,17 +59,17 @@ public:
 
   void reset (void);
 
   uint8NDArray get_pixels (void) const { return pixels; }
 
   Matrix get_boundingbox (void) const { return bbox; }
 
   uint8NDArray render (text_element* elt, Matrix& box,
-		       int rotation = ROTATION_0);
+                       int rotation = ROTATION_0);
 
   void set_font (const base_properties& props);
 
   void set_color (Matrix c);
 
   void set_mode (int m);
 
 private:
diff --git a/src/txt-eng.h b/src/txt-eng.h
--- a/src/txt-eng.h
+++ b/src/txt-eng.h
@@ -77,21 +77,21 @@ text_element_list :
 {
 public:
   text_element_list (void)
       : text_element (), octave_base_list<text_element*> () { }
 
   ~text_element_list (void)
     {
       while (! empty ())
-	{
-	  iterator it = begin ();
-	  delete (*it);
-	  erase (it);
-	}
+        {
+          iterator it = begin ();
+          delete (*it);
+          erase (it);
+        }
     }
 
   void accept (text_processor& p);
 };
 
 class
 OCTINTERP_API
 text_subscript_element : public text_element_list
@@ -123,20 +123,20 @@ OCTINTERP_API
 text_processor
 {
 public:
   virtual void visit (text_element_string& e) = 0;
 
   virtual void visit (text_element_list& e)
     {
       for (text_element_list::iterator it = e.begin ();
-	   it != e.end (); ++it)
-	{
-	  (*it)->accept (*this);
-	}
+           it != e.end (); ++it)
+        {
+          (*it)->accept (*this);
+        }
     }
   
   virtual void visit (text_subscript_element& e)
     { visit (dynamic_cast<text_element_list&> (e)); }
   
   virtual void visit (text_superscript_element& e)
     { visit (dynamic_cast<text_element_list&> (e)); }
 
diff --git a/src/utils.h b/src/utils.h
--- a/src/utils.h
+++ b/src/utils.h
@@ -39,27 +39,27 @@ class string_vector;
 
 extern OCTINTERP_API bool valid_identifier (const char *s);
 extern OCTINTERP_API bool valid_identifier (const std::string& s);
 
 extern OCTINTERP_API bool
 same_file (const std::string& f, const std::string& g);
 
 extern OCTINTERP_API int almost_match (const std::string& std,
-				       const std::string& s,
-				       int min_match_len = 1,
-				       int case_sens = 1);
+                                       const std::string& s,
+                                       int min_match_len = 1,
+                                       int case_sens = 1);
 
 extern OCTINTERP_API int
 keyword_almost_match (const char * const *std, int *min_len,
-		      const std::string& s, int min_toks_to_match,
-		      int max_toks);
+                      const std::string& s, int min_toks_to_match,
+                      int max_toks);
 
 extern OCTINTERP_API int empty_arg (const char *name, octave_idx_type nr,
-				    octave_idx_type nc);
+                                    octave_idx_type nc);
 
 extern OCTINTERP_API std::string
 search_path_for_file (const std::string&, const string_vector&);
 
 extern OCTINTERP_API string_vector
 search_path_for_all_files (const std::string&, const string_vector&);
 
 extern OCTINTERP_API std::string
@@ -81,30 +81,30 @@ extern OCTINTERP_API void
 check_dimensions (dim_vector& dim, const char *warnfor);
 
 extern OCTINTERP_API void
 get_dimensions (const octave_value& a, const char *warn_for,
                 dim_vector& dim);
 
 extern OCTINTERP_API void
 get_dimensions (const octave_value& a, const octave_value& b,
-		const char *warn_for, octave_idx_type& nr,
-		octave_idx_type& nc);
+                const char *warn_for, octave_idx_type& nr,
+                octave_idx_type& nc);
 
 extern OCTINTERP_API void
 get_dimensions (const octave_value& a,const char *warn_for,
-		octave_idx_type& nr, octave_idx_type& nc);
+                octave_idx_type& nr, octave_idx_type& nc);
 
 extern OCTINTERP_API octave_idx_type
 dims_to_numel (const dim_vector& dims, const octave_value_list& idx);
 
 extern OCTINTERP_API void
 decode_subscripts (const char* name, const octave_value& arg,
-		   std::string& type_string,
-		   std::list<octave_value_list>& idx);
+                   std::string& type_string,
+                   std::list<octave_value_list>& idx);
 
 extern OCTINTERP_API Matrix
 identity_matrix (octave_idx_type nr, octave_idx_type nc);
 
 extern OCTINTERP_API FloatMatrix
 float_identity_matrix (octave_idx_type nr, octave_idx_type nc);
 
 extern OCTINTERP_API int
diff --git a/src/variables.h b/src/variables.h
--- a/src/variables.h
+++ b/src/variables.h
@@ -41,33 +41,33 @@ class string_vector;
 #include "ov.h"
 #include "ov-builtin.h"
 #include "symtab.h"
 
 extern OCTINTERP_API void clear_mex_functions (void);
 
 extern OCTINTERP_API octave_function *
 is_valid_function (const octave_value&, const std::string& = std::string (),
-		   bool warn = false); 
+                   bool warn = false); 
 
 extern OCTINTERP_API octave_function *
 is_valid_function (const std::string&, const std::string& = std::string (),
-		   bool warn = false); 
+                   bool warn = false); 
 
 extern OCTINTERP_API octave_function *
 extract_function (const octave_value& arg, const std::string& warn_for,
-		  const std::string& fname, const std::string& header,
-		  const std::string& trailer);
+                  const std::string& fname, const std::string& header,
+                  const std::string& trailer);
 
 extern OCTINTERP_API string_vector
 get_struct_elts (const std::string& text);
 
 extern OCTINTERP_API string_vector
 generate_struct_completions (const std::string& text, std::string& prefix,
-			     std::string& hint);
+                             std::string& hint);
 
 extern OCTINTERP_API bool
 looks_like_struct (const std::string& text);
 
 extern OCTINTERP_API int
 symbol_exist (const std::string& name, const std::string& type = "any");
 
 extern OCTINTERP_API std::string
@@ -84,35 +84,35 @@ set_global_value (const std::string& nm,
 extern OCTINTERP_API octave_value
 get_top_level_value (const std::string& nm, bool silent = false);
 
 extern OCTINTERP_API void
 set_top_level_value (const std::string& nm, const octave_value& val);
 
 extern OCTINTERP_API octave_value
 set_internal_variable (bool& var, const octave_value_list& args,
-		       int nargout, const char *nm);
+                       int nargout, const char *nm);
 
 extern OCTINTERP_API octave_value
 set_internal_variable (char& var, const octave_value_list& args,
-		       int nargout, const char *nm);
+                       int nargout, const char *nm);
 
 extern OCTINTERP_API octave_value
 set_internal_variable (int& var, const octave_value_list& args,
-		       int nargout, const char *nm,
-		       int minval = INT_MIN, int maxval = INT_MAX);
+                       int nargout, const char *nm,
+                       int minval = INT_MIN, int maxval = INT_MAX);
 
 extern OCTINTERP_API octave_value
 set_internal_variable (double& var, const octave_value_list& args,
-		       int nargout, const char *nm,
-		       double minval = DBL_MIN, double maxval = DBL_MAX);
+                       int nargout, const char *nm,
+                       double minval = DBL_MIN, double maxval = DBL_MAX);
 
 extern OCTINTERP_API octave_value
 set_internal_variable (std::string& var, const octave_value_list& args,
-		       int nargout, const char *nm, bool empty_ok = true);
+                       int nargout, const char *nm, bool empty_ok = true);
 
 #define SET_INTERNAL_VARIABLE(NM) \
   set_internal_variable (V ## NM, args, nargout, #NM)
 
 #define SET_NONEMPTY_INTERNAL_STRING_VARIABLE(NM) \
   set_internal_variable (V ## NM, args, nargout, #NM, false)
 
 #define SET_INTERNAL_VARIABLE_WITH_LIMITS(NM, MINVAL, MAXVAL) \
diff --git a/src/xdiv.h b/src/xdiv.h
--- a/src/xdiv.h
+++ b/src/xdiv.h
@@ -25,67 +25,67 @@ along with Octave; see the file COPYING.
 #if !defined (octave_xdiv_h)
 #define octave_xdiv_h 1
 
 #include "mx-defs.h"
 #include "MatrixType.h"
 
 extern Matrix xdiv (const Matrix& a, const Matrix& b, MatrixType &typ);
 extern ComplexMatrix xdiv (const Matrix& a, const ComplexMatrix& b,
-			   MatrixType &typ);
+                           MatrixType &typ);
 extern ComplexMatrix xdiv (const ComplexMatrix& a, const Matrix& b,
-			   MatrixType &typ);
+                           MatrixType &typ);
 extern ComplexMatrix xdiv (const ComplexMatrix& a, const ComplexMatrix& b,
-			   MatrixType &typ);
+                           MatrixType &typ);
 
 extern Matrix x_el_div (double a, const Matrix& b);
 extern ComplexMatrix x_el_div (double a, const ComplexMatrix& b);
 extern ComplexMatrix x_el_div (const Complex a, const Matrix& b);
 extern ComplexMatrix x_el_div (const Complex a, const ComplexMatrix& b);
 
 extern NDArray x_el_div (double a, const NDArray& b);
 extern ComplexNDArray x_el_div (double a, const ComplexNDArray& b);
 extern ComplexNDArray x_el_div (const Complex a, const NDArray& b);
 extern ComplexNDArray x_el_div (const Complex a, const ComplexNDArray& b);
 
 extern Matrix xleftdiv (const Matrix& a, const Matrix& b, MatrixType &typ,
                         blas_trans_type transt = blas_no_trans);
 extern ComplexMatrix xleftdiv (const Matrix& a, const ComplexMatrix& b,
-			       MatrixType &typ, blas_trans_type transt = blas_no_trans);
+                               MatrixType &typ, blas_trans_type transt = blas_no_trans);
 extern ComplexMatrix xleftdiv (const ComplexMatrix& a, const Matrix& b,
-			       MatrixType &typ, blas_trans_type transt = blas_no_trans);
+                               MatrixType &typ, blas_trans_type transt = blas_no_trans);
 extern ComplexMatrix xleftdiv (const ComplexMatrix& a, const ComplexMatrix& b,
-			       MatrixType &typ, blas_trans_type transt = blas_no_trans);
+                               MatrixType &typ, blas_trans_type transt = blas_no_trans);
 
 extern FloatMatrix xdiv (const FloatMatrix& a, const FloatMatrix& b, MatrixType &typ);
 extern FloatComplexMatrix xdiv (const FloatMatrix& a, const FloatComplexMatrix& b,
-			   MatrixType &typ);
+                           MatrixType &typ);
 extern FloatComplexMatrix xdiv (const FloatComplexMatrix& a, const FloatMatrix& b,
-			   MatrixType &typ);
+                           MatrixType &typ);
 extern FloatComplexMatrix xdiv (const FloatComplexMatrix& a, const FloatComplexMatrix& b,
-			   MatrixType &typ);
+                           MatrixType &typ);
 
 extern FloatMatrix x_el_div (float a, const FloatMatrix& b);
 extern FloatComplexMatrix x_el_div (float a, const FloatComplexMatrix& b);
 extern FloatComplexMatrix x_el_div (const FloatComplex a, const FloatMatrix& b);
 extern FloatComplexMatrix x_el_div (const FloatComplex a, const FloatComplexMatrix& b);
 
 extern FloatNDArray x_el_div (float a, const FloatNDArray& b);
 extern FloatComplexNDArray x_el_div (float a, const FloatComplexNDArray& b);
 extern FloatComplexNDArray x_el_div (const FloatComplex a, const FloatNDArray& b);
 extern FloatComplexNDArray x_el_div (const FloatComplex a, const FloatComplexNDArray& b);
 
 extern FloatMatrix xleftdiv (const FloatMatrix& a, const FloatMatrix& b, MatrixType &typ, 
                              blas_trans_type transt = blas_no_trans);
 extern FloatComplexMatrix xleftdiv (const FloatMatrix& a, const FloatComplexMatrix& b,
-			       MatrixType &typ, blas_trans_type transt = blas_no_trans);
+                               MatrixType &typ, blas_trans_type transt = blas_no_trans);
 extern FloatComplexMatrix xleftdiv (const FloatComplexMatrix& a, const FloatMatrix& b,
-			       MatrixType &typ, blas_trans_type transt = blas_no_trans);
+                               MatrixType &typ, blas_trans_type transt = blas_no_trans);
 extern FloatComplexMatrix xleftdiv (const FloatComplexMatrix& a, const FloatComplexMatrix& b,
-			       MatrixType &typ, blas_trans_type transt = blas_no_trans);
+                               MatrixType &typ, blas_trans_type transt = blas_no_trans);
 
 
 extern Matrix xdiv (const Matrix& a, const DiagMatrix& b);
 extern ComplexMatrix xdiv (const ComplexMatrix& a, const DiagMatrix& b);
 extern ComplexMatrix xdiv (const ComplexMatrix& a, const ComplexDiagMatrix& b);
 
 extern DiagMatrix xdiv (const DiagMatrix& a, const DiagMatrix& b);
 extern ComplexDiagMatrix xdiv (const ComplexDiagMatrix& a, const DiagMatrix& b);
