# HG changeset patch
# User Andrew Thornton <art27@cantab.net>
# Date 1482204317 0
#      Tue Dec 20 03:25:17 2016 +0000
# Node ID 36e0e5b428e7cc63c2f81174eed0f6e513d24a89
# Parent  3e44ed9d50b6f34982ab6d832b46ee534f401df1
Implement uitable (patch #9084)

* libgui/graphics/Table.[cc/h]: Add QT toolkit Table object.

* libgui/graphics/module.mk: Add new files.

* libgui/graphics/Backend.cc (toolkitObjectProperty, Backend::initialize,
  Backend::update): Add uitable.

* libgui/graphics/Canvas.cc (Canvas::select_object): Allow uitable to be
  selected like uicontrol or uipanel.

* libgui/graphics/ObjectFactory.cc (ObjectFactory::createObject): Add uitable.

* libgui/graphics/QtHandlesUtils.cc (computeFont<uibuttongroup>): Make
  computeFont template for uitable.

* libinterp/corefcn/gl-render.cc (opengl_renderer::draw): Add uitable.

* libinterp/corefcn/graphics.cc (default_table_position,
  default_table_backgroundcolor): Add new static default values.

* libinterp/corefcn/graphics.cc (lookup_object_name,
  make_graphics_object_from_type, property_list::set, property_list::lookup):
  Add uipanel.

* libinterp/corefcn/graphics.cc (uitable::properties::get_boundingbox,
  uitable::properties::set_columnformat, uitable::properties::set_columnwidth,
  uitable::properties::set_units, uitable::properties::update_units,
  uitable::properties::set_fontunits, uitable::properties::update_fontunits,
  uitable::properties::get___fontsize_points__,
  uitable::properties::get_fontsize_pixels,
  uitable::properties::get_backgroundcolor_rgb,
  uitable::properties::get_alternatebackgroundcolor_rgb,
  uitable::properties::get_extent_matrix, uitable::properties::get_extent,
  uitable::properties::set_selectedobject, F__go_uitable__): Add new functions.

* libinterp/corefcn/graphics.in.h: Add uitable.

* scripts/gui/uitable.m: Add new file.

* scripts/gui/module.mk: Add new file to list.

* scripts/help/__unimplemented__.m: Remove uitable from missing_functions.

* doc/interpreter/genpropdoc.m, doc/interpreter/gui.txi,
  doc/interpreter/module.mk, doc/interpreter/plot.txi: Add documentation for
  uitable.

* NEWS: Add to list of new functions.

diff --git a/NEWS b/NEWS
--- a/NEWS
+++ b/NEWS
@@ -110,16 +110,17 @@ Summary of important user-visible change
  ** New functions added in 5.0:
 
       isfile
       isfolder
       movegui
       openfig
       ordeig
       savefig
+      uitable
 
  ** Legacy functions.
 
     The following functions have been declared legacy functions which
     means they are obsolete and should not be used in any new code.
     Unlike deprecated functions, however, their removal from Octave has
     not yet been scheduled.
 
diff --git a/doc/interpreter/genpropdoc.m b/doc/interpreter/genpropdoc.m
--- a/doc/interpreter/genpropdoc.m
+++ b/doc/interpreter/genpropdoc.m
@@ -29,17 +29,18 @@
 ##
 ## @seealso{}
 ## @end deftypefn
 
 function genpropdoc (objname, fname)
   objnames = {"root", "figure", "axes", "line", ...
               "text", "image", "patch", "surface", "light", ...
               "uimenu", "uibuttongroup", "uicontextmenu", "uipanel", ...
-              "uicontrol", "uitoolbar", "uipushtool", "uitoggletool"};
+              "uicontrol", "uitable", "uitoolbar", "uipushtool", ...
+              "uitoggletool"};
 
   ## Base properties
   base = getstructure ("base");
 
   ## Object properties
   if (any (strcmp (objname, objnames)))
     obj = getstructure (objname, base);
   else
@@ -1652,16 +1653,51 @@ point source (@qcode{\"local\"}).";
       case "style"
       case "tooltipstring"
       case "units"
       case "value"
       case "verticalalignment"
 
     endswitch
 
+  ## uitable Properties
+  elseif (strcmp (objname, "uitable"))
+      switch (field)
+        ## Overridden shared properties
+
+        ## Specific properties
+        case "backgroundcolor"
+        case "celleditcallback"
+        case "cellselectioncallback"
+        case "columneditable"
+        case "columnformat"
+        case "columnname"
+        case "columnwidth"
+        case "createfcn"
+        case "data"
+        case "deletefcn"
+        case "enable"
+        case "extent"
+        case "fontangle"
+        case "fontname"
+        case "fontsize"
+        case "fontunits"
+        case "fontweight"
+        case "foregroundcolor"
+        case "keypressfcn"
+        case "keyreleasefcn"
+        case "position"
+        case "rearrangeablecolumns"
+        case "rowname"
+        case "rowstriping"
+        case "tooltipstring"
+        case "units"
+
+      endswitch
+
   ## uitoolbar properties
   elseif (strcmp (objname, "uitoolbar"))
     switch (field)
       ## Overridden shared properties
       case "buttondownfcn"
         s.doc = doc_unused;
 
     endswitch
diff --git a/doc/interpreter/gui.txi b/doc/interpreter/gui.txi
--- a/doc/interpreter/gui.txi
+++ b/doc/interpreter/gui.txi
@@ -108,16 +108,18 @@ There is no support for the @code{gnuplo
 @DOCSTRING(uibuttongroup)
 
 @DOCSTRING(uicontextmenu)
 
 @DOCSTRING(uicontrol)
 
 @DOCSTRING(uipanel)
 
+@DOCSTRING(uitable)
+
 @DOCSTRING(uipushtool)
 
 @DOCSTRING(uitoggletool)
 
 @DOCSTRING(uitoolbar)
 
 @node GUI Utility Functions
 @section GUI Utility Functions
diff --git a/doc/interpreter/module.mk b/doc/interpreter/module.mk
--- a/doc/interpreter/module.mk
+++ b/doc/interpreter/module.mk
@@ -10,16 +10,17 @@ GRAPH_PROP_TEXI_SRC = \
   %reldir%/plot-rootproperties.texi \
   %reldir%/plot-surfaceproperties.texi \
   %reldir%/plot-textproperties.texi \
   %reldir%/plot-uimenuproperties.texi \
   %reldir%/plot-uibuttongroupproperties.texi \
   %reldir%/plot-uicontextmenuproperties.texi \
   %reldir%/plot-uipanelproperties.texi \
   %reldir%/plot-uicontrolproperties.texi \
+  %reldir%/plot-uitableproperties.texi \
   %reldir%/plot-uitoolbarproperties.texi \
   %reldir%/plot-uipushtoolproperties.texi \
   %reldir%/plot-uitoggletoolproperties.texi
 
 $(GRAPH_PROP_TEXI_SRC): | $(OCTAVE_INTERPRETER_TARGETS)
 
 define gen-propdoc-texi
   rm -f $@-t $@ && \
@@ -66,16 +67,19 @@ GRAPHICS_PROPS_SRC = libinterp/corefcn/g
 	$(AM_V_GEN)$(call gen-propdoc-texi,uicontextmenu)
 
 %reldir%/plot-uipanelproperties.texi: %reldir%/genpropdoc.m $(GRAPHICS_PROPS_SRC)
 	$(AM_V_GEN)$(call gen-propdoc-texi,uipanel)
 
 %reldir%/plot-uicontrolproperties.texi: %reldir%/genpropdoc.m $(GRAPHICS_PROPS_SRC)
 	$(AM_V_GEN)$(call gen-propdoc-texi,uicontrol)
 
+%reldir%/plot-uitableproperties.texi: %reldir%/genpropdoc.m $(GRAPHICS_PROPS_SRC)
+	$(AM_V_GEN)$(call gen-propdoc-texi,uitable)
+
 %reldir%/plot-uitoolbarproperties.texi: %reldir%/genpropdoc.m $(GRAPHICS_PROPS_SRC)
 	$(AM_V_GEN)$(call gen-propdoc-texi,uitoolbar)
 
 %reldir%/plot-uipushtoolproperties.texi: %reldir%/genpropdoc.m $(GRAPHICS_PROPS_SRC)
 	$(AM_V_GEN)$(call gen-propdoc-texi,uipushtool)
 
 %reldir%/plot-uitoggletoolproperties.texi: %reldir%/genpropdoc.m $(GRAPHICS_PROPS_SRC)
 	$(AM_V_GEN)$(call gen-propdoc-texi,uitoggletool)
diff --git a/doc/interpreter/plot.txi b/doc/interpreter/plot.txi
--- a/doc/interpreter/plot.txi
+++ b/doc/interpreter/plot.txi
@@ -1479,16 +1479,17 @@ struct2hdl (fig_struct);
 * Patch Properties::
 * Surface Properties::
 * Light Properties::
 * Uimenu Properties::
 * Uibuttongroup Properties::
 * Uicontextmenu Properties::
 * Uipanel Properties::
 * Uicontrol Properties::
+* Uitable Properties::
 * Uitoolbar Properties::
 * Uipushtool Properties::
 * Uitoggletool Properties::
 @end menu
 
 In this Section the graphics object properties are discussed in detail,
 starting with the root figure properties and continuing through the objects
 hierarchy.  The documentation about a specific graphics object can be
@@ -1617,16 +1618,24 @@ The @code{uipanel} properties are:
 @node Uicontrol Properties
 @subsubsection Uicontrol Properties
 @prindex @sortas{@ Uicontrol Properties} Uicontrol Properties
 
 The @code{uicontrol} properties are:
 
 @include plot-uicontrolproperties.texi
 
+@node Uitable Properties
+@subsubsection Uitable Properties
+@cindex uitable properties
+
+The @code{uitable} properties are:
+
+@include plot-uitableproperties.texi
+
 @node Uitoolbar Properties
 @subsubsection Uitoolbar Properties
 @prindex @sortas{@ Uitoolbar Properties} Uitoolbar Properties
 
 The @code{uitoolbar} properties are:
 
 @include plot-uitoolbarproperties.texi
 
diff --git a/libgui/graphics/Backend.cc b/libgui/graphics/Backend.cc
--- a/libgui/graphics/Backend.cc
+++ b/libgui/graphics/Backend.cc
@@ -53,16 +53,17 @@ namespace QtHandles
   {
     if (go.isa ("figure"))
       return "__plot_stream__";
     else if (go.isa ("uicontrol")
              || go.isa ("uipanel")
              || go.isa ("uibuttongroup")
              || go.isa ("uimenu")
              || go.isa ("uicontextmenu")
+             || go.isa ("uitable")
              || go.isa ("uitoolbar")
              || go.isa ("uipushtool")
              || go.isa ("uitoggletool"))
       return "__object__";
     else
       qCritical ("QtHandles::Backend: no __object__ property known for object "
                  "of type %s", go.type ().c_str ());
 
@@ -85,16 +86,17 @@ namespace QtHandles
   Backend::initialize (const graphics_object& go)
   {
     if (go.isa ("figure")
         || go.isa ("uicontrol")
         || go.isa ("uipanel")
         || go.isa ("uibuttongroup")
         || go.isa ("uimenu")
         || go.isa ("uicontextmenu")
+        || go.isa ("uitable")
         || go.isa ("uitoolbar")
         || go.isa ("uipushtool")
         || go.isa ("uitoggletool"))
       {
         Logger::debug ("Backend::initialize %s from thread %08x",
                        go.type ().c_str (), QThread::currentThreadId ());
 
         ObjectProxy *proxy = new ObjectProxy ();
@@ -116,16 +118,17 @@ namespace QtHandles
   {
     // Rule out obvious properties we want to ignore.
     if (pId == figure::properties::ID___PLOT_STREAM__
         || pId == uicontrol::properties::ID___OBJECT__
         || pId == uipanel::properties::ID___OBJECT__
         || pId == uibuttongroup::properties::ID___OBJECT__
         || pId == uimenu::properties::ID___OBJECT__
         || pId == uicontextmenu::properties::ID___OBJECT__
+        || pId == uitable::properties::ID___OBJECT__
         || pId == uitoolbar::properties::ID___OBJECT__
         || pId == uipushtool::properties::ID___OBJECT__
         || pId == uitoggletool::properties::ID___OBJECT__
         || pId == base_properties::ID___MODIFIED__)
       return;
 
     Logger::debug ("Backend::update %s(%d) from thread %08x",
                    go.type ().c_str (), pId, QThread::currentThreadId ());
diff --git a/libgui/graphics/Canvas.cc b/libgui/graphics/Canvas.cc
--- a/libgui/graphics/Canvas.cc
+++ b/libgui/graphics/Canvas.cc
@@ -377,17 +377,17 @@ namespace QtHandles
               {
                 omitfound = (childObj.get ("tag").string_value () == *p);
                 p++;
               }
             if (! omitfound)
               axesList.append (childObj);
           }
         else if (childObj.isa ("uicontrol") || childObj.isa ("uipanel")
-                 || childObj.isa ("uibuttongroup"))
+                 || childObj.isa ("uibuttongroup") || childObj.isa ("uitable"))
           {
             Matrix bb = childObj.get_properties ().get_boundingbox (false);
             QRectF r (bb(0), bb(1), bb(2), bb(3));
 
             r.adjust (-5, -5, 5, 5);
 
 #if defined (HAVE_QMOUSEEVENT_LOCALPOS)
             bool rect_contains_pos = r.contains (event->localPos ());
diff --git a/libgui/graphics/ObjectFactory.cc b/libgui/graphics/ObjectFactory.cc
--- a/libgui/graphics/ObjectFactory.cc
+++ b/libgui/graphics/ObjectFactory.cc
@@ -41,16 +41,17 @@ along with Octave; see the file COPYING.
 #include "ObjectFactory.h"
 #include "ObjectProxy.h"
 #include "Panel.h"
 #include "PopupMenuControl.h"
 #include "PushButtonControl.h"
 #include "PushTool.h"
 #include "RadioButtonControl.h"
 #include "SliderControl.h"
+#include "Table.h"
 #include "TextControl.h"
 #include "ToggleButtonControl.h"
 #include "ToggleTool.h"
 #include "ToolBar.h"
 #include "QtHandlesUtils.h"
 
 namespace QtHandles
 {
@@ -123,16 +124,18 @@ namespace QtHandles
                 else if (go.isa ("uibuttongroup"))
                   obj = ButtonGroup::create (go);
                 else if (go.isa ("uipanel"))
                   obj = Panel::create (go);
                 else if (go.isa ("uimenu"))
                   obj = Menu::create (go);
                 else if (go.isa ("uicontextmenu"))
                   obj = ContextMenu::create (go);
+                else if (go.isa ("uitable"))
+                  obj = Table::create (go);
                 else if (go.isa ("uitoolbar"))
                   obj = ToolBar::create (go);
                 else if (go.isa ("uipushtool"))
                   obj = PushTool::create (go);
                 else if (go.isa ("uitoggletool"))
                   obj = ToggleTool::create (go);
                 else
                   qWarning ("ObjectFactory::createObject: unsupported type `%s'",
diff --git a/libgui/graphics/QtHandlesUtils.cc b/libgui/graphics/QtHandlesUtils.cc
--- a/libgui/graphics/QtHandlesUtils.cc
+++ b/libgui/graphics/QtHandlesUtils.cc
@@ -135,16 +135,20 @@ namespace QtHandles
                                            int height);
 
     template QFont computeFont<uipanel> (const uipanel::properties& props,
                                          int height);
 
     template QFont computeFont<uibuttongroup> (const uibuttongroup::properties&
         props,
         int height);
+
+    template QFont computeFont<uitable> (const uitable::properties& props,
+                                         int height);
+
     QColor
     fromRgb (const Matrix& rgb)
     {
       QColor c;
 
       if (rgb.numel () == 3)
         c.setRgbF (rgb(0), rgb(1), rgb(2));
 
diff --git a/libgui/graphics/Table.cc b/libgui/graphics/Table.cc
new file mode 100644
--- /dev/null
+++ b/libgui/graphics/Table.cc
@@ -0,0 +1,1692 @@
+/*
+
+Copyright (C) 2016 Andrew Thornton
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 3 of the License, or (at your
+option) any later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, see
+<http://www.gnu.org/licenses/>.
+
+*/
+
+#if defined (HAVE_CONFIG_H)
+#  include "config.h"
+#endif
+
+#include <QEvent>
+#include <QFrame>
+#include <QLabel>
+#include <QMouseEvent>
+#include <QTimer>
+
+#include <QCheckBox>
+#include <QComboBox>
+#include <QHeaderView>
+#include <QLineEdit>
+#include <QModelIndexList>
+#include <QString>
+#include <QStringList>
+#include <QTableWidget>
+#include <QTableWidgetItem>
+#include <QHBoxLayout>
+
+#include "Container.h"
+#include "ContextMenu.h"
+#include "Table.h"
+#include "QtHandlesUtils.h"
+
+#include "oct-stream.h"
+#include "oct-string.h"
+#include "oct-strstrm.h"
+#include "ov-struct.h"
+
+namespace QtHandles
+{
+
+  static const int AUTO_WIDTH = 75;
+
+#define AUTO_HEIGHT \
+  tp.get_fontsize () * 2 - 1
+
+  static QSize realQSizeForTable(QTableWidget *t)
+  {
+    int w = t->verticalHeader ()->width () + 4;
+    for (int i = 0; i < t->columnCount (); i++)
+      w += t->columnWidth (i);
+    int h = t->horizontalHeader ()->height () + 4;
+    for (int i = 0; i < t->rowCount (); i++)
+      h += t->rowHeight (i);
+    return QSize(w, h);
+  }
+
+#define FORMATNUMBER(type)                                                    \
+  static QString formatNumber (type d,                                        \
+                               char format = 'f',                             \
+                               int precision = 4)                             \
+  {                                                                           \
+    if (format == 'n')                                                        \
+      {                                                                       \
+        if (d == floor (d))                                                   \
+          return QString::number(d, 'g', precision);                          \
+        else if (d <= pow (10, precision - 1) && d > pow (10, 1 - precision)) \
+          return QString::number(d, 'f', precision);                          \
+        else                                                                  \
+          return QString::number(d, 'e', precision);                          \
+      }                                                                       \
+    else if (format == 'F')                                                   \
+      {                                                                       \
+        int exponent = floor (log10 (d) / 3) * 3;                             \
+        d *=  pow (10, -exponent);                                            \
+        return QString::number(d, 'f', precision) + "e" +                     \
+          (exponent < 0 ? "-" : "+") +                                        \
+          QString("%1").arg(abs (exponent), 3, 10, QChar('0'));               \
+      }                                                                       \
+    else if (format == 'E')                                                   \
+      {                                                                       \
+        int exponent = floor (log10 (d) / 3) * 3;                             \
+        d *=  pow (10, -exponent);                                            \
+        return QString::number(d,                                             \
+                               'f',                                           \
+                               precision - floor (log10 (d)) - 1) +           \
+               "e" + (exponent < 0 ? "-" : "+") +                             \
+               QString("%1").arg(abs (exponent), 3, 10, QChar('0'));          \
+      }                                                                       \
+    else                                                                      \
+      return QString::number(d, format, precision);                           \
+  }
+
+  FORMATNUMBER(double)
+  FORMATNUMBER(float)
+
+#undef FORMATNUMBER
+
+  static QString formatComplex (Complex c, char format = 'f', int precision = 4)
+  {
+    return formatNumber(c.real(), format, precision) +
+      " + " + formatNumber(c.imag (), format, precision) + "i";
+  }
+
+#define FORMAT_VALUE_EXCEPT_RAT(f,l)                      \
+  if (format == "numeric" || format == "short")           \
+    text = formatNumber(value, 'n', f);                   \
+  else if (format == "short f" || format == "shortf")     \
+    text = formatNumber(value, 'f', f);                   \
+  else if (format == "short e" || format == "shorte")     \
+    text = formatNumber(value, 'e', f);                   \
+  else if (format == "short eng" || format == "shorteng") \
+    text = formatNumber(value, 'F', f);                   \
+  else if (format == "short g" || format == "shortg")     \
+    text = formatNumber(value, 'g', f + 1);               \
+  else if (format == "long")                              \
+    text = formatNumber(value, 'n', l);                   \
+  else if (format == "long f" || format == "longf")       \
+    text = formatNumber(value, 'f', l);                   \
+  else if (format == "long e" || format == "longe")       \
+    text = formatNumber(value, 'e', l);                   \
+  else if (format == "long eng" || format == "longeng")   \
+    text = formatNumber(value, 'E', l);                   \
+  else if (format == "long g" || format == "longg")       \
+    text = formatNumber(value, 'g', l + 1);               \
+  else if (format == "bank")                              \
+    text = QString::number(value, 'f', 2);                \
+  else if (format == "+")                                 \
+    if (value > 0)                                        \
+      text = Utils::fromStdString("+");                   \
+    else if (value < 0)                                   \
+      text = Utils::fromStdString("-");                   \
+    else                                                  \
+      text = Utils::fromStdString("");
+
+#define FORMAT_VALUE(f,l)                                            \
+  FORMAT_VALUE_EXCEPT_RAT(f,l)                                       \
+  else if (format == "rat")                                          \
+    text = Utils::fromStdString(rational_approx(double (value), 0)); \
+  else                                                               \
+    {                                                                \
+      text = formatNumber (value, 'n', f);                           \
+      flag = Qt::AlignLeft ;                                         \
+    }
+
+#define FORMAT_UINT_VALUE()                   \
+  text = QString::number(value);              \
+  if (format == "char"  || format == "popup") \
+    flag = Qt::AlignLeft;                     \
+  else if (format == "+")                     \
+    {                                         \
+      if (value > 0)                          \
+        text = Utils::fromStdString("+");     \
+      else                                    \
+        text = Utils::fromStdString("");      \
+    }
+
+#define FORMAT_INT_VALUE()                    \
+  text = QString::number(value);              \
+  if (format == "char" || format == "popup")  \
+    flag = Qt::AlignLeft ;                    \
+  else if (format == "+")                     \
+    {                                         \
+      if (value > 0)                          \
+        text = Utils::fromStdString("+");     \
+      else if (value < 0)                     \
+        text = Utils::fromStdString("-");     \
+      else                                    \
+        text = Utils::fromStdString("");      \
+    }
+
+  static std::pair <Qt::AlignmentFlag, QString> qStringValueFor (
+    octave_value val, std::string format = "")
+  {
+    Qt::AlignmentFlag flag = Qt::AlignRight;
+    QString text;
+    if (val.is_string ())
+      {
+        text = QtHandles::Utils::fromStdString (val.string_value ());
+        flag = Qt::AlignLeft ;
+      }
+    else if (val.iscomplex ())
+      {
+        // Matlab has mulitple complex types we only have double.
+        Complex c = val.complex_value ();
+        if (format == "short")
+          text = formatComplex(c, 'f', 4);
+        else if (format == "short e" || format == "shorte")
+          text = formatComplex(c, 'e', 4);
+        else if (format == "short eng" || format == "shorteng")
+          text = formatComplex(c, 'E', 4);
+        else if (format == "short g" || format == "shortg")
+          text = formatComplex(c, 'g', 5);
+        else if (format == "long")
+          text = formatComplex(c, 'f', 15);
+        else if (format == "long e" || format == "longe")
+          text = formatComplex(c, 'e', 15);
+        else if (format == "long eng" || format == "longeng")
+          text = formatComplex(c, 'E', 15);
+        else if (format == "long g" || format == "longg")
+          text = formatComplex(c, 'g', 16);
+        else if (format == "bank")
+          text = QString::number(c.real (), 'f', 2);
+        else if (format == "+")
+          {
+            if (c.real () > 0)
+              text = Utils::fromStdString("+");
+            else if (c.real () < 0)
+              text = Utils::fromStdString("-");
+            else
+              text = Utils::fromStdString("");
+          }
+        else if (format == "rat")
+          text = Utils::fromStdString(rational_approx(c.real (), 0)) + " + " +
+            Utils::fromStdString(rational_approx(c.imag (), 0)) + "i";
+        else if (format == "numeric")
+          text = QString::number (c.real (), 'g', 5) + " + "
+            + QString::number (c.imag (), 'g', 5) + "i";
+        else
+          {
+            text = QString::number (c.real (), 'g', 5) + " + "
+              + QString::number (c.imag (), 'g', 5) + "i";
+            flag = Qt::AlignLeft ;
+          }
+      }
+    else if (val.is_double_type () )
+      {
+        double value = val.double_value ();
+        FORMAT_VALUE(4, 15)
+      }
+    else if (val.is_single_type ())
+      {
+        float value = val.float_value ();
+        FORMAT_VALUE(4, 7)
+      }
+    else if (val.is_int8_type ())
+      {
+        short int value = val.short_value ();
+        FORMAT_INT_VALUE()
+      }
+    else if (val.is_uint8_type ())
+      {
+        unsigned short int value = val.ushort_value ();
+        FORMAT_UINT_VALUE()
+      }
+    else if (val.is_int16_type ())
+      {
+        int value = val.int_value ();
+        FORMAT_INT_VALUE()
+      }
+    else if (val.is_uint16_type ())
+      {
+        unsigned int value = val.uint_value ();
+        FORMAT_UINT_VALUE()
+      }
+    else if (val.is_int32_type ())
+      {
+        long int value = val.long_value ();
+        FORMAT_INT_VALUE()
+      }
+    else if (val.is_uint32_type ())
+      {
+        unsigned long int value = val.ulong_value ();
+        FORMAT_UINT_VALUE()
+      }
+    else if (val.is_int64_type ())
+      {
+        int64_t value = val.int64_value ();
+        FORMAT_INT_VALUE()
+      }
+    else if (val.is_uint64_type ())
+      {
+        uint64_t value = val.uint64_value ();
+        FORMAT_UINT_VALUE()
+      }
+    else if (val.islogical ())
+      {
+        bool b = val.bool_value ();
+        if (format == "char" || format == "popup" || format == "")
+          {
+            text = Utils::fromStdString(b ? "true" : "false");
+            flag = Qt::AlignLeft ;
+          }
+        else if (format == "+")
+          {
+            text = Utils::fromStdString(b ? "+" : "");
+            flag = Qt::AlignLeft ;
+          }
+        else
+          text = Utils::fromStdString(b ? "1" : "0");
+      }
+    else
+      {
+        std::stringstream warn_string;
+        warn_string << "Unknown conversion for datatype " << val.class_name ()
+          << " to " << format << " for value " << val.string_value (true);
+        warning (warn_string.str().c_str());
+
+        text = Utils::fromStdString(val.string_value (true));
+      }
+
+    return std::make_pair(flag, text);
+  }
+
+#undef FORMAT_VALUE
+#undef FORMAT_VALUE_EXCEPT_RAT
+#undef FORMAT_UINT_VALUE
+#undef FORMAT_INT_VALUE
+
+  static QTableWidgetItem * itemFor(octave_value val, std::string format = "",
+                                    bool enabled = false)
+  {
+    QTableWidgetItem* retval  = new QTableWidgetItem ();
+    std::pair <Qt::AlignmentFlag, QString> flag_and_text = qStringValueFor(val, format);
+    retval->setTextAlignment (flag_and_text.first);
+    retval->setText (flag_and_text.second);
+
+    if (enabled)
+      retval->setFlags (retval->flags ()  | Qt::ItemIsEditable);
+    else
+      retval->setFlags (retval->flags ()  & ~Qt::ItemIsEditable);
+
+    return retval;
+  }
+
+  static octave_value
+  attempt_type_conversion (const octave_value& ov, const octave_value& old_value)
+  {
+    octave_value retval;
+
+    // Define a macro to help with the conversion of strings to integers
+    // FIXME: these will happily integer overflow in the (u)int64 case
+    // - this probably doesn't matter.
+#define SCANF_AND_CONVERT(name,ctype,format)           \
+  else if (old_value.is_ ## name ## _type ())          \
+    {                                                  \
+      ctype val;                                       \
+      int n;                                           \
+      const char* c_str = ov.string_value ().c_str (); \
+      int error = sscanf (c_str, format, &val, &n);    \
+      if (error != 1 || c_str[n])                      \
+        {                                              \
+          val = 0;                                     \
+        }                                              \
+      retval = octave_value ( octave_ ## name (val));  \
+    }
+
+    if (old_value.is_string ())
+      retval = ov;
+    SCANF_AND_CONVERT(int8, int64_t, "%jd %n")
+    SCANF_AND_CONVERT(uint8, uint64_t, "%ju %n")
+    SCANF_AND_CONVERT(int16, int64_t, "%jd %n")
+    SCANF_AND_CONVERT(uint16, uint64_t, "%ju %n")
+    SCANF_AND_CONVERT(int32, int64_t, "%jd %n")
+    SCANF_AND_CONVERT(uint32, uint64_t, "%ju %n")
+    SCANF_AND_CONVERT(int64, int64_t, "%jd %n")
+    SCANF_AND_CONVERT(uint64, uint64_t, "%ju %n")
+
+  #undef SCANF_AND_CONVERT
+
+    else if (old_value.isnumeric () && !old_value.isinteger ())
+      {
+        // Basically need to do str2double
+        Complex complex = octave_str2double (ov.string_value ());
+        if (old_value.is_single_type ())
+          retval = octave_value (FloatComplex (complex));
+        else
+          retval = octave_value (complex);
+      }
+    else if (old_value.islogical ())
+      {
+        // Right: Matlab basically needs this to be true or false, we should
+        // accept 1 too.
+        if (ov.string_value ()  == "true" || ov.string_value () == "1")
+          retval = octave_value (true);
+        else
+          retval = octave_value (false);
+      }
+    else
+      retval = octave_value (octave_str2double (ov.string_value ()));
+    return retval;
+  }
+
+  QWidget *
+  Table::checkBoxForLogical (octave_value val, bool enabled = false)
+  {
+    QWidget *retval = new QWidget(m_tableWidget);
+    QCheckBox *checkBox = new QCheckBox();
+    QHBoxLayout *layout = new QHBoxLayout(retval);
+    layout->addWidget (checkBox);
+    layout->setAlignment (Qt::AlignCenter);
+    layout->setContentsMargins (0, 0, 0, 0);
+    retval->setLayout (layout);
+
+    if ((val.islogical () || val.is_bool_scalar ()) && val.bool_value ())
+      checkBox->setCheckState (Qt::Checked);
+    else
+      checkBox->setCheckState (Qt::Unchecked);
+
+    checkBox->setAttribute (Qt::WA_TransparentForMouseEvents, true);
+    checkBox->setFocusPolicy (Qt::NoFocus);
+    checkBox->setProperty ("Enabled", QVariant (enabled));
+
+    return retval;
+  }
+
+  Table*
+  Table::create (const graphics_object& go)
+  {
+    Object* parent = Object::parentObject (go);
+
+    if (parent)
+      {
+        Container* container = parent->innerContainer ();
+
+        if (container)
+          return new Table (go, new QTableWidget (container));
+      }
+
+      return 0;
+  }
+
+  Table::Table (const graphics_object& go, QTableWidget* tableWidget)
+    : Object (go, tableWidget), m_tableWidget(tableWidget), m_curData(),
+      m_blockUpdates(false)
+  {
+    uitable::properties& tp = properties<uitable> ();
+
+    m_curData = octave_value(tp.get_data ());
+    Matrix bb = tp.get_boundingbox (false);
+    m_tableWidget->setObjectName ("UITable");
+    m_tableWidget->setAutoFillBackground (true);
+    m_tableWidget->setGeometry (octave::math::round (bb(0)), octave::math::round (bb(1)),
+                    octave::math::round (bb(2)), octave::math::round (bb(3)));
+    m_tableWidget->setFont (Utils::computeFont<uitable> (tp)) ;
+    m_tableWidget->setSelectionBehavior (QAbstractItemView::SelectItems);
+    updatePalette ();
+    m_keyPressHandlerDefined = ! tp.get_keypressfcn ().isempty ();
+    m_keyReleaseHandlerDefined = ! tp.get_keyreleasefcn ().isempty ();
+    updateData ();
+    updateRowname ();
+    updateColumnname ();
+    updateColumnwidth();
+    updateEnable(); // Also does rearrangeableColumns
+    m_tableWidget->setToolTip (Utils::fromStdString (tp.get_tooltipstring ()));
+    m_tableWidget->setVisible (tp.is_visible ());
+    updateExtent ();
+    m_tableWidget->installEventFilter (this);
+
+
+    connect (m_tableWidget, SIGNAL (itemChanged (QTableWidgetItem*)),
+             SLOT (itemChanged (QTableWidgetItem*)));
+    connect (m_tableWidget, SIGNAL (cellClicked (int, int)),
+             SLOT (cellClicked (int, int)));
+    connect (m_tableWidget, SIGNAL (itemSelectionChanged (void)),
+             SLOT (itemSelectionChanged (void)));
+  }
+
+  Table::~Table (void)
+  {
+  }
+
+  void
+  Table::itemSelectionChanged ()
+  {
+    if (!(properties<uitable> ().get_cellselectioncallback ().isempty ()))
+      {
+        QModelIndexList modelIndexList = m_tableWidget->selectionModel()->selectedIndexes ();
+        int length = modelIndexList.size();
+        Matrix indices = Matrix (length, 2);
+        for (int i = 0; i < length; i++)
+          {
+            indices (i, 0) = modelIndexList.value (i).row () + 1;
+            indices (i, 1) = modelIndexList.value (i).column () + 1;
+          }
+        octave_scalar_map eventData;
+        eventData.setfield ("Indices", indices);
+        octave_value cellSelectionCallbackEventObject =
+          octave_value (new octave_struct (eventData));
+        gh_manager::post_callback(m_handle,
+                                  "cellselectioncallback",
+                                  cellSelectionCallbackEventObject);
+      }
+  }
+
+  void
+  Table::cellClicked (int row, int col)
+  {
+    QCheckBox* checkBox = NULL;
+    QWidget* widget = qobject_cast<QWidget*> (
+      m_tableWidget->cellWidget (row, col));
+    if (widget && !widget->children ().isEmpty ())
+      {
+        QHBoxLayout* layout = qobject_cast<QHBoxLayout*> (
+          widget->children ().first ());
+        if (layout && layout->count () > 0)
+          {
+            checkBox = qobject_cast<QCheckBox*> (
+              layout->itemAt (0)-> widget ());
+          }
+      }
+    if (checkBox && checkBox->property ("Enabled").toBool())
+      checkBoxClicked(row, col, checkBox);
+  }
+
+  void
+  Table::sendCellEditCallback (int row,
+    int col,
+    octave_value old_value,
+    octave_value new_value,
+    octave_value edit_data,
+    octave_value error)
+  {
+
+    if (!(properties<uitable> ().get_celleditcallback ().isempty ()))
+      {
+        Matrix indices = Matrix (1, 2);
+        indices (0, 0) = row + 1;
+        indices (0, 1) = col + 1;
+
+        octave_scalar_map eventData;
+        eventData.setfield ("Indices", indices);
+        eventData.setfield ("PreviousData", old_value);
+        eventData.setfield ("NewData", new_value);
+        eventData.setfield ("EditData", edit_data);
+        eventData.setfield ("Error", error);
+
+        octave_value cellEditCallbackEventObject =
+          octave_value (new octave_struct (eventData));
+
+        gh_manager::post_callback (m_handle,
+                                   "celleditcallback",
+                                   cellEditCallbackEventObject);
+      }
+    else if (error.string_value ().length () > 0)
+      warning (error.string_value ().c_str ());
+  }
+
+  void
+  Table::comboBoxCurrentIndexChanged (const QString& value)
+  {
+    if (m_blockUpdates)
+      return;
+    m_blockUpdates = true;
+    gh_manager::auto_lock lock;
+    octave_value data = octave_value(m_curData);
+    bool ok = false;
+
+    QComboBox* comboBox = qobject_cast<QComboBox*> (sender());
+    int row = comboBox->property ("row").toInt ();
+    int col = comboBox->property ("col").toInt ();
+
+    octave_value edit_data = octave_value(Utils::toStdString(value));
+
+    if (row < data.rows () && col < data.columns ())
+      {
+        if (data.iscell ())
+          {
+            Cell cell = data.cell_value ();
+            octave_value old_data = cell (row, col);
+            if (cell (row, col).is_string ())
+              {
+                cell (row, col) = edit_data;
+                if (edit_data.string_value () != old_data.string_value ())
+                  {
+                    m_curData = octave_value(cell);
+                    gh_manager::post_set (m_handle,
+                                          "data",
+                                          octave_value (cell),
+                                          false);
+                  }
+
+                octave_value error = octave_value("");
+                sendCellEditCallback(row,
+                  col,
+                  old_data,
+                  edit_data,
+                  edit_data,
+                  error);
+                ok = true;
+              }
+            else
+              {
+                cell (row, col) = attempt_type_conversion(edit_data, old_data);
+
+                // Inform the QTableWidget of our change
+                updateData(row, col, cell (row, col), columnformat (col), columneditable (col));
+
+                m_curData = octave_value(cell);
+                gh_manager::post_set (m_handle, "data", octave_value (cell), false);
+
+                octave_value error = octave_value("");
+                sendCellEditCallback(row,
+                  col,
+                  old_data,
+                  cell (row, col),
+                  edit_data,
+                  error);
+                ok = true;
+              }
+          }
+        else
+          {
+            octave_value old_data = data.is_matrix_type ()
+              ? data.fast_elem_extract(row + col * data.rows())
+              : octave_value ();
+            data.fast_elem_insert (row + col * data.rows(),
+                                   attempt_type_conversion(edit_data, old_data));
+
+            // Inform the QTableWidget of our change
+            updateData(row,
+                       col,
+                       data.fast_elem_extract (row + col * data.rows ()),
+                       columnformat (col),
+                       columneditable (col));
+
+            m_curData = octave_value(data);
+            gh_manager::post_set (m_handle, "data", data, false);
+
+            octave_value error = octave_value("");
+            sendCellEditCallback(row,
+              col,
+              old_data,
+              data.fast_elem_extract(row + col * data.rows()),
+              edit_data,
+              error);
+            ok = true;
+          }
+      }
+    else
+      {
+        // Reset the QTableWidgetItem
+        updateData(row, col, octave_value (""), columnformat (col), columneditable (col));
+
+        octave_value error = octave_value("Table data is not editable at this location.");
+        sendCellEditCallback(row,
+          col,
+          octave_value(),
+          octave_value(),
+          edit_data,
+          error);
+      }
+
+    if (!ok)
+      {
+        comboBox->setCurrentIndex (-1);
+        comboBox->setEditable (true);
+        comboBox->setEditText (comboBox->property ("original_value").toString ());
+        comboBox->lineEdit ()->setReadOnly (true);
+      }
+      m_blockUpdates = false;
+  }
+
+  void
+  Table::checkBoxClicked (int row, int col, QCheckBox* checkBox)
+  {
+    if (m_blockUpdates)
+      return;
+    m_blockUpdates = true;
+    gh_manager::auto_lock lock;
+
+    bool new_value = !checkBox->isChecked ();
+
+    octave_value data = octave_value(m_curData);
+    if (data.islogical ())
+      {
+        // EASY WE JUST CONVERT
+        boolMatrix matrix = data.bool_matrix_value ();
+        if (row < matrix.rows () && col < matrix.columns ())
+          {
+            bool old_value = matrix (row, col);
+            matrix (row, col) = new_value;
+            checkBox->setChecked(new_value);
+            if (new_value != old_value)
+              {
+                m_curData = octave_value(matrix);
+                gh_manager::post_set (m_handle, "data", octave_value(matrix), false);
+              }
+
+            sendCellEditCallback(row,
+              col,
+              octave_value(old_value),
+              octave_value(new_value),
+              octave_value(new_value),
+              octave_value(""));
+
+          }
+        else
+          {
+            sendCellEditCallback(row,
+              col,
+              octave_value(),
+              octave_value(),
+              octave_value(new_value),
+              octave_value("Table data is not editable at this location."));
+          }
+      }
+    else if (data.iscell ())
+      {
+        Cell cell = data.cell_value ();
+        if (row < cell.rows () && col < cell.columns ())
+          {
+              if (cell (row, col).islogical ())
+                {
+                  bool old_value = cell (row, col).bool_value ();
+                  cell (row, col) = octave_value(new_value);
+                  checkBox->setChecked(new_value);
+                  if (new_value != old_value)
+                    {
+                      m_curData = octave_value(cell);
+                      gh_manager::post_set (m_handle, "data", octave_value (cell), false);
+                    }
+
+                  sendCellEditCallback(row,
+                    col,
+                    octave_value(old_value),
+                    octave_value(new_value),
+                    octave_value(new_value),
+                    octave_value(""));
+                }
+              else
+                {
+                  sendCellEditCallback(row,
+                    col,
+                    cell (row, col),
+                    octave_value(),
+                    octave_value(new_value),
+                    octave_value("Cannot convert logical edit to other type."));
+                }
+          }
+        else
+          {
+            sendCellEditCallback(row,
+              col,
+              cell (row, col),
+              octave_value(),
+              octave_value(new_value),
+              octave_value("Table data is not editable at this location."));
+          }
+      }
+    else if (data.is_matrix_type ())
+      {
+        if (row < data.rows () && col < data.columns ())
+          {
+            sendCellEditCallback(row,
+              col,
+              data.fast_elem_extract (row + col * data.rows()),
+              octave_value(),
+              octave_value(new_value),
+              octave_value("Cannot convert logical edit to other type."));
+          }
+        else
+          {
+            sendCellEditCallback(row,
+              col,
+              data.fast_elem_extract (row + col * data.rows()),
+              octave_value(),
+              octave_value(new_value),
+              octave_value("Table data is not editable at this location."));
+          }
+      }
+      m_blockUpdates = false;
+  }
+
+
+  void
+  Table::itemChanged (QTableWidgetItem* item)
+  {
+    if (m_blockUpdates)
+      return;
+    m_blockUpdates = true;
+    gh_manager::auto_lock lock;
+    octave_value data = octave_value(m_curData);
+
+    int row = item->row ();
+    int col = item->column ();
+    octave_value edit_data = octave_value (Utils::toStdString(item->text ()));
+    octave_value new_value;
+    octave_value old_value;
+    octave_value new_data;
+
+    if (row < data.rows () && col < data.columns ())
+      {
+        if (data.iscell ())
+          {
+            old_value = data.cell_value () (row, col);
+          }
+        else if (data.is_matrix_type ())
+          {
+            old_value = data.fast_elem_extract (row + col * data.rows ());
+          }
+
+        // Now we need to coerce the new_value in to the type of the old_value
+        if (old_value.is_string ())
+          new_value = edit_data;
+        else
+          {
+            new_value = attempt_type_conversion(edit_data, old_value);
+            std::pair <Qt::AlignmentFlag, QString> flag_and_text =
+              qStringValueFor(new_value, columnformat (col));
+            item->setTextAlignment (flag_and_text.first);
+            item->setText (flag_and_text.second);
+          }
+
+        if (data.iscell ())
+          {
+            Cell cell = data.cell_value();
+            cell (row, col) = new_value;
+            new_data = octave_value (cell);
+          }
+        else
+          {
+            data.fast_elem_insert (row + col * data.rows (), new_value);
+            new_data = data;
+          }
+          m_curData = octave_value(new_data);
+          gh_manager::post_set (m_handle, "data", new_data, false);
+
+          sendCellEditCallback(row,
+            col,
+            octave_value(old_value),
+            octave_value(new_value),
+            octave_value(new_value),
+            octave_value(""));
+      }
+    else
+      {
+        item->setText ("");
+
+        octave_value error = octave_value("Table data is not editable at this location.");
+        sendCellEditCallback(row,
+          col,
+          octave_value(),
+          octave_value(),
+          edit_data,
+          error);
+      }
+
+      m_blockUpdates = false;
+  }
+
+  void
+  Table::update (int pId)
+  {
+    uitable::properties& tp = properties<uitable> ();
+
+    switch (pId)
+      {
+      case uitable::properties::ID_BACKGROUNDCOLOR:
+      case uitable::properties::ID_FOREGROUNDCOLOR:
+        updatePalette ();
+        break;
+
+      case uitable::properties::ID_COLUMNNAME:
+        updateColumnname ();
+        updateColumnwidth ();
+        break;
+
+      case uitable::properties::ID_COLUMNWIDTH:
+        updateColumnwidth ();
+        break;
+
+      case uitable::properties::ID_COLUMNEDITABLE:
+      case uitable::properties::ID_COLUMNFORMAT:
+      case uitable::properties::ID_DATA:
+        m_blockUpdates = true;
+        m_curData = octave_value(tp.get_data ());
+        updateData ();
+        updateRowname ();
+        updateColumnname ();
+        updateColumnwidth ();
+        updateEnable();
+        m_blockUpdates = false;
+        break;
+
+      case uitable::properties::ID_ENABLE:
+        updateEnable();
+        break;
+
+      case uitable::properties::ID_KEYPRESSFCN:
+        m_keyPressHandlerDefined = ! tp.get_keypressfcn ().isempty ();
+        break;
+
+      case uitable::properties::ID_KEYRELEASEFCN:
+        m_keyReleaseHandlerDefined = ! tp.get_keyreleasefcn ().isempty ();
+        break;
+
+        case uitable::properties::ID_FONTNAME:
+        case uitable::properties::ID_FONTSIZE:
+        case uitable::properties::ID_FONTWEIGHT:
+        case uitable::properties::ID_FONTANGLE:
+          if (m_tableWidget)
+            {
+              m_tableWidget->setFont (Utils::computeFont<uitable> (tp));
+              for (int row = 0; row < m_tableWidget->rowCount (); row++)
+                {
+                  m_tableWidget->setRowHeight (row, AUTO_HEIGHT);
+                }
+            }
+          break;
+
+      case uitable::properties::ID_POSITION:
+          {
+            Matrix bb = tp.get_boundingbox (false);
+            m_tableWidget->setGeometry (octave::math::round (bb(0)), octave::math::round (bb(1)),
+                                        octave::math::round (bb(2)), octave::math::round (bb(3)));
+            updateExtent();
+          }
+        break;
+
+      case uitable::properties::ID_REARRANGEABLECOLUMNS:
+        updateRearrangeableColumns ();
+        break;
+
+      case uitable::properties::ID_ROWNAME:
+        updateRowname ();
+        break;
+
+      case uitable::properties::ID_ROWSTRIPING:
+        updatePalette();
+        break;
+
+      case uitable::properties::ID_TOOLTIPSTRING:
+        m_tableWidget->setToolTip (Utils::fromStdString (tp.get_tooltipstring ()));
+        break;
+
+      case base_properties::ID_VISIBLE:
+        m_tableWidget->setVisible (tp.is_visible ());
+        break;
+
+      default:
+        break;
+
+      }
+  }
+
+  void
+  Table::updateColumnname (void)
+  {
+    uitable::properties& tp = properties<uitable> ();
+
+    // Reset the Column Count
+    m_tableWidget->setColumnCount (tp.get_data ().columns ());
+
+    octave_value columnname = tp.get_columnname ();
+    QStringList l;
+    bool visible = true;
+
+    if (columnname.is_string () && columnname.string_value (false) == "numbered")
+        for (int i = 0; i < m_tableWidget->columnCount (); i++)
+          l << QString::number(i + 1);
+    else if (columnname.is_string ())
+      {
+        if (m_tableWidget->columnCount () > 0)
+          l << Utils::fromStdString(columnname.string_value ());
+        for (int i = 1; i < m_tableWidget->columnCount (); i++)
+          l << "";
+      }
+    else if (columnname.isempty ())
+      {
+        for (int i = 0; i < m_tableWidget->columnCount (); i++)
+          l << "";
+
+        visible = false;
+      }
+    else if (columnname.iscell ())
+      {
+        octave_idx_type n = columnname.numel();
+        Cell cell_value = columnname.cell_value();
+
+        for (octave_idx_type i = 0; i < n; i++)
+          {
+            octave_value v = cell_value (i);
+            if (v.is_string ())
+              l << Utils::fromStdString(v.string_value (true));
+            else if (v.is_matrix_type ())
+              {
+                Matrix data = v.matrix_value ();
+
+                /* Now Matlab does something very strange here:
+                 * If data is a row or column matrix, then each datapoint is added
+                 * Otherwise nothing is set.
+                 */
+                if (data.rows () > 1 && data.cols () > 1)
+                  l << "";
+                else
+                  for (octave_idx_type j = 0; j < data.numel (); j++)
+                    l << QString::number(data (j));
+              }
+            else if (v.isnumeric ())
+              l << QString::number(v.double_value ());
+            else
+              l << QString::number(v.double_value ());
+          }
+      }
+    else if (columnname.is_matrix_type ())
+      {
+        octave_idx_type n = columnname.numel ();
+        Matrix matrix_value = columnname.matrix_value ();
+
+        for (octave_idx_type i = 0; i < n; i++)
+          l << QString::number(matrix_value (i));
+      }
+    else
+      {
+        for (int i = 0; i < m_tableWidget->columnCount (); i++)
+          l << "";
+        visible = false;
+      }
+
+    l.replaceInStrings("|", "\n");
+
+    // Now add the columns as required
+    if (m_tableWidget->columnCount () < l.length())
+      {
+        int oldColumnCount = m_tableWidget->columnCount ();
+        m_tableWidget->setColumnCount (l.length());
+        for (int col = oldColumnCount; col < l.length (); col++)
+          {
+            std::string format = columnformat (col);
+            bool enabled = columneditable (col);
+
+            for (int row = 0; row < m_tableWidget->rowCount (); row++)
+              updateData (row, col, octave_value (""), format, enabled);
+          }
+      }
+
+      m_tableWidget->setHorizontalHeaderLabels (l);
+      m_tableWidget->horizontalHeader ()->setVisible (visible);
+  }
+
+  void
+  Table::updateColumnwidth (void)
+  {
+    uitable::properties& tp = properties<uitable> ();
+
+    octave_value columnwidth = tp.get_columnwidth ();
+    if (columnwidth.isempty () ||
+      (columnwidth.is_string () && columnwidth.string_value (false) == "auto"))
+      for (int i = 0; i < m_tableWidget->columnCount (); i++)
+        m_tableWidget->setColumnWidth (i, AUTO_WIDTH);
+    else if (columnwidth.is_string () && columnwidth.string_value (false) == "preferred")
+      for (int i = 0; i < m_tableWidget->columnCount (); i++)
+        {
+          int column_size =
+            (qobject_cast<QAbstractItemView*> (m_tableWidget))->sizeHintForColumn (i);
+          int header_size = m_tableWidget->horizontalHeader ()->sectionSizeHint (i);
+
+          if (column_size > header_size)
+            header_size = column_size;
+          m_tableWidget->setColumnWidth (i, header_size);
+        }
+    else if (columnwidth.iscell ())
+      {
+        Cell cell_value = columnwidth.cell_value ();
+        int i = 0;
+        for (; i < m_tableWidget->columnCount () && i < cell_value.numel (); i++)
+          {
+            octave_value v = cell_value (i);
+            if (v.is_string ()  && v.string_value (false) == "auto")
+              m_tableWidget->setColumnWidth (i, AUTO_WIDTH);
+            else if (v.is_string () && v.string_value (false) == "preferred")
+              {
+                int column_size =
+                  (qobject_cast<QAbstractItemView*> (m_tableWidget))->sizeHintForColumn (i);
+                int header_size = m_tableWidget->horizontalHeader ()->sectionSizeHint (i);
+
+                if (column_size > header_size)
+                  header_size = column_size;
+                m_tableWidget->setColumnWidth (i, header_size);
+              }
+            else
+              {
+                int w = int (v.double_value());
+                m_tableWidget->setColumnWidth (i, w);
+              }
+          }
+        for (;i < m_tableWidget->columnCount (); i++)
+          {
+            int column_size =
+              (qobject_cast<QAbstractItemView*> (m_tableWidget))->sizeHintForColumn (i);
+            int header_size = m_tableWidget->horizontalHeader ()->sectionSizeHint (i);
+
+            if (column_size > header_size)
+              header_size = column_size;
+            m_tableWidget->setColumnWidth (i, header_size);
+          }
+      }
+    else if (columnwidth.is_matrix_type ())
+      {
+        Matrix matrix_value = columnwidth.matrix_value ();
+        int i = 0;
+        for (; i < m_tableWidget->columnCount () && i < matrix_value.numel (); i++)
+          {
+            octave_value v = matrix_value (i);
+            int w = int (v.double_value());
+            m_tableWidget->setColumnWidth (i, w);
+          }
+        for (;i < m_tableWidget->columnCount (); i++)
+          m_tableWidget->setColumnWidth (i, AUTO_WIDTH);
+      }
+  }
+
+  bool inline
+  Table::columneditable (int col)
+  {
+    uitable::properties& tp = properties<uitable> ();
+    boolNDArray columneditable = tp.get_columneditable ().bool_array_value ();
+    bool editable = false;
+
+    if (!columneditable.isempty () && col < columneditable.numel ())
+      editable = columneditable.xelem (col);
+    else if (!columneditable.isempty () && columneditable.numel () == 1)
+      editable = columneditable.xelem (0);
+
+    return editable;
+  }
+
+  std::string inline
+  Table::columnformat (int col)
+  {
+    uitable::properties& tp = properties<uitable> ();
+    std::string format = "";
+    octave_value ov_columnformat = tp.get_columnformat ();
+
+    if (ov_columnformat.iscell ())
+      {
+        Cell columnformat = ov_columnformat.cell_value ();
+        if (!columnformat.isempty () && col < columnformat.numel ())
+          {
+            octave_value format_value = columnformat.xelem (col);
+
+            if (!format_value.isempty () && format_value.is_string())
+              format = format_value.string_value ();
+            else if (!format_value.isempty () && format_value.iscell ())
+              format = "popup";
+          }
+      }
+    else if (ov_columnformat.is_string ())
+      {
+        format = ov_columnformat.string_value ();
+      }
+    return format;
+  }
+
+  void inline
+  Table::updateDataColumn (int col)
+  {
+    octave_value data = properties<uitable> ().get_data ();
+
+    std::string format = columnformat (col);
+    bool is_editable = columneditable (col);
+
+    for (octave_idx_type row = 0; row < data.rows (); row++)
+      updateData(row,
+        col,
+        data.iscell ()
+          ? data.cell_value () (row, col)
+          : data.fast_elem_extract (row + col * data.rows ()),
+        format,
+        is_editable);
+  }
+
+  void inline
+  Table::updateData (int row, int col)
+  {
+    octave_value data = properties<uitable> ().get_data ();
+    updateData (row,
+      col,
+      data.iscell ()
+        ? data.cell_value () (row, col)
+        : data.fast_elem_extract (row + col * data.rows ()),
+      columnformat (col),
+      columneditable (col));
+  }
+
+  void inline
+  Table::updateData (int row, int col, octave_value value,
+                     std::string format = "", bool enabled = false)
+  {
+    if (format == "logical" || (format == "" && value.islogical ()))
+      {
+        if (m_tableWidget->item (row, col))
+          delete m_tableWidget->item (row, col);
+
+        m_tableWidget->setCellWidget (row, col, checkBoxForLogical(value, enabled));
+        m_tableWidget->cellWidget (row, col)->setProperty ("row", QVariant(row));
+        m_tableWidget->cellWidget (row, col)->setProperty ("col", QVariant(col));
+      }
+    else if (format == "popup" && enabled)
+      {
+        if (m_tableWidget->item (row, col))
+          delete m_tableWidget->item (row, col);
+
+        QString string_value = qStringValueFor(value, format).second;
+        uitable::properties& tp = properties<uitable> ();
+        octave_value format_value = tp.get_columnformat ().cell_value ().xelem (col);
+
+        QComboBox* comboBox = new QComboBox ();
+        comboBox->setProperty("row", QVariant (row));
+        comboBox->setProperty("col", QVariant (col));
+
+        int index = -1;
+        for (int k = 0; k < format_value.numel (); k++)
+          {
+            QString popup_item = Utils::fromStdString(
+              format_value.fast_elem_extract (k).string_value ());
+
+            comboBox->addItem (popup_item);
+
+            if (popup_item == string_value)
+              index = k;
+          }
+        comboBox->setCurrentIndex (index);
+
+        if (index < 0)
+          {
+            comboBox->setEditable (true);
+            comboBox->setEditText (string_value);
+            comboBox->lineEdit ()->setReadOnly (true);
+          }
+
+        comboBox->setProperty ("original_value", QVariant (string_value));
+
+        comboBox->installEventFilter (this);
+        m_tableWidget->setCellWidget(row, col, comboBox);
+        connect(comboBox, SIGNAL(currentIndexChanged(const QString&)),
+                this, SLOT(comboBoxCurrentIndexChanged(const QString&)));
+      }
+    else
+      {
+        if (m_tableWidget->cellWidget (row, col))
+          delete m_tableWidget->cellWidget (row, col);
+        m_tableWidget->setItem (row, col, itemFor(value, format, enabled));
+      }
+  }
+
+  void
+  Table::updateData ()
+  {
+    uitable::properties& tp = properties<uitable> ();
+
+    octave_value data = tp.get_data();
+
+    if (data.iscell () || data.is_matrix_type ())
+      {
+        m_tableWidget->setRowCount (data.rows ());
+        m_tableWidget->setColumnCount (data.columns ());
+
+        for (octave_idx_type col = 0; col < data.columns (); col++)
+          updateDataColumn (col);
+      }
+
+    for (octave_idx_type row = 0; row < m_tableWidget->rowCount (); row++)
+      m_tableWidget->setRowHeight (row, AUTO_HEIGHT);
+  }
+
+  void
+  Table::updateEnable (void)
+  {
+    uitable::properties& tp = properties<uitable> ();
+    m_tableWidget->setEnabled (!tp.enable_is ("off"));
+
+    bool enabled = tp.enable_is ("on");
+    bool rearrangeableColumns = tp.is_rearrangeablecolumns ();
+
+    // Set selection mode
+    m_tableWidget->setSelectionMode (enabled
+      ? QAbstractItemView::ExtendedSelection
+      : QAbstractItemView::NoSelection);
+
+    // Set rearrangeablecolumns
+    #if defined (HAVE_QT4)
+      m_tableWidget->horizontalHeader ()->setMovable (enabled && rearrangeableColumns);
+    #elif defined (HAVE_QT5)
+      m_tableWidget->horizontalHeader ()->setSectionsMovable (enabled && rearrangeableColumns);
+    #endif
+    m_tableWidget->horizontalHeader ()->setDragEnabled (enabled && rearrangeableColumns);
+    m_tableWidget->horizontalHeader ()->setDragDropMode (QAbstractItemView::InternalMove);
+
+    // Turn off column editable
+    for (int col = 0; col < m_tableWidget->columnCount (); col++)
+      {
+        bool editable = columneditable (col);
+
+        for (int row = 0; row < m_tableWidget->rowCount (); row++)
+          if (QTableWidgetItem* item = m_tableWidget->item (row, col))
+            {
+              Qt::ItemFlags flags = item->flags ();
+              if (enabled && editable)
+                item->setFlags (flags | Qt::ItemIsEditable);
+              else
+                item->setFlags (flags & ~Qt::ItemIsEditable);
+            }
+          else if (QWidget* widget = m_tableWidget->cellWidget (row, col))
+            {
+              QCheckBox* checkBox = NULL;
+              if (widget && !widget->children ().isEmpty ())
+                {
+                  QHBoxLayout* layout = qobject_cast<QHBoxLayout*> (
+                    widget->children ().first ());
+                  if (layout && layout->count () > 0)
+                    {
+                      checkBox = qobject_cast<QCheckBox*> (
+                        layout->itemAt (0)-> widget ());
+                    }
+                }
+              if (checkBox)
+                {
+                  widget->setProperty ("Enabled", QVariant (enabled & editable));
+                }
+              else
+                {
+                  widget->setAttribute(Qt::WA_TransparentForMouseEvents, !(editable & enabled));
+                  widget->setFocusPolicy(Qt::NoFocus);
+                }
+            }
+      }
+  }
+
+  void
+  Table::updateExtent (void)
+  {
+    QSize s = realQSizeForTable (m_tableWidget);
+    Matrix extent = Matrix (1, 4);
+    extent(0, 0) = 0;
+    extent(0, 1) = 0;
+    extent(0, 2) = s.width ();
+    extent(0, 3) = s.height () ;
+    graphics_object go = object ();
+    gh_manager::post_set (go.get_handle (), "extent", extent, false);
+  }
+
+  void
+  Table::updatePalette (void)
+  {
+    uitable::properties& tp = properties<uitable> ();
+
+    QPalette p = m_tableWidget->palette ();
+    p.setColor (QPalette::Text,
+                Utils::fromRgb (tp.get_foregroundcolor_rgb ()));
+    p.setColor (QPalette::Base,
+              Utils::fromRgb (tp.get_backgroundcolor_rgb ()));
+    p.setColor (QPalette::AlternateBase,
+              Utils::fromRgb (tp.get_alternatebackgroundcolor_rgb ()));
+    m_tableWidget->setPalette (p);
+    m_tableWidget->setAlternatingRowColors (tp.is_rowstriping ());
+    // FIXME: Handle multiple alternating background colors
+  }
+
+  void
+  Table::updateRowname (void)
+  {
+    uitable::properties& tp = properties<uitable> ();
+
+    // Reset the row count
+    m_tableWidget->setRowCount (tp.get_data ().rows ());
+
+    octave_value rowname = tp.get_rowname ();
+    QStringList l;
+    bool visible = true;
+
+    if (rowname.is_string () && rowname.string_value (false) == "numbered")
+      for (int i = 0; i < m_tableWidget->rowCount (); i++)
+        l << QString::number(i + 1);
+    else if (rowname.is_string ())
+      {
+        if (m_tableWidget->rowCount () > 0)
+          l << Utils::fromStdString(rowname.string_value ());
+        for (int i = 1; i < m_tableWidget->rowCount (); i++)
+          l << "";
+      }
+    else if (rowname.isempty ())
+      {
+        for (int i = 0; i < m_tableWidget->rowCount (); i++)
+          l << "";
+        visible = false;
+      }
+    else if (rowname.iscell ())
+      {
+        octave_idx_type n = rowname.numel();
+        Cell cell_value = rowname.cell_value();
+
+        for (octave_idx_type i = 0; i < n; i++)
+          {
+            octave_value v = cell_value (i);
+            if (v.is_string ())
+              l << Utils::fromStdString(v.string_value (true));
+            else if (v.is_matrix_type ())
+              {
+                Matrix data = v.matrix_value ();
+
+                /* Now Matlab does something very strange here:
+                 * If data is a row or column matrix, then each datapoint is added
+                 * Otherwise nothing is set.
+                 */
+                if (data.rows () > 1 && data.cols () > 1)
+                  l << "";
+                else
+                  for (octave_idx_type j = 0; j < data.numel (); j++)
+                    l << QString::number(data (j));
+              }
+            else if (v.isnumeric ())
+              l << QString::number(v.double_value (true));
+            else
+              l << QString::number(v.double_value (true));
+          }
+      }
+    else if (rowname.is_matrix_type ())
+      {
+        octave_idx_type n = rowname.numel();
+        Matrix matrix_value = rowname.matrix_value();
+
+        for (octave_idx_type i = 0; i < n; i++)
+          l << QString::number(matrix_value (i));
+      }
+    else
+      {
+        for (int i = 0; i < m_tableWidget->columnCount (); i++)
+          l << "";
+        visible = false;
+      }
+
+    // Add dummy rows as required
+    if (m_tableWidget->rowCount () < l.length())
+      {
+        int oldRowCount = m_tableWidget->rowCount ();
+        m_tableWidget->setRowCount (l.length());
+
+        for (int col = 0; col < m_tableWidget->columnCount (); col++)
+          {
+            std::string format = columnformat (col);
+            bool enabled = columneditable (col);
+
+            for (int row = oldRowCount; row < l.length (); row++)
+              {
+                m_tableWidget->setRowHeight (row, AUTO_HEIGHT);
+
+                updateData (row, col, octave_value (""), format, enabled);
+              }
+          }
+      }
+
+    m_tableWidget->setVerticalHeaderLabels (l);
+    m_tableWidget->verticalHeader ()->setVisible (visible);
+  }
+
+  void
+  Table::updateRearrangeableColumns (void)
+  {
+    uitable::properties& tp = properties<uitable> ();
+
+    bool rearrangeableColumns = tp.is_rearrangeablecolumns ();
+    bool enabled = tp.enable_is ("on");
+
+  #if defined (HAVE_QT4)
+    m_tableWidget->horizontalHeader ()->setMovable (enabled && rearrangeableColumns);
+  #elif defined (HAVE_QT5)
+    m_tableWidget->horizontalHeader ()->setSectionsMovable (enabled && rearrangeableColumns);
+  #endif
+    m_tableWidget->horizontalHeader ()->setDragEnabled (enabled && rearrangeableColumns);
+    m_tableWidget->horizontalHeader ()->setDragDropMode (QAbstractItemView::InternalMove);
+  }
+
+  bool
+  Table::eventFilter (QObject* watched, QEvent* xevent)
+  {
+    //uitable::properties& tp = properties<uitable> ();
+    if (qobject_cast<QTableWidget*> (watched))
+      {
+        switch (xevent->type ())
+          {
+          case QEvent::Resize:
+            {
+              gh_manager::auto_lock lock;
+              graphics_object go = object ();
+              if (go.valid_object ())
+                {
+                  const uitable::properties& tp =
+                    Utils::properties<uitable> (go);
+                  if (tp.fontunits_is ("normalized"))
+                    m_tableWidget->setFont (Utils::computeFont<uitable> (tp));
+                }
+            }
+            break;
+
+          case QEvent::MouseButtonPress:
+            {
+              gh_manager::auto_lock lock;
+              QMouseEvent* m = dynamic_cast<QMouseEvent*> (xevent);
+              graphics_object go = object ();
+              const uitable::properties& tp =
+                Utils::properties<uitable> (go);
+              graphics_object fig = go.get_ancestor ("figure");
+
+              if (m->button () != Qt::LeftButton || !tp.enable_is ("on"))
+                {
+                  gh_manager::post_set (fig.get_handle (), "selectiontype",
+                                        Utils::figureSelectionType (m), false);
+                  gh_manager::post_set (fig.get_handle (), "currentpoint",
+                                        Utils::figureCurrentPoint (fig, m),
+                                        false);
+                  gh_manager::post_callback (fig.get_handle (),
+                                             "windowbuttondownfcn");
+                  gh_manager::post_callback (m_handle, "buttondownfcn");
+
+                  if (m->button () == Qt::RightButton)
+                    ContextMenu::executeAt (properties (), m->globalPos ());
+                }
+              else
+                {
+                  gh_manager::post_set (fig.get_handle (), "selectiontype",
+                                       octave_value ("normal"), false);
+                }
+            }
+            break;
+
+          case QEvent::KeyPress:
+            {
+              QKeyEvent* k = dynamic_cast<QKeyEvent*> (xevent);
+              if (m_keyPressHandlerDefined)
+                {
+                  gh_manager::auto_lock lock;
+
+                  octave_scalar_map keyData = Utils::makeKeyEventStruct (k);
+                  graphics_object fig = object ().get_ancestor ("figure");
+
+                  gh_manager::post_set (fig.get_handle (), "currentcharacter",
+                                        keyData.getfield ("Character"), false);
+                  gh_manager::post_callback (m_handle, "keypressfcn", keyData);
+                }
+              int row = m_tableWidget->currentRow ();
+              int col = m_tableWidget->currentColumn ();
+              switch (k->key())
+                {
+                case Qt::Key_Space:
+                  {
+                    QCheckBox* checkBox = NULL;
+                    QWidget* widget = qobject_cast<QWidget*> (
+                      m_tableWidget->cellWidget (row, col));
+                    if (widget && !widget->children ().isEmpty ())
+                      {
+                        QHBoxLayout* layout = qobject_cast<QHBoxLayout*> (
+                          widget->children ().first ());
+                        if (layout && layout->count () > 0)
+                          {
+                            checkBox = qobject_cast<QCheckBox*> (
+                              layout->itemAt (0)-> widget ());
+                          }
+                      }
+                    if (checkBox && checkBox->property ("Enabled").toBool())
+                      checkBoxClicked(row, col, checkBox);
+  
+                    QComboBox* comboBox = qobject_cast<QComboBox*> (
+                      m_tableWidget->cellWidget (row, col));
+                    if (comboBox)
+                      comboBox->showPopup ();
+                  }
+                  break;
+
+                case Qt::Key_Return:
+                case Qt::Key_Enter:
+                  {
+                    if (k->modifiers() == Qt::NoModifier)
+                      {
+                        if (row + 1 < m_tableWidget->rowCount())
+                          m_tableWidget->setCurrentCell (row + 1, col);
+                        else
+                          {
+                            if (col + 1 < m_tableWidget->columnCount())
+                              m_tableWidget->setCurrentCell (0, col + 1);
+                            else
+                              m_tableWidget->setCurrentCell (0, 0);
+                          }
+                      }
+                    else if (k->modifiers() == Qt::ShiftModifier)
+                      {
+                        if (row - 1 >= 0)
+                          m_tableWidget->setCurrentCell (row - 1, col);
+                        else
+                          {
+                            if (col - 1 >= 0)
+                              m_tableWidget->setCurrentCell
+                                  (m_tableWidget->rowCount() - 1,
+                                   col - 1);
+                            else
+                              m_tableWidget->setCurrentCell
+                                  (m_tableWidget->rowCount() - 1,
+                                   m_tableWidget->columnCount() - 1);
+                          }
+                      }
+                  }
+                  break;
+
+                default:
+                  break;
+                }
+            }
+            break;
+
+          case QEvent::KeyRelease:
+            {
+              if (m_keyReleaseHandlerDefined)
+                {
+                  gh_manager::auto_lock lock;
+                  QKeyEvent* k = dynamic_cast<QKeyEvent*> (xevent);
+
+                  octave_scalar_map keyData = Utils::makeKeyEventStruct (k);
+                  graphics_object fig = object ().get_ancestor ("figure");
+
+                  gh_manager::post_set (fig.get_handle (), "currentcharacter",
+                                        keyData.getfield ("Character"), false);
+                  gh_manager::post_callback (m_handle, "keyreleasefcn", keyData);
+                }
+            }
+            break;
+
+          default:
+            break;
+          }
+      }
+    else if (qobject_cast<QComboBox*> (watched))
+      {
+        switch (xevent->type ())
+          {
+          case QEvent::MouseButtonPress:
+            {
+              gh_manager::auto_lock lock;
+              QMouseEvent* m = dynamic_cast<QMouseEvent*> (xevent);
+              graphics_object go = object ();
+              const uitable::properties& tp =
+                Utils::properties<uitable> (go);
+              graphics_object fig = go.get_ancestor ("figure");
+
+              if (m->button () != Qt::LeftButton || !tp.enable_is ("on"))
+                {
+                  gh_manager::post_set (fig.get_handle (), "selectiontype",
+                                        Utils::figureSelectionType (m), false);
+                  gh_manager::post_set (fig.get_handle (), "currentpoint",
+                                        Utils::figureCurrentPoint (fig, m),
+                                        false);
+                  gh_manager::post_callback (fig.get_handle (),
+                                             "windowbuttondownfcn");
+                  gh_manager::post_callback (m_handle, "buttondownfcn");
+
+                  if (m->button () == Qt::RightButton)
+                    ContextMenu::executeAt (tp, m->globalPos ());
+                }
+              else
+                {
+                  gh_manager::post_set (fig.get_handle (), "selectiontype",
+                                       Utils::figureSelectionType (m), false);
+
+                  QComboBox* comboBox_0 = qobject_cast<QComboBox*> (watched);
+                  for (int row = 0; row < m_tableWidget->rowCount (); row++)
+                    {
+                      for (int col = 0; col < m_tableWidget->columnCount (); col++)
+                        {
+                          QComboBox* comboBox_1 = qobject_cast<QComboBox*> (
+                            m_tableWidget->cellWidget (row, col));
+                          if (comboBox_0 == comboBox_1)
+                            m_tableWidget->setCurrentCell (row, col);
+                        }
+                    }
+                }
+            }
+            break;
+
+          default:
+            break;
+          }
+      }
+    return false;
+  }
+
+#undef AUTO_HEIGHT
+}
diff --git a/libgui/graphics/Table.h b/libgui/graphics/Table.h
new file mode 100644
--- /dev/null
+++ b/libgui/graphics/Table.h
@@ -0,0 +1,91 @@
+/*
+
+Copyright (C) 2016 Andrew Thornton
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 3 of the License, or (at your
+option) any later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, see
+<http://www.gnu.org/licenses/>.
+
+*/
+
+#if ! defined (octave_Table_h)
+#define octave_Table_h 1
+
+#include "Object.h"
+
+class QCheckBox;
+class QTableWidget;
+class QTableWidgetItem;
+
+namespace QtHandles
+{
+
+  class Container;
+
+  class Table : public Object
+  {
+    Q_OBJECT
+
+  public:
+    Table (const graphics_object& go, QTableWidget* tableWidget);
+    ~Table (void);
+
+    Container* innerContainer (void) { return m_container; }
+
+    bool eventFilter (QObject* watched, QEvent* event);
+
+    static Table* create (const graphics_object& go);
+
+  protected:
+    void update (int pId);
+    //void redraw (void);
+    void updateColumnname (void);
+    void updateColumnwidth (void);
+    void updateData (void);
+    void updateEnable (void);
+    void updateExtent (void);
+    void updatePalette (void);
+    void updateRearrangeableColumns (void);
+    void updateRowname (void);
+
+  private slots:
+    void itemChanged (QTableWidgetItem* item);
+    void comboBoxCurrentIndexChanged (const QString& value);
+    void cellClicked (int row, int col);
+    void itemSelectionChanged (void);
+
+  private:
+    Container* m_container;
+    QTableWidget* m_tableWidget;
+    octave_value m_curData;
+    bool m_blockUpdates;
+    bool m_keyPressHandlerDefined;
+    bool m_keyReleaseHandlerDefined;
+    QWidget * checkBoxForLogical(octave_value cal, bool enabled);
+    void updateData (int row, int col, octave_value value, std::string format, bool enabled);
+    void updateData (int row, int col);
+    void updateDataColumn (int col);
+    std::string columnformat (int column);
+    bool columneditable (int column);
+    void sendCellEditCallback (int row, int col, octave_value old_value, octave_value new_value, octave_value edit_data, octave_value error);
+    void checkBoxClicked (int row, int col, QCheckBox* checkBox);
+
+
+
+  };
+
+}; // namespace QtHandles
+
+#endif
diff --git a/libgui/graphics/module.mk b/libgui/graphics/module.mk
--- a/libgui/graphics/module.mk
+++ b/libgui/graphics/module.mk
@@ -16,16 +16,17 @@ OCTAVE_GUI_GRAPHICS_MOC = \
   %reldir%/moc-MouseModeActionGroup.cc \
   %reldir%/moc-Object.cc \
   %reldir%/moc-ObjectFactory.cc \
   %reldir%/moc-ObjectProxy.cc \
   %reldir%/moc-PopupMenuControl.cc \
   %reldir%/moc-PushTool.cc \
   %reldir%/moc-SliderControl.cc \
   %reldir%/moc-TextEdit.cc \
+  %reldir%/moc-Table.cc \
   %reldir%/moc-ToggleTool.cc \
   %reldir%/moc-ToolBar.cc
 
 $(OCTAVE_GUI_GRAPHICS_MOC): | %reldir%/$(octave_dirstamp)
 
 DIRSTAMP_FILES += \
   %reldir%/$(octave_dirstamp)
 
@@ -72,16 +73,17 @@ noinst_HEADERS += \
   %reldir%/ObjectProxy.h \
   %reldir%/Panel.h \
   %reldir%/PopupMenuControl.h \
   %reldir%/PushButtonControl.h \
   %reldir%/PushTool.h \
   %reldir%/QtHandlesUtils.h \
   %reldir%/RadioButtonControl.h \
   %reldir%/SliderControl.h \
+  %reldir%/Table.h \
   %reldir%/TextControl.h \
   %reldir%/TextEdit.h \
   %reldir%/ToggleButtonControl.h \
   %reldir%/ToggleTool.h \
   %reldir%/ToolBar.h \
   %reldir%/ToolBarButton.h \
   %reldir%/gl-select.h \
   %reldir%/qopengl-functions.h \
@@ -112,16 +114,17 @@ noinst_HEADERS += \
   %reldir%/ObjectProxy.cc \
   %reldir%/Panel.cc \
   %reldir%/PopupMenuControl.cc \
   %reldir%/PushButtonControl.cc \
   %reldir%/PushTool.cc \
   %reldir%/QtHandlesUtils.cc \
   %reldir%/RadioButtonControl.cc \
   %reldir%/SliderControl.cc \
+  %reldir%/Table.cc \
   %reldir%/TextControl.cc \
   %reldir%/TextEdit.cc \
   %reldir%/ToggleButtonControl.cc \
   %reldir%/ToggleTool.cc \
   %reldir%/ToolBar.cc \
   %reldir%/gl-select.cc
 
 TEMPLATE_SRC = \
diff --git a/libinterp/corefcn/genprops.awk b/libinterp/corefcn/genprops.awk
--- a/libinterp/corefcn/genprops.awk
+++ b/libinterp/corefcn/genprops.awk
@@ -227,20 +227,20 @@ function emit_get_double_radio (i)
 
   emit_get_accessor(i, "octave_value", "get");
 }
 
 ## callback_property
 
 function emit_get_callback (i)
 {
-  printf ("  void execute_%s (const octave_value& data = octave_value ()) const", name[i]);
+  printf ("  void execute_%s (const octave_value& new_data = octave_value ()) const", name[i]);
 
   if (emit_get[i] == "definition")
-    printf (" { %s.execute (data); }\n", name[i]);
+    printf (" { %s.execute (new_data); }\n", name[i]);
   else
     printf (";\n");
 
   emit_get_accessor(i, "octave_value", "get");
 }
 
 ## array_property
 
diff --git a/libinterp/corefcn/gl-render.cc b/libinterp/corefcn/gl-render.cc
--- a/libinterp/corefcn/gl-render.cc
+++ b/libinterp/corefcn/gl-render.cc
@@ -666,17 +666,18 @@ namespace octave
     else if (go.isa ("hggroup"))
       draw_hggroup (dynamic_cast<const hggroup::properties&> (props));
     else if (go.isa ("text"))
       draw_text (dynamic_cast<const text::properties&> (props));
     else if (go.isa ("image"))
       draw_image (dynamic_cast<const image::properties&> (props));
     else if (go.isa ("uimenu") || go.isa ("uicontrol")
              || go.isa ("uicontextmenu") || go.isa ("uitoolbar")
-             || go.isa ("uipushtool") || go.isa ("uitoggletool"))
+             || go.isa ("uipushtool") || go.isa ("uitoggletool")
+             || go.isa ("uitable"))
       ; // SKIP
     else if (go.isa ("uipanel"))
       {
         if (toplevel)
           draw_uipanel (dynamic_cast<const uipanel::properties&> (props), go);
       }
     else if (go.isa ("uibuttongroup"))
       {
diff --git a/libinterp/corefcn/graphics.cc b/libinterp/corefcn/graphics.cc
--- a/libinterp/corefcn/graphics.cc
+++ b/libinterp/corefcn/graphics.cc
@@ -561,16 +561,42 @@ default_light_position (void)
 
   m(0) = 1.0;
   m(1) = 0.0;
   m(2) = 1.0;
 
   return m;
 }
 
+static Matrix
+default_table_position (void)
+{
+  Matrix retval (1, 4);
+
+  retval(0) = 20;
+  retval(1) = 20;
+  retval(2) = 300;
+  retval(3) = 300;
+
+  return retval;
+}
+
+static Matrix
+default_table_backgroundcolor (void)
+{
+  Matrix retval (2, 3);
+  retval(0, 0) = 1;
+  retval(0, 1) = 1;
+  retval(0, 2) = 1;
+  retval(1, 0) = 0.94;
+  retval(1, 1) = 0.94;
+  retval(1, 2) = 0.94;
+  return retval;
+}
+
 static double
 convert_font_size (double font_size, const caseless_str& from_units,
                    const caseless_str& to_units, double parent_height = 0)
 {
   // Simple case where from_units == to_units
 
   if (from_units.compare (to_units))
     return font_size;
@@ -1068,17 +1094,17 @@ lookup_object_name (const caseless_str& 
 
               if (pfx.compare ("figure") || pfx.compare ("uimenu"))
                 offset = 6;
               else if (len >= 7)
                 {
                   pfx = name.substr (0, 7);
 
                   if (pfx.compare ("surface") || pfx.compare ("hggroup")
-                      || pfx.compare ("uipanel"))
+                      || pfx.compare ("uipanel") || pfx.compare ("uitable"))
                     offset = 7;
                   else if (len >= 9)
                     {
                       pfx = name.substr (0, 9);
 
                       if (pfx.compare ("uicontrol")
                           || pfx.compare ("uitoolbar"))
                         offset = 9;
@@ -1150,16 +1176,18 @@ make_graphics_object_from_type (const ca
   else if (type.compare ("uicontrol"))
     go = new uicontrol (h, p);
   else if (type.compare ("uipanel"))
     go = new uipanel (h, p);
   else if (type.compare ("uibuttongroup"))
     go = new uibuttongroup (h, p);
   else if (type.compare ("uicontextmenu"))
     go = new uicontextmenu (h, p);
+  else if (type.compare ("uitable"))
+    go = new uitable (h, p);
   else if (type.compare ("uitoolbar"))
     go = new uitoolbar (h, p);
   else if (type.compare ("uipushtool"))
     go = new uipushtool (h, p);
   else if (type.compare ("uitoggletool"))
     go = new uitoggletool (h, p);
   return go;
 }
@@ -2155,17 +2183,17 @@ property_list::set (const caseless_str& 
 
               if (pfx.compare ("figure") || pfx.compare ("uimenu"))
                 offset = 6;
               else if (len > 7)
                 {
                   pfx = name.substr (0, 7);
 
                   if (pfx.compare ("surface") || pfx.compare ("hggroup")
-                      || pfx.compare ("uipanel"))
+                      || pfx.compare ("uipanel") || pfx.compare ("uitable"))
                     offset = 7;
                   else if (len > 9)
                     {
                       pfx = name.substr (0, 9);
 
                       if (pfx.compare ("uicontrol")
                           || pfx.compare ("uitoolbar"))
                         offset = 9;
@@ -2228,16 +2256,18 @@ property_list::set (const caseless_str& 
           else if (pfx == "uicontrol")
             has_property = uicontrol::properties::has_core_property (pname);
           else if (pfx == "uibuttongroup")
             has_property = uibuttongroup::properties::has_core_property (pname);
           else if (pfx == "uipanel")
             has_property = uipanel::properties::has_core_property (pname);
           else if (pfx == "uicontextmenu")
             has_property = uicontextmenu::properties::has_core_property (pname);
+          else if (pfx == "uitable")
+            has_property = uitable::properties::has_core_property (pname);
           else if (pfx == "uitoolbar")
             has_property = uitoolbar::properties::has_core_property (pname);
           else if (pfx == "uipushtool")
             has_property = uipushtool::properties::has_core_property (pname);
 
           if (! has_property)
             error ("invalid %s property '%s'", pfx.c_str (), pname.c_str ());
 
@@ -2295,17 +2325,17 @@ property_list::lookup (const caseless_st
 
               if (pfx.compare ("figure") || pfx.compare ("uimenu"))
                 offset = 6;
               else if (len > 7)
                 {
                   pfx = name.substr (0, 7);
 
                   if (pfx.compare ("surface") || pfx.compare ("hggroup")
-                      || pfx.compare ("uipanel"))
+                      || pfx.compare ("uipanel") || pfx.compare ("uitable"))
                     offset = 7;
                   else if (len > 9)
                     {
                       pfx = name.substr (0, 9);
 
                       if (pfx.compare ("uicontrol")
                           || pfx.compare ("uitoolbar"))
                         offset = 9;
@@ -10830,16 +10860,261 @@ uipanel::properties::get___fontsize_poin
   if (fontunits_is ("normalized") && parent_height <= 0)
     parent_height = get_boundingbox (false).elem (3);
 
   return convert_font_size (fontsz, get_fontunits (), "points", parent_height);
 }
 
 // ---------------------------------------------------------------------
 
+Matrix
+uitable::properties::get_boundingbox (bool,
+                                      const Matrix& parent_pix_size) const
+{
+  Matrix pos = get_position ().matrix_value ();
+  Matrix parent_size (parent_pix_size);
+
+  if (parent_size.isempty ())
+    {
+      graphics_object go = gh_manager::get_object (get_parent ());
+
+      parent_size =
+        go.get_properties ().get_boundingbox (true).extract_n (0, 2, 1, 2);
+    }
+
+  pos = convert_position (pos, get_units (), "pixels", parent_size);
+
+  pos(0)--;
+  pos(1)--;
+  pos(1) = parent_size(1) - pos(1) - pos(3);
+  return pos;
+}
+
+void
+uitable::properties::set_columnformat (const octave_value& val)
+{
+  /* Matlab only allows certain values for columnformat - here we will only
+     check the structure of the argument. Values will be checked in Table.cc */
+
+  if (val.iscellstr ())
+    {
+      if (columnformat.set (val, true))
+        {
+          mark_modified ();
+        }
+    }
+  else if (val.iscell ())
+    {
+      Cell cell_value = val.cell_value ();
+
+      for (int i = 0; i < cell_value.numel (); i++)
+        {
+          octave_value v = cell_value (i);
+          if (v.iscell ())
+            {
+              /* We are in a pop-up menu selection
+               * Matlab only allows non-empty strings here */
+              Cell popup = v.cell_value ();
+              for (int j = 0; j < popup.numel (); j++)
+                {
+                  octave_value p = popup (j);
+                  if (!p.is_string () || p.string_value ().length () == 0)
+                    {
+                      error ("set: pop-up menu definitions must be non-empty strings.");
+                    }
+                }
+            }
+          else if (!(v.is_string () || v.isempty ()))
+            {
+              error ("set: columnformat definintions must be a cellstr of "
+                "either 'char', 'short [e|g|eng]?', 'long [e|g|eng]?', "
+                "'numeric', 'bank', '+', 'rat', 'logical', or a cellstr of non-empty "
+                "pop-up menu definitions.");
+            }
+        }
+
+      if (columnformat.set (val, true))
+        {
+          mark_modified ();
+        }
+    }
+  else if (val.isempty ())
+    {
+      if (columnformat.set (Cell (), true))
+        {
+          mark_modified ();
+        }
+    }
+  else
+    {
+      error ("set: expecting cell of strings.");
+    }
+}
+
+void
+uitable::properties::set_columnwidth (const octave_value& val)
+{
+  bool error_exists = false;
+  if (val.is_string ()  && val.string_value (false) == "auto")
+    {
+      error_exists = false;
+    }
+  else if (val.iscell ())
+    {
+      Cell cell_value = val.cell_value ();
+      for (int i = 0; i < cell_value.numel (); i++)
+        {
+          octave_value v = cell_value (i);
+          if (v.is_string ())
+            {
+              if (v.string_value (false) != "auto")
+                error_exists = true;
+            }
+          else if (v.iscell ())
+            {
+              error_exists = true;
+            }
+          else if (!(v.is_scalar_type ()))
+            {
+              error_exists = true;
+            }
+        }
+    }
+  else
+    {
+      error_exists = true;
+    }
+
+  if (error_exists)
+    {
+      error ("set: expecting either 'auto' or a cell of pixel values or auto.");
+    }
+  else
+    {
+      if (columnwidth.set (val, true))
+        {
+          mark_modified ();
+        }
+    }
+}
+
+void
+uitable::properties::set_units (const octave_value& val)
+{
+  caseless_str old_units = get_units ();
+
+  if (units.set (val, true))
+    {
+      update_units (old_units);
+      mark_modified ();
+    }
+}
+
+void
+uitable::properties::update_units (const caseless_str& old_units)
+{
+  Matrix pos = get_position ().matrix_value ();
+
+  graphics_object parent_go = gh_manager::get_object (get_parent ());
+  Matrix parent_bbox = parent_go.get_properties ().get_boundingbox (true);
+  Matrix parent_size = parent_bbox.extract_n (0, 2, 1, 2);
+
+  pos = convert_position (pos, old_units, get_units (), parent_size);
+  set_position (pos);
+}
+
+void
+uitable::properties::set_fontunits (const octave_value& val)
+{
+  caseless_str old_fontunits = get_fontunits ();
+
+  if (fontunits.set (val, true))
+    {
+      update_fontunits (old_fontunits);
+      mark_modified ();
+    }
+}
+
+void
+uitable::properties::update_fontunits (const caseless_str& old_units)
+{
+  caseless_str new_units = get_fontunits ();
+  double parent_height = get_boundingbox (false).elem (3);
+  double fontsz = get_fontsize ();
+
+  fontsz = convert_font_size (fontsz, old_units, new_units, parent_height);
+
+  set_fontsize (octave_value (fontsz));
+}
+
+double
+uitable::properties::get___fontsize_points__ (double box_pix_height) const
+{
+  double fontsz = get_fontsize ();
+  double parent_height = box_pix_height;
+
+  if (fontunits_is ("normalized") && parent_height <= 0)
+    parent_height = get_boundingbox (false).elem (3);
+
+  return convert_font_size (fontsz, get_fontunits (), "points", parent_height);
+}
+
+double
+uitable::properties::get_fontsize_pixels (double box_pix_height) const
+{
+  double fontsz = get_fontsize ();
+  double parent_height = box_pix_height;
+
+  if (fontunits_is ("normalized") && parent_height <= 0)
+    parent_height = get_boundingbox (false).elem (3);
+
+  return convert_font_size (fontsz, get_fontunits (), "pixels", parent_height);
+}
+
+Matrix
+uitable::properties::get_backgroundcolor_rgb (void)
+{
+  Matrix bg = backgroundcolor.get ().matrix_value ();
+  return bg.row (0);
+}
+
+Matrix
+uitable::properties::get_alternatebackgroundcolor_rgb (void)
+{
+  int i = 0;
+  Matrix bg = backgroundcolor.get ().matrix_value ();
+  if (bg.rows () > 1)
+    i = 1;
+  return bg.row (i);
+}
+
+Matrix
+uitable::properties::get_extent_matrix (void) const
+{
+  return extent.get ().matrix_value ();
+}
+
+octave_value
+uitable::properties::get_extent (void) const
+{
+  // FIXME: Is it really acceptable to just let the toolkit update the extent?
+  Matrix m = extent.get ().matrix_value ();
+  graphics_object parent_go = gh_manager::get_object (get_parent ());
+  if (parent_go)
+    {
+      Matrix parent_bbox = parent_go.get_properties ().get_boundingbox (true);
+      Matrix parent_size = parent_bbox.extract_n (0, 2, 1, 2);
+
+      return convert_position (m, "pixels", get_units (), parent_size);
+    }
+  return m;
+}
+
+// ---------------------------------------------------------------------
+
 octave_value
 uitoolbar::get_default (const caseless_str& pname) const
 {
   octave_value retval = default_properties.lookup (pname);
 
   if (retval.is_undefined ())
     {
       graphics_handle parent_h = get_parent ();
@@ -12424,16 +12699,25 @@ DEFUN (__go_uicontextmenu__, args, ,
        doc: /* -*- texinfo -*-
 @deftypefn {} {} __go_uicontextmenu__ (@var{parent})
 Undocumented internal function.
 @end deftypefn */)
 {
   GO_BODY (uicontextmenu);
 }
 
+DEFUN (__go_uitable__, args, ,
+       doc: /* -*- texinfo -*-
+@deftypefn {} {} __go_uitable__ (@var{parent})
+Undocumented internal function.
+@end deftypefn */)
+{
+  GO_BODY (uitable);
+}
+
 DEFUN (__go_uitoolbar__, args, ,
        doc: /* -*- texinfo -*-
 @deftypefn {} {} __go_uitoolbar__ (@var{parent})
 Undocumented internal function.
 @end deftypefn */)
 {
   GO_BODY (uitoolbar);
 }
diff --git a/libinterp/corefcn/graphics.in.h b/libinterp/corefcn/graphics.in.h
--- a/libinterp/corefcn/graphics.in.h
+++ b/libinterp/corefcn/graphics.in.h
@@ -5734,16 +5734,115 @@ public:
     if (! retval)
       retval = base_properties::has_readonly_property (pname);
     return retval;
   }
 };
 
 // ---------------------------------------------------------------------
 
+class OCTINTERP_API uitable : public base_graphics_object
+{
+public:
+  class OCTINTERP_API properties : public base_properties
+  {
+  public:
+    Matrix get_boundingbox (bool internal = false,
+                            const Matrix& parent_pix_size = Matrix ()) const;
+
+    double get___fontsize_points__ (double box_pix_height = 0) const;
+
+    double get_fontsize_pixels (double box_pix_height = 0) const;
+
+    // See the genprops.awk script for an explanation of the
+    // properties declarations.
+    // Programming note: Keep property list sorted if new ones are added.
+
+    BEGIN_PROPERTIES (uitable)
+      any_property __object__ h , Matrix ()
+      array_property backgroundcolor , default_table_backgroundcolor ()
+      callback_property celleditcallback , Matrix ()
+      callback_property cellselectioncallback , Matrix ()
+      row_vector_property columneditable , Matrix ()
+      any_property columnformat S , Matrix ()
+      any_property columnname , "numbered"
+      any_property columnwidth S , "auto"
+      any_property data u , Matrix ()
+      radio_property enable , "{on}|inactive|off"
+      array_property extent rG , Matrix (1, 4, 0.0)
+      radio_property fontangle u , "{normal}|italic|oblique"
+      string_property fontname u , OCTAVE_DEFAULT_FONTNAME
+      double_property fontsize u , 10
+      radio_property fontunits S , "inches|centimeters|normalized|{points}|pixels"
+      radio_property fontweight u , "light|{normal}|demi|bold"
+      color_property foregroundcolor , color_values (0, 0, 0)
+      callback_property keypressfcn , Matrix ()
+      callback_property keyreleasefcn , Matrix ()
+      array_property position , default_table_position ()
+      bool_property rearrangeablecolumns , "off"
+      any_property rowname , "numbered"
+      bool_property rowstriping , "on"
+      string_property tooltipstring , ""
+      radio_property units S , "normalized|inches|centimeters|points|{pixels}|characters"
+    END_PROPERTIES
+
+    Matrix get_extent_matrix (void) const;
+
+    Matrix get_backgroundcolor_rgb (void);
+
+    Matrix get_alternatebackgroundcolor_rgb (void);
+
+  protected:
+    void init (void)
+    {
+      position.add_constraint (dim_vector (1, 4));
+      extent.add_constraint (dim_vector (1, 4));
+      backgroundcolor.add_constraint (dim_vector (-1, 3));
+      backgroundcolor.add_constraint ("double");
+      columneditable.add_constraint ("logical");
+    }
+
+    void update_units (const caseless_str& old_units);
+    void update_fontunits (const caseless_str& old_units);
+    void update_table_extent (void) { };
+    void update_data (void) { update_table_extent (); }
+    void update_fontname (void) { update_table_extent (); }
+    void update_fontsize (void) { update_table_extent (); }
+    void update_fontangle (void) { update_table_extent (); }
+    void update_fontweight (void) { update_table_extent (); }
+
+  };
+
+private:
+  properties xproperties;
+
+public:
+  uitable (const graphics_handle& mh, const graphics_handle& p)
+    : base_graphics_object (), xproperties (mh, p)
+  { }
+
+  ~uitable (void) { }
+
+  base_properties& get_properties (void) { return xproperties; }
+
+  const base_properties& get_properties (void) const { return xproperties; }
+
+  bool valid_object (void) const { return true; }
+
+  bool has_readonly_property (const caseless_str& pname) const
+  {
+    bool retval = xproperties.has_readonly_property (pname);
+    if (! retval)
+      retval = base_properties::has_readonly_property (pname);
+    return retval;
+  }
+};
+
+// ---------------------------------------------------------------------
+
 class OCTINTERP_API uitoolbar : public base_graphics_object
 {
 public:
   class OCTINTERP_API properties : public base_properties
   {
   public:
     // See the genprops.awk script for an explanation of the
     // properties declarations.
diff --git a/scripts/gui/module.mk b/scripts/gui/module.mk
--- a/scripts/gui/module.mk
+++ b/scripts/gui/module.mk
@@ -32,16 +32,17 @@ FCN_FILE_DIRS += \
   %reldir%/uicontrol.m \
   %reldir%/uigetdir.m \
   %reldir%/uigetfile.m \
   %reldir%/uimenu.m \
   %reldir%/uipanel.m \
   %reldir%/uipushtool.m \
   %reldir%/uiputfile.m \
   %reldir%/uiresume.m \
+  %reldir%/uitable.m \
   %reldir%/uitoggletool.m \
   %reldir%/uitoolbar.m \
   %reldir%/uiwait.m \
   %reldir%/waitbar.m \
   %reldir%/waitforbuttonpress.m \
   %reldir%/warndlg.m
 
 %canon_reldir%dir = $(fcnfiledir)/gui
diff --git a/scripts/gui/uitable.m b/scripts/gui/uitable.m
new file mode 100644
--- /dev/null
+++ b/scripts/gui/uitable.m
@@ -0,0 +1,300 @@
+## Copyright (C) 2016-2018 Andrew Thornton
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 3 of the License, or (at
+## your option) any later version.
+##
+## Octave is distributed in the hope that it will be useful, but
+## WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+## General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, see
+## <http://www.gnu.org/licenses/>.
+
+## -*- texinfo -*-
+## @deftypefn  {} {@var{hui} =} uitable (@var{property}, @var{value}, @dots{})
+## @deftypefnx {} {@var{hui} =} uitable (@var{parent}, "@var{property}", @var{value}, @dots{})
+## Create a uitable object and return a handle to it.
+##
+## uitables are used to show tables of data in a figure.
+##
+## If @var{parent} is omitted, a uitable for the current figure is created.  If
+## no figure is available, a new figure is created first.
+##
+## If @var{parent} is given, a uitable relative to @var{parent} is created.
+##
+## Any provided property value pairs will override the default values of the
+## created uitable object.
+##
+## Uitable properties are documented at @ref{Uitable Properties}.
+##
+## Examples:
+##
+## @example
+## @group
+## % create figure and table on it
+## f = figure;
+## m = magic(8);
+## t = uitable(f, 'Data', m, 'ColumnWidth', @{ 40 @});
+## @end group
+##
+## @group
+## % Create a named table
+## f = figure();
+## d = reshape(1:9, 3, []);
+## column_names = @{ 'Col1', 'Col2', 'Col3' @};
+## row_names = @{ 'Row1', 'Row2', 'Row3' @};
+## t = uitable(f, 'Data', d, ...
+##             'ColumnName', column_names, ...
+##             'RowName', row_names);
+##
+## p = get(t, 'Position');
+## e = get(t, 'Extent');
+## p(3:4) = e(3:4);
+## set(t, 'Position', p);
+## @end group
+##
+## @group
+## function uitable_demo ()
+##     f = figure ('Name', 'uitable Demo', 'Menu', 'none', 'Position', [10 10 1000 680]);
+##
+##     % A basic example
+##     d = @{ 'char', 'A string';
+##         'double', 12.3456789;
+##         'complex', 1+2i;
+##         'bool', true;
+##         'single', single(12.3456789);
+##         'int8', int8(-128);
+##         'uint8', uint8(128);
+##         'int16', int16(-32768);
+##         'uint16', uint16(32768);
+##         'int32', int32(-2147483648);
+##         'uint32', uint32(2147483648);
+##         'int64', int64(-2147483649);
+##         'uint64', uint64(2147843649)@};
+##
+##     popup_options = @{'A', 'B', 'C', 'D', 'E'@};
+##
+##     columnformat_options = @{ '[]', 'char', 'pop-up', 'numeric', 'short', 'short e', ...
+##                     'short eng', 'short g', 'long', 'long e', 'long eng', ...
+##                     'long g', 'bank', '+', 'rat', 'logical'@};
+##     columnformat_values = columnformat_options;
+##     columnformat_values@{1@} = '';
+##     columnformat_values@{3@} = popup_options;
+##
+##     %default_data = cell(size(d, 1), 10);
+##     default_data = repmat(d(:,2), 1, size(columnformat_options, 2));
+##     b_add = uicontrol(f, 'Position', [ 285 630 600 50], ...
+##               'UserData', [size(d,1) 1], ...
+##               'Style', 'pushbutton', ...
+##               'String', 'Set data at selected point to selected datatype');
+##
+##     l_type_table = uicontrol(f, 'Position', [ 0 603 120 25 ], ...
+##         'String', 'Datatype Table:', ...
+##         'Style', 'text');
+##     t_type_table = uitable(f, 'Position', [ 0 530 1000 70 ], ...
+##         'Data', transpose(d(:, 2)), ...
+##         'ColumnName', transpose(d(:, 1)), ...
+##         'RowName', 'Value', ...
+##         'CellSelectionCallback', @@(x, y) ...
+##             set(b_add, 'UserData', y.Indices ));
+##
+##     l_point_table = uicontrol(f, 'Position', [ 0 640 60 25 ], ...
+##         'String', 'Point:', ...
+##         'Style', 'text');
+##     t_point_table = uitable(f, 'Position', [ 80 630 160 42 ], ...
+##                            'RowName', [], ...
+##                            'ColumnName', @{'x', 'y'@}, ...
+##                            'Data', [ 1 1 ], ...
+##                            'ColumnEditable', true);
+##
+##     l_editable_table = uicontrol(f, 'Position', [ 0 502 200 25 ], ...
+##         'Style', 'text', ...
+##         'String', 'Set Data Columns Editable:');
+##     t_editable_table = uitable(f, 'Position', [ 0 434 1000 65 ], ...
+##                                'Data', repmat(false, 1, size(default_data, 2)), ...
+##                                'ColumnEditable', true);
+##
+##     l_format_table = uicontrol(f, 'Position', [ 0 406 200 25 ], ...
+##         'Style', 'text', ...
+##         'String', 'Set Data Column Format:');
+##     t_format_table = uitable(f, 'Position', [ 0 338 1000 65 ], ...
+##         'Data', columnformat_options, ...
+##         'ColumnEditable', true, ...
+##         'ColumnFormat', arrayfun(@@(x) @{columnformat_options@}, 1:size(columnformat_options, 2)));
+##
+##     l_data_table = uicontrol(f, 'Style', 'text', 'String', 'Data:', 'Position', [ 0 310 60 25]);
+##     t_data_table = uitable(f, 'Position', [ 0 15 1000 290 ], ...
+##         'Data', default_data, ...
+##         'ColumnFormat', columnformat_values);
+##
+##     set(t_format_table, 'CellEditCallback', ...
+##         @@(x, y) update_column_format(y.NewData, y.Indices, t_data_table, popup_options));
+##     set(t_point_table, 'CellEditCallback', ...
+##        @@(x, y) validate_point_table(x, y, t_data_table));
+##     set(t_editable_table, 'CellEditCallback', @@(x,y) set(t_data_table, ...
+##             'ColumnEditable', get(t_editable_table, 'Data')));
+##     set(b_add, 'Callback', @@(x, y) ...
+##             update_data(b_add, t_point_table, t_type_table, t_data_table));
+##     set(t_data_table, 'cellselectioncallback', @@(x, y) update_point_table(y.Indices, t_point_table));
+## end
+##
+## function validate_point_table(h, dat, t_data_table)
+##     if (~(dat.NewData > 0 && ...
+##         dat.NewData < size(get(t_data_table, 'Data'), dat.Indices(1, 1)) + 1))
+##
+##         d = get(h, 'Data');
+##         d(dat.Indices) = 1;
+##         set(h, 'Data', d);
+##     end
+## end
+##
+## function update_column_format(format, indices, t_data_table, popup_options)
+##     cf = get(t_data_table, 'ColumnFormat');
+##     if (strcmp(format, '[]'))
+##         format = '';
+##     elseif (strcmp(format, 'pop-up'))
+##         format = popup_options;
+##     end
+##     cf@{indices(1,2)@} = format;
+##     set(t_data_table, 'ColumnFormat', cf);
+## end
+##
+## function update_point_table(indices, t_point_table)
+##     if (size(indices, 1) == 0)
+##         indices = [1 1];
+##     end
+##     set(t_point_table, 'Data', indices(1,:));
+## end  % function
+##
+## function update_data (b_add, t_point_table, t_type_table, t_data_table)
+##     indices = get(b_add, 'UserData');
+##     if (size(indices, 1) == 0)
+##         indices = [1 1];
+##     end
+##     d = get(t_data_table, 'Data');
+##     t_type_table_data = get(t_type_table, 'Data');
+##     p = get(t_point_table, 'Data');
+##     d(p(1,2), p(1,1)) = t_type_table_data(indices(1,2));
+##     set(t_data_table, 'Data', d);
+## end
+## @end group
+## @end example
+##
+## @seealso{figure, uicontrol}
+## @end deftypefn
+
+## Author: Andrew Thornton
+
+function hui = uitable (varargin)
+    [h, args] = __uiobject_split_args__ ("uitable", varargin, ...
+                                         {"figure", "uipanel", "uibuttongroup"});
+    hui = __go_uitable__ (h, args{:});
+
+endfunction
+
+
+%!demo
+%!
+%! % create figure and table on it
+%! f = clf ();
+%! m = magic (8);
+%! t = uitable (f, "Data", m, "ColumnWidth", {50}, ...
+%!              "Units", "normalized", "Position", [0.1 0.1 0.8 0.8]);
+
+%!demo
+%! % create figure and table with editable
+%! f = clf ();
+%! m = magic (8);
+%! t = uitable (f, "Data", m, "ColumnWidth", {50}, "ColumnEditable", true, ...
+%!              "Units", "normalized", "Position", [0.1 0.1 0.8 0.8]);
+
+%!demo
+%! % create figure and table but change the format to rational_approx
+%! f = clf ();
+%! m = magic (8) / 64;
+%! t = uitable (f, "Data", m, "ColumnWidth", {50}, ...
+%!              "ColumnFormat", repmat ({"rat"}, 1, 8), ...
+%!              "Units", "normalized", "Position", [0.1 0.1 0.8 0.8]);
+
+%!demo
+%! cf = {"char", "char", {"A", "B", "C"}, "numeric", "short", "short e", ...
+%!      "short eng", "short g", "long", "long e", "long eng", "long g", ...
+%!      "bank", "+", "rat", "logical"};
+%! cn = cf;
+%! cn{1} = "type";
+%! cn{3} = "pop-up";
+%!
+%! d = {"double", 0.0000123456789;
+%!      "double", 0.000123456789;
+%!      "double", 0.00123456789;
+%!      "double", 0.0123456789;
+%!      "double", 0.123456789;
+%!      "double", 12;
+%!      "double", 1.23456789;
+%!      "double", 12.3456789;
+%!      "double", 123.456789;
+%!      "double", 1234.56789;
+%!      "complex", 0.0000123456789 + 12.3456789i;
+%!      "complex", 0.000123456789 + 12.3456789i;
+%!      "complex", 0.00123456789 + 12.3456789i;
+%!      "complex", 0.0123456789 + 12.3456789i;
+%!      "complex", 0.123456789 + 12.3456789i;
+%!      "complex", 1.23456789 + 12.3456789i;
+%!      "complex", 12.3456789 + 12.3456789i;
+%!      "complex", 123.456789 + 12.3456789i;
+%!      "complex", 1234.56789 + 12.3456789i;
+%!      "bool", true;
+%!      "bool", false;
+%!      "single", single(0.0000123456789);
+%!      "single", single(1.23456789);
+%!      "single", single(1234.56789);
+%!      "int8", int8(127);
+%!      "int8", int8(0);
+%!      "int8", int8(-126);
+%!      "int16", int16(32767);
+%!      "int16", int16(0);
+%!      "int16", int16(-32768);
+%!      "int32", int32(2147483647);
+%!      "int32", int32(0);
+%!      "int32", int32(-2147483647);
+%!      "int64", int64(9223372036854775807);
+%!      "int64", int64(0);
+%!      "int64", int64(-9223372036854775807);
+%!      "uint8", uint8(127);
+%!      "uint8", uint8(0);
+%!      "uint8", uint8(255);
+%!      "uint16", uint16(32767);
+%!      "uint16", uint16(0);
+%!      "uint16", uint16(65535);
+%!      "uint32", uint32(2147483647);
+%!      "uint32", uint32(0);
+%!      "uint32", uint32(4294967295);
+%!      "uint64", uint64(9223372036854775807);
+%!      "uint64", uint64(0);
+%!      "uint64", uint64(18446744073709551615);
+%!      "char", "a string"};
+%!
+%! ws = {"auto", 140};
+%! widths = cell (1, size (cf, 2));
+%! widths(1,1) = ws(1,1);
+%! widths(1,2:end) = repmat (ws(:, 2), 1, size (cf, 2) - 1);
+%!
+%! data = cell (size (d, 1), size (cf, 2));
+%!
+%! data(:,1) = d(:,1);
+%!
+%! data(:,2:end) = repmat(d(:,2), 1, size(cf, 2) - 1);
+%!
+%! t = uitable ("Data", data, ...
+%!              "ColumnFormat", cf, ...
+%!              "ColumnWidth", widths, ...
+%!              "Units", "Normalized", ...
+%!              "Position", [0 0 1 1], ...
+%!              "ColumnName", cn, ...
+%!              "ColumnEditable", true);
diff --git a/scripts/help/__unimplemented__.m b/scripts/help/__unimplemented__.m
--- a/scripts/help/__unimplemented__.m
+++ b/scripts/help/__unimplemented__.m
@@ -1299,17 +1299,16 @@ function rlist = missing_functions ()
   "uisetfont",
   "uisetpref",
   "uislider",
   "uispinner",
   "uistack",
   "uiswitch",
   "uitab",
   "uitabgroup",
-  "uitable",
   "uitextarea",
   "uitogglebutton",
   "uitree",
   "uitreenode",
   "undocheckout",
   "uniquetol",
   "unloadlibrary",
   "unmesh",
