# HG changeset patch
# User Rik <octave@nomad.inbox5.com>
# Date 1304265315 25200
#      Sun May 01 08:55:15 2011 -0700
# Branch stable
# Node ID 4d777e05d47c2a82879e5ad7f1d9ca8a5869741b
# Parent  d02798e9eeaec12825fd5b386756ea9195d69102
doc: Review and update documentation for "Matrix Manipulation" chapter.

* matrix.txi, arrayfun.m, blkdiag.m, fliplr.m, flipud.m, logspace.m,
postpad.m, prepad.m, randi.m, repmat.m, rot90.m, rotdim.m, shiftdim.m,
sortrows.m, vech.m, xor.m, hadamard.m, hankel.m, hilb.m, invhilb.m, magic.m,
pascal.m, rosser.m, sylvester_matrix.m, toeplitz.m, vander.m, wilkinson.m,
bsxfun.cc, find.cc, lookup.cc, rand.cc, tril.cc, data.cc, arrayfun.m,
blkdiag.m, fliplr.m, flipud.m, logspace.m, postpad.m, prepad.m, randi.m,
repmat.m, rot90.m, rotdim.m, shiftdim.m, sortrows.m, vech.m, xor.m, hadamard.m,
hankel.m, hilb.m, invhilb.m, magic.m, pascal.m, rosser.m, sylvester_matrix.m,
toeplitz.m, vander.m, wilkinson.m, bsxfun.cc (bsxfun), find.cc (find),
lookup.cc (lookup), rand.cc (rand, randn, rande, randg, randp),
tril.cc (triu), data.cc (all, any, horzcat, vertcat, cat, permute, ipermute,
ones, zeros, eye, linspace, resize, reshape, issorted, diff):
Improve docstrings

diff --git a/doc/interpreter/matrix.txi b/doc/interpreter/matrix.txi
--- a/doc/interpreter/matrix.txi
+++ b/doc/interpreter/matrix.txi
@@ -70,21 +70,21 @@ Note that in conditional contexts (like 
 @DOCSTRING(diff)
 
 @DOCSTRING(isinf)
 
 @DOCSTRING(isnan)
 
 @DOCSTRING(isfinite)
 
+@DOCSTRING(common_size)
+
 @DOCSTRING(find)
         
 @DOCSTRING(lookup)
-        
-@DOCSTRING(common_size)
 
 @node Rearranging Matrices
 @section Rearranging Matrices
 
 @DOCSTRING(fliplr)
 
 @DOCSTRING(flipud)
 
@@ -105,47 +105,26 @@ Note that in conditional contexts (like 
 @DOCSTRING(ipermute)
 
 @DOCSTRING(reshape)
 
 @DOCSTRING(resize)
 
 @DOCSTRING(circshift)
 
-@DOCSTRING(shiftdim)
+@DOCSTRING(shift)
 
-@DOCSTRING(shift)
+@DOCSTRING(shiftdim)
 
 @DOCSTRING(sort)
 
 @DOCSTRING(sortrows)
 
 @DOCSTRING(issorted)
 
-Since the @code{sort} function does not allow sort keys to be specified,
-it can't be used to order the rows of a matrix according to the values
-of the elements in various columns@footnote{For example, to first sort
-based on the values in column 1, and then, for any values that are
-repeated in column 1, sort based on the values found in column 2, etc.}
-in a single call.  Using the second output, however, it is possible to
-sort all rows based on the values in a given column.  Here's an example
-that sorts the rows of a matrix based on the values in the second
-column.
-
-@example
-@group
-a = [1, 2; 2, 3; 3, 1];
-[s, i] = sort (a (:, 2));
-a (i, :)
-     @result{}  3  1
-         1  2
-         2  3
-@end group
-@end example
-
 @DOCSTRING(nth_element)
 
 @anchor{doc-triu}
 @DOCSTRING(tril)
 
 @DOCSTRING(vec)
 
 @DOCSTRING(vech)
@@ -173,16 +152,24 @@ a (i, :)
 @DOCSTRING(ones)
 
 @DOCSTRING(zeros)
 
 @DOCSTRING(repmat)
 
 @DOCSTRING(repelems)
 
+The functions @code{linspace} and @code{logspace} make it very easy to
+create vectors with evenly or logarithmically spaced elements.
+@xref{Ranges}.
+
+@DOCSTRING(linspace)
+
+@DOCSTRING(logspace)
+
 @DOCSTRING(rand)
 
 @DOCSTRING(randi)
 
 @DOCSTRING(randn)
 
 @DOCSTRING(rande)
 
@@ -243,24 +230,16 @@ single element of a random sequence.
 The original @code{rand} and @code{randn} functions use Fortran code from
 @sc{ranlib}, a library of Fortran routines for random number generation,
 compiled by Barry W. Brown and James Lovato of the Department of
 Biomathematics at The University of Texas, M.D. Anderson Cancer Center,
 Houston, TX 77030.
 
 @DOCSTRING(randperm)
 
-The functions @code{linspace} and @code{logspace} make it very easy to
-create vectors with evenly or logarithmically spaced elements.
-@xref{Ranges}.
-
-@DOCSTRING(linspace)
-
-@DOCSTRING(logspace)
-
 @node Famous Matrices
 @section Famous Matrices
 
 The following functions return famous matrix forms.
 
 @DOCSTRING(hadamard)
 
 @DOCSTRING(hankel)
diff --git a/scripts/general/arrayfun.m b/scripts/general/arrayfun.m
--- a/scripts/general/arrayfun.m
+++ b/scripts/general/arrayfun.m
@@ -25,19 +25,19 @@
 ## @deftypefnx {Function File} {} arrayfun (@dots{}, "UniformOutput", @var{val})
 ## @deftypefnx {Function File} {} arrayfun (@dots{}, "ErrorHandler", @var{errfunc})
 ##
 ## Execute a function on each element of an array.  This is useful for
 ## functions that do not accept array arguments.  If the function does
 ## accept array arguments it is better to call the function directly.
 ##
 ## The first input argument @var{func} can be a string, a function
-## handle, an inline function or an anonymous function.  The input
+## handle, an inline function, or an anonymous function.  The input
 ## argument @var{A} can be a logic array, a numeric array, a string
-## array, a structure array or a cell array.  By a call of the function
+## array, a structure array, or a cell array.  By a call of the function
 ## @command{arrayfun} all elements of @var{A} are passed on to the named
 ## function @var{func} individually.
 ##
 ## The named function can also take more than two input arguments, with
 ## the input arguments given as third input argument @var{b}, fourth
 ## input argument @var{c}, @dots{}  If given more than one array input
 ## argument then all input arguments must have the same sizes, for
 ## example:
@@ -91,29 +91,29 @@
 ##   [1,1] =  10
 ##   [2,1] = [](0x0)
 ## @}
 ## @end group
 ## @end example
 ##
 ## If the parameter @var{errfunc} after a further string input argument
 ## "ErrorHandler" is another string, a function handle, an inline
-## function or an anonymous function, then @var{errfunc} defines a
+## function, or an anonymous function, then @var{errfunc} defines a
 ## function to call in the case that @var{func} generates an error.
 ## The definition of the function must be of the form
 ##
 ## @example
 ## function [@dots{}] = errfunc (@var{s}, @dots{})
 ## @end example
 ##
 ## @noindent
 ## where there is an additional input argument to @var{errfunc}
 ## relative to @var{func}, given by @var{s}.  This is a structure with
-## the elements "identifier", "message" and "index", giving
-## respectively the error identifier, the error message and the index of
+## the elements "identifier", "message", and "index" giving,
+## respectively, the error identifier, the error message, and the index of
 ## the array elements that caused the error.  The size of the output
 ## argument of @var{errfunc} must have the same size as the output
 ## argument of @var{func}, otherwise a real error is thrown.  For
 ## example:
 ##
 ## @example
 ## @group
 ## function y = ferr (s, x), y = "MyString"; endfunction
diff --git a/scripts/general/blkdiag.m b/scripts/general/blkdiag.m
--- a/scripts/general/blkdiag.m
+++ b/scripts/general/blkdiag.m
@@ -13,17 +13,17 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} blkdiag (@var{A}, @var{B}, @var{C}, @dots{})
-## Build a block diagonal matrix from @var{A}, @var{B}, @var{C}, @dots{}.
+## Build a block diagonal matrix from @var{A}, @var{B}, @var{C}, @dots{}
 ## All the arguments must be numeric and are two-dimensional matrices or
 ## scalars.
 ## @seealso{diag, horzcat, vertcat}
 ## @end deftypefn
 
 ## Author: Daniel Calvelo
 ## Modified by: William Poetra Yoga Hadisoeseno
 
diff --git a/scripts/general/fliplr.m b/scripts/general/fliplr.m
--- a/scripts/general/fliplr.m
+++ b/scripts/general/fliplr.m
@@ -13,28 +13,29 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} fliplr (@var{x})
-## Return a copy of @var{x} with the order of the columns reversed.  For
+## Return a copy of @var{x} with the order of the columns reversed.  In
+## other words, @var{x} is flipped left-to-right about a vertical axis.  For
 ## example:
 ##
 ## @example
 ## @group
 ## fliplr ([1, 2; 3, 4])
 ##      @result{}  2  1
 ##          4  3
 ## @end group
 ## @end example
 ##
-## Note that @code{fliplr} only work with 2-D arrays.  To flip N-d arrays
+## Note that @code{fliplr} only works with 2-D arrays.  To flip N-D arrays
 ## use @code{flipdim} instead.
 ## @seealso{flipud, flipdim, rot90, rotdim}
 ## @end deftypefn
 
 ## Author: jwe
 
 function y = fliplr (x)
 
diff --git a/scripts/general/flipud.m b/scripts/general/flipud.m
--- a/scripts/general/flipud.m
+++ b/scripts/general/flipud.m
@@ -13,29 +13,29 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} flipud (@var{x})
-## Return a copy of @var{x} with the order of the rows reversed.  For
+## Return a copy of @var{x} with the order of the rows reversed.  In
+## other words, @var{x} is flipped upside-down about a horizontal axis.  For
 ## example:
 ##
 ## @example
 ## @group
 ## flipud ([1, 2; 3, 4])
 ##      @result{}  3  4
 ##          1  2
 ## @end group
 ## @end example
 ##
-## Due to the difficulty of defining which axis about which to flip the
-## matrix @code{flipud} only work with 2-d arrays.  To flip N-d arrays
+## Note that @code{flipud} only works with 2-D arrays.  To flip N-D arrays
 ## use @code{flipdim} instead.
 ## @seealso{fliplr, flipdim, rot90, rotdim}
 ## @end deftypefn
 
 ## Author: jwe
 
 function y = flipud (x)
 
diff --git a/scripts/general/logspace.m b/scripts/general/logspace.m
--- a/scripts/general/logspace.m
+++ b/scripts/general/logspace.m
@@ -12,54 +12,53 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {} logspace (@var{base}, @var{limit})
-## @deftypefnx {Function File} {} logspace (@var{base}, @var{limit}, @var{n})
-## Similar to @code{linspace} except that the values are logarithmically
-## spaced from
+## @deftypefn  {Function File} {} logspace (@var{a}, @var{b})
+## @deftypefnx {Function File} {} logspace (@var{b}, @var{b}, @var{n})
+## @deftypefnx {Function File} {} logspace (@var{a}, pi, @var{n})
+## Return a row vector with @var{n} elements logarithmically spaced from
 ## @tex
-## $10^{base}$ to $10^{limit}$.
+## $10^{a}$ to $10^{b}$.
 ## @end tex
 ## @ifnottex
-## 10^base to 10^limit.
+## 10^@var{a} to 10^@var{b}.
 ## @end ifnottex
+## If @var{n} is unspecified it defaults to 50.
 ##
-## If @var{limit} is equal to
+## If @var{b} is equal to
 ## @tex
 ## $\pi$,
 ## @end tex
 ## @ifnottex
 ## pi,
 ## @end ifnottex
 ## the points are between
 ## @tex
-## $10^{base}$ and $\pi$,
+## $10^{a}$ and $\pi$,
 ## @end tex
 ## @ifnottex
-## 10^base and pi,
+## 10^@var{a} and pi,
 ## @end ifnottex
 ## @emph{not}
 ## @tex
-## $10^{base}$ and $10^{\pi}$,
+## $10^{a}$ and $10^{\pi}$,
 ## @end tex
 ## @ifnottex
-## 10^base and 10^pi,
+## 10^@var{a} and 10^pi,
 ## @end ifnottex
-## in order to be compatible with the corresponding @sc{matlab}
-## function.
-## If @var{n} is unspecified it defaults to 50.
+## in order to be compatible with the corresponding @sc{matlab} function.
 ##
-## Also for compatibility with @sc{matlab}, return the second argument if
-## fewer than two values are requested.
+## Also for compatibility with @sc{matlab}, return the second argument @var{b}
+## if fewer than two values are requested.
 ## @seealso{linspace}
 ## @end deftypefn
 
 ## Author: jwe
 
 function retval = logspace (base, limit, n)
 
   if (nargin == 2)
diff --git a/scripts/general/postpad.m b/scripts/general/postpad.m
--- a/scripts/general/postpad.m
+++ b/scripts/general/postpad.m
@@ -15,19 +15,18 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} postpad (@var{x}, @var{l})
 ## @deftypefnx {Function File} {} postpad (@var{x}, @var{l}, @var{c})
 ## @deftypefnx {Function File} {} postpad (@var{x}, @var{l}, @var{c}, @var{dim})
-## Append the scalar value @var{c} to the vector @var{x}
-## until it is of length @var{l}.  If the third argument is not
-## supplied, a value of 0 is used.
+## Append the scalar value @var{c} to the vector @var{x} until it is of length
+## @var{l}.  If @var{c} is not given, a value of 0 is used.
 ##
 ## If @code{length (@var{x}) > @var{l}}, elements from the end of
 ## @var{x} are removed until a vector of length @var{l} is obtained.
 ##
 ## If @var{x} is a matrix, elements are appended or removed from each row.
 ##
 ## If the optional argument @var{dim} is given, operate along this
 ## dimension.
diff --git a/scripts/general/prepad.m b/scripts/general/prepad.m
--- a/scripts/general/prepad.m
+++ b/scripts/general/prepad.m
@@ -15,19 +15,18 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} prepad (@var{x}, @var{l})
 ## @deftypefnx {Function File} {} prepad (@var{x}, @var{l}, @var{c})
 ## @deftypefnx {Function File} {} prepad (@var{x}, @var{l}, @var{c}, @var{dim})
-## Prepend the scalar value @var{c} to the vector @var{x}
-## until it is of length @var{l}.  If the third argument is not
-## supplied, a value of 0 is used.
+## Prepend the scalar value @var{c} to the vector @var{x} until it is of length
+## @var{l}.  If @var{c} is not given, a value of 0 is used.
 ##
 ## If @code{length (@var{x}) > @var{l}}, elements from the beginning of
 ## @var{x} are removed until a vector of length @var{l} is obtained.
 ##
 ## If @var{x} is a matrix, elements are prepended or removed from each row.
 ##
 ## If the optional argument @var{dim} is given, operate along this
 ## dimension.
diff --git a/scripts/general/randi.m b/scripts/general/randi.m
--- a/scripts/general/randi.m
+++ b/scripts/general/randi.m
@@ -15,17 +15,17 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} randi (@var{imax})
 ## @deftypefnx {Function File} {} randi (@var{imax}, @var{n})
 ## @deftypefnx {Function File} {} randi (@var{imax}, @var{m}, @var{n}, @dots{})
-## @deftypefnx {Function File} {} randi ([@var{imin}, @var{imax}], @dots{})
+## @deftypefnx {Function File} {} randi ([@var{imin} @var{imax}], @dots{})
 ## @deftypefnx {Function File} {} randi (@dots{}, "@var{class}")
 ## Return random integers in the range 1:@var{imax}.
 ##
 ## Additional arguments determine the shape of the return matrix.  When no
 ## arguments are specified a single random integer is returned.  If one
 ## argument @var{n} is specified then a square matrix @w{(@var{n} x @var{n})} is
 ## returned.  Two or more arguments will return a multi-dimensional
 ## matrix @w{(@var{m} x @var{n} x @dots{})}.
@@ -42,17 +42,17 @@
 ## @example
 ## ri = randi (10, 150, 1);
 ## @end example
 ##
 ## Implementation Note: @code{randi} relies internally on @code{rand} which
 ## uses class "double" to represent numbers.  This limits the maximum
 ## integer (@var{imax}) and range (@var{imax} - @var{imin}) to the value
 ## returned by the @code{bitmax} function.  For IEEE floating point numbers
-## this value is @w{@code{2^53 - 1}}.
+## this value is @w{@math{2^{53} - 1}}.
 ##
 ## @seealso{rand}
 ## @end deftypefn
 
 ## Author: Rik Wehbring
 
 function ri = randi (bounds, varargin)
 
diff --git a/scripts/general/repmat.m b/scripts/general/repmat.m
--- a/scripts/general/repmat.m
+++ b/scripts/general/repmat.m
@@ -13,17 +13,19 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {} repmat (@var{A}, @var{m}, @var{n})
+## @deftypefn  {Function File} {} repmat (@var{A}, @var{m})
+## @deftypefnx {Function File} {} repmat (@var{A}, @var{m}, @var{n})
+## @deftypefnx {Function File} {} repmat (@var{A}, @var{m}, @var{n}, @var{p}, @dots{})
 ## @deftypefnx {Function File} {} repmat (@var{A}, [@var{m} @var{n}])
 ## @deftypefnx {Function File} {} repmat (@var{A}, [@var{m} @var{n} @var{p} @dots{}])
 ## Form a block matrix of size @var{m} by @var{n}, with a copy of matrix
 ## @var{A} as each element.  If @var{n} is not specified, form an
 ## @var{m} by @var{m} block matrix.
 ## @seealso{repelems}
 ## @end deftypefn
 
diff --git a/scripts/general/rot90.m b/scripts/general/rot90.m
--- a/scripts/general/rot90.m
+++ b/scripts/general/rot90.m
@@ -12,17 +12,18 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} rot90 (@var{A}, @var{k})
+## @deftypefn  {Function File} {} rot90 (@var{A})
+## @deftypefnx {Function File} {} rot90 (@var{A}, @var{k})
 ## Return a copy of @var{A} with the elements rotated counterclockwise in
 ## 90-degree increments.  The second argument is optional, and specifies
 ## how many 90-degree rotations are to be applied (the default value is 1).
 ## Negative values of @var{k} rotate the matrix in a clockwise direction.
 ## For example,
 ##
 ## @example
 ## @group
@@ -39,18 +40,17 @@
 ## @example
 ## @group
 ## rot90 ([1, 2; 3, 4], -1)
 ## rot90 ([1, 2; 3, 4], 3)
 ## rot90 ([1, 2; 3, 4], 7)
 ## @end group
 ## @end example
 ##
-## Due to the difficulty of defining an axis about which to rotate the
-## matrix @code{rot90} only work with 2-D arrays.  To rotate N-d arrays
+## Note that @code{rot90} only works with 2-D arrays.  To rotate N-D arrays
 ## use @code{rotdim} instead.
 ## @seealso{rotdim, flipud, fliplr, flipdim}
 ## @end deftypefn
 
 ## Author: jwe
 
 function B = rot90 (A, k)
 
diff --git a/scripts/general/rotdim.m b/scripts/general/rotdim.m
--- a/scripts/general/rotdim.m
+++ b/scripts/general/rotdim.m
@@ -12,24 +12,27 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} rotdim (@var{x}, @var{n}, @var{plane})
+## @deftypefn  {Function File} {} rotdim (@var{x})
+## @deftypefnx {Function File} {} rotdim (@var{x}, @var{n})
+## @deftypefnx {Function File} {} rotdim (@var{x}, @var{n}, @var{plane})
 ## Return a copy of @var{x} with the elements rotated counterclockwise in
-## 90-degree increments.  The second argument is optional, and specifies
-## how many 90-degree rotations are to be applied (the default value is 1).
+## 90-degree increments.
+## The second argument @var{n} is optional, and specifies how many 90-degree
+## rotations are to be applied (the default value is 1).
 ## The third argument is also optional and defines the plane of the
-## rotation.  As such @var{plane} is a two element vector containing two
-## different valid dimensions of the matrix.  If @var{plane} is not given
-## Then the first two non-singleton dimensions are used.
+## rotation.  If present, @var{plane} is a two element vector containing two
+## different valid dimensions of the matrix.  When @var{plane} is not given
+## the first two non-singleton dimensions are used.
 ##
 ## Negative values of @var{n} rotate the matrix in a clockwise direction.
 ## For example,
 ##
 ## @example
 ## @group
 ## rotdim ([1, 2; 3, 4], -1, [1, 2])
 ##      @result{}  3  1
diff --git a/scripts/general/shiftdim.m b/scripts/general/shiftdim.m
--- a/scripts/general/shiftdim.m
+++ b/scripts/general/shiftdim.m
@@ -14,17 +14,17 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{y} =} shiftdim (@var{x}, @var{n})
 ## @deftypefnx {Function File} {[@var{y}, @var{ns}] =} shiftdim (@var{x})
-## Shift the dimension of @var{x} by @var{n}, where @var{n} must be
+## Shift the dimensions of @var{x} by @var{n}, where @var{n} must be
 ## an integer scalar.  When @var{n} is positive, the dimensions of
 ## @var{x} are shifted to the left, with the leading dimensions
 ## circulated to the end.  If @var{n} is negative, then the dimensions
 ## of @var{x} are shifted to the right, with @var{n} leading singleton
 ## dimensions added.
 ##
 ## Called with a single argument, @code{shiftdim}, removes the leading
 ## singleton dimensions, returning the number of dimensions removed
diff --git a/scripts/general/sortrows.m b/scripts/general/sortrows.m
--- a/scripts/general/sortrows.m
+++ b/scripts/general/sortrows.m
@@ -13,17 +13,18 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} sortrows (@var{A}, @var{c})
+## @deftypefn  {Function File} {[@var{s}, @var{i}] =} sortrows (@var{A})
+## @deftypefnx {Function File} {[@var{s}, @var{i}] =} sortrows (@var{A}, @var{c})
 ## Sort the rows of the matrix @var{A} according to the order of the
 ## columns specified in @var{c}.  If @var{c} is omitted, a
 ## lexicographical sort is used.  By default ascending order is used
 ## however if elements of @var{c} are negative then the corresponding
 ## column is sorted in descending order.
 ## @end deftypefn
 
 ## Author: Daniel Calvelo, Paul Kienzle
diff --git a/scripts/linear-algebra/vech.m b/scripts/linear-algebra/vech.m
--- a/scripts/linear-algebra/vech.m
+++ b/scripts/linear-algebra/vech.m
@@ -16,17 +16,20 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} vech (@var{x})
 ## Return the vector obtained by eliminating all supradiagonal elements of
 ## the square matrix @var{x} and stacking the result one column above the
-## other.
+## other.  This has uses in matrix calculus where the underlying matrix
+## is symmetric and it would be pointless to keep values above the main
+## diagonal.
+## @seealso{vec}
 ## @end deftypefn
 
 ## See Magnus and Neudecker (1988), Matrix differential calculus with
 ## applications in statistics and econometrics.
 
 ## Author KH <Kurt.Hornik@wu-wien.ac.at>
 ## Created: 8 May 1995
 ## Adapted-By: jwe
diff --git a/scripts/miscellaneous/xor.m b/scripts/miscellaneous/xor.m
--- a/scripts/miscellaneous/xor.m
+++ b/scripts/miscellaneous/xor.m
@@ -12,21 +12,34 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Mapping Function} {} xor (@var{x}, @var{y})
+## @deftypefn {Mapping Function} {@var{z} =} xor (@var{x}, @var{y})
 ## Return the `exclusive or' of the entries of @var{x} and @var{y}.
 ## For boolean expressions @var{x} and @var{y},
-## @code{xor (@var{x}, @var{y})} is true if and only if @var{x} or @var{y}
-## is true, but not if both @var{x} and @var{y} are true.
+## @code{xor (@var{x}, @var{y})} is true if and only if one of @var{x} or
+## @var{y} is true.  Otherwise, for @var{x} and @var{y} both true or both
+## false, @code{xor} returns false.
+##
+## The truth table for the xor operation is
+##
+## @multitable @columnfractions 0.44 .03 .05 .03 0.44
+## @item @tab @var{x} @tab @var{y} @tab @var{z} @tab
+## @item @tab 0 @tab 0 @tab 0 @tab
+## @item @tab 1 @tab 0 @tab 1 @tab
+## @item @tab 0 @tab 1 @tab 1 @tab
+## @item @tab 1 @tab 1 @tab 0 @tab
+## @end multitable
+##
+## @seealso{and, or, not}
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Created: 16 September 1994
 ## Adapted-By: jwe
 
 function z = xor (x, y)
 
diff --git a/scripts/special-matrix/hadamard.m b/scripts/special-matrix/hadamard.m
--- a/scripts/special-matrix/hadamard.m
+++ b/scripts/special-matrix/hadamard.m
@@ -16,42 +16,42 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 ##
 ## Original version by Paul Kienzle distributed as free software in the
 ## public domain.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} hadamard (@var{n})
-## Construct a Hadamard matrix @var{Hn} of size @var{n}-by-@var{n}.  The
-## size @var{n} must be of the form @code{2 ^ @var{k} * @var{p}} in which
-## @var{p} is one of 1, 12, 20 or 28.  The returned matrix is normalized,
-## meaning @code{Hn(:,1) == 1} and @code{Hn(1,:) == 1}.
+## Construct a Hadamard matrix (@nospell{Hn}) of size @var{n}-by-@var{n}.  The
+## size @var{n} must be of the form @math{2^k * p} in which
+## p is one of 1, 12, 20 or 28.  The returned matrix is normalized,
+## meaning @w{@code{Hn(:,1) == 1}} and @w{@code{Hn(1,:) == 1}}.
 ##
 ## Some of the properties of Hadamard matrices are:
 ##
 ## @itemize @bullet
 ## @item
-## @code{kron (@var{Hm}, @var{Hn})} is a Hadamard matrix of size
-## @var{m}-by-@var{n}.
+## @code{kron (Hm, Hn)} is a Hadamard matrix of size @var{m}-by-@var{n}.
 ##
 ## @item
-## @code{Hn * Hn' == @var{n} * eye (@var{n})}.
+## @code{Hn * Hn' = @var{n} * eye (@var{n})}.
+##
+## @item
+## The rows of @nospell{Hn} are orthogonal.
 ##
 ## @item
-## The rows of @var{Hn} are orthogonal.
+## @code{det (@var{A}) <= abs (det (Hn))} for all @var{A} with
+## @w{@code{abs (@var{A}(i, j)) <= 1}}.
 ##
 ## @item
-## @code{det (@var{A}) <= abs(det (@var{Hn}))} for all @var{A} with
-## @code{abs (@var{A} (@var{i}, @var{j})) <= 1}.
-##
-## @item
-## Multiply any row or column by -1 and still have a Hadamard matrix.
+## Multiplying any row or column by -1 and the matrix will remain a Hadamard
+## matrix.
 ## @end itemize
-##
+## @seealso{compan, hankel, toeplitz}
 ## @end deftypefn
 
 
 ## Reference [1] contains a list of Hadamard matrices up to n=256.
 ## See code for h28 in hadamard.m for an example of how to extend
 ## this function for additional p.
 ##
 ## References:
diff --git a/scripts/special-matrix/hankel.m b/scripts/special-matrix/hankel.m
--- a/scripts/special-matrix/hankel.m
+++ b/scripts/special-matrix/hankel.m
@@ -14,17 +14,17 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} hankel (@var{c})
 ## @deftypefnx {Function File} {} hankel (@var{c}, @var{r})
-## Return the Hankel matrix constructed given the first column @var{c}, and
+## Return the Hankel matrix constructed from the first column @var{c}, and
 ## (optionally) the last row @var{r}.  If the last element of @var{c} is
 ## not the same as the first element of @var{r}, the last element of
 ## @var{c} is used.  If the second argument is omitted, it is assumed to
 ## be a vector of zeros with the same size as @var{c}.
 ##
 ## A Hankel matrix formed from an m-vector @var{c}, and an n-vector
 ## @var{r}, has the elements
 ## @tex
@@ -37,17 +37,17 @@
 ## @example
 ## @group
 ## H(i,j) = c(i+j-1),  i+j-1 <= m;
 ## H(i,j) = r(i+j-m),  otherwise
 ## @end group
 ## @end example
 ##
 ## @end ifnottex
-## @seealso{vander, sylvester_matrix, hilb, invhilb, toeplitz}
+## @seealso{hadamard, toeplitz}
 ## @end deftypefn
 
 ## Author: jwe
 
 function retval = hankel (c, r)
 
   if (nargin == 1)
     r = resize (resize (c, 0), size(c));
diff --git a/scripts/special-matrix/hilb.m b/scripts/special-matrix/hilb.m
--- a/scripts/special-matrix/hilb.m
+++ b/scripts/special-matrix/hilb.m
@@ -13,37 +13,46 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} hilb (@var{n})
-## Return the Hilbert matrix of order @var{n}.  The
-## @tex
-## $i,\,j$
-## @end tex
-## @ifnottex
-## i, j
-## @end ifnottex
-## element of a Hilbert matrix is defined as
+## Return the Hilbert matrix of order @var{n}.  The @math{i,j} element
+## of a Hilbert matrix is defined as
 ## @tex
 ## $$
 ## H (i, j) = {1 \over (i + j - 1)}
 ## $$
 ## @end tex
 ## @ifnottex
 ##
 ## @example
 ## H (i, j) = 1 / (i + j - 1)
 ## @end example
 ##
 ## @end ifnottex
-## @seealso{hankel, vander, sylvester_matrix, invhilb, toeplitz}
+##
+## Hilbert matrices are close to being singular which make them difficult to
+## invert with numerical routines.
+## Comparing the condition number of a random matrix 5x5 matrix with that of
+## a Hilbert matrix of order 5 reveals just how difficult the problem is.
+##
+## @example
+## @group
+## cond (rand (5))
+##     @result{} 14.392
+## cond (hilb (5))
+##     @result{} 4.7661e+05
+## @end group
+## @end example
+##
+## @seealso{invhilb}
 ## @end deftypefn
 
 ## Author: jwe
 
 function retval = hilb (n)
 
 
   if (nargin != 1)
diff --git a/scripts/special-matrix/invhilb.m b/scripts/special-matrix/invhilb.m
--- a/scripts/special-matrix/invhilb.m
+++ b/scripts/special-matrix/invhilb.m
@@ -63,17 +63,17 @@
 ## The validity of this formula can easily be checked by expanding
 ## the binomial coefficients in both formulas as factorials.  It can
 ## be derived more directly via the theory of Cauchy matrices.
 ## See J. W. Demmel, @cite{Applied Numerical Linear Algebra}, p. 92.
 ##
 ## Compare this with the numerical calculation of @code{inverse (hilb (n))},
 ## which suffers from the ill-conditioning of the Hilbert matrix, and the
 ## finite precision of your computer's floating point arithmetic.
-## @seealso{hilb, hankel, vander, sylvester_matrix, toeplitz}
+## @seealso{hilb}
 ## @end deftypefn
 
 ## Author: Dirk Laurie <dlaurie@na-net.ornl.gov>
 
 function retval = invhilb (n)
 
   if (nargin != 1)
     print_usage ();
diff --git a/scripts/special-matrix/magic.m b/scripts/special-matrix/magic.m
--- a/scripts/special-matrix/magic.m
+++ b/scripts/special-matrix/magic.m
@@ -14,19 +14,21 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} magic (@var{n})
 ##
-## Create an @var{n}-by-@var{n} magic square.  Note that @code{magic
-## (@var{2})} is undefined since there is no 2-by-2 magic square.
+## Create an @var{n}-by-@var{n} magic square.  A magic square is an arrangement
+## of the integers @code{1:n^2} such that the row sums, column sums, and
+## diagonal sums are all equal to the same value.
 ##
+## Note: @var{n} must be greater than 2 for the magic square to exist.
 ## @end deftypefn
 
 function A = magic(n)
 
   if (nargin != 1)
     print_usage ();
   endif
 
diff --git a/scripts/special-matrix/pascal.m b/scripts/special-matrix/pascal.m
--- a/scripts/special-matrix/pascal.m
+++ b/scripts/special-matrix/pascal.m
@@ -15,29 +15,27 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} pascal (@var{n})
 ## @deftypefnx {Function File} {} pascal (@var{n}, @var{t})
-## Return the Pascal matrix of order @var{n} if @code{@var{t} = 0}.
-## @var{t} defaults to 0.  Return the pseudo-lower triangular 
-## Cholesky@tie{}factor of the Pascal matrix if @code{@var{t} = 1} (The sign
-## of some columns may be negative).  This matrix is its own
-## inverse, that is @code{pascal (@var{n}, 1) ^ 2 == eye (@var{n})}.
-## If @code{@var{t} = -1}, return the true Cholesky@tie{}factor with strictly
-## positive values on the diagonal.  
-## If @code{@var{t} = 2}, return a transposed and permuted version of
-## @code{pascal (@var{n}, 1)}, which is the cube root of the identity
-## matrix.  That is, @code{pascal (@var{n}, 2) ^ 3 == eye (@var{n})}.
+## Return the Pascal matrix of order @var{n} if @code{@var{t} = 0}.  @var{t}
+## defaults to 0.  Return the pseudo-lower triangular Cholesky@tie{}factor of
+## the Pascal matrix if @code{@var{t} = 1} (The sign of some columns may be
+## negative).  This matrix is its own inverse, that is @code{pascal (@var{n},
+## 1) ^ 2 == eye (@var{n})}.  If @code{@var{t} = -1}, return the true
+## Cholesky@tie{}factor with strictly positive values on the diagonal.  If
+## @code{@var{t} = 2}, return a transposed and permuted version of @code{pascal
+## (@var{n}, 1)}, which is the cube root of the identity matrix.  That is,
+## @code{pascal (@var{n}, 2) ^ 3 == eye (@var{n})}.
 ##
-## @seealso{hankel, vander, sylvester_matrix, hilb, invhilb, toeplitz,
-##          hadamard, wilkinson, compan, rosser}
+## @seealso{chol}
 ## @end deftypefn
 
 ## Author: Peter Ekberg
 ##         (peda)
 
 function retval = pascal (n, t)
 
   if (nargin > 2) || (nargin == 0)
diff --git a/scripts/special-matrix/rosser.m b/scripts/special-matrix/rosser.m
--- a/scripts/special-matrix/rosser.m
+++ b/scripts/special-matrix/rosser.m
@@ -16,18 +16,17 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} rosser ()
 ## Return the Rosser matrix.  This is a difficult test case used to evaluate
 ## eigenvalue algorithms.
 ##
-## @seealso{hankel, vander, sylvester_matrix, hilb, invhilb, toeplitz,
-##          hadamard, wilkinson, compan, pascal}
+## @seealso{wilkinson, eig}
 ## @end deftypefn
 
 ## Author: Peter Ekberg
 ##         (peda)
 
 function retval = rosser ()
 
   if (nargin != 0)
@@ -37,12 +36,13 @@ function retval = rosser ()
   retval = [611,   196,  -192,   407,    -8,   -52,   -49,    29;
             196,   899,   113,  -192,   -71,   -43,    -8,   -44;
            -192,   113,   899,   196,    61,    49,     8,    52;
             407,  -192,   196,   611,     8,    44,    59,   -23;
              -8,   -71,    61,     8,   411,  -599,   208,   208;
             -52,   -43,    49,    44,  -599,   411,   208,   208;
             -49,    -8,     8,    59,   208,   208,    99,  -911;
              29,   -44,    52,   -23,   208,   208,  -911,    99];
+
 endfunction
 
 %!assert (size(rosser()), [8,8])
 %!error (rosser(1))
diff --git a/scripts/special-matrix/sylvester_matrix.m b/scripts/special-matrix/sylvester_matrix.m
--- a/scripts/special-matrix/sylvester_matrix.m
+++ b/scripts/special-matrix/sylvester_matrix.m
@@ -18,19 +18,20 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} sylvester_matrix (@var{k})
 ## Return the Sylvester matrix of order
 ## @tex
 ## $n = 2^k$.
 ## @end tex
 ## @ifnottex
-## n = 2^k.
+## n = 2^@var{k}.
 ## @end ifnottex
-## @seealso{hankel, vander, hilb, invhilb, toeplitz}
+##
+## @seealso{toeplitz, hankel}
 ## @end deftypefn
 
 ## Author: jwe
 
 function retval = sylvester_matrix (k)
 
   if (nargin != 1)
     print_usage ();
diff --git a/scripts/special-matrix/toeplitz.m b/scripts/special-matrix/toeplitz.m
--- a/scripts/special-matrix/toeplitz.m
+++ b/scripts/special-matrix/toeplitz.m
@@ -15,19 +15,19 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} toeplitz (@var{c})
 ## @deftypefnx {Function File} {} toeplitz (@var{c}, @var{r})
-## Return the Toeplitz matrix constructed given the first column @var{c},
-## and (optionally) the first row @var{r}.  If the first element of @var{c}
-## is not the same as the first element of @var{r}, the first element of
+## Return the Toeplitz matrix constructed from the first column @var{c},
+## and (optionally) the first row @var{r}.  If the first element of @var{r}
+## is not the same as the first element of @var{c}, the first element of
 ## @var{c} is used.  If the second argument is omitted, the first row is
 ## taken to be the same as the first column.
 ##
 ## A square Toeplitz matrix has the form:
 ## @tex
 ## $$
 ## \left[\matrix{c_0    & r_1     & r_2      & \cdots & r_n\cr
 ##               c_1    & c_0     & r_1      & \cdots & r_{n-1}\cr
@@ -46,17 +46,17 @@
 ##  .     .      .   .      .
 ##  .     .      .     .    .
 ##  .     .      .       .  .
 ## c(n) c(n-1) c(n-2) @dots{}  c(0)
 ## @end group
 ## @end example
 ##
 ## @end ifnottex
-## @seealso{hankel, vander, sylvester_matrix, hilb, invhilb}
+## @seealso{hankel}
 ## @end deftypefn
 
 ## Author: jwe && jh
 
 function retval = toeplitz (c, r)
 
   if (nargin == 1)
     r = c;
diff --git a/scripts/special-matrix/vander.m b/scripts/special-matrix/vander.m
--- a/scripts/special-matrix/vander.m
+++ b/scripts/special-matrix/vander.m
@@ -42,17 +42,17 @@
 ##     .     .      .      .    .
 ##     .       .    .      .    .
 ##     .         .  .      .    .
 ## c(n)^(n-1) @dots{} c(n)^2  c(n)  1
 ## @end group
 ## @end example
 ##
 ## @end ifnottex
-## @seealso{hankel, sylvester_matrix, hilb, invhilb, toeplitz}
+## @seealso{polyfit}
 ## @end deftypefn
 
 ## Author: jwe
 
 function retval = vander (c, n)
 
   if (nargin == 1)
     n = length (c);
diff --git a/scripts/special-matrix/wilkinson.m b/scripts/special-matrix/wilkinson.m
--- a/scripts/special-matrix/wilkinson.m
+++ b/scripts/special-matrix/wilkinson.m
@@ -15,20 +15,20 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} wilkinson (@var{n})
 ## Return the Wilkinson matrix of order @var{n}.  Wilkinson matrices are
 ## symmetric and tridiagonal with pairs of nearly, but not exactly, equal
-## eigenvalues.
+## eigenvalues.  They are useful in testing the behavior and performance
+## of eigenvalue solvers.
 ##
-## @seealso{hankel, vander, sylvester_matrix, hilb, invhilb, toeplitz,
-##          hadamard, rosser, compan, pascal}
+## @seealso{rosser, eig}
 ## @end deftypefn
 
 ## Author: Peter Ekberg
 ##         (peda)
 
 function retval = wilkinson (n)
 
   if (nargin != 1)
diff --git a/src/DLD-FUNCTIONS/bsxfun.cc b/src/DLD-FUNCTIONS/bsxfun.cc
--- a/src/DLD-FUNCTIONS/bsxfun.cc
+++ b/src/DLD-FUNCTIONS/bsxfun.cc
@@ -308,19 +308,20 @@ update_index (Array<int>& idx, const dim
       i = i / dv (j);
     }
 }
 
 DEFUN_DLD (bsxfun, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} bsxfun (@var{f}, @var{A}, @var{B})\n\
 Apply a binary function @var{f} element-by-element to two matrix arguments\n\
-@var{A} and @var{B}.  The function @var{f} must be capable of accepting\n\
-two column-vector arguments of equal length, or one column vector\n\
-argument and a scalar.\n\
+@var{A} and @var{B}.  @var{f} is a function handle, inline function, or\n\
+string containing the name of the function to evaluate.\n\
+The function @var{f} must be capable of accepting two column-vector\n\
+arguments of equal length, or one column vector argument and a scalar.\n\
 \n\
 The dimensions of @var{A} and @var{B} must be equal or singleton.  The\n\
 singleton dimensions of the matrices will be expanded to the same\n\
 dimensionality as the other matrix.\n\
 @seealso{arrayfun, cellfun}\n\
 @end deftypefn")
 {
   int nargin = args.length ();
diff --git a/src/DLD-FUNCTIONS/find.cc b/src/DLD-FUNCTIONS/find.cc
--- a/src/DLD-FUNCTIONS/find.cc
+++ b/src/DLD-FUNCTIONS/find.cc
@@ -336,21 +336,21 @@ find_nonzero_elem_idx (const PermMatrix&
 }
 
 DEFUN_DLD (find, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {@var{idx} =} find (@var{x})\n\
 @deftypefnx {Loadable Function} {@var{idx} =} find (@var{x}, @var{n})\n\
 @deftypefnx {Loadable Function} {@var{idx} =} find (@var{x}, @var{n}, @var{direction})\n\
 @deftypefnx {Loadable Function} {[i, j] =} find (@dots{})\n\
-@deftypefnx {Loadable Function} {[i, j, v]] =} find (@dots{})\n\
+@deftypefnx {Loadable Function} {[i, j, v] =} find (@dots{})\n\
 Return a vector of indices of nonzero elements of a matrix, as a row if\n\
-@var{x} is a row or as a column otherwise.  To obtain a single index for\n\
-each matrix element, Octave pretends that the columns of a matrix form one\n\
-long vector (like Fortran arrays are stored).  For example:\n\
+@var{x} is a row vector or as a column otherwise.  To obtain a single index\n\
+for each matrix element, Octave pretends that the columns of a matrix form\n\
+one long vector (like Fortran arrays are stored).  For example:\n\
 \n\
 @example\n\
 @group\n\
 find (eye (2))\n\
      @result{} [ 1; 4 ]\n\
 @end group\n\
 @end example\n\
 \n\
@@ -385,19 +385,19 @@ If three inputs are given, @var{directio
 However, the indices are always returned in ascending order.\n\
 \n\
 Note that this function is particularly useful for sparse matrices, as\n\
 it extracts the non-zero elements as vectors, which can then be used to\n\
 create the original matrix.  For example:\n\
 \n\
 @example\n\
 @group\n\
-sz = size(a);\n\
+sz = size (a);\n\
 [i, j, v] = find (a);\n\
-b = sparse(i, j, v, sz(1), sz(2));\n\
+b = sparse (i, j, v, sz(1), sz(2));\n\
 @end group\n\
 @end example\n\
 @seealso{nonzeros}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
diff --git a/src/DLD-FUNCTIONS/lookup.cc b/src/DLD-FUNCTIONS/lookup.cc
--- a/src/DLD-FUNCTIONS/lookup.cc
+++ b/src/DLD-FUNCTIONS/lookup.cc
@@ -183,40 +183,41 @@ do_numeric_lookup (const ArrayT& array, 
   else
     retval = idx;
 
   return retval;
 }
 
 DEFUN_DLD (lookup, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {@var{idx} =} lookup (@var{table}, @var{y}, @var{opt})\n\
+@deftypefn  {Loadable Function} {@var{idx} =} lookup (@var{table}, @var{y})\n\
+@deftypefnx {Loadable Function} {@var{idx} =} lookup (@var{table}, @var{y}, @var{opt})\n\
 Lookup values in a sorted table.  Usually used as a prelude to\n\
 interpolation.\n\
 \n\
 If table is increasing and @code{idx = lookup (table, y)}, then\n\
 @code{table(idx(i)) <= y(i) < table(idx(i+1))} for all @code{y(i)}\n\
-within the table.  If @code{y(i) < table (1)} then\n\
+within the table.  If @code{y(i) < table(1)} then\n\
 @code{idx(i)} is 0. If @code{y(i) >= table(end)} or @code{isnan (y(i))} then\n\
 @code{idx(i)} is @code{n}.\n\
 \n\
 If the table is decreasing, then the tests are reversed.\n\
 For non-strictly monotonic tables, empty intervals are always skipped.\n\
 The result is undefined if @var{table} is not monotonic, or if\n\
 @var{table} contains a NaN.\n\
 \n\
 The complexity of the lookup is O(M*log(N)) where N is the size of\n\
 @var{table} and M is the size of @var{y}.  In the special case when @var{y}\n\
 is also sorted, the complexity is O(min(M*log(N),M+N)).\n\
 \n\
 @var{table} and @var{y} can also be cell arrays of strings\n\
 (or @var{y} can be a single string).  In this case, string lookup\n\
 is performed using lexicographical comparison.\n\
 \n\
-If @var{opts} is specified, it shall be a string with letters indicating\n\
+If @var{opts} is specified, it must be a string with letters indicating\n\
 additional options.\n\
 \n\
 @table @code\n\
 @item m\n\
 @code{table(idx(i)) == val(i)} if @code{val(i)}\n\
 occurs in table; otherwise, @code{idx(i)} is zero.\n\
 \n\
 @item b\n\
diff --git a/src/DLD-FUNCTIONS/rand.cc b/src/DLD-FUNCTIONS/rand.cc
--- a/src/DLD-FUNCTIONS/rand.cc
+++ b/src/DLD-FUNCTIONS/rand.cc
@@ -321,18 +321,19 @@ do_rand (const octave_value_list& args, 
         }
     }
   else
     return octave_rand::nd_array (dims);
 }
 
 DEFUN_DLD (rand, args, ,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {} rand (@var{x})\n\
-@deftypefnx {Loadable Function} {} rand (@var{n}, @var{m})\n\
+@deftypefn  {Loadable Function} {} rand (@var{n})\n\
+@deftypefnx {Loadable Function} {} rand (@var{n}, @var{m}, @dots{})\n\
+@deftypefnx {Loadable Function} {} rand ([@var{n} @var{m} @dots{}])\n\
 @deftypefnx {Loadable Function} {@var{v} =} rand (\"state\")\n\
 @deftypefnx {Loadable Function} {} rand (\"state\", @var{v})\n\
 @deftypefnx {Loadable Function} {} rand (\"state\", \"reset\")\n\
 @deftypefnx {Loadable Function} {@var{v} =} rand (\"seed\")\n\
 @deftypefnx {Loadable Function} {} rand (\"seed\", @var{v})\n\
 @deftypefnx {Loadable Function} {} rand (\"seed\", \"reset\")\n\
 Return a matrix with random elements uniformly distributed on the\n\
 interval (0, 1).  The arguments are handled the same as the arguments\n\
@@ -354,23 +355,23 @@ rand (\"state\", v)\n\
 @end example\n\
 \n\
 @noindent\n\
 You may also initialize the state vector from an arbitrary vector of\n\
 length @leq{} 625 for @var{v}.  This new state will be a hash based on the\n\
 value of @var{v}, not @var{v} itself.\n\
 \n\
 By default, the generator is initialized from @code{/dev/urandom} if it is\n\
-available, otherwise from CPU time, wall clock time and the current\n\
+available, otherwise from CPU time, wall clock time, and the current\n\
 fraction of a second.\n\
 \n\
 To compute the pseudo-random sequence, @code{rand} uses the Mersenne\n\
 Twister with a period of @math{2^{19937}-1} (See M. Matsumoto and\n\
 T. Nishimura,\n\
-@cite{Mersenne Twister: A 623-dimensionally equidistributed uniform \n\
+@cite{Mersenne Twister: A 623-dimensionally equidistributed uniform\n\
 pseudorandom number generator}, ACM Trans. on\n\
 Modeling and Computer Simulation Vol. 8, No. 1, pp. 3-30, January 1998,\n\
 @url{http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html}).\n\
 Do @strong{not} use for cryptography without securely hashing\n\
 several returned values together, otherwise the generator state\n\
 can be learned after reading 624 consecutive values.\n\
 \n\
 Older versions of Octave used a different random number generator.\n\
@@ -485,18 +486,19 @@ using the \"reset\" keyword.\n\
 %! endif
 */
 
 
 static std::string current_distribution = octave_rand::distribution ();
 
 DEFUN_DLD (randn, args, ,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {} randn (@var{x})\n\
-@deftypefnx {Loadable Function} {} randn (@var{n}, @var{m})\n\
+@deftypefn  {Loadable Function} {} randn (@var{n})\n\
+@deftypefnx {Loadable Function} {} randn (@var{n}, @var{m}, @dots{})\n\
+@deftypefnx {Loadable Function} {} randn ([@var{n} @var{m} @dots{}])\n\
 @deftypefnx {Loadable Function} {@var{v} =} randn (\"state\")\n\
 @deftypefnx {Loadable Function} {} randn (\"state\", @var{v})\n\
 @deftypefnx {Loadable Function} {} randn (\"state\", \"reset\")\n\
 @deftypefnx {Loadable Function} {@var{v} =} randn (\"seed\")\n\
 @deftypefnx {Loadable Function} {} randn (\"seed\", @var{v})\n\
 @deftypefnx {Loadable Function} {} randn (\"seed\", \"reset\")\n\
 Return a matrix with normally distributed random\n\
 elements having zero mean and variance one.  The arguments are\n\
@@ -550,18 +552,19 @@ J. Statistical Software, vol 5, 2000,\n\
 %!   assert(var(x),1,0.02);
 %!   assert(skewness(x),0,0.02);
 %!   assert(kurtosis(x),0,0.04);
 %! endif
 */
 
 DEFUN_DLD (rande, args, ,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {} rande (@var{x})\n\
-@deftypefnx {Loadable Function} {} rande (@var{n}, @var{m})\n\
+@deftypefn  {Loadable Function} {} rande (@var{n})\n\
+@deftypefnx {Loadable Function} {} rande (@var{n}, @var{m}, @dots{})\n\
+@deftypefnx {Loadable Function} {} rande ([@var{n} @var{m} @dots{}])\n\
 @deftypefnx {Loadable Function} {@var{v} =} rande (\"state\")\n\
 @deftypefnx {Loadable Function} {} rande (\"state\", @var{v})\n\
 @deftypefnx {Loadable Function} {} rande (\"state\", \"reset\")\n\
 @deftypefnx {Loadable Function} {@var{v} =} rande (\"seed\")\n\
 @deftypefnx {Loadable Function} {} rande (\"seed\", @var{v})\n\
 @deftypefnx {Loadable Function} {} rande (\"seed\", \"reset\")\n\
 Return a matrix with exponentially distributed random elements.  The\n\
 arguments are handled the same as the arguments for @code{rand}.\n\
@@ -616,18 +619,19 @@ J. Statistical Software, vol 5, 2000,\n\
 %!   assert(var(x),1,0.03);
 %!   assert(skewness(x),2,0.06);
 %!   assert(kurtosis(x),6,0.7);
 %! endif
 */
 
 DEFUN_DLD (randg, args, ,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {} randg (@var{a}, @var{x})\n\
-@deftypefnx {Loadable Function} {} randg (@var{a}, @var{n}, @var{m})\n\
+@deftypefn  {Loadable Function} {} randg (@var{n})\n\
+@deftypefnx {Loadable Function} {} randg (@var{n}, @var{m}, @dots{})\n\
+@deftypefnx {Loadable Function} {} randg ([@var{n} @var{m} @dots{}])\n\
 @deftypefnx {Loadable Function} {@var{v} =} randg (\"state\")\n\
 @deftypefnx {Loadable Function} {} randg (\"state\", @var{v})\n\
 @deftypefnx {Loadable Function} {} randg (\"state\", \"reset\")\n\
 @deftypefnx {Loadable Function} {@var{v} =} randg (\"seed\")\n\
 @deftypefnx {Loadable Function} {} randg (\"seed\", @var{v})\n\
 @deftypefnx {Loadable Function} {} randg (\"seed\", \"reset\")\n\
 Return a matrix with @code{gamma(@var{a},1)} distributed random elements.\n\
 The arguments are handled the same as the arguments for @code{rand},\n\
@@ -658,17 +662,17 @@ r = a * randg (n)\n\
 @end example\n\
 \n\
 @item @code{chisq (df)} for @code{df > 0}\n\
 \n\
 @example\n\
 r = 2 * randg (df / 2)\n\
 @end example\n\
 \n\
-@item @code{t(df)} for @code{0 < df < inf} (use randn if df is infinite)\n\
+@item @code{t (df)} for @code{0 < df < inf} (use randn if df is infinite)\n\
 \n\
 @example\n\
 r = randn () / sqrt (2 * randg (df / 2) / df)\n\
 @end example\n\
 \n\
 @item @code{F (n1, n2)} for @code{0 < n1}, @code{0 < n2}\n\
 \n\
 @example\n\
@@ -872,18 +876,19 @@ r = r / sum (r)\n\
 %!   assert(skewness(x),2/sqrt(a), 0.05);
 %!   assert(kurtosis(x),6/a,       0.2);
 %! endif
 */
 
 
 DEFUN_DLD (randp, args, ,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {} randp (@var{l}, @var{x})\n\
-@deftypefnx {Loadable Function} {} randp (@var{l}, @var{n}, @var{m})\n\
+@deftypefn  {Loadable Function} {} randp (@var{l}, @var{n})\n\
+@deftypefnx {Loadable Function} {} randp (@var{l}, @var{n}, @var{m}, @dots{})\n\
+@deftypefnx {Loadable Function} {} randp (@var{l}, [@var{n} @var{m} @dots{}])\n\
 @deftypefnx {Loadable Function} {@var{v} =} randp (\"state\")\n\
 @deftypefnx {Loadable Function} {} randp (\"state\", @var{v})\n\
 @deftypefnx {Loadable Function} {} randp (\"state\", \"reset\")\n\
 @deftypefnx {Loadable Function} {@var{v} =} randp (\"seed\")\n\
 @deftypefnx {Loadable Function} {} randp (\"seed\", @var{v})\n\
 @deftypefnx {Loadable Function} {} randp (\"seed\", \"reset\")\n\
 Return a matrix with Poisson distributed random elements with mean value\n\
 parameter given by the first argument, @var{l}.  The arguments\n\
@@ -1017,17 +1022,17 @@ D 50 p1284, 1994.\n\
 */
 
 DEFUN_DLD (randperm, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {} randperm (@var{n})\n\
 @deftypefnx {Loadable Function} {} randperm (@var{n}, @var{m})\n\
 Return a row vector containing a random permutation of @code{1:@var{n}}.\n\
 If @var{m} is supplied, return @var{m} permutations,\n\
-one in each row of an @nospell{NxM} matrix.  The complexity is O(M*N) in both\n\
+one in each row of an @nospell{MxN} matrix.  The complexity is O(M*N) in both\n\
 time and memory.  The randomization is performed using rand().\n\
 All permutations are equally likely.\n\
 @seealso{perms}\n\
 @end deftypefn")
 {
   int nargin = args.length ();
   octave_value retval;
 
diff --git a/src/DLD-FUNCTIONS/tril.cc b/src/DLD-FUNCTIONS/tril.cc
--- a/src/DLD-FUNCTIONS/tril.cc
+++ b/src/DLD-FUNCTIONS/tril.cc
@@ -384,17 +384,17 @@ tril (ones (3), 1)\n\
          1  1  1\n\
          1  1  1\n\
 @end group\n\
 @end example\n\
 \n\
 If the option \"pack\" is given as third argument, the extracted elements\n\
 are not inserted into a matrix, but rather stacked column-wise one above\n\
 other.\n\
-@seealso{triu, diag}\n\
+@seealso{diag}\n\
 @end deftypefn")
 {
   return do_trilu ("tril", args);
 }
 
 DEFUN_DLD (triu, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Function File} {} triu (@var{A})\n\
diff --git a/src/data.cc b/src/data.cc
--- a/src/data.cc
+++ b/src/data.cc
@@ -101,20 +101,35 @@ along with Octave; see the file COPYING.
     } \
   else \
     print_usage (); \
  \
   return retval
 
 DEFUN (all, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} all (@var{x}, @var{dim})\n\
-The function @code{all} behaves like the function @code{any}, except\n\
-that it returns true only if all the elements of a vector, or all the\n\
-elements along dimension @var{dim} of a matrix, are nonzero.\n\
+@deftypefn  {Built-in Function} {} all (@var{x})\n\
+@deftypefnx {Built-in Function} {} all (@var{x}, @var{dim})\n\
+For a vector argument, return true (logical 1) if all elements of the vector\n\
+are nonzero.\n\
+\n\
+For a matrix argument, return a row vector of logical ones and\n\
+zeros with each element indicating whether all of the elements of the\n\
+corresponding column of the matrix are nonzero.  For example:\n\
+\n\
+@example\n\
+@group\n\
+all ([2, 3; 1, 0]))\n\
+     @result{} [ 1, 0 ]\n\
+@end group\n\
+@end example\n\
+\n\
+If the optional argument @var{dim} is supplied, work along dimension\n\
+@var{dim}.\n\
+@seealso{any}\n\
 @end deftypefn")
 {
   ANY_ALL (all);
 }
 
 /*
 
 %!test
@@ -135,21 +150,22 @@ elements along dimension @var{dim} of a 
 
 %!error <Invalid call to all.*> all ();
 %!error <Invalid call to all.*> all (1, 2, 3);
 
  */
 
 DEFUN (any, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} any (@var{x}, @var{dim})\n\
-For a vector argument, return 1 if any element of the vector is\n\
-nonzero.\n\
+@deftypefn  {Built-in Function} {} any (@var{x})\n\
+@deftypefnx {Built-in Function} {} any (@var{x}, @var{dim})\n\
+For a vector argument, return true (logical 1) if any element of the vector\n\
+is nonzero.\n\
 \n\
-For a matrix argument, return a row vector of ones and\n\
+For a matrix argument, return a row vector of logical ones and\n\
 zeros with each element indicating whether any of the elements of the\n\
 corresponding column of the matrix are nonzero.  For example:\n\
 \n\
 @example\n\
 @group\n\
 any (eye (2, 4))\n\
      @result{} [ 1, 1, 0, 0 ]\n\
 @end group\n\
@@ -159,16 +175,17 @@ If the optional argument @var{dim} is su
 @var{dim}.  For example:\n\
 \n\
 @example\n\
 @group\n\
 any (eye (2, 4), 2)\n\
      @result{} [ 1; 1 ]\n\
 @end group\n\
 @end example\n\
+@seealso{all}\n\
 @end deftypefn")
 {
   ANY_ALL (any);
 }
 
 /*
 
 %!test
@@ -1681,79 +1698,91 @@ do_cat (const octave_value_list& args, i
     print_usage ();
 
   return retval;
 }
 
 DEFUN (horzcat, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} horzcat (@var{array1}, @var{array2}, @dots{}, @var{arrayN})\n\
-Return the horizontal concatenation of N-d array objects, @var{array1},\n\
+Return the horizontal concatenation of N-D array objects, @var{array1},\n\
 @var{array2}, @dots{}, @var{arrayN} along dimension 2.\n\
+\n\
+Arrays may also be concatenated horizontally using the syntax for creating\n\
+new matrices.  For example:\n\
+\n\
+@example\n\
+@var{hcat} = [ @var{array1}, @var{array2}, @dots{} ];\n\
+@end example\n\
 @seealso{cat, vertcat}\n\
 @end deftypefn")
 {
   return do_cat (args, -2, "horzcat");
 }
 
 DEFUN (vertcat, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} vertcat (@var{array1}, @var{array2}, @dots{}, @var{arrayN})\n\
-Return the vertical concatenation of N-d array objects, @var{array1},\n\
+Return the vertical concatenation of N-D array objects, @var{array1},\n\
 @var{array2}, @dots{}, @var{arrayN} along dimension 1.\n\
+\n\
+Arrays may also be concatenated vertically using the syntax for creating\n\
+new matrices.  For example:\n\
+\n\
+@example\n\
+@var{vcat} = [ @var{array1}; @var{array2}; @dots{} ];\n\
+@end example\n\
 @seealso{cat, horzcat}\n\
 @end deftypefn")
 {
   return do_cat (args, -1, "vertcat");
 }
 
 DEFUN (cat, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} cat (@var{dim}, @var{array1}, @var{array2}, @dots{}, @var{arrayN})\n\
-Return the concatenation of N-d array objects, @var{array1},\n\
+Return the concatenation of N-D array objects, @var{array1},\n\
 @var{array2}, @dots{}, @var{arrayN} along dimension @var{dim}.\n\
 \n\
 @example\n\
 @group\n\
 A = ones (2, 2);\n\
 B = zeros (2, 2);\n\
 cat (2, A, B)\n\
-@result{} ans =\n\
-\n\
-     1 1 0 0\n\
-     1 1 0 0\n\
+    @result{} 1 1 0 0\n\
+       1 1 0 0\n\
 @end group\n\
 @end example\n\
 \n\
 Alternatively, we can concatenate @var{A} and @var{B} along the\n\
 second dimension the following way:\n\
 \n\
 @example\n\
 @group\n\
 [A, B].\n\
 @end group\n\
 @end example\n\
 \n\
-@var{dim} can be larger than the dimensions of the N-d array objects\n\
+@var{dim} can be larger than the dimensions of the N-D array objects\n\
 and the result will thus have @var{dim} dimensions as the\n\
 following example shows:\n\
 \n\
 @example\n\
 @group\n\
-cat (4, ones(2, 2), zeros (2, 2))\n\
-@result{} ans =\n\
+cat (4, ones (2, 2), zeros (2, 2))\n\
+    @result{} ans =\n\
 \n\
-   ans(:,:,1,1) =\n\
+       ans(:,:,1,1) =\n\
 \n\
-     1 1\n\
-     1 1\n\
+         1 1\n\
+         1 1\n\
 \n\
-   ans(:,:,1,2) =\n\
-     0 0\n\
-     0 0\n\
+       ans(:,:,1,2) =\n\
+         0 0\n\
+         0 0\n\
 @end group\n\
 @end example\n\
 @seealso{horzcat, vertcat}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () > 0)
@@ -1941,37 +1970,37 @@ do_permute (const octave_value_list& arg
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (permute, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} permute (@var{a}, @var{perm})\n\
-Return the generalized transpose for an N-d array object @var{a}.\n\
+@deftypefn {Built-in Function} {} permute (@var{A}, @var{perm})\n\
+Return the generalized transpose for an N-D array object @var{A}.\n\
 The permutation vector @var{perm} must contain the elements\n\
-@code{1:ndims(a)} (in any order, but each element must appear just once).\n\
+@code{1:ndims(A)} (in any order, but each element must appear only once).\n\
 @seealso{ipermute}\n\
 @end deftypefn")
 {
   return do_permute (args, false);
 }
 
 DEFUN (ipermute, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} ipermute (@var{a}, @var{iperm})\n\
+@deftypefn {Built-in Function} {} ipermute (@var{A}, @var{iperm})\n\
 The inverse of the @code{permute} function.  The expression\n\
 \n\
 @example\n\
-ipermute (permute (a, perm), perm)\n\
+ipermute (permute (A, perm), perm)\n\
 @end example\n\
 \n\
 @noindent\n\
-returns the original array @var{a}.\n\
+returns the original array @var{A}.\n\
 @seealso{permute}\n\
 @end deftypefn")
 {
   return do_permute (args, true);
 }
 
 DEFUN (length, args, ,
   "-*- texinfo -*-\n\
@@ -3428,38 +3457,39 @@ fill_matrix (const octave_value_list& ar
         retval = boolNDArray (dims, val);
     }
 
   return retval;
 }
 
 DEFUN (ones, args, ,
   "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} ones (@var{x})\n\
-@deftypefnx {Built-in Function} {} ones (@var{n}, @var{m})\n\
-@deftypefnx {Built-in Function} {} ones (@var{n}, @var{m}, @var{k}, @dots{})\n\
+@deftypefn  {Built-in Function} {} ones (@var{n})\n\
+@deftypefnx {Built-in Function} {} ones (@var{m}, @var{n})\n\
+@deftypefnx {Built-in Function} {} ones (@var{m}, @var{n}, @var{k}, @dots{})\n\
+@deftypefnx {Built-in Function} {} ones ([@var{m} @var{n} @dots{}])\n\
 @deftypefnx {Built-in Function} {} ones (@dots{}, @var{class})\n\
 Return a matrix or N-dimensional array whose elements are all 1.\n\
-If invoked with a single scalar integer argument, return a square\n\
-matrix of the specified size.  If invoked with two or more scalar\n\
+If invoked with a single scalar integer argument @var{n}, return a square\n\
+@nospell{NxN} matrix.  If invoked with two or more scalar\n\
 integer arguments, or a vector of integer values, return an array with\n\
-given dimensions.\n\
+the given dimensions.\n\
 \n\
 If you need to create a matrix whose values are all the same, you should\n\
 use an expression like\n\
 \n\
 @example\n\
-val_matrix = val * ones (n, m)\n\
+val_matrix = val * ones (m, n)\n\
 @end example\n\
 \n\
 The optional argument @var{class} specifies the class of the return array\n\
 and defaults to double.  For example:\n\
 \n\
 @example\n\
-val = ones (n,m, \"uint8\")\n\
+val = ones (m,n, \"uint8\")\n\
 @end example\n\
 @seealso{zeros}\n\
 @end deftypefn")
 {
   return fill_matrix (args, 1, "ones");
 }
 
 /*
@@ -3478,31 +3508,32 @@ val = ones (n,m, \"uint8\")\n\
 %!assert(ones (2, 3,'int8'), int8([1, 1, 1; 1, 1, 1]));
 %!assert(ones (3, 2,'int8'), int8([1, 1; 1, 1; 1, 1]));
 %!assert(size (ones (3, 4, 5, 'int8')),  [3, 4, 5]);
 
  */
 
 DEFUN (zeros, args, ,
   "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} zeros (@var{x})\n\
-@deftypefnx {Built-in Function} {} zeros (@var{n}, @var{m})\n\
-@deftypefnx {Built-in Function} {} zeros (@var{n}, @var{m}, @var{k}, @dots{})\n\
+@deftypefn  {Built-in Function} {} zeros (@var{n})\n\
+@deftypefnx {Built-in Function} {} zeros (@var{m}, @var{n})\n\
+@deftypefnx {Built-in Function} {} zeros (@var{m}, @var{n}, @var{k}, @dots{})\n\
+@deftypefnx {Built-in Function} {} zeros ([@var{m} @var{n} @dots{}])\n\
 @deftypefnx {Built-in Function} {} zeros (@dots{}, @var{class})\n\
 Return a matrix or N-dimensional array whose elements are all 0.\n\
 If invoked with a single scalar integer argument, return a square\n\
-matrix of the specified size.  If invoked with two or more scalar\n\
+@nospell{NxN} matrix.  If invoked with two or more scalar\n\
 integer arguments, or a vector of integer values, return an array with\n\
-given dimensions.\n\
+the given dimensions.\n\
 \n\
 The optional argument @var{class} specifies the class of the return array\n\
 and defaults to double.  For example:\n\
 \n\
 @example\n\
-val = zeros (n,m, \"uint8\")\n\
+val = zeros (m,n, \"uint8\")\n\
 @end example\n\
 @seealso{ones}\n\
 @end deftypefn")
 {
   return fill_matrix (args, 0, "zeros");
 }
 
 /*
@@ -4108,24 +4139,25 @@ identity_matrix (int nr, int nc, oct_dat
 
   return retval;
 }
 
 #undef INT_EYE_MATRIX
 
 DEFUN (eye, args, ,
   "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} eye (@var{x})\n\
-@deftypefnx {Built-in Function} {} eye (@var{n}, @var{m})\n\
+@deftypefn  {Built-in Function} {} eye (@var{n})\n\
+@deftypefnx {Built-in Function} {} eye (@var{m}, @var{n})\n\
+@deftypefnx {Built-in Function} {} eye ([@var{m} @var{n}])\n\
 @deftypefnx {Built-in Function} {} eye (@dots{}, @var{class})\n\
-Return an identity matrix.  If invoked with a single scalar argument,\n\
-@code{eye} returns a square matrix with the dimension specified.  If you\n\
-supply two scalar arguments, @code{eye} takes them to be the number of\n\
-rows and columns.  If given a vector with two elements, @code{eye} uses\n\
-the values of the elements as the number of rows and columns,\n\
+Return an identity matrix.  If invoked with a single scalar argument @var{n},\n\
+return a square @nospell{NxN} identity matrix.  If\n\
+supplied two scalar arguments (@var{m}, @var{n}), @code{eye} takes them to be\n\
+the number of rows and columns.  If given a vector with two elements,\n\
+@code{eye} uses the values of the elements as the number of rows and columns,\n\
 respectively.  For example:\n\
 \n\
 @example\n\
 @group\n\
 eye (3)\n\
      @result{}  1  0  0\n\
          0  1  0\n\
          0  0  1\n\
@@ -4149,16 +4181,17 @@ the specified type, like\n\
 \n\
 @example\n\
 val = zeros (n,m, \"uint8\")\n\
 @end example\n\
 \n\
 Calling @code{eye} with no arguments is equivalent to calling it\n\
 with an argument of 1.  This odd definition is for compatibility\n\
 with @sc{matlab}.\n\
+@seealso{speye}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   oct_data_conv::data_type dt = oct_data_conv::dt_double;
 
@@ -4266,30 +4299,31 @@ do_linspace (const octave_value& base, c
         }
     }
 
   return retval;
 }
 
 DEFUN (linspace, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} linspace (@var{base}, @var{limit}, @var{n})\n\
+@deftypefn  {Built-in Function} {} linspace (@var{base}, @var{limit})\n\
+@deftypefnx {Built-in Function} {} linspace (@var{base}, @var{limit}, @var{n})\n\
 Return a row vector with @var{n} linearly spaced elements between\n\
 @var{base} and @var{limit}.  If the number of elements is greater than one,\n\
-then the @var{base} and @var{limit} are always included in\n\
+then the endpoints @var{base} and @var{limit} are always included in\n\
 the range.  If @var{base} is greater than @var{limit}, the elements are\n\
 stored in decreasing order.  If the number of points is not specified, a\n\
 value of 100 is used.\n\
 \n\
 The @code{linspace} function always returns a row vector if both\n\
-@var{base} and @var{limit} are scalars.  If one of them or both are column\n\
+@var{base} and @var{limit} are scalars.  If one, or both, of them are column\n\
 vectors, @code{linspace} returns a matrix.\n\
 \n\
-For compatibility with @sc{matlab}, return the second argument if\n\
-fewer than two values are requested.\n\
+For compatibility with @sc{matlab}, return the second argument (@var{limit})\n\
+if fewer than two values are requested.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   octave_idx_type npoints = 100;
 
@@ -4352,18 +4386,18 @@ fewer than two values are requested.\n\
 */
 
 // FIXME -- should accept dimensions as separate args for N-d
 // arrays as well as 1-d and 2-d arrays.
 
 DEFUN (resize, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} resize (@var{x}, @var{m})\n\
-@deftypefnx {Built-in Function} {} resize (@var{x}, @var{m}, @var{n})\n\
 @deftypefnx {Built-in Function} {} resize (@var{x}, @var{m}, @var{n}, @dots{})\n\
+@deftypefnx {Built-in Function} {} resize (@var{x}, [@var{m} @var{n} @dots{}])\n\
 Resize @var{x} cutting off elements as necessary.\n\
 \n\
 In the result, element with certain indices is equal to the corresponding\n\
 element of @var{x} if the indices are within the bounds of @var{x};\n\
 otherwise, the element is set to zero.\n\
 \n\
 In other words, the statement\n\
 \n\
@@ -4381,21 +4415,22 @@ is equivalent to the following code:\n\
   for i = 1:length (sz), idx@{i@} = 1:sz(i); endfor\n\
   y(idx@{:@}) = x(idx@{:@});\n\
 @end group\n\
 @end example\n\
 \n\
 @noindent\n\
 but is performed more efficiently.\n\
 \n\
-If only @var{m} is supplied and it is a scalar, the dimension of the\n\
-result is @var{m}-by-@var{m}.  If @var{m} is a vector, then the\n\
-dimensions of the result are given by the elements of @var{m}.\n\
-If both @var{m} and @var{n} are scalars, then the dimensions of\n\
-the result are @var{m}-by-@var{n}.\n\
+If only @var{m} is supplied, and it is a scalar, the dimension of the\n\
+result is @var{m}-by-@var{m}.\n\
+If @var{m}, @var{n}, @dots{} are all scalars, then the dimensions of\n\
+the result are @var{m}-by-@var{n}-by-@dots{}.\n\
+If given a vector as input, then the\n\
+dimensions of the result are given by the elements of that vector.\n\
 \n\
 An object can be resized to more dimensions than it has;\n\
 in such case the missing dimensions are assumed to be 1.\n\
 Resizing an object to fewer dimensions is not possible.\n\
 @seealso{reshape, postpad}\n\
 @end deftypefn")
 {
   octave_value retval;
@@ -4438,38 +4473,44 @@ Resizing an object to fewer dimensions i
     print_usage ();
   return retval;
 }
 
 // FIXME -- should use octave_idx_type for dimensions.
 
 DEFUN (reshape, args, ,
   "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} reshape (@var{a}, @var{m}, @var{n}, @dots{})\n\
-@deftypefnx {Built-in Function} {} reshape (@var{a}, @var{size})\n\
-Return a matrix with the given dimensions whose elements are taken\n\
-from the matrix @var{a}.  The elements of the matrix are accessed in\n\
-column-major order (like Fortran arrays are stored).\n\
+@deftypefn  {Built-in Function} {} reshape (@var{A}, @var{m}, @var{n}, @dots{})\n\
+@deftypefnx {Built-in Function} {} reshape (@var{A}, [@var{m} @var{n} @dots{}])\n\
+@deftypefnx {Built-in Function} {} reshape (@var{A}, @dots{}, [], @dots{})\n\
+@deftypefnx {Built-in Function} {} reshape (@var{A}, @var{size})\n\
+Return a matrix with the specified dimensions (@var{m}, @var{n}, @dots{})\n\
+whose elements are taken from the matrix @var{A}.  The elements of the\n\
+matrix are accessed in column-major order (like Fortran arrays are stored).\n\
 \n\
-For example:\n\
+The following code demonstrates reshaping a 1x4 row vector into a 2x2 square\n\
+matrix.\n\
 \n\
 @example\n\
 @group\n\
 reshape ([1, 2, 3, 4], 2, 2)\n\
      @result{}  1  3\n\
          2  4\n\
 @end group\n\
 @end example\n\
 \n\
 @noindent\n\
 Note that the total number of elements in the original\n\
-matrix must match the total number of elements in the new matrix.\n\
+matrix (@code{prod (size (@var{A}))}) must match the total number of elements\n\
+in the new matrix (@code{prod ([@var{m} @var{n} @dots{}])}).\n\
 \n\
-A single dimension of the return matrix can be unknown and is flagged\n\
-by an empty argument.\n\
+A single dimension of the return matrix may be left unspecified and Octave\n\
+will determine its size automatically.  An empty matrix ([]) is used to flag\n\
+the unspecified dimension.\n\
+@seealso{resize}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   dim_vector new_dims;
 
@@ -4579,16 +4620,17 @@ DEFUN (vec, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{v} =} vec (@var{x})\n\
 @deftypefnx {Built-in Function} {@var{v} =} vec (@var{x}, @var{dim})\n\
 Return the vector obtained by stacking the columns of the matrix @var{x}\n\
 one above the other.  Without @var{dim} this is equivalent to\n\
 @code{@var{x}(:)}.  If @var{dim} is supplied, the dimensions of @var{v}\n\
 are set to @var{dim} with all elements along the last dimension.\n\
 This is equivalent to @code{shiftdim (@var{x}(:), 1-@var{dim})}.\n\
+@seealso{vech}\n\
 @end deftypefn")
 {
   octave_value retval;
   int dim = 1;
 
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 2)
@@ -4866,17 +4908,17 @@ unary_op_defun_body (octave_value::unary
   return retval;
 }
 
 DEFUN (not, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} not (@var{x})\n\
 Return the logical NOT of @var{x}.  This function is equivalent to\n\
 @code{! x}.\n\
-@seealso{and, or}\n\
+@seealso{and, or, xor}\n\
 @end deftypefn")
 {
   return unary_op_defun_body (octave_value::op_not, args);
 }
 
 DEFUN (uplus, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} uplus (@var{x})\n\
@@ -5209,17 +5251,17 @@ This function is equivalent to @w{@code{
 If more arguments are given, the logical and is applied\n\
 cumulatively from left to right:\n\
 \n\
 @example\n\
   (@dots{}((x1 & x2) & x3) & @dots{})\n\
 @end example\n\
 \n\
 At least one argument is required.\n\
-@seealso{or, not}\n\
+@seealso{or, not, xor}\n\
 @end deftypefn")
 {
   return binary_assoc_op_defun_body (octave_value::op_el_and,
                                      octave_value::op_el_and_eq, args);
 }
 
 DEFUN (or, args, ,
   "-*- texinfo -*-\n\
@@ -5230,17 +5272,17 @@ This function is equivalent to @w{@code{
 If more arguments are given, the logical or is applied\n\
 cumulatively from left to right:\n\
 \n\
 @example\n\
   (@dots{}((x1 | x2) | x3) | @dots{})\n\
 @end example\n\
 \n\
 At least one argument is required.\n\
-@seealso{and, not}\n\
+@seealso{and, not, xor}\n\
 @end deftypefn")
 {
   return binary_assoc_op_defun_body (octave_value::op_el_or,
                                      octave_value::op_el_or_eq, args);
 }
 
 static double tic_toc_timestamp = -1.0;
 
@@ -5420,55 +5462,71 @@ CPU time used is nonzero.\n\
 
 DEFUN (sort, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {[@var{s}, @var{i}] =} sort (@var{x})\n\
 @deftypefnx {Loadable Function} {[@var{s}, @var{i}] =} sort (@var{x}, @var{dim})\n\
 @deftypefnx {Loadable Function} {[@var{s}, @var{i}] =} sort (@var{x}, @var{mode})\n\
 @deftypefnx {Loadable Function} {[@var{s}, @var{i}] =} sort (@var{x}, @var{dim}, @var{mode})\n\
 Return a copy of @var{x} with the elements arranged in increasing\n\
-order.  For matrices, @code{sort} orders the elements in each column.\n\
+order.  For matrices, @code{sort} orders the elements within columns\n\
 \n\
 For example:\n\
 \n\
 @example\n\
 @group\n\
 sort ([1, 2; 2, 3; 3, 1])\n\
      @result{}  1  1\n\
          2  2\n\
          3  3\n\
 @end group\n\
 @end example\n\
 \n\
+If the optional argument @var{dim} is given, then the matrix is sorted\n\
+along the dimension defined by @var{dim}.  The optional argument @code{mode}\n\
+defines the order in which the values will be sorted.  Valid values of\n\
+@code{mode} are `ascend' or `descend'.\n\
+\n\
 The @code{sort} function may also be used to produce a matrix\n\
 containing the original row indices of the elements in the sorted\n\
 matrix.  For example:\n\
 \n\
 @example\n\
 @group\n\
 [s, i] = sort ([1, 2; 2, 3; 3, 1])\n\
      @result{} s = 1  1\n\
             2  2\n\
             3  3\n\
      @result{} i = 1  3\n\
             2  1\n\
             3  2\n\
 @end group\n\
 @end example\n\
 \n\
-If the optional argument @var{dim} is given, then the matrix is sorted\n\
-along the dimension defined by @var{dim}.  The optional argument @code{mode}\n\
-defines the order in which the values will be sorted.  Valid values of\n\
-@code{mode} are `ascend' or `descend'.\n\
+For equal elements, the indices are such that equal elements are listed\n\
+in the order in which they appeared in the original list.\n\
+\n\
+Sorting of complex entries is done first by magnitude (@code{abs (@var{z})})\n\
+and for any ties by phase angle (@code{angle (z)}).  For example:\n\
 \n\
-For equal elements, the indices are such that the equal elements are listed\n\
-in the order that appeared in the original list.\n\
+@example\n\
+@group\n\
+sort ([1+i; 1; 1-i])\n\
+     @result{} 1 + 0i\n\
+        1 - 1i\n\
+        1 + 1i\n\
+@end group\n\
+@end example\n\
+\n\
+NaN values are treated as being greater than any other value and are sorted\n\
+to the end of the list.\n\
 \n\
 The @code{sort} function may also be used to sort strings and cell arrays\n\
-of strings, in which case the dictionary order of the strings is used.\n\
+of strings, in which case ASCII dictionary order (uppercase 'A' precedes\n\
+lowercase 'a') of the strings is used.\n\
 \n\
 The algorithm used in @code{sort} is optimized for the sorting of partially\n\
 ordered lists.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
@@ -5808,17 +5866,18 @@ get_sort_mode_option (const octave_value
   else
     error ("issorted: MODE must be \"ascending\", \"descending\", or \"either\"");
 
   return smode;
 }
 
 DEFUN (issorted, args, ,
   "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} issorted (@var{a}, @var{mode})\n\
+@deftypefn  {Built-in Function} {} issorted (@var{a})\n\
+@deftypefnx {Built-in Function} {} issorted (@var{a}, @var{mode})\n\
 @deftypefnx {Built-in Function} {} issorted (@var{a}, @code{\"rows\"}, @var{mode})\n\
 Return true if the array is sorted according to @var{mode}, which\n\
 may be either \"ascending\", \"descending\", or \"either\".  By default,\n\
  @var{mode} is \"ascending\".  NaNs are treated in the same manner as\n\
 @code{sort}.\n\
 \n\
 If the optional argument \"rows\" is supplied, check whether\n\
 the array is sorted by rows as output by the function @code{sortrows}\n\
@@ -5931,17 +5990,18 @@ Select the n-th smallest element of a ve
 @var{n} can also be a contiguous range, either ascending @code{l:u}\n\
 or descending @code{u:-1:l}, in which case a range of elements is returned.\n\
 If @var{x} is an array, @code{nth_element} operates along the dimension\n\
 defined by @var{dim}, or the first non-singleton dimension if @var{dim} is\n\
 not given.\n\
 \n\
 nth_element encapsulates the C++ standard library algorithms nth_element and\n\
 partial_sort.  On average, the complexity of the operation is O(M*log(K)),\n\
-where @code{M = size(@var{x}, @var{dim})} and @code{K = length (@var{n})}.\n\
+where @w{@code{M = size (@var{x}, @var{dim})}} and\n\
+@w{@code{K = length (@var{n})}}.\n\
 This function is intended for cases where the ratio K/M is small; otherwise,\n\
 it may be better to use @code{sort}.\n\
 @seealso{sort, min, max}\n\
 @end deftypefn")
 {
   octave_value retval;
   int nargin = args.length ();
 
@@ -6545,41 +6605,43 @@ do_diff (const octave_value& array, octa
         retval = array.array_value ().diff (order, dim);
     }
 
   return retval;
 }
 
 DEFUN (diff, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} diff (@var{x}, @var{k}, @var{dim})\n\
-If @var{x} is a vector of length @var{n}, @code{diff (@var{x})} is the\n\
+@deftypefn  {Built-in Function} {} diff (@var{x})\n\
+@deftypefnx {Built-in Function} {} diff (@var{x}, @var{k})\n\
+@deftypefnx {Built-in Function} {} diff (@var{x}, @var{k}, @var{dim})\n\
+If @var{x} is a vector of length @math{n}, @code{diff (@var{x})} is the\n\
 vector of first differences\n\
 @tex\n\
  $x_2 - x_1, \\ldots{}, x_n - x_{n-1}$.\n\
 @end tex\n\
 @ifnottex\n\
  @var{x}(2) - @var{x}(1), @dots{}, @var{x}(n) - @var{x}(n-1).\n\
 @end ifnottex\n\
 \n\
 If @var{x} is a matrix, @code{diff (@var{x})} is the matrix of column\n\
 differences along the first non-singleton dimension.\n\
 \n\
 The second argument is optional.  If supplied, @code{diff (@var{x},\n\
 @var{k})}, where @var{k} is a non-negative integer, returns the\n\
 @var{k}-th differences.  It is possible that @var{k} is larger than\n\
-then first non-singleton dimension of the matrix.  In this case,\n\
+the first non-singleton dimension of the matrix.  In this case,\n\
 @code{diff} continues to take the differences along the next\n\
 non-singleton dimension.\n\
 \n\
 The dimension along which to take the difference can be explicitly\n\
-stated with the optional variable @var{dim}.  In this case the \n\
+stated with the optional variable @var{dim}.  In this case the\n\
 @var{k}-th order differences are calculated along this dimension.\n\
 In the case where @var{k} exceeds @code{size (@var{x}, @var{dim})}\n\
-then an empty matrix is returned.\n\
+an empty matrix is returned.\n\
 @end deftypefn")
 {
   int nargin = args.length ();
   octave_value retval;
 
   if (nargin < 1 || nargin > 3)
     print_usage ();
   else if (! (args(0).is_numeric_type () || args(0).is_bool_type ()))
