# HG changeset patch
# User dbateman
# Date 1190747300 0
#      Tue Sep 25 19:08:20 2007 +0000
# Node ID be176b7e110aa72bf8b21f1a09c7381582ffa606
# Parent  1fcee6e2c4d36bd5285e57b85808666c3cf08c5e
[project @ 2007-09-25 19:08:19 by dbateman]

diff --git a/liboctave/CMatrix.cc b/liboctave/CMatrix.cc
--- a/liboctave/CMatrix.cc
+++ b/liboctave/CMatrix.cc
@@ -1686,19 +1686,21 @@ ComplexMatrix::utsolve (MatrixType &matt
 			solve_singularity_handler sing_handler,
 			bool calc_cond) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
-  if (nr == 0 || nc == 0 || nr != b.rows ())
+  if (nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
+  else if (nr == 0 || nc == 0 || b.cols () == 0)
+    retval = ComplexMatrix (nc, b.cols (), Complex (0.0, 0.0));
   else
     {
       volatile int typ = mattype.type ();
 
       if (typ == MatrixType::Permuted_Upper ||
 	  typ == MatrixType::Upper)
 	{
 	  octave_idx_type b_nc = b.cols ();
@@ -1793,19 +1795,21 @@ ComplexMatrix::ltsolve (MatrixType &matt
 			solve_singularity_handler sing_handler,
 			bool calc_cond) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
-  if (nr == 0 || nc == 0 || nr != b.rows ())
+  if (nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
+  else if (nr == 0 || nc == 0 || b.cols () == 0)
+    retval = ComplexMatrix (nc, b.cols (), Complex (0.0, 0.0));
   else
     {
       volatile int typ = mattype.type ();
 
       if (typ == MatrixType::Permuted_Lower ||
 	  typ == MatrixType::Lower)
 	{
 	  octave_idx_type b_nc = b.cols ();
@@ -1900,19 +1904,22 @@ ComplexMatrix::fsolve (MatrixType &matty
 		       solve_singularity_handler sing_handler,
 		       bool calc_cond) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
-  if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
+
+  if (nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
-      ("matrix dimension mismatch in solution of linear equations");
+      ("matrix dimension mismatch solution of linear equations");
+  else if (nr == 0 || b.cols () == 0)
+    retval = ComplexMatrix (nc, b.cols (), Complex (0.0, 0.0));
   else
     {
       volatile int typ = mattype.type ();
  
      // Calculate the norm of the matrix, for later use.
       double anorm = -1.;
 
       if (typ == MatrixType::Hermitian)
@@ -2417,19 +2424,21 @@ ComplexMatrix::lssolve (const ComplexMat
 {
   ComplexMatrix retval;
 
   octave_idx_type nrhs = b.cols ();
 
   octave_idx_type m = rows ();
   octave_idx_type n = cols ();
 
-  if (m == 0 || n == 0 || m != b.rows ())
+  if (m != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
+  else if (m== 0 || n == 0 || b.cols () == 0)
+    retval = ComplexMatrix (n, b.cols (), Complex (0.0, 0.0));
   else
     {
       ComplexMatrix atmp = *this;
       Complex *tmp_data = atmp.fortran_vec ();
 
       octave_idx_type nrr = m > n ? m : n;
       ComplexMatrix result (nrr, nrhs);
 
@@ -2531,19 +2540,21 @@ ComplexMatrix::lssolve (const ComplexCol
 {
   ComplexColumnVector retval;
 
   octave_idx_type nrhs = 1;
 
   octave_idx_type m = rows ();
   octave_idx_type n = cols ();
 
-  if (m == 0 || n == 0 || m != b.length ())
+  if (m != b.length ())
     (*current_liboctave_error_handler)
-      ("matrix dimension mismatch solution of least squares problem");
+      ("matrix dimension mismatch solution of linear equations");
+  else if (m == 0 || n == 0 || b.cols () == 0)
+    retval = ComplexColumnVector (n, Complex (0.0, 0.0));
   else
     {
       ComplexMatrix atmp = *this;
       Complex *tmp_data = atmp.fortran_vec ();
 
       octave_idx_type nrr = m > n ? m : n;
       ComplexColumnVector result (nrr);
 
diff --git a/liboctave/CSparse.cc b/liboctave/CSparse.cc
--- a/liboctave/CSparse.cc
+++ b/liboctave/CSparse.cc
@@ -1207,19 +1207,21 @@ SparseComplexMatrix::dsolve (MatrixType 
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc < nr ? nc : nr);
   err = 0;
 
-  if (nr == 0 || nc == 0 || nr != b.rows ())
+  if (nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
+  else if (nr == 0 || nc == 0 || b.cols () == 0)
+    retval = ComplexMatrix (nc, b.cols (), Complex (0.0, 0.0));
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
       if (typ == MatrixType::Diagonal ||
 	  typ == MatrixType::Permuted_Diagonal)
@@ -1266,19 +1268,21 @@ SparseComplexMatrix::dsolve (MatrixType 
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc < nr ? nc : nr);
   err = 0;
 
-  if (nr == 0 || nc == 0 || nr != b.rows ())
+  if (nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
+  else if (nr == 0 || nc == 0 || b.cols () == 0)
+    retval = SparseComplexMatrix (nc, b.cols ());
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
       if (typ == MatrixType::Diagonal ||
 	  typ == MatrixType::Permuted_Diagonal)
@@ -1355,19 +1359,21 @@ SparseComplexMatrix::dsolve (MatrixType 
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc < nr ? nc : nr);
   err = 0;
 
-  if (nr == 0 || nc == 0 || nr != b.rows ())
+  if (nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
+  else if (nr == 0 || nc == 0 || b.cols () == 0)
+    retval = ComplexMatrix (nc, b.cols (), Complex (0.0, 0.0));
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
       if (typ == MatrixType::Diagonal ||
 	  typ == MatrixType::Permuted_Diagonal)
@@ -1414,19 +1420,21 @@ SparseComplexMatrix::dsolve (MatrixType 
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc < nr ? nc : nr);
   err = 0;
 
-  if (nr == 0 || nc == 0 || nr != b.rows ())
+  if (nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
+  else if (nr == 0 || nc == 0 || b.cols () == 0)
+    retval = SparseComplexMatrix (nc, b.cols ());
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
       if (typ == MatrixType::Diagonal ||
 	  typ == MatrixType::Permuted_Diagonal)
@@ -1503,19 +1511,21 @@ SparseComplexMatrix::utsolve (MatrixType
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc > nr ? nc : nr);
   err = 0;
 
-  if (nr == 0 || nc == 0 || nr != b.rows ())
+  if (nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
+  else if (nr == 0 || nc == 0 || b.cols () == 0)
+    retval = ComplexMatrix (nc, b.cols (), Complex (0.0, 0.0));
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
       if (typ == MatrixType::Permuted_Upper ||
 	  typ == MatrixType::Upper)
@@ -1737,19 +1747,21 @@ SparseComplexMatrix::utsolve (MatrixType
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc > nr ? nc : nr);
   err = 0;
 
-  if (nr == 0 || nc == 0 || nr != b.rows ())
+  if (nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
+  else if (nr == 0 || nc == 0 || b.cols () == 0)
+    retval = SparseComplexMatrix (nc, b.cols ());
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
       if (typ == MatrixType::Permuted_Upper ||
 	  typ == MatrixType::Upper)
@@ -2022,19 +2034,21 @@ SparseComplexMatrix::utsolve (MatrixType
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc > nr ? nc : nr);
   err = 0;
 
-  if (nr == 0 || nc == 0 || nr != b.rows ())
+  if (nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
+  else if (nr == 0 || nc == 0 || b.cols () == 0)
+    retval = ComplexMatrix (nc, b.cols (), Complex (0.0, 0.0));
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
       
       if (typ == MatrixType::Permuted_Upper ||
 	  typ == MatrixType::Upper)
@@ -2256,19 +2270,21 @@ SparseComplexMatrix::utsolve (MatrixType
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc > nr ? nc : nr);
   err = 0;
 
-  if (nr == 0 || nc == 0 || nr != b.rows ())
+  if (nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
+  else if (nr == 0 || nc == 0 || b.cols () == 0)
+    retval = SparseComplexMatrix (nc, b.cols ());
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
       
       if (typ == MatrixType::Permuted_Upper ||
 	  typ == MatrixType::Upper)
@@ -2542,19 +2558,21 @@ SparseComplexMatrix::ltsolve (MatrixType
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc > nr ? nc : nr);
   err = 0;
 
-  if (nr == 0 || nc == 0 || nr != b.rows ())
+  if (nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
+  else if (nr == 0 || nc == 0 || b.cols () == 0)
+    retval = ComplexMatrix (nc, b.cols (), Complex (0.0, 0.0));
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
       
       if (typ == MatrixType::Permuted_Lower ||
 	  typ == MatrixType::Lower)
@@ -2797,19 +2815,21 @@ SparseComplexMatrix::ltsolve (MatrixType
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc > nr ? nc : nr);
 
   err = 0;
 
-  if (nr == 0 || nc == 0 || nr != b.rows ())
+  if (nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
+  else if (nr == 0 || nc == 0 || b.cols () == 0)
+    retval = SparseComplexMatrix (nc, b.cols ());
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
       
       if (typ == MatrixType::Permuted_Lower ||
 	  typ == MatrixType::Lower)
@@ -3102,19 +3122,21 @@ SparseComplexMatrix::ltsolve (MatrixType
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc > nr ? nc : nr);
   err = 0;
 
-  if (nr == 0 || nc == 0 || nr != b.rows ())
+  if (nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
+  else if (nr == 0 || nc == 0 || b.cols () == 0)
+    retval = ComplexMatrix (nc, b.cols (), Complex (0.0, 0.0));
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
       
       if (typ == MatrixType::Permuted_Lower ||
 	  typ == MatrixType::Lower)
@@ -3360,19 +3382,21 @@ SparseComplexMatrix::ltsolve (MatrixType
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc > nr ? nc : nr);
   err = 0;
 
-  if (nr == 0 || nc == 0 || nr != b.rows ())
+  if (nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
+  else if (nr == 0 || nc == 0 || b.cols () == 0)
+    retval = SparseComplexMatrix (nc, b.cols ());
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
       
       if (typ == MatrixType::Permuted_Lower ||
 	  typ == MatrixType::Lower)
@@ -3664,19 +3688,21 @@ SparseComplexMatrix::trisolve (MatrixTyp
 			       bool calc_cond) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   err = 0;
 
-  if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
+  if (nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
+  else if (nr == 0 || b.cols () == 0)
+    retval = ComplexMatrix (nc, b.cols (), Complex (0.0, 0.0));
   else if (calc_cond)
     (*current_liboctave_error_handler) 
       ("calculation of condition number not implemented");
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
       mattype.info ();
@@ -3819,19 +3845,21 @@ SparseComplexMatrix::trisolve (MatrixTyp
 			       bool calc_cond) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   err = 0;
 
-  if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
+  if (nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
+  else if (nr == 0 || b.cols () == 0)
+    retval = SparseComplexMatrix (nc, b.cols ());
   else if (calc_cond)
     (*current_liboctave_error_handler) 
       ("calculation of condition number not implemented");
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
@@ -3977,19 +4005,21 @@ SparseComplexMatrix::trisolve (MatrixTyp
 			       bool calc_cond) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   err = 0;
 
-  if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
+  if (nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
+  else if (nr == 0 || b.cols () == 0)
+    retval = ComplexMatrix (nc, b.cols (), Complex (0.0, 0.0));
   else if (calc_cond)
     (*current_liboctave_error_handler) 
       ("calculation of condition number not implemented");
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
       mattype.info ();
@@ -4140,19 +4170,21 @@ SparseComplexMatrix::trisolve (MatrixTyp
 			       bool calc_cond) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   err = 0;
 
-  if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
+  if (nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
+  else if (nr == 0 || b.cols () == 0)
+    retval = SparseComplexMatrix (nc, b.cols ());
   else if (calc_cond)
     (*current_liboctave_error_handler) 
       ("calculation of condition number not implemented");
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
@@ -4309,19 +4341,21 @@ SparseComplexMatrix::bsolve (MatrixType 
 			     bool calc_cond) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   err = 0;
 
-  if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
+  if (nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
+  else if (nr == 0 || b.cols () == 0)
+    retval = ComplexMatrix (nc, b.cols (), Complex (0.0, 0.0));
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
       mattype.info ();
 
       if (typ == MatrixType::Banded_Hermitian)
 	{
@@ -4583,19 +4617,21 @@ SparseComplexMatrix::bsolve (MatrixType 
 			     bool calc_cond) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   err = 0;
 
-  if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
+  if (nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
+  else if (nr == 0 || b.cols () == 0)
+    retval = SparseComplexMatrix (nc, b.cols ());
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
       mattype.info ();
 
       if (typ == MatrixType::Banded_Hermitian)
 	{
@@ -4934,19 +4970,21 @@ SparseComplexMatrix::bsolve (MatrixType 
 			     bool calc_cond) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   err = 0;
 
-  if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
+  if (nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
+  else if (nr == 0 || b.cols () == 0)
+    retval = ComplexMatrix (nc, b.cols (), Complex (0.0, 0.0));
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
       mattype.info ();
 
       if (typ == MatrixType::Banded_Hermitian)
 	{
@@ -5211,19 +5249,21 @@ SparseComplexMatrix::bsolve (MatrixType 
 			     bool calc_cond) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   err = 0;
 
-  if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
+  if (nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
+  else if (nr == 0 || b.cols () == 0)
+    retval = SparseComplexMatrix (nc, b.cols ());
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
       mattype.info ();
 
       if (typ == MatrixType::Banded_Hermitian)
 	{
@@ -5687,19 +5727,21 @@ SparseComplexMatrix::fsolve (MatrixType 
 			     bool calc_cond) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   err = 0;
 
-  if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
+  if (nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
+  else if (nr == 0 || b.cols () == 0)
+    retval = ComplexMatrix (nc, b.cols (), Complex (0.0, 0.0));
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
       mattype.info ();
 
       if (typ == MatrixType::Hermitian)
 	{
@@ -5945,19 +5987,21 @@ SparseComplexMatrix::fsolve (MatrixType 
 			     bool calc_cond) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   err = 0;
 
-  if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
+  if (nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
+  else if (nr == 0 || b.cols () == 0)
+    retval = SparseComplexMatrix (nc, b.cols ());
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
       mattype.info ();
 
       if (typ == MatrixType::Hermitian)
 	{
@@ -6254,19 +6298,21 @@ SparseComplexMatrix::fsolve (MatrixType 
 			     bool calc_cond) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   err = 0;
 
-  if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
+  if (nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
+  else if (nr == 0 || b.cols () == 0)
+    retval = ComplexMatrix (nc, b.cols (), Complex (0.0, 0.0));
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
       mattype.info ();
 
       if (typ == MatrixType::Hermitian)
 	{
@@ -6494,19 +6540,21 @@ SparseComplexMatrix::fsolve (MatrixType 
 			     bool calc_cond) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   err = 0;
 
-  if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
+  if (nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
+  else if (nr == 0 || b.cols () == 0)
+    retval = SparseComplexMatrix (nc, b.cols ());
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
       mattype.info ();
 
       if (typ == MatrixType::Hermitian)
 	{
diff --git a/liboctave/ChangeLog b/liboctave/ChangeLog
--- a/liboctave/ChangeLog
+++ b/liboctave/ChangeLog
@@ -1,8 +1,22 @@
+2007-09-25  David Bateman  <dbateman@free.fr>
+
+	* dMatrix.cc (utsolve, ltsolve, fsolve, lssolve): Allow
+	zero dimensioned matrices.
+        * CMatrix.cc (utsolve, ltsolve, fsolve, lssolve): ditto.
+	* dSparse.cc (dsolve, utsolve, ltsolve, bsolve, trisolve, fsolve):
+	ditto.
+	* CSparse.cc (dsolve, utsolve, ltsolve, bsolve, trisolve, fsolve):
+	ditto.
+	* SparseQR.cc (SparseQR::SparseQR_rep::C, qrsolve): ditto.
+	* SparseCmplxQR.cc (SparseComplexQR::SparseComplexQR_rep::C,
+	qrsolve): ditto.
+	* sparse-dmsolve.cc (dmsolve): ditto.
+
 2007-09-21  John W. Eaton  <jwe@octave.org>
 
 	* Array.cc (assign1 (Array<LT>&, const Array<RT>&, const LT&)):
 	Also allow resizing empty LHS if it is 1x0 or 0xN.
 
 2007-09-19  John W. Eaton  <jwe@octave.org>
 
 	* cmd-edit.cc (command_editor::remove_startup_hook):
diff --git a/liboctave/SparseCmplxQR.cc b/liboctave/SparseCmplxQR.cc
--- a/liboctave/SparseCmplxQR.cc
+++ b/liboctave/SparseCmplxQR.cc
@@ -185,20 +185,22 @@ SparseComplexQR::SparseComplexQR_rep::C 
 {
 #ifdef HAVE_CXSPARSE
   octave_idx_type b_nr = b.rows();
   octave_idx_type b_nc = b.cols();
   octave_idx_type nc = N->L->n;
   octave_idx_type nr = nrows;
   const cs_complex_t *bvec = 
     reinterpret_cast<const cs_complex_t *>(b.fortran_vec());
-  ComplexMatrix ret(b_nr,b_nc);
+  ComplexMatrix ret(b_nr, b_nc);
   Complex *vec = ret.fortran_vec();
-  if (nr < 1 || nc < 1 || nr != b_nr)
+  if (nr < 0 || nc < 0 || nr != b_nr)
     (*current_liboctave_error_handler) ("matrix dimension mismatch");
+  else if (nr == 0 || nc == 0 || b_nc == 0)
+    ret = ComplexMatrix (nc, b_nc, Complex (0.0, 0.0));
   else
     {
       OCTAVE_LOCAL_BUFFER (Complex, buf, S->m2);
       for (volatile octave_idx_type j = 0, idx = 0; j < b_nc; j++, idx+=b_nr)
 	{
 	  OCTAVE_QUIT;
 	  volatile octave_idx_type nm = (nr < nc ? nr : nc);
 	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
@@ -234,19 +236,21 @@ qrsolve(const SparseComplexMatrix&a, con
   info = -1;
 #ifdef HAVE_CXSPARSE
   octave_idx_type nr = a.rows();
   octave_idx_type nc = a.cols();
   octave_idx_type b_nc = b.cols();
   octave_idx_type b_nr = b.rows();
   ComplexMatrix x;
 
-  if (nr < 1 || nc < 1 || nr != b_nr)
+  if (nr < 0 || nc < 0 || nr != b_nr)
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch in solution of minimum norm problem");
+  else if (nr == 0 || nc == 0 || b_nc == 0)
+    x = ComplexMatrix (nc, b_nc, Complex (0.0, 0.0));
   else if (nr >= nc)
     {
       SparseComplexQR q (a, 2);
       if (! q.ok ())
 	return ComplexMatrix();
       x.resize(nc, b_nc);
       cs_complex_t *vec = reinterpret_cast<cs_complex_t *>
 	(x.fortran_vec());
@@ -361,19 +365,21 @@ qrsolve(const SparseComplexMatrix&a, con
 #ifdef HAVE_CXSPARSE
   octave_idx_type nr = a.rows();
   octave_idx_type nc = a.cols();
   octave_idx_type b_nc = b.cols();
   octave_idx_type b_nr = b.rows();
   SparseComplexMatrix x;
   volatile octave_idx_type ii, x_nz;
 
-  if (nr < 1 || nc < 1 || nr != b_nr)
+  if (nr < 0 || nc < 0 || nr != b_nr)
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch in solution of minimum norm problem");
+  else if (nr == 0 || nc == 0 || b_nc == 0)
+    x = SparseComplexMatrix (nc, b_nc);
   else if (nr >= nc)
     {
       SparseComplexQR q (a, 2);
       if (! q.ok ())
 	return SparseComplexMatrix();
       x = SparseComplexMatrix (nc, b_nc, b.nzmax());
       x.xcidx(0) = 0;
       x_nz = b.nzmax();
@@ -534,19 +540,21 @@ qrsolve(const SparseComplexMatrix&a, con
   octave_idx_type nr = a.rows();
   octave_idx_type nc = a.cols();
   octave_idx_type b_nc = b.cols();
   octave_idx_type b_nr = b.rows();
   const cs_complex_t *bvec = 
     reinterpret_cast<const cs_complex_t *>(b.fortran_vec());
   ComplexMatrix x;
 
-  if (nr < 1 || nc < 1 || nr != b_nr)
+  if (nr < 0 || nc < 0 || nr != b_nr)
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch in solution of minimum norm problem");
+  else if (nr == 0 || nc == 0 || b_nc == 0)
+    x = ComplexMatrix (nc, b_nc, Complex (0.0, 0.0));
   else if (nr >= nc)
     {
       SparseComplexQR q (a, 2);
       if (! q.ok ())
 	return ComplexMatrix();
       x.resize(nc, b_nc);
       cs_complex_t *vec = reinterpret_cast<cs_complex_t *>
 	(x.fortran_vec());
@@ -652,19 +660,21 @@ qrsolve(const SparseComplexMatrix&a, con
 #ifdef HAVE_CXSPARSE
   octave_idx_type nr = a.rows();
   octave_idx_type nc = a.cols();
   octave_idx_type b_nc = b.cols();
   octave_idx_type b_nr = b.rows();
   SparseComplexMatrix x;
   volatile octave_idx_type ii, x_nz;
 
-  if (nr < 1 || nc < 1 || nr != b_nr)
+  if (nr < 0 || nc < 0 || nr != b_nr)
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch in solution of minimum norm problem");
+  else if (nr == 0 || nc == 0 || b_nc == 0)
+    x = SparseComplexMatrix (nc, b_nc);
   else if (nr >= nc)
     {
       SparseComplexQR q (a, 2);
       if (! q.ok ())
 	return SparseComplexMatrix();
       x = SparseComplexMatrix (nc, b_nc, b.nzmax());
       x.xcidx(0) = 0;
       x_nz = b.nzmax();
diff --git a/liboctave/SparseQR.cc b/liboctave/SparseQR.cc
--- a/liboctave/SparseQR.cc
+++ b/liboctave/SparseQR.cc
@@ -168,20 +168,22 @@ Matrix
 SparseQR::SparseQR_rep::C (const Matrix &b) const
 {
 #ifdef HAVE_CXSPARSE
   octave_idx_type b_nr = b.rows();
   octave_idx_type b_nc = b.cols();
   octave_idx_type nc = N->L->n;
   octave_idx_type nr = nrows;
   const double *bvec = b.fortran_vec();
-  Matrix ret(b_nr,b_nc);
+  Matrix ret (b_nr, b_nc);
   double *vec = ret.fortran_vec();
-  if (nr < 1 || nc < 1 || nr != b_nr)
+  if (nr < 0 || nc < 0 || nr != b_nr)
     (*current_liboctave_error_handler) ("matrix dimension mismatch");
+  else if (nr == 0 || nc == 0 || b_nc == 0)
+    ret = Matrix (nc, b_nc, 0.0);
   else
     {
       OCTAVE_LOCAL_BUFFER (double, buf, S->m2);
       for (volatile octave_idx_type j = 0, idx = 0; j < b_nc; j++, idx+=b_nr)
 	{
 	  OCTAVE_QUIT;
 	  for (octave_idx_type i = nr; i < S->m2; i++)
 	    buf[i] = 0.;
@@ -218,19 +220,21 @@ qrsolve(const SparseMatrix&a, const Matr
 #ifdef HAVE_CXSPARSE
   octave_idx_type nr = a.rows();
   octave_idx_type nc = a.cols();
   octave_idx_type b_nc = b.cols();
   octave_idx_type b_nr = b.rows();
   const double *bvec = b.fortran_vec();
   Matrix x;
 
-  if (nr < 1 || nc < 1 || nr != b_nr)
+  if (nr < 0 || nc < 0 || nr != b_nr)
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch in solution of minimum norm problem");
+  else if (nr == 0 || nc == 0 || b_nc == 0)
+    x = Matrix (nc, b_nc, 0.0);
   else if (nr >= nc)
     {
       SparseQR q (a, 3);
       if (! q.ok ()) 
 	return Matrix();
       x.resize(nc, b_nc);
       double *vec = x.fortran_vec();
       OCTAVE_LOCAL_BUFFER (double, buf, q.S()->m2);
@@ -320,19 +324,21 @@ qrsolve(const SparseMatrix&a, const Spar
 #ifdef HAVE_CXSPARSE
   octave_idx_type nr = a.rows();
   octave_idx_type nc = a.cols();
   octave_idx_type b_nr = b.rows();
   octave_idx_type b_nc = b.cols();
   SparseMatrix x;
   volatile octave_idx_type ii, x_nz;
 
-  if (nr < 1 || nc < 1 || nr != b_nr)
+  if (nr < 0 || nc < 0 || nr != b_nr)
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch in solution of minimum norm problem");
+  else if (nr == 0 || nc == 0 || b_nc == 0)
+    x = SparseMatrix (nc, b_nc);
   else if (nr >= nc)
     {
       SparseQR q (a, 3);
       if (! q.ok ()) 
 	return SparseMatrix();
       x = SparseMatrix (nc, b_nc, b.nzmax());
       x.xcidx(0) = 0;
       x_nz = b.nzmax();
@@ -468,19 +474,21 @@ qrsolve(const SparseMatrix&a, const Comp
   info = -1;
 #ifdef HAVE_CXSPARSE
   octave_idx_type nr = a.rows();
   octave_idx_type nc = a.cols();
   octave_idx_type b_nc = b.cols();
   octave_idx_type b_nr = b.rows();
   ComplexMatrix x;
 
-  if (nr < 1 || nc < 1 || nr != b_nr)
+  if (nr < 0 || nc < 0 || nr != b_nr)
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch in solution of minimum norm problem");
+  else if (nr == 0 || nc == 0 || b_nc == 0)
+    x = ComplexMatrix (nc, b_nc, Complex (0.0, 0.0));
   else if (nr >= nc)
     {
       SparseQR q (a, 3);
       if (! q.ok ())
 	return ComplexMatrix();
       x.resize(nc, b_nc);
       Complex *vec = x.fortran_vec();
       OCTAVE_LOCAL_BUFFER (double, Xx, (b_nr > nc ? b_nr : nc));
@@ -634,19 +642,21 @@ qrsolve(const SparseMatrix&a, const Spar
 #ifdef HAVE_CXSPARSE
   octave_idx_type nr = a.rows();
   octave_idx_type nc = a.cols();
   octave_idx_type b_nr = b.rows();
   octave_idx_type b_nc = b.cols();
   SparseComplexMatrix x;
   volatile octave_idx_type ii, x_nz;
 
-  if (nr < 1 || nc < 1 || nr != b_nr)
+  if (nr < 0 || nc < 0 || nr != b_nr)
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch in solution of minimum norm problem");
+  else if (nr == 0 || nc == 0 || b_nc == 0)
+    x = SparseComplexMatrix (nc, b_nc);
   else if (nr >= nc)
     {
       SparseQR q (a, 3);
       if (! q.ok ()) 
 	return SparseComplexMatrix();
       x = SparseComplexMatrix (nc, b_nc, b.nzmax());
       x.xcidx(0) = 0;
       x_nz = b.nzmax();
diff --git a/liboctave/dMatrix.cc b/liboctave/dMatrix.cc
--- a/liboctave/dMatrix.cc
+++ b/liboctave/dMatrix.cc
@@ -1348,19 +1348,21 @@ Matrix::utsolve (MatrixType &mattype, co
 		double& rcond, solve_singularity_handler sing_handler,
 		bool calc_cond) const
 {
   Matrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
-  if (nr == 0 || nc == 0 || nr != b.rows ())
+  if (nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
+  else if (nr == 0 || nc == 0 || b.cols () == 0)
+    retval = Matrix (nc, b.cols (), 0.0);
   else
     {
       volatile int typ = mattype.type ();
 
       if (typ == MatrixType::Permuted_Upper ||
 	  typ == MatrixType::Upper)
 	{
 	  octave_idx_type b_nc = b.cols ();
@@ -1454,19 +1456,21 @@ Matrix::ltsolve (MatrixType &mattype, co
 		double& rcond, solve_singularity_handler sing_handler,
 		bool calc_cond) const
 {
   Matrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
-  if (nr == 0 || nc == 0 || nr != b.rows ())
+  if (nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
+  else if (nr == 0 || nc == 0 || b.cols () == 0)
+    retval = Matrix (nc, b.cols (), 0.0);
   else
     {
       volatile int typ = mattype.type ();
 
       if (typ == MatrixType::Permuted_Lower ||
 	  typ == MatrixType::Lower)
 	{
 	  octave_idx_type b_nc = b.cols ();
@@ -1560,19 +1564,21 @@ Matrix::fsolve (MatrixType &mattype, con
 		double& rcond, solve_singularity_handler sing_handler,
 		bool calc_cond) const
 {
   Matrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
-  if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
+  if (nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
+  else if (nr == 0 || b.cols () == 0)
+    retval = Matrix (nc, b.cols (), 0.0);
   else
     {
       volatile int typ = mattype.type ();
  
      // Calculate the norm of the matrix, for later use.
       double anorm = -1.;
 
       if (typ == MatrixType::Hermitian)
@@ -2041,19 +2047,22 @@ Matrix::lssolve (const Matrix& b, octave
 {
   Matrix retval;
 
   octave_idx_type nrhs = b.cols ();
 
   octave_idx_type m = rows ();
   octave_idx_type n = cols ();
 
-  if (m == 0 || n == 0 || m != b.rows ())
+
+  if (m != b.rows ())
     (*current_liboctave_error_handler)
-      ("matrix dimension mismatch in solution of least squares problem");
+      ("matrix dimension mismatch solution of linear equations");
+  else if (m == 0 || n == 0 || b.cols () == 0)
+    retval = Matrix (n, b.cols (), 0.0);
   else
     {
       Matrix atmp = *this;
       double *tmp_data = atmp.fortran_vec ();
 
       octave_idx_type nrr = m > n ? m : n;
       Matrix result (nrr, nrhs, 0.0);
 
@@ -2150,19 +2159,21 @@ Matrix::lssolve (const ColumnVector& b, 
 {
   ColumnVector retval;
 
   octave_idx_type nrhs = 1;
 
   octave_idx_type m = rows ();
   octave_idx_type n = cols ();
 
-  if (m == 0 || n == 0 || m != b.length ())
+  if (m != b.length ())
     (*current_liboctave_error_handler)
-      ("matrix dimension mismatch in solution of least squares problem");
+      ("matrix dimension mismatch solution of linear equations");
+  else if (m == 0 || n == 0)
+    retval = ColumnVector (n, 0.0);
   else
     {
       Matrix atmp = *this;
       double *tmp_data = atmp.fortran_vec ();
 
       octave_idx_type nrr = m > n ? m : n;
       ColumnVector result (nrr);
 
diff --git a/liboctave/dSparse.cc b/liboctave/dSparse.cc
--- a/liboctave/dSparse.cc
+++ b/liboctave/dSparse.cc
@@ -1273,19 +1273,21 @@ SparseMatrix::dsolve (MatrixType &mattyp
 {
   Matrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc < nr ? nc : nr);
   err = 0;
 
-  if (nr == 0 || nc == 0 || nr != b.rows ())
+  if (nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
+  else if (nr == 0 || nc == 0 || b.cols () == 0)
+    retval = Matrix (nc, b.cols (), 0.0);
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
       if (typ == MatrixType::Diagonal ||
 	  typ == MatrixType::Permuted_Diagonal)
@@ -1331,19 +1333,21 @@ SparseMatrix::dsolve (MatrixType &mattyp
 {
   SparseMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc < nr ? nc : nr);
   err = 0;
 
-  if (nr == 0 || nc == 0 || nr != b.rows ())
+  if (nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
+  else if (nr == 0 || nc == 0 || b.cols () == 0)
+    retval = SparseMatrix (nc, b.cols ());
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
       if (typ == MatrixType::Diagonal ||
 	  typ == MatrixType::Permuted_Diagonal)
@@ -1419,19 +1423,21 @@ SparseMatrix::dsolve (MatrixType &mattyp
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc < nr ? nc : nr);
   err = 0;
 
-  if (nr == 0 || nc == 0 || nr != b.rows ())
+  if (nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
+  else if (nr == 0 || nc == 0 || b.cols () == 0)
+    retval = ComplexMatrix (nc, b.cols (), Complex (0.0, 0.0));
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
       if (typ == MatrixType::Diagonal ||
 	  typ == MatrixType::Permuted_Diagonal)
@@ -1477,19 +1483,21 @@ SparseMatrix::dsolve (MatrixType &mattyp
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc < nr ? nc : nr);
   err = 0;
 
-  if (nr == 0 || nc == 0 || nr != b.rows ())
+  if (nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
+  else if (nr == 0 || nc == 0 || b.cols () == 0)
+    retval = SparseComplexMatrix (nc, b.cols ());
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
       if (typ == MatrixType::Diagonal ||
 	  typ == MatrixType::Permuted_Diagonal)
@@ -1566,19 +1574,21 @@ SparseMatrix::utsolve (MatrixType &matty
 {
   Matrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc > nr ? nc : nr);
   err = 0;
 
-  if (nr == 0 || nc == 0 || nr != b.rows ())
+  if (nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
+  else if (nr == 0 || nc == 0 || b.cols () == 0)
+    retval = Matrix (nc, b.cols (), 0.0);
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
       if (typ == MatrixType::Permuted_Upper ||
 	  typ == MatrixType::Upper)
@@ -1799,19 +1809,21 @@ SparseMatrix::utsolve (MatrixType &matty
 {
   SparseMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc > nr ? nc : nr);
   err = 0;
 
-  if (nr == 0 || nc == 0 || nr != b.rows ())
+  if (nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
+  else if (nr == 0 || nc == 0 || b.cols () == 0)
+    retval = SparseMatrix (nc, b.cols ());
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
       if (typ == MatrixType::Permuted_Upper ||
 	  typ == MatrixType::Upper)
@@ -2084,19 +2096,21 @@ SparseMatrix::utsolve (MatrixType &matty
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc > nr ? nc : nr);
   err = 0;
 
-  if (nr == 0 || nc == 0 || nr != b.rows ())
+  if (nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
+  else if (nr == 0 || nc == 0 || b.cols () == 0)
+    retval = ComplexMatrix (nc, b.cols (), Complex (0.0, 0.0));
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
       
       if (typ == MatrixType::Permuted_Upper ||
 	  typ == MatrixType::Upper)
@@ -2320,19 +2334,21 @@ SparseMatrix::utsolve (MatrixType &matty
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc > nr ? nc : nr);
   err = 0;
 
-  if (nr == 0 || nc == 0 || nr != b.rows ())
+  if (nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
+  else if (nr == 0 || nc == 0 || b.cols () == 0)
+    retval = SparseComplexMatrix (nc, b.cols ());
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
       
       if (typ == MatrixType::Permuted_Upper ||
 	  typ == MatrixType::Upper)
@@ -2608,19 +2624,21 @@ SparseMatrix::ltsolve (MatrixType &matty
 {
   Matrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc > nr ? nc : nr);
   err = 0;
 
-  if (nr == 0 || nc == 0 || nr != b.rows ())
+  if (nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
+  else if (nr == 0 || nc == 0 || b.cols () == 0)
+    retval = Matrix (nc, b.cols (), 0.0);
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
       
       if (typ == MatrixType::Permuted_Lower ||
 	  typ == MatrixType::Lower)
@@ -2866,19 +2884,21 @@ SparseMatrix::ltsolve (MatrixType &matty
 {
   SparseMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc > nr ? nc : nr);
   err = 0;
 
-  if (nr == 0 || nc == 0 || nr != b.rows ())
+  if (nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
+  else if (nr == 0 || nc == 0 || b.cols () == 0)
+    retval = SparseMatrix (nc, b.cols ());
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
       
       if (typ == MatrixType::Permuted_Lower ||
 	  typ == MatrixType::Lower)
@@ -3171,19 +3191,21 @@ SparseMatrix::ltsolve (MatrixType &matty
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc > nr ? nc : nr);
   err = 0;
 
-  if (nr == 0 || nc == 0 || nr != b.rows ())
+  if (nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
+  else if (nr == 0 || nc == 0 || b.cols () == 0)
+    retval = ComplexMatrix (nc, b.cols (), Complex (0.0, 0.0));
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
       
       if (typ == MatrixType::Permuted_Lower ||
 	  typ == MatrixType::Lower)
@@ -3430,19 +3452,21 @@ SparseMatrix::ltsolve (MatrixType &matty
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc > nr ? nc : nr);
   err = 0;
 
-  if (nr == 0 || nc == 0 || nr != b.rows ())
+  if (nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
+  else if (nr == 0 || nc == 0 || b.cols () == 0)
+    retval = SparseComplexMatrix (nc, b.cols ());
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
       
       if (typ == MatrixType::Permuted_Lower ||
 	  typ == MatrixType::Lower)
@@ -3736,19 +3760,21 @@ SparseMatrix::trisolve (MatrixType &matt
 			bool calc_cond) const
 {
   Matrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   err = 0;
 
-  if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
+  if (nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
+  else if (nr == 0 || b.cols () == 0)
+    retval = Matrix (nc, b.cols (), 0.0);
   else if (calc_cond)
     (*current_liboctave_error_handler) 
       ("calculation of condition number not implemented");
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
       mattype.info ();
@@ -3891,19 +3917,21 @@ SparseMatrix::trisolve (MatrixType &matt
 			bool calc_cond) const
 {
   SparseMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   err = 0;
 
-  if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
+  if (nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
+  else if (nr == 0 || b.cols () == 0)
+    retval = SparseMatrix (nc, b.cols ());
   else if (calc_cond)
     (*current_liboctave_error_handler) 
       ("calculation of condition number not implemented");
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
@@ -4049,19 +4077,21 @@ SparseMatrix::trisolve (MatrixType &matt
 			bool calc_cond) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   err = 0;
 
-  if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
+  if (nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
+  else if (nr == 0 || b.cols () == 0)
+    retval = ComplexMatrix (nc, b.cols (), Complex (0.0, 0.0));
   else if (calc_cond)
     (*current_liboctave_error_handler) 
       ("calculation of condition number not implemented");
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
       mattype.info ();
@@ -4211,19 +4241,21 @@ SparseMatrix::trisolve (MatrixType &matt
 			bool calc_cond) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   err = 0;
 
-  if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
+  if (nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
+  else if (nr == 0 || b.cols () == 0)
+    retval = SparseComplexMatrix (nc, b.cols ());
   else if (calc_cond)
     (*current_liboctave_error_handler) 
       ("calculation of condition number not implemented");
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
@@ -4408,19 +4440,21 @@ SparseMatrix::bsolve (MatrixType &mattyp
 		      bool calc_cond) const
 {
   Matrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   err = 0;
 
-  if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
+  if (nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
+  else if (nr == 0 || b.cols () == 0)
+    retval = Matrix (nc, b.cols (), 0.0);
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
       mattype.info ();
 
       if (typ == MatrixType::Banded_Hermitian)
 	{
@@ -4683,19 +4717,21 @@ SparseMatrix::bsolve (MatrixType &mattyp
 		      bool calc_cond) const
 {
   SparseMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   err = 0;
 
-  if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
+  if (nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
+  else if (nr == 0 || b.cols () == 0)
+    retval = SparseMatrix (nc, b.cols ());
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
       mattype.info ();
 
       if (typ == MatrixType::Banded_Hermitian)
 	{
@@ -5034,19 +5070,21 @@ SparseMatrix::bsolve (MatrixType &mattyp
 		      bool calc_cond) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   err = 0;
 
-  if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
+  if (nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
+  else if (nr == 0 || b.cols () == 0)
+    retval = ComplexMatrix (nc, b.cols (), Complex (0.0, 0.0));
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
       mattype.info ();
 
       if (typ == MatrixType::Banded_Hermitian)
 	{
@@ -5381,19 +5419,21 @@ SparseMatrix::bsolve (MatrixType &mattyp
 		      bool calc_cond) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   err = 0;
 
-  if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
+  if (nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
+  else if (nr == 0 || b.cols () == 0)
+    retval = SparseComplexMatrix (nc, b.cols ());
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
       mattype.info ();
 
       if (typ == MatrixType::Banded_Hermitian)
 	{
@@ -5903,19 +5943,21 @@ SparseMatrix::fsolve (MatrixType &mattyp
 		      bool calc_cond) const
 {
   Matrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   err = 0;
 
-  if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
+  if (nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
+  else if (nr == 0 || b.cols () == 0)
+    retval = Matrix (nc, b.cols (), 0.0);
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
       mattype.info ();
 
       if (typ == MatrixType::Hermitian)
 	{
@@ -6135,19 +6177,21 @@ SparseMatrix::fsolve (MatrixType &mattyp
 		      bool calc_cond) const
 {
   SparseMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   err = 0;
 
-  if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
+  if (nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
+  else if (nr == 0 || b.cols () == 0)
+    retval = SparseMatrix (nc, b.cols ());
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
       mattype.info ();
 
       if (typ == MatrixType::Hermitian)
 	{
@@ -6415,19 +6459,21 @@ SparseMatrix::fsolve (MatrixType &mattyp
 		      bool calc_cond) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   err = 0;
 
-  if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
+  if (nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
+  else if (nr == 0 || b.cols () == 0)
+    retval = ComplexMatrix (nc, b.cols (), Complex (0.0, 0.0));
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
       mattype.info ();
 
       if (typ == MatrixType::Hermitian)
 	{
@@ -6667,19 +6713,21 @@ SparseMatrix::fsolve (MatrixType &mattyp
 		      bool calc_cond) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   err = 0;
 
-  if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
+  if (nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
+  else if (nr == 0 || b.cols () == 0)
+    retval = SparseComplexMatrix (nc, b.cols ());
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
       mattype.info ();
 
       if (typ == MatrixType::Hermitian)
 	{
diff --git a/liboctave/sparse-dmsolve.cc b/liboctave/sparse-dmsolve.cc
--- a/liboctave/sparse-dmsolve.cc
+++ b/liboctave/sparse-dmsolve.cc
@@ -363,19 +363,21 @@ dmsolve (const ST &a, const T &b, octave
 {
 #ifdef HAVE_CXSPARSE
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
   octave_idx_type b_nr = b.rows ();
   octave_idx_type b_nc = b.cols ();
   RT retval;
 
-  if (nr < 1 || nc < 1 || nr != b_nr)
+  if (nr < 0 || nc < 0 || nr != b_nr)
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch in solution of minimum norm problem");
+  else if (nr == 0 || nc == 0 || b_nc == 0)
+    retval = RT (nc, b_nc, 0.0);
   else
     {
       octave_idx_type nnz_remaining = a.nnz ();
       CXSPARSE_DNAME () csm;
       csm.m = nr;
       csm.n = nc;
       csm.x = NULL;
       csm.nz = -1;
