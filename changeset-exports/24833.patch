# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1520087656 18000
#      Sat Mar 03 09:34:16 2018 -0500
# Node ID 7c88cf242111fc64eda1ed83f8c3f6ca55f78be5
# Parent  a16c810b77c8b0d5bafa78d48c6bc937b8a7a750
use m_ prefix for data members in more classes

* input.h, input.cc, comment-list.h, lex.h, lex.ll, profiler.h,
profiler.cc: Use m_ prefix for data members in classes.
Change all uses.

diff --git a/libinterp/corefcn/input.cc b/libinterp/corefcn/input.cc
--- a/libinterp/corefcn/input.cc
+++ b/libinterp/corefcn/input.cc
@@ -205,17 +205,17 @@ namespace octave
 
         octave_link::pre_input_event ();
 
         octave_link::set_workspace ();
       }
 
     bool history_skip_auto_repeated_debugging_command = false;
 
-    std::string ps = (pflag > 0) ? VPS1 : VPS2;
+    std::string ps = (m_pflag > 0) ? VPS1 : VPS2;
 
     std::string prompt = command_editor::decode_prompt_string (ps);
 
     pipe_handler_error_count = 0;
 
     flush_stdout ();
 
     pager_stream::reset ();
@@ -267,102 +267,102 @@ namespace octave
     if (application::interactive ())
       octave_link::post_input_event ();
 
     return retval;
   }
 
   bool base_reader::reading_fcn_file (void) const
   {
-    return lexer ? lexer->reading_fcn_file : false;
+    return m_lexer ? m_lexer->m_reading_fcn_file : false;
   }
 
   bool base_reader::reading_classdef_file (void) const
   {
-    return lexer ? lexer->reading_classdef_file : false;
+    return m_lexer ? m_lexer->m_reading_classdef_file : false;
   }
 
   bool base_reader::reading_script_file (void) const
   {
-    return lexer ? lexer->reading_script_file : false;
+    return m_lexer ? m_lexer->m_reading_script_file : false;
   }
 
   class
   terminal_reader : public base_reader
   {
   public:
 
     terminal_reader (base_lexer *lxr = nullptr)
       : base_reader (lxr)
     { }
 
     std::string get_input (bool& eof);
 
-    std::string input_source (void) const { return in_src; }
+    std::string input_source (void) const { return s_in_src; }
 
     bool input_from_terminal (void) const { return true; }
 
   private:
 
-    static const std::string in_src;
+    static const std::string s_in_src;
   };
 
   class
   file_reader : public base_reader
   {
   public:
 
     file_reader (FILE *f_arg, base_lexer *lxr = nullptr)
-      : base_reader (lxr), file (f_arg) { }
+      : base_reader (lxr), m_file (f_arg) { }
 
     std::string get_input (bool& eof);
 
-    std::string input_source (void) const { return in_src; }
+    std::string input_source (void) const { return s_in_src; }
 
     bool input_from_file (void) const { return true; }
 
   private:
 
-    FILE *file;
+    FILE *m_file;
 
-    static const std::string in_src;
+    static const std::string s_in_src;
   };
 
   class
   eval_string_reader : public base_reader
   {
   public:
 
     eval_string_reader (const std::string& str, base_lexer *lxr = nullptr)
-      : base_reader (lxr), eval_string (str)
+      : base_reader (lxr), m_eval_string (str)
     { }
 
     std::string get_input (bool& eof);
 
-    std::string input_source (void) const { return in_src; }
+    std::string input_source (void) const { return s_in_src; }
 
     bool input_from_eval_string (void) const { return true; }
 
   private:
 
-    std::string eval_string;
+    std::string m_eval_string;
 
-    static const std::string in_src;
+    static const std::string s_in_src;
   };
 
   input_reader::input_reader (base_lexer *lxr)
-    : rep (new terminal_reader (lxr))
+    : m_rep (new terminal_reader (lxr))
   { }
 
   input_reader::input_reader (FILE *file, base_lexer *lxr)
-    : rep (new file_reader (file, lxr))
+    : m_rep (new file_reader (file, lxr))
   { }
 
   input_reader::input_reader (const std::string& str, base_lexer *lxr)
-    : rep (new eval_string_reader (str, lxr))
+    : m_rep (new eval_string_reader (str, lxr))
   { }
 }
 
 // Fix things up so that input can come from the standard input.  This
 // may need to become much more complicated, which is why it's in a
 // separate function.
 
 FILE *
@@ -756,58 +756,58 @@ get_debug_input (octave::interpreter& in
           // Ignore errors when in debugging mode;
           octave::interpreter::recover_from_exception ();
         }
     }
 }
 
 namespace octave
 {
-  const std::string base_reader::in_src ("invalid");
+  const std::string base_reader::s_in_src ("invalid");
 
-  const std::string terminal_reader::in_src ("terminal");
+  const std::string terminal_reader::s_in_src ("terminal");
 
   std::string
   terminal_reader::get_input (bool& eof)
   {
     octave_quit ();
 
     eof = false;
 
     return octave_gets (eof);
   }
 
-  const std::string file_reader::in_src ("file");
+  const std::string file_reader::s_in_src ("file");
 
   std::string
   file_reader::get_input (bool& eof)
   {
     octave_quit ();
 
     eof = false;
 
-    return octave_fgets (file, eof);
+    return octave_fgets (m_file, eof);
   }
 
-  const std::string eval_string_reader::in_src ("eval_string");
+  const std::string eval_string_reader::s_in_src ("eval_string");
 
   std::string
   eval_string_reader::get_input (bool& eof)
   {
     octave_quit ();
 
     eof = false;
 
     std::string retval;
 
-    retval = eval_string;
+    retval = m_eval_string;
 
     // Clear the eval string so that the next call will return
     // an empty character string with EOF = true.
-    eval_string = "";
+    m_eval_string = "";
 
     if (retval.empty ())
       eof = true;
 
     return retval;
   }
 }
 
diff --git a/libinterp/corefcn/input.h b/libinterp/corefcn/input.h
--- a/libinterp/corefcn/input.h
+++ b/libinterp/corefcn/input.h
@@ -77,41 +77,41 @@ namespace octave
   class
   base_reader
   {
   public:
 
     friend class input_reader;
 
     base_reader (base_lexer *lxr)
-      : count (1), pflag (0), lexer (lxr)
+      : m_count (1), m_pflag (0), m_lexer (lxr)
     { }
 
     base_reader (const base_reader& x)
-      : count (1), pflag (x.pflag), lexer (x.lexer)
+      : m_count (1), m_pflag (x.m_pflag), m_lexer (x.m_lexer)
     { }
 
     virtual ~base_reader (void) = default;
 
     virtual std::string get_input (bool& eof) = 0;
 
-    virtual std::string input_source (void) const { return in_src; }
+    virtual std::string input_source (void) const { return s_in_src; }
 
     void reset (void) { promptflag (1); }
 
-    void increment_promptflag (void) { pflag++; }
+    void increment_promptflag (void) { m_pflag++; }
 
-    void decrement_promptflag (void) { pflag--; }
+    void decrement_promptflag (void) { m_pflag--; }
 
-    int promptflag (void) const { return pflag; }
+    int promptflag (void) const { return m_pflag; }
 
     int promptflag (int n)
     {
-      int retval = pflag;
-      pflag = n;
+      int retval = m_pflag;
+      m_pflag = n;
       return retval;
     }
 
     std::string octave_gets (bool& eof);
 
     virtual bool reading_fcn_file (void) const;
 
     virtual bool reading_classdef_file (void) const;
@@ -121,93 +121,93 @@ namespace octave
     virtual bool input_from_terminal (void) const { return false; }
 
     virtual bool input_from_file (void) const { return false; }
 
     virtual bool input_from_eval_string (void) const { return false; }
 
   private:
 
-    refcount<int> count;
+    refcount<int> m_count;
 
-    int pflag;
+    int m_pflag;
 
-    base_lexer *lexer;
+    base_lexer *m_lexer;
 
-    static const std::string in_src;
+    static const std::string s_in_src;
   };
 
   class
   input_reader
   {
   public:
 
     input_reader (base_lexer *lxr = nullptr);
 
     input_reader (FILE *file, base_lexer *lxr = nullptr);
 
     input_reader (const std::string& str, base_lexer *lxr = nullptr);
 
     input_reader (const input_reader& ir)
     {
-      rep = ir.rep;
-      rep->count++;
+      m_rep = ir.m_rep;
+      m_rep->m_count++;
     }
 
     input_reader& operator = (const input_reader& ir)
     {
       if (&ir != this)
         {
-          rep = ir.rep;
-          rep->count++;
+          m_rep = ir.m_rep;
+          m_rep->m_count++;
         }
 
       return *this;
     }
 
     ~input_reader (void)
     {
-      if (--rep->count == 0)
-        delete rep;
+      if (--m_rep->m_count == 0)
+        delete m_rep;
     }
 
-    void reset (void) { return rep->reset (); }
+    void reset (void) { return m_rep->reset (); }
 
-    void increment_promptflag (void) { rep->increment_promptflag (); }
+    void increment_promptflag (void) { m_rep->increment_promptflag (); }
 
-    void decrement_promptflag (void) { rep->decrement_promptflag (); }
+    void decrement_promptflag (void) { m_rep->decrement_promptflag (); }
 
-    int promptflag (void) const { return rep->promptflag (); }
+    int promptflag (void) const { return m_rep->promptflag (); }
 
-    int promptflag (int n) { return rep->promptflag (n); }
+    int promptflag (int n) { return m_rep->promptflag (n); }
 
     std::string get_input (bool& eof)
     {
-      return rep->get_input (eof);
+      return m_rep->get_input (eof);
     }
 
     std::string input_source (void) const
     {
-      return rep->input_source ();
+      return m_rep->input_source ();
     }
 
     bool input_from_terminal (void) const
     {
-      return rep->input_from_terminal ();
+      return m_rep->input_from_terminal ();
     }
 
     bool input_from_file (void) const
     {
-      return rep->input_from_file ();
+      return m_rep->input_from_file ();
     }
 
     bool input_from_eval_string (void) const
     {
-      return rep->input_from_eval_string ();
+      return m_rep->input_from_eval_string ();
     }
 
   private:
 
-    base_reader *rep;
+    base_reader *m_rep;
   };
 }
 
 #endif
diff --git a/libinterp/corefcn/interpreter.cc b/libinterp/corefcn/interpreter.cc
--- a/libinterp/corefcn/interpreter.cc
+++ b/libinterp/corefcn/interpreter.cc
@@ -988,17 +988,17 @@ namespace octave
                           break;
                       }
 
                     if (octave_completion_matches_called)
                       octave_completion_matches_called = false;
                     else
                       command_editor::increment_current_command_number ();
                   }
-                else if (parser.m_lexer.end_of_input)
+                else if (parser.m_lexer.m_end_of_input)
                   {
                     retval = EOF;
                     break;
                   }
               }
           }
         catch (const interrupt_exception&)
           {
diff --git a/libinterp/parse-tree/comment-list.h b/libinterp/parse-tree/comment-list.h
--- a/libinterp/parse-tree/comment-list.h
+++ b/libinterp/parse-tree/comment-list.h
@@ -47,47 +47,46 @@ namespace octave
         unknown,
         block,
         full_line,
         end_of_line,
         doc_string,
         copyright
       };
 
-    comment_elt (const std::string& s = "",
-                        comment_type t = unknown)
-      : txt (s), typ (t) { }
+    comment_elt (const std::string& s = "", comment_type t = unknown)
+      : m_text (s), m_type (t) { }
 
     comment_elt (const comment_elt& oc)
-      : txt (oc.txt), typ (oc.typ) { }
+      : m_text (oc.m_text), m_type (oc.m_type) { }
 
     comment_elt& operator = (const comment_elt& oc)
     {
       if (this != &oc)
         {
-          txt = oc.txt;
-          typ = oc.typ;
+          m_text = oc.m_text;
+          m_type = oc.m_type;
         }
 
       return *this;
     }
 
-    std::string text (void) const { return txt; }
+    std::string text (void) const { return m_text; }
 
-    comment_type type (void) const { return typ; }
+    comment_type type (void) const { return m_type; }
 
     ~comment_elt (void) = default;
 
   private:
 
     // The text of the comment.
-    std::string txt;
+    std::string m_text;
 
     // The type of comment.
-    comment_type typ;
+    comment_type m_type;
   };
 
   class
   comment_list : public octave::base_list<comment_elt>
   {
   public:
 
     comment_list (void) { }
diff --git a/libinterp/parse-tree/lex.h b/libinterp/parse-tree/lex.h
--- a/libinterp/parse-tree/lex.h
+++ b/libinterp/parse-tree/lex.h
@@ -52,39 +52,39 @@ namespace octave
 
     // Track symbol table information when parsing functions.
 
     class symbol_table_context
     {
     public:
 
       symbol_table_context (void)
-        : frame_stack () { }
+        : m_frame_stack () { }
 
       ~symbol_table_context (void) { clear (); }
 
       void clear (void);
 
-      bool empty (void) const { return frame_stack.empty (); }
+      bool empty (void) const { return m_frame_stack.empty (); }
 
-      size_t size (void) const { return frame_stack.size (); }
+      size_t size (void) const { return m_frame_stack.size (); }
 
       void pop (void);
 
       void push (const symbol_scope& scope)
       {
-        frame_stack.push_front (scope);
+        m_frame_stack.push_front (scope);
       }
 
       symbol_scope curr_scope (void) const;
       symbol_scope parent_scope (void) const;
 
     private:
 
-      std::deque<symbol_scope> frame_stack;
+      std::deque<symbol_scope> m_frame_stack;
     };
 
     // Track nesting of square brackets, curly braces, and parentheses.
 
     class bbp_nesting_level
     {
     private:
 
@@ -93,87 +93,89 @@ namespace octave
         BRACKET = 1,
         BRACE = 2,
         PAREN = 3,
         ANON_FCN_BODY = 4
       };
 
     public:
 
-      bbp_nesting_level (void) : context () { }
+      bbp_nesting_level (void) : m_context () { }
 
-      bbp_nesting_level (const bbp_nesting_level& nl) : context (nl.context) { }
+      bbp_nesting_level (const bbp_nesting_level& nl)
+        : m_context (nl.m_context)
+      { }
 
       bbp_nesting_level& operator = (const bbp_nesting_level& nl)
       {
         if (&nl != this)
-          context = nl.context;
+          m_context = nl.m_context;
 
         return *this;
       }
 
       ~bbp_nesting_level (void) = default;
 
       void reset (void)
       {
-        while (! context.empty ())
-          context.pop ();
+        while (! m_context.empty ())
+          m_context.pop ();
       }
 
-      void bracket (void) { context.push (BRACKET); }
+      void bracket (void) { m_context.push (BRACKET); }
 
       bool is_bracket (void)
       {
-        return ! context.empty () && context.top () == BRACKET;
+        return ! m_context.empty () && m_context.top () == BRACKET;
       }
 
-      void brace (void) { context.push (BRACE); }
+      void brace (void) { m_context.push (BRACE); }
 
       bool is_brace (void)
       {
-        return ! context.empty () && context.top () == BRACE;
+        return ! m_context.empty () && m_context.top () == BRACE;
       }
 
-      void paren (void) { context.push (PAREN); }
+      void paren (void) { m_context.push (PAREN); }
 
       bool is_paren (void)
       {
-        return ! context.empty () && context.top () == PAREN;
+        return ! m_context.empty () && m_context.top () == PAREN;
       }
 
-      void anon_fcn_body (void) { context.push (ANON_FCN_BODY); }
+      void anon_fcn_body (void) { m_context.push (ANON_FCN_BODY); }
 
       bool is_anon_fcn_body (void)
       {
-        return ! context.empty () && context.top () == ANON_FCN_BODY;
+        return ! m_context.empty () && m_context.top () == ANON_FCN_BODY;
       }
 
       bool is_bracket_or_brace (void)
       {
-        return (! context.empty ()
-                && (context.top () == BRACKET || context.top () == BRACE));
+        return (! m_context.empty ()
+                && (m_context.top () == BRACKET || m_context.top () == BRACE));
       }
 
-      bool none (void) { return context.empty (); }
+      bool none (void) { return m_context.empty (); }
 
       void remove (void)
       {
-        if (! context.empty ())
-          context.pop ();
+        if (! m_context.empty ())
+          m_context.pop ();
       }
 
       void clear (void)
       {
-        while (! context.empty ())
-          context.pop ();
+        while (! m_context.empty ())
+          m_context.pop ();
       }
 
     private:
 
-      std::stack<int> context;
+      std::stack<int> m_context;
     };
 
     class token_cache
     {
     public:
 
       // Store an "unlimited" number of tokens.
 
@@ -182,113 +184,137 @@ namespace octave
       //
       // One of the reasons for using this class instead of std::deque
       // directly is that we can ensure that memory is cleaned up
       // properly.  It's more tedious to do that with deque since the
       // deque destructor and clear method don't call delete on the
       // elements that it stores.  Another reason is that it makes it
       // easier to change the implementation later if needed.
 
-      token_cache (void) : buffer () { }
+      token_cache (void) : m_buffer () { }
 
       // No copying!
 
       token_cache (const token_cache&) = delete;
 
       token_cache& operator = (const token_cache&) = delete;
 
       ~token_cache (void) { clear (); }
 
       void push (token *tok)
       {
-        buffer.push_front (tok);
+        m_buffer.push_front (tok);
       }
 
       void pop (void)
       {
         if (! empty ())
           {
-            delete buffer.back ();
-            buffer.pop_back ();
+            delete m_buffer.back ();
+            m_buffer.pop_back ();
           }
       }
 
       // Direct access.
       token * at (size_t n)
       {
-        return empty () ? nullptr : buffer.at (n);
+        return empty () ? nullptr : m_buffer.at (n);
       }
 
       const token * at (size_t n) const
       {
-        return empty () ? nullptr : buffer.at (n);
+        return empty () ? nullptr : m_buffer.at (n);
       }
 
       // Most recently pushed.
       token * front (void)
       {
-        return empty () ? nullptr : buffer.front ();
+        return empty () ? nullptr : m_buffer.front ();
       }
 
       const token * front (void) const
       {
-        return empty () ? nullptr : buffer.front ();
+        return empty () ? nullptr : m_buffer.front ();
       }
 
       token * back (void)
       {
-        return empty () ? nullptr : buffer.back ();
+        return empty () ? nullptr : m_buffer.back ();
       }
 
       const token * back (void) const
       {
-        return empty () ? nullptr : buffer.back ();
+        return empty () ? nullptr : m_buffer.back ();
       }
 
       // Number of elements currently in the buffer.
-      size_t size (void) const { return buffer.size (); }
+      size_t size (void) const { return m_buffer.size (); }
 
-      bool empty (void) const { return buffer.empty (); }
+      bool empty (void) const { return m_buffer.empty (); }
 
       void clear (void)
       {
         while (! empty ())
           pop ();
       }
 
     private:
 
-      std::deque<token *> buffer;
+      std::deque<token *> m_buffer;
     };
 
     lexical_feedback (void)
-      : end_of_input (false), at_beginning_of_statement (true),
-        looking_at_anon_fcn_args (false), looking_at_return_list (false),
-        looking_at_parameter_list (false), looking_at_decl_list (false),
-        looking_at_initializer_expression (false),
-        looking_at_matrix_or_assign_lhs (false),
-        looking_for_object_index (false),
-        looking_at_indirect_ref (false), parsing_class_method (false),
-        parsing_classdef (false), maybe_classdef_get_set_method (false),
-        parsing_classdef_get_method (false),
-        parsing_classdef_set_method (false),
-        quote_is_transpose (false), force_script (false),
-        reading_fcn_file (false), reading_script_file (false),
-        reading_classdef_file (false), buffer_function_text (false),
-        input_line_number (1), current_input_column (1),
-        bracketflag (0), braceflag (0),
-        looping (0), defining_func (0), looking_at_function_handle (0),
-        block_comment_nesting_level (0), command_arg_paren_count (0),
-        token_count (0), current_input_line (), comment_text (),
-        help_text (), function_text (), string_text (),
-        string_line (0), string_column (0),
-        fcn_file_name (), fcn_file_full_name (), dir_name (),
-        package_name (), looking_at_object_index (), parsed_function_name (),
-        pending_local_variables (), symtab_context (), nesting_level (),
-        tokens ()
+      : m_end_of_input (false),
+        m_at_beginning_of_statement (true),
+        m_looking_at_anon_fcn_args (false),
+        m_looking_at_return_list (false),
+        m_looking_at_parameter_list (false),
+        m_looking_at_decl_list (false),
+        m_looking_at_initializer_expression (false),
+        m_looking_at_matrix_or_assign_lhs (false),
+        m_looking_for_object_index (false),
+        m_looking_at_indirect_ref (false),
+        m_parsing_class_method (false),
+        m_parsing_classdef (false),
+        m_maybe_classdef_get_set_method (false),
+        m_parsing_classdef_get_method (false),
+        m_parsing_classdef_set_method (false),
+        m_quote_is_transpose (false),
+        m_force_script (false),
+        m_reading_fcn_file (false),
+        m_reading_script_file (false),
+        m_reading_classdef_file (false),
+        m_buffer_function_text (false),
+        m_input_line_number (1),
+        m_current_input_column (1),
+        m_bracketflag (0),
+        m_braceflag (0),
+        m_looping (0),
+        m_defining_func (0),
+        m_looking_at_function_handle (0),
+        m_block_comment_nesting_level (0),
+        m_command_arg_paren_count (0),
+        m_token_count (0),
+        m_current_input_line (),
+        m_comment_text (),
+        m_help_text (),
+        m_function_text (),
+        m_string_text (),
+        m_string_line (0),
+        m_string_column (0),
+        m_fcn_file_name (),
+        m_fcn_file_full_name (),
+        m_dir_name (),
+        m_package_name (),
+        m_looking_at_object_index (),
+        m_parsed_function_name (),
+        m_pending_local_variables (),
+        m_symtab_context (),
+        m_nesting_level (),
+        m_tokens ()
     {
       init ();
     }
 
     // No copying!
 
     lexical_feedback (const lexical_feedback&) = delete;
 
@@ -315,170 +341,170 @@ namespace octave
     bool previous_token_may_be_command (void) const;
 
     void maybe_mark_previous_token_as_variable (void);
 
     void mark_as_variable (const std::string& nm);
     void mark_as_variables (const std::list<std::string>& lst);
 
     // true means that we have encountered eof on the input stream.
-    bool end_of_input;
+    bool m_end_of_input;
 
     // true means we are at the beginning of a statement, where a
     // command name is possible.
-    bool at_beginning_of_statement;
+    bool m_at_beginning_of_statement;
 
     // true means we are parsing an anonymous function argument list.
-    bool looking_at_anon_fcn_args;
+    bool m_looking_at_anon_fcn_args;
 
     // true means we're parsing the return list for a function.
-    bool looking_at_return_list;
+    bool m_looking_at_return_list;
 
     // true means we're parsing the parameter list for a function.
-    bool looking_at_parameter_list;
+    bool m_looking_at_parameter_list;
 
     // true means we're parsing a declaration list (global or
     // persistent).
-    bool looking_at_decl_list;
+    bool m_looking_at_decl_list;
 
     // true means we are looking at the initializer expression for a
     // parameter list element.
-    bool looking_at_initializer_expression;
+    bool m_looking_at_initializer_expression;
 
     // true means we're parsing a matrix or the left hand side of
     // multi-value assignment statement.
-    bool looking_at_matrix_or_assign_lhs;
+    bool m_looking_at_matrix_or_assign_lhs;
 
     // object index not possible until we've seen something.
-    bool looking_for_object_index;
+    bool m_looking_for_object_index;
 
     // true means we're looking at an indirect reference to a
     // structure element.
-    bool looking_at_indirect_ref;
+    bool m_looking_at_indirect_ref;
 
     // true means we are parsing a class method in function or classdef file.
-    bool parsing_class_method;
+    bool m_parsing_class_method;
 
     // true means we are parsing a classdef file
-    bool parsing_classdef;
+    bool m_parsing_classdef;
 
     // true means we are parsing a class method declaration line in a
     // classdef file and can accept a property get or set method name.
     // for example, "get.propertyname" is recognized as a function name.
-    bool maybe_classdef_get_set_method;
+    bool m_maybe_classdef_get_set_method;
 
     // TRUE means we are parsing a classdef get.method.
-    bool parsing_classdef_get_method;
+    bool m_parsing_classdef_get_method;
 
     // TRUE means we are parsing a classdef set.method.
-    bool parsing_classdef_set_method;
+    bool m_parsing_classdef_set_method;
 
     // return transpose or start a string?
-    bool quote_is_transpose;
+    bool m_quote_is_transpose;
 
     // TRUE means treat the current file as a script even if the first
     // token is "function" or "classdef".
-    bool force_script;
+    bool m_force_script;
 
     // TRUE means we're parsing a function file.
-    bool reading_fcn_file;
+    bool m_reading_fcn_file;
 
     // TRUE means we're parsing a script file.
-    bool reading_script_file;
+    bool m_reading_script_file;
 
     // TRUE means we're parsing a classdef file.
-    bool reading_classdef_file;
+    bool m_reading_classdef_file;
 
     // TRUE means we should store the text of the function we are
     // parsing.
-    bool buffer_function_text;
+    bool m_buffer_function_text;
 
     // the current input line number.
-    int input_line_number;
+    int m_input_line_number;
 
     // the column of the current token.
-    int current_input_column;
+    int m_current_input_column;
 
     // square bracket level count.
-    int bracketflag;
+    int m_bracketflag;
 
     // curly brace level count.
-    int braceflag;
+    int m_braceflag;
 
     // true means we're in the middle of defining a loop.
-    int looping;
+    int m_looping;
 
     // nonzero means we're in the middle of defining a function.
-    int defining_func;
+    int m_defining_func;
 
     // nonzero means we are parsing a function handle.
-    int looking_at_function_handle;
+    int m_looking_at_function_handle;
 
-    // nestng level for blcok comments.
-    int block_comment_nesting_level;
+    // nestng level for block comments.
+    int m_block_comment_nesting_level;
 
     // Parenthesis count for command argument parsing.
-    int command_arg_paren_count;
+    int m_command_arg_paren_count;
 
     // Count of tokens recognized by this lexer since initialized or
     // since the last reset.
-    size_t token_count;
+    size_t m_token_count;
 
     // The current line of input.
-    std::string current_input_line;
+    std::string m_current_input_line;
 
     // The current comment text.
-    std::string comment_text;
+    std::string m_comment_text;
 
     // The current help text.
-    std::string help_text;
+    std::string m_help_text;
 
     // The text of functions entered on the command line.
-    std::string function_text;
+    std::string m_function_text;
 
     // The current character string text.
-    std::string string_text;
+    std::string m_string_text;
 
     // The position of the beginning of the current character string.
-    int string_line;
-    int string_column;
+    int m_string_line;
+    int m_string_column;
 
     // Simple name of function file we are reading.
-    std::string fcn_file_name;
+    std::string m_fcn_file_name;
 
     // Full name of file we are reading.
-    std::string fcn_file_full_name;
+    std::string m_fcn_file_full_name;
 
     // Directory name where this file was found.  May be relative.
-    std::string dir_name;
+    std::string m_dir_name;
 
     // Name of +package containing this file, if any.
-    std::string package_name;
+    std::string m_package_name;
 
     // if the front of the list is true, the closest paren, brace, or
     // bracket nesting is an index for an object.
-    std::list<bool> looking_at_object_index;
+    std::list<bool> m_looking_at_object_index;
 
     // if the top of the stack is true, then we've already seen the name
     // of the current function.  should only matter if
     // current_function_level > 0
-    std::stack<bool> parsed_function_name;
+    std::stack<bool> m_parsed_function_name;
 
     // set of identifiers that might be local variable names.
-    std::set<std::string> pending_local_variables;
+    std::set<std::string> m_pending_local_variables;
 
     // Track current symbol table scope and context.
-    symbol_table_context symtab_context;
+    symbol_table_context m_symtab_context;
 
     // is the closest nesting level a square bracket, squiggly brace,
     // a paren, or an anonymous function body?
-    bbp_nesting_level nesting_level;
+    bbp_nesting_level m_nesting_level;
 
     // Tokens generated by the lexer.
-    token_cache tokens;
+    token_cache m_tokens;
   };
 
   // base_lexer inherits from lexical_feedback because we will
   // eventually have several different constructors and it is easier to
   // intialize if everything is grouped in a parent class rather than
   // listing all the members in the base_lexer class.
 
   class
@@ -488,34 +514,34 @@ namespace octave
 
     // Handle buffering of input for lexer.
 
    class input_buffer
     {
     public:
 
       input_buffer (void)
-        : buffer (), pos (nullptr), chars_left (0), eof (false)
+        : m_buffer (), m_pos (nullptr), m_chars_left (0), m_eof (false)
       { }
 
       void fill (const std::string& input, bool eof_arg);
 
       // Copy at most max_size characters to buf.
       int copy_chunk (char *buf, size_t max_size);
 
-      bool empty (void) const { return chars_left == 0; }
+      bool empty (void) const { return m_chars_left == 0; }
 
-      bool at_eof (void) const { return eof; }
+      bool at_eof (void) const { return m_eof; }
 
     private:
 
-      std::string buffer;
-      const char *pos;
-      size_t chars_left;
-      bool eof;
+      std::string m_buffer;
+      const char *m_pos;
+      size_t m_chars_left;
+      bool m_eof;
     };
 
     // Collect comment text.
 
     class
     comment_buffer
     {
     public:
@@ -551,18 +577,18 @@ namespace octave
       }
 
     private:
 
       comment_list *m_comment_list;
     };
 
     base_lexer (interpreter *interp = nullptr)
-      : lexical_feedback (), scanner (nullptr), input_buf (), comment_buf (),
-        m_interpreter (interp)
+      : lexical_feedback (), m_scanner (nullptr), m_input_buf (),
+        m_comment_buf (), m_interpreter (interp)
     {
       init ();
     }
 
     // No copying!
 
     base_lexer (const base_lexer&) = delete;
 
@@ -577,19 +603,19 @@ namespace octave
     virtual void reset (void);
 
     void prep_for_file (void);
 
     void begin_string (int state);
 
     virtual int fill_flex_buffer (char *buf, unsigned int max_size) = 0;
 
-    bool at_end_of_buffer (void) const { return input_buf.empty (); }
+    bool at_end_of_buffer (void) const { return m_input_buf.empty (); }
 
-    bool at_end_of_file (void) const { return input_buf.at_eof (); }
+    bool at_end_of_file (void) const { return m_input_buf.at_eof (); }
 
     int handle_end_of_input (void);
 
     char * flex_yytext (void);
 
     int flex_yyleng (void);
 
     int text_yyinput (void);
@@ -611,17 +637,17 @@ namespace octave
     bool whitespace_is_significant (void);
 
     void handle_number (void);
 
     void handle_continuation (void);
 
     void finish_comment (comment_elt::comment_type typ);
 
-    comment_list * get_comment (void) { return comment_buf.get_comment (); }
+    comment_list * get_comment (void) { return m_comment_buf.get_comment (); }
 
     int handle_close_bracket (int bracket_type);
 
     bool looks_like_command_arg (void);
 
     int handle_superclass_identifier (void);
 
     int handle_meta_identifier (void);
@@ -648,23 +674,23 @@ namespace octave
 
     void display_token (int tok);
 
     void fatal_error (const char *msg);
 
     void lexer_debug (const char *pattern);
 
     // Internal state of the flex-generated lexer.
-    void *scanner;
+    void *m_scanner;
 
     // Object that reads and buffers input.
-    input_buffer input_buf;
+    input_buffer m_input_buf;
 
     // Object that collects comment text.
-    comment_buffer comment_buf;
+    comment_buffer m_comment_buf;
 
     // Interpreter that contains us, if any.
     interpreter *m_interpreter;
 
     virtual void increment_promptflag (void) = 0;
 
     virtual void decrement_promptflag (void) = 0;
 
@@ -725,99 +751,99 @@ namespace octave
   };
 
   class
   lexer : public base_lexer
   {
   public:
 
     lexer (interpreter *interp = nullptr)
-      : base_lexer (interp), reader (this)
+      : base_lexer (interp), m_reader (this)
     { }
 
     lexer (FILE *file, interpreter *interp = nullptr)
-      : base_lexer (interp), reader (file, this)
+      : base_lexer (interp), m_reader (file, this)
     { }
 
     lexer (const std::string& eval_string, interpreter *interp = nullptr)
-      : base_lexer (interp), reader (eval_string, this)
+      : base_lexer (interp), m_reader (eval_string, this)
     { }
 
     // No copying!
 
     lexer (const lexer&) = delete;
 
     lexer& operator = (const lexer&) = delete;
 
     void reset (void)
     {
-      reader.reset ();
+      m_reader.reset ();
 
       base_lexer::reset ();
     }
 
-    void increment_promptflag (void) { reader.increment_promptflag (); }
+    void increment_promptflag (void) { m_reader.increment_promptflag (); }
 
-    void decrement_promptflag (void) { reader.decrement_promptflag (); }
+    void decrement_promptflag (void) { m_reader.decrement_promptflag (); }
 
-    int promptflag (void) const { return reader.promptflag (); }
+    int promptflag (void) const { return m_reader.promptflag (); }
 
-    int promptflag (int n) { return reader.promptflag (n); }
+    int promptflag (int n) { return m_reader.promptflag (n); }
 
     std::string input_source (void) const
     {
-      return reader.input_source ();
+      return m_reader.input_source ();
     }
 
     bool input_from_terminal (void) const
     {
-      return reader.input_from_terminal ();
+      return m_reader.input_from_terminal ();
     }
 
     bool input_from_file (void) const
     {
-      return reader.input_from_file ();
+      return m_reader.input_from_file ();
     }
 
     bool input_from_eval_string (void) const
     {
-      return reader.input_from_eval_string ();
+      return m_reader.input_from_eval_string ();
     }
 
     int fill_flex_buffer (char *buf, unsigned int max_size);
 
-    input_reader reader;
+    input_reader m_reader;
   };
 
   class
   push_lexer : public base_lexer
   {
   public:
 
     push_lexer (interpreter *interp = nullptr)
-      : base_lexer (interp), pflag (1)
+      : base_lexer (interp), m_pflag (1)
     {
       append_input ("", false);
     }
 
     push_lexer (const std::string& input, interpreter *interp = nullptr)
-      : base_lexer (interp), pflag (1)
+      : base_lexer (interp), m_pflag (1)
     {
       append_input (input, false);
     }
 
     push_lexer (bool eof, interpreter *interp = nullptr)
-      : base_lexer (interp), pflag (1)
+      : base_lexer (interp), m_pflag (1)
     {
       append_input ("", eof);
     }
 
     push_lexer (const std::string& input, bool eof,
                 interpreter *interp = nullptr)
-      : base_lexer (interp), pflag (1)
+      : base_lexer (interp), m_pflag (1)
     {
       append_input (input, eof);
     }
 
     // No copying!
 
     push_lexer (const push_lexer&) = delete;
 
@@ -829,32 +855,32 @@ namespace octave
     {
       promptflag (1);
 
       base_lexer::reset ();
     }
 
     void append_input (const std::string& input, bool eof);
 
-    void increment_promptflag (void) { pflag++; }
+    void increment_promptflag (void) { m_pflag++; }
 
-    void decrement_promptflag (void) { pflag--; }
+    void decrement_promptflag (void) { m_pflag--; }
 
-    int promptflag (void) const { return pflag; }
+    int promptflag (void) const { return m_pflag; }
 
     int promptflag (int n)
     {
-      int retval = pflag;
-      pflag = n;
+      int retval = m_pflag;
+      m_pflag = n;
       return retval;
     }
 
     std::string input_source (void) const { return "push buffer"; }
 
     int fill_flex_buffer (char *buf, unsigned int max_size);
 
   protected:
 
-    int pflag;
+    int m_pflag;
   };
 }
 
 #endif
diff --git a/libinterp/parse-tree/lex.ll b/libinterp/parse-tree/lex.ll
--- a/libinterp/parse-tree/lex.ll
+++ b/libinterp/parse-tree/lex.ll
@@ -222,17 +222,17 @@ object) relevant global values before an
               ? curr_lexer->handle_unary_op (TOK)                       \
               : curr_lexer->handle_language_extension_unary_op (TOK));  \
                                                                         \
            if (tok < 0)                                                 \
              {                                                          \
                yyless (0);                                              \
                curr_lexer->xunput (',');                                \
                /* Adjust for comma that was not really in the input stream. */ \
-               curr_lexer->current_input_column--;                      \
+               curr_lexer->m_current_input_column--;                    \
              }                                                          \
            else                                                         \
              {                                                          \
                return tok;                                              \
              }                                                          \
          }                                                              \
      }                                                                  \
    while (0)
@@ -242,18 +242,18 @@ object) relevant global values before an
 // 1 is a valid character for a character string.  If we are at the
 // end of the buffer, ask for more input.  If we are at the end of the
 // file, deal with it.  Otherwise, just keep going with the text from
 // the current buffer.
 #define HANDLE_STRING_CONTINUATION                      \
    do                                                   \
      {                                                  \
        curr_lexer->decrement_promptflag ();             \
-       curr_lexer->input_line_number++;                 \
-       curr_lexer->current_input_column = 1;            \
+       curr_lexer->m_input_line_number++;               \
+       curr_lexer->m_current_input_column = 1;          \
                                                         \
        if (curr_lexer->is_push_lexer ())                \
          {                                              \
            if (curr_lexer->at_end_of_buffer ())         \
              return -1;                                 \
                                                         \
            if (curr_lexer->at_end_of_file ())           \
              return curr_lexer->handle_end_of_input (); \
@@ -263,24 +263,24 @@ object) relevant global values before an
 
 // When a command argument boundary is detected, push out the
 // current argument being built.  This one seems like a good
 // candidate for a function call.
 
 #define COMMAND_ARG_FINISH                                              \
    do                                                                   \
      {                                                                  \
-       if (curr_lexer->string_text.empty ())                            \
+       if (curr_lexer->m_string_text.empty ())                          \
          break;                                                         \
                                                                         \
-       int retval = curr_lexer->handle_token (curr_lexer->string_text,  \
+       int retval = curr_lexer->handle_token (curr_lexer->m_string_text, \
                                               SQ_STRING);               \
                                                                         \
-       curr_lexer->string_text = "";                                    \
-       curr_lexer->command_arg_paren_count = 0;                         \
+       curr_lexer->m_string_text = "";                                  \
+       curr_lexer->m_command_arg_paren_count = 0;                       \
                                                                         \
        yyless (0);                                                      \
                                                                         \
        return retval;                                                   \
      }                                                                  \
    while (0)
 
 #define HANDLE_IDENTIFIER(pattern, get_set)                             \
@@ -295,28 +295,28 @@ object) relevant global values before an
            && ! (tok == '[' || tok == '{'                               \
                  || curr_lexer->previous_token_is_binop ()))            \
          {                                                              \
            yyless (0);                                                  \
            unput (',');                                                 \
          }                                                              \
        else                                                             \
          {                                                              \
-           if (! curr_lexer->looking_at_decl_list                       \
+           if (! curr_lexer->m_looking_at_decl_list                     \
                && curr_lexer->previous_token_may_be_command ())         \
              {                                                          \
                yyless (0);                                              \
                curr_lexer->push_start_state (COMMAND_START);            \
              }                                                          \
            else                                                         \
              {                                                          \
                if (get_set)                                             \
                  {                                                      \
                    yyless (3);                                          \
-                   curr_lexer->maybe_classdef_get_set_method = false;   \
+                   curr_lexer->m_maybe_classdef_get_set_method = false; \
                  }                                                      \
                                                                         \
                int id_tok = curr_lexer->handle_identifier ();           \
                                                                         \
                if (id_tok >= 0)                                         \
                  return curr_lexer->count_token_internal (id_tok);      \
              }                                                          \
          }                                                              \
@@ -358,29 +358,29 @@ ANY_INCLUDING_NL (.|{NL})
 
 <INPUT_FILE_START>{ANY_INCLUDING_NL} {
     curr_lexer->lexer_debug ("<INPUT_FILE_START>{ANY_INCLUDING_NL}");
 
     curr_lexer->xunput (yytext[0]);
 
     // May be reset later if we see "function" or "classdef" appears
     // as the first token.
-    curr_lexer->reading_script_file = true;
+    curr_lexer->m_reading_script_file = true;
 
     curr_lexer->pop_start_state ();
 
     return curr_lexer->show_token (INPUT_FILE);
   }
 
 <INPUT_FILE_START><<EOF>> {
     curr_lexer->lexer_debug ("<INPUT_FILE_START><<EOF>>");
 
     // May be reset later if we see "function" or "classdef" appears
     // as the first token.
-    curr_lexer->reading_script_file = true;
+    curr_lexer->m_reading_script_file = true;
 
     curr_lexer->pop_start_state ();
 
     return curr_lexer->show_token (INPUT_FILE);
   }
 
 %{
 // Help and other command-style functions.
@@ -391,77 +391,77 @@ ANY_INCLUDING_NL (.|{NL})
 // If an argument is in construction, it is completed.
 %}
 
 <COMMAND_START>(\.\.\.){ANY_EXCEPT_NL}*{NL} {
     curr_lexer->lexer_debug ("<COMMAND_START>(\\.\\.\\.){ANY_EXCEPT_NL}*{NL}");
 
     COMMAND_ARG_FINISH;
 
-    curr_lexer->input_line_number++;
-    curr_lexer->current_input_column = 1;
+    curr_lexer->m_input_line_number++;
+    curr_lexer->m_current_input_column = 1;
 
     HANDLE_STRING_CONTINUATION;
   }
 
 %{
 // Commands normally end at the end of a line or a semicolon.
 %}
 
 <COMMAND_START>({CCHAR}{ANY_EXCEPT_NL}*)?{NL} {
     curr_lexer->lexer_debug ("<COMMAND_START>({CCHAR}{ANY_EXCEPT_NL}*)?{NL}");
 
     COMMAND_ARG_FINISH;
 
-    curr_lexer->input_line_number++;
-    curr_lexer->current_input_column = 1;
-    curr_lexer->looking_for_object_index = false;
-    curr_lexer->at_beginning_of_statement = true;
+    curr_lexer->m_input_line_number++;
+    curr_lexer->m_current_input_column = 1;
+    curr_lexer->m_looking_for_object_index = false;
+    curr_lexer->m_at_beginning_of_statement = true;
     curr_lexer->pop_start_state ();
 
     return curr_lexer->handle_token ('\n');
   }
 
 <COMMAND_START>[\,\;] {
     curr_lexer->lexer_debug ("<COMMAND_START>[\\,\\;]");
 
-    if (yytext[0] != ',' || curr_lexer->command_arg_paren_count == 0)
+    if (yytext[0] != ',' || curr_lexer->m_command_arg_paren_count == 0)
       {
         COMMAND_ARG_FINISH;
-        curr_lexer->looking_for_object_index = false;
-        curr_lexer->at_beginning_of_statement = true;
+        curr_lexer->m_looking_for_object_index = false;
+        curr_lexer->m_at_beginning_of_statement = true;
         curr_lexer->pop_start_state ();
         return curr_lexer->handle_token (yytext[0]);
       }
     else
-      curr_lexer->string_text += yytext;
-
-    curr_lexer->current_input_column += yyleng;
+      curr_lexer->m_string_text += yytext;
+
+    curr_lexer->m_current_input_column += yyleng;
   }
 
 %{
 // Unbalanced parentheses serve as pseudo-quotes: they are included in
 // the final argument string, but they cause parentheses and quotes to
 // be slurped into that argument as well.
 %}
 
 <COMMAND_START>[\(\[\{]* {
     curr_lexer->lexer_debug ("<COMMAND_START>[\\(\\[\\{]+");
 
-    curr_lexer->command_arg_paren_count += yyleng;
-    curr_lexer->string_text += yytext;
-    curr_lexer->current_input_column += yyleng;
+    curr_lexer->m_command_arg_paren_count += yyleng;
+    curr_lexer->m_string_text += yytext;
+    curr_lexer->m_current_input_column += yyleng;
   }
 
 <COMMAND_START>[\)\]\}]* {
    curr_lexer->lexer_debug ("<COMMAND_START>[\\)\\]\\}]+");
 
-   curr_lexer->command_arg_paren_count -= yyleng;
-   curr_lexer->string_text += yytext;
-   curr_lexer->current_input_column += yyleng;
+   curr_lexer->m_command_arg_paren_count -= yyleng;
+   curr_lexer->m_string_text += yytext;
+   curr_lexer->m_current_input_column += yyleng;
 }
 
 %{
 // Handle quoted strings.  Quoted strings that are not separated by
 // whitespace from other argument text are combined with that previous
 // text.  For instance,
 //
 //   command 'text1'"text2"
@@ -469,76 +469,76 @@ ANY_INCLUDING_NL (.|{NL})
 // has a single argument text1text2, not two separate arguments.
 // That's why we must test to see if we are in command argument mode
 // when processing the end of a string.
 %}
 
 <COMMAND_START>[\"\'] {
     curr_lexer->lexer_debug ("<COMMAND_START>[\\\"\\']");
 
-    if (curr_lexer->command_arg_paren_count == 0)
+    if (curr_lexer->m_command_arg_paren_count == 0)
       curr_lexer->begin_string (yytext[0] == '"'
                                 ? DQ_STRING_START : SQ_STRING_START);
     else
-      curr_lexer->string_text += yytext;
-
-    curr_lexer->current_input_column += yyleng;
+      curr_lexer->m_string_text += yytext;
+
+    curr_lexer->m_current_input_column += yyleng;
   }
 
 %{
 // In standard command argument processing, whitespace separates
 // arguments.  In the presence of unbalanced parentheses, it is
 // incorporated into the argument.
 %}
 
 <COMMAND_START>{S}* {
     curr_lexer->lexer_debug ("<COMMAND_START>{S}*");
 
-    if (curr_lexer->command_arg_paren_count == 0)
+    if (curr_lexer->m_command_arg_paren_count == 0)
       COMMAND_ARG_FINISH;
     else
-      curr_lexer->string_text += yytext;
-
-    curr_lexer->current_input_column += yyleng;
+      curr_lexer->m_string_text += yytext;
+
+    curr_lexer->m_current_input_column += yyleng;
   }
 
 %{
 // Everything else is slurped into the command arguments.
 %}
 
 <COMMAND_START>([\.]|[^#% \t\r\n\.\,\;\"\'\(\[\{\}\]\)]*) {
     curr_lexer->lexer_debug ("<COMMAND_START>([\\.]|[^#% \\t\\r\\n\\.\\,\\;\\\"\\'\\(\\[\\{\\}\\]\\)]*");
 
-    curr_lexer->string_text += yytext;
-    curr_lexer->current_input_column += yyleng;
+    curr_lexer->m_string_text += yytext;
+    curr_lexer->m_current_input_column += yyleng;
   }
 
 <MATRIX_START>{S}* {
     curr_lexer->lexer_debug ("<MATRIX_START>{S}*");
 
     curr_lexer->mark_previous_token_trailing_space ();
   }
 
 <MATRIX_START>{NL} {
     curr_lexer->lexer_debug ("<MATRIX_START>{NL}");
 
-    curr_lexer->input_line_number++;
-    curr_lexer->current_input_column = 1;
-
-    if (curr_lexer->nesting_level.is_paren ())
+    curr_lexer->m_input_line_number++;
+    curr_lexer->m_current_input_column = 1;
+
+    if (curr_lexer->m_nesting_level.is_paren ())
       curr_lexer->warn_language_extension ("bare newline inside parentheses");
     else
       {
         int tok = curr_lexer->previous_token_value ();
 
         if (! (tok == ';' || tok == '[' || tok == '{'))
           {
             curr_lexer->xunput (';');
             // Adjust for semicolon that was not really in the input stream.
-            curr_lexer->current_input_column--;
+            curr_lexer->m_current_input_column--;
           }
       }
   }
 
 %{
 // For this and the next two rules, we're looking at ']', and we
 // need to know if the next token is '=' or '=='.
 //
@@ -550,37 +550,37 @@ ANY_INCLUDING_NL (.|{NL})
 // after seeing a ']' character...
 
 // FIXME: we need to handle block comments here.
 %}
 
 <MATRIX_START>\] {
     curr_lexer->lexer_debug ("<MATRIX_START>\\]");
 
-    curr_lexer->looking_at_object_index.pop_front ();
-
-    curr_lexer->looking_for_object_index = true;
-    curr_lexer->at_beginning_of_statement = false;
+    curr_lexer->m_looking_at_object_index.pop_front ();
+
+    curr_lexer->m_looking_for_object_index = true;
+    curr_lexer->m_at_beginning_of_statement = false;
 
     curr_lexer->handle_close_bracket (']');
 
     return curr_lexer->count_token (']');
   }
 
 %{
 // FIXME: we need to handle block comments here.
 %}
 
 <MATRIX_START>\} {
     curr_lexer->lexer_debug ("<MATRIX_START>\\}*");
 
-    curr_lexer->looking_at_object_index.pop_front ();
-
-    curr_lexer->looking_for_object_index = true;
-    curr_lexer->at_beginning_of_statement = false;
+    curr_lexer->m_looking_at_object_index.pop_front ();
+
+    curr_lexer->m_looking_for_object_index = true;
+    curr_lexer->m_at_beginning_of_statement = false;
 
     curr_lexer->handle_close_bracket ('}');
 
     return curr_lexer->count_token ('}');
   }
 
 \[ {
     curr_lexer->lexer_debug ("\\[");
@@ -597,53 +597,53 @@ ANY_INCLUDING_NL (.|{NL})
           unput_comma = true;
       }
 
     if (unput_comma)
       {
         yyless (0);
         curr_lexer->xunput (',');
         // Adjust for comma that was not really in the input stream.
-        curr_lexer->current_input_column--;
+        curr_lexer->m_current_input_column--;
       }
     else
       {
-        curr_lexer->nesting_level.bracket ();
-
-        curr_lexer->looking_at_object_index.push_front (false);
-
-        curr_lexer->current_input_column += yyleng;
-        curr_lexer->looking_for_object_index = false;
-        curr_lexer->at_beginning_of_statement = false;
-
-        if (curr_lexer->defining_func
-            && ! curr_lexer->parsed_function_name.top ())
-          curr_lexer->looking_at_return_list = true;
+        curr_lexer->m_nesting_level.bracket ();
+
+        curr_lexer->m_looking_at_object_index.push_front (false);
+
+        curr_lexer->m_current_input_column += yyleng;
+        curr_lexer->m_looking_for_object_index = false;
+        curr_lexer->m_at_beginning_of_statement = false;
+
+        if (curr_lexer->m_defining_func
+            && ! curr_lexer->m_parsed_function_name.top ())
+          curr_lexer->m_looking_at_return_list = true;
         else
-          curr_lexer->looking_at_matrix_or_assign_lhs = true;
+          curr_lexer->m_looking_at_matrix_or_assign_lhs = true;
 
         curr_lexer->decrement_promptflag ();
 
-        curr_lexer->bracketflag++;
+        curr_lexer->m_bracketflag++;
 
         curr_lexer->push_start_state (MATRIX_START);
 
         return curr_lexer->count_token ('[');
       }
   }
 
 \] {
     curr_lexer->lexer_debug ("\\]");
 
-    curr_lexer->nesting_level.remove ();
-
-    curr_lexer->looking_at_object_index.pop_front ();
-
-    curr_lexer->looking_for_object_index = true;
-    curr_lexer->at_beginning_of_statement = false;
+    curr_lexer->m_nesting_level.remove ();
+
+    curr_lexer->m_looking_at_object_index.pop_front ();
+
+    curr_lexer->m_looking_for_object_index = true;
+    curr_lexer->m_at_beginning_of_statement = false;
 
     return curr_lexer->handle_token (']');
   }
 
 %{
 // Gobble comments.
 %}
 
@@ -655,96 +655,96 @@ ANY_INCLUDING_NL (.|{NL})
 
 ^{S}*{CCHAR}\{{S}*{NL} {
     curr_lexer->lexer_debug ("^{S}*{CCHAR}\\{{S}*{NL}");
 
     yyless (0);
 
     if (curr_lexer->start_state () == LINE_COMMENT_START)
       {
-        if (! curr_lexer->comment_text.empty ())
+        if (! curr_lexer->m_comment_text.empty ())
           curr_lexer->finish_comment (octave::comment_elt::full_line);
 
         curr_lexer->pop_start_state ();
       }
 
     curr_lexer->decrement_promptflag ();
 
     curr_lexer->push_start_state (BLOCK_COMMENT_START);
 
   }
 
 <BLOCK_COMMENT_START>^{S}*{CCHAR}\{{S}*{NL} {
     curr_lexer->lexer_debug ("<BLOCK_COMMENT_START>^{S}*{CCHAR}\\{{S}*{NL}");
 
-    curr_lexer->input_line_number++;
-    curr_lexer->current_input_column = 1;
-
-    if (curr_lexer->block_comment_nesting_level)
-      curr_lexer->comment_text = "\n";
-
-    curr_lexer->block_comment_nesting_level++;
+    curr_lexer->m_input_line_number++;
+    curr_lexer->m_current_input_column = 1;
+
+    if (curr_lexer->m_block_comment_nesting_level)
+      curr_lexer->m_comment_text = "\n";
+
+    curr_lexer->m_block_comment_nesting_level++;
   }
 
 %{
 // End of a block comment.  If this block comment is nested inside
 // another, wait for the outermost block comment block to be closed
 // before storing the comment.
 %}
 
 <BLOCK_COMMENT_START>^{S}*{CCHAR}\}{S}*{NL} {
     curr_lexer->lexer_debug ("<BLOCK_COMMENT_START>^{S}*{CCHAR}\\}{S}*{NL}");
 
-    curr_lexer->input_line_number++;
-    curr_lexer->current_input_column = 1;
-
-    if (curr_lexer->block_comment_nesting_level > 1)
-      curr_lexer->comment_text = "\n";
+    curr_lexer->m_input_line_number++;
+    curr_lexer->m_current_input_column = 1;
+
+    if (curr_lexer->m_block_comment_nesting_level > 1)
+      curr_lexer->m_comment_text = "\n";
     else
       curr_lexer->finish_comment (octave::comment_elt::block);
 
-    curr_lexer->block_comment_nesting_level--;
-
-    if (curr_lexer->block_comment_nesting_level == 0)
+    curr_lexer->m_block_comment_nesting_level--;
+
+    if (curr_lexer->m_block_comment_nesting_level == 0)
       {
         curr_lexer->increment_promptflag ();
 
         curr_lexer->pop_start_state ();
       }
   }
 
 %{
 // Body of a block comment.
 %}
 
 <BLOCK_COMMENT_START>{ANY_EXCEPT_NL}*{NL} {
     curr_lexer->lexer_debug ("<BLOCK_COMMENT_START>{ANY_EXCEPT_NL}*{NL}");
 
-    curr_lexer->input_line_number++;
-    curr_lexer->current_input_column = 1;
-    curr_lexer->comment_text += yytext;
+    curr_lexer->m_input_line_number++;
+    curr_lexer->m_current_input_column = 1;
+    curr_lexer->m_comment_text += yytext;
   }
 
 %{
 // Full-line or end-of-line comment.
 %}
 
 {S}*{CCHAR}{ANY_EXCEPT_NL}*{NL} {
     curr_lexer->lexer_debug ("{S}*{CCHAR}{ANY_EXCEPT_NL}*{NL}");
 
     curr_lexer->push_start_state (LINE_COMMENT_START);
     yyless (0);
   }
 
 <LINE_COMMENT_START>{S}*{CCHAR}{ANY_EXCEPT_NL}*{NL} {
     curr_lexer->lexer_debug ("<LINE_COMMENT_START>{S}*{CCHAR}{ANY_EXCEPT_NL}*{NL}");
 
-    bool full_line_comment = curr_lexer->current_input_column == 1;
-    curr_lexer->input_line_number++;
-    curr_lexer->current_input_column = 1;
+    bool full_line_comment = curr_lexer->m_current_input_column == 1;
+    curr_lexer->m_input_line_number++;
+    curr_lexer->m_current_input_column = 1;
 
     bool have_space = false;
     size_t len = yyleng;
     size_t i = 0;
     while (i < len)
       {
         char c = yytext[i];
         if (c == ' ' || c == '\t')
@@ -765,17 +765,17 @@ ANY_INCLUDING_NL (.|{NL})
           {
             num_comment_chars++;
             i++;
           }
         else
           break;
       }
 
-    curr_lexer->comment_text += &yytext[i];
+    curr_lexer->m_comment_text += &yytext[i];
 
     if (full_line_comment)
       {
         if (num_comment_chars == 1 && yytext[i++] == '{')
           {
             bool looks_like_block_comment = true;
 
             while (i < len)
@@ -803,17 +803,17 @@ ANY_INCLUDING_NL (.|{NL})
         if (have_space)
           curr_lexer->mark_previous_token_trailing_space ();
 
         curr_lexer->finish_comment (octave::comment_elt::end_of_line);
 
         curr_lexer->pop_start_state ();
 
         curr_lexer->xunput ('\n');
-        curr_lexer->input_line_number--;
+        curr_lexer->m_input_line_number--;
       }
   }
 
 %{
 // End of a block of full-line comments.
 %}
 
 <LINE_COMMENT_START>{ANY_INCLUDING_NL} {
@@ -840,287 +840,287 @@ ANY_INCLUDING_NL (.|{NL})
 
 %{
 // Double-quoted character strings.
 %}
 
 <DQ_STRING_START>\"\" {
     curr_lexer->lexer_debug ("<DQ_STRING_START>\\\"\\\"");
 
-    curr_lexer->current_input_column += yyleng;
-    curr_lexer->string_text += '"';
+    curr_lexer->m_current_input_column += yyleng;
+    curr_lexer->m_string_text += '"';
   }
 
 <DQ_STRING_START>\" {
     curr_lexer->lexer_debug ("<DQ_STRING_START>\\\"");
 
-    curr_lexer->current_input_column++;
+    curr_lexer->m_current_input_column++;
 
     curr_lexer->pop_start_state ();
 
     if (curr_lexer->start_state() != COMMAND_START)
       {
-        curr_lexer->looking_for_object_index = true;
-        curr_lexer->at_beginning_of_statement = false;
+        curr_lexer->m_looking_for_object_index = true;
+        curr_lexer->m_at_beginning_of_statement = false;
 
         curr_lexer->push_token (new octave::token (DQ_STRING,
-                                                   curr_lexer->string_text,
-                                                   curr_lexer->string_line,
-                                                   curr_lexer->string_column));
-
-        curr_lexer->string_text = "";
+                                                   curr_lexer->m_string_text,
+                                                   curr_lexer->m_string_line,
+                                                   curr_lexer->m_string_column));
+
+        curr_lexer->m_string_text = "";
 
         return curr_lexer->count_token_internal (DQ_STRING);
       }
   }
 
 <DQ_STRING_START>\\[0-7]{1,3} {
     curr_lexer->lexer_debug ("<DQ_STRING_START>\\\\[0-7]{1,3}");
 
-    curr_lexer->current_input_column += yyleng;
+    curr_lexer->m_current_input_column += yyleng;
 
     int result;
     sscanf (yytext+1, "%o", &result);
 
     if (result > 0xff)
       {
         octave::token *tok
           = new octave::token (LEXICAL_ERROR,
                                "invalid octal escape sequence in character string",
-                               curr_lexer->input_line_number,
-                               curr_lexer->current_input_column);
+                               curr_lexer->m_input_line_number,
+                               curr_lexer->m_current_input_column);
 
         curr_lexer->push_token (tok);
 
         return curr_lexer->count_token_internal (LEXICAL_ERROR);
       }
     else
-      curr_lexer->string_text += static_cast<unsigned char> (result);
+      curr_lexer->m_string_text += static_cast<unsigned char> (result);
   }
 
 <DQ_STRING_START>\\x[0-9a-fA-F]+ {
     curr_lexer->lexer_debug ("<DQ_STRING_START>\\\\x[0-9a-fA-F]+");
 
-    curr_lexer->current_input_column += yyleng;
+    curr_lexer->m_current_input_column += yyleng;
 
     int result;
     sscanf (yytext+2, "%x", &result);
 
     // Truncate the value silently instead of checking the range like
     // we do for octal above.  This is to match C/C++ where any number
     // of digits is allowed but the value is implementation-defined if
     // it exceeds the range of the character type.
-    curr_lexer->string_text += static_cast<unsigned char> (result);
+    curr_lexer->m_string_text += static_cast<unsigned char> (result);
   }
 
 <DQ_STRING_START>"\\a" {
     curr_lexer->lexer_debug ("<DQ_STRING_START>\"\\\\a\"");
 
-    curr_lexer->current_input_column += yyleng;
-    curr_lexer->string_text += '\a';
+    curr_lexer->m_current_input_column += yyleng;
+    curr_lexer->m_string_text += '\a';
   }
 
 <DQ_STRING_START>"\\b" {
     curr_lexer->lexer_debug ("<DQ_STRING_START>\"\\\\b\"");
 
-    curr_lexer->current_input_column += yyleng;
-    curr_lexer->string_text += '\b';
+    curr_lexer->m_current_input_column += yyleng;
+    curr_lexer->m_string_text += '\b';
   }
 
 <DQ_STRING_START>"\\f" {
     curr_lexer->lexer_debug ("<DQ_STRING_START>\"\\\\f\"");
 
-    curr_lexer->current_input_column += yyleng;
-    curr_lexer->string_text += '\f';
+    curr_lexer->m_current_input_column += yyleng;
+    curr_lexer->m_string_text += '\f';
   }
 
 <DQ_STRING_START>"\\n" {
     curr_lexer->lexer_debug ("<DQ_STRING_START>\"\\\\n\"");
 
-    curr_lexer->current_input_column += yyleng;
-    curr_lexer->string_text += '\n';
+    curr_lexer->m_current_input_column += yyleng;
+    curr_lexer->m_string_text += '\n';
   }
 
 <DQ_STRING_START>"\\r" {
     curr_lexer->lexer_debug ("<DQ_STRING_START>\"\\\\r\"");
 
-    curr_lexer->current_input_column += yyleng;
-    curr_lexer->string_text += '\r';
+    curr_lexer->m_current_input_column += yyleng;
+    curr_lexer->m_string_text += '\r';
   }
 
 <DQ_STRING_START>"\\t" {
     curr_lexer->lexer_debug ("<DQ_STRING_START>\"\\\\t\"");
 
-    curr_lexer->current_input_column += yyleng;
-    curr_lexer->string_text += '\t';
+    curr_lexer->m_current_input_column += yyleng;
+    curr_lexer->m_string_text += '\t';
   }
 
 <DQ_STRING_START>"\\v" {
     curr_lexer->lexer_debug ("<DQ_STRING_START>\"\\\\v\"");
 
-    curr_lexer->current_input_column += yyleng;
-    curr_lexer->string_text += '\v';
+    curr_lexer->m_current_input_column += yyleng;
+    curr_lexer->m_string_text += '\v';
   }
 
 <DQ_STRING_START>(\.\.\.){S}*{NL} {
     curr_lexer->lexer_debug ("<DQ_STRING_START>(\\.\\.\\.){S}*{NL}");
 
     static const char *msg = "'...' continuations in double-quoted character strings are obsolete and will not be allowed in a future version of Octave; please use '\\' instead";
 
-    std::string nm = curr_lexer->fcn_file_full_name;
+    std::string nm = curr_lexer->m_fcn_file_full_name;
 
     if (nm.empty ())
       warning_with_id ("Octave:deprecated-syntax", "%s", msg);
     else
       warning_with_id ("Octave:deprecated-syntax",
                        "%s; near line %d of file '%s'", msg,
-                       curr_lexer->input_line_number, nm.c_str ());
+                       curr_lexer->m_input_line_number, nm.c_str ());
 
     HANDLE_STRING_CONTINUATION;
   }
 
 <DQ_STRING_START>\\{S}+{NL} {
     curr_lexer->lexer_debug ("<DQ_STRING_START>\\\\{S}+{NL}");
 
     static const char *msg = "white space and comments after continuation markers in double-quoted character strings are obsolete and will not be allowed in a future version of Octave";
 
-    std::string nm = curr_lexer->fcn_file_full_name;
+    std::string nm = curr_lexer->m_fcn_file_full_name;
 
     if (nm.empty ())
       warning_with_id ("Octave:deprecated-syntax", "%s", msg);
     else
       warning_with_id ("Octave:deprecated-syntax",
                        "%s; near line %d of file '%s'", msg,
-                       curr_lexer->input_line_number, nm.c_str ());
+                       curr_lexer->m_input_line_number, nm.c_str ());
 
     HANDLE_STRING_CONTINUATION;
   }
 
 <DQ_STRING_START>\\{NL} {
     curr_lexer->lexer_debug ("<DQ_STRING_START>\\\\{NL}");
 
     HANDLE_STRING_CONTINUATION;
   }
 
 <DQ_STRING_START>\\. {
     curr_lexer->lexer_debug ("<DQ_STRING_START>\\\\.");
 
-    curr_lexer->current_input_column += yyleng;
-    curr_lexer->string_text += yytext[1];
+    curr_lexer->m_current_input_column += yyleng;
+    curr_lexer->m_string_text += yytext[1];
   }
 
 <DQ_STRING_START>\. {
     curr_lexer->lexer_debug ("<DQ_STRING_START>\\.");
 
-    curr_lexer->current_input_column++;
-    curr_lexer->string_text += yytext[0];
+    curr_lexer->m_current_input_column++;
+    curr_lexer->m_string_text += yytext[0];
   }
 
 <DQ_STRING_START>[^\.\\\r\n\"]+ {
     curr_lexer->lexer_debug ("<DQ_STRING_START>[^\\.\\\\\\r\\n\\\"]+");
 
-    curr_lexer->current_input_column += yyleng;
-    curr_lexer->string_text += yytext;
+    curr_lexer->m_current_input_column += yyleng;
+    curr_lexer->m_string_text += yytext;
   }
 
 <DQ_STRING_START>{NL} {
     curr_lexer->lexer_debug ("<DQ_STRING_START>{NL}");
 
     octave::token *tok
       = new octave::token (LEXICAL_ERROR,
                            "unterminated character string constant",
-                           curr_lexer->input_line_number,
-                           curr_lexer->current_input_column);
+                           curr_lexer->m_input_line_number,
+                           curr_lexer->m_current_input_column);
 
     curr_lexer->push_token (tok);
 
-    curr_lexer->input_line_number++;
-    curr_lexer->current_input_column = 1;
+    curr_lexer->m_input_line_number++;
+    curr_lexer->m_current_input_column = 1;
 
     return curr_lexer->count_token_internal (LEXICAL_ERROR);
   }
 
 %{
 // Single-quoted character strings.
 %}
 
 <SQ_STRING_START>\'\' {
     curr_lexer->lexer_debug ("<SQ_STRING_START>\\'\\'");
 
-    curr_lexer->current_input_column += yyleng;
-    curr_lexer->string_text += '\'';
+    curr_lexer->m_current_input_column += yyleng;
+    curr_lexer->m_string_text += '\'';
   }
 
 <SQ_STRING_START>\' {
     curr_lexer->lexer_debug ("<SQ_STRING_START>\\'");
 
-    curr_lexer->current_input_column++;
+    curr_lexer->m_current_input_column++;
 
     curr_lexer->pop_start_state ();
 
     if (curr_lexer->start_state() != COMMAND_START)
       {
-        curr_lexer->looking_for_object_index = true;
-        curr_lexer->at_beginning_of_statement = false;
+        curr_lexer->m_looking_for_object_index = true;
+        curr_lexer->m_at_beginning_of_statement = false;
 
         curr_lexer->push_token (new octave::token (SQ_STRING,
-                                                   curr_lexer->string_text,
-                                                   curr_lexer->string_line,
-                                                   curr_lexer->string_column));
-
-        curr_lexer->string_text = "";
+                                                   curr_lexer->m_string_text,
+                                                   curr_lexer->m_string_line,
+                                                   curr_lexer->m_string_column));
+
+        curr_lexer->m_string_text = "";
 
         return curr_lexer->count_token_internal (SQ_STRING);
       }
   }
 
 <SQ_STRING_START>[^\'\n\r]+ {
     curr_lexer->lexer_debug ("<SQ_STRING_START>[^\\'\\n\\r]+");
 
-    curr_lexer->current_input_column += yyleng;
-    curr_lexer->string_text += yytext;
+    curr_lexer->m_current_input_column += yyleng;
+    curr_lexer->m_string_text += yytext;
   }
 
 <SQ_STRING_START>{NL} {
     curr_lexer->lexer_debug ("<SQ_STRING_START>{NL}");
 
     octave::token *tok
       = new octave::token (LEXICAL_ERROR,
                            "unterminated character string constant",
-                           curr_lexer->input_line_number,
-                           curr_lexer->current_input_column);
+                           curr_lexer->m_input_line_number,
+                           curr_lexer->m_current_input_column);
 
     curr_lexer->push_token (tok);
 
-    curr_lexer->input_line_number++;
-    curr_lexer->current_input_column = 1;
+    curr_lexer->m_input_line_number++;
+    curr_lexer->m_current_input_column = 1;
 
     return curr_lexer->count_token_internal (LEXICAL_ERROR);
   }
 
 %{
 // Fully-qualified identifiers (used for classdef).
 %}
 
 <FQ_IDENT_START>{FQIDENT} {
     curr_lexer->lexer_debug ("<FQ_IDENT_START>{FQIDENT}");
     curr_lexer->pop_start_state ();
 
     int id_tok = curr_lexer->handle_fq_identifier ();
 
     if (id_tok >= 0)
       {
-        curr_lexer->looking_for_object_index = true;
+        curr_lexer->m_looking_for_object_index = true;
 
         return curr_lexer->count_token_internal (id_tok);
       }
   }
 
 <FQ_IDENT_START>{S}+ {
-    curr_lexer->current_input_column += yyleng;
+    curr_lexer->m_current_input_column += yyleng;
 
     curr_lexer->mark_previous_token_trailing_space ();
   }
 
 <FQ_IDENT_START>. {
     yyless (0);
     curr_lexer->pop_start_state ();
   }
@@ -1194,17 +1194,17 @@ ANY_INCLUDING_NL (.|{NL})
   }
 
 %{
 // Eat whitespace.  Whitespace inside matrix constants is handled by
 // the <MATRIX_START> start state code above.
 %}
 
 {S}+ {
-    curr_lexer->current_input_column += yyleng;
+    curr_lexer->m_current_input_column += yyleng;
 
     curr_lexer->mark_previous_token_trailing_space ();
   }
 
 %{
 // Continuation lines.  Allow arbitrary text after continuations.
 %}
 
@@ -1219,24 +1219,24 @@ ANY_INCLUDING_NL (.|{NL})
 %}
 
 \\{S}*{NL} |
 \\{S}*{CCHAR}{ANY_EXCEPT_NL}*{NL} {
     curr_lexer->lexer_debug ("\\\\{S}*{NL}|\\\\{S}*{CCHAR}{ANY_EXCEPT_NL}*{NL}");
 
     static const char *msg = "using continuation marker \\ outside of double quoted strings is deprecated and will be removed from a future version of Octave, use ... instead";
 
-    std::string nm = curr_lexer->fcn_file_full_name;
+    std::string nm = curr_lexer->m_fcn_file_full_name;
 
     if (nm.empty ())
       warning_with_id ("Octave:deprecated-syntax", "%s", msg);
     else
       warning_with_id ("Octave:deprecated-syntax",
                        "%s; near line %d of file '%s'", msg,
-                       curr_lexer->input_line_number, nm.c_str ());
+                       curr_lexer->m_input_line_number, nm.c_str ());
 
     curr_lexer->handle_continuation ();
   }
 
 %{
 // End of file.
 %}
 
@@ -1272,17 +1272,17 @@ ANY_INCLUDING_NL (.|{NL})
         curr_lexer->push_start_state (COMMAND_START);
       }
     else
       {
         int id_tok = curr_lexer->handle_superclass_identifier ();
 
         if (id_tok >= 0)
           {
-            curr_lexer->looking_for_object_index = true;
+            curr_lexer->m_looking_for_object_index = true;
 
             return curr_lexer->count_token_internal (id_tok);
           }
       }
   }
 
 %{
 // Metaclass query
@@ -1298,17 +1298,17 @@ ANY_INCLUDING_NL (.|{NL})
         curr_lexer->push_start_state (COMMAND_START);
       }
     else
       {
         int id_tok = curr_lexer->handle_meta_identifier ();
 
         if (id_tok >= 0)
           {
-            curr_lexer->looking_for_object_index = true;
+            curr_lexer->m_looking_for_object_index = true;
 
             return curr_lexer->count_token_internal (id_tok);
           }
       }
   }
 
 "@" {
     curr_lexer->lexer_debug ("@");
@@ -1328,134 +1328,134 @@ ANY_INCLUDING_NL (.|{NL})
             && ! (tok == '[' || tok == '{'
                   || curr_lexer->previous_token_is_binop ()))
           {
             yyless (0);
             unput (',');
           }
         else
           {
-            curr_lexer->current_input_column++;
-
-            curr_lexer->looking_at_function_handle++;
-            curr_lexer->looking_for_object_index = false;
-            curr_lexer->at_beginning_of_statement = false;
+            curr_lexer->m_current_input_column++;
+
+            curr_lexer->m_looking_at_function_handle++;
+            curr_lexer->m_looking_for_object_index = false;
+            curr_lexer->m_at_beginning_of_statement = false;
 
             return curr_lexer->count_token ('@');
           }
       }
   }
 
 %{
 // A new line character.  New line characters inside matrix constants
 // are handled by the <MATRIX_START> start state code above.  If closest
 // nesting is inside parentheses, don't return a row separator.
 %}
 
 {NL} {
     curr_lexer->lexer_debug ("{NL}");
 
-    if (curr_lexer->nesting_level.is_paren ())
+    if (curr_lexer->m_nesting_level.is_paren ())
       {
-        curr_lexer->input_line_number++;
-        curr_lexer->current_input_column = 1;
-
-        curr_lexer->at_beginning_of_statement = false;
+        curr_lexer->m_input_line_number++;
+        curr_lexer->m_current_input_column = 1;
+
+        curr_lexer->m_at_beginning_of_statement = false;
         curr_lexer->warn_language_extension
           ("bare newline inside parentheses");
       }
-    else if (curr_lexer->nesting_level.none ()
-        || curr_lexer->nesting_level.is_anon_fcn_body ())
+    else if (curr_lexer->m_nesting_level.none ()
+        || curr_lexer->m_nesting_level.is_anon_fcn_body ())
       {
-        curr_lexer->input_line_number++;
-        curr_lexer->current_input_column = 1;
-
-        curr_lexer->at_beginning_of_statement = true;
+        curr_lexer->m_input_line_number++;
+        curr_lexer->m_current_input_column = 1;
+
+        curr_lexer->m_at_beginning_of_statement = true;
 
         return curr_lexer->count_token ('\n');
       }
-    else if (curr_lexer->nesting_level.is_bracket_or_brace ())
+    else if (curr_lexer->m_nesting_level.is_bracket_or_brace ())
       {
         octave::token *tok
           = new octave::token (LEXICAL_ERROR,
                                "unexpected internal lexer error",
-                               curr_lexer->input_line_number,
-                               curr_lexer->current_input_column);
+                               curr_lexer->m_input_line_number,
+                               curr_lexer->m_current_input_column);
 
         curr_lexer->push_token (tok);
 
-        curr_lexer->input_line_number++;
-        curr_lexer->current_input_column = 1;
+        curr_lexer->m_input_line_number++;
+        curr_lexer->m_current_input_column = 1;
 
         return curr_lexer->count_token_internal (LEXICAL_ERROR);
       }
   }
 
 %{
 // Single quote can either be the beginning of a string or a transpose
 // operator.
 %}
 
 "'" {
     curr_lexer->lexer_debug ("'");
 
     if (curr_lexer->previous_token_may_be_command ()
         &&  curr_lexer->space_follows_previous_token ())
       {
-        curr_lexer->current_input_column++;
+        curr_lexer->m_current_input_column++;
         curr_lexer->push_start_state (COMMAND_START);
         curr_lexer->begin_string (SQ_STRING_START);
       }
-    else if (curr_lexer->at_beginning_of_statement)
+    else if (curr_lexer->m_at_beginning_of_statement)
       {
-        curr_lexer->current_input_column++;
+        curr_lexer->m_current_input_column++;
         curr_lexer->begin_string (SQ_STRING_START);
       }
     else
       {
         int tok = curr_lexer->previous_token_value ();
 
         if (curr_lexer->whitespace_is_significant ())
           {
             if (curr_lexer->space_follows_previous_token ())
               {
                 if (tok == '[' || tok == '{'
                     || curr_lexer->previous_token_is_binop ())
                   {
-                    curr_lexer->current_input_column++;
+                    curr_lexer->m_current_input_column++;
                     curr_lexer->begin_string (SQ_STRING_START);
                   }
                 else
                   {
                     yyless (0);
                     curr_lexer->xunput (',');
                     // Adjust for comma that was not really in the input stream.
-                    curr_lexer->current_input_column--;
+                    curr_lexer->m_current_input_column--;
                   }
               }
             else
               {
                 if (tok == '[' || tok == '{'
                     || curr_lexer->previous_token_is_binop ()
                     || curr_lexer->previous_token_is_keyword ())
                   {
-                    curr_lexer->current_input_column++;
+                    curr_lexer->m_current_input_column++;
                     curr_lexer->begin_string (SQ_STRING_START);
                   }
                 else
                   return curr_lexer->count_token (HERMITIAN);
               }
           }
         else
           {
             if (! tok || tok == '[' || tok == '{' || tok == '('
                 || curr_lexer->previous_token_is_binop ()
                 || curr_lexer->previous_token_is_keyword ())
               {
-                curr_lexer->current_input_column++;
+                curr_lexer->m_current_input_column++;
                 curr_lexer->begin_string (SQ_STRING_START);
               }
             else
               return curr_lexer->count_token (HERMITIAN);
           }
       }
   }
 
@@ -1464,51 +1464,51 @@ ANY_INCLUDING_NL (.|{NL})
 %}
 
 \" {
     curr_lexer->lexer_debug ("\\\"");
 
     if (curr_lexer->previous_token_may_be_command ()
         &&  curr_lexer->space_follows_previous_token ())
       {
-        curr_lexer->current_input_column++;
+        curr_lexer->m_current_input_column++;
         curr_lexer->push_start_state (COMMAND_START);
         curr_lexer->begin_string (DQ_STRING_START);
       }
     else
       {
         int tok = curr_lexer->previous_token_value ();
 
         if (curr_lexer->whitespace_is_significant ())
           {
             if (curr_lexer->space_follows_previous_token ())
               {
                 if (tok == '[' || tok == '{'
                     || curr_lexer->previous_token_is_binop ())
                   {
-                    curr_lexer->current_input_column++;
+                    curr_lexer->m_current_input_column++;
                     curr_lexer->begin_string (DQ_STRING_START);
                   }
                 else
                   {
                     yyless (0);
                     curr_lexer->xunput (',');
                     // Adjust for comma that was not really in the input stream.
-                    curr_lexer->current_input_column--;
+                    curr_lexer->m_current_input_column--;
                   }
               }
             else
               {
-                curr_lexer->current_input_column++;
+                curr_lexer->m_current_input_column++;
                 curr_lexer->begin_string (DQ_STRING_START);
               }
           }
         else
           {
-            curr_lexer->current_input_column++;
+            curr_lexer->m_current_input_column++;
             curr_lexer->begin_string (DQ_STRING_START);
           }
       }
   }
 
 %{
 // Other operators.
 %}
@@ -1542,31 +1542,31 @@ ANY_INCLUDING_NL (.|{NL})
 "^"   { CMD_OR_OP ("^", POW, true); }
 "**"  { CMD_OR_OP ("**", POW, false); }
 "&&"  { CMD_OR_OP ("&&", EXPR_AND_AND, true); }
 "||"  { CMD_OR_OP ("||", EXPR_OR_OR, true); }
 
 ";" {
     bool at_beginning_of_statement
       = (! (curr_lexer->whitespace_is_significant ()
-            || curr_lexer->looking_at_object_index.front ()));
+            || curr_lexer->m_looking_at_object_index.front ()));
 
     return curr_lexer->handle_op (";", ';', at_beginning_of_statement);
   }
 
 "+" { CMD_OR_UNARY_OP ("+", '+', true); }
 "-" { CMD_OR_UNARY_OP ("-", '-', true); }
 
 "~" { CMD_OR_UNARY_OP ("~", EXPR_NOT, true); }
 "!" { CMD_OR_UNARY_OP ("!", EXPR_NOT, false); }
 
 "," {
     bool at_beginning_of_statement
       = (! (curr_lexer->whitespace_is_significant ()
-            || curr_lexer->looking_at_object_index.front ()));
+            || curr_lexer->m_looking_at_object_index.front ()));
 
     return curr_lexer->handle_op (",", ',', at_beginning_of_statement);
   }
 
 ".'" {
     return curr_lexer->handle_op (".'", TRANSPOSE, false);
   }
 
@@ -1588,72 +1588,72 @@ ANY_INCLUDING_NL (.|{NL})
           unput_comma = true;
       }
 
     if (unput_comma)
       {
         yyless (0);
         curr_lexer->xunput (',');
         // Adjust for comma that was not really in the input stream.
-        curr_lexer->current_input_column--;
+        curr_lexer->m_current_input_column--;
       }
     else
       {
         // If we are looking for an object index, then push TRUE for
-        // looking_at_object_index.  Otherwise, just push whatever state
+        // m_looking_at_object_index.  Otherwise, just push whatever state
         // is current (so that we can pop it off the stack when we find
         // the matching close paren).
 
-        curr_lexer->looking_at_object_index.push_front
-          (curr_lexer->looking_for_object_index);
-
-        curr_lexer->looking_at_indirect_ref = false;
-        curr_lexer->looking_for_object_index = false;
-        curr_lexer->at_beginning_of_statement = false;
-
-        curr_lexer->nesting_level.paren ();
+        curr_lexer->m_looking_at_object_index.push_front
+          (curr_lexer->m_looking_for_object_index);
+
+        curr_lexer->m_looking_at_indirect_ref = false;
+        curr_lexer->m_looking_for_object_index = false;
+        curr_lexer->m_at_beginning_of_statement = false;
+
+        curr_lexer->m_nesting_level.paren ();
         curr_lexer->decrement_promptflag ();
 
         return curr_lexer->handle_token ('(');
       }
   }
 
 ")" {
     curr_lexer->lexer_debug (")");
 
-    curr_lexer->nesting_level.remove ();
-    curr_lexer->current_input_column++;
-
-    curr_lexer->looking_at_object_index.pop_front ();
-
-    curr_lexer->looking_for_object_index = true;
-    curr_lexer->at_beginning_of_statement = false;
-
-    if (curr_lexer->looking_at_anon_fcn_args)
+    curr_lexer->m_nesting_level.remove ();
+    curr_lexer->m_current_input_column++;
+
+    curr_lexer->m_looking_at_object_index.pop_front ();
+
+    curr_lexer->m_looking_for_object_index = true;
+    curr_lexer->m_at_beginning_of_statement = false;
+
+    if (curr_lexer->m_looking_at_anon_fcn_args)
       {
-        curr_lexer->looking_at_anon_fcn_args = false;
-        curr_lexer->nesting_level.anon_fcn_body ();
+        curr_lexer->m_looking_at_anon_fcn_args = false;
+        curr_lexer->m_nesting_level.anon_fcn_body ();
       }
 
     return curr_lexer->count_token (')');
   }
 
 "." {
     curr_lexer->lexer_debug (".");
 
     if (curr_lexer->previous_token_may_be_command ()
         && curr_lexer->space_follows_previous_token ())
       {
         yyless (0);
         curr_lexer->push_start_state (COMMAND_START);
       }
     else
       {
-        curr_lexer->looking_for_object_index = false;
-        curr_lexer->at_beginning_of_statement = false;
+        curr_lexer->m_looking_for_object_index = false;
+        curr_lexer->m_at_beginning_of_statement = false;
 
         return curr_lexer->handle_token ('.');
       }
   }
 
 %{
 // = and op= operators.
 %}
@@ -1700,48 +1700,48 @@ ANY_INCLUDING_NL (.|{NL})
           unput_comma = true;
       }
 
     if (unput_comma)
       {
         yyless (0);
         curr_lexer->xunput (',');
         // Adjust for comma that was not really in the input stream.
-        curr_lexer->current_input_column--;
+        curr_lexer->m_current_input_column--;
       }
     else
       {
-        curr_lexer->nesting_level.brace ();
-
-        curr_lexer->looking_at_object_index.push_front
-          (curr_lexer->looking_for_object_index);
-
-        curr_lexer->current_input_column += yyleng;
-        curr_lexer->looking_for_object_index = false;
-        curr_lexer->at_beginning_of_statement = false;
+        curr_lexer->m_nesting_level.brace ();
+
+        curr_lexer->m_looking_at_object_index.push_front
+          (curr_lexer->m_looking_for_object_index);
+
+        curr_lexer->m_current_input_column += yyleng;
+        curr_lexer->m_looking_for_object_index = false;
+        curr_lexer->m_at_beginning_of_statement = false;
 
         curr_lexer->decrement_promptflag ();
 
-        curr_lexer->braceflag++;
+        curr_lexer->m_braceflag++;
 
         curr_lexer->push_start_state (MATRIX_START);
 
         return curr_lexer->count_token ('{');
       }
   }
 
 "}" {
     curr_lexer->lexer_debug ("}");
 
-    curr_lexer->looking_at_object_index.pop_front ();
-
-    curr_lexer->looking_for_object_index = true;
-    curr_lexer->at_beginning_of_statement = false;
-
-    curr_lexer->nesting_level.remove ();
+    curr_lexer->m_looking_at_object_index.pop_front ();
+
+    curr_lexer->m_looking_for_object_index = true;
+    curr_lexer->m_at_beginning_of_statement = false;
+
+    curr_lexer->m_nesting_level.remove ();
 
     return curr_lexer->handle_token ('}');
   }
 
 %{
 // Unrecognized input is a lexical error.
 %}
 
@@ -1761,22 +1761,22 @@ ANY_INCLUDING_NL (.|{NL})
         std::ostringstream buf;
 
         buf << "invalid character '"
             << undo_string_escape (static_cast<char> (c))
             << "' (ASCII " << c << ")";
 
         octave::token *tok
           = new octave::token (LEXICAL_ERROR, buf.str (),
-                               curr_lexer->input_line_number,
-                               curr_lexer->current_input_column);
+                               curr_lexer->m_input_line_number,
+                               curr_lexer->m_current_input_column);
 
         curr_lexer->push_token (tok);
 
-        curr_lexer->current_input_column++;
+        curr_lexer->m_current_input_column++;
 
         return curr_lexer->count_token_internal (LEXICAL_ERROR);
       }
   }
 
 %{
 #if defined (HAVE_PRAGMA_GCC_DIAGNOSTIC)
    // Disable these warnings for flex code.
@@ -2074,147 +2074,149 @@ debug information as it processes an exp
   return retval;
 }
 
 namespace octave
 {
   void
   lexical_feedback::symbol_table_context::clear (void)
   {
-    while (! frame_stack.empty ())
-      frame_stack.pop_front ();
+    while (! m_frame_stack.empty ())
+      m_frame_stack.pop_front ();
   }
 
   void
   lexical_feedback::symbol_table_context::pop (void)
   {
     if (empty ())
       panic_impossible ();
 
-    frame_stack.pop_front ();
+    m_frame_stack.pop_front ();
   }
 
   symbol_scope
   lexical_feedback::symbol_table_context::curr_scope (void) const
   {
     if (empty ())
       {
         symbol_scope scope
           = __get_current_scope__ ("lexical_feedback::symbol_table_context::curr_scope");
 
         return scope;
       }
     else
-      return frame_stack.front ();
+      return m_frame_stack.front ();
   }
 
   symbol_scope
   lexical_feedback::symbol_table_context::parent_scope (void) const
   {
     size_t sz = size ();
 
-    return sz > 1 ? frame_stack[1] : (sz == 1 ? frame_stack[0] : symbol_scope ());
+    return (sz > 1
+            ? m_frame_stack[1]
+            : (sz == 1 ? m_frame_stack[0] : symbol_scope ()));
   }
 
   lexical_feedback::~lexical_feedback (void)
   {
-    tokens.clear ();
+    m_tokens.clear ();
   }
 
   void
   lexical_feedback::init (void)
   {
     // The closest paren, brace, or bracket nesting is not an object
     // index.
-    looking_at_object_index.push_front (false);
+    m_looking_at_object_index.push_front (false);
   }
 
   void
   lexical_feedback::reset (void)
   {
-    end_of_input = false;
-    at_beginning_of_statement = true;
-    looking_at_anon_fcn_args = false;
-    looking_at_return_list = false;
-    looking_at_parameter_list = false;
-    looking_at_decl_list = false;
-    looking_at_initializer_expression = false;
-    looking_at_matrix_or_assign_lhs = false;
-    looking_for_object_index = false;
-    looking_at_indirect_ref = false;
-    parsing_class_method = false;
-    parsing_classdef = false;
-    maybe_classdef_get_set_method = false;
-    parsing_classdef_get_method = false;
-    parsing_classdef_set_method = false;
-    quote_is_transpose = false;
-    force_script = false;
-    reading_fcn_file = false;
-    reading_script_file = false;
-    reading_classdef_file = false;
-    buffer_function_text = false;
-    input_line_number = 1;
-    current_input_column = 1;
-    bracketflag = 0;
-    braceflag = 0;
-    looping = 0;
-    defining_func = 0;
-    looking_at_function_handle = 0;
-    block_comment_nesting_level = 0;
-    command_arg_paren_count = 0;
-    token_count = 0;
-    current_input_line = "";
-    comment_text = "";
-    help_text = "";
-    function_text = "";
-    string_text = "";
-    string_line = 0;
-    string_column = 0;
-    fcn_file_name = "";
-    fcn_file_full_name = "";
-    dir_name = "";
-    package_name = "";
-    looking_at_object_index.clear ();
-    looking_at_object_index.push_front (false);
-
-    while (! parsed_function_name.empty ())
-      parsed_function_name.pop ();
-
-    pending_local_variables.clear ();
-    symtab_context.clear ();
-    nesting_level.reset ();
-    tokens.clear ();
+    m_end_of_input = false;
+    m_at_beginning_of_statement = true;
+    m_looking_at_anon_fcn_args = false;
+    m_looking_at_return_list = false;
+    m_looking_at_parameter_list = false;
+    m_looking_at_decl_list = false;
+    m_looking_at_initializer_expression = false;
+    m_looking_at_matrix_or_assign_lhs = false;
+    m_looking_for_object_index = false;
+    m_looking_at_indirect_ref = false;
+    m_parsing_class_method = false;
+    m_parsing_classdef = false;
+    m_maybe_classdef_get_set_method = false;
+    m_parsing_classdef_get_method = false;
+    m_parsing_classdef_set_method = false;
+    m_quote_is_transpose = false;
+    m_force_script = false;
+    m_reading_fcn_file = false;
+    m_reading_script_file = false;
+    m_reading_classdef_file = false;
+    m_buffer_function_text = false;
+    m_input_line_number = 1;
+    m_current_input_column = 1;
+    m_bracketflag = 0;
+    m_braceflag = 0;
+    m_looping = 0;
+    m_defining_func = 0;
+    m_looking_at_function_handle = 0;
+    m_block_comment_nesting_level = 0;
+    m_command_arg_paren_count = 0;
+    m_token_count = 0;
+    m_current_input_line = "";
+    m_comment_text = "";
+    m_help_text = "";
+    m_function_text = "";
+    m_string_text = "";
+    m_string_line = 0;
+    m_string_column = 0;
+    m_fcn_file_name = "";
+    m_fcn_file_full_name = "";
+    m_dir_name = "";
+    m_package_name = "";
+    m_looking_at_object_index.clear ();
+    m_looking_at_object_index.push_front (false);
+
+    while (! m_parsed_function_name.empty ())
+      m_parsed_function_name.pop ();
+
+    m_pending_local_variables.clear ();
+    m_symtab_context.clear ();
+    m_nesting_level.reset ();
+    m_tokens.clear ();
   }
 
   int
   lexical_feedback::previous_token_value (void) const
   {
-    const token *tok = tokens.front ();
+    const token *tok = m_tokens.front ();
     return tok ? tok->token_value () : 0;
   }
 
   bool
   lexical_feedback::previous_token_value_is (int tok_val) const
   {
-    const token *tok = tokens.front ();
+    const token *tok = m_tokens.front ();
     return tok ? tok->token_value_is (tok_val) : false;
   }
 
   void
   lexical_feedback::mark_previous_token_trailing_space (void)
   {
-    token *tok = tokens.front ();
+    token *tok = m_tokens.front ();
     if (tok && ! previous_token_value_is ('\n'))
       tok->mark_trailing_space ();
   }
 
   bool
   lexical_feedback::space_follows_previous_token (void) const
   {
-    const token *tok = tokens.front ();
+    const token *tok = m_tokens.front ();
     return tok ? tok->space_follows_token () : false;
   }
 
   bool
   lexical_feedback::previous_token_is_binop (void) const
   {
     int tok = previous_token_value ();
 
@@ -2231,41 +2233,41 @@ namespace octave
             || tok == EXPR_OR_OR || tok == LEFTDIV || tok == LEFTDIV_EQ
             || tok == MUL_EQ || tok == OR_EQ || tok == POW
             || tok == POW_EQ || tok == SUB_EQ);
   }
 
   bool
   lexical_feedback::previous_token_is_keyword (void) const
   {
-    const token *tok = tokens.front ();
+    const token *tok = m_tokens.front ();
     return tok ? tok->is_keyword () : false;
   }
 
   bool
   lexical_feedback::previous_token_may_be_command (void) const
   {
-    const token *tok = tokens.front ();
+    const token *tok = m_tokens.front ();
     return tok ? tok->may_be_command () : false;
   }
 
   void
   lexical_feedback::maybe_mark_previous_token_as_variable (void)
   {
-    token *tok = tokens.front ();
+    token *tok = m_tokens.front ();
 
     if (tok && tok->is_symbol ())
-      pending_local_variables.insert (tok->symbol_name ());
+      m_pending_local_variables.insert (tok->symbol_name ());
   }
 
   void
   lexical_feedback::mark_as_variables (const std::list<std::string>& lst)
   {
     for (const auto& var : lst)
-      pending_local_variables.insert (var);
+      m_pending_local_variables.insert (var);
   }
 }
 
 static bool
 looks_like_copyright (const std::string& s)
 {
   bool retval = false;
 
@@ -2286,173 +2288,173 @@ looks_like_shebang (const std::string& s
   return ((! s.empty ()) && (s[0] == '!'));
 }
 
 namespace octave
 {
   void
   base_lexer::input_buffer::fill (const std::string& input, bool eof_arg)
   {
-    buffer = input;
-    chars_left = buffer.length ();
-    pos = buffer.c_str ();
-    eof = eof_arg;
+    m_buffer = input;
+    m_chars_left = m_buffer.length ();
+    m_pos = m_buffer.c_str ();
+    m_eof = eof_arg;
   }
 
   int
   base_lexer::input_buffer::copy_chunk (char *buf, size_t max_size)
   {
     static const char * const eol = "\n";
 
-    size_t len = max_size > chars_left ? chars_left : max_size;
+    size_t len = max_size > m_chars_left ? m_chars_left : max_size;
     assert (len > 0);
 
-    memcpy (buf, pos, len);
-
-    chars_left -= len;
-    pos += len;
+    memcpy (buf, m_pos, len);
+
+    m_chars_left -= len;
+    m_pos += len;
 
     // Make sure input ends with a new line character.
-    if (chars_left == 0 && buf[len-1] != '\n')
+    if (m_chars_left == 0 && buf[len-1] != '\n')
       {
         if (len < max_size)
           {
             // There is enough room to plug the newline character in
             // the buffer.
             buf[len++] = '\n';
           }
         else
           {
             // There isn't enough room to plug the newline character
             // in the buffer so arrange to have it returned on the next
             // call to base_lexer::read.
-            pos = eol;
-            chars_left = 1;
+            m_pos = eol;
+            m_chars_left = 1;
           }
       }
 
     return len;
   }
 
   base_lexer::~base_lexer (void)
   {
-    yylex_destroy (scanner);
+    yylex_destroy (m_scanner);
   }
 
   void
   base_lexer::init (void)
   {
-    yylex_init (&scanner);
+    yylex_init (&m_scanner);
 
     // Make base_lexer object available through yyextra in
     // flex-generated lexer.
-    yyset_extra (this, scanner);
+    yyset_extra (this, m_scanner);
 
     clear_start_state ();
   }
 
   // Inside Flex-generated functions, yyg is the scanner cast to its real
   // type.  Some flex macros that we use in base_lexer member functions
   // (for example, BEGIN) use yyg.  If we could perform the actions of
   // these macros with functions instead, we could eliminate the
   // OCTAVE_YYG macro.
 
 #define OCTAVE_YYG                                                      \
-  struct yyguts_t *yyg = static_cast<struct yyguts_t*> (scanner)
+  struct yyguts_t *yyg = static_cast<struct yyguts_t*> (m_scanner)
 
   void
   base_lexer::reset (void)
   {
     // Start off on the right foot.
     clear_start_state ();
 
-    symtab_context.clear ();
+    m_symtab_context.clear ();
 
     // We do want a prompt by default.
     promptflag (1);
 
     // Only ask for input from stdin if we are expecting interactive
     // input.
 
     if (application::interactive ()
-        && ! (reading_fcn_file
-              || reading_classdef_file
-              || reading_script_file
+        && ! (m_reading_fcn_file
+              || m_reading_classdef_file
+              || m_reading_script_file
               || input_from_eval_string ()))
-      yyrestart (stdin, scanner);
+      yyrestart (stdin, m_scanner);
 
     lexical_feedback::reset ();
 
-    comment_buf.reset ();
+    m_comment_buf.reset ();
   }
 
   void
   base_lexer::prep_for_file (void)
   {
-    reading_script_file = true;
+    m_reading_script_file = true;
 
     push_start_state (INPUT_FILE_START);
   }
 
   void
   base_lexer::begin_string (int state)
   {
-    string_line = input_line_number;
-    string_column = current_input_column;
+    m_string_line = m_input_line_number;
+    m_string_column = m_current_input_column;
 
     push_start_state (state);
   }
 
   int
   base_lexer::handle_end_of_input (void)
   {
     lexer_debug ("<<EOF>>");
 
-    if (block_comment_nesting_level != 0)
+    if (m_block_comment_nesting_level != 0)
       {
         warning ("block comment open at end of input");
 
-        if ((reading_fcn_file || reading_script_file || reading_classdef_file)
-            && ! fcn_file_name.empty ())
+        if ((m_reading_fcn_file || m_reading_script_file || m_reading_classdef_file)
+            && ! m_fcn_file_name.empty ())
           warning ("near line %d of file '%s.m'",
-                   input_line_number, fcn_file_name.c_str ());
+                   m_input_line_number, m_fcn_file_name.c_str ());
       }
 
     return handle_token (END_OF_INPUT);
   }
 
   char *
   base_lexer::flex_yytext (void)
   {
-    return yyget_text (scanner);
+    return yyget_text (m_scanner);
   }
 
   int
   base_lexer::flex_yyleng (void)
   {
-    return yyget_leng (scanner);
+    return yyget_leng (m_scanner);
   }
 
   int
   base_lexer::text_yyinput (void)
   {
-    int c = yyinput (scanner);
+    int c = yyinput (m_scanner);
 
     if (lexer_debug_flag)
       {
         std::cerr << "I: ";
         display_character (c);
         std::cerr << std::endl;
       }
 
     // Convert CRLF into just LF and single CR into LF.
 
     if (c == '\r')
       {
-        c = yyinput (scanner);
+        c = yyinput (m_scanner);
 
         if (lexer_debug_flag)
           {
             std::cerr << "I: ";
             display_character (c);
             std::cerr << std::endl;
           }
 
@@ -2473,17 +2475,17 @@ namespace octave
       {
         if (lexer_debug_flag)
           {
             std::cerr << "U: ";
             display_character (c);
             std::cerr << std::endl;
           }
 
-        yyunput (c, buf, scanner);
+        yyunput (c, buf, m_scanner);
       }
   }
 
   void
   base_lexer::xunput (char c)
   {
     char *yytxt = flex_yytext ();
 
@@ -2498,249 +2500,249 @@ namespace octave
     return (c == ' ' || c == '\t');
   }
 
   bool
   base_lexer::inside_any_object_index (void)
   {
     bool retval = false;
 
-    for (const bool is_obj_idx : looking_at_object_index)
+    for (const bool is_obj_idx : m_looking_at_object_index)
       {
         if (is_obj_idx)
           {
             retval = true;
             break;
           }
       }
 
     return retval;
   }
 
   bool
   base_lexer::is_variable (const std::string& name,
                            const symbol_scope& scope)
   {
     return ((scope && scope.is_variable (name))
-            || (pending_local_variables.find (name)
-                != pending_local_variables.end ()));
+            || (m_pending_local_variables.find (name)
+                != m_pending_local_variables.end ()));
   }
 
   // Handle keywords.  Return -1 if the keyword should be ignored.
 
   int
   base_lexer::is_keyword_token (const std::string& s)
   {
-    int l = input_line_number;
-    int c = current_input_column;
+    int l = m_input_line_number;
+    int c = m_current_input_column;
 
     int len = s.length ();
 
     const octave_kw *kw = octave_kw_hash::in_word_set (s.c_str (), len);
 
     if (kw)
       {
-        bool previous_at_bos = at_beginning_of_statement;
+        bool previous_at_bos = m_at_beginning_of_statement;
 
         // May be reset to true for some token types.
-        at_beginning_of_statement = false;
+        m_at_beginning_of_statement = false;
 
         token *tok_val = nullptr;
 
         switch (kw->kw_id)
           {
           case break_kw:
           case catch_kw:
           case continue_kw:
           case else_kw:
           case otherwise_kw:
           case return_kw:
           case unwind_protect_cleanup_kw:
-            at_beginning_of_statement = true;
+            m_at_beginning_of_statement = true;
             break;
 
           case persistent_kw:
           case global_kw:
-            looking_at_decl_list = true;
+            m_looking_at_decl_list = true;
             break;
 
           case case_kw:
           case elseif_kw:
           case until_kw:
             break;
 
           case end_kw:
             if (inside_any_object_index ()
-                || (defining_func
-                    && ! (looking_at_return_list
-                          || parsed_function_name.top ())))
+                || (m_defining_func
+                    && ! (m_looking_at_return_list
+                          || m_parsed_function_name.top ())))
               {
-                at_beginning_of_statement = previous_at_bos;
+                m_at_beginning_of_statement = previous_at_bos;
                 return 0;
               }
 
             tok_val = new token (end_kw, token::simple_end, l, c);
-            at_beginning_of_statement = true;
+            m_at_beginning_of_statement = true;
             break;
 
           case end_try_catch_kw:
             tok_val = new token (end_try_catch_kw, token::try_catch_end, l, c);
-            at_beginning_of_statement = true;
+            m_at_beginning_of_statement = true;
             break;
 
           case end_unwind_protect_kw:
             tok_val = new token (end_unwind_protect_kw,
                                  token::unwind_protect_end, l, c);
-            at_beginning_of_statement = true;
+            m_at_beginning_of_statement = true;
             break;
 
           case endfor_kw:
             tok_val = new token (endfor_kw, token::for_end, l, c);
-            at_beginning_of_statement = true;
+            m_at_beginning_of_statement = true;
             break;
 
           case endfunction_kw:
             tok_val = new token (endfunction_kw, token::function_end, l, c);
-            at_beginning_of_statement = true;
+            m_at_beginning_of_statement = true;
             break;
 
           case endif_kw:
             tok_val = new token (endif_kw, token::if_end, l, c);
-            at_beginning_of_statement = true;
+            m_at_beginning_of_statement = true;
             break;
 
           case endparfor_kw:
             tok_val = new token (endparfor_kw, token::parfor_end, l, c);
-            at_beginning_of_statement = true;
+            m_at_beginning_of_statement = true;
             break;
 
           case endswitch_kw:
             tok_val = new token (endswitch_kw, token::switch_end, l, c);
-            at_beginning_of_statement = true;
+            m_at_beginning_of_statement = true;
             break;
 
           case endwhile_kw:
             tok_val = new token (endwhile_kw, token::while_end, l, c);
-            at_beginning_of_statement = true;
+            m_at_beginning_of_statement = true;
             break;
 
           case endclassdef_kw:
             tok_val = new token (endclassdef_kw, token::classdef_end, l, c);
-            at_beginning_of_statement = true;
+            m_at_beginning_of_statement = true;
             break;
 
           case endenumeration_kw:
             tok_val = new token (endenumeration_kw, token::enumeration_end, l, c);
-            at_beginning_of_statement = true;
+            m_at_beginning_of_statement = true;
             break;
 
           case endevents_kw:
             tok_val = new token (endevents_kw, token::events_end, l, c);
-            at_beginning_of_statement = true;
+            m_at_beginning_of_statement = true;
             break;
 
           case endmethods_kw:
             tok_val = new token (endmethods_kw, token::methods_end, l, c);
-            at_beginning_of_statement = true;
+            m_at_beginning_of_statement = true;
             break;
 
           case endproperties_kw:
             tok_val = new token (endproperties_kw, token::properties_end, l, c);
-            at_beginning_of_statement = true;
+            m_at_beginning_of_statement = true;
             break;
 
 
           case for_kw:
           case parfor_kw:
           case while_kw:
             decrement_promptflag ();
-            looping++;
+            m_looping++;
             break;
 
           case do_kw:
-            at_beginning_of_statement = true;
+            m_at_beginning_of_statement = true;
             decrement_promptflag ();
-            looping++;
+            m_looping++;
             break;
 
           case try_kw:
           case unwind_protect_kw:
-            at_beginning_of_statement = true;
+            m_at_beginning_of_statement = true;
             decrement_promptflag ();
             break;
 
           case if_kw:
           case switch_kw:
             decrement_promptflag ();
             break;
 
           case get_kw:
           case set_kw:
             // 'get' and 'set' are keywords in classdef method
             // declarations.
-            if (! maybe_classdef_get_set_method)
+            if (! m_maybe_classdef_get_set_method)
               {
-                at_beginning_of_statement = previous_at_bos;
+                m_at_beginning_of_statement = previous_at_bos;
                 return 0;
               }
             break;
 
           case enumeration_kw:
           case events_kw:
           case methods_kw:
           case properties_kw:
             // 'properties', 'methods' and 'events' are keywords for
             // classdef blocks.
-            if (! parsing_classdef)
+            if (! m_parsing_classdef)
               {
-                at_beginning_of_statement = previous_at_bos;
+                m_at_beginning_of_statement = previous_at_bos;
                 return 0;
               }
             // fall through ...
 
           case classdef_kw:
             // 'classdef' is always a keyword.
             decrement_promptflag ();
 
-            if (! force_script && token_count == 0 && input_from_file ())
+            if (! m_force_script && m_token_count == 0 && input_from_file ())
               {
-                reading_classdef_file = true;
-                reading_script_file = false;
+                m_reading_classdef_file = true;
+                m_reading_script_file = false;
               }
             break;
 
           case function_kw:
             decrement_promptflag ();
 
-            defining_func++;
-            parsed_function_name.push (false);
-
-            if (! force_script && token_count == 0 && input_from_file ())
+            m_defining_func++;
+            m_parsed_function_name.push (false);
+
+            if (! m_force_script && m_token_count == 0 && input_from_file ())
               {
-                reading_fcn_file = true;
-                reading_script_file = false;
+                m_reading_fcn_file = true;
+                m_reading_script_file = false;
               }
 
-            if (! (reading_fcn_file || reading_script_file
-                   || reading_classdef_file))
+            if (! (m_reading_fcn_file || m_reading_script_file
+                   || m_reading_classdef_file))
               {
                 // Input must be coming from the terminal or stdin?
-                buffer_function_text = true;
-                function_text += (current_input_line + "\n");
-
-                input_line_number = 1;
+                m_buffer_function_text = true;
+                m_function_text += (m_current_input_line + "\n");
+
+                m_input_line_number = 1;
               }
             break;
 
           case magic_file_kw:
             {
-              if ((reading_fcn_file || reading_script_file
-                   || reading_classdef_file)
-                  && ! fcn_file_full_name.empty ())
-                tok_val = new token (magic_file_kw, fcn_file_full_name, l, c);
+              if ((m_reading_fcn_file || m_reading_script_file
+                   || m_reading_classdef_file)
+                  && ! m_fcn_file_full_name.empty ())
+                tok_val = new token (magic_file_kw, m_fcn_file_full_name, l, c);
               else
                 tok_val = new token (magic_file_kw, "stdin", l, c);
             }
             break;
 
           case magic_line_kw:
             tok_val = new token (magic_line_kw, static_cast<double> (l),
                                  "", l, c);
@@ -2787,19 +2789,19 @@ namespace octave
     while (p2 != std::string::npos);
 
     return false;
   }
 
   bool
   base_lexer::whitespace_is_significant (void)
   {
-    return (nesting_level.is_bracket ()
-            || (nesting_level.is_brace ()
-                && ! looking_at_object_index.front ()));
+    return (m_nesting_level.is_bracket ()
+            || (m_nesting_level.is_brace ()
+                && ! m_looking_at_object_index.front ()));
   }
 }
 
 static inline bool
 looks_like_bin (const char *s, int len)
 {
   return (len > 2 && s[0] == '0' && (s[1] == 'b' || s[1] == 'B'));
 }
@@ -2869,23 +2871,23 @@ namespace octave
       }
 
     delete [] tmptxt;
 
     // If yytext doesn't contain a valid number, we are in deep doo doo.
 
     assert (nread == 1);
 
-    looking_for_object_index = false;
-    at_beginning_of_statement = false;
-
-    push_token (new token (NUM, value, yytxt, input_line_number,
-                           current_input_column));
-
-    current_input_column += flex_yyleng ();
+    m_looking_for_object_index = false;
+    m_at_beginning_of_statement = false;
+
+    push_token (new token (NUM, value, yytxt, m_input_line_number,
+                           m_current_input_column));
+
+    m_current_input_column += flex_yyleng ();
   }
 
   void
   base_lexer::handle_continuation (void)
   {
     char *yytxt = flex_yytext ();
     int yylng = flex_yyleng ();
 
@@ -2921,66 +2923,66 @@ namespace octave
             offset++;
           }
         else
           break;
       }
 
     if (have_comment)
       {
-        comment_text = &yytxt[offset];
-
-        // finish_comment sets at_beginning_of_statement to true but
+        m_comment_text = &yytxt[offset];
+
+        // finish_comment sets m_at_beginning_of_statement to true but
         // that's not be correct if we are handling a continued
         // statement.  Preserve the current state.
 
-        bool saved_bos = at_beginning_of_statement;
+        bool saved_bos = m_at_beginning_of_statement;
 
         finish_comment (comment_elt::end_of_line);
 
-        at_beginning_of_statement = saved_bos;
+        m_at_beginning_of_statement = saved_bos;
       }
 
     decrement_promptflag ();
-    input_line_number++;
-    current_input_column = 1;
+    m_input_line_number++;
+    m_current_input_column = 1;
   }
 
   void
   base_lexer::finish_comment (comment_elt::comment_type typ)
   {
-    bool copyright = looks_like_copyright (comment_text);
-
-    if (nesting_level.none () && help_text.empty () && ! comment_text.empty ()
-        && ! copyright && ! looks_like_shebang (comment_text))
-      help_text = comment_text;
+    bool copyright = looks_like_copyright (m_comment_text);
+
+    if (m_nesting_level.none () && m_help_text.empty () && ! m_comment_text.empty ()
+        && ! copyright && ! looks_like_shebang (m_comment_text))
+      m_help_text = m_comment_text;
 
     if (copyright)
       typ = comment_elt::copyright;
 
-    comment_buf.append (comment_text, typ);
-
-    comment_text = "";
-
-    at_beginning_of_statement = true;
+    m_comment_buf.append (m_comment_text, typ);
+
+    m_comment_text = "";
+
+    m_at_beginning_of_statement = true;
   }
 
   int
   base_lexer::handle_close_bracket (int bracket_type)
   {
     int retval = bracket_type;
 
-    if (! nesting_level.none ())
+    if (! m_nesting_level.none ())
       {
-        nesting_level.remove ();
+        m_nesting_level.remove ();
 
         if (bracket_type == ']')
-          bracketflag--;
+          m_bracketflag--;
         else if (bracket_type == '}')
-          braceflag--;
+          m_braceflag--;
         else
           panic_impossible ();
       }
 
     pop_start_state ();
 
     return retval;
   }
@@ -3007,75 +3009,75 @@ namespace octave
     bool kw_token = (is_keyword_token (meth)
                      || fq_identifier_contains_keyword (cls));
 
     if (kw_token)
       {
         token *tok
           = new token (LEXICAL_ERROR,
                        "method, class, and package names may not be keywords",
-                       input_line_number, current_input_column);
+                       m_input_line_number, m_current_input_column);
 
         push_token (tok);
 
         return count_token_internal (LEXICAL_ERROR);
       }
 
     push_token (new token (SUPERCLASSREF, meth, cls,
-                           input_line_number, current_input_column));
-
-    current_input_column += flex_yyleng ();
+                           m_input_line_number, m_current_input_column));
+
+    m_current_input_column += flex_yyleng ();
 
     return SUPERCLASSREF;
   }
 
   int
   base_lexer::handle_meta_identifier (void)
   {
     std::string cls = std::string(flex_yytext ()).substr (1);
 
     if (fq_identifier_contains_keyword (cls))
       {
         token *tok = new token (LEXICAL_ERROR,
                                 "class and package names may not be keywords",
-                                input_line_number, current_input_column);
+                                m_input_line_number, m_current_input_column);
         push_token (tok);
 
         return count_token_internal (LEXICAL_ERROR);
       }
 
-    push_token (new token (METAQUERY, cls, input_line_number,
-                           current_input_column));
-
-    current_input_column += flex_yyleng ();
+    push_token (new token (METAQUERY, cls, m_input_line_number,
+                           m_current_input_column));
+
+    m_current_input_column += flex_yyleng ();
 
     return METAQUERY;
   }
 
   int
   base_lexer::handle_fq_identifier (void)
   {
     std::string fq_id = flex_yytext ();
 
     if (fq_identifier_contains_keyword (fq_id))
       {
         token *tok
           = new token (LEXICAL_ERROR,
                        "function, method, class, and package names may not be keywords",
-                       input_line_number, current_input_column);
+                       m_input_line_number, m_current_input_column);
 
         push_token (tok);
 
         return count_token_internal (LEXICAL_ERROR);
       }
 
-    push_token (new token (FQ_IDENT, fq_id, input_line_number,
-                           current_input_column));
-
-    current_input_column += flex_yyleng ();
+    push_token (new token (FQ_IDENT, fq_id, m_input_line_number,
+                           m_current_input_column));
+
+    m_current_input_column += flex_yyleng ();
 
     return FQ_IDENT;
   }
 
   // Figure out exactly what kind of token to return when we have seen
   // an identifier.  Handles keywords.  Return -1 if the identifier
   // should be ignored.
 
@@ -3083,158 +3085,158 @@ namespace octave
   base_lexer::handle_identifier (void)
   {
     std::string ident = flex_yytext ();
 
     // If we are expecting a structure element, avoid recognizing
     // keywords and other special names and return STRUCT_ELT, which is
     // a string that is also a valid identifier.
 
-    if (looking_at_indirect_ref)
+    if (m_looking_at_indirect_ref)
       {
-        push_token (new token (STRUCT_ELT, ident, input_line_number,
-                               current_input_column));
-
-        looking_for_object_index = true;
-
-        current_input_column += flex_yyleng ();
+        push_token (new token (STRUCT_ELT, ident, m_input_line_number,
+                               m_current_input_column));
+
+        m_looking_for_object_index = true;
+
+        m_current_input_column += flex_yyleng ();
 
         return STRUCT_ELT;
       }
 
     // If ident is a keyword token, then is_keyword_token will set
-    // at_beginning_of_statement.  For example, if tok is an IF
-    // token, then at_beginning_of_statement will be false.
+    // m_at_beginning_of_statement.  For example, if tok is an IF
+    // token, then m_at_beginning_of_statement will be false.
 
     int kw_token = is_keyword_token (ident);
 
-    if (looking_at_function_handle)
+    if (m_looking_at_function_handle)
       {
         if (kw_token)
           {
             token *tok
               = new token (LEXICAL_ERROR,
                            "function handles may not refer to keywords",
-                           input_line_number, current_input_column);
+                           m_input_line_number, m_current_input_column);
 
             push_token (tok);
 
             return count_token_internal (LEXICAL_ERROR);
           }
         else
           {
-            push_token (new token (FCN_HANDLE, ident, input_line_number,
-                                   current_input_column));
-
-            current_input_column += flex_yyleng ();
-            looking_for_object_index = true;
-
-            at_beginning_of_statement = false;
+            push_token (new token (FCN_HANDLE, ident, m_input_line_number,
+                                   m_current_input_column));
+
+            m_current_input_column += flex_yyleng ();
+            m_looking_for_object_index = true;
+
+            m_at_beginning_of_statement = false;
 
             return FCN_HANDLE;
           }
       }
 
     // If we have a regular keyword, return it.
     // Keywords can be followed by identifiers.
 
     if (kw_token)
       {
         if (kw_token >= 0)
           {
-            current_input_column += flex_yyleng ();
-            looking_for_object_index = false;
+            m_current_input_column += flex_yyleng ();
+            m_looking_for_object_index = false;
           }
 
-        // The call to is_keyword_token set at_beginning_of_statement.
+        // The call to is_keyword_token set m_at_beginning_of_statement.
 
         return kw_token;
       }
 
     // Find the token in the symbol table.
 
-    symbol_scope scope = symtab_context.curr_scope ();
+    symbol_scope scope = m_symtab_context.curr_scope ();
 
     symbol_record sr = (scope ? scope.insert (ident) : symbol_record (ident));
 
-    token *tok = new token (NAME, sr, input_line_number, current_input_column);
+    token *tok = new token (NAME, sr, m_input_line_number, m_current_input_column);
 
     // The following symbols are handled specially so that things like
     //
     //   pi +1
     //
     // are parsed as an addition expression instead of as a command-style
     // function call with the argument "+1".
 
-    if (at_beginning_of_statement
+    if (m_at_beginning_of_statement
         && (! (is_variable (ident, scope)
                || ident == "e" || ident == "pi"
                || ident == "I" || ident == "i"
                || ident == "J" || ident == "j"
                || ident == "Inf" || ident == "inf"
                || ident == "NaN" || ident == "nan")))
       tok->mark_may_be_command ();
 
     push_token (tok);
 
-    current_input_column += flex_yyleng ();
+    m_current_input_column += flex_yyleng ();
 
     // The magic end index can't be indexed.
 
     if (ident != "end")
-      looking_for_object_index = true;
-
-    at_beginning_of_statement = false;
+      m_looking_for_object_index = true;
+
+    m_at_beginning_of_statement = false;
 
     return NAME;
   }
 
   void
   base_lexer::maybe_warn_separator_insert (char sep)
   {
-    std::string nm = fcn_file_full_name;
+    std::string nm = m_fcn_file_full_name;
 
     if (nm.empty ())
       warning_with_id ("Octave:separator-insert",
                        "potential auto-insertion of '%c' near line %d",
-                       sep, input_line_number);
+                       sep, m_input_line_number);
     else
       warning_with_id ("Octave:separator-insert",
                        "potential auto-insertion of '%c' near line %d of file %s",
-                       sep, input_line_number, nm.c_str ());
+                       sep, m_input_line_number, nm.c_str ());
   }
 
   void
   base_lexer::warn_single_quote_string (void)
   {
-    std::string nm = fcn_file_full_name;
+    std::string nm = m_fcn_file_full_name;
 
     if (nm.empty ())
       warning_with_id ("Octave:single-quote-string",
                        "single quote delimited string near line %d",
-                       input_line_number);
+                       m_input_line_number);
     else
       warning_with_id ("Octave:single-quote-string",
                        "single quote delimited string near line %d of file %s",
-                       input_line_number, nm.c_str ());
+                       m_input_line_number, nm.c_str ());
   }
 
   void
   base_lexer::warn_language_extension (const std::string& msg)
   {
-    std::string nm = fcn_file_full_name;
+    std::string nm = m_fcn_file_full_name;
 
     if (nm.empty ())
       warning_with_id ("Octave:language-extension",
                        "Octave language extension used: %s",
                        msg.c_str ());
     else
       warning_with_id ("Octave:language-extension",
                        "Octave language extension used: %s near line %d offile %s",
-                       msg.c_str (), input_line_number, nm.c_str ());
+                       msg.c_str (), m_input_line_number, nm.c_str ());
   }
 
   void
   base_lexer::maybe_warn_language_extension_comment (char c)
   {
     if (c == '#')
       warn_language_extension ("# used as comment character");
   }
@@ -3253,25 +3255,25 @@ namespace octave
     if (t[n-1] == '\n')
       t.resize (n-1);
     warn_language_extension (t + " used as operator");
   }
 
   void
   base_lexer::push_token (token *tok)
   {
-    YYSTYPE *lval = yyget_lval (scanner);
+    YYSTYPE *lval = yyget_lval (m_scanner);
     lval->tok_val = tok;
-    tokens.push (tok);
+    m_tokens.push (tok);
   }
 
   token *
   base_lexer::current_token (void)
   {
-    YYSTYPE *lval = yyget_lval (scanner);
+    YYSTYPE *lval = yyget_lval (m_scanner);
     return lval->tok_val;
   }
 
   void
   base_lexer::display_token (int tok)
   {
     switch (tok)
       {
@@ -3548,64 +3550,64 @@ namespace octave
   }
 
   int
   base_lexer::handle_op_internal (int tok, bool bos, bool compat)
   {
     if (! compat)
       warn_language_extension_operator (flex_yytext ());
 
-    push_token (new token (tok, input_line_number, current_input_column));
-
-    current_input_column += flex_yyleng ();
-    looking_for_object_index = false;
-    at_beginning_of_statement = bos;
+    push_token (new token (tok, m_input_line_number, m_current_input_column));
+
+    m_current_input_column += flex_yyleng ();
+    m_looking_for_object_index = false;
+    m_at_beginning_of_statement = bos;
 
     return count_token_internal (tok);
   }
 
   int
   base_lexer::handle_token (const std::string& name, int tok)
   {
-    token *tok_val = new token (tok, name, input_line_number,
-                                current_input_column);
+    token *tok_val = new token (tok, name, m_input_line_number,
+                                m_current_input_column);
 
     return handle_token (tok, tok_val);
   }
 
   int
   base_lexer::handle_token (int tok, token *tok_val)
   {
     if (! tok_val)
-      tok_val = new token (tok, input_line_number, current_input_column);
+      tok_val = new token (tok, m_input_line_number, m_current_input_column);
 
     push_token (tok_val);
 
-    current_input_column += flex_yyleng ();
+    m_current_input_column += flex_yyleng ();
 
     return count_token_internal (tok);
   }
 
   int
   base_lexer::count_token (int tok)
   {
-    token *tok_val = new token (tok, input_line_number, current_input_column);
+    token *tok_val = new token (tok, m_input_line_number, m_current_input_column);
 
     push_token (tok_val);
 
     return count_token_internal (tok);
   }
 
   int
   base_lexer::count_token_internal (int tok)
   {
     if (tok != '\n')
       {
         Vtoken_count++;
-        token_count++;
+        m_token_count++;
       }
 
     return show_token (tok);
   }
 
   int
   base_lexer::show_token (int tok)
   {
@@ -3628,75 +3630,75 @@ namespace octave
     push_start_state (FQ_IDENT_START);
   }
 
   int
   lexer::fill_flex_buffer (char *buf, unsigned max_size)
   {
     int status = 0;
 
-    if (input_buf.empty ())
+    if (m_input_buf.empty ())
       {
         bool eof = false;
-        current_input_line = reader.get_input (eof);
-
-        input_buf.fill (current_input_line, eof);
+        m_current_input_line = m_reader.get_input (eof);
+
+        m_input_buf.fill (m_current_input_line, eof);
 
         // Attempt to capture text for functions defined on the
         // command line.
         //
         // FIXME: the handling of newline here seems a bit clumsy.
         //
         // See also comments in push_lexer::append_input.
 
-        if (buffer_function_text)
+        if (m_buffer_function_text)
           {
-            if (! current_input_line.empty ())
+            if (! m_current_input_line.empty ())
             {
-              function_text += current_input_line;
-              if (current_input_line.back () != '\n')
-                function_text += '\n';
+              m_function_text += m_current_input_line;
+              if (m_current_input_line.back () != '\n')
+                m_function_text += '\n';
             }
           }
       }
 
-    if (! input_buf.empty ())
-      status = input_buf.copy_chunk (buf, max_size);
+    if (! m_input_buf.empty ())
+      status = m_input_buf.copy_chunk (buf, max_size);
     else
       status = YY_NULL;
 
     return status;
   }
 
   void
   push_lexer::append_input (const std::string& input, bool eof)
   {
     // FIXME: input may contain more than one line, so how can we
     // properly start buffering input for command-line functions?
     //
     // Currently, base_lexer::is_keyword_token starts buffering text
     // for command-line functions by setting the initial value of
-    // function_text to current_input_line when function_kw is
+    // m_function_text to m_current_input_line when function_kw is
     // recognized.  To make that work, we need to do something like
     // maintain a queue of input strings and pass them to the flex
     // buffer one line at a time, while also setting
-    // current_input_line.  Some care will be needed if a single line
+    // m_current_input_line.  Some care will be needed if a single line
     // of input arrives in multiple calls to append_input.
 
-    input_buf.fill (input, eof);
+    m_input_buf.fill (input, eof);
   }
 
   int
   push_lexer::fill_flex_buffer (char *buf, unsigned max_size)
   {
     int status = 0;
 
-    if (input_buf.empty () && ! input_buf.at_eof ())
-      input_buf.fill (std::string (1, static_cast<char> (1)), false);
-
-    if (! input_buf.empty ())
-      status = input_buf.copy_chunk (buf, max_size);
+    if (m_input_buf.empty () && ! m_input_buf.at_eof ())
+      m_input_buf.fill (std::string (1, static_cast<char> (1)), false);
+
+    if (! m_input_buf.empty ())
+      status = m_input_buf.copy_chunk (buf, max_size);
     else
       status = YY_NULL;
 
     return status;
   }
 }
diff --git a/libinterp/parse-tree/oct-parse.in.yy b/libinterp/parse-tree/oct-parse.in.yy
--- a/libinterp/parse-tree/oct-parse.in.yy
+++ b/libinterp/parse-tree/oct-parse.in.yy
@@ -91,17 +91,17 @@ extern int octave_lex (YYSTYPE *, void *
 static std::map<std::string, std::string> autoload_map;
 
 // Forward declarations for some functions defined at the bottom of
 // the file.
 
 static void yyerror (octave::base_parser& parser, const char *s);
 
 #define lexer parser.m_lexer
-#define scanner lexer.scanner
+#define scanner lexer.m_scanner
 
 #if defined (HAVE_PRAGMA_GCC_DIAGNOSTIC)
    // Disable this warning for code that is generated by Bison,
    // including grammar rules.  Push the current state so we can
    // restore the warning state prior to functions we define at
    // the bottom of the file.
 #  pragma GCC diagnostic push
 #  pragma GCC diagnostic ignored "-Wold-style-cast"
@@ -386,17 +386,17 @@ input           : simple_list '\n'
                   {
                     $$ = nullptr;
                     parser.m_stmt_list = $1;
                     YYACCEPT;
                   }
                 | simple_list END_OF_INPUT
                   {
                     $$ = nullptr;
-                    lexer.end_of_input = true;
+                    lexer.m_end_of_input = true;
                     parser.m_stmt_list = $1;
                     YYACCEPT;
                   }
                 | parse_error
                   {
                     $$ = nullptr;
                     YYABORT;
                   }
@@ -595,24 +595,24 @@ cell_or_matrix_row
                   { $$ = $2; }
                 | ',' arg_list ','
                   { $$ = $2; }
                 ;
 
 fcn_handle      : '@' FCN_HANDLE
                   {
                     $$ = parser.make_fcn_handle ($2);
-                    lexer.looking_at_function_handle--;
+                    lexer.m_looking_at_function_handle--;
                   }
                 ;
 
 anon_fcn_handle : '@' param_list stmt_begin expr_no_assign
                   {
                     $$ = parser.make_anon_fcn_handle ($2, $4);
-                    lexer.nesting_level.remove ();
+                    lexer.m_nesting_level.remove ();
                   }
                 | '@' param_list stmt_begin error
                   {
                     YYUSE ($2);
 
                     $$ = nullptr;
                     parser.bison_error ("anonymous function bodies must be single expressions");
                     YYABORT;
@@ -622,17 +622,17 @@ anon_fcn_handle : '@' param_list stmt_be
 primary_expr    : identifier
                   { $$ = $1; }
                 | constant
                   { $$ = $1; }
                 | fcn_handle
                   { $$ = $1; }
                 | matrix
                   {
-                    lexer.looking_at_matrix_or_assign_lhs = false;
+                    lexer.m_looking_at_matrix_or_assign_lhs = false;
                     $$ = $1;
                   }
                 | cell
                   { $$ = $1; }
                 | meta_identifier
                   { $$ = $1; }
                 | superclass_identifier
                   { $$ = $1; }
@@ -678,17 +678,17 @@ arg_list        : expression
                     $1->append ($3);
                     $$ = $1;
                   }
                 ;
 
 indirect_ref_op : '.'
                   {
                     $$ = 0;
-                    lexer.looking_at_indirect_ref = true;
+                    lexer.m_looking_at_indirect_ref = true;
                   }
                 ;
 
 oper_expr       : primary_expr
                   { $$ = $1; }
                 | oper_expr PLUS_PLUS
                   { $$ = parser.make_postfix_op (PLUS_PLUS, $1, $2); }
                 | oper_expr MINUS_MINUS
@@ -884,17 +884,17 @@ simple_expr     : oper_expr
                   { $$ = parser.make_boolean_op (EXPR_OR_OR, $1, $2, $3); }
                 ;
 
 assign_lhs      : simple_expr
                   {
                     $$ = parser.validate_matrix_for_assignment ($1);
 
                     if ($$)
-                      { lexer.looking_at_matrix_or_assign_lhs = false; }
+                      { lexer.m_looking_at_matrix_or_assign_lhs = false; }
                     else
                       {
                         // validate_matrix_for_assignment deleted $1.
                         YYABORT;
                       }
                   }
                 ;
 
@@ -977,47 +977,47 @@ command         : declaration
 
 // =====================
 // Declaration statemnts
 // =====================
 
 declaration     : GLOBAL decl1
                   {
                     $$ = parser.make_decl_command (GLOBAL, $1, $2);
-                    lexer.looking_at_decl_list = false;
+                    lexer.m_looking_at_decl_list = false;
                   }
                 | PERSISTENT decl1
                   {
                     $$ = parser.make_decl_command (PERSISTENT, $1, $2);
-                    lexer.looking_at_decl_list = false;
+                    lexer.m_looking_at_decl_list = false;
                   }
                 ;
 
 decl1           : decl2
                   { $$ = new octave::tree_decl_init_list ($1); }
                 | decl1 decl2
                   {
                     $1->append ($2);
                     $$ = $1;
                   }
                 ;
 
 decl_param_init : // empty
                   {
                     $$ = 0;
-                    lexer.looking_at_initializer_expression = true;
+                    lexer.m_looking_at_initializer_expression = true;
                   }
 
 decl2           : identifier
                   { $$ = new octave::tree_decl_elt ($1); }
                 | identifier '=' decl_param_init expression
                   {
                     YYUSE ($2);
 
-                    lexer.looking_at_initializer_expression = false;
+                    lexer.m_looking_at_initializer_expression = false;
                     $$ = new octave::tree_decl_elt ($1, $4);
                   }
                 ;
 
 // ====================
 // Selection statements
 // ====================
 
@@ -1281,58 +1281,58 @@ push_fcn_symtab : // empty
                     $$ = 0;
 
                     parser.m_curr_fcn_depth++;
 
                     if (parser.m_max_fcn_depth < parser.m_curr_fcn_depth)
                       parser.m_max_fcn_depth = parser.m_curr_fcn_depth;
 
                     // Will get a real name later.
-                    lexer.symtab_context.push (octave::symbol_scope ("parser:push_fcn_symtab"));
-                    parser.m_function_scopes.push (lexer.symtab_context.curr_scope ());
-
-                    if (! lexer.reading_script_file
+                    lexer.m_symtab_context.push (octave::symbol_scope ("parser:push_fcn_symtab"));
+                    parser.m_function_scopes.push (lexer.m_symtab_context.curr_scope ());
+
+                    if (! lexer.m_reading_script_file
                         && parser.m_curr_fcn_depth == 1
                         && ! parser.m_parsing_subfunctions)
                       parser.m_primary_fcn_scope
-                        = lexer.symtab_context.curr_scope ();
-
-                    if (lexer.reading_script_file
+                        = lexer.m_symtab_context.curr_scope ();
+
+                    if (lexer.m_reading_script_file
                         && parser.m_curr_fcn_depth > 1)
                       {
                         parser.bison_error ("nested functions not implemented in this context");
                         YYABORT;
                       }
                   }
                 ;
 
 // ===========================
 // List of function parameters
 // ===========================
 
 param_list_beg  : '('
                   {
                     $$ = 0;
-                    lexer.looking_at_parameter_list = true;
-
-                    if (lexer.looking_at_function_handle)
+                    lexer.m_looking_at_parameter_list = true;
+
+                    if (lexer.m_looking_at_function_handle)
                       {
                         // Will get a real name later.
-                        lexer.symtab_context.push (octave::symbol_scope ("parser:param_lsit_beg"));
-                        lexer.looking_at_function_handle--;
-                        lexer.looking_at_anon_fcn_args = true;
+                        lexer.m_symtab_context.push (octave::symbol_scope ("parser:param_lsit_beg"));
+                        lexer.m_looking_at_function_handle--;
+                        lexer.m_looking_at_anon_fcn_args = true;
                       }
                   }
                 ;
 
 param_list_end  : ')'
                   {
                     $$ = 0;
-                    lexer.looking_at_parameter_list = false;
-                    lexer.looking_for_object_index = false;
+                    lexer.m_looking_at_parameter_list = false;
+                    lexer.m_looking_for_object_index = false;
                   }
                 ;
 
 opt_param_list  : // empty
                   { $$ = nullptr; }
                 | param_list
                   { $$ = $1; }
                 ;
@@ -1387,23 +1387,23 @@ param_list_elt  : decl2
                 ;
 
 // ===================================
 // List of function return value names
 // ===================================
 
 return_list     : '[' ']'
                   {
-                    lexer.looking_at_return_list = false;
+                    lexer.m_looking_at_return_list = false;
 
                     $$ = new octave::tree_parameter_list ();
                   }
                 | identifier
                   {
-                    lexer.looking_at_return_list = false;
+                    lexer.m_looking_at_return_list = false;
 
                     octave::tree_parameter_list *tmp = new octave::tree_parameter_list ($1);
 
                     // Even though this parameter list can contain only
                     // a single identifier, we still need to validate it
                     // to check for varargin or varargout.
 
                     if (parser.validate_param_list (tmp, octave::tree_parameter_list::out))
@@ -1411,17 +1411,17 @@ return_list     : '[' ']'
                     else
                       {
                         delete tmp;
                         YYABORT;
                       }
                   }
                 | '[' return_list1 ']'
                   {
-                    lexer.looking_at_return_list = false;
+                    lexer.m_looking_at_return_list = false;
 
                     // Check for duplicate parameter names, varargin,
                     // or varargout.
 
                     if (parser.validate_param_list ($2, octave::tree_parameter_list::out))
                       $$ = $2;
                     else
                       {
@@ -1450,126 +1450,126 @@ parsing_local_fcns
                 ;
 
 push_script_symtab : // empty
                   {
                     $$ = 0;
 
                     // This scope may serve as the parent scope for local
                     // functions in classdef files..
-                    lexer.symtab_context.push (octave::symbol_scope ("parser:push_script_symtab"));
+                    lexer.m_symtab_context.push (octave::symbol_scope ("parser:push_script_symtab"));
                   }
                 ;
 
 begin_file      : push_script_symtab INPUT_FILE
                   { $$ = 0; }
                 ;
 
 file            : begin_file opt_nl opt_list END_OF_INPUT
                   {
                     YYUSE ($2);
 
-                    if (lexer.reading_fcn_file)
+                    if (lexer.m_reading_fcn_file)
                       {
                         // Delete the dummy statement_list we created
                         // after parsing the function.  Any function
                         // definitions found in the file have already
                         // been stored in the symbol table or in
                         // base_parser::m_primary_fcn_ptr.
 
                         // Unused symbol table context.
-                        lexer.symtab_context.pop ();
+                        lexer.m_symtab_context.pop ();
 
                         delete $3;
                       }
                     else
                       {
                         octave::tree_statement *end_of_script
                           = parser.make_end ("endscript", true,
-                                             lexer.input_line_number,
-                                             lexer.current_input_column);
+                                             lexer.m_input_line_number,
+                                             lexer.m_current_input_column);
 
                         parser.make_script ($3, end_of_script);
                       }
 
                     $$ = nullptr;
                   }
                 | begin_file opt_nl classdef parsing_local_fcns opt_sep opt_fcn_list END_OF_INPUT
                   {
                     YYUSE ($2);
                     YYUSE ($5);
 
                     // Unused symbol table context.
-                    lexer.symtab_context.pop ();
+                    lexer.m_symtab_context.pop ();
 
                     parser.finish_classdef_file ($3, $6);
 
                     $$ = nullptr;
                   }
                 ;
 
 // ===================
 // Function definition
 // ===================
 
 function_beg    : push_fcn_symtab FCN
                   {
                     $$ = $2;
-                    if (lexer.reading_classdef_file
-                        || lexer.parsing_classdef)
-                      lexer.maybe_classdef_get_set_method = true;
+                    if (lexer.m_reading_classdef_file
+                        || lexer.m_parsing_classdef)
+                      lexer.m_maybe_classdef_get_set_method = true;
                   }
                 ;
 
 fcn_name        : identifier
                   {
                     std::string id = $1->name ();
 
                     // Make classdef local functions unique from
                     // classdef methods.
 
                     if (parser.m_parsing_local_functions
                         && parser.m_curr_fcn_depth == 1)
-                      id = lexer.fcn_file_name + ">" + id;
+                      id = lexer.m_fcn_file_name + ">" + id;
 
                     if (! parser.m_function_scopes.name_current_scope (id))
                       {
                         parser.bison_error ("duplicate subfunction or nested function name",
                                             $1->line (), $1->column ());
 
                         delete $1;
 
                         YYABORT;
                       }
 
                     octave::symbol_scope curr_scope
-                      = lexer.symtab_context.curr_scope ();
+                      = lexer.m_symtab_context.curr_scope ();
                     curr_scope.cache_name (id);
 
-                    lexer.parsed_function_name.top () = true;
-                    lexer.maybe_classdef_get_set_method = false;
+                    lexer.m_parsed_function_name.top () = true;
+                    lexer.m_maybe_classdef_get_set_method = false;
 
                     $$ = $1;
                   }
                 | GET '.' identifier
                   {
                     YYUSE ($1);
 
-                    lexer.parsed_function_name.top () = true;
-                    lexer.maybe_classdef_get_set_method = false;
-                    lexer.parsing_classdef_get_method = true;
+                    lexer.m_parsed_function_name.top () = true;
+                    lexer.m_maybe_classdef_get_set_method = false;
+                    lexer.m_parsing_classdef_get_method = true;
                     $$ = $3;
                   }
                 | SET '.' identifier
                   {
                     YYUSE ($1);
 
-                    lexer.parsed_function_name.top () = true;
-                    lexer.maybe_classdef_get_set_method = false;
-                    lexer.parsing_classdef_set_method = true;
+                    lexer.m_parsed_function_name.top () = true;
+                    lexer.m_maybe_classdef_get_set_method = false;
+                    lexer.m_parsing_classdef_set_method = true;
                     $$ = $3;
                   }
                 ;
 
 function_end    : END
                   {
                     parser.m_endfunction_found = true;
 
@@ -1580,46 +1580,46 @@ function_end    : END
                       {
                         parser.end_token_error ($1, octave::token::function_end);
                         YYABORT;
                       }
                   }
                 | END_OF_INPUT
                   {
 // A lot of tests are based on the assumption that this is OK
-//                  if (lexer.reading_script_file)
+//                  if (lexer.m_reading_script_file)
 //                    {
 //                      parser.bison_error ("function body open at end of script");
 //                      YYABORT;
 //                    }
 
                     if (parser.m_endfunction_found)
                       {
                         parser.bison_error ("inconsistent function endings -- "
                                  "if one function is explicitly ended, "
                                  "so must all the others");
                         YYABORT;
                       }
 
-                    if (! (lexer.reading_fcn_file || lexer.reading_script_file
+                    if (! (lexer.m_reading_fcn_file || lexer.m_reading_script_file
                            || lexer.input_from_eval_string ()))
                       {
                         parser.bison_error ("function body open at end of input");
                         YYABORT;
                       }
 
-                    if (lexer.reading_classdef_file)
+                    if (lexer.m_reading_classdef_file)
                       {
                         parser.bison_error ("classdef body open at end of input");
                         YYABORT;
                       }
 
                     $$ = parser.make_end ("endfunction", true,
-                                          lexer.input_line_number,
-                                          lexer.current_input_column);
+                                          lexer.m_input_line_number,
+                                          lexer.m_current_input_column);
                   }
                 ;
 
 function        : function_beg stash_comment fcn_name
                   opt_param_list opt_sep opt_list function_end
                   {
                     YYUSE ($5);
 
@@ -1636,47 +1636,47 @@ function        : function_beg stash_com
                 ;
 
 // ========
 // Classdef
 // ========
 
 classdef_beg    : CLASSDEF
                   {
-                    if (! lexer.reading_classdef_file)
+                    if (! lexer.m_reading_classdef_file)
                       {
                         parser.bison_error ("classdef must appear inside a file containing only a class definition");
                         YYABORT;
                       }
 
                     // Create invalid parent scope.
-                    lexer.symtab_context.push (octave::symbol_scope ());
-                    lexer.parsing_classdef = true;
+                    lexer.m_symtab_context.push (octave::symbol_scope ());
+                    lexer.m_parsing_classdef = true;
                     $$ = $1;
                   }
                 ;
 
 classdef        : classdef_beg stash_comment opt_attr_list identifier opt_superclass_list opt_sep class_body opt_sep END
                   {
                     YYUSE ($6);
                     YYUSE ($8);
 
-                    lexer.parsing_classdef = false;
+                    lexer.m_parsing_classdef = false;
 
                     if (! ($$ = parser.make_classdef ($1, $3, $4, $5, $7, $9, $2)))
                       {
                         // make_classdef deleted $3, $4, $5, and $7.
                         YYABORT;
                       }
                   }
                 | classdef_beg stash_comment opt_attr_list identifier opt_superclass_list opt_sep END
                   {
                     YYUSE ($6);
 
-                    lexer.parsing_classdef = false;
+                    lexer.m_parsing_classdef = false;
 
                     if (! ($$ = parser.make_classdef ($1, $3, $4, $5, nullptr,
                                                       $7, $2)))
                       {
                         // make_classdef deleted $3, $4, and $5.
                         YYABORT;
                       }
                   }
@@ -1698,17 +1698,17 @@ attr_list       : attr
                 ;
 
 attr            : identifier
                   { $$ = new octave::tree_classdef_attribute ($1); }
                 | identifier '=' decl_param_init expression
                   {
                     YYUSE ($2);
 
-                    lexer.looking_at_initializer_expression = false;
+                    lexer.m_looking_at_initializer_expression = false;
                     $$ = new octave::tree_classdef_attribute ($1, $4);
                   }
                 | EXPR_NOT identifier
                   {
                     YYUSE ($1);
 
                     $$ = new octave::tree_classdef_attribute ($2, false);
                   }
@@ -1823,17 +1823,17 @@ property_list
                 ;
 
 class_property  : identifier
                   { $$ = new octave::tree_classdef_property ($1); }
                 | identifier '=' decl_param_init expression
                   {
                     YYUSE ($2);
 
-                    lexer.looking_at_initializer_expression = false;
+                    lexer.m_looking_at_initializer_expression = false;
                     $$ = new octave::tree_classdef_property ($1, $4);
                   }
                 ;
 
 methods_block   : METHODS stash_comment opt_attr_list opt_sep methods_list opt_sep END
                   {
                     YYUSE ($4);
                     YYUSE ($6);
@@ -1872,23 +1872,23 @@ method_decl1    : identifier
                 ;
 
 method_decl     : stash_comment method_decl1
                   { $$ = parser.finish_classdef_external_method ($2, nullptr, $1); }
                 | stash_comment return_list '='
                   {
                     YYUSE ($3);
 
-                    lexer.defining_func++;
-                    lexer.parsed_function_name.push (false);
+                    lexer.m_defining_func++;
+                    lexer.m_parsed_function_name.push (false);
                   }
                   method_decl1
                   {
-                    lexer.defining_func--;
-                    lexer.parsed_function_name.pop ();
+                    lexer.m_defining_func--;
+                    lexer.m_parsed_function_name.pop ();
                     $$ = parser.finish_classdef_external_method ($5, $2, $1);
                   }
                 ;
 
 method          : method_decl
                   { $$ = $1; }
                 | function
                   { $$ = $1; }
@@ -1998,17 +1998,17 @@ class_enum      : identifier '(' express
 
 // =============
 // Miscellaneous
 // =============
 
 stmt_begin      : // empty
                   {
                     $$ = 0;
-                    lexer.at_beginning_of_statement = true;
+                    lexer.m_at_beginning_of_statement = true;
                   }
                 ;
 
 stash_comment   : // empty
                   { $$ = lexer.get_comment (); }
                 ;
 
 parse_error     : LEXICAL_ERROR
@@ -2328,43 +2328,43 @@ namespace octave
   // test in a logical expression.
 
   void
   base_parser::maybe_warn_assign_as_truth_value (tree_expression *expr)
   {
     if (expr->is_assignment_expression ()
         && expr->paren_count () < 2)
       {
-        if (m_lexer.fcn_file_full_name.empty ())
+        if (m_lexer.m_fcn_file_full_name.empty ())
           warning_with_id
             ("Octave:assign-as-truth-value",
              "suggest parenthesis around assignment used as truth value");
         else
           warning_with_id
             ("Octave:assign-as-truth-value",
              "suggest parenthesis around assignment used as truth value near line %d, column %d in file '%s'",
-             expr->line (), expr->column (), m_lexer.fcn_file_full_name.c_str ());
+             expr->line (), expr->column (), m_lexer.m_fcn_file_full_name.c_str ());
       }
   }
 
   // Maybe print a warning about switch labels that aren't constants.
 
   void
   base_parser::maybe_warn_variable_switch_label (tree_expression *expr)
   {
     if (! expr->is_constant ())
       {
-        if (m_lexer.fcn_file_full_name.empty ())
+        if (m_lexer.m_fcn_file_full_name.empty ())
           warning_with_id ("Octave:variable-switch-label",
                            "variable switch label");
         else
           warning_with_id
             ("Octave:variable-switch-label",
              "variable switch label near line %d, column %d in file '%s'",
-             expr->line (), expr->column (), m_lexer.fcn_file_full_name.c_str ());
+             expr->line (), expr->column (), m_lexer.m_fcn_file_full_name.c_str ());
       }
   }
 
   // Make a constant.
 
   tree_constant *
   base_parser::make_constant (int op, token *tok_val)
   {
@@ -2441,54 +2441,54 @@ namespace octave
 
   // Make an anonymous function handle.
 
   tree_anon_fcn_handle *
   base_parser::make_anon_fcn_handle (tree_parameter_list *param_list,
                                      tree_expression *expr)
   {
     // FIXME: need to get these from the location of the @ symbol.
-    int l = m_lexer.input_line_number;
-    int c = m_lexer.current_input_column;
-
-    symbol_scope fcn_scope = m_lexer.symtab_context.curr_scope ();
-    symbol_scope parent_scope = m_lexer.symtab_context.parent_scope ();
-
-    m_lexer.symtab_context.pop ();
+    int l = m_lexer.m_input_line_number;
+    int c = m_lexer.m_current_input_column;
+
+    symbol_scope fcn_scope = m_lexer.m_symtab_context.curr_scope ();
+    symbol_scope parent_scope = m_lexer.m_symtab_context.parent_scope ();
+
+    m_lexer.m_symtab_context.pop ();
 
     expr->set_print_flag (false);
 
     fcn_scope.mark_static ();
 
     tree_anon_fcn_handle *retval
       = new tree_anon_fcn_handle (param_list, expr, fcn_scope,
                                   parent_scope, l, c);
 
     std::ostringstream buf;
 
     tree_print_code tpc (buf);
 
     retval->accept (tpc);
 
-    std::string file = m_lexer.fcn_file_full_name;
+    std::string file = m_lexer.m_fcn_file_full_name;
     if (! file.empty ())
       buf << ": file: " << file;
     else if (m_lexer.input_from_terminal ())
       buf << ": *terminal input*";
     else if (m_lexer.input_from_eval_string ())
       buf << ": *eval string*";
     buf << ": line: " << l << " column: " << c;
 
     std::string scope_name = buf.str ();
 
     fcn_scope.cache_name (scope_name);
 
     // FIXME: Stash the filename.  This does not work and produces
     // errors when executed.
-    //retval->stash_file_name (m_lexer.fcn_file_name);
+    //retval->stash_file_name (m_lexer.m_fcn_file_name);
 
     return retval;
   }
 
   // Build a colon expression.
 
   tree_expression *
   base_parser::make_colon_expression (tree_expression *base,
@@ -2763,17 +2763,17 @@ namespace octave
                                     token *end_tok,
                                     comment_list *lc,
                                     comment_list *mc)
   {
     tree_command *retval = nullptr;
 
     if (end_token_ok (end_tok, token::unwind_protect_end))
       {
-        comment_list *tc = m_lexer.comment_buf.get_comment ();
+        comment_list *tc = m_lexer.m_comment_buf.get_comment ();
 
         int l = unwind_tok->line ();
         int c = unwind_tok->column ();
 
         retval = new tree_unwind_protect_command (body, cleanup_stmts,
                                                   lc, mc, tc, l, c);
       }
     else
@@ -2797,17 +2797,17 @@ namespace octave
                                  token *end_tok,
                                  comment_list *lc,
                                  comment_list *mc)
   {
     tree_command *retval = nullptr;
 
     if (end_token_ok (end_tok, token::try_catch_end))
       {
-        comment_list *tc = m_lexer.comment_buf.get_comment ();
+        comment_list *tc = m_lexer.m_comment_buf.get_comment ();
 
         int l = try_tok->line ();
         int c = try_tok->column ();
 
         tree_identifier *id = nullptr;
 
         if (! catch_sep && cleanup_stmts && ! cleanup_stmts->empty ())
           {
@@ -2853,19 +2853,19 @@ namespace octave
                                    comment_list *lc)
   {
     tree_command *retval = nullptr;
 
     maybe_warn_assign_as_truth_value (expr);
 
     if (end_token_ok (end_tok, token::while_end))
       {
-        comment_list *tc = m_lexer.comment_buf.get_comment ();
-
-        m_lexer.looping--;
+        comment_list *tc = m_lexer.m_comment_buf.get_comment ();
+
+        m_lexer.m_looping--;
 
         int l = while_tok->line ();
         int c = while_tok->column ();
 
         retval = new tree_while_command (expr, body, lc, tc, l, c);
       }
     else
       {
@@ -2883,19 +2883,19 @@ namespace octave
   tree_command *
   base_parser::make_do_until_command (token *until_tok,
                                       tree_statement_list *body,
                                       tree_expression *expr,
                                       comment_list *lc)
   {
     maybe_warn_assign_as_truth_value (expr);
 
-    comment_list *tc = m_lexer.comment_buf.get_comment ();
-
-    m_lexer.looping--;
+    comment_list *tc = m_lexer.m_comment_buf.get_comment ();
+
+    m_lexer.m_looping--;
 
     int l = until_tok->line ();
     int c = until_tok->column ();
 
     return new tree_do_until_command (expr, body, lc, tc, l, c);
   }
 
   // Build a for command.
@@ -2912,19 +2912,19 @@ namespace octave
     tree_command *retval = nullptr;
 
     bool parfor = tok_id == PARFOR;
 
     if (end_token_ok (end_tok, parfor ? token::parfor_end : token::for_end))
       {
         expr->mark_as_for_cmd_expr ();
 
-        comment_list *tc = m_lexer.comment_buf.get_comment ();
-
-        m_lexer.looping--;
+        comment_list *tc = m_lexer.m_comment_buf.get_comment ();
+
+        m_lexer.m_looping--;
 
         int l = for_tok->line ();
         int c = for_tok->column ();
 
         if (lhs->length () == 1)
           {
             tree_expression *tmp = lhs->remove_front ();
 
@@ -2965,17 +2965,17 @@ namespace octave
   // Build a break command.
 
   tree_command *
   base_parser::make_break_command (token *break_tok)
   {
     int l = break_tok->line ();
     int c = break_tok->column ();
 
-    if (! m_lexer.looping)
+    if (! m_lexer.m_looping)
       {
         bison_error ("break must appear in a loop in the same file as loop command");
         return nullptr;
       }
     else
       return new tree_break_command (l, c);
   }
 
@@ -3021,17 +3021,17 @@ namespace octave
                                   tree_if_command_list *list,
                                   token *end_tok,
                                   comment_list *lc)
   {
     tree_if_command *retval = nullptr;
 
     if (end_token_ok (end_tok, token::if_end))
       {
-        comment_list *tc = m_lexer.comment_buf.get_comment ();
+        comment_list *tc = m_lexer.m_comment_buf.get_comment ();
 
         int l = if_tok->line ();
         int c = if_tok->column ();
 
         if (list && ! list->empty ())
           {
             tree_if_clause *elt = list->front ();
 
@@ -3078,17 +3078,17 @@ namespace octave
                                       tree_switch_case_list *list,
                                       token *end_tok,
                                       comment_list *lc)
   {
     tree_switch_command *retval = nullptr;
 
     if (end_token_ok (end_tok, token::switch_end))
       {
-        comment_list *tc = m_lexer.comment_buf.get_comment ();
+        comment_list *tc = m_lexer.m_comment_buf.get_comment ();
 
         int l = switch_tok->line ();
         int c = switch_tok->column ();
 
         if (list && ! list->empty ())
           {
             tree_switch_case *elt = list->front ();
 
@@ -3263,27 +3263,27 @@ namespace octave
   base_parser::make_script (tree_statement_list *cmds,
                             tree_statement *end_script)
   {
     if (! cmds)
       cmds = new tree_statement_list ();
 
     cmds->append (end_script);
 
-    symbol_scope script_scope = m_lexer.symtab_context.curr_scope ();
-
-    script_scope.cache_name (m_lexer.fcn_file_full_name);
+    symbol_scope script_scope = m_lexer.m_symtab_context.curr_scope ();
+
+    script_scope.cache_name (m_lexer.m_fcn_file_full_name);
 
     octave_user_script *script
-      = new octave_user_script (m_lexer.fcn_file_full_name,
-                                m_lexer.fcn_file_name, script_scope,
-                                cmds, m_lexer.help_text);
-
-    m_lexer.symtab_context.pop ();
-    m_lexer.help_text = "";
+      = new octave_user_script (m_lexer.m_fcn_file_full_name,
+                                m_lexer.m_fcn_file_name, script_scope,
+                                cmds, m_lexer.m_help_text);
+
+    m_lexer.m_symtab_context.pop ();
+    m_lexer.m_help_text = "";
 
     sys::time now;
 
     script->stash_fcn_file_time (now);
 
     m_primary_fcn_ptr = script;
   }
 
@@ -3326,95 +3326,95 @@ namespace octave
                                tree_statement *end_fcn_stmt)
   {
     // We'll fill in the return list later.
 
     std::string id_name = id->name ();
 
     delete id;
 
-    if (m_lexer.parsing_classdef_get_method)
+    if (m_lexer.m_parsing_classdef_get_method)
       id_name.insert (0, "get.");
-    else if (m_lexer.parsing_classdef_set_method)
+    else if (m_lexer.m_parsing_classdef_set_method)
       id_name.insert (0, "set.");
 
-    m_lexer.parsing_classdef_get_method = false;
-    m_lexer.parsing_classdef_set_method = false;
+    m_lexer.m_parsing_classdef_get_method = false;
+    m_lexer.m_parsing_classdef_set_method = false;
 
     if (! body)
       body = new tree_statement_list ();
 
     body->append (end_fcn_stmt);
 
     octave_user_function *fcn
-      = new octave_user_function (m_lexer.symtab_context.curr_scope (),
+      = new octave_user_function (m_lexer.m_symtab_context.curr_scope (),
                                   param_list, nullptr, body);
 
     if (fcn)
       {
-        comment_list *tc = m_lexer.comment_buf.get_comment ();
+        comment_list *tc = m_lexer.m_comment_buf.get_comment ();
 
         fcn->stash_trailing_comment (tc);
         fcn->stash_fcn_end_location (end_fcn_stmt->line (),
                                      end_fcn_stmt->column ());
       }
 
     // If input is coming from a file, issue a warning if the name of
     // the file does not match the name of the function stated in the
     // file.  Matlab doesn't provide a diagnostic (it ignores the stated
     // name).
-    if (! m_autoloading && m_lexer.reading_fcn_file
+    if (! m_autoloading && m_lexer.m_reading_fcn_file
         && m_curr_fcn_depth == 1 && ! m_parsing_subfunctions)
       {
-        // FIXME: should m_lexer.fcn_file_name already be
+        // FIXME: should m_lexer.m_fcn_file_name already be
         // preprocessed when we get here?  It seems to only be a
         // problem with relative filenames.
 
-        std::string nm = m_lexer.fcn_file_name;
+        std::string nm = m_lexer.m_fcn_file_name;
 
         size_t pos = nm.find_last_of (sys::file_ops::dir_sep_chars ());
 
         if (pos != std::string::npos)
-          nm = m_lexer.fcn_file_name.substr (pos+1);
+          nm = m_lexer.m_fcn_file_name.substr (pos+1);
 
         if (nm != id_name)
           {
             warning_with_id
               ("Octave:function-name-clash",
                "function name '%s' does not agree with function filename '%s'",
-               id_name.c_str (), m_lexer.fcn_file_full_name.c_str ());
+               id_name.c_str (), m_lexer.m_fcn_file_full_name.c_str ());
 
             id_name = nm;
           }
       }
 
-    if (m_lexer.reading_fcn_file || m_lexer.reading_classdef_file || m_autoloading)
+    if (m_lexer.m_reading_fcn_file || m_lexer.m_reading_classdef_file || m_autoloading)
       {
         sys::time now;
 
-        fcn->stash_fcn_file_name (m_lexer.fcn_file_full_name);
+        fcn->stash_fcn_file_name (m_lexer.m_fcn_file_full_name);
         fcn->stash_fcn_file_time (now);
-        fcn->stash_dir_name (m_lexer.dir_name);
-        fcn->stash_package_name (m_lexer.package_name);
+        fcn->stash_dir_name (m_lexer.m_dir_name);
+        fcn->stash_package_name (m_lexer.m_package_name);
         fcn->mark_as_system_fcn_file ();
 
         if (m_fcn_file_from_relative_lookup)
           fcn->mark_relative ();
 
         if (m_curr_fcn_depth > 1 || m_parsing_subfunctions)
           {
-            fcn->stash_parent_fcn_name (m_lexer.fcn_file_name);
+            fcn->stash_parent_fcn_name (m_lexer.m_fcn_file_name);
 
             if (m_curr_fcn_depth > 1)
               fcn->stash_parent_fcn_scope (m_function_scopes.parent_scope ());
             else
               fcn->stash_parent_fcn_scope (m_primary_fcn_scope);
           }
 
-        if (m_lexer.parsing_class_method)
+        if (m_lexer.m_parsing_class_method)
           {
             if (m_curr_class_name == id_name)
               fcn->mark_as_class_constructor ();
             else
               fcn->mark_as_class_method ();
 
             fcn->stash_dispatch_class (m_curr_class_name);
           }
@@ -3423,39 +3423,39 @@ namespace octave
 
         sys::file_stat fs (nm);
 
         if (fs && fs.is_newer (now))
           warning_with_id ("Octave:future-time-stamp",
                            "time stamp for '%s' is in the future", nm.c_str ());
       }
     else if (! input_from_tmp_history_file
-             && ! m_lexer.force_script
-             && m_lexer.reading_script_file
-             && m_lexer.fcn_file_name == id_name)
+             && ! m_lexer.m_force_script
+             && m_lexer.m_reading_script_file
+             && m_lexer.m_fcn_file_name == id_name)
       {
         warning ("function '%s' defined within script file '%s'",
-                 id_name.c_str (), m_lexer.fcn_file_full_name.c_str ());
+                 id_name.c_str (), m_lexer.m_fcn_file_full_name.c_str ());
       }
 
     fcn->stash_function_name (id_name);
 
     // Record help text for functions other than nested functions.
     // We cannot currently record help for nested functions (bug #46008)
     // because the doc_string of the outermost function is read first,
     // whereas this function is called for the innermost function first.
     // We could have a stack of help_text in lexer.
-    if (! m_lexer.help_text.empty () && m_curr_fcn_depth == 1)
+    if (! m_lexer.m_help_text.empty () && m_curr_fcn_depth == 1)
       {
-        fcn->document (m_lexer.help_text);
-
-        m_lexer.help_text = "";
+        fcn->document (m_lexer.m_help_text);
+
+        m_lexer.m_help_text = "";
       }
 
-    if (m_lexer.reading_fcn_file && m_curr_fcn_depth == 1
+    if (m_lexer.m_reading_fcn_file && m_curr_fcn_depth == 1
         && ! m_parsing_subfunctions)
       m_primary_fcn_ptr = fcn;
 
     return fcn;
   }
 
   tree_statement *
   base_parser::make_end (const std::string& type, bool eof, int l, int c)
@@ -3513,58 +3513,58 @@ namespace octave
                 fcn_scope.set_parent (m_primary_fcn_scope);
                 m_primary_fcn_scope.install_subfunction (nm, ov_fcn);
               }
           }
 
         if (m_curr_fcn_depth == 1)
           fcn_scope.update_nest ();
 
-        if (! m_lexer.reading_fcn_file && m_curr_fcn_depth == 1)
+        if (! m_lexer.m_reading_fcn_file && m_curr_fcn_depth == 1)
           {
             // We are either reading a script file or defining a function
             // at the command line, so this definition creates a
             // tree_function object that is placed in the parse tree.
             // Otherwise, it is just inserted in the symbol table,
             // either as a subfunction or nested function (see above),
             // or as the primary function for the file, via
             // m_primary_fcn_ptr (see also load_fcn_from_file,,
             // parse_fcn_file, and
             // fcn_info::fcn_info_rep::find_user_function).
 
-            if (m_lexer.buffer_function_text)
+            if (m_lexer.m_buffer_function_text)
               {
-                fcn->cache_function_text (m_lexer.function_text,
+                fcn->cache_function_text (m_lexer.m_function_text,
                                           fcn->time_parsed ());
-                m_lexer.buffer_function_text = false;
+                m_lexer.m_buffer_function_text = false;
               }
 
             retval = new tree_function_def (fcn);
           }
       }
 
     return retval;
   }
 
   void
   base_parser::recover_from_parsing_function (void)
   {
-    m_lexer.symtab_context.pop ();
-
-    if (m_lexer.reading_fcn_file && m_curr_fcn_depth == 1
+    m_lexer.m_symtab_context.pop ();
+
+    if (m_lexer.m_reading_fcn_file && m_curr_fcn_depth == 1
         && ! m_parsing_subfunctions)
       m_parsing_subfunctions = true;
 
     m_curr_fcn_depth--;
     m_function_scopes.pop ();
 
-    m_lexer.defining_func--;
-    m_lexer.parsed_function_name.pop ();
-    m_lexer.looking_at_return_list = false;
-    m_lexer.looking_at_parameter_list = false;
+    m_lexer.m_defining_func--;
+    m_lexer.m_parsed_function_name.pop ();
+    m_lexer.m_looking_at_return_list = false;
+    m_lexer.m_looking_at_parameter_list = false;
   }
 
   tree_funcall *
   base_parser::make_superclass_ref (const std::string& method_nm,
                                     const std::string& class_nm)
   {
     octave_value_list args;
 
@@ -3607,42 +3607,42 @@ namespace octave
                               tree_classdef_attribute_list *a,
                               tree_identifier *id,
                               tree_classdef_superclass_list *sc,
                               tree_classdef_body *body, token *end_tok,
                               comment_list *lc)
   {
     tree_classdef *retval = nullptr;
 
-    m_lexer.symtab_context.pop ();
+    m_lexer.m_symtab_context.pop ();
 
     std::string cls_name = id->name ();
 
-    std::string nm = m_lexer.fcn_file_name;
+    std::string nm = m_lexer.m_fcn_file_name;
 
     size_t pos = nm.find_last_of (sys::file_ops::dir_sep_chars ());
 
     if (pos != std::string::npos)
-      nm = m_lexer.fcn_file_name.substr (pos+1);
+      nm = m_lexer.m_fcn_file_name.substr (pos+1);
 
     if (nm != cls_name)
       {
         delete a;
         delete id;
         delete sc;
         delete body;
 
         bison_error ("invalid classdef definition, the class name must match the filename");
 
       }
     else
       {
         if (end_token_ok (end_tok, token::classdef_end))
           {
-            comment_list *tc = m_lexer.comment_buf.get_comment ();
+            comment_list *tc = m_lexer.m_comment_buf.get_comment ();
 
             int l = tok_val->line ();
             int c = tok_val->column ();
 
             if (! body)
               body = new tree_classdef_body ();
 
             retval = new tree_classdef (a, id, sc, body, lc, tc,
@@ -3668,17 +3668,17 @@ namespace octave
                                                tree_classdef_property_list *plist,
                                                token *end_tok,
                                                comment_list *lc)
   {
     tree_classdef_properties_block *retval = nullptr;
 
     if (end_token_ok (end_tok, token::properties_end))
       {
-        comment_list *tc = m_lexer.comment_buf.get_comment ();
+        comment_list *tc = m_lexer.m_comment_buf.get_comment ();
 
         int l = tok_val->line ();
         int c = tok_val->column ();
 
         if (! plist)
           plist = new tree_classdef_property_list ();
 
         retval = new tree_classdef_properties_block (a, plist, lc, tc, l, c);
@@ -3700,17 +3700,17 @@ namespace octave
                                             tree_classdef_methods_list *mlist,
                                             token *end_tok,
                                             comment_list *lc)
   {
     tree_classdef_methods_block *retval = nullptr;
 
     if (end_token_ok (end_tok, token::methods_end))
       {
-        comment_list *tc = m_lexer.comment_buf.get_comment ();
+        comment_list *tc = m_lexer.m_comment_buf.get_comment ();
 
         int l = tok_val->line ();
         int c = tok_val->column ();
 
         if (! mlist)
           mlist = new tree_classdef_methods_list ();
 
         retval = new tree_classdef_methods_block (a, mlist, lc, tc, l, c);
@@ -3732,17 +3732,17 @@ namespace octave
                                            tree_classdef_events_list *elist,
                                            token *end_tok,
                                            comment_list *lc)
   {
     tree_classdef_events_block *retval = nullptr;
 
     if (end_token_ok (end_tok, token::events_end))
       {
-        comment_list *tc = m_lexer.comment_buf.get_comment ();
+        comment_list *tc = m_lexer.m_comment_buf.get_comment ();
 
         int l = tok_val->line ();
         int c = tok_val->column ();
 
         if (! elist)
           elist = new tree_classdef_events_list ();
 
         retval = new tree_classdef_events_block (a, elist, lc, tc, l, c);
@@ -3764,17 +3764,17 @@ namespace octave
                                          tree_classdef_enum_list *elist,
                                          token *end_tok,
                                          comment_list *lc)
   {
     tree_classdef_enum_block *retval = nullptr;
 
     if (end_token_ok (end_tok, token::enumeration_end))
       {
-        comment_list *tc = m_lexer.comment_buf.get_comment ();
+        comment_list *tc = m_lexer.m_comment_buf.get_comment ();
 
         int l = tok_val->line ();
         int c = tok_val->column ();
 
         if (! elist)
           elist = new tree_classdef_enum_list ();
 
         retval = new tree_classdef_enum_block (a, elist, lc, tc, l, c);
@@ -3855,17 +3855,17 @@ namespace octave
 
     return new tree_function_def (fcn, l, c);
   }
 
   void
   base_parser::finish_classdef_file (tree_classdef *cls,
                                      tree_statement_list *local_fcns)
   {
-    if (m_lexer.reading_classdef_file)
+    if (m_lexer.m_reading_classdef_file)
       m_classdef_object = cls;
 
     if (local_fcns)
       {
         symbol_table& symtab
           = __get_symbol_table__ ("base_parser::finish_classdef_file");
 
         for (tree_statement *elt : *local_fcns)
@@ -3947,17 +3947,17 @@ namespace octave
 
         tmp->append (elt);
 
         retval = tmp;
       }
     else
       retval = new tree_index_expression (expr, elt, l, c);
 
-    m_lexer.looking_at_indirect_ref = false;
+    m_lexer.m_looking_at_indirect_ref = false;
 
     return retval;
   }
 
   // Make an indirect reference expression with dynamic field name.
 
   tree_index_expression *
   base_parser::make_indirect_ref (tree_expression *expr,
@@ -3977,17 +3977,17 @@ namespace octave
 
         tmp->append (elt);
 
         retval = tmp;
       }
     else
       retval = new tree_index_expression (expr, elt, l, c);
 
-    m_lexer.looking_at_indirect_ref = false;
+    m_lexer.m_looking_at_indirect_ref = false;
 
     return retval;
   }
 
   // Make a declaration command.
 
   tree_decl_command *
   base_parser::make_decl_command (int tok, token *tok_val,
@@ -4013,19 +4013,19 @@ namespace octave
       case PERSISTENT:
         if (m_curr_fcn_depth > 0)
           {
             retval = new tree_decl_command ("persistent", lst, l, c);
             retval->mark_persistent ();
           }
         else
           {
-            if (m_lexer.reading_script_file)
+            if (m_lexer.m_reading_script_file)
               warning ("ignoring persistent declaration near line %d of file '%s'",
-                       l, m_lexer.fcn_file_full_name.c_str ());
+                       l, m_lexer.m_fcn_file_full_name.c_str ());
             else
               warning ("ignoring persistent declaration near line %d", l);
           }
         break;
 
       default:
         panic_impossible ();
         break;
@@ -4254,17 +4254,17 @@ namespace octave
     if (m_curr_fcn_depth > 0)
       {
         tree_statement *tmp = t->back ();
 
         if (tmp->is_expression ())
           warning_with_id
             ("Octave:missing-semicolon",
              "missing semicolon near line %d, column %d in file '%s'",
-             tmp->line (), tmp->column (), m_lexer.fcn_file_full_name.c_str ());
+             tmp->line (), tmp->column (), m_lexer.m_fcn_file_full_name.c_str ());
       }
   }
 
   tree_statement_list *
   base_parser::set_stmt_print_flag (tree_statement_list *list,
                                     char sep, bool warn_missing_semi)
   {
     tree_statement *tmp = list->back ();
@@ -4326,34 +4326,34 @@ namespace octave
     list->append (stmt);
 
     return list;
   }
 
   void
   base_parser::bison_error (const std::string& str, int l, int c)
   {
-    int err_line = l < 0 ? m_lexer.input_line_number : l;
-    int err_col = c < 0 ? m_lexer.current_input_column - 1 : c;
+    int err_line = l < 0 ? m_lexer.m_input_line_number : l;
+    int err_col = c < 0 ? m_lexer.m_current_input_column - 1 : c;
 
     std::ostringstream output_buf;
 
-    if (m_lexer.reading_fcn_file || m_lexer.reading_script_file
-        || m_lexer.reading_classdef_file)
+    if (m_lexer.m_reading_fcn_file || m_lexer.m_reading_script_file
+        || m_lexer.m_reading_classdef_file)
       output_buf << "parse error near line " << err_line
-                 << " of file " << m_lexer.fcn_file_full_name;
+                 << " of file " << m_lexer.m_fcn_file_full_name;
     else
       output_buf << "parse error:";
 
     if (str != "parse error")
       output_buf << "\n\n  " << str;
 
     output_buf << "\n\n";
 
-    std::string curr_line = m_lexer.current_input_line;
+    std::string curr_line = m_lexer.m_current_input_line;
 
     if (! curr_line.empty ())
       {
         size_t len = curr_line.length ();
 
         if (curr_line[len-1] == '\n')
           curr_line.resize (len-1);
 
@@ -4383,34 +4383,34 @@ namespace octave
     yypstate *pstate = static_cast<yypstate *> (m_parser_state);
 
     try
       {
         status = octave_pull_parse (pstate, *this);
       }
     catch (execution_exception& e)
       {
-        std::string file = m_lexer.fcn_file_full_name;
+        std::string file = m_lexer.m_fcn_file_full_name;
 
         if (file.empty ())
           error (e, "parse error");
         else
           error (e, "parse error in %s", file.c_str ());
       }
     catch (const exit_exception&)
       {
         throw;
       }
     catch (interrupt_exception &)
       {
         throw;
       }
     catch (...)
       {
-        std::string file = m_lexer.fcn_file_full_name;
+        std::string file = m_lexer.m_fcn_file_full_name;
 
         if (file.empty ())
           error ("unexpected exception while parsing input");
         else
           error ("unexpected exception while parsing %s", file.c_str ());
       }
 
     if (status != 0)
@@ -4428,17 +4428,17 @@ namespace octave
     int status = -1;
 
     dynamic_cast<push_lexer&> (m_lexer).append_input (input, eof);
 
     do
       {
         YYSTYPE lval;
 
-        int token = octave_lex (&lval, m_lexer.scanner);
+        int token = octave_lex (&lval, m_lexer.m_scanner);
 
         if (token < 0)
           {
             if (! eof && m_lexer.at_end_of_buffer ())
               {
                 status = -1;
                 break;
               }
@@ -4447,34 +4447,34 @@ namespace octave
         yypstate *pstate = static_cast<yypstate *> (m_parser_state);
 
         try
           {
             status = octave_push_parse (pstate, token, &lval, *this);
           }
         catch (execution_exception& e)
           {
-            std::string file = m_lexer.fcn_file_full_name;
+            std::string file = m_lexer.m_fcn_file_full_name;
 
             if (file.empty ())
               error (e, "parse error");
             else
               error (e, "parse error in %s", file.c_str ());
           }
         catch (const exit_exception&)
           {
             throw;
           }
         catch (interrupt_exception &)
           {
             throw;
           }
         catch (...)
           {
-            std::string file = m_lexer.fcn_file_full_name;
+            std::string file = m_lexer.m_fcn_file_full_name;
 
             if (file.empty ())
               error ("unexpected exception while parsing input");
             else
               error ("unexpected exception while parsing %s", file.c_str ());
           }
       }
     while (status == YYPUSH_MORE);
@@ -4528,32 +4528,32 @@ parse_fcn_file (const std::string& full_
 
       octave::parser parser (ffile);
 
       parser.m_curr_class_name = dispatch_type;
       parser.m_curr_package_name = package_name;
       parser.m_autoloading = autoload;
       parser.m_fcn_file_from_relative_lookup = relative_lookup;
 
-      parser.m_lexer.force_script = force_script;
+      parser.m_lexer.m_force_script = force_script;
       parser.m_lexer.prep_for_file ();
-      parser.m_lexer.parsing_class_method = ! dispatch_type.empty ();
-
-      parser.m_lexer.fcn_file_name = file;
-      parser.m_lexer.fcn_file_full_name = full_file;
-      parser.m_lexer.dir_name = dir_name;
-      parser.m_lexer.package_name = package_name;
+      parser.m_lexer.m_parsing_class_method = ! dispatch_type.empty ();
+
+      parser.m_lexer.m_fcn_file_name = file;
+      parser.m_lexer.m_fcn_file_full_name = full_file;
+      parser.m_lexer.m_dir_name = dir_name;
+      parser.m_lexer.m_package_name = package_name;
 
       int status = parser.run ();
 
       fcn_ptr = parser.m_primary_fcn_ptr;
 
       if (status == 0)
         {
-          if (parser.m_lexer.reading_classdef_file
+          if (parser.m_lexer.m_reading_classdef_file
               && parser.m_classdef_object)
             {
               // Convert parse tree for classdef object to
               // meta.class info (and stash it in the symbol
               // table?).  Return pointer to constructor?
 
               if (fcn_ptr)
                 panic_impossible ();
@@ -5446,17 +5446,17 @@ namespace octave
                 else
                   error ("eval: invalid use of statement list");
 
                 if (tree_return_command::returning
                     || tree_break_command::breaking
                     || tree_continue_command::continuing)
                   break;
               }
-            else if (parser.m_lexer.end_of_input)
+            else if (parser.m_lexer.m_end_of_input)
               break;
           }
       }
     while (parse_status == 0);
 
     return retval;
   }
 
diff --git a/libinterp/parse-tree/profiler.cc b/libinterp/parse-tree/profiler.cc
--- a/libinterp/parse-tree/profiler.cc
+++ b/libinterp/parse-tree/profiler.cc
@@ -31,19 +31,19 @@ along with Octave; see the file COPYING.
 #include "interpreter.h"
 #include "oct-time.h"
 #include "ov-struct.h"
 #include "pager.h"
 #include "profiler.h"
 
 namespace octave
 {
-  profiler::stats::stats ()
-    : time (0.0), calls (0), recursive (false),
-      parents (), children ()
+  profiler::stats::stats (void)
+    : m_time (0.0), m_calls (0), m_recursive (false),
+      m_parents (), m_children ()
   { }
 
   octave_value
   profiler::stats::function_set_value (const function_set& list)
   {
     const octave_idx_type n = list.size ();
 
     RowVector retval (n);
@@ -52,111 +52,111 @@ namespace octave
       retval(i++) = nm;
 
     assert (i == n);
 
     return retval;
   }
 
   profiler::tree_node::tree_node (tree_node *p, octave_idx_type f)
-    : parent (p), fcn_id (f), children (), time (0.0), calls (0)
+    : m_parent (p), m_fcn_id (f), m_children (), m_time (0.0), m_calls (0)
   { }
 
   profiler::tree_node::~tree_node ()
   {
-    for (auto& idx_tnode : children)
+    for (auto& idx_tnode : m_children)
       delete idx_tnode.second;
   }
 
   profiler::tree_node*
   profiler::tree_node::enter (octave_idx_type fcn)
   {
     tree_node *retval;
 
-    child_map::iterator pos = children.find (fcn);
-    if (pos == children.end ())
+    child_map::iterator pos = m_children.find (fcn);
+    if (pos == m_children.end ())
       {
         retval = new tree_node (this, fcn);
-        children[fcn] = retval;
+        m_children[fcn] = retval;
       }
     else
       retval = pos->second;
 
-    ++retval->calls;
+    ++retval->m_calls;
     return retval;
   }
 
   profiler::tree_node*
   profiler::tree_node::exit (octave_idx_type /* fcn */)
   {
     // FIXME: These assert statements don't make sense if profile() is called
     //        from within a function hierarchy to begin with.  See bug #39587.
-    //  assert (parent);
-    //  assert (fcn_id == fcn);
+    //  assert (m_parent);
+    //  assert (m_fcn_id == fcn);
 
-    return parent;
+    return m_parent;
   }
 
   void
   profiler::tree_node::build_flat (flat_profile& data) const
   {
     // If this is not the top-level node, update profile entry for this function.
-    if (fcn_id != 0)
+    if (m_fcn_id != 0)
       {
-        stats& entry = data[fcn_id - 1];
+        stats& entry = data[m_fcn_id - 1];
 
-        entry.time += time;
-        entry.calls += calls;
+        entry.m_time += m_time;
+        entry.m_calls += m_calls;
 
-        assert (parent);
-        if (parent->fcn_id != 0)
+        assert (m_parent);
+        if (m_parent->m_fcn_id != 0)
           {
-            entry.parents.insert (parent->fcn_id);
-            data[parent->fcn_id - 1].children.insert (fcn_id);
+            entry.m_parents.insert (m_parent->m_fcn_id);
+            data[m_parent->m_fcn_id - 1].m_children.insert (m_fcn_id);
           }
 
-        if (! entry.recursive)
-          for (const tree_node *i = parent; i; i = i->parent)
-            if (i->fcn_id == fcn_id)
+        if (! entry.m_recursive)
+          for (const tree_node *i = m_parent; i; i = i->m_parent)
+            if (i->m_fcn_id == m_fcn_id)
               {
-                entry.recursive = true;
+                entry.m_recursive = true;
                 break;
               }
       }
 
     // Recurse on children.
-    for (const auto& idx_tnode : children)
+    for (const auto& idx_tnode : m_children)
       idx_tnode.second->build_flat (data);
   }
 
   octave_value
   profiler::tree_node::get_hierarchical (double *total) const
   {
     // Note that we don't generate the entry just for this node, but
     // rather a struct-array with entries for all children.  This way, the
     // top-node (for which we don't want a real entry) generates already
     // the final hierarchical profile data.
 
-    const octave_idx_type n = children.size ();
+    const octave_idx_type n = m_children.size ();
 
     Cell rv_indices (n, 1);
     Cell rv_times (n, 1);
     Cell rv_totals (n, 1);
     Cell rv_calls (n, 1);
     Cell rv_children (n, 1);
 
     octave_idx_type i = 0;
-    for (const auto& idx_tnode : children)
+    for (const auto& idx_tnode : m_children)
       {
         const tree_node& entry = *idx_tnode.second;
-        double child_total = entry.time;
+        double child_total = entry.m_time;
 
         rv_indices(i) = octave_value (idx_tnode.first);
-        rv_times(i) = octave_value (entry.time);
-        rv_calls(i) = octave_value (entry.calls);
+        rv_times(i) = octave_value (entry.m_time);
+        rv_calls(i) = octave_value (entry.m_calls);
         rv_children(i) = entry.get_hierarchical (&child_total);
         rv_totals(i) = octave_value (child_total);
 
         if (total)
           *total += child_total;
 
         ++i;
       }
@@ -169,140 +169,140 @@ namespace octave
     retval.assign ("TotalTime", rv_totals);
     retval.assign ("NumCalls", rv_calls);
     retval.assign ("Children", rv_children);
 
     return retval;
   }
 
   profiler::profiler (void)
-    : known_functions (), fcn_index (),
-      enabled (false), call_tree (new tree_node (nullptr, 0)),
-      active_fcn (nullptr), last_time (-1.0)
+    : m_known_functions (), m_fcn_index (),
+      m_enabled (false), m_call_tree (new tree_node (nullptr, 0)),
+      m_active_fcn (nullptr), m_last_time (-1.0)
   { }
 
   profiler::~profiler (void)
   {
-    delete call_tree;
+    delete m_call_tree;
   }
 
   void
   profiler::set_active (bool value)
   {
-    enabled = value;
+    m_enabled = value;
   }
 
   void
   profiler::enter_function (const std::string& fcn)
   {
     // The enter class will check and only call us if the profiler is active.
-    assert (is_active ());
-    assert (call_tree);
+    assert (enabled ());
+    assert (m_call_tree);
 
     // If there is already an active function, add to its time before
     // pushing the new one.
-    if (active_fcn && active_fcn != call_tree)
+    if (m_active_fcn && m_active_fcn != m_call_tree)
       add_current_time ();
 
     // Map the function's name to its index.
     octave_idx_type fcn_idx;
-    fcn_index_map::iterator pos = fcn_index.find (fcn);
-    if (pos == fcn_index.end ())
+    fcn_index_map::iterator pos = m_fcn_index.find (fcn);
+    if (pos == m_fcn_index.end ())
       {
-        known_functions.push_back (fcn);
-        fcn_idx = known_functions.size ();
-        fcn_index[fcn] = fcn_idx;
+        m_known_functions.push_back (fcn);
+        fcn_idx = m_known_functions.size ();
+        m_fcn_index[fcn] = fcn_idx;
       }
     else
       fcn_idx = pos->second;
 
-    if (! active_fcn)
-      active_fcn = call_tree;
+    if (! m_active_fcn)
+      m_active_fcn = m_call_tree;
 
-    active_fcn = active_fcn->enter (fcn_idx);
+    m_active_fcn = m_active_fcn->enter (fcn_idx);
 
-    last_time = query_time ();
+    m_last_time = query_time ();
 
   }
 
   void
   profiler::exit_function (const std::string& fcn)
   {
-    if (active_fcn)
+    if (m_active_fcn)
       {
-        assert (call_tree);
+        assert (m_call_tree);
         // FIXME: This assert statements doesn't make sense if profile() is called
         //        from within a function hierarchy to begin with.  See bug #39587.
-        //assert (active_fcn != call_tree);
+        //assert (m_active_fcn != m_call_tree);
 
         // Usually, if we are disabled this function is not even called.  But the
         // call disabling the profiler is an exception.  So also check here
         // and only record the time if enabled.
-        if (is_active ())
+        if (enabled ())
           add_current_time ();
 
-        fcn_index_map::iterator pos = fcn_index.find (fcn);
+        fcn_index_map::iterator pos = m_fcn_index.find (fcn);
         // FIXME: This assert statements doesn't make sense if profile() is called
         //        from within a function hierarchy to begin with.  See bug #39587.
-        //assert (pos != fcn_index.end ());
-        active_fcn = active_fcn->exit (pos->second);
+        //assert (pos != m_fcn_index.end ());
+        m_active_fcn = m_active_fcn->exit (pos->second);
 
         // If this was an "inner call", we resume executing the parent function
         // up the stack.  So note the start-time for this!
-        last_time = query_time ();
+        m_last_time = query_time ();
       }
   }
 
   void
   profiler::reset (void)
   {
-    if (is_active ())
+    if (enabled ())
       error ("Can't reset active profiler.");
 
-    known_functions.clear ();
-    fcn_index.clear ();
+    m_known_functions.clear ();
+    m_fcn_index.clear ();
 
-    if (call_tree)
+    if (m_call_tree)
       {
-        delete call_tree;
-        call_tree = new tree_node (nullptr, 0);
-        active_fcn = nullptr;
+        delete m_call_tree;
+        m_call_tree = new tree_node (nullptr, 0);
+        m_active_fcn = nullptr;
       }
 
-    last_time = -1.0;
+    m_last_time = -1.0;
   }
 
   octave_value
   profiler::get_flat (void) const
   {
     octave_value retval;
 
-    const octave_idx_type n = known_functions.size ();
+    const octave_idx_type n = m_known_functions.size ();
 
     flat_profile flat (n);
 
-    if (call_tree)
+    if (m_call_tree)
       {
-        call_tree->build_flat (flat);
+        m_call_tree->build_flat (flat);
 
         Cell rv_names (n, 1);
         Cell rv_times (n, 1);
         Cell rv_calls (n, 1);
         Cell rv_recursive (n, 1);
         Cell rv_parents (n, 1);
         Cell rv_children (n, 1);
 
         for (octave_idx_type i = 0; i != n; ++i)
           {
-            rv_names(i) = octave_value (known_functions[i]);
-            rv_times(i) = octave_value (flat[i].time);
-            rv_calls(i) = octave_value (flat[i].calls);
-            rv_recursive(i) = octave_value (flat[i].recursive);
-            rv_parents(i) = stats::function_set_value (flat[i].parents);
-            rv_children(i) = stats::function_set_value (flat[i].children);
+            rv_names(i) = octave_value (m_known_functions[i]);
+            rv_times(i) = octave_value (flat[i].m_time);
+            rv_calls(i) = octave_value (flat[i].m_calls);
+            rv_recursive(i) = octave_value (flat[i].m_recursive);
+            rv_parents(i) = stats::function_set_value (flat[i].m_parents);
+            rv_children(i) = stats::function_set_value (flat[i].m_children);
           }
 
         octave_map m;
 
         m.assign ("FunctionName", rv_names);
         m.assign ("TotalTime", rv_times);
         m.assign ("NumCalls", rv_calls);
         m.assign ("IsRecursive", rv_recursive);
@@ -332,18 +332,18 @@ namespace octave
     return retval;
   }
 
   octave_value
   profiler::get_hierarchical (void) const
   {
     octave_value retval;
 
-    if (call_tree)
-      retval = call_tree->get_hierarchical ();
+    if (m_call_tree)
+      retval = m_call_tree->get_hierarchical ();
     else
       {
         static const char *fn[] =
           {
             "Index",
             "SelfTime",
             "NumCalls",
             "Children",
@@ -368,21 +368,21 @@ namespace octave
     volatile double dnow = now.double_value ();
 
     return dnow;
   }
 
   void
   profiler::add_current_time (void)
   {
-    if (active_fcn)
+    if (m_active_fcn)
       {
         const double t = query_time ();
 
-        active_fcn->add_time (t - last_time);
+        m_active_fcn->add_time (t - m_last_time);
       }
   }
 }
 
 // Enable or disable the profiler data collection.
 DEFMETHOD (__profiler_enable__, interp, args, ,
            doc: /* -*- texinfo -*-
 @deftypefn {} {} __profiler_enable__ ()
@@ -394,17 +394,17 @@ Undocumented internal function.
   if (nargin > 1)
     print_usage ();
 
   octave::profiler& profiler = interp.get_profiler ();
 
   if (nargin == 1)
     profiler.set_active (args(0).bool_value ());
 
-  return ovl (profiler.is_active ());
+  return ovl (profiler.enabled ());
 }
 
 // Clear all collected profiling data.
 DEFMETHOD (__profiler_reset__, interp, args, ,
            doc: /* -*- texinfo -*-
 @deftypefn {} {} __profiler_reset__ ()
 Undocumented internal function.
 @end deftypefn */)
diff --git a/libinterp/parse-tree/profiler.h b/libinterp/parse-tree/profiler.h
--- a/libinterp/parse-tree/profiler.h
+++ b/libinterp/parse-tree/profiler.h
@@ -44,111 +44,113 @@ namespace octave
 
     // This is a utility class that can be used to call the enter/exit
     // functions in a manner protected from stack unwinding.
     template <typename T> class enter
     {
     private:
 
       profiler& m_profiler;
-      std::string fcn;
-      bool is_active;
+      std::string m_fcn;
+      bool m_enabled;
 
     public:
 
       enter (profiler& p, const T& t) : m_profiler (p)
       {
         // A profiling block cannot be active if the profiler is not
-        is_active = m_profiler.is_active ();
+        m_enabled = m_profiler.enabled ();
 
-        if (is_active)
+        if (m_enabled)
           {
-            fcn = t.profiler_name ();
+            m_fcn = t.profiler_name ();
 
-            // NOTE: The test f != "" must be kept to prevent a blank line showing
-            //  up in profiler statistics.  See bug #39524.  The root cause is that
-            //  the function name is not set for the recurring readline hook function.
-            if (fcn == "")
-              is_active = false;  // Inactive profiling block
+            // NOTE: The test f != "" must be kept to prevent a blank
+            // line showing up in profiler statistics.  See bug
+            // #39524.  The root cause is that the function name is
+            // not set for the recurring readline hook function.
+            if (m_fcn == "")
+              m_enabled = false;  // Inactive profiling block
             else
-              m_profiler.enter_function (fcn);
+              m_profiler.enter_function (m_fcn);
           }
       }
 
       // No copying!
 
       enter (const enter&) = delete;
 
       enter& operator = (const enter&) = delete;
 
       ~enter (void)
       {
-        if (is_active)
-          m_profiler.exit_function (fcn);
+        if (m_enabled)
+          m_profiler.exit_function (m_fcn);
       }
     };
 
     profiler (void);
 
     // No copying!
 
     profiler (const profiler&) = delete;
 
     profiler& operator = (const profiler&) = delete;
 
     virtual ~profiler (void);
 
-    bool is_active (void) const { return enabled; }
+    bool enabled (void) const { return m_enabled; }
     void set_active (bool);
 
     void reset (void);
 
     octave_value get_flat (void) const;
     octave_value get_hierarchical (void) const;
 
   private:
 
     // One entry in the flat profile (i.e., a collection of data for a single
     // function).  This is filled in when building the flat profile from the
     // hierarchical call tree.
     struct stats
     {
       stats (void);
 
-      double time;
-      unsigned calls;
+      double m_time;
+      size_t m_calls;
 
-      bool recursive;
+      bool m_recursive;
 
       typedef std::set<octave_idx_type> function_set;
-      function_set parents;
-      function_set children;
+      function_set m_parents;
+      function_set m_children;
 
       // Convert a function_set list to an Octave array of indices.
       static octave_value function_set_value (const function_set&);
     };
 
     typedef std::vector<stats> flat_profile;
 
     // Store data for one node in the call-tree of the hierarchical profiler
     // data we collect.
     class tree_node
     {
     public:
 
       tree_node (tree_node*, octave_idx_type);
+
       virtual ~tree_node (void);
 
       // No copying!
 
       tree_node (const tree_node&) = delete;
 
       tree_node& operator = (const tree_node&) = delete;
 
-      void add_time (double dt) { time += dt; }
+      void add_time (double dt) { m_time += dt; }
 
       // Enter a child function.  It is created in the list of children if it
       // wasn't already there.  The now-active child node is returned.
       tree_node *enter (octave_idx_type);
 
       // Exit function.  As a sanity-check, it is verified that the currently
       // active function actually is the one handed in here.  Returned is the
       // then-active node, which is our parent.
@@ -158,45 +160,45 @@ namespace octave
 
       // Get the hierarchical profile for this node and its children.  If total
       // is set, accumulate total time of the subtree in that variable as
       // additional return value.
       octave_value get_hierarchical (double *total = nullptr) const;
 
     private:
 
-      tree_node *parent;
-      octave_idx_type fcn_id;
+      tree_node *m_parent;
+      octave_idx_type m_fcn_id;
 
       typedef std::map<octave_idx_type, tree_node*> child_map;
-      child_map children;
+      child_map m_children;
 
       // This is only time spent *directly* on this level, excluding children!
-      double time;
+      double m_time;
 
-      unsigned calls;
+      size_t m_calls;
     };
 
     // Each function we see in the profiler is given a unique index (which
     // simply counts starting from 1).  We thus have to map profiler-names to
     // those indices.  For all other stuff, we identify functions by their index.
 
     typedef std::vector<std::string> function_set;
     typedef std::map<std::string, octave_idx_type> fcn_index_map;
 
-    function_set known_functions;
-    fcn_index_map fcn_index;
+    function_set m_known_functions;
+    fcn_index_map m_fcn_index;
 
-    bool enabled;
+    bool m_enabled;
 
-    tree_node *call_tree;
-    tree_node *active_fcn;
+    tree_node *m_call_tree;
+    tree_node *m_active_fcn;
 
     // Store last timestamp we had, when the currently active function was called.
-    double last_time;
+    double m_last_time;
 
     // These are private as only the unwind-protecting inner class enter
     // should be allowed to call them.
     void enter_function (const std::string&);
     void exit_function (const std::string&);
 
     // Query a timestamp, used for timing calls (obviously).
     // This is not static because in the future, maybe we want a flag
