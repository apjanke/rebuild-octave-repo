# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1458253907 14400
#      Thu Mar 17 18:31:47 2016 -0400
# Node ID 29e2523c99c2b7efc29fda08a6d6a248ae15e6d8
# Parent  7d06afd924bea14cd2e9be1c41a6fd541a4927e1
* textscan.cc: More style fixes.

diff --git a/libinterp/corefcn/textscan.cc b/libinterp/corefcn/textscan.cc
--- a/libinterp/corefcn/textscan.cc
+++ b/libinterp/corefcn/textscan.cc
@@ -93,26 +93,29 @@ dstr::get_undelim ()
       return EOF;
     }
 
   if (idx < eob)
     retval = *idx++;
   else
     {
       refresh_buf ();
+
       if (eof ())
         {
           setstate (std::ios_base::eofbit);
           retval = EOF;
         }
       else
         retval = *idx++;
     }
+
   if (idx >= last)
     delimited = false;
+
   return retval;
 }
 
 // Return the next character to be read without incrementing the
 // pointer, refilling the buffer from the file if necessary.
 
 int
 dstr::peek_undelim ()
@@ -147,44 +150,46 @@ dstr::refresh_buf (void)
 
   if (old_remaining > 0)
     memmove (buf, idx, old_remaining);
 
   progress_marker -= idx - buf;         // where original idx would have been
   idx = buf;
 
   int gcount;   // chars read
-  if (!i_stream.eof ())
+  if (! i_stream.eof ())
     {
       buf_in_file = i_stream.tellg ();   // record for destructor
       i_stream.read (buf + old_remaining, bufsize - old_remaining);
       gcount = i_stream.gcount ();
     }
   else
     gcount = 0;
 
   eob = buf + old_remaining + gcount;
   last = eob;
   if (gcount == 0)
     {
       delimited = false;
+
       if (eob != buf)              // no more data in file, but still some to go
         retval = 0;
       else
         retval = EOF;              // file and buffer are both done.
     }
   else
     {
       delimited = true;
 
       for (last = eob - longest; last - buf >= 0; last--)
         {
           if (strchr (delims.c_str (), *last))
             break;
         }
+
       if (last - buf < 0)
         delimited = false;
 
       retval = 0;
     }
 
   if (retval == EOF)  // Ensure fast peek doesn't give valid char
     *idx = '\0';      // FIXME - check that no TreatAsEmpty etc starts w. \0?
@@ -197,40 +202,43 @@ dstr::refresh_buf (void)
 // If called when delimited == true, and size is no greater than
 // longest_lookahead then this will not call refresh_buf, so seekg
 // still works.  Otherwise, seekg may be invalidated.
 
 char *
 dstr::read (char *buffer, int size, char* &prior_tell)
 {
   char *retval;
+
   if (eob  - idx > size)
     {
       retval = idx;
       idx += size;
       if (idx > last)
         delimited = false;
     }
   else
     {
       // If there was a tellg pointing to an earlier point than the current
       // read position, try to keep it in the active buffer.
       // In the current code, prior_tell==idx for each call,
       // so this is not necessary, just a precaution.
+
       if (eob - prior_tell + size < bufsize)
         {
           octave_idx_type gap = idx - prior_tell;
           idx = prior_tell;
           refresh_buf ();
           idx += gap;
         }
       else      // can't keep the tellg in range.  May skip some data.
         {
           refresh_buf ();
         }
+
       prior_tell = buf;
 
       if (eob - idx > size)
         {
           retval = idx;
           idx += size;
           if (idx > last)
             delimited = false;
@@ -243,23 +251,24 @@ dstr::read (char *buffer, int size, char
               memset (eob, 0, size + (idx - buf));
               idx += size;
             }
           else  // Reading more than the whole buf; return it in buffer
             {
               retval = buffer;
               // FIXME -- read bufsize at a time
               int i;
-              for (i = 0; i < size && !eof (); i++)
+              for (i = 0; i < size && ! eof (); i++)
                 *buffer++ = get_undelim ();
               if (eof ())
                 memset (buffer, 0, size - i);
             }
         }
     }
+
   return retval;
 }
 
 // Return in OUT an entire line, terminated by delim.  On input, OUT
 // must have length at least 1.
 
 int
 dstr::getline (std::string& out, char delim)
@@ -308,16 +317,17 @@ textscan_format_list::textscan_format_li
                        discard, type, num_elts);
       have_more = false;
       set_from_first = true;
       nconv = 1;
     }
   else
     {
       set_from_first = false;
+
       while (i < n)
         {
           have_more = true;
 
           if (! buf)
             buf = new std::ostringstream ();
 
           if (s[i] == '%' && (i+1 == n || s[i+1] != '%'))
@@ -363,17 +373,18 @@ textscan_format_list::textscan_format_li
             {
               have_more = false;
               break;
             }
         }
     }
 
   if (have_more)
-    add_elt_to_list (width, prec, bitwidth, octave_value (), discard, type, num_elts);
+    add_elt_to_list (width, prec, bitwidth, octave_value (), discard,
+                     type, num_elts);
 
   list.resize (dim_vector (num_elts, 1));
 
   delete buf;
 }
 
 textscan_format_list::~textscan_format_list (void)
 {
@@ -403,17 +414,17 @@ textscan_format_list::add_elt_to_list (u
             = new textscan_format_elt (text.c_str (), width, prec, bitwidth,
                                        discard, type, char_class);
 
           if (num_elts == list.numel ())
             {
               list.resize (dim_vector (2 * num_elts, 1));
             }
 
-          if (!discard)
+          if (! discard)
             {
               output_container.push_back (val_type);
             }
           list(num_elts++) = elt;
         }
 
       delete buf;
       buf = 0;
@@ -522,17 +533,17 @@ textscan_format_list::process_conversion
                     *buf << s[i++];
                   }
                 else
                   done = false;
               }
             else
               done = false;
 
-            if (!done)
+            if (! done)
               {
                 bitwidth = 32;
                 if (type == 'd')
                   val_type = octave_value (int32NDArray ());
                 else
                   val_type = octave_value (uint32NDArray ());
               }
             goto fini;
@@ -565,25 +576,25 @@ textscan_format_list::process_conversion
 
         case 'n':
           *buf << (type = s[i++]);
           bitwidth = 64;
           val_type = octave_value (NDArray ());
           goto fini;
 
         case 's': case 'q': case '[': case 'c':
-          if (!discard)
+          if (! discard)
             val_type = octave_value (Cell ());
           *buf << (type = s[i++]);
           has_string = true;
           goto fini;
 
         fini:
           {
-            if (!have_width)
+            if (! have_width)
               {
                 if (type == 'c')        // %c defaults to one character
                   width = 1;
                 else
                   width = static_cast<unsigned int> (-1); // others: unlimited
               }
 
             if (finish_conversion (s, i, n, width, prec, bitwidth, val_type,
@@ -664,39 +675,42 @@ textscan_char_class (const std::string& 
                   if (mask[i] == '\0')
                     {
                       mask[i] = '\1';
                       retval[out++] = i;
                     }
                 }
             }
         }
-      if (!was_range)
+      if (! was_range)
         {
           if (mask[ch]++ == 0)
             retval[out++] = ch;
           else if (ch != '-')
             warning_with_id ("octave:textscan-pattern",
                              "textscan: [...] contains two '%c's", ch);
+
           if (prev == '-' && mask['-'] >= 2)
             warning_with_id ("octave:textscan-pattern",
                              "textscan: [...] contains two '-'s "
                              "outside range expressions");
         }
       prev = ch;
       prev_prev_was_range = prev_was_range;
       prev_was_range = was_range;
     }
+
   if (flip)                             // [^...]
     {
       out = 0;
       for (int i = 0; i < 256; i++)
-        if (!mask[i])
+        if (! mask[i])
           retval[out++] = i;
     }
+
   retval.resize (out);
 
   return retval;
 }
 
 int
 textscan_format_list::finish_conversion (const std::string& s, size_t& i,
                                          size_t n, unsigned int& width,
@@ -796,33 +810,35 @@ textscan_format_list::printme (void) con
 // If FORMAT is explicitly "", it is assumed to be "%f" repeated enough
 // times to read the first row of the file.  Set it now.
 
 int
 textscan_format_list::read_first_row (dstr& is, textscan& ts)
 {
   // Read first line and strip end-of-line, which may be two characters
   std::string first_line (20, ' ');
+
   is.getline (first_line, static_cast<char> (ts.eol2));
+
   if (first_line.length () > 0
       && first_line[first_line.length () - 1] == ts.eol1)
     first_line.resize (first_line.length () - 1);
 
   std::istringstream strstr (first_line);
   dstr ds (strstr, is);
 
   dim_vector dv (1,1);      // initial size of each output_container
   Complex val;
   octave_value val_type;
   nconv = 0;
   int max_empty = 1000;     // failsafe, if ds fails but not with eof
   int retval = 0;
 
   // read line, creating output_container as we go
-  while (!ds.eof ())
+  while (! ds.eof ())
     {
       bool already_skipped_delim = false;
       ts.skip_whitespace (ds);
       ds.progress_benchmark ();
       bool progress = false;
       ts.scan_complex (ds, *list(0), val);
       if (ds.fail ())
         {
@@ -853,30 +869,37 @@ textscan_format_list::read_first_row (ds
               textscan_format_elt fe ("", first_line.length ());
               ts.scan_string (ds, fe, dummy);
 
               progress = (dummy.length ());
               ds.setstate (state);
             }
 
           val = ts.empty_value.scalar_value ();
-          if (!--max_empty)
+
+          if (! --max_empty)
             break;
         }
+
       if (val.imag () == 0)
         val_type = octave_value (NDArray (dv, val.real ()));
       else
         val_type = octave_value (ComplexNDArray (dv, val));
+
       output_container.push_back (val_type);
+
       if (! already_skipped_delim)
         ts.skip_delim (ds);
+
       if (! progress && ds.no_progress ())
         break;
+
       nconv++;
     }
+
   output_container.pop_front (); // discard empty element from constructor
 
   //Create  fmt  now that the size is known
   list.resize (dim_vector (nconv, 1));
   for (octave_idx_type i = 1; i < nconv; i++)
     list(i) = new textscan_format_elt (*list(0));
 
   return retval;             // May have returned 4 above.
@@ -885,20 +908,22 @@ textscan_format_list::read_first_row (ds
 // Perform actual textscan: read data from stream, and create cell array.
 
 octave_value
 textscan::scan (std::istream *isp, textscan_format_list& fmt_list,
                 octave_idx_type ntimes)
 {
   octave_value retval;
 
-  if (!isp)
+  if (! isp)
     error ("internal error: textscan called with invalid istream");
+
   if (fmt_list.num_conversions () == -1)
     error ("textscan: invalid format specified");
+
   if (fmt_list.num_conversions () == 0)
     error ("textscan: no valid format conversion specifiers\n");
 
   // skip the first  header_lines
   std::string dummy;
   for (int i = 0; i < header_lines && *isp; i++)
     getline (*isp, dummy, static_cast<char> (eol2));
 
@@ -940,17 +965,17 @@ textscan::scan (std::istream *isp, texts
 
   // If FORMAT explicitly "", read first line and see how many "%f" match
   if (fmt_list.set_from_first)
     {
       err = fmt_list.read_first_row (is, *this);
       lines = 1;
 
       done_after = fmt_list.numel () + 1;
-      if (!err)
+      if (! err)
         row = 1;  // the above puts the first line into fmt_list.out_buf ()
     }
   else
     done_after = fmt_list.out_buf ().size () + 1;
 
   std::list<octave_value> out = fmt_list.out_buf ();
 
   // We will later merge adjacent columns of the same type.
@@ -967,44 +992,48 @@ textscan::scan (std::istream *isp, texts
       for (std::list<octave_value>::iterator col = out.begin ();
            col != out.end (); col++)
         {
           if (col->type_id () == prev_type
               || (fmt_list.set_from_first && prev_type != -1))
             merge_with_prev [conv++] = true;
           else
             merge_with_prev [conv++] = false;
+
           prev_type = col->type_id ();
         }
     }
 
   // This should be caught by earlier code, but this avoids a possible
   // infinite loop below.
   if (fmt_list.num_conversions () == 0)
     error ("textscan: No conversions specified");
 
-
   // Read the data.  This is the main loop.
-  if (!err)
-    for (/* row set ~30 lines above */; row < ntimes || ntimes == -1; row++)
-      {
-        if (row == 0 || row >= size)
-          {
-            size += size+1;
-            for (std::list<octave_value>::iterator col = out.begin ();
-                 col != out.end (); col++)
-              *col = (*col).resize (dim_vector (size, 1), 0);
-          }
-        row_idx(0) = row;
-        err = read_format_once (is, fmt_list, out, row_idx, done_after);
-        if (err > 0 || !is || (lines >= ntimes && ntimes > -1))
-          break;
-      }
-
-  if ((err & 4) && !return_on_error)
+  if (! err)
+    {
+      for (/* row set ~30 lines above */; row < ntimes || ntimes == -1; row++)
+        {
+          if (row == 0 || row >= size)
+            {
+              size += size+1;
+              for (std::list<octave_value>::iterator col = out.begin ();
+                   col != out.end (); col++)
+                *col = (*col).resize (dim_vector (size, 1), 0);
+            }
+
+          row_idx(0) = row;
+          err = read_format_once (is, fmt_list, out, row_idx, done_after);
+
+          if (err > 0 || ! is || (lines >= ntimes && ntimes > -1))
+            break;
+        }
+    }
+
+  if ((err & 4) && ! return_on_error)
     error ("textscan: Read error in field %d of row %d",
            done_after + 1, row + 1);
 
   // If file does not end in EOL, do not pad columns with NaN.
   bool uneven_columns = false;
   if (isp->eof () || (err & 4))
     {
       isp->clear ();
@@ -1012,26 +1041,27 @@ textscan::scan (std::istream *isp, texts
       int last_char = isp->get ();
       isp->setstate (isp->eofbit);
       uneven_columns = (last_char != eol1 && last_char != eol2);
     }
 
   // convert return value to Cell array
   Array<octave_idx_type> ra_idx (dim_vector (1,2));
 
-          // (err & 1) means "error, and no columns read this row
-          // FIXME -- This may redundant now that done_after=0 says the same
+  // (err & 1) means "error, and no columns read this row
+  // FIXME -- This may redundant now that done_after=0 says the same
   if (err & 1)
     done_after = out.size () + 1;
+
   int valid_rows = (row == ntimes) ? ntimes : ((err & 1) ? row : row+1);
   dim_vector dv (valid_rows, 1);
 
   ra_idx(0) = 0;
   int i = 0;
-  if (!collect_output)
+  if (! collect_output)
     {
       retval = Cell (dim_vector (1, out.size ()));
       for (std::list<octave_value>::iterator col = out.begin ();
            col != out.end (); col++, i++)
         {
           // trim last columns if that was requested
           if (i == done_after && uneven_columns)
             dv = dim_vector (std::max (valid_rows - 1, 0), 1);
@@ -1047,17 +1077,17 @@ textscan::scan (std::istream *isp, texts
       octave_idx_type group_size = 0;     // columns in this cell
       int prev_type = -1;
 
       conv = 0;
       retval = Cell ();
       for (std::list<octave_value>::iterator col = out.begin ();
            col != out.end (); col++)
         {
-          if (!merge_with_prev [conv++])  // including first time
+          if (! merge_with_prev [conv++])  // including first time
             {
               if (prev_type != -1)
                 {
                   ra_idx(1) = i++;
                   retval = do_cat_op (retval, octave_value (Cell(cur)),
                                       ra_idx);
                 }
               cur = octave_value (col->resize (dv,0));
@@ -1069,16 +1099,17 @@ textscan::scan (std::istream *isp, texts
               ra_idx(1) = group_size++;
               cur = do_cat_op (cur, octave_value (col->resize (dv,0)),
                                ra_idx);
             }
         }
       ra_idx(1) = i;
       retval = do_cat_op (retval, octave_value (Cell (cur)), ra_idx);
     }
+
   return retval;
 }
 
 // Calculate x^n.  Used for ...e+nn  so that, for example, 1e2 is
 // exactly 100 and 5e-1 is 1/2
 
 static double
 pown (double x, unsigned int n)
@@ -1096,22 +1127,22 @@ pown (double x, unsigned int n)
 }
 
 // Read a double considering the "precision" field of  fmt  and the
 // exp_chars  option of  options.
 
 double
 textscan::read_double (dstr& is, const textscan_format_elt& fmt) const
 {
-  int    sign = 1;
-  unsigned int    width_left = fmt.width;
-  double retval  = 0;
-  bool   valid = false;         // syntactically correct double?
-
-  int    ch = is.peek ();
+  int sign = 1;
+  unsigned int width_left = fmt.width;
+  double retval = 0;
+  bool valid = false;         // syntactically correct double?
+
+  int ch = is.peek ();
 
   if (ch == '+')
     {
       is.get ();
       ch = is.peek ();
       if (width_left)
         width_left--;
     }
@@ -1128,54 +1159,57 @@ textscan::read_double (dstr& is, const t
   if (ch != '.')
     {
       if (ch >= '0' && ch <= '9')       // valid if at least one digit
         valid = true;
       while (width_left-- && is && (ch = is.get ()) >= '0' && ch <= '9')
         retval = retval * 10 + (ch - '0');
       width_left++;
     }
+
   // Read fractional part, up to specified precision
   if (ch == '.' && width_left)
     {
       double multiplier = 1;
       int precision = fmt.prec;
       int i;
 
       if (width_left)
         width_left--;                  // Consider width of '.'
 
       if (precision == -1)
         precision = 1<<30;           // FIXME Should be MAXINT
-      if (!valid)                    // if there was nothing before '.'...
+
+      if (! valid)                    // if there was nothing before '.'...
         is.get ();                   // ...ch was a "peek", not "get".
 
       for (i = 0; i < precision; i++)
         {
           if (width_left-- && is && (ch = is.get ()) >= '0' && ch <= '9')
             retval += (ch - '0') * (multiplier *= 0.1);
           else
             {
               width_left++;
               break;
             }
         }
 
       // round up if we truncated and the next digit is >= 5
-      if ((i == precision || !width_left) && (ch = is.get ()) >= '5'
-                                              && ch <= '9')
+      if ((i == precision || ! width_left) && (ch = is.get ()) >= '5'
+          && ch <= '9')
         retval += multiplier;
 
       if (i > 0)
         valid = true;           // valid if at least one digit after '.'
 
       // skip remainder after '.', to field width, to look for exponent
       if (i == precision)
         while (width_left-- && is && (ch = is.get ()) >= '0' && ch <= '9')
           ;  // discard
+
       width_left++;
     }
 
   // look for exponent part in, e.g.,  6.023E+23
   const char *ec = exp_chars.c_str ();
   bool used_exp = false;
   if (valid && width_left > 1 && strchr (ec, ch))
     {
@@ -1213,52 +1247,52 @@ textscan::read_double (dstr& is, const t
             retval *= multiplier;
           else
             retval /= multiplier;
 
           used_exp = true;
         }
     }
   is.clear ();
-  if (!used_exp && ch != EOF && width_left)
+  if (! used_exp && ch != EOF && width_left)
     is.putback (ch);
 
   // Check for +/- inf and NaN
-  if (!valid && width_left >= 3)
+  if (! valid && width_left >= 3)
     {
       int i = lookahead (is, inf_nan, 3, false);   // false -> case insensitive
       if (i == 0)
         {
           retval = octave_Inf;
           valid = true;
         }
       else if (i == 1)
         {
           retval = octave_NaN;
           valid = true;
         }
     }
 
   // Check for +/- inf and NaN
-  if (!valid && width_left >= 3)
+  if (! valid && width_left >= 3)
     {
       int i = lookahead (is, inf_nan, 3, false);   // false -> case insensitive
       if (i == 0)
         {
           retval = octave_Inf;
           valid = true;
         }
       else if (i == 1)
         {
           retval = octave_NaN;
           valid = true;
         }
     }
 
-  if (!valid)
+  if (! valid)
     is.setstate (std::ios::failbit);
   else
     is.setstate (is.rdstate () & ~std::ios::failbit);
 
   return retval * sign;
 }
 
 // Read a single number: real, complex, inf, NaN, possibly with limited
@@ -1305,17 +1339,17 @@ textscan::scan_complex (dstr& is, const 
             }
 
           im = (ch == '+') ? value : -value;
         }
       else
         is.putback (ch);
     }
 
-  if (!im && !inf)        // if not [+-][ij] or [+-]inf, read real normally
+  if (! im && ! inf)        // if not [+-][ij] or [+-]inf, read real normally
     {
       char *pos = is.tellg ();
       std::ios::iostate state = is.rdstate ();
       //re = octave_read_value<double> (is);
       re = read_double (is, fmt);
 
       // check for "treat as empty" string
       if (treat_as_empty.numel ()
@@ -1337,39 +1371,39 @@ textscan::scan_complex (dstr& is, const 
 
               is.clear (state);      // treat_as_empty "-" causes partial read
               is.seekg (pos);        // reset to position before failed read
 
               // treat_as_empty strings may be different sizes.
               // Read ahead longest, put it all back, then re-read the string
               // that matches.
               char *look, look_buf [treat_as_empty_len + 1];
-                // prefill, in case EOF means part-filled.
+              // prefill, in case EOF means part-filled.
               memset (look_buf, '\0', treat_as_empty_len);
               look = is.read (look_buf, treat_as_empty_len, pos);
 
               is.clear (state);
               is.seekg (pos);        // reset to position before look-ahead
                                      // FIXME -- is.read could invalidate pos
 
               for (int i = 0; i < treat_as_empty.numel (); i++)
                 {
                   std::string s = treat_as_empty (i).string_value ();
-                  if (!strncmp (s.c_str (), look, s.size ()))
+                  if (! strncmp (s.c_str (), look, s.size ()))
                     {
                       as_empty = true;
                                      // read just the right amount
                       is.read (look_buf, s.size (), pos);
                       break;
                     }
                 }
             }
         }
 
-      if (!is.eof () && !as_empty)
+      if (! is.eof () && ! as_empty)
         {
           state = is.rdstate ();        // before tellg, since that fails at EOF
           pos = is.tellg ();
           ch = is.peek ();   // ch == EOF if read failed; no need to chk fail
           if (ch == 'i' || ch == 'j')           // pure imaginary
             {
               is.get ();
               im = re;
@@ -1403,24 +1437,23 @@ textscan::scan_complex (dstr& is, const 
     val = empty_value.scalar_value ();
   else
     val = Complex (re, im);
 }
 
 // Return in VAL the run of characters from IS NOT contained in PATTERN. 
 
 int
-textscan::scan_caret (dstr& is, const char *pattern, std::string& val)
-          const
+textscan::scan_caret (dstr& is, const char *pattern, std::string& val) const
 {
   int c1 = EOF;
   std::ostringstream obuf;              // Is this optimised for growing?
 
-  while (is && (c1 = (is && !is.eof ()) ? is.get_undelim () : EOF) != EOF
-         && !strchr (pattern, c1))
+  while (is && (c1 = (is && ! is.eof ()) ? is.get_undelim () : EOF) != EOF
+         && ! strchr (pattern, c1))
     obuf << static_cast<char> (c1);
 
   val = obuf.str ();
 
   if (c1 != EOF)
     is.putback (c1);
 
   return c1;
@@ -1436,17 +1469,17 @@ textscan::read_until (dstr& is, const Ce
   std::string retval ("");
   bool done = false;
   do
     {                               // find sequence ending with an ending char
       std::string next;
       scan_caret (is, ends.c_str (), next);
       retval = retval + next;   // FIXME -- could use repeated doubling of size
 
-      int last = (!is.eof ()) ? is.get_undelim () : EOF;
+      int last = (! is.eof ()) ? is.get_undelim () : EOF;
       if (last != EOF)
         {
           retval = retval + static_cast<char> (last);
           for (int i = 0; i < delimiters.numel (); i++)
             {
               std::string delim = delimiters(i).string_value ();
               int start = retval.length () - delim.length ();
               if (start < 0)
@@ -1456,17 +1489,17 @@ textscan::read_until (dstr& is, const Ce
                 {
                   done = true;
                   retval = retval.substr (0, start);
                   break;
                 }
             }
         }
     }
-  while (!done && is && !is.eof ());
+  while (! done && is && ! is.eof ());
 
   return retval;
 }
 
 
 // Read stream until either fmt.width chars have been read, or
 // options.delimiter has been found.  Does *not* rely on fmt being 's'.
 // Used by formats like %6f to limit to 6.
@@ -1556,26 +1589,29 @@ textscan::scan_qstring (dstr& is, const 
 
 // Read from IS into VAL a string of the next fmt.width characters,
 // including any whitespace or delimiters.
 
 void
 textscan::scan_cstring (dstr& is, const textscan_format_elt& fmt,
                         std::string& val) const
 {
-  int ch;
   val.resize (fmt.width);
+
   for (unsigned int i = 0; is && i < fmt.width; i++)
-    if ((ch = is.get_undelim ()) != EOF)
-      val[i] = ch;
-    else
-      {
-        val.resize (i);
-        break;
-      }
+    {
+      int ch = is.get_undelim ();
+      if (ch != EOF)
+        val[i] = ch;
+      else
+        {
+          val.resize (i);
+          break;
+        }
+    }
 }
 
 
 //  Read a single '%...' conversion and place it in position ROW of OV.
 
 void
 textscan::scan_one (dstr& is, const textscan_format_elt& fmt,
                     octave_value& ov, Array<octave_idx_type> row)
@@ -1588,17 +1624,17 @@ textscan::scan_one (dstr& is, const text
   if (fmt.numeric)
     {
       if (fmt.type == 'f' || fmt.type == 'n')
         {
           Complex v;
           skip_whitespace (is);
           scan_complex (is, fmt, v);
 
-          if (!fmt.discard && !is.fail ())
+          if (! fmt.discard && ! is.fail ())
             {
               if (fmt.bitwidth == 64)
                 {
                   if (ov.is_real_type () && v.imag () == 0)
                     ov.internal_rep ()->fast_elem_insert (row(0), v.real ());
                   else
                     {
                       if (ov.is_real_type ())  // cat does type conversion
@@ -1625,82 +1661,88 @@ textscan::scan_one (dstr& is, const text
         }
       else
         {
           double v;    // Matlab docs say 1e30 etc should be valid for %d and
                        // 1000 as a %d8 should be 127, so read as double.
                        // Some loss of precision for d64 and u64.
           skip_whitespace (is);
           v = read_double (is, fmt);
-          if (!fmt.discard && !is.fail ())
+          if (! fmt.discard && ! is.fail ())
             switch (fmt.bitwidth)
               {
-                case 64:
-                  switch (fmt.type)
+              case 64:
+                switch (fmt.type)
+                  {
+                  case 'd':
                     {
-                      case 'd':
-                        {
-                          octave_int64 vv = v;
-                          ov.internal_rep ()->fast_elem_insert (row(0), vv);
-                        }
-                        break;
-                      case 'u':
-                        {
-                          octave_uint64 vv = v;
-                          ov.internal_rep ()->fast_elem_insert (row(0), vv);
-                        }
-                        break;
+                      octave_int64 vv = v;
+                      ov.internal_rep ()->fast_elem_insert (row(0), vv);
+                    }
+                    break;
+
+                  case 'u':
+                    {
+                      octave_uint64 vv = v;
+                      ov.internal_rep ()->fast_elem_insert (row(0), vv);
                     }
-                  break;
-                case 32:
-                  switch (fmt.type)
+                    break;
+                  }
+                break;
+
+              case 32:
+                switch (fmt.type)
+                  {
+                  case 'd':
                     {
-                      case 'd':
-                        {
-                          octave_int32 vv = v;
-                          ov.internal_rep ()->fast_elem_insert (row(0), vv);
-                        }
-                        break;
-                      case 'u':
-                        {
-                          octave_uint32 vv = v;
-                          ov.internal_rep ()->fast_elem_insert (row(0), vv);
-                        }
-                        break;
+                      octave_int32 vv = v;
+                      ov.internal_rep ()->fast_elem_insert (row(0), vv);
                     }
-                  break;
-                case 16:
-                  if (fmt.type == 'd')
+                    break;
+
+                  case 'u':
                     {
-                      octave_int16 vv = v;
+                      octave_uint32 vv = v;
                       ov.internal_rep ()->fast_elem_insert (row(0), vv);
                     }
-                  else
-                    {
-                      octave_uint16 vv = v;
-                      ov.internal_rep ()->fast_elem_insert (row(0), vv);
-                    }
-                  break;
-                case 8:
-                  if (fmt.type == 'd')
-                    {
-                      octave_int8 vv = v;
-                      ov.internal_rep ()->fast_elem_insert (row(0), vv);
-                    }
-                  else
-                    {
-                      octave_uint8 vv = v;
-                      ov.internal_rep ()->fast_elem_insert (row(0), vv);
-                    }
-                  break;
+                    break;
+                  }
+                break;
+
+              case 16:
+                if (fmt.type == 'd')
+                  {
+                    octave_int16 vv = v;
+                    ov.internal_rep ()->fast_elem_insert (row(0), vv);
+                  }
+                else
+                  {
+                    octave_uint16 vv = v;
+                    ov.internal_rep ()->fast_elem_insert (row(0), vv);
+                  }
+                break;
+
+              case 8:
+                if (fmt.type == 'd')
+                  {
+                    octave_int8 vv = v;
+                    ov.internal_rep ()->fast_elem_insert (row(0), vv);
+                  }
+                else
+                  {
+                    octave_uint8 vv = v;
+                    ov.internal_rep ()->fast_elem_insert (row(0), vv);
+                  }
+                break;
               }
         }
+
       if (is.fail ())
         {
-          if (!fmt.discard)
+          if (! fmt.discard)
             ov = do_cat_op (ov, empty_value, row);
 
           // If we are continuing after errors, skip over this field
           if (return_on_error == 2)
             {
               std::ios::iostate state = is.rdstate ();
               is.clear ();          // clear to allow read pointer to advance
 
@@ -1712,39 +1754,46 @@ textscan::scan_one (dstr& is, const text
         }
 
     }
   else
     {
       std::string vv ("        ");      // initial buffer.  Grows as needed
       switch (fmt.type)
         {
-          case 's':
-            scan_string (is, fmt, vv);
-            break;
-          case 'q':
-            scan_qstring (is, fmt, vv);
-            break;
-          case 'c':
-            scan_cstring (is, fmt, vv);
-            break;
-          case '[':
-            scan_bracket (is, fmt.char_class.c_str (), vv);
-            break;
-          case '^':
-            scan_caret   (is, fmt.char_class.c_str (), vv);
-            break;
+        case 's':
+          scan_string (is, fmt, vv);
+          break;
+
+        case 'q':
+          scan_qstring (is, fmt, vv);
+          break;
+
+        case 'c':
+          scan_cstring (is, fmt, vv);
+          break;
+
+        case '[':
+          scan_bracket (is, fmt.char_class.c_str (), vv);
+          break;
+
+        case '^':
+          scan_caret   (is, fmt.char_class.c_str (), vv);
+          break;
         }
-      if (!fmt.discard)
+
+      if (! fmt.discard)
         ov.internal_rep ()->fast_elem_insert (row (0),
                                               Cell (octave_value (vv)));
-        // FIXME -- why does failbit get set at EOF, instead of eofbit?
+
+      // FIXME -- why does failbit get set at EOF, instead of eofbit?
       if (vv.length () != 0)
         is.clear (is.rdstate () & ~std::ios_base::failbit);
     }
+
   is.field_done ();
 }
 
 // Read data corresponding to the entire format string once, placing the
 // values in row ROW of retval. 
 
 int
 textscan::read_format_once (dstr& is, textscan_format_list& fmt_list,
@@ -1789,30 +1838,30 @@ textscan::read_format_once (dstr& is, te
         case textscan_format_elt::literal_conversion :
           match_literal (is, *elem);
           break;
 
         default:
           error ("Unknown format element '%c'", elem->type);
         }
 
-      if (!is.fail ())
+      if (! is.fail ())
         {
-          if (!elem->discard)
+          if (! elem->discard)
             no_conversions = false;
         }
       else
         {
           if (return_on_error < 2)
             this_conversion_failed = true;
 
           is.clear (is.rdstate () & ~std::ios::failbit);
         }
 
-      if (!elem->discard)
+      if (! elem->discard)
         out++;
 
       elem = fmt_list.next ();
       char *pos = is.tellg ();
 
       // FIXME -- these conversions "ignore delimiters".  Should they include
       // delimiters at the start of the conversion, or can those be skipped?
       if (elem->type != textscan_format_elt::literal_conversion
@@ -1828,17 +1877,17 @@ textscan::read_format_once (dstr& is, te
               conversion_failed = true;
             }
           else
             this_conversion_failed = false;
         }
 
       if (is.eof ())
         {
-          if (!done)
+          if (! done)
             done_after = i+1;
 
           // note EOF, but process others to get empty_val.
           done = true;
         }
     }
 
   if (done)
@@ -1863,17 +1912,17 @@ textscan::parse_options (const octave_va
 
   if (n & 1)
     error ("textscan: %d parameters given, but only %d values", n-n/2, n/2);
 
   delim_len = 1;
   bool have_delims = false;
   for (int i = first_param; i < last; i += 2)
     {
-      if (!args(i).is_string ())
+      if (! args(i).is_string ())
         error ("textscan: Invalid paramter type <%s> for parameter %d",
                args(i).type_name ().c_str (), (i-first_param)/2 + 1);
 
       std::string param = args(i).string_value ();
       std::transform (param.begin (), param.end (),
                       param.begin (), ::tolower);
       if (param == "delimiter")
         {
@@ -1888,17 +1937,17 @@ textscan::parse_options (const octave_va
             {
               invalid = false;
               delim_list = args(i+1).cell_value ();
               delim_table = " "; // non-empty, to flag non-default delim
 
               // Check that all elements are strings, and find max length
               for (int j = 0; j < delim_list.numel (); j++)
                 {
-                  if (!delim_list(j).is_string ())
+                  if (! delim_list(j).is_string ())
                     invalid = true;
                   else
                     {
                       octave_idx_type len = delim_list(j).string_value ()
                                                          .length ();
                       delim_len = std::max (static_cast<int>(len), delim_len);
                     }
                 }
@@ -1912,18 +1961,18 @@ textscan::parse_options (const octave_va
           if (args(i+1).is_string ())
             {   // check here for names like "C++", "C", "shell", ...?
               comment_style = Cell (args(i+1));
             }
           else if (args(i+1).is_cell ())
             {
               comment_style = args(i+1).cell_value ();
               int len = comment_style.numel ();
-              if ((len >= 1 && !comment_style (0).is_string ())
-                  || (len >= 2 && !comment_style (1).is_string ())
+              if ((len >= 1 && ! comment_style (0).is_string ())
+                  || (len >= 2 && ! comment_style (1).is_string ())
                   || (len >= 3))
                 error ("textscan: CommentStyle must be either a string or "
                        "cell array of one or two strings");
             }
           else
             error ("textscan:  CommentStyle must be either a string"
                    " or cell array of one or two strings, not <%s>",
                    args(i+1).class_name ().c_str ());
@@ -1943,17 +1992,17 @@ textscan::parse_options (const octave_va
             {
               treat_as_empty = Cell (args(i+1));
               treat_as_empty_len = args(i+1).string_value ().size ();
             }
           else if (args(i+1).is_cell ())
             {
               treat_as_empty = args(i+1).cell_value ();
               for (int j = 0; j < treat_as_empty.numel (); j++)
-                if (!treat_as_empty (j).is_string ())
+                if (! treat_as_empty (j).is_string ())
                   invalid = true;
                 else
                   {
                     int k = treat_as_empty (j).string_value ().size ();
                     if (k > treat_as_empty_len)
                       treat_as_empty_len = k;
                   }
             }
@@ -2050,17 +2099,17 @@ textscan::parse_options (const octave_va
                   if (eol1 != '\r' || eol2 != '\n')    // Why limit it?
                     valid = false;
                 }
               else
                 valid = false;
             }
           else
             valid = false;
-          if (!valid)
+          if (! valid)
             error ("textscan: EndOfLine must be at most one character "
                    "or '\\r\\n'");
         }
       else
         error ("textscan: Unrecognised option '%s'", param.c_str ());
     }
 
   whitespace_table = std::string (256, '\0');
@@ -2073,17 +2122,17 @@ textscan::parse_options (const octave_va
     whitespace_table[' '] = '1';
 
   // Create look-up table of delimiters, based on 'delimiter'
   delim_table = std::string (256, '\0');
   if (eol1 >= 0 && eol1 < 256)
     delim_table[eol1] = '1';        // EOL is always a delimiter
   if (eol2 >= 0 && eol2 < 256)
     delim_table[eol2] = '1';        // EOL is always a delimiter
-  if (!have_delims)
+  if (! have_delims)
     for (unsigned int i = 0; i < 256; i++)
       {
         if (isspace (i))
           delim_table[i] = '1';
       }
   else
     for (unsigned int i = 0; i < delims.length (); i++)
       delim_table[delims[i]] = '1';
@@ -2098,34 +2147,34 @@ textscan::skip_whitespace (dstr& is, boo
   int c1 = EOF;
   bool found_comment = false;
 
   do
     {
       found_comment = false;
       int prev = -1;
       while (is && (c1 = is.get_undelim ()) != EOF
-             && ( ( (c1 == eol1 || c1 == eol2) && ++lines && !EOLstop)
+             && ( ( (c1 == eol1 || c1 == eol2) && ++lines && ! EOLstop)
                   || isspace (c1)))
         {
           if (prev == eol1 && eol1 != eol2 && c1 == eol2)
             lines--;
           prev = c1;
         }
 
       if (c1 == comment_char)           // see if we match an open comment
         {
           // save stream state in case we have to restore it
           char *pos   = is.tellg ();
           std::ios::iostate state = is.rdstate ();
 
           char *look, tmp [comment_len];
           look = is.read (tmp, comment_len-1, pos);   // already read first char
-          if (is && !strncmp (comment_style(0).string_value ().substr (1)
-                              .c_str (), look, comment_len-1))
+          if (is && ! strncmp (comment_style(0).string_value ().substr (1)
+                               .c_str (), look, comment_len-1))
             {
               found_comment = true;
 
               std::string dummy;
               char eol [3] = {static_cast<char> (eol1),
                               static_cast<char> (eol2),
                               '\0'};
               if (comment_style.numel () == 1)  // skip to end of line
@@ -2149,17 +2198,17 @@ textscan::skip_whitespace (dstr& is, boo
                       is.get_undelim ();        // (read   last  itself)
 
                       may_match = may_match + dummy + *last;
                       int start = may_match.length () - end_c.length ();
                       if (start < 0)
                         start = 0;
                       may_match = may_match.substr (start);
                     }
-                  while (may_match != end_c && is && !is.eof ());
+                  while (may_match != end_c && is && ! is.eof ());
                 }
             }
           else  // wasn't really a comment; restore state
             {
               is.clear (state);
               is.seekg (pos);
             }
         }
@@ -2196,17 +2245,17 @@ textscan::lookahead (dstr& is, const Cel
 
   int i;
   int (*compare)(const char *, const char *, size_t);
   compare = case_sensitive ? strncmp : strncasecmp;
 
   for (i = 0; i < targets.numel (); i++)
     {
       std::string s = targets (i).string_value ();
-      if (!(*compare) (s.c_str (), look, s.size ()))
+      if (! (*compare) (s.c_str (), look, s.size ()))
         {
           is.read (tmp, s.size (), pos); // read just the right amount
           break;
         }
     }
 
   if (i == targets.numel ())
     i = -1;
@@ -2601,35 +2650,39 @@ from the beginning of the file or string
 
   if (args.length () < 1)
     print_usage ();
   else if (args.length () == 1)
     format = "%f";      // ommited format = %f.  explicit "" = width from file
   else if (args(1).is_string ())
     {
       format = args(1).string_value ();
+
       if (args(1).is_sq_string ())
         format = do_string_escapes (format);
+
       params++;
     }
   else
     error ("textscan: FORMAT must be a string, not <%s>",
            args(1).class_name ().c_str ());
 
   octave_idx_type ntimes = -1;
   textscan tscanner;
 
   if (args.length () >= 3)
     {
       if (args(2).is_numeric_type ())
         {
           ntimes = args(2).idx_type_value ();
+
           if (ntimes < args(2).double_value ())
             error ("textscan: REPEAT = %g is too large",
                    args(2).double_value ());
+
           params = 3;
         }
     }
   textscan_format_list fmt_list (format);
 
   tscanner.parse_options (args, params, fmt_list);
 
   if (args(0).is_string ())
