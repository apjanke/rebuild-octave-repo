# HG changeset patch
# User Rik <octave@nomad.inbox5.com>
# Date 1324489486 28800
#      Wed Dec 21 09:44:46 2011 -0800
# Branch stable
# Node ID 4e8f23ccadcecf3a26188b26272a2466e8411e5f
# Parent  5aba9fa234cf5e4a311013cc51fe1e3482f408b2
test: Use internal prefix "__" for %!functions to avoid polluting workspace
symbol table until bug #34497 has been resolved.

* cellfun.cc, dassl.cc, lsode.cc, qr.cc, quad.cc, data.cc, ov-fcn-handle.cc,
pt-fcn-handle.cc: Use internal prefix "__" for %!functions to avoid polluting
workspace symbol table until bug #34497 has been resolved.

diff --git a/src/DLD-FUNCTIONS/cellfun.cc b/src/DLD-FUNCTIONS/cellfun.cc
--- a/src/DLD-FUNCTIONS/cellfun.cc
+++ b/src/DLD-FUNCTIONS/cellfun.cc
@@ -691,59 +691,59 @@ cellfun (\"factorial\", @{-1,2@}, 'Error
   else
     error ("cellfun: argument NAME must be a string or function handle");
 
   return retval;
 }
 
 /*
 
-%!function r = f11 (x)
+%!function r = __f11 (x)
 %!  global __cellfun_test_num_outputs__
 %!  __cellfun_test_num_outputs__ = nargout;
 %!  r = x;
-%! endfunction
+%!endfunction
 
-%!function f01 (x)
+%!function __f01 (x)
 %!  global __cellfun_test_num_outputs__
 %!  __cellfun_test_num_outputs__ = nargout;
-%! endfunction
+%!endfunction
 
 %!test
 %! global __cellfun_test_num_outputs__
-%! cellfun (@f11, {1});
+%! cellfun (@__f11, {1});
 %! assert (__cellfun_test_num_outputs__, 0)
-%! x = cellfun (@f11, {1});
+%! x = cellfun (@__f11, {1});
 %! assert (__cellfun_test_num_outputs__, 1)
 
 %!test
 %! global __cellfun_test_num_outputs__
-%! cellfun (@f01, {1});
+%! cellfun (@__f01, {1});
 %! assert (__cellfun_test_num_outputs__, 0)
 
-%!error x = cellfun (@f01, {1, 2});
+%!error x = cellfun (@__f01, {1, 2});
 
 %!test
-%! assert (cellfun (@f11, {1, 2}), [1, 2])
-%! assert (cellfun (@f11, {1, 2}, 'uniformoutput', false), {1, 2})
+%! assert (cellfun (@__f11, {1, 2}), [1, 2])
+%! assert (cellfun (@__f11, {1, 2}, 'uniformoutput', false), {1, 2})
 
 %!test
 %!  [a,b] = cellfun (@(x) x, cell (2, 0));
 %!  assert (a, zeros (2, 0));
 %!  assert (b, zeros (2, 0));
 
 %!test
 %!  [a,b] = cellfun (@(x) x, cell (2, 0), "uniformoutput", false);
 %!  assert (a, cell (2, 0));
 %!  assert (b, cell (2, 0));
 
 %% Test function to check the "Errorhandler" option
-%!function [z] = cellfunerror (S, varargin)
-%!    z = S;
-%!  endfunction
+%!function [z] = __cellfunerror (S, varargin)
+%!  z = S;
+%!endfunction
 
 %% First input argument can be a string, an inline function,
 %% a function_handle or an anonymous function
 %!test
 %!  A = cellfun ("islogical", {true, 0.1, false, i*2});
 %!  assert (A, [true, false, true, false]);
 %!test
 %!  A = cellfun (inline ("islogical (x)", "x"), {true, 0.1, false, i*2});
@@ -810,25 +810,25 @@ cellfun (\"factorial\", @{-1,2@}, 'Error
 %!test %% Three ouptut arguments of same type
 %!  [A, B, C] = cellfun (@find, {true, false; false, true}, \
 %!    "UniformOutput", false);
 %!  assert (isequal (A, {true, []; [], true}));
 %!  assert (isequal (B, {true, []; [], true}));
 %!  assert (isequal (C, {true, []; [], true}));
 %!test
 %!  A = cellfun (@(x,y) cell2str (x,y), {true}, {true}, \
-%!    "ErrorHandler", @cellfunerror);
+%!    "ErrorHandler", @__cellfunerror);
 %!  assert (isfield (A, "identifier"), true);
 %!  assert (isfield (A, "message"), true);
 %!  assert (isfield (A, "index"), true);
 %!  assert (isempty (A.message), false);
 %!  assert (A.index, 1);
 %!test %% Overwriting setting of "UniformOutput" true
 %!  A = cellfun (@(x,y) cell2str (x,y), {true}, {true}, \
-%!    "UniformOutput", true, "ErrorHandler", @cellfunerror);
+%!    "UniformOutput", true, "ErrorHandler", @__cellfunerror);
 %!  assert (isfield (A, "identifier"), true);
 %!  assert (isfield (A, "message"), true);
 %!  assert (isfield (A, "index"), true);
 %!  assert (isempty (A.message), false);
 %!  assert (A.index, 1);
 
 %% Input arguments can be of type cell array of numeric
 %!test
@@ -844,26 +844,26 @@ cellfun (\"factorial\", @{-1,2@}, 'Error
 %!  assert (isequal (A{2}, [4, 5, 6]));
 %!test %% Three ouptut arguments of different type
 %!  [A, B, C] = cellfun (@find, {10, 11; 0, 12}, "UniformOutput", false);
 %!  assert (isequal (A, {true, true; [], true}));
 %!  assert (isequal (B, {true, true; [], true}));
 %!  assert (isequal (C, {10, 11; [], 12}));
 %!test
 %!  A = cellfun (@(x,y) cell2str(x,y), {1.1, 4}, {3.1, 6}, \
-%!    "ErrorHandler", @cellfunerror);
+%!    "ErrorHandler", @__cellfunerror);
 %!  B = isfield (A(1), "message") && isfield (A(1), "index");
 %!  assert ([(isfield (A(1), "identifier")), (isfield (A(2), "identifier"))], [true, true]);
 %!  assert ([(isfield (A(1), "message")), (isfield (A(2), "message"))], [true, true]);
 %!  assert ([(isfield (A(1), "index")), (isfield (A(2), "index"))], [true, true]);
 %!  assert ([(isempty (A(1).message)), (isempty (A(2).message))], [false, false]);
 %!  assert ([A(1).index, A(2).index], [1, 2]);
 %!test %% Overwriting setting of "UniformOutput" true
 %!  A = cellfun (@(x,y) cell2str(x,y), {1.1, 4}, {3.1, 6}, \
-%!    "UniformOutput", true, "ErrorHandler", @cellfunerror);
+%!    "UniformOutput", true, "ErrorHandler", @__cellfunerror);
 %!  B = isfield (A(1), "message") && isfield (A(1), "index");
 %!  assert ([(isfield (A(1), "identifier")), (isfield (A(2), "identifier"))], [true, true]);
 %!  assert ([(isfield (A(1), "message")), (isfield (A(2), "message"))], [true, true]);
 %!  assert ([(isfield (A(1), "index")), (isfield (A(2), "index"))], [true, true]);
 %!  assert ([(isempty (A(1).message)), (isempty (A(2).message))], [false, false]);
 %!  assert ([A(1).index, A(2).index], [1, 2]);
 
 %% Input arguments can be of type cell arrays of character or strings
@@ -872,25 +872,25 @@ cellfun (\"factorial\", @{-1,2@}, 'Error
 %!test
 %!  A = cellfun (@(x,y) x>y, {"a"; "f"}, {"c"; "d"}, "UniformOutput", true);
 %!  assert (A, [false; true]);
 %!test
 %!  A = cellfun (@(x,y) x:y, {"a", "d"}, {"c", "f"}, "UniformOutput", false);
 %!  assert (A, {"abc", "def"});
 %!test
 %!  A = cellfun (@(x,y) cell2str(x,y), {"a", "d"}, {"c", "f"}, \
-%!    "ErrorHandler", @cellfunerror);
+%!    "ErrorHandler", @__cellfunerror);
 %!  assert ([(isfield (A(1), "identifier")), (isfield (A(2), "identifier"))], [true, true]);
 %!  assert ([(isfield (A(1), "message")), (isfield (A(2), "message"))], [true, true]);
 %!  assert ([(isfield (A(1), "index")), (isfield (A(2), "index"))], [true, true]);
 %!  assert ([(isempty (A(1).message)), (isempty (A(2).message))], [false, false]);
 %!  assert ([A(1).index, A(2).index], [1, 2]);
 %!test %% Overwriting setting of "UniformOutput" true
 %!  A = cellfun (@(x,y) cell2str(x,y), {"a", "d"}, {"c", "f"}, \
-%!    "UniformOutput", true, "ErrorHandler", @cellfunerror);
+%!    "UniformOutput", true, "ErrorHandler", @__cellfunerror);
 %!  assert ([(isfield (A(1), "identifier")), (isfield (A(2), "identifier"))], [true, true]);
 %!  assert ([(isfield (A(1), "message")), (isfield (A(2), "message"))], [true, true]);
 %!  assert ([(isfield (A(1), "index")), (isfield (A(2), "index"))], [true, true]);
 %!  assert ([(isempty (A(1).message)), (isempty (A(2).message))], [false, false]);
 %!  assert ([A(1).index, A(2).index], [1, 2]);
 
 %% Structures cannot be handled by cellfun
 %!error
@@ -906,25 +906,25 @@ cellfun (\"factorial\", @{-1,2@}, 'Error
 %!    "UniformOutput", true);
 %!  assert (A, [1; 0], 1e-16);
 %!test
 %!  A = cellfun (@(x,y) x{1} < y{1}, {{1.1}, {4.2}}, {{3.1}, {2}}, \
 %!    "UniformOutput", false);
 %!  assert (A, {true, false});
 %!test
 %!  A = cellfun (@(x,y) mat2str(x,y), {{1.1}, {4.2}}, {{3.1}, {2}}, \
-%!    "ErrorHandler", @cellfunerror);
+%!    "ErrorHandler", @__cellfunerror);
 %!  assert ([(isfield (A(1), "identifier")), (isfield (A(2), "identifier"))], [true, true]);
 %!  assert ([(isfield (A(1), "message")), (isfield (A(2), "message"))], [true, true]);
 %!  assert ([(isfield (A(1), "index")), (isfield (A(2), "index"))], [true, true]);
 %!  assert ([(isempty (A(1).message)), (isempty (A(2).message))], [false, false]);
 %!  assert ([A(1).index, A(2).index], [1, 2]);
 %!test %% Overwriting setting of "UniformOutput" true
 %!  A = cellfun (@(x,y) mat2str(x,y), {{1.1}, {4.2}}, {{3.1}, {2}}, \
-%!    "UniformOutput", true, "ErrorHandler", @cellfunerror);
+%!    "UniformOutput", true, "ErrorHandler", @__cellfunerror);
 %!  assert ([(isfield (A(1), "identifier")), (isfield (A(2), "identifier"))], [true, true]);
 %!  assert ([(isfield (A(1), "message")), (isfield (A(2), "message"))], [true, true]);
 %!  assert ([(isfield (A(1), "index")), (isfield (A(2), "index"))], [true, true]);
 %!  assert ([(isempty (A(1).message)), (isempty (A(2).message))], [false, false]);
 %!  assert ([A(1).index, A(2).index], [1, 2]);
 
 %% Input arguments can be of type cell array of structure arrays
 %!test
@@ -939,26 +939,26 @@ cellfun (\"factorial\", @{-1,2@}, 'Error
 %!test
 %!  a = struct ("a", 1, "b", 2); b = struct ("a", 1, "b", 3);
 %!  A = cellfun (@(x,y) (x.a == y.a) && (x.b < y.b) , {a}, {b}, \
 %!    "UniformOutput", false);
 %!  assert (A, {true});
 %!test
 %!  a = struct ("a", 1, "b", 2); b = struct ("a", 1, "b", 3);
 %!  A = cellfun (@(x,y) cell2str (x.a, y.a), {a}, {b}, \
-%!    "ErrorHandler", @cellfunerror);
+%!    "ErrorHandler", @__cellfunerror);
 %!  assert (isfield (A, "identifier"), true);
 %!  assert (isfield (A, "message"), true);
 %!  assert (isfield (A, "index"), true);
 %!  assert (isempty (A.message), false);
 %!  assert (A.index, 1);
 %!test %% Overwriting setting of "UniformOutput" true
 %!  a = struct ("a", 1, "b", 2); b = struct ("a", 1, "b", 3);
 %!  A = cellfun (@(x,y) cell2str (x.a, y.a), {a}, {b}, \
-%!    "UniformOutput", true, "ErrorHandler", @cellfunerror);
+%!    "UniformOutput", true, "ErrorHandler", @__cellfunerror);
 %!  assert (isfield (A, "identifier"), true);
 %!  assert (isfield (A, "message"), true);
 %!  assert (isfield (A, "index"), true);
 %!  assert (isempty (A.message), false);
 %!  assert (A.index, 1);
 
 %% A lot of other tests
 %!error(cellfun(1))
@@ -1415,53 +1415,53 @@ arrayfun (@@str2num, [1234], \\n\
     }
   else
     error ("arrayfun: argument NAME must be a string or function handle");
 
   return retval;
 }
 
 /*
-%!function r = f11 (x)
+%!function r = __f11 (x)
 %!  global __arrayfun_test_num_outputs__
 %!  __arrayfun_test_num_outputs__ = nargout;
 %!  r = x;
-%! endfunction
+%!endfunction
 
-%!function f01 (x)
+%!function __f01 (x)
 %!  global __arrayfun_test_num_outputs__
 %!  __arrayfun_test_num_outputs__ = nargout;
-%! endfunction
+%!endfunction
 
 %!test
 %! global __arrayfun_test_num_outputs__
-%! arrayfun (@f11, {1});
+%! arrayfun (@__f11, {1});
 %! assert (__arrayfun_test_num_outputs__, 0)
-%! x = arrayfun (@f11, {1});
+%! x = arrayfun (@__f11, {1});
 %! assert (__arrayfun_test_num_outputs__, 1)
 
 %!test
 %! global __arrayfun_test_num_outputs__
-%! arrayfun (@f01, {1});
+%! arrayfun (@__f01, {1});
 %! assert (__arrayfun_test_num_outputs__, 0)
 
-%!error x = arrayfun (@f01, [1, 2]);
+%!error x = arrayfun (@__f01, [1, 2]);
 
 %!test
-%! assert (arrayfun (@f11, [1, 2]), [1, 2])
-%! assert (arrayfun (@f11, [1, 2], 'uniformoutput', false), {1, 2});
-%! assert (arrayfun (@f11, {1, 2}), {1, 2})
-%! assert (arrayfun (@f11, {1, 2}, 'uniformoutput', false), {{1}, {2}});
+%! assert (arrayfun (@__f11, [1, 2]), [1, 2])
+%! assert (arrayfun (@__f11, [1, 2], 'uniformoutput', false), {1, 2});
+%! assert (arrayfun (@__f11, {1, 2}), {1, 2})
+%! assert (arrayfun (@__f11, {1, 2}, 'uniformoutput', false), {{1}, {2}});
 
 %!assert (arrayfun (@ones, 1, [2,3], 'uniformoutput', false), {[1,1], [1,1,1]});
 
 %% Test function to check the "Errorhandler" option
-%!function [z] = arrayfunerror (S, varargin)
+%!function [z] = __arrayfunerror (S, varargin)
 %!      z = S;
-%!    endfunction
+%!endfunction
 %% First input argument can be a string, an inline function, a
 %% function_handle or an anonymous function
 %!test
 %!  arrayfun (@isequal, [false, true], [true, true]); %% No output argument
 %!error
 %!  arrayfun (@isequal); %% One or less input arguments
 %!test
 %!  A = arrayfun ("isequal", [false, true], [true, true]);
@@ -1506,25 +1506,25 @@ arrayfun (@@str2num, [1234], \\n\
 %!  A = arrayfun (@(x) x, [false, true, false, true], "UniformOutput", false);
 %!  assert (A, {false, true, false, true});
 %!test %% Three ouptut arguments of same type
 %!  [A, B, C] = arrayfun (@find, [true, false; false, true], "UniformOutput", false);
 %!  assert (isequal (A, {true, []; [], true}));
 %!  assert (isequal (B, {true, []; [], true}));
 %!  assert (isequal (C, {true, []; [], true}));
 %!test
-%!  A = arrayfun (@(x,y) array2str (x,y), true, true, "ErrorHandler", @arrayfunerror);
+%!  A = arrayfun (@(x,y) array2str (x,y), true, true, "ErrorHandler", @__arrayfunerror);
 %!  assert (isfield (A, "identifier"), true);
 %!  assert (isfield (A, "message"), true);
 %!  assert (isfield (A, "index"), true);
 %!  assert (isempty (A.message), false);
 %!  assert (A.index, 1);
 %!test %% Overwriting setting of "UniformOutput" true
 %!  A = arrayfun (@(x,y) array2str (x,y), true, true, \
-%!                "UniformOutput", true, "ErrorHandler", @arrayfunerror);
+%!                "UniformOutput", true, "ErrorHandler", @__arrayfunerror);
 %!  assert (isfield (A, "identifier"), true);
 %!  assert (isfield (A, "message"), true);
 %!  assert (isfield (A, "index"), true);
 %!  assert (isempty (A.message), false);
 %!  assert (A.index, 1);
 
 %% Input arguments can be of type numeric
 %!test
@@ -1538,26 +1538,26 @@ arrayfun (@@str2num, [1234], \\n\
 %!  assert (isequal (A{1}, [1.1, 2.1, 3.1]));
 %!  assert (isequal (A{2}, [4, 5, 6]));
 %!test %% Three ouptut arguments of different type
 %!  [A, B, C] = arrayfun (@find, [10, 11; 0, 12], "UniformOutput", false);
 %!  assert (isequal (A, {true, true; [], true}));
 %!  assert (isequal (B, {true, true; [], true}));
 %!  assert (isequal (C, {10, 11; [], 12}));
 %!test
-%!  A = arrayfun (@(x,y) array2str(x,y), {1.1, 4}, {3.1, 6}, "ErrorHandler", @arrayfunerror);
+%!  A = arrayfun (@(x,y) array2str(x,y), {1.1, 4}, {3.1, 6}, "ErrorHandler", @__arrayfunerror);
 %!  B = isfield (A(1), "message") && isfield (A(1), "index");
 %!  assert ([(isfield (A(1), "identifier")), (isfield (A(2), "identifier"))], [true, true]);
 %!  assert ([(isfield (A(1), "message")), (isfield (A(2), "message"))], [true, true]);
 %!  assert ([(isfield (A(1), "index")), (isfield (A(2), "index"))], [true, true]);
 %!  assert ([(isempty (A(1).message)), (isempty (A(2).message))], [false, false]);
 %!  assert ([A(1).index, A(2).index], [1, 2]);
 %!test %% Overwriting setting of "UniformOutput" true
 %!  A = arrayfun (@(x,y) array2str(x,y), {1.1, 4}, {3.1, 6}, \
-%!                "UniformOutput", true, "ErrorHandler", @arrayfunerror);
+%!                "UniformOutput", true, "ErrorHandler", @__arrayfunerror);
 %!  B = isfield (A(1), "message") && isfield (A(1), "index");
 %!  assert ([(isfield (A(1), "identifier")), (isfield (A(2), "identifier"))], [true, true]);
 %!  assert ([(isfield (A(1), "message")), (isfield (A(2), "message"))], [true, true]);
 %!  assert ([(isfield (A(1), "index")), (isfield (A(2), "index"))], [true, true]);
 %!  assert ([(isempty (A(1).message)), (isempty (A(2).message))], [false, false]);
 %!  assert ([A(1).index, A(2).index], [1, 2]);
 
 %% Input arguments can be of type character or strings
@@ -1566,17 +1566,17 @@ arrayfun (@@str2num, [1234], \\n\
 %!  assert (A, [false, true, false, true, true, true]);
 %!test
 %!  A = arrayfun (@(x,y) x>y, ["a"; "f"], ["c"; "d"], "UniformOutput", true);
 %!  assert (A, [false; true]);
 %!test
 %!  A = arrayfun (@(x,y) x:y, ["a", "d"], ["c", "f"], "UniformOutput", false);
 %!  assert (A, {"abc", "def"});
 %! %#!test
-%!   A = arrayfun (@(x,y) cell2str(x,y), ["a", "d"], ["c", "f"], "ErrorHandler", @arrayfunerror);
+%!   A = arrayfun (@(x,y) cell2str(x,y), ["a", "d"], ["c", "f"], "ErrorHandler", @__arrayfunerror);
 %!   B = isfield (A(1), "identifier") && isfield (A(1), "message") && isfield (A(1), "index");
 %!   assert (B, true);
 
 %% Input arguments can be of type structure
 %!test
 %!  a = struct ("a", 1.1, "b", 4.2); b = struct ("a", 3.1, "b", 2);
 %!  A = arrayfun (@(x,y) (x.a < y.a) && (x.b > y.b), a, b);
 %!  assert (A, true);
@@ -1584,25 +1584,25 @@ arrayfun (@@str2num, [1234], \\n\
 %!  a = struct ("a", 1.1, "b", 4.2); b = struct ("a", 3.1, "b", 2);
 %!  A = arrayfun (@(x,y) (x.a < y.a) && (x.b > y.b), a, b, "UniformOutput", true);
 %!  assert (A, true);
 %!test
 %!  a = struct ("a", 1.1, "b", 4.2); b = struct ("a", 3.1, "b", 2);
 %!  A = arrayfun (@(x,y) x.a:y.a, a, b, "UniformOutput", false);
 %!  assert (isequal (A, {[1.1, 2.1, 3.1]}));
 %!test
-%!  A = arrayfun (@(x) mat2str(x), "a", "ErrorHandler", @arrayfunerror);
+%!  A = arrayfun (@(x) mat2str(x), "a", "ErrorHandler", @__arrayfunerror);
 %!  assert (isfield (A, "identifier"), true);
 %!  assert (isfield (A, "message"), true);
 %!  assert (isfield (A, "index"), true);
 %!  assert (isempty (A.message), false);
 %!  assert (A.index, 1);
 %!test %% Overwriting setting of "UniformOutput" true
 %!  A = arrayfun (@(x) mat2str(x), "a", "UniformOutput", true, \
-%!                "ErrorHandler", @arrayfunerror);
+%!                "ErrorHandler", @__arrayfunerror);
 %!  assert (isfield (A, "identifier"), true);
 %!  assert (isfield (A, "message"), true);
 %!  assert (isfield (A, "index"), true);
 %!  assert (isempty (A.message), false);
 %!  assert (A.index, 1);
 
 %% Input arguments can be of type cell array
 %!test
@@ -1610,25 +1610,25 @@ arrayfun (@@str2num, [1234], \\n\
 %!  assert (A, [true, false]);
 %!test
 %!  A = arrayfun (@(x,y) x{1} < y{1}, {1.1; 4.2}, {3.1; 2}, "UniformOutput", true);
 %!  assert (A, [true; false]);
 %!test
 %!  A = arrayfun (@(x,y) x{1} < y{1}, {1.1, 4.2}, {3.1, 2}, "UniformOutput", false);
 %!  assert (A, {true, false});
 %!test
-%!  A = arrayfun (@(x,y) num2str(x,y), {1.1, 4.2}, {3.1, 2}, "ErrorHandler", @arrayfunerror);
+%!  A = arrayfun (@(x,y) num2str(x,y), {1.1, 4.2}, {3.1, 2}, "ErrorHandler", @__arrayfunerror);
 %!  assert ([(isfield (A(1), "identifier")), (isfield (A(2), "identifier"))], [true, true]);
 %!  assert ([(isfield (A(1), "message")), (isfield (A(2), "message"))], [true, true]);
 %!  assert ([(isfield (A(1), "index")), (isfield (A(2), "index"))], [true, true]);
 %!  assert ([(isempty (A(1).message)), (isempty (A(2).message))], [false, false]);
 %!  assert ([A(1).index, A(2).index], [1, 2]);
 %!test
 %!  A = arrayfun (@(x,y) num2str(x,y), {1.1, 4.2}, {3.1, 2}, \
-%!                "UniformOutput", true, "ErrorHandler", @arrayfunerror);
+%!                "UniformOutput", true, "ErrorHandler", @__arrayfunerror);
 %!  assert ([(isfield (A(1), "identifier")), (isfield (A(2), "identifier"))], [true, true]);
 %!  assert ([(isfield (A(1), "message")), (isfield (A(2), "message"))], [true, true]);
 %!  assert ([(isfield (A(1), "index")), (isfield (A(2), "index"))], [true, true]);
 %!  assert ([(isempty (A(1).message)), (isempty (A(2).message))], [false, false]);
 %!  assert ([A(1).index, A(2).index], [1, 2]);
 */
 
 static void
diff --git a/src/DLD-FUNCTIONS/dassl.cc b/src/DLD-FUNCTIONS/dassl.cc
--- a/src/DLD-FUNCTIONS/dassl.cc
+++ b/src/DLD-FUNCTIONS/dassl.cc
@@ -495,28 +495,31 @@ parameters for @code{dassl}.\n\
 %%
 %%    y1' = -y2,   y1(0) = 1
 %%    y2' =  y1,   y2(0) = 0
 %%
 %% Solution
 %%
 %%    y1(t) = cos(t)
 %%    y2(t) = sin(t)
-%!function res = f (x, xdot, t)
+
+%!function res = __f (x, xdot, t)
 %!  res = [xdot(1)+x(2); xdot(2)-x(1)];
+%!endfunction
+
 %!test
 %!
 %! x0 = [1; 0];
 %! xdot0 = [0; 1];
 %! t = (0:1:10)';
 %!
 %! tol = 100 * dassl_options ("relative tolerance");
 %!
 %!
-%! [x, xdot] = dassl ("f", x0, xdot0, t);
+%! [x, xdot] = dassl ("__f", x0, xdot0, t);
 %!
 %! y = [cos(t), sin(t)];
 %!
 %! assert(all (all (abs (x - y) < tol)));
 
 %% dassl-2.m
 %%
 %% Test dassl() function
@@ -532,28 +535,31 @@ parameters for @code{dassl}.\n\
 %%   x1' + 10*x1 = 0,   x1(0) = 1
 %%   x1  + x2    = 1,   x2(0) = 0
 %%
 %%
 %% Solution
 %%
 %%  x1(t) = exp(-10*t)
 %%  x2(t) = 1 - x(1)
-%!function res = f (x, xdot, t)
+
+%!function res = __f (x, xdot, t)
 %!  res = [xdot(1)+10*x(1); x(1)+x(2)-1];
+%!endfunction
+
 %!test
 %!
 %! x0 = [1; 0];
 %! xdot0 = [-10; 10];
 %! t = (0:0.2:1)';
 %!
 %! tol = 500 * dassl_options ("relative tolerance");
 %!
 %!
-%! [x, xdot] = dassl ("f", x0, xdot0, t);
+%! [x, xdot] = dassl ("__f", x0, xdot0, t);
 %!
 %! y = [exp(-10*t), 1-exp(-10*t)];
 %!
 %! assert(all (all (abs (x - y) < tol)));
 
 %!test
 %! dassl_options ("absolute tolerance", eps);
 %! assert(dassl_options ("absolute tolerance") == eps);
diff --git a/src/DLD-FUNCTIONS/lsode.cc b/src/DLD-FUNCTIONS/lsode.cc
--- a/src/DLD-FUNCTIONS/lsode.cc
+++ b/src/DLD-FUNCTIONS/lsode.cc
@@ -487,56 +487,56 @@ parameters for @code{lsode}.\n\
 %%
 %%    y1' = -y2,   y1(0) = 1
 %%    y2' =  y1,   y2(0) = 0
 %%
 %% Solution
 %%
 %%    y1(t) = cos(t)
 %%    y2(t) = sin(t)
-%!function xdot = f (x, t)
+%!function xdot = __f (x, t)
 %!  xdot = [-x(2); x(1)];
 %!test
 %!
 %! x0 = [1; 0];
 %! xdot0 = [0; 1];
 %! t = (0:1:10)';
 %!
 %! tol = 500 * lsode_options ("relative tolerance");
 %!
 %!
-%! x = lsode ("f", x0, t);
+%! x = lsode ("__f", x0, t);
 %!
 %! y = [cos(t), sin(t)];
 %!
 %! assert(all (all (abs (x - y) < tol)));
 
-%!function xdotdot = f (x, t)
+%!function xdotdot = __f (x, t)
 %!  xdotdot = [x(2); -x(1)];
 %!test
 %!
 %! x0 = [1; 0];
 %! t = [0; 2*pi];
 %! tol = 100 * dassl_options ("relative tolerance");
 %!
-%! x = lsode ("f", x0, t);
+%! x = lsode ("__f", x0, t);
 %!
 %! y = [1, 0; 1, 0];
 %!
 %! assert(all (all (abs (x - y) < tol)));
 
-%!function xdot = f (x, t)
+%!function xdot = __f (x, t)
 %!  xdot = x;
 %!test
 %!
 %! x0 = 1;
 %! t = [0; 1];
 %! tol = 100 * dassl_options ("relative tolerance");
 %!
-%! x = lsode ("f", x0, t);
+%! x = lsode ("__f", x0, t);
 %!
 %! y = [1; e];
 %!
 %! assert(all (all (abs (x - y) < tol)));
 
 %!test
 %! lsode_options ("absolute tolerance", eps);
 %! assert(lsode_options ("absolute tolerance") == eps);
diff --git a/src/DLD-FUNCTIONS/qr.cc b/src/DLD-FUNCTIONS/qr.cc
--- a/src/DLD-FUNCTIONS/qr.cc
+++ b/src/DLD-FUNCTIONS/qr.cc
@@ -495,17 +495,17 @@ x = @var{R} \\ @var{C}\n\
 %! [qe, re, pe] = qr (a, 0);
 %!
 %! assert (q * r, a * p, sqrt (eps));
 %! assert (qe * re, a(:, pe), sqrt (eps));
 
 %!error <Invalid call to qr> qr ();
 %!error <Invalid call to qr> qr ([1, 2; 3, 4], 0, 2);
 
-%!function retval = testqr (q, r, a, p)
+%!function retval = __testqr (q, r, a, p)
 %!  tol = 100*eps (class(q));
 %!  retval = 0;
 %!  if (nargin == 3)
 %!    n1 = norm (q*r-a);
 %!    n2 = norm (q'*q-eye(columns(q)));
 %!    retval = (n1 < tol && n2 < tol);
 %!  else
 %!    n1 = norm (q'*q-eye(columns(q)));
@@ -513,58 +513,60 @@ x = @var{R} \\ @var{C}\n\
 %!    if (isvector (p))
 %!      n2 = norm (q*r-a(:,p));
 %!      retval = (retval && n2 < tol);
 %!    else
 %!      n2 = norm (q*r - a*p);
 %!      retval = (retval && n2 < tol);
 %!    endif
 %!  endif
+%!endfunction
+
 %!test
 %!
 %! t = ones (24, 1);
 %! j = 1;
 %!
 %! if false # eliminate big matrix tests
 %!   a = rand(5000,20);
-%!   [q,r]=qr(a,0); t(j++) = testqr(q,r,a);
-%!   [q,r]=qr(a',0); t(j++) = testqr(q,r,a');
-%!   [q,r,p]=qr(a,0); t(j++) = testqr(q,r,a,p);
-%!   [q,r,p]=qr(a',0); t(j++) = testqr(q,r,a',p);
+%!   [q,r]=qr(a,0); t(j++) = __testqr(q,r,a);
+%!   [q,r]=qr(a',0); t(j++) = __testqr(q,r,a');
+%!   [q,r,p]=qr(a,0); t(j++) = __testqr(q,r,a,p);
+%!   [q,r,p]=qr(a',0); t(j++) = __testqr(q,r,a',p);
 %!
 %!   a = a+1i*eps;
-%!   [q,r]=qr(a,0); t(j++) = testqr(q,r,a);
-%!   [q,r]=qr(a',0); t(j++) = testqr(q,r,a');
-%!   [q,r,p]=qr(a,0); t(j++) = testqr(q,r,a,p);
-%!   [q,r,p]=qr(a',0); t(j++) = testqr(q,r,a',p);
+%!   [q,r]=qr(a,0); t(j++) = __testqr(q,r,a);
+%!   [q,r]=qr(a',0); t(j++) = __testqr(q,r,a');
+%!   [q,r,p]=qr(a,0); t(j++) = __testqr(q,r,a,p);
+%!   [q,r,p]=qr(a',0); t(j++) = __testqr(q,r,a',p);
 %! endif
 %!
 %! a = [ ones(1,15); sqrt(eps)*eye(15) ];
-%! [q,r]=qr(a); t(j++) = testqr(q,r,a);
-%! [q,r]=qr(a'); t(j++) = testqr(q,r,a');
-%! [q,r,p]=qr(a); t(j++) = testqr(q,r,a,p);
-%! [q,r,p]=qr(a'); t(j++) = testqr(q,r,a',p);
+%! [q,r]=qr(a); t(j++) = __testqr(q,r,a);
+%! [q,r]=qr(a'); t(j++) = __testqr(q,r,a');
+%! [q,r,p]=qr(a); t(j++) = __testqr(q,r,a,p);
+%! [q,r,p]=qr(a'); t(j++) = __testqr(q,r,a',p);
 %!
 %! a = a+1i*eps;
-%! [q,r]=qr(a); t(j++) = testqr(q,r,a);
-%! [q,r]=qr(a'); t(j++) = testqr(q,r,a');
-%! [q,r,p]=qr(a); t(j++) = testqr(q,r,a,p);
-%! [q,r,p]=qr(a'); t(j++) = testqr(q,r,a',p);
+%! [q,r]=qr(a); t(j++) = __testqr(q,r,a);
+%! [q,r]=qr(a'); t(j++) = __testqr(q,r,a');
+%! [q,r,p]=qr(a); t(j++) = __testqr(q,r,a,p);
+%! [q,r,p]=qr(a'); t(j++) = __testqr(q,r,a',p);
 %!
 %! a = [ ones(1,15); sqrt(eps)*eye(15) ];
-%! [q,r]=qr(a,0); t(j++) = testqr(q,r,a);
-%! [q,r]=qr(a',0); t(j++) = testqr(q,r,a');
-%! [q,r,p]=qr(a,0); t(j++) = testqr(q,r,a,p);
-%! [q,r,p]=qr(a',0); t(j++) = testqr(q,r,a',p);
+%! [q,r]=qr(a,0); t(j++) = __testqr(q,r,a);
+%! [q,r]=qr(a',0); t(j++) = __testqr(q,r,a');
+%! [q,r,p]=qr(a,0); t(j++) = __testqr(q,r,a,p);
+%! [q,r,p]=qr(a',0); t(j++) = __testqr(q,r,a',p);
 %!
 %! a = a+1i*eps;
-%! [q,r]=qr(a,0); t(j++) = testqr(q,r,a);
-%! [q,r]=qr(a',0); t(j++) = testqr(q,r,a');
-%! [q,r,p]=qr(a,0); t(j++) = testqr(q,r,a,p);
-%! [q,r,p]=qr(a',0); t(j++) = testqr(q,r,a',p);
+%! [q,r]=qr(a,0); t(j++) = __testqr(q,r,a);
+%! [q,r]=qr(a',0); t(j++) = __testqr(q,r,a');
+%! [q,r,p]=qr(a,0); t(j++) = __testqr(q,r,a,p);
+%! [q,r,p]=qr(a',0); t(j++) = __testqr(q,r,a',p);
 %!
 %! a = [
 %! 611   196  -192   407    -8   -52   -49    29
 %! 196   899   113  -192   -71   -43    -8   -44
 %! -192   113   899   196    61    49     8    52
 %! 407  -192   196   611     8    44    59   -23
 %! -8   -71    61     8   411  -599   208   208
 %! -52   -43    49    44  -599   411   208   208
@@ -620,51 +622,51 @@ x = @var{R} \\ @var{C}\n\
 
 %!test
 %!
 %! t = ones (24, 1);
 %! j = 1;
 %!
 %! if false # eliminate big matrix tests
 %!   a = rand(5000,20);
-%!   [q,r]=qr(a,0); t(j++) = testqr(q,r,a);
-%!   [q,r]=qr(a',0); t(j++) = testqr(q,r,a');
-%!   [q,r,p]=qr(a,0); t(j++) = testqr(q,r,a,p);
-%!   [q,r,p]=qr(a',0); t(j++) = testqr(q,r,a',p);
+%!   [q,r]=qr(a,0); t(j++) = __testqr(q,r,a);
+%!   [q,r]=qr(a',0); t(j++) = __testqr(q,r,a');
+%!   [q,r,p]=qr(a,0); t(j++) = __testqr(q,r,a,p);
+%!   [q,r,p]=qr(a',0); t(j++) = __testqr(q,r,a',p);
 %!
 %!   a = a+1i*eps('single');
-%!   [q,r]=qr(a,0); t(j++) = testqr(q,r,a);
-%!   [q,r]=qr(a',0); t(j++) = testqr(q,r,a');
-%!   [q,r,p]=qr(a,0); t(j++) = testqr(q,r,a,p);
-%!   [q,r,p]=qr(a',0); t(j++) = testqr(q,r,a',p);
+%!   [q,r]=qr(a,0); t(j++) = __testqr(q,r,a);
+%!   [q,r]=qr(a',0); t(j++) = __testqr(q,r,a');
+%!   [q,r,p]=qr(a,0); t(j++) = __testqr(q,r,a,p);
+%!   [q,r,p]=qr(a',0); t(j++) = __testqr(q,r,a',p);
 %! endif
 %!
 %! a = [ ones(1,15); sqrt(eps('single'))*eye(15) ];
-%! [q,r]=qr(a); t(j++) = testqr(q,r,a);
-%! [q,r]=qr(a'); t(j++) = testqr(q,r,a');
-%! [q,r,p]=qr(a); t(j++) = testqr(q,r,a,p);
-%! [q,r,p]=qr(a'); t(j++) = testqr(q,r,a',p);
+%! [q,r]=qr(a); t(j++) = __testqr(q,r,a);
+%! [q,r]=qr(a'); t(j++) = __testqr(q,r,a');
+%! [q,r,p]=qr(a); t(j++) = __testqr(q,r,a,p);
+%! [q,r,p]=qr(a'); t(j++) = __testqr(q,r,a',p);
 %!
 %! a = a+1i*eps('single');
-%! [q,r]=qr(a); t(j++) = testqr(q,r,a);
-%! [q,r]=qr(a'); t(j++) = testqr(q,r,a');
-%! [q,r,p]=qr(a); t(j++) = testqr(q,r,a,p);
-%! [q,r,p]=qr(a'); t(j++) = testqr(q,r,a',p);
+%! [q,r]=qr(a); t(j++) = __testqr(q,r,a);
+%! [q,r]=qr(a'); t(j++) = __testqr(q,r,a');
+%! [q,r,p]=qr(a); t(j++) = __testqr(q,r,a,p);
+%! [q,r,p]=qr(a'); t(j++) = __testqr(q,r,a',p);
 %!
 %! a = [ ones(1,15); sqrt(eps('single'))*eye(15) ];
-%! [q,r]=qr(a,0); t(j++) = testqr(q,r,a);
-%! [q,r]=qr(a',0); t(j++) = testqr(q,r,a');
-%! [q,r,p]=qr(a,0); t(j++) = testqr(q,r,a,p);
-%! [q,r,p]=qr(a',0); t(j++) = testqr(q,r,a',p);
+%! [q,r]=qr(a,0); t(j++) = __testqr(q,r,a);
+%! [q,r]=qr(a',0); t(j++) = __testqr(q,r,a');
+%! [q,r,p]=qr(a,0); t(j++) = __testqr(q,r,a,p);
+%! [q,r,p]=qr(a',0); t(j++) = __testqr(q,r,a',p);
 %!
 %! a = a+1i*eps('single');
-%! [q,r]=qr(a,0); t(j++) = testqr(q,r,a);
-%! [q,r]=qr(a',0); t(j++) = testqr(q,r,a');
-%! [q,r,p]=qr(a,0); t(j++) = testqr(q,r,a,p);
-%! [q,r,p]=qr(a',0); t(j++) = testqr(q,r,a',p);
+%! [q,r]=qr(a,0); t(j++) = __testqr(q,r,a);
+%! [q,r]=qr(a',0); t(j++) = __testqr(q,r,a');
+%! [q,r,p]=qr(a,0); t(j++) = __testqr(q,r,a,p);
+%! [q,r,p]=qr(a',0); t(j++) = __testqr(q,r,a',p);
 %!
 %! a = [
 %! 611   196  -192   407    -8   -52   -49    29
 %! 196   899   113  -192   -71   -43    -8   -44
 %! -192   113   899   196    61    49     8    52
 %! 407  -192   196   611     8    44    59   -23
 %! -8   -71    61     8   411  -599   208   208
 %! -52   -43    49    44  -599   411   208   208
diff --git a/src/DLD-FUNCTIONS/quad.cc b/src/DLD-FUNCTIONS/quad.cc
--- a/src/DLD-FUNCTIONS/quad.cc
+++ b/src/DLD-FUNCTIONS/quad.cc
@@ -469,39 +469,43 @@ variable by routines @code{dblquad} and 
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 
-%!function y = f (x)
+%!function y = __f (x)
 %! y = x + 1;
+%!endfunction
+
 %!test
-%! [v, ier, nfun, err] = quad ("f", 0, 5);
+%! [v, ier, nfun, err] = quad ("__f", 0, 5);
 %! assert(ier == 0 && abs (v - 17.5) < sqrt (eps) && nfun > 0 &&
 %!        err < sqrt (eps))
 %!test
-%! [v, ier, nfun, err] = quad ("f", single(0), single(5));
+%! [v, ier, nfun, err] = quad ("__f", single(0), single(5));
 %! assert(ier == 0 && abs (v - 17.5) < sqrt (eps ("single")) && nfun > 0 &&
 %!        err < sqrt (eps ("single")))
 
-%!function y = f (x)
+%!function y = __f (x)
 %!  y = x .* sin (1 ./ x) .* sqrt (abs (1 - x));
+%!endfunction
+
 %!test
-%!  [v, ier, nfun, err] = quad ("f", 0.001, 3);
+%!  [v, ier, nfun, err] = quad ("__f", 0.001, 3);
 %! assert((ier == 0 || ier == 1) && abs (v - 1.98194120273598) < sqrt (eps) && nfun > 0);
 %!test
-%!  [v, ier, nfun, err] = quad ("f", single(0.001), single(3));
+%!  [v, ier, nfun, err] = quad ("__f", single(0.001), single(3));
 %! assert((ier == 0 || ier == 1) && abs (v - 1.98194120273598) < sqrt (eps ("single")) && nfun > 0);
 
 %!error <Invalid call to quad> quad ();
 
-%!error <Invalid call to quad> quad ("f", 1, 2, 3, 4, 5);
+%!error <Invalid call to quad> quad ("__f", 1, 2, 3, 4, 5);
 
 %!test
 %! quad_options ("absolute tolerance", eps);
 %! assert(quad_options ("absolute tolerance") == eps);
 
 %!error <Invalid call to quad_options> quad_options (1, 2, 3);
 
 */
diff --git a/src/data.cc b/src/data.cc
--- a/src/data.cc
+++ b/src/data.cc
@@ -2155,17 +2155,17 @@ cat (4, ones (2, 2), zeros (2, 2))\n\
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 
-%!function ret = testcat (t1, t2, tr, cmplx)
+%!function ret = __testcat (t1, t2, tr, cmplx)
 %! assert (cat (1, cast ([], t1), cast([], t2)), cast ([], tr));
 %!
 %! assert (cat (1, cast (1, t1), cast (2, t2)), cast ([1; 2], tr));
 %! assert (cat (1, cast (1, t1), cast ([2; 3], t2)), cast ([1; 2; 3], tr));
 %! assert (cat (1, cast ([1; 2], t1), cast (3, t2)), cast ([1; 2; 3], tr));
 %! assert (cat (1, cast ([1; 2], t1), cast ([3; 4], t2)), cast ([1; 2; 3; 4], tr));
 %! assert (cat (2, cast (1, t1), cast (2, t2)), cast ([1, 2], tr));
 %! assert (cat (2, cast (1, t1), cast ([2, 3], t2)), cast ([1, 2, 3], tr));
@@ -2232,77 +2232,78 @@ cat (4, ones (2, 2), zeros (2, 2))\n\
 %!   assert ([cast([1i; 2], t1); cast(3i, t2)], cast ([1i; 2; 3i], tr));
 %!   assert ([cast([1i; 2], t1); cast([3i; 4], t2)], cast ([1i; 2; 3i; 4], tr));
 %!   assert ([cast(1i, t1), cast(2i, t2)], cast ([1i, 2i], tr));
 %!   assert ([cast(1i, t1), cast([2i, 3], t2)], cast ([1i, 2i, 3], tr));
 %!   assert ([cast([1i, 2], t1), cast(3i, t2)], cast ([1i, 2, 3i], tr));
 %!   assert ([cast([1i, 2], t1), cast([3i, 4], t2)], cast ([1i, 2, 3i, 4], tr));
 %! endif
 %! ret = true;
-
-%!assert (testcat('double', 'double', 'double'));
-%!assert (testcat('single', 'double', 'single'));
-%!assert (testcat('double', 'single', 'single'));
-%!assert (testcat('single', 'single', 'single'));
-
-%!assert (testcat('double', 'int8', 'int8', false));
-%!assert (testcat('int8', 'double', 'int8', false));
-%!assert (testcat('single', 'int8', 'int8', false));
-%!assert (testcat('int8', 'single', 'int8', false));
-%!assert (testcat('int8', 'int8', 'int8', false));
-%!assert (testcat('double', 'int16', 'int16', false));
-%!assert (testcat('int16', 'double', 'int16', false));
-%!assert (testcat('single', 'int16', 'int16', false));
-%!assert (testcat('int16', 'single', 'int16', false));
-%!assert (testcat('int16', 'int16', 'int16', false));
-%!assert (testcat('double', 'int32', 'int32', false));
-%!assert (testcat('int32', 'double', 'int32', false));
-%!assert (testcat('single', 'int32', 'int32', false));
-%!assert (testcat('int32', 'single', 'int32', false));
-%!assert (testcat('int32', 'int32', 'int32', false));
-%!assert (testcat('double', 'int64', 'int64', false));
-%!assert (testcat('int64', 'double', 'int64', false));
-%!assert (testcat('single', 'int64', 'int64', false));
-%!assert (testcat('int64', 'single', 'int64', false));
-%!assert (testcat('int64', 'int64', 'int64', false));
-
-%!assert (testcat('double', 'uint8', 'uint8', false));
-%!assert (testcat('uint8', 'double', 'uint8', false));
-%!assert (testcat('single', 'uint8', 'uint8', false));
-%!assert (testcat('uint8', 'single', 'uint8', false));
-%!assert (testcat('uint8', 'uint8', 'uint8', false));
-%!assert (testcat('double', 'uint16', 'uint16', false));
-%!assert (testcat('uint16', 'double', 'uint16', false));
-%!assert (testcat('single', 'uint16', 'uint16', false));
-%!assert (testcat('uint16', 'single', 'uint16', false));
-%!assert (testcat('uint16', 'uint16', 'uint16', false));
-%!assert (testcat('double', 'uint32', 'uint32', false));
-%!assert (testcat('uint32', 'double', 'uint32', false));
-%!assert (testcat('single', 'uint32', 'uint32', false));
-%!assert (testcat('uint32', 'single', 'uint32', false));
-%!assert (testcat('uint32', 'uint32', 'uint32', false));
-%!assert (testcat('double', 'uint64', 'uint64', false));
-%!assert (testcat('uint64', 'double', 'uint64', false));
-%!assert (testcat('single', 'uint64', 'uint64', false));
-%!assert (testcat('uint64', 'single', 'uint64', false));
-%!assert (testcat('uint64', 'uint64', 'uint64', false));
-
-%!assert (cat (3, [], [1,2;3,4]), [1,2;3,4]);
-%!assert (cat (3, [1,2;3,4], []), [1,2;3,4]);
-%!assert (cat (3, [], [1,2;3,4], []), [1,2;3,4]);
-%!assert (cat (3, [], [], []), zeros (0, 0, 3));
-
-%!assert (cat (3, [], [], 1, 2), cat (3, 1, 2));
-%!assert (cat (3, [], [], [1,2;3,4]), [1,2;3,4]);
-%!assert (cat (4, [], [], [1,2;3,4]), [1,2;3,4]);
-%!error <dimension mismatch> cat (3, cat (3, [], []), [1,2;3,4]);
-%!error <dimension mismatch> cat (3, zeros (0, 0, 2), [1,2;3,4]);
-
-%!assert ([zeros(3,2,2); ones(1,2,2)], repmat([0;0;0;1],[1,2,2]) );
-%!assert ([zeros(3,2,2); ones(1,2,2)], vertcat(zeros(3,2,2), ones(1,2,2)) );
+%!endfunction
+
+%!assert (__testcat('double', 'double', 'double'))
+%!assert (__testcat('single', 'double', 'single'))
+%!assert (__testcat('double', 'single', 'single'))
+%!assert (__testcat('single', 'single', 'single'))
+
+%!assert (__testcat('double', 'int8', 'int8', false))
+%!assert (__testcat('int8', 'double', 'int8', false))
+%!assert (__testcat('single', 'int8', 'int8', false))
+%!assert (__testcat('int8', 'single', 'int8', false))
+%!assert (__testcat('int8', 'int8', 'int8', false))
+%!assert (__testcat('double', 'int16', 'int16', false))
+%!assert (__testcat('int16', 'double', 'int16', false))
+%!assert (__testcat('single', 'int16', 'int16', false))
+%!assert (__testcat('int16', 'single', 'int16', false))
+%!assert (__testcat('int16', 'int16', 'int16', false))
+%!assert (__testcat('double', 'int32', 'int32', false))
+%!assert (__testcat('int32', 'double', 'int32', false))
+%!assert (__testcat('single', 'int32', 'int32', false))
+%!assert (__testcat('int32', 'single', 'int32', false))
+%!assert (__testcat('int32', 'int32', 'int32', false))
+%!assert (__testcat('double', 'int64', 'int64', false))
+%!assert (__testcat('int64', 'double', 'int64', false))
+%!assert (__testcat('single', 'int64', 'int64', false))
+%!assert (__testcat('int64', 'single', 'int64', false))
+%!assert (__testcat('int64', 'int64', 'int64', false))
+
+%!assert (__testcat('double', 'uint8', 'uint8', false))
+%!assert (__testcat('uint8', 'double', 'uint8', false))
+%!assert (__testcat('single', 'uint8', 'uint8', false))
+%!assert (__testcat('uint8', 'single', 'uint8', false))
+%!assert (__testcat('uint8', 'uint8', 'uint8', false))
+%!assert (__testcat('double', 'uint16', 'uint16', false))
+%!assert (__testcat('uint16', 'double', 'uint16', false))
+%!assert (__testcat('single', 'uint16', 'uint16', false))
+%!assert (__testcat('uint16', 'single', 'uint16', false))
+%!assert (__testcat('uint16', 'uint16', 'uint16', false))
+%!assert (__testcat('double', 'uint32', 'uint32', false))
+%!assert (__testcat('uint32', 'double', 'uint32', false))
+%!assert (__testcat('single', 'uint32', 'uint32', false))
+%!assert (__testcat('uint32', 'single', 'uint32', false))
+%!assert (__testcat('uint32', 'uint32', 'uint32', false))
+%!assert (__testcat('double', 'uint64', 'uint64', false))
+%!assert (__testcat('uint64', 'double', 'uint64', false))
+%!assert (__testcat('single', 'uint64', 'uint64', false))
+%!assert (__testcat('uint64', 'single', 'uint64', false))
+%!assert (__testcat('uint64', 'uint64', 'uint64', false))
+
+%!assert (cat (3, [], [1,2;3,4]), [1,2;3,4])
+%!assert (cat (3, [1,2;3,4], []), [1,2;3,4])
+%!assert (cat (3, [], [1,2;3,4], []), [1,2;3,4])
+%!assert (cat (3, [], [], []), zeros (0, 0, 3))
+
+%!assert (cat (3, [], [], 1, 2), cat (3, 1, 2))
+%!assert (cat (3, [], [], [1,2;3,4]), [1,2;3,4])
+%!assert (cat (4, [], [], [1,2;3,4]), [1,2;3,4])
+%!error <dimension mismatch> cat (3, cat (3, [], []), [1,2;3,4])
+%!error <dimension mismatch> cat (3, zeros (0, 0, 2), [1,2;3,4])
+
+%!assert ([zeros(3,2,2); ones(1,2,2)], repmat([0;0;0;1],[1,2,2]) )
+%!assert ([zeros(3,2,2); ones(1,2,2)], vertcat(zeros(3,2,2), ones(1,2,2)) )
 
 */
 
 static octave_value
 do_permute (const octave_value_list& args, bool inv)
 {
   octave_value retval;
 
diff --git a/src/ov-fcn-handle.cc b/src/ov-fcn-handle.cc
--- a/src/ov-fcn-handle.cc
+++ b/src/ov-fcn-handle.cc
@@ -1754,28 +1754,31 @@ are ignored in the lookup.\n\
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-%!function y = testrecursionfunc (f, x, n)
+
+%!function y = __testrecursionfunc (f, x, n)
 %!  if (nargin < 3)
 %!    n = 0;
 %!  endif
 %!  if (n > 2)
 %!    y = f (x);
 %!  else
 %!    n++;
-%!    y = testrecursionfunc (@(x) f(2*x), x, n);
+%!    y = __testrecursionfunc (@(x) f(2*x), x, n);
 %!  endif
-%!test
-%! assert (testrecursionfunc (@(x) x, 1), 8);
+%!endfunction
+%!
+%!assert (__testrecursionfunc (@(x) x, 1), 8)
+
 */
 
 octave_fcn_binder::octave_fcn_binder (const octave_value& f,
                                       const octave_value& root,
                                       const octave_value_list& templ,
                                       const std::vector<int>& mask,
                                       int exp_nargin)
 : octave_fcn_handle (f), root_handle (root), arg_template (templ),
@@ -1953,15 +1956,15 @@ octave_fcn_binder::do_multi_index_op (in
     }
   else
      retval = octave_fcn_handle::do_multi_index_op (nargout, args, lvalue_list);
 
   return retval;
 }
 
 /*
-%!function r = f (g, i)
+%!function r = __f (g, i)
 %!  r = g(i);
 %!endfunction
 %!test
 %! x = [1,2;3,4];
-%! assert (f (@(i) x(:,i), 1), [1;3]);
+%! assert (__f (@(i) x(:,i), 1), [1;3]);
 */
diff --git a/src/pt-fcn-handle.cc b/src/pt-fcn-handle.cc
--- a/src/pt-fcn-handle.cc
+++ b/src/pt-fcn-handle.cc
@@ -136,32 +136,34 @@ tree_anon_fcn_handle::rvalue1 (int)
   octave_value ov_fcn (uf);
 
   octave_value fh (octave_fcn_binder::maybe_binder (ov_fcn));
 
   return fh;
 }
 
 /*
-%!function r = f2 (f, x)
+%!function r = __f2 (f, x)
 %!  r = f (x);
-%!function f = f1 (k)
-%!  f = @(x) f2 (@(y) y-k, x);
+%!endfunction
+%!function f = __f1 (k)
+%!  f = @(x) __f2 (@(y) y-k, x);
+%!endfunction
+
+%!assert ((__f1 (3)) (10) == 7)
+
 %!test
-%! assert ((f1 (3)) (10) == 7)
-%!
-%!shared g
 %! g = @(t) feval (@(x) t*x, 2);
-%!assert (g(0.5) == 1)
-%!
-%!shared f, g, h
+%! assert (g(0.5) == 1);
+
+%!test
 %! h = @(x) sin (x);
 %! g = @(f, x) h (x);
 %! f = @() g (@(x) h, pi);
-%!assert (f () == sin (pi))
+%! assert (f () == sin (pi));
 */
 
 octave_value_list
 tree_anon_fcn_handle::rvalue (int nargout)
 {
   octave_value_list retval;
 
   if (nargout > 1)
