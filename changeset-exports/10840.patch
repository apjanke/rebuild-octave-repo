# HG changeset patch
# User Rik <octave@nomad.inbox5.com>
# Date 1280600291 25200
#      Sat Jul 31 11:18:11 2010 -0700
# Node ID 89f4d7e294cc80ec7c628d3d06455abe45f772d7
# Parent  65bc065bec957208d59a204229131a39e1eb4ce5
Grammarcheck .cc files

diff --git a/liboctave/ChangeLog b/liboctave/ChangeLog
--- a/liboctave/ChangeLog
+++ b/liboctave/ChangeLog
@@ -1,8 +1,13 @@
+2010-07-31  Rik <octave@nomad.inbox5.com>
+
+	* DASPK-opts.in, DASRT-opts.in, DASSL-opts.in, LSODE-opts.in, 
+	  Quad-opts.in: Grammarcheck .cc files
+
 2010-07-29  Jaroslav Hajek  <highegg@gmail.com>
 
 	* dim-vector.cc (dim_vector::dim_max (void)): Turn it into a function.
 	(dim_vector::safe_numel): Update usage.
 	* dim-vector.h: Update declaration.
 
 2010-07-27  Jaroslav Hajek  <highegg@gmail.com>
 
diff --git a/liboctave/DASPK-opts.in b/liboctave/DASPK-opts.in
--- a/liboctave/DASPK-opts.in
+++ b/liboctave/DASPK-opts.in
@@ -21,16 +21,17 @@ CLASS = "DASPK"
 INCLUDE = "DAE.h"
 
 OPTION
   NAME = "absolute tolerance"
   DOC_ITEM
 Absolute tolerance.  May be either vector or scalar.  If a vector, it
 must match the dimension of the state vector, and the relative
 tolerance must also be a vector of the same length.
+
   END_DOC_ITEM
   TYPE = "Array<double>"
   SET_ARG_TYPE = "const $TYPE&"
   INIT_BODY
     $OPTVAR.resize (1, 1);
     $OPTVAR(0) = ::sqrt (DBL_EPSILON);
   END_INIT_BODY
   SET_CODE
@@ -56,16 +57,17 @@ tolerance must also be a vector of the s
 The local error test applied at each integration step is
 
 @example
 @group
   abs (local error in x(i))
        <= rtol(i) * abs (Y(i)) + atol(i)
 @end group
 @end example
+
   END_DOC_ITEM
   TYPE = "Array<double>"
   SET_ARG_TYPE = "const $TYPE&"
   INIT_BODY
     $OPTVAR.resize (1, 1);
     $OPTVAR(0) = ::sqrt (DBL_EPSILON);
   END_INIT_BODY
   SET_CODE
@@ -85,78 +87,87 @@ OPTION
   NAME = "compute consistent initial condition"
   DOC_ITEM
 Denoting the differential variables in the state vector by @samp{Y_d}
 and the algebraic variables by @samp{Y_a}, @code{ddaspk} can solve
 one of two initialization problems:
 
 @enumerate
 @item Given Y_d, calculate Y_a and Y'_d
+
 @item Given Y', calculate Y.
 @end enumerate
 
 In either case, initial values for the given components are input, and
 initial guesses for the unknown components must also be provided as
 input.  Set this option to 1 to solve the first problem, or 2 to solve
 the second (the default is 0, so you must provide a set of
 initial conditions that are consistent).
 
 If this option is set to a nonzero value, you must also set the
 @code{\"algebraic variables\"} option to declare which variables in the
 problem are algebraic.
+
   END_DOC_ITEM
   TYPE = "octave_idx_type"
   INIT_VALUE = "0"
   SET_EXPR = "val"
 END_OPTION
 
 OPTION
   NAME = "use initial condition heuristics"
   DOC_ITEM
 Set to a nonzero value to use the initial condition heuristics options
 described below.
+
   END_DOC_ITEM
   TYPE = "octave_idx_type"
   INIT_VALUE = "0"
   SET_EXPR = "val"
 END_OPTION
 
 OPTION
   NAME = "initial condition heuristics"
   DOC_ITEM
 A vector of the following parameters that can be used to control the
 initial condition calculation.
 
 @table @code
 @item MXNIT
 Maximum number of Newton iterations (default is 5).
+
 @item MXNJ
 Maximum number of Jacobian evaluations (default is 6).
+
 @item MXNH
 Maximum number of values of the artificial stepsize parameter to be
 tried if the @code{\"compute consistent initial condition\"} option has
 been set to 1 (default is 5).
 
 Note that the maximum total number of Newton iterations allowed is
 @code{MXNIT*MXNJ*MXNH} if the @code{\"compute consistent initial
 condition\"} option has been set to 1 and @code{MXNIT*MXNJ} if it is
 set to 2.
+
 @item LSOFF
 Set to a nonzero value to disable the linesearch algorithm (default is
 0).
+
 @item STPTOL
 Minimum scaled step in linesearch algorithm (default is eps^(2/3)).
+
 @item EPINIT
 Swing factor in the Newton iteration convergence test.  The test is
 applied to the residual vector, premultiplied by the approximate
 Jacobian.  For convergence, the weighted RMS norm of this vector
 (scaled by the error weights) must be less than @code{EPINIT*EPCON},
 where @code{EPCON} = 0.33 is the analogous test constant used in the
 time steps.  The default is @code{EPINIT} = 0.01.
 @end table
+
   END_DOC_ITEM
   TYPE = "Array<double>"
   SET_ARG_TYPE = "const $TYPE&"
   INIT_BODY
     $OPTVAR.resize (6, 1);
     $OPTVAR(0) = 5.0;
     $OPTVAR(1) = 6.0;
     $OPTVAR(2) = 5.0;
@@ -167,28 +178,30 @@ time steps.  The default is @code{EPINIT
   SET_EXPR = "val"
 END_OPTION
 
 OPTION
   NAME = "print initial condition info"
   DOC_ITEM
 Set this option to a nonzero value to display detailed information
 about the initial condition calculation (default is 0).
+
   END_DOC_ITEM
   TYPE = "octave_idx_type"
   INIT_VALUE = "0"
   SET_EXPR = "val"
 END_OPTION
 
 OPTION
   NAME = "exclude algebraic variables from error test"
   DOC_ITEM
 Set to a nonzero value to exclude algebraic variables from the error
 test.  You must also set the @code{\"algebraic variables\"} option to
 declare which variables in the problem are algebraic (default is 0).
+
   END_DOC_ITEM
   TYPE = "octave_idx_type"
   INIT_VALUE = "0"
   SET_EXPR = "val"
 END_OPTION
 
 OPTION
   NAME = "algebraic variables"
@@ -196,16 +209,17 @@ OPTION
 A vector of the same length as the state vector.  A nonzero element
 indicates that the corresponding element of the state vector is an
 algebraic variable (i.e., its derivative does not appear explicitly
 in the equation set.
 
 This option is required by the
 @code{compute consistent initial condition\"} and
 @code{\"exclude algebraic variables from error test\"} options.
+
   END_DOC_ITEM
   TYPE = "Array<octave_idx_type>"
   SET_ARG_TYPE = const $TYPE&
   INIT_BODY
     $OPTVAR.resize (1, 1);
     $OPTVAR(0) = 0;
   END_INIT_BODY
   SET_CODE
@@ -225,19 +239,22 @@ OPTION
   NAME = "enforce inequality constraints"
   DOC_ITEM
 Set to one of the following values to enforce the inequality
 constraints specified by the @code{\"inequality constraint types\"}
 option (default is 0).
 
 @enumerate
 @item To have constraint checking only in the initial condition calculation.
+
 @item To enforce constraint checking during the integration.
+
 @item To enforce both options 1 and 2.
 @end enumerate
+
   END_DOC_ITEM
   TYPE = "octave_idx_type"
   INIT_VALUE = "0"
   SET_EXPR = "val"
 END_OPTION
 
 OPTION
   NAME = "inequality constraint types"
@@ -245,28 +262,33 @@ OPTION
 A vector of the same length as the state specifying the type of
 inequality constraint.  Each element of the vector corresponds to an
 element of the state and should be assigned one of the following
 codes 
 
 @table @asis
 @item -2
 Less than zero.
+
 @item -1
 Less than or equal to zero.
+
 @item 0
 Not constrained.
+
 @item 1
 Greater than or equal to zero.
+
 @item 2
 Greater than zero.
 @end table
 
 This option only has an effect if the
 @code{\"enforce inequality constraints\"} option is nonzero.
+
   END_DOC_ITEM
   TYPE = "Array<octave_idx_type>"
   SET_ARG_TYPE = const $TYPE&
   INIT_BODY
     $OPTVAR.resize (1, 1);
     $OPTVAR(0) = 0;
   END_INIT_BODY
   SET_CODE
@@ -285,27 +307,29 @@ END_OPTION
 OPTION
   NAME = "initial step size"
   DOC_ITEM
 Differential-algebraic problems may occasionally suffer from severe
 scaling difficulties on the first step.  If you know a great deal
 about the scaling of your problem, you can help to alleviate this
 problem by specifying an initial stepsize (default is computed
 automatically).
+
   END_DOC_ITEM
   TYPE = "double"
   INIT_VALUE = "-1.0"
   SET_EXPR = "(val >= 0.0) ? val : -1.0"
 END_OPTION
 
 OPTION
   NAME = "maximum order"
   DOC_ITEM
 Restrict the maximum order of the solution method.  This option must
 be between 1 and 5, inclusive (default is 5).
+
   END_DOC_ITEM
   TYPE = "octave_idx_type"
   INIT_VALUE = "5"
   SET_EXPR = "val"
 END_OPTION
 
 OPTION
   NAME = "maximum step size"
diff --git a/liboctave/DASRT-opts.in b/liboctave/DASRT-opts.in
--- a/liboctave/DASRT-opts.in
+++ b/liboctave/DASRT-opts.in
@@ -21,16 +21,17 @@ CLASS = "DASRT"
 INCLUDE = "DAERT.h"
 
 OPTION
   NAME = "absolute tolerance"
   DOC_ITEM
 Absolute tolerance.  May be either vector or scalar.  If a vector, it
 must match the dimension of the state vector, and the relative
 tolerance must also be a vector of the same length.
+
   END_DOC_ITEM
   TYPE = "Array<double>"
   SET_ARG_TYPE = "const $TYPE&"
   INIT_BODY
     $OPTVAR.resize (1, 1);
     $OPTVAR(0) = ::sqrt (DBL_EPSILON);
   END_INIT_BODY
   SET_CODE
@@ -49,22 +50,24 @@ END_OPTION
 OPTION
   NAME = "relative tolerance"
   DOC_ITEM
 Relative tolerance.  May be either vector or scalar.  If a vector, it
 must match the dimension of the state vector, and the absolute
 tolerance must also be a vector of the same length.
 
 The local error test applied at each integration step is
+
 @example
 @group
   abs (local error in x(i)) <= ...
       rtol(i) * abs (Y(i)) + atol(i)
 @end group
 @end example
+
   END_DOC_ITEM
   TYPE = "Array<double>"
   SET_ARG_TYPE = "const $TYPE&"
   INIT_BODY
     $OPTVAR.resize (1, 1);
     $OPTVAR(0) = ::sqrt (DBL_EPSILON);
   END_INIT_BODY
   SET_CODE
@@ -82,38 +85,41 @@ END_OPTION
 
 OPTION
   NAME = "initial step size"
   DOC_ITEM
 Differential-algebraic problems may occasionally suffer from severe
 scaling difficulties on the first step.  If you know a great deal
 about the scaling of your problem, you can help to alleviate this
 problem by specifying an initial stepsize.
+
   END_DOC_ITEM
   TYPE = "double"
   INIT_VALUE = "-1.0"
   SET_EXPR = "(val >= 0.0) ? val : -1.0"
 END_OPTION
 
 OPTION
   NAME = "maximum order"
   DOC_ITEM
 Restrict the maximum order of the solution method.  This option must
 be between 1 and 5, inclusive.
+
   END_DOC_ITEM
   TYPE = "octave_idx_type"
   INIT_VALUE = "-1"
   SET_EXPR = "val"
 END_OPTION
 
 OPTION
   NAME = "maximum step size"
   DOC_ITEM
 Setting the maximum stepsize will avoid passing over very large
 regions.
+
   END_DOC_ITEM
   TYPE = "double"
   INIT_VALUE = "-1.0"
   SET_EXPR = "(val >= 0.0) ? val : -1.0"
 END_OPTION
 
 OPTION
   NAME = "step limit"
diff --git a/liboctave/DASSL-opts.in b/liboctave/DASSL-opts.in
--- a/liboctave/DASSL-opts.in
+++ b/liboctave/DASSL-opts.in
@@ -21,16 +21,17 @@ CLASS = "DASSL"
 INCLUDE = "DAE.h"
 
 OPTION
   NAME = "absolute tolerance"
   DOC_ITEM
 Absolute tolerance.  May be either vector or scalar.  If a vector, it
 must match the dimension of the state vector, and the relative
 tolerance must also be a vector of the same length.
+
   END_DOC_ITEM
   TYPE = "Array<double>"
   SET_ARG_TYPE = "const $TYPE&"
   INIT_BODY
     $OPTVAR.resize (1, 1);
     $OPTVAR(0) = ::sqrt (DBL_EPSILON);
   END_INIT_BODY
   SET_CODE
@@ -56,16 +57,17 @@ tolerance must also be a vector of the s
 The local error test applied at each integration step is
 
 @example
 @group
   abs (local error in x(i))
        <= rtol(i) * abs (Y(i)) + atol(i)
 @end group
 @end example
+
   END_DOC_ITEM
   TYPE = "Array<double>"
   SET_ARG_TYPE = "const $TYPE&"
   INIT_BODY
     $OPTVAR.resize (1, 1);
     $OPTVAR(0) = ::sqrt (DBL_EPSILON);
   END_INIT_BODY
   SET_CODE
@@ -82,65 +84,70 @@ The local error test applied at each int
 END_OPTION
 
 OPTION
   NAME = "compute consistent initial condition"
   DOC_ITEM
 If nonzero, @code{dassl} will attempt to compute a consistent set of initial
 conditions.  This is generally not reliable, so it is best to provide
 a consistent set and leave this option set to zero.
+
   END_DOC_ITEM
   TYPE = "octave_idx_type"
   INIT_VALUE = "0"
   SET_EXPR = "val"
 END_OPTION
 
 OPTION
   NAME = "enforce nonnegativity constraints"
   DOC_ITEM
 If you know that the solutions to your equations will always be
 non-negative, it may help to set this parameter to a nonzero
 value.  However, it is probably best to try leaving this option set to
 zero first, and only setting it to a nonzero value if that doesn't
 work very well.
+
   END_DOC_ITEM
   TYPE = "octave_idx_type"
   INIT_VALUE = "0"
   SET_EXPR = "val"
 END_OPTION
 
 OPTION
   NAME = "initial step size"
   DOC_ITEM
 Differential-algebraic problems may occasionally suffer from severe
 scaling difficulties on the first step.  If you know a great deal
 about the scaling of your problem, you can help to alleviate this
 problem by specifying an initial stepsize.
+
   END_DOC_ITEM
   TYPE = "double"
   INIT_VALUE = "-1.0"
   SET_EXPR = "(val >= 0.0) ? val : -1.0"
 END_OPTION
 
 OPTION
   NAME = "maximum order"
   DOC_ITEM
 Restrict the maximum order of the solution method.  This option must
 be between 1 and 5, inclusive.
+
   END_DOC_ITEM
   TYPE = "octave_idx_type"
   INIT_VALUE = "-1"
   SET_EXPR = "val"
 END_OPTION
 
 OPTION
   NAME = "maximum step size"
   DOC_ITEM
 Setting the maximum stepsize will avoid passing over very large
 regions  (default is not specified).
+
   END_DOC_ITEM
   TYPE = "double"
   INIT_VALUE = "-1.0"
   SET_EXPR = "(val >= 0.0) ? val : -1.0"
 END_OPTION
 
 OPTION
   NAME = "step limit"
diff --git a/liboctave/LSODE-opts.in b/liboctave/LSODE-opts.in
--- a/liboctave/LSODE-opts.in
+++ b/liboctave/LSODE-opts.in
@@ -20,16 +20,17 @@ CLASS = "LSODE"
 
 INCLUDE = "ODE.h"
 
 OPTION
   NAME = "absolute tolerance"
   DOC_ITEM
 Absolute tolerance.  May be either vector or scalar.  If a vector, it
 must match the dimension of the state vector.
+
   END_DOC_ITEM
   TYPE = "Array<double>"
   SET_ARG_TYPE = "const $TYPE&"
   INIT_BODY
     $OPTVAR.resize (1, 1);
     $OPTVAR(0) = ::sqrt (DBL_EPSILON);
   END_INIT_BODY
   SET_CODE
@@ -54,38 +55,41 @@ parameter may only be a scalar.
 The local error test applied at each integration step is
 
 @example
 @group
   abs (local error in x(i)) <= ...
       rtol * abs (y(i)) + atol(i)
 @end group
 @end example
+
   END_DOC_ITEM
   TYPE = "double"
   INIT_VALUE = "::sqrt (DBL_EPSILON)"
   SET_EXPR = "(val > 0.0) ? val : ::sqrt (DBL_EPSILON)"
 END_OPTION
 
 OPTION
   NAME = "integration method"
   DOC_ITEM
 A string specifying the method of integration to use to solve the ODE
 system.  Valid values are
 
 @table @asis
 @item \"adams\"
 @itemx \"non-stiff\"
 No Jacobian used (even if it is available).
+
 @item \"bdf\"
-@item \"stiff\"
+@itemx \"stiff\"
 Use stiff backward differentiation formula (BDF) method.  If a
 function to compute the Jacobian is not supplied, @code{lsode} will
 compute a finite difference approximation of the Jacobian matrix.
 @end table
+
   END_DOC_ITEM
   TYPE = "std::string"
   SET_ARG_TYPE = "const $TYPE&"
   INIT_VALUE = ""stiff""
   SET_BODY
     if (val == "stiff" || val == "bdf")
       $OPTVAR = "stiff";
     else if (val == "non-stiff" || val == "adams")
@@ -96,49 +100,53 @@ compute a finite difference approximatio
   END_SET_BODY
 END_OPTION
 
 OPTION
   NAME = "initial step size"
   DOC_ITEM
 The step size to be attempted on the first step (default is determined
 automatically).
+
   END_DOC_ITEM
   TYPE = "double"
   INIT_VALUE = "-1.0"
   SET_EXPR = "(val >= 0.0) ? val : -1.0"
 END_OPTION
 
 OPTION
   NAME = "maximum order"
   DOC_ITEM
 Restrict the maximum order of the solution method.  If using the Adams
 method, this option must be between 1 and 12.  Otherwise, it must be
 between 1 and 5, inclusive.
+
   END_DOC_ITEM
   TYPE = "octave_idx_type"
   INIT_VALUE = "-1"
   SET_EXPR = "val"
 END_OPTION
 
 OPTION
   NAME = "maximum step size"
   DOC_ITEM
 Setting the maximum stepsize will avoid passing over very large
 regions  (default is not specified).
+
   END_DOC_ITEM
   TYPE = "double"
   INIT_VALUE = "-1.0"
   SET_EXPR = "(val >= 0.0) ? val : -1.0"
 END_OPTION
 
 OPTION
   NAME = "minimum step size"
   DOC_ITEM
 The minimum absolute step size allowed (default is 0).
+
   END_DOC_ITEM
   TYPE = "double"
   INIT_VALUE = "0.0"
   SET_EXPR = "(val >= 0.0) ? val : 0.0"
 END_OPTION
 
 OPTION
   NAME = "step limit"
diff --git a/liboctave/Quad-opts.in b/liboctave/Quad-opts.in
--- a/liboctave/Quad-opts.in
+++ b/liboctave/Quad-opts.in
@@ -17,48 +17,51 @@
 # <http://www.gnu.org/licenses/>.
 
 CLASS = "Quad"
 
 OPTION
   NAME = "absolute tolerance"
   DOC_ITEM
 Absolute tolerance; may be zero for pure relative error test.
+
   END_DOC_ITEM
   TYPE = "double"
   INIT_VALUE = "::sqrt (DBL_EPSILON)"
   SET_EXPR = "val"
 END_OPTION
 
 OPTION
   NAME = "relative tolerance"
   DOC_ITEM
-Nonnegative relative tolerance.  If the absolute tolerance is zero,
+Non-negative relative tolerance.  If the absolute tolerance is zero,
 the relative tolerance must be greater than or equal to 
 @code{max (50*eps, 0.5e-28)}.
+
   END_DOC_ITEM
   TYPE = "double"
   INIT_VALUE = "::sqrt (DBL_EPSILON)"
   SET_EXPR = "val"
 END_OPTION
 
 OPTION
   NAME = "single precision absolute tolerance"
   DOC_ITEM
 Absolute tolerance for single precision; may be zero for pure relative 
 error test.
+
   END_DOC_ITEM
   TYPE = "float"
   INIT_VALUE = "::sqrt (FLT_EPSILON)"
   SET_EXPR = "val"
 END_OPTION
 
 OPTION
   NAME = "single precision relative tolerance"
   DOC_ITEM
-Nonnegative relative tolerance for single precision.  If the absolute
+Non-negative relative tolerance for single precision.  If the absolute
 tolerance is zero, the relative tolerance must be greater than or equal to 
 @code{max (50*eps, 0.5e-28)}.
   END_DOC_ITEM
   TYPE = "float"
   INIT_VALUE = "::sqrt (FLT_EPSILON)"
   SET_EXPR = "val"
 END_OPTION
diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,8 +1,42 @@
+2010-07-31  Rik <octave@nomad.inbox5.com>
+
+	* DLD-FUNCTIONS/__magick_read__.cc, DLD-FUNCTIONS/__voronoi__.cc,
+	DLD-FUNCTIONS/amd.cc, DLD-FUNCTIONS/balance.cc,
+	DLD-FUNCTIONS/besselj.cc, DLD-FUNCTIONS/betainc.cc,
+	DLD-FUNCTIONS/ccolamd.cc, DLD-FUNCTIONS/cellfun.cc,
+	DLD-FUNCTIONS/chol.cc, DLD-FUNCTIONS/colamd.cc, DLD-FUNCTIONS/conv2.cc,
+	DLD-FUNCTIONS/convhulln.cc, DLD-FUNCTIONS/daspk.cc,
+	DLD-FUNCTIONS/dasrt.cc, DLD-FUNCTIONS/dassl.cc,
+	DLD-FUNCTIONS/dmperm.cc, DLD-FUNCTIONS/dot.cc, DLD-FUNCTIONS/eigs.cc,
+	DLD-FUNCTIONS/fftn.cc, DLD-FUNCTIONS/fftw.cc, DLD-FUNCTIONS/filter.cc,
+	DLD-FUNCTIONS/find.cc, DLD-FUNCTIONS/gammainc.cc, DLD-FUNCTIONS/gcd.cc,
+	DLD-FUNCTIONS/getrusage.cc, DLD-FUNCTIONS/givens.cc,
+	DLD-FUNCTIONS/hess.cc, DLD-FUNCTIONS/hex2num.cc, DLD-FUNCTIONS/inv.cc,
+	DLD-FUNCTIONS/kron.cc, DLD-FUNCTIONS/lookup.cc, DLD-FUNCTIONS/lsode.cc,
+	DLD-FUNCTIONS/lu.cc, DLD-FUNCTIONS/luinc.cc,
+	DLD-FUNCTIONS/matrix_type.cc, DLD-FUNCTIONS/max.cc,
+	DLD-FUNCTIONS/md5sum.cc, DLD-FUNCTIONS/onCleanup.cc,
+	DLD-FUNCTIONS/qr.cc, DLD-FUNCTIONS/quad.cc, DLD-FUNCTIONS/qz.cc,
+	DLD-FUNCTIONS/rand.cc, DLD-FUNCTIONS/regexp.cc, DLD-FUNCTIONS/schur.cc,
+	DLD-FUNCTIONS/sparse.cc, DLD-FUNCTIONS/spparms.cc,
+	DLD-FUNCTIONS/str2double.cc, DLD-FUNCTIONS/strfind.cc,
+	DLD-FUNCTIONS/sub2ind.cc, DLD-FUNCTIONS/svd.cc, DLD-FUNCTIONS/syl.cc,
+	DLD-FUNCTIONS/symbfact.cc, DLD-FUNCTIONS/time.cc,
+	DLD-FUNCTIONS/tril.cc, DLD-FUNCTIONS/typecast.cc,
+	DLD-FUNCTIONS/urlwrite.cc, bitfcns.cc, data.cc, debug.cc, defaults.cc,
+	dirfns.cc, error.cc, file-io.cc, graphics.cc, help.cc, input.cc,
+	load-path.cc, load-save.cc, ls-oct-ascii.cc, mappers.cc, oct-hist.cc,
+	octave.cc, ov-base.cc, ov-cell.cc, ov-class.cc, ov-fcn-handle.cc,
+	ov-fcn-inline.cc, ov-null-mat.cc, ov-range.cc, ov-struct.cc,
+	ov-usr-fcn.cc, pager.cc, pr-output.cc, pt-eval.cc, pt-mat.cc,
+	sighandlers.cc, strfns.cc, symtab.cc, syscalls.cc, sysdep.cc,
+	toplev.cc, utils.cc, variables.cc: Grammarcheck .cc files
+
 2010-07-30  John W. Eaton  <jwe@octave.org>
 
 	* debug.cc (Fdbstack): Improve display.
 
 	* toplev.cc (octave_call_stack::do_goto_frame_relative):
 	Improve message.  Don't display column number.
 
 	* debug.cc (get_file_line): Don't allow eol to be less than bol.
diff --git a/src/DLD-FUNCTIONS/__magick_read__.cc b/src/DLD-FUNCTIONS/__magick_read__.cc
--- a/src/DLD-FUNCTIONS/__magick_read__.cc
+++ b/src/DLD-FUNCTIONS/__magick_read__.cc
@@ -368,21 +368,21 @@ read_images (const std::vector<Magick::I
 
   return retval;
 }
 
 #endif
 
 DEFUN_DLD (__magick_read__, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Function File} {@var{m} =} __magick_read__(@var{fname}, @var{index})\n\
-@deftypefnx{Function File} {[@var{m}, @var{colormap}] =} __magick_read__(@var{fname}, @var{index})\n\
-@deftypefnx{Function File} {[@var{m}, @var{colormap}, @var{alpha}] =} __magick_read__(@var{fname}, @var{index})\n\
-Read images with ImageMagick++.  In general you should not be using this function.\n\
-Instead you should use @code{imread}.\n\
+@deftypefn  {Function File} {@var{m} =} __magick_read__(@var{fname}, @var{index})\n\
+@deftypefnx {Function File} {[@var{m}, @var{colormap}] =} __magick_read__(@var{fname}, @var{index})\n\
+@deftypefnx {Function File} {[@var{m}, @var{colormap}, @var{alpha}] =} __magick_read__(@var{fname}, @var{index})\n\
+Read images with ImageMagick++.  In general you should not be using this\n\
+function.  Instead you should use @code{imread}.\n\
 @seealso{imread}\n\
 @end deftypefn")
 {
   octave_value_list output;
 
 #ifdef HAVE_MAGICK
 
   static bool initialized = false;
@@ -817,20 +817,20 @@ write_image (const std::string& filename
       error ("Magick++ exception: %s", e.what ());
     }
 }
 
 #endif
 
 DEFUN_DLD (__magick_write__, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Function File} {} __magick_write__(@var{fname}, @var{fmt}, @var{img})\n\
+@deftypefn  {Function File} {} __magick_write__(@var{fname}, @var{fmt}, @var{img})\n\
 @deftypefnx {Function File} {} __magick_write__(@var{fname}, @var{fmt}, @var{img}, @var{map})\n\
-Write images with ImageMagick++.  In general you should not be using this function.\n\
-Instead you should use @code{imwrite}.\n\
+Write images with ImageMagick++.  In general you should not be using this\n\
+function.  Instead you should use @code{imwrite}.\n\
 @seealso{imread}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
 #ifdef HAVE_MAGICK
   int nargin = args.length ();
 
diff --git a/src/DLD-FUNCTIONS/__voronoi__.cc b/src/DLD-FUNCTIONS/__voronoi__.cc
--- a/src/DLD-FUNCTIONS/__voronoi__.cc
+++ b/src/DLD-FUNCTIONS/__voronoi__.cc
@@ -50,17 +50,17 @@ extern "C" {
 
 #ifdef NEED_QHULL_VERSION
 char qh_version[] = "__voronoi__.oct 2007-07-24";
 #endif
 #endif
 
 DEFUN_DLD (__voronoi__, args, ,
         "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {@var{tri} =} __voronoi__ (@var{point})\n\
+@deftypefn  {Loadable Function} {@var{tri} =} __voronoi__ (@var{point})\n\
 @deftypefnx {Loadable Function} {@var{tri} =} __voronoi__ (@var{point}, @var{options})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
 #ifdef HAVE_QHULL
 
diff --git a/src/DLD-FUNCTIONS/amd.cc b/src/DLD-FUNCTIONS/amd.cc
--- a/src/DLD-FUNCTIONS/amd.cc
+++ b/src/DLD-FUNCTIONS/amd.cc
@@ -47,17 +47,17 @@ along with Octave; see the file COPYING.
 #ifdef IDX_TYPE_LONG
 #define AMD_NAME(name) amd_l ## name
 #else
 #define AMD_NAME(name) amd ## name
 #endif
 
 DEFUN_DLD (amd, args, nargout,
     "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {@var{p} =} amd (@var{s})\n\
+@deftypefn  {Loadable Function} {@var{p} =} amd (@var{s})\n\
 @deftypefnx {Loadable Function} {@var{p} =} amd (@var{s}, @var{opts})\n\
 \n\
 Returns the approximate minimum degree permutation of a matrix.  This\n\
 permutation such that the Cholesky factorization of @code{@var{s} (@var{p},\n\
 @var{p})} tends to be sparser than the Cholesky factorization of @var{s}\n\
 itself.  @code{amd} is typically faster than @code{symamd} but serves a\n\
 similar purpose.\n\
 \n\
@@ -72,17 +72,17 @@ sqrt (@var{n})} entries, where @var{n} i
 are ignored by @code{amd} during the calculation of the permutation\n\
 The value of dense must be a positive scalar and its default value is 10.0\n\
 \n\
 @item opts.aggressive\n\
 If this value is a non zero scalar, then @code{amd} performs aggressive\n\
 absorption.  The default is not to perform aggressive absorption.\n\
 @end table\n\
 \n\
-The author of the code itself is Timothy A. Davis (davis@@cise.ufl.edu),\n\
+The author of the code itself is Timothy A. Davis @email{davis@@cise.ufl.edu},\n\
 University of Florida (see @url{http://www.cise.ufl.edu/research/sparse/amd}).\n\
 @seealso{symamd, colamd}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
 #ifdef HAVE_AMD
   int nargin = args.length ();
diff --git a/src/DLD-FUNCTIONS/balance.cc b/src/DLD-FUNCTIONS/balance.cc
--- a/src/DLD-FUNCTIONS/balance.cc
+++ b/src/DLD-FUNCTIONS/balance.cc
@@ -44,31 +44,31 @@ along with Octave; see the file COPYING.
 #include "error.h"
 #include "f77-fcn.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "utils.h"
 
 DEFUN_DLD (balance, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {@var{aa} =} balance (@var{a}, @var{opt})\n\
+@deftypefn  {Loadable Function} {@var{aa} =} balance (@var{a}, @var{opt})\n\
 @deftypefnx {Loadable Function} {[@var{dd}, @var{aa}] =} balance (@var{a}, @var{opt})\n\
 @deftypefnx {Loadable Function} {[@var{d}, @var{p}, @var{aa}] =} balance (@var{a}, @var{opt})\n\
 @deftypefnx {Loadable Function} {[@var{cc}, @var{dd}, @var{aa}, @var{bb}] =} balance (@var{a}, @var{b}, @var{opt})\n\
 \n\
 Compute @code{aa = dd \\ a * dd} in which @code{aa} is a matrix whose\n\
 row and column norms are roughly equal in magnitude, and\n\
 @code{dd} = @code{p * d}, in which @code{p} is a permutation\n\
 matrix and @code{d} is a diagonal matrix of powers of two.  This allows\n\
 the equilibration to be computed without round-off.  Results of\n\
 eigenvalue calculation are typically improved by balancing first.\n\
 \n\
 If two output values are requested, @code{balance} returns \n\
 the diagonal @code{d} and the permutation @code{p} separately as vectors.  \n\
-In this case, @code{dd = eye(n)(:,p) * diag (d)}, where @code{n} is the matrix \n\
+In this case, @code{dd = eye(n)(:,p) * diag (d)}, where @code{n} is the matrix\n\
 size.  \n\
 \n\
 If four output values are requested, compute @code{aa = cc*a*dd} and\n\
 @code{bb = cc*b*dd)}, in which @code{aa} and @code{bb} have non-zero\n\
 elements of approximately the same magnitude and @code{cc} and @code{dd}\n\
 are permuted diagonal matrices as in @code{dd} for the algebraic\n\
 eigenvalue problem.\n\
 \n\
diff --git a/src/DLD-FUNCTIONS/besselj.cc b/src/DLD-FUNCTIONS/besselj.cc
--- a/src/DLD-FUNCTIONS/besselj.cc
+++ b/src/DLD-FUNCTIONS/besselj.cc
@@ -374,36 +374,42 @@ do_bessel (enum bessel_type type, const 
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN_DLD (besselj, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {[@var{j}, @var{ierr}] =} besselj (@var{alpha}, @var{x}, @var{opt})\n\
+@deftypefn  {Loadable Function} {[@var{j}, @var{ierr}] =} besselj (@var{alpha}, @var{x}, @var{opt})\n\
 @deftypefnx {Loadable Function} {[@var{y}, @var{ierr}] =} bessely (@var{alpha}, @var{x}, @var{opt})\n\
 @deftypefnx {Loadable Function} {[@var{i}, @var{ierr}] =} besseli (@var{alpha}, @var{x}, @var{opt})\n\
 @deftypefnx {Loadable Function} {[@var{k}, @var{ierr}] =} besselk (@var{alpha}, @var{x}, @var{opt})\n\
 @deftypefnx {Loadable Function} {[@var{h}, @var{ierr}] =} besselh (@var{alpha}, @var{k}, @var{x}, @var{opt})\n\
 Compute Bessel or Hankel functions of various kinds:\n\
 \n\
 @table @code\n\
 @item besselj\n\
 Bessel functions of the first kind.  If the argument @var{opt} is supplied, \n\
 the result is multiplied by @code{exp(-abs(imag(x)))}.\n\
+\n\
 @item bessely\n\
 Bessel functions of the second kind.  If the argument @var{opt} is supplied,\n\
 the result is multiplied by @code{exp(-abs(imag(x)))}.\n\
+\n\
 @item besseli\n\
-Modified Bessel functions of the first kind.  If the argument @var{opt} is supplied,\n\
-the result is multiplied by @code{exp(-abs(real(x)))}.\n\
+\n\
+Modified Bessel functions of the first kind.  If the argument @var{opt} is\n\
+supplied, the result is multiplied by @code{exp(-abs(real(x)))}.\n\
+\n\
 @item besselk\n\
-Modified Bessel functions of the second kind.  If the argument @var{opt} is supplied,\n\
-the result is multiplied by @code{exp(x)}.\n\
+\n\
+Modified Bessel functions of the second kind.  If the argument @var{opt} is\n\
+supplied, the result is multiplied by @code{exp(x)}.\n\
+\n\
 @item besselh\n\
 Compute Hankel functions of the first (@var{k} = 1) or second (@var{k}\n\
 = 2) kind.  If the argument @var{opt} is supplied, the result is multiplied by\n\
 @code{exp (-I*@var{x})} for @var{k} = 1 or @code{exp (I*@var{x})} for\n\
 @var{k} = 2.\n\
 @end table\n\
 \n\
 If @var{alpha} is a scalar, the result is the same size as @var{x}.\n\
@@ -417,25 +423,30 @@ The value of @var{alpha} must be real.  
 complex.\n\
 \n\
 If requested, @var{ierr} contains the following status information\n\
 and is the same size as the result.\n\
 \n\
 @enumerate 0\n\
 @item\n\
 Normal return.\n\
+\n\
 @item\n\
 Input error, return @code{NaN}.\n\
+\n\
 @item\n\
 Overflow, return @code{Inf}.\n\
+\n\
 @item\n\
 Loss of significance by argument reduction results in less than\n\
 half of machine accuracy.\n\
+\n\
 @item\n\
 Complete loss of significance by argument reduction, return @code{NaN}.\n\
+\n\
 @item\n\
 Error---no computation, algorithm termination condition not met,\n\
 return @code{NaN}.\n\
 @end enumerate\n\
 @end deftypefn")
 {
   return do_bessel (BESSEL_J, "besselj", args, nargout);
 }
@@ -534,25 +545,30 @@ The function call @code{airy (@var{z})} 
 The result is the same size as @var{z}.\n\
 \n\
 If requested, @var{ierr} contains the following status information and\n\
 is the same size as the result.\n\
 \n\
 @enumerate 0\n\
 @item\n\
 Normal return.\n\
+\n\
 @item\n\
 Input error, return @code{NaN}.\n\
+\n\
 @item\n\
 Overflow, return @code{Inf}.\n\
+\n\
 @item\n\
 Loss of significance by argument reduction results in less than half\n\
  of machine accuracy.\n\
+\n\
 @item\n\
 Complete loss of significance by argument reduction, return @code{NaN}.\n\
+\n\
 @item\n\
 Error---no computation, algorithm termination condition not met,\n\
 return @code{NaN}.\n\
 @end enumerate\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
diff --git a/src/DLD-FUNCTIONS/betainc.cc b/src/DLD-FUNCTIONS/betainc.cc
--- a/src/DLD-FUNCTIONS/betainc.cc
+++ b/src/DLD-FUNCTIONS/betainc.cc
@@ -41,22 +41,25 @@ Return the incomplete Beta function,\n\
 $$\n\
  \\beta (x, a, b) = B (a, b)^{-1} \\int_0^x t^{(a-z)} (1-t)^{(b-1)} dt.\n\
 $$\n\
 @end tex\n\
 @ifnottex\n\
 \n\
 @c Set example in small font to prevent overfull line\n\
 @smallexample\n\
+@group\n\
                                       x\n\
                                      /\n\
 betainc (x, a, b) = beta (a, b)^(-1) | t^(a-1) (1-t)^(b-1) dt.\n\
                                      /\n\
                                   t=0\n\
+@end group\n\
 @end smallexample\n\
+\n\
 @end ifnottex\n\
 \n\
 If x has more than one component, both @var{a} and @var{b} must be\n\
 scalars.  If @var{x} is a scalar, @var{a} and @var{b} must be of\n\
 compatible dimensions.\n\
 @end deftypefn")
 {
   octave_value retval;
diff --git a/src/DLD-FUNCTIONS/ccolamd.cc b/src/DLD-FUNCTIONS/ccolamd.cc
--- a/src/DLD-FUNCTIONS/ccolamd.cc
+++ b/src/DLD-FUNCTIONS/ccolamd.cc
@@ -48,27 +48,29 @@ along with Octave; see the file COPYING.
 #define CSYMAMD_NAME(name) csymamd_l ## name
 #else
 #define CCOLAMD_NAME(name) ccolamd ## name
 #define CSYMAMD_NAME(name) csymamd ## name
 #endif
 
 DEFUN_DLD (ccolamd, args, nargout,
     "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {@var{p} =} ccolamd (@var{s})\n\
+@deftypefn  {Loadable Function} {@var{p} =} ccolamd (@var{s})\n\
 @deftypefnx {Loadable Function} {@var{p} =} ccolamd (@var{s}, @var{knobs})\n\
 @deftypefnx {Loadable Function} {@var{p} =} ccolamd (@var{s}, @var{knobs}, @var{cmember})\n\
 @deftypefnx {Loadable Function} {[@var{p}, @var{stats}] =} ccolamd (@dots{})\n\
 \n\
-Constrained column approximate minimum degree permutation.  @code{@var{p} =\n\
-ccolamd (@var{s})} returns the column approximate minimum degree permutation\n\
-vector for the sparse matrix @var{s}.  For a non-symmetric matrix @var{s},\n\
+Constrained column approximate minimum degree permutation.\n\
+@code{@var{p} = ccolamd (@var{s})} returns the column approximate minimum degree\n\
+permutation vector for the sparse matrix @var{s}.  For a non-symmetric matrix\n\
+@var{s},\n\
 @code{@var{s} (:, @var{p})} tends to have sparser LU factors than @var{s}.\n\
 @code{chol (@var{s} (:, @var{p})' * @var{s} (:, @var{p}))} also tends to be\n\
-sparser than @code{chol (@var{s}' * @var{s})}.  @code{@var{p} = ccolamd\n\
+sparser than @code{chol (@var{s}' * @var{s})}.\n\
+@code{@var{p} = ccolamd\n\
 (@var{s}, 1)} optimizes the ordering for @code{lu (@var{s} (:, @var{p}))}.\n\
 The ordering is followed by a column elimination tree post-ordering.\n\
 \n\
 @var{knobs} is an optional one- to five-element input vector, with a default\n\
 value of @code{[0 10 10 1 0]} if not present or empty.  Entries not present\n\
 are set to their defaults.\n\
 \n\
 @table @code\n\
@@ -94,45 +96,45 @@ if nonzero, statistics and knobs are pri
 \n\
 @end table\n\
 \n\
 @var{cmember} is an optional vector of length n.  It defines the constraints\n\
 on the column ordering.  If @code{@var{cmember} (j) = @var{c}}, then column\n\
 @var{j} is in constraint set @var{c} (@var{c} must be in the range 1 to\n\
 @var{n}).  In the output permutation @var{p}, all columns in set 1 appear\n\
 first, followed by all columns in set 2, and so on.  @code{@var{cmember} =\n\
-ones(1,n)} if not present or empty.  @code{ccolamd (@var{s}, [], 1 :\n\
-@var{n})} returns @code{1 : @var{n}}\n\
+ones(1,n)} if not present or empty.\n\
+@code{ccolamd (@var{s}, [], 1 : @var{n})} returns @code{1 : @var{n}}\n\
 \n\
-@code{@var{p} = ccolamd (@var{s})} is about the same as @code{@var{p} =\n\
-colamd (@var{s})}.  @var{knobs} and its default values differ.  @code{colamd}\n\
-always does aggressive absorption, and it finds an ordering suitable for\n\
-both @code{lu (@var{s} (:, @var{p}))} and @code{chol (@var{S} (:, @var{p})'\n\
-* @var{s} (:, @var{p}))}; it cannot optimize its ordering for\n\
+@code{@var{p} = ccolamd (@var{s})} is about the same as\n\
+@code{@var{p} = colamd (@var{s})}.  @var{knobs} and its default values differ.  \n\
+@code{colamd} always does aggressive absorption, and it finds an ordering\n\
+suitable for both @code{lu (@var{s} (:, @var{p}))} and @code{chol (@var{S} (:,\n\
+@var{p})' * @var{s} (:, @var{p}))}; it cannot optimize its ordering for\n\
 @code{lu (@var{s} (:, @var{p}))} to the extent that\n\
 @code{ccolamd (@var{s}, 1)} can.\n\
 \n\
 @var{stats} is an optional 20-element output vector that provides data\n\
 about the ordering and the validity of the input matrix @var{s}.  Ordering\n\
 statistics are in @code{@var{stats} (1 : 3)}.  @code{@var{stats} (1)} and\n\
 @code{@var{stats} (2)} are the number of dense or empty rows and columns\n\
-ignored by CCOLAMD and @code{@var{stats} (3)} is the number of garbage\n\
-collections performed on the internal data structure used by CCOLAMD\n\
+ignored by @sc{ccolamd} and @code{@var{stats} (3)} is the number of garbage\n\
+collections performed on the internal data structure used by @sc{ccolamd}\n\
 (roughly of size @code{2.2 * nnz (@var{s}) + 4 * @var{m} + 7 * @var{n}}\n\
 integers).\n\
 \n\
 @code{@var{stats} (4 : 7)} provide information if CCOLAMD was able to\n\
 continue.  The matrix is OK if @code{@var{stats} (4)} is zero, or 1 if\n\
 invalid.  @code{@var{stats} (5)} is the rightmost column index that is\n\
 unsorted or contains duplicate entries, or zero if no such column exists.\n\
 @code{@var{stats} (6)} is the last seen duplicate or out-of-order row\n\
 index in the column index given by @code{@var{stats} (5)}, or zero if no\n\
 such row index exists.  @code{@var{stats} (7)} is the number of duplicate\n\
 or out-of-order row indices.  @code{@var{stats} (8 : 20)} is always zero in\n\
-the current version of CCOLAMD (reserved for future use).\n\
+the current version of @sc{ccolamd} (reserved for future use).\n\
 \n\
 The authors of the code itself are S. Larimore, T. Davis (Univ. of Florida)\n\
 and S. Rajamanickam in collaboration with J. Bilbert and E. Ng.  Supported\n\
 by the National Science Foundation (DMS-9504974, DMS-9803599, CCR-0203270),\n\
 and a grant from Sandia National Lab.  See\n\
 @url{http://www.cise.ufl.edu/research/sparse} for ccolamd, csymamd, amd,\n\
 colamd, symamd, and other related orderings.\n\
 @seealso{colamd, csymamd}\n\
@@ -328,17 +330,17 @@ colamd, symamd, and other related orderi
 
 #endif
 
   return retval;
 }
 
 DEFUN_DLD (csymamd, args, nargout,
     "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {@var{p} =} csymamd (@var{s})\n\
+@deftypefn  {Loadable Function} {@var{p} =} csymamd (@var{s})\n\
 @deftypefnx {Loadable Function} {@var{p} =} csymamd (@var{s}, @var{knobs})\n\
 @deftypefnx {Loadable Function} {@var{p} =} csymamd (@var{s}, @var{knobs}, @var{cmember})\n\
 @deftypefnx {Loadable Function} {[@var{p}, @var{stats}] =} csymamd (@dots{})\n\
 \n\
 For a symmetric positive definite matrix @var{s}, returns the permutation\n\
 vector @var{p} such that @code{@var{s}(@var{p},@var{p})} tends to have a\n\
 sparser Cholesky factor than @var{s}.  Sometimes @code{csymamd} works well\n\
 for symmetric indefinite matrices too.  The matrix @var{s} is assumed to\n\
@@ -377,17 +379,17 @@ symamd(@var{s})}.  @var{knobs} and its d
 @code{@var{stats} (4:7)} provide information if CCOLAMD was able to\n\
 continue.  The matrix is OK if @code{@var{stats} (4)} is zero, or 1 if\n\
 invalid.  @code{@var{stats} (5)} is the rightmost column index that is\n\
 unsorted or contains duplicate entries, or zero if no such column exists.\n\
 @code{@var{stats} (6)} is the last seen duplicate or out-of-order row\n\
 index in the column index given by @code{@var{stats} (5)}, or zero if no\n\
 such row index exists.  @code{@var{stats} (7)} is the number of duplicate\n\
 or out-of-order row indices.  @code{@var{stats} (8:20)} is always zero in\n\
-the current version of CCOLAMD (reserved for future use).\n\
+the current version of @sc{ccolamd} (reserved for future use).\n\
 \n\
 The authors of the code itself are S. Larimore, T. Davis (Uni of Florida)\n\
 and S. Rajamanickam in collaboration with J. Bilbert and E. Ng.  Supported\n\
 by the National Science Foundation (DMS-9504974, DMS-9803599, CCR-0203270),\n\
 and a grant from Sandia National Lab.  See\n\
 @url{http://www.cise.ufl.edu/research/sparse} for ccolamd, csymamd, amd,\n\
 colamd, symamd, and other related orderings.\n\
 @seealso{symamd, ccolamd}\n\
diff --git a/src/DLD-FUNCTIONS/cellfun.cc b/src/DLD-FUNCTIONS/cellfun.cc
--- a/src/DLD-FUNCTIONS/cellfun.cc
+++ b/src/DLD-FUNCTIONS/cellfun.cc
@@ -104,74 +104,81 @@ DEFUN_DLD (cellfun, args, nargout,
 \n\
 Evaluate the function named @var{name} on the elements of the cell array\n\
 @var{c}.  Elements in @var{c} are passed on to the named function\n\
 individually.  The function @var{name} can be one of the functions\n\
 \n\
 @table @code\n\
 @item isempty\n\
 Return 1 for empty elements.\n\
+\n\
 @item islogical\n\
 Return 1 for logical elements.\n\
+\n\
 @item isreal\n\
 Return 1 for real elements.\n\
+\n\
 @item length\n\
 Return a vector of the lengths of cell elements.\n\
+\n\
 @item ndims\n\
 Return the number of dimensions of each element.\n\
+\n\
 @item prodofsize\n\
 Return the product of dimensions of each element.\n\
+\n\
 @item size\n\
 Return the size along the @var{k}-th dimension.\n\
+\n\
 @item isclass\n\
 Return 1 for elements of @var{class}.\n\
 @end table\n\
 \n\
 Additionally, @code{cellfun} accepts an arbitrary function @var{func}\n\
 in the form of an inline function, function handle, or the name of a\n\
 function (in a character string).  In the case of a character string\n\
 argument, the function must accept a single argument named @var{x}, and\n\
 it must return a string value.  The function can take one or more arguments,\n\
 with the inputs arguments given by @var{c}, @var{d}, etc.  Equally the\n\
-function can return one or more output arguments.  For example\n\
+function can return one or more output arguments.  For example:\n\
 \n\
 @example\n\
 @group\n\
 cellfun (@@atan2, @{1, 0@}, @{0, 1@})\n\
      @result{}ans = [1.57080   0.00000]\n\
 @end group\n\
 @end example\n\
 \n\
 The number of output arguments of @code{cellfun} matches the number of output\n\
-arguments of the function.  The outputs of the function will be collected into the\n\
-output arguments of @code{cellfun} like this:\n\
+arguments of the function.  The outputs of the function will be collected into\n\
+the output arguments of @code{cellfun} like this:\n\
 \n\
 @example\n\
 @group\n\
 function [a, b] = twoouts (x)\n\
   a = x;\n\
   b = x*x;\n\
 endfunction\n\
 [aa, bb] = cellfun(@@twoouts, @{1, 2, 3@})\n\
      @result{}\n\
         aa = \n\
            1 2 3\n\
         bb =\n\
            1 4 9\n\
 @end group\n\
 @end example\n\
+\n\
 Note that per default the output argument(s) are arrays of the same size as the\n\
-input arguments.\n\
-Input arguments that are singleton (1x1) cells will be automatically expanded\n\
-to the size of the other arguments.\n\
+input arguments.  Input arguments that are singleton (1x1) cells will be\n\
+automatically expanded to the size of the other arguments.\n\
 \n\
 If the parameter 'UniformOutput' is set to true (the default), then the function\n\
-must return scalars which will be concatenated into the\n\
-return array(s).  If 'UniformOutput' is false, the outputs are concatenated into\n\
-a cell array (or cell arrays).  For example\n\
+must return scalars which will be concatenated into the return array(s).  If\n\
+'UniformOutput' is false, the outputs are concatenated into a cell array (or\n\
+cell arrays).  For example\n\
 \n\
 @example\n\
 @group\n\
 cellfun (\"tolower(x)\", @{\"Foo\", \"Bar\", \"FooBar\"@},\n\
          \"UniformOutput\",false)\n\
 @result{} ans = @{\"foo\", \"bar\", \"foobar\"@}\n\
 @end group\n\
 @end example\n\
@@ -182,17 +189,17 @@ call in case @var{func} generates an err
 @example\n\
 function [@dots{}] = errfunc (@var{s}, @dots{})\n\
 @end example\n\
 \n\
 where there is an additional input argument to @var{errfunc} relative to\n\
 @var{func}, given by @var{s}.  This is a structure with the elements\n\
 'identifier', 'message' and 'index', giving respectively the error\n\
 identifier, the error message, and the index into the input arguments\n\
-of the element that caused the error.  For example\n\
+of the element that caused the error.  For example:\n\
 \n\
 @example\n\
 @group\n\
 function y = foo (s, x), y = NaN; endfunction\n\
 cellfun (@@factorial, @{-1,2@},'ErrorHandler',@@foo)\n\
 @result{} ans = [NaN 2]\n\
 @end group\n\
 @end example\n\
@@ -1276,17 +1283,17 @@ do_mat2cell (octave_value& a, const Arra
       rdv.increment_index (ridx);
     }
 
   return retval;
 }
 
 DEFUN_DLD (mat2cell, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {@var{b} =} mat2cell (@var{a}, @var{m}, @var{n})\n\
+@deftypefn  {Loadable Function} {@var{b} =} mat2cell (@var{a}, @var{m}, @var{n})\n\
 @deftypefnx {Loadable Function} {@var{b} =} mat2cell (@var{a}, @var{d1}, @var{d2}, @dots{})\n\
 @deftypefnx {Loadable Function} {@var{b} =} mat2cell (@var{a}, @var{r})\n\
 Convert the matrix @var{a} to a cell array.  If @var{a} is 2-D, then\n\
 it is required that @code{sum (@var{m}) == size (@var{a}, 1)} and\n\
 @code{sum (@var{n}) == size (@var{a}, 2)}.  Similarly, if @var{a} is\n\
 a multi-dimensional and the number of dimensional arguments is equal\n\
 to the dimensions of @var{a}, then it is required that @code{sum (@var{di})\n\
 == size (@var{a}, i)}.\n\
@@ -1448,19 +1455,19 @@ do_cellslices_nda (const NDA& array,
     }
 
   return retval;
 }
 
 DEFUN_DLD (cellslices, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{sl} =} cellslices (@var{x}, @var{lb}, @var{ub}, @var{dim})\n\
-Given an array @var{x}, this function produces a cell array of slices from the array\n\
-determined by the index vectors @var{lb}, @var{ub}, for lower and upper bounds, respectively.\n\
-In other words, it is equivalent to the following code:\n\
+Given an array @var{x}, this function produces a cell array of slices from the\n\
+array determined by the index vectors @var{lb}, @var{ub}, for lower and upper\n\
+bounds, respectively.  In other words, it is equivalent to the following code:\n\
 \n\
 @example\n\
 @group\n\
 n = length (lb);\n\
 sl = cell (1, n);\n\
 for i = 1:length (lb)\n\
   sl@{i@} = x(:,@dots{},lb(i):ub(i),@dots{},:);\n\
 endfor\n\
diff --git a/src/DLD-FUNCTIONS/chol.cc b/src/DLD-FUNCTIONS/chol.cc
--- a/src/DLD-FUNCTIONS/chol.cc
+++ b/src/DLD-FUNCTIONS/chol.cc
@@ -58,32 +58,33 @@ static octave_value
 get_chol_l (const CHOLT& fact)
 {
   return octave_value (fact.chol_matrix ().transpose (), 
                        MatrixType (MatrixType::Lower));
 }
 
 DEFUN_DLD (chol, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {@var{r} =} chol (@var{a})\n\
+@deftypefn  {Loadable Function} {@var{r} =} chol (@var{a})\n\
 @deftypefnx {Loadable Function} {[@var{r}, @var{p}] =} chol (@var{a})\n\
 @deftypefnx {Loadable Function} {[@var{r}, @var{p}, @var{q}] =} chol (@var{s})\n\
 @deftypefnx {Loadable Function} {[@var{r}, @var{p}, @var{q}] =} chol (@var{s}, 'vector')\n\
 @deftypefnx {Loadable Function} {[@var{l}, @dots{}] =} chol (@dots{}, 'lower')\n\
 @cindex Cholesky factorization\n\
 Compute the Cholesky factor, @var{r}, of the symmetric positive definite\n\
 matrix @var{a}, where\n\
 @tex\n\
 $ R^T R = A $.\n\
 @end tex\n\
 @ifnottex\n\
 \n\
 @example\n\
 @var{r}' * @var{r} = @var{a}.\n\
 @end example\n\
+\n\
 @end ifnottex\n\
 \n\
 Called with one output argument @code{chol} fails if @var{a} or @var{s} is\n\
 not positive definite.  With two or more output arguments @var{p} flags\n\
 whether the matrix was positive definite and @code{chol} does not fail.  A\n\
 zero value indicated that the matrix was positive definite and the @var{r}\n\
 gives the factorization, and @var{p} will have a positive value otherwise.\n\
 \n\
@@ -93,41 +94,44 @@ is the factorization of @code{@var{a}(@v
 @tex\n\
 $ R^T R = Q^T A Q$.\n\
 @end tex\n\
 @ifnottex\n\
 \n\
 @example\n\
 @var{r}' * @var{r} = @var{q}' * @var{a} * @var{q}.\n\
 @end example\n\
+\n\
 @end ifnottex\n\
 \n\
 The sparsity preserving permutation is generally returned as a matrix.\n\
 However, given the flag 'vector', @var{q} will be returned as a vector\n\
 such that\n\
 @tex\n\
 $ R^T R = A (Q, Q)$.\n\
 @end tex\n\
 @ifnottex\n\
 \n\
 @example\n\
 @var{r}' * @var{r} = a (@var{q}, @var{q}).\n\
 @end example\n\
+\n\
 @end ifnottex\n\
 \n\
 Called with either a sparse or full matrix and using the 'lower' flag,\n\
 @code{chol} returns the lower triangular factorization such that\n\
 @tex\n\
 $ L L^T = A $.\n\
 @end tex\n\
 @ifnottex\n\
 \n\
 @example\n\
 @var{l} * @var{l}' = @var{a}.\n\
 @end example\n\
+\n\
 @end ifnottex\n\
 \n\
 In general the lower triangular factorization is significantly faster for\n\
 sparse matrices.\n\
 @seealso{cholinv, chol2inv}\n\
 @end deftypefn")
 {
   octave_value_list retval;
@@ -593,25 +597,28 @@ DEFUN_DLD (cholupdate, args, nargout,
 @deftypefn {Loadable Function} {[@var{R1}, @var{info}] =} cholupdate (@var{R}, @var{u}, @var{op})\n\
 Update or downdate a Cholesky factorization.  Given an upper triangular\n\
 matrix @var{R} and a column vector @var{u}, attempt to determine another\n\
 upper triangular matrix @var{R1} such that\n\
 @itemize @bullet\n\
 @item\n\
 @var{R1}'*@var{R1} = @var{R}'*@var{R} + @var{u}*@var{u}'\n\
 if @var{op} is \"+\"\n\
+\n\
 @item\n\
 @var{R1}'*@var{R1} = @var{R}'*@var{R} - @var{u}*@var{u}'\n\
 if @var{op} is \"-\"\n\
 @end itemize\n\
 \n\
 If @var{op} is \"-\", @var{info} is set to\n\
 @itemize\n\
 @item 0 if the downdate was successful,\n\
+\n\
 @item 1 if @var{R}'*@var{R} - @var{u}*@var{u}' is not positive definite,\n\
+\n\
 @item 2 if @var{R} is singular.\n\
 @end itemize\n\
 \n\
 If @var{info} is not present, an error message is printed in cases 1 and 2.\n\
 @seealso{chol, qrupdate}\n\
 @end deftypefn")
 {
   octave_idx_type nargin = args.length ();
@@ -803,25 +810,27 @@ If @var{info} is not present, an error m
 %! 
 %! assert(norm(triu(R1)-R1,Inf) == 0)
 %! assert(norm(R1 - R,Inf) < 2e1*eps('single'))
 */
 
 DEFUN_DLD (cholinsert, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {[@var{R1}, @var{info}] =} cholinsert (@var{R}, @var{j}, @var{u})\n\
-Given a Cholesky@tie{}factorization of a real symmetric or complex hermitian\n\
-positive definite matrix @w{@var{A} = @var{R}'*@var{R}}, @var{R}@tie{}upper triangular,\n\
-return the Cholesky@tie{}factorization of\n\
+Given a Cholesky@tie{}factorization of a real symmetric or complex Hermitian\n\
+positive definite matrix @w{@var{A} = @var{R}'*@var{R}}, @var{R}@tie{}upper\n\
+triangular, return the Cholesky@tie{}factorization of\n\
 @var{A1}, where @w{A1(p,p) = A}, @w{A1(:,j) = A1(j,:)' = u} and\n\
 @w{p = [1:j-1,j+1:n+1]}.  @w{u(j)} should be positive.\n\
 On return, @var{info} is set to\n\
 @itemize\n\
 @item 0 if the insertion was successful,\n\
+\n\
 @item 1 if @var{A1} is not positive definite,\n\
+\n\
 @item 2 if @var{R} is singular.\n\
 @end itemize\n\
 \n\
 If @var{info} is not present, an error message is printed in cases 1 and 2.\n\
 @seealso{chol, cholupdate, choldelete}\n\
 @end deftypefn")
 {
   octave_idx_type nargin = args.length ();
@@ -987,19 +996,20 @@ If @var{info} is not present, an error m
 %! assert(norm(triu(R1)-R1,Inf) == 0)
 %! assert(norm(A1(p,p) - single(Ac),Inf) < 2e1*eps('single'))
 %! 
 */
 
 DEFUN_DLD (choldelete, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{R1} =} choldelete (@var{R}, @var{j})\n\
-Given a Cholesky@tie{}factorization of a real symmetric or complex hermitian\n\
-positive definite matrix @w{@var{A} = @var{R}'*@var{R}}, @var{R}@tie{}upper triangular,\n\
-return the Cholesky@tie{}factorization of @w{A(p,p)}, where @w{p = [1:j-1,j+1:n+1]}.\n\
+Given a Cholesky@tie{}factorization of a real symmetric or complex Hermitian\n\
+positive definite matrix @w{@var{A} = @var{R}'*@var{R}}, @var{R}@tie{}upper\n\
+triangular, return the Cholesky@tie{}factorization of @w{A(p,p)}, where @w{p =\n\
+[1:j-1,j+1:n+1]}.\n\
 @seealso{chol, cholupdate, cholinsert}\n\
 @end deftypefn")
 {
   octave_idx_type nargin = args.length ();
 
   octave_value_list retval;
 
   if (nargin != 2)
@@ -1119,19 +1129,19 @@ return the Cholesky@tie{}factorization o
 %! 
 %! assert(norm(triu(R1)-R1,Inf) == 0)
 %! assert(norm(R1'*R1 - single(Ac(p,p)),Inf) < 1e1*eps('single'))
 */
 
 DEFUN_DLD (cholshift, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{R1} =} cholshift (@var{R}, @var{i}, @var{j})\n\
-Given a Cholesky@tie{}factorization of a real symmetric or complex hermitian\n\
-positive definite matrix @w{@var{A} = @var{R}'*@var{R}}, @var{R}@tie{}upper triangular,\n\
-return the Cholesky@tie{}factorization of\n\
+Given a Cholesky@tie{}factorization of a real symmetric or complex Hermitian\n\
+positive definite matrix @w{@var{A} = @var{R}'*@var{R}}, @var{R}@tie{}upper\n\
+triangular, return the Cholesky@tie{}factorization of\n\
 @w{@var{A}(p,p)}, where @w{p} is the permutation @*\n\
 @code{p = [1:i-1, shift(i:j, 1), j+1:n]} if @w{@var{i} < @var{j}} @*\n\
  or @*\n\
 @code{p = [1:j-1, shift(j:i,-1), i+1:n]} if @w{@var{j} < @var{i}}.  @*\n\
 \n\
 @seealso{chol, cholinsert, choldelete}\n\
 @end deftypefn")
 {
diff --git a/src/DLD-FUNCTIONS/colamd.cc b/src/DLD-FUNCTIONS/colamd.cc
--- a/src/DLD-FUNCTIONS/colamd.cc
+++ b/src/DLD-FUNCTIONS/colamd.cc
@@ -205,24 +205,25 @@ coletree (const octave_idx_type *ridx, c
               root[cset] = col;
             }
         }
     }
 }
 
 DEFUN_DLD (colamd, args, nargout,
     "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {@var{p} =} colamd (@var{s})\n\
+@deftypefn  {Loadable Function} {@var{p} =} colamd (@var{s})\n\
 @deftypefnx {Loadable Function} {@var{p} =} colamd (@var{s}, @var{knobs})\n\
 @deftypefnx {Loadable Function} {[@var{p}, @var{stats}] =} colamd (@var{s})\n\
 @deftypefnx {Loadable Function} {[@var{p}, @var{stats}] =} colamd (@var{s}, @var{knobs})\n\
 \n\
-Column approximate minimum degree permutation.  @code{@var{p} = colamd\n\
-(@var{s})} returns the column approximate minimum degree permutation\n\
-vector for the sparse matrix @var{s}.  For a non-symmetric matrix @var{s},\n\
+Column approximate minimum degree permutation.\n\
+@code{@var{p} = colamd (@var{s})} returns the column approximate minimum degree\n\
+permutation vector for the sparse matrix @var{s}.  For a non-symmetric matrix\n\
+@var{s},\n\
 @code{@var{s} (:,@var{p})} tends to have sparser LU factors than @var{s}.\n\
 The Cholesky factorization of @code{@var{s} (:,@var{p})' * @var{s}\n\
 (:,@var{p})} also tends to be sparser than that of @code{@var{s}' *\n\
 @var{s}}.\n\
 \n\
 @var{knobs} is an optional one- to three-element input vector.  If @var{s} is\n\
 m-by-n, then rows with more than @code{max(16,@var{knobs}(1)*sqrt(n))} entries\n\
 are ignored.  Columns with more than @code{max(16,knobs(2)*sqrt(min(m,n)))}\n\
@@ -232,49 +233,49 @@ if @code{@var{knobs} (1)} and @code{@var
 If @code{@var{knobs} (3)} is nonzero, @var{stats} and @var{knobs} are\n\
 printed.  The default is @code{@var{knobs} = [10 10 0]}.  Note that\n\
 @var{knobs} differs from earlier versions of colamd\n\
 \n\
 @var{stats} is an optional 20-element output vector that provides data\n\
 about the ordering and the validity of the input matrix @var{s}.  Ordering\n\
 statistics are in @code{@var{stats} (1:3)}.  @code{@var{stats} (1)} and\n\
 @code{@var{stats} (2)} are the number of dense or empty rows and columns\n\
-ignored by COLAMD and @code{@var{stats} (3)} is the number of garbage\n\
-collections performed on the internal data structure used by COLAMD\n\
+ignored by @sc{colamd} and @code{@var{stats} (3)} is the number of garbage\n\
+collections performed on the internal data structure used by @sc{colamd}\n\
 (roughly of size @code{2.2 * nnz(@var{s}) + 4 * @var{m} + 7 * @var{n}}\n\
 integers).\n\
 \n\
 Octave built-in functions are intended to generate valid sparse matrices,\n\
 with no duplicate entries, with ascending row indices of the nonzeros\n\
 in each column, with a non-negative number of entries in each column (!)\n\
-and so on.  If a matrix is invalid, then COLAMD may or may not be able\n\
+and so on.  If a matrix is invalid, then @sc{colamd} may or may not be able\n\
 to continue.  If there are duplicate entries (a row index appears two or\n\
 more times in the same column) or if the row indices in a column are out\n\
-of order, then COLAMD can correct these errors by ignoring the duplicate\n\
+of order, then @sc{colamd} can correct these errors by ignoring the duplicate\n\
 entries and sorting each column of its internal copy of the matrix\n\
 @var{s} (the input matrix @var{s} is not repaired, however).  If a matrix\n\
-is invalid in other ways then COLAMD cannot continue, an error message is\n\
+is invalid in other ways then @sc{colamd} cannot continue, an error message is\n\
 printed, and no output arguments (@var{p} or @var{stats}) are returned.\n\
-COLAMD is thus a simple way to check a sparse matrix to see if it's\n\
+@sc{colamd} is thus a simple way to check a sparse matrix to see if it's\n\
 valid.\n\
 \n\
 @code{@var{stats} (4:7)} provide information if COLAMD was able to\n\
 continue.  The matrix is OK if @code{@var{stats} (4)} is zero, or 1 if\n\
 invalid.  @code{@var{stats} (5)} is the rightmost column index that is\n\
 unsorted or contains duplicate entries, or zero if no such column exists.\n\
 @code{@var{stats} (6)} is the last seen duplicate or out-of-order row\n\
 index in the column index given by @code{@var{stats} (5)}, or zero if no\n\
 such row index exists.  @code{@var{stats} (7)} is the number of duplicate\n\
 or out-of-order row indices.  @code{@var{stats} (8:20)} is always zero in\n\
-the current version of COLAMD (reserved for future use).\n\
+the current version of @sc{colamd} (reserved for future use).\n\
 \n\
 The ordering is followed by a column elimination tree post-ordering.\n\
 \n\
 The authors of the code itself are Stefan I. Larimore and Timothy A.\n\
-Davis (davis@@cise.ufl.edu), University of Florida.  The algorithm was\n\
+Davis @email{davis@@cise.ufl.edu}, University of Florida.  The algorithm was\n\
 developed in collaboration with John Gilbert, Xerox PARC, and Esmond\n\
 Ng, Oak Ridge National Laboratory.  (see\n\
 @url{http://www.cise.ufl.edu/research/sparse/colamd})\n\
 @seealso{colperm, symamd}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
@@ -444,17 +445,17 @@ Ng, Oak Ridge National Laboratory.  (see
 
 #endif
 
   return retval;
 }
 
 DEFUN_DLD (symamd, args, nargout,
     "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {@var{p} =} symamd (@var{s})\n\
+@deftypefn  {Loadable Function} {@var{p} =} symamd (@var{s})\n\
 @deftypefnx {Loadable Function} {@var{p} =} symamd (@var{s}, @var{knobs})\n\
 @deftypefnx {Loadable Function} {[@var{p}, @var{stats}] =} symamd (@var{s})\n\
 @deftypefnx {Loadable Function} {[@var{p}, @var{stats}] =} symamd (@var{s}, @var{knobs})\n\
 \n\
 For a symmetric positive definite matrix @var{s}, returns the permutation\n\
 vector p such that @code{@var{s} (@var{p}, @var{p})} tends to have a\n\
 sparser Cholesky factor than @var{s}.  Sometimes SYMAMD works well for\n\
 symmetric indefinite matrices too.  The matrix @var{s} is assumed to be\n\
@@ -500,17 +501,17 @@ row index in the column index given by @
 if no such row index exists.  @code{@var{stats} (7)} is the number of\n\
 duplicate or out-of-order row indices.  @code{@var{stats} (8:20)} is\n\
 always zero in the current version of SYMAMD (reserved for future use).\n\
 \n\
 The ordering is followed by a column elimination tree post-ordering.\n\
 \n\
 \n\
 The authors of the code itself are Stefan I. Larimore and Timothy A.\n\
-Davis (davis@@cise.ufl.edu), University of Florida.  The algorithm was\n\
+Davis @email{davis@@cise.ufl.edu}, University of Florida.  The algorithm was\n\
 developed in collaboration with John Gilbert, Xerox PARC, and Esmond\n\
 Ng, Oak Ridge National Laboratory.  (see\n\
 @url{http://www.cise.ufl.edu/research/sparse/colamd})\n\
 @seealso{colperm, colamd}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
@@ -641,17 +642,17 @@ Ng, Oak Ridge National Laboratory.  (see
 
 #endif
 
   return retval;
 }
 
 DEFUN_DLD (etree, args, nargout,
     "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {@var{p} =} etree (@var{s})\n\
+@deftypefn  {Loadable Function} {@var{p} =} etree (@var{s})\n\
 @deftypefnx {Loadable Function} {@var{p} =} etree (@var{s}, @var{typ})\n\
 @deftypefnx {Loadable Function} {[@var{p}, @var{q}] =} etree (@var{s}, @var{typ})\n\
 \n\
 Returns the elimination tree for the matrix @var{s}.  By default @var{s}\n\
 is assumed to be symmetric and the symmetric elimination tree is\n\
 returned.  The argument @var{typ} controls whether a symmetric or\n\
 column elimination tree is returned.  Valid values of @var{typ} are\n\
 'sym' or 'col', for symmetric or column elimination tree respectively\n\
diff --git a/src/DLD-FUNCTIONS/conv2.cc b/src/DLD-FUNCTIONS/conv2.cc
--- a/src/DLD-FUNCTIONS/conv2.cc
+++ b/src/DLD-FUNCTIONS/conv2.cc
@@ -46,27 +46,29 @@ enum Shape { SHAPE_FULL, SHAPE_SAME, SHA
 
 %!assert (conv2 (1:3, 1:2, [1,2;3,4;5,6]),
 %!        [1,4,4;5,18,16;14,48,40;19,62,48;15,48,36;]);
 */
 
 
 DEFUN_DLD (conv2, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {y =} conv2 (@var{a}, @var{b}, @var{shape})\n\
+@deftypefn  {Loadable Function} {y =} conv2 (@var{a}, @var{b}, @var{shape})\n\
 @deftypefnx {Loadable Function} {y =} conv2 (@var{v1}, @var{v2}, @var{M}, @var{shape})\n\
 \n\
 Returns 2D convolution of @var{a} and @var{b} where the size\n\
 of @var{c} is given by\n\
 \n\
 @table @asis\n\
 @item @var{shape} = 'full'\n\
 returns full 2-D convolution\n\
+\n\
 @item @var{shape} = 'same'\n\
 same size as a. 'central' part of convolution\n\
+\n\
 @item @var{shape} = 'valid'\n\
 only parts which do not include zero-padded edges\n\
 @end table\n\
 \n\
 By default @var{shape} is 'full'.  When the third argument is a matrix\n\
 returns the convolution of the matrix @var{M} by the vector @var{v1}\n\
 in the column direction and by vector @var{v2} in the row direction\n\
 @end deftypefn")
@@ -241,18 +243,20 @@ DEFUN_DLD (convn, args, ,
 @deftypefn {Loadable Function} {y =} conv2 (@var{a}, @var{b}, @var{shape})\n\
 \n\
 Returns n-D convolution of @var{a} and @var{b} where the size\n\
 of @var{c} is given by\n\
 \n\
 @table @asis\n\
 @item @var{shape} = 'full'\n\
 returns full n-D convolution\n\
+\n\
 @item @var{shape} = 'same'\n\
 same size as a. 'central' part of convolution\n\
+\n\
 @item @var{shape} = 'valid'\n\
 only parts which do not include zero-padded edges\n\
 @end table\n\
 \n\
 By default @var{shape} is 'full'.\n\
 @end deftypefn")
 {
   octave_value retval;
diff --git a/src/DLD-FUNCTIONS/convhulln.cc b/src/DLD-FUNCTIONS/convhulln.cc
--- a/src/DLD-FUNCTIONS/convhulln.cc
+++ b/src/DLD-FUNCTIONS/convhulln.cc
@@ -48,17 +48,17 @@ extern "C" {
 
 # ifdef NEED_QHULL_VERSION
 char qh_version[] = "convhulln.oct 2007-07-24";
 # endif
 #endif /* HAVE_QHULL */
 
 DEFUN_DLD (convhulln, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {@var{h} =} convhulln (@var{p})\n\
+@deftypefn  {Loadable Function} {@var{h} =} convhulln (@var{p})\n\
 @deftypefnx {Loadable Function} {@var{h} =} convhulln (@var{p}, @var{opt})\n\
 @deftypefnx {Loadable Function} {[@var{h}, @var{v}] =} convhulln (@dots{})\n\
 Return an index vector to the points of the enclosing convex hull.\n\
 The input matrix of size [n, dim] contains n points of dimension dim.\n\n\
 If a second optional argument is given, it must be a string or cell array\n\
 of strings containing options for the underlying qhull command.  (See\n\
 the Qhull documentation for the available options.)  The default options\n\
 are \"s Qci Tcv\".\n\
diff --git a/src/DLD-FUNCTIONS/daspk.cc b/src/DLD-FUNCTIONS/daspk.cc
--- a/src/DLD-FUNCTIONS/daspk.cc
+++ b/src/DLD-FUNCTIONS/daspk.cc
@@ -227,16 +227,17 @@ J = {\\partial f \\over \\partial x}\n\
 \n\
 @example\n\
 @group\n\
       df       df\n\
 jac = -- + c ------\n\
       dx     d xdot\n\
 @end group\n\
 @end example\n\
+\n\
 @end ifnottex\n\
 \n\
 The modified Jacobian function must have the form\n\
 \n\
 @example\n\
 @group\n\
 \n\
 @var{jac} = j (@var{x}, @var{xdot}, @var{t}, @var{c})\n\
@@ -255,17 +256,17 @@ be consistent.  If they are not consiste
 that @code{daspk} can compute a consistent starting point.\n\
 \n\
 The fifth argument is optional, and may be used to specify a set of\n\
 times that the DAE solver should not integrate past.  It is useful for\n\
 avoiding difficulties with singularities and points where there is a\n\
 discontinuity in the derivative.\n\
 \n\
 After a successful computation, the value of @var{istate} will be\n\
-greater than zero (consistent with the Fortran version of @sc{Daspk}).\n\
+greater than zero (consistent with the Fortran version of @sc{daspk}).\n\
 \n\
 If the computation is not successful, the value of @var{istate} will be\n\
 less than zero and @var{msg} will contain additional information.\n\
 \n\
 You can use the function @code{daspk_options} to set optional\n\
 parameters for @code{daspk}.\n\
 @seealso{dassl}\n\
 @end deftypefn")
diff --git a/src/DLD-FUNCTIONS/dasrt.cc b/src/DLD-FUNCTIONS/dasrt.cc
--- a/src/DLD-FUNCTIONS/dasrt.cc
+++ b/src/DLD-FUNCTIONS/dasrt.cc
@@ -293,51 +293,51 @@ The optional second argument names a fun
 constraint functions whose roots are desired during the integration.\n\
 This function must have the form\n\
 \n\
 @example\n\
 @var{g_out} = g (@var{x}, @var{t})\n\
 @end example\n\
 \n\
 and return a vector of the constraint function values.\n\
-If the value of any of the constraint functions changes sign, @sc{Dasrt}\n\
+If the value of any of the constraint functions changes sign, @sc{dasrt}\n\
 will attempt to stop the integration at the point of the sign change.\n\
 \n\
 If the name of the constraint function is omitted, @code{dasrt} solves\n\
 the same problem as @code{daspk} or @code{dassl}.\n\
 \n\
 Note that because of numerical errors in the constraint functions\n\
-due to round-off and integration error, @sc{Dasrt} may return false\n\
+due to round-off and integration error, @sc{dasrt} may return false\n\
 roots, or return the same root at two or more nearly equal values of\n\
 @var{T}.  If such false roots are suspected, the user should consider\n\
 smaller error tolerances or higher precision in the evaluation of the\n\
 constraint functions.\n\
 \n\
 If a root of some constraint function defines the end of the problem,\n\
-the input to @sc{Dasrt} should nevertheless allow integration to a\n\
-point slightly past that root, so that @sc{Dasrt} can locate the root\n\
+the input to @sc{dasrt} should nevertheless allow integration to a\n\
+point slightly past that root, so that @sc{dasrt} can locate the root\n\
 by interpolation.\n\
 \n\
 The third and fourth arguments to @code{dasrt} specify the initial\n\
 condition of the states and their derivatives, and the fourth argument\n\
 specifies a vector of output times at which the solution is desired,\n\
 including the time corresponding to the initial condition.\n\
 \n\
 The set of initial states and derivatives are not strictly required to\n\
-be consistent.  In practice, however, @sc{Dassl} is not very good at\n\
+be consistent.  In practice, however, @sc{dassl} is not very good at\n\
 determining a consistent set for you, so it is best if you ensure that\n\
 the initial values result in the function evaluating to zero.\n\
 \n\
 The sixth argument is optional, and may be used to specify a set of\n\
 times that the DAE solver should not integrate past.  It is useful for\n\
 avoiding difficulties with singularities and points where there is a\n\
 discontinuity in the derivative.\n\
 \n\
 After a successful computation, the value of @var{istate} will be\n\
-greater than zero (consistent with the Fortran version of @sc{Dassl}).\n\
+greater than zero (consistent with the Fortran version of @sc{dassl}).\n\
 \n\
 If the computation is not successful, the value of @var{istate} will be\n\
 less than zero and @var{msg} will contain additional information.\n\
 \n\
 You can use the function @code{dasrt_options} to set optional\n\
 parameters for @code{dasrt}.\n\
 @seealso{daspk, dasrt, lsode}\n\
 @end deftypefn")
diff --git a/src/DLD-FUNCTIONS/dassl.cc b/src/DLD-FUNCTIONS/dassl.cc
--- a/src/DLD-FUNCTIONS/dassl.cc
+++ b/src/DLD-FUNCTIONS/dassl.cc
@@ -221,23 +221,25 @@ function to compute the modified Jacobia
 \n\
 @tex\n\
 $$\n\
 J = {\\partial f \\over \\partial x}\n\
   + c {\\partial f \\over \\partial \\dot{x}}\n\
 $$\n\
 @end tex\n\
 @ifnottex\n\
+\n\
 @example\n\
 @group\n\
       df       df\n\
 jac = -- + c ------\n\
       dx     d xdot\n\
 @end group\n\
 @end example\n\
+\n\
 @end ifnottex\n\
 \n\
 The modified Jacobian function must have the form\n\
 \n\
 @example\n\
 @group\n\
 \n\
 @var{jac} = j (@var{x}, @var{xdot}, @var{t}, @var{c})\n\
@@ -246,27 +248,27 @@ The modified Jacobian function must have
 @end example\n\
 \n\
 The second and third arguments to @code{dassl} specify the initial\n\
 condition of the states and their derivatives, and the fourth argument\n\
 specifies a vector of output times at which the solution is desired,\n\
 including the time corresponding to the initial condition.\n\
 \n\
 The set of initial states and derivatives are not strictly required to\n\
-be consistent.  In practice, however, @sc{Dassl} is not very good at\n\
+be consistent.  In practice, however, @sc{dassl} is not very good at\n\
 determining a consistent set for you, so it is best if you ensure that\n\
 the initial values result in the function evaluating to zero.\n\
 \n\
 The fifth argument is optional, and may be used to specify a set of\n\
 times that the DAE solver should not integrate past.  It is useful for\n\
 avoiding difficulties with singularities and points where there is a\n\
 discontinuity in the derivative.\n\
 \n\
 After a successful computation, the value of @var{istate} will be\n\
-greater than zero (consistent with the Fortran version of @sc{Dassl}).\n\
+greater than zero (consistent with the Fortran version of @sc{dassl}).\n\
 \n\
 If the computation is not successful, the value of @var{istate} will be\n\
 less than zero and @var{msg} will contain additional information.\n\
 \n\
 You can use the function @code{dassl_options} to set optional\n\
 parameters for @code{dassl}.\n\
 @seealso{daspk, dasrt, lsode}\n\
 @end deftypefn")
diff --git a/src/DLD-FUNCTIONS/dmperm.cc b/src/DLD-FUNCTIONS/dmperm.cc
--- a/src/DLD-FUNCTIONS/dmperm.cc
+++ b/src/DLD-FUNCTIONS/dmperm.cc
@@ -128,17 +128,17 @@ dmperm_internal (bool rank, const octave
         }
     }
   return retval;
 }
 #endif
 
 DEFUN_DLD (dmperm, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {@var{p} =} dmperm (@var{s})\n\
+@deftypefn  {Loadable Function} {@var{p} =} dmperm (@var{s})\n\
 @deftypefnx {Loadable Function} {[@var{p}, @var{q}, @var{r}, @var{s}] =} dmperm (@var{s})\n\
 \n\
 @cindex Dulmage-Mendelsohn decomposition\n\
 Perform a Dulmage-Mendelsohn permutation on the sparse matrix @var{s}.\n\
 With a single output argument @dfn{dmperm} performs the row permutations\n\
 @var{p} such that @code{@var{s} (@var{p},:)} has no zero elements on the\n\
 diagonal.\n\
 \n\
@@ -190,20 +190,20 @@ 16(4):303-324, 1990.\n\
 
 DEFUN_DLD (sprank, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{p} =} sprank (@var{s})\n\
 \n\
 @cindex Structural Rank\n\
 Calculates the structural rank of a sparse matrix @var{s}.  Note that\n\
 only the structure of the matrix is used in this calculation based on\n\
-a Dulmage-Mendelsohn permutation to block triangular form.  As such the numerical\n\
-rank of the matrix @var{s} is bounded by @code{sprank (@var{s}) >=\n\
-rank (@var{s})}.  Ignoring floating point errors @code{sprank (@var{s}) ==\n\
-rank (@var{s})}.\n\
+a Dulmage-Mendelsohn permutation to block triangular form.  As such the\n\
+numerical rank of the matrix @var{s} is bounded by\n\
+@code{sprank (@var{s}) >= rank (@var{s})}.  Ignoring floating point errors\n\
+@code{sprank (@var{s}) == rank (@var{s})}.\n\
 @seealso{dmperm}\n\
 @end deftypefn")
 {
   int nargin = args.length();
   octave_value_list retval;
   
   if (nargin != 1)
     {
diff --git a/src/DLD-FUNCTIONS/dot.cc b/src/DLD-FUNCTIONS/dot.cc
--- a/src/DLD-FUNCTIONS/dot.cc
+++ b/src/DLD-FUNCTIONS/dot.cc
@@ -106,18 +106,18 @@ DEFUN_DLD (dot, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} dot (@var{x}, @var{y}, @var{dim})\n\
 Computes the dot product of two vectors.  If @var{x} and @var{y}\n\
 are matrices, calculate the dot products along the first \n\
 non-singleton dimension.  If the optional argument @var{dim} is\n\
 given, calculate the dot products along this dimension.\n\
 \n\
 This is equivalent to doing @code{sum (conj (@var{X}) .* @var{Y}, @var{dim})},\n\
-but avoids forming a temporary array and is faster.\n\
-When @var{X} and @var{Y} are column vectors, the result is equivalent to\n\
+but avoids forming a temporary array and is faster.  When @var{X} and @var{Y}\n\
+are column vectors, the result is equivalent to\n\
 @code{ @var{X}'*@var{Y} }.\n\
 @end deftypefn")
 {
   octave_value retval;
   int nargin = args.length ();
 
   if (nargin < 2 || nargin > 3)
     {
diff --git a/src/DLD-FUNCTIONS/eigs.cc b/src/DLD-FUNCTIONS/eigs.cc
--- a/src/DLD-FUNCTIONS/eigs.cc
+++ b/src/DLD-FUNCTIONS/eigs.cc
@@ -281,19 +281,19 @@ the same size as @var{A}.\n\
 \n\
 @item (A - sigma * B) \\ x\n\
 for the general eigenvalue problem.\n\
 @end table\n\
 \n\
 The return arguments of @code{eigs} depend on the number of return arguments\n\
 requested.  With a single return argument, a vector @var{d} of length @var{k}\n\
 is returned containing the @var{k} eigenvalues that have been found.  With two\n\
-return arguments, @var{v} is a @var{n}-by-@var{k} matrix whose columns are\n\
-the @var{k} eigenvectors corresponding to the returned eigenvalues.  The\n\
-eigenvalues themselves are returned in @var{d} in the form of a\n\
+return arguments, @var{v} is a @var{n}-by-@var{k} matrix whose columns are the\n\
+@var{k} eigenvectors corresponding to the returned eigenvalues.  The eigenvalues\n\
+themselves are returned in @var{d} in the form of a\n\
 @var{n}-by-@var{k} matrix, where the elements on the diagonal are the\n\
 eigenvalues.\n\
 \n\
 Given a third return argument @var{flag}, @code{eigs} returns the status\n\
 of the convergence.  If @var{flag} is 0 then all eigenvalues have converged.\n\
 Any other value indicates a failure to converge.\n\
 \n\
 This function is based on the @sc{arpack} package, written by R. Lehoucq,\n\
diff --git a/src/DLD-FUNCTIONS/fftn.cc b/src/DLD-FUNCTIONS/fftn.cc
--- a/src/DLD-FUNCTIONS/fftn.cc
+++ b/src/DLD-FUNCTIONS/fftn.cc
@@ -152,33 +152,33 @@ do_fftn (const octave_value_list &args, 
 DEFUN_DLD (fftn, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} fftn (@var{a}, @var{size})\n\
 Compute the N-dimensional FFT of @var{a} using subroutines from\n"
 FFTSRC
 ".  The optional vector argument @var{size} may be used specify the\n\
 dimensions of the array to be used.  If an element of @var{size} is\n\
 smaller than the corresponding dimension, then the dimension is\n\
-truncated prior to performing the FFT.  Otherwise if an element\n\
+truncated prior to performing the FFT@.  Otherwise if an element\n\
 of @var{size} is larger than the corresponding dimension @var{a}\n\
 is resized and padded with zeros.\n\
 @seealso {ifftn, fft, fft2, fftw}\n\
 @end deftypefn")
 {
   return do_fftn (args, "fftn", 0);
 }
 
 DEFUN_DLD (ifftn, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} ifftn (@var{a}, @var{size})\n\
 Compute the inverse N-dimensional FFT of @var{a} using subroutines from\n"
 FFTSRC
 ".  The optional vector argument @var{size} may be used specify the\n\
 dimensions of the array to be used.  If an element of @var{size} is\n\
 smaller than the corresponding dimension, then the dimension is\n\
-truncated prior to performing the inverse FFT.  Otherwise if an element\n\
+truncated prior to performing the inverse FFT@.  Otherwise if an element\n\
 of @var{size} is larger than the corresponding dimension @var{a}\n\
 is resized and padded with zeros.\n\
 @seealso {fftn, ifft, ifft2, fftw}\n\
 @end deftypefn")
 {
   return do_fftn (args, "ifftn", 1);
 }
diff --git a/src/DLD-FUNCTIONS/fftw.cc b/src/DLD-FUNCTIONS/fftw.cc
--- a/src/DLD-FUNCTIONS/fftw.cc
+++ b/src/DLD-FUNCTIONS/fftw.cc
@@ -29,26 +29,26 @@ along with Octave; see the file COPYING.
 #include "oct-fftw.h"
 
 #include "defun-dld.h"
 #include "error.h"
 #include "ov.h"
 
 DEFUN_DLD (fftw, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {@var{method} =} fftw ('planner')\n\
+@deftypefn  {Loadable Function} {@var{method} =} fftw ('planner')\n\
 @deftypefnx {Loadable Function} {} fftw ('planner', @var{method})\n\
 @deftypefnx {Loadable Function} {@var{wisdom} =} fftw ('dwisdom')\n\
 @deftypefnx {Loadable Function} {@var{wisdom} =} fftw ('dwisdom', @var{wisdom})\n\
 \n\
 Manage @sc{fftw} wisdom data.  Wisdom data can be used to significantly\n\
 accelerate the calculation of the FFTs but implies an initial cost\n\
 in its calculation.  When the @sc{fftw} libraries are initialized, they read\n\
-a system wide wisdom file (typically in @file{/etc/fftw/wisdom}), allowing wisdom\n\
-to be shared between applications other than Octave.  Alternatively, the\n\
+a system wide wisdom file (typically in @file{/etc/fftw/wisdom}), allowing\n\
+wisdom to be shared between applications other than Octave.  Alternatively, the\n\
 @code{fftw} function can be used to import wisdom.  For example\n\
 \n\
 @example\n\
 @var{wisdom} = fftw ('dwisdom')\n\
 @end example\n\
 \n\
 will save the existing wisdom used by Octave to the string @var{wisdom}.\n\
 This string can then be saved to a file and restored using the @code{save}\n\
diff --git a/src/DLD-FUNCTIONS/filter.cc b/src/DLD-FUNCTIONS/filter.cc
--- a/src/DLD-FUNCTIONS/filter.cc
+++ b/src/DLD-FUNCTIONS/filter.cc
@@ -278,36 +278,39 @@ filter (MArray<T>& b, MArray<T>& a, MArr
   
   MArray<T> si (si_dims, T (0.0));
 
   return filter (b, a, x, si, dim);
 }
 
 DEFUN_DLD (filter, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {y =} filter (@var{b}, @var{a}, @var{x})\n\
+@deftypefn  {Loadable Function} {y =} filter (@var{b}, @var{a}, @var{x})\n\
 @deftypefnx {Loadable Function} {[@var{y}, @var{sf}] =} filter (@var{b}, @var{a}, @var{x}, @var{si})\n\
 @deftypefnx {Loadable Function} {[@var{y}, @var{sf}] =} filter (@var{b}, @var{a}, @var{x}, [], @var{dim})\n\
 @deftypefnx {Loadable Function} {[@var{y}, @var{sf}] =} filter (@var{b}, @var{a}, @var{x}, @var{si}, @var{dim})\n\
 Return the solution to the following linear, time-invariant difference\n\
 equation:\n\
 @tex\n\
 $$\n\
 \\sum_{k=0}^N a_{k+1} y_{n-k} = \\sum_{k=0}^M b_{k+1} x_{n-k}, \\qquad\n\
  1 \\le n \\le P\n\
 $$\n\
 @end tex\n\
 @ifnottex\n\
 \n\
 @c Set example in small font to prevent overfull line\n\
 @smallexample\n\
+@group\n\
    N                   M\n\
   SUM a(k+1) y(n-k) = SUM b(k+1) x(n-k)      for 1<=n<=length(x)\n\
   k=0                 k=0\n\
+@end group\n\
 @end smallexample\n\
+\n\
 @end ifnottex\n\
 \n\
 @noindent\n\
 where\n\
 @ifnottex\n\
  N=length(a)-1 and M=length(b)-1.\n\
 @end ifnottex\n\
 @tex\n\
@@ -320,20 +323,23 @@ supplied.  An equivalent form of this eq
 y_n = -\\sum_{k=1}^N c_{k+1} y_{n-k} + \\sum_{k=0}^M d_{k+1} x_{n-k}, \\qquad\n\
  1 \\le n \\le P\n\
 $$\n\
 @end tex\n\
 @ifnottex\n\
 \n\
 @c Set example in small font to prevent overfull line\n\
 @smallexample\n\
+@group\n\
             N                   M\n\
   y(n) = - SUM c(k+1) y(n-k) + SUM d(k+1) x(n-k)  for 1<=n<=length(x)\n\
            k=1                 k=0\n\
+@end group\n\
 @end smallexample\n\
+\n\
 @end ifnottex\n\
 \n\
 @noindent\n\
 where\n\
 @ifnottex\n\
  c = a/a(1) and d = b/a(1).\n\
 @end ifnottex\n\
 @tex\n\
@@ -364,16 +370,17 @@ H(z) = {\\displaystyle\\sum_{k=0}^M d_{k
             SUM d(k+1) z^(-k)\n\
             k=0\n\
   H(z) = ----------------------\n\
                N\n\
           1 + SUM c(k+1) z^(-k)\n\
               k=1\n\
 @end group\n\
 @end example\n\
+\n\
 @end ifnottex\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin  = args.length ();
 
   if (nargin < 3 || nargin > 5)
diff --git a/src/DLD-FUNCTIONS/find.cc b/src/DLD-FUNCTIONS/find.cc
--- a/src/DLD-FUNCTIONS/find.cc
+++ b/src/DLD-FUNCTIONS/find.cc
@@ -333,44 +333,44 @@ find_nonzero_elem_idx (const PermMatrix&
       break;
     }
 
   return retval;
 }
 
 DEFUN_DLD (find, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {} find (@var{x})\n\
+@deftypefn  {Loadable Function} {} find (@var{x})\n\
 @deftypefnx {Loadable Function} {} find (@var{x}, @var{n})\n\
 @deftypefnx {Loadable Function} {} find (@var{x}, @var{n}, @var{direction})\n\
 Return a vector of indices of nonzero elements of a matrix, as a row if\n\
 @var{x} is a row or as a column otherwise.  To obtain a single index for\n\
 each matrix element, Octave pretends that the columns of a matrix form one\n\
-long vector (like Fortran arrays are stored).  For example,\n\
+long vector (like Fortran arrays are stored).  For example:\n\
 \n\
 @example\n\
 @group\n\
 find (eye (2))\n\
      @result{} [ 1; 4 ]\n\
 @end group\n\
 @end example\n\
 \n\
 If two outputs are requested, @code{find} returns the row and column\n\
-indices of nonzero elements of a matrix.  For example,\n\
+indices of nonzero elements of a matrix.  For example:\n\
 \n\
 @example\n\
 @group\n\
 [i, j] = find (2 * eye (2))\n\
      @result{} i = [ 1; 2 ]\n\
      @result{} j = [ 1; 2 ]\n\
 @end group\n\
 @end example\n\
 \n\
 If three outputs are requested, @code{find} also returns a vector\n\
-containing the nonzero values.  For example,\n\
+containing the nonzero values.  For example:\n\
 \n\
 @example\n\
 @group\n\
 [i, j, v] = find (3 * eye (2))\n\
      @result{} i = [ 1; 2 ]\n\
      @result{} j = [ 1; 2 ]\n\
      @result{} v = [ 3; 3 ]\n\
 @end group\n\
@@ -380,17 +380,17 @@ If two inputs are given, @var{n} indicat
 elements to find from the beginning of the matrix or vector.\n\
 \n\
 If three inputs are given, @var{direction} should be one of \"first\" or\n\
 \"last\", requesting only the first or last @var{n} indices, respectively.\n\
 However, the indices are always returned in ascending order.\n\
 \n\
 Note that this function is particularly useful for sparse matrices, as\n\
 it extracts the non-zero elements as vectors, which can then be used to\n\
-create the original matrix.  For example,\n\
+create the original matrix.  For example:\n\
 \n\
 @example\n\
 @group\n\
 sz = size(a);\n\
 [i, j, v] = find (a);\n\
 b = sparse(i, j, v, sz(1), sz(2));\n\
 @end group\n\
 @end example\n\
diff --git a/src/DLD-FUNCTIONS/gammainc.cc b/src/DLD-FUNCTIONS/gammainc.cc
--- a/src/DLD-FUNCTIONS/gammainc.cc
+++ b/src/DLD-FUNCTIONS/gammainc.cc
@@ -30,33 +30,35 @@ along with Octave; see the file COPYING.
 #include "defun-dld.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "utils.h"
 
 DEFUN_DLD (gammainc, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Mapping Function} {} gammainc (@var{x}, @var{a})\n\
+@deftypefn  {Mapping Function} {} gammainc (@var{x}, @var{a})\n\
 @deftypefnx {Mapping Function} {} gammainc (@var{x}, @var{a}, \"lower\")\n\
 @deftypefnx {Mapping Function} {} gammainc (@var{x}, @var{a}, \"upper\")\n\
 Compute the normalized incomplete gamma function,\n\
 @tex\n\
 $$\n\
  \\gamma (x, a) = {\\displaystyle\\int_0^x e^{-t} t^{a-1} dt \\over \\Gamma (a)}\n\
 $$\n\
 @end tex\n\
 @ifnottex\n\
 \n\
 @smallexample\n\
+@group\n\
                                 x\n\
                       1        /\n\
 gammainc (x, a) = ---------    | exp (-t) t^(a-1) dt\n\
                   gamma (a)    /\n\
                             t=0\n\
+@end group\n\
 @end smallexample\n\
 \n\
 @end ifnottex\n\
 with the limiting value of 1 as @var{x} approaches infinity.\n\
 The standard notation is @math{P(a,x)}, e.g., Abramowitz and Stegun (6.5.1).\n\
 \n\
 If @var{a} is scalar, then @code{gammainc (@var{x}, @var{a})} is returned\n\
 for each element of @var{x} and vice versa.\n\
diff --git a/src/DLD-FUNCTIONS/gcd.cc b/src/DLD-FUNCTIONS/gcd.cc
--- a/src/DLD-FUNCTIONS/gcd.cc
+++ b/src/DLD-FUNCTIONS/gcd.cc
@@ -79,19 +79,21 @@ gcd ([15, 9], [20, 18])\n\
 \n\
 Optional return arguments @var{v1}, etc., contain integer vectors such\n\
 that,\n\
 \n\
 @tex\n\
 $g = v_1 a_1 + v_2 a_2 + \\cdots$\n\
 @end tex\n\
 @ifnottex\n\
+\n\
 @example\n\
 @var{g} = @var{v1} .* @var{a1} + @var{v2} .* @var{a2} + @dots{}\n\
 @end example\n\
+\n\
 @end ifnottex\n\
 \n\
 For backward compatibility with previous versions of this function, when\n\
 all arguments are scalar, a single return argument @var{v1} containing\n\
 all of the values of @var{v1}, @dots{} is acceptable.\n\
 @seealso{lcm, factor}\n\
 @end deftypefn")
 {
diff --git a/src/DLD-FUNCTIONS/getrusage.cc b/src/DLD-FUNCTIONS/getrusage.cc
--- a/src/DLD-FUNCTIONS/getrusage.cc
+++ b/src/DLD-FUNCTIONS/getrusage.cc
@@ -61,17 +61,17 @@ along with Octave; see the file COPYING.
 // System resource functions.
 
 DEFUN_DLD (getrusage, , ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} getrusage ()\n\
 Return a structure containing a number of statistics about the current\n\
 Octave process.  Not all fields are available on all systems.  If it is\n\
 not possible to get CPU time statistics, the CPU time slots are set to\n\
-zero.  Other missing data are replaced by NaN.  Here is a list of all\n\
+zero.  Other missing data are replaced by NaN@.  Here is a list of all\n\
 the possible fields that can be present in the structure returned by\n\
 @code{getrusage}:\n\
 \n\
 @table @code\n\
 @item idrss\n\
 Unshared data size.\n\
 \n\
 @item inblock\n\
diff --git a/src/DLD-FUNCTIONS/givens.cc b/src/DLD-FUNCTIONS/givens.cc
--- a/src/DLD-FUNCTIONS/givens.cc
+++ b/src/DLD-FUNCTIONS/givens.cc
@@ -28,17 +28,17 @@ along with Octave; see the file COPYING.
 #endif
 
 #include "defun-dld.h"
 #include "error.h"
 #include "oct-obj.h"
 
 DEFUN_DLD (givens, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {@var{g} =} givens (@var{x}, @var{y})\n\
+@deftypefn  {Loadable Function} {@var{g} =} givens (@var{x}, @var{y})\n\
 @deftypefnx {Loadable Function} {[@var{c}, @var{s}] =} givens (@var{x}, @var{y})\n\
 @tex\n\
 Return a $2\\times 2$ orthogonal matrix\n\
 $$\n\
  G = \\left[\\matrix{c & s\\cr -s'& c\\cr}\\right]\n\
 $$\n\
 such that\n\
 $$\n\
@@ -47,17 +47,17 @@ such that\n\
 with $x$ and $y$ scalars.\n\
 @end tex\n\
 @ifnottex\n\
 Return a 2 by 2 orthogonal matrix\n\
 @code{@var{g} = [@var{c} @var{s}; -@var{s}' @var{c}]} such that\n\
 @code{@var{g} [@var{x}; @var{y}] = [*; 0]} with @var{x} and @var{y} scalars.\n\
 @end ifnottex\n\
 \n\
-For example,\n\
+For example:\n\
 \n\
 @example\n\
 @group\n\
 givens (1, 1)\n\
      @result{}   0.70711   0.70711\n\
          -0.70711   0.70711\n\
 @end group\n\
 @end example\n\
diff --git a/src/DLD-FUNCTIONS/hess.cc b/src/DLD-FUNCTIONS/hess.cc
--- a/src/DLD-FUNCTIONS/hess.cc
+++ b/src/DLD-FUNCTIONS/hess.cc
@@ -33,17 +33,17 @@ along with Octave; see the file COPYING.
 #include "defun-dld.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "utils.h"
 
 DEFUN_DLD (hess, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {@var{h} =} hess (@var{a})\n\
+@deftypefn  {Loadable Function} {@var{h} =} hess (@var{a})\n\
 @deftypefnx {Loadable Function} {[@var{p}, @var{h}] =} hess (@var{a})\n\
 @cindex Hessenberg decomposition\n\
 Compute the Hessenberg decomposition of the matrix @var{a}.\n\
 \n\
 The Hessenberg decomposition is usually used as the first step in an\n\
 eigenvalue computation, but has other applications as well (see Golub,\n\
 Nash, and Van Loan, IEEE Transactions on Automatic Control, 1979).  The\n\
 Hessenberg decomposition is\n\
diff --git a/src/DLD-FUNCTIONS/hex2num.cc b/src/DLD-FUNCTIONS/hex2num.cc
--- a/src/DLD-FUNCTIONS/hex2num.cc
+++ b/src/DLD-FUNCTIONS/hex2num.cc
@@ -119,17 +119,17 @@ hex2num ([\"4005bf0a8b145769\";\"4024000
 /*
 %!assert (hex2num(['c00';'bff';'000';'3ff';'400']),[-2:2]')
 */
 
 DEFUN_DLD (num2hex, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{s} =} num2hex (@var{n})\n\
 Typecast a double precision number or vector to a 16 character hexadecimal\n\
-string of the IEEE 754 representation of the number.  For example\n\
+string of the IEEE 754 representation of the number.  For example:\n\
 \n\
 @example\n\
 @group\n\
 num2hex ([-1, 1, e, Inf, NaN, NA]);\n\
 @result{} \"bff0000000000000\n\
     3ff0000000000000\n\
     4005bf0a8b145769\n\
     7ff0000000000000\n\
diff --git a/src/DLD-FUNCTIONS/inv.cc b/src/DLD-FUNCTIONS/inv.cc
--- a/src/DLD-FUNCTIONS/inv.cc
+++ b/src/DLD-FUNCTIONS/inv.cc
@@ -34,17 +34,17 @@ along with Octave; see the file COPYING.
 #include "ov-cx-diag.h"
 #include "ov-flt-re-diag.h"
 #include "ov-flt-cx-diag.h"
 #include "ov-perm.h"
 #include "utils.h"
 
 DEFUN_DLD (inv, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {[@var{x}, @var{rcond}] =} inv (@var{a})\n\
+@deftypefn  {Loadable Function} {[@var{x}, @var{rcond}] =} inv (@var{a})\n\
 @deftypefnx {Loadable Function} {[@var{x}, @var{rcond}] =} inverse (@var{a})\n\
 Compute the inverse of the square matrix @var{a}.  Return an estimate\n\
 of the reciprocal condition number if requested, otherwise warn of an\n\
 ill-conditioned matrix if the reciprocal condition number is small.\n\
 \n\
 If called with a sparse matrix, then in general @var{x} will be a full\n\
 matrix, and so if possible forming the inverse of a sparse matrix should\n\
 be avoided.  It is significantly more accurate and faster to do\n\
diff --git a/src/DLD-FUNCTIONS/kron.cc b/src/DLD-FUNCTIONS/kron.cc
--- a/src/DLD-FUNCTIONS/kron.cc
+++ b/src/DLD-FUNCTIONS/kron.cc
@@ -172,23 +172,23 @@ do_kron (const octave_value& a, const oc
   return octave_value (kron (am, bm));
 }
 
 #define ALL_TYPES(AMT, BMT) \
   } while (0) \
 
 DEFUN_DLD (kron, args, , "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} kron (@var{a}, @var{b})\n\
-Form the kronecker product of two matrices, defined block by block as\n\
+Form the Kronecker product of two matrices, defined block by block as\n\
 \n\
 @example\n\
 x = [a(i, j) b]\n\
 @end example\n\
 \n\
-For example,\n\
+For example:\n\
 \n\
 @example\n\
 @group\n\
 kron (1:4, ones (3, 1))\n\
       @result{}  1  2  3  4\n\
           1  2  3  4\n\
           1  2  3  4\n\
 @end group\n\
diff --git a/src/DLD-FUNCTIONS/lookup.cc b/src/DLD-FUNCTIONS/lookup.cc
--- a/src/DLD-FUNCTIONS/lookup.cc
+++ b/src/DLD-FUNCTIONS/lookup.cc
@@ -213,24 +213,26 @@ is performed using lexicographical compa
 \n\
 If @var{opts} is specified, it shall be a string with letters indicating\n\
 additional options.\n\
 \n\
 @table @code\n\
 @item m\n\
 @code{table(idx(i)) == val(i)} if @code{val(i)}\n\
 occurs in table; otherwise, @code{idx(i)} is zero.\n\
+\n\
 @item b\n\
 @code{idx(i)} is a logical 1 or 0, indicating whether\n\
 @code{val(i)} is contained in table or not.\n\
 \n\
 @item l\n\
 For numeric lookups\n\
 the leftmost subinterval shall be extended to infinity (i.e., all indices\n\
 at least 1)\n\
+\n\
 @item r\n\
 For numeric lookups\n\
 the rightmost subinterval shall be extended to infinity (i.e., all indices\n\
 at most n-1).\n\
 \n\
 @item i\n\
 For string lookups, use case-insensitive comparison.\n\
 @end table\n\
diff --git a/src/DLD-FUNCTIONS/lsode.cc b/src/DLD-FUNCTIONS/lsode.cc
--- a/src/DLD-FUNCTIONS/lsode.cc
+++ b/src/DLD-FUNCTIONS/lsode.cc
@@ -255,17 +255,17 @@ The second and third arguments specify t
 @math{x_0}, and the initial value of the independent variable @math{t_0}.\n\
 \n\
 The fourth argument is optional, and may be used to specify a set of\n\
 times that the ODE solver should not integrate past.  It is useful for\n\
 avoiding difficulties with singularities and points where there is a\n\
 discontinuity in the derivative.\n\
 \n\
 After a successful computation, the value of @var{istate} will be 2\n\
-(consistent with the Fortran version of @sc{Lsode}).\n\
+(consistent with the Fortran version of @sc{lsode}).\n\
 \n\
 If the computation is not successful, @var{istate} will be something\n\
 other than 2 and @var{msg} will contain additional information.\n\
 \n\
 You can use the function @code{lsode_options} to set optional\n\
 parameters for @code{lsode}.\n\
 @seealso{daspk, dassl, dasrt}\n\
 @end deftypefn")
diff --git a/src/DLD-FUNCTIONS/lu.cc b/src/DLD-FUNCTIONS/lu.cc
--- a/src/DLD-FUNCTIONS/lu.cc
+++ b/src/DLD-FUNCTIONS/lu.cc
@@ -609,17 +609,18 @@ a row permutation (pivoting) matrix @var
 in that case, an updated permutation matrix is returned.\n\
 Note that if @var{L}, @var{U}, @var{P} is a pivoted LU@tie{}factorization\n\
 as obtained by @code{lu}:\n\
 \n\
 @example\n\
   [@var{L}, @var{U}, @var{P}] = lu (@var{A});\n\
 @end example\n\
 \n\
-then a factorization of @code{@var{a}+@var{x}*@var{y}.'} can be obtained either as\n\
+then a factorization of @code{@var{a}+@var{x}*@var{y}.'} can be obtained either\n\
+as\n\
 \n\
 @example\n\
   [@var{L1}, @var{U1}] = lu (@var{L}, @var{U}, @var{P}*@var{x}, @var{y})\n\
 @end example\n\
 \n\
 or\n\
 \n\
 @example\n\
diff --git a/src/DLD-FUNCTIONS/luinc.cc b/src/DLD-FUNCTIONS/luinc.cc
--- a/src/DLD-FUNCTIONS/luinc.cc
+++ b/src/DLD-FUNCTIONS/luinc.cc
@@ -34,17 +34,17 @@ along with Octave; see the file COPYING.
 #include "MatrixType.h"
 #include "SparseCmplxLU.h"
 #include "SparsedbleLU.h"
 #include "ov-re-sparse.h"
 #include "ov-cx-sparse.h"
 
 DEFUN_DLD (luinc, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {[@var{l}, @var{u}, @var{p}, @var{q}] =} luinc (@var{a}, '0')\n\
+@deftypefn  {Loadable Function} {[@var{l}, @var{u}, @var{p}, @var{q}] =} luinc (@var{a}, '0')\n\
 @deftypefnx {Loadable Function} {[@var{l}, @var{u}, @var{p}, @var{q}] =} luinc (@var{a}, @var{droptol})\n\
 @deftypefnx {Loadable Function} {[@var{l}, @var{u}, @var{p}, @var{q}] =} luinc (@var{a}, @var{opts})\n\
 @cindex LU decomposition\n\
 Produce the incomplete LU factorization of the sparse matrix @var{a}.\n\
 Two types of incomplete factorization are possible, and the type\n\
 is determined by the second argument to @dfn{luinc}.\n\
 \n\
 Called with a second argument of '0', the zero-level incomplete\n\
diff --git a/src/DLD-FUNCTIONS/matrix_type.cc b/src/DLD-FUNCTIONS/matrix_type.cc
--- a/src/DLD-FUNCTIONS/matrix_type.cc
+++ b/src/DLD-FUNCTIONS/matrix_type.cc
@@ -33,88 +33,89 @@ along with Octave; see the file COPYING.
 #include "ov-cx-mat.h"
 #include "ov-re-sparse.h"
 #include "ov-cx-sparse.h"
 #include "MatrixType.h"
 #include "oct-locbuf.h"
 
 DEFUN_DLD (matrix_type, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {@var{type} =} matrix_type (@var{a})\n\
+@deftypefn  {Loadable Function} {@var{type} =} matrix_type (@var{a})\n\
 @deftypefnx {Loadable Function} {@var{type} =} matrix_type (@var{a}, 'nocompute')\n\
 @deftypefnx {Loadable Function} {@var{a} =} matrix_type (@var{a}, @var{type})\n\
 @deftypefnx {Loadable Function} {@var{a} =} matrix_type (@var{a}, 'upper', @var{perm})\n\
 @deftypefnx {Loadable Function} {@var{a} =} matrix_type (@var{a}, 'lower', @var{perm})\n\
 @deftypefnx {Loadable Function} {@var{a} =} matrix_type (@var{a}, 'banded', @var{nl}, @var{nu})\n\
-Identify the matrix type or mark a matrix as a particular type.  This allows rapid\n\
-for solutions of linear equations involving @var{a} to be performed.  Called with a\n\
-single argument, @code{matrix_type} returns the type of the matrix and caches it for\n\
-future use.  Called with more than one argument, @code{matrix_type} allows the type\n\
-of the matrix to be defined.\n\
+Identify the matrix type or mark a matrix as a particular type.  This allows\n\
+rapid for solutions of linear equations involving @var{a} to be performed.  \n\
+Called with a single argument, @code{matrix_type} returns the type of the matrix\n\
+and caches it for future use.  Called with more than one argument,\n\
+@code{matrix_type} allows the type of the matrix to be defined.\n\
 \n\
-If the option 'nocompute' is given, the function will not attempt to guess the type if it is\n\
-still unknown.  This is useful for debugging purposes.\n\
+If the option 'nocompute' is given, the function will not attempt to guess the\n\
+type if it is still unknown.  This is useful for debugging purposes.\n\
 \n\
-The possible matrix types depend on whether the matrix is full or sparse, and can be\n\
-one of the following\n\
+The possible matrix types depend on whether the matrix is full or sparse, and\n\
+can be one of the following\n\
 \n\
 @table @asis\n\
 @item 'unknown'\n\
 Remove any previously cached matrix type, and mark type as unknown\n\
 \n\
 @item 'full'\n\
 Mark the matrix as full.\n\
 \n\
 @item 'positive definite'\n\
 Probable full positive definite matrix.\n\
 \n\
 @item 'diagonal'\n\
 Diagonal Matrix.  (Sparse matrices only)\n\
 \n\
 @item 'permuted diagonal'\n\
 Permuted Diagonal matrix.  The permutation does not need to be specifically\n\
-indicated, as the structure of the matrix explicitly gives this.  (Sparse matrices\n\
-only)\n\
+indicated, as the structure of the matrix explicitly gives this.  (Sparse\n\
+matrices only)\n\
 \n\
 @item 'upper'\n\
-Upper triangular.  If the optional third argument @var{perm} is given, the matrix is\n\
-assumed to be a permuted upper triangular with the permutations defined by the\n\
-vector @var{perm}.\n\
+Upper triangular.  If the optional third argument @var{perm} is given, the\n\
+matrix is assumed to be a permuted upper triangular with the permutations\n\
+defined by the vector @var{perm}.\n\
 \n\
 @item 'lower'\n\
-Lower triangular.  If the optional third argument @var{perm} is given, the matrix is\n\
-assumed to be a permuted lower triangular with the permutations defined by the\n\
-vector @var{perm}.\n\
+Lower triangular.  If the optional third argument @var{perm} is given, the\n\
+matrix is assumed to be a permuted lower triangular with the permutations\n\
+defined by the vector @var{perm}.\n\
 \n\
 @item 'banded'\n\
 @itemx 'banded positive definite'\n\
-Banded matrix with the band size of @var{nl} below the diagonal and @var{nu} above\n\
-it.  If @var{nl} and @var{nu} are 1, then the matrix is tridiagonal and treated\n\
-with specialized code.  In addition the matrix can be marked as probably a\n\
-positive definite (Sparse matrices only)\n\
+Banded matrix with the band size of @var{nl} below the diagonal and @var{nu}\n\
+above it.  If @var{nl} and @var{nu} are 1, then the matrix is tridiagonal and\n\
+treated with specialized code.  In addition the matrix can be marked as probably\n\
+a positive definite (Sparse matrices only)\n\
 \n\
 @item 'singular'\n\
-The matrix is assumed to be singular and will be treated with a minimum norm solution\n\
+The matrix is assumed to be singular and will be treated with a minimum norm\n\
+solution\n\
 \n\
 @end table\n\
 \n\
-Note that the matrix type will be discovered automatically on the first attempt to\n\
-solve a linear equation involving @var{a}.  Therefore @code{matrix_type} is only\n\
-useful to give Octave hints of the matrix type.  Incorrectly defining the\n\
+Note that the matrix type will be discovered automatically on the first attempt\n\
+to solve a linear equation involving @var{a}.  Therefore @code{matrix_type} is\n\
+only useful to give Octave hints of the matrix type.  Incorrectly defining the\n\
 matrix type will result in incorrect results from solutions of linear equations,\n\
 and so it is entirely the responsibility of the user to correctly identify the\n\
 matrix type.\n\
 \n\
-Also the test for positive definiteness is a low-cost test for a hermitian\n\
+Also the test for positive definiteness is a low-cost test for a Hermitian\n\
 matrix with a real positive diagonal.  This does not guarantee that the matrix\n\
 is positive definite, but only that it is a probable candidate.  When such a\n\
-matrix is factorized, a Cholesky factorization is first attempted, and if\n\
-that fails the matrix is then treated with an LU factorization.  Once the\n\
-matrix has been factorized, @code{matrix_type} will return the correct\n\
-classification of the matrix.\n\
+matrix is factorized, a Cholesky factorization is first attempted, and if that\n\
+fails the matrix is then treated with an LU factorization.  Once the matrix has\n\
+been factorized, @code{matrix_type} will return the correct classification of\n\
+the matrix.\n\
 @end deftypefn")
 {
   int nargin = args.length ();
   octave_value retval;
 
   if (nargin == 0)
     print_usage ();
   else if (nargin > 4)
diff --git a/src/DLD-FUNCTIONS/max.cc b/src/DLD-FUNCTIONS/max.cc
--- a/src/DLD-FUNCTIONS/max.cc
+++ b/src/DLD-FUNCTIONS/max.cc
@@ -326,16 +326,17 @@ min (min (@var{x}))\n\
 returns the smallest element of @var{x}, and\n\
 \n\
 @example\n\
 @group\n\
 min (2:5, pi)\n\
     @result{}  2.0000  3.0000  3.1416  3.1416\n\
 @end group\n\
 @end example\n\
+\n\
 @noindent\n\
 compares each element of the range @code{2:5} with @code{pi}, and\n\
 returns a row vector of the minimum values.\n\
 \n\
 For complex arguments, the magnitude of the elements are used for\n\
 comparison.\n\
 \n\
 If called with one input and two output arguments,\n\
@@ -402,16 +403,17 @@ max (max (@var{x}))\n\
 returns the largest element of the matrix @var{x}, and\n\
 \n\
 @example\n\
 @group\n\
 max (2:5, pi)\n\
     @result{}  3.1416  3.1416  4.0000  5.0000\n\
 @end group\n\
 @end example\n\
+\n\
 @noindent\n\
 compares each element of the range @code{2:5} with @code{pi}, and\n\
 returns a row vector of the maximum values.\n\
 \n\
 For complex arguments, the magnitude of the elements are used for\n\
 comparison.\n\
 \n\
 If called with one input and two output arguments,\n\
@@ -561,33 +563,35 @@ do_cumminmax_body (const octave_value_li
 }
 
 DEFUN_DLD (cummin, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {} cummin (@var{x})\n\
 @deftypefnx {Loadable Function} {} cummin (@var{x}, @var{dim})\n\
 @deftypefnx {Loadable Function} {[@var{w}, @var{iw}] =} cummin (@var{x})\n\
 Return the cumulative minimum values along dimension @var{dim}.  If @var{dim}\n\
-is unspecified it defaults to column-wise operation.  For example,\n\
+is unspecified it defaults to column-wise operation.  For example:\n\
 \n\
 @example\n\
 @group\n\
 cummin ([5 4 6 2 3 1])\n\
     @result{}  5  4  4  2  2  1\n\
 @end group\n\
 @end example\n\
 \n\
 \n\
 The call\n\
+\n\
 @example\n\
   [w, iw] = cummin (x)\n\
 @end example\n\
 \n\
 @noindent\n\
 with @code{x} a vector, is equivalent to the following code:\n\
+\n\
 @example\n\
 @group\n\
 w = iw = zeros (size (x));\n\
 for i = 1:length (x)\n\
   [w(i), iw(i)] = max (x(1:i));\n\
 endfor\n\
 @end group\n\
 @end example\n\
@@ -601,32 +605,34 @@ but computed in a much faster manner.\n\
 }
 
 DEFUN_DLD (cummax, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {} cummax (@var{x})\n\
 @deftypefnx {Loadable Function} {} cummax (@var{x}, @var{dim})\n\
 @deftypefnx {Loadable Function} {[@var{w}, @var{iw}] =} cummax (@var{x})\n\
 Return the cumulative maximum values along dimension @var{dim}.  If @var{dim}\n\
-is unspecified it defaults to column-wise operation.  For example,\n\
+is unspecified it defaults to column-wise operation.  For example:\n\
 \n\
 @example\n\
 @group\n\
 cummax ([1 3 2 6 4 5])\n\
     @result{}  1  3  3  6  6  6\n\
 @end group\n\
 @end example\n\
 \n\
 The call\n\
+\n\
 @example\n\
 [w, iw] = cummax (x, dim)\n\
 @end example\n\
 \n\
 @noindent\n\
 with @code{x} a vector, is equivalent to the following code:\n\
+\n\
 @example\n\
 @group\n\
 w = iw = zeros (size (x));\n\
 for i = 1:length (x)\n\
   [w(i), iw(i)] = max (x(1:i));\n\
 endfor\n\
 @end group\n\
 @end example\n\
diff --git a/src/DLD-FUNCTIONS/md5sum.cc b/src/DLD-FUNCTIONS/md5sum.cc
--- a/src/DLD-FUNCTIONS/md5sum.cc
+++ b/src/DLD-FUNCTIONS/md5sum.cc
@@ -33,17 +33,17 @@ along with Octave; see the file COPYING.
 #include "file-ops.h"
 #include "gripes.h"
 #include "load-path.h"
 #include "oct-env.h"
 #include "oct-md5.h"
 
 DEFUN_DLD (md5sum, args, ,
    "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {} md5sum (@var{file})\n\
+@deftypefn  {Loadable Function} {} md5sum (@var{file})\n\
 @deftypefnx {Loadable Function} {} md5sum (@var{str}, @var{opt})\n\
 Calculates the MD5 sum of the file @var{file}.  If the second parameter\n\
 @var{opt} exists and is true, then calculate the MD5 sum of the\n\
 string @var{str}.\n\
 @end deftypefn")
 {
   octave_value retval;
   int nargin = args.length ();
diff --git a/src/DLD-FUNCTIONS/onCleanup.cc b/src/DLD-FUNCTIONS/onCleanup.cc
--- a/src/DLD-FUNCTIONS/onCleanup.cc
+++ b/src/DLD-FUNCTIONS/onCleanup.cc
@@ -249,19 +249,19 @@ octave_oncleanup::print_raw (std::ostrea
   os << ")";
 }
 
 DEFUN_DLD (onCleanup, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{c} =} onCleanup (@var{action})\n\
 Creates a special object that executes a given function upon destruction.\n\
 If the object is copied to multiple variables (or cell or struct array elements)\n\
-or returned from a function, @var{action} will be executed after clearing the last\n\
-copy of the object.  Note that if multiple local onCleanup variables are created, the\n\
-order in which they are called is unspecified.\n\
+or returned from a function, @var{action} will be executed after clearing the\n\
+last copy of the object.  Note that if multiple local onCleanup variables are\n\
+created, the order in which they are called is unspecified.\n\
 @seealso{unwind_protect}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1)
     {
       if (octave_oncleanup::static_type_id () < 0)
diff --git a/src/DLD-FUNCTIONS/qr.cc b/src/DLD-FUNCTIONS/qr.cc
--- a/src/DLD-FUNCTIONS/qr.cc
+++ b/src/DLD-FUNCTIONS/qr.cc
@@ -69,17 +69,17 @@ get_qr_r (const base_qr<MT>& fact)
 // [Q, R, P] = qr (X, 0): form the economy decomposition with
 //                        permutation vector P such that Q * R = X (:, P)
 //
 // qr (X) alone returns the output of the LAPACK routine dgeqrf, such
 // that R = triu (qr (X))
 
 DEFUN_DLD (qr, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {[@var{q}, @var{r}, @var{p}] =} qr (@var{a})\n\
+@deftypefn  {Loadable Function} {[@var{q}, @var{r}, @var{p}] =} qr (@var{a})\n\
 @deftypefnx {Loadable Function} {[@var{q}, @var{r}, @var{p}] =} qr (@var{a}, '0')\n\
 @cindex QR factorization\n\
 Compute the QR factorization of @var{a}, using standard @sc{lapack}\n\
 subroutines.  For example, given the matrix @code{a = [1, 2; 3, 4]},\n\
 \n\
 @example\n\
 [q, r] = qr (a)\n\
 @end example\n\
@@ -767,19 +767,19 @@ bool check_index (const octave_value& i,
 DEFUN_DLD (qrupdate, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {[@var{Q1}, @var{R1}] =} qrupdate (@var{Q}, @var{R}, @var{u}, @var{v})\n\
 Given a QR@tie{}factorization of a real or complex matrix\n\
 @w{@var{A} = @var{Q}*@var{R}}, @var{Q}@tie{}unitary and\n\
 @var{R}@tie{}upper trapezoidal, return the QR@tie{}factorization\n\
 of @w{@var{A} + @var{u}*@var{v}'}, where @var{u} and @var{v} are\n\
 column vectors (rank-1 update) or matrices with equal number of columns\n\
-(rank-k update).  Notice that the latter case is done as a sequence of rank-1 updates;\n\
-thus, for k large enough, it will be both faster and more accurate to recompute\n\
-the factorization from scratch.\n\
+(rank-k update).  Notice that the latter case is done as a sequence of rank-1\n\
+updates; thus, for k large enough, it will be both faster and more accurate to\n\
+recompute the factorization from scratch.\n\
 \n\
 The QR factorization supplied may be either full\n\
 (Q is square) or economized (R is square).\n\
 \n\
 @seealso{qr, qrinsert, qrdelete}\n\
 @end deftypefn")
 {
   octave_idx_type nargin = args.length ();
diff --git a/src/DLD-FUNCTIONS/quad.cc b/src/DLD-FUNCTIONS/quad.cc
--- a/src/DLD-FUNCTIONS/quad.cc
+++ b/src/DLD-FUNCTIONS/quad.cc
@@ -171,17 +171,17 @@ quad_float_user_function (float x)
       ::error ("quad: " fmt, arg); \
       QUAD_ABORT (); \
     } \
   while (0)
 
 DEFUN_DLD (quad, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {[@var{v}, @var{ier}, @var{nfun}, @var{err}] =} quad (@var{f}, @var{a}, @var{b}, @var{tol}, @var{sing})\n\
-Integrate a nonlinear function of one variable using Quadpack.\n\
+Integrate a nonlinear function of one variable using @sc{quadpack}.\n\
 The first argument is the name of the function, the function handle or\n\
 the inline function to call to compute the value of the integrand.  It\n\
 must have the form\n\
 \n\
 @example\n\
 y = f (x)\n\
 @end example\n\
 \n\
diff --git a/src/DLD-FUNCTIONS/qz.cc b/src/DLD-FUNCTIONS/qz.cc
--- a/src/DLD-FUNCTIONS/qz.cc
+++ b/src/DLD-FUNCTIONS/qz.cc
@@ -299,58 +299,62 @@ QZ decomposition.  There are three ways 
 Computes the generalized eigenvalues\n\
 @tex\n\
 $\\lambda$\n\
 @end tex\n\
 @ifnottex\n\
 @var{lambda}\n\
 @end ifnottex\n\
 of @math{(A - s B)}.\n\
+\n\
 @item @code{[AA, BB, Q, Z, V, W, lambda] = qz (A, B)}\n\
 \n\
 Computes qz decomposition, generalized eigenvectors, and \n\
 generalized eigenvalues of @math{(A - sB)}\n\
 @tex\n\
 $$ AV = BV{ \\rm diag }(\\lambda) $$\n\
 $$ W^T A = { \\rm diag }(\\lambda)W^T B $$\n\
 $$ AA = Q^T AZ, BB = Q^T BZ $$\n\
 @end tex\n\
 @ifnottex\n\
+\n\
 @example\n\
 @group\n\
 \n\
     A * V = B * V * diag (lambda)\n\
     W' * A = diag (lambda) * W' * B\n\
     AA = Q * A * Z, BB = Q * B * Z\n\
 \n\
 @end group\n\
 @end example\n\
+\n\
 @end ifnottex\n\
 with @var{Q} and @var{Z} orthogonal (unitary)= @var{I}\n\
 \n\
 @item @code{[AA,BB,Z@{, lambda@}] = qz(A,B,opt)}\n\
 \n\
 As in form [2], but allows ordering of generalized eigenpairs\n\
 for (e.g.) solution of discrete time algebraic Riccati equations.\n\
 Form 3 is not available for complex matrices, and does not compute\n\
-the generalized eigenvectors @var{V}, @var{W}, nor the orthogonal matrix @var{Q}.\n\
+the generalized eigenvectors @var{V}, @var{W}, nor the orthogonal matrix\n\
+@var{Q}.\n\
 \n\
 @table @var\n\
 @item opt\n\
 for ordering eigenvalues of the GEP pencil.  The leading block\n\
 of the revised pencil contains all eigenvalues that satisfy:\n\
 @table @code\n\
 @item \"N\"\n\
 = unordered (default) \n\
 \n\
 @item \"S\"\n\
-= small: leading block has all |lambda| <= 1 \n\
+= small: leading block has all |lambda| @leq{} 1 \n\
 \n\
 @item \"B\"\n\
-= big: leading block has all |lambda| >= 1 \n\
+= big: leading block has all |lambda| @geq{} 1 \n\
 \n\
 @item \"-\"\n\
 = negative real part: leading block has all eigenvalues\n\
 in the open left half-plane\n\
 \n\
 @item \"+\"\n\
 = non-negative real part: leading block has all eigenvalues\n\
 in the closed right half-plane\n\
diff --git a/src/DLD-FUNCTIONS/rand.cc b/src/DLD-FUNCTIONS/rand.cc
--- a/src/DLD-FUNCTIONS/rand.cc
+++ b/src/DLD-FUNCTIONS/rand.cc
@@ -349,17 +349,17 @@ restore the random number generator to t
 using the form\n\
 \n\
 @example\n\
 rand (\"state\", v)\n\
 @end example\n\
 \n\
 @noindent\n\
 You may also initialize the state vector from an arbitrary vector of\n\
-length <= 625 for @var{v}.  This new state will be a hash based on the\n\
+length @leq{} 625 for @var{v}.  This new state will be a hash based on the\n\
 value of @var{v}, not @var{v} itself.\n\
 \n\
 By default, the generator is initialized from @code{/dev/urandom} if it is\n\
 available, otherwise from CPU time, wall clock time and the current\n\
 fraction of a second.\n\
 \n\
 To compute the pseudo-random sequence, @code{rand} uses the Mersenne\n\
 Twister with a period of @math{2^{19937}-1} (See M. Matsumoto and T. Nishimura,\n\
@@ -629,68 +629,86 @@ DEFUN_DLD (randg, args, ,
 Return a matrix with @code{gamma(@var{a},1)} distributed random elements.\n\
 The arguments are handled the same as the arguments for @code{rand},\n\
 except for the argument @var{a}.\n\
 \n\
 This can be used to generate many distributions:\n\
 \n\
 @table @asis\n\
 @item @code{gamma (a, b)} for @code{a > -1}, @code{b > 0}\n\
+\n\
 @example\n\
 r = b * randg (a)\n\
 @end example\n\
+\n\
 @item @code{beta (a, b)} for @code{a > -1}, @code{b > -1}\n\
+\n\
 @example\n\
 @group\n\
 r1 = randg (a, 1)\n\
 r = r1 / (r1 + randg (b, 1))\n\
 @end group\n\
 @end example\n\
+\n\
 @item @code{Erlang (a, n)}\n\
+\n\
 @example\n\
 r = a * randg (n)\n\
 @end example\n\
+\n\
 @item @code{chisq (df)} for @code{df > 0}\n\
+\n\
 @example\n\
 r = 2 * randg (df / 2)\n\
 @end example\n\
+\n\
 @item @code{t(df)} for @code{0 < df < inf} (use randn if df is infinite)\n\
+\n\
 @example\n\
 r = randn () / sqrt (2 * randg (df / 2) / df)\n\
 @end example\n\
+\n\
 @item @code{F (n1, n2)} for @code{0 < n1}, @code{0 < n2}\n\
+\n\
 @example\n\
 @group\n\
 ## r1 equals 1 if n1 is infinite\n\
 r1 = 2 * randg (n1 / 2) / n1\n\
 ## r2 equals 1 if n2 is infinite\n\
 r2 = 2 * randg (n2 / 2) / n2\n\
 r = r1 / r2\n\n\
 @end group\n\
 @end example\n\
+\n\
 @item negative @code{binomial (n, p)} for @code{n > 0}, @code{0 < p <= 1}\n\
+\n\
 @example\n\
 r = randp ((1 - p) / p * randg (n))\n\
 @end example\n\
+\n\
 @item non-central @code{chisq (df, L)}, for @code{df >= 0} and @code{L > 0}\n\
 (use chisq if @code{L = 0})\n\
+\n\
 @example\n\
 @group\n\
 r = randp (L / 2)\n\
 r(r > 0) = 2 * randg (r(r > 0))\n\
 r(df > 0) += 2 * randg (df(df > 0)/2)\n\
 @end group\n\
 @end example\n\
+\n\
 @item @code{Dirichlet (a1, @dots{} ak)}\n\
+\n\
 @example\n\
 @group\n\
 r = (randg (a1), @dots{}, randg (ak))\n\
 r = r / sum (r)\n\
 @end group\n\
 @end example\n\
+\n\
 @end table\n\
 @seealso{rand, randn, rande, randp}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
@@ -866,27 +884,33 @@ Return a matrix with Poisson distributed
 parameter given by the first argument, @var{l}.  The arguments\n\
 are handled the same as the arguments for @code{rand}, except for the\n\
 argument @var{l}.\n\
 \n\
 Five different algorithms are used depending on the range of @var{l}\n\
 and whether or not @var{l} is a scalar or a matrix.\n\
 \n\
 @table @asis\n\
-@item For scalar @var{l} <= 12, use direct method.\n\
-W.H. Press, et al., @cite{Numerical Recipes in C}, Cambridge University Press, 1992.\n\
+@item For scalar @var{l} @leq{} 12, use direct method.\n\
+W.H. Press, et al., @cite{Numerical Recipes in C},\n\
+Cambridge University Press, 1992.\n\
+\n\
 @item For scalar @var{l} > 12, use rejection method.[1]\n\
-W.H. Press, et al., @cite{Numerical Recipes in C}, Cambridge University Press, 1992.\n\
-@item For matrix @var{l} <= 10, use inversion method.[2]\n\
+W.H. Press, et al., @cite{Numerical Recipes in C},\n\
+Cambridge University Press, 1992.\n\
+\n\
+@item For matrix @var{l} @leq{} 10, use inversion method.[2]\n\
 E. Stadlober, et al., WinRand source code, available via FTP.\n\
+\n\
 @item For matrix @var{l} > 10, use patchwork rejection method.\n\
 E. Stadlober, et al., WinRand source code, available via FTP, or\n\
 H. Zechner, @cite{Efficient sampling from continuous and discrete\n\
 unimodal distributions}, Doctoral Dissertation, 156pp., Technical\n\
 University Graz, Austria, 1994.\n\
+\n\
 @item For @var{l} > 1e8, use normal approximation.\n\
 L. Montanet, et al., @cite{Review of Particle Properties}, Physical Review\n\
 D 50 p1284, 1994.\n\
 @end table\n\
 @seealso{rand, randn, rande, randg}\n\
 @end deftypefn")
 {
   octave_value retval;
diff --git a/src/DLD-FUNCTIONS/regexp.cc b/src/DLD-FUNCTIONS/regexp.cc
--- a/src/DLD-FUNCTIONS/regexp.cc
+++ b/src/DLD-FUNCTIONS/regexp.cc
@@ -875,79 +875,97 @@ octcellregexp (const octave_value_list &
     retval = octregexp (args, nargout, nm, case_insensitive);
 
   return retval;
 
 }
 
 DEFUN_DLD (regexp, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {[@var{s}, @var{e}, @var{te}, @var{m}, @var{t}, @var{nm}] =} regexp (@var{str}, @var{pat})\n\
+@deftypefn  {Loadable Function} {[@var{s}, @var{e}, @var{te}, @var{m}, @var{t}, @var{nm}] =} regexp (@var{str}, @var{pat})\n\
 @deftypefnx {Loadable Function} {[@dots{}] =} regexp (@var{str}, @var{pat}, @var{opts}, @dots{})\n\
 \n\
 Regular expression string matching.  Matches @var{pat} in @var{str} and\n\
 returns the position and matching substrings or empty values if there are\n\
 none.\n\
 \n\
 The matched pattern @var{pat} can include any of the standard regex\n\
 operators, including:\n\
 \n\
 @table @code\n\
 @item .\n\
 Match any character\n\
+\n\
 @item * + ? @{@}\n\
 Repetition operators, representing\n\
 @table @code\n\
 @item *\n\
 Match zero or more times\n\
+\n\
 @item +\n\
 Match one or more times\n\
+\n\
 @item ?\n\
 Match zero or one times\n\
+\n\
 @item @{@}\n\
 Match range operator, which is of the form @code{@{@var{n}@}} to match exactly\n\
 @var{n} times, @code{@{@var{m},@}} to match @var{m} or more times,\n\
 @code{@{@var{m},@var{n}@}} to match between @var{m} and @var{n} times.\n\
 @end table\n\
+\n\
 @item [@dots{}] [^@dots{}]\n\
+\n\
 List operators, where for example @code{[ab]c} matches @code{ac} and @code{bc}\n\
+\n\
 @item ()\n\
 Grouping operator\n\
+\n\
 @item |\n\
 Alternation operator.  Match one of a choice of regular expressions.  The\n\
 alternatives must be delimited by the grouping operator @code{()} above\n\
+\n\
 @item ^ $\n\
 Anchoring operator.  @code{^} matches the start of the string @var{str} and\n\
 @code{$} the end\n\
 @end table\n\
 \n\
 In addition the following escaped characters have special meaning.  It should\n\
 be noted that it is recommended to quote @var{pat} in single quotes rather\n\
 than double quotes, to avoid the escape sequences being interpreted by Octave\n\
 before being passed to @code{regexp}.\n\
 \n\
 @table @code\n\
 @item \\b\n\
 Match a word boundary\n\
+\n\
 @item \\B\n\
 Match within a word\n\
+\n\
 @item \\w\n\
 Matches any word character\n\
+\n\
 @item \\W\n\
 Matches any non word character\n\
+\n\
 @item \\<\n\
 Matches the beginning of a word\n\
+\n\
 @item \\>\n\
 Matches the end of a word\n\
+\n\
 @item \\s\n\
 Matches any whitespace character\n\
+\n\
 @item \\S\n\
 Matches any non whitespace character\n\
+\n\
 @item \\d\n\
 Matches any digit\n\
+\n\
 @item \\D\n\
 Matches any non-digit\n\
 @end table\n\
 \n\
 The outputs of @code{regexp} by default are in the order as given below\n\
 \n\
 @table @asis\n\
 @item @var{s}\n\
@@ -987,29 +1005,36 @@ are\n\
 @end multitable\n\
 \n\
 A further optional argument is 'once', that limits the number of returned\n\
 matches to the first match.  Additional arguments are\n\
 \n\
 @table @asis\n\
 @item matchcase\n\
 Make the matching case sensitive.\n\
+\n\
 @item ignorecase\n\
 Make the matching case insensitive.\n\
+\n\
 @item stringanchors\n\
 Match the anchor characters at the beginning and end of the string.\n\
+\n\
 @item lineanchors\n\
 Match the anchor characters at the beginning and end of the line.\n\
+\n\
 @item dotall\n\
 The character @code{.} matches the newline character.\n\
+\n\
 @item dotexceptnewline\n\
 The character @code{.} matches all but the newline character.\n\
+\n\
 @item freespacing\n\
 The pattern can include arbitrary whitespace and comments starting with\n\
 @code{#}.\n\
+\n\
 @item literalspacing\n\
 The pattern is taken literally.\n\
 @end table\n\
 @seealso{regexpi, regexprep}\n\
 @end deftypefn")
 {
   octave_value_list retval;
   int nargin = args.length();
@@ -1195,17 +1220,17 @@ The pattern is taken literally.\n\
 %!assert(regexp("qit",'q(?=u*)','match'), {'q'})
 
 %!assert(regexp('thingamabob','(?<=a)b'), 9)
 
 */
 
 DEFUN_DLD (regexpi, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {[@var{s}, @var{e}, @var{te}, @var{m}, @var{t}, @var{nm}] =} regexpi (@var{str}, @var{pat})\n\
+@deftypefn  {Loadable Function} {[@var{s}, @var{e}, @var{te}, @var{m}, @var{t}, @var{nm}] =} regexpi (@var{str}, @var{pat})\n\
 @deftypefnx {Loadable Function} {[@dots{}] =} regexpi (@var{str}, @var{pat}, @var{opts}, @dots{})\n\
 \n\
 Case insensitive regular expression string matching.  Matches @var{pat} in\n\
 @var{str} and returns the position and matching substrings or empty values\n\
 if there are none.  @xref{doc-regexp,,regexp}, for more details\n\
 @end deftypefn")
 {
   octave_value_list retval;
@@ -1544,29 +1569,31 @@ octregexprep (const octave_value_list &a
     }
   
   retval = rep;
   return retval;
 }
 
 DEFUN_DLD (regexprep, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function}  {@var{string} =} regexprep (@var{string}, @var{pat}, @var{repstr}, @var{options})\n\
+@deftypefn {Loadable Function} {@var{string} =} regexprep (@var{string}, @var{pat}, @var{repstr}, @var{options})\n\
 Replace matches of @var{pat} in  @var{string} with @var{repstr}.\n\
 \n\
 \n\
 The replacement can contain @code{$i}, which substitutes\n\
 for the ith set of parentheses in the match string.  E.g.,\n\
+\n\
 @example\n\
 @group\n\
 \n\
    regexprep(\"Bill Dunn\",'(\\w+) (\\w+)','$2, $1')\n\
 \n\
 @end group\n\
 @end example\n\
+\n\
 returns \"Dunn, Bill\"\n\
 \n\
 @var{options} may be zero or more of\n\
 @table @samp\n\
 \n\
 @item once\n\
 Replace only the first occurrence of @var{pat} in the result.\n\
 \n\
@@ -1581,18 +1608,18 @@ Alternatively, use (?i) or (?-i) in the 
 Whether characters ^ and $ match the beginning and ending of lines.\n\
 Alternatively, use (?m) or (?-m) in the pattern.\n\
 \n\
 @item dotexceptnewline and dotall\n\
 Whether . matches newlines in the string.\n\
 Alternatively, use (?s) or (?-s) in the pattern.\n\
 \n\
 @item freespacing or literalspacing\n\
-Whether whitespace and # comments can be used to make the regular expression more readable.\n\
-Alternatively, use (?x) or (?-x) in the pattern.\n\
+Whether whitespace and # comments can be used to make the regular expression\n\
+more readable.  Alternatively, use (?x) or (?-x) in the pattern.\n\
 \n\
 @end table\n\
 @seealso{regexp,regexpi,strrep}\n\
 @end deftypefn")
 {
   octave_value_list retval;
   int nargin = args.length();
 
diff --git a/src/DLD-FUNCTIONS/schur.cc b/src/DLD-FUNCTIONS/schur.cc
--- a/src/DLD-FUNCTIONS/schur.cc
+++ b/src/DLD-FUNCTIONS/schur.cc
@@ -55,17 +55,17 @@ mark_upper_triangular (const Matrix& a)
 
   retval.matrix_type (MatrixType::Upper);
 
   return retval;
 }
 
 DEFUN_DLD (schur, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {@var{s} =} schur (@var{a})\n\
+@deftypefn  {Loadable Function} {@var{s} =} schur (@var{a})\n\
 @deftypefnx {Loadable Function} {@var{s} =} schur (@var{a}, \"complex\")\n\
 @deftypefnx {Loadable Function} {[@var{u}, @var{s}] =} schur (@var{a}, @var{opt})\n\
 @cindex Schur decomposition\n\
 The Schur decomposition is used to compute eigenvalues of a\n\
 square matrix, and has applications in the solution of algebraic\n\
 Riccati equations in control (see @code{are} and @code{dare}).\n\
 @code{schur} always returns\n\
 @tex\n\
diff --git a/src/DLD-FUNCTIONS/sparse.cc b/src/DLD-FUNCTIONS/sparse.cc
--- a/src/DLD-FUNCTIONS/sparse.cc
+++ b/src/DLD-FUNCTIONS/sparse.cc
@@ -53,31 +53,31 @@ Return 1 if the value of the expression 
        return octave_value ();
      }
    else 
      return octave_value (args(0).is_sparse_type ());
 }
 
 DEFUN_DLD (sparse, args, ,
     "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {@var{s} =} sparse (@var{a})\n\
+@deftypefn  {Loadable Function} {@var{s} =} sparse (@var{a})\n\
 @deftypefnx {Loadable Function} {@var{s} =} sparse (@var{i}, @var{j}, @var{sv}, @var{m}, @var{n}, @var{nzmax})\n\
 @deftypefnx {Loadable Function} {@var{s} =} sparse (@var{i}, @var{j}, @var{sv})\n\
 @deftypefnx {Loadable Function} {@var{s} =} sparse (@var{i}, @var{j}, @var{s}, @var{m}, @var{n}, \"unique\")\n\
 @deftypefnx {Loadable Function} {@var{s} =} sparse (@var{m}, @var{n})\n\
 Create a sparse matrix from the full matrix or row, column, value triplets.\n\
 If @var{a} is a full matrix, convert it to a sparse matrix representation,\n\
 removing all zero values in the process.\n\
 \n\
 Given the integer index vectors @var{i} and @var{j}, a 1-by-@code{nnz} vector\n\
 of real of complex values @var{sv}, overall dimensions @var{m} and @var{n}\n\
 of the sparse matrix.  The argument @code{nzmax} is ignored but accepted for\n\
 compatibility with @sc{matlab}.  If @var{m} or @var{n} are not specified their\n\
-values are derived from the maximum index in the vectors @var{i} and @var{j}\n\
-as given by @code{@var{m} = max (@var{i})}, @code{@var{n} = max (@var{j})}.\n\
+values are derived from the maximum index in the vectors @var{i} and @var{j} as\n\
+given by @code{@var{m} = max (@var{i})}, @code{@var{n} = max (@var{j})}.\n\
 \n\
 @strong{Note}: if multiple values are specified with the same\n\
 @var{i}, @var{j} indices, the corresponding values in @var{s} will\n\
 be added.\n\
 \n\
 The following are all equivalent:\n\
 \n\
 @example\n\
@@ -209,33 +209,39 @@ DEFUN_DLD (spalloc, args, ,
 @deftypefn {Loadable Function} {@var{s} =} spalloc (@var{m}, @var{n}, @var{nz})\n\
 Creates a @var{m}-by-@var{n} sparse matrix with pre-allocated space for at most\n\
 @var{nz} nonzero elements.  This is useful for building the matrix incrementally\n\
 by a sequence of indexed assignments.  Subsequent indexed assignments will reuse\n\
 the pre-allocated memory, provided they are of one of the simple forms\n\
 \n\
 @itemize\n\
 @item @code{@var{s}(I:J) = @var{x}}\n\
+\n\
 @item @code{@var{s}(:,I:J) = @var{x}}\n\
+\n\
 @item @code{@var{s}(K:L,I:J) = @var{x}}\n\
 @end itemize\n\
 \n\
 @b{and} that the following conditions are met:\n\
 \n\
 @itemize\n\
 @item the assignment does not decrease nnz(@var{S}).\n\
+\n\
 @item after the assignment, nnz(@var{S}) does not exceed @var{nz}.\n\
+\n\
 @item no index is out of bounds.\n\
 @end itemize\n\
 \n\
-Partial movement of data may still occur, but in general the assignment will be more\n\
-memory and time-efficient under these circumstances.  In particular, it is possible\n\
-to efficiently build a pre-allocated sparse matrix from contiguous block of columns.\n\
+Partial movement of data may still occur, but in general the assignment will be\n\
+more memory and time-efficient under these circumstances.  In particular, it is\n\
+possible to efficiently build a pre-allocated sparse matrix from contiguous\n\
+block of columns.\n\
 \n\
-The amount of pre-allocated memory for a given matrix may be queried using the function\n\
+The amount of pre-allocated memory for a given matrix may be queried using the\n\
+function\n\
 @code{nzmax}.\n\
 @seealso{nzmax, sparse}\n\
 @end deftypefn")
 {
    octave_value retval;
    int nargin = args.length ();
 
    if (nargin == 2 || nargin == 3)
diff --git a/src/DLD-FUNCTIONS/spparms.cc b/src/DLD-FUNCTIONS/spparms.cc
--- a/src/DLD-FUNCTIONS/spparms.cc
+++ b/src/DLD-FUNCTIONS/spparms.cc
@@ -30,58 +30,70 @@ along with Octave; see the file COPYING.
 #include "pager.h"
 #include "error.h"
 #include "gripes.h"
 
 #include "oct-spparms.h"
 
 DEFUN_DLD (spparms, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} { } spparms ()\n\
+@deftypefn  {Loadable Function} { } spparms ()\n\
 @deftypefnx {Loadable Function} {@var{vals} =} spparms ()\n\
 @deftypefnx {Loadable Function} {[@var{keys}, @var{vals}] =} spparms ()\n\
 @deftypefnx {Loadable Function} {@var{val} =} spparms (@var{key})\n\
 @deftypefnx {Loadable Function} { } spparms (@var{vals})\n\
 @deftypefnx {Loadable Function} { } spparms ('defaults')\n\
 @deftypefnx {Loadable Function} { } spparms ('tight')\n\
 @deftypefnx {Loadable Function} { } spparms (@var{key}, @var{val})\n\
 Sets or displays the parameters used by the sparse solvers and factorization\n\
 functions.  The first four calls above get information about the current\n\
 settings, while the others change the current settings.  The parameters are\n\
 stored as pairs of keys and values, where the values are all floats and the\n\
 keys are one of the following strings:\n\
 \n\
 @table @code\n\
 @item spumoni\n\
 Printing level of debugging information of the solvers (default 0)\n\
+\n\
 @item ths_rel\n\
 Included for compatibility.  Not used.  (default 1)\n\
+\n\
 @item ths_abs\n\
 Included for compatibility.  Not used.  (default 1)\n\
+\n\
 @item exact_d\n\
 Included for compatibility.  Not used.  (default 0)\n\
+\n\
 @item supernd\n\
 Included for compatibility.  Not used.  (default 3)\n\
+\n\
 @item rreduce\n\
 Included for compatibility.  Not used.  (default 3)\n\
+\n\
 @item wh_frac\n\
 Included for compatibility.  Not used.  (default 0.5)\n\
+\n\
 @item autommd\n\
 Flag whether the LU/QR and the '\\' and '/' operators will automatically\n\
 use the sparsity preserving mmd functions (default 1)\n\
+\n\
 @item autoamd\n\
 Flag whether the LU and the '\\' and '/' operators will automatically\n\
 use the sparsity preserving amd functions (default 1)\n\
+\n\
 @item piv_tol\n\
 The pivot tolerance of the @sc{umfpack} solvers (default 0.1)\n\
+\n\
 @item sym_tol\n\
 The pivot tolerance of the @sc{umfpack} symmetric solvers (default 0.001)\n\
+\n\
 @item bandden\n\
 The density of non-zero elements in a banded matrix before it is treated\n\
 by the @sc{lapack} banded solvers (default 0.5)\n\
+\n\
 @item umfpack\n\
 Flag whether the @sc{umfpack} or mmd solvers are used for the LU, '\\' and\n\
 '/' operations (default 1)\n\
 @end table\n\
 \n\
 The value of individual keys can be set with @code{spparms (@var{key},\n\
 @var{val})}.  The default values can be restored with the special keyword\n\
 'defaults'.  The special keyword 'tight' can be used to set the mmd solvers\n\
diff --git a/src/DLD-FUNCTIONS/str2double.cc b/src/DLD-FUNCTIONS/str2double.cc
--- a/src/DLD-FUNCTIONS/str2double.cc
+++ b/src/DLD-FUNCTIONS/str2double.cc
@@ -197,31 +197,36 @@ str2double1 (const std::string& str_arg)
 
 DEFUN_DLD (str2double, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} str2double (@var{s})\n\
 Converts a string to real or complex number.\n\
 A complex number should be in one of the formats:\n\
 \n\
 @itemize\n\
-@item  a + bi\n\
-@item  a + b*i\n\
-@item  a + i*b\n\
-@item  bi + a\n\
-@item  b*i + a\n\
-@item  i*b + a\n\
+@item a + bi\n\
+\n\
+@item a + b*i\n\
+\n\
+@item a + i*b\n\
+\n\
+@item bi + a\n\
+\n\
+@item b*i + a\n\
+\n\
+@item i*b + a\n\
 @end itemize\n\
 \n\
 It is also possible to use @code{j} instead of @code{i}, or write just\n\
 @code{i} instead of @code{1*i}.\n\
 @code{a} and @code{b} should be real numbers\n\
 in a standard format.\n\
 @var{s} can also be a character matrix, in which case the conversion is repeated\n\
-for each row, or a cell array of strings, in which case each element is converted\n\
-and an array of the same dimensions is returned.\n\
+for each row, or a cell array of strings, in which case each element is\n\
+converted and an array of the same dimensions is returned.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1)
     {
       if (args(0).is_string ())
         {
diff --git a/src/DLD-FUNCTIONS/strfind.cc b/src/DLD-FUNCTIONS/strfind.cc
--- a/src/DLD-FUNCTIONS/strfind.cc
+++ b/src/DLD-FUNCTIONS/strfind.cc
@@ -142,17 +142,17 @@ qs_search (const Array<char>& needle,
       result.xelem (k++) = *iter;
     }
 
   return result;
 }
 
 DEFUN_DLD (strfind, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {@var{idx} =} strfind (@var{str}, @var{pattern})\n\
+@deftypefn  {Loadable Function} {@var{idx} =} strfind (@var{str}, @var{pattern})\n\
 @deftypefnx {Loadable Function} {@var{idx} =} strfind (@var{cellstr}, @var{pattern})\n\
 Search for @var{pattern} in the string @var{str} and return the\n\
 starting index of every such occurrence in the vector @var{idx}.\n\
 If there is no such occurrence, or if @var{pattern} is longer\n\
 than @var{str}, then @var{idx} is the empty array @code{[]}.\n\
 \n\
 If the cell array of strings @var{cellstr} is specified instead of the\n\
 string @var{str}, then @var{idx} is a cell array of vectors, as specified\n\
@@ -318,20 +318,20 @@ qs_replace (const Array<char>& str, cons
         }
     }
 
   return ret;
 }
 
 DEFUN_DLD (strrep, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {} strrep (@var{s}, @var{x}, @var{y})\n\
+@deftypefn  {Loadable Function} {} strrep (@var{s}, @var{x}, @var{y})\n\
 @deftypefnx {Loadable Function} {} strrep (@var{s}, @var{x}, @var{y}, \"overlaps\", @var{o})\n\
 Replace all occurrences of the substring @var{x} of the string @var{s}\n\
-with the string @var{y} and return the result.  For example,\n\
+with the string @var{y} and return the result.  For example:\n\
 \n\
 @example\n\
 @group\n\
 strrep (\"This is a test string\", \"is\", \"&%$\")\n\
      @result{} \"Th&%$ &%$ a test string\"\n\
 @end group\n\
 @end example\n\
 \n\
diff --git a/src/DLD-FUNCTIONS/sub2ind.cc b/src/DLD-FUNCTIONS/sub2ind.cc
--- a/src/DLD-FUNCTIONS/sub2ind.cc
+++ b/src/DLD-FUNCTIONS/sub2ind.cc
@@ -58,17 +58,17 @@ get_dim_vector (const octave_value& val,
         }
     }
 
   return dv;
 }
 
 DEFUN_DLD (sub2ind, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Function File} {@var{ind} =} sub2ind (@var{dims}, @var{i}, @var{j})\n\
+@deftypefn  {Function File} {@var{ind} =} sub2ind (@var{dims}, @var{i}, @var{j})\n\
 @deftypefnx {Function File} {@var{ind} =} sub2ind (@var{dims}, @var{s1}, @var{s2}, @dots{}, @var{sN})\n\
 Convert subscripts into a linear index.\n\
 \n\
 The following example shows how to convert the two-dimensional\n\
 index @code{(2,3)} of a 3-by-3 matrix to a linear index.  The matrix\n\
 is linearly indexed moving from one column to next, filling up\n\
 all rows in each column.\n\
 \n\
@@ -173,16 +173,17 @@ linear_index = sub2ind ([3, 3], 2, 3)\n\
 DEFUN_DLD (ind2sub, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Function File} {[@var{s1}, @var{s2}, @dots{}, @var{sN}] =} ind2sub (@var{dims}, @var{ind})\n\
 Convert a linear index into subscripts.\n\
 \n\
 The following example shows how to convert the linear index @code{8}\n\
 in a 3-by-3 matrix into a subscript.  The matrix is linearly indexed\n\
 moving from one column to next, filling up all rows in each column.\n\
+\n\
 @example\n\
 @group\n\
 [r, c] = ind2sub ([3, 3], 8)\n\
 @result{} r =  2\n\
 c =  3\n\
 @end group\n\
 @end example\n\
 @seealso{sub2ind}\n\
diff --git a/src/DLD-FUNCTIONS/svd.cc b/src/DLD-FUNCTIONS/svd.cc
--- a/src/DLD-FUNCTIONS/svd.cc
+++ b/src/DLD-FUNCTIONS/svd.cc
@@ -52,16 +52,17 @@ Compute the singular value decomposition
  A = U S V^H\n\
 $$\n\
 @end tex\n\
 @ifnottex\n\
 \n\
 @example\n\
 A = U*S*V'\n\
 @end example\n\
+\n\
 @end ifnottex\n\
 \n\
 The function @code{svd} normally returns only the vector of singular values.\n\
 When called with three return values, it computes\n\
 @tex\n\
 $U$, $S$, and $V$.\n\
 @end tex\n\
 @ifnottex\n\
diff --git a/src/DLD-FUNCTIONS/syl.cc b/src/DLD-FUNCTIONS/syl.cc
--- a/src/DLD-FUNCTIONS/syl.cc
+++ b/src/DLD-FUNCTIONS/syl.cc
@@ -42,18 +42,19 @@ Solve the Sylvester equation\n\
  A X + X B + C = 0\n\
 $$\n\
 @end tex\n\
 @ifnottex\n\
 \n\
 @example\n\
 A X + X B + C = 0\n\
 @end example\n\
+\n\
 @end ifnottex\n\
-using standard @sc{lapack} subroutines.  For example,\n\
+using standard @sc{lapack} subroutines.  For example:\n\
 \n\
 @example\n\
 @group\n\
 syl ([1, 2; 3, 4], [5, 6; 7, 8], [9, 10; 11, 12])\n\
      @result{} [ -0.50000, -0.66667; -0.66667, -0.50000 ]\n\
 @end group\n\
 @end example\n\
 @end deftypefn")
diff --git a/src/DLD-FUNCTIONS/symbfact.cc b/src/DLD-FUNCTIONS/symbfact.cc
--- a/src/DLD-FUNCTIONS/symbfact.cc
+++ b/src/DLD-FUNCTIONS/symbfact.cc
@@ -54,18 +54,20 @@ Where\n\
 Is the type of the factorization and can be one of\n\
 \n\
 @table @code\n\
 @item sym\n\
 Factorize @var{s}.  This is the default.\n\
 \n\
 @item col\n\
 Factorize @code{@var{s}' * @var{s}}.\n\
+\n\
 @item row\n\
 Factorize @code{@var{s} * @var{s}'}.\n\
+\n\
 @item lo\n\
 Factorize @code{@var{s}'}\n\
 @end table\n\
 \n\
 @item @var{mode}\n\
 The default is to return the Cholesky factorization for @var{r}, and if\n\
 @var{mode} is 'L', the conjugate transpose of the Cholesky factorization\n\
 is returned.  The conjugate transpose version is faster and uses less\n\
diff --git a/src/DLD-FUNCTIONS/time.cc b/src/DLD-FUNCTIONS/time.cc
--- a/src/DLD-FUNCTIONS/time.cc
+++ b/src/DLD-FUNCTIONS/time.cc
@@ -101,17 +101,17 @@ value returned by @code{time} was 856163
 %!assert(time () > 0);
 
 */
 
 DEFUN_DLD (gmtime, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} gmtime (@var{t})\n\
 Given a value returned from time (or any non-negative integer),\n\
-return a time structure corresponding to CUT.  For example,\n\
+return a time structure corresponding to CUT@.  For example:\n\
 \n\
 @example\n\
 @group\n\
 gmtime (time ())\n\
      @result{} @{\n\
            usec = 0\n\
            year = 97\n\
            mon = 1\n\
@@ -229,17 +229,17 @@ localtime (time ())\n\
 %!error <Invalid call to localtime.*> localtime (1, 2);
 
 */
 
 DEFUN_DLD (mktime, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} mktime (@var{tm_struct})\n\
 Convert a time structure corresponding to the local time to the number\n\
-of seconds since the epoch.  For example,\n\
+of seconds since the epoch.  For example:\n\
 \n\
 @example\n\
 @group\n\
 mktime (localtime (time ()))\n\
      @result{} 856163706\n\
 @end group\n\
 @end example\n\
 @seealso{strftime, strptime, localtime, gmtime, time, now, date, clock, datenum, datestr, datevec, calendar, weekday}\n\
@@ -287,17 +287,17 @@ DEFUN_DLD (strftime, args, ,
 Format the time structure @var{tm_struct} in a flexible way using the\n\
 format string @var{fmt} that contains @samp{%} substitutions\n\
 similar to those in @code{printf}.  Except where noted, substituted\n\
 fields have a fixed size; numeric fields are padded if necessary.\n\
 Padding is with zeros by default; for fields that display a single\n\
 number, padding can be changed or inhibited by following the @samp{%}\n\
 with one of the modifiers described below.  Unknown field specifiers are\n\
 copied as normal characters.  All other characters are copied to the\n\
-output without change.  For example,\n\
+output without change.  For example:\n\
 \n\
 @example\n\
 @group\n\
 strftime (\"%r (%Z) %A %e %B %Y\", localtime (time ()))\n\
      @result{} \"01:15:06 AM (CST) Monday 17 February 1997\"\n\
 @end group\n\
 @end example\n\
 \n\
diff --git a/src/DLD-FUNCTIONS/tril.cc b/src/DLD-FUNCTIONS/tril.cc
--- a/src/DLD-FUNCTIONS/tril.cc
+++ b/src/DLD-FUNCTIONS/tril.cc
@@ -357,17 +357,17 @@ matrix.\n\
 \n\
 If the value of @var{k} is negative, additional elements above (for\n\
 @code{tril}) or below (for @code{triu}) the main diagonal are also\n\
 selected.\n\
 \n\
 The absolute value of @var{k} must not be greater than the number of\n\
 sub- or super-diagonals.\n\
 \n\
-For example,\n\
+For example:\n\
 \n\
 @example\n\
 @group\n\
 tril (ones (3), -1)\n\
      @result{}  0  0  0\n\
          1  0  0\n\
          1  1  0\n\
 @end group\n\
diff --git a/src/DLD-FUNCTIONS/typecast.cc b/src/DLD-FUNCTIONS/typecast.cc
--- a/src/DLD-FUNCTIONS/typecast.cc
+++ b/src/DLD-FUNCTIONS/typecast.cc
@@ -107,24 +107,26 @@ of @var{x} and @var{class} must be one o
   \"uint64\"\n\
   \"double\"\n\
   \"single\"\n\
   \"double complex\"\n\
   \"single complex\"\n\
 @end group\n\
 @end example\n\
 \n\
-the last two are reserved for @var{class}; they indicate that a complex-valued result\n\
-is requested.  Complex arrays are stored in memory as consecutive pairs of real numbers.\n\
-The sizes of integer types are given by their bit counts.  Both logical and char are typically\n\
-one byte wide; however, this is not guaranteed by C++.  If your system is IEEE conformant,\n\
-single and double should be 4 bytes and 8 bytes wide, respectively.\n\
-\"logical\" is not allowed for @var{class}.\n\
-If the input is a row vector, the return value is a row vector, otherwise it is a column vector.\n\
-If the bit length of @var{x} is not divisible by that of @var{class}, an error occurs.\n\
+the last two are reserved for @var{class}; they indicate that a complex-valued\n\
+result is requested.  Complex arrays are stored in memory as consecutive pairs\n\
+of real numbers.  The sizes of integer types are given by their bit counts.  \n\
+Both logical and char are typically one byte wide; however, this is not\n\
+guaranteed by C++.  If your system is IEEE conformant, single and double should\n\
+be 4 bytes and 8 bytes wide, respectively.  \"logical\" is not allowed for\n\
+@var{class}.  If the input is a row vector, the return value is a row vector,\n\
+otherwise it is a column vector.  If the bit length of @var{x} is not divisible\n\
+by that of\n\
+@var{class}, an error occurs.\n\
 \n\
 An example of the use of typecast on a little-endian machine is\n\
 \n\
 @example\n\
 @group\n\
 @var{x} = uint16 ([1, 65535]);\n\
 typecast (@var{x}, 'uint8')\n\
 @result{} [   0,   1, 255, 255]\n\
@@ -267,18 +269,18 @@ do_bitpack (const boolNDArray& bitp)
       return ArrayType ();
     }
 }
 
 DEFUN_DLD (bitpack, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{y} =} bitpack (@var{x}, @var{class})\n\
 Returns a new array @var{y} resulting from interpreting a logical array @var{x}\n\
-as raw bit pattern for data of the numeric class @var{class}.  @var{class} must be\n\
-one of the built-in numeric classes:\n\
+as raw bit pattern for data of the numeric class @var{class}.  @var{class} must\n\
+be one of the built-in numeric classes:\n\
 \n\
 @example\n\
 @group\n\
   \"char\"\n\
   \"int8\"\n\
   \"int16\"\n\
   \"int32\"\n\
   \"int64\"\n\
@@ -286,20 +288,22 @@ one of the built-in numeric classes:\n\
   \"uint16\"\n\
   \"uint32\"\n\
   \"uint64\"\n\
   \"double\"\n\
   \"single\"\n\
 @end group\n\
 @end example\n\
 \n\
-The number of elements of @var{x} should be divisible by the bit length of @var{class}.\n\
-If it is not, excess bits are discarded.  Bits come in increasing order of significance, i.e.\n\
+The number of elements of @var{x} should be divisible by the bit length of\n\
+@var{class}.  If it is not, excess bits are discarded.  Bits come in increasing\n\
+order of significance, i.e.\n\
 @code{x(1)} is bit 0, @code{x(2)} is bit 1, etc.\n\
-The result is a row vector if @var{x} is a row vector, otherwise it is a column vector.\n\
+The result is a row vector if @var{x} is a row vector, otherwise it is a column\n\
+vector.\n\
 @seealso{bitunpack,typecast,bitget,bitset}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 2 && args(0).is_bool_type ())
     {
       boolNDArray bitp = args(0).bool_array_value ();
@@ -393,17 +397,18 @@ Returns a logical array @var{y} correspo
   \"uint16\"\n\
   \"uint32\"\n\
   \"uint64\"\n\
   \"double\"\n\
   \"single\"\n\
 @end group\n\
 @end example\n\
 \n\
-The result is a row vector if @var{x} is a row vector, otherwise it is a column vector.\n\
+The result is a row vector if @var{x} is a row vector, otherwise it is a column\n\
+vector.\n\
 @seealso{bitpack,typecast,bitget,bitset}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1 && (args(0).is_numeric_type () || args(0).is_string ()))
     {
       octave_value array = args(0);
diff --git a/src/DLD-FUNCTIONS/urlwrite.cc b/src/DLD-FUNCTIONS/urlwrite.cc
--- a/src/DLD-FUNCTIONS/urlwrite.cc
+++ b/src/DLD-FUNCTIONS/urlwrite.cc
@@ -677,22 +677,22 @@ static void
 delete_file (std::string file)
 {
   octave_unlink (file);
 }
 #endif
 
 DEFUN_DLD (urlwrite, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {} urlwrite (@var{url}, @var{localfile})\n\
+@deftypefn  {Loadable Function} {} urlwrite (@var{url}, @var{localfile})\n\
 @deftypefnx {Loadable Function} {@var{f} =} urlwrite (@var{url}, @var{localfile})\n\
 @deftypefnx {Loadable Function} {[@var{f}, @var{success}] =} urlwrite (@var{url}, @var{localfile})\n\
 @deftypefnx {Loadable Function} {[@var{f}, @var{success}, @var{message}] =} urlwrite (@var{url}, @var{localfile})\n\
 Download a remote file specified by its @var{url} and save it as\n\
-@var{localfile}.  For example,\n\
+@var{localfile}.  For example:\n\
 \n\
 @example\n\
 @group\n\
 urlwrite (\"ftp://ftp.octave.org/pub/octave/README\", \n\
           \"README.txt\");\n\
 @end group\n\
 @end example\n\
 \n\
@@ -843,44 +843,44 @@ urlwrite (\"http://www.google.com/search
   error ("urlwrite: not available in this version of Octave");
 #endif
 
   return retval;
 }
 
 DEFUN_DLD (urlread, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {@var{s} =} urlread (@var{url})\n\
+@deftypefn  {Loadable Function} {@var{s} =} urlread (@var{url})\n\
 @deftypefnx {Loadable Function} {[@var{s}, @var{success}] =} urlread (@var{url})\n\
 @deftypefnx {Loadable Function} {[@var{s}, @var{success}, @var{message}] =} urlread (@var{url})\n\
 @deftypefnx {Loadable Function} {[@dots{}] =} urlread (@var{url}, @var{method}, @var{param})\n\
 Download a remote file specified by its @var{url} and return its content\n\
-in string @var{s}.  For example,\n\
+in string @var{s}.  For example:\n\
 \n\
 @example\n\
 s = urlread (\"ftp://ftp.octave.org/pub/octave/README\");\n\
 @end example\n\
 \n\
 The variable @var{success} is 1 if the download was successful,\n\
 otherwise it is 0 in which case @var{message} contains an error\n\
 message.  If no output argument is specified and if an error occurs,\n\
 then the error is signaled through Octave's error handling mechanism.\n\
 \n\
 This function uses libcurl.  Curl supports, among others, the HTTP,\n\
 FTP and FILE protocols.  Username and password may be specified in the\n\
-URL.  For example,\n\
+URL@.  For example:\n\
 \n\
 @example\n\
 s = urlread (\"http://user:password@@example.com/file.txt\");\n\
 @end example\n\
 \n\
 GET and POST requests can be specified by @var{method} and @var{param}.\n\
 The parameter @var{method} is either @samp{get} or @samp{post}\n\
 and @var{param} is a cell array of parameter and value pairs.\n\
-For example,\n\
+For example:\n\
 \n\
 @example\n\
 @group\n\
 s = urlread (\"http://www.google.com/search\", \"get\",\n\
              @{\"query\", \"octave\"@});\n\
 @end group\n\
 @end example\n\
 @seealso{urlwrite}\n\
@@ -962,17 +962,17 @@ s = urlread (\"http://www.google.com/sea
   error ("urlread: not available in this version of Octave");
 #endif
 
   return retval;
 }
 
 DEFUN_DLD (__ftp__, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {} __ftp__ (@var{handle}, @var{host})\n\
+@deftypefn  {Loadable Function} {} __ftp__ (@var{handle}, @var{host})\n\
 @deftypefnx {Loadable Function} {} __ftp__ (@var{handle}, @var{host}, @var{username}, @var{password})\n\
 Undocumented internal function\n\
 @end deftypefn")
 {
 #ifdef HAVE_CURL
   int nargin = args.length ();
   std::string handle;
   std::string host;
diff --git a/src/bitfcns.cc b/src/bitfcns.cc
--- a/src/bitfcns.cc
+++ b/src/bitfcns.cc
@@ -402,17 +402,17 @@ bitshift (float a, int n, int64_t mask)
         mask = 0; \
       mask = mask | octave_ ## T :: min (); /* FIXME: 2's complement only? */ \
       DO_BITSHIFT (T); \
     } \
   while (0)
 
 DEFUN (bitshift, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} bitshift (@var{a}, @var{k})\n\
+@deftypefn  {Built-in Function} {} bitshift (@var{a}, @var{k})\n\
 @deftypefnx {Built-in Function} {} bitshift (@var{a}, @var{k}, @var{n})\n\
 Return a @var{k} bit shift of @var{n}-digit unsigned\n\
 integers in @var{a}.  A positive @var{k} leads to a left shift.\n\
 A negative value to a right shift.  If @var{n} is omitted it defaults\n\
 to log2(bitmax)+1.\n\
 @var{n} must be in the range [1,log2(bitmax)+1] usually [1,33]\n\
 \n\
 @example\n\
@@ -531,28 +531,35 @@ DEFUN (intmax, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} intmax (@var{type})\n\
 Return the largest integer that can be represented in an integer type.\n\
 The variable @var{type} can be\n\
 \n\
 @table @code\n\
 @item int8\n\
 signed 8-bit integer.\n\
+\n\
 @item int16\n\
 signed 16-bit integer.\n\
+\n\
 @item int32\n\
 signed 32-bit integer.\n\
+\n\
 @item int64\n\
 signed 64-bit integer.\n\
+\n\
 @item uint8\n\
 unsigned 8-bit integer.\n\
+\n\
 @item uint16\n\
 unsigned 16-bit integer.\n\
+\n\
 @item uint32\n\
 unsigned 32-bit integer.\n\
+\n\
 @item uint64\n\
 unsigned 64-bit integer.\n\
 @end table\n\
 \n\
 The default for @var{type} is @code{uint32}.\n\
 @seealso{intmin, bitmax}\n\
 @end deftypefn")
 {
@@ -594,28 +601,35 @@ DEFUN (intmin, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} intmin (@var{type})\n\
 Return the smallest integer that can be represented in an integer type.\n\
 The variable @var{type} can be\n\
 \n\
 @table @code\n\
 @item int8\n\
 signed 8-bit integer.\n\
+\n\
 @item int16\n\
 signed 16-bit integer.\n\
+\n\
 @item int32\n\
 signed 32-bit integer.\n\
+\n\
 @item int64\n\
 signed 64-bit integer.\n\
+\n\
 @item uint8\n\
 unsigned 8-bit integer.\n\
+\n\
 @item uint16\n\
 unsigned 16-bit integer.\n\
+\n\
 @item uint32\n\
 unsigned 32-bit integer.\n\
+\n\
 @item uint64\n\
 unsigned 64-bit integer.\n\
 @end table\n\
 \n\
 The default for @var{type} is @code{uint32}.\n\
 @seealso{intmax, bitmax}\n\
 @end deftypefn")
 {
@@ -653,17 +667,17 @@ The default for @var{type} is @code{uint
   return retval;
 }
 
 DEFUN (sizemax, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} sizemax ()\n\
 Return the largest value that is allowed as the size of an array.\n\
 If Octave is compiled with 64-bit indexing, the result is of class int64,\n\
-otherwise it is of class int32. It will be a tiny bit lower than the maximum\n\
+otherwise it is of class int32.  It will be a tiny bit lower than the maximum\n\
 allowable value for that type, as reported by intmax.\n\
 @seealso{intmax}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 0)
     retval = octave_int<octave_idx_type> (dim_vector::dim_max ());
diff --git a/src/data.cc b/src/data.cc
--- a/src/data.cc
+++ b/src/data.cc
@@ -142,27 +142,27 @@ elements along dimension @var{dim} of a 
 DEFUN (any, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} any (@var{x}, @var{dim})\n\
 For a vector argument, return 1 if any element of the vector is\n\
 nonzero.\n\
 \n\
 For a matrix argument, return a row vector of ones and\n\
 zeros with each element indicating whether any of the elements of the\n\
-corresponding column of the matrix are nonzero.  For example,\n\
+corresponding column of the matrix are nonzero.  For example:\n\
 \n\
 @example\n\
 @group\n\
 any (eye (2, 4))\n\
      @result{} [ 1, 1, 0, 0 ]\n\
 @end group\n\
 @end example\n\
 \n\
 If the optional argument @var{dim} is supplied, work along dimension\n\
-@var{dim}.  For example,\n\
+@var{dim}.  For example:\n\
 \n\
 @example\n\
 @group\n\
 any (eye (2, 4), 2)\n\
      @result{} [ 1; 1 ]\n\
 @end group\n\
 @end example\n\
 @end deftypefn")
@@ -332,24 +332,25 @@ do_hypot (const octave_value& x, const o
         }
     }
 
   return retval;
 }
 
 DEFUN (hypot, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} hypot (@var{x}, @var{y})\n\
+@deftypefn  {Built-in Function} {} hypot (@var{x}, @var{y})\n\
 @deftypefnx {Built-in Function} {} hypot (@var{x}, @var{y}, @var{z}, @dots{})\n\
 Compute the element-by-element square root of the sum of the squares of\n\
 @var{x} and @var{y}.  This is equivalent to\n\
 @code{sqrt (@var{x}.^2 + @var{y}.^2)}, but calculated in a manner that\n\
 avoids overflows for large values of @var{x} or @var{y}.\n\
 @code{hypot} can also be called with more than 2 arguments; in this case,\n\
 the arguments are accumulated from left to right:\n\
+\n\
 @example\n\
 @group\n\
   hypot (hypot (@var{x}, @var{y}), @var{z})\n\
   hypot (hypot (hypot (@var{x}, @var{y}), @var{z}), @var{w}), etc.\n\
 @end group\n\
 @end example\n\
 @end deftypefn")
 {
@@ -394,17 +395,17 @@ map_2_xlog2 (const Array<T>& x, Array<T>
       int exp;
       f.xelem (i) = xlog2 (x(i), exp);
       e.xelem (i) = exp;
     }
 }
 
 DEFUN (log2, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Mapping Function} {} log2 (@var{x})\n\
+@deftypefn  {Mapping Function} {} log2 (@var{x})\n\
 @deftypefnx {Mapping Function} {[@var{f}, @var{e}] =} log2 (@var{x})\n\
 Compute the base-2 logarithm of each element of @var{x}.\n\
 \n\
 If called with two output arguments, split @var{x} into\n\
 binary mantissa and exponent so that\n\
 @tex\n\
 ${1 \\over 2} \\le \\left| f \\right| < 1$\n\
 @end tex\n\
@@ -494,17 +495,17 @@ and @var{e} is an integer.  If\n\
 %!test
 %! [f, e] = log2 (complex (zeros (3, 2), [0,-1; 2,-4; Inf,-Inf]));
 %! assert (f, complex (zeros (3, 2), [0,-0.5; 0.5,-0.5; Inf,-Inf]));
 %! assert (e(1:2,:), [0,1; 2,3]);
 */
 
 DEFUN (rem, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Mapping Function} {} rem (@var{x}, @var{y})\n\
+@deftypefn  {Mapping Function} {} rem (@var{x}, @var{y})\n\
 @deftypefnx {Mapping Function} {} fmod (@var{x}, @var{y})\n\
 Return the remainder of the division @code{@var{x} / @var{y}}, computed \n\
 using the expression\n\
 \n\
 @example\n\
 x - y .* fix (x ./ y)\n\
 @end example\n\
 \n\
@@ -1218,17 +1219,17 @@ The \"native\" argument implies the summ
 
 DEFUN (diag, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} diag (@var{v}, @var{k})\n\
 Return a diagonal matrix with vector @var{v} on diagonal @var{k}.  The\n\
 second argument is optional.  If it is positive, the vector is placed on\n\
 the @var{k}-th super-diagonal.  If it is negative, it is placed on the\n\
 @var{-k}-th sub-diagonal.  The default value of @var{k} is 0, and the\n\
-vector is placed on the main diagonal.  For example,\n\
+vector is placed on the main diagonal.  For example:\n\
 \n\
 @example\n\
 @group\n\
 diag ([1, 2, 3], 1)\n\
      @result{}  0  1  0  0\n\
          0  0  2  0\n\
          0  0  0  3\n\
          0  0  0  0\n\
@@ -1710,16 +1711,17 @@ second dimension the following way:\n\
 @group\n\
 [A, B].\n\
 @end group\n\
 @end example\n\
 \n\
 @var{dim} can be larger than the dimensions of the N-d array objects\n\
 and the result will thus have @var{dim} dimensions as the\n\
 following example shows:\n\
+\n\
 @example\n\
 @group\n\
 cat (4, ones(2, 2), zeros (2, 2))\n\
 @result{} ans =\n\
 \n\
    ans(:,:,1,1) =\n\
 \n\
      1 1\n\
@@ -1932,16 +1934,17 @@ The permutation vector @var{perm} must c
 DEFUN (ipermute, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} ipermute (@var{a}, @var{iperm})\n\
 The inverse of the @code{permute} function.  The expression\n\
 \n\
 @example\n\
 ipermute (permute (a, perm), perm)\n\
 @end example\n\
+\n\
 returns the original array @var{a}.\n\
 @seealso{permute}\n\
 @end deftypefn")
 {
   return do_permute (args, true);
 }
 
 DEFUN (length, args, ,
@@ -1963,16 +1966,17 @@ odd definition is used for compatibility
 }
 
 DEFUN (ndims, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} ndims (@var{a})\n\
 Return the number of dimensions of @var{a}.\n\
 For any array, the result will always be larger than or equal to 2.\n\
 Trailing singleton dimensions are not counted.\n\
+\n\
 @example\n\
 @group\n\
   ndims (ones (4, 1, 2, 1)\n\
      @result{} 3\n\
 @end group\n\
 @end example\n\
 @end deftypefn")
 {
@@ -1988,19 +1992,21 @@ Trailing singleton dimensions are not co
 
 DEFUN (numel, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} numel (@var{a})\n\
 @deftypefnx {Built-in Function} {} numel (@var{a}, @var{idx1}, @var{idx2}, @dots{})\n\
 Return the number of elements in the object @var{a}.\n\
 Optionally, if indices @var{idx1}, @var{idx2}, @dots{} are supplied,\n\
 return the number of elements that would result from the indexing\n\
+\n\
 @example\n\
   @var{a}(@var{idx1}, @var{idx2}, @dots{})\n\
 @end example\n\
+\n\
 This method is also called when an object appears as lvalue with cs-list\n\
 indexing, i.e., @code{object@{@dots{}@}} or @code{object(@dots{}).field}.\n\
 @seealso{size}\n\
 @end deftypefn")
 {
   octave_value retval;
   octave_idx_type nargin = args.length ();
 
@@ -2022,31 +2028,31 @@ DEFUN (size, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} size (@var{a})\n\
 @deftypefnx {Built-in Function} {} size (@var{a}, @var{dim})\n\
 Return the number rows and columns of @var{a}.\n\
 \n\
 With one input argument and one output argument, the result is returned\n\
 in a row vector.  If there are multiple output arguments, the number of\n\
 rows is assigned to the first, and the number of columns to the second,\n\
-etc.  For example,\n\
+etc.  For example:\n\
 \n\
 @example\n\
 @group\n\
 size ([1, 2; 3, 4; 5, 6])\n\
      @result{} [ 3, 2 ]\n\
 \n\
 [nr, nc] = size ([1, 2; 3, 4; 5, 6])\n\
      @result{} nr = 3\n\
      @result{} nc = 2\n\
 @end group\n\
 @end example\n\
 \n\
 If given a second argument, @code{size} will return the size of the\n\
-corresponding dimension.  For example\n\
+corresponding dimension.  For example,\n\
 \n\
 @example\n\
 @group\n\
 size ([1, 2; 3, 4; 5, 6], 2)\n\
      @result{} 2\n\
 @end group\n\
 @end example\n\
 \n\
@@ -2222,33 +2228,34 @@ DEFUN (sum, args, ,
 @deftypefnx {Built-in Function} {} sum (@dots{}, 'native')\n\
 @deftypefnx {Built-in Function} {} sum (@dots{}, 'double')\n\
 @deftypefnx {Built-in Function} {} sum (@dots{}, 'extra')\n\
 Sum of elements along dimension @var{dim}.  If @var{dim} is\n\
 omitted, it defaults to the first non-singleton dimension.\n\
 \n\
 If the optional argument 'native' is given, then the sum is performed\n\
 in the same type as the original argument, rather than in the default\n\
-double type.  For example\n\
+double type.  For example:\n\
 \n\
 @example\n\
 @group\n\
 sum ([true, true])\n\
   @result{} 2\n\
 sum ([true, true], 'native')\n\
   @result{} true\n\
 @end group\n\
 @end example\n\
+\n\
   \n\
 On the contrary, if 'double' is given, the sum is performed in double precision\n\
 even for single precision inputs.\n\
 \n\
 For double precision inputs, 'extra' indicates that a more accurate algorithm\n\
-than straightforward summation is to be used.  For single precision inputs, 'extra' is\n\
-the same as 'double'.  Otherwise, 'extra' has no effect.\n\
+than straightforward summation is to be used.  For single precision inputs,\n\
+'extra' is the same as 'double'.  Otherwise, 'extra' has no effect.\n\
 @seealso{cumsum, sumsq, prod}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   bool isnative = false;
@@ -2435,19 +2442,21 @@ the same as 'double'.  Otherwise, 'extra
 DEFUN (sumsq, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} sumsq (@var{x})\n\
 @deftypefnx {Built-in Function} {} sumsq (@var{x}, @var{dim})\n\
 Sum of squares of elements along dimension @var{dim}.  If @var{dim}\n\
 is omitted, it defaults to the first non-singleton dimension.\n\
 \n\
 This function is conceptually equivalent to computing\n\
+\n\
 @example\n\
 sum (x .* conj (x), dim)\n\
 @end example\n\
+\n\
 but it uses less memory and avoids calling @code{conj} if @var{x} is real.\n\
 @seealso{sum}\n\
 @end deftypefn")
 {
   DATA_REDUCTION (sumsq);
 }
 
 /*
@@ -2879,18 +2888,18 @@ the number of columns, or both are zero)
     print_usage ();
 
   return retval;
 }
 
 DEFUN (isnumeric, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} isnumeric (@var{x})\n\
-Return nonzero if @var{x} is a numeric object, i.e., an integer, real or complex array.\n\
-Logical and character arrays are not considered to be numeric.\n\
+Return nonzero if @var{x} is a numeric object, i.e., an integer, real or complex\n\
+array.  Logical and character arrays are not considered to be numeric.\n\
 @seealso{ischar, islogical, isinteger}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1)
     retval = args(0).is_numeric_type ();
   else
@@ -3380,17 +3389,17 @@ given dimensions.\n\
 If you need to create a matrix whose values are all the same, you should\n\
 use an expression like\n\
 \n\
 @example\n\
 val_matrix = val * ones (n, m)\n\
 @end example\n\
 \n\
 The optional argument @var{class} specifies the class of the return array\n\
-and defaults to double.  For example\n\
+and defaults to double.  For example:\n\
 \n\
 @example\n\
 val = ones (n,m, \"uint8\")\n\
 @end example\n\
 @seealso{zeros}\n\
 @end deftypefn")
 {
   return fill_matrix (args, 1, "ones");
@@ -3423,17 +3432,17 @@ DEFUN (zeros, args, ,
 @deftypefnx {Built-in Function} {} zeros (@dots{}, @var{class})\n\
 Return a matrix or N-dimensional array whose elements are all 0.\n\
 If invoked with a single scalar integer argument, return a square\n\
 matrix of the specified size.  If invoked with two or more scalar\n\
 integer arguments, or a vector of integer values, return an array with\n\
 given dimensions.\n\
 \n\
 The optional argument @var{class} specifies the class of the return array\n\
-and defaults to double.  For example\n\
+and defaults to double.  For example:\n\
 \n\
 @example\n\
 val = zeros (n,m, \"uint8\")\n\
 @end example\n\
 @seealso{ones}\n\
 @end deftypefn")
 {
   return fill_matrix (args, 0, "zeros");
@@ -3466,16 +3475,17 @@ DEFUN (Inf, args, ,
 @deftypefnx {Built-in Function} {} Inf (@var{n}, @var{m}, @var{k}, @dots{})\n\
 @deftypefnx {Built-in Function} {} Inf (@dots{}, @var{class})\n\
 Return a scalar, matrix or N-dimensional array whose elements are all equal\n\
 to the IEEE representation for positive infinity.\n\
 \n\
 Infinity is produced when results are too large to be represented using the\n\
 the IEEE floating point format for numbers.  Two common examples which\n\
 produce infinity are division by zero and overflow.\n\
+\n\
 @example\n\
 @group\n\
 [1/0 e^800]\n\
 @result{}\n\
 Inf   Inf\n\
 @end group\n\
 @end example\n\
 \n\
@@ -4041,25 +4051,25 @@ identity_matrix (int nr, int nc, oct_dat
 
   return retval;
 }
 
 #undef INT_EYE_MATRIX
 
 DEFUN (eye, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} eye (@var{x})\n\
+@deftypefn  {Built-in Function} {} eye (@var{x})\n\
 @deftypefnx {Built-in Function} {} eye (@var{n}, @var{m})\n\
 @deftypefnx {Built-in Function} {} eye (@dots{}, @var{class})\n\
 Return an identity matrix.  If invoked with a single scalar argument,\n\
 @code{eye} returns a square matrix with the dimension specified.  If you\n\
 supply two scalar arguments, @code{eye} takes them to be the number of\n\
 rows and columns.  If given a vector with two elements, @code{eye} uses\n\
 the values of the elements as the number of rows and columns,\n\
-respectively.  For example,\n\
+respectively.  For example:\n\
 \n\
 @example\n\
 @group\n\
 eye (3)\n\
      @result{}  1  0  0\n\
          0  1  0\n\
          0  0  1\n\
 @end group\n\
@@ -4284,17 +4294,17 @@ fewer than two values are requested.\n\
 
 */
 
 // FIXME -- should accept dimensions as separate args for N-d
 // arrays as well as 1-d and 2-d arrays.
 
 DEFUN (resize, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} resize (@var{x}, @var{m})\n\
+@deftypefn  {Built-in Function} {} resize (@var{x}, @var{m})\n\
 @deftypefnx {Built-in Function} {} resize (@var{x}, @var{m}, @var{n})\n\
 @deftypefnx {Built-in Function} {} resize (@var{x}, @var{m}, @var{n}, @dots{})\n\
 Resize @var{x} cutting off elements as necessary.\n\
 \n\
 In the result, element with certain indices is equal to the corresponding\n\
 element of @var{x} if the indices are within the bounds of @var{x};\n\
 otherwise, the element is set to zero.\n\
 \n\
@@ -4371,23 +4381,23 @@ Resizing an object to fewer dimensions i
     print_usage ();
   return retval;
 }
 
 // FIXME -- should use octave_idx_type for dimensions.
 
 DEFUN (reshape, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} reshape (@var{a}, @var{m}, @var{n}, @dots{})\n\
+@deftypefn  {Built-in Function} {} reshape (@var{a}, @var{m}, @var{n}, @dots{})\n\
 @deftypefnx {Built-in Function} {} reshape (@var{a}, @var{size})\n\
 Return a matrix with the given dimensions whose elements are taken\n\
 from the matrix @var{a}.  The elements of the matrix are accessed in\n\
 column-major order (like Fortran arrays are stored).\n\
 \n\
-For example,\n\
+For example:\n\
 \n\
 @example\n\
 @group\n\
 reshape ([1, 2, 3, 4], 2, 2)\n\
      @result{}  1  3\n\
          2  4\n\
 @end group\n\
 @end example\n\
@@ -4557,17 +4567,18 @@ a minimum of two dimensions and row vect
     print_usage ();    
 
   return retval;
 }
 
 DEFUN (full, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{FM} =} full (@var{SM})\n\
- returns a full storage matrix from a sparse, diagonal, permutation matrix or a range.\n\
+ returns a full storage matrix from a sparse, diagonal, permutation matrix or a\n\
+range.\n\
 @seealso{sparse}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1)
     retval = args(0).full_value ();
   else
@@ -4893,17 +4904,17 @@ binary_assoc_op_defun_body (octave_value
      break;
     }
 
   return retval;
 }
 
 DEFUN (plus, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} plus (@var{x}, @var{y})\n\
+@deftypefn  {Built-in Function} {} plus (@var{x}, @var{y})\n\
 @deftypefnx {Built-in Function} {} plus (@var{x1}, @var{x2}, @dots{})\n\
 This function is equivalent to @code{x + y}.\n\
 If more arguments are given, the summation is applied\n\
 cumulatively from left to right:\n\
 \n\
 @example\n\
   (@dots{}((x1 + x2) + x3) + @dots{})\n\
 @end example\n\
@@ -4921,17 +4932,17 @@ DEFUN (minus, args, ,
 This function is equivalent to @code{x - y}.\n\
 @end deftypefn")
 {
   return binary_op_defun_body (octave_value::op_sub, args);
 }
 
 DEFUN (mtimes, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} mtimes (@var{x}, @var{y})\n\
+@deftypefn  {Built-in Function} {} mtimes (@var{x}, @var{y})\n\
 @deftypefnx {Built-in Function} {} mtimes (@var{x1}, @var{x2}, @dots{})\n\
 This function is equivalent to @code{x * y}.\n\
 If more arguments are given, the multiplication is applied\n\
 cumulatively from left to right:\n\
 \n\
 @example\n\
   (@dots{}((x1 * x2) * x3) * @dots{})\n\
 @end example\n\
@@ -5021,17 +5032,17 @@ DEFUN (ne, args, ,
 This function is equivalent to @code{x != y}.\n\
 @end deftypefn")
 {
   return binary_op_defun_body (octave_value::op_ne, args);
 }
 
 DEFUN (times, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} times (@var{x}, @var{y})\n\
+@deftypefn  {Built-in Function} {} times (@var{x}, @var{y})\n\
 @deftypefnx {Built-in Function} {} times (@var{x1}, @var{x2}, @dots{})\n\
 This function is equivalent to @code{x .* y}.\n\
 If more arguments are given, the multiplication is applied\n\
 cumulatively from left to right:\n\
 \n\
 @example\n\
   (@dots{}((x1 .* x2) .* x3) .* @dots{})\n\
 @end example\n\
@@ -5067,17 +5078,17 @@ DEFUN (ldivide, args, ,
 This function is equivalent to @code{x .\\ y}.\n\
 @end deftypefn")
 {
   return binary_op_defun_body (octave_value::op_el_ldiv, args);
 }
 
 DEFUN (and, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} and (@var{x}, @var{y})\n\
+@deftypefn  {Built-in Function} {} and (@var{x}, @var{y})\n\
 @deftypefnx {Built-in Function} {} and (@var{x1}, @var{x2}, @dots{})\n\
 This function is equivalent to @code{x & y}.\n\
 If more arguments are given, the logical and is applied\n\
 cumulatively from left to right:\n\
 \n\
 @example\n\
   (@dots{}((x1 & x2) & x3) & @dots{})\n\
 @end example\n\
@@ -5086,17 +5097,17 @@ At least one argument is needed.\n\
 @end deftypefn")
 {
   return binary_assoc_op_defun_body (octave_value::op_el_and,
                                      octave_value::op_el_and_eq, args);
 }
 
 DEFUN (or, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} or (@var{x}, @var{y})\n\
+@deftypefn  {Built-in Function} {} or (@var{x}, @var{y})\n\
 @deftypefnx {Built-in Function} {} or (@var{x1}, @var{x2}, @dots{})\n\
 This function is equivalent to @code{x | y}.\n\
 If more arguments are given, the logical or is applied\n\
 cumulatively from left to right:\n\
 \n\
 @example\n\
   (@dots{}((x1 | x2) | x3) | @dots{})\n\
 @end example\n\
@@ -5107,17 +5118,17 @@ At least one argument is needed.\n\
   return binary_assoc_op_defun_body (octave_value::op_el_or,
                                      octave_value::op_el_or_eq, args);
 }
 
 static double tic_toc_timestamp = -1.0;
 
 DEFUN (tic, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} tic ()\n\
+@deftypefn  {Built-in Function} {} tic ()\n\
 @deftypefnx {Built-in Function} {} toc ()\n\
 Set or check a wall-clock timer.  Calling @code{tic} without an\n\
 output argument sets the timer.  Subsequent calls to @code{toc}\n\
 return the number of seconds since the timer was set.  For example,\n\
 \n\
 @example\n\
 @group\n\
 tic ();\n\
@@ -5143,17 +5154,17 @@ t = tic; sleep (5); (double (tic ()) - d
 Nested timing with @code{tic} and @code{toc} is not supported.\n\
 Therefore @code{toc} will always return the elapsed time from the most\n\
 recent call to @code{tic}.\n\
 \n\
 If you are more interested in the CPU time that your process used, you\n\
 should use the @code{cputime} function instead.  The @code{tic} and\n\
 @code{toc} functions report the actual wall clock time that elapsed\n\
 between the calls.  This may include time spent processing other jobs or\n\
-doing nothing at all.  For example,\n\
+doing nothing at all.  For example:\n\
 \n\
 @example\n\
 @group\n\
 tic (); sleep (5); toc ()\n\
      @result{} 5\n\
 t = cputime (); sleep (5); cputime () - t\n\
      @result{} 0\n\
 @end group\n\
@@ -5281,37 +5292,37 @@ CPU time used is nonzero.\n\
   retval (1) = usr;
   retval (0) = sys + usr;
 
   return retval;
 }
 
 DEFUN (sort, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {[@var{s}, @var{i}] =} sort (@var{x})\n\
+@deftypefn  {Loadable Function} {[@var{s}, @var{i}] =} sort (@var{x})\n\
 @deftypefnx {Loadable Function} {[@var{s}, @var{i}] =} sort (@var{x}, @var{dim})\n\
 @deftypefnx {Loadable Function} {[@var{s}, @var{i}] =} sort (@var{x}, @var{mode})\n\
 @deftypefnx {Loadable Function} {[@var{s}, @var{i}] =} sort (@var{x}, @var{dim}, @var{mode})\n\
 Return a copy of @var{x} with the elements arranged in increasing\n\
 order.  For matrices, @code{sort} orders the elements in each column.\n\
 \n\
-For example,\n\
+For example:\n\
 \n\
 @example\n\
 @group\n\
 sort ([1, 2; 2, 3; 3, 1])\n\
      @result{}  1  1\n\
          2  2\n\
          3  3\n\
 @end group\n\
 @end example\n\
 \n\
 The @code{sort} function may also be used to produce a matrix\n\
 containing the original row indices of the elements in the sorted\n\
-matrix.  For example,\n\
+matrix.  For example:\n\
 \n\
 @example\n\
 @group\n\
 [s, i] = sort ([1, 2; 2, 3; 3, 1])\n\
      @result{} s = 1  1\n\
             2  2\n\
             3  3\n\
      @result{} i = 1  3\n\
@@ -5674,17 +5685,17 @@ get_sort_mode_option (const octave_value
   else
     error ("issorted: expecting MODE to be \"ascending\", \"descending\", or \"either\"");
 
   return smode;
 }
 
 DEFUN (issorted, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} issorted (@var{a}, @var{mode})\n\
+@deftypefn  {Built-in Function} {} issorted (@var{a}, @var{mode})\n\
 @deftypefnx {Built-in Function} {} issorted (@var{a}, @code{\"rows\"}, @var{mode})\n\
 Returns true if the array is sorted according to @var{mode}, which\n\
 may be either \"ascending\", \"descending\", or \"either\".  By default,\n\
  @var{mode} is \"ascending\".  NaNs are treated as by @code{sort}.\n\
 If @var{rows} is supplied and has the value \"rows\", checks whether\n\
 the array is sorted by rows as if output by @code{sortrows} (with no\n\
 options).\n\
 \n\
@@ -5782,27 +5793,28 @@ This function does not yet support spars
 %!assert(issorted (sv, "either"));
 %!assert(issorted (fliplr (sv), "either"));
 %!assert(issorted (sv', "either"));
 %!assert(issorted (fliplr (sv)', "either"));
 */
 
 DEFUN (nth_element, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} nth_element (@var{x}, @var{n})\n\
+@deftypefn  {Built-in Function} {} nth_element (@var{x}, @var{n})\n\
 @deftypefnx {Built-in Function} {} nth_element (@var{x}, @var{n}, @var{dim})\n\
-Select the n-th smallest element of a vector, using the ordering defined by @code{sort}.\n\
-In other words, the result is equivalent to @code{sort(@var{x})(@var{n})}.\n\
+Select the n-th smallest element of a vector, using the ordering defined by\n\
+@code{sort}.  In other words, the result is equivalent to\n\
+@code{sort(@var{x})(@var{n})}.\n\
 @var{n} can also be a contiguous range, either ascending @code{l:u}\n\
 or descending @code{u:-1:l}, in which case a range of elements is returned.\n\
-If @var{x} is an array, @code{nth_element} operates along the dimension defined by @var{dim},\n\
-or the first non-singleton dimension if @var{dim} is not given.\n\
+If @var{x} is an array, @code{nth_element} operates along the dimension defined\n\
+by @var{dim}, or the first non-singleton dimension if @var{dim} is not given.\n\
 \n\
-nth_element encapsulates the C++ standard library algorithms nth_element and partial_sort.\n\
-On average, the complexity of the operation is O(M*log(K)), where\n\
+nth_element encapsulates the C++ standard library algorithms nth_element and\n\
+partial_sort.  On average, the complexity of the operation is O(M*log(K)), where\n\
 @code{M = size(@var{x}, @var{dim})} and @code{K = length (@var{n})}.\n\
 This function is intended for cases where the ratio K/M is small; otherwise,\n\
 it may be better to use @code{sort}.\n\
 @seealso{sort, min, max}\n\
 @end deftypefn")
 {
   octave_value retval;
   int nargin = args.length ();
@@ -6184,27 +6196,30 @@ do_merge (const Array<bool>& mask,
     { \
       retval = do_merge (mask, \
                          tval.INTX ## _array_value (), \
                          fval.INTX ## _array_value ()); \
     }
 
 DEFUN (merge, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} merge (@var{mask}, @var{tval}, @var{fval})\n\
+@deftypefn  {Built-in Function} {} merge (@var{mask}, @var{tval}, @var{fval})\n\
 @deftypefnx {Built-in Function} {} ifelse (@var{mask}, @var{tval}, @var{fval})\n\
 Merges elements of @var{true_val} and @var{false_val}, depending on the value of\n\
 @var{mask}.  If @var{mask} is a logical scalar, the other two arguments can be\n\
-arbitrary values.  Otherwise, @var{mask} must be a logical array, and @var{tval},\n\
+arbitrary values.  Otherwise, @var{mask} must be a logical array, and\n\
+@var{tval},\n\
 @var{fval} should be arrays of matching class, or cell arrays.\n\
 In the scalar mask case, @var{tval} is returned if @var{mask} is true, otherwise\n\
 @var{fval} is returned.\n\
 \n\
 In the array mask case, both @var{tval} and @var{fval} must be either scalars or\n\
-arrays with dimensions equal to @var{mask}.  The result is constructed as follows:\n\
+arrays with dimensions equal to @var{mask}.  The result is constructed as\n\
+follows: \n\
+\n\
 @example\n\
 @group\n\
 result(mask) = tval(mask);\n\
 result(! mask) = fval(! mask);\n\
 @end group\n\
 @end example\n\
 \n\
 @var{mask} can also be arbitrary numeric type, in which case\n\
@@ -6538,20 +6553,22 @@ Entries in the first row, @var{r}(1,j), 
 The corresponding entry in the second row, @var{r}(2,j), specifies\n\
 the repeat count.  If @var{x} is a matrix then the columns of @var{x} are\n\
 imagined to be stacked on top of each other for purposes of the selection\n\
 index.  A row vector is always returned.\n\
 \n\
 Conceptually the result is calculated as follows:\n\
 \n\
 @example\n\
+@group\n\
 y = [];\n\
 for i = 1:columns (@var{r})\n\
   y = [y, @var{x}(@var{r}(1,i)*ones(1, @var{r}(2,i)))];\n\
 endfor\n\
+@end group\n\
 @end example\n\
 @seealso{repmat}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 2)
     {
diff --git a/src/debug.cc b/src/debug.cc
--- a/src/debug.cc
+++ b/src/debug.cc
@@ -482,16 +482,17 @@ intmap_to_ov (const bp_table::intmap& li
 DEFUN (dbstop, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{rline} =} dbstop (@var{func}, @var{line}, @dots{})\n\
 Set a breakpoint in a function\n\
 @table @code\n\
 @item func\n\
 String representing the function name.  When already in debug\n\
 mode this should be left out and only the line should be given.\n\
+\n\
 @item line\n\
 Line number you would like the breakpoint to be set on.  Multiple\n\
 lines might be given as separate arguments or as a vector.\n\
 @end table\n\
 \n\
 The rline returned is the real line that the breakpoint was set at.\n\
 @seealso{dbclear, dbstatus, dbstep}\n\
 @end deftypefn")
@@ -514,16 +515,17 @@ The rline returned is the real line that
 DEFUN (dbclear, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} dbclear (@var{func}, @var{line}, @dots{})\n\
 Delete a breakpoint in a function\n\
 @table @code\n\
 @item func\n\
 String representing the function name.  When already in debug\n\
 mode this should be left out and only the line should be given.\n\
+\n\
 @item line\n\
 Line number where you would like to remove the breakpoint.  Multiple\n\
 lines might be given as separate arguments or as a vector.\n\
 @end table\n\
 No checking is done to make sure that the line you requested is really\n\
 a breakpoint.  If you get the wrong line nothing will happen.\n\
 @seealso{dbstop, dbstatus, dbwhere}\n\
 @end deftypefn")
diff --git a/src/defaults.cc b/src/defaults.cc
--- a/src/defaults.cc
+++ b/src/defaults.cc
@@ -391,58 +391,58 @@ install_defaults (void)
 
   set_local_site_defaults_file ();
 
   set_site_defaults_file ();
 }
 
 DEFUN (EDITOR, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {@var{val} =} EDITOR ()\n\
+@deftypefn  {Built-in Function} {@var{val} =} EDITOR ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} EDITOR (@var{new_val})\n\
 Query or set the internal variable that specifies the editor to\n\
 use with the @code{edit_history} command.  The default value is taken from\n\
-the environment variable @w{@code{EDITOR}} when Octave starts.  If the\n\
-environment variable is not initialized, @w{@code{EDITOR}} will be set to\n\
+the environment variable @w{@env{EDITOR}} when Octave starts.  If the\n\
+environment variable is not initialized, @w{@env{EDITOR}} will be set to\n\
 @code{\"emacs\"}.\n\
 @seealso{edit_history}\n\
 @end deftypefn")
 {
   return SET_NONEMPTY_INTERNAL_STRING_VARIABLE (EDITOR);
 }
 
 DEFUN (EXEC_PATH, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {@var{val} =} EXEC_PATH ()\n\
+@deftypefn  {Built-in Function} {@var{val} =} EXEC_PATH ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} EXEC_PATH (@var{new_val})\n\
 Query or set the internal variable that specifies a colon separated\n\
 list of directories to search when executing external programs.\n\
 Its initial value is taken from the environment variable\n\
-@w{@code{OCTAVE_EXEC_PATH}} (if it exists) or @code{PATH}, but that\n\
+@w{@env{OCTAVE_EXEC_PATH}} (if it exists) or @env{PATH}, but that\n\
 value can be overridden by the command line argument\n\
-@code{--exec-path PATH}.  At startup, an additional set of\n\
+@option{--exec-path PATH}.  At startup, an additional set of\n\
 directories (including the shell PATH) is appended to the path\n\
 specified in the environment or on the command line.  If you use\n\
-the @w{@code{EXEC_PATH}} function to modify the path, you should take\n\
+the @w{@env{EXEC_PATH}} function to modify the path, you should take\n\
 care to preserve these additional directories.\n\
 @end deftypefn")
 {
   std::string saved_exec_path = VEXEC_PATH;
 
   octave_value retval = SET_NONEMPTY_INTERNAL_STRING_VARIABLE (EXEC_PATH);
 
   if (VEXEC_PATH != saved_exec_path)
     octave_env::putenv ("PATH", VEXEC_PATH);
 
   return retval;
 }
 
 DEFUN (IMAGE_PATH, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {@var{val} =} IMAGE_PATH ()\n\
+@deftypefn  {Built-in Function} {@var{val} =} IMAGE_PATH ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} IMAGE_PATH (@var{new_val})\n\
 Query or set the internal variable that specifies a colon separated\n\
 list of directories in which to search for image files.\n\
 @end deftypefn")
 {
   return SET_NONEMPTY_INTERNAL_STRING_VARIABLE (IMAGE_PATH);
 }
 
diff --git a/src/dirfns.cc b/src/dirfns.cc
--- a/src/dirfns.cc
+++ b/src/dirfns.cc
@@ -96,17 +96,17 @@ Change the current working directory to 
 omitted, the current directory is changed to the user's home\n\
 directory.  For example,\n\
 \n\
 @example\n\
 cd ~/octave\n\
 @end example\n\
 \n\
 @noindent\n\
-Changes the current working directory to @file{~/octave}.  If the\n\
+changes the current working directory to @file{~/octave}.  If the\n\
 directory does not exist, an error message is printed and the working\n\
 directory is not changed.\n\
 @seealso{mkdir, rmdir, dir}\n\
 @end deffn")
 {
   octave_value_list retval;
 
   int argc = args.length () + 1;
@@ -195,17 +195,17 @@ system-dependent error message.\n\
   return retval;
 }
 
 // FIXME -- should maybe also allow second arg to specify
 // mode?  OTOH, that might cause trouble with compatibility later...
 
 DEFUNX ("mkdir", Fmkdir, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {[@var{status}, @var{msg}, @var{msgid}] =} mkdir (@var{dir})\n\
+@deftypefn  {Built-in Function} {[@var{status}, @var{msg}, @var{msgid}] =} mkdir (@var{dir})\n\
 @deftypefnx {Built-in Function} {[@var{status}, @var{msg}, @var{msgid}] =} mkdir (@var{parent}, @var{dir})\n\
 Create a directory named @var{dir} in the directory @var{parent}.\n\
 \n\
 If successful, @var{status} is 1, with @var{msg} and @var{msgid} empty\n\
 character strings.  Otherwise, @var{status} is 0, @var{msg} contains a\n\
 system-dependent error message, and @var{msgid} contains a unique\n\
 message identifier.\n\
 @seealso{rmdir}\n\
@@ -278,17 +278,17 @@ message identifier.\n\
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("rmdir", Frmdir, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {[@var{status}, @var{msg}, @var{msgid}] =} rmdir (@var{dir})\n\
+@deftypefn  {Built-in Function} {[@var{status}, @var{msg}, @var{msgid}] =} rmdir (@var{dir})\n\
 @deftypefnx {Built-in Function} {[@var{status}, @var{msg}, @var{msgid}] =} rmdir (@var{dir}, @code{\"s\"})\n\
 Remove the directory named @var{dir}.\n\
 \n\
 If successful, @var{status} is 1, with @var{msg} and @var{msgid} empty\n\
 character strings.  Otherwise, @var{status} is 0, @var{msg} contains a\n\
 system-dependent error message, and @var{msgid} contains a unique\n\
 message identifier.\n\
 \n\
@@ -549,16 +549,17 @@ Given an array of pattern strings (as a 
 them, or an empty cell array if no patterns match.  The pattern strings are \n\
 interpreted as filename globbing patterns (as they are used by Unix shells).\n\
 Within a pattern\n\
 @table @code\n\
 @itemx *\n\
 matches any string, including the null string,\n\
 @itemx ?\n\
 matches any single character, and\n\
+\n\
 @item [@dots{}]\n\
 matches any of the enclosed characters.\n\
 @end table\n\
 \n\
 Tilde expansion\n\
 is performed on each of the patterns before looking for matching file\n\
 names.  For example:\n\
 \n\
@@ -641,17 +642,17 @@ glob (\"file[12]\")\n\
 %!  assert (result3, {"file1"; "file2"});
 */
 
 DEFUN (fnmatch, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} fnmatch (@var{pattern}, @var{string})\n\
 Return 1 or zero for each element of @var{string} that matches any of\n\
 the elements of the string array @var{pattern}, using the rules of\n\
-filename pattern matching.  For example,\n\
+filename pattern matching.  For example:\n\
 \n\
 @example\n\
 @group\n\
 fnmatch (\"a*b\", @{\"ab\"; \"axyzb\"; \"xyzab\"@})\n\
      @result{} [ 1; 1; 0 ]\n\
 @end group\n\
 @end example\n\
 @end deftypefn")
@@ -675,17 +676,17 @@ fnmatch (\"a*b\", @{\"ab\"; \"axyzb\"; \
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (filesep, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} filesep ()\n\
+@deftypefn  {Built-in Function} {} filesep ()\n\
 @deftypefnx {Built-in Function} {} filesep ('all')\n\
 Return the system-dependent character used to separate directory names.\n\
 \n\
 If 'all' is given, the function return all valid file separators in\n\
 the form of a string.  The list of file separators is system-dependent.\n\
 It is / (forward slash) under UNIX or Mac OS X, / and \\ (forward and\n\
 backward slashes) under Windows.\n\
 @seealso{pathsep, dir, ls}\n\
@@ -712,17 +713,17 @@ backward slashes) under Windows.\n\
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (pathsep, args, nargout,
     "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {@var{val} =} pathsep ()\n\
+@deftypefn  {Built-in Function} {@var{val} =} pathsep ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} pathsep (@var{new_val})\n\
 Query or set the character used to separate directories in\n\
 a path.\n\
 @seealso{filesep, dir, ls}\n\
 @end deftypefn")
 {
   octave_value retval;
 
@@ -758,16 +759,16 @@ a path.\n\
   else if (nargin > 1)
     print_usage ();
 
   return retval;
 }
 
 DEFUN (confirm_recursive_rmdir, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {@var{val} =} confirm_recursive_rmdir ()\n\
+@deftypefn  {Built-in Function} {@var{val} =} confirm_recursive_rmdir ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} confirm_recursive_rmdir (@var{new_val})\n\
 Query or set the internal variable that controls whether Octave\n\
 will ask for confirmation before recursively removing a directory tree.\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (confirm_recursive_rmdir);
 }
diff --git a/src/error.cc b/src/error.cc
--- a/src/error.cc
+++ b/src/error.cc
@@ -968,17 +968,17 @@ location of the error.  Typically @var{e
             error ("rethrow: structure must contain the fields 'message and 'identifier'");
         }
     }
   return retval;
 }
 
 DEFUN (error, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} error (@var{template}, @dots{})\n\
+@deftypefn  {Built-in Function} {} error (@var{template}, @dots{})\n\
 @deftypefnx {Built-in Function} {} error (@var{id}, @var{template}, @dots{})\n\
 Format the optional arguments under the control of the template string\n\
 @var{template} using the same rules as the @code{printf} family of\n\
 functions (@pxref{Formatted Output}) and print the resulting message\n\
 on the @code{stderr} stream.  The message is prefixed by the character\n\
 string @samp{error: }.\n\
 \n\
 Calling @code{error} also sets Octave's internal error state such that\n\
@@ -1092,17 +1092,17 @@ error: nargin != 1\n\
       handle_message (error_with_id, id.c_str (), "unspecified error", nargs);
     }
 
   return retval;
 }
 
 DEFUN (warning, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} warning (@var{template}, @dots{})\n\
+@deftypefn  {Built-in Function} {} warning (@var{template}, @dots{})\n\
 @deftypefnx {Built-in Function} {} warning (@var{id}, @var{template}, @dots{})\n\
 Format the optional arguments under the control of the template string\n\
 @var{template} using the same rules as the @code{printf} family of\n\
 functions (@pxref{Formatted Output}) and print the resulting message\n\
 on the @code{stderr} stream.  The message is prefixed by the character\n\
 string @samp{warning: }.\n\
 You should use this function when you want to notify the user\n\
 of an unusual condition, but only when it makes sense for your program\n\
@@ -1474,39 +1474,44 @@ initialize_default_warning_state (void)
 
   // This should be an error unless we are in maximum braindamage mode.
 
   set_warning_state ("Octave:allow-noninteger-ranges-as-indices", "error");
 }
 
 DEFUN (lasterror, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {@var{err} =} lasterror (@var{err})\n\
+@deftypefn  {Built-in Function} {@var{err} =} lasterror (@var{err})\n\
 @deftypefnx {Built-in Function} {} lasterror ('reset')\n\
 Returns or sets the last error message.  Called without any arguments\n\
 returns a structure containing the last error message, as well as other\n\
 information related to this error.  The elements of this structure are:\n\
 \n\
 @table @asis\n\
 @item 'message'\n\
 The text of the last error message\n\
+\n\
 @item 'identifier'\n\
 The message identifier of this error message\n\
+\n\
 @item 'stack'\n\
 A structure containing information on where the message occurred.  This might\n\
 be an empty structure if this in the case where this information cannot\n\
 be obtained.  The fields of this structure are:\n\
 \n\
 @table @asis\n\
 @item 'file'\n\
 The name of the file where the error occurred\n\
+\n\
 @item 'name'\n\
 The name of function in which the error occurred\n\
+\n\
 @item 'line'\n\
 The line number at which the error occurred\n\
+\n\
 @item 'column'\n\
 An optional field with the column number at which the error occurred\n\
 @end table\n\
 @end table\n\
 \n\
 The @var{err} structure may also be passed to @code{lasterror} to set the\n\
 information about the last error.  The only constraint on @var{err} in that\n\
 case is that it is a scalar structure.  Any fields of @var{err} that match\n\
@@ -1755,41 +1760,41 @@ to check for the proper number of argume
 {
   octave_value_list retval;
   handle_message (usage_with_id, "", "unknown", args);
   return retval;
 }
 
 DEFUN (beep_on_error, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {@var{val} =} beep_on_error ()\n\
+@deftypefn  {Built-in Function} {@var{val} =} beep_on_error ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} beep_on_error (@var{new_val})\n\
 Query or set the internal variable that controls whether Octave will try\n\
 to ring the terminal bell before printing an error message.\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (beep_on_error);
 }
 
 DEFUN (debug_on_error, args, nargout,
     "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {@var{val} =} debug_on_error ()\n\
+@deftypefn  {Built-in Function} {@var{val} =} debug_on_error ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} debug_on_error (@var{new_val})\n\
 Query or set the internal variable that controls whether Octave will try\n\
 to enter the debugger when an error is encountered.  This will also\n\
 inhibit printing of the normal traceback message (you will only see\n\
 the top-level error message).\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (debug_on_error);
 }
 
 DEFUN (debug_on_warning, args, nargout,
     "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {@var{val} =} debug_on_warning ()\n\
+@deftypefn  {Built-in Function} {@var{val} =} debug_on_warning ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} debug_on_warning (@var{new_val})\n\
 Query or set the internal variable that controls whether Octave will try\n\
 to enter the debugger when a warning is encountered.\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (debug_on_warning);
 }
 
diff --git a/src/file-io.cc b/src/file-io.cc
--- a/src/file-io.cc
+++ b/src/file-io.cc
@@ -546,17 +546,17 @@ do_stream_open (const octave_value& tc_n
   else
     ::error ("%s: file name must be a string", fcn);
 
   return retval;
 }
 
 DEFUN (fopen, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {[@var{fid}, @var{msg}] =} fopen (@var{name}, @var{mode}, @var{arch})\n\
+@deftypefn  {Built-in Function} {[@var{fid}, @var{msg}] =} fopen (@var{name}, @var{mode}, @var{arch})\n\
 @deftypefnx {Built-in Function} {@var{fid_list} =} fopen (\"all\")\n\
 @deftypefnx {Built-in Function} {[@var{file}, @var{mode}, @var{arch}] =} fopen (@var{fid})\n\
 The first form of the @code{fopen} function opens the named file with\n\
 the specified mode (read-write, read-only, etc.) and architecture\n\
 interpretation (IEEE big endian, IEEE little endian, etc.), and returns\n\
 an integer value that may be used to refer to the file later.  If an\n\
 error occurs, @var{fid} is set to @minus{}1 and @var{msg} contains the\n\
 corresponding system error message.  The @var{mode} is a one or two\n\
@@ -714,17 +714,17 @@ however, conversions are currently only 
 
   return retval;
 }
 
 DEFUN (freport, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} freport ()\n\
 Print a list of which files have been opened, and whether they are open\n\
-for reading, writing, or both.  For example,\n\
+for reading, writing, or both.  For example:\n\
 \n\
 @example\n\
 @group\n\
 freport ()\n\
 \n\
      @print{}  number  mode  name\n\
      @print{} \n\
      @print{}       0     r  stdin\n\
@@ -1056,17 +1056,17 @@ converted.\n\
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (fscanf, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {[@var{val}, @var{count}] =} fscanf (@var{fid}, @var{template}, @var{size})\n\
+@deftypefn  {Built-in Function} {[@var{val}, @var{count}] =} fscanf (@var{fid}, @var{template}, @var{size})\n\
 @deftypefnx {Built-in Function} {[@var{v1}, @var{v2}, @dots{}, @var{count}] =} fscanf (@var{fid}, @var{template}, \"C\")\n\
 In the first form, read from @var{fid} according to @var{template},\n\
 returning the result in the matrix @var{val}.\n\
 \n\
 The optional argument @var{size} specifies the amount of data to read\n\
 and may be one of\n\
 \n\
 @table @code\n\
@@ -1164,17 +1164,17 @@ complete description of the syntax of th
         print_usage ();
     }
 
   return retval;
 }
 
 DEFUN (sscanf, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {[@var{val}, @var{count}] =} sscanf (@var{string}, @var{template}, @var{size})\n\
+@deftypefn  {Built-in Function} {[@var{val}, @var{count}] =} sscanf (@var{string}, @var{template}, @var{size})\n\
 @deftypefnx {Built-in Function} {[@var{v1}, @var{v2}, @dots{}, @var{count}] =} sscanf (@var{string}, @var{template}, \"C\")\n\
 This is like @code{fscanf}, except that the characters are taken from the\n\
 string @var{string} instead of from a stream.  Reaching the end of the\n\
 string is treated as an end-of-file condition.\n\
 @seealso{fscanf, scanf, sprintf}\n\
 @end deftypefn")
 {
   static std::string who = "sscanf";
@@ -1259,17 +1259,17 @@ string is treated as an end-of-file cond
         print_usage ();
     }
 
   return retval;
 }
 
 DEFUN (scanf, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {[@var{val}, @var{count}] =} scanf (@var{template}, @var{size})\n\
+@deftypefn  {Built-in Function} {[@var{val}, @var{count}] =} scanf (@var{template}, @var{size})\n\
 @deftypefnx {Built-in Function} {[@var{v1}, @var{v2}, @dots{}, @var{count}]] =} scanf (@var{template}, \"C\")\n\
 This is equivalent to calling @code{fscanf} with @var{fid} = @code{stdin}.\n\
 \n\
 It is currently not useful to call @code{scanf} in interactive\n\
 programs.\n\
 @seealso{fscanf, sscanf, printf}\n\
 @end deftypefn")
 {
@@ -1766,17 +1766,17 @@ or output stream of the process is retur
 The pipe will be connected to the standard output of the process, and\n\
 open for reading.\n\
 \n\
 @item \"w\"\n\
 The pipe will be connected to the standard input of the process, and\n\
 open for writing.\n\
 @end table\n\
 \n\
-For example,\n\
+For example:\n\
 \n\
 @example\n\
 @group\n\
 fid = popen (\"ls -ltr / | tail -3\", \"r\");\n\
 while (ischar (s = fgets (fid)))\n\
   fputs (stdout, s);\n\
 endwhile\n\
      @print{} drwxr-xr-x  33 root  root  3072 Feb 15 13:28 etc\n\
@@ -2170,17 +2170,17 @@ this system.  The name of this directory
   return retval;
 }
 
 // NOTE: the values of SEEK_SET, SEEK_CUR, and SEEK_END have to be
 // this way for Matlab compatibility.
 
 DEFUNX ("SEEK_SET", FSEEK_SET, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} SEEK_SET ()\n\
+@deftypefn  {Built-in Function} {} SEEK_SET ()\n\
 @deftypefnx {Built-in Function} {} SEEK_CUR ()\n\
 @deftypefnx {Built-in Function} {} SEEK_END ()\n\
 Return the value required to request that @code{fseek} perform\n\
 one of the following actions:\n\
 @table @code\n\
 @item SEEK_SET\n\
 Position file relative to the beginning.\n\
 \n\
diff --git a/src/graphics.cc b/src/graphics.cc
--- a/src/graphics.cc
+++ b/src/graphics.cc
@@ -5073,17 +5073,17 @@ Return true if @var{h} is a graphics han
     print_usage ();
 
   return retval;
 }
 
 DEFUN (reset, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} reset (@var{h}, @var{property})\n\
-Removes any defaults set for the handle @var{h}. The default figure\n\
+Removes any defaults set for the handle @var{h}.  The default figure\n\
 properties \"position\", \"units\", \"windowstyle\" and\n\
 \"paperunits\" and the default axes properties \"position\" and \"units\"\n\
 are not reset.\n\
 @end deftypefn")
 {
   int nargin = args.length ();
 
   if (nargin != 1)
@@ -5101,38 +5101,41 @@ are not reset.\n\
         }
     }
 
   return octave_value ();
 }
 
 DEFUN (set, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} set (@var{h}, @var{property}, @var{value}, @dots{})\n\
+@deftypefn  {Built-in Function} {} set (@var{h}, @var{property}, @var{value}, @dots{})\n\
 @deftypefnx {Built-in Function} {} set (@var{h}, @var{properties}, @var{values})\n\
 @deftypefnx {Built-in Function} {} set (@var{h}, @var{pv})\n\
 Set named property values for the graphics handle (or vector of graphics\n\
 handles) @var{h}.\n\
 There are three ways how to give the property names and values:\n\
 \n\
 @itemize\n\
 @item as a comma separated list of @var{property}, @var{value} pairs\n\
 \n\
 Here, each @var{property} is a string containing the property name, each\n\
 @var{value} is a value of the appropriate type for the property.\n\
+\n\
 @item as a cell array of strings @var{properties} containing property names\n\
 and a cell array @var{values} containing property values.\n\
 \n\
 In this case, the number of columns of @var{values} must match the number of\n\
 elements in @var{properties}.  The first column of @var{values} contains values\n\
-for the first entry in @var{properties}, etc.  The number of rows of @var{values}\n\
-must be 1 or match the number of elements of @var{h}.  In the first case, each\n\
-handle in @var{h} will be assigned the same values.  In the latter case, the\n\
-first handle in @var{h} will be assigned the values from the first row of\n\
+for the first entry in @var{properties}, etc.  The number of rows of\n\
+@var{values} must be 1 or match the number of elements of @var{h}.  In the first\n\
+case, each handle in @var{h} will be assigned the same values.  In the latter\n\
+case, the first handle in @var{h} will be assigned the values from the first row\n\
+of\n\
 @var{values} and so on.\n\
+\n\
 @item as a structure array @var{pv}\n\
 \n\
 Here, the field names of @var{pv} represent the property names, and the field\n\
 values give the property values.  In contrast to the previous case, all\n\
 elements of @var{pv} will be set in all handles in @var{h} independent of\n\
 the dimensions of @var{pv}.\n\
 @end itemize\n\
 @end deftypefn")
@@ -5710,17 +5713,17 @@ Undocumented internal function.\n\
 {
   gh_manager::autolock guard;
 
   return octave_value (gh_manager::figure_handle_list ());
 }
 
 DEFUN (__go_execute_callback__, args, ,
    "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} __go_execute_callback__ (@var{h}, @var{name})\n\
+@deftypefn  {Built-in Function} {} __go_execute_callback__ (@var{h}, @var{name})\n\
 @deftypefnx {Built-in Function} {} __go_execute_callback__ (@var{h}, @var{name}, @var{param})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
@@ -6080,40 +6083,47 @@ Create a new property named @var{name} i
 usually contains the default value of the property, but additional\n\
 arguments might be given, depending on the type of the property.\n\
 \n\
 The supported property types are:\n\
 \n\
 @table @code\n\
 @item string\n\
 A string property.  @var{arg} contains the default string value.\n\
+\n\
 @item any\n\
 An un-typed property.  This kind of property can hold any octave\n\
 value.  @var{args} contains the default value.\n\
+\n\
 @item radio\n\
 A string property with a limited set of accepted values.  The first\n\
 argument must be a string with all accepted values separated by\n\
 a vertical bar ('|').  The default value can be marked by enclosing\n\
 it with a '@{' '@}' pair.  The default value may also be given as\n\
 an optional second string argument.\n\
+\n\
 @item boolean\n\
 A boolean property.  This property type is equivalent to a radio\n\
 property with \"on|off\" as accepted values.  @var{arg} contains\n\
 the default property value.\n\
+\n\
 @item double\n\
 A scalar double property.  @var{arg} contains the default value.\n\
+\n\
 @item handle\n\
 A handle property.  This kind of property holds the handle of a\n\
 graphics object.  @var{arg} contains the default handle value.\n\
 When no default value is given, the property is initialized to\n\
 the empty matrix.\n\
+\n\
 @item data\n\
 A data (matrix) property.  @var{arg} contains the default data\n\
 value.  When no default value is given, the data is initialized to\n\
 the empty matrix.\n\
+\n\
 @item color\n\
 A color property.  @var{arg} contains the default color value.\n\
 When no default color is given, the property is set to black.\n\
 An optional second string argument may be given to specify an\n\
 additional set of accepted string values (like a radio property).\n\
 @end table\n\
 \n\
 @var{type} may also be the concatenation of a core object type and\n\
diff --git a/src/help.cc b/src/help.cc
--- a/src/help.cc
+++ b/src/help.cc
@@ -281,17 +281,18 @@ Alternate action for an if block.  See @
 @deffn Keyword elseif (@var{condition})\n\
 Alternate conditional test for an if block.  See @code{if} for an example.\n\
 @seealso{if}\n\
 @end deffn"),
 
   pair_type ("end",
     "-*- texinfo -*-\n\
 @deffn Keyword end\n\
-Mark the end of any @code{for}, @code{if}, @code{do}, @code{while}, or @code{function} block.\n\
+Mark the end of any @code{for}, @code{if}, @code{do}, @code{while}, or\n\
+@code{function} block.\n\
 @seealso{for, if, do, while, function}\n\
 @end deffn"),
 
   pair_type ("end_try_catch",
     "-*- texinfo -*-\n\
 @deffn Keyword end_try_catch\n\
 Mark the end of an @code{try-catch} block.\n\
 @seealso{try, catch}\n\
@@ -338,16 +339,17 @@ Mark the end of a switch block.  See @co
 Mark the end of a while loop.  See @code{while} for an example.\n\
 @seealso{do, while}\n\
 @end deffn"),
 
   pair_type ("for",
     "-*- texinfo -*-\n\
 @deffn Keyword for @var{i} = @var{range}\n\
 Begin a for loop.\n\
+\n\
 @example\n\
 @group\n\
 for i = 1:10\n\
   i\n\
 endfor\n\
 @end group\n\
 @end example\n\
 @seealso{do, while}\n\
@@ -362,16 +364,17 @@ Begin a function body with @var{outputs}
 parameters.\n\
 @seealso{return}\n\
 @end deffn"),
 
   pair_type ("global",
     "-*- texinfo -*-\n\
 @deffn Keyword global\n\
 Declare variables to have global scope.\n\
+\n\
 @example\n\
 @group\n\
 global @var{x};\n\
 if isempty (@var{x})\n\
   x = 1;\n\
 endif\n\
 @end group\n\
 @end example\n\
@@ -380,16 +383,17 @@ endif\n\
 
   pair_type ("if",
     "-*- texinfo -*-\n\
 @deffn Keyword if (@var{cond}) @dots{} endif\n\
 @deffnx Keyword if (@var{cond}) @dots{} else @dots{} endif\n\
 @deffnx Keyword if (@var{cond}) @dots{} elseif (@var{cond}) @dots{} endif\n\
 @deffnx Keyword if (@var{cond}) @dots{} elseif (@var{cond}) @dots{} else @dots{} endif\n\
 Begin an if block.\n\
+\n\
 @example\n\
 @group\n\
 x = 1;\n\
 if (x == 1)\n\
   disp (\"one\");\n\
 elseif (x == 2)\n\
   disp (\"two\");\n\
 else\n\
@@ -438,16 +442,17 @@ Return from a function.\n\
 This function has been deprecated in favor of persistent.\n\
 @seealso{persistent}\n\
 @end deffn"),
 
   pair_type ("switch",
     "-*- texinfo -*-\n\
 @deffn Keyword switch @var{statement}\n\
 Begin a switch block.\n\
+\n\
 @example\n\
 @group\n\
 yesno = \"yes\"\n\
 \n\
 switch yesno\n\
   case @{\"Yes\" \"yes\" \"YES\" \"y\" \"Y\"@}\n\
     value = 1;\n\
   case @{\"No\" \"no\" \"NO\" \"n\" \"N\"@}\n\
@@ -999,18 +1004,18 @@ file_is_in_dir (const std::string filena
 }
 
 // Return a cell array of strings containing the names of all
 // functions available in DIRECTORY.  If no directory is given, search
 // the current path.
 
 DEFUN (__list_functions__, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Function File} {@var{retval} =} __list_functions__ ()\n\
-@deftypefnx{Function File} {@var{retval} =} __list_functions__ (@var{directory})\n\
+@deftypefn  {Function File} {@var{retval} =} __list_functions__ ()\n\
+@deftypefnx {Function File} {@var{retval} =} __list_functions__ (@var{directory})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   // Get list of functions
   string_vector ffl = load_path::fcn_names ();
   string_vector afl = autoloaded_functions ();
@@ -1039,85 +1044,85 @@ Undocumented internal function.\n\
         error ("__list_functions__: input must be a string");
     }  
 
   return retval;
 }
 
 DEFUN (doc_cache_file, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {@var{val} =} doc_cache_file ()\n\
+@deftypefn  {Built-in Function} {@var{val} =} doc_cache_file ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} doc_cache_file (@var{new_val})\n\
 Query or set the internal variable that specifies the name of the\n\
 Octave documentation cache file.  A cache file significantly improves\n\
 the performance of the @code{lookfor} command.  The default value is \n\
 @file{@var{octave-home}/share/octave/@var{version}/etc/doc-cache},\n\
 in which @var{octave-home} is the root directory of the Octave installation,\n\
 and @var{version} is the Octave version number.\n\
 The default value may be overridden by the environment variable\n\
-@w{@code{OCTAVE_DOC_CACHE_FILE}}, or the command line argument\n\
+@w{@env{OCTAVE_DOC_CACHE_FILE}}, or the command line argument\n\
 @samp{--doc-cache-file NAME}.\n\
 @seealso{lookfor, info_program, doc, help, makeinfo_program}\n\
 @end deftypefn")
 {
   return SET_NONEMPTY_INTERNAL_STRING_VARIABLE (doc_cache_file);
 }
 
 DEFUN (info_file, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {@var{val} =} info_file ()\n\
+@deftypefn  {Built-in Function} {@var{val} =} info_file ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} info_file (@var{new_val})\n\
 Query or set the internal variable that specifies the name of the\n\
 Octave info file.  The default value is\n\
 @file{@var{octave-home}/info/octave.info}, in\n\
 which @var{octave-home} is the root directory of the Octave installation.\n\
 The default value may be overridden by the environment variable\n\
-@w{@code{OCTAVE_INFO_FILE}}, or the command line argument\n\
+@w{@env{OCTAVE_INFO_FILE}}, or the command line argument\n\
 @samp{--info-file NAME}.\n\
 @seealso{info_program, doc, help, makeinfo_program}\n\
 @end deftypefn")
 {
   return SET_NONEMPTY_INTERNAL_STRING_VARIABLE (info_file);
 }
 
 DEFUN (info_program, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {@var{val} =} info_program ()\n\
+@deftypefn  {Built-in Function} {@var{val} =} info_program ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} info_program (@var{new_val})\n\
 Query or set the internal variable that specifies the name of the\n\
 info program to run.  The default value is\n\
 @file{@var{octave-home}/libexec/octave/@var{version}/exec/@var{arch}/info}\n\
 in which @var{octave-home} is the root directory of the Octave installation,\n\
 @var{version} is the Octave version number, and @var{arch}\n\
 is the system type (for example, @code{i686-pc-linux-gnu}).  The\n\
 default value may be overridden by the environment variable\n\
-@w{@code{OCTAVE_INFO_PROGRAM}}, or the command line argument\n\
+@w{@env{OCTAVE_INFO_PROGRAM}}, or the command line argument\n\
 @samp{--info-program NAME}.\n\
 @seealso{info_file, doc, help, makeinfo_program}\n\
 @end deftypefn")
 {
   return SET_NONEMPTY_INTERNAL_STRING_VARIABLE (info_program);
 }
 
 DEFUN (makeinfo_program, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {@var{val} =} makeinfo_program ()\n\
+@deftypefn  {Built-in Function} {@var{val} =} makeinfo_program ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} makeinfo_program (@var{new_val})\n\
 Query or set the internal variable that specifies the name of the\n\
 program that Octave runs to format help text containing\n\
 Texinfo markup commands.  The default value is @code{makeinfo}.\n\
 @seealso{info_file, info_program, doc, help}\n\
 @end deftypefn")
 {
   return SET_NONEMPTY_INTERNAL_STRING_VARIABLE (makeinfo_program);
 }
 
 DEFUN (suppress_verbose_help_message, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {@var{val} =} suppress_verbose_help_message ()\n\
+@deftypefn  {Built-in Function} {@var{val} =} suppress_verbose_help_message ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} suppress_verbose_help_message (@var{new_val})\n\
 Query or set the internal variable that controls whether Octave\n\
 will add additional help information to the end of the output from\n\
 the @code{help} command and usage messages for built-in commands.\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (suppress_verbose_help_message);
 }
diff --git a/src/input.cc b/src/input.cc
--- a/src/input.cc
+++ b/src/input.cc
@@ -838,17 +838,17 @@ get_user_input (const octave_value_list&
   else
     error ("input: reading user-input failed!");
 
   return retval;
 }
 
 DEFUN (input, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} input (@var{prompt})\n\
+@deftypefn  {Built-in Function} {} input (@var{prompt})\n\
 @deftypefnx {Built-in Function} {} input (@var{prompt}, \"s\")\n\
 Print a prompt and wait for user input.  For example,\n\
 \n\
 @example\n\
 input (\"Pick a number, any number! \")\n\
 @end example\n\
 \n\
 @noindent\n\
@@ -1272,16 +1272,17 @@ input_event_hook (void)
 }
 
 DEFUN (add_input_event_hook, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} add_input_event_hook (@var{fcn}, @var{data})\n\
 Add the named function @var{fcn} to the list of functions to call\n\
 periodically when Octave is waiting for input.  The function should\n\
 have the form\n\
+\n\
 @example\n\
 @var{fcn} (@var{data})\n\
 @end example\n\
 \n\
 If @var{data} is omitted, Octave calls the function without any\n\
 arguments.\n\
 @seealso{remove_input_event_hook}\n\
 @end deftypefn")
@@ -1350,17 +1351,17 @@ periodically when Octave is waiting for 
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (PS1, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {@var{val} =} PS1 ()\n\
+@deftypefn  {Built-in Function} {@var{val} =} PS1 ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} PS1 (@var{new_val})\n\
 Query or set the primary prompt string.  When executing interactively,\n\
 Octave displays the primary prompt when it is ready to read a command.\n\
 \n\
 The default value of the primary prompt string is @code{\"\\s:\\#> \"}.\n\
 To change it, use a command like\n\
 \n\
 @example\n\
@@ -1376,59 +1377,59 @@ character string.\n\
 @seealso{PS2, PS4}\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (PS1);
 }
 
 DEFUN (PS2, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {@var{val} =} PS2 ()\n\
+@deftypefn  {Built-in Function} {@var{val} =} PS2 ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} PS2 (@var{new_val})\n\
 Query or set the secondary prompt string.  The secondary prompt is\n\
 printed when Octave is expecting additional input to complete a\n\
 command.  For example, if you are typing a @code{for} loop that spans several\n\
 lines, Octave will print the secondary prompt at the beginning of\n\
 each line after the first.  The default value of the secondary prompt\n\
 string is @code{\"> \"}.\n\
 @seealso{PS1, PS4}\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (PS2);
 }
 
 DEFUN (PS4, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {@var{val} =} PS4 ()\n\
+@deftypefn  {Built-in Function} {@var{val} =} PS4 ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} PS4 (@var{new_val})\n\
 Query or set the character string used to prefix output produced\n\
 when echoing commands is enabled.\n\
 The default value is @code{\"+ \"}.\n\
 @xref{Diary and Echo Commands}, for a description of echoing commands.\n\
 @seealso{echo, echo_executing_commands, PS1, PS2}\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (PS4);
 }
 
 DEFUN (completion_append_char, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {@var{val} =} completion_append_char ()\n\
+@deftypefn  {Built-in Function} {@var{val} =} completion_append_char ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} completion_append_char (@var{new_val})\n\
 Query or set the internal character variable that is appended to\n\
 successful command-line completion attempts.  The default\n\
 value is @code{\" \"} (a single space).\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (completion_append_char);
 }
 
 DEFUN (echo_executing_commands, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {@var{val} =} echo_executing_commands ()\n\
+@deftypefn  {Built-in Function} {@var{val} =} echo_executing_commands ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} echo_executing_commands (@var{new_val})\n\
 Query or set the internal variable that controls the echo state.\n\
 It may be the sum of the following values:\n\
 \n\
 @table @asis\n\
 @item 1\n\
 Echo commands read from script files.\n\
 \n\
@@ -1438,25 +1439,25 @@ Echo commands from functions.\n\
 @item 4\n\
 Echo commands read from command line.\n\
 @end table\n\
 \n\
 More than one state can be active at once.  For example, a value of 3 is\n\
 equivalent to the command @kbd{echo on all}.\n\
 \n\
 The value of @code{echo_executing_commands} may be set by the @kbd{echo}\n\
-command or the command line option @code{--echo-commands}.\n\
+command or the command line option @option{--echo-commands}.\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (echo_executing_commands);
 }
 
 DEFUN (__request_drawnow__, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} __request_drawnow__ ()\n\
+@deftypefn  {Built-in Function} {} __request_drawnow__ ()\n\
 @deftypefnx {Built-in Function} {} __request_drawnow__ (@var{flag})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
@@ -1490,27 +1491,27 @@ Undocumented internal function.\n\
   return retval;
 }
 
 DEFUN (filemarker, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} filemarker ()\n\
 Returns or sets the character used to separate filename from the\n\
 the subfunction names contained within the file.  This can be used in\n\
-a generic manner to interact with subfunctions.  For example\n\
+a generic manner to interact with subfunctions.  For example,\n\
 \n\
 @example\n\
 help ([\"myfunc\", filemarker, \"mysubfunc\"])\n\
 @end example\n\
 \n\
 @noindent\n\
 returns the help string associated with the sub-function @code{mysubfunc}\n\
 of the function @code{myfunc}.  Another use of @code{filemarker} is when\n\
 debugging it allows easier placement of breakpoints within sub-functions.\n\
-For example\n\
+For example,\n\
 \n\
 @example\n\
 dbstop ([\"myfunc\", filemarker, \"mysubfunc\"])\n\
 @end example\n\
 \n\
 @noindent\n\
 will set a breakpoint at the first line of the subfunction @code{mysubfunc}.\n\
 @end deftypefn")
diff --git a/src/load-path.cc b/src/load-path.cc
--- a/src/load-path.cc
+++ b/src/load-path.cc
@@ -2030,17 +2030,17 @@ No checks are made for duplicate element
         }
     }
 
   return retval;
 }
 
 DEFUN (addpath, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} addpath (@var{dir1}, @dots{})\n\
+@deftypefn  {Built-in Function} {} addpath (@var{dir1}, @dots{})\n\
 @deftypefnx {Built-in Function} {} addpath (@var{dir1}, @dots{}, @var{option})\n\
 Add @var{dir1}, @dots{} to the current function search path.  If\n\
 @var{option} is @samp{\"-begin\"} or 0 (the default), prepend the\n\
 directory name to the current path.  If @var{option} is @samp{\"-end\"}\n\
 or 1, append the directory name to the current path.\n\
 Directories added to the path must exist.\n\
 @seealso{path, rmpath, genpath, pathdef, savepath, pathsep}\n\
 @end deftypefn")
diff --git a/src/load-save.cc b/src/load-save.cc
--- a/src/load-save.cc
+++ b/src/load-save.cc
@@ -608,20 +608,20 @@ Force Octave to assume the file contains
 without any header or other information.  Data in the file will be loaded\n\
 as a single numeric matrix with the name of the variable derived from the\n\
 name of the file.\n\
 \n\
 @item -binary\n\
 Force Octave to assume the file is in Octave's binary format.\n\
 \n\
 @item -hdf5\n\
-Force Octave to assume the file is in HDF5 format.\n\
+Force Octave to assume the file is in @sc{hdf5} format.\n\
 (HDF5 is a free, portable binary format developed by the National\n\
 Center for Supercomputing Applications at the University of Illinois.)\n\
-Note that Octave can read HDF5 files not created by itself, but may\n\
+Note that Octave can read @sc{hdf5} files not created by itself, but may\n\
 skip some datasets in formats that it cannot support.\n"
 
 HAVE_HDF5_HELP_STRING
 
 "\n\
 @item -import\n\
 This option is accepted for backward compatibility but is ignored.\n\
 Octave can now support multi-dimensional HDF data and automatically\n\
@@ -1455,17 +1455,17 @@ DEFUN (save, args, ,
 @deffnx {Command} save options file\n\
 @deffnx {Command} save options file @var{v1} @var{v2} @dots{}\n\
 @deffnx {Command} save options file -struct @var{STRUCT} @var{f1} @var{f2} @dots{}\n\
 Save the named variables @var{v1}, @var{v2}, @dots{}, in the file\n\
 @var{file}.  The special filename @samp{-} may be used to write\n\
 output to the terminal.  If no variable names are listed, Octave saves\n\
 all the variables in the current scope.  Otherwise, full variable names or\n\
 pattern syntax can be used to specify the variables to save.\n\
-If the @code{-struct} modifier is used, fields @var{f1} @var{f2} @dots{}\n\
+If the @option{-struct} modifier is used, fields @var{f1} @var{f2} @dots{}\n\
 of the scalar structure @var{STRUCT} are saved as if they were variables\n\
 with corresponding names.\n\
 Valid options for the @code{save} command are listed in the following table.\n\
 Options that modify the output format override the format specified by \n\
 @code{default_save_options}.\n\
 \n\
 If save is invoked using the functional form\n\
 \n\
@@ -1485,25 +1485,25 @@ Save a single matrix in a text file with
 Save the data in Octave's binary data format.\n\
 \n\
 @item -float-binary\n\
 Save the data in Octave's binary data format but only using single\n\
 precision.  Only use this format if you know that all the\n\
 values to be saved can be represented in single precision.\n\
 \n\
 @item -hdf5\n\
-Save the data in HDF5 format.\n\
+Save the data in @sc{hdf5} format.\n\
 (HDF5 is a free, portable binary format developed by the National\n\
 Center for Supercomputing Applications at the University of Illinois.)\n"
 
 HAVE_HDF5_HELP_STRING
 
 "\n\
 @item -float-hdf5\n\
-Save the data in HDF5 format but only using single precision.\n\
+Save the data in @sc{hdf5} format but only using single precision.\n\
 Only use this format if you know that all the\n\
 values to be saved can be represented in single precision.\n\
 \n\
 @item -V7\n\
 @itemx -v7\n\
 @itemx -7\n\
 @itemx -mat7-binary\n\
 Save the data in @sc{matlab}'s v7 binary data format.\n"
@@ -1548,17 +1548,17 @@ Match zero or more characters.\n\
 \n\
 @item [ @var{list} ]\n\
 Match the list of characters specified by @var{list}.  If the first\n\
 character is @code{!} or @code{^}, match all characters except those\n\
 specified by @var{list}.  For example, the pattern @code{[a-zA-Z]} will\n\
 match all lower and upper case alphabetic characters.  \n\
 \n\
 Wildcards may also be used in the field name specifications when using\n\
-the @code{-struct} modifier (but not in the struct name itself).\n\
+the @option{-struct} modifier (but not in the struct name itself).\n\
 \n\
 @end table\n\
 \n\
 Except when using the @sc{matlab} binary data file format or the\n\
 @samp{-ascii} format, saving global\n\
 variables also saves the global status of the variable.  If the variable\n\
 is restored at a later time using @samp{load}, it will be restored as a\n\
 global variable.\n\
@@ -1748,17 +1748,17 @@ the file @file{data} in Octave's binary 
         }
     }
 
   return retval;
 }
 
 DEFUN (crash_dumps_octave_core, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {@var{val} =} crash_dumps_octave_core ()\n\
+@deftypefn  {Built-in Function} {@var{val} =} crash_dumps_octave_core ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} crash_dumps_octave_core (@var{new_val})\n\
 Query or set the internal variable that controls whether Octave tries\n\
 to save all current variables to the file \"octave-core\" if it\n\
 crashes or receives a hangup, terminate or similar signal.\n\
 @seealso{octave_core_file_limit, octave_core_file_name, octave_core_file_options}\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (crash_dumps_octave_core);
@@ -1766,26 +1766,26 @@ crashes or receives a hangup, terminate 
 
 DEFUN (default_save_options, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} default_save_options ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} default_save_options (@var{new_val})\n\
 Query or set the internal variable that specifies the default options\n\
 for the @code{save} command, and defines the default format.\n\
 Typical values include @code{\"-ascii\"}, @code{\"-text -zip\"}.\n\
-The default value is @code{-text}.\n\
+The default value is @option{-text}.\n\
 @seealso{save}\n\
 @end deftypefn")
 {
   return SET_NONEMPTY_INTERNAL_STRING_VARIABLE (default_save_options);
 }
 
 DEFUN (octave_core_file_limit, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {@var{val} =} octave_core_file_limit ()\n\
+@deftypefn  {Built-in Function} {@var{val} =} octave_core_file_limit ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} octave_core_file_limit (@var{new_val})\n\
 Query or set the internal variable that specifies the maximum amount\n\
 of memory (in kilobytes) of the top-level workspace that Octave will\n\
 attempt to save when writing data to the crash dump file (the name of\n\
 the file is specified by @var{octave_core_file_name}).  If\n\
 @var{octave_core_file_options} flags specify a binary format,\n\
 then @var{octave_core_file_limit} will be approximately the maximum\n\
 size of the file.  If a text file format is used, then the file could\n\
@@ -1793,30 +1793,30 @@ be much larger than the limit.  The defa
 @seealso{crash_dumps_octave_core, octave_core_file_name, octave_core_file_options}\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (octave_core_file_limit);
 }
 
 DEFUN (octave_core_file_name, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {@var{val} =} octave_core_file_name ()\n\
+@deftypefn  {Built-in Function} {@var{val} =} octave_core_file_name ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} octave_core_file_name (@var{new_val})\n\
 Query or set the internal variable that specifies the name of the file\n\
 used for saving data from the top-level workspace if Octave aborts.\n\
 The default value is @code{\"octave-core\"}\n\
 @seealso{crash_dumps_octave_core, octave_core_file_name, octave_core_file_options}\n\
 @end deftypefn")
 {
   return SET_NONEMPTY_INTERNAL_STRING_VARIABLE (octave_core_file_name);
 }
 
 DEFUN (octave_core_file_options, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {@var{val} =} octave_core_file_options ()\n\
+@deftypefn  {Built-in Function} {@var{val} =} octave_core_file_options ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} octave_core_file_options (@var{new_val})\n\
 Query or set the internal variable that specifies the options used for\n\
 saving the workspace data if Octave aborts.  The value of\n\
 @code{octave_core_file_options} should follow the same format as the\n\
 options for the @code{save} function.  The default value is Octave's binary\n\
 format.\n\
 @seealso{crash_dumps_octave_core, octave_core_file_name, octave_core_file_limit}\n\
 @end deftypefn")
diff --git a/src/ls-oct-ascii.cc b/src/ls-oct-ascii.cc
--- a/src/ls-oct-ascii.cc
+++ b/src/ls-oct-ascii.cc
@@ -412,16 +412,16 @@ save_three_d (std::ostream& os, const oc
       fail = true;
     }
 
   return (os && ! fail);
 }
 
 DEFUN (save_precision, args, nargout,
     "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {@var{val} =} save_precision ()\n\
+@deftypefn  {Built-in Function} {@var{val} =} save_precision ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} save_precision (@var{new_val})\n\
 Query or set the internal variable that specifies the number of\n\
 digits to keep when saving data in text format.\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE_WITH_LIMITS (save_precision, -1, INT_MAX);
 }
diff --git a/src/mappers.cc b/src/mappers.cc
--- a/src/mappers.cc
+++ b/src/mappers.cc
@@ -43,17 +43,17 @@ DEFUN (abs, args, ,
 Compute the magnitude of @var{z}, defined as\n\
 @tex\n\
 $|z| = \\sqrt{x^2 + y^2}$.\n\
 @end tex\n\
 @ifnottex\n\
 |@var{z}| = @code{sqrt (x^2 + y^2)}.\n\
 @end ifnottex\n\
 \n\
-For example,\n\
+For example:\n\
 \n\
 @example\n\
 @group\n\
 abs (3 + 4i)\n\
      @result{} 5\n\
 @end group\n\
 @end example\n\
 @end deftypefn")
@@ -168,28 +168,28 @@ See arg.\n\
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (arg, args, ,
     "-*- texinfo -*-\n\
-@deftypefn {Mapping Function} {} arg (@var{z})\n\
+@deftypefn  {Mapping Function} {} arg (@var{z})\n\
 @deftypefnx {Mapping Function} {} angle (@var{z})\n\
 Compute the argument of @var{z}, defined as,\n\
 @tex\n\
 $\\theta = atan2 (y, x),$\n\
 @end tex\n\
 @ifnottex\n\
 @var{theta} = @code{atan2 (@var{y}, @var{x})},\n\
 @end ifnottex\n\
 in radians.\n\
 \n\
-For example,\n\
+For example:\n\
 \n\
 @example\n\
 @group\n\
 arg (3 + 4i)\n\
      @result{} 0.92730\n\
 @end group\n\
 @end example\n\
 @end deftypefn")
@@ -382,16 +382,17 @@ the result will be negative if @var{x} i
 */
 
 DEFUN (ceil, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} ceil (@var{x})\n\
 Return the smallest integer not less than @var{x}.  This is equivalent to\n\
 rounding towards positive infinity.  If @var{x} is\n\
 complex, return @code{ceil (real (@var{x})) + ceil (imag (@var{x})) * I}.\n\
+\n\
 @example\n\
 @group\n\
 ceil ([-2.7, 2.7])\n\
    @result{}  -2   3\n\
 @end group\n\
 @end example\n\
 @seealso{floor, round, fix}\n\
 @end deftypefn")
@@ -550,16 +551,17 @@ Computes the error function,\n\
 @group\n\
                          z\n\
                         /\n\
 erf (z) = (2/sqrt (pi)) | e^(-t^2) dt\n\
                         /\n\
                      t=0\n\
 @end group\n\
 @end example\n\
+\n\
 @end ifnottex\n\
 @seealso{erfc, erfinv}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
     retval = args(0).erf ();
   else
@@ -597,16 +599,17 @@ erf (z) = (2/sqrt (pi)) | e^(-t^2) dt\n\
 
 
 */
 
 DEFUN (erfinv, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} erfinv (@var{x})\n\
 Computes the inverse error function, i.e., @var{y} such that\n\
+\n\
 @example\n\
   erf(@var{y}) == @var{x}\n\
 @end example\n\
 @seealso{erfc, erf}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
@@ -749,17 +752,17 @@ accurately in the neighborhood of zero.\
 
   return retval;
 }
 
 DEFUN (finite, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} finite (@var{x})\n\
 Return 1 for elements of @var{x} that are finite values and zero\n\
-otherwise.  For example,\n\
+otherwise.  For example:\n\
 \n\
 @example\n\
 @group\n\
 finite ([13, Inf, NA, NaN])\n\
      @result{} [ 1, 0, 0, 0 ]\n\
 @end group\n\
 @end example\n\
 @end deftypefn")
@@ -786,16 +789,17 @@ finite ([13, Inf, NA, NaN])\n\
  */
 
 DEFUN (fix, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} fix (@var{x})\n\
 Truncate fractional portion of @var{x} and return the integer portion.  This\n\
 is equivalent to rounding towards zero.  If @var{x} is complex, return\n\
 @code{fix (real (@var{x})) + fix (imag (@var{x})) * I}.\n\
+\n\
 @example\n\
 @group\n\
 fix ([-2.7, 2.7])\n\
    @result{} -2   2\n\
 @end group\n\
 @end example\n\
 @seealso{ceil, floor, round}\n\
 @end deftypefn")
@@ -822,16 +826,17 @@ fix ([-2.7, 2.7])\n\
 */
 
 DEFUN (floor, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} floor (@var{x})\n\
 Return the largest integer not greater than @var{x}.  This is equivalent to\n\
 rounding towards negative infinity.  If @var{x} is\n\
 complex, return @code{floor (real (@var{x})) + floor (imag (@var{x})) * I}.\n\
+\n\
 @example\n\
 @group\n\
 floor ([-2.7, 2.7])\n\
      @result{} -3   2\n\
 @end group\n\
 @end example\n\
 @seealso{ceil, round, fix}\n\
 @end deftypefn")
@@ -872,16 +877,17 @@ Computes the Gamma function,\n\
 @group\n\
             infinity\n\
             /\n\
 gamma (z) = | t^(z-1) exp (-t) dt.\n\
             /\n\
          t=0\n\
 @end group\n\
 @end example\n\
+\n\
 @end ifnottex\n\
 @seealso{gammainc, lgamma}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
     retval = args(0).gamma ();
   else
@@ -961,17 +967,17 @@ Return 1 for characters that are letters
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("isalpha", Fisalpha, args, ,
     "-*- texinfo -*-\n\
-@deftypefn {Mapping Function} {} isalpha (@var{s})\n\
+@deftypefn  {Mapping Function} {} isalpha (@var{s})\n\
 @deftypefnx {Mapping Function} {} isletter (@var{s})\n\
 Return true for characters that are letters (@code{isupper (@var{s})}\n\
 or @code{islower (@var{s})} is true).\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
     retval = args(0).xisalpha ();
@@ -1025,17 +1031,17 @@ Return 1 for characters that are decimal
 
   return retval;
 }
 
 DEFUN (isinf, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} isinf (@var{x})\n\
 Return 1 for elements of @var{x} that are infinite and zero\n\
-otherwise.  For example,\n\
+otherwise.  For example:\n\
 \n\
 @example\n\
 @group\n\
 isinf ([13, Inf, NA, NaN])\n\
      @result{} [ 0, 1, 0, 0 ]\n\
 @end group\n\
 @end example\n\
 @end deftypefn")
@@ -1094,17 +1100,17 @@ Return 1 for characters that are lower c
 
   return retval;
 }
 
 DEFUN (isna, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} isna (@var{x})\n\
 Return 1 for elements of @var{x} that are NA (missing) values and zero\n\
-otherwise.  For example,\n\
+otherwise.  For example:\n\
 \n\
 @example\n\
 @group\n\
 isna ([13, Inf, NA, NaN])\n\
      @result{} [ 0, 0, 1, 0 ]\n\
 @end group\n\
 @end example\n\
 @seealso{isnan}\n\
@@ -1134,17 +1140,17 @@ isna ([13, Inf, NA, NaN])\n\
 %!assert(isna(single([NaN -Inf -1 0 1 Inf NA])), [false, false, false, false, false, false, true]);
 
  */
 
 DEFUN (isnan, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} isnan (@var{x})\n\
 Return 1 for elements of @var{x} that are NaN values and zero\n\
-otherwise.  NA values are also considered NaN values.  For example,\n\
+otherwise.  NA values are also considered NaN values.  For example:\n\
 \n\
 @example\n\
 @group\n\
 isnan ([13, Inf, NA, NaN])\n\
      @result{} [ 0, 0, 1, 1 ]\n\
 @end group\n\
 @end example\n\
 @seealso{isna}\n\
@@ -1248,17 +1254,17 @@ Return 1 for characters that are hexadec
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (lgamma, args, ,
     "-*- texinfo -*-\n\
-@deftypefn {Mapping Function} {} lgamma (@var{x})\n\
+@deftypefn  {Mapping Function} {} lgamma (@var{x})\n\
 @deftypefnx {Mapping Function} {} gammaln (@var{x})\n\
 Return the natural logarithm of the gamma function of @var{x}.\n\
 @seealso{gamma, gammainc}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
     retval = args(0).lgamma ();
@@ -1412,16 +1418,17 @@ Return the real part of @var{z}.\n\
 
 */
 
 DEFUN (round, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} round (@var{x})\n\
 Return the integer nearest to @var{x}.  If @var{x} is complex, return\n\
 @code{round (real (@var{x})) + round (imag (@var{x})) * I}.\n\
+\n\
 @example\n\
 @group\n\
 round ([-2.7, 2.7])\n\
      @result{} -3   3\n\
 @end group\n\
 @end example\n\
 @seealso{ceil, floor, fix}\n\
 @end deftypefn")
@@ -1489,16 +1496,17 @@ Compute the @dfn{signum} function, which
 \n\
 @example\n\
 @group\n\
            -1, x < 0;\n\
 sign (x) =  0, x = 0;\n\
             1, x > 0.\n\
 @end group\n\
 @end example\n\
+\n\
 @end ifnottex\n\
 \n\
 For complex arguments, @code{sign} returns @code{x ./ abs (@var{x})}.\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
     retval = args(0).signum ();
@@ -1698,17 +1706,17 @@ Compute hyperbolic tangent for each elem
 %!error tanh ();
 %!error tanh (1, 2);
 
 */
 
 DEFUNX ("toascii", Ftoascii, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} toascii (@var{s})\n\
-Return ASCII representation of @var{s} in a matrix.  For example,\n\
+Return ASCII representation of @var{s} in a matrix.  For example:\n\
 \n\
 @example\n\
 @group\n\
 toascii (\"ASCII\")\n\
      @result{} [ 65, 83, 67, 73, 73 ]\n\
 @end group\n\
 \n\
 @end example\n\
@@ -1721,21 +1729,21 @@ toascii (\"ASCII\")\n\
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("tolower", Ftolower, args, ,
     "-*- texinfo -*-\n\
-@deftypefn {Mapping Function} {} tolower (@var{s})\n\
+@deftypefn  {Mapping Function} {} tolower (@var{s})\n\
 @deftypefnx {Mapping Function} {} lower (@var{s})\n\
 Return a copy of the string or cell string @var{s}, with each upper-case\n\
 character replaced by the corresponding lower-case one; non-alphabetic\n\
-characters are left unchanged.  For example,\n\
+characters are left unchanged.  For example:\n\
 \n\
 @example\n\
 @group\n\
 tolower (\"MiXeD cAsE 123\")\n\
      @result{} \"mixed case 123\"\n\
 @end group\n\
 @end example\n\
 @seealso{toupper}\n\
@@ -1767,21 +1775,21 @@ DEFALIAS (lower, tolower);
 %!  a(3,3,3,3) = "D";
 %!  assert(tolower(a)(3,3,3,3), "d");
 
 */
 
 
 DEFUNX ("toupper", Ftoupper, args, ,
     "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} toupper (@var{s})\n\
+@deftypefn  {Built-in Function} {} toupper (@var{s})\n\
 @deftypefnx {Built-in Function} {} upper (@var{s})\n\
 Return a copy of the string or cell string @var{s}, with each lower-case\n\
 character replaced by the corresponding upper-case one; non-alphabetic\n\
-characters are left unchanged.  For example,\n\
+characters are left unchanged.  For example:\n\
 \n\
 @example\n\
 @group\n\
 toupper (\"MiXeD cAsE 123\")\n\
      @result{} \"MIXED CASE 123\"\n\
 @end group\n\
 @end example\n\
 @seealso{tolower}\n\
diff --git a/src/oct-hist.cc b/src/oct-hist.cc
--- a/src/oct-hist.cc
+++ b/src/oct-hist.cc
@@ -537,17 +537,17 @@ octave_history_write_timestamp (void)
   if (! timestamp.empty ())
     command_history::add (timestamp);
 }
 
 DEFUN (edit_history, args, ,
   "-*- texinfo -*-\n\
 @deffn {Command} edit_history [@var{first}] [@var{last}]\n\
 If invoked with no arguments, @code{edit_history} allows you to edit the\n\
-history list using the editor named by the variable @w{@code{EDITOR}}.  The\n\
+history list using the editor named by the variable @w{@env{EDITOR}}.  The\n\
 commands to be edited are first copied to a temporary file.  When you\n\
 exit the editor, Octave executes the commands that remain in the file.\n\
 It is often more convenient to use @code{edit_history} to define functions \n\
 rather than attempting to enter them directly on the command line.\n\
 By default, the block of commands is executed as soon as you exit the\n\
 editor.  To avoid executing any commands, simply delete all the lines\n\
 from the buffer before exiting the editor.\n\
 \n\
@@ -651,59 +651,59 @@ and the commands are simply executed as 
 
   do_run_history (argc, argv);
 
   return retval;
 }
 
 DEFUN (history_size, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {@var{val} =} history_size ()\n\
+@deftypefn  {Built-in Function} {@var{val} =} history_size ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} history_size (@var{new_val})\n\
 Query or set the internal variable that specifies how many entries\n\
 to store in the history file.  The default value is @code{1024},\n\
-but may be overridden by the environment variable @w{@code{OCTAVE_HISTSIZE}}.\n\
+but may be overridden by the environment variable @w{@env{OCTAVE_HISTSIZE}}.\n\
 @seealso{history_file, history_timestamp_format_string, saving_history}\n\
 @end deftypefn")
 {
   int saved_history_size = Vhistory_size;
 
   octave_value retval
     = SET_INTERNAL_VARIABLE_WITH_LIMITS (history_size, -1, INT_MAX);
 
   if (Vhistory_size != saved_history_size)
     command_history::set_size (Vhistory_size);
 
   return retval;
 }
 
 DEFUN (history_file, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {@var{val} =} history_file ()\n\
+@deftypefn  {Built-in Function} {@var{val} =} history_file ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} history_file (@var{new_val})\n\
 Query or set the internal variable that specifies the name of the\n\
 file used to store command history.  The default value is\n\
 @file{~/.octave_hist}, but may be overridden by the environment\n\
-variable @w{@code{OCTAVE_HISTFILE}}.\n\
+variable @w{@env{OCTAVE_HISTFILE}}.\n\
 @seealso{history_size, saving_history, history_timestamp_format_string}\n\
 @end deftypefn")
 {
   std::string saved_history_file = Vhistory_file;
 
   octave_value retval = SET_INTERNAL_VARIABLE (history_file);
 
   if (Vhistory_file != saved_history_file)
     command_history::set_file (Vhistory_file);
 
   return retval;
 }
 
 DEFUN (history_timestamp_format_string, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {@var{val} =} history_timestamp_format_string ()\n\
+@deftypefn  {Built-in Function} {@var{val} =} history_timestamp_format_string ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} history_timestamp_format_string (@var{new_val})\n\
 Query or set the internal variable that specifies the format string\n\
 for the comment line that is written to the history file when Octave\n\
 exits.  The format string is passed to @code{strftime}.  The default\n\
 value is\n\
 \n\
 @example\n\
 \"# Octave VERSION, %a %b %d %H:%M:%S %Y %Z <USER@@HOST>\"\n\
@@ -711,17 +711,17 @@ value is\n\
 @seealso{strftime, history_file, history_size, saving_history}\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (history_timestamp_format_string);
 }
 
 DEFUN (saving_history, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {@var{val} =} saving_history ()\n\
+@deftypefn  {Built-in Function} {@var{val} =} saving_history ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} saving_history (@var{new_val})\n\
 Query or set the internal variable that controls whether commands entered\n\
 on the command line are saved in the history file.\n\
 @seealso{history_file, history_size, history_timestamp_format_string}\n\
 @end deftypefn")
 {
   octave_value retval = SET_INTERNAL_VARIABLE (saving_history);
 
diff --git a/src/octave.cc b/src/octave.cc
--- a/src/octave.cc
+++ b/src/octave.cc
@@ -896,17 +896,17 @@ Return the command line arguments passed
 if you invoked Octave using the command\n\
 \n\
 @example\n\
 octave --no-line-editing --silent\n\
 @end example\n\
 \n\
 @noindent\n\
 @code{argv} would return a cell array of strings with the elements\n\
-@code{--no-line-editing} and @code{--silent}.\n\
+@option{--no-line-editing} and @option{--silent}.\n\
 \n\
 If you write an executable Octave script, @code{argv} will return the\n\
 list of arguments passed to the script.  @xref{Executable Octave Programs},\n\
 for an example of how to create an executable Octave script.\n\
 @end deftypefn")
 {
   octave_value retval;
 
diff --git a/src/ov-base.cc b/src/ov-base.cc
--- a/src/ov-base.cc
+++ b/src/ov-base.cc
@@ -1512,21 +1512,21 @@ install_base_type_conversions (void)
   INSTALL_WIDENOP (octave_base_value, octave_matrix, matrix_conv);
   INSTALL_WIDENOP (octave_base_value, octave_complex_matrix, complex_matrix_conv);
   INSTALL_WIDENOP (octave_base_value, octave_char_matrix_str, string_conv);
   INSTALL_WIDENOP (octave_base_value, octave_cell, cell_conv);
 }
 
 DEFUN (sparse_auto_mutate, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {@var{val} =} sparse_auto_mutate ()\n\
+@deftypefn  {Built-in Function} {@var{val} =} sparse_auto_mutate ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} sparse_auto_mutate (@var{new_val})\n\
 Query or set the internal variable that controls whether Octave will\n\
 automatically mutate sparse matrices to real matrices to save memory.\n\
-For example,\n\
+For example:\n\
 \n\
 @example\n\
 @group\n\
 s = speye(3);\n\
 sparse_auto_mutate (false)\n\
 s (:, 1) = 1;\n\
 typeinfo (s)\n\
 @result{} sparse matrix\n\
diff --git a/src/ov-cell.cc b/src/ov-cell.cc
--- a/src/ov-cell.cc
+++ b/src/ov-cell.cc
@@ -1245,17 +1245,17 @@ false.\n\
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (cell, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} cell (@var{x})\n\
+@deftypefn  {Built-in Function} {} cell (@var{x})\n\
 @deftypefnx {Built-in Function} {} cell (@var{n}, @var{m})\n\
 Create a new cell array object.  If invoked with a single scalar\n\
 argument, @code{cell} returns a square cell array with the dimension\n\
 specified.  If you supply two scalar arguments, @code{cell} takes\n\
 them to be the number of rows and columns.  If given a vector with two\n\
 elements, @code{cell} uses the values of the elements as the number of\n\
 rows and columns, respectively.\n\
 @end deftypefn")
diff --git a/src/ov-class.cc b/src/ov-class.cc
--- a/src/ov-class.cc
+++ b/src/ov-class.cc
@@ -1697,17 +1697,17 @@ octave_class::exemplar_info::compare (co
       error ("invalid comparison of class exemplar to non-class object");
     }
 
   return retval;
 }
 
 DEFUN (class, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} class (@var{expr})\n\
+@deftypefn  {Built-in Function} {} class (@var{expr})\n\
 @deftypefnx {Built-in Function} {} class (@var{s}, @var{id})\n\
 @deftypefnx {Built-in Function} {} class (@var{s}, @var{id}, @var{p}, @dots{})\n\
 Return the class of the expression @var{expr} or create a class with\n\
 fields from structure @var{s} and name (string) @var{id}.  Additional\n\
 arguments name a list of parent classes from which the new class is\n\
 derived.\n\
 @end deftypefn")
 {
@@ -1869,17 +1869,17 @@ is a method of this class.\n\
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (methods, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} methods (@var{x})\n\
+@deftypefn  {Built-in Function} {} methods (@var{x})\n\
 @deftypefnx {Built-in Function} {} methods (\"classname\")\n\
 Return a cell array containing the names of the methods for the\n\
 object @var{x} or the named class.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1)
diff --git a/src/ov-fcn-handle.cc b/src/ov-fcn-handle.cc
--- a/src/ov-fcn-handle.cc
+++ b/src/ov-fcn-handle.cc
@@ -1695,17 +1695,17 @@ the function handle @var{fcn_handle}.\n\
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (str2func, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} str2func (@var{fcn_name})\n\
+@deftypefn  {Built-in Function} {} str2func (@var{fcn_name})\n\
 @deftypefnx {Built-in Function} {} str2func (@var{fcn_name}, \"global\")\n\
 Return a function handle constructed from the string @var{fcn_name}.\n\
 If the optional \"global\" argument is passed, locally visible functions\n\
 are ignored in the lookup.\n\
 @end deftypefn")
 {
   octave_value retval;
   int nargin = args.length ();
diff --git a/src/ov-fcn-inline.cc b/src/ov-fcn-inline.cc
--- a/src/ov-fcn-inline.cc
+++ b/src/ov-fcn-inline.cc
@@ -624,17 +624,17 @@ octave_fcn_inline::print_raw (std::ostre
 octave_value
 octave_fcn_inline::convert_to_str_internal (bool, bool, char type) const
 {
   return octave_value (fcn_text (), type);
 }
 
 DEFUNX ("inline", Finline, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} inline (@var{str})\n\
+@deftypefn  {Built-in Function} {} inline (@var{str})\n\
 @deftypefnx {Built-in Function} {} inline (@var{str}, @var{arg1}, @dots{})\n\
 @deftypefnx {Built-in Function} {} inline (@var{str}, @var{n})\n\
 Create an inline function from the character string @var{str}.\n\
 If called with a single argument, the arguments of the generated\n\
 function are extracted from the function itself.  The generated\n\
 function arguments will then be in alphabetical order.  It should\n\
 be noted that i, and j are ignored as arguments due to the\n\
 ambiguity between their use as a variable or their use as an inbuilt\n\
diff --git a/src/ov-null-mat.cc b/src/ov-null-mat.cc
--- a/src/ov-null-mat.cc
+++ b/src/ov-null-mat.cc
@@ -87,22 +87,23 @@ octave_null_sq_str::numeric_conversion_f
   return octave_base_value::type_conv_info (default_null_sq_str_numeric_conversion_function, 
                                             octave_char_matrix_sq_str::static_type_id ());
 }
 
 DEFUN (isnull, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} isnull (@var{x})\n\
 Return 1 if @var{x} is a special null matrix, string or single quoted string.\n\
-Indexed assignment with such a value as right-hand side should delete array elements.\n\
-This function should be used when overloading indexed assignment for user-defined \n\
-classes instead of @code{isempty}, to distinguish the cases:\n\
+Indexed assignment with such a value as right-hand side should delete array\n\
+elements.  This function should be used when overloading indexed assignment for\n\
+user-defined classes instead of @code{isempty}, to distinguish the cases:\n\
 @table @asis\n\
 @item @code{A(I) = []}\n\
 This should delete elements if @code{I} is nonempty.\n\
+\n\
 @item @code{X = []; A(I) = X}\n\
 This should give an error if @code{I} is nonempty.\n\
 @end table\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
diff --git a/src/ov-range.cc b/src/ov-range.cc
--- a/src/ov-range.cc
+++ b/src/ov-range.cc
@@ -627,17 +627,17 @@ octave_range::as_mxArray (void) const
   for (mwSize i = 0; i < nel; i++)
     pr[i] = p[i];
 
   return retval;
 }
 
 DEFUN (allow_noninteger_range_as_index, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {@var{val} =} allow_noninteger_range_as_index ()\n\
+@deftypefn  {Built-in Function} {@var{val} =} allow_noninteger_range_as_index ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} allow_noninteger_range_as_index (@var{new_val})\n\
 Query or set the internal variable that controls whether non-integer\n\
 ranges are allowed as indices.  This might be useful for @sc{matlab}\n\
 compatibility; however, it is still not entirely compatible because\n\
 @sc{matlab} treats the range expression differently in different contexts.\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (allow_noninteger_range_as_index);
diff --git a/src/ov-struct.cc b/src/ov-struct.cc
--- a/src/ov-struct.cc
+++ b/src/ov-struct.cc
@@ -2136,18 +2136,18 @@ A(1)\n\
 
 // So we can call Fcellstr directly.
 extern octave_value_list Fcellstr (const octave_value_list& args, int);
 
 DEFUN (rmfield, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} rmfield (@var{s}, @var{f})\n\
 Return a copy of the structure (array) @var{s} with the field @var{f} removed.\n\
-If @var{f} is a cell array of strings or a character array, remove the\n\
-named fields.\n\
+If @var{f} is a cell array of strings or a character array, remove the named\n\
+fields.\n\
 @seealso{cellstr, iscellstr, setfield}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 2)
diff --git a/src/ov-usr-fcn.cc b/src/ov-usr-fcn.cc
--- a/src/ov-usr-fcn.cc
+++ b/src/ov-usr-fcn.cc
@@ -578,17 +578,17 @@ octave_user_function::bind_automatic_var
           symbol_table::varref (".ignored.") = bh;
           symbol_table::mark_hidden (".ignored.");
         }
     }
 }
 
 DEFUN (nargin, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} nargin ()\n\
+@deftypefn  {Built-in Function} {} nargin ()\n\
 @deftypefnx {Built-in Function} {} nargin (@var{fcn_name})\n\
 Within a function, return the number of arguments passed to the function.\n\
 At the top level, return the number of command line arguments passed to\n\
 Octave.  If called with the optional argument @var{fcn_name}, return the\n\
 maximum number of arguments the named function can accept, or -1 if the\n\
 function accepts a variable number of arguments.\n\
 @seealso{nargout, varargin, varargout}\n\
 @end deftypefn")
@@ -634,17 +634,17 @@ function accepts a variable number of ar
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (nargout, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} nargout ()\n\
+@deftypefn  {Built-in Function} {} nargout ()\n\
 @deftypefnx {Built-in Function} {} nargout (@var{fcn_name})\n\
 Within a function, return the number of values the caller expects to\n\
 receive.  If called with the optional argument @var{fcn_name}, return the\n\
 maximum number of values the named function can produce, or -1 if the\n\
 function can produce a variable number of values.\n\
 \n\
 For example,\n\
 \n\
@@ -713,18 +713,18 @@ At the top level, @code{nargout} is unde
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (optimize_subsasgn_calls, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {@var{val} =} optimize_subsasgn_calls ()\n\
-@deftypefnx {Built-in Function} {@var{old_val} =} optimize_subsasgn_calls  (@var{new_val})\n\
+@deftypefn  {Built-in Function} {@var{val} =} optimize_subsasgn_calls ()\n\
+@deftypefnx {Built-in Function} {@var{old_val} =} optimize_subsasgn_calls (@var{new_val})\n\
 Query or set the internal flag for subsasgn method call optimizations.\n\
 If true, Octave will attempt to eliminate the redundant copying when calling\n\
 subsasgn method of a user-defined class.\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (optimize_subsasgn_calls);
 }
 
@@ -737,19 +737,19 @@ static bool val_in_table (const Matrix& 
   return (i > 0 && table(i-1) == val);
 }
 
 DEFUN (is_ignored_output, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} is_ignored_output (@var{k})\n\
 Within a function, given an index @var{k} within the range @code{1:nargout},\n\
 return a logical value indicating whether the argument will be ignored on output\n\
-using the tilde (~) special output argument. If @var{k} is outside the range,\n\
-the function yields false. @var{k} can also be an array, in which case the function\n\
-works element-wise and a logical array is returned.\n\
+using the tilde (~) special output argument.  If @var{k} is outside the range,\n\
+the function yields false.  @var{k} can also be an array, in which case the\n\
+function works element-wise and a logical array is returned.\n\
 \n\
 At the top level, @code{is_ignored_output} returns an error.\n\
 @seealso{nargout, nargin, varargin, varargout}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
diff --git a/src/pager.cc b/src/pager.cc
--- a/src/pager.cc
+++ b/src/pager.cc
@@ -539,59 +539,59 @@ terminal window in characters (rows and 
   size(0) = command_editor::terminal_rows ();
   size(1) = command_editor::terminal_cols ();
 
   return octave_value (size);
 }
 
 DEFUN (page_output_immediately, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {@var{val} =} page_output_immediately ()\n\
+@deftypefn  {Built-in Function} {@var{val} =} page_output_immediately ()\n\
 @deftypefnx {Built-in Function} {@var{val} =} page_output_immediately (@var{new_val})\n\
 Query or set the internal variable that controls whether Octave sends\n\
 output to the pager as soon as it is available.  Otherwise, Octave\n\
 buffers its output and waits until just before the prompt is printed to\n\
 flush it to the pager.\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (page_output_immediately);
 }
 
 DEFUN (page_screen_output, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {@var{val} =} page_screen_output ()\n\
+@deftypefn  {Built-in Function} {@var{val} =} page_screen_output ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} page_screen_output (@var{new_val})\n\
 Query or set the internal variable that controls whether output intended\n\
 for the terminal window that is longer than one page is sent through a\n\
 pager.  This allows you to view one screenful at a time.  Some pagers\n\
 (such as @code{less}---see @ref{Installation}) are also capable of moving\n\
 backward on the output.\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (page_screen_output);
 }
 
 DEFUN (PAGER, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {@var{val} =} PAGER ()\n\
+@deftypefn  {Built-in Function} {@var{val} =} PAGER ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} PAGER (@var{new_val})\n\
 Query or set the internal variable that specifies the program to use\n\
 to display terminal output on your system.  The default value is\n\
 normally @code{\"less\"}, @code{\"more\"}, or\n\
 @code{\"pg\"}, depending on what programs are installed on your system.\n\
 @xref{Installation}.\n\
 @seealso{more, page_screen_output, page_output_immediately, PAGER_FLAGS}\n\
 @end deftypefn")
 {
   return SET_NONEMPTY_INTERNAL_STRING_VARIABLE (PAGER);
 }
 
 DEFUN (PAGER_FLAGS, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {@var{val} =} PAGER_FLAGS ()\n\
+@deftypefn  {Built-in Function} {@var{val} =} PAGER_FLAGS ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} PAGER_FLAGS (@var{new_val})\n\
 Query or set the internal variable that specifies the options to pass\n\
 to the pager.\n\
 @seealso{PAGER}\n\
 @end deftypefn")
 {
   return SET_NONEMPTY_INTERNAL_STRING_VARIABLE (PAGER_FLAGS);
 }
diff --git a/src/pr-output.cc b/src/pr-output.cc
--- a/src/pr-output.cc
+++ b/src/pr-output.cc
@@ -3430,17 +3430,17 @@ representing the elements of @var{x}.  B
     }
 
   return retval;
 }
 
 DEFUN (disp, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} disp (@var{x})\n\
-Display the value of @var{x}.  For example,\n\
+Display the value of @var{x}.  For example:\n\
 \n\
 @example\n\
 @group\n\
 disp (\"The value of pi is:\"), disp (pi)\n\
 \n\
      @print{} the value of pi is:\n\
      @print{} 3.1416\n\
 @end group\n\
@@ -3474,17 +3474,17 @@ returns the formatted output in a string
     print_usage ();
 
   return retval;
 }
 
 DEFUN (fdisp, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} fdisp (@var{fid}, @var{x})\n\
-Display the value of @var{x} on the stream @var{fid}.  For example,\n\
+Display the value of @var{x} on the stream @var{fid}.  For example:\n\
 \n\
 @example\n\
 @group\n\
 fdisp (stdout, \"The value of pi is:\"), fdisp (stdout, pi)\n\
 \n\
      @print{} the value of pi is:\n\
      @print{} 3.1416\n\
 @end group\n\
@@ -3856,30 +3856,32 @@ point.\n\
 Print the hexadecimal representation of numbers as they are stored in\n\
 memory.  For example, on a workstation which stores 8 byte real values\n\
 in IEEE format with the least significant byte first, the value of\n\
 @code{pi} when printed in @code{native-hex} format is @code{400921fb54442d18}.\n\
 \n\
 @item hex\n\
 The same as @code{native-hex}, but always print the most significant\n\
 byte first.\n\
+\n\
 @item native-bit\n\
 Print the bit representation of numbers as stored in memory.\n\
 For example, the value of @code{pi} is\n\
 \n\
 @example\n\
 @group\n\
 01000000000010010010000111111011\n\
 01010100010001000010110100011000\n\
 @end group\n\
 @end example\n\
 \n\
 (shown here in two 32 bit sections for typesetting purposes) when\n\
 printed in native-bit format on a workstation which stores 8 byte real values\n\
 in IEEE format with the least significant byte first.\n\
+\n\
 @item bit\n\
 The same as @code{native-bit}, but always print the most significant\n\
 bits first.\n\
 \n\
 @item rat\n\
 Print a rational approximation, i.e., values are approximated\n\
 as the ratio of small integers.\n\
 For example, with the @samp{rat} format,\n\
@@ -3887,16 +3889,17 @@ For example, with the @samp{rat} format,
 @end table\n\
 \n\
 The following two options affect the display of all matrices.\n\
 \n\
 @table @code\n\
 @item compact\n\
 Remove extra blank space around column number labels producing more compact\n\
 output with more data per page.\n\
+\n\
 @item loose\n\
 Insert blank lines above and below column number labels to produce a more\n\
 readable output with less data per page.  (default).\n\
 @end table\n\
 @end deffn")
 {
   octave_value_list retval;
 
@@ -3909,22 +3912,22 @@ readable output with less data per page.
 
   set_format_style (argc, argv);
 
   return retval;
 }
 
 DEFUN (fixed_point_format, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {@var{val} =} fixed_point_format ()\n\
+@deftypefn  {Built-in Function} {@var{val} =} fixed_point_format ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} fixed_point_format (@var{new_val})\n\
 Query or set the internal variable that controls whether Octave will\n\
 use a scaled format to print matrix values such that the largest\n\
 element may be written with a single leading digit with the scaling\n\
-factor is printed on the first line of output.  For example,\n\
+factor is printed on the first line of output.  For example:\n\
 \n\
 @example\n\
 @group\n\
 octave:1> logspace (1, 7, 5)'\n\
 ans =\n\
 \n\
   1.0e+07  *\n\
 \n\
@@ -3942,17 +3945,17 @@ this reason, you should be careful when 
 @code{fixed_point_format} to a nonzero value.\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (fixed_point_format);
 }
 
 DEFUN (print_empty_dimensions, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {@var{val} =} print_empty_dimensions ()\n\
+@deftypefn  {Built-in Function} {@var{val} =} print_empty_dimensions ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} print_empty_dimensions (@var{new_val})\n\
 Query or set the internal variable that controls whether the\n\
 dimensions of empty matrices are printed along with the empty matrix\n\
 symbol, @samp{[]}.  For example, the expression\n\
 \n\
 @example\n\
 zeros (3, 0)\n\
 @end example\n\
@@ -3965,17 +3968,17 @@ ans = [](3x0)\n\
 @end example\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (print_empty_dimensions);
 }
 
 DEFUN (split_long_rows, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {@var{val} =} split_long_rows ()\n\
+@deftypefn  {Built-in Function} {@var{val} =} split_long_rows ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} split_long_rows (@var{new_val})\n\
 Query or set the internal variable that controls whether rows of a matrix\n\
 may be split when displayed to a terminal window.  If the rows are split,\n\
 Octave will display the matrix in a series of smaller pieces, each of\n\
 which can fit within the limits of your terminal width and each set of\n\
 rows is labeled so that you can easily see which columns are currently\n\
 being displayed.  For example:\n\
 \n\
@@ -3997,41 +4000,41 @@ ans =\n\
 @end example\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (split_long_rows);
 }
 
 DEFUN (output_max_field_width, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {@var{val} =} output_max_field_width ()\n\
+@deftypefn  {Built-in Function} {@var{val} =} output_max_field_width ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} output_max_field_width (@var{new_val})\n\
 Query or set the internal variable that specifies the maximum width\n\
 of a numeric output field.\n\
 @seealso{format, output_precision}\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE_WITH_LIMITS (output_precision, 0, INT_MAX);
 }
 
 DEFUN (output_precision, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {@var{val} =} output_precision ()\n\
+@deftypefn  {Built-in Function} {@var{val} =} output_precision ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} output_precision (@var{new_val})\n\
 Query or set the internal variable that specifies the minimum number of\n\
 significant figures to display for numeric output.\n\
 @seealso{format, output_max_field_width}\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE_WITH_LIMITS (output_precision, -1, INT_MAX);
 }
 
 DEFUN (struct_levels_to_print, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {@var{val} =} struct_levels_to_print ()\n\
+@deftypefn  {Built-in Function} {@var{val} =} struct_levels_to_print ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} struct_levels_to_print (@var{new_val})\n\
 Query or set the internal variable that specifies the number of\n\
 structure levels to display.\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE_WITH_LIMITS (struct_levels_to_print,
                                             -1, INT_MAX);
 }
diff --git a/src/pt-eval.cc b/src/pt-eval.cc
--- a/src/pt-eval.cc
+++ b/src/pt-eval.cc
@@ -1179,29 +1179,29 @@ tree_evaluator::do_breakpoint (bool is_b
 octave_value
 tree_evaluator::do_keyboard (const octave_value_list& args) const
 {
   return ::do_keyboard (args);
 }
 
 DEFUN (max_recursion_depth, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {@var{val} =} max_recursion_depth ()\n\
+@deftypefn  {Built-in Function} {@var{val} =} max_recursion_depth ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} max_recursion_depth (@var{new_val})\n\
 Query or set the internal limit on the number of times a function may\n\
 be called recursively.  If the limit is exceeded, an error message is\n\
 printed and control returns to the top level.\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (max_recursion_depth);
 }
 
 DEFUN (silent_functions, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {@var{val} =} silent_functions ()\n\
+@deftypefn  {Built-in Function} {@var{val} =} silent_functions ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} silent_functions (@var{new_val})\n\
 Query or set the internal variable that controls whether internal\n\
 output from a function is suppressed.  If this option is disabled,\n\
 Octave will display the results produced by evaluating expressions\n\
 within a function body that are not terminated with a semicolon.\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (silent_functions);
diff --git a/src/pt-mat.cc b/src/pt-mat.cc
--- a/src/pt-mat.cc
+++ b/src/pt-mat.cc
@@ -1120,21 +1120,21 @@ tree_matrix::dup (symbol_table::scope_id
 void
 tree_matrix::accept (tree_walker& tw)
 {
   tw.visit_matrix (*this);
 }
 
 DEFUN (string_fill_char, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {@var{val} =} string_fill_char ()\n\
+@deftypefn  {Built-in Function} {@var{val} =} string_fill_char ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} string_fill_char (@var{new_val})\n\
 Query or set the internal variable used to pad all rows of a character\n\
 matrix to the same length.  It must be a single character.  The default\n\
-value is @code{\" \"} (a single space).  For example,\n\
+value is @code{\" \"} (a single space).  For example:\n\
 \n\
 @example\n\
 @group\n\
 string_fill_char (\"X\");\n\
 [ \"these\"; \"are\"; \"strings\" ]\n\
      @result{} \"theseXX\"\n\
         \"areXXXX\"\n\
         \"strings\"\n\
diff --git a/src/sighandlers.cc b/src/sighandlers.cc
--- a/src/sighandlers.cc
+++ b/src/sighandlers.cc
@@ -956,42 +956,42 @@ Return a structure containing Unix signa
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (debug_on_interrupt, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {@var{val} =} debug_on_interrupt ()\n\
+@deftypefn  {Built-in Function} {@var{val} =} debug_on_interrupt ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} debug_on_interrupt (@var{new_val})\n\
 Query or set the internal variable that controls whether Octave will try\n\
 to enter debugging mode when it receives an interrupt signal (typically\n\
 generated with @kbd{C-c}).  If a second interrupt signal is received\n\
 before reaching the debugging mode, a normal interrupt will occur.\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (debug_on_interrupt);
 }
 
 DEFUN (sighup_dumps_octave_core, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {@var{val} =} sighup_dumps_octave_core ()\n\
+@deftypefn  {Built-in Function} {@var{val} =} sighup_dumps_octave_core ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} sighup_dumps_octave_core (@var{new_val})\n\
 Query or set the internal variable that controls whether Octave tries\n\
 to save all current variables to the file \"octave-core\" if it receives\n\
 a hangup signal.\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (sighup_dumps_octave_core);
 }
 
 DEFUN (sigterm_dumps_octave_core, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {@var{val} =} sigterm_dumps_octave_core ()\n\
+@deftypefn  {Built-in Function} {@var{val} =} sigterm_dumps_octave_core ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} sigterm_dumps_octave_core (@var{new_val})\n\
 Query or set the internal variable that controls whether Octave tries\n\
 to save all current variables to the file \"octave-core\" if it receives\n\
 a terminate signal.\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (sigterm_dumps_octave_core);
 }
diff --git a/src/strfns.cc b/src/strfns.cc
--- a/src/strfns.cc
+++ b/src/strfns.cc
@@ -52,17 +52,18 @@ matrices, or cell arrays.  Arguments are
 The returned values are padded with blanks as needed to make each row\n\
 of the string array have the same length.  Empty input strings are\n\
 significant and will concatenated in the output.\n\
 \n\
 For numerical input, each element is converted\n\
 to the corresponding ASCII character.  A range error results if an input\n\
 is outside the ASCII range (0-255).\n\
 \n\
-For cell arrays, each element is concatenated separately.  Cell arrays converted through\n\
+For cell arrays, each element is concatenated separately.  Cell arrays converted\n\
+through\n\
 @code{char} can mostly be converted back with @code{cellstr}.\n\
 For example,\n\
 \n\
 @example\n\
 @group\n\
 char ([97, 98, 99], \"\", @{\"98\", \"99\", 100@}, \"str1\", [\"ha\", \"lf\"])\n\
      @result{} [\"abc    \"\n\
          \"       \"\n\
@@ -175,17 +176,18 @@ matrices, or cell arrays.  Arguments are
 The returned values are padded with blanks as needed to make each row\n\
 of the string array have the same length.  Unlike @code{char}, empty\n\
 strings are removed and will not appear in the output.\n\
 \n\
 For numerical input, each element is converted\n\
 to the corresponding ASCII character.  A range error results if an input\n\
 is outside the ASCII range (0-255).\n\
 \n\
-For cell arrays, each element is concatenated separately.  Cell arrays converted through\n\
+For cell arrays, each element is concatenated separately.  Cell arrays converted\n\
+through\n\
 @code{strvcat} can mostly be converted back with @code{cellstr}.\n\
 For example,\n\
 \n\
 @example\n\
 @group\n\
 strvcat ([97, 98, 99], \"\", @{\"98\", \"99\", 100@}, \"str1\", [\"ha\", \"lf\"])\n\
      @result{} [\"abc    \"\n\
          \"98     \"\n\
@@ -634,18 +636,18 @@ strncmp_str_op (const std::string& s1, c
   octave_idx_type l1 = s1.length (), l2 = s2.length ();
   return (n > 0 && n <= l1 && n <= l2 
           && std::equal (s1.data (), s1.data () + n, s2.data ()));
 }
 
 DEFUN (strncmp, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} strncmp (@var{s1}, @var{s2}, @var{n})\n\
-Return 1 if the first @var{n} characters of strings @var{s1} and @var{s2} are the same,\n\
-and 0 otherwise.\n\
+Return 1 if the first @var{n} characters of strings @var{s1} and @var{s2} are\n\
+the same, and 0 otherwise.\n\
 \n\
 @example\n\
 @group\n\
 strncmp (\"abce\", \"abcd\", 3)\n\
      @result{} 1\n\
 @end group\n\
 @end example\n\
 \n\
diff --git a/src/symtab.cc b/src/symtab.cc
--- a/src/symtab.cc
+++ b/src/symtab.cc
@@ -1406,17 +1406,17 @@ void symbol_table::cleanup (void)
       // Now delete the scope. Note that there may be side effects, such as
       // deleting other scopes.
       delete inst;
     }
 }
 
 DEFUN (ignore_function_time_stamp, args, nargout,
     "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {@var{val} =} ignore_function_time_stamp ()\n\
+@deftypefn  {Built-in Function} {@var{val} =} ignore_function_time_stamp ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} ignore_function_time_stamp (@var{new_val})\n\
 Query or set the internal variable that controls whether Octave checks\n\
 the time stamp on files each time it looks up functions defined in\n\
 function files.  If the internal variable is set to @code{\"system\"},\n\
 Octave will not automatically recompile function files in subdirectories of\n\
 @file{@var{octave-home}/lib/@var{version}} if they have changed since\n\
 they were last compiled, but will recompile other function files in the\n\
 search path if they change.  If set to @code{\"all\"}, Octave will not\n\
@@ -1483,17 +1483,17 @@ Undocumented internal function.\n\
   retval(1) = symbol_table::current_context ();
   retval(0) = symbol_table::current_scope ();
 
   return retval;
 }
 
 DEFUN (__dump_symtab_info__, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} __dump_symtab_info__ ()\n\
+@deftypefn  {Built-in Function} {} __dump_symtab_info__ ()\n\
 @deftypefnx {Built-in Function} {} __dump_symtab_info__ (@var{scope})\n\
 @deftypefnx {Built-in Function} {} __dump_symtab_info__ (\"scopes\")\n\
 @deftypefnx {Built-in Function} {} __dump_symtab_info__ (\"functions\")\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
diff --git a/src/syscalls.cc b/src/syscalls.cc
--- a/src/syscalls.cc
+++ b/src/syscalls.cc
@@ -108,17 +108,17 @@ mk_stat_result (const base_file_stat& fs
 }
 
 DEFUNX ("dup2", Fdup2, args, ,
  "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {[@var{fid}, @var{msg}] =} dup2 (@var{old}, @var{new})\n\
 Duplicate a file descriptor.\n\
 \n\
 If successful, @var{fid} is greater than zero and contains the new file\n\
-ID.  Otherwise, @var{fid} is negative and @var{msg} contains a\n\
+ID@.  Otherwise, @var{fid} is negative and @var{msg} contains a\n\
 system-dependent error message.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   retval(1) = std::string ();
   retval(0) = -1;
 
@@ -243,17 +243,17 @@ DEFUNX ("popen2", Fpopen2, args, ,
 Start a subprocess with two-way communication.  The name of the process\n\
 is given by @var{command}, and @var{args} is an array of strings\n\
 containing options for the command.  The file identifiers for the input\n\
 and output streams of the subprocess are returned in @var{in} and\n\
 @var{out}.  If execution of the command is successful, @var{pid}\n\
 contains the process ID of the subprocess.  Otherwise, @var{pid} is\n\
 @minus{}1.\n\
 \n\
-For example,\n\
+For example:\n\
 \n\
 @example\n\
 [in, out, pid] = popen2 (\"sort\", \"-r\");\n\
 fputs (in, \"these\\nare\\nsome\\nstrings\\n\");\n\
 fclose (in);\n\
 EAGAIN = errno (\"EAGAIN\");\n\
 done = false;\n\
 do\n\
@@ -871,17 +871,17 @@ system-dependent error message.\n\
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("stat", Fstat, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {[@var{info}, @var{err}, @var{msg}] =} stat (@var{file})\n\
+@deftypefn  {Built-in Function} {[@var{info}, @var{err}, @var{msg}] =} stat (@var{file})\n\
 @deftypefnx {Built-in Function} {[@var{info}, @var{err}, @var{msg}] =} lstat (@var{file})\n\
 Return a structure @var{s} containing the following information about\n\
 @var{file}.\n\
 \n\
 @table @code\n\
 @item dev\n\
 ID of device containing a directory entry for this file.\n\
 \n\
@@ -936,17 +936,17 @@ If the call is successful @var{err} is 0
 string.  If the file does not exist, or some other error occurs, @var{s}\n\
 is an empty matrix, @var{err} is @minus{}1, and @var{msg} contains the\n\
 corresponding system error message.\n\
 \n\
 If @var{file} is a symbolic link, @code{stat} will return information\n\
 about the actual file that is referenced by the link.  Use @code{lstat}\n\
 if you want information about the symbolic link itself.\n\
 \n\
-For example,\n\
+For example:\n\
 \n\
 @example\n\
 [s, err, msg] = stat (\"/vmlinuz\")\n\
       @result{} s =\n\
         @{\n\
           atime = 855399756\n\
           rdev = 0\n\
           ctime = 847219094\n\
@@ -1171,17 +1171,17 @@ DEFUNX ("S_ISSOCK", FS_ISSOCK, args, ,
     print_usage ();
 
   return retval;
 }
 
 DEFUN (uname, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {[@var{uts}, @var{err}, @var{msg}] =} uname ()\n\
-Return system information in the structure.  For example,\n\
+Return system information in the structure.  For example:\n\
 \n\
 @example\n\
 @group\n\
 uname ()\n\
      @result{} @{\n\
            sysname = x86_64\n\
            nodename = segfault\n\
            release = 2.6.15-1-amd64-k8-smp\n\
diff --git a/src/sysdep.cc b/src/sysdep.cc
--- a/src/sysdep.cc
+++ b/src/sysdep.cc
@@ -530,17 +530,17 @@ octave_kbhit (bool wait)
   raw_mode (false, true);
 #endif
 
   return c;
 }
 
 DEFUN (clc, , ,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} clc ()\n\
+@deftypefn  {Built-in Function} {} clc ()\n\
 @deftypefnx {Built-in Function} {} home ()\n\
 Clear the terminal screen and move the cursor to the upper left corner.\n\
 @end deftypefn")
 {
   command_editor::clear_screen ();
 
   return octave_value_list ();
 }
@@ -574,17 +574,17 @@ returns a string containing the value of
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (putenv, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} putenv (@var{var}, @var{value})\n\
+@deftypefn  {Built-in Function} {} putenv (@var{var}, @var{value})\n\
 @deftypefnx {Built-in Function} {} setenv (@var{var}, @var{value})\n\
 Set the value of the environment variable @var{var} to @var{value}.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
@@ -815,17 +815,17 @@ DEFUN (tilde_expand, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} tilde_expand (@var{string})\n\
 Performs tilde expansion on @var{string}.  If @var{string} begins with a\n\
 tilde character, (@samp{~}), all of the characters preceding the first\n\
 slash (or all characters, if there is no slash) are treated as a\n\
 possible user name, and the tilde and the following characters up to the\n\
 slash are replaced by the home directory of the named user.  If the\n\
 tilde is followed immediately by a slash, the tilde is replaced by the\n\
-home directory of the user running Octave.  For example,\n\
+home directory of the user running Octave.  For example:\n\
 \n\
 @example\n\
 @group\n\
 tilde_expand (\"~joeuser/bin\")\n\
      @result{} \"/home/joeuser/bin\"\n\
 tilde_expand (\"~/bin\")\n\
      @result{} \"/home/jwe/bin\"\n\
 @end group\n\
diff --git a/src/toplev.cc b/src/toplev.cc
--- a/src/toplev.cc
+++ b/src/toplev.cc
@@ -674,17 +674,17 @@ clean_up_and_exit (int retval)
   SAFE_CALL (sysdep_cleanup, ())
 
   if (octave_exit)
     (*octave_exit) (retval == EOF ? 0 : retval);
 }
 
 DEFUN (quit, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} exit (@var{status})\n\
+@deftypefn  {Built-in Function} {} exit (@var{status})\n\
 @deftypefnx {Built-in Function} {} quit (@var{status})\n\
 Exit the current Octave session.  If the optional integer value\n\
 @var{status} is supplied, pass that value to the operating system as the\n\
 Octave's exit status.  The default value is zero.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
@@ -1060,17 +1060,17 @@ octave_remove_atexit_function (const std
     }
 
   return found;
 }
 
 
 DEFUN (atexit, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} atexit (@var{fcn})\n\
+@deftypefn  {Built-in Function} {} atexit (@var{fcn})\n\
 @deftypefnx {Built-in Function} {} atexit (@var{fcn}, @var{flag})\n\
 Register a function to be called when Octave exits.  For example,\n\
 \n\
 @example\n\
 @group\n\
 function last_words ()\n\
   disp (\"Bye bye\");\n\
 endfunction\n\
diff --git a/src/utils.cc b/src/utils.cc
--- a/src/utils.cc
+++ b/src/utils.cc
@@ -269,17 +269,17 @@ make_absolute (const string_vector& sv)
   for (octave_idx_type i = 0; i < len; i++)
     retval[i] = octave_env::make_absolute (sv[i]);
  
   return retval;
 }
 
 DEFUN (file_in_loadpath, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} file_in_loadpath (@var{file})\n\
+@deftypefn  {Built-in Function} {} file_in_loadpath (@var{file})\n\
 @deftypefnx {Built-in Function} {} file_in_loadpath (@var{file}, \"all\")\n\
 \n\
 Return the absolute name of @var{file} if it can be found in\n\
 the list of directories specified by @code{path}.\n\
 If no file is found, return an empty character string.\n\
 \n\
 If the first argument is a cell array of strings, search each\n\
 directory of the loadpath for element of the cell array and return\n\
@@ -320,22 +320,22 @@ name in the path.  If no files are found
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (file_in_path, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} file_in_path (@var{path}, @var{file})\n\
+@deftypefn  {Built-in Function} {} file_in_path (@var{path}, @var{file})\n\
 @deftypefnx {Built-in Function} {} file_in_path (@var{path}, @var{file}, \"all\")\n\
 Return the absolute name of @var{file} if it can be found in\n\
 @var{path}.  The value of @var{path} should be a colon-separated list of\n\
 directories in the format described for @code{path}.  If no file\n\
-is found, return an empty character string.  For example,\n\
+is found, return an empty character string.  For example:\n\
 \n\
 @example\n\
 @group\n\
 file_in_path (EXEC_PATH, \"sh\")\n\
      @result{} \"/bin/sh\"\n\
 @end group\n\
 @end example\n\
 \n\
@@ -820,17 +820,17 @@ containing all the directory names that 
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("errno", Ferrno, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {@var{err} =} errno ()\n\
+@deftypefn  {Built-in Function} {@var{err} =} errno ()\n\
 @deftypefnx {Built-in Function} {@var{err} =} errno (@var{val})\n\
 @deftypefnx {Built-in Function} {@var{err} =} errno (@var{name})\n\
 Return the current value of the system-dependent variable errno,\n\
 set its value to @var{val} and return the previous value, or return\n\
 the named error code given @var{name} as a character string, or -1\n\
 if @var{name} is not found.\n\
 @end deftypefn")
 {
diff --git a/src/variables.cc b/src/variables.cc
--- a/src/variables.cc
+++ b/src/variables.cc
@@ -553,20 +553,23 @@ other types of files, you should use som
 @code{file_in_path} and @code{stat} instead.\n\
 \n\
 If the optional argument @var{type} is supplied, check only for\n\
 symbols of the specified type.  Valid types are\n\
 \n\
 @table @samp\n\
 @item \"var\"\n\
 Check only for variables.\n\
+\n\
 @item \"builtin\"\n\
 Check only for built-in functions.\n\
+\n\
 @item \"file\"\n\
 Check only for files.\n\
+\n\
 @item \"dir\"\n\
 Check only for directories.\n\
 @end table\n\
 @end deftypefn")
 {
   octave_value retval = false;
 
   int nargin = args.length ();
@@ -1740,20 +1743,22 @@ pattern syntax is the same as described 
 If no patterns are supplied, all variables are listed.\n\
 By default, only variables visible in the local scope are displayed.\n\
 \n\
 The following are valid options but may not be combined.\n\
 \n\
 @table @code\n\
 @item global\n\
 List variables in the global scope rather than the current scope.\n\
+\n\
 @item -regexp\n\
 The patterns are considered to be regular expressions when matching the\n\
 variables to display.  The same pattern syntax accepted by\n\
 the @code{regexp} function is used.\n\
+\n\
 @item -file\n\
 The next argument is treated as a filename.  All variables found within the\n\
 specified file are listed.  No patterns are accepted when reading variables\n\
 from a file.\n\
 @end table\n\
 \n\
 If called as a function, return a cell array of defined variable names\n\
 matching the given patterns.\n\
@@ -1789,28 +1794,34 @@ given patterns.  Options and pattern syn
 summarized in a table with the following default entries.\n\
 \n\
 @table @asis\n\
 @item Attr\n\
 Attributes of the listed variable.  Possible attributes are:\n\
 @table @asis\n\
 @item blank\n\
 Variable in local scope\n\
+\n\
 @item @code{g}\n\
 Variable with global scope\n\
+\n\
 @item @code{p}\n\
 Persistent variable\n\
 @end table\n\
+\n\
 @item Name\n\
 The name of the variable.\n\
+\n\
 @item Size\n\
 The logical size of the variable.  A scalar is 1x1, a vector is 1xN or Nx1,\n\
 a 2-D matrix is MxN.\n\
+\n\
 @item Bytes\n\
 The amount of memory currently used to store the variable.\n\
+\n\
 @item Class\n\
 The class of the variable.  Examples include double, single, char, uint16,\n\
 cell, and struct.\n\
 @end table\n\
 \n\
 The table can be customized to display more or less information through\n\
 the function @code{whos_line_format}.\n\
 \n\
@@ -2280,22 +2291,26 @@ The following options are available in b
 Clears all local and global user-defined variables and all functions\n\
 from the symbol table.\n\
 \n\
 @item -exclusive, -x\n\
 Clears the variables that don't match the following pattern.\n\
 \n\
 @item -functions, -f\n\
 Clears the function names and the built-in symbols names.\n\
+\n\
 @item -global, -g\n\
 Clears the global symbol names.\n\
+\n\
 @item -variables, -v\n\
 Clears the local variable names.\n\
+\n\
 @item -classes, -c\n\
 Clears the class structure table and clears all objects.\n\
+\n\
 @item -regexp, -r\n\
 The arguments are treated as regular expressions as any variables that\n\
 match will be cleared.\n\
 @end table\n\
 With the exception of @code{exclusive}, all long options can be used \n\
 without the dash as well.\n\
 @end deffn")
 {
@@ -2443,37 +2458,45 @@ A full format string is:\n\
 @end smallexample\n\
 \n\
 The following command sequences are available:\n\
 \n\
 @table @code\n\
 @item %a\n\
 Prints attributes of variables (g=global, p=persistent,\n\
 f=formal parameter, a=automatic variable).\n\
+\n\
 @item %b\n\
 Prints number of bytes occupied by variables.\n\
+\n\
 @item %c\n\
 Prints class names of variables.\n\
+\n\
 @item %e\n\
 Prints elements held by variables.\n\
+\n\
 @item %n\n\
 Prints variable names.\n\
+\n\
 @item %s\n\
 Prints dimensions of variables.\n\
+\n\
 @item %t\n\
 Prints type names of variables.\n\
 @end table\n\
 \n\
 Every command may also have an alignment modifier:\n\
 \n\
 @table @code\n\
 @item l\n\
 Left alignment.\n\
+\n\
 @item r\n\
 Right alignment (default).\n\
+\n\
 @item c\n\
 Column-aligned (only applicable to command %s).\n\
 @end table\n\
 \n\
 The @code{width} parameter is a positive integer specifying the minimum\n\
 number of columns used for printing.  No maximum is needed as the field will\n\
 auto-expand as required.\n\
 \n\
@@ -2491,17 +2514,17 @@ The default format is\n\
 {
   return SET_INTERNAL_VARIABLE (whos_line_format);
 }
 
 static std::string Vmissing_function_hook = "unimplemented";
 
 DEFUN (missing_function_hook, args, nargout,
     "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {@var{val} =} missing_function_hook ()\n\
+@deftypefn  {Built-in Function} {@var{val} =} missing_function_hook ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} missing_function_hook (@var{new_val})\n\
 Query or set the internal variable that allows setting a custom hook function\n\
 called when an uknown identifier is requested.\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (missing_function_hook);
 }
 
