# HG changeset patch
# User Jordi Guti√©rrez Hermoso <jordigh@octave.org>
# Date 1329446836 18000
#      Thu Feb 16 21:47:16 2012 -0500
# Branch gui
# Node ID d738c29a2528f166c7b6ba3e065e9bd440056826
# Parent  75cb16d1292b37e34fbfaa8a881b4adca1969739
# Parent  dbc99d17f0add4d32f9648d4b737bc8f07b1635b
Merge default onto gui

diff --git a/NEWS b/NEWS
--- a/NEWS
+++ b/NEWS
@@ -1,13 +1,46 @@
 Summary of important user-visible changes for version 4.0:
 ---------------------------------------------------------
 
  ** A new GUI is now available with Octave.
 
+Summary of important user-visible changes for version 3.8:
+---------------------------------------------------------
+
+ ** Other new functions added in 3.8.0:
+
+      colorcube
+      lines
+      rgbplot
+
+ ** Deprecated functions.
+
+    The following functions were deprecated in Octave 3.4 and have been
+    removed from Octave 3.8.
+                                           
+      autocor    dispatch              is_global    strerror
+      autocov    fstat                 krylovb      values  
+      betai      gammai                perror               
+      cellidx    glpkmex               replot               
+      cquad      is_duplicate_entry    saveimage            
+      
+    The following functions have been deprecated in Octave 3.8 and will
+    be removed from Octave 3.12 (or whatever version is the second major
+    release after 3.8):
+
+      <none yet>
+
+    The following keywords have been deprecated in Octave 3.8 and will
+    be removed from Octave 3.12 (or whatever version is the second major
+    release after 3.8):
+
+      static
+
+
 Summary of important user-visible changes for version 3.6:
 ---------------------------------------------------------
 
  ** The PCRE library is now required to build Octave.  If a pre-compiled
     package does not exist for your system, you can find PCRE sources
     at http://www.pcre.org
 
  ** The ARPACK library is no longer distributed with Octave.
@@ -705,19 +738,19 @@ Summary of important user-visible change
       spatan2             spkron       str2mat
       spchol              splchol      unmark_command
       spchol2inv          split        unmark_rawcommand
 
     The following functions have been deprecated in Octave 3.4 and will
     be removed from Octave 3.8 (or whatever version is the second major
     release after 3.4):
 
-      autocor  cellidx   gammai     krylovb  saveimage 
-      autocov  dispatch  glpkmex    perror   strerror  
-      betai    fstat     is_global  replot   values    
+      autocor  cellidx   gammai     is_global  replot     values
+      autocov  dispatch  glpkmex    krylovb    saveimage
+      betai    fstat     intwarning perror     strerror
 
 Summary of important user-visible changes for version 3.2:
 ---------------------------------------------------------
 
  ** Compatibility with Matlab graphics has been improved.
 
     The hggroup object and associated listener callback functions have
     been added allowing the inclusion of group objects.  Data sources
diff --git a/configure.ac b/configure.ac
--- a/configure.ac
+++ b/configure.ac
@@ -22,17 +22,17 @@ dnl Copyright (C) 1993-2012 John W. Eato
 
 ### Preserve CFLAGS and CXXFLAGS from the environment before doing
 ### anything else because we don't know which macros might call
 ### AC_PROG_CC or AC_PROG_CXX.
 
 EXTERN_CFLAGS="$CFLAGS"
 EXTERN_CXXFLAGS="$CXXFLAGS"
 
-AC_INIT([GNU Octave], [3.6.0], [http://octave.org/bugs.html], [octave])
+AC_INIT([GNU Octave], [3.7.0+], [http://octave.org/bugs.html], [octave])
 
 dnl PACKAGE_VERSION is set by the AC_INIT VERSION arg
 OCTAVE_VERSION="$PACKAGE_VERSION"
 OCTAVE_API_VERSION_NUMBER="48"
 OCTAVE_API_VERSION="api-v$OCTAVE_API_VERSION_NUMBER+"
 OCTAVE_RELEASE_DATE="2012-01-15"
 OCTAVE_COPYRIGHT="Copyright (C) 2012 John W. Eaton and others."
 AC_SUBST(OCTAVE_VERSION)
@@ -644,17 +644,17 @@ OCTAVE_IEEE754_DATA_FORMAT
 
 OCTAVE_CXX_COMPLEX_SETTERS
 OCTAVE_CXX_COMPLEX_REFERENCE_ACCESSORS
 
 ### Check for the QHull library
 
 OCTAVE_CHECK_LIBRARY(qhull, QHull,
   [Qhull library not found -- this will result in loss of functionality of some geometry functions.],
-  [qhull/libqhull.h libqhull.h qhull/qhull.h qhull.h], [qh_qhull], [], [],
+  [libqhull/libqhull.h qhull/libqhull.h libqhull.h qhull/qhull.h qhull.h], [qh_qhull], [], [],
   [warn_qhull=
    OCTAVE_CHECK_QHULL_VERSION
    OCTAVE_CHECK_QHULL_OK([TEXINFO_QHULL="@set HAVE_QHULL"
      AC_DEFINE(HAVE_QHULL, 1, [Define if QHull is available.])], [
      warn_qhull="Qhull library found, but seems not to work properly -- this will result in loss of functionality of some geometry functions.  Please try recompiling the library with -fno-strict-aliasing."])])
 
 ### Check for pcre regex library.
 
@@ -2135,17 +2135,17 @@ else
   AC_MSG_WARN([I couldn't find termios.h, termio.h, or sgtty.h!])
 fi
 
 ### Checks for functions and variables.
 
 AC_CHECK_FUNCS(basename canonicalize_file_name \
   chmod dup2 endgrent endpwent execvp expm1 expm1f fork \
   getegid geteuid getgid getgrent getgrgid getgrnam getpgrp getpid \
-  getppid getpwent getpwuid getuid getwd _kbhit \
+  getppid getpwent getpwuid getuid getwd _kbhit kill \
   lgamma lgammaf lgamma_r lgammaf_r localtime_r log1p log1pf \
   mkstemp pipe putenv \
   realpath resolvepath rindex roundl select setgrent setlocale \
   setpwent setvbuf siglongjmp \
   strsignal tempnam tgammaf umask \
   uname utime waitpid \
   _chmod x_utime _utime32)
 
diff --git a/doc/interpreter/doccheck/aspell-octave.en.pws b/doc/interpreter/doccheck/aspell-octave.en.pws
--- a/doc/interpreter/doccheck/aspell-octave.en.pws
+++ b/doc/interpreter/doccheck/aspell-octave.en.pws
@@ -115,16 +115,17 @@ changeset
 changesets
 Chaves
 chdir
 chisq
 chisquare
 chol
 Cholesky
 cholmod
+chrominance
 cindex
 circ
 circshift
 circum
 Clenshaw
 clim
 cloglog
 clubsuit
@@ -133,16 +134,17 @@ cmd
 cmember
 cntrl
 cof
 coffset
 colamd
 collectoutput
 colorbar
 colormap
+ColorOrder
 colperm
 Comint
 Commandline
 commentstyle
 ComplexEqn
 cond
 condest
 conformant
diff --git a/doc/interpreter/grammar.txi b/doc/interpreter/grammar.txi
--- a/doc/interpreter/grammar.txi
+++ b/doc/interpreter/grammar.txi
@@ -41,22 +41,22 @@ or function names:
 @item @code{case} @tab @code{catch} @tab @code{classdef}
 @item @code{continue} @tab @code{do} @tab @code{else}
 @item @code{elseif} @tab @code{end} @tab @code{end_try_catch}
 @item @code{end_unwind_protect} @tab @code{endclassdef} @tab @code{endenumeration}
 @item @code{endevents} @tab @code{endfor} @tab @code{endfunction}
 @item @code{endif} @tab @code{endmethods} @tab @code{endparfor}
 @item @code{endproperties} @tab @code{endswitch} @tab @code{endwhile}
 @item @code{enumeration} @tab @code{events} @tab @code{for}
-@item @code{function} @tab @code{get} @tab @code{global}
-@item @code{if} @tab @code{methods} @tab @code{otherwise}
-@item @code{parfor} @tab @code{persistent} @tab @code{properties}
-@item @code{return} @tab @code{set} @tab @code{static}
-@item @code{switch} @tab @code{try} @tab @code{until}
-@item @code{unwind_protect} @tab @code{unwind_protect_cleanup} @tab @code{while}
+@item @code{function} @tab @code{global} @tab @code{if}
+@item @code{methods} @tab @code{otherwise} @tab @code{parfor}
+@item @code{persistent} @tab @code{properties} @tab @code{return}
+@item @code{static} @tab @code{switch} @tab @code{try}
+@item @code{until} @tab @code{unwind_protect} @tab @code{unwind_protect_cleanup}
+@item @code{while}
 @end multitable
 
 The function @code{iskeyword} can be used to quickly check whether an
 identifier is reserved by Octave.
 
 @DOCSTRING(iskeyword)
 
 @node Parser
diff --git a/doc/interpreter/image.txi b/doc/interpreter/image.txi
--- a/doc/interpreter/image.txi
+++ b/doc/interpreter/image.txi
@@ -122,34 +122,40 @@ between 0 and 1.
 @DOCSTRING(ind2gray)
 
 @DOCSTRING(rgb2ind)
 
 @DOCSTRING(ind2rgb)
 
 @DOCSTRING(colormap)
 
+@DOCSTRING(rgbplot)
+
 @DOCSTRING(autumn)
 
 @DOCSTRING(bone)
 
+@DOCSTRING(colorcube)
+
 @DOCSTRING(cool)
 
 @DOCSTRING(copper)
 
 @DOCSTRING(flag)
 
 @DOCSTRING(gray)
 
 @DOCSTRING(hot)
 
 @DOCSTRING(hsv)
 
 @DOCSTRING(jet)
 
+@DOCSTRING(lines)
+
 @DOCSTRING(ocean)
 
 @DOCSTRING(pink)
 
 @DOCSTRING(prism)
 
 @DOCSTRING(rainbow)
 
@@ -161,19 +167,19 @@ between 0 and 1.
 
 @DOCSTRING(winter)
 
 @DOCSTRING(contrast)
 
 An additional colormap is @code{gmap40}.  This code map contains only
 colors with integer values of the red, green and blue components.  This
 is a workaround for a limitation of gnuplot 4.0, that does not allow the color
-of line or patch objects to be set, and so @code{gmap40} is useful for gnuplot
-4.0 users, and in particular in conjunction with the @var{bar},
-@var{barh} or @var{contour} functions.
+of line or patch objects to be set.  @code{gmap40} is chiefly useful to gnuplot
+4.0 users, and particularly in conjunction with the @var{bar}, @var{surf},
+and @var{contour} functions.
 
 @DOCSTRING(gmap40)
 
 The following three functions modify the existing colormap rather than
 replace it.   
 
 @DOCSTRING(brighten)
 
diff --git a/liboctave/caseless-str.h b/liboctave/caseless-str.h
--- a/liboctave/caseless-str.h
+++ b/liboctave/caseless-str.h
@@ -18,16 +18,17 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, see
 <http://www.gnu.org/licenses/>.
 
 */
 
 #if !defined (octave_caseless_str_h)
 #define octave_caseless_str_h 1
 
+#include <cctype>
 #include <string>
 
 class caseless_str : public std::string
 {
 public:
 
   typedef std::string::iterator iterator;
   typedef std::string::const_iterator const_iterator;
diff --git a/liboctave/regexp.h b/liboctave/regexp.h
--- a/liboctave/regexp.h
+++ b/liboctave/regexp.h
@@ -28,17 +28,19 @@ along with Octave; see the file COPYING.
 #include <sstream>
 #include <string>
 
 #include "Array.h"
 #include "Matrix.h"
 #include "base-list.h"
 #include "str-vec.h"
 
-class regexp
+class
+OCTAVE_API
+regexp
 {
 public:
 
   class opts;
   class match_data;
 
   regexp (const std::string& pat = "",
           const regexp::opts& opt = regexp::opts (),
diff --git a/m4/acinclude.m4 b/m4/acinclude.m4
--- a/m4/acinclude.m4
+++ b/m4/acinclude.m4
@@ -932,17 +932,23 @@ AC_DEFUN([OCTAVE_HDF5_HAS_ENFORCED_16_AP
 dnl
 dnl Check for the QHull version.
 dnl
 AC_DEFUN([OCTAVE_CHECK_QHULL_VERSION],
   [AC_CACHE_CHECK([for qh_version in $QHULL_LIBS],
     octave_cv_lib_qhull_version,  [
       AC_LINK_IFELSE([AC_LANG_PROGRAM([[
 #include <stdio.h>
-#if defined (HAVE_QHULL_LIBQHULL_H) || defined (HAVE_QHULL_QHULL_H)
+#if defined (HAVE_LIBQHULL_LIBQHULL_H)
+# include <libqhull/libqhull.h>
+# include <libqhull/qset.h>
+# include <libqhull/geom.h>
+# include <libqhull/poly.h>
+# include <libqhull/io.h>
+#elif defined (HAVE_QHULL_LIBQHULL_H) || defined (HAVE_QHULL_QHULL_H)
 # if defined (HAVE_QHULL_LIBQHULL_H)
 #  include <qhull/libqhull.h>
 # else
 #  include <qhull/qhull.h>
 # endif
 # include <qhull/qset.h>
 # include <qhull/geom.h>
 # include <qhull/poly.h>
@@ -969,17 +975,23 @@ const char *tmp = qh_version;
 dnl
 dnl Check whether QHull works (does not crash)
 dnl
 AC_DEFUN([OCTAVE_CHECK_QHULL_OK],
   [AC_CACHE_CHECK([whether the qhull library works],
     octave_cv_lib_qhull_ok, [
       AC_RUN_IFELSE([AC_LANG_PROGRAM([[
 #include <stdio.h>
-#if defined (HAVE_QHULL_LIBQHULL_H) || defined (HAVE_QHULL_QHULL_H)
+#if defined (HAVE_LIBQHULL_LIBQHULL_H)
+# include <libqhull/libqhull.h>
+# include <libqhull/qset.h>
+# include <libqhull/geom.h>
+# include <libqhull/poly.h>
+# include <libqhull/io.h>
+#elif defined (HAVE_QHULL_LIBQHULL_H) || defined (HAVE_QHULL_QHULL_H)
 # if defined (HAVE_QHULL_LIBQHULL_H)
 #  include <qhull/libqhull.h>
 # else
 #  include <qhull/qhull.h>
 # endif
 # include <qhull/qset.h>
 # include <qhull/geom.h>
 # include <qhull/poly.h>
diff --git a/scripts/audio/wavread.m b/scripts/audio/wavread.m
--- a/scripts/audio/wavread.m
+++ b/scripts/audio/wavread.m
@@ -239,11 +239,12 @@ function chunk_size = find_chunk (fid, c
     chunk_size += rem (chunk_size, 2);
     offset = offset + 8 + chunk_size;
   endwhile
   if (! strcmp (id, chunk_id))
     chunk_size = -1;
   endif
 endfunction
 
-## Mark file as being tested.  Tests for wavread/wavwrite pair are in
-## wavwrite.m
+
+## Mark file as tested.  Tests for wavread/wavwrite pair are in wavwrite.m.
 %!assert(1)
+
diff --git a/scripts/deprecated/autocor.m b/scripts/deprecated/autocor.m
deleted file mode 100644
--- a/scripts/deprecated/autocor.m
+++ /dev/null
@@ -1,59 +0,0 @@
-## Copyright (C) 1995-2012 Friedrich Leisch
-##
-## This file is part of Octave.
-##
-## Octave is free software; you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation; either version 3 of the License, or (at
-## your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <http://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn {Function File} {} autocor (@var{x}, @var{h})
-## Return the autocorrelations from lag 0 to @var{h} of vector @var{x}.
-## If @var{h} is omitted, all autocorrelations are computed.
-## If @var{x} is a matrix, the autocorrelations of each column are
-## computed.
-## The particular algorithm used is from the field of statistics and
-## differs from the definition used in signal processing.
-## @end deftypefn
-
-## Author: FL <Friedrich.Leisch@ci.tuwien.ac.at>
-## Description: Compute autocorrelations
-
-## Deprecated in version 3.4
-
-function retval = autocor (X, h)
-
-  persistent warned = false;
-  if (! warned)
-    warned = true;
-    warning ("Octave:deprecated-function",
-             "autocor is obsolete and will be removed from a future version of Octave; See the Octave-Forge signal package and the function xcor for a replacement");
-  endif
-
-
-  if (nargin == 1)
-    retval = autocov (X);
-  elseif (nargin == 2)
-    retval = autocov (X, h);
-  else
-    print_usage ();
-  endif
-
-  if (min (retval (1,:)) != 0)
-    retval = retval ./ (ones (rows (retval), 1) * retval(1,:));
-  endif
-
-endfunction
-
-
-
diff --git a/scripts/deprecated/autocov.m b/scripts/deprecated/autocov.m
deleted file mode 100644
--- a/scripts/deprecated/autocov.m
+++ /dev/null
@@ -1,62 +0,0 @@
-## Copyright (C) 1995-2012 Friedrich Leisch
-##
-## This file is part of Octave.
-##
-## Octave is free software; you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation; either version 3 of the License, or (at
-## your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <http://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn {Function File} {} autocov (@var{x}, @var{h})
-## Return the autocovariances from lag 0 to @var{h} of vector @var{x}.
-## If @var{h} is omitted, all autocovariances are computed.
-## If @var{x} is a matrix, the autocovariances of each column are
-## computed.
-## The particular algorithm used is from the field of statistics and
-## differs from the definition used in signal processing.
-## @end deftypefn
-
-## Author: FL <Friedrich.Leisch@ci.tuwien.ac.at>
-## Description: Compute autocovariances
-
-## Deprecated in version 3.4
-
-function retval = autocov (X, h)
-  persistent warned = false;
-  if (! warned)
-    warned = true;
-    warning ("Octave:deprecated-function",
-             "autocov is obsolete and will be removed from a future version of Octave; See the Octave-Forge signal package and the function xcov for a replacement");
-  endif
-
-  [n, c] = size (X);
-
-  if (isvector (X))
-    n = length (X);
-    c = 1;
-    X = reshape (X, n, 1);
-  endif
-
-  X = center (X);
-
-  if (nargin == 1)
-    h = n - 1;
-  endif
-
-  retval = zeros (h + 1, c);
-
-  for i = 0 : h
-    retval(i+1, :) = diag (X(i+1:n, :).' * conj (X(1:n-i, :))).' / n;
-  endfor
-
-endfunction
diff --git a/scripts/deprecated/betai.m b/scripts/deprecated/betai.m
deleted file mode 100644
--- a/scripts/deprecated/betai.m
+++ /dev/null
@@ -1,47 +0,0 @@
-## Copyright (C) 1994-2012 John W. Eaton
-##
-## This file is part of Octave.
-##
-## Octave is free software; you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation; either version 3 of the License, or (at
-## your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <http://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn {Function File} {} betai (@var{a}, @var{b}, @var{x})
-## This function is provided for compatibility with older versions of
-## Octave.  New programs should use betainc instead.
-##
-## @code{betai (@var{a}, @var{b}, @var{x})} is the same as
-## @code{betainc (@var{x}, @var{a}, @var{b})}.
-## @end deftypefn
-
-## Author: jwe
-## Created: 30 Jan 1998
-
-## Deprecated in version 3.4
-
-function retval = betai (a, b, x)
-  persistent warned = false;
-  if (! warned)
-    warned = true;
-    warning ("Octave:deprecated-function",
-             "betai is obsolete and will be removed from a future version of Octave; please use betainc instead");
-  endif
-
-  if (nargin == 3)
-    retval = betainc (x, a, b);
-  else
-    print_usage ();
-  endif
-
-endfunction
diff --git a/scripts/deprecated/cellidx.m b/scripts/deprecated/cellidx.m
deleted file mode 100644
--- a/scripts/deprecated/cellidx.m
+++ /dev/null
@@ -1,108 +0,0 @@
-## Copyright (C) 2000-2012 Auburn University.  All rights reserved.
-##
-## This file is part of Octave.
-##
-## Octave program is free software; you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation; either version 3 of the License, or (at
-## your option) any later version.
-##
-## Octave program is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <http://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn {Function File} {[@var{idxvec}, @var{errmsg}] =} cellidx (@var{listvar}, @var{strlist})
-## Return indices of string entries in @var{listvar} that match strings
-## in @var{strlist}.
-##
-## Both @var{listvar} and @var{strlist} may be passed as strings or
-## string matrices.  If they are passed as string matrices, each entry
-## is processed by @code{deblank} prior to searching for the entries.
-##
-## The first output is the vector of indices in @var{listvar}.
-##
-## If @var{strlist} contains a string not in @var{listvar}, then
-## an error message is returned in @var{errmsg}.  If only one output
-## argument is requested, then @var{cellidx} prints @var{errmsg} to the
-## screen and exits with an error.
-## @end deftypefn
-
-## deprecated in version 3.4
-
-function [idxvec,errmsg]  = cellidx (listvar, strlist)
-
-  persistent warned = false;
-  if (! warned)
-    warned = true;
-    warning ("Octave:deprecated-function",
-             "cellidx is obsolete and will be removed from a future version of Octave; use ismember instead");
-  endif
-
-  if (nargin != 2)
-    print_usage ();
-  endif
-
-  if (ischar (strlist))
-    tmp = strlist;
-    strlist = {};
-    for kk = 1:rows(tmp)
-      strlist{kk} = deblank (tmp(kk,:));
-    endfor
-  endif
-
-  if (ischar (listvar))
-    tmp = listvar;
-    listvar = {};
-    for kk = 1:rows(tmp)
-      listvar{kk} = deblank (tmp(kk,:));
-    endfor
-  endif
-
-  ## initialize size of idxvec (for premature return)
-  idxvec = zeros (length(strlist), 1);
-
-  errmsg = "";
-  if (! iscellstr (listvar))
-    errmsg = "listvar must be a list of strings";
-  elseif (! iscellstr (strlist))
-    errmsg = "strlist must be a list of strings";
-  endif
-
-  if (length (errmsg))
-    if (nargout < 2)
-      error (errmsg);
-    else
-      return;
-    endif
-  endif
-
-  nsigs = length(listvar);
-  for idx = 1:length(strlist)
-    signame = strlist{idx};
-    for jdx = 1:nsigs
-      if (strcmp (signame, listvar{jdx}))
-        if (idxvec(idx) != 0)
-          warning ("Duplicate signal name %s (%d,%d)\n",
-                   listvar{jdx}, jdx, idxvec(idx));
-        else
-          idxvec(idx) = jdx;
-        endif
-      endif
-    endfor
-    if (idxvec(idx) == 0)
-      errmsg = sprintf ("Did not find %s", signame);
-      if (nargout == 1)
-        error (errmsg);
-      else
-        break;
-      endif
-    endif
-  endfor
-
-endfunction
diff --git a/scripts/deprecated/clg.m b/scripts/deprecated/clg.m
deleted file mode 100644
--- a/scripts/deprecated/clg.m
+++ /dev/null
@@ -1,40 +0,0 @@
-## Copyright (C) 2006-2012 John W. Eaton
-##
-## This file is part of Octave.
-##
-## Octave is free software; you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation; either version 3 of the License, or (at
-## your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <http://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn {Function File} {} clg ()
-## This function has been deprecated.  Use clf instead.
-## @end deftypefn
-
-## Author: jwe
-
-## Deprecated in version 3.0
-## Matlab still has this function, so don't remove just yet.
-
-function clg ()
-
-  persistent warned = false;
-  if (! warned)
-    warned = true;
-    warning ("Octave:deprecated-function",
-             "clg is obsolete and will be removed from a future version of Octave, please use clf instead");
-  endif
-
-  clf ();
-
-endfunction
diff --git a/scripts/deprecated/cquad.m b/scripts/deprecated/cquad.m
deleted file mode 100644
--- a/scripts/deprecated/cquad.m
+++ /dev/null
@@ -1,39 +0,0 @@
-## Copyright (C) 2012 John W. Eaton
-##
-## This file is part of Octave.
-##
-## Octave is free software; you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation; either version 3 of the License, or (at
-## your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <http://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn  {Function File} {[@var{int}, @var{err}, @var{nr_points}] =} cquad (@var{f}, @var{a}, @var{b}, @var{tol})
-## @deftypefnx {Function File} {[@var{int}, @var{err}, @var{nr_points}] =} cquad (@var{f}, @var{a}, @var{b}, @var{tol}, @var{sing})
-## This function is an alias for compatibility with older versions of
-## Octave.  New programs should use @code{quadcc} instead.
-## @seealso{quadcc}
-## @end deftypefn
-
-## Deprecated in version 3.4
-
-function retval = cquad (varargin)
-  persistent warned = false;
-  if (! warned)
-    warned = true;
-    warning ("Octave:deprecated-function",
-             "cquad has been renamed to quadcc and this alias will be removed from a future version of Octave; please use quadcc instead");
-  endif
-
-  retval = quadcc (varargin{:});
-
-endfunction
diff --git a/scripts/deprecated/dispatch.m b/scripts/deprecated/dispatch.m
deleted file mode 100644
--- a/scripts/deprecated/dispatch.m
+++ /dev/null
@@ -1,103 +0,0 @@
-## Copyright (C) 2010-2012 John W. Eaton
-##
-## This file is part of Octave.
-##
-## Octave is free software; you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation; either version 3 of the License, or (at
-## your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <http://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn {Loadable Function} {} dispatch (@var{f}, @var{r}, @var{type})
-##
-## Replace the function @var{f} with a dispatch so that function @var{r}
-## is called when @var{f} is called with the first argument of the named
-## @var{type}.  If the type is @var{any} then call @var{r} if no other type
-## matches.  The original function @var{f} is accessible using
-## @code{builtin (@var{f}, @dots{})}.
-##
-## If @var{r} is omitted, clear dispatch function associated with @var{type}.
-##
-## If both @var{r} and @var{type} are omitted, list dispatch functions
-## for @var{f}.
-## @seealso{builtin}
-## @end deftypefn
-
-## Deprecated in version 3.4
-
-function varargout = dispatch (varargin)
-
-  persistent warned = false;
-  if (! warned)
-    warned = true;
-    warning ("Octave:deprecated-function",
-             "dispatch is obsolete and will be removed from a future version of Octave; please use classes instead");
-  endif
-
-  varargout = cell (nargout, 1);
-  [ varargout{:} ] = __dispatch__ (varargin{:});
-
-endfunction
-
-
-%!test # builtin function replacement
-%! dispatch('sin','length','string')
-%! assert(sin("abc"),3)
-%! assert(sin(0),0,10*eps);
-
-%!test # 'any' function
-%! dispatch('sin','exp','any')
-%! assert(sin(0),1,eps);
-%! assert(sin("abc"),3);
-
-%!test # 'builtin' function
-%! assert(builtin('sin',0),0,eps);
-%! builtin('eval','x=1;');
-%! assert(x,1);
-
-%!test # clear function mapping
-%! dispatch('sin','string')
-%! dispatch('sin','any')
-%! assert(sin(0),0,10*eps);
-
-%!test # oct-file replacement
-%! dispatch('fft','length','string')
-%! assert(fft([1,1]),[2,0]);
-%! assert(fft("abc"),3)
-%! dispatch('fft','string');
-
-%!test # m-file replacement
-%! dispatch('hamming','length','string')
-%! assert(hamming(1),1)
-%! assert(hamming("abc"),3)
-%! dispatch('hamming','string')
-
-%!test # override preloaded builtin
-%! evalin('base','cos(1);');
-%! dispatch('cos','length','string')
-%! evalin('base','assert(cos("abc"),3)');
-%! evalin('base','assert(cos(0),1,eps)');
-%! dispatch('cos','string')
-
-%!test # override pre-loaded oct-file
-%! evalin('base','qr(1);');
-%! dispatch('qr','length','string')
-%! evalin('base','assert(qr("abc"),3)');
-%! evalin('base','assert(qr(1),1)');
-%! dispatch('qr','string');
-
-%!test # override pre-loaded m-file
-%! evalin('base','hanning(1);');
-%! dispatch('hanning','length','string')
-%! evalin('base','assert(hanning("abc"),3)');
-%! evalin('base','assert(hanning(1),1)');
-%! dispatch('hanning','string');
diff --git a/scripts/deprecated/fstat.m b/scripts/deprecated/fstat.m
deleted file mode 100644
--- a/scripts/deprecated/fstat.m
+++ /dev/null
@@ -1,35 +0,0 @@
-## Copyright (C) 2010-2012 VZLU Prague
-##
-## This file is part of Octave.
-##
-## Octave is free software; you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation; either version 3 of the License, or (at
-## your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <http://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn {Function File} {[@var{info}, @var{err}, @var{msg}] =} fstat (fid)
-## This function has been deprecated.  Use stat instead.
-## @end deftypefn
-
-## Deprecated in version 3.4
-
-function [info, err, msg] = fstat (fid)
-  persistent warned = false;
-  if (! warned)
-    warned = true;
-    warning ("Octave:deprecated-function",
-             "fstat is obsolete and will be removed from a future version of Octave, please use stat instead");
-  endif
-
-  [info, err, msg] = stat (fid);
-endfunction
diff --git a/scripts/deprecated/gammai.m b/scripts/deprecated/gammai.m
deleted file mode 100644
--- a/scripts/deprecated/gammai.m
+++ /dev/null
@@ -1,47 +0,0 @@
-## Copyright (C) 1994-2012 John W. Eaton
-##
-## This file is part of Octave.
-##
-## Octave is free software; you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation; either version 3 of the License, or (at
-## your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <http://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn {Function File} {} gammai (@var{a}, @var{x})
-## This function is provided for compatibility with older versions of
-## Octave.  New programs should use @code{gammainc} instead.
-##
-## @code{gammai (@var{a}, @var{x})} is the same as
-## @code{gammainc (@var{x}, @var{a})}.
-## @end deftypefn
-
-## Author: jwe
-## Created: 30 Jan 1998
-
-## Deprecated in version 3.4
-
-function retval = gammai (a, x)
-  persistent warned = false;
-  if (! warned)
-    warned = true;
-    warning ("Octave:deprecated-function",
-             "gammai is obsolete and will be removed from a future version of Octave; please use gammainc instead");
-  endif
-
-  if (nargin == 2)
-    retval = gammainc (x, a);
-  else
-    print_usage ();
-  endif
-
-endfunction
diff --git a/scripts/deprecated/glpkmex.m b/scripts/deprecated/glpkmex.m
deleted file mode 100644
--- a/scripts/deprecated/glpkmex.m
+++ /dev/null
@@ -1,117 +0,0 @@
-## Copyright (C) 2005-2012 Nicolo' Giorgetti
-##
-## This file is part of Octave.
-##
-## Octave is free software; you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation; either version 3 of the License, or (at
-## your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <http://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn {Function File} {[@var{xopt}, @var{fmin}, @var{status}, @var{extra}] =} glpkmex (@var{sense}, @var{c}, @var{A}, @var{b}, @var{ctype}, @var{lb}, @var{ub}, @var{vartype}, @var{param}, @var{lpsolver}, @var{save_pb})
-## This function is provided for compatibility with the old @sc{matlab}
-## interface to the GNU @sc{glpk} library.  For Octave code, you should use
-## the @code{glpk} function instead.
-## @seealso{glpk}
-## @end deftypefn
-
-function [xopt, fopt, status, extra] = glpkmex (varargin)
-
-  persistent warned = false;
-  if (! warned)
-    warned = true;
-    warning ("Octave:deprecated-function",
-             "glpkmex is obsolete and will be removed from a future version of Octave; please use glpk instead");
-  endif
-
-  ## If there is no input output the version and syntax
-  if (nargin < 4 || nargin > 11)
-    print_usage ();
-    return;
-  endif
-
-  ## reorder args:
-  ##
-  ##     glpkmex    glpk
-  ##
-  ##  1   sense      c
-  ##  2   c          a
-  ##  3   a          b
-  ##  4   b          lb
-  ##  5   ctype      ub
-  ##  6   lb         ctype
-  ##  7   ub         vartype
-  ##  8   vartype    sense
-  ##  9   param      param
-  ## 10   lpsolver
-  ## 11   savepb
-
-  sense = varargin{1};
-  c = varargin{2};
-  a = varargin{3};
-  b = varargin{4};
-
-  nx = length  (c);
-
-  if (nargin > 4)
-    ctype = varargin{5};
-  else
-    ctype = repmat ("U", nx, 1);
-  endif
-
-  if (nargin > 5)
-    lb = varargin{6};
-  else
-    lb = repmat (-Inf, nx, 1);
-  endif
-
-  if (nargin > 6)
-    ub = varargin{7};
-  else
-    ub = repmat (Inf, nx, 1);
-  endif
-
-  if (nargin > 7)
-    vartype = varargin{8};
-  else
-    vartype = repmat ("C", nx, 1);
-  endif
-
-  if (nargin > 8)
-    param = varargin{9};
-  else
-    param = struct ();
-  endif
-
-  if (nargin > 9 && ! isfield (param, "lpsolver"))
-    param.lpsolver = varargin{10};
-  endif
-
-  if (nargin > 10 && ! isfield (param, "save"))
-    param.save = varargin{11};
-  endif
-
-  if (nargout == 0)
-    glpk (c, a, b, lb, ub, ctype, vartype, sense, param);
-  elseif (nargout == 1)
-    xopt = glpk (c, a, b, lb, ub, ctype, vartype, sense, param);
-  elseif (nargout == 2)
-    [xopt, fopt] = glpk (c, a, b, lb, ub, ctype, vartype, sense, param);
-  elseif (nargout == 3)
-    [xopt, fopt, status] = ...
-      glpk (c, a, b, lb, ub, ctype, vartype, sense, param);
-  else
-    [xopt, fopt, status, extra] = ...
-      glpk (c, a, b, lb, ub, ctype, vartype, sense, param);
-  endif
-
-endfunction
diff --git a/scripts/deprecated/intwarning.m b/scripts/deprecated/intwarning.m
deleted file mode 100644
--- a/scripts/deprecated/intwarning.m
+++ /dev/null
@@ -1,133 +0,0 @@
-## Copyright (C) 2008-2012 David Bateman
-##
-## This file is part of Octave.
-##
-## Octave is free software; you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation; either version 3 of the License, or (at
-## your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <http://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn  {Function File} {} intwarning (@var{action})
-## @deftypefnx {Function File} {} intwarning (@var{s})
-## @deftypefnx {Function File} {@var{s} =} intwarning (@dots{})
-## Control the state of the warning for integer conversions and math
-## operations.
-##
-## @table @asis
-## @item "query"
-## With an output argument, return the current state of the integer
-## conversion and math warnings.  With no output arguments, print the
-## current state.
-## @c Set example in small font to prevent overfull line
-##
-## @smallexample
-## @group
-## intwarning ("query")
-## The state of warning "Octave:int-convert-nan" is "off"
-## The state of warning "Octave:int-convert-non-int-val" is "off"
-## The state of warning "Octave:int-convert-overflow" is "off"
-## The state of warning "Octave:int-math-overflow" is "off"
-## @end group
-## @end smallexample
-##
-## @item "on"
-## @itemx "off"
-## Turn integer conversion and math warnings on (or off).  If there is
-## no output argument, then nothing is printed.  Otherwise the original
-## state of the state of the integer conversion and math warnings is
-## returned in a structure array.
-## @end table
-##
-## The original state of the integer warnings can be restored by passing
-## the structure array returned by @code{intwarning} to a later call to
-## @code{intwarning}.  For example:
-##
-## @example
-## @group
-## s = intwarning ("off");
-## @dots{}
-## intwarning (s);
-## @end group
-## @end example
-## @seealso{warning}
-## @end deftypefn
-
-## Deprecated in v. 3.4
-
-function y = intwarning (x)
-
-  persistent warned = false;
-  if (! warned)
-    warned = true;
-    warning ("Octave:deprecated-function",
-             "intwarning is obsolete and will be removed from a future version of Octave; integer math no longer produces warnings -- supply your own checks if you need those");
-  endif
-
-  return;
-
-  if (nargin != 1)
-    print_usage ();
-  else
-    if (nargout > 0)
-      y = warning("query", "Octave:int-convert-nan");
-      y = [y; warning("query", "Octave:int-convert-non-int-val")];
-      y = [y; warning("query", "Octave:int-convert-overflow")];
-      y = [y; warning("query", "Octave:int-math-overflow")];
-    endif
-    if (ischar (x))
-      if (strcmpi (x, "query"))
-        if (nargout == 0)
-          __print_int_warn_state__ ("Octave:int-convert-nan");
-          __print_int_warn_state__ ("Octave:int-convert-non-int-val");
-          __print_int_warn_state__ ("Octave:int-convert-overflow");
-          __print_int_warn_state__ ("Octave:int-math-overflow");
-          printf("\n");
-        endif
-      elseif (strcmpi (x, "on"))
-        warning ("on", "Octave:int-convert-nan");
-        warning ("on", "Octave:int-convert-non-int-val");
-        warning ("on", "Octave:int-convert-overflow");
-        warning ("on", "Octave:int-math-overflow");
-      elseif (strcmpi (x, "off"))
-        warning ("off", "Octave:int-convert-nan");
-        warning ("off", "Octave:int-convert-non-int-val");
-        warning ("off", "Octave:int-convert-overflow");
-        warning ("off", "Octave:int-math-overflow");
-      else
-        error ("intwarning: unrecognized argument");
-      endif
-    elseif (isstruct(x))
-      for fld = fieldnames (x)
-        if (strcmp ("Octave:int-convert-nan")
-            || strcmp ("Octave:int-convert-non-int-val")
-            || strcmp ("Octave:int-convert-overflow")
-            || strcmp ("Octave:int-cmath-overflow"))
-          s = getfield (x, fld);
-          if (! ischar (s) || !(strcmpi("s","on") || strcmpi("s","off")))
-            error ("intwarning: unexpected warning state");
-          endif
-          warning (s, fld);
-        else
-          error ("intwarning: unrecognized integer warning %s", fld);
-        endif
-      endfor
-    else
-      error ("intwarning: unexpected input");
-    endif
-  endif
-endfunction
-
-function __print_int_warn_state__ (s)
-  fprintf ("The state of warning \"%s\" is \"%s\"\n",
-           s, warning ("query", s).state);
-endfunction
diff --git a/scripts/deprecated/is_duplicate_entry.m b/scripts/deprecated/is_duplicate_entry.m
deleted file mode 100644
--- a/scripts/deprecated/is_duplicate_entry.m
+++ /dev/null
@@ -1,53 +0,0 @@
-## Copyright (C) 1996-2012 A. S. Hodel
-##
-## This file is part of Octave.
-##
-## Octave is free software; you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation; either version 3 of the License, or (at
-## your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <http://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn {Function File} {} is_duplicate_entry (@var{x})
-## Return non-zero if any entries in @var{x} are duplicates of one
-## another.
-## @seealso{unique}
-## @end deftypefn
-
-## Author: A. S. Hodel <scotte@eng.auburn.edu>
-
-function retval = is_duplicate_entry (x)
-
-  persistent warned = false;
-  if (! warned)
-    warned = true;
-    warning ("Octave:deprecated-function",
-             "is_duplicate_entry is obsolete and will be removed from a future version of Octave; see the function unique for equivalent functionality");
-  endif
-
-
-  if (nargin == 1)
-    if (ismatrix (x))
-      lx = numel (x);
-      lx1 = lx-1;
-      x = sort (reshape (x, 1, lx));
-      dx = x(1:lx1) - x(2:lx);
-      retval = sum (dx == 0);
-    else
-      error ("is_duplicate_entry: expecting matrix argument");
-    endif
-  else
-    print_usage ();
-  endif
-
-endfunction
-
diff --git a/scripts/deprecated/is_global.m b/scripts/deprecated/is_global.m
deleted file mode 100644
--- a/scripts/deprecated/is_global.m
+++ /dev/null
@@ -1,37 +0,0 @@
-## Copyright (C) 1994-2012 John W. Eaton
-##
-## This file is part of Octave.
-##
-## Octave is free software; you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation; either version 3 of the License, or (at
-## your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <http://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn {Function File} {} is_global (@var{name})
-## This function is provided for compatibility with older versions of
-## Octave.  New programs should use isglobal instead.
-## @end deftypefn
-
-## Deprecated in version 3.4
-
-function retval = is_global (name)
-  persistent warned = false;
-  if (! warned)
-    warned = true;
-    warning ("Octave:deprecated-function",
-             "is_global is obsolete and will be removed from a future version of Octave; please use isglobal instead");
-  endif
-
-  retval = isglobal(name);
-
-endfunction
diff --git a/scripts/deprecated/krylovb.m b/scripts/deprecated/krylovb.m
deleted file mode 100644
--- a/scripts/deprecated/krylovb.m
+++ /dev/null
@@ -1,46 +0,0 @@
-## Copyright (C) 1993-2012 A. Scottedward Hodel
-##
-## This file is part of Octave.
-##
-## Octave is free software; you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation; either version 3 of the License, or (at
-## your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <http://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn {Function File} {[@var{u}, @var{ucols}] =} krylovb (@var{A}, @var{V}, @var{k}, @var{eps1}, @var{pflg})
-## See @code{krylov}.
-## @end deftypefn
-
-## Deprecated in version 3.4
-
-function [Uret, Ucols] = krylovb (A, V, k, eps1, pflg)
-
-  persistent warned = false;
-  if (! warned)
-    warned = true;
-    warning ("Octave:deprecated-function",
-             "krylovb is obsolete and will be removed from a future version of Octave; please use [Uret, ~, Ucols] = krylov (...) instead");
-  endif
-
-  switch (nargin)
-    case (3)
-      [Uret, H, Ucols] = krylov (A, V, k);
-    case (4)
-      [Uret, H, Ucols] = krylov (A, V, k, eps1);
-    case (5)
-      [Uret, H, Ucols] = krylov (A, V, k, eps1, pflg);
-    otherwise
-      print_usage ();
-  endswitch
-
-endfunction
diff --git a/scripts/deprecated/module.mk b/scripts/deprecated/module.mk
--- a/scripts/deprecated/module.mk
+++ b/scripts/deprecated/module.mk
@@ -1,43 +1,20 @@
 FCN_FILE_DIRS += deprecated
 
 deprecated_FCN_FILES = \
   deprecated/__error_text__.m \
-  deprecated/autocor.m \
-  deprecated/autocov.m \
-  deprecated/betai.m \
-  deprecated/cellidx.m \
-  deprecated/clg.m \
   deprecated/cor.m \
   deprecated/corrcoef.m \
-  deprecated/cquad.m \
   deprecated/cut.m \
-  deprecated/dispatch.m \
   deprecated/error_text.m \
-  deprecated/fstat.m \
-  deprecated/gammai.m \
-  deprecated/glpkmex.m \
-  deprecated/intwarning.m \
-  deprecated/is_duplicate_entry.m \
-  deprecated/is_global.m \
   deprecated/isstr.m \
-  deprecated/krylovb.m \
-  deprecated/perror.m \
   deprecated/polyderiv.m \
-  deprecated/replot.m \
-  deprecated/saveimage.m \
   deprecated/setstr.m \
   deprecated/shell_cmd.m \
-  deprecated/strerror.m \
   deprecated/studentize.m \
-  deprecated/sylvester_matrix.m \
-  deprecated/values.m \
-  deprecated/weibcdf.m \
-  deprecated/weibinv.m \
-  deprecated/weibpdf.m \
-  deprecated/weibrnd.m
+  deprecated/sylvester_matrix.m
 
 FCN_FILES += $(deprecated_FCN_FILES)
 
 PKG_ADD_FILES += deprecated/PKG_ADD
 
 DIRSTAMP_FILES += deprecated/$(octave_dirstamp)
diff --git a/scripts/deprecated/perror.m b/scripts/deprecated/perror.m
deleted file mode 100644
--- a/scripts/deprecated/perror.m
+++ /dev/null
@@ -1,45 +0,0 @@
-## Copyright (C) 1993-2012 John W. Eaton
-##
-## This file is part of Octave.
-##
-## Octave is free software; you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation; either version 3 of the License, or (at
-## your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <http://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn {Function File} {} perror (@var{funcname}, @var{num})
-## Print the error message for function @var{funcname} corresponding to the
-## error number @var{num}.  This function is intended to be used to print
-## useful error messages for those functions that return numeric error
-## codes.
-## @seealso{strerror}
-## @end deftypefn
-
-## Author: jwe
-
-function perror (funcname, num)
-
-  persistent warned = false;
-  if (! warned)
-    warned = true;
-    warning ("Octave:deprecated-function",
-             "perror is obsolete and will be removed from a future version of Octave.");
-  endif
-
-  if (nargin != 2)
-    print_usage ();
-  else
-    printf (strerror (funcname, num));
-  endif
-
-endfunction
diff --git a/scripts/deprecated/replot.m b/scripts/deprecated/replot.m
deleted file mode 100644
--- a/scripts/deprecated/replot.m
+++ /dev/null
@@ -1,43 +0,0 @@
-## Copyright (C) 2005-2012 John W. Eaton
-##
-## This file is part of Octave.
-##
-## Octave is free software; you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation; either version 3 of the License, or (at
-## your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <http://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn {Function File} {} replot ()
-## Refresh the plot window.
-## @end deftypefn
-
-## Author: jwe
-
-## Deprecated in version 3.4
-
-function replot ()
-
-  persistent warned = false;
-  if (! warned)
-    warned = true;
-    warning ("Octave:deprecated-function",
-             "replot is obsolete and will be removed from a future version of Octave; please use refresh instead");
-  endif
-
-  if (nargin == 0)
-    drawnow ();
-  else
-    print_usage ();
-  endif
-
-endfunction
diff --git a/scripts/deprecated/saveimage.m b/scripts/deprecated/saveimage.m
deleted file mode 100644
--- a/scripts/deprecated/saveimage.m
+++ /dev/null
@@ -1,314 +0,0 @@
-## Copyright (C) 1994-2012 John W. Eaton
-##
-## This file is part of Octave.
-##
-## Octave is free software; you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation; either version 3 of the License, or (at
-## your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <http://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn  {Function File} {} saveimage (@var{fname}, @var{img}, @var{fmt})
-## @deftypefnx {Function File} {} saveimage (@var{fname}, @var{img}, @var{fmt}, @var{map})
-## Save the matrix @var{img} to file @var{fname} in image format @var{fmt}.
-## Valid values for @var{fmt} are
-##
-## @table @asis
-## @item "img"
-## Octave's image format.  The current colormap is also saved in the file.
-##
-## @item "ppm"
-## Portable pixmap format.
-##
-## @item "ps"
-## PostScript format.
-## @end table
-##
-## If the fourth argument is supplied, the specified colormap will also be
-## saved along with the image.
-##
-## Note: if the colormap contains only two entries and these entries are
-## black and white, the bitmap ppm and PostScript formats are used.  If the
-## image is a gray scale image (the entries within each row of the colormap
-## are equal) the gray scale ppm and PostScript image formats are used,
-## otherwise the full color formats are used.
-## @seealso{imread, save, load, colormap}
-## @end deftypefn
-
-## The conversion to PostScript is based on pbmtolps.c, which was
-## written by
-##
-##   George Phillips <phillips@cs.ubc.ca>
-##   Department of Computer Science
-##   University of British Columbia
-##
-## and is part of the portable bitmap utilities,
-
-## Author: Tony Richardson <arichard@stark.cc.oh.us>
-## Created: July 1994
-## Adapted-By: jwe
-
-## Rewritten by jwe to avoid using octoppm and pbm routines so that
-## people who don't have the pbm stuff installed can still use this
-## function.
-##
-## The conversion to PostScript is based on pnmtops.c, which is part of
-## the portable bitmap utilties and bears this copyright notice:
-##
-## Copyright (C) 1989 by Jef Poskanzer.
-##
-## Permission to use, copy, modify, and distribute this software and its
-## documentation for any purpose and without fee is hereby granted, provided
-## that the above copyright notice appear in all copies and that both that
-## copyright notice and this permission notice appear in supporting
-## documentation.  This software is provided "as is" without express or
-## implied warranty.
-
-function saveimage (fname, img, fmt, map)
-
-  persistent warned = false;
-  if (! warned)
-    warned = true;
-    warning ("Octave:deprecated-function",
-             "saveimage is obsolete and will be removed from a future version of Octave; please use imwrite instead");
-  endif
-
-  if (nargin < 2 || nargin > 4)
-    print_usage ();
-  endif
-
-  if (nargin < 4)
-    if (size(img, 3) == 3)
-      [img, map] = rgb2ind(img);
-    else
-      map = colormap ();
-    endif
-  endif
-
-  [map_nr, map_nc] = size (map);
-
-  if (map_nc != 3)
-    error ("saveimage: MAP must be an N x 3 matrix");
-  endif
-
-  if (nargin < 3)
-    fmt = "img";
-  elseif (! ischar (fmt))
-    error ("saveimage: FMT specification must be a string");
-  elseif (! (strcmp (fmt, "img")
-             || strcmp (fmt, "ppm")
-             || strcmp (fmt, "ps")))
-    error ("saveimage: unsupported image format specification");
-  endif
-
-  if (! ismatrix (img))
-    warning ("IMG variable is not a matrix");
-  endif
-
-  if (! ischar (fname))
-    error ("saveimage: FNAME must be a string");
-  endif
-
-  ## If we just want Octave image format, save and return.
-
-  if (strcmp (fmt, "img"))
-    save ("-text", fname, "map", "img");
-    return;
-  endif
-
-  ## Convert to another format if requested.
-
-  grey = all (map(:,1) == map(:,2) && map(:,1) == map (:,3));
-
-  pbm = pgm = ppm = 0;
-
-  map_sz = map_nr * map_nc;
-
-  map = reshape (map, map_sz, 1);
-
-  map (map > 1) = 1;
-  map (map < 0) = 0;
-
-  map = round (255 * map);
-
-  bw = (map_nr == 2
-        && ((map(1,1) == 0 && map(2,1) == 255)
-            || (map(1,1) == 255 && map(2,1) == 0)));
-
-  img = round (img');
-  [img_nr, img_nc] = size (img);
-
-  img_sz = img_nr * img_nc;
-  img = reshape (img, img_sz, 1);
-
-  img (img > map_nr) = map_nr;
-  img (img <= 0) = 1;
-
-  if (strcmp (fmt, "ppm"))
-
-    ## Would be nice to make this consistent with the line used by the
-    ## load/save functions, but we need a good way to get username and
-    ## hostname information.
-
-    time_string = ctime (time ());
-    time_string = time_string (1:length (time_string)-1);
-    tagline = sprintf ("# Created by Octave %s, %s",
-                       OCTAVE_VERSION, time_string);
-
-    if (grey && bw)
-
-      if (map(1) != 0)
-        map = [0; 1];
-      else
-        map = [1; 0];
-      endif
-
-      n_long = rem (img_nc, 8);
-      tmp = zeros (ceil (img_nc/8), img_nr);
-
-      k = ceil (img_nr/8);
-      tmp = zeros (k, img_nc);
-
-      ## Append columns with zeros to original image so that
-      ## mod (cols, 8) = 0.
-
-      bwimg = postpad (reshape (map(img), img_nr, img_nc), k * 8, 0);
-
-      b = kron (pow2 (7:-1:0)', ones (1, img_nc));
-
-      for i = 1:k
-        tmp(i,:) = sum (bwimg(8*(i-1)+1:8*i,:) .* b);
-      endfor
-
-      fid = fopen (fname, "wb");
-      fprintf (fid, "P4\n%s\n%d %d\n", tagline, img_nr, img_nc);
-      fwrite (fid, tmp, "uchar");
-      fprintf (fid, "\n");
-      fclose (fid);
-
-    elseif (grey)
-
-      fid = fopen (fname, "wb");
-      fprintf (fid, "P5\n%s\n%d %d\n255\n", tagline, img_nr, img_nc);
-      fwrite (fid, map(img), "uchar");
-      fprintf (fid, "\n");
-      fclose (fid);
-
-    else
-
-      img_idx = ((1:3:3*img_sz)+2)';
-      map_idx = ((2*map_nr+1):map_sz)';
-
-      tmap = map(map_idx);
-      tmp(img_idx--) = tmap(img);
-
-      map_idx = map_idx - map_nr;
-      tmap = map(map_idx);
-      tmp(img_idx--) = tmap(img);
-
-      map_idx = map_idx - map_nr;
-      tmap = map(map_idx);
-      tmp(img_idx--) = tmap(img);
-
-      fid = fopen (fname, "wb");
-      fprintf (fid, "P6\n%s\n%d %d\n255\n", tagline, img_nr, img_nc);
-      fwrite (fid, tmp, "uchar");
-      fprintf (fid, "\n");
-      fclose (fid);
-
-    endif
-
-  elseif (strcmp (fmt, "ps") == 1)
-
-    if (! grey)
-      error ("saveimage: must have a greyscale colormap for conversion to PostScript");
-    endif
-
-    bps = 8;
-    dpi = 300;
-    pagewid = 612;
-    pagehgt = 762;
-    MARGIN = 0.95;
-    devpix = dpi / 72.0 + 0.5;
-    pixfac = 72.0 / dpi * devpix;
-
-    ## Compute padding to round cols * bps up to the nearest multiple of 8
-    ## (nr and nc are switched because we transposed the image above).
-
-    padright = (((img_nr * bps + 7) / 8) * 8 - img_nr * bps) / bps;
-
-    scols = img_nr * pixfac;
-    srows = img_nc * pixfac;
-    scale = 1;
-
-    if (scols > pagewid * MARGIN || srows > pagehgt * MARGIN)
-      if (scols > pagewid * MARGIN)
-        scale = scale * (pagewid / scols * MARGIN);
-        scols = scale * img_nr * pixfac;
-        srows = scale * img_nc * pixfac;
-      endif
-      if (srows > pagehgt * MARGIN)
-        scale = scale * (pagehgt / srows * MARGIN);
-        scols = scale * img_nr * pixfac;
-        srows = scale * img_nc * pixfac;
-      endif
-      warning ("image too large for page, rescaling to %g", scale);
-    endif
-
-    llx = (pagewid - scols) / 2;
-    lly = (pagehgt - srows) / 2;
-    urx = llx + fix (scols + 0.5);
-    ury = lly + fix (srows + 0.5);
-
-    fid = fopen (fname, "wb");
-
-    fprintf (fid, "%%!PS-Adobe-2.0 EPSF-2.0\n");
-    fprintf (fid, "%%%%Creator: Octave %s (saveimage.m)\n", OCTAVE_VERSION);
-    fprintf (fid, "%%%%Title: %s\n", fname);
-    fprintf (fid, "%%%%Pages: 1\n");
-    fprintf (fid, "%%%%BoundingBox: %d %d %d %d\n",
-             fix (llx), fix (lly), fix (urx), fix (ury));
-    fprintf (fid, "%%%%EndComments\n");
-    fprintf (fid, "/readstring {\n");
-    fprintf (fid, "  currentfile exch readhexstring pop\n");
-    fprintf (fid, "} bind def\n");
-    fprintf (fid, "/picstr %d string def\n",
-             fix ((img_nr + padright) * bps / 8));
-    fprintf (fid, "%%%%EndProlog\n");
-    fprintf (fid, "%%%%Page: 1 1\n");
-    fprintf (fid, "gsave\n");
-    fprintf (fid, "%g %g translate\n", llx, lly);
-    fprintf (fid, "%g %g scale\n", scols, srows);
-    fprintf (fid, "%d %d %d\n", img_nr, img_nc, bps);
-    fprintf (fid, "[ %d 0 0 -%d 0 %d ]\n", img_nr, img_nc, img_nc);
-    fprintf (fid, "{ picstr readstring }\n");
-    fprintf (fid, "image\n");
-
-    img = map(img);
-
-    fmt = "%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x\n";
-    fprintf (fid, fmt, img);
-
-    if (rem (img_sz, 30) != 0)
-      fprintf (fid, "\n");
-    endif
-
-    fprintf (fid, "grestore\n");
-    fprintf (fid, "showpage\n");
-    fprintf (fid, "%%%%Trailer\n");
-    fclose (fid);
-
-  else
-    error ("saveimage: what happened to the image type?");
-  endif
-
-endfunction
diff --git a/scripts/deprecated/strerror.m b/scripts/deprecated/strerror.m
deleted file mode 100644
--- a/scripts/deprecated/strerror.m
+++ /dev/null
@@ -1,72 +0,0 @@
-## Copyright (C) 1995-2012 John W. Eaton
-##
-## This file is part of Octave.
-##
-## Octave is free software; you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation; either version 3 of the License, or (at
-## your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <http://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn {Function File} {} strerror (@var{name}, @var{num})
-## Return the text of an error message for function @var{name}
-## corresponding to the error number @var{num}.  This function is intended
-## to be used to print useful error messages for those functions that
-## return numeric error codes.
-## @end deftypefn
-
-## Author: jwe
-
-function msg = strerror (name, num)
-
-  persistent warned = false;
-  if (! warned)
-    warned = true;
-    warning ("Octave:deprecated-function",
-             "strerror is obsolete and will be removed from a future version of Octave.");
-  endif
-
-  if (nargin != 2)
-    print_usage ();
-  endif
-
-  if (! ischar (name))
-    error ("strerror: first argument must be a string");
-  endif
-
-  if (! isscalar (num))
-    error ("strerror: second argument must be a scalar");
-  endif
-
-  if (strcmp (name, "fsolve"))
-
-    if (num == -2)
-      msg = "input error\n";
-    elseif (num == -1)
-      msg = "error encountered in user-supplied function\n";
-    elseif (num == 1)
-      msg = "solution converged to requested tolerance\n";
-    elseif (num == 3)
-      msg = "iteration is not making good progress\n";
-    elseif (num == 4)
-      msg = "iteration limit exceeded\n";
-    else
-      error ("strerror: unrecognized error code for fsolve");
-    endif
-
-  else
-
-    error ("strerror: unrecognized function NAME");
-
-  endif
-
-endfunction
diff --git a/scripts/deprecated/values.m b/scripts/deprecated/values.m
deleted file mode 100644
--- a/scripts/deprecated/values.m
+++ /dev/null
@@ -1,61 +0,0 @@
-## Copyright (C) 1995-2012 Kurt Hornik
-##
-## This file is part of Octave.
-##
-## Octave is free software; you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation; either version 3 of the License, or (at
-## your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <http://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn {Function File} {} values (@var{x})
-## Return the different values in a column vector, arranged in ascending
-## order.
-##
-## As an example, @code{values([1, 2, 3, 1])} returns the vector
-## @code{[1, 2, 3]}.
-## @end deftypefn
-
-## Author: KH <Kurt.Hornik@wu-wien.ac.at>
-## Description: Extract unique elements
-
-## Deprecated in version 3.4
-
-function v = values (x)
-
-  persistent warned = false;
-  if (! warned)
-    warned = true;
-    warning ("Octave:deprecated-function",
-             "values is obsolete and will be removed from a future version of Octave; please use unique instead");
-  endif
-
-  if (nargin != 1)
-    print_usage ();
-  endif
-
-  if (! (isvector (x)))
-    error ("values: X must be a vector");
-  endif
-
-  i = any (isnan (x));
-  ## HACK!
-  x = x(find(!isnan (x)));
-  n = length (x);
-  x = reshape (x, n, 1);
-  s = sort (x);
-  v = s([1; (find (s(2:n) > s(1:n-1)) + 1)]);
-  if (i)
-    v = [v; NaN];
-  endif
-
-endfunction
diff --git a/scripts/deprecated/weibcdf.m b/scripts/deprecated/weibcdf.m
deleted file mode 100644
--- a/scripts/deprecated/weibcdf.m
+++ /dev/null
@@ -1,47 +0,0 @@
-## Copyright (C) 2006-2012 John W. Eaton
-##
-## This file is part of Octave.
-##
-## Octave is free software; you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation; either version 3 of the License, or (at
-## your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <http://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn {Function File} {} weibcdf (@var{x}, @var{scale}, @var{shape})
-## Compute the cumulative distribution function (CDF) at @var{x} of the
-## Weibull distribution with shape parameter @var{scale} and scale
-## parameter @var{shape}, which is
-##
-## @example
-## 1 - exp(-(x/shape)^scale)
-## @end example
-##
-## @noindent
-## for @var{x} @geq{} 0.
-## @end deftypefn
-
-## Deprecated in version 3.0
-## Matlab still has this function, so don't remove just yet.
-
-function cdf = weibcdf (varargin)
-
-  persistent warned = false;
-  if (! warned)
-    warned = true;
-    warning ("Octave:deprecated-function",
-             "weibcdf is obsolete and will be removed from a future version of Octave; please use wblcdf instead");
-  endif
-
-  cdf = wblcdf (varargin{:});
-
-endfunction
diff --git a/scripts/deprecated/weibinv.m b/scripts/deprecated/weibinv.m
deleted file mode 100644
--- a/scripts/deprecated/weibinv.m
+++ /dev/null
@@ -1,40 +0,0 @@
-## Copyright (C) 2006-2012 John W. Eaton
-##
-## This file is part of Octave.
-##
-## Octave is free software; you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation; either version 3 of the License, or (at
-## your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <http://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn {Function File} {} weibinv (@var{x}, @var{scale}, @var{shape})
-## Compute the quantile (the inverse of the CDF) at @var{x} of the
-## Weibull distribution with shape parameter @var{scale} and scale
-## parameter @var{shape}.
-## @end deftypefn
-
-## Deprecated in version 3.0
-## Matlab still has this function, so don't remove just yet.
-
-function inv = weibinv (varargin)
-
-  persistent warned = false;
-  if (! warned)
-    warned = true;
-    warning ("Octave:deprecated-function",
-             "weibinv is obsolete and will be removed from a future version of Octave; please use wblinv instead");
-  endif
-
-  inv = wblinv (varargin{:});
-
-endfunction
diff --git a/scripts/deprecated/weibpdf.m b/scripts/deprecated/weibpdf.m
deleted file mode 100644
--- a/scripts/deprecated/weibpdf.m
+++ /dev/null
@@ -1,47 +0,0 @@
-## Copyright (C) 2006-2012 John W. Eaton
-##
-## This file is part of Octave.
-##
-## Octave is free software; you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation; either version 3 of the License, or (at
-## your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <http://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn {Function File} {} weibpdf (@var{x}, @var{scale}, @var{shape})
-## Compute the probability density function (PDF) at @var{x} of the
-## Weibull distribution with shape parameter @var{scale} and scale
-## parameter @var{shape} which is given by
-##
-## @example
-##    scale * shape^(-scale) * x^(scale-1) * exp(-(x/shape)^scale)
-## @end example
-##
-## @noindent
-## for @var{x} > 0.
-## @end deftypefn
-
-## Deprecated in version 3.0
-## Matlab still has this function, so don't remove just yet.
-
-function pdf = weibpdf (varargin)
-
-  persistent warned = false;
-  if (! warned)
-    warned = true;
-    warning ("Octave:deprecated-function",
-             "weibpdf is obsolete and will be removed from a future version of Octave; please use wblpdf instead");
-  endif
-
-  pdf = wblpdf (varargin{:});
-
-endfunction
diff --git a/scripts/deprecated/weibrnd.m b/scripts/deprecated/weibrnd.m
deleted file mode 100644
--- a/scripts/deprecated/weibrnd.m
+++ /dev/null
@@ -1,46 +0,0 @@
-## Copyright (C) 2006-2012 John W. Eaton
-##
-## This file is part of Octave.
-##
-## Octave is free software; you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation; either version 3 of the License, or (at
-## your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <http://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn  {Function File} {} weibrnd (@var{scale}, @var{shape}, @var{r}, @var{c})
-## @deftypefnx {Function File} {} weibrnd (@var{scale}, @var{shape}, @var{sz})
-## Return an @var{r} by @var{c} matrix of random samples from the
-## Weibull distribution with parameters @var{scale} and @var{shape}
-## which must be scalar or of size @var{r} by @var{c}.  Or if @var{sz}
-## is a vector return a matrix of size @var{sz}.
-##
-## If @var{r} and @var{c} are omitted, the size of the result matrix is
-## the common size of @var{alpha} and @var{sigma}.
-## @end deftypefn
-
-## Deprecated in version 3.0
-## Matlab still has this function, so don't remove just yet.
-
-function rnd = weibrnd (varargin)
-
-  persistent warned = false;
-  if (! warned)
-    warned = true;
-    warning ("Octave:deprecated-function",
-             "weibrnd is obsolete and will be removed from a future version of Octave; please use wblrnd instead");
-  endif
-
-  rnd = wblrnd (varargin{:});
-
-endfunction
-
diff --git a/scripts/elfun/acosd.m b/scripts/elfun/acosd.m
--- a/scripts/elfun/acosd.m
+++ b/scripts/elfun/acosd.m
@@ -30,12 +30,13 @@ function y = acosd (x)
     print_usage ();
   endif
 
   y = acos (x) .* 180 ./ pi;
 
 endfunction
 
 
-%!assert (acosd (0:0.1:1), 180/pi*acos (0:0.1:1), -10*eps)
+%!assert (acosd (0:0.1:1), 180/pi * acos (0:0.1:1), -10*eps)
 
 %!error acosd ()
 %!error acosd (1, 2)
+
diff --git a/scripts/elfun/acot.m b/scripts/elfun/acot.m
--- a/scripts/elfun/acot.m
+++ b/scripts/elfun/acot.m
@@ -35,13 +35,13 @@ function y = acot (x)
 endfunction
 
 
 %!test
 %! rt2 = sqrt (2);
 %! rt3 = sqrt (3);
 %! x = [rt3, 1, rt3/3, 0, -rt3/3, -1, -rt3];
 %! v = [pi/6, pi/4, pi/3, pi/2, -pi/3, -pi/4, -pi/6];
-%! assert (all (abs (acot (x) - v) < sqrt (eps)));
+%! assert (acot (x), v, sqrt (eps));
 
 %!error acot ()
 %!error acot (1, 2)
 
diff --git a/scripts/elfun/acotd.m b/scripts/elfun/acotd.m
--- a/scripts/elfun/acotd.m
+++ b/scripts/elfun/acotd.m
@@ -30,12 +30,13 @@ function y = acotd (x)
     print_usage ();
   endif
 
   y = atand (1 ./ x);
 
 endfunction
 
 
-%!assert (acotd (0:10:90), 180./pi.*acot (0:10:90), -10*eps)
+%!assert (acotd (0:10:90), 180/pi * acot (0:10:90), -10*eps)
 
 %!error acotd ()
 %!error acotd (1, 2)
+
diff --git a/scripts/elfun/acoth.m b/scripts/elfun/acoth.m
--- a/scripts/elfun/acoth.m
+++ b/scripts/elfun/acoth.m
@@ -35,13 +35,13 @@ function y = acoth (x)
 endfunction
 
 
 %!test
 %! rt2 = sqrt (2);
 %! rt3 = sqrt (3);
 %! v = -i*[pi/6, pi/4, pi/3, -pi/3, -pi/4, -pi/6];
 %! x = i*[rt3, 1, rt3/3, -rt3/3, -1, -rt3];
-%! assert (all (abs (acoth (x) - v) < sqrt (eps)));
+%! assert (acoth (x), v, sqrt (eps));
 
 %!error acoth ()
 %!error acoth (1, 2)
 
diff --git a/scripts/elfun/acsc.m b/scripts/elfun/acsc.m
--- a/scripts/elfun/acsc.m
+++ b/scripts/elfun/acsc.m
@@ -35,13 +35,13 @@ function y = acsc (x)
 endfunction
 
 
 %!test
 %! rt2 = sqrt (2);
 %! rt3 = sqrt (3);
 %! v = [pi/6, pi/4, pi/3, pi/2, pi/3, pi/4, pi/6];
 %! x = [2, rt2, 2*rt3/3, 1, 2*rt3/3, rt2, 2];
-%! assert (all (abs (acsc (x) - v) < sqrt (eps)));
+%! assert (acsc (x), v, sqrt (eps));
 
 %!error acsc ()
 %!error acsc (1, 2)
 
diff --git a/scripts/elfun/acscd.m b/scripts/elfun/acscd.m
--- a/scripts/elfun/acscd.m
+++ b/scripts/elfun/acscd.m
@@ -30,12 +30,13 @@ function y = acscd (x)
     print_usage ();
   endif
 
   y = acsc (x) .* 180 ./ pi;
 
 endfunction
 
 
-%!assert (acscd (0:10:90), 180/pi*acsc (0:10:90), -10*eps)
+%!assert (acscd (0:10:90), 180/pi * acsc (0:10:90), -10*eps)
 
 %!error acscd ()
 %!error acscd (1, 2)
+
diff --git a/scripts/elfun/acsch.m b/scripts/elfun/acsch.m
--- a/scripts/elfun/acsch.m
+++ b/scripts/elfun/acsch.m
@@ -33,13 +33,13 @@ function y = acsch (x)
   y = asinh (1 ./ x);
 
 endfunction
 
 
 %!test
 %! v = [pi/2*i, -pi/2*i];
 %! x = [-i, i];
-%! assert (all (abs (acsch (x) - v) < sqrt (eps)));
+%! assert (acsch (x), v, sqrt (eps));
 
 %!error acsch ()
 %!error acsch (1, 2)
 
diff --git a/scripts/elfun/asec.m b/scripts/elfun/asec.m
--- a/scripts/elfun/asec.m
+++ b/scripts/elfun/asec.m
@@ -35,12 +35,13 @@ function y = asec (x)
 endfunction
 
 
 %!test
 %! rt2 = sqrt (2);
 %! rt3 = sqrt (3);
 %! v = [0, pi/6, pi/4, pi/3, 2*pi/3, 3*pi/4, 5*pi/6, pi];
 %! x = [1, 2*rt3/3, rt2, 2, -2, -rt2, -2*rt3/3, -1];
-%! assert (all (abs (asec (x) - v) < sqrt (eps)));
+%! assert (asec (x), v, sqrt (eps));
 
 %!error asec ()
 %!error asec (1, 2)
+
diff --git a/scripts/elfun/asecd.m b/scripts/elfun/asecd.m
--- a/scripts/elfun/asecd.m
+++ b/scripts/elfun/asecd.m
@@ -30,12 +30,13 @@ function y = asecd (x)
     print_usage ();
   endif
 
   y = asec (x) .* 180 ./ pi;
 
 endfunction
 
 
-%!assert (asecd (0:10:90), 180./pi.*asec (0:10:90), -10*eps)
+%!assert (asecd (0:10:90), 180/pi * asec (0:10:90), -10*eps)
 
 %!error asecd ()
 %!error asecd (1, 2)
+
diff --git a/scripts/elfun/asech.m b/scripts/elfun/asech.m
--- a/scripts/elfun/asech.m
+++ b/scripts/elfun/asech.m
@@ -33,13 +33,13 @@ function y = asech (x)
   y = acosh (1 ./ x);
 
 endfunction
 
 
 %!test
 %! v = [0, pi*i];
 %! x = [1, -1];
-%! assert (all (abs (asech (x) - v) < sqrt (eps)));
+%! assert (asech (x), v, sqrt (eps));
 
 %!error asech ()
 %!error asech (1, 2)
 
diff --git a/scripts/elfun/asind.m b/scripts/elfun/asind.m
--- a/scripts/elfun/asind.m
+++ b/scripts/elfun/asind.m
@@ -30,12 +30,13 @@ function y = asind (x)
     print_usage ();
   endif
 
   y = asin (x) .* 180 ./ pi;
 
 endfunction
 
 
-%!assert (asind (0:0.1:1), 180/pi*asin (0:0.1:1), -10*eps)
+%!assert (asind (0:0.1:1), 180/pi * asin (0:0.1:1), -10*eps)
 
 %!error asind ()
 %!error asind (1, 2)
+
diff --git a/scripts/elfun/atand.m b/scripts/elfun/atand.m
--- a/scripts/elfun/atand.m
+++ b/scripts/elfun/atand.m
@@ -30,12 +30,13 @@ function y = atand (x)
     print_usage ();
   endif
 
   y = 180 ./ pi .* atan (x);
 
 endfunction
 
 
-%!assert (atand (0:10:90), 180./pi.*atan (0:10:90), -10*eps)
+%!assert (atand (0:10:90), 180/pi * atan (0:10:90), -10*eps)
 
 %!error atand ()
 %!error atand (1, 2)
+
diff --git a/scripts/elfun/cosd.m b/scripts/elfun/cosd.m
--- a/scripts/elfun/cosd.m
+++ b/scripts/elfun/cosd.m
@@ -40,8 +40,9 @@ endfunction
 
 
 %!assert (cosd (0:10:80), cos (pi*[0:10:80]/180), -10*eps)
 %!assert (cosd ([0, 180, 360]) != 0)
 %!assert (cosd ([90, 270]) == 0)
 
 %!error cosd ()
 %!error cosd (1, 2)
+
diff --git a/scripts/elfun/cot.m b/scripts/elfun/cot.m
--- a/scripts/elfun/cot.m
+++ b/scripts/elfun/cot.m
@@ -35,13 +35,13 @@ function y = cot (x)
 endfunction
 
 
 %!test
 %! rt2 = sqrt (2);
 %! rt3 = sqrt (3);
 %! x = [pi/6, pi/4, pi/3, pi/2, 2*pi/3, 3*pi/4, 5*pi/6];
 %! v = [rt3, 1, rt3/3, 0, -rt3/3, -1, -rt3];
-%! assert (all (abs (cot (x) - v) < sqrt (eps)));
+%! assert (cot (x), v, sqrt (eps));
 
 %!error cot ()
 %!error cot (1, 2)
 
diff --git a/scripts/elfun/cotd.m b/scripts/elfun/cotd.m
--- a/scripts/elfun/cotd.m
+++ b/scripts/elfun/cotd.m
@@ -36,8 +36,9 @@ endfunction
 
 
 %!assert (cotd (10:10:80), cot (pi*[10:10:80]/180), -10*eps)
 %!assert (cotd ([0, 180, 360]) == Inf)
 %!assert (cotd ([90, 270]) == 0)
 
 %!error cotd ()
 %!error cotd (1, 2)
+
diff --git a/scripts/elfun/coth.m b/scripts/elfun/coth.m
--- a/scripts/elfun/coth.m
+++ b/scripts/elfun/coth.m
@@ -33,13 +33,13 @@ function y = coth (x)
   y = 1 ./ tanh (x);
 
 endfunction
 
 
 %!test
 %! x = [pi/2*i, 3*pi/2*i];
 %! v = [0, 0];
-%! assert (all (abs (coth (x) - v) < sqrt (eps)));
+%! assert (coth (x), v, sqrt (eps));
 
 %!error coth ()
 %!error coth (1, 2)
 
diff --git a/scripts/elfun/csc.m b/scripts/elfun/csc.m
--- a/scripts/elfun/csc.m
+++ b/scripts/elfun/csc.m
@@ -35,13 +35,13 @@ function y = csc (x)
 endfunction
 
 
 %!test
 %! rt2 = sqrt (2);
 %! rt3 = sqrt (3);
 %! x = [pi/6, pi/4, pi/3, pi/2, 2*pi/3, 3*pi/4, 5*pi/6];
 %! v = [2, rt2, 2*rt3/3, 1, 2*rt3/3, rt2, 2];
-%! assert (all (abs (csc (x) - v) < sqrt (eps)));
+%! assert (csc (x), v, sqrt (eps));
 
 %!error csc ()
 %!error csc (1, 2)
 
diff --git a/scripts/elfun/cscd.m b/scripts/elfun/cscd.m
--- a/scripts/elfun/cscd.m
+++ b/scripts/elfun/cscd.m
@@ -36,8 +36,9 @@ endfunction
 
 
 %!assert (cscd (10:10:90), csc (pi*[10:10:90]/180), -10*eps)
 %!assert (cscd ([0, 180, 360]) == Inf)
 %!assert (cscd ([90, 270]) != Inf)
 
 %!error cscd ()
 %!error cscd (1, 2)
+
diff --git a/scripts/elfun/csch.m b/scripts/elfun/csch.m
--- a/scripts/elfun/csch.m
+++ b/scripts/elfun/csch.m
@@ -33,13 +33,13 @@ function y = csch (x)
   y = 1 ./ sinh (x);
 
 endfunction
 
 
 %!test
 %! x = [pi/2*i, 3*pi/2*i];
 %! v = [-i, i];
-%! assert (all (abs (csch (x) - v) < sqrt (eps)));
+%! assert (csch (x), v, sqrt (eps));
 
 %!error csch ()
 %!error csch (1, 2)
 
diff --git a/scripts/elfun/sec.m b/scripts/elfun/sec.m
--- a/scripts/elfun/sec.m
+++ b/scripts/elfun/sec.m
@@ -35,13 +35,13 @@ function y = sec (x)
 endfunction
 
 
 %!test
 %! rt2 = sqrt (2);
 %! rt3 = sqrt (3);
 %! x = [0, pi/6, pi/4, pi/3, 2*pi/3, 3*pi/4, 5*pi/6, pi];
 %! v = [1, 2*rt3/3, rt2, 2, -2, -rt2, -2*rt3/3, -1];
-%! assert (all (abs (sec (x) - v) < sqrt (eps)));
+%! assert (sec (x), v, sqrt (eps));
 
 %!error sec ()
 %!error sec (1, 2)
 
diff --git a/scripts/elfun/secd.m b/scripts/elfun/secd.m
--- a/scripts/elfun/secd.m
+++ b/scripts/elfun/secd.m
@@ -36,8 +36,9 @@ endfunction
 
 
 %!assert (secd (0:10:80), sec (pi*[0:10:80]/180), -10*eps)
 %!assert (secd ([0, 180, 360]) != Inf)
 %!assert (secd ([90, 270]) == Inf)
 
 %!error secd ()
 %!error secd (1, 2)
+
diff --git a/scripts/elfun/sech.m b/scripts/elfun/sech.m
--- a/scripts/elfun/sech.m
+++ b/scripts/elfun/sech.m
@@ -33,13 +33,13 @@ if (nargin != 1)
   y = 1 ./ cosh (x);
 
 endfunction
 
 
 %!test
 %! x = [0, pi*i];
 %! v = [1, -1];
-%! assert (all (abs (sech (x) - v) < sqrt (eps)));
+%! assert (sech (x), v, sqrt (eps));
 
 %!error sech ()
 %!error sech (1, 2)
 
diff --git a/scripts/elfun/sind.m b/scripts/elfun/sind.m
--- a/scripts/elfun/sind.m
+++ b/scripts/elfun/sind.m
@@ -39,8 +39,9 @@ endfunction
 
 
 %!assert (sind (10:10:90), sin (pi*[10:10:90]/180), -10*eps)
 %!assert (sind ([0, 180, 360]) == 0)
 %!assert (sind ([90, 270]) != 0)
 
 %!error sind ()
 %!error sind (1, 2)
+
diff --git a/scripts/elfun/tand.m b/scripts/elfun/tand.m
--- a/scripts/elfun/tand.m
+++ b/scripts/elfun/tand.m
@@ -42,8 +42,9 @@ endfunction
 
 
 %!assert (tand (10:10:80), tan (pi*[10:10:80]/180), -10*eps)
 %!assert (tand ([0, 180, 360]) == 0)
 %!assert (tand ([90, 270]) == Inf)
 
 %!error tand ()
 %!error tand (1, 2)
+
diff --git a/scripts/general/accumarray.m b/scripts/general/accumarray.m
--- a/scripts/general/accumarray.m
+++ b/scripts/general/accumarray.m
@@ -63,55 +63,55 @@
 ## of @code{unique}  for assigning to all repeated elements of @var{x}
 ## the same index (@pxref{doc-unique}).
 ##
 ## @example
 ## @group
 ## @var{x} = [91, 92, 90, 92, 90, 89, 91, 89, 90, 100, 100, 100];
 ## [@var{u}, ~, @var{j}] = unique (@var{x});
 ## [accumarray(@var{j}', 1), @var{u}']
-## @result{} 2    89
-##    3    90
-##    2    91
-##    2    92
-##    3   100
+##   @result{}  2    89
+##       3    90
+##       2    91
+##       2    92
+##       3   100
 ## @end group
 ## @end example
 ##
 ## Another example, where the result is a multi-dimensional 3-D array and
 ## the default value (zero) appears in the output:
 ##
 ## @example
 ## @group
 ## accumarray ([1, 1, 1;
 ##              2, 1, 2;
 ##              2, 3, 2;
 ##              2, 1, 2;
 ##              2, 3, 2], 101:105)
 ## @result{} ans(:,:,1) = [101, 0, 0; 0, 0, 0]
-##    ans(:,:,2) = [0, 0, 0; 206, 0, 208]
+## @result{} ans(:,:,2) = [0, 0, 0; 206, 0, 208]
 ## @end group
 ## @end example
 ##
 ## The sparse option can be used as an alternative to the @code{sparse}
-## constructor (@pxref{doc-sparse}). Thus
+## constructor (@pxref{doc-sparse}).  Thus
 ##
 ## @example
 ## sparse (@var{i}, @var{j}, @var{sv})
 ## @end example
 ##
 ## @noindent
 ## can be written with @code{accumarray} as
 ##
 ## @example
 ## accumarray ([@var{i}, @var{j}], @var{sv}', [], [], 0, true)
 ## @end example
 ##
 ## @noindent
-## For repeated indices, @code{sparse} adds the corresponding value. To
+## For repeated indices, @code{sparse} adds the corresponding value.  To
 ## take the minimum instead, use @code{min} as an accumulator function:
 ##
 ## @example
 ## accumarray ([@var{i}, @var{j}], @var{sv}', [], @@min, 0, true)
 ## @end example
 ##
 ## The complexity of accumarray in general for the non-sparse case is
 ## generally O(M+N), where N is the number of subscripts and M is the
@@ -363,34 +363,33 @@ function A = accumarray (subs, vals, sz 
       endif
 
       ## Set the reduced values.
       A(subs) = vals;
     endif
   endif
 endfunction
 
-%!error (accumarray (1:5))
-%!error (accumarray ([1,2,3],1:2))
+
 %!assert (accumarray ([1;2;4;2;4],101:105), [101;206;0;208])
-%!assert (accumarray ([1,1,1;2,1,2;2,3,2;2,1,2;2,3,2],101:105),cat(3, [101,0,0;0,0,0],[0,0,0;206,0,208]))
-%!assert (accumarray ([1,1,1;2,1,2;2,3,2;2,1,2;2,3,2],101:105,[],@(x)sin(sum(x))),sin(cat(3, [101,0,0;0,0,0],[0,0,0;206,0,208])))
-%!assert (accumarray ({[1 3 3 2 3 1 2 2 3 3 1 2],[3 4 2 1 4 3 4 2 2 4 3 4],[1 1 2 2 1 1 2 1 1 1 2 2]},101:112),cat(3,[0,0,207,0;0,108,0,0;0,109,0,317],[0,0,111,0;104,0,0,219;0,103,0,0]))
-%!assert (accumarray ([1,1;2,1;2,3;2,1;2,3],101:105,[2,4],@max,NaN),[101,NaN,NaN,NaN;104,NaN,105,NaN])
+%!assert (accumarray ([1,1,1;2,1,2;2,3,2;2,1,2;2,3,2],101:105), cat(3, [101,0,0;0,0,0],[0,0,0;206,0,208]))
+%!assert (accumarray ([1,1,1;2,1,2;2,3,2;2,1,2;2,3,2],101:105,[],@(x)sin(sum(x))), sin (cat (3, [101,0,0;0,0,0],[0,0,0;206,0,208])))
+%!assert (accumarray ({[1 3 3 2 3 1 2 2 3 3 1 2],[3 4 2 1 4 3 4 2 2 4 3 4],[1 1 2 2 1 1 2 1 1 1 2 2]},101:112), cat (3, [0,0,207,0;0,108,0,0;0,109,0,317], [0,0,111,0;104,0,0,219;0,103,0,0]))
+%!assert (accumarray ([1,1;2,1;2,3;2,1;2,3],101:105,[2,4],@max,NaN), [101,NaN,NaN,NaN;104,NaN,105,NaN])
 %!assert (accumarray ([1 1; 2 1; 2 3; 2 1; 2 3],101:105, [], @prod), [101, 0, 0; 10608, 0, 10815])
-%!assert (accumarray ([1 1; 2 1; 2 3; 2 1; 2 3],101:105,[2 4],@prod,0,true),sparse([1,2,2],[1,1,3],[101,10608,10815],2,4))
+%!assert (accumarray ([1 1; 2 1; 2 3; 2 1; 2 3],101:105,[2 4],@prod,0,true), sparse ([1,2,2],[1,1,3],[101,10608,10815],2,4))
 %!assert (accumarray ([1 1; 2 1; 2 3; 2 1; 2 3],1,[2,4]), [1,0,0,0;2,0,2,0])
-%!assert (accumarray ([1 1; 2 1; 2 3; 2 1; 2 3],101:105,[2,4],@(x)length(x)>1),[false,false,false,false;true,false,true,false])
+%!assert (accumarray ([1 1; 2 1; 2 3; 2 1; 2 3],101:105,[2,4],@(x)length(x)>1), [false,false,false,false;true,false,true,false])
 %!assert (accumarray ([1; 2], [3; 4], [2, 1], @min, [], 0), [3; 4])
 %!assert (accumarray ([1; 2], [3; 4], [2, 1], @min, [], 1), sparse ([3; 4]))
 %!assert (accumarray ([1; 2], [3; 4], [1, 2], @min, [], 0), [3, 4])
 %!assert (accumarray ([1; 2], [3; 4], [1, 2], @min, [], 1), sparse ([3, 4]))
 %!test
-%! A = accumarray ([1 1; 2 1; 2 3; 2 1; 2 3],101:105,[2,4],@(x){x});
-%! assert (A{2},[102;104])
+%! A = accumarray ([1 1; 2 1; 2 3; 2 1; 2 3], 101:105, [2,4], @(x){x});
+%! assert (A{2},[102;104]);
 %!test
 %! subs = ceil (rand (2000, 3)*10);
 %! vals = rand (2000, 1);
 %! assert (accumarray (subs, vals, [], @max), accumarray (subs, vals, [], @(x) max (x)));
 %!test
 %! subs = ceil (rand (2000, 1)*100);
 %! vals = rand (2000, 1);
 %! assert (accumarray (subs, vals, [100, 1], @min, NaN), accumarray (subs, vals, [100, 1], @(x) min (x), NaN));
@@ -400,9 +399,11 @@ endfunction
 %! vals = rand (2000, 1);
 %! assert (accumarray (subsc, vals, [], [], 0, true), accumarray (subs, vals, [], [], 0, true));
 %!test
 %! subs = ceil (rand (2000, 3)*10);
 %! subsc = num2cell (subs, 1);
 %! vals = rand (2000, 1);
 %! assert (accumarray (subsc, vals, [], @max), accumarray (subs, vals, [], @max));
 
+%!error (accumarray (1:5))
+%!error (accumarray ([1,2,3],1:2))
 
diff --git a/scripts/general/accumdim.m b/scripts/general/accumdim.m
--- a/scripts/general/accumdim.m
+++ b/scripts/general/accumdim.m
@@ -45,17 +45,17 @@
 ##
 ## @example
 ## @group
 ## accumdim ([1, 2, 1, 2, 1], [ 7, -10,   4;
 ##                             -5, -12,   8;
 ##                            -12,   2,   8;
 ##                            -10,   9,  -3;
 ##                             -5,  -3, -13])
-## @result{} ans = [-10,-11,-1;-15,-3,5]
+## @result{} [-10,-11,-1;-15,-3,5]
 ## @end group
 ## @end example
 ##
 ## @seealso{accumarray}
 ## @end deftypefn
 
 function A = accumdim (subs, vals, dim, n = 0, func = [], fillval = 0)
 
@@ -143,17 +143,19 @@ function A = accumdim (subs, vals, dim, 
   endif
 
   ## Set the reduced values.
   subsc{dim} = subs;
   A(subsc{:}) = vals;
 
 endfunction
 
+
 %%test accumdim vs. accumarray
 
 %!shared a
 %! a = rand (5, 5, 5);
 
 %!assert (accumdim ([1;3;1;3;3], a)(:,2,3), accumarray ([1;3;1;3;3], a(:,2,3)))
 %!assert (accumdim ([2;3;2;2;2], a, 2, 4)(4,:,2), accumarray ([2;3;2;2;2], a(4,:,2), [1,4]))
 %!assert (accumdim ([2;3;2;1;2], a, 3, 3, @min)(1,5,:), accumarray ([2;3;2;1;2], a(1,5,:), [1,1,3], @min))
 %!assert (accumdim ([1;3;2;2;1], a, 2, 3, @median)(4,:,5), accumarray ([1;3;2;2;1], a(4,:,5), [1,3], @median))
+
diff --git a/scripts/general/bitcmp.m b/scripts/general/bitcmp.m
--- a/scripts/general/bitcmp.m
+++ b/scripts/general/bitcmp.m
@@ -18,22 +18,22 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} bitcmp (@var{A}, @var{k})
 ## Return the @var{k}-bit complement of integers in @var{A}.  If
 ## @var{k} is omitted @code{k = log2 (bitmax) + 1} is assumed.
 ##
 ## @example
 ## @group
-## bitcmp(7,4)
-## @result{} 8
-## dec2bin(11)
-## @result{} 1011
-## dec2bin(bitcmp(11, 6))
-## @result{} 110100
+## bitcmp (7,4)
+##   @result{} 8
+## dec2bin (11)
+##   @result{} 1011
+## dec2bin (bitcmp (11, 6))
+##   @result{} 110100
 ## @end group
 ## @end example
 ## @seealso{bitand, bitor, bitxor, bitset, bitget, bitcmp, bitshift, bitmax}
 ## @end deftypefn
 
 ## Liberally based on the version by Kai Habel from octave-forge
 
 function C = bitcmp (A, k)
@@ -81,43 +81,43 @@ function C = bitcmp (A, k)
     endif
     mask = bitshift (bmax, k - amax);
     C = bitxor (bitand (A, mask), mask);
   endif
 endfunction
 
 
 %!test
-%! Amax=53;
+%! Amax = 53;
 %! Bmax = bitmax;
-%! A = bitshift(Bmax,-2);
-%! assert(bitcmp(A,Amax),bitor(bitshift(1,Amax-1),bitshift(1,Amax-2)));
-%! assert(bitcmp(A,Amax-1),bitshift(1,Amax-2));
-%! assert(bitcmp(A,Amax-2),0);
+%! A = bitshift (Bmax,-2);
+%! assert (bitcmp (A,Amax),bitor (bitshift (1,Amax-1), bitshift (1,Amax-2)));
+%! assert (bitcmp (A,Amax-1), bitshift (1,Amax-2));
+%! assert (bitcmp (A,Amax-2), 0);
 %!test
-%! Amax=8;
-%! Bmax = intmax('uint8');
-%! A = bitshift(Bmax,-2);
-%! assert(bitcmp(A,Amax),bitor(bitshift(uint8(1),Amax-1),bitshift(uint8(1),Amax-2)));
-%! assert(bitcmp(A,Amax-1),bitshift(uint8(1),Amax-2));
-%! assert(bitcmp(A,Amax-2),uint8(0));
+%! Amax = 8;
+%! Bmax = intmax ("uint8");
+%! A = bitshift (Bmax,-2);
+%! assert (bitcmp (A,Amax),bitor (bitshift (uint8 (1),Amax-1), bitshift (uint8 (1),Amax-2)));
+%! assert (bitcmp (A,Amax-1), bitshift (uint8 (1),Amax-2));
+%! assert (bitcmp (A,Amax-2), uint8 (0));
 %!test
-%! Amax=16;
-%! Bmax = intmax('uint16');
-%! A = bitshift(Bmax,-2);
-%! assert(bitcmp(A,Amax),bitor(bitshift(uint16(1),Amax-1),bitshift(uint16(1),Amax-2)));
-%! assert(bitcmp(A,Amax-1),bitshift(uint16(1),Amax-2));
-%! assert(bitcmp(A,Amax-2),uint16(0));
+%! Amax = 16;
+%! Bmax = intmax ("uint16");
+%! A = bitshift (Bmax,-2);
+%! assert (bitcmp (A,Amax),bitor (bitshift (uint16 (1),Amax-1), bitshift (uint16 (1),Amax-2)));
+%! assert (bitcmp (A,Amax-1), bitshift (uint16 (1),Amax-2));
+%! assert (bitcmp (A,Amax-2), uint16 (0));
 %!test
-%! Amax=32;
-%! Bmax = intmax('uint32');
-%! A = bitshift(Bmax,-2);
-%! assert(bitcmp(A,Amax),bitor(bitshift(uint32(1),Amax-1),bitshift(uint32(1),Amax-2)));
-%! assert(bitcmp(A,Amax-1),bitshift(uint32(1),Amax-2));
-%! assert(bitcmp(A,Amax-2),uint32(0));
+%! Amax = 32;
+%! Bmax = intmax ("uint32");
+%! A = bitshift (Bmax,-2);
+%! assert (bitcmp (A,Amax),bitor (bitshift (uint32 (1),Amax-1), bitshift (uint32 (1),Amax-2)));
+%! assert (bitcmp (A,Amax-1), bitshift (uint32 (1),Amax-2));
+%! assert (bitcmp (A,Amax-2), uint32 (0));
 %!test
-%! Amax=64;
-%! Bmax = intmax('uint64');
-%! A = bitshift(Bmax,-2);
-%! assert(bitcmp(A,Amax),bitor(bitshift(uint64(1),Amax-1),bitshift(uint64(1),Amax-2)));
-%! assert(bitcmp(A,Amax-1),bitshift(uint64(1),Amax-2));
-%! assert(bitcmp(A,Amax-2),uint64(0));
+%! Amax = 64;
+%! Bmax = intmax ("uint64");
+%! A = bitshift (Bmax,-2);
+%! assert (bitcmp (A,Amax),bitor (bitshift (uint64 (1),Amax-1), bitshift (uint64 (1),Amax-2)));
+%! assert (bitcmp (A,Amax-1), bitshift (uint64 (1),Amax-2));
+%! assert (bitcmp (A,Amax-2), uint64 (0));
 
diff --git a/scripts/general/bitget.m b/scripts/general/bitget.m
--- a/scripts/general/bitget.m
+++ b/scripts/general/bitget.m
@@ -75,35 +75,37 @@ function C = bitget (A, n)
   if (any (m < 1) || any (m > Amax))
     error ("bitget: N must be in the range [1,%d]", Amax);
   endif
 
   C = bitand (A, bitshift (_conv (1), uint8 (n) - uint8 (1))) != _conv (0);
 
 endfunction
 
-%!error bitget (1);
-%!error bitget (1, 2, 3);
 
 %!test
 %! assert (bitget ([4, 14], [3, 3]), logical ([1, 1]));
 %! pfx = {"", "u"};
 %! for i = 1:2
 %!   for prec = [8, 16, 32, 64]
 %!     fcn = str2func (sprintf ("%sint%d", pfx{i}, prec));
 %!     assert (bitget (fcn ([4, 14]), [3, 3]), logical ([1, 1]));
 %!   endfor
 %! endfor
 
-%!error bitget (0, 0);
-%!error bitget (0, 55);
+%!error bitget (0, 0)
+%!error bitget (0, 55)
 
-%!error bitget (int8 (0), 9);
-%!error bitget (uint8 (0), 9);
+%!error bitget (int8 (0), 9)
+%!error bitget (uint8 (0), 9)
+
+%!error bitget (int16 (0), 17)
+%!error bitget (uint16 (0), 17)
 
-%!error bitget (int16 (0), 17);
-%!error bitget (uint16 (0), 17);
+%!error bitget (int32 (0), 33)
+%!error bitget (uint32 (0), 33)
 
-%!error bitget (int32 (0), 33);
-%!error bitget (uint32 (0), 33);
+%!error bitget (int64 (0), 65)
+%!error bitget (uint64 (0), 65)
 
-%!error bitget (int64 (0), 65);
-%!error bitget (uint64 (0), 65);
+%!error bitget (1)
+%!error bitget (1, 2, 3)
+
diff --git a/scripts/general/bitset.m b/scripts/general/bitset.m
--- a/scripts/general/bitset.m
+++ b/scripts/general/bitset.m
@@ -21,17 +21,17 @@
 ## @deftypefnx {Function File} {@var{C} =} bitset (@var{A}, @var{n}, @var{val})
 ## Set or reset bit(s) @var{n} of unsigned integers in @var{A}.
 ## @var{val} = 0 resets and @var{val} = 1 sets the bits.
 ## The lowest significant bit is: @var{n} = 1
 ##
 ## @example
 ## @group
 ## dec2bin (bitset (10, 1))
-## @result{} 1011
+##   @result{} 1011
 ## @end group
 ## @end example
 ## @seealso{bitand, bitor, bitxor, bitget, bitcmp, bitshift, bitmax}
 ## @end deftypefn
 
 ## Liberally based on the version by Kai Habel from octave-forge
 
 function C = bitset (A, n, val)
@@ -88,35 +88,33 @@ function C = bitset (A, n, val)
   C = bitxor (A, bitand (A, mask));
 
   if (val)
     C = bitor (A, mask);
   endif
 
 endfunction
 
-%!error bitset (1);
-%!error bitset (1, 2, 3, 4);
 
 %!test
 %! assert (bitset ([0, 10], [3, 3]), [4, 14]);
 %! pfx = {"", "u"};
 %! for i = 1:2
 %!   for prec = [8, 16, 32, 64]
 %!     fcn = str2func (sprintf ("%sint%d", pfx{i}, prec));
 %!     assert (bitset (fcn ([0, 10]), [3, 3]), fcn ([4, 14]));
 %!   endfor
 %! endfor
 
-%!error bitset (0, 0);
-%!error bitset (0, 55);
-
-%!error bitset (int8 (0), 9);
-%!error bitset (uint8 (0), 9);
+%!error bitset (0, 0)
+%!error bitset (0, 55)
+%!error bitset (int8 (0), 9)
+%!error bitset (uint8 (0), 9)
+%!error bitset (int16 (0), 17)
+%!error bitset (uint16 (0), 17)
+%!error bitset (int32 (0), 33)
+%!error bitset (uint32 (0), 33)
+%!error bitset (int64 (0), 65)
+%!error bitset (uint64 (0), 65)
 
-%!error bitset (int16 (0), 17);
-%!error bitset (uint16 (0), 17);
+%!error bitset (1)
+%!error bitset (1, 2, 3, 4)
 
-%!error bitset (int32 (0), 33);
-%!error bitset (uint32 (0), 33);
-
-%!error bitset (int64 (0), 65);
-%!error bitset (uint64 (0), 65);
diff --git a/scripts/general/blkdiag.m b/scripts/general/blkdiag.m
--- a/scripts/general/blkdiag.m
+++ b/scripts/general/blkdiag.m
@@ -58,24 +58,26 @@ function retval = blkdiag (varargin)
     vp = varargin{p};
     if (! isempty (vp))
       retval((csz(p,1)+1):csz(p+1,1),(csz(p,2)+1):csz(p+1,2)) = vp;
     endif
   endfor
 
 endfunction
 
+
 ## regular tests
-%!assert(blkdiag(1,ones(2),1),[1,0,0,0;0,1,1,0;0,1,1,0;0,0,0,1])
-%!assert(blkdiag([1,2],[3,4],[5,6]),[1,2,0,0,0,0;0,0,3,4,0,0;0,0,0,0,5,6])
-%!assert(blkdiag([1,2],[3;4],[5,6]),[1,2,0,0,0;0,0,3,0,0;0,0,4,0,0;0,0,0,5,6])
-%!assert(blkdiag([1,2;3,4],[5,6,7]),[1,2,0,0,0;3,4,0,0,0;0,0,5,6,7])
+%!assert (blkdiag (1,ones (2),1), [1,0,0,0;0,1,1,0;0,1,1,0;0,0,0,1])
+%!assert (blkdiag ([1,2],[3,4],[5,6]), [1,2,0,0,0,0;0,0,3,4,0,0;0,0,0,0,5,6])
+%!assert (blkdiag ([1,2],[3;4],[5,6]), [1,2,0,0,0;0,0,3,0,0;0,0,4,0,0;0,0,0,5,6])
+%!assert (blkdiag ([1,2;3,4],[5,6,7]), [1,2,0,0,0;3,4,0,0,0;0,0,5,6,7])
 ## tests involving empty matrices
-%!assert(blkdiag([],[],[]),[])
-%!assert(blkdiag([],[1,2;3,4],[],5,[]),[1,2,0;3,4,0;0,0,5])
-%!assert(blkdiag(zeros(1,0,1),[1,2,3],1,0,5,zeros(0,1,1)),[0,0,0,0,0,0,0;1,2,3,0,0,0,0;0,0,0,1,0,0,0;0,0,0,0,0,0,0;0,0,0,0,0,5,0]);
+%!assert (blkdiag ([],[],[]), [])
+%!assert (blkdiag ([],[1,2;3,4],[],5,[]), [1,2,0;3,4,0;0,0,5])
+%!assert (blkdiag (zeros (1,0,1),[1,2,3],1,0,5,zeros (0,1,1)), [0,0,0,0,0,0,0;1,2,3,0,0,0,0;0,0,0,1,0,0,0;0,0,0,0,0,0,0;0,0,0,0,0,5,0]);
 ## tests involving sparse matrices
-%!assert (blkdiag (sparse([1,2;3,4]),[5,6;7,8]), sparse([1,2,0,0;3,4,0,0;0,0,5,6;0,0,7,8]))
-%!assert (blkdiag (sparse([1,2;3,4]),[5,6]), sparse([1,2,0,0;3,4,0,0;0,0,5,6]))
+%!assert (blkdiag (sparse ([1,2;3,4]),[5,6;7,8]), sparse ([1,2,0,0;3,4,0,0;0,0,5,6;0,0,7,8]))
+%!assert (blkdiag (sparse ([1,2;3,4]),[5,6]), sparse ([1,2,0,0;3,4,0,0;0,0,5,6]))
 # sanity checks
 %!test
 %! A = rand (round (rand (1, 2) * 10));
 %! assert (blkdiag (A), A);
+
diff --git a/scripts/general/cart2pol.m b/scripts/general/cart2pol.m
--- a/scripts/general/cart2pol.m
+++ b/scripts/general/cart2pol.m
@@ -76,37 +76,38 @@ function [theta, r, z] = cart2pol (x, y,
   r = sqrt (x .^ 2 + y .^ 2);
 
   if (nargout <= 1)
     theta = [theta, r, z];
   endif
 
 endfunction
 
+
 %!test
 %! x = [0, 1, 2];
 %! y = 0;
 %! [t, r] = cart2pol (x, y);
 %! assert (t, [0, 0, 0]);
 %! assert (r, x);
 
 %!test
 %! x = [0, 1, 2];
 %! y = [0, 1, 2];
 %! [t, r] = cart2pol (x, y);
-%! assert (t, [0, pi/4, pi/4], sqrt(eps));
-%! assert (r, sqrt(2)*[0, 1, 2], sqrt(eps));
+%! assert (t, [0, pi/4, pi/4], sqrt (eps));
+%! assert (r, sqrt (2)*[0, 1, 2], sqrt (eps));
 
 %!test
 %! x = [0, 1, 2];
 %! y = [0, 1, 2];
 %! z = [0, 1, 2];
 %! [t, r, z2] = cart2pol (x, y, z);
-%! assert (t, [0, pi/4, pi/4], sqrt(eps));
-%! assert (r, sqrt(2)*[0, 1, 2], sqrt(eps));
+%! assert (t, [0, pi/4, pi/4], sqrt (eps));
+%! assert (r, sqrt (2)*[0, 1, 2], sqrt (eps));
 %! assert (z, z2);
 
 %!test
 %! x = [0, 1, 2];
 %! y = 0;
 %! z = 0;
 %! [t, r, z2] = cart2pol (x, y, z);
 %! assert (t, [0, 0, 0], eps);
@@ -129,15 +130,15 @@ endfunction
 %! [t, r, z2] = cart2pol (x, y, z);
 %! assert (t, 0);
 %! assert (r, 0);
 %! assert (z, z2);
 
 %!test
 %! C = [0, 0; 1, 1; 2, 2];
 %! P = [0, 0; pi/4, sqrt(2); pi/4, 2*sqrt(2)];
-%! assert (cart2pol (C), P, sqrt(eps));
+%! assert (cart2pol (C), P, sqrt (eps));
 
 %!test
 %! C = [0, 0, 0; 1, 1, 1; 2, 2, 2];
 %! P = [0, 0, 0; pi/4, sqrt(2), 1; pi/4, 2*sqrt(2), 2];
-%! assert (cart2pol (C), P, sqrt(eps));
+%! assert (cart2pol (C), P, sqrt (eps));
 
diff --git a/scripts/general/cart2sph.m b/scripts/general/cart2sph.m
--- a/scripts/general/cart2sph.m
+++ b/scripts/general/cart2sph.m
@@ -66,48 +66,50 @@ function [theta, phi, r] = cart2sph (x, 
   r = sqrt (x .^ 2 + y .^ 2 + z .^ 2);
 
   if (nargout <= 1)
     theta = [theta, phi, r];
   endif
 
 endfunction
 
+
 %!test
 %! x = [0, 1, 2];
 %! y = [0, 1, 2];
 %! z = [0, 1, 2];
 %! [t, p, r] = cart2sph (x, y, z);
 %! assert (t, [0, pi/4, pi/4], eps);
-%! assert (p, [0, 1, 1]*atan(sqrt(0.5)), eps);
-%! assert (r, [0, 1, 2]*sqrt(3), eps);
+%! assert (p, [0, 1, 1]*atan (sqrt (0.5)), eps);
+%! assert (r, [0, 1, 2]*sqrt (3), eps);
 
 %!test
 %! x = 0;
 %! y = [0, 1, 2];
 %! z = [0, 1, 2];
 %! [t, p, r] = cart2sph (x, y, z);
 %! assert (t, [0, 1, 1] * pi/2, eps);
 %! assert (p, [0, 1, 1] * pi/4, eps);
-%! assert (r, [0, 1, 2] * sqrt(2), eps);
+%! assert (r, [0, 1, 2] * sqrt (2), eps);
 
 %!test
 %! x = [0, 1, 2];
 %! y = 0;
 %! z = [0, 1, 2];
 %! [t, p, r] = cart2sph (x, y, z);
 %! assert (t, [0, 0, 0]);
 %! assert (p, [0, 1, 1] * pi/4);
-%! assert (r, [0, 1, 2] * sqrt(2));
+%! assert (r, [0, 1, 2] * sqrt (2));
 
 %!test
 %! x = [0, 1, 2];
 %! y = [0, 1, 2];
 %! z = 0;
 %! [t, p, r] = cart2sph (x, y, z);
 %! assert (t, [0, 1, 1] * pi/4);
 %! assert (p, [0, 0, 0]);
-%! assert (r, [0, 1, 2] * sqrt(2));
+%! assert (r, [0, 1, 2] * sqrt (2));
 
 %!test
 %! C = [0, 0, 0; 1, 0, 1; 2, 0, 2];
 %! S = [0, 0, 0; 0, pi/4, sqrt(2); 0, pi/4, 2*sqrt(2)];
-%! assert (cart2sph(C), S, eps);
+%! assert (cart2sph (C), S, eps);
+
diff --git a/scripts/general/celldisp.m b/scripts/general/celldisp.m
--- a/scripts/general/celldisp.m
+++ b/scripts/general/celldisp.m
@@ -20,26 +20,26 @@
 ## @deftypefn {Function File} {} celldisp (@var{c}, @var{name})
 ## Recursively display the contents of a cell array.  By default the values
 ## are displayed with the name of the variable @var{c}.  However, this name
 ## can be replaced with the variable @var{name}.  For example:
 ##
 ## @example
 ## @group
 ## c = @{1, 2, @{31, 32@}@};
-## celldisp(c, "b")
-##      @result{}
-##         b@{1@} =
-##          1
-##         b@{2@} =
-##          2
-##         b@{3@}@{1@} =
-##          31
-##         b@{3@}@{2@} =
-##          32
+## celldisp (c, "b")
+##    @result{}
+##       b@{1@} =
+##        1
+##       b@{2@} =
+##        2
+##       b@{3@}@{1@} =
+##        31
+##       b@{3@}@{2@} =
+##        32
 ## @end group
 ## @end example
 ##
 ## @seealso{disp}
 ## @end deftypefn
 
 ## This is ugly, but seems to be what matlab does..
 
@@ -78,11 +78,12 @@ function s = indices (dv, i)
   endif
 endfunction
 
 
 %!demo
 %! c = {1, 2, {31, 32}};
 %! celldisp (c, "b")
 
-%!error celldisp ();
-%!error celldisp ({}, "name", 1);
-%!error celldisp (1);
+%!error celldisp ()
+%!error celldisp ({}, "name", 1)
+%!error celldisp (1)
+
diff --git a/scripts/general/chop.m b/scripts/general/chop.m
--- a/scripts/general/chop.m
+++ b/scripts/general/chop.m
@@ -20,19 +20,19 @@
 ## @deftypefn {Function File} {} chop (@var{x}, @var{ndigits}, @var{base})
 ## Truncate elements of @var{x} to a length of @var{ndigits} such that the
 ## resulting numbers are exactly divisible by @var{base}.  If @var{base} is not
 ## specified it defaults to 10.
 ##
 ## @example
 ## @group
 ## chop (-pi, 5, 10)
-##      @result{} -3.14200000000000
+##    @result{} -3.14200000000000
 ## chop (-pi, 5, 5)
-##      @result{} -3.14150000000000
+##    @result{} -3.14150000000000
 ## @end group
 ## @end example
 ## @end deftypefn
 
 function retval = chop (x, ndigits, base = 10)
 
   if (nargin == 2 || nargin == 3)
     tmp = abs (x);
@@ -73,8 +73,9 @@ endfunction
 %!assert (chop (e, 4, 5), 2.72)
 %!assert (chop (e, 4, 7), 2.716)
 %!assert (chop (-e, 3), -2.72)
 %!assert (chop (-e, 4), -2.718)
 %!assert (chop (-e, 4, 5), -2.72)
 %!assert (chop (-e, 4, 7), -2.716)
 %!assert (chop (hilb (3), 3), [1,.5,.333;.5,.333,.25;.333,.25,.2])
 %!assert (chop (hilb (3), 2, 7), [.7,.49,.35;.49,.35,.28;.35,.28,.21], 2*eps)
+
diff --git a/scripts/general/circshift.m b/scripts/general/circshift.m
--- a/scripts/general/circshift.m
+++ b/scripts/general/circshift.m
@@ -93,12 +93,12 @@ endfunction
 
 %!assert (circshift (eye (3), 1), circshift (eye (3), 1))
 %!assert (circshift (eye (3), 1), [0,0,1;1,0,0;0,1,0])
 
 %% Test input validation
 %!error circshift ()
 %!error circshift (1)
 %!error circshift (1,2,3)
-%!error circshift (1, ones(2,2))
+%!error circshift (1, ones (2,2))
 %!error circshift (1, [1 2 3])
 %!error circshift (1, 1.5)
 
diff --git a/scripts/general/colon.m b/scripts/general/colon.m
--- a/scripts/general/colon.m
+++ b/scripts/general/colon.m
@@ -19,26 +19,27 @@
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{r} =} colon (@var{a}, @var{b})
 ## @deftypefnx {Function File} {@var{r} =} colon (@var{a}, @var{b}, @var{c})
 ## Method of a class to construct a range with the @code{:} operator.  For
 ## example:
 ##
 ## @example
 ## @group
-## a = myclass (@dots{})
-## b = myclass (@dots{})
+## a = myclass (@dots{});
+## b = myclass (@dots{});
 ## c = a : b
 ## @end group
 ## @end example
 ##
 ## @seealso{class, subsref, subsasgn}
 ## @end deftypefn
 
 function r = colon (varargin)
   if (nargin != 0)
     error ("colon: not defined for class \"%s\"", class(varargin{1}));
   endif
 endfunction
 
+
 %!error colon (1)
 
 ## FIXME -- what does colon () mean since it doesn't set a return value?
diff --git a/scripts/general/common_size.m b/scripts/general/common_size.m
--- a/scripts/general/common_size.m
+++ b/scripts/general/common_size.m
@@ -74,17 +74,19 @@ function [errorcode, varargout] = common
           subs = arrayfun (@ones, 1, dims, "uniformoutput", false);
           varargout(scal) = cellindexmat (varargin(scal), subs{:});
         endif
       endif
     endif
   endif
 endfunction
 
-%!error common_size ();
 
 %!test
 %! m = [1,2;3,4];
 %! [err, a, b, c] = common_size (m, 3, 5);
 %! assert (err, 0);
 %! assert (a, m);
 %! assert (b, [3,3;3,3]);
 %! assert (c, [5,5;5,5]);
+
+%!error common_size ()
+
diff --git a/scripts/general/cplxpair.m b/scripts/general/cplxpair.m
--- a/scripts/general/cplxpair.m
+++ b/scripts/general/cplxpair.m
@@ -158,9 +158,9 @@ endfunction
 %!assert (cplxpair (z(randperm (7))), z)
 %!assert (cplxpair (z(randperm (7))), z)
 %!assert (cplxpair ([z(randperm(7)),z(randperm(7))]), [z,z])
 %!assert (cplxpair ([z(randperm(7)),z(randperm(7))],[],1), [z,z])
 %!assert (cplxpair ([z(randperm(7)).';z(randperm(7)).'],[],2), [z.';z.'])
 
 %!## tolerance test
 %!assert (cplxpair ([1i, -1i, 1+(1i*eps)],2*eps), [-1i, 1i, 1+(1i*eps)])
-
+ 
diff --git a/scripts/general/cumtrapz.m b/scripts/general/cumtrapz.m
--- a/scripts/general/cumtrapz.m
+++ b/scripts/general/cumtrapz.m
@@ -112,23 +112,23 @@ function z = cumtrapz (x, y, dim)
 
 endfunction
 
 
 %!shared x1,x2,y
 %! x1 = [0,0,0;2,2,2];
 %! x2 = [0,2,4;0,2,4];
 %! y = [1,2,3;4,5,6];
-%!assert (cumtrapz(y), [0,0,0;2.5,3.5,4.5])
-%!assert (cumtrapz(x1,y), [0,0,0;5,7,9])
-%!assert (cumtrapz(y,1), [0,0,0;2.5,3.5,4.5])
-%!assert (cumtrapz(x1,y,1), [0,0,0;5,7,9])
-%!assert (cumtrapz(y,2), [0,1.5,4;0,4.5,10])
-%!assert (cumtrapz(x2,y,2), [0,3,8;0,9,20])
+%!assert (cumtrapz (y), [0,0,0;2.5,3.5,4.5])
+%!assert (cumtrapz (x1,y), [0,0,0;5,7,9])
+%!assert (cumtrapz (y,1), [0,0,0;2.5,3.5,4.5])
+%!assert (cumtrapz (x1,y,1), [0,0,0;5,7,9])
+%!assert (cumtrapz (y,2), [0,1.5,4;0,4.5,10])
+%!assert (cumtrapz (x2,y,2), [0,3,8;0,9,20])
 %% Test ND-array implementation
 %!shared x1,x2,y
 %! x1 = 1:3;
 %! x2 = reshape ([0,2,4;0,2,4], [1 2 3]);
 %! y = reshape ([1,2,3;4,5,6], [1 2 3]);
-%!assert (cumtrapz(y,3), reshape([0,1.5,4;0,4.5,10],[1 2 3]))
-%!assert (cumtrapz(x1,y,3), reshape([0,1.5,4;0,4.5,10],[1 2 3]))
-%!assert (cumtrapz(x2,y,3), reshape([0,3,8;0,9,20],[1 2 3]))
+%!assert (cumtrapz (y,3), reshape ([0,1.5,4;0,4.5,10],[1 2 3]))
+%!assert (cumtrapz (x1,y,3), reshape ([0,1.5,4;0,4.5,10],[1 2 3]))
+%!assert (cumtrapz (x2,y,3), reshape ([0,3,8;0,9,20],[1 2 3]))
 
diff --git a/scripts/general/curl.m b/scripts/general/curl.m
--- a/scripts/general/curl.m
+++ b/scripts/general/curl.m
@@ -124,19 +124,21 @@ function varargout = curl (varargin)
       varargout{2} = rot_y;
       varargout{3} = rot_z;
       varargout{4} = av;
     endif
   endif
 
 endfunction
 
+
 %!test
-%! [X,Y]=meshgrid(-20:20,-22:22);
-%! av = curl(2*(X-Y),Y);
-%! assert(all(av(:)==1));
-%! [cz,av] = curl(2*(X-Y),Y);
-%! assert(all(cz(:)==2));
-%! assert(all(av(:)==1));
-%! [cz,av] = curl(X/2,Y/2,2*(X-Y),Y);
-%! assert(all(cz(:)==4));
-%! assert(all(av(:)==2));
-%! assert(size_equal(X,Y,cz,av));
+%! [X,Y] = meshgrid (-20:20,-22:22);
+%! av = curl (2*(X-Y), Y);
+%! assert (all (av(:) == 1));
+%! [cz,av] = curl (2*(X-Y), Y);
+%! assert (all (cz(:) == 2));
+%! assert (all (av(:) == 1));
+%! [cz,av] = curl (X/2, Y/2, 2*(X-Y), Y);
+%! assert (all (cz(:) == 4));
+%! assert (all (av(:) == 2));
+%! assert (size_equal (X,Y,cz,av));
+
diff --git a/scripts/general/dblquad.m b/scripts/general/dblquad.m
--- a/scripts/general/dblquad.m
+++ b/scripts/general/dblquad.m
@@ -68,15 +68,16 @@ endfunction
 
 function q = __dblquad_inner__ (y, f, xa, xb, tol, quadf, varargin)
   q = zeros (size(y));
   for i = 1 : length (y)
     q(i) = feval (quadf, @(x) f(x, y(i), varargin{:}), xa, xb, tol);
   endfor
 endfunction
 
+
 %% Nasty integrand to show quadcc off
-%!assert (dblquad (@(x,y) 1 ./ (x+y), 0, 1, 0, 1), 2*log(2), 1e-6)
+%!assert (dblquad (@(x,y) 1 ./ (x+y), 0, 1, 0, 1), 2*log (2), 1e-6)
 
-%!assert (dblquad (@(x,y) exp(-x.^2 - y.^2) , -1, 1, -1, 1, 1e-6, @quadgk), pi * erf(1).^2, 1e-6)
-%!assert (dblquad (@(x,y) exp(-x.^2 - y.^2) , -1, 1, -1, 1, 1e-6, @quadl), pi * erf(1).^2, 1e-6)
-%!assert (dblquad (@(x,y) exp(-x.^2 - y.^2) , -1, 1, -1, 1, 1e-6, @quadv), pi * erf(1).^2, 1e-6)
+%!assert (dblquad (@(x,y) exp (-x.^2 - y.^2) , -1, 1, -1, 1, 1e-6, @quadgk), pi * erf (1).^2, 1e-6)
+%!assert (dblquad (@(x,y) exp (-x.^2 - y.^2) , -1, 1, -1, 1, 1e-6, @quadl), pi * erf (1).^2, 1e-6)
+%!assert (dblquad (@(x,y) exp (-x.^2 - y.^2) , -1, 1, -1, 1, 1e-6, @quadv), pi * erf (1).^2, 1e-6)
 
diff --git a/scripts/general/deal.m b/scripts/general/deal.m
--- a/scripts/general/deal.m
+++ b/scripts/general/deal.m
@@ -68,16 +68,18 @@ function [varargout] = deal (varargin)
   elseif (nargin == 1 || nargin == nargout)
     varargout(1:nargout) = varargin;
   else
     error ("deal: nargin > 1 and nargin != nargout");
   endif
 
 endfunction
 
+
 %!test
-%! [a,b]=deal(1,2);
-%! assert(a,1);
-%! assert(b,2);
+%! [a,b] = deal (1,2);
+%! assert (a, 1);
+%! assert (b, 2);
 %!test
-%! [a,b]=deal(1);
-%! assert(a,1);
-%! assert(b,1);
+%! [a,b] = deal (1);
+%! assert (a, 1);
+%! assert (b, 1);
+
diff --git a/scripts/general/divergence.m b/scripts/general/divergence.m
--- a/scripts/general/divergence.m
+++ b/scripts/general/divergence.m
@@ -100,13 +100,15 @@ function retval = divergence (varargin)
     ## y-direction
     retval += shiftdim (gradient (shiftdim (varargin{fidx + 1}, 2), dy), 1);
     ## z-direction
     retval += shiftdim (gradient (shiftdim (varargin{fidx + 2}, 1), dz), 2);
   endif
 
 endfunction
 
+
 %!test
-%! [X,Y]=meshgrid(-20:20,-22:22);
-%! div = divergence(X-Y,Y);
-%! assert(all(div(:)==2));
-%! assert(size_equal(X,Y,div));
+%! [X,Y] = meshgrid (-20:20,-22:22);
+%! div = divergence (X-Y,Y);
+%! assert (all (div(:) == 2));
+%! assert (size_equal (X,Y,div));
+
diff --git a/scripts/general/flipdim.m b/scripts/general/flipdim.m
--- a/scripts/general/flipdim.m
+++ b/scripts/general/flipdim.m
@@ -22,18 +22,18 @@
 ## @deftypefnx {Function File} {} flipdim (@var{x}, @var{dim})
 ## Return a copy of @var{x} flipped about the dimension @var{dim}.
 ## @var{dim} defaults to the first non-singleton dimension.
 ## For example:
 ##
 ## @example
 ## @group
 ## flipdim ([1, 2; 3, 4], 2)
-##      @result{}  2  1
-##          4  3
+##       @result{}  2  1
+##           4  3
 ## @end group
 ## @end example
 ## @seealso{fliplr, flipud, rot90, rotdim}
 ## @end deftypefn
 
 ## Author: David Bateman, Jaroslav Hajek
 
 function y = flipdim (x, dim)
@@ -52,16 +52,18 @@ function y = flipdim (x, dim)
   endif
 
   idx(1:max(nd, dim)) = {':'};
   idx{dim} = size (x, dim):-1:1;
   y = x(idx{:});
 
 endfunction
 
-%!error flipdim ();
-%!error flipdim (1, 2, 3);
 
-%!assert (flipdim ([1,2;3,4]), flipdim ([1,2 ; 3,4], 1));
-%!assert (flipdim ([1,2;3,4], 2), [2,1;4,3]);
-%!assert (flipdim ([1,2;3,4], 3), [1,2;3,4]);
+%!assert (flipdim ([1,2;3,4]), flipdim ([1,2 ; 3,4], 1))
+%!assert (flipdim ([1,2;3,4], 2), [2,1;4,3])
+%!assert (flipdim ([1,2;3,4], 3), [1,2;3,4])
 
 ## FIXME -- we need tests for multidimensional arrays.
+
+%!error flipdim ()
+%!error flipdim (1, 2, 3)
+
diff --git a/scripts/general/fliplr.m b/scripts/general/fliplr.m
--- a/scripts/general/fliplr.m
+++ b/scripts/general/fliplr.m
@@ -47,16 +47,16 @@ function y = fliplr (x)
     error ("fliplr: Only works with 2-D arrays");
   endif
 
   nc = columns (x);
   y = x (:, nc:-1:1);
 
 endfunction
 
-%!assert((fliplr ([1, 2; 3, 4]) == [2, 1; 4, 3]
-%! && fliplr ([1, 2; 3, 4; 5, 6]) == [2, 1; 4, 3; 6, 5]
-%! && fliplr ([1, 2, 3; 4, 5, 6]) == [3, 2, 1; 6, 5, 4]));
 
-%!error fliplr();
+%!assert (fliplr ([1, 2; 3, 4]), [2, 1; 4, 3])
+%!assert (fliplr ([1, 2; 3, 4; 5, 6]), [2, 1; 4, 3; 6, 5])
+%!assert (fliplr ([1, 2, 3; 4, 5, 6]), [3, 2, 1; 6, 5, 4])
 
-%!error fliplr (1, 2);
+%!error fliplr()
+%!error fliplr (1, 2)
 
diff --git a/scripts/general/flipud.m b/scripts/general/flipud.m
--- a/scripts/general/flipud.m
+++ b/scripts/general/flipud.m
@@ -47,16 +47,16 @@ function y = flipud (x)
     error ("flipud: Only works with 2-d arrays");
   endif
 
   nr = rows (x);
   y = x (nr:-1:1, :);
 
 endfunction
 
-%!assert((flipud ([1, 2; 3, 4]) == [3, 4; 1, 2]
-%! && flipud ([1, 2; 3, 4; 5, 6]) == [5, 6; 3, 4; 1, 2]
-%! && flipud ([1, 2, 3; 4, 5, 6]) == [4, 5, 6; 1, 2, 3]));
 
-%!error flipud ();
+%!assert (flipud ([1, 2; 3, 4]), [3, 4; 1, 2])
+%!assert (flipud ([1, 2; 3, 4; 5, 6]), [5, 6; 3, 4; 1, 2])
+%!assert (flipud ([1, 2, 3; 4, 5, 6]), [4, 5, 6; 1, 2, 3])
 
-%!error flipud (1, 2);
+%!error flipud ()
+%!error flipud (1, 2)
 
diff --git a/scripts/general/genvarname.m b/scripts/general/genvarname.m
--- a/scripts/general/genvarname.m
+++ b/scripts/general/genvarname.m
@@ -25,61 +25,60 @@
 ##
 ## If @var{str} is a cellstr, then a unique variable is created for each
 ## cell in @var{str}.
 ##
 ## @example
 ## @group
 ## x = 3.141;
 ## genvarname ("x", who ())
-## @result{} x1
+##   @result{} x1
 ## @end group
 ## @end example
 ##
 ## If @var{wanted} is a cell array, genvarname will make sure the returned
 ## strings are distinct:
 ##
 ## @example
 ## @group
 ## genvarname (@{"foo", "foo"@})
-## @result{}
-## @{
-##   [1,1] = foo
-##   [1,2] = foo1
-## @}
+##   @result{}
+##      @{
+##        [1,1] = foo
+##        [1,2] = foo1
+##      @}
 ## @end group
 ## @end example
 ##
 ## Note that the result is a char array/cell array of strings, not the
 ## variables themselves.  To define a variable, @code{eval()} can be
 ## used.  The following trivial example sets @code{x} to @code{42}.
 ##
 ## @example
 ## @group
 ## name = genvarname ("x");
-## eval([name " = 42"]);
-## @result{} x =  42
+## eval ([name " = 42"]);
+##   @result{} x =  42
 ## @end group
 ## @end example
 ##
 ## Also, this can be useful for creating unique struct field names.
 ##
 ## @example
 ## @group
 ## x = struct ();
 ## for i = 1:3
 ##   x.(genvarname ("a", fieldnames (x))) = i;
 ## endfor
-## @result{}
-## x =
-## @{
-##   a =  1
-##   a1 =  2
-##   a2 =  3
-## @}
+##   @result{} x =
+##      @{
+##        a =  1
+##        a1 =  2
+##        a2 =  3
+##      @}
 ## @end group
 ## @end example
 ##
 ## Since variable names may only contain letters, digits and underscores,
 ## genvarname replaces any sequence of disallowed characters with
 ## an underscore.  Also, variables may not begin with a digit; in this
 ## case an underscore is added before the variable name.
 ##
@@ -168,42 +167,43 @@ function varname = genvarname (str, excl
   endfor
 
   if strinput
     varname = varname{1};
   endif
 
 endfunction
 
-## Tests
+
 ## a single argument
-%!assert(genvarname("a"), "a")
+%!assert (genvarname ("a"), "a")
 ## a single argument with a non-conflicting exception
-%!assert(genvarname("a", "b"), "a")
+%!assert (genvarname ("a", "b"), "a")
 ## a single argument with a conflicting exception
-%!assert(genvarname("a", "a"), "a1")
+%!assert (genvarname ("a", "a"), "a1")
 ## a single argument as a cell
-%!assert(genvarname({"a"}), {"a"})
-%!assert(genvarname({"a"}, "b"), {"a"})
-%!assert(genvarname({"a"}, {"b"}), {"a"})
-%!assert(genvarname({"a"}, "a"), {"a1"})
-%!assert(genvarname({"a"}, {"a"}), {"a1"})
+%!assert (genvarname ({"a"}), {"a"})
+%!assert (genvarname ({"a"}, "b"), {"a"})
+%!assert (genvarname ({"a"}, {"b"}), {"a"})
+%!assert (genvarname ({"a"}, "a"), {"a1"})
+%!assert (genvarname ({"a"}, {"a"}), {"a1"})
 ## Test different arguments
 ## orientation
-%!assert(genvarname({"a" "b"}), {"a" "b"})
-%!assert(genvarname({"a";"b"}), {"a";"b"})
-%!assert(genvarname({"a" "a"}), {"a" "a1"})
-%!assert(genvarname({"a" "b";"c" "d"}), {"a" "b";"c" "d"})
-%!assert(genvarname({"a" "a" "a";"a" "a" "a"}), {"a" "a2" "a4";"a1" "a3" "a5"})
+%!assert (genvarname ({"a" "b"}), {"a" "b"})
+%!assert (genvarname ({"a";"b"}), {"a";"b"})
+%!assert (genvarname ({"a" "a"}), {"a" "a1"})
+%!assert (genvarname ({"a" "b";"c" "d"}), {"a" "b";"c" "d"})
+%!assert (genvarname ({"a" "a" "a";"a" "a" "a"}), {"a" "a2" "a4";"a1" "a3" "a5"})
 ## more than one repetition
-%!assert(genvarname({"a" "a" "a"}), {"a" "a1" "a2"})
-%!assert(genvarname({"a" "a" "a"}, {"a" "a1" "a2"}), {"a3" "a4" "a5"})
+%!assert (genvarname ({"a" "a" "a"}), {"a" "a1" "a2"})
+%!assert (genvarname ({"a" "a" "a"}, {"a" "a1" "a2"}), {"a3" "a4" "a5"})
 ## more than one repetition not in order
-%!assert(genvarname({"a" "b" "a" "b" "a"}), {"a" "b" "a1" "b1" "a2"})
+%!assert (genvarname ({"a" "b" "a" "b" "a"}), {"a" "b" "a1" "b1" "a2"})
 ## Variable name munging
 %!assert (genvarname ("__x__"), "_x_")
 %!assert (genvarname ("123456789"), "_123456789")
 %!assert (genvarname ("_$1__"), "_1_")
 %!assert (genvarname ("__foo__", "_foo_"), "_foo_1")
 %!assert (genvarname ("1million_and1", "_1million_and1"), "_1million_and1_1")
 %!assert (genvarname ({"", "", ""}), {"x", "x1", "x2"})
 %!assert (genvarname ("if"), "_if")
 %!assert (genvarname ({"if", "if", "if"}), {"_if", "_if1", "_if2"})
+
diff --git a/scripts/general/gradient.m b/scripts/general/gradient.m
--- a/scripts/general/gradient.m
+++ b/scripts/general/gradient.m
@@ -215,81 +215,82 @@ function varargout = handle_gradient (f,
     if (dim == 1)
       varargout{d} = reshape (df_dx, p0_size);
     else
       varargout{d} = df_dx;
     endif
   endfor
 endfunction
 
+
 %!test
 %! data = [1, 2, 4, 2];
 %! dx = gradient (data);
 %! dx2 = gradient (data, 0.25);
 %! dx3 = gradient (data, [0.25, 0.5, 1, 3]);
 %! assert (dx, [1, 3/2, 0, -2]);
 %! assert (dx2, [4, 6, 0, -8]);
 %! assert (dx3, [4, 4, 0, -1]);
-%! assert (size_equal(data, dx));
+%! assert (size_equal (data, dx));
 
 %!test
 %! [Y,X,Z,U] = ndgrid (2:2:8,1:5,4:4:12,3:5:30);
 %! [dX,dY,dZ,dU] = gradient (X);
-%! assert (all(dX(:)==1));
-%! assert (all(dY(:)==0));
-%! assert (all(dZ(:)==0));
-%! assert (all(dU(:)==0));
+%! assert (all (dX(:) == 1));
+%! assert (all (dY(:) == 0));
+%! assert (all (dZ(:) == 0));
+%! assert (all (dU(:) == 0));
 %! [dX,dY,dZ,dU] = gradient (Y);
-%! assert (all(dX(:)==0));
-%! assert (all(dY(:)==2));
-%! assert (all(dZ(:)==0));
-%! assert (all(dU(:)==0));
+%! assert (all (dX(:) == 0));
+%! assert (all (dY(:) == 2));
+%! assert (all (dZ(:) == 0));
+%! assert (all (dU(:) == 0));
 %! [dX,dY,dZ,dU] = gradient (Z);
-%! assert (all(dX(:)==0));
-%! assert (all(dY(:)==0));
-%! assert (all(dZ(:)==4));
-%! assert (all(dU(:)==0));
+%! assert (all (dX(:) == 0));
+%! assert (all (dY(:) == 0));
+%! assert (all (dZ(:) == 4));
+%! assert (all (dU(:) == 0));
 %! [dX,dY,dZ,dU] = gradient (U);
-%! assert (all(dX(:)==0));
-%! assert (all(dY(:)==0));
-%! assert (all(dZ(:)==0));
-%! assert (all(dU(:)==5));
-%! assert (size_equal(dX, dY, dZ, dU, X, Y, Z, U));
+%! assert (all (dX(:) == 0));
+%! assert (all (dY(:) == 0));
+%! assert (all (dZ(:) == 0));
+%! assert (all (dU(:) == 5));
+%! assert (size_equal (dX, dY, dZ, dU, X, Y, Z, U));
 %! [dX,dY,dZ,dU] = gradient (U, 5.0);
-%! assert (all(dU(:)==1));
+%! assert (all (dU(:) == 1));
 %! [dX,dY,dZ,dU] = gradient (U, 1.0, 2.0, 3.0, 2.5);
-%! assert (all(dU(:)==2));
+%! assert (all (dU(:) == 2));
 
 %!test
 %! [Y,X,Z,U] = ndgrid (2:2:8,1:5,4:4:12,3:5:30);
 %! [dX,dY,dZ,dU] = gradient (X+j*X);
-%! assert (all(dX(:)==1+1j));
-%! assert (all(dY(:)==0));
-%! assert (all(dZ(:)==0));
-%! assert (all(dU(:)==0));
+%! assert (all (dX(:) == 1+1j));
+%! assert (all (dY(:) == 0));
+%! assert (all (dZ(:) == 0));
+%! assert (all (dU(:) == 0));
 %! [dX,dY,dZ,dU] = gradient (Y-j*Y);
-%! assert (all(dX(:)==0));
-%! assert (all(dY(:)==2-j*2));
-%! assert (all(dZ(:)==0));
-%! assert (all(dU(:)==0));
+%! assert (all (dX(:) == 0));
+%! assert (all (dY(:) == 2-j*2));
+%! assert (all (dZ(:) == 0));
+%! assert (all (dU(:) == 0));
 %! [dX,dY,dZ,dU] = gradient (Z+j*1);
-%! assert (all(dX(:)==0));
-%! assert (all(dY(:)==0));
-%! assert (all(dZ(:)==4));
-%! assert (all(dU(:)==0));
+%! assert (all (dX(:) == 0));
+%! assert (all (dY(:) == 0));
+%! assert (all (dZ(:) == 4));
+%! assert (all (dU(:) == 0));
 %! [dX,dY,dZ,dU] = gradient (U-j*1);
-%! assert (all(dX(:)==0));
-%! assert (all(dY(:)==0));
-%! assert (all(dZ(:)==0));
-%! assert (all(dU(:)==5));
+%! assert (all (dX(:) == 0));
+%! assert (all (dY(:) == 0));
+%! assert (all (dZ(:) == 0));
+%! assert (all (dU(:) == 5));
 %! assert (size_equal(dX, dY, dZ, dU, X, Y, Z, U));
 %! [dX,dY,dZ,dU] = gradient (U, 5.0);
-%! assert (all(dU(:)==1));
+%! assert (all (dU(:) == 1));
 %! [dX,dY,dZ,dU] = gradient (U, 1.0, 2.0, 3.0, 2.5);
-%! assert (all(dU(:)==2));
+%! assert (all (dU(:) == 2));
 
 %!test
 %! x = 0:10;
 %! f = @cos;
 %! df_dx = @(x) -sin (x);
 %! assert (gradient (f, x), df_dx (x), 0.2);
 %! assert (gradient (f, x, 0.5), df_dx (x), 0.1);
 
diff --git a/scripts/general/idivide.m b/scripts/general/idivide.m
--- a/scripts/general/idivide.m
+++ b/scripts/general/idivide.m
@@ -47,23 +47,23 @@
 ##
 ## @noindent
 ## If @var{op} is not given it defaults to @code{"fix"}.
 ## An example demonstrating these rounding rules is
 ##
 ## @example
 ## @group
 ## idivide (int8 ([-3, 3]), int8 (4), "fix")
-## @result{} int8 ([0, 0])
+##   @result{} int8 ([0, 0])
 ## idivide (int8 ([-3, 3]), int8 (4), "round")
-## @result{} int8 ([-1, 1])
+##   @result{} int8 ([-1, 1])
 ## idivide (int8 ([-3, 3]), int8 (4), "floor")
-## @result{} int8 ([-1, 0])
+##   @result{} int8 ([-1, 0])
 ## idivide (int8 ([-3, 3]), int8 (4), "ceil")
-## @result{} int8 ([0, 1])
+##   @result{} int8 ([0, 1])
 ## @end group
 ## @end example
 ##
 ## @seealso{ldivide, rdivide}
 ## @end deftypefn
 
 function z = idivide (x, y, op)
   if (nargin < 2 || nargin > 3)
@@ -95,30 +95,32 @@ function z = idivide (x, y, op)
     elseif (strcmp (op, "ceil"))
       z = cast (ceil (double (x) ./ double (y)), typ);
     else
       error ("idivide: unrecognized rounding type");
     endif
   endif
 endfunction
 
+
 %!shared a, af, b, bf
-%! a = int8(3);
+%! a = int8 (3);
 %! af = 3;
-%! b = int8([-4, 4]);
+%! b = int8 ([-4, 4]);
 %! bf = [-4, 4];
 
 %!assert (idivide (a, b), int8 ([0, 0]))
-%!assert (idivide (a, b, "floor"), int8([-1, 0]))
+%!assert (idivide (a, b, "floor"), int8 ([-1, 0]))
 %!assert (idivide (a, b, "ceil"), int8 ([0, 1]))
 %!assert (idivide (a, b, "round"), int8 ([-1, 1]))
 
 %!assert (idivide (af, b), int8 ([0, 0]))
-%!assert (idivide (af, b, "floor"), int8([-1, 0]))
+%!assert (idivide (af, b, "floor"), int8 ([-1, 0]))
 %!assert (idivide (af, b, "ceil"), int8 ([0, 1]))
 %!assert (idivide (af, b, "round"), int8 ([-1, 1]))
 
 %!assert (idivide (a, bf), int8 ([0, 0]))
-%!assert (idivide (a, bf, "floor"), int8([-1, 0]))
+%!assert (idivide (a, bf, "floor"), int8 ([-1, 0]))
 %!assert (idivide (a, bf, "ceil"), int8 ([0, 1]))
 %!assert (idivide (a, bf, "round"), int8 ([-1, 1]))
 
-%!error (idivide (uint8(1), int8(1)))
+%!error (idivide (uint8 (1), int8 (1)))
+
diff --git a/scripts/general/int2str.m b/scripts/general/int2str.m
--- a/scripts/general/int2str.m
+++ b/scripts/general/int2str.m
@@ -18,17 +18,16 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} int2str (@var{n})
 ## Convert an integer (or array of integers) to a string (or a character
 ## array).
 ##
 ## @example
 ## @group
-##
 ## int2str (123)
 ##      @result{} "123"
 ##
 ## s = int2str ([1, 2, 3; 4, 5, 6])
 ##      @result{} s =
 ##         1  2  3
 ##         4  5  6
 ##
@@ -109,15 +108,17 @@ function fmt = get_fmt (x, sep)
         fw++;
       endif
       fmt = sprintf ("%%%dd", max (fw, min_fw));
     endif
   endif
 
 endfunction
 
-%!assert (strcmp (int2str (-123), "-123") && strcmp (int2str (1.2), "1"));
-%!assert (all (int2str ([1, 2, 3; 4, 5, 6]) == ["1  2  3";"4  5  6"]));
-%!assert (int2str([]), "");
 
-%!error int2str ();
-%!error int2str (1, 2);
+%!assert (int2str (-123), "-123")
+%!assert (int2str (1.2), "1")
+%!assert (int2str ([1, 2, 3; 4, 5, 6]), ["1  2  3";"4  5  6"])
+%!assert (int2str ([]), "")
 
+%!error int2str ()
+%!error int2str (1, 2)
+
diff --git a/scripts/general/interp1.m b/scripts/general/interp1.m
--- a/scripts/general/interp1.m
+++ b/scripts/general/interp1.m
@@ -17,59 +17,59 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{yi} =} interp1 (@var{x}, @var{y}, @var{xi})
 ## @deftypefnx {Function File} {@var{yi} =} interp1 (@var{y}, @var{xi})
 ## @deftypefnx {Function File} {@var{yi} =} interp1 (@dots{}, @var{method})
 ## @deftypefnx {Function File} {@var{yi} =} interp1 (@dots{}, @var{extrap})
-## @deftypefnx {Function File} {@var{pp} =} interp1 (@dots{}, 'pp')
+## @deftypefnx {Function File} {@var{pp} =} interp1 (@dots{}, "pp")
 ##
 ## One-dimensional interpolation.  Interpolate @var{y}, defined at the
 ## points @var{x}, at the points @var{xi}.  The sample points @var{x}
 ## must be monotonic.  If not specified, @var{x} is taken to be the
 ## indices of @var{y}.  If @var{y} is an array, treat the columns
 ## of @var{y} separately.
 ##
 ## Method is one of:
 ##
 ## @table @asis
-## @item 'nearest'
+## @item "nearest"
 ## Return the nearest neighbor.
 ##
-## @item 'linear'
+## @item "linear"
 ## Linear interpolation from nearest neighbors
 ##
-## @item 'pchip'
+## @item "pchip"
 ## Piecewise cubic Hermite interpolating polynomial
 ##
-## @item 'cubic'
+## @item "cubic"
 ## Cubic interpolation (same as @code{pchip})
 ##
-## @item 'spline'
+## @item "spline"
 ## Cubic spline interpolation---smooth first and second derivatives
 ## throughout the curve
 ## @end table
 ##
 ## Appending '*' to the start of the above method forces @code{interp1}
 ## to assume that @var{x} is uniformly spaced, and only @code{@var{x}
 ## (1)} and @code{@var{x} (2)} are referenced.  This is usually faster,
-## and is never slower.  The default method is 'linear'.
+## and is never slower.  The default method is "linear".
 ##
-## If @var{extrap} is the string 'extrap', then extrapolate values beyond
+## If @var{extrap} is the string "extrap", then extrapolate values beyond
 ## the endpoints.  If @var{extrap} is a number, replace values beyond the
 ## endpoints with that number.  If @var{extrap} is missing, assume NA.
 ##
-## If the string argument 'pp' is specified, then @var{xi} should not be
+## If the string argument "pp" is specified, then @var{xi} should not be
 ## supplied and @code{interp1} returns the piecewise polynomial that
 ## can later be used with @code{ppval} to evaluate the interpolation.
 ## There is an equivalence, such that @code{ppval (interp1 (@var{x},
-## @var{y}, @var{method}, 'pp'), @var{xi}) == interp1 (@var{x}, @var{y},
-## @var{xi}, @var{method}, 'extrap')}.
+## @var{y}, @var{method}, "pp"), @var{xi}) == interp1 (@var{x}, @var{y},
+## @var{xi}, @var{method}, "extrap")}.
 ##
 ## Duplicate points in @var{x} specify a discontinuous interpolant.  There
 ## should be at most 2 consecutive points with the same value.
 ## The discontinuous interpolant is right-continuous if @var{x} is increasing,
 ## left-continuous if it is decreasing.
 ## Discontinuities are (currently) only allowed for "nearest" and "linear"
 ## methods; in all other cases, @var{x} must be strictly monotonic.
 ##
@@ -82,17 +82,17 @@
 ## xp = [0:10];
 ## yp = sin (2*pi*xp/5);
 ## lin = interp1 (xp, yp, xf);
 ## spl = interp1 (xp, yp, xf, "spline");
 ## cub = interp1 (xp, yp, xf, "cubic");
 ## near = interp1 (xp, yp, xf, "nearest");
 ## plot (xf, yf, "r", xf, lin, "g", xf, spl, "b",
 ##       xf, cub, "c", xf, near, "m", xp, yp, "r*");
-## legend ("original", "linear", "spline", "cubic", "nearest")
+## legend ("original", "linear", "spline", "cubic", "nearest");
 ## @end group
 ## @end example
 ##
 ## @seealso{interpft}
 ## @end deftypefn
 
 ## Author: Paul Kienzle
 ## Date: 2000-03-25
@@ -296,31 +296,31 @@ function yi = interp1 (x, y, varargin)
     yi.orient = "first";
   endif
 
 endfunction
 
 
 %!demo
 %! clf;
-%! xf = 0:0.05:10; yf = sin (2*pi*xf/5);
-%! xp = 0:10;      yp = sin (2*pi*xp/5);
+%! xf = 0:0.05:10;  yf = sin (2*pi*xf/5);
+%! xp = 0:10;       yp = sin (2*pi*xp/5);
 %! lin = interp1 (xp,yp,xf, "linear");
 %! spl = interp1 (xp,yp,xf, "spline");
 %! cub = interp1 (xp,yp,xf, "pchip");
 %! near= interp1 (xp,yp,xf, "nearest");
 %! plot (xf,yf,"r",xf,near,"g",xf,lin,"b",xf,cub,"c",xf,spl,"m",xp,yp,"r*");
 %! legend ("original", "nearest", "linear", "pchip", "spline");
 %! %--------------------------------------------------------
 %! % confirm that interpolated function matches the original
 
 %!demo
 %! clf;
-%! xf = 0:0.05:10; yf = sin (2*pi*xf/5);
-%! xp = 0:10;      yp = sin (2*pi*xp/5);
+%! xf = 0:0.05:10;  yf = sin (2*pi*xf/5);
+%! xp = 0:10;       yp = sin (2*pi*xp/5);
 %! lin = interp1 (xp,yp,xf, "*linear");
 %! spl = interp1 (xp,yp,xf, "*spline");
 %! cub = interp1 (xp,yp,xf, "*cubic");
 %! near= interp1 (xp,yp,xf, "*nearest");
 %! plot (xf,yf,"r",xf,near,"g",xf,lin,"b",xf,cub,"c",xf,spl,"m",xp,yp,"r*");
 %! legend ("*original", "*nearest", "*linear", "*cubic", "*spline");
 %! %--------------------------------------------------------
 %! % confirm that interpolated function matches the original
@@ -335,30 +335,30 @@ endfunction
 %! ddys = diff (diff (interp1 (t,y,ti, "spline"))./dti)./dti;
 %! ddyp = diff (diff (interp1 (t,y,ti, "pchip")) ./dti)./dti;
 %! plot (ti(2:end-1),ddyc,'g+', ti(2:end-1),ddys,'b*', ti(2:end-1),ddyp,'c^');
 %! legend ("cubic", "spline", "pchip");
 %! title ("Second derivative of interpolated 'sin (4*t + 0.3) .* cos (3*t - 0.1)'");
 
 %!demo
 %! clf;
-%! xf = 0:0.05:10;               yf = sin (2*pi*xf/5) - (xf >= 5);
-%! xp = [0:.5:4.5,4.99,5:.5:10]; yp = sin (2*pi*xp/5) - (xp >= 5);
+%! xf = 0:0.05:10;                yf = sin (2*pi*xf/5) - (xf >= 5);
+%! xp = [0:.5:4.5,4.99,5:.5:10];  yp = sin (2*pi*xp/5) - (xp >= 5);
 %! lin = interp1 (xp,yp,xf, "linear");
 %! near= interp1 (xp,yp,xf, "nearest");
 %! plot (xf,yf,"r", xf,near,"g", xf,lin,"b", xp,yp,"r*");
 %! legend ("original", "nearest", "linear");
 %! %--------------------------------------------------------
 %! % confirm that interpolated function matches the original
 
 ##FIXME: add test for n-d arguments here
 
 ## For each type of interpolated test, confirm that the interpolated
 ## value at the knots match the values at the knots.  Points away
-## from the knots are requested, but only 'nearest' and 'linear'
+## from the knots are requested, but only "nearest" and "linear"
 ## confirm they are the correct values.
 
 %!shared xp, yp, xi, style
 %! xp = 0:2:10;
 %! yp = sin (2*pi*xp/5);
 %! xi = [-1, 0, 2.2, 4, 6.6, 10, 11];
 
 ## The following BLOCK/ENDBLOCK section is repeated for each style
@@ -367,209 +367,210 @@ endfunction
 ## the tests are identical.
 ## Note that the block checks style and *style; if you add more tests
 ## be sure to add them to both sections of each block.  One test,
 ## style vs. *style, occurs only in the first section.
 ## There is an ENDBLOCKTEST after the final block
 
 %!test style = "nearest";
 ## BLOCK
-%!assert (interp1(xp, yp, [min(xp)-1, max(xp)+1],style), [NA, NA]);
-%!assert (interp1(xp,yp,xp,style), yp, 100*eps);
-%!assert (interp1(xp,yp,xp',style), yp', 100*eps);
-%!assert (interp1(xp',yp',xp',style), yp', 100*eps);
-%!assert (interp1(xp',yp',xp,style), yp, 100*eps);
-%!assert (isempty(interp1(xp',yp',[],style)));
-%!assert (isempty(interp1(xp,yp,[],style)));
-%!assert (interp1(xp,[yp',yp'],xi(:),style),...
-%!        [interp1(xp,yp,xi(:),style),interp1(xp,yp,xi(:),style)]);
-%!assert (interp1(xp,yp,xi,style),...
-%!        interp1(fliplr(xp),fliplr(yp),xi,style),100*eps);
-%!assert (ppval(interp1(xp,yp,style,"pp"),xi),
-%!        interp1(xp,yp,xi,style,"extrap"),10*eps);
-%!error interp1(1,1,1, style);
-%!assert (interp1(xp,[yp',yp'],xi,style),
-%!        interp1(xp,[yp',yp'],xi,["*",style]),100*eps);
-%!test style=['*',style];
-%!assert (interp1(xp, yp, [min(xp)-1, max(xp)+1],style), [NA, NA]);
-%!assert (interp1(xp,yp,xp,style), yp, 100*eps);
-%!assert (interp1(xp,yp,xp',style), yp', 100*eps);
-%!assert (interp1(xp',yp',xp',style), yp', 100*eps);
-%!assert (interp1(xp',yp',xp,style), yp, 100*eps);
-%!assert (isempty(interp1(xp',yp',[],style)));
-%!assert (isempty(interp1(xp,yp,[],style)));
-%!assert (interp1(xp,[yp',yp'],xi(:),style),...
-%!        [interp1(xp,yp,xi(:),style),interp1(xp,yp,xi(:),style)]);
-%!assert (interp1(xp,yp,xi,style),...
-%!        interp1(fliplr(xp),fliplr(yp),xi,style),100*eps);
-%!assert (ppval(interp1(xp,yp,style,"pp"),xi),
-%!        interp1(xp,yp,xi,style,"extrap"),10*eps);
-%!error interp1(1,1,1, style);
+%!assert (interp1 (xp, yp, [min(xp)-1, max(xp)+1],style), [NA, NA])
+%!assert (interp1 (xp,yp,xp,style), yp, 100*eps)
+%!assert (interp1 (xp,yp,xp',style), yp', 100*eps)
+%!assert (interp1 (xp',yp',xp',style), yp', 100*eps)
+%!assert (interp1 (xp',yp',xp,style), yp, 100*eps)
+%!assert (isempty (interp1 (xp',yp',[],style)))
+%!assert (isempty (interp1 (xp,yp,[],style)))
+%!assert (interp1 (xp,[yp',yp'],xi(:),style),...
+%!        [interp1(xp,yp,xi(:),style),interp1(xp,yp,xi(:),style)])
+%!assert (interp1 (xp,yp,xi,style),...
+%!        interp1 (fliplr (xp),fliplr (yp),xi,style),100*eps)
+%!assert (ppval (interp1 (xp,yp,style,"pp"),xi),
+%!        interp1 (xp,yp,xi,style,"extrap"),10*eps)
+%!error interp1 (1,1,1, style)
+%!assert (interp1 (xp,[yp',yp'],xi,style),
+%!        interp1 (xp,[yp',yp'],xi,["*",style]),100*eps)
+%!test style = ["*",style];
+%!assert (interp1 (xp, yp, [min(xp)-1, max(xp)+1],style), [NA, NA])
+%!assert (interp1 (xp,yp,xp,style), yp, 100*eps)
+%!assert (interp1 (xp,yp,xp',style), yp', 100*eps)
+%!assert (interp1 (xp',yp',xp',style), yp', 100*eps)
+%!assert (interp1 (xp',yp',xp,style), yp, 100*eps)
+%!assert (isempty (interp1 (xp',yp',[],style)))
+%!assert (isempty (interp1 (xp,yp,[],style)))
+%!assert (interp1 (xp,[yp',yp'],xi(:),style),...
+%!        [interp1(xp,yp,xi(:),style),interp1(xp,yp,xi(:),style)])
+%!assert (interp1 (xp,yp,xi,style),...
+%!        interp1 (fliplr (xp),fliplr (yp),xi,style),100*eps)
+%!assert (ppval (interp1 (xp,yp,style,"pp"),xi),
+%!        interp1 (xp,yp,xi,style,"extrap"),10*eps)
+%!error interp1 (1,1,1, style)
 ## ENDBLOCK
 
-%!test style='linear';
+%!test style = "linear";
 ## BLOCK
-%!assert (interp1(xp, yp, [min(xp)-1, max(xp)+1],style), [NA, NA]);
-%!assert (interp1(xp,yp,xp,style), yp, 100*eps);
-%!assert (interp1(xp,yp,xp',style), yp', 100*eps);
-%!assert (interp1(xp',yp',xp',style), yp', 100*eps);
-%!assert (interp1(xp',yp',xp,style), yp, 100*eps);
-%!assert (isempty(interp1(xp',yp',[],style)));
-%!assert (isempty(interp1(xp,yp,[],style)));
-%!assert (interp1(xp,[yp',yp'],xi(:),style),...
-%!        [interp1(xp,yp,xi(:),style),interp1(xp,yp,xi(:),style)]);
-%!assert (interp1(xp,yp,xi,style),...
-%!        interp1(fliplr(xp),fliplr(yp),xi,style),100*eps);
-%!assert (ppval(interp1(xp,yp,style,"pp"),xi),
-%!        interp1(xp,yp,xi,style,"extrap"),10*eps);
-%!error interp1(1,1,1, style);
-%!assert (interp1(xp,[yp',yp'],xi,style),
-%!        interp1(xp,[yp',yp'],xi,["*",style]),100*eps);
-%!test style=['*',style];
-%!assert (interp1(xp, yp, [min(xp)-1, max(xp)+1],style), [NA, NA]);
-%!assert (interp1(xp,yp,xp,style), yp, 100*eps);
-%!assert (interp1(xp,yp,xp',style), yp', 100*eps);
-%!assert (interp1(xp',yp',xp',style), yp', 100*eps);
-%!assert (interp1(xp',yp',xp,style), yp, 100*eps);
-%!assert (isempty(interp1(xp',yp',[],style)));
-%!assert (isempty(interp1(xp,yp,[],style)));
-%!assert (interp1(xp,[yp',yp'],xi(:),style),...
-%!        [interp1(xp,yp,xi(:),style),interp1(xp,yp,xi(:),style)]);
-%!assert (interp1(xp,yp,xi,style),...
-%!        interp1(fliplr(xp),fliplr(yp),xi,style),100*eps);
-%!assert (ppval(interp1(xp,yp,style,"pp"),xi),
-%!        interp1(xp,yp,xi,style,"extrap"),10*eps);
-%!error interp1(1,1,1, style);
+%!assert (interp1 (xp, yp, [min(xp)-1, max(xp)+1],style), [NA, NA])
+%!assert (interp1 (xp,yp,xp,style), yp, 100*eps)
+%!assert (interp1 (xp,yp,xp',style), yp', 100*eps)
+%!assert (interp1 (xp',yp',xp',style), yp', 100*eps)
+%!assert (interp1 (xp',yp',xp,style), yp, 100*eps)
+%!assert (isempty (interp1 (xp',yp',[],style)))
+%!assert (isempty (interp1 (xp,yp,[],style)))
+%!assert (interp1 (xp,[yp',yp'],xi(:),style),...
+%!        [interp1(xp,yp,xi(:),style),interp1(xp,yp,xi(:),style)])
+%!assert (interp1 (xp,yp,xi,style),...
+%!        interp1 (fliplr (xp),fliplr (yp),xi,style),100*eps)
+%!assert (ppval (interp1 (xp,yp,style,"pp"),xi),
+%!        interp1 (xp,yp,xi,style,"extrap"),10*eps)
+%!error interp1 (1,1,1, style)
+%!assert (interp1 (xp,[yp',yp'],xi,style),
+%!        interp1 (xp,[yp',yp'],xi,["*",style]),100*eps)
+%!test style = ['*',style];
+%!assert (interp1 (xp, yp, [min(xp)-1, max(xp)+1],style), [NA, NA])
+%!assert (interp1 (xp,yp,xp,style), yp, 100*eps)
+%!assert (interp1 (xp,yp,xp',style), yp', 100*eps)
+%!assert (interp1 (xp',yp',xp',style), yp', 100*eps)
+%!assert (interp1 (xp',yp',xp,style), yp, 100*eps)
+%!assert (isempty (interp1 (xp',yp',[],style)))
+%!assert (isempty (interp1 (xp,yp,[],style)))
+%!assert (interp1 (xp,[yp',yp'],xi(:),style),...
+%!        [interp1(xp,yp,xi(:),style),interp1(xp,yp,xi(:),style)])
+%!assert (interp1 (xp,yp,xi,style),...
+%!        interp1 (fliplr (xp),fliplr (yp),xi,style),100*eps)
+%!assert (ppval (interp1 (xp,yp,style,"pp"),xi),
+%!        interp1 (xp,yp,xi,style,"extrap"),10*eps)
+%!error interp1 (1,1,1, style)
 ## ENDBLOCK
 
-%!test style='cubic';
+%!test style = "cubic";
 ## BLOCK
-%!assert (interp1(xp, yp, [min(xp)-1, max(xp)+1],style), [NA, NA]);
-%!assert (interp1(xp,yp,xp,style), yp, 100*eps);
-%!assert (interp1(xp,yp,xp',style), yp', 100*eps);
-%!assert (interp1(xp',yp',xp',style), yp', 100*eps);
-%!assert (interp1(xp',yp',xp,style), yp, 100*eps);
-%!assert (isempty(interp1(xp',yp',[],style)));
-%!assert (isempty(interp1(xp,yp,[],style)));
-%!assert (interp1(xp,[yp',yp'],xi(:),style),...
-%!        [interp1(xp,yp,xi(:),style),interp1(xp,yp,xi(:),style)]);
-%!assert (interp1(xp,yp,xi,style),...
-%!        interp1(fliplr(xp),fliplr(yp),xi,style),100*eps);
-%!assert (ppval(interp1(xp,yp,style,"pp"),xi),
-%!        interp1(xp,yp,xi,style,"extrap"),100*eps);
-%!error interp1(1,1,1, style);
-%!assert (interp1(xp,[yp',yp'],xi,style),
-%!        interp1(xp,[yp',yp'],xi,["*",style]),100*eps);
-%!test style=['*',style];
-%!assert (interp1(xp, yp, [min(xp)-1, max(xp)+1],style), [NA, NA]);
-%!assert (interp1(xp,yp,xp,style), yp, 100*eps);
-%!assert (interp1(xp,yp,xp',style), yp', 100*eps);
-%!assert (interp1(xp',yp',xp',style), yp', 100*eps);
-%!assert (interp1(xp',yp',xp,style), yp, 100*eps);
-%!assert (isempty(interp1(xp',yp',[],style)));
-%!assert (isempty(interp1(xp,yp,[],style)));
-%!assert (interp1(xp,[yp',yp'],xi(:),style),...
-%!        [interp1(xp,yp,xi(:),style),interp1(xp,yp,xi(:),style)]);
-%!assert (interp1(xp,yp,xi,style),...
-%!        interp1(fliplr(xp),fliplr(yp),xi,style),100*eps);
-%!assert (ppval(interp1(xp,yp,style,"pp"),xi),
-%!        interp1(xp,yp,xi,style,"extrap"),100*eps);
-%!error interp1(1,1,1, style);
+%!assert (interp1 (xp, yp, [min(xp)-1, max(xp)+1],style), [NA, NA])
+%!assert (interp1 (xp,yp,xp,style), yp, 100*eps)
+%!assert (interp1 (xp,yp,xp',style), yp', 100*eps)
+%!assert (interp1 (xp',yp',xp',style), yp', 100*eps)
+%!assert (interp1 (xp',yp',xp,style), yp, 100*eps)
+%!assert (isempty (interp1 (xp',yp',[],style)))
+%!assert (isempty (interp1 (xp,yp,[],style)))
+%!assert (interp1 (xp,[yp',yp'],xi(:),style),...
+%!        [interp1(xp,yp,xi(:),style),interp1(xp,yp,xi(:),style)])
+%!assert (interp1 (xp,yp,xi,style),...
+%!        interp1 (fliplr (xp),fliplr (yp),xi,style),100*eps)
+%!assert (ppval (interp1 (xp,yp,style,"pp"),xi),
+%!        interp1 (xp,yp,xi,style,"extrap"),100*eps)
+%!error interp1 (1,1,1, style)
+%!assert (interp1 (xp,[yp',yp'],xi,style),
+%!        interp1 (xp,[yp',yp'],xi,["*",style]),100*eps)
+%!test style = ["*",style];
+%!assert (interp1 (xp, yp, [min(xp)-1, max(xp)+1],style), [NA, NA])
+%!assert (interp1 (xp,yp,xp,style), yp, 100*eps)
+%!assert (interp1 (xp,yp,xp',style), yp', 100*eps)
+%!assert (interp1 (xp',yp',xp',style), yp', 100*eps)
+%!assert (interp1 (xp',yp',xp,style), yp, 100*eps)
+%!assert (isempty (interp1 (xp',yp',[],style)))
+%!assert (isempty (interp1 (xp,yp,[],style)))
+%!assert (interp1 (xp,[yp',yp'],xi(:),style),...
+%!        [interp1(xp,yp,xi(:),style),interp1(xp,yp,xi(:),style)])
+%!assert (interp1 (xp,yp,xi,style),...
+%!        interp1 (fliplr (xp),fliplr (yp),xi,style),100*eps)
+%!assert (ppval (interp1 (xp,yp,style,"pp"),xi),
+%!        interp1 (xp,yp,xi,style,"extrap"),100*eps)
+%!error interp1 (1,1,1, style)
 ## ENDBLOCK
 
-%!test style='pchip';
+%!test style = "pchip";
 ## BLOCK
-%!assert (interp1(xp, yp, [min(xp)-1, max(xp)+1],style), [NA, NA]);
-%!assert (interp1(xp,yp,xp,style), yp, 100*eps);
-%!assert (interp1(xp,yp,xp',style), yp', 100*eps);
-%!assert (interp1(xp',yp',xp',style), yp', 100*eps);
-%!assert (interp1(xp',yp',xp,style), yp, 100*eps);
-%!assert (isempty(interp1(xp',yp',[],style)));
-%!assert (isempty(interp1(xp,yp,[],style)));
-%!assert (interp1(xp,[yp',yp'],xi(:),style),...
-%!        [interp1(xp,yp,xi(:),style),interp1(xp,yp,xi(:),style)]);
-%!assert (interp1(xp,yp,xi,style),...
-%!        interp1(fliplr(xp),fliplr(yp),xi,style),100*eps);
-%!assert (ppval(interp1(xp,yp,style,"pp"),xi),
-%!        interp1(xp,yp,xi,style,"extrap"),10*eps);
-%!error interp1(1,1,1, style);
-%!assert (interp1(xp,[yp',yp'],xi,style),
-%!        interp1(xp,[yp',yp'],xi,["*",style]),100*eps);
-%!test style=['*',style];
-%!assert (interp1(xp, yp, [min(xp)-1, max(xp)+1],style), [NA, NA]);
-%!assert (interp1(xp,yp,xp,style), yp, 100*eps);
-%!assert (interp1(xp,yp,xp',style), yp', 100*eps);
-%!assert (interp1(xp',yp',xp',style), yp', 100*eps);
-%!assert (interp1(xp',yp',xp,style), yp, 100*eps);
-%!assert (isempty(interp1(xp',yp',[],style)));
-%!assert (isempty(interp1(xp,yp,[],style)));
-%!assert (interp1(xp,[yp',yp'],xi(:),style),...
-%!        [interp1(xp,yp,xi(:),style),interp1(xp,yp,xi(:),style)]);
-%!assert (interp1(xp,yp,xi,style),...
-%!        interp1(fliplr(xp),fliplr(yp),xi,style),100*eps);
-%!assert (ppval(interp1(xp,yp,style,"pp"),xi),
-%!        interp1(xp,yp,xi,style,"extrap"),10*eps);
-%!error interp1(1,1,1, style);
+%!assert (interp1 (xp, yp, [min(xp)-1, max(xp)+1],style), [NA, NA])
+%!assert (interp1 (xp,yp,xp,style), yp, 100*eps)
+%!assert (interp1 (xp,yp,xp',style), yp', 100*eps)
+%!assert (interp1 (xp',yp',xp',style), yp', 100*eps)
+%!assert (interp1 (xp',yp',xp,style), yp, 100*eps)
+%!assert (isempty (interp1 (xp',yp',[],style)))
+%!assert (isempty (interp1 (xp,yp,[],style)))
+%!assert (interp1 (xp,[yp',yp'],xi(:),style),...
+%!        [interp1(xp,yp,xi(:),style),interp1(xp,yp,xi(:),style)])
+%!assert (interp1 (xp,yp,xi,style),...
+%!        interp1 (fliplr (xp),fliplr (yp),xi,style),100*eps)
+%!assert (ppval (interp1 (xp,yp,style,"pp"),xi),
+%!        interp1 (xp,yp,xi,style,"extrap"),10*eps)
+%!error interp1 (1,1,1, style)
+%!assert (interp1 (xp,[yp',yp'],xi,style),
+%!        interp1 (xp,[yp',yp'],xi,["*",style]),100*eps)
+%!test style = ["*",style];
+%!assert (interp1 (xp, yp, [min(xp)-1, max(xp)+1],style), [NA, NA])
+%!assert (interp1 (xp,yp,xp,style), yp, 100*eps)
+%!assert (interp1 (xp,yp,xp',style), yp', 100*eps)
+%!assert (interp1 (xp',yp',xp',style), yp', 100*eps)
+%!assert (interp1 (xp',yp',xp,style), yp, 100*eps)
+%!assert (isempty (interp1 (xp',yp',[],style)))
+%!assert (isempty (interp1 (xp,yp,[],style)))
+%!assert (interp1 (xp,[yp',yp'],xi(:),style),...
+%!        [interp1(xp,yp,xi(:),style),interp1(xp,yp,xi(:),style)])
+%!assert (interp1 (xp,yp,xi,style),...
+%!        interp1 (fliplr (xp),fliplr (yp),xi,style),100*eps)
+%!assert (ppval (interp1 (xp,yp,style,"pp"),xi),
+%!        interp1 (xp,yp,xi,style,"extrap"),10*eps)
+%!error interp1 (1,1,1, style)
 ## ENDBLOCK
 
-%!test style='spline';
+%!test style = "spline";
 ## BLOCK
-%!assert (interp1(xp, yp, [min(xp)-1, max(xp)+1],style), [NA, NA]);
-%!assert (interp1(xp,yp,xp,style), yp, 100*eps);
-%!assert (interp1(xp,yp,xp',style), yp', 100*eps);
-%!assert (interp1(xp',yp',xp',style), yp', 100*eps);
-%!assert (interp1(xp',yp',xp,style), yp, 100*eps);
-%!assert (isempty(interp1(xp',yp',[],style)));
-%!assert (isempty(interp1(xp,yp,[],style)));
-%!assert (interp1(xp,[yp',yp'],xi(:),style),...
-%!        [interp1(xp,yp,xi(:),style),interp1(xp,yp,xi(:),style)]);
-%!assert (interp1(xp,yp,xi,style),...
-%!        interp1(fliplr(xp),fliplr(yp),xi,style),100*eps);
-%!assert (ppval(interp1(xp,yp,style,"pp"),xi),
-%!        interp1(xp,yp,xi,style,"extrap"),10*eps);
-%!error interp1(1,1,1, style);
-%!assert (interp1(xp,[yp',yp'],xi,style),
-%!        interp1(xp,[yp',yp'],xi,["*",style]),100*eps);
-%!test style=['*',style];
-%!assert (interp1(xp, yp, [min(xp)-1, max(xp)+1],style), [NA, NA]);
-%!assert (interp1(xp,yp,xp,style), yp, 100*eps);
-%!assert (interp1(xp,yp,xp',style), yp', 100*eps);
-%!assert (interp1(xp',yp',xp',style), yp', 100*eps);
-%!assert (interp1(xp',yp',xp,style), yp, 100*eps);
-%!assert (isempty(interp1(xp',yp',[],style)));
-%!assert (isempty(interp1(xp,yp,[],style)));
-%!assert (interp1(xp,[yp',yp'],xi(:),style),...
-%!        [interp1(xp,yp,xi(:),style),interp1(xp,yp,xi(:),style)]);
-%!assert (interp1(xp,yp,xi,style),...
-%!        interp1(fliplr(xp),fliplr(yp),xi,style),100*eps);
-%!assert (ppval(interp1(xp,yp,style,"pp"),xi),
-%!        interp1(xp,yp,xi,style,"extrap"),10*eps);
-%!error interp1(1,1,1, style);
+%!assert (interp1 (xp, yp, [min(xp)-1, max(xp)+1],style), [NA, NA])
+%!assert (interp1 (xp,yp,xp,style), yp, 100*eps)
+%!assert (interp1 (xp,yp,xp',style), yp', 100*eps)
+%!assert (interp1 (xp',yp',xp',style), yp', 100*eps)
+%!assert (interp1 (xp',yp',xp,style), yp, 100*eps)
+%!assert (isempty (interp1 (xp',yp',[],style)))
+%!assert (isempty (interp1 (xp,yp,[],style)))
+%!assert (interp1 (xp,[yp',yp'],xi(:),style),...
+%!        [interp1(xp,yp,xi(:),style),interp1(xp,yp,xi(:),style)])
+%!assert (interp1 (xp,yp,xi,style),...
+%!        interp1 (fliplr (xp),fliplr (yp),xi,style),100*eps)
+%!assert (ppval (interp1 (xp,yp,style,"pp"),xi),
+%!        interp1 (xp,yp,xi,style,"extrap"),10*eps)
+%!error interp1 (1,1,1, style)
+%!assert (interp1 (xp,[yp',yp'],xi,style),
+%!        interp1 (xp,[yp',yp'],xi,["*",style]),100*eps)
+%!test style = ["*",style];
+%!assert (interp1 (xp, yp, [min(xp)-1, max(xp)+1],style), [NA, NA])
+%!assert (interp1 (xp,yp,xp,style), yp, 100*eps)
+%!assert (interp1 (xp,yp,xp',style), yp', 100*eps)
+%!assert (interp1 (xp',yp',xp',style), yp', 100*eps)
+%!assert (interp1 (xp',yp',xp,style), yp, 100*eps)
+%!assert (isempty (interp1 (xp',yp',[],style)))
+%!assert (isempty (interp1 (xp,yp,[],style)))
+%!assert (interp1 (xp,[yp',yp'],xi(:),style),...
+%!        [interp1(xp,yp,xi(:),style),interp1(xp,yp,xi(:),style)])
+%!assert (interp1 (xp,yp,xi,style),...
+%!        interp1 (fliplr (xp),fliplr (yp),xi,style),100*eps)
+%!assert (ppval (interp1 (xp,yp,style,"pp"),xi),
+%!        interp1 (xp,yp,xi,style,"extrap"),10*eps)
+%!error interp1 (1,1,1, style)
 ## ENDBLOCK
 ## ENDBLOCKTEST
 
 %!# test linear extrapolation
-%!assert (interp1([1:5],[3:2:11],[0,6],"linear","extrap"), [1, 13], eps);
-%!assert (interp1(xp, yp, [-1, max(xp)+1],"linear",5), [5, 5]);
-
-%!error interp1
-%!error interp1(1:2,1:2,1,"bogus")
+%!assert (interp1 ([1:5],[3:2:11],[0,6],"linear","extrap"), [1, 13], eps)
+%!assert (interp1 (xp, yp, [-1, max(xp)+1],"linear",5), [5, 5])
 
-%!assert (interp1(1:2,1:2,1.4,"nearest"),1);
-%!error interp1(1,1,1, "linear");
-%!assert (interp1(1:2,1:2,1.4,"linear"),1.4);
-%!assert (interp1(1:4,1:4,1.4,"cubic"),1.4);
-%!assert (interp1(1:2,1:2,1.1, "spline"), 1.1);
-%!assert (interp1(1:3,1:3,1.4,"spline"),1.4);
+%!assert (interp1 (1:2,1:2,1.4,"nearest"), 1)
+%!assert (interp1 (1:2,1:2,1.4,"linear"), 1.4)
+%!assert (interp1 (1:4,1:4,1.4,"cubic"), 1.4)
+%!assert (interp1 (1:2,1:2,1.1, "spline"), 1.1)
+%!assert (interp1 (1:3,1:3,1.4,"spline"), 1.4)
 
-%!error interp1(1,1,1, "*nearest");
-%!assert (interp1(1:2:4,1:2:4,1.4,"*nearest"),1);
-%!error interp1(1,1,1, "*linear");
-%!assert (interp1(1:2:4,1:2:4,[0,1,1.4,3,4],"*linear"),[NA,1,1.4,3,NA]);
-%!assert (interp1(1:2:8,1:2:8,1.4,"*cubic"),1.4);
-%!assert (interp1(1:2,1:2,1.3, "*spline"), 1.3);
-%!assert (interp1(1:2:6,1:2:6,1.4,"*spline"),1.4);
+%!assert (interp1 (1:2:4,1:2:4,1.4,"*nearest"), 1)
+%!assert (interp1 (1:2:4,1:2:4,[0,1,1.4,3,4],"*linear"), [NA,1,1.4,3,NA])
+%!assert (interp1 (1:2:8,1:2:8,1.4,"*cubic"), 1.4)
+%!assert (interp1 (1:2,1:2,1.3, "*spline"), 1.3)
+%!assert (interp1 (1:2:6,1:2:6,1.4,"*spline"), 1.4)
 
-%!assert (interp1([3,2,1],[3,2,2],2.5),2.5)
+%!assert (interp1 ([3,2,1],[3,2,2],2.5), 2.5)
 
 %!assert (interp1 ([1,2,2,3,4],[0,1,4,2,1],[-1,1.5,2,2.5,3.5], "linear", "extrap"), [-2,0.5,4,3,1.5])
 %!assert (interp1 ([4,4,3,2,0],[0,1,4,2,1],[1.5,4,4.5], "linear"), [1.75,1,NA])
 %!assert (interp1 (0:4, 2.5), 1.5)
+
+%!error interp1 ()
+%!error interp1 (1,1,1, "linear")
+%!error interp1 (1,1,1, "*nearest")
+%!error interp1 (1,1,1, "*linear")
+%!error interp1 (1:2,1:2,1, "bogus")
+
diff --git a/scripts/general/interp1q.m b/scripts/general/interp1q.m
--- a/scripts/general/interp1q.m
+++ b/scripts/general/interp1q.m
@@ -52,19 +52,21 @@ function yi = interp1q (x, y, xi)
   yi(range,:) = NA;
   if (length (szx) == 2 && any (szx == 1))
     yi = reshape (yi, [max(szx), szy(2:end)]);
   else
     yi = reshape (yi, [szx, szy(2:end)]);
   endif
 endfunction
 
+
 %!shared xp, yp, xi, yi
-%! xp=[0:2:10].';      yp = sin(2*pi*xp/5);
+%! xp = [0:2:10].';   yp = sin(2*pi*xp/5);
 %! xi = [-1; 0; 2.2; 4; 6.6; 10; 11];
 %! yi = interp1 (xp,yp,xi);
-%!assert (interp1q(xp, yp, [min(xp)-1; max(xp)+1]), [NA; NA]);
-%!assert (interp1q(xp,yp,xp), yp, 100*eps);
-%!assert (isempty(interp1q(xp,yp,[])));
-%!assert (interp1q(xp,yp,xi), yi);
-%!assert (interp1q(xp,[yp,yp],xi), [yi, yi]);
-%!assert (interp1q(xp,yp,[xi,xi]), [yi, yi]);
-%!assert (interp1q(xp,[yp,yp],[xi,xi]), cat (3, [yi, yi], [yi, yi]));
+%!assert (interp1q (xp,yp, [min(xp)-1; max(xp)+1]), [NA; NA]);
+%!assert (interp1q (xp,yp,xp), yp, 100*eps);
+%!assert (isempty (interp1q (xp,yp,[])));
+%!assert (interp1q (xp,yp,xi), yi);
+%!assert (interp1q (xp,[yp,yp],xi), [yi, yi]);
+%!assert (interp1q (xp,yp,[xi,xi]), [yi, yi]);
+%!assert (interp1q (xp,[yp,yp],[xi,xi]), cat (3, [yi, yi], [yi, yi]));
+
diff --git a/scripts/general/interp2.m b/scripts/general/interp2.m
--- a/scripts/general/interp2.m
+++ b/scripts/general/interp2.m
@@ -31,45 +31,45 @@
 ## format.
 ##
 ## @table @code
 ## @item interp2 (@var{x}, @var{y}, @var{Z}, @var{xi}, @var{yi}, @dots{})
 ## Returns a matrix corresponding to the points described by the
 ## matrices @var{xi}, @var{yi}.
 ##
 ## If the last argument is a string, the interpolation method can
-## be specified.  The method can be 'linear', 'nearest' or 'cubic'.
-## If it is omitted 'linear' interpolation is assumed.
+## be specified.  The method can be "linear", "nearest" or "cubic".
+## If it is omitted "linear" interpolation is assumed.
 ##
 ## @item interp2 (@var{z}, @var{xi}, @var{yi})
 ## Assumes @code{@var{x} = 1:rows (@var{z})} and @code{@var{y} =
 ## 1:columns (@var{z})}
 ##
 ## @item interp2 (@var{z}, @var{n})
 ## Interleaves the matrix @var{z} n-times.  If @var{n} is omitted a value
 ## of @code{@var{n} = 1} is assumed.
 ## @end table
 ##
 ## The variable @var{method} defines the method to use for the
 ## interpolation.  It can take one of the following values
 ##
 ## @table @asis
-## @item 'nearest'
+## @item "nearest"
 ## Return the nearest neighbor.
 ##
-## @item 'linear'
+## @item "linear"
 ## Linear interpolation from nearest neighbors.
 ##
-## @item 'pchip'
+## @item "pchip"
 ## Piecewise cubic Hermite interpolating polynomial.
 ##
-## @item 'cubic'
+## @item "cubic"
 ## Cubic interpolation from four nearest neighbors.
 ##
-## @item 'spline'
+## @item "spline"
 ## Cubic spline interpolation---smooth first and second derivatives
 ## throughout the curve.
 ## @end table
 ##
 ## If a scalar value @var{extrapval} is defined as the final value, then
 ## values outside the mesh as set to this value.  Note that in this case
 ## @var{method} must be defined as well.  If @var{extrapval} is not
 ## defined then NA is assumed.
@@ -444,187 +444,188 @@ function ind = sym_sub2ind(sz, Y, X)
   ind = sub2ind(sz, Y, X);
 endfunction
 
 
 %!demo
 %! clf;
 %! colormap ("default");
 %! A = [13,-1,12;5,4,3;1,6,2];
-%! x = [0,1,4]; y = [10,11,12];
-%! xi = linspace (min(x), max(x), 17);
-%! yi = linspace (min(y), max(y), 26)';
+%! x = [0,1,4];  y = [10,11,12];
+%! xi = linspace (min (x), max (x), 17);
+%! yi = linspace (min (y), max (y), 26)';
 %! mesh (xi,yi,interp2 (x,y,A,xi,yi, "linear"));
 %! [x,y] = meshgrid (x,y);
 %! hold on; plot3 (x(:),y(:),A(:),"b*"); hold off;
 
 %!demo
 %! clf;
 %! colormap ("default");
 %! [x,y,A] = peaks (10);
-%! x = x(1,:)'; y = y(:,1);
-%! xi = linspace (min(x), max(x), 41);
-%! yi = linspace (min(y), max(y), 41)';
+%! x = x(1,:)';  y = y(:,1);
+%! xi = linspace (min (x), max (x), 41);
+%! yi = linspace (min (y), max (y), 41)';
 %! mesh (xi,yi,interp2 (x,y,A,xi,yi, "linear"));
 %! [x,y] = meshgrid (x,y);
 %! hold on; plot3 (x(:),y(:),A(:),"b*"); hold off;
 
 %!demo
 %! clf;
 %! colormap ("default");
 %! A = [13,-1,12;5,4,3;1,6,2];
-%! x = [0,1,4]; y = [10,11,12];
-%! xi = linspace (min(x), max(x), 17);
-%! yi = linspace (min(y), max(y), 26)';
+%! x = [0,1,4];  y = [10,11,12];
+%! xi = linspace (min (x), max (x), 17);
+%! yi = linspace (min (y), max (y), 26)';
 %! mesh (xi,yi,interp2 (x,y,A,xi,yi, "nearest"));
 %! [x,y] = meshgrid (x,y);
 %! hold on; plot3 (x(:),y(:),A(:),"b*"); hold off;
 
 %!demo
 %! clf;
 %! colormap ("default");
 %! [x,y,A] = peaks (10);
-%! x = x(1,:)'; y = y(:,1);
-%! xi = linspace (min(x), max(x), 41);
-%! yi = linspace (min(y), max(y), 41)';
+%! x = x(1,:)';  y = y(:,1);
+%! xi = linspace (min (x), max (x), 41);
+%! yi = linspace (min (y), max (y), 41)';
 %! mesh (xi,yi,interp2 (x,y,A,xi,yi, "nearest"));
 %! [x,y] = meshgrid (x,y);
 %! hold on; plot3 (x(:),y(:),A(:),"b*"); hold off;
 
 %!demo
 %! clf;
 %! colormap ("default");
 %! A = [13,-1,12;5,4,3;1,6,2];
-%! x = [0,1,2]; y = [10,11,12];
-%! xi = linspace (min(x), max(x), 17);
-%! yi = linspace (min(y), max(y), 26)';
+%! x = [0,1,2];  y = [10,11,12];
+%! xi = linspace (min (x), max (x), 17);
+%! yi = linspace (min (y), max (y), 26)';
 %! mesh (xi,yi,interp2 (x,y,A,xi,yi, "pchip"));
 %! [x,y] = meshgrid (x,y);
 %! hold on; plot3 (x(:),y(:),A(:),"b*"); hold off;
 
 %!demo
 %! clf;
 %! colormap ("default");
 %! [x,y,A] = peaks (10);
-%! x = x(1,:)'; y = y(:,1);
-%! xi = linspace (min(x), max(x), 41);
-%! yi = linspace (min(y), max(y), 41)';
+%! x = x(1,:)';  y = y(:,1);
+%! xi = linspace (min (x), max (x), 41);
+%! yi = linspace (min (y), max (y), 41)';
 %! mesh (xi,yi,interp2 (x,y,A,xi,yi, "pchip"));
 %! [x,y] = meshgrid (x,y);
 %! hold on; plot3 (x(:),y(:),A(:),"b*"); hold off;
 
 %!demo
 %! clf;
 %! colormap ("default");
 %! A = [13,-1,12;5,4,3;1,6,2];
-%! x = [0,1,2]; y = [10,11,12];
-%! xi = linspace (min(x), max(x), 17);
-%! yi = linspace (min(y), max(y), 26)';
+%! x = [0,1,2];  y = [10,11,12];
+%! xi = linspace (min (x), max (x), 17);
+%! yi = linspace (min (y), max (y), 26)';
 %! mesh (xi,yi,interp2 (x,y,A,xi,yi, "cubic"));
 %! [x,y] = meshgrid (x,y);
 %! hold on; plot3 (x(:),y(:),A(:),"b*"); hold off;
 
 %!demo
 %! clf;
 %! colormap ("default");
 %! [x,y,A] = peaks (10);
-%! x = x(1,:)'; y = y(:,1);
-%! xi = linspace (min(x), max(x), 41);
-%! yi = linspace (min(y), max(y), 41)';
+%! x = x(1,:)';  y = y(:,1);
+%! xi = linspace (min (x), max (x), 41);
+%! yi = linspace (min (y), max (y), 41)';
 %! mesh (xi,yi,interp2 (x,y,A,xi,yi, "cubic"));
 %! [x,y] = meshgrid (x,y);
 %! hold on; plot3 (x(:),y(:),A(:),"b*"); hold off;
 
 %!demo
 %! clf;
 %! colormap ("default");
 %! A = [13,-1,12;5,4,3;1,6,2];
-%! x = [0,1,2]; y = [10,11,12];
-%! xi = linspace (min(x), max(x), 17);
-%! yi = linspace (min(y), max(y), 26)';
+%! x = [0,1,2];  y = [10,11,12];
+%! xi = linspace (min (x), max (x), 17);
+%! yi = linspace (min (y), max (y), 26)';
 %! mesh (xi,yi,interp2 (x,y,A,xi,yi, "spline"));
 %! [x,y] = meshgrid (x,y);
 %! hold on; plot3 (x(:),y(:),A(:),"b*"); hold off;
 
 %!demo
 %! clf;
 %! colormap ("default");
 %! [x,y,A] = peaks (10);
-%! x = x(1,:)'; y = y(:,1);
-%! xi = linspace (min(x), max(x), 41);
-%! yi = linspace (min(y), max(y), 41)';
+%! x = x(1,:)';  y = y(:,1);
+%! xi = linspace (min (x), max (x), 41);
+%! yi = linspace (min (y), max (y), 41)';
 %! mesh (xi,yi,interp2 (x,y,A,xi,yi, "spline"));
 %! [x,y] = meshgrid (x,y);
 %! hold on; plot3 (x(:),y(:),A(:),"b*"); hold off;
 
 %!test % simple test
-%!  x = [1,2,3];
-%!  y = [4,5,6,7];
-%!  [X, Y] = meshgrid (x,y);
-%!  Orig = X.^2 + Y.^3;
-%!  xi = [1.2,2, 1.5];
-%!  yi = [6.2, 4.0, 5.0]';
+%! x = [1,2,3];
+%! y = [4,5,6,7];
+%! [X, Y] = meshgrid (x, y);
+%! Orig = X.^2 + Y.^3;
+%! xi = [1.2,2, 1.5];
+%! yi = [6.2, 4.0, 5.0]';
 %!
-%!  Expected = ...
-%!    [243,   245.4,  243.9;
-%!      65.6,  68,     66.5;
-%!     126.6, 129,    127.5];
-%!  Result = interp2 (x,y,Orig, xi, yi);
+%! Expected = ...
+%!   [243,   245.4,  243.9;
+%!     65.6,  68,     66.5;
+%!    126.6, 129,    127.5];
+%! Result = interp2 (x,y,Orig, xi, yi);
 %!
-%!  assert(Result, Expected, 1000*eps);
+%! assert (Result, Expected, 1000*eps);
 
 %!test % 2^n form
-%!  x = [1,2,3];
-%!  y = [4,5,6,7];
-%!  [X, Y] = meshgrid(x,y);
-%!  Orig = X.^2 + Y.^3;
-%!  xi = [1:0.25:3]; yi = [4:0.25:7]';
-%!  Expected = interp2(x,y,Orig, xi, yi);
-%!  Result = interp2(Orig,2);
+%! x = [1,2,3];
+%! y = [4,5,6,7];
+%! [X, Y] = meshgrid (x, y);
+%! Orig = X.^2 + Y.^3;
+%! xi = [1:0.25:3];  yi = [4:0.25:7]';
+%! Expected = interp2 (x,y,Orig, xi, yi);
+%! Result = interp2 (Orig, 2);
 %!
-%!  assert(Result, Expected, 10*eps);
+%! assert (Result, Expected, 10*eps);
 
 %!test % matrix slice
-%!  A = eye(4);
-%!  assert(interp2(A,[1:4],[1:4]),[1,1,1,1]);
+%! A = eye (4);
+%! assert (interp2 (A,[1:4],[1:4]), [1,1,1,1]);
 
 %!test % non-gridded XI,YI
-%!  A = eye(4);
-%!  assert(interp2(A,[1,2;3,4],[1,3;2,4]),[1,0;0,1]);
+%! A = eye (4);
+%! assert (interp2 (A,[1,2;3,4],[1,3;2,4]), [1,0;0,1]);
 
 %!test % for values outside of boundaries
-%!  x = [1,2,3];
-%!  y = [4,5,6,7];
-%!  [X, Y] = meshgrid(x,y);
-%!  Orig = X.^2 + Y.^3;
-%!  xi = [0,4];
-%!  yi = [3,8]';
-%!  assert(interp2(x,y,Orig, xi, yi),[NA,NA;NA,NA]);
-%!  assert(interp2(x,y,Orig, xi, yi,'linear', 0),[0,0;0,0]);
+%! x = [1,2,3];
+%! y = [4,5,6,7];
+%! [X, Y] = meshgrid (x,y);
+%! Orig = X.^2 + Y.^3;
+%! xi = [0,4];
+%! yi = [3,8]';
+%! assert (interp2 (x,y,Orig, xi, yi), [NA,NA;NA,NA]);
+%! assert (interp2 (x,y,Orig, xi, yi,"linear", 0), [0,0;0,0]);
 
 %!test % for values at boundaries
-%!  A=[1,2;3,4];
-%!  x=[0,1];
-%!  y=[2,3]';
-%!  assert(interp2(x,y,A,x,y,'linear'), A);
-%!  assert(interp2(x,y,A,x,y,'nearest'), A);
+%! A=[1,2;3,4];
+%! x=[0,1];
+%! y=[2,3]';
+%! assert (interp2 (x,y,A,x,y,"linear"), A);
+%! assert (interp2 (x,y,A,x,y,"nearest"), A);
 
 %!test % for Matlab-compatible rounding for 'nearest'
 %! X = meshgrid (1:4);
-%! assert (interp2 (X, 2.5, 2.5, 'nearest'), 3);
+%! assert (interp2 (X, 2.5, 2.5, "nearest"), 3);
 
 %!shared z, zout, tol
-%!  z = [1 3 5; 3 5 7; 5 7 9];
-%!  zout = [1 2 3 4 5; 2 3 4 5 6; 3 4 5 6 7; 4 5 6 7 8; 5 6 7 8 9];
-%!  tol = 2 * eps;
-%!assert (interp2 (z), zout, tol);
-%!assert (interp2 (z, "linear"), zout, tol);
-%!assert (interp2 (z, "pchip"), zout, tol);
-%!assert (interp2 (z, "cubic"), zout, 10 * tol);
-%!assert (interp2 (z, "spline"), zout, tol);
+%! z = [1 3 5; 3 5 7; 5 7 9];
+%! zout = [1 2 3 4 5; 2 3 4 5 6; 3 4 5 6 7; 4 5 6 7 8; 5 6 7 8 9];
+%! tol = 2 * eps;
+%!assert (interp2 (z), zout, tol)
+%!assert (interp2 (z, "linear"), zout, tol)
+%!assert (interp2 (z, "pchip"), zout, tol)
+%!assert (interp2 (z, "cubic"), zout, 10 * tol)
+%!assert (interp2 (z, "spline"), zout, tol)
 %!assert (interp2 (z, [2 3 1], [2 2 2]', "linear"), repmat ([5, 7, 3], [3, 1]), tol) 
 %!assert (interp2 (z, [2 3 1], [2 2 2]', "pchip"), repmat ([5, 7, 3], [3, 1]), tol) 
 %!assert (interp2 (z, [2 3 1], [2 2 2]', "cubic"), repmat ([5, 7, 3], [3, 1]), 10 * tol) 
 %!assert (interp2 (z, [2 3 1], [2 2 2]', "spline"), repmat ([5, 7, 3], [3, 1]), tol) 
-%!assert (interp2 (z, [2 3 1], [2 2 2], "linear"), [5 7 3], tol);
-%!assert (interp2 (z, [2 3 1], [2 2 2], "pchip"), [5 7 3], tol);
-%!assert (interp2 (z, [2 3 1], [2 2 2], "cubic"), [5 7 3], 10 * tol);
-%!assert (interp2 (z, [2 3 1], [2 2 2], "spline"), [5 7 3], tol);
+%!assert (interp2 (z, [2 3 1], [2 2 2], "linear"), [5 7 3], tol)
+%!assert (interp2 (z, [2 3 1], [2 2 2], "pchip"), [5 7 3], tol)
+%!assert (interp2 (z, [2 3 1], [2 2 2], "cubic"), [5 7 3], 10 * tol)
+%!assert (interp2 (z, [2 3 1], [2 2 2], "spline"), [5 7 3], tol)
+
diff --git a/scripts/general/interp3.m b/scripts/general/interp3.m
--- a/scripts/general/interp3.m
+++ b/scripts/general/interp3.m
@@ -23,47 +23,47 @@
 ## @deftypefnx {Function File} {@var{vi} =} interp3 (@var{v})
 ## @deftypefnx {Function File} {@var{vi} =} interp3 (@dots{}, @var{method})
 ## @deftypefnx {Function File} {@var{vi} =} interp3 (@dots{}, @var{method}, @var{extrapval})
 ##
 ## Perform 3-dimensional interpolation.  Each element of the 3-dimensional
 ## array @var{v} represents a value at a location given by the parameters
 ## @var{x}, @var{y}, and @var{z}.  The parameters @var{x}, @var{x}, and
 ## @var{z} are either 3-dimensional arrays of the same size as the array
-## @var{v} in the 'meshgrid' format or vectors.  The parameters @var{xi}, etc.
+## @var{v} in the "meshgrid" format or vectors.  The parameters @var{xi}, etc.
 ## respect a similar format to @var{x}, etc., and they represent the points
 ## at which the array @var{vi} is interpolated.
 ##
 ## If @var{x}, @var{y}, @var{z} are omitted, they are assumed to be
 ## @code{x = 1 : size (@var{v}, 2)}, @code{y = 1 : size (@var{v}, 1)} and
 ## @code{z = 1 : size (@var{v}, 3)}.  If @var{m} is specified, then
 ## the interpolation adds a point half way between each of the interpolation
 ## points.  This process is performed @var{m} times.  If only @var{v} is
 ## specified, then @var{m} is assumed to be @code{1}.
 ##
 ## Method is one of:
 ##
 ## @table @asis
-## @item 'nearest'
+## @item "nearest"
 ## Return the nearest neighbor.
 ##
-## @item 'linear'
+## @item "linear"
 ## Linear interpolation from nearest neighbors.
 ##
-## @item 'cubic'
+## @item "cubic"
 ## Cubic interpolation from four nearest neighbors (not implemented yet).
 ##
-## @item 'spline'
+## @item "spline"
 ## Cubic spline interpolation---smooth first and second derivatives
 ## throughout the curve.
 ## @end table
 ##
-## The default method is 'linear'.
+## The default method is "linear".
 ##
-## If @var{extrap} is the string 'extrap', then extrapolate values beyond
+## If @var{extrap} is the string "extrap", then extrapolate values beyond
 ## the endpoints.  If @var{extrap} is a number, replace values beyond the
 ## endpoints with that number.  If @var{extrap} is missing, assume NA.
 ## @seealso{interp1, interp2, spline, meshgrid}
 ## @end deftypefn
 
 function vi = interp3 (varargin)
   method = "linear";
   extrapval = NA;
@@ -130,26 +130,27 @@ function vi = interp3 (varargin)
     endif
     v = permute (v, [2, 1, 3]);
     vi = ipermute (interpn (x{:}, v, y{:}, method, extrapval), [2, 1, 3]);
   else
     error ("interp3: wrong number or incorrectly formatted input arguments");
   endif
 endfunction
 
+
 %!test
 %! x = y = z = -1:1;
 %! f = @(x,y,z) x.^2 - y - z.^2;
 %! [xx, yy, zz] = meshgrid (x, y, z);
 %! v = f (xx,yy,zz);
 %! xi = yi = zi = -1:0.5:1;
 %! [xxi, yyi, zzi] = meshgrid (xi, yi, zi);
-%! vi = interp3(x, y, z, v, xxi, yyi, zzi);
+%! vi = interp3 (x, y, z, v, xxi, yyi, zzi);
 %! [xxi, yyi, zzi] = ndgrid (xi, yi, zi);
-%! vi2 = interpn(x, y, z, v, xxi, yyi, zzi);
+%! vi2 = interpn (x, y, z, v, xxi, yyi, zzi);
 %! assert (vi, vi2);
 
 %!shared z, zout, tol
 %! z = zeros (3, 3, 3);
 %! zout = zeros (5, 5, 5);
 %! z(:,:,1) = [1 3 5; 3 5 7; 5 7 9];
 %! z(:,:,2) = z(:,:,1) + 2;
 %! z(:,:,3) = z(:,:,2) + 2;
@@ -159,8 +160,9 @@ endfunction
 %!                  3 4 5 6 7;
 %!                  4 5 6 7 8;
 %!                  5 6 7 8 9] + (n-1);
 %! end
 %! tol = 10 * eps;
 %!assert (interp3 (z), zout, tol)
 %!assert (interp3 (z, "linear"), zout, tol)
 %!assert (interp3 (z, "spline"), zout, tol)
+
diff --git a/scripts/general/interpft.m b/scripts/general/interpft.m
--- a/scripts/general/interpft.m
+++ b/scripts/general/interpft.m
@@ -88,27 +88,27 @@ function z = interpft (x, n, dim)
 
   z = ipermute (z, perm);
 
 endfunction
 
 
 %!demo
 %! clf;
-%! t = 0 : 0.3 : pi; dt = t(2)-t(1);
-%! n = length (t); k = 100;
+%! t = 0 : 0.3 : pi;  dt = t(2)-t(1);
+%! n = length (t);  k = 100;
 %! ti = t(1) + [0 : k-1]*dt*n/k;
 %! y = sin (4*t + 0.3) .* cos (3*t - 0.1);
 %! yp = sin (4*ti + 0.3) .* cos (3*ti - 0.1);
 %! plot (ti, yp, 'g', ti, interp1(t, y, ti, "spline"), 'b', ...
 %!       ti, interpft (y, k), 'c', t, y, "r+");
 %! legend ("sin(4t+0.3)cos(3t-0.1)", "spline", "interpft", "data");
 
 %!shared n,y
-%! x = [0:10]'; y = sin(x); n = length (x);
+%! x = [0:10]';  y = sin(x);  n = length (x);
 %!assert (interpft (y, n), y, 20*eps);
 %!assert (interpft (y', n), y', 20*eps);
 %!assert (interpft ([y,y],n), [y,y], 20*eps);
 
 %% Test input validation
 %!error interpft ()
 %!error interpft (1)
 %!error interpft (1,2,3)
diff --git a/scripts/general/interpn.m b/scripts/general/interpn.m
--- a/scripts/general/interpn.m
+++ b/scripts/general/interpn.m
@@ -24,44 +24,44 @@
 ## @deftypefnx {Function File} {@var{vi} =} interpn (@dots{}, @var{method})
 ## @deftypefnx {Function File} {@var{vi} =} interpn (@dots{}, @var{method}, @var{extrapval})
 ##
 ## Perform @var{n}-dimensional interpolation, where @var{n} is at least two.
 ## Each element of the @var{n}-dimensional array @var{v} represents a value
 ## at a location given by the parameters @var{x1}, @var{x2}, @dots{}, @var{xn}.
 ## The parameters @var{x1}, @var{x2}, @dots{}, @var{xn} are either
 ## @var{n}-dimensional arrays of the same size as the array @var{v} in
-## the 'ndgrid' format or vectors.  The parameters @var{y1}, etc. respect a
+## the "ndgrid" format or vectors.  The parameters @var{y1}, etc. respect a
 ## similar format to @var{x1}, etc., and they represent the points at which
 ## the array @var{vi} is interpolated.
 ##
 ## If @var{x1}, @dots{}, @var{xn} are omitted, they are assumed to be
 ## @code{x1 = 1 : size (@var{v}, 1)}, etc.  If @var{m} is specified, then
 ## the interpolation adds a point half way between each of the interpolation
 ## points.  This process is performed @var{m} times.  If only @var{v} is
 ## specified, then @var{m} is assumed to be @code{1}.
 ##
 ## Method is one of:
 ##
 ## @table @asis
-## @item 'nearest'
+## @item "nearest"
 ## Return the nearest neighbor.
 ##
-## @item 'linear'
+## @item "linear"
 ## Linear interpolation from nearest neighbors.
 ##
-## @item 'cubic'
+## @item "cubic"
 ## Cubic interpolation from four nearest neighbors (not implemented yet).
 ##
-## @item 'spline'
+## @item "spline"
 ## Cubic spline interpolation---smooth first and second derivatives
 ## throughout the curve.
 ## @end table
 ##
-## The default method is 'linear'.
+## The default method is "linear".
 ##
 ## If @var{extrapval} is the scalar value, use it to replace the values
 ## beyond the endpoints with that number.  If @var{extrapval} is missing,
 ## assume NA.
 ## @seealso{interp1, interp2, spline, ndgrid}
 ## @end deftypefn
 
 function vi = interpn (varargin)
@@ -209,66 +209,66 @@ function vi = interpn (varargin)
 
 endfunction
 
 
 %!demo
 %! clf;
 %! colormap ("default");
 %! A = [13,-1,12;5,4,3;1,6,2];
-%! x = [0,1,4]; y = [10,11,12];
-%! xi = linspace (min(x), max(x), 17);
-%! yi = linspace (min(y), max(y), 26)';
+%! x = [0,1,4];  y = [10,11,12];
+%! xi = linspace (min (x), max (x), 17);
+%! yi = linspace (min (y), max (y), 26)';
 %! mesh (xi, yi, interpn (x,y,A.',xi,yi, "linear").');
 %! [x,y] = meshgrid (x,y);
 %! hold on; plot3 (x(:),y(:),A(:),"b*"); hold off;
 
 %!demo
 %! clf;
 %! colormap ("default");
 %! A = [13,-1,12;5,4,3;1,6,2];
-%! x = [0,1,4]; y = [10,11,12];
-%! xi = linspace (min(x), max(x), 17);
-%! yi = linspace (min(y), max(y), 26)';
+%! x = [0,1,4];  y = [10,11,12];
+%! xi = linspace (min (x), max (x), 17);
+%! yi = linspace (min (y), max (y), 26)';
 %! mesh (xi, yi, interpn (x,y,A.',xi,yi, "nearest").');
 %! [x,y] = meshgrid (x,y);
 %! hold on; plot3 (x(:),y(:),A(:),"b*"); hold off;
 
 %!#demo  # FIXME: Uncomment when support for "cubic" has been added
 %! clf;
 %! colormap ("default");
 %! A = [13,-1,12;5,4,3;1,6,2];
-%! x = [0,1,2]; y = [10,11,12];
-%! xi = linspace (min(x), max(x), 17);
-%! yi = linspace (min(y), max(y), 26)';
+%! x = [0,1,2];  y = [10,11,12];
+%! xi = linspace (min (x), max (x), 17);
+%! yi = linspace (min (y), max (y), 26)';
 %! mesh (xi, yi, interpn (x,y,A.',xi,yi, "cubic").');
 %! [x,y] = meshgrid (x,y);
 %! hold on; plot3 (x(:),y(:),A(:),"b*"); hold off;
 
 %!demo
 %! clf;
 %! colormap ("default");
 %! A = [13,-1,12;5,4,3;1,6,2];
-%! x = [0,1,2]; y = [10,11,12];
-%! xi = linspace (min(x), max(x), 17);
-%! yi = linspace (min(y), max(y), 26)';
+%! x = [0,1,2];  y = [10,11,12];
+%! xi = linspace (min (x), max (x), 17);
+%! yi = linspace (min (y), max (y), 26)';
 %! mesh (xi, yi, interpn (x,y,A.',xi,yi, "spline").');
 %! [x,y] = meshgrid (x,y);
 %! hold on; plot3 (x(:),y(:),A(:),"b*"); hold off;
 
 %!demo
 %! clf;
 %! colormap ("default");
 %! x = y = z = -1:1;
 %! f = @(x,y,z) x.^2 - y - z.^2;
 %! [xx, yy, zz] = meshgrid (x, y, z);
 %! v = f (xx,yy,zz);
 %! xi = yi = zi = -1:0.1:1;
 %! [xxi, yyi, zzi] = ndgrid (xi, yi, zi);
-%! vi = interpn (x, y, z, v, xxi, yyi, zzi, 'spline');
+%! vi = interpn (x, y, z, v, xxi, yyi, zzi, "spline");
 %! mesh (yi, zi, squeeze (vi(1,:,:)));
 
 %!test
 %! [x,y,z] = ndgrid (0:2);
 %! f = x + y + z;
 %! assert (interpn (x,y,z,f,[.5 1.5],[.5 1.5],[.5 1.5]), [1.5, 4.5]);
 %! assert (interpn (x,y,z,f,[.51 1.51],[.51 1.51],[.51 1.51],"nearest"), [3, 6]);
 %! assert (interpn (x,y,z,f,[.5 1.5],[.5 1.5],[.5 1.5],"spline"), [1.5, 4.5]);
diff --git a/scripts/general/isa.m b/scripts/general/isa.m
--- a/scripts/general/isa.m
+++ b/scripts/general/isa.m
@@ -46,16 +46,17 @@ function retval = isa (obj, cname)
     retval = strcmp (class_of_x, cname);
     if (! retval && isobject (obj))
       retval = __isa_parent__ (obj, cname);
     endif
   endif
 
 endfunction
 
+
 %!assert (isa ("char", "float"), false)
 %!assert (isa (logical (1), "float"), false)
 %!assert (isa (double (13), "float"), true)
 %!assert (isa (single (13), "float"), true)
 %!assert (isa (int8 (13), "float"), false)
 %!assert (isa (int16 (13), "float"), false)
 %!assert (isa (int32 (13), "float"), false)
 %!assert (isa (int64 (13), "float"), false)
@@ -71,26 +72,26 @@ endfunction
 %!assert (isa (int16 (13), "numeric"), true)
 %!assert (isa (int32 (13), "numeric"), true)
 %!assert (isa (int64 (13), "numeric"), true)
 %!assert (isa (uint8 (13), "numeric"), true)
 %!assert (isa (uint16 (13), "numeric"), true)
 %!assert (isa (uint32 (13), "numeric"), true)
 %!assert (isa (uint64 (13), "numeric"), true)
 
-%!assert (isa (double (13), "double"));
-%!assert (isa (single (13), "single"));
-%!assert (isa (int8 (13), "int8"));
-%!assert (isa (int16 (13), "int16"));
-%!assert (isa (int32 (13), "int32"));
-%!assert (isa (int64 (13), "int64"));
-%!assert (isa (uint8 (13), "uint8"));
-%!assert (isa (uint16 (13), "uint16"));
-%!assert (isa (uint32 (13), "uint32"));
-%!assert (isa (uint64 (13), "uint64"));
-%!assert (isa ("string", "char"));
-%!assert (isa (true, "logical"));
-%!assert (isa (false, "logical"));
-%!assert (isa ({1, 2}, "cell"));
+%!assert (isa (double (13), "double"))
+%!assert (isa (single (13), "single"))
+%!assert (isa (int8 (13), "int8"))
+%!assert (isa (int16 (13), "int16"))
+%!assert (isa (int32 (13), "int32"))
+%!assert (isa (int64 (13), "int64"))
+%!assert (isa (uint8 (13), "uint8"))
+%!assert (isa (uint16 (13), "uint16"))
+%!assert (isa (uint32 (13), "uint32"))
+%!assert (isa (uint64 (13), "uint64"))
+%!assert (isa ("string", "char"))
+%!assert (isa (true, "logical"))
+%!assert (isa (false, "logical"))
+%!assert (isa ({1, 2}, "cell"))
 %!test
 %! a.b = 1;
 %! assert (isa (a, "struct"));
 
diff --git a/scripts/general/isdir.m b/scripts/general/isdir.m
--- a/scripts/general/isdir.m
+++ b/scripts/general/isdir.m
@@ -27,13 +27,14 @@ function retval = isdir (f)
     print_usage ("isdir");
   endif
 
   ## Exist returns an integer but isdir should return a logical.
   retval = (exist (f, "dir") == 7);
 
 endfunction
 
-%!error isdir ();
-%!error isdir (1, 2);
+%!assert (isdir (pwd ()))
+%!assert (! isdir ("this is highly unlikely to be a directory name"))
 
-%!assert (isdir (pwd ()));
-%!assert (! isdir ("this is highly unlikely to be a directory name"));
+%!error isdir ()
+%!error isdir (1, 2)
+
diff --git a/scripts/general/isequal.m b/scripts/general/isequal.m
--- a/scripts/general/isequal.m
+++ b/scripts/general/isequal.m
@@ -27,22 +27,23 @@ function retval = isequal (x1, varargin)
   if (nargin < 2)
     print_usage ();
   endif
 
   retval = __isequal__ (false, x1, varargin{:});
 
 endfunction
 
+
 ## test size and shape
-%!assert(isequal([1,2,3,4],[1,2,3,4]), true)
-%!assert(isequal([1;2;3;4],[1;2;3;4]), true)
-%!assert(isequal([1,2,3,4],[1;2;3;4]), false)
-%!assert(isequal([1,2,3,4],[1,2;3,4]), false)
-%!assert(isequal([1,2,3,4],[1,3;2,4]), false)
+%!assert (isequal ([1,2,3,4],[1,2,3,4]), true)
+%!assert (isequal ([1;2;3;4],[1;2;3;4]), true)
+%!assert (isequal ([1,2,3,4],[1;2;3;4]), false)
+%!assert (isequal ([1,2,3,4],[1,2;3,4]), false)
+%!assert (isequal ([1,2,3,4],[1,3;2,4]), false)
 
 %!test
 %! A = 1:8;
 %! B = reshape (A, 2, 2, 2);
 %! assert (isequal (A, B), false);
 
 %!test
 %! A = reshape (1:8, 2, 2, 2);
@@ -50,25 +51,26 @@ endfunction
 %! assert (isequal (A, B), true);
 
 %!test
 %! A = reshape (1:8, 2, 4);
 %! B = reshape (A, 2, 2, 2);
 %! assert (isequal (A, B), false);
 
 ## test for equality
-%!assert(isequal([1,2,3,4],[1,2,3,4]), true)
-%!assert(isequal(['a','b','c','d'],['a','b','c','d']), true)
+%!assert (isequal ([1,2,3,4],[1,2,3,4]), true)
+%!assert (isequal (['a','b','c','d'],['a','b','c','d']), true)
 ## Test multi-line strings
-%!assert(isequal(["test";"strings"],["test";"strings"],["test";"strings"]), true)
+%!assert (isequal (["test";"strings"],["test";"strings"],["test";"strings"]), true)
 ## test for inequality
-%!assert(isequal([1,2,3,4],[1;2;3;4]),false)
-%!assert(isequal({1,2,3,4},[1,2,3,4]),false)
-%!assert(isequal([1,2,3,4],{1,2,3,4}),false)
-%!assert(isequal([1,2,NaN,4],[1,2,NaN,4]),false)
-%!assert(isequal(['a','b','c','d'],['a';'b';'c';'d']),false)
-%!assert(isequal({'a','b','c','d'},{'a';'b';'c';'d'}),false)
+%!assert (isequal ([1,2,3,4],[1;2;3;4]), false)
+%!assert (isequal ({1,2,3,4},[1,2,3,4]), false)
+%!assert (isequal ([1,2,3,4],{1,2,3,4}), false)
+%!assert (isequal ([1,2,NaN,4],[1,2,NaN,4]), false)
+%!assert (isequal (['a','b','c','d'],['a';'b';'c';'d']), false)
+%!assert (isequal ({'a','b','c','d'},{'a';'b';'c';'d'}), false)
 ## test for equality (struct)
-%!assert(isequal(struct('a',1,'b',2),struct('a',1,'b',2)),true)
-%!assert(isequal(struct('a',1,'b',2),struct('a',1,'b',2),struct('a',1,'b',2)),true)
-%!assert(isequal(struct('a','abc','b',2),struct('a','abc','b',2)),true)
+%!assert (isequal (struct ('a',1,'b',2),struct ('a',1,'b',2)), true)
+%!assert (isequal (struct ('a',1,'b',2),struct ('a',1,'b',2),struct ('a',1,'b',2)), true)
+%!assert (isequal (struct ('a',"abc",'b',2),struct ('a',"abc",'b',2)), true)
 ## test for inequality (struct)
-%!assert(isequal(struct('a',NaN,'b',2),struct('a',NaN,'b',2),struct('a',NaN,'b',2)),false)
+%!assert (isequal (struct ('a',NaN,'b',2),struct ('a',NaN,'b',2),struct ('a',NaN,'b',2)), false)
+
diff --git a/scripts/general/isequalwithequalnans.m b/scripts/general/isequalwithequalnans.m
--- a/scripts/general/isequalwithequalnans.m
+++ b/scripts/general/isequalwithequalnans.m
@@ -28,17 +28,19 @@ function retval = isequalwithequalnans (
   if (nargin < 2)
     print_usage ();
   endif
 
   retval = __isequal__ (true, x1, varargin{:});
 
 endfunction
 
+
 ## test for equality
-%!assert(isequalwithequalnans({1,2,NaN,4},{1,2,NaN,4}), true)
-%!assert(isequalwithequalnans([1,2,NaN,4],[1,2,NaN,4]), true)
+%!assert (isequalwithequalnans ({1,2,NaN,4},{1,2,NaN,4}), true)
+%!assert (isequalwithequalnans ([1,2,NaN,4],[1,2,NaN,4]), true)
 ## test for inequality
-%!assert(isequalwithequalnans([1,2,NaN,4],[1,NaN,3,4]),false)
-%!assert(isequalwithequalnans([1,2,NaN,4],[1,2,3,4]),false)
+%!assert (isequalwithequalnans ([1,2,NaN,4],[1,NaN,3,4]), false)
+%!assert (isequalwithequalnans ([1,2,NaN,4],[1,2,3,4]), false)
 ## test for equality (struct)
-%!assert(isequalwithequalnans(struct('a',NaN,'b',2),struct('a',NaN,'b',2),struct('a',NaN,'b',2)),true)
-%!assert(isequalwithequalnans(1,2,1), false)
+%!assert (isequalwithequalnans (struct ('a',NaN,'b',2),struct ('a',NaN,'b',2),struct ('a',NaN,'b',2)), true)
+%!assert (isequalwithequalnans (1,2,1), false)
+
diff --git a/scripts/general/issquare.m b/scripts/general/issquare.m
--- a/scripts/general/issquare.m
+++ b/scripts/general/issquare.m
@@ -36,27 +36,28 @@ function retval = issquare (x)
     [r, c] = size (x);
     retval = r == c;
   else
     retval = false;
   endif
 
 endfunction
 
-%!assert(issquare ([]));
-%!assert(issquare (1));
-%!assert(!(issquare ([1, 2])));
-%!assert(issquare ([1, 2; 3, 4]));
-%!assert(!(issquare ([1, 2; 3, 4; 5, 6])));
-%!assert(!(issquare (ones (3,3,3))));
-%!assert(issquare ("t"));
-%!assert(!(issquare ("test")));
-%!assert(issquare (["test"; "ing"; "1"; "2"]));
+
+%!assert (issquare ([]))
+%!assert (issquare (1))
+%!assert (! issquare ([1, 2]))
+%!assert (issquare ([1, 2; 3, 4]))
+%!assert (! issquare ([1, 2; 3, 4; 5, 6]))
+%!assert (! issquare (ones (3,3,3)))
+%!assert (issquare ("t"))
+%!assert (! issquare ("test"))
+%!assert (issquare (["test"; "ing"; "1"; "2"]))
 %!test
 %! s.a = 1;
-%! assert(issquare (s));
-%!assert(issquare ({1, 2; 3, 4}));
-%!assert(sparse (([1, 2; 3, 4])));
+%! assert (issquare (s));
+%!assert (issquare ({1, 2; 3, 4}))
+%!assert (sparse (([1, 2; 3, 4])))
 
 %% Test input validation
-%!error issquare ();
-%!error issquare ([1, 2; 3, 4], 2);
+%!error issquare ()
+%!error issquare ([1, 2; 3, 4], 2)
 
diff --git a/scripts/general/logspace.m b/scripts/general/logspace.m
--- a/scripts/general/logspace.m
+++ b/scripts/general/logspace.m
@@ -86,14 +86,14 @@ endfunction
 %! x3 = logspace (1, -2, 10);
 %! x4 = logspace (1, pi, 10);
 %! assert (size (x1) == [1, 50] && x1(1) == 10 && x1(50) == 100);
 %! assert (size (x2) == [1, 10] && x2(1) == 10 && x2(10) == 100);
 %! assert (size (x3) == [1, 10] && x3(1) == 10 && x3(10) == 0.01);
 %! assert (size (x4) == [1, 10] && x4(1) == 10 && abs (x4(10) - pi) < sqrt (eps));
 
 %% Test input validation
-%!error logspace ();
-%!error logspace (1, 2, 3, 4);
-%!error logspace ([1, 2; 3, 4], 5, 6);
-%!error logspace (1, [1, 2; 3, 4], 6);
-%!error logspace (1, 2, [1, 2; 3, 4]);
+%!error logspace ()
+%!error logspace (1, 2, 3, 4)
+%!error logspace ([1, 2; 3, 4], 5, 6)
+%!error logspace (1, [1, 2; 3, 4], 6)
+%!error logspace (1, 2, [1, 2; 3, 4])
 
diff --git a/scripts/general/nargchk.m b/scripts/general/nargchk.m
--- a/scripts/general/nargchk.m
+++ b/scripts/general/nargchk.m
@@ -58,23 +58,24 @@ function msg = nargchk (minargs, maxargs
     msg = resize (msg, 0, 1);
   endif
 
 endfunction
 
 
 ## Tests
 %!shared stnul, stmin, stmax
-%!  stnul = resize (struct ("message", "", "identifier", ""), 0, 1);
-%!  stmin = struct ("message", "not enough input arguments",
-%!                  "identifier", "Octave:nargchk:not-enough-inputs");
-%!  stmax = struct ("message", "too many input arguments",
-%!                  "identifier", "Octave:nargchk:too-many-inputs");
+%! stnul = resize (struct ("message", "", "identifier", ""), 0, 1);
+%! stmin = struct ("message", "not enough input arguments",
+%!                 "identifier", "Octave:nargchk:not-enough-inputs");
+%! stmax = struct ("message", "too many input arguments",
+%!                 "identifier", "Octave:nargchk:too-many-inputs");
 %!assert (nargchk (0, 1, 0), "")
 %!assert (nargchk (0, 1, 1), "")
 %!assert (nargchk (1, 1, 0), "not enough input arguments")
 %!assert (nargchk (0, 1, 2), "too many input arguments")
 %!assert (nargchk (0, 1, 2, "string"), "too many input arguments")
 ## Struct outputs
-%!assert (isequal (nargchk (0, 1, 0, "struct"), stnul))
-%!assert (isequal (nargchk (0, 1, 1, "struct"), stnul))
+%!assert (nargchk (0, 1, 0, "struct"), stnul)
+%!assert (nargchk (0, 1, 1, "struct"), stnul)
 %!assert (nargchk (1, 1, 0, "struct"), stmin)
 %!assert (nargchk (0, 1, 2, "struct"), stmax)
+
diff --git a/scripts/general/narginchk.m b/scripts/general/narginchk.m
--- a/scripts/general/narginchk.m
+++ b/scripts/general/narginchk.m
@@ -50,20 +50,21 @@ function narginchk (minargs, maxargs)
   if (args < minargs)
     error ("not enough input arguments");
   elseif (args > maxargs)
     error ("too many input arguments");
   endif
 
 endfunction
 
+
 %!function f (nargs, varargin)
 %! narginchk (nargs(1), nargs(2));
 %!endfunction
 
 %!error <too many input arguments> f([0,0])
 %!error <not enough input arguments> f([3, 3], 1)
 
 %!test
 %! f([1,1])
-
 %!test
 %! f([1,5], 2, 3, 4, 5)
+
diff --git a/scripts/general/nargoutchk.m b/scripts/general/nargoutchk.m
--- a/scripts/general/nargoutchk.m
+++ b/scripts/general/nargoutchk.m
@@ -99,26 +99,26 @@ function msg = nargoutchk (minargs, maxa
     endif
 
   else
     print_usage;
   endif
 
 endfunction
 
-## Tests
+
 %!shared stnul, stmin, stmax
-%!  stnul = resize (struct ("message", "", "identifier", ""), 0, 1);
-%!  stmin = struct ("message", "not enough output arguments",
-%!                  "identifier", "Octave:nargoutchk:not-enough-outputs");
-%!  stmax = struct ("message", "too many output arguments",
-%!                  "identifier", "Octave:nargoutchk:too-many-outputs");
+%! stnul = resize (struct ("message", "", "identifier", ""), 0, 1);
+%! stmin = struct ("message", "not enough output arguments",
+%!                 "identifier", "Octave:nargoutchk:not-enough-outputs");
+%! stmax = struct ("message", "too many output arguments",
+%!                 "identifier", "Octave:nargoutchk:too-many-outputs");
 %!assert (nargoutchk (0, 1, 0), "")
 %!assert (nargoutchk (0, 1, 1), "")
 %!assert (nargoutchk (1, 1, 0), "not enough output arguments")
 %!assert (nargoutchk (0, 1, 2), "too many output arguments")
 %!assert (nargoutchk (0, 1, 2, "string"), "too many output arguments")
 ## Struct outputs
-%!assert (isequal (nargoutchk (0, 1, 0, "struct"), stnul))
-%!assert (isequal (nargoutchk (0, 1, 1, "struct"), stnul))
+%!assert (nargoutchk (0, 1, 0, "struct"), stnul)
+%!assert (nargoutchk (0, 1, 1, "struct"), stnul)
 %!assert (nargoutchk (1, 1, 0, "struct"), stmin)
 %!assert (nargoutchk (0, 1, 2, "struct"), stmax)
 
diff --git a/scripts/general/nextpow2.m b/scripts/general/nextpow2.m
--- a/scripts/general/nextpow2.m
+++ b/scripts/general/nextpow2.m
@@ -51,18 +51,20 @@ function n = nextpow2 (x)
 
   [f, n] = log2 (abs (x));
   if (f == 0.5)
     n = n - 1;
   endif
 
 endfunction
 
-%!error nexpow2 ();
-%!error nexpow2 (1, 2);
 
-%!assert (nextpow2 (16), 4);
-%!assert (nextpow2 (17), 5);
-%!assert (nextpow2 (31), 5);
-%!assert (nextpow2 (-16), 4);
-%!assert (nextpow2 (-17), 5);
-%!assert (nextpow2 (-31), 5);
-%!assert (nextpow2 (1:17), 5);
+%!assert (nextpow2 (16), 4)
+%!assert (nextpow2 (17), 5)
+%!assert (nextpow2 (31), 5)
+%!assert (nextpow2 (-16), 4)
+%!assert (nextpow2 (-17), 5)
+%!assert (nextpow2 (-31), 5)
+%!assert (nextpow2 (1:17), 5)
+
+%!error nexpow2 ()
+%!error nexpow2 (1, 2)
+
diff --git a/scripts/general/nthargout.m b/scripts/general/nthargout.m
--- a/scripts/general/nthargout.m
+++ b/scripts/general/nthargout.m
@@ -102,12 +102,14 @@ function out = nthargout (n, varargin)
       error ("nthargout: Too many output arguments: %d", ntot);
     else
       error (err);
     endif
   end_try_catch
 
 endfunction
 
+
 %!shared m
 %! m = magic (5);
-%!assert (nthargout ([1, 2], @ind2sub, size(m), nthargout (2, @max, m(:))), {5,3}) 
+%!assert (nthargout ([1,2], @ind2sub, size (m), nthargout (2, @max, m(:))), {5,3})
 %!assert (nthargout (3, @find, m(m>20)), [23, 24, 25, 21, 22]')
+
diff --git a/scripts/general/num2str.m b/scripts/general/num2str.m
--- a/scripts/general/num2str.m
+++ b/scripts/general/num2str.m
@@ -172,15 +172,18 @@ function retval = num2str (x, arg)
     nd = ndims (x);
     tmp = sprintf (fmt, permute (x, [2, 1, 3:nd]));
     tmp(length (tmp)) = "";
     retval = strtrim (char (strsplit (tmp, "\n")));
   endif
 
 endfunction
 
-%!assert ((strcmp (num2str (123), "123") && strcmp (num2str (1.23), "1.23")));
-%!assert (num2str (123.456, 4), "123.5");
-%!assert (all (num2str ([1, 1.34; 3, 3.56], "%5.1f") == ["1.0  1.3"; "3.0  3.6"]));
-%!assert (num2str (1.234 + 27.3i), "1.234+27.3i");
-%!error num2str ();
-%!error num2str (1, 2, 3);
 
+%!assert (num2str (123), "123")
+%!assert (num2str (1.23), "1.23")
+%!assert (num2str (123.456, 4), "123.5")
+%!assert (num2str ([1, 1.34; 3, 3.56], "%5.1f"),  ["1.0  1.3"; "3.0  3.6"])
+%!assert (num2str (1.234 + 27.3i), "1.234+27.3i")
+
+%!error num2str ()
+%!error num2str (1, 2, 3)
+
diff --git a/scripts/general/pol2cart.m b/scripts/general/pol2cart.m
--- a/scripts/general/pol2cart.m
+++ b/scripts/general/pol2cart.m
@@ -75,68 +75,69 @@ function [x, y, z] = pol2cart (theta, r,
   y = r .* sin (theta);
 
   if (nargout <= 1)
     x  = [x, y, z];
   endif
 
 endfunction
 
+
 %!test
 %! t = [0, 0.5, 1] * pi;
 %! r = 1;
 %! [x, y] = pol2cart (t, r);
-%! assert (x, [1, 0, -1], sqrt(eps));
-%! assert (y, [0, 1,  0], sqrt(eps));
+%! assert (x, [1, 0, -1], sqrt (eps));
+%! assert (y, [0, 1,  0], sqrt (eps));
 
 %!test
 %! t = [0, 1, 1] * pi/4;
-%! r = sqrt(2) * [0, 1, 2];
+%! r = sqrt (2) * [0, 1, 2];
 %! [x, y] = pol2cart (t, r);
-%! assert (x, [0, 1, 2], sqrt(eps));
-%! assert (y, [0, 1, 2], sqrt(eps));
+%! assert (x, [0, 1, 2], sqrt (eps));
+%! assert (y, [0, 1, 2], sqrt (eps));
 
 %!test
 %! t = [0, 1, 1] * pi/4;
-%! r = sqrt(2) * [0, 1, 2];
+%! r = sqrt (2) * [0, 1, 2];
 %! z = [0, 1, 2];
 %! [x, y, z2] = pol2cart (t, r, z);
-%! assert (x, [0, 1, 2], sqrt(eps));
-%! assert (y, [0, 1, 2], sqrt(eps));
+%! assert (x, [0, 1, 2], sqrt (eps));
+%! assert (y, [0, 1, 2], sqrt (eps));
 %! assert (z, z2);
 
 %!test
 %! t = 0;
 %! r = [0, 1, 2];
 %! z = [0, 1, 2];
 %! [x, y, z2] = pol2cart (t, r, z);
-%! assert (x, [0, 1, 2], sqrt(eps));
-%! assert (y, [0, 0, 0], sqrt(eps));
+%! assert (x, [0, 1, 2], sqrt (eps));
+%! assert (y, [0, 0, 0], sqrt (eps));
 %! assert (z, z2);
 
 %!test
 %! t = [1, 1, 1]*pi/4;
 %! r = 1;
 %! z = [0, 1, 2];
 %! [x, y, z2] = pol2cart (t, r, z);
-%! assert (x, [1, 1, 1] / sqrt(2), eps);
-%! assert (y, [1, 1, 1] / sqrt(2), eps);
+%! assert (x, [1, 1, 1] / sqrt (2), eps);
+%! assert (y, [1, 1, 1] / sqrt (2), eps);
 %! assert (z, z2);
 
 %!test
 %! t = 0;
 %! r = [1, 2, 3];
 %! z = 1;
 %! [x, y, z2] = pol2cart (t, r, z);
 %! assert (x, [1, 2, 3], eps);
-%! assert (y, [0, 0, 0] / sqrt(2), eps);
+%! assert (y, [0, 0, 0] / sqrt (2), eps);
 %! assert (z, z2);
 
 %!test
 %! P = [0, 0; pi/4, sqrt(2); pi/4, 2*sqrt(2)];
 %! C = [0, 0; 1, 1; 2, 2];
-%! assert (pol2cart(P), C, sqrt(eps));
+%! assert (pol2cart (P), C, sqrt (eps));
 
 %!test
 %! P = [0, 0, 0; pi/4, sqrt(2), 1; pi/4, 2*sqrt(2), 2];
 %! C = [0, 0, 0; 1, 1, 1; 2, 2, 2];
-%! assert (pol2cart(P), C, sqrt(eps));
+%! assert (pol2cart (P), C, sqrt (eps));
 
diff --git a/scripts/general/polyarea.m b/scripts/general/polyarea.m
--- a/scripts/general/polyarea.m
+++ b/scripts/general/polyarea.m
@@ -56,15 +56,17 @@ function a = polyarea (x, y, dim)
     else
       a = abs (sum (x .* (shift (y, -1, dim) - shift (y, 1, dim)), dim)) / 2;
     endif
   else
     error ("polyarea: X and Y must have the same shape");
   endif
 endfunction
 
+
 %!shared x, y
 %! x = [1;1;3;3;1];
 %! y = [1;3;3;1;1];
-%!assert (polyarea(x,y), 4, eps)
-%!assert (polyarea([x,x],[y,y]), [4,4], eps)
-%!assert (polyarea([x,x],[y,y],1), [4,4], eps)
-%!assert (polyarea([x,x]',[y,y]',2), [4;4], eps)
+%!assert (polyarea (x,y), 4, eps)
+%!assert (polyarea ([x,x],[y,y]), [4,4], eps)
+%!assert (polyarea ([x,x],[y,y],1), [4,4], eps)
+%!assert (polyarea ([x,x]',[y,y]',2), [4;4], eps)
+
diff --git a/scripts/general/postpad.m b/scripts/general/postpad.m
--- a/scripts/general/postpad.m
+++ b/scripts/general/postpad.m
@@ -78,20 +78,20 @@ function y = postpad (x, l, c, dim)
     y = x(idx{:});
   else
     sz (dim) = l - d;
     y = cat (dim, x, c * ones (sz));
   endif
 
 endfunction
 
-%!error postpad ();
-%!error postpad (1);
-%!error postpad (1,2,3,4,5);
-%!error postpad ([1,2], 2, 2,3);
 
-%!assert (postpad ([1,2], 4), [1,2,0,0]);
-%!assert (postpad ([1;2], 4), [1;2;0;0]);
+%!assert (postpad ([1,2], 4), [1,2,0,0])
+%!assert (postpad ([1;2], 4), [1;2;0;0])
+%!assert (postpad ([1,2], 4, 2), [1,2,2,2])
+%!assert (postpad ([1;2], 4, 2), [1;2;2;2])
+%!assert (postpad ([1,2], 2, 2, 1), [1,2;2,2])
 
-%!assert (postpad ([1,2], 4, 2), [1,2,2,2]);
-%!assert (postpad ([1;2], 4, 2), [1;2;2;2]);
+%!error postpad ()
+%!error postpad (1)
+%!error postpad (1,2,3,4,5)
+%!error postpad ([1,2], 2, 2,3)
 
-%!assert (postpad ([1,2], 2, 2, 1), [1,2;2,2]);
diff --git a/scripts/general/prepad.m b/scripts/general/prepad.m
--- a/scripts/general/prepad.m
+++ b/scripts/general/prepad.m
@@ -78,22 +78,24 @@ function y = prepad (x, l, c, dim)
     y = x(idx{:});
   else
     sz (dim) = l - d;
     y = cat (dim, c * ones (sz), x);
   endif
 
 endfunction
 
-%!error prepad ();
-%!error prepad (1);
-%!error prepad (1,2,3,4,5);
-%!error prepad ([1,2], 2, 2,3);
+
+%!assert (prepad ([1,2], 4), [0,0,1,2])
+%!assert (prepad ([1;2], 4), [0;0;1;2])
 
-%!assert (prepad ([1,2], 4), [0,0,1,2]);
-%!assert (prepad ([1;2], 4), [0;0;1;2]);
+%!assert (prepad ([1,2], 4, 2), [2,2,1,2])
+%!assert (prepad ([1;2], 4, 2), [2;2;1;2])
 
-%!assert (prepad ([1,2], 4, 2), [2,2,1,2]);
-%!assert (prepad ([1;2], 4, 2), [2;2;1;2]);
-
-%!assert (prepad ([1,2], 2, 2, 1), [2,2;1,2]);
+%!assert (prepad ([1,2], 2, 2, 1), [2,2;1,2])
 
 ## FIXME -- we need tests for multidimensional arrays.
+
+%!error prepad ()
+%!error prepad (1)
+%!error prepad (1,2,3,4,5)
+%!error prepad ([1,2], 2, 2,3)
+
diff --git a/scripts/general/profexplore.m b/scripts/general/profexplore.m
--- a/scripts/general/profexplore.m
+++ b/scripts/general/profexplore.m
@@ -16,17 +16,17 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} profexplore (@var{data})
 ## Interactively explore hierarchical profiler output.
 ##
 ## Assuming @var{data} is the structure with profile data returned by
-## @code{profile ('info')}, this command opens an interactive prompt
+## @code{profile ("info")}, this command opens an interactive prompt
 ## that can be used to explore the call-tree.  Type @kbd{help} to get a list
 ## of possible commands.
 ## @seealso{profile, profshow}
 ## @end deftypefn
 
 ## Built-in profiler.
 ## Author: Daniel Kraft <d@domob.eu>
 
@@ -40,17 +40,17 @@ function profexplore (data)
   ## is an easy way to traverse the tree datastructure.  Here, we just check
   ## the arguments (already done) and give over to it.
 
   __profexplore_worker (data.FunctionTable, data.Hierarchical, "Top\n", "  ");
 
 endfunction
 
 ## This is the worker function.  tree is the current subtree we want to
-## display / explore.  parents is a string containing the already 'rendered'
+## display / explore.  parents is a string containing the already "rendered"
 ## data for the parents which is displayed on top of the list of current
 ## children.  prefix is the prefix to add to each line rendered; this
 ## is just a string of spaces to get indentation right.
 ##
 ## Returning 0 indicates that the user requested to totally exit the
 ## explorer, thus also all higher levels should exit immediately.  An integer
 ## greater zero indicates to exit that many levels since the user wants to go
 ## up (but not necessarily quit).
diff --git a/scripts/general/profile.m b/scripts/general/profile.m
--- a/scripts/general/profile.m
+++ b/scripts/general/profile.m
@@ -16,42 +16,42 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Command} {} profile on
 ## @deftypefnx {Command} {} profile off
 ## @deftypefnx {Command} {} profile resume
 ## @deftypefnx {Command} {} profile clear
-## @deftypefnx {Function File} {@var{S} =} profile ('status')
-## @deftypefnx {Function File} {@var{T} =} profile ('info')
+## @deftypefnx {Function File} {@var{S} =} profile ("status")
+## @deftypefnx {Function File} {@var{T} =} profile ("info")
 ## Control the built-in profiler.
 ##
 ## @table @code
 ## @item profile on
 ## Start the profiler, clearing all previously collected data if there
 ## is any.
 ##
 ## @item profile off
 ## Stop profiling.  The collected data can later be retrieved and examined
-## with calls like @code{S = profile ('info')}.
+## with calls like @code{S = profile ("info")}.
 ##
 ## @item profile clear
 ## Clear all collected profiler data.
 ##
 ## @item profile resume
 ## Restart profiling without cleaning up the old data and instead
 ## all newly collected statistics are added to the already existing ones.
 ##
-## @item @var{S} = profile ('status')
+## @item @var{S} = profile ("status")
 ## Return a structure filled with certain information about the current status
 ## of the profiler.  At the moment, the only field is @code{ProfilerStatus}
-## which is either 'on' or 'off'.
+## which is either "on" or "off".
 ##
-## @item @var{T} = profile ('info')
+## @item @var{T} = profile ("info")
 ## Return the collected profiling statistics in the structure @var{T}.
 ## The flat profile is returned in the field @code{FunctionTable} which is an
 ## array of structures, each entry corresponding to a function which was called
 ## and for which profiling statistics are present.  Furthermore, the field
 ## @code{Hierarchical} contains the hierarchical call-tree.  Each node
 ## has an index into the @code{FunctionTable} identifying the function it
 ## corresponds to as well as data fields for number of calls and time spent
 ## at this level in the call-tree.
@@ -145,10 +145,10 @@ endfunction
 %! assert (fieldnames (ftbl), {"FunctionName"; "TotalTime"; "NumCalls"; "IsRecursive"; "Parents"; "Children"});
 %! hier = info.Hierarchical;
 %! assert (size (hier), [0, 1]);
 %! assert (fieldnames (hier), {"Index"; "SelfTime"; "NumCalls"; "Children"});
 
 %% Test input validation
 %!error profile ()
 %!error profile ("on", 2)
-%!error profile ("INVALID_OPTION");
+%!error profile ("INVALID_OPTION")
 
diff --git a/scripts/general/profshow.m b/scripts/general/profshow.m
--- a/scripts/general/profshow.m
+++ b/scripts/general/profshow.m
@@ -17,17 +17,17 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} profshow (@var{data})
 ## @deftypefnx {Function File} {} profshow (@var{data}, @var{n})
 ## Show flat profiler results.
 ##
 ## This command prints out profiler data as a flat profile.  @var{data} is the
-## structure returned by @code{profile ('info')}.  If @var{n} is given, it
+## structure returned by @code{profile ("info")}.  If @var{n} is given, it
 ## specifies the number of functions to show in the profile; functions are
 ## sorted in descending order by total time spent in them.  If there are more
 ## than @var{n} included in the profile, those will not be shown.  @var{n}
 ## defaults to 20.
 ##
 ## The attribute column shows @samp{R} for recursive functions and nothing
 ## otherwise.
 ## @seealso{profexplore, profile}
@@ -91,12 +91,12 @@ endfunction
 %! profshow (T, 10);
 
 %!demo
 %! profile on;
 %! expm (rand (500) + eye (500));
 %! profile off;
 %! profshow (profile ("info"), 5);
 
-%!error profshow ();
-%!error profshow (1, 2, 3);
-%!error profshow (struct (), 1.2);
+%!error profshow ()
+%!error profshow (1, 2, 3)
+%!error profshow (struct (), 1.2)
 
diff --git a/scripts/general/quadgk.m b/scripts/general/quadgk.m
--- a/scripts/general/quadgk.m
+++ b/scripts/general/quadgk.m
@@ -37,17 +37,17 @@
 ## given values of @var{x}.
 ##
 ## @var{a} and @var{b} are the lower and upper limits of integration.  Either
 ## or both limits may be infinite or contain weak end singularities.
 ## Variable transformation will be used to treat any infinite intervals and
 ## weaken the singularities.  For example:
 ##
 ## @example
-## quadgk(@@(x) 1 ./ (sqrt (x) .* (x + 1)), 0, Inf)
+## quadgk (@@(x) 1 ./ (sqrt (x) .* (x + 1)), 0, Inf)
 ## @end example
 ##
 ## @noindent
 ## Note that the formulation of the integrand uses the
 ## element-by-element operator @code{./} and all user functions to
 ## @code{quadgk} should do the same.
 ##
 ## The optional argument @var{tol} defines the absolute tolerance used to stop
@@ -73,28 +73,28 @@
 ## relative tolerance is 1e-5.
 ##
 ## @item MaxIntervalCount
 ## @code{quadgk} initially subdivides the interval on which to perform
 ## the quadrature into 10 intervals.  Subintervals that have an
 ## unacceptable error are subdivided and re-evaluated.  If the number of
 ## subintervals exceeds 650 subintervals at any point then a poor
 ## convergence is signaled and the current estimate of the integral is
-## returned.  The property 'MaxIntervalCount' can be used to alter the
+## returned.  The property "MaxIntervalCount" can be used to alter the
 ## number of subintervals that can exist before exiting.
 ##
 ## @item WayPoints
 ## Discontinuities in the first derivative of the function to integrate can be
 ## flagged with the  @code{"WayPoints"} property.  This forces the ends of
 ## a subinterval to fall on the breakpoints of the function and can result in
 ## significantly improved estimation of the error in the integral, faster
 ## computation, or both.  For example,
 ##
 ## @example
-## quadgk (@@(x) abs (1 - x.^2), 0, 2, 'Waypoints', 1)
+## quadgk (@@(x) abs (1 - x.^2), 0, 2, "Waypoints", 1)
 ## @end example
 ##
 ## @noindent
 ## signals the breakpoint in the integrand at @code{@var{x} = 1}.
 ##
 ## @item Trace
 ## If logically true @code{quadgk} prints information on the
 ## convergence of the quadrature at each iteration.
@@ -435,27 +435,29 @@ function [q, err] = __quadgk_eval__ (f, 
 endfunction
 
 function t = __quadgk_finite_waypoint__ (x, a, b)
   c = (-4 .* x + 2.* (b + a)) ./ (b - a);
   k = ((sqrt(c .^ 2 - 4) + c) ./ 2) .^ (1/3);
   t = real ((sqrt(3) .* 1i * (1 - k .^ 2) - (1 + k .^ 2)) ./ 2 ./ k);
 endfunction
 
+
+%!assert (quadgk (@sin,-pi,pi), 0, 1e-6)
+%!assert (quadgk (inline ("sin"),-pi,pi), 0, 1e-6)
+%!assert (quadgk ("sin",-pi,pi), 0, 1e-6)
+%!assert (quadgk (@sin,-pi,pi, "waypoints", 0, "MaxIntervalCount", 100, "reltol", 1e-3, "abstol", 1e-6, "trace", false), 0, 1e-6)
+%!assert (quadgk (@sin,-pi,pi, 1e-6,false), 0, 1e-6)
+
+%!assert (quadgk (@sin,-pi,0), -2, 1e-6)
+%!assert (quadgk (@sin,0,pi), 2, 1e-6)
+%!assert (quadgk (@(x) 1./sqrt (x),0,1), 2, 1e-6)
+%!assert (quadgk (@(x) abs (1 - x.^2),0,2, "Waypoints", 1), 2, 1e-6)
+%!assert (quadgk (@(x) 1./(sqrt (x) .* (x+1)),0,Inf), pi, 1e-6)
+%!assert (quadgk (@(z) log (z),1+1i,1+1i, "WayPoints", [1-1i, -1,-1i, -1+1i]), -pi * 1i, 1e-6)
+
+%!assert (quadgk (@(x) exp (-x .^ 2),-Inf,Inf), sqrt (pi), 1e-6)
+%!assert (quadgk (@(x) exp (-x .^ 2),-Inf,0), sqrt (pi)/2, 1e-6)
+
 %error (quadgk (@sin))
 %error (quadgk (@sin, -pi))
-%error (quadgk (@sin, -pi, pi, 'DummyArg'))
-
-%!assert (quadgk(@sin,-pi,pi), 0, 1e-6)
-%!assert (quadgk(inline('sin'),-pi,pi), 0, 1e-6)
-%!assert (quadgk('sin',-pi,pi), 0, 1e-6)
-%!assert (quadgk(@sin,-pi,pi,'waypoints', 0, 'MaxIntervalCount', 100, 'reltol', 1e-3, 'abstol', 1e-6, 'trace', false), 0, 1e-6)
-%!assert (quadgk(@sin,-pi,pi,1e-6,false), 0, 1e-6)
+%error (quadgk (@sin, -pi, pi, "DummyArg"))
 
-%!assert (quadgk(@sin,-pi,0), -2, 1e-6)
-%!assert (quadgk(@sin,0,pi), 2, 1e-6)
-%!assert (quadgk(@(x) 1./sqrt(x), 0, 1), 2, 1e-6)
-%!assert (quadgk (@(x) abs (1 - x.^2), 0, 2, 'Waypoints', 1), 2, 1e-6)
-%!assert (quadgk(@(x) 1./(sqrt(x).*(x+1)), 0, Inf), pi, 1e-6)
-%!assert (quadgk (@(z) log (z), 1+1i, 1+1i, 'WayPoints', [1-1i, -1,-1i, -1+1i]), -pi * 1i, 1e-6)
-
-%!assert (quadgk (@(x) exp(-x .^ 2), -Inf, Inf), sqrt(pi), 1e-6)
-%!assert (quadgk (@(x) exp(-x .^ 2), -Inf, 0), sqrt(pi)/2, 1e-6)
diff --git a/scripts/general/quadv.m b/scripts/general/quadv.m
--- a/scripts/general/quadv.m
+++ b/scripts/general/quadv.m
@@ -143,19 +143,21 @@ function [q, nfun, hmin] = simpsonstp (f
                                     tol, trace, varargin{:});
       [q2, nfun, hmin] = simpsonstp (f, c, b, e, fc, fb, fe, q2, nfun, hmin,
                                      tol, trace, varargin{:});
       q = q1 + q2;
     endif
   endif
 endfunction
 
+
 %!assert (quadv (@sin, 0, 2 * pi), 0, 1e-5)
 %!assert (quadv (@sin, 0, pi), 2, 1e-5)
 
 %% Handles weak singularities at the edge
 %!assert (quadv (@(x) 1 ./ sqrt(x), 0, 1), 2, 1e-5)
 
 %% Handles vector-valued functions
 %!assert (quadv (@(x) [(sin (x)), (sin (2 * x))], 0, pi), [2, 0], 1e-5)
 
 %% Handles matrix-valued functions
 %!assert (quadv (@(x) [ x, x, x; x, 1./sqrt(x), x; x, x, x ], 0, 1 ), [0.5, 0.5, 0.5; 0.5, 2, 0.5; 0.5, 0.5, 0.5], 1e-5)
+
diff --git a/scripts/general/randi.m b/scripts/general/randi.m
--- a/scripts/general/randi.m
+++ b/scripts/general/randi.m
@@ -35,17 +35,17 @@
 ## on the interval @w{[@var{imin}, @var{imax}]}.
 ##
 ## The optional argument "@var{class}" will return a matrix of the requested
 ## type.  The default is "double".
 ##
 ## The following example returns 150 integers in the range 1-10.
 ##
 ## @example
-## ri = randi (10, 150, 1);
+## ri = randi (10, 150, 1)
 ## @end example
 ##
 ## Implementation Note: @code{randi} relies internally on @code{rand} which
 ## uses class "double" to represent numbers.  This limits the maximum
 ## integer (@var{imax}) and range (@var{imax} - @var{imin}) to the value
 ## returned by the @code{bitmax} function.  For IEEE floating point numbers
 ## this value is @w{@math{2^{53} - 1}}.
 ##
@@ -108,34 +108,34 @@ function ri = randi (bounds, varargin)
   if (! strcmp (rclass, "double"))
     ri = cast (ri, rclass);
   endif
 
 endfunction
 
 %!test
 %! ri = randi (10, 1000, 1);
-%! assert(isequal(ri, fix (ri)));
-%! assert(min(ri) == 1);
-%! assert(max(ri) == 10);
-%! assert(rows(ri) == 1000);
-%! assert(columns(ri) == 1);
-%! assert(strcmp (class (ri), "double"));
+%! assert (ri, fix (ri));
+%! assert (min (ri), 1);
+%! assert (max (ri), 10);
+%! assert (rows (ri), 1000);
+%! assert (columns (ri), 1);
+%! assert (class (ri), "double");
 %!test
 %! ri = randi ([-5, 10], 1000, 1, "int8");
-%! assert(isequal(ri, fix (ri)));
-%! assert(min(ri) == -5);
-%! assert(max(ri) == 10);
-%! assert(strcmp (class (ri), "int8"));
+%! assert (ri, fix (ri));
+%! assert (min (ri), int8 (-5));
+%! assert (max (ri), int8 (10));
+%! assert (class (ri), "int8");
 %!
-%!assert(size (randi(10, 3,1,2)) == [3, 1, 2])
+%!assert (size (randi (10, 3,1,2)), [3, 1, 2])
 
 %% Test input validation
-%!error(randi())
-%!error(randi("test"))
-%!error(randi(10+2i))
-%!error(randi(0))
-%!error(randi([10, 1]))
-%!error(randi(256, "uint8"))
-%!error(randi(2^25, "single"))
-%!error(randi(bitmax() + 1))
-%!error(randi([-1, bitmax()]))
+%!error (randi ())
+%!error (randi ("test"))
+%!error (randi (10+2i))
+%!error (randi (0))
+%!error (randi ([10, 1]))
+%!error (randi (256, "uint8"))
+%!error (randi (2^25, "single"))
+%!error (randi (bitmax () + 1))
+%!error (randi ([-1, bitmax()]))
 
diff --git a/scripts/general/rat.m b/scripts/general/rat.m
--- a/scripts/general/rat.m
+++ b/scripts/general/rat.m
@@ -20,19 +20,19 @@
 ## @deftypefn  {Function File} {@var{s} =} rat (@var{x}, @var{tol})
 ## @deftypefnx {Function File} {[@var{n}, @var{d}] =} rat (@var{x}, @var{tol})
 ##
 ## Find a rational approximation to @var{x} within the tolerance defined
 ## by @var{tol} using a continued fraction expansion.  For example:
 ##
 ## @example
 ## @group
-## rat(pi) = 3 + 1/(7 + 1/16) = 355/113
-## rat(e) = 3 + 1/(-4 + 1/(2 + 1/(5 + 1/(-2 + 1/(-7)))))
-##        = 1457/536
+## rat (pi) = 3 + 1/(7 + 1/16) = 355/113
+## rat (e) = 3 + 1/(-4 + 1/(2 + 1/(5 + 1/(-2 + 1/(-7)))))
+##         = 1457/536
 ## @end group
 ## @end example
 ##
 ## Called with two arguments returns the numerator and denominator separately
 ## as two matrices.
 ## @seealso{rats}
 ## @end deftypefn
 
@@ -146,15 +146,17 @@ function [n,d] = rat(x,tol)
         n(:,n_nc+1:s_nc) = " ";
       endif
       n = cat (1, n, s);
     endfor
   endif
 
 endfunction
 
-%!error rat ();
-%!error rat (1, 2, 3);
 
 %!test
 %! [n, d] = rat ([0.5, 0.3, 1/3]);
 %! assert (n, [1, 3, 1]);
 %! assert (d, [2, 10, 3]);
+
+%!error rat ();
+%!error rat (1, 2, 3);
+
diff --git a/scripts/general/repmat.m b/scripts/general/repmat.m
--- a/scripts/general/repmat.m
+++ b/scripts/general/repmat.m
@@ -19,17 +19,17 @@
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} repmat (@var{A}, @var{m})
 ## @deftypefnx {Function File} {} repmat (@var{A}, @var{m}, @var{n})
 ## @deftypefnx {Function File} {} repmat (@var{A}, [@var{m} @var{n}])
 ## @deftypefnx {Function File} {} repmat (@var{A}, [@var{m} @var{n} @var{p} @dots{}])
 ## Form a block matrix of size @var{m} by @var{n}, with a copy of matrix
 ## @var{A} as each element.  If @var{n} is not specified, form an
-## @var{m} by @var{m} block matrix. For copying along more than two
+## @var{m} by @var{m} block matrix.  For copying along more than two
 ## dimensions, specify the number of times to copy across each dimension
 ## @var{m}, @var{n}, @var{p}, @dots{}, in a vector in the second argument.
 ## @seealso{repelems}
 ## @end deftypefn
 
 ## Author: Paul Kienzle <pkienzle@kienzle.powernet.co.uk>
 ## Created: July 2000
 
@@ -96,68 +96,69 @@ function x = repmat (A, m, n)
     # add singleton dims
     aaidx(2,:) = 1;
     A = reshape (A, aaidx(:));
     x = reshape (A (cidx{:}), idx .* aidx);
   endif
 
 endfunction
 
+
 # Test various methods of providing size parameters
 %!shared x
 %! x = [1 2;3 4];
-%!assert(repmat(x, [1 1]), repmat(x, 1));
-%!assert(repmat(x, [3 3]), repmat(x, 3));
-%!assert(repmat(x, [1 1]), repmat(x, 1, 1));
-%!assert(repmat(x, [1 3]), repmat(x, 1, 3));
-%!assert(repmat(x, [3 1]), repmat(x, 3, 1));
-%!assert(repmat(x, [3 3]), repmat(x, 3, 3));
+%!assert (repmat (x, [1 1]), repmat (x, 1))
+%!assert (repmat (x, [3 3]), repmat (x, 3))
+%!assert (repmat (x, [1 1]), repmat (x, 1, 1))
+%!assert (repmat (x, [1 3]), repmat (x, 1, 3))
+%!assert (repmat (x, [3 1]), repmat (x, 3, 1))
+%!assert (repmat (x, [3 3]), repmat (x, 3, 3))
 
 # Tests for numel==1 case:
 %!shared x, r
 %! x = [ 65 ];
-%! r = kron(ones(2,2), x);
-%!assert(r, repmat(x, [2 2]));
-%!assert(char(r), repmat(char(x), [2 2]));
-%!assert(int8(r), repmat(int8(x), [2 2]));
+%! r = kron (ones (2,2), x);
+%!assert (r, repmat (x, [2 2]))
+%!assert (char (r), repmat (char (x), [2 2]))
+%!assert (int8 (r), repmat (int8 (x), [2 2]))
 
 # Tests for ndims==2 case:
 %!shared x, r
 %! x = [ 65 66 67 ];
-%! r = kron(ones(2,2), x);
-%!assert(r, repmat(x, [2 2]));
-%!assert(char(r), repmat(char(x), [2 2]));
-%!assert(int8(r), repmat(int8(x), [2 2]));
+%! r = kron (ones (2,2), x);
+%!assert (r, repmat (x, [2 2]))
+%!assert (char (r), repmat (char (x), [2 2]))
+%!assert (int8 (r), repmat (int8 (x), [2 2]))
 
 # Tests for dim>2 case:
 %!shared x, r
 %! x = [ 65 66 67 ];
-%! r = kron(ones(2,2), x);
+%! r = kron (ones (2,2), x);
 %! r(:,:,2) = r(:,:,1);
-%!assert(r, repmat(x, [2 2 2]));
-%!assert(char(r), repmat(char(x), [2 2 2]));
-%!assert(int8(r), repmat(int8(x), [2 2 2]));
+%!assert (r, repmat (x, [2 2 2]))
+%!assert (char (r), repmat (char (x), [2 2 2]))
+%!assert (int8 (r), repmat (int8 (x), [2 2 2]))
 
 # Test that sparsity is kept
-%!assert(sparse(4,4), repmat(sparse(2,2),[2 2]));
+%!assert (sparse (4,4), repmat (sparse (2,2),[2 2]))
 
+%!assert (size (repmat (".", -1, 1)), [0, 1])
+%!assert (size (repmat (".", 1, -1)), [1, 0])
 
-%!assert (size (repmat (".", -1, 1)), [0, 1]);
-%!assert (size (repmat (".", 1, -1)), [1, 0]);
-%!error (size (repmat (".", -1, -1)));
-
-%!assert (size (repmat (1, [1, 0])), [1, 0]);
-%!assert (size (repmat (1, [5, 0])), [5, 0]);
-%!assert (size (repmat (1, [0, 1])), [0, 1]);
-%!assert (size (repmat (1, [0, 5])), [0, 5]);
+%!assert (size (repmat (1, [1, 0])), [1, 0])
+%!assert (size (repmat (1, [5, 0])), [5, 0])
+%!assert (size (repmat (1, [0, 1])), [0, 1])
+%!assert (size (repmat (1, [0, 5])), [0, 5])
 
 %!shared x
 %! x = struct ("a", [], "b", []);
-%!assert (size (repmat (x, [1, 0])), [1, 0]);
-%!assert (size (repmat (x, [5, 0])), [5, 0]);
-%!assert (size (repmat (x, [0, 1])), [0, 1]);
-%!assert (size (repmat (x, [0, 5])), [0, 5]);
+%!assert (size (repmat (x, [1, 0])), [1, 0])
+%!assert (size (repmat (x, [5, 0])), [5, 0])
+%!assert (size (repmat (x, [0, 1])), [0, 1])
+%!assert (size (repmat (x, [0, 5])), [0, 5])
 
-%!assert (size (repmat ({1}, [1, 0])), [1, 0]);
-%!assert (size (repmat ({1}, [5, 0])), [5, 0]);
-%!assert (size (repmat ({1}, [0, 1])), [0, 1]);
-%!assert (size (repmat ({1}, [0, 5])), [0, 5]);
+%!assert (size (repmat ({1}, [1, 0])), [1, 0])
+%!assert (size (repmat ({1}, [5, 0])), [5, 0])
+%!assert (size (repmat ({1}, [0, 1])), [0, 1])
+%!assert (size (repmat ({1}, [0, 5])), [0, 5])
 
+%!error (size (repmat (".", -1, -1)))
+
diff --git a/scripts/general/rot90.m b/scripts/general/rot90.m
--- a/scripts/general/rot90.m
+++ b/scripts/general/rot90.m
@@ -23,18 +23,18 @@
 ## 90-degree increments.  The second argument is optional, and specifies
 ## how many 90-degree rotations are to be applied (the default value is 1).
 ## Negative values of @var{k} rotate the matrix in a clockwise direction.
 ## For example,
 ##
 ## @example
 ## @group
 ## rot90 ([1, 2; 3, 4], -1)
-##      @result{}  3  1
-##          4  2
+##     @result{}  3  1
+##         4  2
 ## @end group
 ## @end example
 ##
 ## @noindent
 ## rotates the given matrix clockwise by 90 degrees.  The following are all
 ## equivalent statements:
 ##
 ## @example
@@ -90,13 +90,14 @@ endfunction
 %! assert(rot90 (x1), x2);
 %! assert(rot90 (x1, 2), x3);
 %! assert(rot90 (x1, 3), x4);
 %! assert(rot90 (x1, 4), x1);
 %! assert(rot90 (x1, 5), x2);
 %! assert(rot90 (x1, -1), x4);
 
 %% Test input validation
-%!error rot90 ();
-%!error rot90 (1, 2, 3);
-%!error rot90 (1, ones(2));
-%!error rot90 (1, 1.5);
-%!error rot90 (1, 1+i);
+%!error rot90 ()
+%!error rot90 (1, 2, 3)
+%!error rot90 (1, ones(2))
+%!error rot90 (1, 1.5)
+%!error rot90 (1, 1+i)
+
diff --git a/scripts/general/rotdim.m b/scripts/general/rotdim.m
--- a/scripts/general/rotdim.m
+++ b/scripts/general/rotdim.m
@@ -119,40 +119,42 @@ function y = rotdim (x, n, plane)
       y = flipdim (y, max (plane));
     endif
   else
     error ("rotdim: internal error!");
   endif
 
 endfunction
 
-%!error rotdim ();
-%!error rotdim (1, 2, 3, 4);
 
 %!shared r, rr
-%! r = [1,2,3]; rr = [3,2,1];
-%!assert (rotdim (r, 0), r);
-%!assert (rotdim (r, 1), rr');
-%!assert (rotdim (r, 2), rr);
-%!assert (rotdim (r, 3), r');
-%!assert (rotdim (r, 3), rotdim (r, -1));
-%!assert (rotdim (r, 1), rotdim (r));
+%! r = [1,2,3];  rr = [3,2,1];
+%!assert (rotdim (r, 0), r)
+%!assert (rotdim (r, 1), rr')
+%!assert (rotdim (r, 2), rr)
+%!assert (rotdim (r, 3), r')
+%!assert (rotdim (r, 3), rotdim (r, -1))
+%!assert (rotdim (r, 1), rotdim (r))
 
 %!shared c, cr
-%! c = [1;2;3]; cr = [3;2;1];
-%!assert (rotdim (c, 0), c);
-%!assert (rotdim (c, 1), c');
-%!assert (rotdim (c, 2), cr);
-%!assert (rotdim (c, 3), cr');
-%!assert (rotdim (c, 3), rotdim (c, -1));
-%!assert (rotdim (c, 1), rotdim (c));
+%! c = [1;2;3];  cr = [3;2;1];
+%!assert (rotdim (c, 0), c)
+%!assert (rotdim (c, 1), c')
+%!assert (rotdim (c, 2), cr)
+%!assert (rotdim (c, 3), cr')
+%!assert (rotdim (c, 3), rotdim (c, -1))
+%!assert (rotdim (c, 1), rotdim (c))
 
 %!shared m
 %! m = [1,2;3,4];
-%!assert (rotdim (m, 0), m);
-%!assert (rotdim (m, 1), [2,4;1,3]);
-%!assert (rotdim (m, 2), [4,3;2,1]);
-%!assert (rotdim (m, 3), [3,1;4,2]);
-%!assert (rotdim (m, 3), rotdim (m, -1));
-%!assert (rotdim (m, 1), rotdim (m));
+%!assert (rotdim (m, 0), m)
+%!assert (rotdim (m, 1), [2,4;1,3])
+%!assert (rotdim (m, 2), [4,3;2,1])
+%!assert (rotdim (m, 3), [3,1;4,2])
+%!assert (rotdim (m, 3), rotdim (m, -1))
+%!assert (rotdim (m, 1), rotdim (m))
 
 ## FIXME -- we need tests for multidimensional arrays and different
 ## values of PLANE.
+
+%!error rotdim ()
+%!error rotdim (1, 2, 3, 4)
+
diff --git a/scripts/general/saveobj.m b/scripts/general/saveobj.m
--- a/scripts/general/saveobj.m
+++ b/scripts/general/saveobj.m
@@ -25,17 +25,17 @@
 ## or it might be used to ensure that certain fields of the object are
 ## initialized before the object is saved.  For example:
 ##
 ## @example
 ## @group
 ## function b = saveobj (a)
 ##   b = a;
 ##   if (isempty (b.field))
-##      b.field = initfield(b);
+##      b.field = initfield (b);
 ##   endif
 ## endfunction
 ## @end group
 ## @end example
 ##
 ## @seealso{loadobj, class}
 ## @end deftypefn
 
diff --git a/scripts/general/shift.m b/scripts/general/shift.m
--- a/scripts/general/shift.m
+++ b/scripts/general/shift.m
@@ -75,25 +75,25 @@ endfunction
 %!test
 %! a = [1, 2, 3];
 %! b = [4, 5, 6];
 %! c = [7, 8, 9];
 %!
 %! r = [a, b, c];
 %! m = [a; b; c];
 %!
-%! assert(shift (r, 0), r);
-%! assert(shift (r, 3), [c, a, b]);
-%! assert(shift (r, -6), [c, a, b]);
-%! assert(shift (r, -3), [b, c, a]);
-%! assert(shift (m, 1), [c; a; b]);
-%! assert(shift (m, -2), [c; a; b]);
+%! assert (shift (r, 0), r);
+%! assert (shift (r, 3), [c, a, b]);
+%! assert (shift (r, -6), [c, a, b]);
+%! assert (shift (r, -3), [b, c, a]);
+%! assert (shift (m, 1), [c; a; b]);
+%! assert (shift (m, -2), [c; a; b]);
 
 %% Test input validation
 %!error shift ()
 %!error shift (1, 2, 3, 4)
 %!error shift ([], 1)
-%!error shift (ones(2), ones(2))
-%!error shift (ones(2), 1.5)
+%!error shift (ones (2), ones (2))
+%!error shift (ones (2), 1.5)
 %!error shift (1, 1, 1.5)
 %!error shift (1, 1, 0)
 %!error shift (1, 1, 3)
 
diff --git a/scripts/general/shiftdim.m b/scripts/general/shiftdim.m
--- a/scripts/general/shiftdim.m
+++ b/scripts/general/shiftdim.m
@@ -31,22 +31,22 @@
 ## in the second output argument @var{ns}.
 ##
 ## For example:
 ##
 ## @example
 ## @group
 ## x = ones (1, 2, 3);
 ## size (shiftdim (x, -1))
-##      @result{} [1, 1, 2, 3]
+##    @result{} [1, 1, 2, 3]
 ## size (shiftdim (x, 1))
-##      @result{} [2, 3]
-## [b, ns] = shiftdim (x);
-##      @result{} b =  [1, 1, 1; 1, 1, 1]
-##      @result{} ns = 1
+##    @result{} [2, 3]
+## [b, ns] = shiftdim (x)
+##    @result{} b = [1, 1, 1; 1, 1, 1]
+##    @result{} ns = 1
 ## @end group
 ## @end example
 ## @seealso {reshape, permute, ipermute, circshift, squeeze}
 ## @end deftypefn
 
 function [y, ns]  = shiftdim (x, n)
 
   if (nargin < 1 || nargin > 2)
@@ -85,16 +85,17 @@ endfunction
 
 %!test
 %! x = rand (1, 1, 4, 2);
 %! [y, ns] = shiftdim (x);
 %! assert (size (y), [4 2]);
 %! assert (ns, 2);
 %! assert (shiftdim (y, -2), x);
 %! assert (size (shiftdim (x, 2)), [4 2]);
-%!assert (size (shiftdim (rand (0, 1, 2))), [0 1 2]);
+
+%!assert (size (shiftdim (rand (0, 1, 2))), [0 1 2])
 
 %% Test input validation
-%!error(shiftdim ());
-%!error(shiftdim (1,2,3));
-%!error(shiftdim (1, ones (2)));
-%!error(shiftdim (1, 1.5));
+%!error (shiftdim ())
+%!error (shiftdim (1,2,3))
+%!error (shiftdim (1, ones (2)))
+%!error (shiftdim (1, 1.5))
 
diff --git a/scripts/general/sph2cart.m b/scripts/general/sph2cart.m
--- a/scripts/general/sph2cart.m
+++ b/scripts/general/sph2cart.m
@@ -66,16 +66,17 @@ function [x, y, z] = sph2cart (theta, ph
   z = r .* sin (phi);
 
   if (nargout <= 1)
     x = [x, y, z];
   endif
 
 endfunction
 
+
 %!test
 %! t = [0, 0, 0];
 %! p = [0, 0, 0];
 %! r = [0, 1, 2];
 %! [x, y, z] = sph2cart (t, p, r);
 %! assert (x, r);
 %! assert (y, [0, 0, 0]);
 %! assert (z, [0, 0, 0]);
@@ -105,10 +106,10 @@ endfunction
 %! [x, y, z] = sph2cart (t, p, r);
 %! assert (x, [1, 0, -1], eps);
 %! assert (y, [0, 1, 0], eps);
 %! assert (z, [0, 0, 0], eps);
 
 %!test
 %! S = [ 0, 0, 1; 0.5*pi, 0, 1; pi, 0, 1];
 %! C = [ 1, 0, 0; 0, 1, 0; -1, 0, 0];
-%! assert (sph2cart(S), C, eps);
+%! assert (sph2cart (S), C, eps);
 
diff --git a/scripts/general/structfun.m b/scripts/general/structfun.m
--- a/scripts/general/structfun.m
+++ b/scripts/general/structfun.m
@@ -42,17 +42,17 @@
 ## with the same fieldnames as the input structure.
 ##
 ## @example
 ## @group
 ## s.name1 = "John Smith";
 ## s.name2 = "Jill Jones";
 ## structfun (@@(x) regexp (x, '(\w+)$', "matches")@{1@}, s,
 ##            "UniformOutput", false)
-##     @result{}
+## @result{}
 ##    @{
 ##      name1 = Smith
 ##      name2 = Jones
 ##    @}
 ## @end group
 ## @end example
 ##
 ## Given the parameter "ErrorHandler", @var{errfunc} defines a function to
@@ -128,19 +128,20 @@ endfunction
 %!test
 %! s = struct ("a", {1, 2, 3}, "b", {4, 5, 6});
 %! c(1:2, 1, 1) = [2; 8];
 %! c(1:2, 1, 2) = [4; 10];
 %! c(1:2, 1, 3) = [6; 12];
 %! d(1:2, 1, 1) = [1; 16];
 %! d(1:2, 1, 2) = [4; 25];
 %! d(1:2, 1, 3) = [9; 36];
-%! [aa, bb] = structfun(@__twoouts, s);
-%! assert(aa, c);
-%! assert(bb, d);
+%! [aa, bb] = structfun (@__twoouts, s);
+%! assert (aa, c);
+%! assert (bb, d);
 
 %!test
 %! s = struct ("a", {1, 2, 3}, "b", {4, 5, 6});
 %! c = struct ("a", {2, 4, 6}, "b", {8, 10, 12});
 %! d = struct ("a", {1, 4, 9}, "b", {16, 25, 36});
-%! [aa, bb] = structfun(@__twoouts, s, "UniformOutput", false);
-%! assert(aa, c);
-%! assert(bb, d);
+%! [aa, bb] = structfun (@__twoouts, s, "UniformOutput", false);
+%! assert (aa, c);
+%! assert (bb, d);
+
diff --git a/scripts/general/subsindex.m b/scripts/general/subsindex.m
--- a/scripts/general/subsindex.m
+++ b/scripts/general/subsindex.m
@@ -23,28 +23,28 @@
 ## overloading method that allows the conversion of this class object to
 ## a valid indexing vector.  It is important to note that
 ## @code{subsindex} must return a zero-based real integer vector of the
 ## class "double".  For example, if the class constructor
 ##
 ## @example
 ## @group
 ## function b = myclass (a)
-##  b = class (struct ("a", a), "myclass");
+##   b = class (struct ("a", a), "myclass");
 ## endfunction
 ## @end group
 ## @end example
 ##
 ## @noindent
 ## then the @code{subsindex} function
 ##
 ## @example
 ## @group
 ## function idx = subsindex (a)
-##  idx = double (a.a) - 1.0;
+##   idx = double (a.a) - 1.0;
 ## endfunction
 ## @end group
 ## @end example
 ##
 ## @noindent
 ## can then be used as follows
 ##
 ## @example
diff --git a/scripts/general/trapz.m b/scripts/general/trapz.m
--- a/scripts/general/trapz.m
+++ b/scripts/general/trapz.m
@@ -118,21 +118,21 @@ function z = trapz (x, y, dim)
         error ("trapz: X and Y must have same shape");
       endif
       z = 0.5 * sum (diff (x, 1, dim) .* (y(idx1{:}) + y(idx2{:})), dim);
     endif
   endif
 endfunction
 
 
-%!assert (trapz(1:5), 12)
-%!assert (trapz(0:0.5:2,1:5), 6)
-%!assert (trapz([1:5;1:5].',1), [12,12])
-%!assert (trapz([1:5;1:5],2), [12;12])
-%!assert (trapz(repmat(reshape(1:5,1,1,5),2,2), 3), [12 12; 12 12])
-%!assert (trapz([0:0.5:2;0:0.5:2].',[1:5;1:5].',1), [6, 6])
-%!assert (trapz([0:0.5:2;0:0.5:2],[1:5;1:5],2), [6; 6])
-%!assert (trapz(repmat(reshape([0:0.5:2],1,1,5),2,2), ...
-%!              repmat(reshape(1:5,1,1,5),2,2), 3), [6 6; 6 6])
-%!assert (trapz(0:0.5:2,[(1:5)',(1:5)']), [6, 6])
-%!assert (trapz(0:0.5:2,[(1:5);(1:5)],2), [6; 6])
-%!assert (trapz(0:0.5:2,repmat(reshape(1:5,1,1,5),2,2),3), [6 6; 6 6])
+%!assert (trapz (1:5), 12)
+%!assert (trapz (0:0.5:2,1:5), 6)
+%!assert (trapz ([1:5;1:5].',1), [12,12])
+%!assert (trapz ([1:5;1:5],2), [12;12])
+%!assert (trapz (repmat (reshape (1:5,1,1,5),2,2), 3), [12 12; 12 12])
+%!assert (trapz ([0:0.5:2;0:0.5:2].',[1:5;1:5].',1), [6, 6])
+%!assert (trapz ([0:0.5:2;0:0.5:2],[1:5;1:5],2), [6; 6])
+%!assert (trapz (repmat (reshape ([0:0.5:2],1,1,5),2,2), ...
+%!               repmat (reshape (1:5,1,1,5),2,2), 3), [6 6; 6 6])
+%!assert (trapz (0:0.5:2,[(1:5)',(1:5)']), [6, 6])
+%!assert (trapz (0:0.5:2,[(1:5);(1:5)],2), [6; 6])
+%!assert (trapz (0:0.5:2,repmat (reshape (1:5,1,1,5),2,2),3), [6 6; 6 6])
 
diff --git a/scripts/general/triplequad.m b/scripts/general/triplequad.m
--- a/scripts/general/triplequad.m
+++ b/scripts/general/triplequad.m
@@ -71,15 +71,15 @@ endfunction
 function q = __triplequad_inner__ (y, z, f, xa, xb, tol, quadf, varargin)
   q = zeros (size(y));
   for i = 1 : length (y)
     q(i) = feval (quadf, @(x) f (x, y(i), z, varargin{:}), xa, xb, tol);
   endfor
 endfunction
 
 
-%!assert (triplequad (@(x,y,z) exp(-x.^2 - y.^2 - z.^2) , -1, 1, -1, 1, -1, 1, [],  @quadcc), pi ^ (3/2) * erf(1).^3, 1e-6)
+%!assert (triplequad (@(x,y,z) exp (-x.^2 - y.^2 - z.^2) , -1, 1, -1, 1, -1, 1, [], @quadcc), pi^(3/2) * erf (1).^3, 1e-6)
 
 %% These tests are too expensive to run normally (~30 sec each).  Disable them
-#%!assert (triplequad (@(x,y,z) exp(-x.^2 - y.^2 - z.^2) , -1, 1, -1, 1, -1, 1, [],  @quadgk), pi ^ (3/2) * erf(1).^3, 1e-6)
-#%!#assert (triplequad (@(x,y,z) exp(-x.^2 - y.^2 - z.^2) , -1, 1, -1, 1, -1, 1, [],  @quadl), pi ^ (3/2) * erf(1).^3, 1e-6)
-#%!#assert (triplequad (@(x,y,z) exp(-x.^2 - y.^2 - z.^2) , -1, 1, -1, 1, -1, 1, [],  @quadv), pi ^ (3/2) * erf(1).^3, 1e-6)
+#%!assert (triplequad (@(x,y,z) exp (-x.^2 - y.^2 - z.^2) , -1, 1, -1, 1, -1, 1, [], @quadgk), pi^(3/2) * erf (1).^3, 1e-6)
+#%!#assert (triplequad (@(x,y,z) exp (-x.^2 - y.^2 - z.^2) , -1, 1, -1, 1, -1, 1, [], @quadl), pi^(3/2) * erf (1).^3, 1e-6)
+#%!#assert (triplequad (@(x,y,z) exp (-x.^2 - y.^2 - z.^2) , -1, 1, -1, 1, -1, 1, [], @quadv), pi^(3/2) * erf (1).^3, 1e-6)
 
diff --git a/scripts/geometry/convhull.m b/scripts/geometry/convhull.m
--- a/scripts/geometry/convhull.m
+++ b/scripts/geometry/convhull.m
@@ -15,17 +15,17 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{H} =} convhull (@var{x}, @var{y})
 ## @deftypefnx {Function File} {@var{H} =} convhull (@var{x}, @var{y}, @var{options})
 ## Compute the convex hull of the set of points defined by the
-## vectors @var{x} and @var{y}.  The hull @var{H} is an index vector into
+## arrays @var{x} and @var{y}.  The hull @var{H} is an index vector into
 ## the set of points and specifies which points form the enclosing hull.
 ##
 ## An optional third argument, which must be a string or cell array of strings,
 ## contains options passed to the underlying qhull command.
 ## See the documentation for the Qhull library for details
 ## @url{http://www.qhull.org/html/qh-quick.htm#options}.
 ## The default option is @code{@{"Qt"@}}.
 ##
@@ -40,27 +40,30 @@
 ## Author: Kai Habel <kai.habel@gmx.de>
 
 function H = convhull (x, y, options)
 
   if (nargin != 2 && nargin != 3)
     print_usage ();
   endif
 
-  if (! (isvector (x) && isvector (y) && length (x) == length (y))
-      && ! size_equal (x, y))
-    error ("convhull: X and Y must be the same size");
+  ## convhulln expects column vectors
+  x = x(:);
+  y = y(:);
+
+  if (length (x) != length (y))
+    error ("convhull: X and Y must have the same size");
   elseif (nargin == 3 && ! (ischar (options) || iscellstr (options)))
     error ("convhull: OPTIONS must be a string or cell array of strings");
   endif
 
   if (nargin == 2)
-    i = convhulln ([x(:), y(:)]);
+    i = convhulln ([x, y]);
   else
-    i = convhulln ([x(:), y(:)], options);
+    i = convhulln ([x, y], options);
   endif
 
   n = rows (i);
   i = i'(:);
   H = zeros (n + 1, 1);
 
   H(1) = i(1);
   next_i = i(2);
@@ -90,12 +93,12 @@ endfunction
 %! y = abs (sin (x));
 %! k = convhull (x, y);
 %! plot (x(k),y(k),"r-;convex hull;", x,y,"b+;points;");
 %! axis ([-3.05, 3.05, -0.05, 1.05]);
 
 %!testif HAVE_QHULL
 %! x = -3:0.5:3;
 %! y = abs (sin (x));
-%! assert (convhull (x, y), [1;7;13;12;11;10;4;3;2;1])
+%! assert (convhull (x, y), [1;7;13;12;11;10;4;3;2;1]);
 
 %% FIXME: Need input validation tests
 
diff --git a/scripts/geometry/dsearch.m b/scripts/geometry/dsearch.m
--- a/scripts/geometry/dsearch.m
+++ b/scripts/geometry/dsearch.m
@@ -27,14 +27,16 @@
 
 function idx = dsearch (x, y, tri, xi, yi, s)
   if (nargin < 5 || nargin > 6)
     print_usage ();
   endif
   idx = __dsearchn__ ([x(:), y(:)], [xi(:), yi(:)]);
 endfunction
 
+
 %!shared x, y, tri
 %! x = [-1;-1;1];
 %! y = [-1;1;-1];
 %! tri = [1,2,3];
-%!assert (dsearch(x,y,tri,1,1/3), 3);
-%!assert (dsearch(x,y,tri,1/3,1), 2);
+%!assert (dsearch (x,y,tri,1,1/3), 3)
+%!assert (dsearch (x,y,tri,1/3,1), 2)
+
diff --git a/scripts/geometry/dsearchn.m b/scripts/geometry/dsearchn.m
--- a/scripts/geometry/dsearchn.m
+++ b/scripts/geometry/dsearchn.m
@@ -41,17 +41,19 @@ function [idx, d] = dsearchn (x, tri, xi
     if (nargin == 4)
       idx2 = isnan (tsearchn (x, tri, xi));
       idx(idx2) = outval;
       d(idx2) = outval;
     endif
   endif
 endfunction
 
+
 %!shared x, tri
 %! x = [-1,-1;-1,1;1,-1];
 %! tri = [1,2,3];
-%!assert (dsearchn(x,tri,[1,1/3]), 3);
-%!assert (dsearchn(x,tri,[1,1/3],NaN), NaN);
-%!assert (dsearchn(x,tri,[1,1/3],NA), NA);
-%!assert (dsearchn(x,tri,[1/3,1]), 2);
-%!assert (dsearchn(x,tri,[1/3,1],NaN), NaN);
-%!assert (dsearchn(x,tri,[1/3,1],NA), NA);
+%!assert (dsearchn (x,tri,[1,1/3]), 3)
+%!assert (dsearchn (x,tri,[1,1/3],NaN), NaN)
+%!assert (dsearchn (x,tri,[1,1/3],NA), NA)
+%!assert (dsearchn (x,tri,[1/3,1]), 2)
+%!assert (dsearchn (x,tri,[1/3,1],NaN), NaN)
+%!assert (dsearchn (x,tri,[1/3,1],NA), NA)
+
diff --git a/scripts/geometry/griddata.m b/scripts/geometry/griddata.m
--- a/scripts/geometry/griddata.m
+++ b/scripts/geometry/griddata.m
@@ -12,71 +12,74 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {@var{zi} =} griddata (@var{x}, @var{y}, @var{z}, @var{xi}, @var{yi}, @var{method})
-## @deftypefnx {Function File} {[@var{xi}, @var{yi}, @var{zi}] =} griddata (@var{x}, @var{y}, @var{z}, @var{xi}, @var{yi}, @var{method})
+## @deftypefn  {Function File} {@var{zi} =} griddata (@var{x}, @var{y}, @var{z}, @var{xi}, @var{yi})
+## @deftypefnx {Function File} {@var{zi} =} griddata (@var{x}, @var{y}, @var{z}, @var{xi}, @var{yi}, @var{method})
+## @deftypefnx {Function File} {[@var{xi}, @var{yi}, @var{zi}] =} griddata (@dots{})
 ##
 ## Generate a regular mesh from irregular data using interpolation.
 ## The function is defined by @code{@var{z} = f (@var{x}, @var{y})}.
 ## Inputs @code{@var{x}, @var{y}, @var{z}} are vectors of the same length
 ## or @code{@var{x}, @var{y}} are vectors and @code{@var{z}} is matrix.
 ##
 ## The interpolation points are all @code{(@var{xi}, @var{yi})}.  If
 ## @var{xi}, @var{yi} are vectors then they are made into a 2-D mesh.
 ##
 ## The interpolation method can be @code{"nearest"}, @code{"cubic"} or
 ## @code{"linear"}.  If method is omitted it defaults to @code{"linear"}.
-## @seealso{delaunay}
+## @seealso{griddata3, griddatan, delaunay}
 ## @end deftypefn
 
 ## Author:      Kai Habel <kai.habel@gmx.de>
 ## Adapted-by:  Alexander Barth <barth.alexander@gmail.com>
 ##              xi and yi are not "meshgridded" if both are vectors
 ##              of the same size (for compatibility)
 
-function [rx, ry, rz] = griddata (x, y, z, xi, yi, method)
+function [rx, ry, rz] = griddata (x, y, z, xi, yi, method = "linear")
 
-  if (nargin == 5)
-    method = "linear";
-  endif
   if (nargin < 5 || nargin > 7)
     print_usage ();
   endif
 
   if (ischar (method))
     method = tolower (method);
   endif
 
+  ## Meshgrid if x and y are vectors but z is matrix
   if (isvector (x) && isvector (y) && all ([numel(y), numel(x)] == size (z)))
     [x, y] = meshgrid (x, y);
-  elseif (! all (size (x) == size (y) & size (x) == size (z)))
-    if (isvector (z))
-      error ("griddata: X, Y, and Z, be vectors of same length");
-    else
-      error ("griddata: lengths of X, Y must match the columns and rows of Z");
+  endif
+    
+  if (isvector (x) && isvector (y) && isvector (z))
+    if (! isequal (length (x), length (y), length (z)))
+      error ("griddata: X, Y, and Z must be vectors of the same length");
     endif
+  elseif (! size_equal (x, y, z))
+    error ("griddata: lengths of X, Y must match the columns and rows of Z");
   endif
 
   ## Meshgrid xi and yi if they are a row and column vector.
   if (rows (xi) == 1 && columns (yi) == 1)
     [xi, yi] = meshgrid (xi, yi);
+  elseif (isvector (xi) && isvector (yi))
+    ## Otherwise, convert to column vectors
+    xi = xi(:);
+    yi = yi(:);
   endif
 
   if (! size_equal (xi, yi))
     error ("griddata: XI and YI must be vectors or matrices of same size");
   endif
 
-  [nr, nc] = size (xi);
-
   x = x(:);
   y = y(:);
   z = z(:);
 
   ## Triangulate data.
   tri = delaunay (x, y);
   zi = NaN (size (xi));
 
@@ -133,16 +136,17 @@ function [rx, ry, rz] = griddata (x, y, 
     rx = xi;
     ry = yi;
     rz = zi;
   elseif (nargout == 1)
     rx = zi;
   elseif (nargout == 0)
     mesh (xi, yi, zi);
   endif
+
 endfunction
 
 
 %!demo
 %! clf;
 %! colormap ("default");
 %! x = 2*rand (100,1) - 1;
 %! y = 2*rand (size (x)) - 1;
@@ -178,8 +182,23 @@ endfunction
 %! y = yy(:);
 %! y = y + 10*(2*round (rand (size(y))) - 1) * eps;
 %! z = sin (2*(x.^2 + y.^2));
 %! zz = griddata (x,y,z,xx,yy,"linear");
 %! zz2 = sin (2*(xx.^2 + yy.^2));
 %! zz2(isnan (zz)) = NaN;
 %! assert (zz, zz2, 100*eps);
 
+%% Test input validation
+%!error griddata ()
+%!error griddata (1)
+%!error griddata (1,2)
+%!error griddata (1,2,3)
+%!error griddata (1,2,3,4)
+%!error griddata (1,2,3,4,5,6,7)
+%!error <vectors of the same length> griddata (1:3, 1:3, 1:4, 1:3, 1:3)
+%!error <vectors of the same length> griddata (1:3, 1:4, 1:3, 1:3, 1:3)
+%!error <vectors of the same length> griddata (1:4, 1:3, 1:3, 1:3, 1:3)
+%!error <the columns and rows of Z> griddata (1:4, 1:3, ones (4,4), 1:3, 1:3)
+%!error <the columns and rows of Z> griddata (1:4, 1:3, ones (3,5), 1:3, 1:3)
+%!error <matrices of same size> griddata (1:3, 1:3, 1:3, 1:4, 1:3)
+%!error <matrices of same size> griddata (1:3, 1:3, 1:3, 1:3, 1:4)
+
diff --git a/scripts/geometry/griddata3.m b/scripts/geometry/griddata3.m
--- a/scripts/geometry/griddata3.m
+++ b/scripts/geometry/griddata3.m
@@ -12,48 +12,65 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {@var{vi} =} griddata3 (@var{x}, @var{y}, @var{z}, @var{v} @var{xi}, @var{yi}, @var{zi}, @var{method}, @var{options})
+## @deftypefn  {Function File} {@var{vi} =} griddata3 (@var{x}, @var{y}, @var{z}, @var{v} @var{xi}, @var{yi}, @var{zi})
+## @deftypefnx {Function File} {@var{vi} =} griddata3 (@var{x}, @var{y}, @var{z}, @var{v} @var{xi}, @var{yi}, @var{zi}, @var{method})
+## @deftypefnx {Function File} {@var{vi} =} griddata3 (@var{x}, @var{y}, @var{z}, @var{v} @var{xi}, @var{yi}, @var{zi}, @var{method}, @var{options})
 ##
 ## Generate a regular mesh from irregular data using interpolation.
 ## The function is defined by @code{@var{y} = f (@var{x},@var{y},@var{z})}.
 ## The interpolation points are all @var{xi}.
 ##
 ## The interpolation method can be @code{"nearest"} or @code{"linear"}.
 ## If method is omitted it defaults to @code{"linear"}.
-## @seealso{griddata, delaunayn}
+##
+## The optional argument @var{options} is passed directly to Qhull when
+## computing the Delaunay triangulation used for interpolation.  See
+## @code{delaunayn} for information on the defaults and how to pass different
+## values.
+## @seealso{griddata, griddatan, delaunayn}
 ## @end deftypefn
 
 ## Author: David Bateman <dbateman@free.fr>
 
 function vi = griddata3 (x, y, z, v, xi, yi, zi, method, varargin)
 
   if (nargin < 7)
     print_usage ();
   endif
 
-  if (!all (size (x) == size (y) & size (x) == size(z) & size(x) == size (v)))
-    error ("griddata3: X, Y, Z, and V must be vectors of same length");
+  if (isvector (x) && isvector (y) && isvector (z) && isvector (v))
+    if (! isequal (length (x), length (y), length (z), length (v)))
+      error ("griddata: X, Y, Z, and V must be vectors of the same length");
+    endif
+  elseif (! size_equal (x, y, z, v))
+    error ("griddata: X, Y, Z, and V must have equal sizes");
   endif
 
-  ## meshgrid xi, yi and zi if they are vectors unless they
-  ## are vectors of the same length
-  if (isvector (xi) && isvector (yi) && isvector (zi)
-      && (numel (xi) != numel (yi) || numel (xi) != numel (zi)))
-    [xi, yi, zi] = meshgrid (xi, yi, zi);
+  ## meshgrid xi, yi and zi if they are vectors unless
+  ## they are vectors of the same length.
+  if (isvector (xi) && isvector (yi) && isvector (zi))
+    if (! isequal (length (xi), length (yi), length (zi)))
+      [xi, yi, zi] = meshgrid (xi, yi, zi);
+    else
+      ## Otherwise, convert to column vectors
+      xi = xi(:);
+      yi = yi(:);
+      zi = zi(:);
+    endif
   endif
 
-  if (any (size(xi) != size(yi)) || any (size(xi) != size(zi)))
-    error ("griddata3: XI, YI and ZI must be vectors or matrices of same size");
+  if (! size_equal (xi, yi, zi))
+    error ("griddata3: XI, YI, and ZI must be vectors or matrices of the same size");
   endif
 
   vi = griddatan ([x(:), y(:), z(:)], v(:), [xi(:), yi(:), zi(:)], varargin{:});
   vi = reshape (vi, size (xi));
 
 endfunction
 
 
@@ -61,24 +78,25 @@ endfunction
 %! old_state = rand ("state");
 %! restore_state = onCleanup (@() rand ("state", old_state));
 %! rand ("state", 0);
 %! x = 2 * rand (1000, 1) - 1;
 %! y = 2 * rand (1000, 1) - 1;
 %! z = 2 * rand (1000, 1) - 1;
 %! v = x.^2 + y.^2 + z.^2;
 %! [xi, yi, zi] = meshgrid (-0.8:0.2:0.8);
-%! vi = griddata3 (x, y, z, v, xi, yi, zi, 'linear');
+%! vi = griddata3 (x, y, z, v, xi, yi, zi, "linear");
 %! vv = vi - xi.^2 - yi.^2 - zi.^2;
 %! assert (max (abs (vv(:))), 0, 0.1);
 
 %!testif HAVE_QHULL
 %! old_state = rand ("state");
 %! restore_state = onCleanup (@() rand ("state", old_state));
 %! rand ("state", 0);
 %! x = 2 * rand (1000, 1) - 1;
 %! y = 2 * rand (1000, 1) - 1;
 %! z = 2 * rand (1000, 1) - 1;
 %! v = x.^2 + y.^2 + z.^2;
 %! [xi, yi, zi] = meshgrid (-0.8:0.2:0.8);
-%! vi = griddata3 (x, y, z, v, xi, yi, zi, 'nearest');
+%! vi = griddata3 (x, y, z, v, xi, yi, zi, "nearest");
 %! vv = vi - xi.^2 - yi.^2 - zi.^2;
 %! assert (max (abs (vv(:))), 0, 0.1)
+
diff --git a/scripts/geometry/griddatan.m b/scripts/geometry/griddatan.m
--- a/scripts/geometry/griddatan.m
+++ b/scripts/geometry/griddatan.m
@@ -12,52 +12,55 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {@var{yi} =} griddatan (@var{x}, @var{y}, @var{xi}, @var{method}, @var{options})
+## @deftypefn  {Function File} {@var{yi} =} griddatan (@var{x}, @var{y}, @var{xi})
+## @deftypefnx {Function File} {@var{yi} =} griddatan (@var{x}, @var{y}, @var{xi}, @var{method})
+## @deftypefnx {Function File} {@var{yi} =} griddatan (@var{x}, @var{y}, @var{xi}, @var{method}, @var{options})
 ##
 ## Generate a regular mesh from irregular data using interpolation.
 ## The function is defined by @code{@var{y} = f (@var{x})}.
 ## The interpolation points are all @var{xi}.
 ##
 ## The interpolation method can be @code{"nearest"} or @code{"linear"}.
 ## If method is omitted it defaults to @code{"linear"}.
-## @seealso{griddata, delaunayn}
+## 
+## The optional argument @var{options} is passed directly to Qhull when
+## computing the Delaunay triangulation used for interpolation.  See
+## @code{delaunayn} for information on the defaults and how to pass different
+## values.
+## @seealso{griddata, griddata3, delaunayn}
 ## @end deftypefn
 
 ## Author: David Bateman <dbateman@free.fr>
 
-function yi = griddatan (x, y, xi, method, varargin)
+function yi = griddatan (x, y, xi, method = "linear", varargin)
 
-  if (nargin == 3)
-    method = "linear";
-  endif
   if (nargin < 3)
     print_usage ();
   endif
 
   if (ischar (method))
     method = tolower (method);
   endif
 
   [m, n] = size (x);
   [mi, ni] = size (xi);
 
-  if (n != ni || size (y, 1) != m || size (y, 2) != 1)
+  if (n != ni || rows (y) != m || columns (y) != 1)
     error ("griddatan: dimensional mismatch");
   endif
 
   ## triangulate data
-  ## tri = delaunayn(x, varargin{:});
-  tri = delaunayn (x);
+  tri = delaunayn (x, varargin{:});
 
   yi = NaN (mi, 1);
 
   if (strcmp (method, "nearest"))
     ## search index of nearest point
     idx = dsearchn (x, tri, xi);
     valid = !isnan (idx);
     yi(valid) = y(idx(valid));
@@ -80,27 +83,29 @@ function yi = griddatan (x, y, xi, metho
     yi(valid) = sum (y(tri(tri_list,:)) .* bary_list, 2);
 
   else
     error ("griddatan: unknown interpolation METHOD");
   endif
 
 endfunction
 
-%!testif HAVE_QHULL
-%! [xx,yy] = meshgrid(linspace(-1,1,32));
-%! xi = [xx(:), yy(:)];
-%! x = (2 * rand(100,2) - 1);
-%! x = [x;1,1;1,-1;-1,-1;-1,1];
-%! y = sin(2*(sum(x.^2,2)));
-%! zz = griddatan(x,y,xi,'linear');
-%! zz2 = griddata(x(:,1),x(:,2),y,xi(:,1),xi(:,2),'linear');
-%! assert (zz, zz2, 1e-10)
 
 %!testif HAVE_QHULL
-%! [xx,yy] = meshgrid(linspace(-1,1,32));
+%! [xx,yy] = meshgrid (linspace (-1,1,32));
 %! xi = [xx(:), yy(:)];
-%! x = (2 * rand(100,2) - 1);
+%! x = 2*rand (100,2) - 1;
 %! x = [x;1,1;1,-1;-1,-1;-1,1];
-%! y = sin(2*(sum(x.^2,2)));
-%! zz = griddatan(x,y,xi,'nearest');
-%! zz2 = griddata(x(:,1),x(:,2),y,xi(:,1),xi(:,2),'nearest');
-%! assert (zz, zz2, 1e-10)
+%! y = sin (2 * sum (x.^2,2));
+%! zz = griddatan (x,y,xi,"linear");
+%! zz2 = griddata (x(:,1),x(:,2),y,xi(:,1),xi(:,2),"linear");
+%! assert (zz, zz2, 1e-10);
+
+%!testif HAVE_QHULL
+%! [xx,yy] = meshgrid (linspace (-1,1,32));
+%! xi = [xx(:), yy(:)];
+%! x = 2*rand (100,2) - 1;
+%! x = [x;1,1;1,-1;-1,-1;-1,1];
+%! y = sin (2*sum (x.^2,2));
+%! zz = griddatan (x,y,xi,"nearest");
+%! zz2 = griddata (x(:,1),x(:,2),y,xi(:,1),xi(:,2),"nearest");
+%! assert (zz, zz2, 1e-10);
+
diff --git a/scripts/geometry/rectint.m b/scripts/geometry/rectint.m
--- a/scripts/geometry/rectint.m
+++ b/scripts/geometry/rectint.m
@@ -106,26 +106,27 @@ function area = rectint (a, b)
   endfor
 
   if swapinputs
     area = area';
   endif
 
 endfunction
 
-## Tests
+
 ## Exactly overlapping
-%!assert(rectint([0 0 1 1], [0 0 1 1]), 1)
+%!assert (rectint ([0 0 1 1], [0 0 1 1]), 1)
 ## rect2 completely enclosed by rect1
-%!assert(rectint([-1 -1 3 3], [0 0 1 1]), 1)
+%!assert (rectint ([-1 -1 3 3], [0 0 1 1]), 1)
 ## rect1 completely enclosed by rect2
-%!assert(rectint([0 0 1 1], [-1 -1 3 3]), 1)
+%!assert (rectint ([0 0 1 1], [-1 -1 3 3]), 1)
 ## rect1 right and top in rect2
-%!assert(rectint([-1 -1 1.5 1.5], [0 0 1 1]), 0.25)
+%!assert (rectint ([-1 -1 1.5 1.5], [0 0 1 1]), 0.25)
 ## rect2 right and top in rect1
-%!assert(rectint([0 0 1 1], [-1 -1 1.5 1.5]), 0.25)
+%!assert (rectint ([0 0 1 1], [-1 -1 1.5 1.5]), 0.25)
 ## no overlap - shared corner
-%!assert(rectint([0 0 1 1], [1 1 2 2]), 0)
+%!assert (rectint ([0 0 1 1], [1 1 2 2]), 0)
 ## no overlap - shared edge
-%!assert(rectint([0 0 1 1], [0 1 2 2]), 0)
+%!assert (rectint ([0 0 1 1], [0 1 2 2]), 0)
 ## Correct orientation of output
-%!assert(rectint([0 0 1 1;0.5 0.5 1 1;-1 -1 2 2], [1 1 2 2]), [0;0.25;0])
-%!assert(rectint([1 1 2 2], [0 0 1 1;0.5 0.5 1 1;-1 -1 2 2]), [0 0.25 0])
+%!assert (rectint ([0 0 1 1;0.5 0.5 1 1;-1 -1 2 2], [1 1 2 2]), [0;0.25;0])
+%!assert (rectint ([1 1 2 2], [0 0 1 1;0.5 0.5 1 1;-1 -1 2 2]), [0 0.25 0])
+
diff --git a/scripts/geometry/tsearchn.m b/scripts/geometry/tsearchn.m
--- a/scripts/geometry/tsearchn.m
+++ b/scripts/geometry/tsearchn.m
@@ -77,31 +77,33 @@ function Beta = cart2bary (T, P)
   ## Beta(end) = sum(Beta)
   ##
   ## Note below is generalize for multiple values of P, one per row.
   [M, N] = size (P);
   Beta = (P - ones (M,1) * T(end,:)) / (T(1:end-1,:) - ones(N,1) * T(end,:));
   Beta (:,end+1) = 1 - sum(Beta, 2);
 endfunction
 
+
 %!shared x, tri
 %! x = [-1,-1;-1,1;1,-1];
 %! tri = [1, 2, 3];
 %!test
 %! [idx, p] = tsearchn (x,tri,[-1,-1]);
-%! assert (idx, 1)
-%! assert (p, [1,0,0], 1e-12)
+%! assert (idx, 1);
+%! assert (p, [1,0,0], 1e-12);
 %!test
 %! [idx, p] = tsearchn (x,tri,[-1,1]);
-%! assert (idx, 1)
-%! assert (p, [0,1,0], 1e-12)
+%! assert (idx, 1);
+%! assert (p, [0,1,0], 1e-12);
 %!test
 %! [idx, p] = tsearchn (x,tri,[1,-1]);
-%! assert (idx, 1)
-%! assert (p, [0,0,1], 1e-12)
+%! assert (idx, 1);
+%! assert (p, [0,0,1], 1e-12);
 %!test
 %! [idx, p] = tsearchn (x,tri,[-1/3,-1/3]);
-%! assert (idx, 1)
-%! assert (p, [1/3,1/3,1/3], 1e-12)
+%! assert (idx, 1);
+%! assert (p, [1/3,1/3,1/3], 1e-12);
 %!test
 %! [idx, p] = tsearchn (x,tri,[1,1]);
-%! assert (idx, NaN)
-%! assert (p, [NaN, NaN, NaN])
+%! assert (idx, NaN);
+%! assert (p, [NaN, NaN, NaN]);
+
diff --git a/scripts/geometry/voronoi.m b/scripts/geometry/voronoi.m
--- a/scripts/geometry/voronoi.m
+++ b/scripts/geometry/voronoi.m
@@ -37,22 +37,22 @@
 ##
 ## If a single output argument is requested then the Voronoi diagram will be
 ## plotted and a graphics handle @var{h} to the plot is returned.
 ## [@var{vx}, @var{vy}] = voronoi(@dots{}) returns the Voronoi vertices
 ## instead of plotting the diagram.
 ##
 ## @example
 ## @group
-##   x = rand (10, 1);
-##   y = rand (size (x));
-##   h = convhull (x, y);
-##   [vx, vy] = voronoi (x, y);
-##   plot (vx, vy, "-b", x, y, "o", x(h), y(h), "-g")
-##   legend ("", "points", "hull");
+## x = rand (10, 1);
+## y = rand (size (x));
+## h = convhull (x, y);
+## [vx, vy] = voronoi (x, y);
+## plot (vx, vy, "-b", x, y, "o", x(h), y(h), "-g");
+## legend ("", "points", "hull");
 ## @end group
 ## @end example
 ##
 ## @seealso{voronoin, delaunay, convhull}
 ## @end deftypefn
 
 ## Author: Kai Habel <kai.habel@gmx.de>
 ## First Release: 20/08/2000
diff --git a/scripts/help/__makeinfo__.m b/scripts/help/__makeinfo__.m
--- a/scripts/help/__makeinfo__.m
+++ b/scripts/help/__makeinfo__.m
@@ -36,17 +36,17 @@
 ## If the optional argument @var{see_also} is present, it is used to expand the
 ## Octave specific @t{@@seealso} macro. This argument must be a function handle,
 ## that accepts a cell array of strings as input argument (each elements of the
 ## array corresponds to the arguments to the @t{@@seealso} macro), and return
 ## the expanded string. If this argument is not given, the @t{@@seealso} macro
 ## will be expanded to the text
 ##
 ## @example
-## See also: arg1, arg2@, ...
+## See also: arg1, arg2, ...
 ## @end example
 ##
 ## @noindent
 ## for @t{"plain text"} output, and
 ##
 ## @example
 ## See also: @@ref@{arg1@}, @@ref@{arg2@}, ...
 ## @end example
@@ -81,20 +81,23 @@ function [retval, status] = __makeinfo__
           ("\nSee also:", sprintf (" @ref{%s},", T{:})(1:end-1), "\n");
     endif
   endif
 
   if (! isa (fsee_also, "function_handle"))
     error ("__makeinfo__: third input argument must be a function handle");
   endif
 
-
-  ## It seems like makeinfo sometimes gets angry if the first character
-  ## on a line is a space, so we remove these.
-  text = strrep (text, "\n ", "\n");
+  ## Formatting in m-files has an extra space at the beginning of every line.
+  ## Remove these unwanted spaces if present.  First text char is "\n" delim.
+  if (text(2) == " ")
+    text = strrep (text, "\n ", "\n");
+  endif
+  ## Texinfo crashes if @end tex does not appear first on the line.
+  text = regexprep (text, '^ +@end tex', '@end tex', 'lineanchors');
 
   ## Handle @seealso macro
   see_also_pat = '@seealso *\{(.*)\}';
   args = regexp (text, see_also_pat, 'tokens');
   for ii = 1:numel (args)
     expanded = fsee_also (strtrim (strsplit (args{ii}{:}, ',', true)));
     text = regexprep (text, see_also_pat, expanded, 'once');
   endfor
@@ -140,11 +143,12 @@ function [retval, status] = __makeinfo__
 
   unwind_protect_cleanup
     if (exist (name, "file"))
       delete (name);
     endif
   end_unwind_protect
 endfunction
 
+
 ## No test needed for internal helper function.
 %!assert (1)
 
diff --git a/scripts/help/doc.m b/scripts/help/doc.m
--- a/scripts/help/doc.m
+++ b/scripts/help/doc.m
@@ -101,11 +101,15 @@ function retval = doc (fname)
     endif
 
   else
     print_usage ();
   endif
 
 endfunction
 
-%!test if exist( info_file ()) != 2 && exist (sprintf ("%s.gz", info_file ())) != 2
-%!       error ("Info file %s or %s.gz does not exist!", info_file (), info_file ());
-%!     endif
+
+%!test
+%! ifile = info_file ();
+%! if (exist (ifile) != 2 && exist (sprintf ("%s.gz", ifile)) != 2)
+%!   error ("Info file %s or %s.gz does not exist!", ifile, ifile);
+%! endif
+
diff --git a/scripts/help/get_first_help_sentence.m b/scripts/help/get_first_help_sentence.m
--- a/scripts/help/get_first_help_sentence.m
+++ b/scripts/help/get_first_help_sentence.m
@@ -148,17 +148,18 @@ endfunction
 function [text, status] = first_sentence_html (help_text, max_len)
   ## Strip tags
   [help_text, status] = strip_html_tags (help_text);
 
   ## Extract first line with plain text method.
   text = first_sentence_plain_text (help_text, max_len);
 endfunction
 
-%!assert (strcmp (get_first_help_sentence('get_first_help_sentence'), "Return the first sentence of a function's help text."));
+
+%!assert (get_first_help_sentence ('get_first_help_sentence'), "Return the first sentence of a function's help text.")
 
 %% Test input validation
 %!error get_first_help_sentence ()
 %!error get_first_help_sentence (1, 2, 3)
 %!error get_first_help_sentence (1)
 %!error get_first_help_sentence ('ls', 'a')
 %!error get_first_help_sentence ('ls', 0)
 %!error get_first_help_sentence ('ls', 80.1)
diff --git a/scripts/help/help.m b/scripts/help/help.m
--- a/scripts/help/help.m
+++ b/scripts/help/help.m
@@ -179,8 +179,9 @@ function do_contents (name)
   endif
 
 endfunction
 
 
 %!assert (! isempty (strfind (help ("ls"), "List directory contents")))
 %!error <invalid input> help (42)
 
+
diff --git a/scripts/help/lookfor.m b/scripts/help/lookfor.m
--- a/scripts/help/lookfor.m
+++ b/scripts/help/lookfor.m
@@ -15,33 +15,33 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Command} {} lookfor @var{str}
 ## @deftypefnx {Command} {} lookfor -all @var{str}
 ## @deftypefnx {Function File} {[@var{func}, @var{helpstring}] =} lookfor (@var{str})
-## @deftypefnx {Function File} {[@var{func}, @var{helpstring}] =} lookfor ('-all', @var{str})
+## @deftypefnx {Function File} {[@var{func}, @var{helpstring}] =} lookfor ("-all", @var{str})
 ## Search for the string @var{str} in all functions found in the current
 ## function search path.  By default, @code{lookfor} searches for @var{str}
 ## in the first sentence of the help string of each function found.  The entire
-## help text of each function can be searched if the '-all' argument is
+## help text of each function can be searched if the "-all" argument is
 ## supplied.  All searches are case insensitive.
 ##
 ## Called with no output arguments, @code{lookfor} prints the list of
 ## matching functions to the terminal.  Otherwise, the output arguments
 ## @var{func} and @var{helpstring} define the matching functions and the
 ## first sentence of each of their help strings.
 ##
 ## The ability of @code{lookfor} to correctly identify the first
 ## sentence of the help text is dependent on the format of the
 ## function's help.  All Octave core functions are correctly
 ## formatted, but the same can not be guaranteed for external packages and
-## user-supplied functions.  Therefore, the use of the '-all' argument may
+## user-supplied functions.  Therefore, the use of the "-all" argument may
 ## be necessary to find related functions that are not a part of Octave.
 ## @seealso{help, doc, which}
 ## @end deftypefn
 
 function [out_fun, out_help_text] = lookfor (str, arg2)
 
   if (strcmpi (str, "-all"))
     ## The difference between using '-all' and not, is which part of the caches
diff --git a/scripts/help/type.m b/scripts/help/type.m
--- a/scripts/help/type.m
+++ b/scripts/help/type.m
@@ -106,19 +106,21 @@ function retval = type (varargin)
     if (nargout == 0)
       disp (text);
     else
       retval {n} = text;
     endif
   endfor
 endfunction
 
+
 %!test
 %! var = 1;
 %! typestr = type ("var");
 %! typestr = typestr{1}(1:17);
 %! assert (typestr, "var is a variable");
 
-%!assert (type ('dot'){1}, "dot is a dynamically-linked function")
-%!assert (type ('cat'){1}, "cat is a built-in function")
-%!assert (type ('+'){1}, "+ is an operator")
-%!assert (type ('end'){1}, "end is a keyword")
+%!assert (type ("dot"){1}, "dot is a dynamically-linked function")
+%!assert (type ("cat"){1}, "cat is a built-in function")
+%!assert (type ("+"){1}, "+ is an operator")
+%!assert (type ("end"){1}, "end is a keyword")
 %!error (type ('NO_NAME'))
+ 
diff --git a/scripts/help/unimplemented.m b/scripts/help/unimplemented.m
--- a/scripts/help/unimplemented.m
+++ b/scripts/help/unimplemented.m
@@ -316,29 +316,27 @@ function list = missing_functions ()
   "plotedit",
   "plottools",
   "polyeig",
   "prefdir",
   "preferences",
   "printdlg",
   "printopt",
   "printpreview",
-  "profile",
   "profsave",
   "propedit",
   "propertyeditor",
   "publish",
   "qmr",
   "quad2d",
   "questdlg",
   "rbbox",
   "reducepatch",
   "reducevolume",
   "resample",
-  "rgbplot",
   "root",
   "rotate",
   "rotate3d",
   "selectmoveresize",
   "sendmail",
   "serial",
   "setpixelposition",
   "showplottool",
@@ -426,10 +424,9 @@ endfunction
 
 %!test
 %! str = unimplemented ("no_name_function");
 %! assert (isempty (str));
 %! str = unimplemented ("quad2d");
 %! assert (str(1:51), "quad2d is not implemented.  Consider using dblquad.");
 %! str = unimplemented ("MException");
 %! assert (str(1:58), "the `MException' function is not yet implemented in Octave");
-
-
+ 
diff --git a/scripts/help/which.m b/scripts/help/which.m
--- a/scripts/help/which.m
+++ b/scripts/help/which.m
@@ -57,9 +57,10 @@ endfunction
 
 %!test
 %! str = which ("ls");
 %! assert (str(end-17:end), strcat ("miscellaneous", filesep(), "ls.m"));
 %!test
 %! str = which ("dot");
 %! assert (str(end-6:end), "dot.oct");
 
-%!assert (which ("NO_NAME"), "");
+%!assert (which ("_NO_SUCH_NAME_"), "")
+
diff --git a/scripts/image/autumn.m b/scripts/image/autumn.m
--- a/scripts/image/autumn.m
+++ b/scripts/image/autumn.m
@@ -39,17 +39,17 @@ function map = autumn (n)
   else
     print_usage ();
   endif
 
   if (n == 1)
     map = [1, 0, 0];
   elseif (n > 1)
     r = ones (n, 1);
-    g = (0:n - 1)' ./ (n - 1);
+    g = [0:(n-1)]' / (n - 1);
     b = zeros (n, 1);
     map = [r, g, b];
   else
     map = [];
   endif
 
 endfunction
 
diff --git a/scripts/image/bone.m b/scripts/image/bone.m
--- a/scripts/image/bone.m
+++ b/scripts/image/bone.m
@@ -39,26 +39,28 @@ function map = bone (n)
   else
     print_usage ();
   endif
 
   if (n == 1)
     map = [0, 0, 0];
   elseif (n > 1)
     x = linspace (0, 1, n)';
-
-    r = (x < 3/4) .* (7/8 * x) + (x >= 3/4) .* (11/8 * x - 3/8);
-    g = (x < 3/8) .* (7/8 * x)\
-      + (x >= 3/8 & x < 3/4) .* (29/24 * x - 1/8)\
+    r = (x < 3/4) .* (7/8 * x) ...
+      + (x >= 3/4) .* (11/8 * x - 3/8);
+    g = (x < 3/8) .* (7/8 * x) ...
+      + (x >= 3/8 & x < 3/4) .* (29/24 * x - 1/8) ...
       + (x >= 3/4) .* (7/8 * x + 1/8);
-    b = (x < 3/8) .* (29/24 * x) + (x >= 3/8) .* (7/8 * x + 1/8);
+    b = (x < 3/8) .* (29/24 * x) ...
+      + (x >= 3/8) .* (7/8 * x + 1/8);
     map = [r, g, b];
   else
     map = [];
   endif
+
 endfunction
 
 
 %!demo
 %! ## Show the 'bone' colormap as an image
 %! image (1:64, linspace (0, 1, 64), repmat ((1:64)', 1, 64));
 %! axis ([1, 64, 0, 1], "ticy", "xy");
 %! colormap (bone (64));
diff --git a/scripts/image/brighten.m b/scripts/image/brighten.m
--- a/scripts/image/brighten.m
+++ b/scripts/image/brighten.m
@@ -13,30 +13,28 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{map_out} =} brighten (@var{map}, @var{beta})
+## @deftypefnx {Function File} {@var{map_out} =} brighten (@var{beta})
 ## @deftypefnx {Function File} {@var{map_out} =} brighten (@var{h}, @var{beta})
-## @deftypefnx {Function File} {@var{map_out} =} brighten (@var{beta})
-## Darken or brighten the given colormap.  If the @var{map} argument
-## is omitted, the function is applied to the current colormap.  The first
-## argument can also be a valid graphics handle @var{h}, in which case
-## @code{brighten} is applied to the colormap associated with this handle.
+## Brighten or darken a colormap.  If the @var{map} argument is omitted, the
+## function is applied to the current colormap.  The first argument can also be
+## a valid graphics handle @var{h}, in which case @code{brighten} is applied to
+## the colormap associated with this handle.
 ##
-## Should the resulting colormap @var{map_out} not be assigned, it will be
-## written to the current colormap.
+## The argument @var{beta} must be a scalar between -1 and 1, where a
+## negative value darkens and a positive value brightens the colormap.
 ##
-## The argument @var{beta} should be a scalar between -1 and 1,
-## where a negative value darkens and a positive value brightens
-## the colormap.
-## @seealso{colormap}
+## If no output is specified then the result is written to the current colormap.
+## @seealso{colormap, contrast}
 ## @end deftypefn
 
 function rmap = brighten (arg1, beta)
   h = -1;
   if (nargin == 1)
     beta = arg1;
     m = colormap;
     h = gcf ();
diff --git a/scripts/image/colorcube.m b/scripts/image/colorcube.m
new file mode 100644
--- /dev/null
+++ b/scripts/image/colorcube.m
@@ -0,0 +1,96 @@
+## Copyright (C) 2012 Rik Wehbring
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 3 of the License, or (at
+## your option) any later version.
+##
+## Octave is distributed in the hope that it will be useful, but
+## WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+## General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, see
+## <http://www.gnu.org/licenses/>.
+
+## -*- texinfo -*-
+## @deftypefn  {Function File} {@var{map} =} colorcube ()
+## @deftypefnx {Function File} {@var{map} =} colorcube (@var{n})
+## Create color colormap.  This colormap is composed of as many equally
+## spaced colors (not grays) in the RGB color space as possible.  If there
+## are not a perfect number @var{n} of regularly spaced colors then the
+## remaining entries in the colormap are gradients of pure red, green, blue,
+## and gray.
+## The argument @var{n} must be a scalar.
+## If unspecified, the length of the current colormap, or 64, is used.
+## @seealso{colormap}
+## @end deftypefn
+
+function map = colorcube (n)
+
+  if (nargin == 0)
+    n = rows (colormap);
+  elseif (nargin == 1)
+    if (! isscalar (n))
+      error ("colorcube: argument must be a scalar");
+    endif
+  else
+    print_usage ();
+  endif
+
+  if (n < 9)
+    map = gray (n);
+    return;
+  endif
+
+  # Create colorcube of evenly spaced points with side length of n^1/3
+  cubelen = fix (cbrt (n));
+  reserve = n - cubelen^3; 
+
+  if (reserve == 0)
+    # Steal space from blue to put the gray gradient
+    [r, g, b] = meshgrid (linspace (0,1,cubelen),
+                          linspace (0,1,cubelen),
+                          linspace (0,1,cubelen-1));
+  else
+    [r, g, b] = meshgrid (linspace (0,1,cubelen),
+                          linspace (0,1,cubelen),
+                          linspace (0,1,cubelen));
+  endif
+
+  # Create map and weed out grays
+  map = [r(:), g(:), b(:)];
+  idx = any (bsxfun (@ne, map(:, 1), map(:, 2:3)), 2);
+  map = map(idx, :);
+
+  # Weed out pure colors
+  idx = sum (map == 0, 2);
+  map = map(idx != 2, :);
+
+  # Put in remaining gradients of pure red, green, blue, and gray
+  reserve = n - rows (map) - 1;
+  csteps = fix (reserve/4);
+  cstepsz = 1 / csteps;
+  cgrad = (cstepsz:cstepsz:1)';
+  gsteps = reserve - 3*csteps;
+  gstepsz = 1 / gsteps;
+  ggrad = (gstepsz:gstepsz:1)';
+  map = [map
+         cgrad, zeros(csteps, 1), zeros(csteps, 1)
+         zeros(csteps, 1), cgrad, zeros(csteps, 1)
+         zeros(csteps, 1), zeros(csteps, 1), cgrad 
+         0, 0, 0
+         ggrad, ggrad, ggrad];
+
+endfunction
+
+
+%!demo
+%! ## Show the 'colorcube' colormap as an image
+%! image (1:64, linspace (0, 1, 64), repmat ((1:64)', 1, 64));
+%! axis ([1, 64, 0, 1], "ticy", "xy");
+%! colormap (colorcube (64));
+
diff --git a/scripts/image/colormap.m b/scripts/image/colormap.m
--- a/scripts/image/colormap.m
+++ b/scripts/image/colormap.m
@@ -15,22 +15,22 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{cmap} =} colormap ()
 ## @deftypefnx {Function File} {@var{cmap} =} colormap (@var{map})
 ## @deftypefnx {Function File} {@var{cmap} =} colormap ("default")
-## Set the current colormap.
+## Query or set the current colormap.
 ##
 ## @code{colormap (@var{map})} sets the current colormap to @var{map}.  The
-## color map should be an @var{n} row by 3 column matrix.  The columns
+## colormap should be an @var{n} row by 3 column matrix.  The columns
 ## contain red, green, and blue intensities respectively.  All entries
-## should be between 0 and 1 inclusive.  The new colormap is returned.
+## must be between 0 and 1 inclusive.  The new colormap is returned.
 ##
 ## @code{colormap ("default")} restores the default colormap (the
 ## @code{jet} map with 64 entries).  The default colormap is returned.
 ##
 ## With no arguments, @code{colormap} returns the current color map.
 ## @seealso{jet}
 ## @end deftypefn
 
diff --git a/scripts/image/contrast.m b/scripts/image/contrast.m
--- a/scripts/image/contrast.m
+++ b/scripts/image/contrast.m
@@ -12,22 +12,22 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {} contrast (@var{x})
-## @deftypefnx {Function File} {} contrast (@var{x}, @var{n})
+## @deftypefn  {Function File} {@var{map} =} contrast (@var{x})
+## @deftypefnx {Function File} {@var{map} =} contrast (@var{x}, @var{n})
 ## Return a gray colormap that maximizes the contrast in an image.  The
 ## returned colormap will have @var{n} rows.  If @var{n} is not defined
 ## then the size of the current colormap is used.
-## @seealso{colormap}
+## @seealso{colormap, brighten}
 ## @end deftypefn
 
 function map = contrast (x, n)
 
   if (nargin == 1)
     n = rows (colormap);
   elseif (nargin == 2)
     if (! isscalar (n))
@@ -45,17 +45,20 @@ function map = contrast (x, n)
   map = [map, map, map];
 
 endfunction
 
 
 %!demo
 %! clf;
 %! img = reshape (1:100, 10, 10);
-%! image (img);
-%! colormap (gray (10));
-%! title ("Image with default 256 gray levels");
-%! input ("Press <enter> to continue: ", "s");
-%! colormap (contrast (img));
+%! imagesc (img);
+%! colormap (gray (64));
+%! title ("Image with default 64 gray levels");
+%! pos = get (gcf, "position");
+%! pos(1) += pos(3) + 15;
+%! figure ("position", pos); 
+%! colormap (contrast (img, 10));
+%! imagesc (img);
 %! title ("Image with contrast enhanced");
 
 %!assert (contrast (1:100,10), [([0:9]/9)',([0:9]/9)',([0:9]/9)'], 1e-10)
 
diff --git a/scripts/image/cool.m b/scripts/image/cool.m
--- a/scripts/image/cool.m
+++ b/scripts/image/cool.m
@@ -37,17 +37,17 @@ function map = cool (n)
     endif
   else
     print_usage ();
   endif
 
   if (n == 1)
     map = [0, 1, 1];
   elseif (n > 1)
-    r = (0:n - 1)' ./ (n - 1);
+    r = [0:(n-1)]' / (n - 1);
     g = 1 - r;
     b = ones (n, 1);
     map = [r, g, b];
   else
     map = [];
   endif
 
 endfunction
diff --git a/scripts/image/copper.m b/scripts/image/copper.m
--- a/scripts/image/copper.m
+++ b/scripts/image/copper.m
@@ -39,17 +39,18 @@ function map = copper (n)
   else
     print_usage ();
   endif
 
   if (n == 1)
     map = [0, 0, 0];
   elseif (n > 1)
     x = linspace (0, 1, n)';
-    r = (x < 4/5) .* (5/4 * x) + (x >= 4/5);
+    r = (x < 4/5) .* (5/4 * x) ...
+      + (x >= 4/5);
     g = 4/5 * x;
     b = 1/2 * x;
     map = [r, g, b];
   else
     map = [];
   endif
 
 endfunction
diff --git a/scripts/image/flag.m b/scripts/image/flag.m
--- a/scripts/image/flag.m
+++ b/scripts/image/flag.m
@@ -14,17 +14,17 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{map} =} flag ()
 ## @deftypefnx {Function File} {@var{map} =} flag (@var{n})
-## Create color colormap.  This colormap cycles through red, white, blue
+## Create color colormap.  This colormap cycles through red, white, blue,
 ## and black with each index change.
 ## The argument @var{n} must be a scalar.
 ## If unspecified, the length of the current colormap, or 64, is used.
 ## @seealso{colormap}
 ## @end deftypefn
 
 ## Author:  Kai Habel <kai.habel@gmx.de>
 
@@ -35,24 +35,18 @@ function map = flag (n)
   elseif (nargin == 1)
     if (! isscalar (n))
       error ("flag: argument must be a scalar");
     endif
   else
     print_usage ();
   endif
 
-  p = [1, 0, 0; 1, 1, 1; 0, 0, 1; 0, 0, 0];
-  if (rem(n,4) == 0)
-    map = kron (ones (n / 4, 1), p);
-  else
-    m1 = kron (ones (fix (n / 4), 1), p);
-    m2 = p(1:rem (n, 4), :);
-    map = [m1; m2];
-  endif
+  C = [1, 0, 0; 1, 1, 1; 0, 0, 1; 0, 0, 0];
+  map = C(rem (0:(n-1), 4) + 1, :);
 
 endfunction
 
 
 %!demo
 %! ## Show the 'flag' colormap as an image
 %! image (1:64, linspace (0, 1, 64), repmat ((1:64)', 1, 64));
 %! axis ([1, 64, 0, 1], "ticy", "xy");
diff --git a/scripts/image/gmap40.m b/scripts/image/gmap40.m
--- a/scripts/image/gmap40.m
+++ b/scripts/image/gmap40.m
@@ -18,39 +18,35 @@
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{map} =} gmap40 ()
 ## @deftypefnx {Function File} {@var{map} =} gmap40 (@var{n})
 ## Create color colormap.  The colormap consists of red, green, blue, yellow,
 ## magenta and cyan.  This colormap is specifically designed for users of
 ## gnuplot 4.0 where these 6 colors are the allowable ones for patch objects.
 ## The argument @var{n} must be a scalar.
-## If unspecified, a length of 6 is assumed.  Larger values
-## of @var{n} result in a repetition of the above colors.
+## If unspecified, a length of 6 is assumed.  Larger values of @var{n} result
+## in a repetition of the above colors.
 ## @seealso{colormap}
 ## @end deftypefn
 
 function map = gmap40 (n)
 
   if (nargin == 0)
     n = 6;
   elseif (nargin == 1)
     if (! isscalar (n))
       error ("gmap40: argument must be a scalar");
     endif
   else
     print_usage ();
   endif
 
-  if (n >= 1)
-    map = repmat ([1, 0, 0; 0, 1, 0; 0, 0, 1; 1, 1, 0; 1, 0, 1; 0, 1, 1],
-          ceil (n / 6), 1) (1:n, :);
-  else
-    map = [];
-  endif
+  C = [1, 0, 0; 0, 1, 0; 0, 0, 1; 1, 1, 0; 1, 0, 1; 0, 1, 1];
+  map = C(rem (0:(n-1), 6) + 1, :);
 
 endfunction
 
 
 %!demo
 %! ## Show the 'gmap40' colormap as an image
 %! image (1:6, linspace (0, 1, 6), repmat ((1:6)', 1, 6));
 %! axis ([1, 6, 0, 1], "ticy", "xy");
diff --git a/scripts/image/gray.m b/scripts/image/gray.m
--- a/scripts/image/gray.m
+++ b/scripts/image/gray.m
@@ -18,16 +18,17 @@
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{map} =} gray ()
 ## @deftypefnx {Function File} {@var{map} =} gray (@var{n})
 ## Create gray colormap.  This colormap varies from black to white with
 ## shades of gray.
 ## The argument @var{n} must be a scalar.
 ## If unspecified, the length of the current colormap, or 64, is used.
+## @seealso{colormap}
 ## @end deftypefn
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: July 1994
 ## Adapted-By: jwe
 
 function map = gray (n)
 
@@ -36,19 +37,19 @@ function map = gray (n)
   elseif (nargin == 1)
     if (! isscalar (n))
       error ("gray: argument must be a scalar");
     endif
   else
     print_usage ();
   endif
 
-  gr = [0:(n-1)]';
+  gr = [0:(n-1)]' / (n - 1);
 
-  map = [ gr, gr, gr ] / (n - 1);
+  map = [gr, gr, gr];
 
 endfunction
 
 
 %!demo
 %! ## Show the 'gray' colormap as an image
 %! image (1:64, linspace (0, 1, 64), repmat ((1:64)', 1, 64));
 %! axis ([1, 64, 0, 1], "ticy", "xy");
diff --git a/scripts/image/gray2ind.m b/scripts/image/gray2ind.m
--- a/scripts/image/gray2ind.m
+++ b/scripts/image/gray2ind.m
@@ -12,20 +12,23 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {[@var{img}, @var{map}] =} gray2ind (@var{I}, @var{n})
+## @deftypefn  {Function File} {[@var{img} =} gray2ind (@var{I})
+## @deftypefnx {Function File} {[@var{img} =} gray2ind (@var{I}, @var{n})
+## @deftypefnx {Function File} {[@var{img}, @var{map} =} gray2ind (@dots{})
 ## Convert a gray scale intensity image to an Octave indexed image.
-## The indexed image will consist of @var{n} different intensity values.  If not
-## given @var{n} will default to 64.
+## The indexed image will consist of @var{n} different intensity values.
+## If not given @var{n} defaults to 64.
+## @seealso{ind2gray, rgb2ind} 
 ## @end deftypefn
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: July 1994
 ## Adapted-By: jwe
 
 function [X, map] = gray2ind (I, n = 64)
   ## Check input
diff --git a/scripts/image/hot.m b/scripts/image/hot.m
--- a/scripts/image/hot.m
+++ b/scripts/image/hot.m
@@ -39,19 +39,21 @@ function map = hot (n)
   else
     print_usage ();
   endif
 
   if (n == 1)
     map = [0, 0, 0];
   elseif (n > 1)
     x = linspace (0, 1, n)';
-    r = (x < 2/5) .* (5/2 * x) + (x >= 2/5);
-    g = (x >= 2/5 & x < 4/5) .* (5/2 * x - 1) + (x >= 4/5);
-    b = (x >= 4/5) .* (5*x - 4);
+    r = (x < 2/5) .* (5/2 * x) ...
+      + (x >= 2/5);
+    g = (x >= 2/5 & x < 4/5) .* (5/2 * x - 1) ...
+      + (x >= 4/5);
+    b = (x >= 4/5) .* (5 * x - 4);
     map = [r, g, b];
   else
     map = [];
   endif
 
 endfunction
 
 
diff --git a/scripts/image/hsv.m b/scripts/image/hsv.m
--- a/scripts/image/hsv.m
+++ b/scripts/image/hsv.m
@@ -15,19 +15,19 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} hsv (@var{n})
 ## Create color colormap.  This colormap begins with red, changes through
 ## yellow, green, cyan, blue, and magenta, before returning to red.
-## It is useful for displaying periodic functions.  It is obtained by linearly
-## varying the hue through all possible values while keeping constant maximum
-## saturation and value and is equivalent to
+## It is useful for displaying periodic functions.  The map is obtained by
+## linearly varying the hue through all possible values while keeping constant
+## maximum saturation and value.  The equivalent code is
 ## @code{hsv2rgb ([linspace(0,1,N)', ones(N,2)])}.
 ##
 ## The argument @var{n} must be a scalar.
 ## If unspecified, the length of the current colormap, or 64, is used.
 ## @seealso{colormap}
 ## @end deftypefn
 
 ## Author:  Kai Habel <kai.habel@gmx.de>
@@ -42,18 +42,18 @@ function map = hsv (n)
     endif
   else
     print_usage ();
   endif
 
   if (n == 1)
     map = [1, 0, 0];
   elseif (n > 1)
-    h = linspace (0, 1, n)';
-    map = hsv2rgb ([h, ones(n, 1), ones(n, 1)]);
+    hue = linspace (0, 1, n)';
+    map = hsv2rgb ([hue, ones(n,1), ones(n,1)]);
   else
     map = [];
   endif
 
 endfunction
 
 
 %!demo
diff --git a/scripts/image/hsv2rgb.m b/scripts/image/hsv2rgb.m
--- a/scripts/image/hsv2rgb.m
+++ b/scripts/image/hsv2rgb.m
@@ -12,30 +12,32 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {@var{rgb_map} =} hsv2rgb (@var{hsv_map})
-## Transform a colormap or image from the HSV space to the RGB space.
-## @seealso{rgb2hsv}
+## @deftypefn  {Function File} {@var{rgb_map} =} hsv2rgb (@var{hsv_map})
+## @deftypefnx {Function File} {@var{rgb_img} =} hsv2rgb (@var{hsv_img})
+## Transform a colormap or image from hue-saturation-value (HSV) space to
+## red-green-blue (RGB) space.
+## @seealso{rgb2hsv, ind2rgb, ntsc2rgb}
 ## @end deftypefn
 
 ## Author: Kai Habel <kai.habel@gmx.de>
 ## Adapted-by: jwe
 
 function rgb_map = hsv2rgb (hsv_map)
 
-## Each color value x = (r,g,b) is calculated with
-## x = (1-sat)*val+sat*val*f_x(hue)
-## where f_x(hue) is a piecewise defined function for
-## each color with f_r(hue-2/3) = f_g(hue) = f_b(hue-1/3).
+  ## Each color value x = (r,g,b) is calculated with
+  ## x = (1-sat)*val+sat*val*f_x(hue)
+  ## where f_x(hue) is a piecewise defined function for
+  ## each color with f_r(hue-2/3) = f_g(hue) = f_b(hue-1/3).
 
   if (nargin != 1)
     print_usage ();
   endif
 
   ## If we have an image convert it into a color map.
   if (ismatrix (hsv_map) && ndims (hsv_map) == 3)
     is_image = true;
diff --git a/scripts/image/image.m b/scripts/image/image.m
--- a/scripts/image/image.m
+++ b/scripts/image/image.m
@@ -15,34 +15,34 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} image (@var{img})
 ## @deftypefnx {Function File} {} image (@var{x}, @var{y}, @var{img})
 ## @deftypefnx {Function File} {@var{h} =} image (@dots{})
-## Display a matrix as a color image.  The elements of @var{img} are indices
-## into the current colormap, and the colormap will be scaled so that the
-## extremes of @var{img} are mapped to the extremes of the colormap.
+## Display a matrix as a color image.
 ##
+## The elements of @var{img} are indices into the current colormap.
 ## The axis values corresponding to the matrix elements are specified in
-## @var{x} and @var{y}.  If you're not using gnuplot 4.2 or later, these
+## @var{x} and @var{y}.  If you are using gnuplot 4.1 or earlier, these
 ## variables are ignored.
 ##
+## The optional return value @var{h} is a graphics handle to the image.
+##
 ## Implementation Note: The origin (0, 0) for images is located in the
 ## upper left.  For ordinary plots, the origin is located in the lower
 ## left.  Octave handles this inversion by plotting the data normally,
 ## and then reversing the direction of the y-axis by setting the
-## @code{ydir} property to @code{"reverse"}.  This has implications whenever
+## @code{ydir} property to "reverse".  This has implications whenever
 ## an image and an ordinary plot need to be overlaid.  The recommended
 ## solution is to display the image and then plot the reversed ydata
 ## using, for example, @code{flipud (ydata,1)}.
 ##
-## The optional return value @var{h} is a graphics handle to the image.
 ## @seealso{imshow, imagesc, colormap}
 ## @end deftypefn
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: July 1994
 ## Adapted-By: jwe
 
 function retval = image (varargin)
@@ -85,17 +85,17 @@ function retval = image (varargin)
     retval = h;
   endif
 
 endfunction
 
 ## Generic image creation.
 ##
 ## The axis values corresponding to the matrix elements are specified in
-## @var{x} and @var{y}. If you're not using gnuplot 4.2 or later, these
+## @var{x} and @var{y}.  If you're not using gnuplot 4.2 or later, these
 ## variables are ignored.
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: July 1994
 ## Adapted-By: jwe
 
 function h = __img__ (x, y, img, varargin)
   
diff --git a/scripts/image/imagesc.m b/scripts/image/imagesc.m
--- a/scripts/image/imagesc.m
+++ b/scripts/image/imagesc.m
@@ -20,17 +20,17 @@
 ## @deftypefn  {Function File} {} imagesc (@var{A})
 ## @deftypefnx {Function File} {} imagesc (@var{x}, @var{y}, @var{A})
 ## @deftypefnx {Function File} {} imagesc (@dots{}, @var{limits})
 ## @deftypefnx {Function File} {} imagesc (@var{h}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} imagesc (@dots{})
 ## Display a scaled version of the matrix @var{A} as a color image.  The
 ## colormap is scaled so that the entries of the matrix occupy the entire
 ## colormap.  If @var{limits} = [@var{lo}, @var{hi}] are given, then that
-## range is set to the 'clim' of the current axes.
+## range is set to the "clim" of the current axes.
 ##
 ## The axis values corresponding to the matrix elements are specified in
 ## @var{x} and @var{y}, either as pairs giving the minimum and maximum
 ## values for the respective axes, or as values for each row and column
 ## of the matrix @var{A}.
 ##
 ## The optional return value @var{h} is a graphics handle to the image.
 ## @seealso{image, imshow, caxis}
diff --git a/scripts/image/imread.m b/scripts/image/imread.m
--- a/scripts/image/imread.m
+++ b/scripts/image/imread.m
@@ -84,16 +84,17 @@ function varargout = imread (filename, v
     else
       error ("imread: invalid Octave image file format");
     endif
 
   end_try_catch
 
 endfunction
 
+
 %!testif HAVE_MAGICK
 %! vpng = [ ...
 %!  137,  80,  78,  71,  13,  10,  26,  10,   0,   0, ...
 %!    0,  13,  73,  72,  68,  82,   0,   0,   0,   3, ...
 %!    0,   0,   0,   3,   8,   2,   0,   0,   0, 217, ...
 %!   74,  34, 232,   0,   0,   0,   1, 115,  82,  71, ...
 %!   66,   0, 174, 206,  28, 233,   0,   0,   0,   4, ...
 %!  103,  65,  77,  65,   0,   0, 177, 143,  11, 252, ...
@@ -102,16 +103,17 @@ endfunction
 %!  250,   0,   0,   0, 128, 232,   0,   0, 117,  48, ...
 %!    0,   0, 234,  96,   0,   0,  58, 152,   0,   0, ...
 %!   23, 112, 156, 186,  81,  60,   0,   0,   0,  25, ...
 %!   73,  68,  65,  84,  24,  87,  99,  96,  96,  96, ...
 %!  248, 255, 255,  63, 144,   4,  81, 111, 101,  84, ...
 %!   16,  28, 160,  16,   0, 197, 214,  13,  34,  74, ...
 %!  117, 213,  17,   0,   0,   0,   0,  73,  69,  78, ...
 %!   68, 174,  66,  96, 130];
-%! fid = fopen('test.png', 'wb');
-%! fwrite(fid, vpng);
-%! fclose(fid);
-%! A = imread('test.png');
-%! delete('test.png');
-%! assert(A(:,:,1), uint8 ([0, 255, 0; 255, 237, 255; 0, 255, 0]));
-%! assert(A(:,:,2), uint8 ([0, 255, 0; 255,  28, 255; 0, 255, 0]));
-%! assert(A(:,:,3), uint8 ([0, 255, 0; 255,  36, 255; 0, 255, 0]));
+%! fid = fopen ("test.png", "wb");
+%! fwrite (fid, vpng);
+%! fclose (fid);
+%! A = imread ("test.png");
+%! delete ("test.png");
+%! assert (A(:,:,1), uint8 ([0, 255, 0; 255, 237, 255; 0, 255, 0]));
+%! assert (A(:,:,2), uint8 ([0, 255, 0; 255,  28, 255; 0, 255, 0]));
+%! assert (A(:,:,3), uint8 ([0, 255, 0; 255,  36, 255; 0, 255, 0]));
+
diff --git a/scripts/image/imshow.m b/scripts/image/imshow.m
--- a/scripts/image/imshow.m
+++ b/scripts/image/imshow.m
@@ -36,16 +36,17 @@
 ## If @var{map} is a valid color map, the image will be shown as an indexed
 ## image using the supplied color map.
 ##
 ## If a file name is given instead of an image, the file will be read and
 ## shown.
 ##
 ## If given, the parameter @var{string_param1} has value
 ## @var{value1}.  @var{string_param1} can be any of the following:
+##
 ## @table @asis
 ## @item "displayrange"
 ## @var{value1} is the display range as described above.
 ## @end table
 ##
 ## The optional return value @var{h} is a graphics handle to the image.
 ## @seealso{image, imagesc, colormap, gray2ind, rgb2ind}
 ## @end deftypefn
diff --git a/scripts/image/imwrite.m b/scripts/image/imwrite.m
--- a/scripts/image/imwrite.m
+++ b/scripts/image/imwrite.m
@@ -182,19 +182,20 @@ function imwrite (img, varargin)
     else
       __magick_write__ (filename, fmt, tmp);
       ## __magick_write__ (filename, fmt, img, map);
     endif
   endif
 
 endfunction
 
+
 %% Test input validation
-%!error imwrite ()                           # Wrong # of args
-%!error imwrite (1)                          # Wrong # of args
-%!error imwrite ({"cell"}, "filename.jpg")   # Wrong class for img
-%!error imwrite (1, [], "filename.jpg")      # Empty image map
-%!error imwrite (1, 2, 3)                    # No filename specified
-%!error imwrite (1, "filename")              # No fmt specified
-%!error imwrite (1, "filename", "junk")      # Invalid fmt specified
-%!error imwrite ([], "filename.jpg")         # Empty img matrix
-%!error imwrite (spones(2), "filename.jpg")  # Invalid sparse img
+%!error imwrite ()                            # Wrong # of args
+%!error imwrite (1)                           # Wrong # of args
+%!error imwrite ({"cell"}, "filename.jpg")    # Wrong class for img
+%!error imwrite (1, [], "filename.jpg")       # Empty image map
+%!error imwrite (1, 2, 3)                     # No filename specified
+%!error imwrite (1, "filename")               # No fmt specified
+%!error imwrite (1, "filename", "junk")       # Invalid fmt specified
+%!error imwrite ([], "filename.jpg")          # Empty img matrix
+%!error imwrite (spones (2), "filename.jpg")  # Invalid sparse img
 
diff --git a/scripts/image/ind2gray.m b/scripts/image/ind2gray.m
--- a/scripts/image/ind2gray.m
+++ b/scripts/image/ind2gray.m
@@ -12,21 +12,22 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} ind2gray (@var{x}, @var{map})
-## Convert an Octave indexed image to a gray scale intensity image.
+## @deftypefn  {Function File} {} ind2gray (@var{x})
+## @deftypefnx {Function File} {} ind2gray (@var{x}, @var{map})
+## Convert a color indexed image to a gray scale intensity image.
 ## If @var{map} is omitted, the current colormap is used to determine the
 ## intensities.
-## @seealso{gray2ind, rgb2ntsc, image, colormap}
+## @seealso{gray2ind, ind2rgb}
 ## @end deftypefn
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: July 1994
 ## Adapted-By: jwe
 
 function y = ind2gray (x, map)
 
diff --git a/scripts/image/ind2rgb.m b/scripts/image/ind2rgb.m
--- a/scripts/image/ind2rgb.m
+++ b/scripts/image/ind2rgb.m
@@ -12,23 +12,24 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {@var{rgb} =} ind2rgb (@var{x}, @var{map})
-## @deftypefnx {Function File} {[@var{R}, @var{R}, @var{R}] =} ind2rgb (@var{x}, @var{map})
+## @deftypefn  {Function File} {@var{rgb} =} ind2rgb (@var{x})
+## @deftypefnx {Function File} {@var{rgb} =} ind2rgb (@var{x}, @var{map})
+## @deftypefnx {Function File} {[@var{R}, @var{G}, @var{B}] =} ind2rgb (@dots{})
 ## Convert an indexed image to red, green, and blue color components.
 ## If the colormap doesn't contain enough colors, pad it with the
 ## last color in the map.
 ## If @var{map} is omitted, the current colormap is used for the conversion.
-## @seealso{rgb2ind, image, imshow, ind2gray, gray2ind}
+## @seealso{rgb2ind, ind2gray, hsv2rgb, ntsc2rgb}
 ## @end deftypefn
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: July 1994
 ## Adapted-By: jwe
 
 function [R, G, B] = ind2rgb (x, map)
 
diff --git a/scripts/image/jet.m b/scripts/image/jet.m
--- a/scripts/image/jet.m
+++ b/scripts/image/jet.m
@@ -38,22 +38,25 @@ function map = jet (n)
     endif
   else
     print_usage ();
   endif
 
   if (n == 1)
     map = [0, 0, 0.5];
   elseif (n > 1)
-    x = linspace(0, 1, n)';
-    r = (x >= 3/8 & x < 5/8) .* (4 * x - 3/2)\
-      + (x >= 5/8 & x < 7/8) + (x >= 7/8) .* (-4 * x + 9/2);
-    g = (x >= 1/8 & x < 3/8) .* (4 * x - 1/2)\
-      + (x >= 3/8 & x < 5/8) + (x >= 5/8 & x < 7/8) .* (-4 * x + 7/2);
-    b = (x < 1/8) .* (4 * x + 1/2) + (x >= 1/8 & x < 3/8)\
+    x = linspace (0, 1, n)';
+    r = (x >= 3/8 & x < 5/8) .* (4 * x - 3/2) ...
+      + (x >= 5/8 & x < 7/8) ...
+      + (x >= 7/8) .* (-4 * x + 9/2);
+    g = (x >= 1/8 & x < 3/8) .* (4 * x - 1/2) ...
+      + (x >= 3/8 & x < 5/8) ...
+      + (x >= 5/8 & x < 7/8) .* (-4 * x + 7/2);
+    b = (x < 1/8) .* (4 * x + 1/2) ...
+      + (x >= 1/8 & x < 3/8) ...
       + (x >= 3/8 & x < 5/8) .* (-4 * x + 5/2);
     map = [r, g, b];
   else
     map = [];
   endif
 
 endfunction
 
diff --git a/scripts/image/lines.m b/scripts/image/lines.m
new file mode 100644
--- /dev/null
+++ b/scripts/image/lines.m
@@ -0,0 +1,54 @@
+## Copyright (C) 2012 Rik Wehbring
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 3 of the License, or (at
+## your option) any later version.
+##
+## Octave is distributed in the hope that it will be useful, but
+## WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+## General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, see
+## <http://www.gnu.org/licenses/>.
+
+## -*- texinfo -*-
+## @deftypefn  {Function File} {@var{map} =} lines ()
+## @deftypefnx {Function File} {@var{map} =} lines (@var{n})
+## Create color colormap.  This colormap is composed of the list of colors
+## in the current axes "ColorOrder" property.  The default is blue,
+## green, red, cyan, pink, yellow, and gray.
+## The argument @var{n} must be a scalar.
+## If unspecified, the length of the current colormap, or 64, is used.
+## @seealso{colormap}
+## @end deftypefn
+
+function map = lines (n)
+
+  if (nargin == 0)
+    n = rows (colormap);
+  elseif (nargin == 1)
+    if (! isscalar (n))
+      error ("lines: argument must be a scalar");
+    endif
+  else
+    print_usage ();
+  endif
+
+  C = get (gca, "colororder");
+  nr = rows (C);
+  map = C(rem (0:(n-1), nr) + 1, :);
+
+endfunction
+
+
+%!demo
+%! ## Show the 'lines' colormap as an image
+%! image (1:64, linspace (0, 1, 64), repmat ((1:64)', 1, 64));
+%! axis ([1, 64, 0, 1], "ticy", "xy");
+%! colormap (lines (64));
+
diff --git a/scripts/image/module.mk b/scripts/image/module.mk
--- a/scripts/image/module.mk
+++ b/scripts/image/module.mk
@@ -1,14 +1,15 @@
 FCN_FILE_DIRS += image
 
 image_FCN_FILES = \
   image/autumn.m \
   image/bone.m \
   image/brighten.m \
+  image/colorcube.m \
   image/colormap.m \
   image/contrast.m \
   image/cool.m \
   image/copper.m \
   image/flag.m \
   image/gmap40.m \
   image/gray.m \
   image/gray2ind.m \
@@ -19,24 +20,27 @@ image_FCN_FILES = \
   image/imagesc.m \
   image/imfinfo.m \
   image/imread.m \
   image/imshow.m \
   image/imwrite.m \
   image/ind2gray.m \
   image/ind2rgb.m \
   image/jet.m \
+  image/lines.m \
   image/ntsc2rgb.m \
   image/ocean.m \
   image/pink.m \
   image/prism.m \
   image/rainbow.m \
   image/rgb2hsv.m \
   image/rgb2ind.m \
   image/rgb2ntsc.m \
+  image/rgbplot.m \
+  image/spinmap.m \
   image/spring.m \
   image/summer.m \
   image/white.m \
   image/winter.m
 
 IMAGES += \
   image/default.img
 
diff --git a/scripts/image/ntsc2rgb.m b/scripts/image/ntsc2rgb.m
--- a/scripts/image/ntsc2rgb.m
+++ b/scripts/image/ntsc2rgb.m
@@ -12,19 +12,21 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} ntsc2rgb (@var{yiq})
-## Transform a colormap or image from NTSC to RGB.
-## @seealso{rgb2ntsc}
+## @deftypefn  {Function File} {@var{rgb_map} =} ntsc2rgb (@var{yiq_map})
+## @deftypefnx {Function File} {@var{rgb_img} =} ntsc2rgb (@var{yiq_img})
+## Transform a colormap or image from luminance-chrominance (NTSC) space to
+## red-green-blue (RGB) space.
+## @seealso{rgb2ntsc, hsv2rgb, ind2rgb}
 ## @end deftypefn
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: July 1994
 ## Adapted-By: jwe
 
 function rgb = ntsc2rgb (yiq)
 
diff --git a/scripts/image/ocean.m b/scripts/image/ocean.m
--- a/scripts/image/ocean.m
+++ b/scripts/image/ocean.m
@@ -18,16 +18,17 @@
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{map} =} ocean ()
 ## @deftypefnx {Function File} {@var{map} =} ocean (@var{n})
 ## Create color colormap.  This colormap varies from black to white with shades
 ## of blue.
 ## The argument @var{n} must be a scalar.
 ## If unspecified, the length of the current colormap, or 64, is used.
+## @seealso{colormap}
 ## @end deftypefn
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: July 1994
 ## Adapted-By: jwe
 
 function map = ocean (n)
 
@@ -39,26 +40,24 @@ function map = ocean (n)
     endif
   else
     print_usage ();
   endif
 
   cutin = fix (n/3);
 
   dr = (n - 1) / cutin;
-
   r = prepad ([0:dr:(n-1)], n)';
 
   dg = (n - 1) / (2 * cutin);
-
-  g = prepad([0:dg:(n-1)], n)';
+  g = prepad ([0:dg:(n-1)], n)';
 
   b = [0:(n-1)]';
 
-  map = [ r, g, b ] / (n - 1);
+  map = [r, g, b] / (n - 1);
 
 endfunction
 
 
 %!demo
 %! ## Show the 'ocean' colormap as an image
 %! image (1:64, linspace (0, 1, 64), repmat ((1:64)', 1, 64));
 %! axis ([1, 64, 0, 1], "ticy", "xy");
diff --git a/scripts/image/pink.m b/scripts/image/pink.m
--- a/scripts/image/pink.m
+++ b/scripts/image/pink.m
@@ -39,22 +39,23 @@ function map = pink (n)
   else
     print_usage ();
   endif
 
   if (n == 1)
     map = [0, 0, 0];
   elseif (n > 1)
     x = linspace (0, 1, n)';
-    r = (x < 3/8) .* (14/9 * x) + (x >= 3/8) .* (2/3 * x + 1/3);
-    g = (x < 3/8) .* (2/3 * x)\
-      + (x >= 3/8 & x < 3/4) .* (14/9 * x - 1/3)\
+    r = (x < 3/8) .* (14/9 * x) ...
+      + (x >= 3/8) .* (2/3 * x + 1/3);
+    g = (x < 3/8) .* (2/3 * x) ...
+      + (x >= 3/8 & x < 3/4) .* (14/9 * x - 1/3) ...
       + (x >= 3/4) .* (2/3 * x + 1/3);
-    b = (x < 3/4) .* (2/3 * x) + (x >= 3/4) .* (2 * x - 1);
-
+    b = (x < 3/4) .* (2/3 * x) ...
+      + (x >= 3/4) .* (2 * x - 1);
     map = sqrt ([r, g, b]);
   else
     map = [];
   endif
 
 endfunction
 
 
diff --git a/scripts/image/prism.m b/scripts/image/prism.m
--- a/scripts/image/prism.m
+++ b/scripts/image/prism.m
@@ -35,23 +35,18 @@ function map = prism (n)
   elseif (nargin == 1)
     if (! isscalar (n))
       error ("prism: argument must be a scalar");
     endif
   else
     print_usage ();
   endif
 
-  p = [1, 0, 0; 1, 1/2, 0; 1, 1, 0; 0, 1, 0; 0, 0, 1; 2/3, 0, 1];
-
-  if (rem (n, 6) == 0)
-    map = kron(ones (fix (n / 6), 1), p);
-  else
-    map = [kron(ones (fix (n / 6), 1), p); p(1:rem (n, 6), :)];
-  endif
+  C = [1, 0, 0; 1, 1/2, 0; 1, 1, 0; 0, 1, 0; 0, 0, 1; 2/3, 0, 1];
+  map = C(rem (0:(n-1), 6) + 1, :);
 
 endfunction
 
 
 %!demo
 %! ## Show the 'prism' colormap as an image
 %! image (1:64, linspace (0, 1, 64), repmat ((1:64)', 1, 64));
 %! axis ([1, 64, 0, 1], "ticy", "xy");
diff --git a/scripts/image/rainbow.m b/scripts/image/rainbow.m
--- a/scripts/image/rainbow.m
+++ b/scripts/image/rainbow.m
@@ -42,21 +42,28 @@ function map = rainbow (n)
   else
     print_usage ();
   endif
 
   if (n == 1)
     map = [1, 0, 0];
   elseif (n > 1)
     x = linspace (0, 1, n)';
-    r = (x < 2/5) + (x >= 2/5 & x < 3/5) .* (-5 * x + 3)\
-      + (x >= 4/5) .* (10/3 * x - 8/3);
-    g = (x < 2/5) .* (5/2 * x) + (x >= 2/5 & x < 3/5)\
-      + (x >= 3/5 & x < 4/5) .* (-5 * x + 4);
-    b = (x >= 3/5 & x < 4/5) .* (5 * x - 3) + (x >= 4/5);
+
+    r = (x < 2/5) \
+        + (x >= 2/5 & x < 3/5) .* (-5 * x + 3) \
+        + (x >= 4/5) .* (10/3 * x - 8/3);
+
+    g = (x < 2/5) .* (5/2 * x) \
+        + (x >= 2/5 & x < 3/5) \
+        + (x >= 3/5 & x < 4/5) .* (-5 * x + 4);
+
+    b = (x >= 3/5 & x < 4/5) .* (5 * x - 3) \
+        + (x >= 4/5);
+
     map = [r, g, b];
   else
     map = [];
   endif
 
 endfunction
 
 
diff --git a/scripts/image/rgb2hsv.m b/scripts/image/rgb2hsv.m
--- a/scripts/image/rgb2hsv.m
+++ b/scripts/image/rgb2hsv.m
@@ -12,26 +12,28 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {@var{hsv_map} =} rgb2hsv (@var{rgb})
-## Transform a colormap or image from the RGB space to the HSV space.
-##
-## A color in the RGB space consists of the red, green and blue intensities.
+## @deftypefn  {Function File} {@var{hsv_map} =} rgb2hsv (@var{rgb})
+## @deftypefnx {Function File} {@var{hsv_map} =} rgb2hsv (@var{rgb})
+## Transform a colormap or image from red-green-blue (RGB) space to
+## hue-saturation-value (HSV) space.
 ##
-## In the HSV space each color is represented by their hue, saturation
-## and value (brightness).  Value gives the amount of light in the color.
-## Hue describes the dominant wavelength.
-## Saturation is the amount of hue mixed into the color.
-## @seealso{hsv2rgb}
+## A color in the RGB space consists of red, green, and blue intensities.
+##
+## A color in HSV space is represented by hue, saturation and value
+## (brightness) levels.  Value gives the amount of light in the color.  Hue
+## describes the dominant wavelength.  Saturation is the amount of hue mixed
+## into the color.
+## @seealso{hsv2rgb, rgb2ind, rgb2ntsc}
 ## @end deftypefn
 
 ## Author: Kai Habel <kai.habel@gmx.de>
 ## Adapted-by: jwe
 
 function hsv_map = rgb2hsv (rgb)
 
   if (nargin != 1)
diff --git a/scripts/image/rgb2ind.m b/scripts/image/rgb2ind.m
--- a/scripts/image/rgb2ind.m
+++ b/scripts/image/rgb2ind.m
@@ -14,18 +14,18 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {[@var{x}, @var{map}] =} rgb2ind (@var{rgb})
 ## @deftypefnx {Function File} {[@var{x}, @var{map}] =} rgb2ind (@var{R}, @var{G}, @var{B})
-## Convert an RGB image to an Octave indexed image.
-## @seealso{ind2rgb, rgb2ntsc}
+## Convert an image in red-green-blue (RGB) space to an indexed image.
+## @seealso{ind2rgb, rgb2hsv, rgb2ntsc}
 ## @end deftypefn
 
 ## Bugs: The color map may have duplicate entries.
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: July 1994
 ## Adapted-By: jwe
 
diff --git a/scripts/image/rgb2ntsc.m b/scripts/image/rgb2ntsc.m
--- a/scripts/image/rgb2ntsc.m
+++ b/scripts/image/rgb2ntsc.m
@@ -12,19 +12,21 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} rgb2ntsc (@var{rgb})
-## Transform a colormap or image from RGB to NTSC.
-## @seealso{ntsc2rgb}
+## @deftypefn  {Function File} {@var{yiq_map} =} rgb2ntsc (@var{rgb_map})
+## @deftypefnx {Function File} {@var{yiq_img} =} rgb2ntsc (@var{rgb_img})
+## Transform a colormap or image from red-green-blue (RGB) space to
+## luminance-chrominance (NTSC) space.
+## @seealso{ntsc2rgb, rgb2hsv, rgb2ind}
 ## @end deftypefn
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: July 1994
 ## Adapted-By: jwe
 
 function yiq = rgb2ntsc (rgb)
 
diff --git a/scripts/image/rgbplot.m b/scripts/image/rgbplot.m
new file mode 100644
--- /dev/null
+++ b/scripts/image/rgbplot.m
@@ -0,0 +1,60 @@
+## Copyright (C) 2012 Rik Wehbring
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 3 of the License, or (at
+## your option) any later version.
+##
+## Octave is distributed in the hope that it will be useful, but
+## WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+## General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, see
+## <http://www.gnu.org/licenses/>.
+
+## -*- texinfo -*-
+## @deftypefn {Function File} {} rgbplot (@var{cmap})
+## Plot the components of a colormap.
+##
+## The first column is plotted in red, the second column in green, and
+## the third column in blue.  The values are between 0 and 1 and represent
+## the intensity of the RGB components in the given indexed color.
+## @seealso{colormap}
+## @end deftypefn
+
+function rgbplot (cmap)
+
+  if (nargin != 1)
+    print_usage ();
+  endif
+
+  if (! ismatrix (cmap) || ndims (cmap) != 2 || columns (cmap) != 3)
+    error ("rgbplot: CMAP must be a matrix of size Nx3");
+  elseif (any (cmap(:) < 0) || any (cmap(:) > 1))
+    error ("rgbplot: CMAP intensities must be in the range [0, 1]");
+  endif
+
+  plot (cmap(:,1),"r", cmap(:,2),"g", cmap(:,3),"b");
+  set (gca, 'ytick', 0:0.1:1);
+  xlabel ("color index");
+
+endfunction
+
+
+%!demo
+%! clf;
+%! rgbplot (ocean);
+
+%%test input validation
+%!error rgbplot ()
+%!error rgbplot (1,2)
+%!error <CMAP must be a matrix of size Nx3> rgbplot ({0 1 0})
+%!error <CMAP must be a matrix of size Nx3> rgbplot (ones (3,3,3))
+%!error <CMAP must be a matrix of size Nx3> rgbplot (ones (3,4))
+%!error <CMAP intensities must be in the range> rgbplot ([0 0 -2])
+%!error <CMAP intensities must be in the range> rgbplot ([0 0 2])
+
diff --git a/scripts/plot/spinmap.m b/scripts/image/spinmap.m
rename from scripts/plot/spinmap.m
rename to scripts/image/spinmap.m
--- a/scripts/plot/spinmap.m
+++ b/scripts/image/spinmap.m
@@ -12,46 +12,61 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} spinmap (@var{t}, @var{inc})
-## Cycle the colormap for @var{t} seconds with an increment
-## of @var{inc}.  Both parameters are optional.  The default cycle time
-## is 5 seconds and the default increment is 2.
+## @deftypefn  {Function File} {} spinmap ()
+## @deftypefnx {Function File} {} spinmap (@var{t})
+## @deftypefnx {Function File} {} spinmap (@var{t}, @var{inc})
+## @deftypefnx {Function File} {} spinmap ("inf")
+## Cycle the colormap for @var{t} seconds with a color increment of @var{inc}.
+## Both parameters are optional.  The default cycle time is 5 seconds and the
+## default increment is 2.  If the option "inf" is given then cycle
+## continuously until @kbd{Control-C} is pressed.
 ##
-## A higher value of @var{inc} causes a faster cycle through the
-## colormap.
-## @seealso{gca, colorbar}
+## When rotating the original color 1 becomes color 2, color 2 becomes
+## color 3, etc.  A positive or negative increment is allowed and a higher
+## value of @var{inc} will cause faster cycling through the colormap.
+## @seealso{colormap}
 ## @end deftypefn
 
 ## Author: Kai Habel <kai.habel at gmx.de>
 
-function spinmap (t, inc)
+function spinmap (t = 5, inc = 2)
 
-  if (nargin == 0)
-    inc = 2;
-    t = 5;
-  elseif (nargin == 1)
-    inc = 2;
+  if (nargin > 2)
+    print_usage ();
+  elseif (ischar (t))
+    if (strcmpi (t, "inf")) 
+      t = Inf;
+    else
+      error ('spinmap: time T must be a real scalar or "inf"');
+    endif
+  elseif (! isscalar (t) || ! isreal (t))
+    error ("spinmap: time T must be a real scalar");
   endif
 
-  cmap = get (gcf (), "colormap");
-  clen = rows (cmap);
+  cmap = cmap_orig = get (gcf (), "colormap");
 
   t0 = clock;
-
   while (etime (clock, t0) < t)
-    for n = 1:inc:clen
-      newmap = shift (cmap, n, 1);
-      set (gcf (), "colormap", newmap);
-      drawnow ();
-    endfor
+    cmap = shift (cmap, inc, 1);
+    set (gcf (), "colormap", cmap);
+    drawnow ();
   endwhile
 
-  set (gcf (), "colormap", cmap);
+  set (gcf (), "colormap", cmap_orig);
 
 endfunction
 
+
+%!demo
+%! clf;
+%! colormap (rainbow (128));
+%! imagesc (1:8);
+%! axis off;
+%! title ("Rotate color bars to the right");
+%! spinmap (3, 1);
+
diff --git a/scripts/image/spring.m b/scripts/image/spring.m
--- a/scripts/image/spring.m
+++ b/scripts/image/spring.m
@@ -38,17 +38,17 @@ function map = spring (n)
   else
     print_usage ();
   endif
 
   if (n == 1)
     map = [1, 0, 1];
   elseif (n > 1)
     r = ones (n, 1);
-    g = (0:n - 1)' ./ (n - 1);
+    g = [0:(n-1)]' / (n - 1);
     b = 1 - g;
     map = [r, g, b];
   else
     map = [];
   endif
 
 endfunction
 
diff --git a/scripts/image/summer.m b/scripts/image/summer.m
--- a/scripts/image/summer.m
+++ b/scripts/image/summer.m
@@ -22,35 +22,35 @@
 ## Create color colormap.  This colormap varies from green to yellow.
 ## The argument @var{n} must be a scalar.
 ## If unspecified, the length of the current colormap, or 64, is used.
 ## @seealso{colormap}
 ## @end deftypefn
 
 ## Author:  Kai Habel <kai.habel@gmx.de>
 ## Date:  06/03/2000
+
 function map = summer (n)
 
   if (nargin == 0)
     n = rows (colormap);
   elseif (nargin == 1)
     if (! isscalar (n))
       error ("summer: argument must be a scalar");
     endif
   else
     print_usage ();
   endif
 
   if (n == 1)
     map = [0, 0.5, 0.4];
   elseif (n > 1)
-    r = (0:n - 1)' ./ (n - 1);
-    g = 0.5 + r ./ 2;
+    r = [0:(n-1)]' / (n - 1);
+    g = 0.5 + r / 2;
     b = 0.4 * ones (n, 1);
-
     map = [r, g, b];
   else
     map = [];
   endif
 
 endfunction
 
 
diff --git a/scripts/image/white.m b/scripts/image/white.m
--- a/scripts/image/white.m
+++ b/scripts/image/white.m
@@ -34,21 +34,17 @@ function map = white (n)
   elseif (nargin == 1)
     if (! isscalar (n))
       error ("white: argument must be a scalar");
     endif
   else
     print_usage ();
   endif
 
-  if (n > 0)
-    map = ones (n, 3);
-  else
-    map = [];
-  endif
+  map = ones (n, 3);
 
 endfunction
 
 
 %!demo
 %! ## Show the 'white' colormap as an image
 %! image (1:64, linspace (0, 1, 64), repmat ((1:64)', 1, 64));
 %! axis ([1, 64, 0, 1], "ticy", "xy");
diff --git a/scripts/image/winter.m b/scripts/image/winter.m
--- a/scripts/image/winter.m
+++ b/scripts/image/winter.m
@@ -38,19 +38,18 @@ function map = winter (n)
   else
     print_usage ();
   endif
 
   if (n == 1)
     map = [0, 0, 1];
   elseif (n > 1)
     r = zeros (n, 1);
-    g = (0:n - 1)' ./ (n - 1);
-    b = 1 - g ./ 2;
-
+    g = [0:(n-1)]' / (n - 1);
+    b = 1 - g / 2;
     map = [r, g, b];
   else
     map = [];
   endif
 
 endfunction
 
 
diff --git a/scripts/io/dlmwrite.m b/scripts/io/dlmwrite.m
--- a/scripts/io/dlmwrite.m
+++ b/scripts/io/dlmwrite.m
@@ -35,28 +35,29 @@
 ## The value of @var{c} specifies the number of delimiters to prepend to
 ## each line of data.
 ##
 ## If the argument @code{"-append"} is given, append to the end of
 ## @var{file}.
 ##
 ## In addition, the following keyword value pairs may appear at the end
 ## of the argument list:
+##
 ## @table @asis
 ## @item "append"
 ## Either @samp{"on"} or @samp{"off"}.  See @samp{"-append"} above.
 ##
 ## @item "delimiter"
 ## See @var{delim} above.
 ##
 ## @item "newline"
 ## The character(s) to use to separate each row.  Three special cases
-## exist for this option.  @samp{"unix"} is changed into '\n',
-## @samp{"pc"} is changed into '\r\n', and @samp{"mac"} is changed
-## into '\r'.  Other values for this option are kept as is.
+## exist for this option.  @samp{"unix"} is changed into "\n",
+## @samp{"pc"} is changed into "\r\n", and @samp{"mac"} is changed
+## into "\r".  Other values for this option are kept as is.
 ##
 ## @item "roffset"
 ## See @var{r} above.
 ##
 ## @item "coffset"
 ## See @var{c} above.
 ##
 ## @item "precision"
@@ -191,21 +192,21 @@ function dlmwrite (file, M, varargin)
     endif
   endif
 
 endfunction
 
 
 %!test
 %! f = tmpnam ();
-%! dlmwrite (f,[1,2;3,4],'precision','%5.2f','newline','unix','roffset',1,'coffset',1);
+%! dlmwrite (f,[1,2;3,4],"precision","%5.2f","newline","unix","roffset",1,"coffset",1);
 %! fid = fopen (f,"rt");
-%! f1 = char (fread (fid,Inf,'char')');
+%! f1 = char (fread (fid,Inf,"char")');
 %! fclose (fid);
-%! dlmwrite (f,[5,6],'precision','%5.2f','newline','unix','coffset',1,'delimiter',',','-append');
+%! dlmwrite (f,[5,6],"precision","%5.2f","newline","unix","coffset",1,"delimiter",",","-append");
 %! fid = fopen (f,"rt");
-%! f2 = char (fread (fid,Inf,'char')');
+%! f2 = char (fread (fid,Inf,"char")');
 %! fclose (fid);
 %! unlink (f);
 %!
 %! assert (f1,",,\n, 1.00, 2.00\n, 3.00, 4.00\n");
 %! assert (f2,",,\n, 1.00, 2.00\n, 3.00, 4.00\n, 5.00, 6.00\n");
 
diff --git a/scripts/io/fileread.m b/scripts/io/fileread.m
--- a/scripts/io/fileread.m
+++ b/scripts/io/fileread.m
@@ -45,17 +45,17 @@ function str = fileread (filename)
 
 endfunction
 
 
 %!test
 %! cstr = {"Hello World", "The answer is 42", "Goodbye World"};
 %! fname = tmpnam ();
 %! fid = fopen (fname, "w");
-%! fprintf (fid, "%s\n", cstr{:})
+%! fprintf (fid, "%s\n", cstr{:});
 %! fclose (fid);
 %! str = fileread (fname);
 %! assert (str', [cstr{1} "\n" cstr{2} "\n" cstr{3} "\n"]);
 %! unlink (fname);
 
 %% Test input validation
 %!error fileread ()
 %!error fileread (1, 2)
diff --git a/scripts/io/is_valid_file_id.m b/scripts/io/is_valid_file_id.m
--- a/scripts/io/is_valid_file_id.m
+++ b/scripts/io/is_valid_file_id.m
@@ -34,13 +34,15 @@ function retval = is_valid_file_id (fid)
       endif
     end_try_catch
   else
     print_usage ();
   endif
 
 endfunction
 
+
 %!assert (is_valid_file_id (stdout))
 %!assert (! is_valid_file_id ([1,2;3,4]))
 %!assert (! is_valid_file_id ("not_a_file_id"))
 %!assert (! is_valid_file_id (-1))
 %!assert (! is_valid_file_id (pi))
+
diff --git a/scripts/io/strread.m b/scripts/io/strread.m
--- a/scripts/io/strread.m
+++ b/scripts/io/strread.m
@@ -29,16 +29,17 @@
 ## specifiers in @var{format}.  The first word is matched to the first
 ## specifier, the second to the second specifier and so forth.  If there are
 ## more words than specifiers, the process is repeated until all words have
 ## been processed.
 ##
 ## The string @var{format} describes how the words in @var{str} should be
 ## parsed.
 ## It may contain any combination of the following specifiers:
+##
 ## @table @code
 ## @item %s
 ## The word is parsed as a string.
 ##
 ## @itemx %f
 ## @itemx %n
 ## The word is parsed as a number and converted to double.
 ##
@@ -79,33 +80,34 @@
 ## can be read using
 ##
 ## @example
 ## [@var{a}, @var{b}, @var{c}] = strread (@var{str}, "%s %s %f");
 ## @end example
 ##
 ## Optional numeric argument @var{format_repeat} can be used for
 ## limiting the number of items read:
+##
 ## @table @asis
 ## @item -1
 ## (default) read all of the string until the end.
 ##
 ## @item N
 ## Read N times @var{nargout} items.  0 (zero) is an acceptable
 ## value for @var{format_repeat}.
-##
 ## @end table
 ##
 ## The behavior of @code{strread} can be changed via property-value
 ## pairs.  The following properties are recognized:
 ##
 ## @table @asis
 ## @item "commentstyle"
 ## Parts of @var{str} are considered comments and will be skipped.
 ## @var{value} is the comment style and can be any of the following.
+##
 ## @itemize
 ## @item "shell"
 ## Everything from @code{#} characters to the nearest end-of-line is skipped.
 ##
 ## @item "c"
 ## Everything between @code{/*} and @code{*/} is skipped.
 ##
 ## @item "c++"
@@ -434,83 +436,81 @@ function varargout = strread (str, forma
 
       ## 1. Assess "period" in the split-up words array ( < num_words_per_line).
       ## Could be done using EndOfLine but that prohibits EndOfLine = "" option.
       ## Alternative below goes by simply parsing a first grab of words
       ## and counting words until the fmt_words array is exhausted:
       iwrd = 1; iwrdp = 0; iwrdl = length (words{iwrd});
       for ii = 1:numel (fmt_words)
 
+        nxt_wrd = 0;
+
         if (idf(ii))
           ## Literal expected
           if (isempty (strfind (fmt_words{ii}, words(iwrd))))
             ## Not found in current word; supposed to be in next word
-            ++iwrd; iwrdp = 0;
-            if (ii < numel (fmt_words))
-              iwrdl = length (words{iwrd});
-            endif
+            nxt_wrd = 1;
           else
             ## Found it in current word.  Subtract literal length
             iwrdp += length (fmt_words{ii});
             if (iwrdp > iwrdl)
               ## Parse error.  Literal extends beyond delimiter (word boundary)
               warning ("strread: literal '%s' (fmt spec # %d) does not match data", ...
                 fmt_words{ii}, ii);
               ## Word assumed to be completely "used up". Next word
-              ++iwrd; iwrdp = 0;
-              if (ii < numel (fmt_words))
-                iwrdl = length (words{iwrd});
-              endif
+              nxt_wrd = 1;
             elseif (iwrdp == iwrdl)
               ## Word completely "used up". Next word
-              ++iwrd; iwrdp = 0;
-              if (ii < numel (fmt_words))
-                iwrdl = length (words{iwrd});
-              endif
+              nxt_wrd = 1;
             endif
           endif
 
         elseif (idg(ii))
           ## Fixed width specifier (%N or %*N): read just a part of word
-            iwrdp += floor ...
-             (str2double (fmt_words{ii}(regexp(fmt_words{ii}, '\d') : end-1)));
-            if (iwrdp > iwrdl)
-              ## Match error. Field extends beyond word boundary.
-              warning  ...
-              ("strread: field width '%s' (fmt spec # %d) extends beyond actual word limit", ...
-                 fmt_words{ii}, ii);
-              ## Assume word to be completely "used up".  Next word
-              ++iwrd; iwrdp = 0; iwrdl = length (words{iwrd});
-            elseif (iwrdp == iwrdl)
-              ## Word completely "used up".  Next word
-              ++iwrd; iwrdp = 0; iwrdl = length (words{iwrd});
-            endif
+          iwrdp += floor ...
+           (str2double (fmt_words{ii}(regexp(fmt_words{ii}, '\d') : end-1)));
+          if (iwrdp > iwrdl)
+            ## Match error. Field extends beyond word boundary.
+            warning  ...
+            ("strread: field width '%s' (fmt spec # %d) extends beyond actual word limit", ...
+               fmt_words{ii}, ii);
+            ## Assume word to be completely "used up".  Next word
+            nxt_wrd = 1;
+          elseif (iwrdp == iwrdl)
+            ## Word completely "used up".  Next word
+            nxt_wrd = 1;
+          endif
 
         else
           ## A simple format conv. specifier. Either (1) uses rest of word, or
           ## (2) is squeezed between current iwrdp and next literal, or (3) uses
           ## next word. (3) is already taken care of.  So just check (1) & (2)
           if (ii < numel (fmt_words) && idf(ii+1))
             ## Next fmt_word is a literal...
             if (! index (words{iwrd}(iwrdp+1:end), fmt_words{ii+1}))
               ## ...but not found in current word => field uses rest of word
-              ++iwrd; iwrdp = 0; iwrdl = length (words{iwrd});
+              nxt_wrd = 1;
             else
               ## ..or it IS found.  Add inferred width of current conversion field
               iwrdp += index (words{iwrd}(iwrdp+1:end), fmt_words{ii+1}) - 1;
             endif
           elseif (iwrdp < iwrdl)
             ## No bordering literal to the right => field occupies (rest of) word
-            ++iwrd; iwrdp = 0;
-            if (ii < numel (fmt_words))
-              iwrdl = length (words{iwrd});
-            endif
+            nxt_wrd = 1;
           endif
 
         endif
+
+        if (nxt_wrd)
+          ++iwrd; iwrdp = 0;
+          if (ii < numel (fmt_words))
+            iwrdl = length (words{iwrd});
+          endif
+        endif
+
       endfor
       ## Done
       words_period = max (iwrd - 1, 1);
       num_lines = ceil (num_words / words_period);
 
       ## 2. Pad words array so that it can be reshaped
       tmp_lines = ceil (num_words / words_period);
       num_words_padded = tmp_lines * words_period - num_words;
@@ -665,17 +665,17 @@ function varargout = strread (str, forma
                 ## Cast to integer
                 ## FIXME: NaNs will be transformed into zeros
                 data = int32 (data);
               endif
               varargout{k} = data.';
               k++;
             case "s"
               if (pad_out)
-                data(end+1:num_lines) = {""}
+                data(end+1:num_lines) = {""};
               endif
               varargout{k} = strtrunc (data, swidth)';
               k++;
             otherwise
           endswitch
         case {"%*", "%*s"}
           ## skip the word
         otherwise
@@ -733,39 +733,39 @@ endfunction
 
 
 %!test
 %! [a, b] = strread ("1 2", "%f%f");
 %! assert (a, 1);
 %! assert (b, 2);
 
 %!test
-%! str = '';
+%! str = "";
 %! a = rand (10, 1);
 %! b = char (randi ([65, 85], 10, 1));
 %! for k = 1:10
 %!   str = sprintf ('%s %.6f %s\n', str, a(k), b(k));
 %! endfor
-%! [aa, bb] = strread (str, '%f %s');
+%! [aa, bb] = strread (str, "%f %s");
 %! assert (a, aa, 1e-6);
 %! assert (cellstr (b), bb);
 
 %!test
-%! str = '';
+%! str = "";
 %! a = rand (10, 1);
 %! b = char (randi ([65, 85], 10, 1));
 %! for k = 1:10
 %!   str = sprintf ('%s %.6f %s\n', str, a(k), b(k));
 %! endfor
-%! aa = strread (str, '%f %*s');
+%! aa = strread (str, "%f %*s");
 %! assert (a, aa, 1e-6);
 
 %!test
 %! str = sprintf ('/* this is\nacomment*/ 1 2 3');
-%! a = strread (str, '%f', 'commentstyle', 'c');
+%! a = strread (str, "%f", "commentstyle", "c");
 %! assert (a, [1; 2; 3]);
 
 %!test
 %! str = "# comment\n# comment\n1 2 3";
 %! [a, b] = strread (str, '%n %s', 'commentstyle', 'shell', 'endofline', "\n");
 %! assert (a, [1; 3]);
 %! assert (b, {"2"});
 
@@ -779,70 +779,70 @@ endfunction
 
 %!test
 %! a = strread ("a b c, d e, , f", "%s", "delimiter", ",");
 %! assert (a, {"a b c"; "d e"; ""; "f"});
 
 %!test
 %! # Bug #33536
 %! [a, b, c] = strread ("1,,2", "%s%s%s", "delimiter", ",");
-%! assert (a{1}, '1');
-%! assert (b{1}, '');
-%! assert (c{1}, '2');
+%! assert (a{1}, "1");
+%! assert (b{1}, "");
+%! assert (c{1}, "2");
 
 %!test
 %! # Bug #33536
 %! a = strread ("[SomeText]", "[%s", "delimiter", "]");
 %! assert (a{1}, "SomeText");
 
 %!test
 %! dat = "Data file.\r\n=  =  =  =  =\r\nCOMPANY    : <Company name>\r\n";
-%! a = strread (dat, "%s", 'delimiter', "\n", 'whitespace', '', 'endofline', "\r\n");
+%! a = strread (dat, "%s", "delimiter", "\n", "whitespace", "", "endofline", "\r\n");
 %! assert (a{2}, "=  =  =  =  =");
 %! assert (double (a{3}(end-5:end)), [32 110 97 109 101 62]);
 
 %!test
-%! [a, b, c, d] = strread ("1,2,3,,5,6", "%d%f%d%f", 'delimiter', ',');
+%! [a, b, c, d] = strread ("1,2,3,,5,6", "%d%f%d%f", "delimiter", ",");
 %! assert (c, int32 (3));
 %! assert (d, NaN);
 
 %!test
-%! [a, b, c, d] = strread ("1,2,3,,5,6\n", "%d%d%f%d", 'delimiter', ',');
+%! [a, b, c, d] = strread ("1,2,3,,5,6\n", "%d%d%f%d", "delimiter", ",");
 %! assert (c, [3; NaN]);
 %! assert (d, int32 ([0; 0]));
 
 %!test
 %! # Default format (= %f)
 %1 [a, b, c] = strread ("0.12 0.234 0.3567");
 %1 assert (a, 0.12);
 %1 assert (b, 0.234);
 %1 assert (c, 0.3567);
 
 %!test
-%! [a, b] = strread('0.41 8.24 3.57 6.24 9.27', "%f%f", 2, 'delimiter', ' ');
+%! [a, b] = strread ("0.41 8.24 3.57 6.24 9.27", "%f%f", 2, "delimiter", " ");
 %1 assert (a, [0.41; 3.57]);
 
 %!test
 %! # TreatAsEmpty
-%! [a, b, c, d] = strread ("1,2,3,NN,5,6\n", "%d%d%d%f", 'delimiter', ',', 'TreatAsEmpty', 'NN');
+%! [a, b, c, d] = strread ("1,2,3,NN,5,6\n", "%d%d%d%f", "delimiter", ",", "TreatAsEmpty", "NN");
 %! assert (c, int32 ([3; 0]));
 %! assert (d, [NaN; NaN]);
 
 %!test
 %! # No delimiters at all besides EOL.  Plain reading numbers & strings
 %! str = "Text1Text2Text\nText398Text4Text\nText57Text";
 %! [a, b] = strread (str, "Text%dText%1sText");
 %! assert (a, int32 ([1; 398; 57]));
-%! assert (b(1:2), {'2'; '4'});
+%! assert (b(1:2), {"2"; "4"});
 %! assert (isempty (b{3}), true);
 
 %% MultipleDelimsAsOne
 %!test
 %! str = "11, 12, 13,, 15\n21,, 23, 24, 25\n,, 33, 34, 35";
-%! [a b c d] = strread (str, "%f %f %f %f", 'delimiter', ',', 'multipledelimsasone', 1, 'endofline', "\n");
+%! [a b c d] = strread (str, "%f %f %f %f", "delimiter", ",", "multipledelimsasone", 1, "endofline", "\n");
 %! assert (a', [11, 21, NaN]);
 %! assert (b', [12, 23, 33]);
 %! assert (c', [13, 24, 34]);
 %! assert (d', [15, 25, 35]);
 
 %% delimiter as sq_string and dq_string
 %!test
 %! assert (strread ("1\n2\n3", "%d", "delimiter", "\n"),
@@ -883,8 +883,9 @@ endfunction
 %!test
 %! str =  "0.31, 0.86, 0.94\n 0.60, 0.72, 0.87";
 %! fmt = "%f %f %f";
 %! args = {"delimiter", ",", "endofline", "\n", "whitespace", " "};
 %! [a, b, c] = strread (str, fmt, args {:});
 %! assert (a, [0.31; 0.60], 0.01)
 %! assert (b, [0.86; 0.72], 0.01)
 %! assert (c, [0.94; 0.87], 0.01)
+
diff --git a/scripts/io/textread.m b/scripts/io/textread.m
--- a/scripts/io/textread.m
+++ b/scripts/io/textread.m
@@ -126,23 +126,23 @@ function varargout = textread (filename,
 
   ## Call strread to make it do the real work
   [varargout{1:max (nargout, 1)}] = strread (str, format, varargin {:});
 
 endfunction
 
 
 %!test
-%! f = tmpnam();
+%! f = tmpnam ();
 %! d = rand (5, 3);
-%! dlmwrite (f, d, 'precision', '%5.2f');
+%! dlmwrite (f, d, "precision", "%5.2f");
 %! [a, b, c] = textread (f, "%f %f %f", "delimiter", ",", "headerlines", 3);
-%! unlink(f);
+%! unlink (f);
 %! assert (a, d(4:5, 1), 1e-2);
 %! assert (b, d(4:5, 2), 1e-2);
 %! assert (c, d(4:5, 3), 1e-2);
 
 %% Test input validation
 %!error textread ()
 %!error textread (1)
-%!error <arguments must be strings> textread (1, '%f')
+%!error <arguments must be strings> textread (1, "%f")
 %!error <arguments must be strings> textread ("fname", 1)
 
diff --git a/scripts/io/textscan.m b/scripts/io/textscan.m
--- a/scripts/io/textscan.m
+++ b/scripts/io/textscan.m
@@ -250,16 +250,17 @@ function C = colloutp (C)
     else
       ## No similar class in column to the left, search from there
       --ii;
     endif
   endwhile
 
 endfunction
 
+
 %!test
 %! str = "1,  2,  3,  4\n 5,  ,  ,  8\n 9, 10, 11, 12";
 %! fmtstr = "%f %d %f %s";
 %! c = textscan (str, fmtstr, 2, "delimiter", ",", "emptyvalue", -Inf);
 %! assert (isequal (c{1}, [1;5]));
 %! assert (length (c{1}), 2);
 %! assert (iscellstr (c{4}));
 %! assert (isequal (c{3}, [3; -Inf]));
@@ -270,57 +271,57 @@ endfunction
 %! str = sprintf ("%g miles/hr = %g kilometers/hr\n", b);
 %! fmt = "%f miles/hr = %f kilometers/hr";
 %! c = textscan (str, fmt);
 %! assert (b(1,:)', c{1}, 1e-5);
 %! assert (b(2,:)', c{2}, 1e-5);
 
 #%!test
 #%! str = "13, 72, NA, str1, 25\r\n// Middle line\r\n36, na, 05, str3, 6";
-#%! a = textscan(str, '%d %n %f %s %n', 'delimiter', ',','treatAsEmpty', {'NA', 'na'},'commentStyle', '//');
+#%! a = textscan (str, "%d %n %f %s %n", "delimiter", ",","treatAsEmpty", {"NA", "na"},"commentStyle", "//");
 #%! assert (a{1}, int32([13; 36]));
 #%! assert (a{2}, [72; NaN]);
 #%! assert (a{3}, [NaN; 5]);
 #%! assert (a{4}, {"str1"; "str3"});
 #%! assert (a{5}, [25; 6]);
 
 %!test
 %! str = "Km:10 = hhhBjjj miles16hour\r\n";
 %! str = [str "Km:15 = hhhJjjj miles241hour\r\n"];
 %! str = [str "Km:2 = hhhRjjj miles3hour\r\n"];
 %! str = [str "Km:25 = hhhZ\r\n"];
 %! fmt = "Km:%d = hhh%1sjjj miles%dhour";
-%! a = textscan (str, fmt, 'delimiter', ' ');
+%! a = textscan (str, fmt, "delimiter", " ");
 %! assert (a{1}', int32([10 15 2 25]));
 %! assert (a{2}', {'B' 'J' 'R' 'Z'});
 %! assert (a{3}', int32([16 241 3 0]));
 
 %% Test with default endofline parameter
 %!test
 %! c = textscan ("L1\nL2", "%s");
 %! assert (c{:}, {"L1"; "L2"});
 
-%% Test with endofline parameter set to '' (empty) - newline should be in word
+%% Test with endofline parameter set to "" (empty) - newline should be in word
 %!test
-%! c = textscan ("L1\nL2", "%s", 'endofline', '');
+%! c = textscan ("L1\nL2", "%s", "endofline", "");
 %! assert (int8(c{:}{:}), int8([ 76,  49,  10,  76,  50 ]));
 
 %!test
 %! # No delimiters at all besides EOL.  Skip fields, even empty fields
 %! str = "Text1Text2Text\nTextText4Text\nText57Text";
 %! c = textscan (str, "Text%*dText%dText");
 %! assert (c{1}, int32 ([2; 4; 0]));
 
 %!test
 %% CollectOutput test
 %! b = [10:10:100];
 %! b = [b; 8*b/5; 8*b*1000/5];
 %! str = sprintf ("%g miles/hr = %g (%g) kilometers (meters)/hr\n", b);
 %! fmt = "%f miles%s %s %f (%f) kilometers %*s";
-%! c = textscan (str, fmt, 'collectoutput', 1);
+%! c = textscan (str, fmt, "collectoutput", 1);
 %! assert (size(c{3}), [10, 2]);
 %! assert (size(c{2}), [10, 2]);
 
 %% Test input validation
 %!error textscan ()
 %!error textscan (single (4))
 %!error textscan ({4})
 %!error <must be a string> textscan ("Hello World", 2)
diff --git a/scripts/linear-algebra/commutation_matrix.m b/scripts/linear-algebra/commutation_matrix.m
--- a/scripts/linear-algebra/commutation_matrix.m
+++ b/scripts/linear-algebra/commutation_matrix.m
@@ -91,29 +91,31 @@ function k = commutation_matrix (m, n)
   for i = 1 : m
     for j = 1 : n
       k ((i - 1) * n + j, (j - 1) * m + i) = 1;
     endfor
   endfor
 
 endfunction
 
+
 %!test
-%! c = commutation_matrix(1,1);
-%! assert(c,1);
+%! c = commutation_matrix (1,1);
+%! assert (c,1);
 
 %!test
-%! A = rand(3,5);
-%! vc = vec(A);
-%! vr = vec(A');
-%! c = commutation_matrix(3,5);
-%! assert(c*vc,vr);
+%! A = rand (3,5);
+%! vc = vec (A);
+%! vr = vec (A');
+%! c = commutation_matrix (3,5);
+%! assert (c*vc, vr);
 
 %!test
-%! A = rand(4,6);
-%! vc = vec(A);
-%! vr = vec(A');
-%! c = commutation_matrix(4,6);
-%! assert(c*vc,vr);
+%! A = rand (4,6);
+%! vc = vec (A);
+%! vr = vec (A');
+%! c = commutation_matrix (4,6);
+%! assert (c*vc, vr);
 
-%!error commutation_matrix(0,0);
-%!error commutation_matrix(1,0);
-%!error commutation_matrix(0,1);
+%!error <M must be a positive integer> commutation_matrix (0,0)
+%!error <N must be a positive integer> commutation_matrix (1,0)
+%!error <M must be a positive integer> commutation_matrix (0,1)
+
diff --git a/scripts/linear-algebra/cond.m b/scripts/linear-algebra/cond.m
--- a/scripts/linear-algebra/cond.m
+++ b/scripts/linear-algebra/cond.m
@@ -69,25 +69,24 @@ function retval = cond (A, p)
       retval = norm (A, p) * norm (inv (A), p);
     endif
   else
     print_usage ();
   endif
 
 endfunction
 
+
 %!test
-%! y= [7, 2, 3; 1, 3, 4; 6, 4, 5];
+%! y = [7, 2, 3; 1, 3, 4; 6, 4, 5];
 %! tol = 1e-6;
-%! type = {1, 2, 'fro', 'inf', inf};
-%! for n = 1:numel(type)
+%! type = {1, 2, "fro", "inf", inf};
+%! for n = 1:numel (type)
 %!   rcondition(n) = 1 / cond (y, type{n});
 %! endfor
 %! assert (rcondition, [0.017460, 0.019597, 0.018714, 0.012022, 0.012022], tol);
 
-%!assert (abs (cond ([1, 2; 2, 1]) - 3) < sqrt (eps));
-
-%!assert (cond ([1, 2, 3; 4, 5, 6; 7, 8, 9]) > 1.0e+16);
+%!assert (cond ([1, 2; 2, 1]), 3, sqrt (eps))
+%!assert (cond ([1, 2, 3; 4, 5, 6; 7, 8, 9]) > 1.0e+16)
 
-%!error cond ();
+%!error cond ()
+%!error cond (1, 2, 3)
 
-%!error cond (1, 2, 3);
-
diff --git a/scripts/linear-algebra/condest.m b/scripts/linear-algebra/condest.m
--- a/scripts/linear-algebra/condest.m
+++ b/scripts/linear-algebra/condest.m
@@ -231,9 +231,10 @@ endfunction
 %! cA_test = norm (inv (A), 1) * norm (A, 1);
 %! assert (cA, cA_test, -2^-6);
 
 %!test
 %! N = 12;
 %! A = hilb (N);
 %! [rcondA, v] = condest (A);
 %! x = A*v;
-%! assert (norm(x, inf), 0, eps);
+%! assert (norm (x, inf), 0, eps);
+
diff --git a/scripts/linear-algebra/cross.m b/scripts/linear-algebra/cross.m
--- a/scripts/linear-algebra/cross.m
+++ b/scripts/linear-algebra/cross.m
@@ -86,30 +86,31 @@ function z = cross (x, y, dim)
     y3 = y(idx3{:});
     z = cat (dim, (x2.*y3 - x3.*y2), (x3.*y1 - x1.*y3), (x1.*y2 - x2.*y1));
   else
     error ("cross: X and Y must have the same dimensions");
   endif
 
 endfunction
 
+
 %!test
 %! x = [1 0 0];
 %! y = [0 1 0];
 %! r = [0 0 1];
-%! assert(cross(x, y), r, 2e-8);
+%! assert (cross (x, y), r, 2e-8);
 
 %!test
 %! x = [1 2 3];
 %! y = [4 5 6];
 %! r = [(2*6-3*5) (3*4-1*6) (1*5-2*4)];
-%! assert(cross(x, y), r, 2e-8);
+%! assert (cross (x, y), r, 2e-8);
 
 %!test
 %! x = [1 0 0; 0 1 0; 0 0 1];
 %! y = [0 1 0; 0 0 1; 1 0 0];
 %! r = [0 0 1; 1 0 0; 0 1 0];
-%! assert(cross(x, y, 2), r, 2e-8);
-%! assert(cross(x, y, 1), -r, 2e-8);
+%! assert (cross (x, y, 2), r, 2e-8);
+%! assert (cross (x, y, 1), -r, 2e-8);
 
-%!error cross(0,0);
-%!error cross();
+%!error cross (0,0)
+%!error cross ()
 
diff --git a/scripts/linear-algebra/duplication_matrix.m b/scripts/linear-algebra/duplication_matrix.m
--- a/scripts/linear-algebra/duplication_matrix.m
+++ b/scripts/linear-algebra/duplication_matrix.m
@@ -82,39 +82,41 @@ function d = duplication_matrix (n)
       d ((j - 1) * n + i, count + i) = 1;
       d ((i - 1) * n + j, count + i) = 1;
     endfor
     count = count + n - j;
   endfor
 
 endfunction
 
+
 %!test
 %! N = 2;
-%! A = rand(N);
+%! A = rand (N);
 %! B = A * A';
 %! C = A + A';
 %! D = duplication_matrix (N);
 %! assert (D * vech (B), vec (B), 1e-6);
 %! assert (D * vech (C), vec (C), 1e-6);
 
 %!test
 %! N = 3;
-%! A = rand(N);
+%! A = rand (N);
 %! B = A * A';
 %! C = A + A';
 %! D = duplication_matrix (N);
 %! assert (D * vech (B), vec (B), 1e-6);
 %! assert (D * vech (C), vec (C), 1e-6);
 
 %!test
 %! N = 4;
-%! A = rand(N);
+%! A = rand (N);
 %! B = A * A';
 %! C = A + A';
 %! D = duplication_matrix (N);
 %! assert (D * vech (B), vec (B), 1e-6);
 %! assert (D * vech (C), vec (C), 1e-6);
 
-%!error duplication_matrix ();
-%!error duplication_matrix (0.5);
-%!error duplication_matrix (-1);
-%!error duplication_matrix (ones(1,4));
+%!error duplication_matrix ()
+%!error duplication_matrix (0.5)
+%!error duplication_matrix (-1)
+%!error duplication_matrix (ones (1,4))
+
diff --git a/scripts/linear-algebra/expm.m b/scripts/linear-algebra/expm.m
--- a/scripts/linear-algebra/expm.m
+++ b/scripts/linear-algebra/expm.m
@@ -23,17 +23,17 @@
 ## @tex
 ## $$
 ##  \exp (A) = I + A + {A^2 \over 2!} + {A^3 \over 3!} + \cdots
 ## $$
 ## @end tex
 ## @ifnottex
 ##
 ## @example
-## expm(A) = I + A + A^2/2! + A^3/3! + @dots{}
+## expm (A) = I + A + A^2/2! + A^3/3! + @dots{}
 ## @end example
 ##
 ## @end ifnottex
 ## The Taylor series is @emph{not} the way to compute the matrix
 ## exponential; see Moler and Van Loan, @cite{Nineteen Dubious Ways to
 ## Compute the Exponential of a Matrix}, SIAM Review, 1978.  This routine
 ## uses Ward's diagonal Pad@'e approximation method with three step
 ## preconditioning (SIAM Journal on Numerical Analysis, 1977).  Diagonal
@@ -136,19 +136,21 @@ function r = expm (A)
   r(p, p) = r;
   ## Inverse trace reduction.
   if (trshift >0)
     r *= exp (trshift);
   endif
 
 endfunction
 
-%!assert(norm(expm([1 -1;0 1]) - [e -e; 0 e]) < 1e-5);
-%!assert(expm([1 -1 -1;0 1 -1; 0 0 1]), [e -e -e/2; 0 e -e; 0 0 e], 1e-5);
 
-%% Test input validation
-%!error expm ();
-%!error expm (1, 2);
-%!error <expm: A must be a square matrix> expm([1 0;0 1; 2 2]);
+%!assert (norm (expm ([1 -1;0 1]) - [e -e; 0 e]) < 1e-5);
+%!assert (expm ([1 -1 -1;0 1 -1; 0 0 1]), [e -e -e/2; 0 e -e; 0 0 e], 1e-5);
 
 %!assert (expm (10), expm (10))
 %!assert (full (expm (eye (3))), expm (full (eye (3))))
 %!assert (full (expm (10*eye (3))), expm (full (10*eye (3))), 8*eps)
+
+%% Test input validation
+%!error expm ()
+%!error expm (1, 2)
+%!error <expm: A must be a square matrix> expm ([1 0;0 1; 2 2])
+
diff --git a/scripts/linear-algebra/housh.m b/scripts/linear-algebra/housh.m
--- a/scripts/linear-algebra/housh.m
+++ b/scripts/linear-algebra/housh.m
@@ -87,47 +87,48 @@ function [housv, beta, zer] = housh (x, 
     else
       beta = 0.0;
     endif
     zer = (beta == 0);
   endif
 
 endfunction
 
+
 %!test
 %! x = [1 2 3]';
 %! j = 3;
-%! [hv, b, z] = housh(x, j, 0);
-%! r = (eye(3) - b*hv*hv') * x;
-%! d = - norm(x) * [0 0 1]';
-%! assert(r, d, 2e-8);
-%! assert(z, 0, 2e-8);
+%! [hv, b, z] = housh (x, j, 0);
+%! r = (eye (3) - b*hv*hv') * x;
+%! d = - norm (x) * [0 0 1]';
+%! assert (r, d, 2e-8);
+%! assert (z, 0, 2e-8);
 
 %!test
 %! x = [7 -3 1]';
 %! j = 2;
-%! [hv, b, z] = housh(x, j, 0);
-%! r = (eye(3) - b*hv*hv') * x;
-%! d = norm(x) * [0 1 0]';
-%! assert(r, d, 2e-8);
-%! assert(z, 0, 2e-8);
+%! [hv, b, z] = housh (x, j, 0);
+%! r = (eye (3) - b*hv*hv') * x;
+%! d = norm (x) * [0 1 0]';
+%! assert (r, d, 2e-8);
+%! assert (z, 0, 2e-8);
 
 %!test
 %! x = [1 0 0]';
 %! j = 1;
-%! [hv, b, z] = housh(x, j, 10);
-%! r = (eye(3) - b*hv*hv') * x;
-%! d = norm(x) * [1 0 0]';
-%! assert(r, d, 2e-8);
-%! assert(z, 1, 2e-8);
+%! [hv, b, z] = housh (x, j, 10);
+%! r = (eye (3) - b*hv*hv') * x;
+%! d = norm (x) * [1 0 0]';
+%! assert (r, d, 2e-8);
+%! assert (z, 1, 2e-8);
 
 %!test
 %! x = [5 0 4 1]';
 %! j = 2;
-%! [hv, b, z] = housh(x, j, 0);
-%! r = (eye(4) - b*hv*hv') * x;
-%! d = - norm(x) * [0 1 0 0]';
-%! assert(r, d, 2e-8);
-%! assert(z, 0, 2e-8);
+%! [hv, b, z] = housh (x, j, 0);
+%! r = (eye (4) - b*hv*hv') * x;
+%! d = - norm (x) * [0 1 0 0]';
+%! assert (r, d, 2e-8);
+%! assert (z, 0, 2e-8);
 
-%!error housh([0]);
-%!error housh();
+%!error housh ([0])
+%!error housh ()
 
diff --git a/scripts/linear-algebra/isdefinite.m b/scripts/linear-algebra/isdefinite.m
--- a/scripts/linear-algebra/isdefinite.m
+++ b/scripts/linear-algebra/isdefinite.m
@@ -62,26 +62,26 @@ function retval = isdefinite (x, tol)
     endif
   endif
 
 endfunction
 
 
 %!test
 %! A = [-1 0; 0 -1];
-%! assert (isdefinite (A), -1)
+%! assert (isdefinite (A), -1);
 
 %!test
 %! A = [1 0; 0 1];
-%! assert (isdefinite (A), 1)
+%! assert (isdefinite (A), 1);
 
 %!test
 %! A = [2 -1 0; -1 2 -1; 0 -1 2];
-%! assert (isdefinite (A), 1)
+%! assert (isdefinite (A), 1);
 
 %!test
 %! A = [1 0; 0 0];
-%! assert (isdefinite (A), 0)
+%! assert (isdefinite (A), 0);
 
 %!error isdefinite ()
 %!error isdefinite (1,2,3)
 %!error <X must be a Hermitian matrix> isdefinite ([1 2; 3 4])
 
diff --git a/scripts/linear-algebra/ishermitian.m b/scripts/linear-algebra/ishermitian.m
--- a/scripts/linear-algebra/ishermitian.m
+++ b/scripts/linear-algebra/ishermitian.m
@@ -45,23 +45,26 @@ function retval = ishermitian (x, tol = 
     else
       norm_x = norm (x, inf);
       retval = norm_x == 0 || norm (x - x', inf) / norm_x <= tol;
     endif
   endif
 
 endfunction
 
-%!assert(ishermitian (1));
-%!assert(!(ishermitian ([1, 2])));
-%!assert(ishermitian ([]));
-%!assert(ishermitian ([1, 2; 2, 1]));
-%!assert(!(ishermitian ("test")));
-%!assert(ishermitian ([1, 2.1; 2, 1.1], 0.2));
-%!assert(ishermitian ([1, -2i; 2i, 1]));
-%!assert(!(ishermitian ("t")));
-%!assert(!(ishermitian (["te"; "et"])));
-%!error ishermitian ([1, 2; 2, 1], 0, 0);
-%!error ishermitian ();
+
+%!assert (ishermitian (1))
+%!assert (! ishermitian ([1, 2]))
+%!assert (ishermitian ([]))
+%!assert (ishermitian ([1, 2; 2, 1]))
+%!assert (! ishermitian ("test"))
+%!assert (ishermitian ([1, 2.1; 2, 1.1], 0.2))
+%!assert (ishermitian ([1, -2i; 2i, 1]))
+%!assert (! ishermitian ("t"))
+%!assert (! ishermitian (["te"; "et"]))
 
 %!test
 %! s.a = 1;
-%! assert(!(ishermitian (s)));
+%! assert(! ishermitian (s));
+
+%!error ishermitian ([1, 2; 2, 1], 0, 0)
+%!error ishermitian ()
+
diff --git a/scripts/linear-algebra/issymmetric.m b/scripts/linear-algebra/issymmetric.m
--- a/scripts/linear-algebra/issymmetric.m
+++ b/scripts/linear-algebra/issymmetric.m
@@ -44,23 +44,26 @@ function retval = issymmetric (x, tol = 
     else
       norm_x = norm (x, inf);
       retval = norm_x == 0 || norm (x - x.', inf) / norm_x <= tol;
     endif
   endif
 
 endfunction
 
-%!assert(issymmetric (1));
-%!assert(!(issymmetric ([1, 2])));
-%!assert(issymmetric ([]));
-%!assert(issymmetric ([1, 2; 2, 1]));
-%!assert(!(issymmetric ("test")));
-%!assert(issymmetric ([1, 2.1; 2, 1.1], 0.2));
-%!assert(issymmetric ([1, 2i; 2i, 1]));
-%!assert(!(issymmetric ("t")));
-%!assert(!(issymmetric (["te"; "et"])));
-%!error issymmetric ([1, 2; 2, 1], 0, 0);
-%!error issymmetric ();
+
+%!assert (issymmetric (1))
+%!assert (! issymmetric ([1, 2]))
+%!assert (issymmetric ([]))
+%!assert (issymmetric ([1, 2; 2, 1]))
+%!assert (! (issymmetric ("test")))
+%!assert (issymmetric ([1, 2.1; 2, 1.1], 0.2))
+%!assert (issymmetric ([1, 2i; 2i, 1]))
+%!assert (! (issymmetric ("t")))
+%!assert (! (issymmetric (["te"; "et"])))
 
 %!test
 %! s.a = 1;
-%! assert(!(issymmetric (s)));
+%! assert(! issymmetric (s));
+
+%!error issymmetric ([1, 2; 2, 1], 0, 0)
+%!error issymmetric ()
+
diff --git a/scripts/linear-algebra/logm.m b/scripts/linear-algebra/logm.m
--- a/scripts/linear-algebra/logm.m
+++ b/scripts/linear-algebra/logm.m
@@ -21,17 +21,17 @@
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{s} =} logm (@var{A})
 ## @deftypefnx {Function File} {@var{s} =} logm (@var{A}, @var{opt_iters})
 ## @deftypefnx {Function File} {[@var{s}, @var{iters}] =} logm (@dots{})
 ## Compute the matrix logarithm of the square matrix @var{A}.  The
 ## implementation utilizes a Pad@'e approximant and the identity
 ##
 ## @example
-## logm(@var{A}) = 2^k * logm(@var{A}^(1 / 2^k))
+## logm (@var{A}) = 2^k * logm (@var{A}^(1 / 2^k))
 ## @end example
 ##
 ## The optional argument @var{opt_iters} is the maximum number of square roots
 ## to compute and defaults to 100.  The optional output @var{iters} is the
 ## number of square roots actually computed.
 ## @seealso{expm, sqrtm}
 ## @end deftypefn
 
@@ -151,20 +151,20 @@ function [x, w] = gauss_legendre (n)
   i = 1:n-1;
   v = i./sqrt ((2*i).^2-1);
   [V, D] = eig (diag (v, -1) + diag (v, 1));
   x = diag (D);
   w = 2*(V(1,:)'.^2);
 endfunction
 
 
-%!assert(norm(logm([1 -1;0 1]) - [0 -1; 0 0]) < 1e-5);
-%!assert(norm(expm(logm([-1 2 ; 4 -1])) - [-1 2 ; 4 -1]) < 1e-5);
-%!assert(logm([1 -1 -1;0 1 -1; 0 0 1]), [0 -1 -1.5; 0 0 -1; 0 0 0], 1e-5);
-
-%% Test input validation
-%!error logm ();
-%!error logm (1, 2, 3);
-%!error <logm: A must be a square matrix> logm([1 0;0 1; 2 2]);
-
+%!assert (norm (logm ([1 -1;0 1]) - [0 -1; 0 0]) < 1e-5)
+%!assert (norm (expm (logm ([-1 2 ; 4 -1])) - [-1 2 ; 4 -1]) < 1e-5)
+%!assert (logm ([1 -1 -1;0 1 -1; 0 0 1]), [0 -1 -1.5; 0 0 -1; 0 0 0], 1e-5)
 %!assert (logm (10), log (10))
 %!assert (full (logm (eye (3))), logm (full (eye (3))))
 %!assert (full (logm (10*eye (3))), logm (full (10*eye (3))), 8*eps)
+
+%% Test input validation
+%!error logm ()
+%!error logm (1, 2, 3)
+%!error <logm: A must be a square matrix> logm ([1 0;0 1; 2 2])
+
diff --git a/scripts/linear-algebra/normest.m b/scripts/linear-algebra/normest.m
--- a/scripts/linear-algebra/normest.m
+++ b/scripts/linear-algebra/normest.m
@@ -70,23 +70,24 @@ function [n, c] = normest (A, tol = 1e-6
     y = A' * x;
     n = norm (y);
     c += 1;
   until (abs (n - n0) <= tol * n)
 
   rand ("state", v);    # restore state of random number generator
 endfunction
 
+
 %!test
 %! A = toeplitz ([-2,1,0,0]);
-%! assert (normest(A), norm(A), 1e-6);
+%! assert (normest (A), norm (A), 1e-6);
 
 %!test
 %! A = rand (10);
-%! assert (normest(A), norm(A), 1e-6);
+%! assert (normest (A), norm (A), 1e-6);
 
 %% Test input validation
 %!error normest ()
 %!error normest (1, 2, 3)
 %!error normest ([true true])
 %!error normest (ones (3,3,3))
 %!error normest (1, [1, 2])
 %!error normest (1, 1+1i)
diff --git a/scripts/linear-algebra/null.m b/scripts/linear-algebra/null.m
--- a/scripts/linear-algebra/null.m
+++ b/scripts/linear-algebra/null.m
@@ -73,39 +73,43 @@ function retval = null (A, tol)
       endif
     else
       retval = zeros (cols, 0);
     endif
   endif
 
 endfunction
 
+
+%% FIXME: Need some tests for 'single' variables as well
+
 %!test
 %! A = 0;
-%! assert(null(A), 1);
+%! assert (null (A), 1);
 
 %!test
 %! A = 1;
-%! assert(null(A), zeros(1,0))
+%! assert (null (A), zeros (1,0));
 
 %!test
 %! A = [1 0; 0 1];
-%! assert(null(A), zeros(2,0));
+%! assert (null (A), zeros (2,0));
 
 %!test
 %! A = [1 0; 1 0];
-%! assert(null(A), [0 1]')
+%! assert (null (A), [0 1]');
 
 %!test
 %! A = [1 1; 0 0];
-%! assert(null(A), [-1/sqrt(2) 1/sqrt(2)]', eps)
+%! assert (null (A), [-1/sqrt(2) 1/sqrt(2)]', eps);
 
 %!test
 %! tol = 1e-4;
 %! A = [1 0; 0 tol-eps];
-%! assert(null(A,tol), [0 1]')
+%! assert (null (A,tol), [0; 1]);
 
 %!test
 %! tol = 1e-4;
 %! A = [1 0; 0 tol+eps];
-%! assert(null(A,tol), zeros(2,0));
+%! assert (null (A,tol), zeros (2,0));
 
-%!error null()
+%!error null ()
+
diff --git a/scripts/linear-algebra/onenormest.m b/scripts/linear-algebra/onenormest.m
--- a/scripts/linear-algebra/onenormest.m
+++ b/scripts/linear-algebra/onenormest.m
@@ -248,44 +248,45 @@ endfunction
 
 %!test
 %! N = 10;
 %! A = ones (N);
 %! [nm1, v1, w1] = onenormest (A);
 %! [nminf, vinf, winf] = onenormest (A', 6);
 %! assert (nm1, N, -2*eps);
 %! assert (nminf, N, -2*eps);
-%! assert (norm (w1, 1), nm1 * norm (v1, 1), -2*eps)
-%! assert (norm (winf, 1), nminf * norm (vinf, 1), -2*eps)
+%! assert (norm (w1, 1), nm1 * norm (v1, 1), -2*eps);
+%! assert (norm (winf, 1), nminf * norm (vinf, 1), -2*eps);
 
 %!test
 %! N = 10;
 %! A = ones (N);
 %! [nm1, v1, w1] = onenormest (@(x) A*x, @(x) A'*x, N, 3);
 %! [nminf, vinf, winf] = onenormest (@(x) A'*x, @(x) A*x, N, 3);
 %! assert (nm1, N, -2*eps);
 %! assert (nminf, N, -2*eps);
-%! assert (norm (w1, 1), nm1 * norm (v1, 1), -2*eps)
-%! assert (norm (winf, 1), nminf * norm (vinf, 1), -2*eps)
+%! assert (norm (w1, 1), nm1 * norm (v1, 1), -2*eps);
+%! assert (norm (winf, 1), nminf * norm (vinf, 1), -2*eps);
 
 %!test
 %! N = 5;
 %! A = hilb (N);
 %! [nm1, v1, w1] = onenormest (A);
 %! [nminf, vinf, winf] = onenormest (A', 6);
 %! assert (nm1, norm (A, 1), -2*eps);
 %! assert (nminf, norm (A, inf), -2*eps);
-%! assert (norm (w1, 1), nm1 * norm (v1, 1), -2*eps)
-%! assert (norm (winf, 1), nminf * norm (vinf, 1), -2*eps)
+%! assert (norm (w1, 1), nm1 * norm (v1, 1), -2*eps);
+%! assert (norm (winf, 1), nminf * norm (vinf, 1), -2*eps);
 
 ## Only likely to be within a factor of 10.
 %!test
 %! old_state = rand ("state");
 %! restore_state = onCleanup (@() rand ("state", old_state));
 %! rand ('state', 42);  % Initialize to guarantee reproducible results
 %! N = 100;
 %! A = rand (N);
 %! [nm1, v1, w1] = onenormest (A);
 %! [nminf, vinf, winf] = onenormest (A', 6);
 %! assert (nm1, norm (A, 1), -.1);
 %! assert (nminf, norm (A, inf), -.1);
-%! assert (norm (w1, 1), nm1 * norm (v1, 1), -2*eps)
-%! assert (norm (winf, 1), nminf * norm (vinf, 1), -2*eps)
+%! assert (norm (w1, 1), nm1 * norm (v1, 1), -2*eps);
+%! assert (norm (winf, 1), nminf * norm (vinf, 1), -2*eps);
+
diff --git a/scripts/linear-algebra/orth.m b/scripts/linear-algebra/orth.m
--- a/scripts/linear-algebra/orth.m
+++ b/scripts/linear-algebra/orth.m
@@ -75,16 +75,18 @@ function retval = orth (A, tol)
   else
 
     print_usage ();
 
   endif
 
 endfunction
 
+
 %!test
-%! for ii=1:20
+%! for i = 1:20
 %!   A = rand (10, 10);
 %!   V = orth (A);
 %!   if (det (A) != 0)
-%!     assert (V'*V, eye (10), 100*eps)
+%!     assert (V'*V, eye (10), 100*eps);
 %!   endif
 %! endfor
+
diff --git a/scripts/linear-algebra/planerot.m b/scripts/linear-algebra/planerot.m
--- a/scripts/linear-algebra/planerot.m
+++ b/scripts/linear-algebra/planerot.m
@@ -30,18 +30,19 @@
 ## @seealso{givens}
 ## @end deftypefn
 
 function [G, y] = planerot (x)
   G = givens (x(1), x(2));
   y = G * x(:);
 endfunction
 
+
 %!test
 %! x = [3 4];
-%! [g y] = planerot(x);
-%! assert(g - [x(1) x(2); -x(2) x(1)] / sqrt(x(1)^2 + x(2)^2), zeros(2), 2e-8);
-%! assert(y(2), 0, 2e-8);
+%! [g y] = planerot (x);
+%! assert (g, [x(1) x(2); -x(2) x(1)] / sqrt (x(1)^2 + x(2)^2), 2e-8);
+%! assert (y(2), 0, 2e-8);
 
-%!error planerot([0]);
-%!error planerot([0 0 0]);
-%!error planerot();
+%!error planerot ([0])
+%!error planerot ([0 0 0])
+%!error planerot ()
 
diff --git a/scripts/linear-algebra/qzhess.m b/scripts/linear-algebra/qzhess.m
--- a/scripts/linear-algebra/qzhess.m
+++ b/scripts/linear-algebra/qzhess.m
@@ -32,18 +32,18 @@
 ##      @result{}  q = [ -0.58124, -0.81373; -0.81373,  0.58124 ]
 ##      @result{}  z = [ 1, 0; 0, 1 ]
 ## @end group
 ## @end example
 ##
 ## The Hessenberg-triangular decomposition is the first step in
 ## Moler and Stewart's QZ@tie{}decomposition algorithm.
 ##
-## Algorithm taken from Golub and Van Loan, @cite{Matrix Computations, 2nd
-## edition}.
+## Algorithm taken from Golub and Van Loan,
+## @cite{Matrix Computations, 2nd edition}.
 ## @end deftypefn
 
 ## Author: A. S. Hodel <scotte@eng.auburn.edu>
 ## Created: August 1993
 ## Adapted-By: jwe
 
 function [aa, bb, q, z] = qzhess (A, B)
 
@@ -86,36 +86,37 @@ function [aa, bb, q, z] = qzhess (A, B)
   bb (2, 1) = 0.0;
   for i = 3:na
     bb (i, 1:(i-1)) = zeros (1, i-1);
     aa (i, 1:(i-2)) = zeros (1, i-2);
   endfor
 
 endfunction
 
+
 %!test
 %! a = [1 2 1 3;
 %!      2 5 3 2;
 %!      5 5 1 0;
 %!      4 0 3 2];
 %! b = [0 4 2 1;
 %!      2 3 1 1;
 %!      1 0 2 1;
 %!      2 5 3 2];
 %! mask = [0 0 0 0;
 %!         0 0 0 0;
 %!         1 0 0 0;
 %!         1 1 0 0];
-%! [aa, bb, q, z] = qzhess(a, b);
-%! assert(inv(q) - q', zeros(4), 2e-8);
-%! assert(inv(z) - z', zeros(4), 2e-8);
-%! assert(q * a * z, aa, 2e-8);
-%! assert(aa .* mask, zeros(4), 2e-8);
-%! assert(q * b * z, bb, 2e-8);
-%! assert(bb .* mask, zeros(4), 2e-8);
+%! [aa, bb, q, z] = qzhess (a, b);
+%! assert (inv (q) - q', zeros (4), 2e-8);
+%! assert (inv (z) - z', zeros (4), 2e-8);
+%! assert (q * a * z, aa, 2e-8);
+%! assert (aa .* mask, zeros (4), 2e-8);
+%! assert (q * b * z, bb, 2e-8);
+%! assert (bb .* mask, zeros (4), 2e-8);
 
 %!test
 %! a = [1 2 3 4 5;
 %!      3 2 3 1 0;
 %!      4 3 2 1 1;
 %!      0 1 0 1 0;
 %!      3 2 1 0 5];
 %! b = [5 0 4 0 1;
@@ -123,19 +124,19 @@ endfunction
 %!      0 3 2 1 0;
 %!      4 3 0 3 5;
 %!      2 1 2 1 3];
 %! mask = [0 0 0 0 0;
 %!         0 0 0 0 0;
 %!         1 0 0 0 0;
 %!         1 1 0 0 0;
 %!         1 1 1 0 0];
-%! [aa, bb, q, z] = qzhess(a, b);
-%! assert(inv(q) - q', zeros(5), 2e-8);
-%! assert(inv(z) - z', zeros(5), 2e-8);
-%! assert(q * a * z, aa, 2e-8);
-%! assert(aa .* mask, zeros(5), 2e-8);
-%! assert(q * b * z, bb, 2e-8);
-%! assert(bb .* mask, zeros(5), 2e-8);
+%! [aa, bb, q, z] = qzhess (a, b);
+%! assert (inv (q) - q', zeros (5), 2e-8);
+%! assert (inv (z) - z', zeros (5), 2e-8);
+%! assert (q * a * z, aa, 2e-8);
+%! assert (aa .* mask, zeros (5), 2e-8);
+%! assert (q * b * z, bb, 2e-8);
+%! assert (bb .* mask, zeros (5), 2e-8);
 
-%!error qzhess([0]);
-%!error qzhess();
+%!error qzhess ([0])
+%!error qzhess ()
 
diff --git a/scripts/linear-algebra/rank.m b/scripts/linear-algebra/rank.m
--- a/scripts/linear-algebra/rank.m
+++ b/scripts/linear-algebra/rank.m
@@ -54,58 +54,60 @@ function retval = rank (A, tol)
   else
     print_usage ();
   endif
 
   retval = sum (sigma > tolerance);
 
 endfunction
 
+
 %!test
 %! A = [1 2 3 4 5 6 7;
 %!      4 5 6 7 8 9 12;
 %!      1 2 3.1 4 5 6 7;
 %!      2 3 4 5 6 7 8;
 %!      3 4 5 6 7 8 9;
 %!      4 5 6 7 8 9 10;
 %!      5 6 7 8 9 10 11];
-%! assert(rank(A),4);
+%! assert (rank (A), 4);
 
 %!test
 %! A = [1 2 3 4 5 6 7;
 %!      4 5 6 7 8 9 12;
 %!      1 2 3.0000001 4 5 6 7;
 %!      4 5 6 7 8 9 12.00001;
 %!      3 4 5 6 7 8 9;
 %!      4 5 6 7 8 9 10;
 %!      5 6 7 8 9 10 11];
-%! assert(rank(A),4);
+%! assert (rank (A), 4);
 
 %!test
 %! A = [1 2 3 4 5 6 7;
 %!      4 5 6 7 8 9 12;
 %!      1 2 3 4 5 6 7;
 %!      4 5 6 7 8 9 12.00001;
 %!      3 4 5 6 7 8 9;
 %!      4 5 6 7 8 9 10;
 %!      5 6 7 8 9 10 11];
-%! assert(rank(A),3);
+%! assert (rank (A), 3);
 
 %!test
 %! A = [1 2 3 4 5 6 7;
 %!      4 5 6 7 8 9 12;
 %!      1 2 3 4 5 6 7;
 %!      4 5 6 7 8 9 12;
 %!      3 4 5 6 7 8 9;
 %!      4 5 6 7 8 9 10;
 %!      5 6 7 8 9 10 11];
-%! assert(rank(A),3);
+%! assert (rank (A), 3);
 
 %!test
-%! A = eye(100);
-%! assert(rank(A),100);
+%! A = eye (100);
+%! assert (rank (A), 100);
 
 %!test
 %! A = [1, 2, 3; 1, 2.001, 3; 1, 2, 3.0000001];
-%! assert(rank(A),3)
-%! assert(rank(A,0.0009),1)
-%! assert(rank(A,0.0006),2)
-%! assert(rank(A,0.00000002),3)
\ No newline at end of file
+%! assert (rank (A), 3);
+%! assert (rank (A,0.0009), 1);
+%! assert (rank (A,0.0006), 2);
+%! assert (rank (A,0.00000002), 3);
+
diff --git a/scripts/linear-algebra/rref.m b/scripts/linear-algebra/rref.m
--- a/scripts/linear-algebra/rref.m
+++ b/scripts/linear-algebra/rref.m
@@ -82,47 +82,47 @@ function [A, k] = rref (A, tol)
         break;
       endif
     endif
   endfor
   k = find (used);
 
 endfunction
 
+
 %!test
 %! a = [1];
-%! [r k] = rref(a);
-%! assert(r, [1], 2e-8);
-%! assert(k, [1], 2e-8);
+%! [r k] = rref (a);
+%! assert (r, [1], 2e-8);
+%! assert (k, [1], 2e-8);
 
 %!test
 %! a = [1 3; 4 5];
-%! [r k] = rref(a);
-%! assert(rank(a), rank(r), 2e-8);
-%! assert(r, eye(2), 2e-8);
-%! assert(k == [1, 2] || k == [2, 1]);
-
+%! [r k] = rref (a);
+%! assert (rank (a), rank (r), 2e-8);
+%! assert (r, eye (2), 2e-8);
+%! assert (k == [1, 2] || k == [2, 1]);
 
 %!test
 %! a = [1 3; 4 5; 7 9];
-%! [r k] = rref(a);
-%! assert(rank(a), rank(r), 2e-8);
-%! assert(r, eye(3)(:,1:2), 2e-8);
-%! assert(k, [1 2], 2e-8);
+%! [r k] = rref (a);
+%! assert (rank (a), rank (r), 2e-8);
+%! assert (r, eye(3)(:,1:2), 2e-8);
+%! assert (k, [1 2], 2e-8);
 
 %!test
 %! a = [1 2 3; 2 4 6; 7 2 0];
-%! [r k] = rref(a);
-%! assert(rank(a), rank(r), 2e-8);
-%! assert(r, [1 0 (3-7/2); 0 1 (7/4); 0 0 0], 2e-8);
-%! assert(k, [1 2], 2e-8);
+%! [r k] = rref (a);
+%! assert (rank (a), rank (r), 2e-8);
+%! assert (r, [1 0 (3-7/2); 0 1 (7/4); 0 0 0], 2e-8);
+%! assert (k, [1 2], 2e-8);
 
 %!test
 %! a = [1 2 1; 2 4 2.01; 2 4 2.1];
 %! tol = 0.02;
-%! [r k] = rref(a, tol);
-%! assert(rank(a, tol), rank(r, tol), 2e-8);
+%! [r k] = rref (a, tol);
+%! assert (rank (a, tol), rank (r, tol), 2e-8);
 %! tol = 0.2;
-%! [r k] = rref(a, tol);
-%! assert(rank(a, tol), rank(r, tol), 2e-8);
+%! [r k] = rref (a, tol);
+%! assert (rank (a, tol), rank (r, tol), 2e-8);
 
-%!error rref();
+%!error rref ();
 
diff --git a/scripts/linear-algebra/trace.m b/scripts/linear-algebra/trace.m
--- a/scripts/linear-algebra/trace.m
+++ b/scripts/linear-algebra/trace.m
@@ -36,17 +36,19 @@ function y = trace (A)
   elseif (any (size (A) == 1))
     y = A(1);
   else
     y = sum (diag (A));
   endif
 
 endfunction
 
-%!assert(trace ([1, 2; 3, 4]) == 5);
-%!assert(trace ([1, 2; 3, 4; 5, 6]) == 5);
-%!assert(trace ([1, 3, 5; 2, 4, 6]) == 5);
-%!assert(trace ([]), 0);
-%!assert(trace (randn(1,0)), 0);
-%!
-%!error trace ();
-%!error trace (1, 2);
-%!error <only valid on 2-D objects> trace(reshape(1:9,[1,3,3]));
+
+%!assert (trace ([1, 2; 3, 4]), 5)
+%!assert (trace ([1, 2; 3, 4; 5, 6]), 5)
+%!assert (trace ([1, 3, 5; 2, 4, 6]), 5)
+%!assert (trace ([]), 0)
+%!assert (trace (randn (1,0)), 0)
+
+%!error trace ()
+%!error trace (1, 2)
+%!error <only valid on 2-D objects> trace (reshape (1:9,[1,3,3]))
+
diff --git a/scripts/linear-algebra/vech.m b/scripts/linear-algebra/vech.m
--- a/scripts/linear-algebra/vech.m
+++ b/scripts/linear-algebra/vech.m
@@ -45,14 +45,14 @@ function v = vech (x)
   endif
 
   n = rows (x);
   slices = cellslices (x(:), (1:n) + n*(0:n-1), n*(1:n));
   v = vertcat (slices{:});
 
 endfunction
 
-%!assert(all (vech ([1, 2, 3; 4, 5, 6; 7, 8, 9]) == [1; 4; 7; 5; 8; 9]));
+
+%!assert (vech ([1, 2, 3; 4, 5, 6; 7, 8, 9]), [1; 4; 7; 5; 8; 9])
 
-%!error vech ();
+%!error vech ()
+%!error vech (1, 2)
 
-%!error vech (1, 2);
-
diff --git a/scripts/miscellaneous/ans.m b/scripts/miscellaneous/ans.m
--- a/scripts/miscellaneous/ans.m
+++ b/scripts/miscellaneous/ans.m
@@ -24,11 +24,12 @@
 ## @example
 ## 3^2 + 4^2
 ## @end example
 ##
 ## @noindent
 ## is evaluated, the value returned by @code{ans} is 25.
 ## @end defvr
 
+
 ## Mark file as being tested.  No real test needed for a documentation .m file
 %!assert (1)
 
diff --git a/scripts/miscellaneous/bincoeff.m b/scripts/miscellaneous/bincoeff.m
--- a/scripts/miscellaneous/bincoeff.m
+++ b/scripts/miscellaneous/bincoeff.m
@@ -37,17 +37,17 @@
 ## @end example
 ##
 ## @end ifnottex
 ## For example:
 ##
 ## @example
 ## @group
 ## bincoeff (5, 2)
-##      @result{} 10
+##    @result{} 10
 ## @end group
 ## @end example
 ##
 ## In most cases, the @code{nchoosek} function is faster for small
 ## scalar integer arguments.  It also warns about loss of precision for
 ## big arguments.
 ##
 ## @seealso{nchoosek}
@@ -98,23 +98,23 @@ function b = bincoeff (n, k)
   b(n_int) = round (b(n_int));
 
   idx = ! n_int;
   b(idx) = real (b(idx));
 
 endfunction
 
 
-%!assert(bincoeff (4, 2), 6)
-%!assert(bincoeff (2, 4), 0)
-%!assert(bincoeff (-4, 2), 10)
-%!assert(bincoeff (5, 2), 10)
-%!assert(bincoeff (50, 6), 15890700)
-%!assert(bincoeff (0.4, 2), -.12, 8*eps)
+%!assert (bincoeff (4, 2), 6)
+%!assert (bincoeff (2, 4), 0)
+%!assert (bincoeff (-4, 2), 10)
+%!assert (bincoeff (5, 2), 10)
+%!assert (bincoeff (50, 6), 15890700)
+%!assert (bincoeff (0.4, 2), -.12, 8*eps)
 
-%!assert(bincoeff ([4 NaN 4], [-1, 2, 2.5]), NaN (1, 3))
+%!assert (bincoeff ([4 NaN 4], [-1, 2, 2.5]), NaN (1, 3))
 
 %% Test input validation
-%!error bincoeff ();
-%!error bincoeff (1, 2, 3);
-%!error bincoeff (ones(3),ones(2))
-%!error bincoeff (ones(2),ones(3))
+%!error bincoeff ()
+%!error bincoeff (1, 2, 3)
+%!error bincoeff (ones (3),ones (2))
+%!error bincoeff (ones (2),ones (3))
 
diff --git a/scripts/miscellaneous/bug_report.m b/scripts/miscellaneous/bug_report.m
--- a/scripts/miscellaneous/bug_report.m
+++ b/scripts/miscellaneous/bug_report.m
@@ -39,10 +39,11 @@ function bug_report ()
   puts ("\n");
   puts ("  to learn how to submit useful bug reports that will\n");
   puts ("  help the Octave community diagnose and fix the problem\n");
   puts ("  quickly and efficiently.\n");
   puts ("\n");
 
 endfunction
 
+
 ## Mark file as being tested.  No real test needed for this function.
 %!assert (1)
diff --git a/scripts/miscellaneous/bzip2.m b/scripts/miscellaneous/bzip2.m
--- a/scripts/miscellaneous/bzip2.m
+++ b/scripts/miscellaneous/bzip2.m
@@ -16,17 +16,17 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{entries} =} bzip2 (@var{files})
 ## @deftypefnx {Function File} {@var{entries} =} bzip2 (@var{files}, @var{outdir})
 ## Compress the list of files specified in @var{files}.
-## Each file is compressed separately and a new file with a '.bz2' extension
+## Each file is compressed separately and a new file with a ".bz2" extension
 ## is created.  The original files are not modified.  Existing compressed files
 ## are silently overwritten.  If @var{outdir} is defined the compressed
 ## files are placed in this directory.
 ## @seealso{bunzip2, gzip, zip, tar}
 ## @end deftypefn
 
 function entries = bzip2 (varargin)
 
@@ -37,25 +37,27 @@ function entries = bzip2 (varargin)
       entries = __xzip__ ("bzip2", "bz2", "bzip2 %s", varargin{:});
     endif
   else
     print_usage ();
   endif
 
 endfunction
 
+
 %!xtest
-%!  # test for correct cleanup of temporary files
-%!  unwind_protect
-%!    filename = tmpnam;
-%!    dummy    = 1;
-%!    save(filename, "dummy");
-%!    n_tmpfiles_before = length(find(strncmp("oct-", cellstr(ls(P_tmpdir)), 4)));
-%!    entry = bzip2(filename);
-%!    n_tmpfiles_after = length(find(strncmp("oct-", cellstr(ls(P_tmpdir)), 4)));
-%!    if (n_tmpfiles_before != n_tmpfiles_after)
-%!      error("bzip2 has not cleaned up temporary files correctly!");
-%!    endif
-%!  unwind_protect_cleanup
-%!    delete(filename);
-%!    [path, basename, extension] = fileparts(filename);
-%!    delete([basename, extension, ".bz2"]);
-%!  end_unwind_protect
+%! # test for correct cleanup of temporary files
+%! unwind_protect
+%!   filename = tmpnam;
+%!   dummy    = 1;
+%!   save (filename, "dummy");
+%!   n_tmpfiles_before = length (find (strncmp ("oct-", cellstr (ls (P_tmpdir)), 4)));
+%!   entry = bzip2 (filename);
+%!   n_tmpfiles_after = length (find (strncmp ("oct-", cellstr (ls (P_tmpdir)), 4)));
+%!   if (n_tmpfiles_before != n_tmpfiles_after)
+%!     error ("bzip2 has not cleaned up temporary files correctly!");
+%!   endif
+%! unwind_protect_cleanup
+%!   delete (filename);
+%!   [path, basename, extension] = fileparts (filename);
+%!   delete ([basename, extension, ".bz2"]);
+%! end_unwind_protect
+
diff --git a/scripts/miscellaneous/comma.m b/scripts/miscellaneous/comma.m
--- a/scripts/miscellaneous/comma.m
+++ b/scripts/miscellaneous/comma.m
@@ -17,11 +17,12 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Operator} {} ,
 ## Array index, function argument, or command separator.
 ## @seealso{semicolon}
 ## @end deftypefn
 
+
 ## Mark file as being tested.  No real test needed for a documentation .m file
 %!assert (1)
 
diff --git a/scripts/miscellaneous/compare_versions.m b/scripts/miscellaneous/compare_versions.m
--- a/scripts/miscellaneous/compare_versions.m
+++ b/scripts/miscellaneous/compare_versions.m
@@ -195,59 +195,59 @@ function out = compare_versions (v1, v2,
 
   ## Reverse the output if not is given.
   if (not_op)
     out = !out;
   endif
 
 endfunction
 
+
 ## tests
 ## test both equality symbols
 ## test arbitrarily long equality
-%!assert(compare_versions("1.1.0.0.0", "1.1", "=="), true)
-%!assert(compare_versions("1", "1.1", "<"), true)
-%!assert(compare_versions("1.1", "1.1", "<="), true)
-%!assert(compare_versions("1.1", "1.1.1", "<="), true)
-%!assert(compare_versions("1.23", "1.24", "=<"), true)
+%!assert (compare_versions ("1.1.0.0.0", "1.1", "=="), true)
+%!assert (compare_versions ("1", "1.1", "<"), true)
+%!assert (compare_versions ("1.1", "1.1", "<="), true)
+%!assert (compare_versions ("1.1", "1.1.1", "<="), true)
+%!assert (compare_versions ("1.23", "1.24", "=<"), true)
 ## test different length numbers
-%!assert(compare_versions("23.2000", "23.1", ">"), true)
-%!assert(compare_versions("0.0.2", "0.0.1", ">="), true)
-%!assert(compare_versions("0.2", "0.0.100", "=>"), true)
-%!assert(compare_versions("0.1", "0.2", "!="), true)
-%!assert(compare_versions("0.1", "0.2", "~="), true)
+%!assert (compare_versions ("23.2000", "23.1", ">"), true)
+%!assert (compare_versions ("0.0.2", "0.0.1", ">="), true)
+%!assert (compare_versions ("0.2", "0.0.100", "=>"), true)
+%!assert (compare_versions ("0.1", "0.2", "!="), true)
+%!assert (compare_versions ("0.1", "0.2", "~="), true)
 
 ## test alphanumeric strings
-%!assert(compare_versions("1a", "1b", "<"), true)
-%!assert(compare_versions("a", "1", "<"), true)
-%!assert(compare_versions("1a", "1b", ">"), false)
-%!assert(compare_versions("a", "1", ">"), false)
-%!assert(compare_versions("1.1.0a", "1.1.0b", "=="), false)
-%!assert(compare_versions("1.1.0a", "1.1.0b", "!="), true)
-%!assert(compare_versions("1.1.0test", "1.1.0b", "=="), false)
-%!assert(compare_versions("1.1.0test", "1.1.0test", "=="), true)
+%!assert (compare_versions ("1a", "1b", "<"), true)
+%!assert (compare_versions ("a", "1", "<"), true)
+%!assert (compare_versions ("1a", "1b", ">"), false)
+%!assert (compare_versions ("a", "1", ">"), false)
+%!assert (compare_versions ("1.1.0a", "1.1.0b", "=="), false)
+%!assert (compare_versions ("1.1.0a", "1.1.0b", "!="), true)
+%!assert (compare_versions ("1.1.0test", "1.1.0b", "=="), false)
+%!assert (compare_versions ("1.1.0test", "1.1.0test", "=="), true)
 
 ## make sure that it won't just give true output
-%!assert(compare_versions("1", "0", "=="), false)
+%!assert (compare_versions ("1", "0", "=="), false)
 ## test arbitrarily long equality
-%!assert(compare_versions("1.1.1.0.0", "1.1", "=="), false)
-%!assert(compare_versions("1.1", "1", "<"), false)
-%!assert(compare_versions("2", "1.1", "<="), false)
-%!assert(compare_versions("1.1.1", "1.1", "<="), false)
-%!assert(compare_versions("1.25", "1.24", "=<"), false)
+%!assert (compare_versions ("1.1.1.0.0", "1.1", "=="), false)
+%!assert (compare_versions ("1.1", "1", "<"), false)
+%!assert (compare_versions ("2", "1.1", "<="), false)
+%!assert (compare_versions ("1.1.1", "1.1", "<="), false)
+%!assert (compare_versions ("1.25", "1.24", "=<"), false)
 ## test different length numbers
-%!assert(compare_versions("23.2", "23.100", ">"), false)
-%!assert(compare_versions("0.0.0.2", "0.0.1", ">="), false)
-%!assert(compare_versions("0.0.20", "0.10.2", "=>"), false)
-%!assert(compare_versions("0.1", "0.1", "!="), false)
-%!assert(compare_versions("0.1", "0.1", "~="), false)
+%!assert (compare_versions ("23.2", "23.100", ">"), false)
+%!assert (compare_versions ("0.0.0.2", "0.0.1", ">="), false)
+%!assert (compare_versions ("0.0.20", "0.10.2", "=>"), false)
+%!assert (compare_versions ("0.1", "0.1", "!="), false)
+%!assert (compare_versions ("0.1", "0.1", "~="), false)
 
 %% Test input validation
-%!error(compare_versions(0.1, "0.1", "=="))
-%!error(compare_versions("0.1", 0.1, "=="))
-%!error(compare_versions(["0";".";"1"], "0.1", "=="))
-%!error(compare_versions("0.1", ["0";".";"1"], "=="))
-%!error(compare_versions("0.1", "0.1", "<>"))
-%!error(compare_versions("0.1", "0.1", "!>"))
-%!error(compare_versions("0.1", "0.1", "="))
-%!error(compare_versions("0.1", "0.1", "aa"))
+%!error (compare_versions (0.1, "0.1", "=="))
+%!error (compare_versions ("0.1", 0.1, "=="))
+%!error (compare_versions (["0";".";"1"], "0.1", "=="))
+%!error (compare_versions ("0.1", ["0";".";"1"], "=="))
+%!error (compare_versions ("0.1", "0.1", "<>"))
+%!error (compare_versions ("0.1", "0.1", "!>"))
+%!error (compare_versions ("0.1", "0.1", "="))
+%!error (compare_versions ("0.1", "0.1", "aa"))
 
-
diff --git a/scripts/miscellaneous/computer.m b/scripts/miscellaneous/computer.m
--- a/scripts/miscellaneous/computer.m
+++ b/scripts/miscellaneous/computer.m
@@ -22,20 +22,20 @@
 ## Print or return a string of the form @var{cpu}-@var{vendor}-@var{os}
 ## that identifies the kind of computer Octave is running on.  If invoked
 ## with an output argument, the value is returned instead of printed.  For
 ## example:
 ##
 ## @example
 ## @group
 ## computer ()
-##      @print{} i586-pc-linux-gnu
+##    @print{} i586-pc-linux-gnu
 ##
 ## x = computer ()
-##      @result{} x = "i586-pc-linux-gnu"
+##    @result{} x = "i586-pc-linux-gnu"
 ## @end group
 ## @end example
 ##
 ## If two output arguments are requested, also return the maximum number
 ## of elements for an array.
 ##
 ## If three output arguments are requested, also return the byte order
 ## of the current system as a character (@code{"B"} for big-endian or
@@ -80,12 +80,15 @@ function [c, maxsize, endian] = computer
       endif
     endif
   else
     print_usage ();
   endif
 
 endfunction
 
-%!assert((ischar (computer ())
-%! && computer () == octave_config_info ("canonical_host_type")));
-%!assert(ischar (computer ("arch")));
-%!error computer (2);
+
+%!assert (ischar (computer ()))
+%!assert (computer (), octave_config_info ("canonical_host_type"))
+%!assert (ischar (computer ("arch")))
+
+%!error computer (2)
+
diff --git a/scripts/miscellaneous/dir.m b/scripts/miscellaneous/dir.m
--- a/scripts/miscellaneous/dir.m
+++ b/scripts/miscellaneous/dir.m
@@ -28,25 +28,25 @@
 ## bytes
 ## date
 ## isdir
 ## statinfo
 ## @end group
 ## @end example
 ##
 ## @noindent
-## in which @code{statinfo} is the structure returned from @code{stat}.
+## where @code{statinfo} is the structure returned from @code{stat}.
 ##
 ## If @var{directory} is not a directory, return information about the
 ## named @var{filename}.  @var{directory} may be a list of directories
 ## specified either by name or with wildcard characters (like * and ?)
 ## which will be expanded with glob.
 ##
 ## Note that for symbolic links, @code{dir} returns information about
-## the file that a symbolic link points to instead of the link itself.
+## the file that the symbolic link points to instead of the link itself.
 ## However, if the link points to a nonexistent file, @code{dir} returns
 ## information about the link.
 ## @seealso{ls, stat, lstat, readdir, glob, filesep}
 ## @end deftypefn
 
 ## Author: jwe
 
 ## FIXME -- this is quite slow for large directories, so perhaps
diff --git a/scripts/miscellaneous/edit.m b/scripts/miscellaneous/edit.m
--- a/scripts/miscellaneous/edit.m
+++ b/scripts/miscellaneous/edit.m
@@ -69,16 +69,17 @@
 ## The following control fields are used:
 ##
 ## @table @samp
 ## @item editor
 ## This is the editor to use to modify the functions.  By default it uses
 ## Octave's @env{EDITOR} built-in function, which comes from
 ## @code{getenv("EDITOR")} and defaults to @code{emacs}.  Use @code{%s}
 ## In place of the function name.  For example,
+##
 ## @table @samp
 ## @item [EDITOR, " %s"]
 ## Use the editor which Octave uses for @code{edit_history}.
 ##
 ## @item "xedit %s &"
 ## pop up simple X11 editor in a separate window
 ##
 ## @item "gnudoit -q \"(find-file \\\"%s\\\")\""
@@ -105,16 +106,17 @@
 ##
 ## @item email
 ## This is the e-mail address to list after the name in the author field.
 ## By default it guesses @code{<$LOGNAME@@$HOSTNAME>}, and if @code{$HOSTNAME}
 ## is not defined it uses @code{uname -n}.  You probably want to override this.
 ## Be sure to use @code{<user@@host>} as your format.
 ##
 ## @item license
+##
 ## @table @samp
 ## @item gpl
 ## GNU General Public License (default).
 ##
 ## @item bsd
 ## BSD-style license without advertising clause.
 ##
 ## @item pd
@@ -499,16 +501,17 @@ function ret = default_user (long_form)
       ret = ret(1:pos-1);
     endif
   else
     ret = ent.name;
   endif
 
 endfunction
 
+
 %!test
 %! s.editor = edit ("get", "editor");
 %! s.home = edit ("get", "home");
 %! s.author = edit ("get", "author");
 %! s.email = edit ("get", "email");
 %! s.license = edit ("get", "license");
 %! s.editinplace = edit ("get", "editinplace");
 %! s.mode = edit ("get", "mode");
diff --git a/scripts/miscellaneous/fact.m b/scripts/miscellaneous/fact.m
--- a/scripts/miscellaneous/fact.m
+++ b/scripts/miscellaneous/fact.m
@@ -26,17 +26,17 @@
 
 function f = fact()
   persistent wisdom = \
       {
        "Richard Stallman takes notes in binary.";
        "Richard Stallman doesn't need sudo. I will make him a sandwich anyway.";
        "Richard Stallman is my shephurd, and I am his GNU.";
        "Richard Stallman doesn't wget, Richard Stallman wdemands!";
-       "Richard Stallman can touch MC Hammer";
+       "Richard Stallman can touch MC Hammer.";
        "Richard Stallman doesn't read web pages. They write to him.";
        "Richard Stallman gets 9 bits to the byte.";
        "Richard Stallman doesn't really believe in open software, because it's not free enough.";
        "Richard Stallman can leave neutral or negative feedback on eBay.";
        "Richard Stallman is the only man alive who can pronounce GNU the way it is meant to be pronounced.";
        "Richard Stallman does not own a mobile phone because he can fashion a crude convex dish and shout into it at the exact resonant frequency of the ozone, causing a voice to seemingly come from the sky above his intended recipient.";
        "Richard Stallman is so handsome that when he was young he was responsible for all other geeks not being able to get girls. This is why he has to cover his face with a thick layer of hair.";
        "Some people check their computers for viruses. Viruses check their computers for Richard Stallman.";
@@ -45,58 +45,58 @@ function f = fact()
        "Richard Stallman's beard is made of parentheses.";
        "Richard Stallman's DNA is in binary.";
        "Richard Stallman's nervous system is completely wireless.";
        "Richard Stallman's brain accepts UNIX commands.";
        "If Richard Stallman has 1GB of RAM, and if you have 1GB of RAM, Richard Stallman has more RAM than you.";
        "Richard Stallman eats ethernet cables. That's why they invented wireless.";
        "Richard Stallman has a katana. 'Nuff said.";
        "Richard Stallman wrote a program that divides by zero.";
-       "Ricahrd Stallman doesn't use zip drives, he just squeezes the hard drive.";
+       "Richard Stallman doesn't use zip drives; he just squeezes the hard drive.";
        "Richard Stallman's compiler is afraid to report errors.";
        "Richard Stallman wrote the compiler God used. The Big Bang was the Universe's first segfault.";
        "Richard Stallman successfully compiled a kernel of popcorn.";
-       "Richard Stallman doesn't write programs, they write themselves out of reverence.";
+       "Richard Stallman doesn't write programs; they write themselves out of reverence.";
        "Richard Stallman can make infinite loops end.";
        "Richard Stallman's anti-virus programs cures HIV.";
        "Richard Stallman's computer doesn't have a clock; it defines what time it is.";
        "Richard Stallman wrote a program to compute the last digit of pi.";
-       "Richard Stallman doesn't use web browsers. He sends a link to a demon that uses wget to fetch the page and sends it back to him.";
+       "Richard Stallman doesn't use web browsers. He sends a link to a daemon that uses wget to fetch the page and sends it back to him.";
        "Richard Stallman can solve the halting problem... in polynomial time.";
        "For Richard Stallman, polynomial time is O(1).";
        "Richard Stallman didn't \"write\" Emacs or created it in his own image. Richard Stallman made Emacs an instance of himself.";
        "Richard Stallman can coerce meaningful data from /dev/null.";
        "Some people wear Linus Torvalds pyjamas to bed, Linus Torvalds wears Richard Stallman pyjamas.";
-       "There is no software development process, only a bunch of programs Richard Stallman allows to exist. ";
-       "Richard Stallman spends his leisure time programming with Guile on GNU Hurd. ";
+       "There is no software development process, only a bunch of programs Richard Stallman allows to exist.";
+       "Richard Stallman spends his leisure time programming with Guile on GNU Hurd.";
        "Richard Stallman's left and right hands are named \"(\" and \")\" ";
-       "Richard Stallman first words were actually syscalls. ";
-       "Richard Stallman didn't create the singularity. He is the singularity. GNU/Linux is only the event horizon. ";
+       "Richard Stallman first words were actually syscalls.";
+       "Richard Stallman didn't create the singularity. He is the singularity. GNU/Linux is only the event horizon.";
        "When Richard Stallman pipes to more, he gets less ";
-       "Richard Stallman never showers: he runs 'make clean'. ";
-       "Richard Stallman needs neither mouse nor keyboard to operate his computer. He just stares it down until it does what he wants. ";
-       "Richard Stallman didn't write the GPL. He is the GPL. ";
-       "Richad Stallman's pinky finger is really a USB memory stick. ";
-       "Richard Stallman called his operating system GNU because he created it before computers existed, when actual gnus were used for calcuations. ";
-       "In Soviet Russia, Richard Stallman is still Richard Stallman! ";
-       "Richard Stallman's flute only plays free music. ";
+       "Richard Stallman never showers; he runs 'make clean'.";
+       "Richard Stallman needs neither mouse nor keyboard to operate his computer. He just stares it down until it does what he wants.";
+       "Richard Stallman didn't write the GPL. He is the GPL.";
+       "Richard Stallman's pinky finger is really a USB memory stick.";
+       "Richard Stallman called his operating system GNU because he created it before computers existed, when actual gnus were used for calcuations.";
+       "In Soviet Russia, Richard Stallman is still Richard Stallman!";
+       "Richard Stallman's flute only plays free music.";
        "When Richard Stallman uses floats, there are no rounding errors.";
-       "Richard Stallman wrote a program so powerful, it knows the question to 42.";
+       "Richard Stallman wrote a program so powerful it knows the question to 42.";
        "Richard Stallman released his own DNA under GNU FDL.";
        "Richard Stallman knows the entire wikipedia by heart, markup included.";
        "Richard Stallman wrote the HAL9000 OS.";
        "Richard Stallman's laser pointer is a lightsaber.";
-       "Richard Stallman never steps down; he shifts the universe up .";
+       "Richard Stallman never steps down; he shifts the universe up.";
        "Richard Stallman doesn't maintain code; he stares at it until it fixes itself out of reverence.";
        "Richard Stallman doesn't use an editor; he sets the fundamental constants of the universe so that a magnetic platter with his code on it evolves itself.";
        "Richard Stallman doesn‚Äôt code; he dares the computer to not do his bidding.";
-       "Global warming is caused by Richard Stallman‚Äôs rage toward non-free software.";
+       "Global warming is caused by Richard Stallman's rage towards non-free software.";
        "Rather than being birthed like a normal child, Richard Stallman instead instantiated himself polymorphically. Shortly thereafter he grew a beard.";
        "Richard Stallman discovered extra-terrestrial life but killed them because they used non-free software.";
-       "Richard Stallman doesn't evaluate expressions, expressions evaluate to Richard Stallman.";
+       "Richard Stallman doesn't evaluate expressions; expressions evaluate to Richard Stallman.";
        "Richard Stallman can see Russia from his house.";
        "Richard Stallman proved P=NP, twice!";
        "Richard Stallman knows of an unfixed bug in TeX.";
        "Richard Stallman can write a context-free grammar for C.";
        "Richard Stallman can determine whether an arbitrary program will terminate.";
        "Richard Stallman's computer has only two buttons. One is for guests.";
        "Richard Stallman does not actually write programs. He comes up with a length and digit index in pi.";
        "Richard Stallman's distributed version control system is a flamewar on Usenet.";
@@ -113,135 +113,133 @@ function f = fact()
        "In an average living room there are 1,242 objects Richard Stallman could use to write an OS, including the room itself.";
        "Vendor lock-in is when vendors lock themselves inside of a building out of fear of Richard Stallman's wrath.";
        "When Richard Stallman executes ps -e, you show up.";
        "When Richard Stallman gets angry he doesn't swear; he recurses.";
        "On Richard Stallman's computer the bootloader is contained in his .emacs.";
        "Richard Satallman can make any operating system free, free from drivers.";
        "Richard Stallman programmed Chuck Norris.";
        "Behind Richard Stallman's beard there is another fist, to code faster.";
-       "Richard Stallman won a Suduku that started with only one number in each line";
+       "Richard Stallman won a Sudoku that started with only one number in each line.";
        "Richard Stallman's brain compiles and runs C code.";
        "Richard Stallman wrote the first version of Emacs using Emacs.";
        "Richard Stallman never gonna give you up, never gonna let you down, never gonna run around and desert you, never gonna make you cry, never gonna say goodbye, never gonna tell a lie and hurt you.";
        "Richard Stallman, upon reading these facts, didn't laugh at all. Instead, he complained that he is being linked to that dirty \"open source\" software. He also asked it to be changed to \"free software\", in order to raise awareness for software freedom in our society.";
        "Richard Stallman has no problem using Emacs. He wrote it with his 4 hands.";
        "Richard Stallman will revert the big rip by adding parenthesis to the dark matter.";
        "When you make a Google search and it doesn't find the answer, Google gently consults Richard Stallman.";
        "Richard Stallman's uptime is over 53 years. And counting up.";
-       "Richard Stallman's portable music player plays ogg and WMA.";
+       "Richard Stallman's portable music player can play ogg and WMA, but is too afraid to invoke Richard Stallman's wrath by playing WMA. Ogg it is, then.";
        "Richard Stallman will never die, but may some day go to /dev/null.";
        "Richard Stallman once got swine flu, but it got cleansed by hereditay GPL and thus got assimilated.";
-       "Richard Stallman don't cut his hair because there are no GNU/Scissors";
+       "Richard Stallman don't cut his hair because there are no GNU/Scissors.";
        "Richard Stallman is the one who trims Chuck Norris beard. And he does it freely, of course.";
        "Richard Stallman does not take bath, for the hydroelectric company uses proprietary software.";
        "Agent Smith loves Richard Stallman's scent.";
        "Richard Stallman is the One.";
-       "\"They can take our lives, but they can never take our freedom.\" Willian Wallace after a litle talk with Richard Stallman.";
+       "\"They can take our lives, but they can never take our freedom.\" -- William Wallace after a little talk with Richard Stallman.";
        "Richard Stallman can connect to any brain using an Emacs ssh client.";
        "Richard Stallman ported Emacs to Intel 4004 chip.";
        "Richard Stallman did not write GNU Emacs, he simply read the source code from /dev/null.";
        "Richard Stallman once used GDB to reverse-engineer Windows 7 into a free operating system - able to run on GNU Emacs!";
        "Richard Stallman does not contribute to open source projects; open source projects contribute to Richard Stallman, and then call themselves free software projects.";
        "Richard Stallman programmed himself before he could even exist";
        "Richard Stallman can fill up /dev/null.";
        "Richard Stallman is so zealous about privacy he has /dev/null as his home.";
        "When Richard Stallman runs /bin/false, it returns \"true\".";
        "Richard Stallman doesn't like money, because banks don't run on free software.";
        "Richard Stallman user GNU tar to compress air.";
-       "Richard Stallman was installed in the world, it runs on a free program ..";
        "When Richard Stallman reports a bug, the bug prefers to squash itself instead of facing Richard Stallman's wrath.";
-       "There is no Windows in Richard Stallman's house... only Doors...";
+       "There are no Windows in Richard Stallman's house... only Doors...";
        "Richard Stallman doesn't like neither PCs-Intel nor Burger King... He prefers e-Macs...";
        "Richard Stallman can use grep to find Jimmy Hoffa.";
        "Richard Stallman made it possible to not absolutely abhor HPUX.";
        "When Richard Stallman pours his alphabets cereal into a bowl, only G's, N's, and U's come out.";
        "Richard Stallman is pronounced \"GNU slash Stallman\"";
        "Richard Stallman doesn't mind if you read his mail as long as you don't delete it before he reads it.";
        "Richard Stallman is just a guy who has strong principles and decided to follow them.";
        "Richard Stallman knows that you don't have class because it is a keyword that he defined.";
        "Richard Stallman doesn't need a qwerty/dvorak keyboard only two buttons \"1\" and \"0\" and his erect penis.";
        "On the first day Richard Stallman said M-x create-light.";
        "Richard Stallman once went out of scope for a while. The garbage collector never dared to touch him.";
-       "Richard Stallman does not compile; he closes his eyes, and see energy lines created between bit blocks by the compiler optimizations...";
-       "intx80 first calls Richard Stallman before calling sys_call";
+       "Richard Stallman does not compile; he closes his eyes, and see energy lines created between bit blocks by the compiler optimizations.";
+       "intx80 first calls Richard Stallman before calling sys_call.";
        "Tron is actually a biographical story about Richard Stallman. The director decided to tone it down or audiences wouldn't find it believable.";
        "Richard Stallman always wears a red shirt to make sure that whatever attacks his away-team has to go through him first.";
        "kill -9 invokes Richard Stallman's rage against a process.";
        "If Richard were to stumble upon stallmanfacts.com, he would find it a gnuisance.";
        "Richard Stallman can telnet into Mordor.";
        "sudo chown Richard:Stallman /all/your/base";
        "Richard Stallman's nervous system is completely wireless.";
        "Richard Stallman does not sleep. He yields.";
        "Some people say M-x psychoanalyse-pinhead is a merely a program. Others say M-x psychoanalyse-pinhead *is* Richard Stallman. All I know is, Richard Stallman is The Stig.";
        "If you execute Emacs backward it either undoes the industrial revolution or induces the rapture. But only Richard Stallman knows which.";
        "If Richard Stallman's beard were ever trimmed, the clippings would re-marshal into an exact copy of Richard Stallman.";
        "Richard Stallman never sleeps because he altered his own source to gain background garbage collection.";
        "Richard Stallman's doctor can retrieve a blood sample via CVS.";
-       "Richard Stallman can touch this";
+       "Richard Stallman can touch this.";
        "Because Richard Stallman's DNA is licensed under the FDL, his doctor can't draw his blood without violating HIPAA.";
-       "Richard Stallman can remove his own appendix, using only gdb.";
+       "Richard Stallman can remove his own appendix, using only GDB.";
        "Richard Stallman's DNA includes debugging symbols. But he doesn't need them.";
        "Richard Stallman met Chuck Norris once. Chuck tried a roundhouse, but Richard bashed him in the skull.";
-       "Richard Stallman doesn't need to buy a bigger hard drive. He can compress data infinitely. ";
+       "Richard Stallman doesn't need to buy a bigger hard drive. He can compress data infinitely.";
        "When Richard Stallman cannot take your call, his beard answers the phone for you.";
        "The R in RMS stands for RMS.";
        "Richard Stallman can parse HTML with regular expressions.";
        "Richard Stallman's traceroute goes all the way through an infinite number of anonymous proxies back to the traffic's source.";
        "Richard Stallman's beard is in fact not a just a beard, but a microprinted hard copy of Emacs source code. New patches must be checked against new hair growth before being approved.";
        "In the beginning-of-buffer there was Richard Stallman.";
        "The NOOP was created to give Richard Stallman some time to comb his beard.";
        "Whenever Richard Stallman looks at a Windows computer, it segfaults. Whenever Richard Stallman doesn't look at a Windows computer, it segfaults.";
        "Richard Stallman can walk on Windows!";
        "After being unable to satisfy my wife for years, Richard Stallman was able to single-handedly unlock her orgasm within seconds and managed to write a texinfo manual minutes later for other users.";
        "Richard Stallman's tabbed browser is a set to wget/telnet fg/bg processes.";
        "There is no chin under Richard Stallman' beard. There's only another beard. Recursively.";
-       "Stallman can chown anything! stallman@stallman~$ chown stallman:stallman Earth (for example)";
+       "Richard Stallman can chown anything! stallman@stallman~$ chown stallman:stallman Earth (for example)";
        "Richard Stallman freed his beard so he can always check what's in it.";
        "In the beginning was the Word, and the Word was with RMS, and the Word was GNU.";
        "RMS means \"RMS means Stallman\"";
        "Richard Stallman is the babelfish of his own speeches.";
        "Richard Stallman wrote his own library and lives in it.";
        "Richard Stallman found Waldo using grep in /dev/null";
-       "Richard Stallman doesn't sleep; he is compiling";
+       "Richard Stallman doesn't sleep; he is compiling.";
        "Richard Stallman will get Coca Cola to release their recipe under the GPL.";
        "Richard Stallman doesn't change clothes. He makes case mods.";
        "Richard Stallman compiled the first version of gcc with an hexadecimal editor.";
-       "Richard Stallman will be the last guest on Linux Outlaws";
+       "Richard Stallman will be the last guest on Linux Outlaws.";
        "Richard Stallman calculates the universe's entropy by exploiting forced stack overflows.";
        "Richard Stallman's consciousness will one day become the singularity, which will create Deep Thought, and answer the meaning of life, the universe and everything.";
        "C is actually written in RMS.";
        "Richard Stallman can write software that does not have a buffer overflow when counting money lost by Jerome Kerviel.";
        "There were no double rainbows before Richard Stallman.";
-       "Chuck Norris had to shorten his beard in the presence of Stallman because two beards that awsome, so close would segfault the universe (again).";
+       "Chuck Norris had to shorten his beard in the presence of Richard Stallman because two beards that awsome, so close would segfault the universe (again).";
        "RMS is Titanic.";
        "Richard Stallman is the answer to the Turing Test.";
        "Richard Stallman's beard makes ads for Gillette and Braun appear.";
        "for i = 1 to Stallman will never stop.";
        "\"RMS\" stands for \"RMS Makes Software\"";
        "Whenever someone writes a \"Hello, world\" program, Richard Stallman says \"Hello\" back.";
        "Richard Stallman wasn't born. He was compiled from source.";
        "Richard Stallman has a URL tatooed on the left side of his chest where you can download his genetic code.";
        "The GNU command line idiom that Richard Stallman never needs: \"date | more\"";
        "Richard Stallman's toe cheese is aged to perfection.";
        "Richard Stallman doesn't always run an OS kernel, but when he does he prefers GNU/Hurd. He is... the most interesting hacker in the world. Stay free, my friends.";
        "When Richard Stallman gets hungry, he just picks debris from his foot and eats it.";
        "Richard Stallman can GPL your code just by looking at it funny.";
-       "Richard Mathew Stallman loves birds. Birds make auricular love to Richard Mathew Stallman.";
+       "Richard Stallman loves birds. Birds make auricular love to Richard Stallman.";
        "Richard Stallman is so free that the primitive recursive function for computing his liberty causes a stack overflow.";
        "GNU Hurd is taking more than twenty years to develop because Richard Stallman is using a programming language comprised entirely of different lengths of time.";
        "Richard Stallman's beard contains Richard Stallman, whose beard contains Richard Stallman....";
-       "Richard Stallman had a Google Plus account in 2010.";
-       "sudo chown rms:gnu ~/base -R";
+       "Richard Stallman could have had a Google Plus account in 2010. Too bad he didn't want it.";
        "Richard Stallman pipes the Emacs binaries to /dev/dsp before he goes to sleep.";
        "When Richard Stallman counted his fingers as a kid, he always started with 0.";
        "When Richard Stallman's computer gets a virus, he simply applies a GPL license to it which converts the whole botnet to Linux. I mean, GNU/Linux.";
        "Richard Stallman's beard trimmings can cure cancer. Too bad he never shaves.";
-       "Richard Stallman's doesn't kill a process, he just dares it to stay running.";
-       "Richard Stallman exists because he compiled himself into being. ";
+       "Richard Stallman's doesn't kill a process; he just dares it to stay running.";
+       "Richard Stallman exists because he compiled himself into being.";
        "Richard Stallman's first words were in binary. When they couldn't understand him, he wrote a parser.";
        "Richard Stallman doesn't need any codecs, he just opens a multimedia file with Emacs, and reads the bytes of the file as plain text. He then performs all the necessary decoding in his mind. But he refuses to decode files encrypted with DRM, although his mind is able to.";
        };
 
   w = wisdom{randi([1, numel(wisdom)])};
   if nargout > 0
     f = w;
   else
diff --git a/scripts/miscellaneous/fileparts.m b/scripts/miscellaneous/fileparts.m
--- a/scripts/miscellaneous/fileparts.m
+++ b/scripts/miscellaneous/fileparts.m
@@ -54,16 +54,17 @@ function [directory, name, extension, ve
       error ("fileparts: expecting FILENAME argument to be a string");
     endif
   else
     print_usage ();
   endif
 
 endfunction
 
+
 %!test
 %! [d, n, e] = fileparts ("file");
 %! assert (strcmp (d, "") && strcmp (n, "file") && strcmp (e, ""));
 
 %!test
 %! [d, n, e] = fileparts ("file.ext");
 %! assert (strcmp (d, "") && strcmp (n, "file") && strcmp (e, ".ext"));
 
@@ -89,8 +90,9 @@ endfunction
 
 %!test
 %! [d, n, e] = fileparts ("/.ext");
 %! assert (strcmp (d, "/") && strcmp (n, char (zeros (1, 0))) && strcmp (e, ".ext"));
 
 %!test
 %! [d, n, e] = fileparts (".ext");
 %! assert (strcmp (d, "") && strcmp (n, char (zeros (1, 0))) && strcmp (e, ".ext"));
+
diff --git a/scripts/miscellaneous/fullfile.m b/scripts/miscellaneous/fullfile.m
--- a/scripts/miscellaneous/fullfile.m
+++ b/scripts/miscellaneous/fullfile.m
@@ -48,16 +48,17 @@ function filename = fullfile (varargin)
       filename = "";
     endif
   else
     print_usage ();
   endif
 
 endfunction
 
+
 %!shared fs, fsx, xfs, fsxfs, xfsy
 %! fs = filesep ();
 %! fsx = cstrcat (fs, "x");
 %! xfs = cstrcat ("x", fs);
 %! fsxfs = cstrcat (fs, "x", fs);
 %! xfsy = cstrcat ("x", fs, "y");
 %!assert (fullfile (""), "")
 %!assert (fullfile (fs), fs)
@@ -73,8 +74,9 @@ endfunction
 %!assert (fullfile ("x", "", "y", ""), xfsy)
 %!assert (fullfile ("", "x", "", "y", ""), xfsy)
 %!assert (fullfile (fs), fs)
 %!assert (fullfile (fs, fs), fs)
 %!assert (fullfile (fs, "x"), fsx)
 %!assert (fullfile (fs, xfs), fsxfs)
 %!assert (fullfile (fsx, fs), fsxfs)
 %!assert (fullfile (fs, "x", fs), fsxfs)
+
diff --git a/scripts/miscellaneous/getfield.m b/scripts/miscellaneous/getfield.m
--- a/scripts/miscellaneous/getfield.m
+++ b/scripts/miscellaneous/getfield.m
@@ -20,28 +20,28 @@
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{v1}, @dots{}] =} getfield (@var{s}, @var{key}, @dots{})
 ## Extract a field from a structure (or a nested structure).  For example:
 ##
 ## @example
 ## @group
 ## ss(1,2).fd(3).b = 5;
 ## getfield (ss, @{1,2@}, "fd", @{3@}, "b")
-##      @result{} ans = 5
+##    @result{} 5
 ## @end group
 ## @end example
 ##
 ## Note that the function call in the previous example is equivalent to
 ## the expression
 ##
 ## @example
 ## @group
 ## i1 = @{1,2@}; i2 = "fd"; i3 = @{3@}; i4= "b";
 ## ss(i1@{:@}).(i2)(i3@{:@}).(i4)
-##      @result{} ans = 5
+##    @result{} 5
 ##
 ## @end group
 ## @end example
 ## @seealso{setfield, rmfield, isfield, isstruct, fieldnames, struct}
 ## @end deftypefn
 
 ## Author: Etienne Grossmann <etienne@cs.uky.edu>
 
@@ -55,14 +55,16 @@ function obj = getfield (s, varargin)
   if (all (flds | idxs))
     typs = merge (flds, {"."}, {"()"});
     obj = subsref (s, struct ("type", typs, "subs", subs));
   else
     error ("getfield: invalid index");
   endif
 endfunction
 
+
 %!test
 %! x.a = "hello";
-%! assert(getfield(x,"a"),"hello");
+%! assert (getfield (x, "a"), "hello");
 %!test
 %! ss(1,2).fd(3).b = 5;
-%! assert(getfield(ss,{1,2},'fd',{3},'b'),5)
+%! assert (getfield (ss,{1,2},"fd",{3},"b"), 5);
+
diff --git a/scripts/miscellaneous/gzip.m b/scripts/miscellaneous/gzip.m
--- a/scripts/miscellaneous/gzip.m
+++ b/scripts/miscellaneous/gzip.m
@@ -15,17 +15,17 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{entries} =} gzip (@var{files})
 ## @deftypefnx {Function File} {@var{entries} =} gzip (@var{files}, @var{outdir})
 ## Compress the list of files and/or directories specified in @var{files}.
-## Each file is compressed separately and a new file with a '.gz' extension
+## Each file is compressed separately and a new file with a ".gz" extension
 ## is created.  The original files are not modified.  Existing compressed
 ## files are silently overwritten.  If @var{outdir} is defined the compressed
 ## files are placed in this directory.
 ## @seealso{gunzip, bzip2, zip, tar}
 ## @end deftypefn
 
 function entries = gzip (varargin)
   if (nargin != 1 && nargin != 2) || (nargout > 1)
@@ -35,38 +35,41 @@ function entries = gzip (varargin)
   if (nargout == 0)
     __xzip__ ("gzip", "gz", "gzip -r %s", varargin{:});
   else
     entries = __xzip__ ("gzip", "gz", "gzip -r %s", varargin{:});
   endif
 
 endfunction
 
-%!error <Invalid call to gzip.  Correct usage is> gzip("1", "2", "3");
-%!error <Invalid call to gzip.  Correct usage is> gzip();
-%!error <output directory does not exist> gzip("1", tmpnam);
-%!error <FILES must be a character array or cellstr> gzip(1);
+
 %!xtest
-%!  # test gzip together with gunzip
-%!  unwind_protect
-%!    filename = tmpnam;
-%!    dummy    = 1;
-%!    save(filename, "dummy");
-%!    dirname  = tmpnam;
-%!    mkdir(dirname);
-%!    entry = gzip(filename, dirname);
-%!    [path, basename, extension] = fileparts(filename);
-%!    if ! strcmp(entry, [dirname, filesep, basename, extension, ".gz"])
-%!      error("gzipped file does not match expected name!");
-%!    endif
-%!    if ! exist(entry, "file")
-%!      error("gzipped file cannot be found!");
-%!    endif
-%!    gunzip(entry);
-%!    if (system(sprintf("diff %s %s%c%s%s", filename, dirname, filesep,
-%!                                          basename, extension)))
-%!      error("unzipped file not equal to original file!");
-%!    end
-%!  unwind_protect_cleanup
-%!    delete(filename);
-%!    delete([dirname, filesep, basename, extension]);
-%!    rmdir(dirname);
-%!  end_unwind_protect
+%! # test gzip together with gunzip
+%! unwind_protect
+%!   filename = tmpnam;
+%!   dummy    = 1;
+%!   save (filename, "dummy");
+%!   dirname  = tmpnam;
+%!   mkdir (dirname);
+%!   entry = gzip (filename, dirname);
+%!   [path, basename, extension] = fileparts (filename);
+%!   if ! strcmp (entry, [dirname, filesep, basename, extension, ".gz"])
+%!     error ("gzipped file does not match expected name!");
+%!   endif
+%!   if ! exist (entry, "file")
+%!     error ("gzipped file cannot be found!");
+%!   endif
+%!   gunzip (entry);
+%!   if (system (sprintf ("diff %s %s%c%s%s", filename, dirname, filesep,
+%!                                            basename, extension)))
+%!     error ("unzipped file not equal to original file!");
+%!   end
+%! unwind_protect_cleanup
+%!   delete (filename);
+%!   delete ([dirname, filesep, basename, extension]);
+%!   rmdir (dirname);
+%! end_unwind_protect
+
+%!error gzip ()
+%!error gzip ("1", "2", "3")
+%!error <output directory does not exist> gzip ("1", tmpnam)
+%!error <FILES must be a character array or cellstr> gzip (1)
+
diff --git a/scripts/miscellaneous/info.m b/scripts/miscellaneous/info.m
--- a/scripts/miscellaneous/info.m
+++ b/scripts/miscellaneous/info.m
@@ -39,10 +39,12 @@ function info ()
 \n\
   Report bugs to the bug tracker at\n\
   http://bugs.octave.org\n\
   But first, please read the guidelines to writing a helpful report at\n\
   http://www.octave.org/bugs.html\n");
 
 endfunction
 
+
 ## Mark file as being tested.  No real test needed for this function.
 %! assert (1)
+
diff --git a/scripts/miscellaneous/inputname.m b/scripts/miscellaneous/inputname.m
--- a/scripts/miscellaneous/inputname.m
+++ b/scripts/miscellaneous/inputname.m
@@ -35,22 +35,25 @@ function s = inputname (n)
       s = "";
     endif
   else
     print_usage ();
   endif
 
 endfunction
 
+
 ## Warning: heap big magic in the following tests!!!
 ## The test function builds a private context for each
 ## test, with only the specified values shared between
 ## them.  It does this using the following template:
 ##
 ##     function [<shared>] = testfn(<shared>)
 ##        <test>
 ##
 ## To test inputname, I need a function context invoked
 ## with known parameter names.  So define a couple of
 ## shared parameters, et voila!, the test is trivial.
-%!shared hello,worldly
-%!assert(inputname(1),'hello');
-%!assert(inputname(2),'worldly');
+  
+%!shared hello, worldly
+%!assert (inputname (1), "hello")
+%!assert (inputname (2), "worldly")
+
diff --git a/scripts/miscellaneous/isappdata.m b/scripts/miscellaneous/isappdata.m
--- a/scripts/miscellaneous/isappdata.m
+++ b/scripts/miscellaneous/isappdata.m
@@ -36,13 +36,14 @@ function res = isappdata (h, name)
       res(nh) = true;
     else
       res(nh) = false;
     endif
   endfor
 
 endfunction
 
+
 %!test
-%! setappdata (0, "hello", "world")
-%! assert (isappdata (0, "hello"), true)
-%!assert (isappdata (0, "foobar"), false)
+%! setappdata (0, "hello", "world");
+%! assert (isappdata (0, "hello"), true);
+%! assert (isappdata (0, "foobar"), false);
 
diff --git a/scripts/miscellaneous/isdeployed.m b/scripts/miscellaneous/isdeployed.m
--- a/scripts/miscellaneous/isdeployed.m
+++ b/scripts/miscellaneous/isdeployed.m
@@ -23,9 +23,10 @@
 ## the Octave interpreter.  Currently, this function always returns
 ## false in Octave.
 ## @end deftypefn
 
 function retval = isdeployed ()
   retval = false;
 endfunction
 
+
 %!assert (isdeployed (), false)
diff --git a/scripts/miscellaneous/ismac.m b/scripts/miscellaneous/ismac.m
--- a/scripts/miscellaneous/ismac.m
+++ b/scripts/miscellaneous/ismac.m
@@ -27,10 +27,12 @@ function retval = ismac ()
   if (nargin == 0)
     retval = octave_config_info ("mac");
   else
     print_usage ();
   endif
 
 endfunction
 
-%!error ismac (1);
-%!assert (islogical (ismac ()));
+
+%!assert (islogical (ismac ()))
+
+%!error ismac (1)
diff --git a/scripts/miscellaneous/ispc.m b/scripts/miscellaneous/ispc.m
--- a/scripts/miscellaneous/ispc.m
+++ b/scripts/miscellaneous/ispc.m
@@ -27,10 +27,13 @@ function retval = ispc ()
   if (nargin == 0)
     retval = octave_config_info ("windows");
   else
     print_usage ();
   endif
 
 endfunction
 
-%!error ispc (1);
-%!assert (islogical (ispc ()));
+
+%!assert (islogical (ispc ()))
+
+%!error ispc (1)
+
diff --git a/scripts/miscellaneous/isunix.m b/scripts/miscellaneous/isunix.m
--- a/scripts/miscellaneous/isunix.m
+++ b/scripts/miscellaneous/isunix.m
@@ -27,10 +27,13 @@ function retval = isunix ()
   if (nargin == 0)
     retval = octave_config_info ("unix");
   else
     print_usage ();
   endif
 
 endfunction
 
-%!error isunix (1);
-%!assert (islogical (isunix ()));
+
+%!assert (islogical (isunix ()))
+
+%!error isunix (1)
+
diff --git a/scripts/miscellaneous/list_primes.m b/scripts/miscellaneous/list_primes.m
--- a/scripts/miscellaneous/list_primes.m
+++ b/scripts/miscellaneous/list_primes.m
@@ -79,13 +79,13 @@ function retval = list_primes (n)
       n--;
     endif
     p = p + 2;
 
   endwhile
 
 endfunction
 
-%!test
-%! assert (list_primes(), [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41,\
-%!                        43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]);
-%! assert (list_primes(5), [2, 3, 5, 7, 11]);
 
+%!assert (list_primes (), [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, ...
+%!                         43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97])
+%!assert (list_primes (5), [2, 3, 5, 7, 11]);
+
diff --git a/scripts/miscellaneous/ls.m b/scripts/miscellaneous/ls.m
--- a/scripts/miscellaneous/ls.m
+++ b/scripts/miscellaneous/ls.m
@@ -85,10 +85,10 @@ function retval = ls (varargin)
 endfunction
 
 
 %!test
 %! list = ls ();
 %! assert (ischar (list));
 %! assert (! isempty (list));
 
-%!error ls (1);
+%!error ls (1)
 
diff --git a/scripts/miscellaneous/mexext.m b/scripts/miscellaneous/mexext.m
--- a/scripts/miscellaneous/mexext.m
+++ b/scripts/miscellaneous/mexext.m
@@ -21,9 +21,10 @@
 ## Return the filename extension used for MEX files.
 ## @seealso{mex}
 ## @end deftypefn
 
 function retval = mexext ()
   retval = "mex";
 endfunction
 
+
 %!assert (mexext (), "mex")
diff --git a/scripts/miscellaneous/mkoctfile.m b/scripts/miscellaneous/mkoctfile.m
--- a/scripts/miscellaneous/mkoctfile.m
+++ b/scripts/miscellaneous/mkoctfile.m
@@ -12,17 +12,17 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Command} {} mkoctfile [-options] file @dots{}
+## @deftypefn  {Command} {} mkoctfile [-options] file @dots{}
 ## @deftypefnx {Function File} {[@var{output}, @var{status} =} mkoctfile (@dots{})
 ##
 ## The @code{mkoctfile} function compiles source code written in C,
 ## C++, or Fortran.  Depending on the options used with @code{mkoctfile}, the
 ## compiled code can be called within Octave or can be used as a stand-alone
 ## application.
 ##
 ## @code{mkoctfile} can be called from the shell prompt or from the Octave
@@ -119,26 +119,26 @@
 ## @itemx --verbose
 ## Echo commands as they are executed.
 ##
 ## @item file
 ## The file to compile or link.  Recognized file types are
 ##
 ## @example
 ## @group
-##                   .c    C source
-##                   .cc   C++ source
-##                   .C    C++ source
-##                   .cpp  C++ source
-##                   .f    Fortran source (fixed form)
-##                   .F    Fortran source (fixed form)
-##                   .f90  Fortran source (free form)
-##                   .F90  Fortran source (free form)
-##                   .o    object file
-##                   .a    library file
+##    .c    C source
+##    .cc   C++ source
+##    .C    C++ source
+##    .cpp  C++ source
+##    .f    Fortran source (fixed form)
+##    .F    Fortran source (fixed form)
+##    .f90  Fortran source (free form)
+##    .F90  Fortran source (free form)
+##    .o    object file
+##    .a    library file
 ## @end group
 ## @end example
 ##
 ## @end table
 ## @end deftypefn
 
 function [output, status] = mkoctfile (varargin)
 
diff --git a/scripts/miscellaneous/namelengthmax.m b/scripts/miscellaneous/namelengthmax.m
--- a/scripts/miscellaneous/namelengthmax.m
+++ b/scripts/miscellaneous/namelengthmax.m
@@ -26,9 +26,9 @@
 ## format will have their names truncated to this length.
 ## @end deftypefn
 
 function n = namelengthmax ()
   n = 63;
 endfunction
 
 
-%!assert (namelengthmax, 63)
+%!assert (namelengthmax (), 63)
diff --git a/scripts/miscellaneous/news.m b/scripts/miscellaneous/news.m
--- a/scripts/miscellaneous/news.m
+++ b/scripts/miscellaneous/news.m
@@ -63,8 +63,9 @@ function news (package = "octave")
   fclose (fid);
 
 endfunction
 
 
 %!error news (1, 2)
 %!error <PACKAGE must be a string> news (1)
 %!error <Package .* is not installed> news ("__NOT_A_VALID_PKG_NAME__")
+
diff --git a/scripts/miscellaneous/orderfields.m b/scripts/miscellaneous/orderfields.m
--- a/scripts/miscellaneous/orderfields.m
+++ b/scripts/miscellaneous/orderfields.m
@@ -33,59 +33,60 @@
 ## vector
 ## which converts the original name order into the new name order.
 ##
 ## Examples:
 ##
 ## @example
 ## @group
 ## s = struct("d", 4, "b", 2, "a", 1, "c", 3);
-## t1 = orderfields(s)
+## t1 = orderfields (s)
 ##      @result{} t1 =
 ##         @{
 ##           a =  1
 ##           b =  2
 ##           c =  3
 ##           d =  4
 ##         @}
 ## @end group
 ## @group
 ## t = struct("d", @{@}, "c", @{@}, "b", "a", @{@});
-## t2 = orderfields(s, t)
+## t2 = orderfields (s, t)
 ##      @result{} t2 =
 ##         @{
 ##           d =  4
 ##           c =  3
 ##           b =  2
 ##           a =  1
 ##         @}
 ## @end group
 ## @group
-## t3 = orderfields(s, [3, 2, 4, 1]);
+## t3 = orderfields (s, [3, 2, 4, 1]);
 ##      @result{} t3 =
 ##         @{
 ##           a =  1
 ##           b =  2
 ##           c =  3
 ##           d =  4
 ##         @}
 ## @end group
 ## @group
-## [t4, p] = orderfields(s, @{"d", "c", "b", "a"@})
-##      @result{} t4 = @{
+## [t4, p] = orderfields (s, @{"d", "c", "b", "a"@})
+##      @result{} t4 =
+##         @{
 ##           d =  4
 ##           c =  3
 ##           b =  2
 ##           a =  1
 ##         @}
-##      p =
-##         1
-##         4
-##         2
-##         3
+##         p =
+##            1
+##            4
+##            2
+##            3
 ## @end group
 ## @end example
 ##
 ## @seealso{getfield, rmfield, isfield, isstruct, fieldnames, struct}
 ## @end deftypefn
 
 ## Author: Paul Kienzle <pkienzle@users.sf.net>
 ## Adapted-By: jwe
@@ -156,39 +157,41 @@ function [t, p] = orderfields (s1, s2)
       [t(1:n).(el)] = s1(:).(el);
     endfor
     ## inherit dimensions
     t = reshape (t, size (s1));
   endif
 
 endfunction
 
+
 %!shared a, b, c
 %! a = struct ("foo", {1, 2}, "bar", {3, 4});
 %! b = struct ("bar", 6, "foo", 5);
 %! c = struct ("bar", {7, 8}, "foo", 9);
 %!test
 %! a(2) = orderfields (b, a);
-%! assert (a(2).foo, 5)
-%! assert (a(2).bar, 6)
+%! assert (a(2).foo, 5);
+%! assert (a(2).bar, 6);
 %!test
 %! [a(2), p] = orderfields (b, [2 1]);
-%! assert (a(2).foo, 5)
-%! assert (a(2).bar, 6)
+%! assert (a(2).foo, 5);
+%! assert (a(2).bar, 6);
 %! assert (p, [2; 1]);
 %!test
 %! a(2) = orderfields (b, fieldnames (a));
-%! assert (a(2).foo, 5)
-%! assert (a(2).bar, 6)
+%! assert (a(2).foo, 5);
+%! assert (a(2).bar, 6);
 %!test
 %! a(1:2) = orderfields (c, fieldnames (a));
-%! assert (a(2).foo, 9)
-%! assert (a(2).bar, 8)
+%! assert (a(2).foo, 9);
+%! assert (a(2).bar, 8);
 
 %!test
 %! aa.x = {1, 2};
 %! aa.y = 3;
 %! aa(2).x = {4, 5};
 %! bb.y = {6, 7};
 %! bb.x = 8;
 %! aa(2) = orderfields (bb, aa);
 %! assert (aa(2).x, 8);
 %! assert (aa(2).y{1}, 6);
+
diff --git a/scripts/miscellaneous/paren.m b/scripts/miscellaneous/paren.m
--- a/scripts/miscellaneous/paren.m
+++ b/scripts/miscellaneous/paren.m
@@ -17,11 +17,12 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Operator} {} (
 ## @deftypefnx {Operator} {} )
 ## Array index or function argument delimeter.
 ## @end deftypefn
 
+
 ## Mark file as being tested.  No real test needed for a documentation .m file
 %!assert (1)
 
diff --git a/scripts/miscellaneous/parseparams.m b/scripts/miscellaneous/parseparams.m
--- a/scripts/miscellaneous/parseparams.m
+++ b/scripts/miscellaneous/parseparams.m
@@ -35,17 +35,17 @@
 ## prop =
 ## @{
 ##   [1,1] = linewidth
 ##   [1,2] = 10
 ## @}
 ## @end group
 ## @end example
 ##
-## The parseparams function may be used to separate 'regular'
+## The parseparams function may be used to separate "regular"
 ## arguments and additional arguments given as property/value pairs of
 ## the @var{varargin} cell array.
 ##
 ## In the second form of the call, available options are specified directly
 ## with their default values given as name-value pairs.
 ## If @var{params} do not form name-value pairs, or if an option occurs
 ## that does not match any of the available options, an error occurs.
 ## When called from an m-file function, the error is prefixed with the
diff --git a/scripts/miscellaneous/recycle.m b/scripts/miscellaneous/recycle.m
--- a/scripts/miscellaneous/recycle.m
+++ b/scripts/miscellaneous/recycle.m
@@ -46,21 +46,23 @@ function retval = recycle (state)
       if (strcmpi (state, "on"))
         error ("recycle: recycling files is not implemented");
       elseif (strcmpi (state, "off"))
         current_state = "off";
       else
         error ("recycle: invalid value of STATE = `%s'", state);
       endif
     else
-      error ("recycle: expecting STATE to be a character string");
+      error ("recycle: STATE must be a character string");
     endif
   endif
 
 endfunction
 
-%!error recycle ("on");
-%!error recycle ("on", "and I mean it");
-%!error recycle (1);
 
 %!test
 %! recycle ("off");
 %! assert (recycle ("off"), "off");
+
+%!error <recycling files is not implemented> recycle ("on")
+%!error recycle ("on", "and I mean it")
+%!error <STATE must be a character string> recycle (1)
+
diff --git a/scripts/miscellaneous/rmappdata.m b/scripts/miscellaneous/rmappdata.m
--- a/scripts/miscellaneous/rmappdata.m
+++ b/scripts/miscellaneous/rmappdata.m
@@ -32,13 +32,14 @@ function rmappdata (h, varargin)
   for nh = 1:numel(h)
     appdata = get (h(nh), "__appdata__");
     appdata = rmfield (appdata, varargin);
     set (h(nh), "__appdata__", appdata);
   endfor
 
 endfunction
 
+
 %!test
-%! setappdata (0, "hello", "world")
-%! rmappdata (0, "hello")
-%! assert (isappdata (0, "hello"), false)
+%! setappdata (0, "hello", "world");
+%! rmappdata (0, "hello");
+%! assert (isappdata (0, "hello"), false);
 
diff --git a/scripts/miscellaneous/semicolon.m b/scripts/miscellaneous/semicolon.m
--- a/scripts/miscellaneous/semicolon.m
+++ b/scripts/miscellaneous/semicolon.m
@@ -17,11 +17,12 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Operator} {} ;
 ## Array row or command separator.
 ## @seealso{comma}
 ## @end deftypefn
 
+
 ## Mark file as being tested.  No real test needed for a documentation .m file
 %!assert (1)
 
diff --git a/scripts/miscellaneous/setappdata.m b/scripts/miscellaneous/setappdata.m
--- a/scripts/miscellaneous/setappdata.m
+++ b/scripts/miscellaneous/setappdata.m
@@ -47,13 +47,14 @@ function setappdata (h, varargin)
         error ("setappdata: invalid input");
       endif
     endfor
     set (h(nh), "__appdata__", appdata);
   endfor
 
 endfunction
 
+
 %!test
-%! setappdata (0, "hello", "world")
-%! assert (isappdata (0, "hello"), true)
-%!assert (getappdata (0, "hello"), "world")
+%! setappdata (0, "hello", "world");
+%! assert (isappdata (0, "hello"), true);
+%! assert (getappdata (0, "hello"), "world");
 
diff --git a/scripts/miscellaneous/setfield.m b/scripts/miscellaneous/setfield.m
--- a/scripts/miscellaneous/setfield.m
+++ b/scripts/miscellaneous/setfield.m
@@ -55,17 +55,19 @@ function obj = setfield (obj, varargin)
   if (all (flds | idxs))
     typs = merge (flds, {"."}, {"()"});
     obj = subsasgn (obj, struct ("type", typs, "subs", subs), rhs);
   else
     error ("setfield: invalid index");
   endif
 endfunction
 
+
 %!test
 %! x.a = "hello";
-%! x = setfield(x,"b","world");
-%! y = struct("a","hello","b","world");
-%! assert(x,y);
+%! x = setfield (x, "b", "world");
+%! y = struct ("a", "hello", "b", "world");
+%! assert (x,y);
 %!test
-%! oo(1,1).f0= 1;
-%! oo = setfield(oo,{1,2},"fd",{3},"b", 6);
-%! assert (oo(1,2).fd(3).b, 6)
+%! oo(1,1).f0 = 1;
+%! oo = setfield (oo,{1,2},"fd",{3},"b", 6);
+%! assert (oo(1,2).fd(3).b, 6);
+
diff --git a/scripts/miscellaneous/substruct.m b/scripts/miscellaneous/substruct.m
--- a/scripts/miscellaneous/substruct.m
+++ b/scripts/miscellaneous/substruct.m
@@ -19,31 +19,30 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} substruct (@var{type}, @var{subs}, @dots{})
 ## Create a subscript structure for use with @code{subsref} or
 ## @code{subsasgn}.  For example:
 ##
 ## @example
 ## @group
-## idx = substruct("()", @{3, ":"@})
+## idx = substruct ("()", @{3, ":"@})
 ##      @result{}
 ##        idx =
 ##        @{
 ##          type = ()
 ##          subs =
 ##          @{
 ##            [1,1] =  3
 ##            [1,2] = :
 ##          @}
 ##        @}
 ## x = [1, 2, 3; 4, 5, 6; 7, 8, 9];
-## subsref(x, idx)
-##      @result{} ans =
-##         7  8  9
+## subsref (x, idx)
+##    @result{} 7  8  9
 ## @end group
 ## @end example
 ## @seealso{subsref, subsasgn}
 ## @end deftypefn
 
 ## Author:  jwe
 
 function retval = substruct (varargin)
@@ -69,22 +68,25 @@ function retval = substruct (varargin)
 
     retval = struct ("type", typ, "subs", sub);
   else
     print_usage ();
   endif
 
 endfunction
 
+
 %!test
 %! x(1,1).type = "()";
 %! x(1,2).type = "{}";
 %! x(1,3).type = ".";
 %! x(1,1).subs = {1,2,3};
 %! x(1,2).subs = {":"};
 %! x(1,3).subs = "foo";
 %! y = substruct ("()", {1,2,3}, "{}", {":"}, ".", "foo");
-%! assert(x,y);
-%!error assert(substruct);
-%!error assert(substruct (1, 2, 3));
-%!error assert(substruct ("x", 1));
-%!error assert(substruct ("()", [1,2,3]));
-%!error assert(substruct (".", {1,2,3}));
+%! assert (x,y);
+
+%!error substruct ()
+%!error substruct (1, 2, 3)
+%!error substruct ("x", 1)
+%!error substruct ("()", [1,2,3])
+%!error substruct (".", {1,2,3})
+
diff --git a/scripts/miscellaneous/symvar.m b/scripts/miscellaneous/symvar.m
--- a/scripts/miscellaneous/symvar.m
+++ b/scripts/miscellaneous/symvar.m
@@ -24,10 +24,12 @@
 ## found are returned in a cell array of strings.  If no variables are
 ## found then the returned cell array is empty.
 ## @end deftypefn
 
 function args = symvar (s)
   args = argnames (inline (s));
 endfunction
 
+
 ## This function is tested by the tests for argnames().
 %!assert (1)
+
diff --git a/scripts/miscellaneous/usejava.m b/scripts/miscellaneous/usejava.m
--- a/scripts/miscellaneous/usejava.m
+++ b/scripts/miscellaneous/usejava.m
@@ -1,9 +1,10 @@
 ## Copyright (C) 2012 Rik Wehbring
+## Parts Copyright (C) 2012 Philip Nienhuis <prnienhuis@users.sf.net>
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -13,17 +14,17 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} usejava (@var{feature})
-## Return true if the specific Sun Java element @var{feature} is available.
+## Return true if the Java element @var{feature} is available.
 ##
 ## Possible features are:
 ##
 ## @table @asis
 ## @item "awt"
 ## Abstract Window Toolkit for GUIs.
 ##
 ## @item "desktop"
@@ -31,37 +32,58 @@
 ##
 ## @item "jvm"
 ## Java Virtual Machine.
 ##
 ## @item "swing"
 ## Swing components for lightweight GUIs.
 ## @end table
 ##
-## This function is provided for compatibility with @sc{matlab} scripts which
-## may alter their behavior based on the availability of Java.  Octave does
-## not implement an interface to Java and this function always returns
-## @code{false}.
+## @code{usejava} determines if specific Java features are available in an
+## Octave session.  This function is provided for compatibility with scripts
+## which may alter their behavior based on the availability of Java.  The
+## feature "desktop" always returns @code{false} as Octave has no Java-based
+## desktop.  Other features may be available if the Octave-Forge Java package
+## has been installed.
 ## @end deftypefn
 
 function retval = usejava (feature)
 
   if (nargin != 1 || ! ischar (feature))
     print_usage ();
   endif
 
-  if (! any (strcmp (feature, {"awt", "desktop", "jvm", "swing"})))
-    error ("usejava: unrecognized feature '%s'", feature);
-  endif
+  retval = false;
 
-  retval = false;
+  switch feature
+    ## For each feature, try javamethods() on a Java class of a feature
+    case "awt"
+      try
+        dum = javamethods ("java.awt.Frame");
+        retval = true;
+      end_try_catch
+    case "desktop"
+      ## Octave has no Java based GUI/desktop, leave retval = false
+    case "jvm"
+      try
+        dum = javamethods ("java.lang.Runtime");
+        retval = true;
+      end_try_catch
+    case "swing"
+      try
+        dum = javamethods ("javax.swing.Popup");
+        retval = true;
+      end_try_catch
+    otherwise
+      error ("usejava: unrecognized feature '%s'", feature);
+  endswitch
 
 endfunction
 
 
-%!assert (usejava ("awt"), false)
+%!assert (usejava ("desktop"), false)
 
 %% Test input validation
 %!error usejava ()
 %!error usejava (1, 2)
 %!error usejava (1)
 %!error <unrecognized feature> usejava ("abc")
 
diff --git a/scripts/miscellaneous/ver.m b/scripts/miscellaneous/ver.m
--- a/scripts/miscellaneous/ver.m
+++ b/scripts/miscellaneous/ver.m
@@ -102,27 +102,28 @@ function varargout = ver (package = "")
       endfor
       ret = ret(n);
     endif
     varargout{1} = ret;
   endif
 
 endfunction
 
+
 %!test
 %! result = ver;
-%! assert (result(1).Name, "Octave")
-%! assert (result(1).Version, version)
+%! assert (result(1).Name, "Octave");
+%! assert (result(1).Version, version);
 %! result = ver ("octave");
-%! assert (result(1).Name, "Octave")
-%! assert (result(1).Version, version)
+%! assert (result(1).Name, "Octave");
+%! assert (result(1).Version, version);
 
 %!test
 %! lst = pkg ("list");
-%! for n=1:numel(lst)
+%! for n = 1:numel (lst)
 %!   expected = lst{n}.name;
 %!   result = ver (expected);
 %!   assert (result.Name, expected);
 %!   assert (isfield (result, "Version"), true);
 %!   assert (isfield (result, "Release"), true);
 %!   assert (isfield (result, "Date"), true);
 %! endfor
 
diff --git a/scripts/miscellaneous/version.m b/scripts/miscellaneous/version.m
--- a/scripts/miscellaneous/version.m
+++ b/scripts/miscellaneous/version.m
@@ -32,12 +32,14 @@ function vs = version ()
   if (nargin != 0)
     warning ("version: ignoring extra arguments");
   endif
 
   vs = OCTAVE_VERSION;
 
 endfunction
 
-%!assert(ischar (version ()) && strcmp (version (), OCTAVE_VERSION));
+
+%!assert (ischar (version ()))
+%!assert (version (), OCTAVE_VERSION)
 
 %!warning version (1);
 
diff --git a/scripts/miscellaneous/warning_ids.m b/scripts/miscellaneous/warning_ids.m
--- a/scripts/miscellaneous/warning_ids.m
+++ b/scripts/miscellaneous/warning_ids.m
@@ -13,16 +13,17 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @cindex warning ids
+##
 ## @table @code
 ## @item Octave:abbreviated-property-match
 ## By default, the @code{Octave:abbreviated-property-match} warning is enabled.
 ##
 ## @item Octave:array-to-scalar
 ## If the @code{Octave:array-to-scalar} warning is enabled, Octave will
 ## warn when an implicit conversion from an array to a scalar value is
 ## attempted.
@@ -60,17 +61,17 @@
 ## instead.
 ##
 ## There are times when it is useful to write code that contains
 ## assignments within the condition of a @code{while} or @code{if}
 ## statement.  For example, statements like
 ##
 ## @example
 ## @group
-## while (c = getc())
+## while (c = getc ())
 ##   @dots{}
 ## @end group
 ## @end example
 ##
 ## @noindent
 ## are common in C programming.
 ##
 ## It is possible to avoid all warnings about such statements by
@@ -88,17 +89,17 @@
 ## slip by.
 ##
 ## In such cases, it is possible suppress errors for specific statements by
 ## writing them with an extra set of parentheses.  For example, writing the
 ## previous example as
 ##
 ## @example
 ## @group
-## while ((c = getc()))
+## while ((c = getc ()))
 ##   @dots{}
 ## @end group
 ## @end example
 ##
 ## @noindent
 ## will prevent the warning from being printed for this statement, while
 ## allowing Octave to warn about other assignments used in conditional
 ## contexts.
@@ -208,17 +209,17 @@
 ## If the @code{Octave:num-to-str} warning is enable, a warning is
 ## printed for implicit conversions of numbers to their ASCII character
 ## equivalents when strings are constructed using a mixture of strings and
 ## numbers in matrix notation.  For example,
 ##
 ## @example
 ## @group
 ## [ "f", 111, 111 ]
-##      @result{} "foo"
+## @result{} "foo"
 ## @end group
 ## @end example
 ##
 ## @noindent
 ## elicits a warning if the @code{Octave:num-to-str} warning is
 ## enabled.  By default, the @code{Octave:num-to-str} warning is enabled.
 ##
 ## @item Octave:possible-matlab-short-circuit-operator
@@ -226,17 +227,17 @@
 ## is enabled, Octave will warn about using the not short circuiting
 ## operators @code{&} and @code{|} inside @code{if} or @code{while}
 ## conditions.  They normally never short circuit, but @sc{matlab} always
 ## short circuits if any logical operators are used in a condition.  You
 ## can turn on the option
 ##
 ## @example
 ## @group
-## do_braindead_shortcircuit_evaluation(1)
+## do_braindead_shortcircuit_evaluation (1)
 ## @end group
 ## @end example
 ##
 ## @noindent
 ## if you would like to enable this short-circuit evaluation in
 ## Octave.  Note that the @code{&&} and @code{||} operators always short
 ## circuit in both Octave and @sc{matlab}, so it's only necessary to
 ## enable @sc{matlab}-style short-circuiting it's too arduous to modify
@@ -290,17 +291,17 @@
 ## @item Octave:str-to-num
 ## If the @code{Octave:str-to-num} warning is enabled, a warning is printed
 ## for implicit conversions of strings to their numeric ASCII equivalents.
 ## For example,
 ##
 ## @example
 ## @group
 ## "abc" + 0
-##      @result{} 97 98 99
+## @result{} 97 98 99
 ## @end group
 ## @end example
 ##
 ## @noindent
 ## elicits a warning if the @code{Octave:str-to-num} warning is enabled.
 ## By default, the @code{Octave:str-to-num} warning is disabled.
 ##
 ## @item Octave:undefined-return-values
@@ -315,10 +316,12 @@
 ## expression.
 ## By default, the @code{Octave:variable-switch-label} warning is disabled.
 ## @end table
 
 function warning_ids ()
   help ("warning_ids");
 endfunction
 
+
 ## Remove from test statistics.  No real tests possible
 %!assert (1)
+
diff --git a/scripts/miscellaneous/xor.m b/scripts/miscellaneous/xor.m
--- a/scripts/miscellaneous/xor.m
+++ b/scripts/miscellaneous/xor.m
@@ -55,17 +55,17 @@ function z = xor (x, y)
       end_try_catch
     endif
   else
     print_usage ();
   endif
 
 endfunction
 
-%!assert((xor ([1, 1, 0, 0], [0, 1, 0, 1]) == [1, 0, 0, 1]
-%! && xor ([i, i, 0, 0], [1, 0, 1, 0]) == [0, 1, 1, 0]));
 
-%!assert(all (all (xor (eye (2), fliplr (eye (2))) == ones (2))));
+%!assert (xor ([1, 1, 0, 0], [0, 1, 0, 1]), logical ([1, 0, 0, 1]))
+%!assert (xor ([i, i, 0, 0], [1, 0, 1, 0]), logical ([0, 1, 1, 0]))
 
-%!error xor ();
+%!assert (xor (eye (2), fliplr (eye (2))), logical (ones (2)))
 
-%!error xor (1, 2, 3);
+%!error xor ()
+%!error xor (1, 2, 3)
 
diff --git a/scripts/optimization/fminbnd.m b/scripts/optimization/fminbnd.m
--- a/scripts/optimization/fminbnd.m
+++ b/scripts/optimization/fminbnd.m
@@ -200,14 +200,16 @@ function fx = guarded_eval (fun, x)
   fx = fx(1);
   if (! isreal (fx))
     error ("fminbnd:notreal", "fminbnd: non-real value encountered");
   elseif (isnan (fx))
     error ("fminbnd:isnan", "fminbnd: NaN value encountered");
   endif
 endfunction
 
+
 %!shared opt0
 %! opt0 = optimset ("tolx", 0);
-%!assert (fminbnd (@cos, pi/2, 3*pi/2, opt0), pi, 10*sqrt(eps))
-%!assert (fminbnd (@(x) (x - 1e-3)^4, -1, 1, opt0), 1e-3, 10e-3*sqrt(eps))
-%!assert (fminbnd (@(x) abs(x-1e7), 0, 1e10, opt0), 1e7, 10e7*sqrt(eps))
-%!assert (fminbnd (@(x) x^2 + sin(2*pi*x), 0.4, 1, opt0), fzero (@(x) 2*x + 2*pi*cos(2*pi*x), [0.4, 1], opt0), sqrt(eps))
+%!assert (fminbnd (@cos, pi/2, 3*pi/2, opt0), pi, 10*sqrt (eps))
+%!assert (fminbnd (@(x) (x - 1e-3)^4, -1, 1, opt0), 1e-3, 10e-3*sqrt (eps))
+%!assert (fminbnd (@(x) abs (x-1e7), 0, 1e10, opt0), 1e7, 10e7*sqrt (eps))
+%!assert (fminbnd (@(x) x^2 + sin (2*pi*x), 0.4, 1, opt0), fzero (@(x) 2*x + 2*pi*cos (2*pi*x), [0.4, 1], opt0), sqrt (eps))
+
diff --git a/scripts/optimization/fsolve.m b/scripts/optimization/fsolve.m
--- a/scripts/optimization/fsolve.m
+++ b/scripts/optimization/fsolve.m
@@ -460,24 +460,24 @@ function [fx, jx] = make_fcn_jac (x, fcn
   endif
 endfunction
 
 %!function retval = __f (p)
 %!  x = p(1);
 %!  y = p(2);
 %!  z = p(3);
 %!  retval = zeros (3, 1);
-%!  retval(1) = sin(x) + y**2 + log(z) - 7;
-%!  retval(2) = 3*x + 2**y -z**3 + 1;
+%!  retval(1) = sin (x) + y^2 + log (z) - 7;
+%!  retval(2) = 3*x + 2^y -z^3 + 1;
 %!  retval(3) = x + y + z - 5;
 %!endfunction
 %!test
 %! x_opt = [ 0.599054;
-%! 2.395931;
-%! 2.005014 ];
+%!           2.395931;
+%!           2.005014 ];
 %! tol = 1.0e-5;
 %! [x, fval, info] = fsolve (@__f, [ 0.5; 2.0; 2.5 ]);
 %! assert (info > 0);
 %! assert (norm (x - x_opt, Inf) < tol);
 %! assert (norm (fval) < tol);
 
 %!function retval = __f (p)
 %!  x = p(1);
@@ -486,56 +486,57 @@ endfunction
 %!  w = p(4);
 %!  retval = zeros (4, 1);
 %!  retval(1) = 3*x + 4*y + exp (z + w) - 1.007;
 %!  retval(2) = 6*x - 4*y + exp (3*z + w) - 11;
 %!  retval(3) = x^4 - 4*y^2 + 6*z - 8*w - 20;
 %!  retval(4) = x^2 + 2*y^3 + z - w - 4;
 %!endfunction
 %!test
-%! x_opt = [ -0.767297326653401, 0.590671081117440, 1.47190018629642, -1.52719341133957 ];
+%! x_opt = [ -0.767297326653401, 0.590671081117440, ...
+%!            1.47190018629642, -1.52719341133957 ];
 %! tol = 1.0e-5;
 %! [x, fval, info] = fsolve (@__f, [-1, 1, 2, -1]);
 %! assert (info > 0);
 %! assert (norm (x - x_opt, Inf) < tol);
 %! assert (norm (fval) < tol);
 
 %!function retval = __f (p)
 %!  x = p(1);
 %!  y = p(2);
 %!  z = p(3);
 %!  retval = zeros (3, 1);
-%!  retval(1) = sin(x) + y**2 + log(z) - 7;
-%!  retval(2) = 3*x + 2**y -z**3 + 1;
+%!  retval(1) = sin (x) + y^2 + log (z) - 7;
+%!  retval(2) = 3*x + 2^y -z^3 + 1;
 %!  retval(3) = x + y + z - 5;
-%!  retval(4) = x*x + y - z*log(z) - 1.36;
+%!  retval(4) = x*x + y - z*log (z) - 1.36;
 %!endfunction
 %!test
 %! x_opt = [ 0.599054;
-%! 2.395931;
-%! 2.005014 ];
+%!           2.395931;
+%!           2.005014 ];
 %! tol = 1.0e-5;
 %! [x, fval, info] = fsolve (@__f, [ 0.5; 2.0; 2.5 ]);
 %! assert (info > 0);
 %! assert (norm (x - x_opt, Inf) < tol);
 %! assert (norm (fval) < tol);
 
 %!function retval = __f (p)
 %!  x = p(1);
 %!  y = p(2);
 %!  z = p(3);
 %!  retval = zeros (3, 1);
-%!  retval(1) = sin(x) + y**2 + log(z) - 7;
-%!  retval(2) = 3*x + 2**y -z**3 + 1;
+%!  retval(1) = sin (x) + y^2 + log (z) - 7;
+%!  retval(2) = 3*x + 2^y -z^3 + 1;
 %!  retval(3) = x + y + z - 5;
 %!endfunction
 %!test
 %! x_opt = [ 0.599054;
-%! 2.395931;
-%! 2.005014 ];
+%!           2.395931;
+%!           2.005014 ];
 %! tol = 1.0e-5;
 %! opt = optimset ("Updating", "qrp");
 %! [x, fval, info] = fsolve (@__f, [ 0.5; 2.0; 2.5 ], opt);
 %! assert (info > 0);
 %! assert (norm (x - x_opt, Inf) < tol);
 %! assert (norm (fval) < tol);
 
 %!test
@@ -547,17 +548,16 @@ endfunction
 %! c_opt = [a0, b0];
 %! tol = 1e-5;
 %!
 %! [c, fval, info, output] =  fsolve (@(c) (exp(-c(1)*x) + c(2) - y), [0, 0]);
 %! assert (info > 0);
 %! assert (norm (c - c_opt, Inf) < tol);
 %! assert (norm (fval) < norm (noise));
 
-
 %!function y = cfun (x)
 %!  y(1) = (1+i)*x(1)^2 - (1-i)*x(2) - 2;
 %!  y(2) = sqrt (x(1)*x(2)) - (1-2i)*x(3) + (3-4i);
 %!  y(3) = x(1) * x(2) - x(3)^2 + (3+2i);
 %!endfunction
 
 %!test
 %! x_opt = [-1+i, 1-i, 2+i];
diff --git a/scripts/optimization/fzero.m b/scripts/optimization/fzero.m
--- a/scripts/optimization/fzero.m
+++ b/scripts/optimization/fzero.m
@@ -354,10 +354,11 @@ function fx = guarded_eval (fun, x)
     error ("fzero:notreal", "fzero: non-real value encountered");
   elseif (isnan (fx))
     error ("fzero:isnan", "fzero: NaN value encountered");
   endif
 endfunction
 
 %!shared opt0
 %! opt0 = optimset ("tolx", 0);
-%!assert(fzero(@cos, [0, 3], opt0), pi/2, 10*eps)
-%!assert(fzero(@(x) x^(1/3) - 1e-8, [0,1], opt0), 1e-24, 1e-22*eps)
+%!assert (fzero (@cos, [0, 3], opt0), pi/2, 10*eps)
+%!assert (fzero (@(x) x^(1/3) - 1e-8, [0,1], opt0), 1e-24, 1e-22*eps)
+
diff --git a/scripts/optimization/glpk.m b/scripts/optimization/glpk.m
--- a/scripts/optimization/glpk.m
+++ b/scripts/optimization/glpk.m
@@ -101,16 +101,17 @@
 ## An array containing the upper bound on each of the variables.  If
 ## @var{ub} is not supplied, the default upper bound is assumed to be
 ## infinite.
 ##
 ## @item ctype
 ## An array of characters containing the sense of each constraint in the
 ## constraint matrix.  Each element of the array may be one of the
 ## following values
+##
 ## @table @asis
 ## @item "F"
 ## A free (unbounded) constraint (the constraint is ignored).
 ##
 ## @item "U"
 ## An inequality constraint with an upper bound (@code{A(i,:)*x <= b(i)}).
 ##
 ## @item "S"
@@ -121,16 +122,17 @@
 ##
 ## @item "D"
 ## An inequality constraint with both upper and lower bounds
 ## (@code{A(i,:)*x >= -b(i)} @emph{and} (@code{A(i,:)*x <= b(i)}).
 ## @end table
 ##
 ## @item vartype
 ## A column array containing the types of the variables.
+##
 ## @table @asis
 ## @item "C"
 ## A continuous variable.
 ##
 ## @item "I"
 ## An integer variable.
 ## @end table
 ##
@@ -144,65 +146,70 @@
 ## values, so you only need to set the elements that you wish to change
 ## from the default.
 ##
 ## Integer parameters:
 ##
 ## @table @code
 ## @item msglev (@w{@code{LPX_K_MSGLEV}}, default: 1)
 ## Level of messages output by solver routines:
+##
 ## @table @asis
 ## @item 0
 ## No output.
 ##
 ## @item 1
 ## Error messages only.
 ##
 ## @item 2
 ## Normal output.
 ##
 ## @item 3
 ## Full output (includes informational messages).
 ## @end table
 ##
 ## @item scale (@w{@code{LPX_K_SCALE}}, default: 1)
 ## Scaling option:
+##
 ## @table @asis
 ## @item 0
 ## No scaling.
 ##
 ## @item 1
 ## Equilibration scaling.
 ##
 ## @item 2
 ## Geometric mean scaling, then equilibration scaling.
 ## @end table
 ##
 ## @item dual    (@w{@code{LPX_K_DUAL}}, default: 0)
 ## Dual simplex option:
+##
 ## @table @asis
 ## @item 0
 ## Do not use the dual simplex.
 ##
 ## @item 1
 ## If initial basic solution is dual feasible, use the dual simplex.
 ## @end table
 ##
 ## @item price   (@w{@code{LPX_K_PRICE}}, default: 1)
 ## Pricing option (for both primal and dual simplex):
+##
 ## @table @asis
 ## @item 0
 ## Textbook pricing.
 ##
 ## @item 1
 ## Steepest edge pricing.
 ## @end table
 ##
 ## @item round   (@w{@code{LPX_K_ROUND}}, default: 0)
 ## Solution rounding option:
+##
 ## @table @asis
 ## @item 0
 ## Report all primal and dual values "as is".
 ##
 ## @item 1
 ## Replace tiny primal and dual values by exact zero.
 ## @end table
 ##
@@ -214,29 +221,31 @@
 ##
 ## @item itcnt (@w{@code{LPX_K_OUTFRQ}}, default: 200)
 ## Output frequency, in iterations.  This parameter specifies how
 ## frequently the solver sends information about the solution to the
 ## standard output.
 ##
 ## @item branch (@w{@code{LPX_K_BRANCH}}, default: 2)
 ## Branching heuristic option (for MIP only):
+##
 ## @table @asis
 ## @item 0
 ## Branch on the first variable.
 ##
 ## @item 1
 ## Branch on the last variable.
 ##
 ## @item 2
 ## Branch using a heuristic by Driebeck and Tomlin.
 ## @end table
 ##
 ## @item btrack (@w{@code{LPX_K_BTRACK}}, default: 2)
 ## Backtracking heuristic option (for MIP only):
+##
 ## @table @asis
 ## @item 0
 ## Depth first search.
 ##
 ## @item 1
 ## Breadth first search.
 ##
 ## @item 2
@@ -245,16 +254,17 @@
 ##
 ## @item presol (@w{@code{LPX_K_PRESOL}}, default: 1)
 ## If this flag is set, the routine lpx_simplex solves the problem using
 ## the built-in LP presolver.  Otherwise the LP presolver is not used.
 ##
 ## @item lpsolver (default: 1)
 ## Select which solver to use.  If the problem is a MIP problem this flag
 ## will be ignored.
+##
 ## @table @asis
 ## @item 1
 ## Revised simplex method.
 ##
 ## @item 2
 ## Interior point method.
 ## @end table
 ##
@@ -334,16 +344,17 @@
 ##
 ## @item fopt
 ## The optimum value of the objective function.
 ##
 ## @item status
 ## Status of the optimization.
 ##
 ## Simplex Method:
+##
 ## @table @asis
 ## @item 180 (@w{@code{LPX_OPT}})
 ## Solution is optimal.
 ##
 ## @item 181 (@w{@code{LPX_FEAS}})
 ## Solution is feasible.
 ##
 ## @item 182 (@w{@code{LPX_INFEAS}})
@@ -354,24 +365,26 @@
 ##
 ## @item 184 (@w{@code{LPX_UNBND}})
 ## Problem has no unbounded solution.
 ##
 ## @item 185 (@w{@code{LPX_UNDEF}})
 ## Solution status is undefined.
 ## @end table
 ## Interior Point Method:
+##
 ## @table @asis
 ## @item 150 (@w{@code{LPX_T_UNDEF}})
 ## The interior point method is undefined.
 ##
 ## @item 151 (@w{@code{LPX_T_OPT}})
 ## The interior point method is optimal.
 ## @end table
 ## Mixed Integer Method:
+##
 ## @table @asis
 ## @item 170 (@w{@code{LPX_I_UNDEF}})
 ## The status is undefined.
 ##
 ## @item 171 (@w{@code{LPX_I_OPT}})
 ## The solution is integer optimal.
 ##
 ## @item 172 (@w{@code{LPX_I_FEAS}})
@@ -416,16 +429,17 @@
 ## No primal feasible solution (LP presolver).
 ##
 ## @item 214 (@w{@code{LPX_E_NODFS}})
 ## No dual feasible solution (LP presolver).
 ## @end table
 ##
 ## @item extra
 ## A data structure containing the following fields:
+##
 ## @table @code
 ## @item lambda
 ## Dual variables.
 ##
 ## @item redcosts
 ## Reduced Costs.
 ##
 ## @item time
diff --git a/scripts/optimization/lsqnonneg.m b/scripts/optimization/lsqnonneg.m
--- a/scripts/optimization/lsqnonneg.m
+++ b/scripts/optimization/lsqnonneg.m
@@ -26,16 +26,17 @@
 ## @deftypefnx {Function File} {[@var{x}, @var{resnorm}, @var{residual}, @var{exitflag}] =} lsqnonneg (@dots{})
 ## @deftypefnx {Function File} {[@var{x}, @var{resnorm}, @var{residual}, @var{exitflag}, @var{output}] =} lsqnonneg (@dots{})
 ## @deftypefnx {Function File} {[@var{x}, @var{resnorm}, @var{residual}, @var{exitflag}, @var{output}, @var{lambda}] =} lsqnonneg (@dots{})
 ## Minimize @code{norm (@var{c}*@var{x} - d)} subject to
 ## @code{@var{x} >= 0}.  @var{c} and @var{d} must be real.  @var{x0} is an
 ## optional initial guess for @var{x}.
 ##
 ## Outputs:
+##
 ## @itemize @bullet
 ## @item resnorm
 ##
 ## The squared 2-norm of the residual: norm(@var{c}*@var{x}-@var{d})^2
 ##
 ## @item residual
 ##
 ## The residual: @var{d}-@var{c}*@var{x}
@@ -45,16 +46,17 @@
 ## An indicator of convergence.  0 indicates that the iteration count
 ## was exceeded, and therefore convergence was not reached; >0 indicates
 ## that the algorithm converged.  (The algorithm is stable and will
 ## converge given enough iterations.)
 ##
 ## @item output
 ##
 ## A structure with two fields:
+##
 ## @itemize @bullet
 ## @item "algorithm": The algorithm used ("nnls")
 ##
 ## @item "iterations": The number of iterations taken.
 ## @end itemize
 ##
 ## @item lambda
 ##
@@ -193,19 +195,20 @@ function [x, resnorm, residual, exitflag
   endif
   if (nargout > 5)
     lambda = zeros (size (x));
     lambda(p) = w;
   endif
 
 endfunction
 
-## Tests
+
 %!test
 %! C = [1 0;0 1;2 1];
 %! d = [1;3;-2];
-%! assert (lsqnonneg (C, d), [0;0.5], 100*eps)
+%! assert (lsqnonneg (C, d), [0;0.5], 100*eps);
 
 %!test
 %! C = [0.0372 0.2869;0.6861 0.7071;0.6233 0.6245;0.6344 0.6170];
 %! d = [0.8587;0.1781;0.0747;0.8405];
 %! xnew = [0;0.6929];
-%! assert (lsqnonneg (C, d), xnew, 0.0001)
+%! assert (lsqnonneg (C, d), xnew, 0.0001);
+
diff --git a/scripts/optimization/optimset.m b/scripts/optimization/optimset.m
--- a/scripts/optimization/optimset.m
+++ b/scripts/optimization/optimset.m
@@ -20,16 +20,17 @@
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} optimset ()
 ## @deftypefnx {Function File} {} optimset (@var{par}, @var{val}, @dots{})
 ## @deftypefnx {Function File} {} optimset (@var{old}, @var{par}, @var{val}, @dots{})
 ## @deftypefnx {Function File} {} optimset (@var{old}, @var{new})
 ## Create options struct for optimization functions.
 ##
 ## Valid parameters are:
+##
 ## @itemize @bullet
 ## @item AutoScaling
 ##
 ## @item ComplexEqn
 ##
 ## @item FinDiffType
 ##
 ## @item FunValCheck
@@ -136,13 +137,13 @@ function retval = optimset (varargin)
     retval = optimset (struct (), cell2struct (pairs(2, :), pairs(1, :), 2));
   else
     print_usage ();
   endif
 
 endfunction
 
 
-%!assert (optimget (optimset ('tolx', 1e-2), 'tOLx'), 1e-2)
-%!assert (isfield (optimset ('tolFun', 1e-3), 'TolFun'))
+%!assert (optimget (optimset ("tolx", 1e-2), "tOLx"), 1e-2)
+%!assert (isfield (optimset ("tolFun", 1e-3), "TolFun"))
 
 %!error (optimset ("%NOT_A_REAL_FUNCTION_NAME%"))
 
diff --git a/scripts/optimization/pqpnonneg.m b/scripts/optimization/pqpnonneg.m
--- a/scripts/optimization/pqpnonneg.m
+++ b/scripts/optimization/pqpnonneg.m
@@ -25,31 +25,33 @@
 ## @deftypefnx {Function File} {[@var{x}, @var{minval}, @var{exitflag}] =} pqpnonneg (@dots{})
 ## @deftypefnx {Function File} {[@var{x}, @var{minval}, @var{exitflag}, @var{output}] =} pqpnonneg (@dots{})
 ## @deftypefnx {Function File} {[@var{x}, @var{minval}, @var{exitflag}, @var{output}, @var{lambda}] =} pqpnonneg (@dots{})
 ## Minimize @code{1/2*x'*c*x + d'*x} subject to @code{@var{x} >= 0}.  @var{c}
 ## and @var{d} must be real, and @var{c} must be symmetric and positive
 ## definite.  @var{x0} is an optional initial guess for @var{x}.
 ##
 ## Outputs:
+##
 ## @itemize @bullet
 ## @item minval
 ##
 ## The minimum attained model value, 1/2*xmin'*c*xmin + d'*xmin
 ##
 ## @item exitflag
 ##
 ## An indicator of convergence.  0 indicates that the iteration count
 ## was exceeded, and therefore convergence was not reached; >0 indicates
 ## that the algorithm converged.  (The algorithm is stable and will
 ## converge given enough iterations.)
 ##
 ## @item output
 ##
 ## A structure with two fields:
+##
 ## @itemize @bullet
 ## @item "algorithm": The algorithm used ("nnls")
 ##
 ## @item "iterations": The number of iterations taken.
 ## @end itemize
 ##
 ## @item lambda
 ##
@@ -193,19 +195,20 @@ function [x, minval, exitflag, output, l
   endif
   if (nargout > 4)
     lambda = zeros (size (x));
     lambda(p) = w;
   endif
 
 endfunction
 
-## Tests
+
 %!test
 %! C = [5 2;2 2];
 %! d = [3; -1];
-%! assert (pqpnonneg (C, d), [0;0.5], 100*eps)
+%! assert (pqpnonneg (C, d), [0;0.5], 100*eps);
 
 ## Test equivalence of lsq and pqp
 %!test
 %! C = rand (20, 10);
 %! d = rand (20, 1);
-%! assert (pqpnonneg (C'*C, -C'*d), lsqnonneg (C, d), 100*eps)
+%! assert (pqpnonneg (C'*C, -C'*d), lsqnonneg (C, d), 100*eps);
+
diff --git a/scripts/optimization/qp.m b/scripts/optimization/qp.m
--- a/scripts/optimization/qp.m
+++ b/scripts/optimization/qp.m
@@ -28,35 +28,35 @@
 ## $$
 ##  \min_x {1 \over 2} x^T H x + x^T q
 ## $$
 ## @end tex
 ## @ifnottex
 ##
 ## @example
 ## @group
-##      min 0.5 x'*H*x + x'*q
-##       x
+## min 0.5 x'*H*x + x'*q
+##  x
 ## @end group
 ## @end example
 ##
 ## @end ifnottex
 ## subject to
 ## @tex
 ## $$
 ##  Ax = b \qquad lb \leq x \leq ub \qquad A_{lb} \leq A_{in} \leq A_{ub}
 ## $$
 ## @end tex
 ## @ifnottex
 ##
 ## @example
 ## @group
-##      A*x = b
-##      lb <= x <= ub
-##      A_lb <= A_in*x <= A_ub
+## A*x = b
+## lb <= x <= ub
+## A_lb <= A_in*x <= A_ub
 ## @end group
 ## @end example
 ##
 ## @end ifnottex
 ## @noindent
 ## using a null-space active-set method.
 ##
 ## Any bound (@var{A}, @var{b}, @var{lb}, @var{ub}, @var{A_lb},
diff --git a/scripts/optimization/sqp.m b/scripts/optimization/sqp.m
--- a/scripts/optimization/sqp.m
+++ b/scripts/optimization/sqp.m
@@ -28,35 +28,35 @@
 ## $$
 ## \min_x \phi (x)
 ## $$
 ## @end tex
 ## @ifnottex
 ##
 ## @example
 ## @group
-##      min phi (x)
-##       x
+## min phi (x)
+##  x
 ## @end group
 ## @end example
 ##
 ## @end ifnottex
 ## subject to
 ## @tex
 ## $$
 ##  g(x) = 0 \qquad h(x) \geq 0 \qquad lb \leq x \leq ub
 ## $$
 ## @end tex
 ## @ifnottex
 ##
 ## @example
 ## @group
-##      g(x)  = 0
-##      h(x) >= 0
-##      lb <= x <= ub
+## g(x)  = 0
+## h(x) >= 0
+## lb <= x <= ub
 ## @end group
 ## @end example
 ##
 ## @end ifnottex
 ## @noindent
 ## using a sequential quadratic programming method.
 ##
 ## The first argument is the initial guess for the vector @var{x0}.
@@ -97,19 +97,19 @@
 ##         {\partial f(x) \over \partial x_2}, \ldots,
 ##         {\partial f(x) \over \partial x_N} \Bigg)^T
 ## $$
 ## @end tex
 ## @ifnottex
 ##
 ## @example
 ## @group
-##                 [ d f(x)   d f(x)        d f(x) ]
-##     transpose ( [ ------   -----   ...   ------ ] )
-##                 [  dx_1     dx_2          dx_N  ]
+##             [ d f(x)   d f(x)        d f(x) ]
+## transpose ( [ ------   -----   ...   ------ ] )
+##             [  dx_1     dx_2          dx_N  ]
 ## @end group
 ## @end example
 ##
 ## @end ifnottex
 ## The fifth and sixth arguments, @var{lb} and @var{ub}, contain lower
 ## and upper bounds on @var{x}.  These must be consistent with the
 ## equality and inequality constraints @var{g} and @var{h}.  If the
 ## arguments are vectors then @var{x}(i) is bound by @var{lb}(i) and
@@ -150,17 +150,17 @@
 ## @example
 ## function r = g (x)
 ##   r = [ sumsq(x)-10;
 ##         x(2)*x(3)-5*x(4)*x(5);
 ##         x(1)^3+x(2)^3+1 ];
 ## endfunction
 ##
 ## function obj = phi (x)
-##   obj = exp(prod(x)) - 0.5*(x(1)^3+x(2)^3+1)^2;
+##   obj = exp (prod (x)) - 0.5*(x(1)^3+x(2)^3+1)^2;
 ## endfunction
 ##
 ## x0 = [-1.8; 1.7; 1.9; -0.8; -0.8];
 ##
 ## [x, obj, info, iter, nf, lambda] = sqp (x0, @@phi, @@g, [])
 ##
 ## x =
 ##
@@ -728,54 +728,56 @@ function report (iter, qp_iter, alpha, n
   if (nargin == 0)
     printf ("  Itn ItQP     Step  Nfun     Objective\n");
   else
     printf ("%5d %4d %8.1g %5d %13.6e\n", iter, qp_iter, alpha, nfun, obj);
   endif
 
 endfunction
 
+
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %% Test Code
 
 %!function r = __g (x)
 %!  r = [sumsq(x)-10;
 %!       x(2)*x(3)-5*x(4)*x(5);
 %!       x(1)^3+x(2)^3+1 ];
 %!endfunction
 %!
 %!function obj = __phi (x)
-%!  obj = exp(prod(x)) - 0.5*(x(1)^3+x(2)^3+1)^2;
+%!  obj = exp (prod (x)) - 0.5*(x(1)^3 + x(2)^3 + 1)^2;
 %!endfunction
 %!
 %!test
 %!
 %! x0 = [-1.8; 1.7; 1.9; -0.8; -0.8];
 %!
 %! [x, obj, info, iter, nf, lambda] = sqp (x0, @__phi, @__g, []);
 %!
 %! x_opt = [-1.717143501952599;
 %!           1.595709610928535;
 %!           1.827245880097156;
 %!          -0.763643103133572;
 %!          -0.763643068453300];
 %!
 %! obj_opt = 0.0539498477702739;
 %!
-%! assert (all (abs (x-x_opt) < 5*sqrt (eps)) && abs (obj-obj_opt) < sqrt (eps));
+%! assert (x, x_opt, 5*sqrt (eps));
+%! assert (obj, obj_opt, sqrt (eps));
 
 %% Test input validation
 %!error sqp ()
 %!error sqp (1)
 %!error sqp (1,2,3,4,5,6,7,8,9)
 %!error sqp (1,2,3,4,5)
-%!error sqp (ones(2,2))
-%!error sqp (1,cell(4,1))
-%!error sqp (1,cell(3,1),cell(3,1))
-%!error sqp (1,cell(3,1),cell(2,1),cell(3,1))
-%!error sqp (1,cell(3,1),cell(2,1),cell(2,1),ones(2,2),[])
-%!error sqp (1,cell(3,1),cell(2,1),cell(2,1),[],ones(2,2))
-%!error sqp (1,cell(3,1),cell(2,1),cell(2,1),1,-1)
-%!error sqp (1,cell(3,1),cell(2,1),cell(2,1),[],[],ones(2,2))
-%!error sqp (1,cell(3,1),cell(2,1),cell(2,1),[],[],-1)
-%!error sqp (1,cell(3,1),cell(2,1),cell(2,1),[],[],1.5)
-%!error sqp (1,cell(3,1),cell(2,1),cell(2,1),[],[],[],ones(2,2))
-%!error sqp (1,cell(3,1),cell(2,1),cell(2,1),[],[],[],-1)
+%!error sqp (ones (2,2))
+%!error sqp (1, cell (4,1))
+%!error sqp (1, cell (3,1), cell (3,1))
+%!error sqp (1, cell (3,1), cell (2,1), cell (3,1))
+%!error sqp (1, cell (3,1), cell (2,1), cell (2,1), ones (2,2),[])
+%!error sqp (1, cell (3,1), cell (2,1), cell (2,1),[], ones (2,2))
+%!error sqp (1, cell (3,1), cell (2,1), cell (2,1),1,-1)
+%!error sqp (1, cell (3,1), cell (2,1), cell (2,1),[],[], ones (2,2))
+%!error sqp (1, cell (3,1), cell (2,1), cell (2,1),[],[],-1)
+%!error sqp (1, cell (3,1), cell (2,1), cell (2,1),[],[],1.5)
+%!error sqp (1, cell (3,1), cell (2,1), cell (2,1),[],[],[], ones (2,2))
+%!error sqp (1, cell (3,1), cell (2,1), cell (2,1),[],[],[],-1)
diff --git a/scripts/path/matlabroot.m b/scripts/path/matlabroot.m
--- a/scripts/path/matlabroot.m
+++ b/scripts/path/matlabroot.m
@@ -27,10 +27,11 @@
 
 function retval = matlabroot ()
 
   retval = OCTAVE_HOME;
 
 endfunction
 
 
-%!assert (matlabroot(), OCTAVE_HOME())
 
+%!assert (matlabroot (), OCTAVE_HOME ())
+
diff --git a/scripts/pkg/pkg.m b/scripts/pkg/pkg.m
--- a/scripts/pkg/pkg.m
+++ b/scripts/pkg/pkg.m
@@ -131,26 +131,26 @@
 ## If two output arguments are requested @code{pkg} splits the list of
 ## installed packages into those which were installed by the current user,
 ## and those which were installed by the system administrator.
 ##
 ## @example
 ## [user_packages, system_packages] = pkg ("list")
 ## @end example
 ##
-## The option '-forge' lists packages available at the Octave-Forge repository.
+## The option "-forge" lists packages available at the Octave-Forge repository.
 ## This requires an internet connection and the cURL library.  For example:
 ##
 ## @example
 ## oct_forge_pkgs = pkg ("list", "-forge")
 ## @end example
 ##
 ## @item describe
 ## Show a short description of the named installed packages, with the option
-## '-verbose' also list functions provided by the package.  For example,
+## "-verbose" also list functions provided by the package.  For example,
 ##
 ## @example
 ## pkg describe -verbose all
 ## @end example
 ##
 ## @noindent
 ## will describe all installed packages and the functions they provide.
 ## If one output is requested a cell of structure containing the
diff --git a/scripts/plot/__gnuplot_drawnow__.m b/scripts/plot/__gnuplot_drawnow__.m
--- a/scripts/plot/__gnuplot_drawnow__.m
+++ b/scripts/plot/__gnuplot_drawnow__.m
@@ -385,8 +385,9 @@ function retval = have_non_legend_axes (
       retval = (n_all_axes - n_legend_axes) > 1;
     endif
   endif
 endfunction
 
 
 ## No test needed for internal helper function.
 %!assert (1)
+
diff --git a/scripts/plot/__plt_get_axis_arg__.m b/scripts/plot/__plt_get_axis_arg__.m
--- a/scripts/plot/__plt_get_axis_arg__.m
+++ b/scripts/plot/__plt_get_axis_arg__.m
@@ -75,8 +75,9 @@ function [h, varargin, narg] = __plt_get
 
   narg = length (varargin);
 
 endfunction
 
 
 ## No test needed for internal helper function.
 %!assert (1)
+
diff --git a/scripts/plot/ancestor.m b/scripts/plot/ancestor.m
--- a/scripts/plot/ancestor.m
+++ b/scripts/plot/ancestor.m
@@ -13,17 +13,17 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{parent} =} ancestor (@var{h}, @var{type})
-## @deftypefnx {Function File} {@var{parent} =} ancestor (@var{h}, @var{type}, 'toplevel')
+## @deftypefnx {Function File} {@var{parent} =} ancestor (@var{h}, @var{type}, "toplevel")
 ## Return the first ancestor of handle object @var{h} whose type matches
 ## @var{type}, where @var{type} is a character string.  If @var{type} is a
 ## cell array of strings, return the first parent whose type matches
 ## any of the given type strings.
 ##
 ## If the handle object @var{h} is of type @var{type}, return @var{h}.
 ##
 ## If @code{"toplevel"} is given as a 3rd argument, return the highest
@@ -70,17 +70,19 @@ function p = ancestor (h, type, toplevel
       error ("ancestor: second argument must be a string or cell array of strings");
     endif
   else
     print_usage ();
   endif
 
 endfunction
 
+
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   l = line;
 %!   assert (ancestor (l, "axes"), gca);
 %!   assert (ancestor (l, "figure"), hf);
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
+
diff --git a/scripts/plot/bar.m b/scripts/plot/bar.m
--- a/scripts/plot/bar.m
+++ b/scripts/plot/bar.m
@@ -61,28 +61,28 @@
 ## bar (randn (1, 100), "facecolor", "r", "edgecolor", "b")
 ## @end example
 ##
 ## @noindent
 ## The color of the bars is taken from the figure's colormap, such that
 ##
 ## @example
 ## @group
-## bar (rand(10,3))
-## colormap (summer ())
+## bar (rand (10, 3));
+## colormap (summer (64));
 ## @end group
 ## @end example
 ##
 ## @noindent
 ## will change the colors used for the bars.  The color of bars can also be set
 ## manually using the "facecolor" property as shown below.
 ##
 ## @example
 ## @group
-## h = bar (rand(10,3))
+## h = bar (rand (10, 3));
 ## set (h(1), "facecolor", "r")
 ## set (h(2), "facecolor", "g")
 ## set (h(3), "facecolor", "b")
 ## @end group
 ## @end example
 ##
 ## @seealso{barh, plot}
 ## @end deftypefn
diff --git a/scripts/plot/caxis.m b/scripts/plot/caxis.m
--- a/scripts/plot/caxis.m
+++ b/scripts/plot/caxis.m
@@ -21,18 +21,18 @@
 ## @deftypefnx {Function File} {} caxis (@var{h}, @dots{})
 ## Set color axis limits for plots.
 ##
 ## The argument @var{limits} should be a 2-element vector specifying the
 ## lower and upper limits to assign to the first and last value in the
 ## colormap.  Values outside this range are clamped to the first and last
 ## colormap entries.
 ##
-## If @var{limits} is 'auto', then automatic colormap scaling is applied,
-## whereas if @var{limits} is 'manual' the colormap scaling is set to manual.
+## If @var{limits} is "auto", then automatic colormap scaling is applied,
+## whereas if @var{limits} is "manual" the colormap scaling is set to manual.
 ##
 ## Called without any arguments to current color axis limits are returned.
 ##
 ## If an axes handle is passed as the first argument, then operate on
 ## this axes rather than the current axes.
 ## @end deftypefn
 
 function varargout = caxis (varargin)
diff --git a/scripts/plot/cla.m b/scripts/plot/cla.m
--- a/scripts/plot/cla.m
+++ b/scripts/plot/cla.m
@@ -84,19 +84,21 @@ function cla (varargin)
   axes (hax);
   axis ("auto");
 
   ## Set the current axis back to where it was upon entry.
   axes (oldhax);
 
 endfunction
 
+
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
-%!   plot (1:10)
-%!   cla ()
+%!   plot (1:10);
+%!   cla ();
 %!   kids = get (gca, "children");
-%!   cla ()
+%!   cla ();
 %! unwind_protect_cleanup
-%!   close (hf)
+%!   close (hf);
 %! end_unwind_protect
-%! assert (numel (kids), 0)
+%! assert (numel (kids), 0);
+
diff --git a/scripts/plot/clabel.m b/scripts/plot/clabel.m
--- a/scripts/plot/clabel.m
+++ b/scripts/plot/clabel.m
@@ -43,18 +43,18 @@
 ## the text objects representing each label.  
 ## The "userdata" property of the text objects contains the numerical value of
 ## the contour label.
 ##
 ## An example of the use of @code{clabel} is
 ##
 ## @example
 ## @group
-## [c, h] = contour (peaks(), -4 : 6);
-## clabel (c, h, -4 : 2 : 6, 'fontsize', 12);
+## [c, h] = contour (peaks (), -4 : 6);
+## clabel (c, h, -4:2:6, "fontsize", 12);
 ## @end group
 ## @end example
 ##
 ## @seealso{contour, contourf, contour3, meshc, surfc, text}
 ## @end deftypefn
 
 function retval = clabel (c, varargin)
   label_spacing = 2 * 72;
diff --git a/scripts/plot/clf.m b/scripts/plot/clf.m
--- a/scripts/plot/clf.m
+++ b/scripts/plot/clf.m
@@ -84,17 +84,17 @@ function retval = clf (varargin)
 
 endfunction
 
 
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   l = line;
-%!   assert (!isempty (get (gcf, "children")));
+%!   assert (! isempty (get (gcf, "children")));
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
 
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   clf;
diff --git a/scripts/plot/close.m b/scripts/plot/close.m
--- a/scripts/plot/close.m
+++ b/scripts/plot/close.m
@@ -75,19 +75,21 @@ function close_all_figures (close_hidden
     ## handlevisibility = get (fig, "handlevisibility")
     ## if (close_hidden_figs || ! strcmpi (handlevisibility, "off"))
     close (fig);
     ## endif
   endwhile
 
 endfunction
 
+
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   close (hf);
 %!   objs = findobj ("type", "figure");
 %!   assert (isempty (intersect (objs, hf)));
 %! unwind_protect_cleanup
 %!   if (isfigure (hf))
 %!     close (hf);
 %!   endif
 %! end_unwind_protect
+
diff --git a/scripts/plot/colorbar.m b/scripts/plot/colorbar.m
--- a/scripts/plot/colorbar.m
+++ b/scripts/plot/colorbar.m
@@ -377,17 +377,17 @@ endfunction
 %! imagesc (x);
 %! colorbar ('westoutside');
 
 %!demo
 %! clf;
 %! colormap ('default');
 %! n = 64; x = kron (1:n, ones (n,1)); x = abs (x - x.');
 %! imagesc (x);
-%! colorbar ('peer', gca (), 'northoutside');
+%! colorbar ('peer', gca, 'northoutside');
 
 %!demo
 %! clf;
 %! colormap ('default');
 %! n = 64; x = kron (1:n, ones (n,1)); x = abs (x - x.');
 %! imagesc (x);
 %! colorbar ('southoutside');
 
diff --git a/scripts/plot/colstyle.m b/scripts/plot/colstyle.m
--- a/scripts/plot/colstyle.m
+++ b/scripts/plot/colstyle.m
@@ -59,16 +59,17 @@ function [l, c, m, msg] = colstyle (styl
     endswitch
   catch
     l = c = m = [];
     msg = lasterr ();
   end_try_catch
 
 endfunction
 
+
 %!test
 %! [l, c, m, msg] = colstyle ("r:x");
 %! assert (isempty (msg));
 %! assert (l, ":");
 %! assert (c, "r");
 %! assert (m, "x");
 
 %!test
diff --git a/scripts/plot/comet3.m b/scripts/plot/comet3.m
--- a/scripts/plot/comet3.m
+++ b/scripts/plot/comet3.m
@@ -79,10 +79,10 @@ function comet3 (varargin)
   end_unwind_protect
 
 endfunction
 
 
 %!demo
 %! clf;
 %! t = 0:pi/20:5*pi;
-%! comet3 (cos(t), sin(t), t, 0.01);
+%! comet3 (cos (t), sin (t), t, 0.01);
 
diff --git a/scripts/plot/compass.m b/scripts/plot/compass.m
--- a/scripts/plot/compass.m
+++ b/scripts/plot/compass.m
@@ -32,17 +32,17 @@
 ## in a similar manner to the line styles used with the @code{plot} command.
 ##
 ## The optional return value @var{h} is a vector of graphics handles to the
 ## line objects representing the drawn vectors.
 ##
 ## @example
 ## @group
 ## a = toeplitz ([1;randn(9,1)], [1,randn(1,9)]);
-## compass (eig (a))
+## compass (eig (a));
 ## @end group
 ## @end example
 ##
 ## @seealso{polar, quiver, feather, plot}
 ## @end deftypefn
 
 function retval = compass (varargin)
 
diff --git a/scripts/plot/contour3.m b/scripts/plot/contour3.m
--- a/scripts/plot/contour3.m
+++ b/scripts/plot/contour3.m
@@ -29,18 +29,18 @@
 ## arguments; see the latter for their interpretation.  The contours are
 ## plotted at the Z level corresponding to their contour.  The set of
 ## contour levels, @var{c}, is only returned if requested.  For example:
 ##
 ## @example
 ## @group
 ## contour3 (peaks (19));
 ## hold on
-## surface (peaks (19), "facecolor", "none", "EdgeColor", "black")
-## colormap hot
+## surface (peaks (19), "facecolor", "none", "EdgeColor", "black");
+## colormap hot;
 ## @end group
 ## @end example
 ##
 ## The style to use for the plot can be defined with a line style @var{style}
 ## in a similar manner to the line styles used with the @code{plot} command.
 ## Any markers defined by @var{style} are ignored.
 ##
 ## The optional input and output argument @var{h} allows an axis handle to
diff --git a/scripts/plot/contourc.m b/scripts/plot/contourc.m
--- a/scripts/plot/contourc.m
+++ b/scripts/plot/contourc.m
@@ -45,19 +45,18 @@
 ## For example:
 ##
 ## @example
 ## @group
 ## x = 0:2;
 ## y = x;
 ## z = x' * y;
 ## contourc (x, y, z, 2:3)
-##      @result{}   2.0000   2.0000   1.0000   3.0000   1.5000   2.0000
-##      2.0000   1.0000   2.0000   2.0000   2.0000   1.5000
-##
+##    @result{}   2.0000   2.0000   1.0000   3.0000   1.5000   2.0000
+##         2.0000   1.0000   2.0000   2.0000   2.0000   1.5000
 ## @end group
 ## @end example
 ## @seealso{contour}
 ## @end deftypefn
 
 ## Author: Shai Ayal <shaiay@users.sourceforge.net>
 
 function [cout, lev] = contourc (varargin)
@@ -136,19 +135,19 @@ function [cout, lev] = contourc (varargi
 
   if (nargout > 0)
     cout = c;
     lev = vv;
   endif
 
 endfunction
 
+
 %!test
 %! x = 0:2;
 %! y = x;
 %! z = x' * y;
 %! [c_actual, lev_actual]= contourc (x, y, z, 2:3);
 %! c_expected = [2, 1, 1, 2, 2, 3, 1.5, 2; 4, 2, 2, 1, 1, 2, 2, 1.5];
 %! lev_expected = [2 3];
-%! assert (c_actual, c_expected, eps)
-%! assert (lev_actual, lev_expected, eps)
+%! assert (c_actual, c_expected, eps);
+%! assert (lev_actual, lev_expected, eps);
 
-
diff --git a/scripts/plot/cylinder.m b/scripts/plot/cylinder.m
--- a/scripts/plot/cylinder.m
+++ b/scripts/plot/cylinder.m
@@ -33,19 +33,19 @@
 ## @code{surf (@var{x}, @var{y}, @var{z})}.  If an axes handle @var{ax}
 ## is passed as the first argument, the surface is plotted to this set
 ## of axes.
 ##
 ## Examples:
 ##
 ## @example
 ## @group
-## [x, y, z] = cylinder (10:-1:0,50);
+## [x, y, z] = cylinder (10:-1:0, 50);
 ## surf (x, y, z);
-## title ("a cone")
+## title ("a cone");
 ## @end group
 ## @end example
 ## @seealso{sphere}
 ## @end deftypefn
 
 function [xx, yy, zz] = cylinder (varargin)
 
   [ax, args, nargs] = __plt_get_axis_arg__ ((nargout > 0), "cylinder",
diff --git a/scripts/plot/ezcontour.m b/scripts/plot/ezcontour.m
--- a/scripts/plot/ezcontour.m
+++ b/scripts/plot/ezcontour.m
@@ -34,17 +34,17 @@
 ## separately.
 ##
 ## @var{n} is a scalar defining the number of points to use in each dimension.
 ##
 ## The optional return value @var{h} is a graphics handle to the created plot.
 ##
 ## @example
 ## @group
-## f = @@(x,y) sqrt(abs(x .* y)) ./ (1 + x.^2 + y.^2);
+## f = @@(x,y) sqrt (abs (x .* y)) ./ (1 + x.^2 + y.^2);
 ## ezcontour (f, [-3, 3]);
 ## @end group
 ## @end example
 ##
 ## @seealso{ezplot, ezcontourf, ezsurfc, ezmeshc}
 ## @end deftypefn
 
 function retval = ezcontour (varargin)
diff --git a/scripts/plot/ezcontourf.m b/scripts/plot/ezcontourf.m
--- a/scripts/plot/ezcontourf.m
+++ b/scripts/plot/ezcontourf.m
@@ -34,17 +34,17 @@
 ## separately.
 ##
 ## @var{n} is a scalar defining the number of points to use in each dimension.
 ##
 ## The optional return value @var{h} is a graphics handle to the created plot.
 ##
 ## @example
 ## @group
-## f = @@(x,y) sqrt(abs(x .* y)) ./ (1 + x.^2 + y.^2);
+## f = @@(x,y) sqrt (abs (x .* y)) ./ (1 + x.^2 + y.^2);
 ## ezcontourf (f, [-3, 3]);
 ## @end group
 ## @end example
 ##
 ## @seealso{ezplot, ezcontour, ezsurfc, ezmeshc}
 ## @end deftypefn
 
 function retval = ezcontourf (varargin)
diff --git a/scripts/plot/ezmesh.m b/scripts/plot/ezmesh.m
--- a/scripts/plot/ezmesh.m
+++ b/scripts/plot/ezmesh.m
@@ -16,17 +16,17 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} ezmesh (@var{f})
 ## @deftypefnx {Function File} {} ezmesh (@var{fx}, @var{fy}, @var{fz})
 ## @deftypefnx {Function File} {} ezmesh (@dots{}, @var{dom})
 ## @deftypefnx {Function File} {} ezmesh (@dots{}, @var{n})
-## @deftypefnx {Function File} {} ezmesh (@dots{}, 'circ')
+## @deftypefnx {Function File} {} ezmesh (@dots{}, "circ")
 ## @deftypefnx {Function File} {} ezmesh (@var{h}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} ezmesh (@dots{})
 ##
 ## Plot the mesh defined by a function.  @var{f} is a string, inline
 ## function or function handle with two arguments defining the function.  By
 ## default the plot is over the domain @code{-2*pi < @var{x} < 2*pi} and
 ## @code{-2*pi < @var{y} < 2*pi} with 60 points in each dimension.
 ##
@@ -36,25 +36,25 @@
 ## separately.
 ##
 ## @var{n} is a scalar defining the number of points to use in each dimension.
 ##
 ## If three functions are passed, then plot the parametrically defined
 ## function @code{[@var{fx} (@var{s}, @var{t}), @var{fy} (@var{s}, @var{t}),
 ## @var{fz} (@var{s}, @var{t})]}.
 ##
-## If the argument 'circ' is given, then the function is plotted over a disk
+## If the argument "circ" is given, then the function is plotted over a disk
 ## centered on the middle of the domain @var{dom}.
 ##
 ## The optional return value @var{h} is a graphics handle to the created 
 ## surface object.
 ##
 ## @example
 ## @group
-## f = @@(x,y) sqrt(abs(x .* y)) ./ (1 + x.^2 + y.^2);
+## f = @@(x,y) sqrt (abs (x .* y)) ./ (1 + x.^2 + y.^2);
 ## ezmesh (f, [-3, 3]);
 ## @end group
 ## @end example
 ##
 ## An example of a parametrically defined function is
 ##
 ## @example
 ## @group
diff --git a/scripts/plot/ezmeshc.m b/scripts/plot/ezmeshc.m
--- a/scripts/plot/ezmeshc.m
+++ b/scripts/plot/ezmeshc.m
@@ -16,17 +16,17 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} ezmeshc (@var{f})
 ## @deftypefnx {Function File} {} ezmeshc (@var{fx}, @var{fy}, @var{fz})
 ## @deftypefnx {Function File} {} ezmeshc (@dots{}, @var{dom})
 ## @deftypefnx {Function File} {} ezmeshc (@dots{}, @var{n})
-## @deftypefnx {Function File} {} ezmeshc (@dots{}, 'circ')
+## @deftypefnx {Function File} {} ezmeshc (@dots{}, "circ")
 ## @deftypefnx {Function File} {} ezmeshc (@var{h}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} ezmeshc (@dots{})
 ##
 ## Plot the mesh and contour lines defined by a function.  @var{f} is a string,
 ## inline function or function handle with two arguments defining the function.
 ## By default the plot is over the domain @code{-2*pi < @var{x} < 2*pi} and
 ## @code{-2*pi < @var{y} < 2*pi} with 60 points in each dimension.
 ##
@@ -36,26 +36,26 @@
 ## separately.
 ##
 ## @var{n} is a scalar defining the number of points to use in each dimension.
 ##
 ## If three functions are passed, then plot the parametrically defined
 ## function @code{[@var{fx} (@var{s}, @var{t}), @var{fy} (@var{s}, @var{t}),
 ## @var{fz} (@var{s}, @var{t})]}.
 ##
-## If the argument 'circ' is given, then the function is plotted over a disk
+## If the argument "circ" is given, then the function is plotted over a disk
 ## centered on the middle of the domain @var{dom}.
 ##
 ## The optional return value @var{h} is a 2-element vector with a graphics
 ## handle for the created mesh plot and a second handle for the created contour
 ## plot.
 ##
 ## @example
 ## @group
-## f = @@(x,y) sqrt(abs(x .* y)) ./ (1 + x.^2 + y.^2);
+## f = @@(x,y) sqrt (abs (x .* y)) ./ (1 + x.^2 + y.^2);
 ## ezmeshc (f, [-3, 3]);
 ## @end group
 ## @end example
 ##
 ## @seealso{ezplot, ezsurfc, ezsurf, ezmesh}
 ## @end deftypefn
 
 function retval = ezmeshc (varargin)
diff --git a/scripts/plot/ezplot.m b/scripts/plot/ezplot.m
--- a/scripts/plot/ezplot.m
+++ b/scripts/plot/ezplot.m
@@ -30,17 +30,17 @@
 ## the function is plotted over the domain @code{-2*pi < @var{x} < 2*pi}
 ## with 500 points.
 ##
 ## If @var{f} has two variables then @code{@var{f}(@var{x},@var{y}) = 0}
 ## is calculated over the meshed domain @code{-2*pi < @var{x} | @var{y}
 ## < 2*pi} with 60 by 60 in the mesh.  For example:
 ##
 ## @example
-## ezplot (@@(@var{x}, @var{y}) @var{x} .^ 2 - @var{y} .^ 2 - 1)
+## ezplot (@@(@var{x}, @var{y}) @var{x}.^2 - @var{y}.^2 - 1)
 ## @end example
 ##
 ## If two functions are passed as strings, inline functions or function
 ## handles, then the parametric function
 ##
 ## @example
 ## @group
 ## @var{x} = @var{fx} (@var{t})
diff --git a/scripts/plot/ezsurf.m b/scripts/plot/ezsurf.m
--- a/scripts/plot/ezsurf.m
+++ b/scripts/plot/ezsurf.m
@@ -16,17 +16,17 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} ezsurf (@var{f})
 ## @deftypefnx {Function File} {} ezsurf (@var{fx}, @var{fy}, @var{fz})
 ## @deftypefnx {Function File} {} ezsurf (@dots{}, @var{dom})
 ## @deftypefnx {Function File} {} ezsurf (@dots{}, @var{n})
-## @deftypefnx {Function File} {} ezsurf (@dots{}, 'circ')
+## @deftypefnx {Function File} {} ezsurf (@dots{}, "circ")
 ## @deftypefnx {Function File} {} ezsurf (@var{h}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} ezsurf (@dots{})
 ##
 ## Plot the surface defined by a function.  @var{f} is a string, inline
 ## function or function handle with two arguments defining the function.  By
 ## default the plot is over the domain @code{-2*pi < @var{x} < 2*pi} and
 ## @code{-2*pi < @var{y} < 2*pi} with 60 points in each dimension.
 ##
@@ -36,36 +36,36 @@
 ## separately.
 ##
 ## @var{n} is a scalar defining the number of points to use in each dimension.
 ##
 ## If three functions are passed, then plot the parametrically defined
 ## function @code{[@var{fx} (@var{s}, @var{t}), @var{fy} (@var{s}, @var{t}),
 ## @var{fz} (@var{s}, @var{t})]}.
 ##
-## If the argument 'circ' is given, then the function is plotted over a disk
+## If the argument "circ" is given, then the function is plotted over a disk
 ## centered on the middle of the domain @var{dom}.
 ##
 ## The optional return value @var{h} is a graphics handle to the created
 ## surface object.
 ##
 ## @example
 ## @group
-## f = @@(x,y) sqrt(abs(x .* y)) ./ (1 + x.^2 + y.^2);
+## f = @@(x,y) sqrt (abs (x .* y)) ./ (1 + x.^2 + y.^2);
 ## ezsurf (f, [-3, 3]);
 ## @end group
 ## @end example
 ##
 ## An example of a parametrically defined function is
 ##
 ## @example
 ## @group
-## fx = @@(s,t) cos (s) .* cos(t);
-## fy = @@(s,t) sin (s) .* cos(t);
-## fz = @@(s,t) sin(t);
+## fx = @@(s,t) cos (s) .* cos (t);
+## fy = @@(s,t) sin (s) .* cos (t);
+## fz = @@(s,t) sin (t);
 ## ezsurf (fx, fy, fz, [-pi, pi, -pi/2, pi/2], 20);
 ## @end group
 ## @end example
 ##
 ## @seealso{ezplot, ezmesh, ezsurfc, ezmeshc}
 ## @end deftypefn
 
 function retval = ezsurf (varargin)
diff --git a/scripts/plot/ezsurfc.m b/scripts/plot/ezsurfc.m
--- a/scripts/plot/ezsurfc.m
+++ b/scripts/plot/ezsurfc.m
@@ -16,17 +16,17 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} ezsurfc (@var{f})
 ## @deftypefnx {Function File} {} ezsurfc (@var{fx}, @var{fy}, @var{fz})
 ## @deftypefnx {Function File} {} ezsurfc (@dots{}, @var{dom})
 ## @deftypefnx {Function File} {} ezsurfc (@dots{}, @var{n})
-## @deftypefnx {Function File} {} ezsurfc (@dots{}, 'circ')
+## @deftypefnx {Function File} {} ezsurfc (@dots{}, "circ")
 ## @deftypefnx {Function File} {} ezsurfc (@var{h}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} ezsurfc (@dots{})
 ##
 ## Plot the surface and contour lines defined by a function.  @var{f} is a
 ## string, inline function or function handle with two arguments defining the
 ## function.  By default the plot is over the domain @code{-2*pi < @var{x} <
 ## 2*pi} and @code{-2*pi < @var{y} < 2*pi} with 60 points in each dimension.
 ##
@@ -36,26 +36,26 @@
 ## separately.
 ##
 ## @var{n} is a scalar defining the number of points to use in each dimension.
 ##
 ## If three functions are passed, then plot the parametrically defined
 ## function @code{[@var{fx} (@var{s}, @var{t}), @var{fy} (@var{s}, @var{t}),
 ## @var{fz} (@var{s}, @var{t})]}.
 ##
-## If the argument 'circ' is given, then the function is plotted over a disk
+## If the argument "circ" is given, then the function is plotted over a disk
 ## centered on the middle of the domain @var{dom}.
 ##
 ## The optional return value @var{h} is a 2-element vector with a graphics
 ## for the created surface plot and a second handle for the created contour
 ## plot.
 ##
 ## @example
 ## @group
-## f = @@(x,y) sqrt(abs(x .* y)) ./ (1 + x.^2 + y.^2);
+## f = @@(x,y) sqrt (abs (x .* y)) ./ (1 + x.^2 + y.^2);
 ## ezsurfc (f, [-3, 3]);
 ## @end group
 ## @end example
 ##
 ## @seealso{ezplot, ezmeshc, ezsurf, ezmesh}
 ## @end deftypefn
 
 function retval = ezsurfc (varargin)
diff --git a/scripts/plot/feather.m b/scripts/plot/feather.m
--- a/scripts/plot/feather.m
+++ b/scripts/plot/feather.m
@@ -31,18 +31,18 @@
 ## The style to use for the plot can be defined with a line style @var{style}
 ## in a similar manner to the line styles used with the @code{plot} command.
 ##
 ## The optional return value @var{h} is a vector of graphics handles to the
 ## line objects representing the drawn vectors.
 ##
 ## @example
 ## @group
-## phi = [0 : 15 : 360] * pi / 180;
-## feather (sin (phi), cos (phi))
+## phi = [0 : 15 : 360] * pi/180;
+## feather (sin (phi), cos (phi));
 ## @end group
 ## @end example
 ##
 ## @seealso{plot, quiver, compass}
 ## @end deftypefn
 
 function retval = feather (varargin)
 
diff --git a/scripts/plot/figure.m b/scripts/plot/figure.m
--- a/scripts/plot/figure.m
+++ b/scripts/plot/figure.m
@@ -12,18 +12,20 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {} figure (@var{n})
-## @deftypefnx {Function File} {} figure (@var{n}, @var{property}, @var{value}, @dots{})
+## @deftypefn  {Command} {} figure
+## @deftypefnx {Command} {} figure @var{n}
+## @deftypefnx {Function File} {} figure (@var{n})
+## @deftypefnx {Function File} {} figure (@var{n}, "@var{property}", @var{value}, @dots{})
 ## Set the current plot window to plot window @var{n}.  If no arguments are
 ## specified, the next available window number is chosen.
 ##
 ## Multiple property-value pairs may be specified for the figure, but they
 ## must appear in pairs.
 ## @end deftypefn
 
 ## Author: jwe, Bill Denney
@@ -32,16 +34,19 @@ function h = figure (varargin)
 
   nargs = nargin;
 
   f = NaN;
 
   init_new_figure = false;
   if (mod (nargs, 2) == 1)
     tmp = varargin{1};
+    if (ischar (tmp))
+      tmp = str2double (tmp);
+    endif
     if (isfigure (tmp))
       f = tmp;
       varargin(1) = [];
       nargs--;
     elseif (isnumeric (tmp) && tmp > 0 && tmp == fix (tmp))
       f = tmp;
       init_new_figure = true;
       varargin(1) = [];
@@ -49,54 +54,55 @@ function h = figure (varargin)
     else
       error ("figure: expecting figure handle or figure number");
     endif
   endif
 
   ## Check to see if we already have a figure on the screen.  If we do,
   ## then update it if it is different from the figure we are creating
   ## or switching to.
-  cf = get (0, "currentfigure");
+  cf = get (0, "currentfigure");   # Can't use gcf() because it calls figure()
   if (! isempty (cf) && cf != 0)
     if (isnan (f) || cf != f)
       drawnow ();
     endif
   endif
 
   if (rem (nargs, 2) == 0)
     if (isnan (f) || init_new_figure)
       if (ismac () && strcmp (graphics_toolkit (), "fltk"))
-        ## FIXME - Hack for fltk-aqua to work around bug # 31931
+        ## FIXME - Hack for fltk-aqua to work around bug #31931
         f = __go_figure__ (f);
         drawnow ();
         if (! isempty (varargin))
           set (f, varargin{:});
         endif
       else
         f = __go_figure__ (f, varargin{:});
       endif
     elseif (nargs > 0)
       set (f, varargin{:});
     endif
     set (0, "currentfigure", f);
   else
     print_usage ();
   endif
 
-  cf = get (0, "currentfigure");
-  if (strcmp (get (cf, "__graphics_toolkit__"), "fltk"))
-    __add_default_menu__ (cf);
+  if (strcmp (get (f, "__graphics_toolkit__"), "fltk"))
+    __add_default_menu__ (f);
   endif
 
   if (nargout > 0)
     h = f;
   endif
 
 endfunction
 
+
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   assert (gcf, hf);
 %!   assert (isfigure (hf));
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
+
diff --git a/scripts/plot/findobj.m b/scripts/plot/findobj.m
--- a/scripts/plot/findobj.m
+++ b/scripts/plot/findobj.m
@@ -14,54 +14,54 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{h} =} findobj ()
 ## @deftypefnx {Function File} {@var{h} =} findobj (@var{prop_name}, @var{prop_value})
-## @deftypefnx {Function File} {@var{h} =} findobj ('-property', @var{prop_name})
-## @deftypefnx {Function File} {@var{h} =} findobj ('-regexp', @var{prop_name}, @var{pattern})
-## @deftypefnx {Function File} {@var{h} =} findobj ('flat', @dots{})
+## @deftypefnx {Function File} {@var{h} =} findobj ("-property", @var{prop_name})
+## @deftypefnx {Function File} {@var{h} =} findobj ("-regexp", @var{prop_name}, @var{pattern})
+## @deftypefnx {Function File} {@var{h} =} findobj ("flat", @dots{})
 ## @deftypefnx {Function File} {@var{h} =} findobj (@var{h}, @dots{})
-## @deftypefnx {Function File} {@var{h} =} findobj (@var{h}, '-depth', @var{d}, @dots{})
+## @deftypefnx {Function File} {@var{h} =} findobj (@var{h}, "-depth", @var{d}, @dots{})
 ## Find graphics object with specified property values.  The simplest form is
 ##
 ## @example
-## findobj (@var{prop_name}, @var{prop_Value})
+## findobj (@var{prop_name}, @var{prop_value})
 ## @end example
 ##
 ## @noindent
 ## which returns all of the handles to the objects with the name
-## @var{prop_name} and the name @var{prop_Value}.  The search can be limited
+## @var{prop_name} and the name @var{prop_value}.  The search can be limited
 ## to a particular object or set of objects and their descendants by
 ## passing a handle or set of handles @var{h} as the first argument to
 ## @code{findobj}.
 ##
 ## The depth of hierarchy of objects to which to search to can be limited
-## with the '-depth' argument.  To limit the number depth of the hierarchy
+## with the "-depth" argument.  To limit the number depth of the hierarchy
 ## to search to @var{d} generations of children, and example is
 ##
 ## @example
-## findobj (@var{h}, '-depth', @var{d}, @var{prop_Name}, @var{prop_Value})
+## findobj (@var{h}, "-depth", @var{d}, @var{prop_name}, @var{prop_value})
 ## @end example
 ##
 ## Specifying a depth @var{d} of 0, limits the search to the set of object
-## passed in @var{h}.  A depth @var{d} of 0 is equivalent to the '-flat'
+## passed in @var{h}.  A depth @var{d} of 0 is equivalent to the "-flat"
 ## argument.
 ##
-## A specified logical operator may be applied to the pairs of @var{prop_Name}
-## and @var{prop_Value}.  The supported logical operators are '-and', '-or',
-## '-xor', '-not'.
+## A specified logical operator may be applied to the pairs of @var{prop_name}
+## and @var{prop_value}.  The supported logical operators are "-and", "-or",
+## "-xor", "-not".
 ##
 ## The objects may also be matched by comparing a regular expression to the
 ## property values, where property values that match @code{regexp
-## (@var{prop_Value}, @var{pattern})} are returned.  Finally, objects may be
-## matched by property name only, using the '-property' option.
+## (@var{prop_value}, @var{pattern})} are returned.  Finally, objects may be
+## matched by property name only, using the "-property" option.
 ## @seealso{get, set}
 ## @end deftypefn
 
 ## Author: Ben Abbott <bpabbott@mac.com>
 
 function h = findobj (varargin)
 
   depth = NaN;
diff --git a/scripts/plot/fplot.m b/scripts/plot/fplot.m
--- a/scripts/plot/fplot.m
+++ b/scripts/plot/fplot.m
@@ -28,18 +28,18 @@
 ## @code{[@var{xlo}, @var{xhi}]} or @code{[@var{xlo}, @var{xhi},
 ## @var{ylo}, @var{yhi}]}.  @var{tol} is the default tolerance to use for the
 ## plot, and if @var{tol} is an integer it is assumed that it defines the
 ## number points to use in the plot.  The @var{fmt} argument is passed
 ## to the plot command.
 ##
 ## @example
 ## @group
-##    fplot ("cos", [0, 2*pi])
-##    fplot ("[cos(x), sin(x)]", [0, 2*pi])
+## fplot ("cos", [0, 2*pi])
+## fplot ("[cos(x), sin(x)]", [0, 2*pi])
 ## @end group
 ## @end example
 ## @seealso{plot}
 ## @end deftypefn
 
 ## Author: Paul Kienzle <pkienzle@users.sf.net>
 
 function fplot (fn, limits, n, fmt)
diff --git a/scripts/plot/gca.m b/scripts/plot/gca.m
--- a/scripts/plot/gca.m
+++ b/scripts/plot/gca.m
@@ -45,16 +45,18 @@ function h = gca ()
       h = axes ();
     endif
   else
     print_usage ();
   endif
 
 endfunction
 
+
 %!test
 %! hf = figure ("visible", "off");
 %! ax = axes;
 %! unwind_protect
 %!   assert (gca, ax);
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
+
diff --git a/scripts/plot/gcbf.m b/scripts/plot/gcbf.m
--- a/scripts/plot/gcbf.m
+++ b/scripts/plot/gcbf.m
@@ -27,10 +27,11 @@
 ##@end deftypefn
 
 function fig = gcbf ()
 
   [dummy, fig] = gcbo ();
 
 endfunction
 
-%!test
-%! assert (isempty (gcbf ));
+
+%!assert (isempty (gcbf))
+
diff --git a/scripts/plot/gcbo.m b/scripts/plot/gcbo.m
--- a/scripts/plot/gcbo.m
+++ b/scripts/plot/gcbo.m
@@ -37,10 +37,12 @@ function [h, fig] = gcbo ()
   fig = [];
 
   if (! isempty (h) && nargout > 1)
     fig = ancestor (h, "figure");
   endif
 
 endfunction
 
+
 %!test
-%! assert (isempty (gcbo ));
+%! assert (isempty (gcbo));
+
diff --git a/scripts/plot/gcf.m b/scripts/plot/gcf.m
--- a/scripts/plot/gcf.m
+++ b/scripts/plot/gcf.m
@@ -49,15 +49,17 @@ function h = gcf ()
       h = figure (1);
     endif
   else
     print_usage ();
   endif
 
 endfunction
 
+
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   assert (gcf, hf);
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
+
diff --git a/scripts/plot/ginput.m b/scripts/plot/ginput.m
--- a/scripts/plot/ginput.m
+++ b/scripts/plot/ginput.m
@@ -38,11 +38,13 @@ function varargout = ginput (n)
   if (nargin == 0)
     [varargout{:}] = feval (strcat ("__", toolkit, "_ginput__"), f);
   else
     [varargout{:}] = feval (strcat ("__", toolkit, "_ginput__"), f, n);
   endif
 
 endfunction
 
+
 ## Remove from test statistics.  No real tests possible.
 %!test
 %! assert (1);
+
diff --git a/scripts/plot/graphics_toolkit.m b/scripts/plot/graphics_toolkit.m
--- a/scripts/plot/graphics_toolkit.m
+++ b/scripts/plot/graphics_toolkit.m
@@ -78,18 +78,18 @@ endfunction
 %!   assert (get (0, "defaultfigure__graphics_toolkit__"), toolkit);
 %!   graphics_toolkit (hf, "fltk"); 
 %!   assert (get (hf, "__graphics_toolkit__"), "fltk");
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
 
 %!testif HAVE_FLTK
-%!  old_toolkit = graphics_toolkit ();
-%!  switch old_toolkit
-%!    case {"gnuplot"}
-%!      new_toolkit = "fltk";
-%!    otherwise
-%!      new_toolkit = "gnuplot";
-%!  endswitch
-%!  assert (graphics_toolkit (new_toolkit), old_toolkit)
-%!  assert (graphics_toolkit (old_toolkit), new_toolkit)
+%! old_toolkit = graphics_toolkit ();
+%! switch old_toolkit
+%!   case {"gnuplot"}
+%!     new_toolkit = "fltk";
+%!   otherwise
+%!     new_toolkit = "gnuplot";
+%! endswitch
+%! assert (graphics_toolkit (new_toolkit), old_toolkit);
+%! assert (graphics_toolkit (old_toolkit), new_toolkit);
 
diff --git a/scripts/plot/gtext.m b/scripts/plot/gtext.m
--- a/scripts/plot/gtext.m
+++ b/scripts/plot/gtext.m
@@ -39,11 +39,12 @@ function gtext (s, varargin)
 
   if (! isempty (s))
     [x, y] = ginput (1);
     text (x, y, s, varargin{:});
   endif
 
 endfunction
 
+
 ## Remove from test statistics.  No real tests possible.
-%!test
-%! assert (1);
+%!assert (1)
+
diff --git a/scripts/plot/hggroup.m b/scripts/plot/hggroup.m
--- a/scripts/plot/hggroup.m
+++ b/scripts/plot/hggroup.m
@@ -37,17 +37,19 @@ function h = hggroup (varargin)
   tmp = __go_hggroup__ (ax, varargin{:});
 
   if (nargout > 0)
     h = tmp;
   endif
 
 endfunction
 
+
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   h = hggroup;
 %!   assert (findobj (hf, "type", "hggroup"), h);
 %!   assert (get (h, "type"), "hggroup");
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
+
diff --git a/scripts/plot/hidden.m b/scripts/plot/hidden.m
--- a/scripts/plot/hidden.m
+++ b/scripts/plot/hidden.m
@@ -16,17 +16,17 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} hidden (@var{mode})
 ## @deftypefnx {Function File} {} hidden ()
 ## Manipulation the mesh hidden line removal.  Called with no argument
 ## the hidden line removal is toggled.  The argument @var{mode} can be either
-## 'on' or 'off' and the set of the hidden line removal is set accordingly.
+## "on" or "off" and the set of the hidden line removal is set accordingly.
 ## @seealso{mesh, meshc, surf}
 ## @end deftypefn
 
 function retval = hidden (mode)
 
   if (nargin == 0)
     mode = "swap";
   elseif (nargin == 1);
diff --git a/scripts/plot/hist.m b/scripts/plot/hist.m
--- a/scripts/plot/hist.m
+++ b/scripts/plot/hist.m
@@ -46,27 +46,27 @@
 ## that @code{bar (@var{xx}, @var{nn})} will plot the histogram.
 ##
 ## The histogram's appearance may be modified by specifying property/value
 ## pairs, @var{prop} and @var{val} pairs.  For example the face and edge
 ## color may be modified.
 ##
 ## @example
 ## @group
-## hist (randn (1, 100), 25, "facecolor", "r", "edgecolor", "b")
+## hist (randn (1, 100), 25, "facecolor", "r", "edgecolor", "b");
 ## @end group
 ## @end example
 ##
 ## @noindent
 ## The histograms colors also depend upon the colormap.
 ##
 ## @example
 ## @group
-## hist (rand (10, 3))
-## colormap (summer ())
+## hist (rand (10, 3));
+## colormap (summer ());
 ## @end group
 ## @end example
 ##
 ## @seealso{bar}
 ## @end deftypefn
 
 ## Author: jwe
 
@@ -163,35 +163,36 @@ function [nn, xx] = hist (y, varargin)
   elseif (size (freq, 2) != 1)
     bar (x, freq, 0.8, varargin{iarg:end});
   else
     bar (x, freq, 1.0, varargin{iarg:end});
   endif
 
 endfunction
 
+
 %!test
-%!  [nn,xx]=hist([1:4],3);
-%!  assert(xx, [1.5,2.5,3.5]);
-%!  assert(nn, [2,1,1]);
+%! [nn,xx] = hist ([1:4], 3);
+%! assert (xx, [1.5,2.5,3.5]);
+%! assert (nn, [2,1,1]);
 %!test
-%!  [nn,xx]=hist([1:4]',3);
-%!  assert(xx, [1.5,2.5,3.5]);
-%!  assert(nn, [2,1,1]);
+%! [nn,xx] = hist ([1:4]', 3);
+%! assert (xx, [1.5,2.5,3.5]);
+%! assert (nn, [2,1,1]);
 %!test
-%!  [nn,xx]=hist([1 1 1 NaN NaN NaN 2 2 3],[1 2 3]);
-%!  assert(xx, [1,2,3]);
-%!  assert(nn, [3,2,1]);
+%! [nn,xx] = hist ([1 1 1 NaN NaN NaN 2 2 3],[1 2 3]);
+%! assert (xx, [1,2,3]);
+%! assert (nn, [3,2,1]);
 %!test
-%!  [nn,xx]=hist([[1:4]',[1:4]'],3);
-%!  assert(xx, [1.5;2.5;3.5]);
-%!  assert(nn, [[2,1,1]',[2,1,1]']);
-%!assert(hist(1,1),1);
+%! [nn,xx] = hist ([[1:4]', [1:4]'], 3);
+%! assert (xx, [1.5;2.5;3.5]);
+%! assert (nn, [[2,1,1]',[2,1,1]']);
 %!test
-%!  for n = [10, 30, 100, 1000]
-%!    assert(sum(hist([1:n], n)), n);
-%!    assert(sum(hist([1:n], [2:n-1])), n);
-%!    assert(sum(hist([1:n], [1:n])), n);
-%!    assert(sum(hist([1:n], 29)), n);
-%!    assert(sum(hist([1:n], 30)), n);
-%!  endfor
-%!test
-%!  assert (size (hist(randn(750,240), 200)), [200,240]);
+%! for n = [10, 30, 100, 1000]
+%!   assert (sum (hist ([1:n], n)), n);
+%!   assert (sum (hist ([1:n], [2:n-1])), n);
+%!   assert (sum (hist ([1:n], [1:n])), n);
+%!   assert (sum (hist ([1:n], 29)), n);
+%!   assert (sum (hist ([1:n], 30)), n);
+%! endfor
+%!assert (hist (1,1), 1)
+%!assert (size (hist (randn (750,240), 200)), [200,240])
+
diff --git a/scripts/plot/hold.m b/scripts/plot/hold.m
--- a/scripts/plot/hold.m
+++ b/scripts/plot/hold.m
@@ -15,17 +15,17 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Command} {} hold
 ## @deftypefnx {Command} {} hold @var{state}
 ## @deftypefnx {Function File} {} hold (@var{hax}, @dots{})
-## Toggle or set the 'hold' state of the plotting engine which determines
+## Toggle or set the "hold" state of the plotting engine which determines
 ## whether new graphic objects are added to the plot or replace the existing
 ## objects.
 ##
 ## @table @code
 ## @item hold on
 ## Retain plot data and settings so that subsequent plot commands are displayed
 ## on a single graph.
 ##
@@ -34,23 +34,23 @@
 ## plot commands are displayed on a single graph with the next line color and
 ## style.
 ##
 ## @item hold off
 ## Clear plot and restore default graphics settings before each new plot
 ## command.  (default).
 ##
 ## @item hold
-## Toggle the current 'hold' state.
+## Toggle the current hold state.
 ## @end table
 ##
 ## When given the additional argument @var{hax}, the hold state is modified
 ## only for the given axis handle.
 ##
-## To query the current 'hold' state use the @code{ishold} function.
+## To query the current hold state use the @code{ishold} function.
 ## @seealso{ishold, cla, newplot, clf}
 ## @end deftypefn
 
 function hold (varargin)
 
   if (nargin > 0 && numel (varargin{1}) == 1 && ishandle (varargin{1})
       && strcmp (get (varargin{1}, "type"), "axes"))
     [ax, varargin, nargs] = __plt_get_axis_arg__ ("hold", varargin{:});
@@ -131,48 +131,48 @@ endfunction
 %!demo
 %! clf;
 %! colormap ('default');
 %! t = linspace (-3, 3, 50);
 %! [x, y] = meshgrid (t, t);
 %! z = peaks (x, y);
 %! contourf (x, y, z, 10);
 %! hold on;
-%! plot (vec (x), vec (y), '^');
+%! plot (x(:), y(:), '^');
 %! patch ([-1.0 1.0 1.0 -1.0 -1.0], [-1.0 -1.0 1.0 1.0 -1.0], 'red');
 %! xlim ([-2.0 2.0]);
 %! ylim ([-2.0 2.0]);
 %! colorbar ('SouthOutside');
 %! title ('Test script for some plot functions');
 
 ##hold on
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   p = plot ([0 1]);
 %!   assert (! ishold);
 %!   hold on;
 %!   assert (ishold);
-%!   p1 = fill ([0 1 1], [0 0 1],"black");
+%!   p1 = fill ([0 1 1], [0 0 1], "black");
 %!   p2 = fill ([0 1 0], [0 1 1], "red");
 %!   assert (length (get (hf, "children")), 1);
 %!   assert (length (get (gca, "children")), 3);
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
 
 ##hold off
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   p = plot ([0 1]);
 %!   assert (! ishold);
 %!   hold on;
 %!   assert (ishold);
-%!   p1 = fill ([0 1 1], [0 0 1],"black");
+%!   p1 = fill ([0 1 1], [0 0 1], "black");
 %!   hold off;
 %!   p2 = fill ([0 1 0], [0 1 1], "red");
 %!   assert (length (get (hf, "children")), 1);
 %!   assert (length (get (gca, "children")), 1);
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
 
diff --git a/scripts/plot/isfigure.m b/scripts/plot/isfigure.m
--- a/scripts/plot/isfigure.m
+++ b/scripts/plot/isfigure.m
@@ -30,16 +30,18 @@ function retval = isfigure (h)
   if (nargin == 1)
     retval = (ishandle (h) && strcmp (get (h, "type"), "figure"));
   else
     print_usage ();
   endif
 
 endfunction
 
+
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   assert (isfigure (hf));
-%!   assert (!isfigure (-hf));
+%!   assert (! isfigure (-hf));
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
+
diff --git a/scripts/plot/ishghandle.m b/scripts/plot/ishghandle.m
--- a/scripts/plot/ishghandle.m
+++ b/scripts/plot/ishghandle.m
@@ -22,38 +22,39 @@
 ## @end deftypefn
 
 function retval = ishghandle (h)
   ## This function is just included for compatibility as Octave has
   ## no simulink equivalent.
   retval = ishandle (h);
 endfunction
 
+
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   assert (ishghandle (hf));
-%!   assert (!ishghandle (-hf));
+%!   assert (! ishghandle (-hf));
 %!   l = line;
-%!   ax = gca();
+%!   ax = gca;
 %!   assert (ishghandle (ax));
-%!   assert (!ishghandle (-ax));
+%!   assert (! ishghandle (-ax));
 %!   assert (ishghandle (l));
-%!   assert (!ishghandle (-l));
+%!   assert (! ishghandle (-l));
 %!   p = patch;
 %!   assert (ishghandle (p));
-%!   assert (!ishghandle (-p));
+%!   assert (! ishghandle (-p));
 %!   s = surface;
 %!   assert (ishghandle (s));
-%!   assert (!ishghandle (-s));
+%!   assert (! ishghandle (-s));
 %!   t = text;
 %!   assert (ishghandle (t));
-%!   assert (!ishghandle (-t));
+%!   assert (! ishghandle (-t));
 %!   i = image;
 %!   assert (ishghandle (i));
-%!   assert (!ishghandle (-i));
+%!   assert (! ishghandle (-i));
 %!   hg = hggroup;
 %!   assert (ishghandle (hg));
-%!   assert (!ishghandle (-hg));
+%!   assert (! ishghandle (-hg));
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
 
diff --git a/scripts/plot/ishold.m b/scripts/plot/ishold.m
--- a/scripts/plot/ishold.m
+++ b/scripts/plot/ishold.m
@@ -50,30 +50,32 @@ function retval = ishold (h)
     print_usage ();
   endif
 
   retval = (strcmpi (get (fig, "nextplot"), "add")
             && ! isempty (ax) && strcmpi (get (ax, "nextplot"), "add"));
 
 endfunction
 
+
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
-%!   assert (!ishold);
+%!   assert (! ishold);
 %!   assert (isempty (get (hf, "currentaxes")));
 %!   assert (get (hf, "NextPlot"), "add");
 %!   l = plot ([0 1]);
-%!   assert (!ishold);
-%!   assert (!ishold (gca));
+%!   assert (! ishold);
+%!   assert (! ishold (gca));
 %!   assert (get (gca, "NextPlot"), "replace");
 %!   assert (get (hf, "NextPlot"), "add");
 %!   hold;
 %!   assert (ishold);
 %!   assert (ishold (gca));
 %!   assert (get (gca, "NextPlot"), "add");
 %!   assert (get (hf, "NextPlot"), "add");
 %!   p = fill ([0 1 1], [0 0 1],"black");
 %!   assert (length (get (hf, "children")), 1);
 %!   assert (length (get (gca, "children")), 2);
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
+
diff --git a/scripts/plot/isocolors.m b/scripts/plot/isocolors.m
--- a/scripts/plot/isocolors.m
+++ b/scripts/plot/isocolors.m
@@ -45,53 +45,53 @@
 ## data @var{v}.  Finally, if no output argument is given then directly
 ## change the colors of a patch that is given by the patch handle
 ## @var{p}.
 ##
 ## For example:
 ##
 ## @example
 ## function [] = isofinish (p)
-##   set (gca, "PlotBoxAspectRatioMode", "manual", \
-##        "PlotBoxAspectRatio", [1 1 1]);
+##   set (gca, "PlotBoxAspectRatioMode", "manual", ...
+##             "PlotBoxAspectRatio", [1 1 1]);
 ##   set (p, "FaceColor", "interp");
 ##   ## set (p, "FaceLighting", "flat");
 ##   ## light ("Position", [1 1 5]); ## Available with JHandles
 ## endfunction
 ##
-## N = 15;    ## Increase number of vertices in each direction
-## iso = .4;  ## Change isovalue to .1 to display a sphere
+## N = 15;    # Increase number of vertices in each direction
+## iso = .4;  # Change isovalue to .1 to display a sphere
 ## lin = linspace (0, 2, N);
 ## [x, y, z] = meshgrid (lin, lin, lin);
 ## c = abs ((x-.5).^2 + (y-.5).^2 + (z-.5).^2);
-## figure (); ## Open another figure window
+## figure (); # Open another figure window
 ##
-## subplot (2, 2, 1); view (-38, 20);
+## subplot (2,2,1); view (-38, 20);
 ## [f, v] = isosurface (x, y, z, c, iso);
 ## p = patch ("Faces", f, "Vertices", v, "EdgeColor", "none");
-## cdat = rand (size (c));       ## Compute random patch color data
-## isocolors (x, y, z, cdat, p); ## Directly set colors of patch
-## isofinish (p);                ## Call user function isofinish
+## cdat = rand (size (c));       # Compute random patch color data
+## isocolors (x, y, z, cdat, p); # Directly set colors of patch
+## isofinish (p);                # Call user function isofinish
 ##
-## subplot (2, 2, 2); view (-38, 20);
+## subplot (2,2,2); view (-38, 20);
 ## p = patch ("Faces", f, "Vertices", v, "EdgeColor", "none");
 ## [r, g, b] = meshgrid (lin, 2-lin, 2-lin);
-## cdat = isocolors (x, y, z, c, v); ## Compute color data vertices
-## set (p, "FaceVertexCData", cdat); ## Set color data manually
+## cdat = isocolors (x, y, z, c, v); # Compute color data vertices
+## set (p, "FaceVertexCData", cdat); # Set color data manually
 ## isofinish (p);
 ##
-## subplot (2, 2, 3); view (-38, 20);
+## subplot (2,2,3); view (-38, 20);
 ## p = patch ("Faces", f, "Vertices", v, "EdgeColor", "none");
-## cdat = isocolors (r, g, b, c, p); ## Compute color data patch
-## set (p, "FaceVertexCData", cdat); ## Set color data manually
+## cdat = isocolors (r, g, b, c, p); # Compute color data patch
+## set (p, "FaceVertexCData", cdat); # Set color data manually
 ## isofinish (p);
 ##
-## subplot (2, 2, 4); view (-38, 20);
+## subplot (2,2,4); view (-38, 20);
 ## p = patch ("Faces", f, "Vertices", v, "EdgeColor", "none");
-## r = g = b = repmat ([1:N] / N, [N, 1, N]); ## Black to white
+## r = g = b = repmat ([1:N] / N, [N, 1, N]); # Black to white
 ## cdat = isocolors (x, y, z, r, g, b, v);
 ## set (p, "FaceVertexCData", cdat);
 ## isofinish (p);
 ## @end example
 ##
 ## @seealso{isosurface, isonormals}
 ##
 ## @end deftypefn
@@ -158,15 +158,17 @@ function varargout = isocolors(varargin)
       endif
     case 1
       varargout = {new_col};
     otherwise
       print_usage ();
   endswitch
 endfunction
 
+
 %!test
-%!  [x, y, z] = meshgrid (0:.5:2, 0:.5:2, 0:.5:2);
-%!  c = (x-.5).^2 + (y-.5).^2 + (z-.5).^2;
-%!  [f, v] = isosurface (x, y, z, c, .4);
-%!  cdat = isocolors (x, y, z, c, v);
-%!  assert (size (cdat, 1) == size (v, 1));
+%! [x, y, z] = meshgrid (0:.5:2, 0:.5:2, 0:.5:2);
+%! c = (x-.5).^2 + (y-.5).^2 + (z-.5).^2;
+%! [f, v] = isosurface (x, y, z, c, .4);
+%! cdat = isocolors (x, y, z, c, v);
+%! assert (rows (cdat) == rows (v));
 ## Can't create a patch handle for tests without a figure
+
diff --git a/scripts/plot/isonormals.m b/scripts/plot/isonormals.m
--- a/scripts/plot/isonormals.m
+++ b/scripts/plot/isonormals.m
@@ -45,51 +45,51 @@
 ## given by the patch handle @var{p}.
 ##
 ## For example:
 ## @c Set example in small font to prevent overfull line
 ##
 ## @smallexample
 ## function [] = isofinish (p)
 ##   set (gca, "PlotBoxAspectRatioMode", "manual", ...
-##             "PlotBoxAspectRatio",[1 1 1]);
-##   set (p, "VertexNormals", -get(p,"VertexNormals")); # Revert normals
+##             "PlotBoxAspectRatio", [1 1 1]);
+##   set (p, "VertexNormals", -get (p,"VertexNormals")); # Revert normals
 ##   set (p, "FaceColor", "interp");
 ##   ## set (p, "FaceLighting", "phong");
 ##   ## light ("Position", [1 1 5]); # Available with JHandles
 ## endfunction
 ##
 ## N = 15;    # Increase number of vertices in each direction
 ## iso = .4;  # Change isovalue to .1 to display a sphere
 ## lin = linspace (0, 2, N);
 ## [x, y, z] = meshgrid (lin, lin, lin);
 ## c = abs ((x-.5).^2 + (y-.5).^2 + (z-.5).^2);
 ## figure (); # Open another figure window
 ##
-## subplot (2, 2, 1); view (-38, 20);
+## subplot (2,2,1); view (-38, 20);
 ## [f, v, cdat] = isosurface (x, y, z, c, iso, y);
-## p = patch ("Faces", f, "Vertices", v, "FaceVertexCData", cdat, \
+## p = patch ("Faces", f, "Vertices", v, "FaceVertexCData", cdat, ...
 ##            "FaceColor", "interp", "EdgeColor", "none");
 ## isofinish (p); ## Call user function isofinish
 ##
-## subplot (2, 2, 2); view (-38, 20);
-## p = patch ("Faces", f, "Vertices", v, "FaceVertexCData", cdat, \
+## subplot (2,2,2); view (-38, 20);
+## p = patch ("Faces", f, "Vertices", v, "FaceVertexCData", cdat, ...
 ##            "FaceColor", "interp", "EdgeColor", "none");
 ## isonormals (x, y, z, c, p); # Directly modify patch
 ## isofinish (p);
 ##
-## subplot (2, 2, 3); view (-38, 20);
-## p = patch ("Faces", f, "Vertices", v, "FaceVertexCData", cdat, \
+## subplot (2,2,3); view (-38, 20);
+## p = patch ("Faces", f, "Vertices", v, "FaceVertexCData", cdat, ...
 ##            "FaceColor", "interp", "EdgeColor", "none");
 ## n = isonormals (x, y, z, c, v); # Compute normals of isosurface
 ## set (p, "VertexNormals", n);    # Manually set vertex normals
 ## isofinish (p);
 ##
-## subplot (2, 2, 4); view (-38, 20);
-## p = patch ("Faces", f, "Vertices", v, "FaceVertexCData", cdat, \
+## subplot (2,2,4); view (-38, 20);
+## p = patch ("Faces", f, "Vertices", v, "FaceVertexCData", cdat, ...
 ##            "FaceColor", "interp", "EdgeColor", "none");
 ## isonormals (x, y, z, c, v, "negate"); # Use reverse directly
 ## isofinish (p);
 ## @end smallexample
 ##
 ## @seealso{isosurface, isocolors}
 ## @end deftypefn
 
@@ -143,21 +143,23 @@ function varargout = isonormals(varargin
       endif
     case 1
       varargout = {normals};
     otherwise
       print_usage ();
   endswitch
 endfunction
 
+
 %!test
-%!  [x, y, z] = meshgrid (0:.5:2, 0:.5:2, 0:.5:2);
-%!  c = abs ((x-.5).^2 + (y-.5).^2 + (z-.5).^2);
-%!  [f, v, cdat] = isosurface (x, y, z, c, .4, y);
-%!  n = isonormals (x, y, z, c, v);
-%!  assert (size (v), size (n));
+%! [x, y, z] = meshgrid (0:.5:2, 0:.5:2, 0:.5:2);
+%! c = abs ((x-.5).^2 + (y-.5).^2 + (z-.5).^2);
+%! [f, v, cdat] = isosurface (x, y, z, c, .4, y);
+%! n = isonormals (x, y, z, c, v);
+%! assert (size (v), size (n));
 %!test
-%!  [x, y, z] = meshgrid (0:.5:2, 0:.5:2, 0:.5:2);
-%!  c = abs ((x-.5).^2 + (y-.5).^2 + (z-.5).^2);
-%!  [f, v, cdat] = isosurface (x, y, z, c, .4, y);
-%!  np = isonormals (x, y, z, c, v);
-%!  nn = isonormals (x, y, z, c, v, "negate");
-%!  assert (all (np == -nn));
+%! [x, y, z] = meshgrid (0:.5:2, 0:.5:2, 0:.5:2);
+%! c = abs ((x-.5).^2 + (y-.5).^2 + (z-.5).^2);
+%! [f, v, cdat] = isosurface (x, y, z, c, .4, y);
+%! np = isonormals (x, y, z, c, v);
+%! nn = isonormals (x, y, z, c, v, "negate");
+%! assert (np, -nn);
+
diff --git a/scripts/plot/isosurface.m b/scripts/plot/isosurface.m
--- a/scripts/plot/isosurface.m
+++ b/scripts/plot/isosurface.m
@@ -75,44 +75,44 @@
 ## @smallexample
 ## N = 15;    # Increase number of vertices in each direction
 ## iso = .4;  # Change isovalue to .1 to display a sphere
 ## lin = linspace (0, 2, N);
 ## [x, y, z] = meshgrid (lin, lin, lin);
 ## c = abs ((x-.5).^2 + (y-.5).^2 + (z-.5).^2);
 ## figure (); # Open another figure window
 ##
-## subplot (2, 2, 1); view (-38, 20);
+## subplot (2,2,1); view (-38, 20);
 ## [f, v] = isosurface (x, y, z, c, iso);
 ## p = patch ("Faces", f, "Vertices", v, "EdgeColor", "none");
-## set (gca, "PlotBoxAspectRatioMode","manual", ...
+## set (gca, "PlotBoxAspectRatioMode", "manual", ...
 ##           "PlotBoxAspectRatio", [1 1 1]);
 ## # set (p, "FaceColor", "green", "FaceLighting", "phong");
 ## # light ("Position", [1 1 5]); # Available with the JHandles package
 ##
-## subplot (2, 2, 2); view (-38, 20);
+## subplot (2,2,2); view (-38, 20);
 ## p = patch ("Faces", f, "Vertices", v, "EdgeColor", "blue");
-## set (gca, "PlotBoxAspectRatioMode","manual", ...
+## set (gca, "PlotBoxAspectRatioMode", "manual", ...
 ##           "PlotBoxAspectRatio", [1 1 1]);
 ## # set (p, "FaceColor", "none", "FaceLighting", "phong");
 ## # light ("Position", [1 1 5]);
 ##
-## subplot (2, 2, 3); view (-38, 20);
+## subplot (2,2,3); view (-38, 20);
 ## [f, v, c] = isosurface (x, y, z, c, iso, y);
-## p = patch ("Faces", f, "Vertices", v, "FaceVertexCData", c, \
+## p = patch ("Faces", f, "Vertices", v, "FaceVertexCData", c, ...
 ##            "FaceColor", "interp", "EdgeColor", "none");
-## set (gca, "PlotBoxAspectRatioMode","manual", ...
+## set (gca, "PlotBoxAspectRatioMode", "manual", ...
 ##           "PlotBoxAspectRatio", [1 1 1]);
 ## # set (p, "FaceLighting", "phong");
 ## # light ("Position", [1 1 5]);
 ##
-## subplot (2, 2, 4); view (-38, 20);
-## p = patch ("Faces", f, "Vertices", v, "FaceVertexCData", c, \
+## subplot (2,2,4); view (-38, 20);
+## p = patch ("Faces", f, "Vertices", v, "FaceVertexCData", c, ...
 ##            "FaceColor", "interp", "EdgeColor", "blue");
-## set (gca, "PlotBoxAspectRatioMode","manual", ...
+## set (gca, "PlotBoxAspectRatioMode", "manual", ...
 ##           "PlotBoxAspectRatio", [1 1 1]);
 ## # set (p, "FaceLighting", "phong");
 ## # light ("Position", [1 1 5]);
 ## @end smallexample
 ##
 ## @seealso{isonormals, isocolors}
 ## @end deftypefn
 
@@ -192,35 +192,35 @@ endfunction
 
 %!demo
 %! clf;
 %! [x,y,z] = meshgrid (-2:0.5:2, -2:0.5:2, -2:0.5:2);
 %! v = x.^2 + y.^2 + z.^2;
 %! isosurface (x, y, z, v, 1);
 
 %!shared x, y, z, val
-%!  [x, y, z]  = meshgrid (0:1, 0:1, 0:1); %% Points for single
-%!  val        = [0, 0; 0, 0];             %% cube and a 3-D
-%!  val(:,:,2) = [0, 0; 1, 0];             %% array of values
+%! [x, y, z]  = meshgrid (0:1, 0:1, 0:1); %% Points for single
+%! val        = [0, 0; 0, 0];             %% cube and a 3-D
+%! val(:,:,2) = [0, 0; 1, 0];             %% array of values
 %!test
-%!  fv = isosurface (x, y, z, val, 0.3);
-%!  assert (isfield (fv, "vertices"), true);
-%!  assert (isfield (fv, "faces"), true);
-%!  assert (size (fv.vertices), [3 3]);
-%!  assert (size (fv.faces), [1 3]);
+%! fv = isosurface (x, y, z, val, 0.3);
+%! assert (isfield (fv, "vertices"), true);
+%! assert (isfield (fv, "faces"), true);
+%! assert (size (fv.vertices), [3 3]);
+%! assert (size (fv.faces), [1 3]);
 %!test
-%!  fvc = isosurface (x, y, z, val, .3, y);
-%!  assert (isfield (fvc, "vertices"), true);
-%!  assert (isfield (fvc, "faces"), true);
-%!  assert (isfield (fvc, "facevertexcdata"), true);
-%!  assert (size (fvc.vertices), [3 3]);
-%!  assert (size (fvc.faces), [1 3]);
-%!  assert (size (fvc.facevertexcdata), [3 1]);
+%! fvc = isosurface (x, y, z, val, .3, y);
+%! assert (isfield (fvc, "vertices"), true);
+%! assert (isfield (fvc, "faces"), true);
+%! assert (isfield (fvc, "facevertexcdata"), true);
+%! assert (size (fvc.vertices), [3 3]);
+%! assert (size (fvc.faces), [1 3]);
+%! assert (size (fvc.facevertexcdata), [3 1]);
 %!test
-%!  [f, v] = isosurface (x, y, z, val, .3);
-%!  assert (size (f), [1 3]);
-%!  assert (size (v), [3 3]);
+%! [f, v] = isosurface (x, y, z, val, .3);
+%! assert (size (f), [1 3]);
+%! assert (size (v), [3 3]);
 %!test
-%!  [f, v, c] = isosurface (x, y, z, val, .3, y);
-%!  assert (size (f), [1 3]);
-%!  assert (size (v), [3 3]);
-%!  assert (size (c), [3 1]);
+%! [f, v, c] = isosurface (x, y, z, val, .3, y);
+%! assert (size (f), [1 3]);
+%! assert (size (v), [3 3]);
+%! assert (size (c), [3 1]);
 
diff --git a/scripts/plot/isprop.m b/scripts/plot/isprop.m
--- a/scripts/plot/isprop.m
+++ b/scripts/plot/isprop.m
@@ -42,14 +42,13 @@ function res = isprop (h, prop)
     try
       v = get (h(n), prop);
     catch
       res(n) = false;
     end_try_catch
   endfor
 endfunction
 
+
 %!assert (isprop (0, "foobar"), false)
-
 %!assert (isprop (0, "screenpixelsperinch"), true)
-
 %!assert (isprop (zeros (2, 3), "visible"), true (2, 3))
 
diff --git a/scripts/plot/legend.m b/scripts/plot/legend.m
--- a/scripts/plot/legend.m
+++ b/scripts/plot/legend.m
@@ -1030,43 +1030,28 @@ endfunction
 %! title ('a very long label can sometimes cause problems');
 %! legend ('hello world', 'location', 'northeastoutside');
 
 %!demo
 %! clf;
 %! labels = {};
 %! colororder = get (gca, 'colororder');
 %! for i = 1:5
-%!   h = plot (1:100, i + rand(100,1)); hold on;
+%!   h = plot (1:100, i + rand (100,1)); hold on;
 %!   set (h, 'color', colororder(i,:));
-%!   labels = {labels{:}, cstrcat('Signal ', num2str (i))};
+%!   labels = {labels{:}, ['Signal ', num2str(i)]};
 %! end
 %! hold off;
 %! title ('Signals with random offset and uniform noise');
 %! xlabel ('Sample Nr [k]'); ylabel ('Amplitude [V]');
 %! legend (labels, 'location', 'southoutside');
 %! legend ('boxon');
 
 %!demo
 %! clf;
-%! labels = {};
-%! colororder = get (gca, 'colororder');
-%! for i = 1:5
-%!   h = plot (1:100, i + rand (100,1)); hold on;
-%!   set (h, 'color', colororder(i,:));
-%!   labels = {labels{:}, cstrcat('Signal ', num2str (i))};
-%! end
-%! hold off;
-%! title ('Signals with random offset and uniform noise');
-%! xlabel ('Sample Nr [k]'); ylabel ('Amplitude [V]');
-%! legend (labels{:}, 'location', 'southoutside');
-%! legend ('boxon');
-
-%!demo
-%! clf;
 %! x = linspace (0, 10);
 %! plot (x, x);
 %! hold on;
 %! stem (x, x.^2, 'g');
 %! legend ('linear');
 %! hold off;
 
 %!demo
@@ -1096,62 +1081,62 @@ endfunction
 %! legend ('1st Bar', '2nd Bar', '3rd Bar');
 %! legend right;
 
 %!demo
 %! clf;
 %! x = 0:0.1:7;
 %! h = plot (x,sin(x), x,cos(x), x,sin(x.^2/10), x,cos(x.^2/10));
 %! title ('Only the sin() objects have keylabels');
-%! legend (h([1, 3]), {'sin(x)', 'sin(x^2/10)'}, 'location', 'southwest');
+%! legend (h([1, 3]), {'sin (x)', 'sin (x^2/10)'}, 'location', 'southwest');
 
 %!demo
 %! clf;
 %! x = 0:0.1:10;
-%! plot (x, sin(x), ';sin(x);');
+%! plot (x, sin (x), ';sin (x);');
 %! hold all;
-%! plot (x, cos(x), ';cos(x);');
+%! plot (x, cos (x), ';cos (x);');
 %! hold off;
 
 %!demo
 %! clf;
 %! x = 0:0.1:10;
-%! plot (x, sin(x), ';sin(x);');
+%! plot (x, sin (x), ';sin (x);');
 %! hold all;
-%! plot (x, cos(x), ';cos(x);');
+%! plot (x, cos (x), ';cos (x);');
 %! hold off;
-%! legend ({'sin(x)', 'cos(x)'}, 'location', 'northeastoutside');
+%! legend ({'sin (x)', 'cos (x)'}, 'location', 'northeastoutside');
 
 %!demo
 %! clf;
 %! x = 0:10;
 %! plot (x, rand (11));
 %! xlabel ('Indices');
 %! ylabel ('Random Values');
 %! title ('Legend ''off'' should delete the legend');
 %! legend (cellstr (num2str ((1:10)')), 'location', 'northeastoutside');
 %! legend off;
 %! axis ([0, 10, 0 1]);
 
 %!demo
 %! clf;
 %! x = (1:5)';
-%! subplot (2, 2, 1);
+%! subplot (2,2,1);
 %!  plot (x, rand (numel (x)));
 %!  legend (cellstr (num2str (x)), 'location', 'northwestoutside');
 %!  legend boxon;
-%! subplot (2, 2, 2);
+%! subplot (2,2,2);
 %!  plot (x, rand (numel (x)));
 %!  legend (cellstr (num2str (x)), 'location', 'northeastoutside');
 %!  legend boxon;
-%! subplot (2, 2, 3);
+%! subplot (2,2,3);
 %!  plot (x, rand (numel (x)));
 %!  legend (cellstr (num2str (x)), 'location', 'southwestoutside');
 %!  legend boxon;
-%! subplot (2, 2, 4);
+%! subplot (2,2,4);
 %!  plot (x, rand (numel (x)));
 %!  legend (cellstr (num2str (x)), 'location', 'southeastoutside');
 %!  legend boxon;
 
 %!demo
 %! clf;
 %! plot (rand (2));
 %! title ('Warn of extra labels');
diff --git a/scripts/plot/line.m b/scripts/plot/line.m
--- a/scripts/plot/line.m
+++ b/scripts/plot/line.m
@@ -52,8 +52,9 @@ endfunction
 %!   assert (get (h, "ydata"), [0 1], eps);
 %!   assert (get (h, "type"), "line");
 %!   assert (get (h, "color"), get (0, "defaultlinecolor"));
 %!   assert (get (h, "linestyle"), get (0, "defaultlinelinestyle"));
 %!   assert (get (h, "linewidth"), get (0, "defaultlinelinewidth"), eps);
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
+
diff --git a/scripts/plot/linkprop.m b/scripts/plot/linkprop.m
--- a/scripts/plot/linkprop.m
+++ b/scripts/plot/linkprop.m
@@ -23,19 +23,19 @@
 ## string of cell string array by @var{prop} and the objects containing
 ## these properties by the handle array @var{h}.
 ##
 ## An example of the use of linkprop is
 ##
 ## @example
 ## @group
 ## x = 0:0.1:10;
-## subplot (1, 2, 1);
+## subplot (1,2,1);
 ## h1 = plot (x, sin (x));
-## subplot (1, 2, 2);
+## subplot (1,2,2);
 ## h2 = plot (x, cos (x));
 ## hlink = linkprop ([h1, h2], @{"color","linestyle"@});
 ## set (h1, "color", "green");
 ## set (h2, "linestyle", "--");
 ## @end group
 ## @end example
 ##
 ## @end deftypefn
diff --git a/scripts/plot/loglog.m b/scripts/plot/loglog.m
--- a/scripts/plot/loglog.m
+++ b/scripts/plot/loglog.m
@@ -62,17 +62,17 @@ function retval = loglog (varargin)
 
 endfunction
 
 
 %!demo
 %! clf;
 %! t = 1:0.01:10;
 %! x = sort ((t .* (1 + rand (size (t)))) .^ 2);
-%! y = ((t .* (1 + rand (size (t)))) .^ 2);
+%! y = (t .* (1 + rand (size (t)))) .^ 2;
 %! loglog (x, y);
 
 %!demo
 %! clf;
 %! a = logspace (-5, 1, 10);
 %! b =-logspace (-5, 1, 10);
 %!
 %! subplot (1,2,1);
diff --git a/scripts/plot/loglogerr.m b/scripts/plot/loglogerr.m
--- a/scripts/plot/loglogerr.m
+++ b/scripts/plot/loglogerr.m
@@ -58,15 +58,15 @@ function retval = loglogerr (varargin)
     axes (oldh);
   end_unwind_protect
 
 endfunction
 
 
 %!demo
 %! clf;
-%! x = exp (log(0.01):0.2:log(10));
+%! x = exp (log (0.01):0.2:log (10));
 %! y = wblpdf (x, 3, 2);
 %! eyu = 2*rand (size (y)) .* y;
 %! eyl = 0.5*rand (size (y)) .* y;
 %! loglogerr (x, y, eyl, eyu, '#~x-');
 %! xlim (x([1, end]));
 
diff --git a/scripts/plot/meshgrid.m b/scripts/plot/meshgrid.m
--- a/scripts/plot/meshgrid.m
+++ b/scripts/plot/meshgrid.m
@@ -66,16 +66,17 @@ function [xx, yy, zz] = meshgrid (x, y, 
        zz = reshape (repmat (z(:).', lenx*leny, 1)(:), leny, lenx, lenz);
     else
       error ("meshgrid: arguments must be vectors");
     endif
   endif
 
 endfunction
 
+
 %!test
 %! x = 1:2;
 %! y = 1:3;
 %! z = 1:4;
 %! [XX, YY, ZZ] = meshgrid (x, y, z);
 %! assert (size_equal (XX, YY, ZZ));
 %! assert (ndims (XX), 3);
 %! assert (size (XX), [3, 2, 4]);
@@ -95,9 +96,10 @@ endfunction
 %!test
 %! x = 1:3;
 %! [XX1, YY1] = meshgrid (x, x);
 %! [XX2, YY2] = meshgrid (x);
 %! assert (size_equal (XX1, XX2, YY1, YY2));
 %! assert (ndims (XX1), 2);
 %! assert (size (XX1), [3, 3]);
 %! assert (XX1, XX2);
-%! assert (YY1, YY2);
\ No newline at end of file
+%! assert (YY1, YY2);
+
diff --git a/scripts/plot/module.mk b/scripts/plot/module.mk
--- a/scripts/plot/module.mk
+++ b/scripts/plot/module.mk
@@ -161,17 +161,16 @@ plot_FCN_FILES = \
   plot/semilogy.m \
   plot/semilogyerr.m \
   plot/shading.m \
   plot/shg.m \
   plot/slice.m \
   plot/sombrero.m \
   plot/specular.m \
   plot/sphere.m \
-  plot/spinmap.m \
   plot/stairs.m \
   plot/stem.m \
   plot/stem3.m \
   plot/subplot.m \
   plot/surf.m \
   plot/surface.m \
   plot/surfc.m \
   plot/surfl.m \
diff --git a/scripts/plot/ndgrid.m b/scripts/plot/ndgrid.m
--- a/scripts/plot/ndgrid.m
+++ b/scripts/plot/ndgrid.m
@@ -15,23 +15,23 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {[@var{y1}, @var{y2}, @dots{}, @var{y}n] =} ndgrid (@var{x1}, @var{x2}, @dots{}, @var{x}n)
 ## @deftypefnx {Function File} {[@var{y1}, @var{y2}, @dots{}, @var{y}n] =} ndgrid (@var{x})
 ## Given n vectors @var{x1}, @dots{} @var{x}n, @code{ndgrid} returns
-## n arrays of dimension n. The elements of the i-th output argument
+## n arrays of dimension n.  The elements of the i-th output argument
 ## contains the elements of the vector @var{x}i repeated over all
 ## dimensions different from the i-th dimension.  Calling ndgrid with
 ## only one input argument @var{x} is equivalent of calling ndgrid with
 ## all n input arguments equal to @var{x}:
 ##
-## [@var{y1}, @var{y2}, @dots{},  @var{y}n] = ndgrid (@var{x}, @dots{}, @var{x})
+## [@var{y1}, @var{y2}, @dots{}, @var{y}n] = ndgrid (@var{x}, @dots{}, @var{x})
 ## @seealso{meshgrid}
 ## @end deftypefn
 
 ## Author: Alexander Barth <abarth@marine.usf.edu>
 
 function varargout = ndgrid (varargin)
 
   if (nargin == 1)
@@ -65,16 +65,17 @@ function varargout = ndgrid (varargin)
     s = shape;
     s(i) = 1;
 
     varargout{i} = repmat (reshape (varargin{i}, r), s);
   endfor
 
 endfunction
 
+
 %!test
 %! x = 1:2;
 %! y = 1:3;
 %! z = 1:4;
 %! [XX, YY, ZZ] = ndgrid (x, y, z);
 %! assert (size_equal (XX, YY, ZZ));
 %! assert (ndims (XX), 3);
 %! assert (size (XX), [2, 3, 4]);
@@ -90,8 +91,9 @@ endfunction
 %! assert (size_equal (XX2, YY2));
 %! assert (ndims (XX1), 2);
 %! assert (size (XX1), [3, 2]);
 %! assert (size (XX2), [2, 3]);
 %! assert (XX2(1) * YY2(1), x(1) * y(1));
 %! assert (XX2(end) * YY2(end), x(end) * y(end));
 %! assert (XX1, XX2.');
 %! assert (YY1, YY2.');
+
diff --git a/scripts/plot/newplot.m b/scripts/plot/newplot.m
--- a/scripts/plot/newplot.m
+++ b/scripts/plot/newplot.m
@@ -60,17 +60,19 @@ function newplot ()
         error ("newplot: unrecognized nextplot property for current axes");
     endswitch
   else
     print_usage ();
   endif
 
 endfunction
 
+
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   p = plot ([0, 1]);
 %!   newplot;
 %!   assert (isempty (get (gca, "children")));
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
+
diff --git a/scripts/plot/orient.m b/scripts/plot/orient.m
--- a/scripts/plot/orient.m
+++ b/scripts/plot/orient.m
@@ -65,45 +65,47 @@ function retval = orient (varargin)
       error ("orient: unknown ORIENTATION");
     endif
   else
     print_usage ();
   endif
 
 endfunction
 
+
 %!shared papersize, paperposition, tallpaperposition, hfig
-%!  papersize = [8.5, 11];
-%!  paperposition = [0.25, 2.5, 8, 6];
-%!  tallpaperposition = [0.25, 0.25, (papersize-0.5)];
-%!  hfig = figure ();
-%!  set (hfig, "visible", "off")
-%!  set (hfig, "paperorientation", "portrait")
-%!  set (hfig, "papersize", papersize)
-%!  set (hfig, "paperposition", paperposition)
+%! papersize = [8.5, 11];
+%! paperposition = [0.25, 2.5, 8, 6];
+%! tallpaperposition = [0.25, 0.25, (papersize-0.5)];
+%! hfig = figure ();
+%! set (hfig, "visible", "off");
+%! set (hfig, "paperorientation", "portrait");
+%! set (hfig, "papersize", papersize);
+%! set (hfig, "paperposition", paperposition);
 %!test
-%!  orient portrait
-%!  assert (orient, "portrait") # default
-%!  assert (get (hfig, "papersize"), papersize)
-%!  assert (get (hfig, "paperposition"), paperposition)
+%! orient portrait;
+%! assert (orient, "portrait")   # default
+%! assert (get (hfig, "papersize"), papersize);
+%! assert (get (hfig, "paperposition"), paperposition);
 %!test
-%!  orient landscape
-%!  assert (orient,"landscape") # change to landscape
-%!  assert (get (hfig, "papersize"), papersize([2, 1]))
-%!  assert (get (hfig, "paperposition"), paperposition([2, 1, 4, 3]))
+%! orient landscape;
+%! assert (orient,"landscape")   # change to landscape
+%! assert (get (hfig, "papersize"), papersize([2, 1]));
+%! assert (get (hfig, "paperposition"), paperposition([2, 1, 4, 3]));
 %!test
-%!  orient portrait # change back to portrait
-%!  assert (orient, "portrait")
-%!  assert (get (hfig, "papersize"), papersize)
-%!  assert (get (hfig, "paperposition"), paperposition)
+%! orient portrait   # change back to portrait
+%! assert (orient, "portrait");
+%! assert (get (hfig, "papersize"), papersize);
+%! assert (get (hfig, "paperposition"), paperposition);
 %!test
-%!  orient landscape
-%!  orient tall
-%!  assert (orient, "portrait")
-%!  assert (get (hfig, "papersize"), papersize)
-%!  assert (get (hfig, "paperposition"), tallpaperposition)
+%! orient landscape;
+%! orient tall;
+%! assert (orient, "portrait");
+%! assert (get (hfig, "papersize"), papersize);
+%! assert (get (hfig, "paperposition"), tallpaperposition);
 %!fail ("orient ('nobody')", "unknown ORIENTATION")
 %!test
-%!  orient portrait # errors don't change the state
-%!  assert (orient, "portrait")
-%!  assert (get (hfig, "papersize"), papersize)
-%!  assert (get (hfig, "paperposition"), tallpaperposition)
-%!  close (hfig)
+%! orient portrait   # errors don't change the state
+%! assert (orient, "portrait");
+%! assert (get (hfig, "papersize"), papersize);
+%! assert (get (hfig, "paperposition"), tallpaperposition);
+%! close (hfig);
+
diff --git a/scripts/plot/patch.m b/scripts/plot/patch.m
--- a/scripts/plot/patch.m
+++ b/scripts/plot/patch.m
@@ -16,17 +16,17 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} patch ()
 ## @deftypefnx {Function File} {} patch (@var{x}, @var{y}, @var{c})
 ## @deftypefnx {Function File} {} patch (@var{x}, @var{y}, @var{z}, @var{c})
 ## @deftypefnx {Function File} {} patch (@var{fv})
-## @deftypefnx {Function File} {} patch ('Faces', @var{f}, 'Vertices', @var{v}, @dots{})
+## @deftypefnx {Function File} {} patch ("Faces", @var{f}, "Vertices", @var{v}, @dots{})
 ## @deftypefnx {Function File} {} patch (@dots{}, @var{prop}, @var{val})
 ## @deftypefnx {Function File} {} patch (@var{h}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} patch (@dots{})
 ## Create patch object from @var{x} and @var{y} with color @var{c} and
 ## insert in the current axes object.  Return handle to patch object.
 ##
 ## For a uniform colored patch, @var{c} can be given as an RGB vector,
 ## scalar value referring to the current colormap, or string value (for
@@ -101,28 +101,28 @@ endfunction
 %! t1 = (1/16:1/8:1)' * 2*pi;
 %! t2 = ((1/16:1/16:1)' + 1/32) * 2*pi;
 %! x1 = sin (t1) - 0.8;
 %! y1 = cos (t1);
 %! x2 = sin (t2) + 0.8;
 %! y2 = cos (t2);
 %! vert = [x1, y1; x2, y2];
 %! fac = [1:8,NaN(1,8);9:24];
-%! patch ('Faces',fac, 'Vertices',vert, 'FaceVertexCData', [0, 1, 0; 0, 0, 1]);
+%! patch ('Faces',fac, 'Vertices',vert, 'FaceVertexCData',[0, 1, 0; 0, 0, 1]);
 
 %!demo
 %! %% Property change on multiple patches
 %! clf;
 %! t1 = (1/16:1/8:1)' * 2*pi;
 %! t2 = ((1/16:1/8:1)' + 1/32) * 2*pi;
 %! x1 = sin (t1) - 0.8;
 %! y1 = cos (t1);
 %! x2 = sin (t2) + 0.8;
 %! y2 = cos (t2);
-%! h = patch ([x1,x2], [y1,y2], cat (3,[0,0],[1,0],[0,1]));
+%! h = patch ([x1,x2], [y1,y2], cat (3, [0,0],[1,0],[0,1]));
 %! pause (1);
 %! set (h, 'FaceColor', 'r');
 
 %!demo
 %! clf;
 %! vertices = [0, 0, 0;
 %!             1, 0, 0;
 %!             1, 1, 0;
@@ -151,38 +151,38 @@ endfunction
 %!        'FaceVertexCData', jet (5), 'FaceColor', 'interp');
 %! view (-37.5, 30);
 
 %!demo
 %! clf;
 %! colormap (jet (64));
 %! x = [0 1 1 0];
 %! y = [0 0 1 1];
-%! subplot (2, 1, 1);
+%! subplot (2,1,1);
 %!  title ('Blue, Light-Green, and Red Horizontal Bars');
 %!  patch (x, y + 0, 1);
 %!  patch (x, y + 1, 2);
 %!  patch (x, y + 2, 3);
-%! subplot (2, 1, 2);
+%! subplot (2,1,2);
 %!  title ('Blue, Light-Green, and Red Vertical Bars');
 %!  patch (x + 0, y, 1 * ones (size (x)));
 %!  patch (x + 1, y, 2 * ones (size (x)));
 %!  patch (x + 2, y, 3 * ones (size (x)));
 
 %!demo
 %! clf;
 %! colormap (jet (64));
 %! x = [0 1 1 0];
 %! y = [0 0 1 1];
-%! subplot (2, 1, 1);
+%! subplot (2,1,1);
 %!  title ('Blue horizontal bars: Dark to Light');
 %!  patch (x, y + 0, 1, 'cdatamapping', 'direct');
 %!  patch (x, y + 1, 9, 'cdatamapping', 'direct');
 %!  patch (x, y + 2, 17, 'cdatamapping', 'direct');
-%! subplot (2, 1, 2);
+%! subplot (2,1,2);
 %!  title ('Blue vertical bars: Dark to Light');
 %!  patch (x + 0, y, 1 * ones (size (x)), 'cdatamapping', 'direct');
 %!  patch (x + 1, y, 9 * ones (size (x)), 'cdatamapping', 'direct');
 %!  patch (x + 2, y, 17 * ones (size (x)), 'cdatamapping', 'direct');
 
 %!demo
 %! clf;
 %! colormap (jet (64));
diff --git a/scripts/plot/pie.m b/scripts/plot/pie.m
--- a/scripts/plot/pie.m
+++ b/scripts/plot/pie.m
@@ -24,17 +24,17 @@
 ## @deftypefnx {Function File} {@var{h} =} pie (@dots{});
 ## Produce a 2-D pie chart.
 ##
 ## Called with a single vector argument, produces a pie chart of the
 ## elements in @var{x}, with the size of the slice determined by percentage
 ## size of the values of @var{x}.
 ##
 ## The variable @var{explode} is a vector of the same length as @var{x} that
-## if non zero 'explodes' the slice from the pie chart.
+## if non zero "explodes" the slice from the pie chart.
 ##
 ## If given @var{labels} is a cell array of strings of the same length as
 ## @var{x}, giving the labels of each of the slices of the pie chart.
 ##
 ## The optional return value @var{h} is a list of handles to the patch
 ## and text objects generating the plot.
 ##
 ## @seealso{pie3, bar, stem}
diff --git a/scripts/plot/pie3.m b/scripts/plot/pie3.m
--- a/scripts/plot/pie3.m
+++ b/scripts/plot/pie3.m
@@ -25,17 +25,17 @@
 ## @deftypefnx {Function File} {@var{h} =} pie3 (@dots{});
 ## Draw a 3-D pie chart.
 ##
 ## Called with a single vector argument, produces a 3-D pie chart of the
 ## elements in @var{x}, with the size of the slice determined by percentage
 ## size of the values of @var{x}.
 ##
 ## The variable @var{explode} is a vector of the same length as @var{x} that
-## if non zero 'explodes' the slice from the pie chart.
+## if non zero "explodes" the slice from the pie chart.
 ##
 ## If given @var{labels} is a cell array of strings of the same length as
 ## @var{x}, giving the labels of each of the slices of the pie chart.
 ##
 ## The optional return value @var{h} is a list of graphics handles to the patch,
 ## surface, and text objects generating the plot.
 ##
 ## @seealso{pie, bar, stem}
diff --git a/scripts/plot/plot3.m b/scripts/plot/plot3.m
--- a/scripts/plot/plot3.m
+++ b/scripts/plot/plot3.m
@@ -69,19 +69,19 @@
 ## @example
 ## plot3 (@var{x1}, @var{c1}, "", @var{c2}, "", @dots{})
 ## @end example
 ##
 ## An example of the use of @code{plot3} is
 ##
 ## @example
 ## @group
-##    z = [0:0.05:5];
-##    plot3 (cos(2*pi*z), sin(2*pi*z), z, ";helix;");
-##    plot3 (z, exp(2i*pi*z), ";complex sinusoid;");
+## z = [0:0.05:5];
+## plot3 (cos (2*pi*z), sin (2*pi*z), z, ";helix;");
+## plot3 (z, exp (2i*pi*z), ";complex sinusoid;");
 ## @end group
 ## @end example
 ## @seealso{plot, xlabel, ylabel, zlabel, title, print}
 ## @end deftypefn
 
 ## Author: Paul Kienzle
 ##         (modified from __plt__.m)
 
@@ -337,11 +337,11 @@ function retval = plot3 (varargin)
   endif
 
 endfunction
 
 
 %!demo
 %! clf;
 %! z = [0:0.05:5];
-%! plot3 (cos(2*pi*z), sin(2*pi*z), z, ';helix;');
-%! plot3 (z, exp(2i*pi*z), ';complex sinusoid;');
+%! plot3 (cos (2*pi*z), sin (2*pi*z), z, ';helix;');
+%! plot3 (z, exp (2i*pi*z), ';complex sinusoid;');
 
diff --git a/scripts/plot/plotmatrix.m b/scripts/plot/plotmatrix.m
--- a/scripts/plot/plotmatrix.m
+++ b/scripts/plot/plotmatrix.m
@@ -49,19 +49,17 @@
 ## graphics objects in the scatter plots, whereas @var{ax} returns the
 ## handles to the scatter plot axis objects.  @var{bigax} is a hidden
 ## axis object that surrounds the other axes, such that the commands
 ## @code{xlabel}, @code{title}, etc., will be associated with this hidden
 ## axis.  Finally @var{p} returns the graphics objects associated with
 ## the histogram and @var{pax} the corresponding axes objects.
 ##
 ## @example
-## @group
-## plotmatrix (randn (100, 3), 'g+')
-## @end group
+## plotmatrix (randn (100, 3), "g+")
 ## @end example
 ##
 ## @end deftypefn
 
 function [h, ax, bigax, p, pax] = plotmatrix (varargin)
 
   [bigax2, varargin, nargin] = __plt_get_axis_arg__ ("plotmatrix", varargin{:});
 
diff --git a/scripts/plot/plotyy.m b/scripts/plot/plotyy.m
--- a/scripts/plot/plotyy.m
+++ b/scripts/plot/plotyy.m
@@ -255,17 +255,17 @@ endfunction
 %!  contour (peaks (25));
 %! subplot (2,2,4);
 %!  plotyy (x,10*sin(2*pi*x), x,cos(2*pi*x));
 %! axis square;
 
 %!demo
 %! clf;
 %! x = linspace (-1, 1, 201);
-%! hax = plotyy (x, sin(pi*x), x, cos(pi*x));
+%! hax = plotyy (x, sin (pi*x), x, cos (pi*x));
 %! ylabel ('Blue on the Left');
 %! ylabel (hax(2), 'Green on the Right');
 %! xlabel ('xlabel');
 
 function deleteplotyy (h, d, ax2, t2)
   if (ishandle (ax2) && strcmp (get (ax2, "type"), "axes")
       && (isempty (gcbf()) || strcmp (get (gcbf(), "beingdeleted"),"off"))
       && strcmp (get (ax2, "beingdeleted"), "off"))
diff --git a/scripts/plot/print.m b/scripts/plot/print.m
--- a/scripts/plot/print.m
+++ b/scripts/plot/print.m
@@ -59,16 +59,17 @@
 ##   Specify the orientation of the plot for printed output.  For
 ## non-printed output the aspect ratio of the output corresponds to
 ## the plot area defined by the "paperposition" property in the
 ## orientation specified.  This options is equivalent to changing
 ## the figure's "paperorientation" property.
 ##
 ## @item -d@var{device}
 ##   Output device, where @var{device} is one of:
+##
 ##   @table @code
 ##   @item ps
 ##   @itemx ps2
 ##   @itemx psc
 ##   @itemx psc2
 ##     Postscript (level 1 and 2, mono and color).  The FLTK graphics
 ##     toolkit generates Postscript level 3.0.
 ##
@@ -229,30 +230,30 @@
 ## @end table
 ##
 ## The filename and options can be given in any order.
 ##
 ## Example: Print to a file, using the svg device.
 ##
 ## @example
 ## @group
-## figure (1)
-## clf ()
-## surf (peaks)
+## figure (1);
+## clf ();
+## surf (peaks);
 ## print -dsvg figure1.svg
 ## @end group
 ## @end example
 ##
 ## Example: Print to an HP Deskjet 550C.
 ##
 ## @example
 ## @group
-## figure (1)
-## clf ()
-## surf (peaks)
+## figure (1);
+## clf ();
+## surf (peaks);
 ## print -dcdj550
 ## @end group
 ## @end example
 ##
 ## @seealso{figure, orient, saveas}
 ## @end deftypefn
 
 function print (varargin)
@@ -278,31 +279,39 @@ function print (varargin)
     copyfile (opts.ghostscript.output, opts.ghostscript.prepend);
   endif
 
   unwind_protect
 
     ## Modify properties as specified by options
     props = [];
 
+    drawnow ();
+
+    ## print() requires figure units to be "pixels"
+    props(1).h = opts.figure;
+    props(1).name = "units";
+    props(1).value = {get(opts.figure, "units")};
+    set (opts.figure, "units", "pixels");
+
     ## graphics toolkit tranlates figure position to eps bbox in points
     fpos = get (opts.figure, "position");
-    props(1).h = opts.figure;
-    props(1).name = "position";
-    props(1).value = {fpos};
+    props(2).h = opts.figure;
+    props(2).name = "position";
+    props(2).value = {fpos};
     fpos(3:4) = opts.canvas_size;
     set (opts.figure, "position", fpos);
 
     ## Set figure background to none. This is done both for
     ## consistency with Matlab and to elliminate the visible
     ## box along the figure's perimeter.
-    props(2).h = opts.figure;
-    props(2).name = "color";
-    props(2).value{1} = get (props(2).h, props(2).name);
-    set (props(2).h, props(2).name, "none");
+    props(3).h = opts.figure;
+    props(3).name = "color";
+    props(3).value{1} = get (props(3).h, props(3).name);
+    set (props(3).h, "color", "none");
 
     if (opts.force_solid != 0)
       h = findall (opts.figure, "-property", "linestyle");
       m = numel (props);
       for n = 1:numel(h)
         props(m+n).h = h(n);
         props(m+n).name = "linestyle";
         props(m+n).value = {get(h(n), "linestyle")};
@@ -384,17 +393,17 @@ function print (varargin)
       opts = __gnuplot_print__ (opts);
     otherwise
       opts = __fltk_print__ (opts);
     endswitch
 
   unwind_protect_cleanup
     ## restore modified properties
     if (isstruct (props))
-      for n = 1:numel(props)
+      for n = numel(props):-1:1
         if (ishandle (props(n).h))
           set (props(n).h, props(n).name, props(n).value{1});
         endif
       endfor
     endif
 
     ## Unlink temporary files
     for n = 1:numel(opts.unlink)
diff --git a/scripts/plot/private/__marching_cube__.m b/scripts/plot/private/__marching_cube__.m
--- a/scripts/plot/private/__marching_cube__.m
+++ b/scripts/plot/private/__marching_cube__.m
@@ -44,17 +44,17 @@
 ## beyond other surface and geometry stuff at Paul Bourke's website
 ## @uref{http://local.wasp.uwa.edu.au/~pbourke/geometry/polygonise}.
 ##
 ## For example:
 ##
 ## @example
 ## @group
 ## N = 20;
-## lin = linspace(0, 2, N);
+## lin = linspace (0, 2, N);
 ## [x, y, z] = meshgrid (lin, lin, lin);
 ##
 ## c = (x-.5).^2 + (y-.5).^2 + (z-.5).^2;
 ## [t, p] = __marching_cube__ (x, y, z, c, .5);
 ##
 ## figure ();
 ## trimesh (t, p(:,1), p(:,2), p(:,3));
 ## @end group
@@ -65,21 +65,21 @@
 ##
 ## @example
 ## @group
 ## figure (); view (-38, 20);
 ## pa = patch ("Faces", t, "Vertices", p, "FaceVertexCData", p, \
 ##             "FaceColor", "interp", "EdgeColor", "none");
 ##
 ## ## Revert normals
-## set (pa, "VertexNormals", -get(pa, "VertexNormals"));
+## set (pa, "VertexNormals", -get (pa, "VertexNormals"));
 ##
 ## ## Set lightning (available with the JHandles package)
 ## # set (pa, "FaceLighting", "gouraud");
-## # light( "Position", [1 1 5]);
+## # light ( "Position", [1 1 5]);
 ## @end group
 ## @end example
 ##
 ## @end deftypefn
 
 ## Author: Martin Helm <martin@mhelm.de>
 
 function [T, p, col] = __marching_cube__ (xx, yy, zz, c, iso, colors)
diff --git a/scripts/plot/private/__print_parse_opts__.m b/scripts/plot/private/__print_parse_opts__.m
--- a/scripts/plot/private/__print_parse_opts__.m
+++ b/scripts/plot/private/__print_parse_opts__.m
@@ -12,17 +12,17 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {@var{args} =} __print_parse_opts__ (@var{propname}, @var{propvalue})
+## @deftypefn  {Function File} {@var{args} =} __print_parse_opts__ (@var{propname}, @var{propvalue})
 ## @deftypefnx {Function File} {@var{args} =} __print_parse_opts__ (@var{struct})
 ## Undocumented internal function.
 ## @end deftypefn
 
 function arg_st = __print_parse_opts__ (varargin)
 
   persistent warn_on_missing_binary = true
 
@@ -366,66 +366,66 @@ endfunction
 
 ## Test blocks are not allowed (and not needed) for private functions
 #%!test
 %! opts = __print_parse_opts__ ();
 %! assert (opts.devopt, "pswrite");
 %! assert (opts.use_color, 1);
 %! assert (opts.send_to_printer, true);
 %! assert (opts.canvas_size, [576, 432]);
-%! assert (opts.ghostscript.device, "pswrite")
+%! assert (opts.ghostscript.device, "pswrite");
 
 #%!test
 %! opts = __print_parse_opts__ ("test.pdf", "-S640,480");
 %! assert (opts.canvas_size, [307.2, 230.4], 0.1);
 
 #%!test
 %! opts = __print_parse_opts__ ("-dpsc", "-append", "-loose");
 %! assert (opts.devopt, "pswrite");
 %! assert (opts.send_to_printer, true);
 %! assert (opts.use_color, 1);
 %! assert (opts.append_to_file, false);
-%! assert (opts.ghostscript.device, "pswrite")
+%! assert (opts.ghostscript.device, "pswrite");
 %! assert (opts.ghostscript.epscrop, false);
 
 #%!test
 %! opts = __print_parse_opts__ ("-deps", "-tight");
 %! assert (opts.tight_flag, true);
 %! assert (opts.send_to_printer, true);
 %! assert (opts.use_color, -1);
-%! assert (opts.ghostscript.device, "")
+%! assert (opts.ghostscript.device, "");
 
 #%!test
 %! opts = __print_parse_opts__ ("-djpg", "foobar", "-mono", "-loose");
-%! assert (opts.devopt, "jpeg")
-%! assert (opts.name, "foobar.jpg")
-%! assert (opts.ghostscript.device, "jpeg")
+%! assert (opts.devopt, "jpeg");
+%! assert (opts.name, "foobar.jpg");
+%! assert (opts.ghostscript.device, "jpeg");
 %! assert (opts.ghostscript.epscrop, true);
 %! assert (opts.ghostscript.papersize, "");
 %! assert (opts.ghostscript.pageoffset, [0, 0]);
 %! assert (opts.send_to_printer, false);
 %! assert (opts.printer, "");
 %! assert (opts.use_color, -1);
 
 #%!test
 %! opts = __print_parse_opts__ ("-ddeskjet", "foobar", "-mono", "-Pmyprinter");
-%! assert (opts.ghostscript.output, "foobar.deskjet")
-%! assert (opts.ghostscript.device, "deskjet")
-%! assert (opts.devopt, "deskjet")
+%! assert (opts.ghostscript.output, "foobar.deskjet");
+%! assert (opts.ghostscript.device, "deskjet");
+%! assert (opts.devopt, "deskjet");
 %! assert (opts.send_to_printer, true);
 %! assert (opts.printer, "-Pmyprinter");
 %! assert (opts.use_color, -1);
 
 #%!test
 %! opts = __print_parse_opts__ ("-f5", "-dljet3");
-%! assert (opts.ghostscript.device, "ljet3")
-%! assert (strfind (opts.ghostscript.output, ".ljet3"))
-%! assert (opts.devopt, "ljet3")
+%! assert (opts.ghostscript.device, "ljet3");
+%! assert (strfind (opts.ghostscript.output, ".ljet3"));
+%! assert (opts.devopt, "ljet3");
 %! assert (opts.send_to_printer, true);
-%! assert (opts.figure, 5)
+%! assert (opts.figure, 5);
 
 function cmd = __quote_path__ (cmd)
   if (any (cmd == " ") && ! (cmd(1) == """" && cmd(end) == """"))
     cmd = strcat ("""", strrep (cmd, """", """"""), """");
   endif
 endfunction
 
 function gs = __ghostscript_binary__ ()
diff --git a/scripts/plot/quiver.m b/scripts/plot/quiver.m
--- a/scripts/plot/quiver.m
+++ b/scripts/plot/quiver.m
@@ -16,17 +16,17 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} quiver (@var{u}, @var{v})
 ## @deftypefnx {Function File} {} quiver (@var{x}, @var{y}, @var{u}, @var{v})
 ## @deftypefnx {Function File} {} quiver (@dots{}, @var{s})
 ## @deftypefnx {Function File} {} quiver (@dots{}, @var{style})
-## @deftypefnx {Function File} {} quiver (@dots{}, 'filled')
+## @deftypefnx {Function File} {} quiver (@dots{}, "filled")
 ## @deftypefnx {Function File} {} quiver (@var{h}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} quiver (@dots{})
 ##
 ## Plot the @code{(@var{u}, @var{v})} components of a vector field in
 ## an @code{(@var{x}, @var{y})} meshgrid.  If the grid is uniform, you can
 ## specify @var{x} and @var{y} as vectors.
 ##
 ## If @var{x} and @var{y} are undefined they are assumed to be
@@ -35,17 +35,17 @@
 ##
 ## The variable @var{s} is a scalar defining a scaling factor to use for
 ## the arrows of the field relative to the mesh spacing.  A value of 0
 ## disables all scaling.  The default value is 1.
 ##
 ## The style to use for the plot can be defined with a line style @var{style}
 ## in a similar manner to the line styles used with the @code{plot} command.
 ## If a marker is specified then markers at the grid points of the vectors are
-## printed rather than arrows.  If the argument 'filled' is given then the
+## printed rather than arrows.  If the argument "filled" is given then the
 ## markers as filled.
 ##
 ## The optional return value @var{h} is a graphics handle to a quiver object.
 ## A quiver object regroups the components of the quiver plot (body, arrow,
 ## and marker), and allows them to be changed together.
 ##
 ## @example
 ## @group
diff --git a/scripts/plot/quiver3.m b/scripts/plot/quiver3.m
--- a/scripts/plot/quiver3.m
+++ b/scripts/plot/quiver3.m
@@ -16,17 +16,17 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} quiver3 (@var{u}, @var{v}, @var{w})
 ## @deftypefnx {Function File} {} quiver3 (@var{x}, @var{y}, @var{z}, @var{u}, @var{v}, @var{w})
 ## @deftypefnx {Function File} {} quiver3 (@dots{}, @var{s})
 ## @deftypefnx {Function File} {} quiver3 (@dots{}, @var{style})
-## @deftypefnx {Function File} {} quiver3 (@dots{}, 'filled')
+## @deftypefnx {Function File} {} quiver3 (@dots{}, "filled")
 ## @deftypefnx {Function File} {} quiver3 (@var{h}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} quiver3 (@dots{})
 ##
 ## Plot the @code{(@var{u}, @var{v}, @var{w})} components of a vector field in
 ## an @code{(@var{x}, @var{y}), @var{z}} meshgrid.  If the grid is uniform, you
 ## can specify @var{x}, @var{y} @var{z} as vectors.
 ##
 ## If @var{x}, @var{y} and @var{z} are undefined they are assumed to be
@@ -35,17 +35,17 @@
 ##
 ## The variable @var{s} is a scalar defining a scaling factor to use for
 ##  the arrows of the field relative to the mesh spacing.  A value of 0
 ## disables all scaling.  The default value is 1.
 ##
 ## The style to use for the plot can be defined with a line style @var{style}
 ## in a similar manner to the line styles used with the @code{plot} command.
 ## If a marker is specified then markers at the grid points of the vectors are
-## printed rather than arrows.  If the argument 'filled' is given then the
+## printed rather than arrows.  If the argument "filled" is given then the
 ## markers as filled.
 ##
 ## The optional return value @var{h} is a graphics handle to a quiver object.
 ## A quiver object regroups the components of the quiver plot (body, arrow,
 ## and marker), and allows them to be changed together.
 ##
 ## @example
 ## @group
@@ -88,17 +88,17 @@ endfunction
 %!demo
 %! clf;
 %! colormap ('default');
 %! [x,y] = meshgrid (-1:0.1:1);
 %! z = sin (2*pi * sqrt (x.^2 + y.^2));
 %! theta = 2*pi * sqrt (x.^2 + y.^2) + pi/2;
 %! quiver3 (x, y, z, sin (theta), cos (theta), ones (size (z)));
 %! hold on;
-%! mesh (x,y,z);
+%! mesh (x, y, z);
 %! hold off;
 
 %!demo
 %! clf;
 %! colormap ('default');
 %! [x, y, z] = peaks (25);
 %! surf (x, y, z);
 %! hold on;
diff --git a/scripts/plot/refreshdata.m b/scripts/plot/refreshdata.m
--- a/scripts/plot/refreshdata.m
+++ b/scripts/plot/refreshdata.m
@@ -37,18 +37,18 @@
 ## An example of the use of @code{refreshdata} is:
 ##
 ## @example
 ## @group
 ## x = 0:0.1:10;
 ## y = sin (x);
 ## plot (x, y, "ydatasource", "y");
 ## for i = 1 : 100
-##   pause (0.1)
-##   y = sin (x + 0.1 * i);
+##   pause (0.1);
+##   y = sin (x + 0.1*i);
 ##   refreshdata ();
 ## endfor
 ## @end group
 ## @end example
 ## @end deftypefn
 
 function refreshdata (h, workspace)
 
@@ -110,11 +110,11 @@ endfunction
 %!demo
 %! clf;
 %! x = 0:0.1:10;
 %! y = sin (x);
 %! plot (x, y, 'ydatasource', 'y');
 %! for i = 1 : 100
 %!   pause (0.1);
 %!   y = sin (x + 0.1 * i);
-%!   refreshdata (gcf (), 'caller');
+%!   refreshdata (gcf, 'caller');
 %! end
 
diff --git a/scripts/plot/ribbon.m b/scripts/plot/ribbon.m
--- a/scripts/plot/ribbon.m
+++ b/scripts/plot/ribbon.m
@@ -88,8 +88,9 @@ endfunction
 %!demo
 %! clf;
 %! colormap ('default');
 %! [x, y, z] = sombrero ();
 %! [x, y] = meshgrid (x, y);
 %! ribbon (y, z);
 
 %!FIXME: Could have some input validation tests here
+
diff --git a/scripts/plot/rose.m b/scripts/plot/rose.m
--- a/scripts/plot/rose.m
+++ b/scripts/plot/rose.m
@@ -34,17 +34,17 @@
 ## line objects representing each histogram.
 ##
 ## If two output arguments are requested then, rather than plotting the
 ## histogram, the polar vectors necessary to plot the histogram are
 ## returned.
 ##
 ## @example
 ## @group
-## [r, t] = rose ([2*randn(1e5,1), pi + 2 * randn(1e5,1)]);
+## [r, t] = rose ([2*randn(1e5,1), pi + 2*randn(1e5,1)]);
 ## polar (r, t);
 ## @end group
 ## @end example
 ##
 ## @seealso{polar, compass, hist}
 ## @end deftypefn
 
 function [thout, rout] = rose (varargin)
diff --git a/scripts/plot/saveas.m b/scripts/plot/saveas.m
--- a/scripts/plot/saveas.m
+++ b/scripts/plot/saveas.m
@@ -45,20 +45,19 @@
 ## @end table
 ##
 ## All device formats specified in @code{print} may also be used.  If
 ## @var{fmt} is omitted it is extracted from the extension of @var{filename}.
 ## The default format is @code{"pdf"}.
 ##
 ## @example
 ## @group
-## figure (1);
 ## clf ();
 ## surf (peaks);
-## saveas(1, "figure1.png");
+## saveas (1, "figure1.png");
 ## @end group
 ## @end example
 ##
 ## @seealso{print}
 ## @end deftypefn
 
 ## Author: Kai Habel
 
diff --git a/scripts/plot/scatter3.m b/scripts/plot/scatter3.m
--- a/scripts/plot/scatter3.m
+++ b/scripts/plot/scatter3.m
@@ -13,17 +13,17 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} scatter3 (@var{x}, @var{y}, @var{z}, @var{s}, @var{c})
-## @deftypefnx {Function File} {} scatter3 (@dots{}, 'filled')
+## @deftypefnx {Function File} {} scatter3 (@dots{}, "filled")
 ## @deftypefnx {Function File} {} scatter3 (@dots{}, @var{style})
 ## @deftypefnx {Function File} {} scatter3 (@dots{}, @var{prop}, @var{val})
 ## @deftypefnx {Function File} {} scatter3 (@var{h}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} scatter3 (@dots{})
 ##
 ## Plot a scatter plot of the data in 3D@.  A marker is plotted at each point
 ## defined by the points in the vectors @var{x}, @var{y} and @var{z}.  The size
 ## of the markers used is determined by @var{s}, which can be a scalar or
@@ -33,17 +33,17 @@
 ## The color of the markers is determined by @var{c}, which can be a string
 ## defining a fixed color; a 3-element vector giving the red, green, and blue
 ## components of the color; a vector of the same length as @var{x} that gives
 ## a scaled index into the current colormap; or a @var{n}-by-3 matrix defining
 ## the colors of each of the markers individually.
 ##
 ## The marker to use can be changed with the @var{style} argument, that is a
 ## string defining a marker in the same manner as the @code{plot} command.
-## If the argument 'filled' is given then the markers as filled.  All
+## If the argument "filled" is given then the markers as filled.  All
 ## additional arguments are passed to the underlying patch command.
 ##
 ## The optional return value @var{h} is a graphics handle to the hggroup
 ## object representing the points.
 ##
 ## @example
 ## @group
 ## [x, y, z] = peaks (20);
diff --git a/scripts/plot/semilogx.m b/scripts/plot/semilogx.m
--- a/scripts/plot/semilogx.m
+++ b/scripts/plot/semilogx.m
@@ -97,27 +97,27 @@ endfunction
 %!  set (gca, 'xdir', 'reverse', 'activepositionproperty', 'outerposition');
 %!  xlabel ({'semilogx (-x, y)', 'xdir = reversed'});
 
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   a = logspace (-5, 1, 10);
 %!   b = logspace (-5, 1, 10);
-%!   semilogx (a, b)
+%!   semilogx (a, b);
 %!   assert (get (gca, "xscale"), "log");
 %!   assert (get (gca, "yscale"), "linear");
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
 
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
-%!   a = logspace (-5, 1, 10);
-%!   b =-logspace (-5, 1, 10);
+%!   a =-logspace (-5, 1, 10);
+%!   b = logspace (-5, 1, 10);
 %!   semilogx (a, b);
 %!   axis tight;
-%!   assert (all (get (gca, "ytick") < 0));
+%!   assert (all (get (gca, "xtick") < 0));
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
 
diff --git a/scripts/plot/semilogxerr.m b/scripts/plot/semilogxerr.m
--- a/scripts/plot/semilogxerr.m
+++ b/scripts/plot/semilogxerr.m
@@ -58,14 +58,14 @@ function retval = semilogxerr (varargin)
     axes (oldh);
   end_unwind_protect
 
 endfunction
 
 
 %!demo
 %! clf;
-%! x = exp (log(0.01):0.2:log(10));
+%! x = exp (log (0.01):0.2:log (10));
 %! y = wblpdf (x, 2, 2);
 %! ey = 0.5*rand (size (y)) .* y;
 %! semilogxerr (x, y, ey, '#~x-');
 %! xlim (x([1, end]));
 
diff --git a/scripts/plot/semilogy.m b/scripts/plot/semilogy.m
--- a/scripts/plot/semilogy.m
+++ b/scripts/plot/semilogy.m
@@ -70,35 +70,35 @@ endfunction
 %! y = (x .* (1 + rand (size (x)))) .^ 2;
 %! semilogy (x, y);
 
 %!demo
 %! clf;
 %! x = logspace (-5, 1, 10);
 %! y = logspace (-5, 1, 10);
 %!
-%! subplot (2, 1, 1);
+%! subplot (2,1,1);
 %! semilogy (x, y);
 %! ylabel ('semilogy (x, y)');
 %!
-%! subplot (2, 1, 2);
+%! subplot (2,1,2);
 %! semilogy (x, -y);
 %! ylabel ('semilogy (x, -y)');
 
 %!demo
 %! clf;
 %! x = logspace (-5, 1, 10);
 %! y = logspace (-5, 1, 10);
 %!
-%! subplot (2, 1, 1);
+%! subplot (2,1,1);
 %! semilogy (x, y);
 %! set (gca, 'ydir', 'reverse', 'activepositionproperty', 'outerposition');
 %! ylabel ({'semilogy (x, y)', 'ydir = reversed'});
 %!
-%! subplot (2, 1, 2);
+%! subplot (2,1,2);
 %! semilogy (x, -y);
 %! set (gca, 'ydir', 'reverse', 'activepositionproperty', 'outerposition');
 %! ylabel ({'semilogy (x, -y)', 'ydir = reversed'});
 
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   a = logspace (-5, 1, 10);
diff --git a/scripts/plot/stem.m b/scripts/plot/stem.m
--- a/scripts/plot/stem.m
+++ b/scripts/plot/stem.m
@@ -34,42 +34,42 @@
 ## The default color is @code{"b"} (blue).  The default line style is
 ## @code{"-"} and the default marker is @code{"o"}.  The line style can
 ## be altered by the @code{linespec} argument in the same manner as the
 ## @code{plot} command.  For example,
 ##
 ## @example
 ## @group
 ## x = 1:10;
-## y = ones (1, length (x))*2.*x;
+## y = 2*x;
 ## stem (x, y, "r");
 ## @end group
 ## @end example
 ##
 ## @noindent
 ## plots 10 stems with heights from 2 to 20 in red;
 ##
 ## The optional return value @var{h} is a vector of "stem series" graphics
 ## handles with one handle per column of the variable @var{y}.  The
 ## handle regroups the elements of the stem graph together as the
 ## children of the "stem series" handle, allowing them to be altered
 ## together.  For example,
 ##
 ## @example
 ## @group
-## x = [0 : 10]';
+## x = [0:10]';
 ## y = [sin(x), cos(x)]
 ## h = stem (x, y);
 ## set (h(2), "color", "g");
 ## set (h(1), "basevalue", -1)
 ## @end group
 ## @end example
 ##
 ## @noindent
-## changes the color of the second "stem series"  and moves the base line
+## changes the color of the second "stem series" and moves the base line
 ## of the first.
 ## @seealso{bar, barh, plot}
 ## @end deftypefn
 
 ## Author: Michel D. Schmid <michaelschmid@users.sourceforge.net>
 ## Adapted-by: jwe
 
 function h = stem (varargin)
@@ -123,10 +123,10 @@ endfunction
 %! h = stem (x, y, 'filled');
 
 %!demo
 %! clf;
 %! x = (0 : 10)';
 %! y = [sin(x), cos(x)];
 %! h = stem (x, y);
 %! set (h(2), 'color', 'g');
-%! set (h(1), 'basevalue', -1)
+%! set (h(1), 'basevalue', -1);
 
diff --git a/scripts/plot/stem3.m b/scripts/plot/stem3.m
--- a/scripts/plot/stem3.m
+++ b/scripts/plot/stem3.m
@@ -51,10 +51,10 @@ function h = stem3 (varargin)
   endif
 
 endfunction
 
 
 %!demo
 %! clf;
 %! theta = 0:0.2:6;
-%! stem3 (cos(theta), sin(theta), theta);
+%! stem3 (cos (theta), sin (theta), theta);
 
diff --git a/scripts/plot/subplot.m b/scripts/plot/subplot.m
--- a/scripts/plot/subplot.m
+++ b/scripts/plot/subplot.m
@@ -51,17 +51,17 @@
 ## +-----+-----+-----+
 ## @end group
 ## @end example
 ##
 ## @var{index} may be a vector.  In which case, the new axis will enclose
 ## the grid locations specified.  The first demo illustrates an example:
 ##
 ## @example
-## @code{demo ("subplot", 1)}
+## demo ("subplot", 1)
 ## @end example
 ##
 ## @end ifnottex
 ## @seealso{axes, plot}
 ## @end deftypefn
 
 ## Author: Vinayak Dutt <Dutt.Vinayak@mayo.EDU>
 ## Adapted-By: jwe
@@ -322,16 +322,17 @@ function pos = subplot_position (rows, c
     pos = [x0, y0, x1-x0, y1-y0];
   else
     ## subplot (row, col, num)
     pos = [x0, y0, width, height];
   endif
 
 endfunction
 
+
 %!demo
 %! clf;
 %! r = 3;
 %! c = 3;
 %! fmt = {'horizontalalignment', 'center', 'verticalalignment', 'middle'};
 %! for n = 1 : r*c
 %!   subplot (r, c, n);
 %!   xlabel (sprintf ('xlabel #%d', n));
@@ -346,20 +347,20 @@ endfunction
 %! title (sprintf ('title #%d:%d', 1, 3));
 %! text (0.5, 0.5, sprintf('subplot(%d,%d,%d:%d)', r, c, 1, 3), fmt{:});
 %! axis ([0 1 0 1]);
 
 %!demo
 %! clf;
 %! x = 0:1;
 %! for n = 1:4
-%!   subplot (2, 2, n, 'align');
+%!   subplot (2,2,n, 'align');
 %!   plot (x, x);
 %!   xlabel (sprintf ('xlabel (2,2,%d)', n));
 %!   ylabel (sprintf ('ylabel (2,2,%d)', n));
 %!   title (sprintf ('title (2,2,%d)', n));
 %! end
-%! subplot (1, 2, 1, 'align');
+%! subplot (1,2,1, 'align');
 %! plot (x, x);
 %! xlabel ('xlabel (1,2,1)');
 %! ylabel ('ylabel (1,2,1)');
 %! title ('title (1,2,1)');
 
diff --git a/scripts/plot/surfl.m b/scripts/plot/surfl.m
--- a/scripts/plot/surfl.m
+++ b/scripts/plot/surfl.m
@@ -52,17 +52,17 @@
 ## impression of a lighted surface.  Please note: the alternative "light"
 ## mode, which creates a light object to illuminate the surface is not
 ## implemented (yet).
 ##
 ## Example:
 ##
 ## @example
 ## @group
-## colormap (bone);
+## colormap (bone (64));
 ## surfl (peaks);
 ## shading interp;
 ## @end group
 ## @end example
 ## @seealso{surf, diffuse, specular, surface}
 ## @end deftypefn
 
 ## Author: Kai Habel <kai.habel@gmx.de>
diff --git a/scripts/plot/surfnorm.m b/scripts/plot/surfnorm.m
--- a/scripts/plot/surfnorm.m
+++ b/scripts/plot/surfnorm.m
@@ -22,18 +22,18 @@
 ## @deftypefnx {Function File} {[@var{nx}, @var{ny}, @var{nz}] =} surfnorm (@dots{})
 ## @deftypefnx {Function File} {} surfnorm (@var{h}, @dots{})
 ## Find the vectors normal to a meshgridded surface.  The meshed gridded
 ## surface is defined by @var{x}, @var{y}, and @var{z}.  If @var{x} and
 ## @var{y} are not defined, then it is assumed that they are given by
 ##
 ## @example
 ## @group
-## [@var{x}, @var{y}] = meshgrid (1:size(@var{z}, 1),
-##                      1:size(@var{z}, 2));
+## [@var{x}, @var{y}] = meshgrid (1:size (@var{z}, 1),
+##                    1:size (@var{z}, 2));
 ## @end group
 ## @end example
 ##
 ## If no return arguments are requested, a surface plot with the normal
 ## vectors to the surface is plotted.  Otherwise the components of the normal
 ## vectors at the mesh gridded points are returned in @var{nx}, @var{ny},
 ## and @var{nz}.
 ##
diff --git a/scripts/plot/title.m b/scripts/plot/title.m
--- a/scripts/plot/title.m
+++ b/scripts/plot/title.m
@@ -43,41 +43,41 @@ function retval = title (varargin)
   endif
 
 endfunction
 
 
 %!demo
 %! clf;
 %! ax = axes ();
-%! xl = get (ax,'title');
+%! xl = get (ax, 'title');
 %! title ('Testing title');
 %! assert (get (xl, 'string'), 'Testing title');
 
 %!demo
 %! clf;
 %! plot3 ([0,1], [0,1], [0,1]);
-%! xl = get (gca (), 'title');
+%! xl = get (gca, 'title');
 %! title ('Testing title');
 %! assert (get (xl, 'string'), 'Testing title');
 
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
-%!   ax = axes();
-%!   xl = get (ax,"title");
+%!   ax = axes ();
+%!   xl = get (ax, "title");
 %!   title ("Testing title");
 %!   assert (get (xl, "string"), "Testing title");
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
 
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   plot3 ([0,1], [0,1], [0,1]);
-%!   xl = get (gca (), "title");
+%!   xl = get (gca, "title");
 %!   title ("Testing title");
 %!   assert (get (xl, "string"), "Testing title");
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
 
diff --git a/scripts/plot/uicontextmenu.m b/scripts/plot/uicontextmenu.m
--- a/scripts/plot/uicontextmenu.m
+++ b/scripts/plot/uicontextmenu.m
@@ -12,17 +12,17 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {@var{handle} =} uicontextmenu ('Name', value, @dots{})
+## @deftypefn {Function File} {@var{handle} =} uicontextmenu ("Name", value, @dots{})
 ## @end deftypefn
 
 ## Author: goffioul
 
 function handle = uicontextmenu (varargin)
 
   [h, args] = __uiobject_split_args__ ("uicontextmenu", varargin, {"figure"});
   handle = __go_uicontextmenu__ (h, args{:});
diff --git a/scripts/plot/uicontrol.m b/scripts/plot/uicontrol.m
--- a/scripts/plot/uicontrol.m
+++ b/scripts/plot/uicontrol.m
@@ -12,18 +12,18 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {@var{handle} =} uicontrol ('Name', value, @dots{})
-## @deftypefnx {Function File} {@var{handle} =} uicontrol (@var{parent}, 'Name', value, @dots{})
+## @deftypefn  {Function File} {@var{handle} =} uicontrol ("Name", value, @dots{})
+## @deftypefnx {Function File} {@var{handle} =} uicontrol (@var{parent}, "Name", value, @dots{})
 ## @deftypefnx {Function File} {} uicontrol (@var{handle})
 ## @end deftypefn
 
 ## Author: goffioul
 
 function handle = uicontrol (varargin)
 
   if (nargin == 1 && ishandle (varargin{1}) && strcmpi (get (varargin{1}, "type"), "uicontrol"))
diff --git a/scripts/plot/uigetfile.m b/scripts/plot/uigetfile.m
--- a/scripts/plot/uigetfile.m
+++ b/scripts/plot/uigetfile.m
@@ -186,10 +186,10 @@ function [retfile, retpath, retindex] = 
 
 endfunction
 
 
 %!demo
 %! uigetfile ({'*.gif;*.png;*.jpg', 'Supported Picture Formats'});
 
 ## Remove from test statistics.  No real tests possible.
-%!assert (1);
+%!assert (1)
 
diff --git a/scripts/plot/uimenu.m b/scripts/plot/uimenu.m
--- a/scripts/plot/uimenu.m
+++ b/scripts/plot/uimenu.m
@@ -59,22 +59,22 @@
 ## current position.  It is ignored for top level entries.
 ##
 ## @end table
 ##
 ## Examples:
 ##
 ## @example
 ## @group
-## f = uimenu("label", "&File", "accelerator", "f");
-## e = uimenu("label", "&Edit", "accelerator", "e");
-## uimenu(f, "label", "Close", "accelerator", "q", ...
-##           "callback", "close (gcf)");
-## uimenu(e, "label", "Toggle &Grid", "accelerator", "g", ...
-##           "callback", "grid (gca)");
+## f = uimenu ("label", "&File", "accelerator", "f");
+## e = uimenu ("label", "&Edit", "accelerator", "e");
+## uimenu (f, "label", "Close", "accelerator", "q", ...
+##            "callback", "close (gcf)");
+## uimenu (e, "label", "Toggle &Grid", "accelerator", "g", ...
+##            "callback", "grid (gca)");
 ## @end group
 ## @end example
 ## @seealso{figure}
 ## @end deftypefn
 
 ## Author: Kai Habel
 
 function hui = uimenu (varargin)
diff --git a/scripts/plot/uipanel.m b/scripts/plot/uipanel.m
--- a/scripts/plot/uipanel.m
+++ b/scripts/plot/uipanel.m
@@ -12,18 +12,18 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {@var{handle} =} uipanel ('Name', value, @dots{})
-## @deftypefnx {Function File} {@var{handle} =} uipanel (@var{parent}, 'Name', value, @dots{})
+## @deftypefn  {Function File} {@var{handle} =} uipanel ("Name", value, @dots{})
+## @deftypefnx {Function File} {@var{handle} =} uipanel (@var{parent}, "Name", value, @dots{})
 ## @end deftypefn
 
 ## Author: goffioul
 
 function handle = uipanel (varargin)
 
   [h, args] = __uiobject_split_args__ ("uipanel", varargin, {"figure", "uipanel", "uibuttongroup"});
   handle = __go_uipanel__ (h, args{:});
diff --git a/scripts/plot/uipushtool.m b/scripts/plot/uipushtool.m
--- a/scripts/plot/uipushtool.m
+++ b/scripts/plot/uipushtool.m
@@ -12,18 +12,18 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {@var{handle} =} uipushtool ('Name', value, @dots{})
-## @deftypefnx {Function File} {@var{handle} =} uipushtool (@var{parent}, 'Name', value, @dots{})
+## @deftypefn  {Function File} {@var{handle} =} uipushtool ("Name", value, @dots{})
+## @deftypefnx {Function File} {@var{handle} =} uipushtool (@var{parent}, "Name", value, @dots{})
 ## @end deftypefn
 
 ## Author: goffioul
 
 function handle = uipushtool (varargin)
 
   [h, args] = __uiobject_split_args__ ("uipushtool", varargin, {"uitoolbar"}, 0);
   if (isempty (h))
diff --git a/scripts/plot/uitoggletool.m b/scripts/plot/uitoggletool.m
--- a/scripts/plot/uitoggletool.m
+++ b/scripts/plot/uitoggletool.m
@@ -12,18 +12,18 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {@var{handle} =} uitoggletool ('Name', value, @dots{})
-## @deftypefnx {Function File} {@var{handle} =} uitoggletool (@var{parent}, 'Name', value, @dots{})
+## @deftypefn  {Function File} {@var{handle} =} uitoggletool ("Name", value, @dots{})
+## @deftypefnx {Function File} {@var{handle} =} uitoggletool (@var{parent}, "Name", value, @dots{})
 ## @end deftypefn
 
 ## Author: goffioul
 
 function handle = uitoggletool (varargin)
 
   [h, args] = __uiobject_split_args__ ("uitoggletool", varargin, {"uitoolbar"}, 0);
   if (isempty (h))
diff --git a/scripts/plot/uitoolbar.m b/scripts/plot/uitoolbar.m
--- a/scripts/plot/uitoolbar.m
+++ b/scripts/plot/uitoolbar.m
@@ -12,18 +12,18 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {@var{handle} =} uitoolbar ('Name', value, @dots{})
-## @deftypefnx {Function File} {@var{handle} =} uitoolbar (@var{parent}, 'Name', value, @dots{})
+## @deftypefn  {Function File} {@var{handle} =} uitoolbar ("Name", value, @dots{})
+## @deftypefnx {Function File} {@var{handle} =} uitoolbar (@var{parent}, "Name", value, @dots{})
 ## @end deftypefn
 
 ## Author: goffioul
 
 function handle = uitoolbar (varargin)
 
   [h, args] = __uiobject_split_args__ ("uitoolbar", varargin, {"figure"});
   handle = __go_uitoolbar__ (h, args{:});
diff --git a/scripts/plot/uiwait.m b/scripts/plot/uiwait.m
--- a/scripts/plot/uiwait.m
+++ b/scripts/plot/uiwait.m
@@ -24,19 +24,19 @@
 ## deleted or @code{uiresume} is called.  When no figure handle is specified,
 ## this function uses the current figure.
 ##
 ## If the figure handle is invalid or there is no current figure, this
 ## functions returns immediately.
 ##
 ## When specified, @var{timeout} defines the number of seconds to wait
 ## for the figure deletion or the @code{uiresume} call.  The timeout value
-## must be at least 1. If a smaller value is specified, a warning is issued
+## must be at least 1.  If a smaller value is specified, a warning is issued
 ## and a timeout value of 1 is used instead.  If a non-integer value is
-## specified, it is truncated towards 0. If @var{timeout} is not specified,
+## specified, it is truncated towards 0.  If @var{timeout} is not specified,
 ## the program execution is suspended indefinitely.
 ## @seealso{uiresume, waitfor}
 ## @end deftypefn
 
 ## Author: goffioul
 
 function uiwait (varargin)
 
diff --git a/scripts/plot/view.m b/scripts/plot/view.m
--- a/scripts/plot/view.m
+++ b/scripts/plot/view.m
@@ -89,16 +89,17 @@ function [azimuth, elevation] = view (va
       elevation = el;
     endif
   else
     print_usage ();
   endif
 
 endfunction
 
+
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   plot3 ([0,1], [0,1], [0,1]);
 %!   [az, el] = view;
 %!   assert ([az, el], [-37.5, 30], eps);
 %!   view (2);
 %!   [az, el] = view;
@@ -117,8 +118,9 @@ endfunction
 %!   [az, el] = view;
 %!   assert ([az, el], [0, 90], eps);
 %!   view (3);
 %!   [az, el] = view;
 %!   assert ([az, el], [-37.5, 30], eps);
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
+
diff --git a/scripts/plot/whitebg.m b/scripts/plot/whitebg.m
--- a/scripts/plot/whitebg.m
+++ b/scripts/plot/whitebg.m
@@ -139,16 +139,17 @@ function whitebg (varargin)
       if (isfield (defs, "defaultaxescolor")
           && strcmp (defs.defaultaxescolor, "none"))
         set (0, "defaultaxescolor", color);
       endif
     endif
   endif
 endfunction
 
+
 %!test
 %! dac = get (0, "defaultaxescolor");
 %! dfc = get (0, "defaultfigurecolor");
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   l = line;
 %!   assert (get (hf, "color"), dfc);
 %!   assert (get (gca, "color"), dac);
@@ -157,8 +158,9 @@ endfunction
 %!   assert (get (gca, "color"), 1 - dac);
 %!   c = [0.2 0.2 0.2];
 %!   whitebg (hf, c);
 %!   assert (get (hf, "color"), 1 - dfc);
 %!   assert (get (gca, "color"), c);
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
+
diff --git a/scripts/plot/xlim.m b/scripts/plot/xlim.m
--- a/scripts/plot/xlim.m
+++ b/scripts/plot/xlim.m
@@ -18,27 +18,27 @@
 
 ## -*- texinfo -*-
 ## @c List other forms of function in documentation index
 ## @findex ylim
 ## @findex zlim
 ##
 ## @deftypefn  {Function File} {@var{xl} =} xlim ()
 ## @deftypefnx {Function File} {} xlim (@var{xl})
-## @deftypefnx {Function File} {@var{m} =} xlim ('mode')
+## @deftypefnx {Function File} {@var{m} =} xlim ("mode")
 ## @deftypefnx {Function File} {} xlim (@var{m})
 ## @deftypefnx {Function File} {} xlim (@var{h}, @dots{})
 ## Get or set the limits of the x-axis of the current plot.  Called without
 ## arguments @code{xlim} returns the x-axis limits of the current plot.
 ## If passed a two element vector @var{xl}, the limits of the x-axis are set
 ## to this value.
 ##
 ## The current mode for calculation of the x-axis can be returned with a
-## call @code{xlim ('mode')}, and can be either 'auto' or 'manual'.  The
-## current plotting mode can be set by passing either 'auto' or 'manual'
+## call @code{xlim ("mode")}, and can be either "auto" or "manual".  The
+## current plotting mode can be set by passing either "auto" or "manual"
 ## as the argument.
 ##
 ## If passed a handle as the first argument, then operate on this handle
 ## rather than the current axes handle.
 ## @seealso{ylim, zlim, set, get, gca}
 ## @end deftypefn
 
 function retval = xlim (varargin)
diff --git a/scripts/plot/ylim.m b/scripts/plot/ylim.m
--- a/scripts/plot/ylim.m
+++ b/scripts/plot/ylim.m
@@ -14,27 +14,27 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{yl} =} ylim ()
 ## @deftypefnx {Function File} {} ylim (@var{yl})
-## @deftypefnx {Function File} {@var{m} =} ylim ('mode')
+## @deftypefnx {Function File} {@var{m} =} ylim ("mode")
 ## @deftypefnx {Function File} {} ylim (@var{m})
 ## @deftypefnx {Function File} {} ylim (@var{h}, @dots{})
 ## Get or set the limits of the y-axis of the current plot.  Called without
 ## arguments @code{ylim} returns the y-axis limits of the current plot.
 ## If passed a two element vector @var{yl}, the limits of the y-axis are set
 ## to this value.
 ##
 ## The current mode for calculation of the y-axis can be returned with a
-## call @code{ylim ('mode')}, and can be either 'auto' or 'manual'.  The
-## current plotting mode can be set by passing either 'auto' or 'manual'
+## call @code{ylim ("mode")}, and can be either "auto" or "manual".  The
+## current plotting mode can be set by passing either "auto" or "manual"
 ## as the argument.
 ##
 ## If passed a handle as the first argument, then operate on this handle
 ## rather than the current axes handle.
 ## @seealso{xlim, zlim, set, get, gca}
 ## @end deftypefn
 
 function retval = ylim (varargin)
diff --git a/scripts/plot/zlim.m b/scripts/plot/zlim.m
--- a/scripts/plot/zlim.m
+++ b/scripts/plot/zlim.m
@@ -14,27 +14,27 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{zl} =} zlim ()
 ## @deftypefnx {Function File} {} zlim (@var{zl})
-## @deftypefnx {Function File} {@var{m} =} zlim ('mode')
+## @deftypefnx {Function File} {@var{m} =} zlim ("mode")
 ## @deftypefnx {Function File} {} zlim (@var{m})
 ## @deftypefnx {Function File} {} zlim (@var{h}, @dots{})
 ## Get or set the limits of the z-axis of the current plot.  Called without
 ## arguments @code{zlim} returns the z-axis limits of the current plot.
 ## If passed a two element vector @var{zl}, the limits of the z-axis are set
 ## to this value.
 ##
 ## The current mode for calculation of the z-axis can be returned with a
-## call @code{zlim ('mode')}, and can be either 'auto' or 'manual'.  The
-## current plotting mode can be set by passing either 'auto' or 'manual'
+## call @code{zlim ("mode")}, and can be either "auto" or "manual".  The
+## current plotting mode can be set by passing either "auto" or "manual"
 ## as the argument.
 ##
 ## If passed a handle as the first argument, then operate on this handle
 ## rather than the current axes handle.
 ## @seealso{xlim, ylim, set, get, gca}
 ## @end deftypefn
 
 function retval = zlim (varargin)
diff --git a/scripts/polynomial/compan.m b/scripts/polynomial/compan.m
--- a/scripts/polynomial/compan.m
+++ b/scripts/polynomial/compan.m
@@ -74,20 +74,17 @@ function A = compan (c)
     A = [];
   else
     A = diag (ones (n-2, 1), -1);
     A(1,:) = -c(2:n) / c(1);
   endif
 
 endfunction
 
-%!assert(all (all (compan ([1, 2, 3]) == [-2, -3; 1, 0])));
-
-%!assert(all (all (compan ([1; 2; 3]) == [-2, -3; 1, 0])));
-
-%!assert(isempty (compan (4)));
 
-%!assert(all (all (compan ([3, 2, 1]) == [-2/3, -1/3; 1, 0])));
+%!assert (compan ([1, 2, 3]), [-2, -3; 1, 0])
+%!assert (compan ([1; 2; 3]), [-2, -3; 1, 0])
+%!assert (isempty (compan (4)))
+%!assert (compan ([3, 2, 1]), [-2/3, -1/3; 1, 0])
 
-%!error compan ([1,2;3,4]);
+%!error compan ([1,2;3,4])
+%!error compan ([])
 
-%!error compan ([]);
-
diff --git a/scripts/polynomial/conv.m b/scripts/polynomial/conv.m
--- a/scripts/polynomial/conv.m
+++ b/scripts/polynomial/conv.m
@@ -46,22 +46,22 @@
 function y = conv (a, b, shape = "full")
 
   if (nargin < 2 || nargin > 3)
     print_usage ();
   endif
 
   if (! (isvector (a) && isvector (b)))
     error ("conv: both arguments A and B must be vectors");
-  elseif (nargin == 3 && ! any (strcmpi (shape, {"full", "same"})))
-    error ('conv: SHAPE argument must be "full" or "same"');
+  elseif (nargin == 3 && ! any (strcmpi (shape, {"full", "same", "valid"})))
+    error ('conv: SHAPE argument must be "full", "same", or "valid"');
   endif
 
-  la = length (a);
-  lb = length (b);
+  la = la_orig = length (a);
+  lb = lb_orig = length (b);
 
   ly = la + lb - 1;
 
   if (ly == 0)
     y = zeros (1, 0);
     return;
   endif
 
@@ -74,68 +74,73 @@ function y = conv (a, b, shape = "full")
 
   ## Pad longer vector to convolution length.
   if (ly > lb)
     x(end+1:end+ly-lb) = 0;
   endif
 
   y = filter (a, 1, x);
 
-  if (strcmp (shape, "same"))
+  if (strcmpi (shape, "same"))
     idx = ceil ((ly - la) / 2);
     y = y(idx+1:idx+la);
+  elseif (strcmpi (shape, "valid"))
+    len = la_orig - lb_orig;
+    y = y(lb_orig:lb_orig+len);
   endif
 
 endfunction
 
 
 %!test
-%!  x = ones(3,1);
-%!  y = ones(1,3);
-%!  b = 2;
-%!  c = 3;
-%!  assert (conv (x, x), [1; 2; 3; 2; 1]);
-%!  assert (conv (y, y), [1, 2, 3, 2, 1]);
-%!  assert (conv (x, y), [1, 2, 3, 2, 1]);
-%!  assert (conv (y, x), [1; 2; 3; 2; 1]);
-%!  assert (conv (c, x), [3; 3; 3]);
-%!  assert (conv (c, y), [3, 3, 3]);
-%!  assert (conv (x, c), [3; 3; 3]);
-%!  assert (conv (y, c), [3, 3, 3]);
-%!  assert (conv (b, c), 6);
+%! x = ones (3,1);
+%! y = ones (1,3);
+%! b = 2;
+%! c = 3;
+%! assert (conv (x, x), [1; 2; 3; 2; 1]);
+%! assert (conv (y, y), [1, 2, 3, 2, 1]);
+%! assert (conv (x, y), [1, 2, 3, 2, 1]);
+%! assert (conv (y, x), [1; 2; 3; 2; 1]);
+%! assert (conv (c, x), [3; 3; 3]);
+%! assert (conv (c, y), [3, 3, 3]);
+%! assert (conv (x, c), [3; 3; 3]);
+%! assert (conv (y, c), [3, 3, 3]);
+%! assert (conv (b, c), 6);
 
+%!shared a,b
 %!test
-%!  a = 1:10;
-%!  b = 1:3;
-%!  assert (size (conv(a,b)), [1, numel(a)+numel(b)-1]);
-%!  assert (size (conv(b,a)), [1, numel(a)+numel(b)-1]);
+%! a = 1:10;
+%! b = 1:3;
+%!assert (size (conv (a,b)), [1, numel(a)+numel(b)-1])
+%!assert (size (conv (b,a)), [1, numel(a)+numel(b)-1])
 
 %!test
-%!  a = (1:10).';
-%!  b = 1:3;
-%!  assert (size (conv(a,b)), [numel(a)+numel(b)-1, 1]);
-%!  assert (size (conv(b,a)), [numel(a)+numel(b)-1, 1]);
+%! a = (1:10).';
+%!assert (size (conv (a,b)), [numel(a)+numel(b)-1, 1])
+%!assert (size (conv (b,a)), [numel(a)+numel(b)-1, 1])
+
+%!test
+%! a = 1:10;
+%! b = (1:3).';
+%!assert (size (conv (a,b)), [1, numel(a)+numel(b)-1])
+%!assert (size (conv (b,a)), [1, numel(a)+numel(b)-1])
 
 %!test
-%!  a = 1:10;
-%!  b = (1:3).';
-%!  assert (size (conv(a,b)), [1, numel(a)+numel(b)-1]);
-%!  assert (size (conv(b,a)), [1, numel(a)+numel(b)-1]);
+%! a = 1:10;
+%! b = 1:3;
+
+%!assert (conv (a,b,"full"), conv (a,b))
+%!assert (conv (b,a,"full"), conv (b,a))
 
-%!test
-%!  a = 1:10;
-%!  b = 1:3;
-%!  assert (conv (a,b,"full"), conv (a,b));
-%!  assert (conv (b,a,"full"), conv (b,a));
+%!assert (conv (a,b,"same"), [4, 10, 16, 22, 28, 34, 40, 46, 52, 47])
+%!assert (conv (b,a,"same"), [28, 34, 40])
 
-%!test
-%!  a = 1:10;
-%!  b = 1:3;
-%!  assert (conv (a,b,"same"), [4, 10, 16, 22, 28, 34, 40, 46, 52, 47]);
-%!  assert (conv (b,a,"same"), [28, 34, 40]);
+%!assert (conv (a,b,"valid"), [10, 16, 22, 28, 34, 40, 46, 52])
+%!assert (conv (b,a,"valid"), zeros (1,0))
+
 
 %% Test input validation
 %!error conv (1)
 %!error conv (1,2,3,4)
-%!error conv ([1, 2; 3, 4], 3)
-%!error conv (3, [1, 2; 3, 4])
-%!error conv (2, 3, "XXXX")
+%!error <A and B must be vectors> conv ([1, 2; 3, 4], 3)
+%!error <A and B must be vectors> conv (3, [1, 2; 3, 4])
+%!error <SHAPE argument must be> conv (2, 3, "INVALID_SHAPE")
 
diff --git a/scripts/polynomial/deconv.m b/scripts/polynomial/deconv.m
--- a/scripts/polynomial/deconv.m
+++ b/scripts/polynomial/deconv.m
@@ -76,35 +76,39 @@ function [b, r] = deconv (y, a)
     if (ly < la)
       ## Trim the remainder is equal to the length of Y.
       r = r(end-(length(y)-1):end);
     endif
   endif
 
 endfunction
 
+
 %!test
 %! [b, r] = deconv ([3, 6, 9, 9], [1, 2, 3]);
-%! assert(all (all (b == [3, 0])) && all (all (r == [0, 0, 0, 9])));
+%! assert (b, [3, 0]);
+%! assert (r, [0, 0, 0, 9]);
 
 %!test
 %! [b, r] = deconv ([3, 6], [1, 2, 3]);
-%! assert(b == 0 && all (all (r == [3, 6])));
+%! assert (b, 0);
+%! assert (r, [3, 6]);
 
 %!test
 %! [b, r] = deconv ([3, 6], [1; 2; 3]);
-%! assert(b == 0 && all (all (r == [3, 6])));
+%! assert (b, 0);
+%! assert (r, [3, 6]);
 
 %!test
 %! [b,r] = deconv ([3; 6], [1; 2; 3]);
-%! assert (b == 0 && all (all (r == [3; 6])))
+%! assert (b, 0);
+%! assert (r, [3; 6]);
 
 %!test
 %! [b, r] = deconv ([3; 6], [1, 2, 3]);
-%! assert (b == 0 && all (all (r == [3; 6])))
-
-%!test
-%! assert (deconv ((1:3)',[1, 1]), [1; 1])
+%! assert (b, 0);
+%! assert (r, [3; 6]);
 
-%!error [b, r] = deconv ([3, 6], [1, 2; 3, 4]);
+%!assert (deconv ((1:3)',[1, 1]), [1; 1])
 
-%!error [b, r] = deconv ([3, 6; 1, 2], [1, 2, 3]);
+%!error [b, r] = deconv ([3, 6], [1, 2; 3, 4])
+%!error [b, r] = deconv ([3, 6; 1, 2], [1, 2, 3])
 
diff --git a/scripts/polynomial/mkpp.m b/scripts/polynomial/mkpp.m
--- a/scripts/polynomial/mkpp.m
+++ b/scripts/polynomial/mkpp.m
@@ -83,32 +83,32 @@ endfunction
 %!demo # linear interpolation
 %! x = linspace (0,pi,5)';
 %! t = [sin(x), cos(x)];
 %! m = diff (t) ./ (x(2)-x(1));
 %! b = t(1:4,:);
 %! pp = mkpp (x, [m(:),b(:)]);
 %! xi = linspace (0,pi,50);
 %! plot (x,t,"x", xi,ppval (pp,xi));
-%! legend ("control","interp");
+%! legend ("control", "interp");
 
 %!shared b,c,pp
 %! b = 1:3; c = 1:24; pp = mkpp (b,c);
-%!assert (pp.pieces, 2);
-%!assert (pp.order, 12);
-%!assert (pp.dim, 1);
-%!assert (size (pp.coefs), [2,12]);
+%!assert (pp.pieces, 2)
+%!assert (pp.order, 12)
+%!assert (pp.dim, 1)
+%!assert (size (pp.coefs), [2,12])
 %! pp = mkpp(b,c,2);
-%!assert (pp.pieces, 2);
-%!assert (pp.order, 6);
-%!assert (pp.dim, 2);
-%!assert (size (pp.coefs), [4,6]);
+%!assert (pp.pieces, 2)
+%!assert (pp.order, 6)
+%!assert (pp.dim, 2)
+%!assert (size (pp.coefs), [4,6])
 %! pp = mkpp(b,c,3);
-%!assert (pp.pieces, 2);
-%!assert (pp.order, 4);
-%!assert (pp.dim, 3);
-%!assert (size (pp.coefs), [6,4]);
+%!assert (pp.pieces, 2)
+%!assert (pp.order, 4)
+%!assert (pp.dim, 3)
+%!assert (size (pp.coefs), [6,4])
 %! pp = mkpp(b,c,[2,3]);
-%!assert (pp.pieces, 2);
-%!assert (pp.order, 2);
-%!assert (pp.dim, [2,3]);
-%!assert (size (pp.coefs), [12,2]);
+%!assert (pp.pieces, 2)
+%!assert (pp.order, 2)
+%!assert (pp.dim, [2,3])
+%!assert (size (pp.coefs), [12,2])
 
diff --git a/scripts/polynomial/mpoles.m b/scripts/polynomial/mpoles.m
--- a/scripts/polynomial/mpoles.m
+++ b/scripts/polynomial/mpoles.m
@@ -33,20 +33,20 @@
 ## poles.  @code{@var{multp}(n)} refers to the multiplicity of the Nth pole
 ## @code{@var{p}(@var{idxp}(n))}.
 ##
 ## For example:
 ##
 ## @example
 ## @group
 ## p = [2 3 1 1 2];
-## [m, n] = mpoles(p);
-##   @result{} m = [1; 1; 2; 1; 2]
-##   @result{} n = [2; 5; 1; 4; 3]
-##   @result{} p(n) = [3, 2, 2, 1, 1]
+## [m, n] = mpoles (p)
+##    @result{} m = [1; 1; 2; 1; 2]
+##    @result{} n = [2; 5; 1; 4; 3]
+##    @result{} p(n) = [3, 2, 2, 1, 1]
 ## @end group
 ## @end example
 ##
 ## @seealso{residue, poly, roots, conv, deconv}
 ## @end deftypefn
 
 ## Author: Ben Abbott <bpabbott@mac.com>
 ## Created: Sept 30, 2007
@@ -111,12 +111,13 @@ function [multp, indx] = mpoles (p, tol,
     indx = [indx; k];
     n = find (multp == 0, 1);
   endwhile
   multp = multp(indx);
   indx = ordr(indx);
 
 endfunction
 
+
 %!test
 %! [mp, n] = mpoles ([0 0], 0.01);
-%! assert (mp, [1; 2])
+%! assert (mp, [1; 2]);
 
diff --git a/scripts/polynomial/pchip.m b/scripts/polynomial/pchip.m
--- a/scripts/polynomial/pchip.m
+++ b/scripts/polynomial/pchip.m
@@ -133,39 +133,39 @@ endfunction
 %! yspline = spline (x,y,xi);
 %! ypchip = pchip (x,y,xi);
 %! title ("pchip and spline fit to discontinuous function");
 %! plot (xi,yspline, xi,ypchip,"-", x,y,"+");
 %! legend ("spline", "pchip", "data");
 %! %-------------------------------------------------------------------
 %! % confirm that pchip agreed better to discontinuous data than spline
 
-%!shared x,y,y2,pp,yi1,yi2,yi3
+%!shared x, y, y2, pp, yi1, yi2, yi3
 %! x = 0:8;
 %! y = [1, 1, 1, 1, 0.5, 0, 0, 0, 0];
 %!assert (pchip (x,y,x), y)
 %!assert (pchip (x,y,x'), y')
 %!assert (pchip (x',y',x'), y')
 %!assert (pchip (x',y',x), y)
 %!assert (isempty (pchip(x',y',[])))
 %!assert (isempty (pchip(x,y,[])))
 %!assert (pchip (x,[y;y],x), [pchip(x,y,x);pchip(x,y,x)])
 %!assert (pchip (x,[y;y],x'), [pchip(x,y,x);pchip(x,y,x)])
 %!assert (pchip (x',[y;y],x), [pchip(x,y,x);pchip(x,y,x)])
 %!assert (pchip (x',[y;y],x'), [pchip(x,y,x);pchip(x,y,x)])
 %!test
-%! x = (0:8)*pi/4; y = [sin(x);cos(x)];
+%! x = (0:8)*pi/4; y = [sin(x); cos(x)];
 %! y2(:,:,1) = y; y2(:,:,2) = y+1; y2(:,:,3) = y-1;
 %! pp = pchip (x, shiftdim (y2,2));
 %! yi1 = ppval (pp, (1:4)*pi/4);
 %! yi2 = ppval (pp, repmat ((1:4)*pi/4, [5,1]));
 %! yi3 = ppval (pp, [pi/2,pi]);
 %!assert (size (pp.coefs), [48,4])
 %!assert (pp.pieces, 8)
 %!assert (pp.order, 4)
 %!assert (pp.dim, [3,2])
 %!assert (ppval (pp,pi), [0,-1;1,0;-1,-2], 1e-14)
-%!assert (yi3(:,:,2), ppval(pp,pi), 1e-14)
+%!assert (yi3(:,:,2), ppval (pp,pi), 1e-14)
 %!assert (yi3(:,:,1), [1,0;2,1;0,-1], 1e-14)
 %!assert (squeeze (yi1(1,2,:)), [1/sqrt(2); 0; -1/sqrt(2);-1], 1e-14)
 %!assert (size (yi2), [3,2,5,4])
 %!assert (squeeze (yi2(1,2,3,:)), [1/sqrt(2); 0; -1/sqrt(2);-1], 1e-14)
 
diff --git a/scripts/polynomial/poly.m b/scripts/polynomial/poly.m
--- a/scripts/polynomial/poly.m
+++ b/scripts/polynomial/poly.m
@@ -22,20 +22,20 @@
 ## If @var{A} is a square @math{N}-by-@math{N} matrix, @code{poly (@var{A})}
 ## is the row vector of the coefficients of @code{det (z * eye (N) - A)},
 ## the characteristic polynomial of @var{A}.  For example,
 ## the following code finds the eigenvalues of @var{A} which are the roots of
 ## @code{poly (@var{A})}.
 ##
 ## @example
 ## @group
-## roots(poly(eye(3)))
-## @result{} 1.00001 + 0.00001i
-## @result{} 1.00001 - 0.00001i
-## @result{} 0.99999 + 0.00000i
+## roots (poly (eye (3)))
+##     @result{} 1.00001 + 0.00001i
+##        1.00001 - 0.00001i
+##        0.99999 + 0.00000i
 ## @end group
 ## @end example
 ##
 ## In fact, all three eigenvalues are exactly 1 which emphasizes that for
 ## numerical performance the @code{eig} function should be used to compute
 ## eigenvalues.
 ##
 ## If @var{x} is a vector, @code{poly (@var{x})} is a vector of the
@@ -76,16 +76,15 @@ function y = poly (x)
   endfor
 
   if (all (all (imag (x) == 0)))
     y = real (y);
   endif
 
 endfunction
 
-%!assert(all (all (poly ([1, 2, 3]) == [1, -6, 11, -6])));
-
-%!assert(all (all (abs (poly ([1, 2; 3, 4]) - [1, -5, -2]) < sqrt (eps))));
 
-%!error poly ([1, 2, 3; 4, 5, 6]);
+%!assert (poly ([]), 1)
+%!assert (poly ([1, 2, 3]), [1, -6, 11, -6])
+%!assert (poly ([1, 2; 3, 4]), [1, -5, -2], sqrt (eps))
 
-%!assert(poly ([]),1);
+%!error poly ([1, 2, 3; 4, 5, 6])
 
diff --git a/scripts/polynomial/polyaffine.m b/scripts/polynomial/polyaffine.m
--- a/scripts/polynomial/polyaffine.m
+++ b/scripts/polynomial/polyaffine.m
@@ -19,23 +19,22 @@
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} polyaffine (@var{f}, @var{mu})
 ## Return the coefficients of the polynomial vector @var{f} after an affine
 ## transformation.  If @var{f} is the vector representing the polynomial f(x),
 ## then @code{@var{g} = polyaffine (@var{f}, @var{mu})} is the vector
 ## representing:
 ##
 ## @example
-## g(x) = f((x-@var{mu}(1))/@var{mu}(2)).
+## g(x) = f( (x - @var{mu}(1)) / @var{mu}(2) )
 ## @end example
 ##
 ## @seealso{polyval, polyfit}
 ## @end deftypefn
 
-
 function g = polyaffine (f, mu)
 
    if (nargin != 2)
       print_usage ();
    endif
 
    if (! isvector (f))
       error ("polyaffine: F must be a vector");
diff --git a/scripts/polynomial/polyder.m b/scripts/polynomial/polyder.m
--- a/scripts/polynomial/polyder.m
+++ b/scripts/polynomial/polyder.m
@@ -86,14 +86,15 @@ function [q, d] = polyder (p, a)
     endif
   else
     print_usage ();
   endif
 
 endfunction
 
 
-%!assert(all (all (polyder ([1, 2, 3]) == [2, 2])));
-%!assert(polyder (13) == 0);
+%!assert (polyder ([1, 2, 3], [2, 2]))
+%!assert (polyder (13), 0)
 
-%!error polyder ([]);
-%!error polyder ([1, 2; 3, 4]);
+%!error polyder ([])
+%!error polyder (1,2,3)
+%!error <argument must be a vector> polyder ([1, 2; 3, 4])
 
diff --git a/scripts/polynomial/polyfit.m b/scripts/polynomial/polyfit.m
--- a/scripts/polynomial/polyfit.m
+++ b/scripts/polynomial/polyfit.m
@@ -17,54 +17,65 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{p} =} polyfit (@var{x}, @var{y}, @var{n})
 ## @deftypefnx {Function File} {[@var{p}, @var{s}] =} polyfit (@var{x}, @var{y}, @var{n})
 ## @deftypefnx {Function File} {[@var{p}, @var{s}, @var{mu}] =} polyfit (@var{x}, @var{y}, @var{n})
 ## Return the coefficients of a polynomial @var{p}(@var{x}) of degree
 ## @var{n} that minimizes the least-squares-error of the fit to the points
-## @code{[@var{x}, @var{y}]}.
+## @code{[@var{x}, @var{y}]}. If @var{n} is a logical vector, it is used
+## as a mask to selectivelly force the corresponding polynomial
+## coefficients to be used or ignored.
 ##
 ## The polynomial coefficients are returned in a row vector.
 ##
 ## The optional output @var{s} is a structure containing the following fields:
 ##
 ## @table @samp
 ## @item R
 ## Triangular factor R from the QR@tie{}decomposition.
 ##
 ## @item X
 ## The Vandermonde matrix used to compute the polynomial coefficients.
 ##
+## @item C
+## The unscaled covariance matrix, formally equal to the inverse of
+## @var{x'}*@var{x}, but computed in a way minimizing roundoff error
+## propagation.
+## 
 ## @item df
 ## The degrees of freedom.
 ##
 ## @item normr
 ## The norm of the residuals.
 ##
 ## @item yf
 ## The values of the polynomial for each value of @var{x}.
 ## @end table
 ##
 ## The second output may be used by @code{polyval} to calculate the
-## statistical error limits of the predicted values.
+## statistical error limits of the predicted values. In particular, the
+## standard deviation of @var{p} coefficients is given by @*
+## @code{sqrt (diag (s.C)/s.df)*s.normr}.
 ##
 ## When the third output, @var{mu}, is present the
 ## coefficients, @var{p}, are associated with a polynomial in
 ## @var{xhat} = (@var{x}-@var{mu}(1))/@var{mu}(2).
 ## Where @var{mu}(1) = mean (@var{x}), and @var{mu}(2) = std (@var{x}).
 ## This linear transformation of @var{x} improves the numerical
 ## stability of the fit.
 ## @seealso{polyval, polyaffine, roots, vander, zscore}
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Created: 13 December 1994
 ## Adapted-By: jwe
+## Modified on 20120204 by P. Dupuis; added the ability to specify a
+## polynomial mask instead of a polynomial degree.
 
 function [p, s, mu] = polyfit (x, y, n)
 
   if (nargin < 3 || nargin > 4)
     print_usage ();
   endif
 
   if (nargout > 2)
@@ -72,106 +83,128 @@ function [p, s, mu] = polyfit (x, y, n)
     mu = [mean(x), std(x)];
     x = (x - mu(1)) / mu(2);
   endif
 
   if (! size_equal (x, y))
     error ("polyfit: X and Y must be vectors of the same size");
   endif
 
-  if (! (isscalar (n) && n >= 0 && ! isinf (n) && n == fix (n)))
-    error ("polyfit: N must be a non-negative integer");
+  if (islogical (n))
+    polymask = n;
+    ## n is the polynomial degree as given the polymask size; m is the
+    ## effective number of used coefficients.
+    n = length (polymask) - 1; m = sum (polymask) - 1;
+  else
+    if (! (isscalar (n) && n >= 0 && ! isinf (n) && n == fix (n)))
+      error ("polyfit: N must be a non-negative integer");
+    endif
+    polymask = logical (ones (1, n+1)); m = n;
   endif
 
   y_is_row_vector = (rows (y) == 1);
 
   ## Reshape x & y into column vectors.
   l = numel (x);
   x = x(:);
   y = y(:);
 
   ## Construct the Vandermonde matrix.
   v = vander (x, n+1);
 
   ## Solve by QR decomposition.
-  [q, r, k] = qr (v, 0);
+  [q, r, k] = qr (v(:, polymask), 0);
   p = r \ (q' * y);
   p(k) = p;
-
+  
+  if (n ~= m)
+    q = p; p = zeros (n+1, 1); 
+    p(polymask) = q;
+  endif
+  
   if (nargout > 1)
     yf = v*p;
 
     if (y_is_row_vector)
       s.yf = yf.';
     else
       s.yf = yf;
     endif
+    s.X = v; 
 
-    s.R = r;
-    s.X = v;
-    s.df = l - n - 1;
+    ## r.'*r is positive definite if X(:, polymask) is of full rank.
+    ## Invert it by cholinv to avoid taking the square root of squared
+    ## quantities. If cholinv fails, then X(:, polymask) is rank
+    ## deficient and not invertible.
+    try
+      C = cholinv (r.'*r)(k, k);
+    catch
+      C = NaN * ones (m+1, m+1);
+    end_try_catch
+
+    if (n ~= m)
+      ## fill matrices if required
+      s.X(:, ~polymask) = 0;
+      s.R = zeros (n+1, n+1); s.R(polymask, polymask) = r;
+      s.C = zeros (n+1, n+1); s.C(polymask, polymask) = C;
+    else
+      s.R = r; 
+      s.C = C;
+    endif
+    s.df = l - m - 1;
     s.normr = norm (yf - y);
   endif
 
   ## Return a row vector.
   p = p.';
 
 endfunction
 
-%!test
-%! x = [-2, -1, 0, 1, 2];
-%! assert(all (all (abs (polyfit (x, x.^2+x+1, 2) - [1, 1, 1]) < sqrt (eps))));
 
-%!error(polyfit ([1, 2; 3, 4], [1, 2, 3, 4], 2))
-
-%!test
+%!shared x
 %! x = [-2, -1, 0, 1, 2];
-%! assert(all (all (abs (polyfit (x, x.^2+x+1, 3) - [0, 1, 1, 1]) < sqrt (eps))));
-
-%!test
-%! x = [-2, -1, 0, 1, 2];
-%! fail("polyfit (x, x.^2+x+1)");
-
-%!test
-%! x = [-2, -1, 0, 1, 2];
-%! fail("polyfit (x, x.^2+x+1, [])");
+%!assert (polyfit (x, x.^2+x+1, 2), [1, 1, 1], sqrt (eps))
+%!assert (polyfit (x, x.^2+x+1, 3), [0, 1, 1, 1], sqrt (eps))
+%!fail ("polyfit (x, x.^2+x+1)")
+%!fail ("polyfit (x, x.^2+x+1, [])")
 
 ## Test difficult case where scaling is really needed. This example
 ## demonstrates the rather poor result which occurs when the dependent
 ## variable is not normalized properly.
 ## Also check the usage of 2nd & 3rd output arguments.
 %!test
 %! x = [ -1196.4, -1195.2, -1194, -1192.8, -1191.6, -1190.4, -1189.2, -1188, \
 %!       -1186.8, -1185.6, -1184.4, -1183.2, -1182];
 %! y = [ 315571.7086, 315575.9618, 315579.4195, 315582.6206, 315585.4966,    \
 %!       315588.3172, 315590.9326, 315593.5934, 315596.0455, 315598.4201,    \
 %!       315600.7143, 315602.9508, 315605.1765 ];
 %! [p1, s1] = polyfit (x, y, 10);
 %! [p2, s2, mu] = polyfit (x, y, 10);
-%! assert (s2.normr < s1.normr)
+%! assert (s2.normr < s1.normr);
 
 %!test
 %! x = 1:4;
 %! p0 = [1i, 0, 2i, 4];
 %! y0 = polyval (p0, x);
-%! p = polyfit (x, y0, numel(p0)-1);
-%! assert (p, p0, 1000*eps)
+%! p = polyfit (x, y0, numel (p0) - 1);
+%! assert (p, p0, 1000*eps);
 
 %!test
 %! x = 1000 + (-5:5);
 %! xn = (x - mean (x)) / std (x);
 %! pn = ones (1,5);
 %! y = polyval (pn, xn);
-%! [p, s, mu] = polyfit (x, y, numel(pn)-1);
-%! [p2, s2] = polyfit (x, y, numel(pn)-1);
-%! assert (p, pn, s.normr)
-%! assert (s.yf, y, s.normr)
-%! assert (mu, [mean(x), std(x)])
-%! assert (s.normr/s2.normr < sqrt(eps))
+%! [p, s, mu] = polyfit (x, y, numel (pn) - 1);
+%! [p2, s2] = polyfit (x, y, numel (pn) - 1);
+%! assert (p, pn, s.normr);
+%! assert (s.yf, y, s.normr);
+%! assert (mu, [mean(x), std(x)]);
+%! assert (s.normr/s2.normr < sqrt (eps));
 
 %!test
 %! x = [1, 2, 3; 4, 5, 6];
 %! y = [0, 0, 1; 1, 0, 0];
 %! p = polyfit (x, y, 5);
-%! expected = [0, 1, -14, 65, -112, 60]/12;
-%! assert (p, expected, sqrt(eps))
+%! expected = [0, 1, -14, 65, -112, 60] / 12;
+%! assert (p, expected, sqrt (eps));
 
+%!error <vectors of the same size> polyfit ([1, 2; 3, 4], [1, 2, 3, 4], 2)
 
diff --git a/scripts/polynomial/polygcd.m b/scripts/polynomial/polygcd.m
--- a/scripts/polynomial/polygcd.m
+++ b/scripts/polynomial/polygcd.m
@@ -20,26 +20,26 @@
 ## @deftypefn  {Function File} {@var{q} =} polygcd (@var{b}, @var{a})
 ## @deftypefnx {Function File} {@var{q} =} polygcd (@var{b}, @var{a}, @var{tol})
 ##
 ## Find the greatest common divisor of two polynomials.  This is equivalent
 ## to the polynomial found by multiplying together all the common roots.
 ## Together with deconv, you can reduce a ratio of two polynomials.
 ## The tolerance @var{tol} defaults to @code{sqrt(eps)}.
 ##
-## @strong{Caution:} This is a numerically unstable algorithm and should not be used on large polynomials.
+## @strong{Caution:} This is a numerically unstable algorithm and should not
+## be used on large polynomials.
 ##
 ## Example code:
 ##
 ## @example
 ## @group
-## polygcd (poly(1:8), poly(3:12)) - poly(3:8)
+## polygcd (poly (1:8), poly (3:12)) - poly (3:8)
 ## @result{} [ 0, 0, 0, 0, 0, 0, 0 ]
-## deconv (poly(1:8), polygcd (poly(1:8), poly(3:12))) ...
-##   - poly(1:2)
+## deconv (poly (1:8), polygcd (poly (1:8), poly (3:12))) - poly(1:2)
 ## @result{} [ 0, 0, 0 ]
 ## @end group
 ## @end example
 ## @seealso{poly, roots, conv, deconv, residue}
 ## @end deftypefn
 
 function x = polygcd (b, a, tol)
 
@@ -77,26 +77,24 @@ function x = polygcd (b, a, tol)
   else
     print_usage ();
   endif
 
 endfunction
 
 
 %!test
-%! poly1 = [1 6 11 6]; % (x+1)(x+2)(x+3)
-%! poly2 = [1 3 2]; % (x+1)(x+2)
+%! poly1 = [1 6 11 6]; # (x+1)(x+2)(x+3);
+%! poly2 = [1 3 2];    # (x+1)(x+2);
 %! poly3 = polygcd (poly1, poly2);
-%! assert (poly3, poly2, sqrt (eps))
+%! assert (poly3, poly2, sqrt (eps));
 
-%!test
-%! assert (polygcd (poly(1:8), poly(3:12)), poly(3:8), sqrt (eps))
-
-%!test
-%! assert (deconv (poly(1:8), polygcd (poly(1:8), poly(3:12))), poly(1:2), sqrt (eps))
+%!assert (polygcd (poly (1:8), poly (3:12)), poly (3:8), sqrt (eps))
+%!assert (deconv (poly (1:8), polygcd (poly (1:8), poly (3:12))), poly (1:2), sqrt (eps))
 
 %!test
 %! for ii=1:10
 %!   p  = (unique (randn (10, 1)) * 10).';
 %!   p1 = p(3:end);
 %!   p2 = p(1:end-2);
-%!   assert (polygcd (poly (-p1), poly (-p2)), poly (- intersect (p1, p2)), sqrt (eps))
+%!   assert (polygcd (poly (-p1), poly (-p2)), poly (- intersect (p1, p2)), sqrt (eps));
 %! endfor
+
diff --git a/scripts/polynomial/polyint.m b/scripts/polynomial/polyint.m
--- a/scripts/polynomial/polyint.m
+++ b/scripts/polynomial/polyint.m
@@ -56,22 +56,24 @@ function retval = polyint (p, k)
     ## Convert to column vector
     p = p.';
   endif
 
   retval = [(p ./ [lp:-1:1]), k];
 
 endfunction
 
+
 %!test
 %! A = [3, 2, 1];
-%! assert (polyint(A),polyint(A,0));
-%! assert (polyint(A),polyint(A'));
-%! assert (polyint(A),[1, 1, 1, 0]);
-%! assert (polyint(A,1),ones(1,4));
+%! assert (polyint (A), polyint (A,0));
+%! assert (polyint (A), polyint (A'));
+%! assert (polyint (A), [1, 1, 1, 0]);
+%! assert (polyint (A,1), ones (1,4));
 
 %!test
-%! A = ones(1,8);
+%! A = ones (1,8);
 %! B = [length(A):-1:1];
-%! assert (polyint(A),[1./B, 0]);
+%! assert (polyint (A), [1./B, 0]);
 
-%!error polyint()
-%!error polyint(ones(2,2))
+%!error polyint ()
+%!error polyint (ones (2,2))
+
diff --git a/scripts/polynomial/polyout.m b/scripts/polynomial/polyout.m
--- a/scripts/polynomial/polyout.m
+++ b/scripts/polynomial/polyout.m
@@ -22,17 +22,17 @@
 ## @deftypefnx {Function File} {@var{str} =} polyout (@dots{})
 ## Write formatted polynomial
 ## @tex
 ## $$ c(x) = c_1 x^n + \ldots + c_n x + c_{n+1} $$
 ## @end tex
 ## @ifnottex
 ##
 ## @example
-##    c(x) = c(1) * x^n + @dots{} + c(n) x + c(n+1)
+## c(x) = c(1) * x^n + @dots{} + c(n) x + c(n+1)
 ## @end example
 ##
 ## @end ifnottex
 ## and return it as a string or write it to the screen (if @var{nargout} is
 ## zero).  @var{x} defaults to the string @code{"s"}.
 ## @seealso{polyreduce}
 ## @end deftypefn
 
@@ -91,13 +91,16 @@ function str = coeff (c)
     else
       str = num2str (c, 5);
     endif
   else
     str = num2str (c, 5);
   endif
 endfunction
 
-%!assert (polyout ([3 2 1]), '3*s^2 + 2*s^1 + 1')
-%!assert (polyout ([3 2 1], 'x'), '3*x^2 + 2*x^1 + 1')
-%!assert (polyout ([3 2 1], 'wxyz'), '3*wxyz^2 + 2*wxyz^1 + 1')
-%!assert (polyout ([5 4 3 2 1], '1'),'5*1^4 + 4*1^3 + 3*1^2 + 2*1^1 + 1')
+
+%!assert (polyout ([3 2 1]), "3*s^2 + 2*s^1 + 1")
+%!assert (polyout ([3 2 1], "x"), "3*x^2 + 2*x^1 + 1")
+%!assert (polyout ([3 2 1], "wxyz"), "3*wxyz^2 + 2*wxyz^1 + 1")
+%!assert (polyout ([5 4 3 2 1], "1"),"5*1^4 + 4*1^3 + 3*1^2 + 2*1^1 + 1")
+
 %!error polyout ([])
+
diff --git a/scripts/polynomial/polyval.m b/scripts/polynomial/polyval.m
--- a/scripts/polynomial/polyval.m
+++ b/scripts/polynomial/polyval.m
@@ -88,65 +88,66 @@ function [y, dy] = polyval (p, x, s = []
       else
         error ("polyval: third input is not a structure.");
       endif
     end_try_catch
   endif
 
 endfunction
 
-%!test
-%! fail("polyval([1,0;0,1],0:10)");
+
+%!fail ("polyval ([1,0;0,1],0:10)")
 
 %!test
 %! r = 0:10:50;
 %! p = poly (r);
-%! p = p / max(abs(p));
-%! x = linspace(0,50,11);
-%! y = polyval(p,x) + 0.25*sin(100*x);
-%! [pf, s] = polyfit (x, y, numel(r));
+%! p = p / max (abs (p));
+%! x = linspace (0,50,11);
+%! y = polyval (p,x) + 0.25*sin (100*x);
+%! [pf, s] = polyfit (x, y, numel (r));
 %! [y1, delta] = polyval (pf, x, s);
 %! expected = [0.37235, 0.35854, 0.32231, 0.32448, 0.31328, ...
 %!    0.32036, 0.31328, 0.32448, 0.32231, 0.35854, 0.37235];
-%! assert (delta, expected, 0.00001)
+%! assert (delta, expected, 0.00001);
 
 %!test
 %! x = 10 + (-2:2);
 %! y = [0, 0, 1, 0, 2];
 %! p = polyfit (x, y, numel (x) - 1);
 %! [pn, s, mu] = polyfit (x, y, numel (x) - 1);
 %! y1 = polyval (p, x);
 %! yn = polyval (pn, x, [], mu);
-%! assert (y1, y, sqrt(eps))
-%! assert (yn, y, sqrt(eps))
+%! assert (y1, y, sqrt (eps));
+%! assert (yn, y, sqrt (eps));
 
 %!test
 %! p = [0, 1, 0];
 %! x = 1:10;
-%! assert (x, polyval(p,x), eps)
+%! assert (x, polyval (p,x), eps);
 %! x = x(:);
-%! assert (x, polyval(p,x), eps)
+%! assert (x, polyval (p,x), eps);
 %! x = reshape(x, [2, 5]);
-%! assert (x, polyval(p,x), eps)
+%! assert (x, polyval (p,x), eps);
 %! x = reshape(x, [5, 2]);
-%! assert (x, polyval(p,x), eps)
-%! x = reshape(x, [1, 1, 5, 2]);
-%! assert (x, polyval(p,x), eps)
+%! assert (x, polyval (p,x), eps);
+%! x = reshape (x, [1, 1, 5, 2]);
+%! assert (x, polyval (p,x), eps);
 
 %!test
 %! p = [1];
 %! x = 1:10;
-%! y = ones(size(x));
-%! assert (y, polyval(p,x), eps)
+%! y = ones (size (x));
+%! assert (y, polyval (p,x), eps);
 %! x = x(:);
-%! y = ones(size(x));
-%! assert (y, polyval(p,x), eps)
-%! x = reshape(x, [2, 5]);
-%! y = ones(size(x));
-%! assert (y, polyval(p,x), eps)
-%! x = reshape(x, [5, 2]);
-%! y = ones(size(x));
-%! assert (y, polyval(p,x), eps)
-%! x = reshape(x, [1, 1, 5, 2]);
+%! y = ones (size (x));
+%! assert (y, polyval (p,x), eps);
+%! x = reshape (x, [2, 5]);
+%! y = ones (size (x));
+%! assert (y, polyval (p,x), eps);
+%! x = reshape (x, [5, 2]);
+%! y = ones (size (x));
+%! assert (y, polyval (p,x), eps);
+%! x = reshape (x, [1, 1, 5, 2]);
 
 %!assert (zeros (1, 10), polyval ([], 1:10))
 %!assert ([], polyval (1, []))
 %!assert ([], polyval ([], []))
+
diff --git a/scripts/polynomial/polyvalm.m b/scripts/polynomial/polyvalm.m
--- a/scripts/polynomial/polyvalm.m
+++ b/scripts/polynomial/polyvalm.m
@@ -56,13 +56,13 @@ function y = polyvalm (c, x)
     for i = 2:n
       y = y * x + c(i) * id;
     endfor
   endif
 
 endfunction
 
 
-%!assert(! any (polyvalm ([], [1, 2; 3, 4]))(:));
-%!assert(polyvalm ([1, 2, 3, 4], [3, -4, 1; -2, 0, 2; -1, 4, -3]), [117, -124, 11; -70, 36, 38; -43, 92, -45])
+%!assert (! any (polyvalm ([], [1, 2; 3, 4]))(:));
+%!assert (polyvalm ([1, 2, 3, 4], [3, -4, 1; -2, 0, 2; -1, 4, -3]), [117, -124, 11; -70, 36, 38; -43, 92, -45])
 
-%!error polyvalm ([1, 1, 1], [1, 2; 3, 4; 5, 6]);
+%!error <must be a square matrix> polyvalm ([1, 1, 1], [1, 2; 3, 4; 5, 6])
 
diff --git a/scripts/polynomial/ppder.m b/scripts/polynomial/ppder.m
--- a/scripts/polynomial/ppder.m
+++ b/scripts/polynomial/ppder.m
@@ -46,25 +46,29 @@ function ppd = ppder (pp, m)
     ff = bincoeff (f, m + 1) .* factorial (m + 1) ./ f;
     k -= m;
     pd = p(:,1:k) * diag (ff(1:k));
   endif
 
   ppd = mkpp (x, pd, d);
 endfunction
 
+
 %!shared x,y,pp,ppd
-%! x=0:8;y=[x.^2;x.^3+1];pp=spline(x,y);
-%! ppd=ppder(pp);
-%!assert(ppval(ppd,x),[2*x;3*x.^2],1e-14)
-%!assert(ppd.order,3)
-%! ppd=ppder(pp,2);
-%!assert(ppval(ppd,x),[2*ones(size(x));6*x],1e-14)
-%!assert(ppd.order,2)
-%! ppd=ppder(pp,3);
-%!assert(ppd.order,1)
-%!assert(ppd.pieces,8)
-%!assert(size(ppd.coefs),[16,1])
-%! ppd=ppder(pp,4);
-%!assert(ppd.order,1)
-%!assert(ppd.pieces,1)
-%!assert(size(ppd.coefs),[2,1])
-%!assert(ppval(ppd,x),zeros(size(y)),1e-14)
+%! x = 0:8;
+%! y = [x.^2; x.^3+1];
+%! pp = spline (x, y);
+%! ppd = ppder (pp);
+%!assert (ppval (ppd, x), [2*x; 3*x.^2], 1e-14)
+%!assert (ppd.order, 3)
+%! ppd = ppder (pp, 2);
+%!assert (ppval (ppd, x), [2*ones(size (x)); 6*x], 1e-14)
+%!assert (ppd.order, 2)
+%! ppd = ppder (pp, 3);
+%!assert (ppd.order, 1)
+%!assert (ppd.pieces, 8)
+%!assert (size (ppd.coefs), [16, 1])
+%! ppd = ppder (pp, 4);
+%!assert (ppd.order, 1)
+%!assert (ppd.pieces, 1)
+%!assert (size (ppd.coefs), [2, 1])
+%!assert (ppval (ppd,x), zeros (size (y)), 1e-14)
+
diff --git a/scripts/polynomial/ppint.m b/scripts/polynomial/ppint.m
--- a/scripts/polynomial/ppint.m
+++ b/scripts/polynomial/ppint.m
@@ -46,13 +46,17 @@ function ppi = ppint (pp, c)
 
   ppi = mkpp (x, pi, d);
 
   tmp = -cumsum (ppjumps (ppi), length (d) + 1);
   ppi.coefs(prod(d)+1:end, k) = tmp(:);
 
 endfunction
 
+
 %!shared x,y,pp,ppi
-%! x=0:8;y=[ones(size(x));x+1];pp=spline(x,y);
-%! ppi=ppint(pp);
-%!assert(ppval(ppi,x),[x;0.5*x.^2+x],1e-14)
-%!assert(ppi.order,5)
+%! x = 0:8;
+%! y = [ ones(size(x)); x+1 ];
+%! pp = spline (x, y);
+%! ppi = ppint (pp);
+%!assert (ppval (ppi, x), [x; 0.5*x.^2 + x], 1e-14)
+%!assert (ppi.order, 5)
+
diff --git a/scripts/polynomial/ppjumps.m b/scripts/polynomial/ppjumps.m
--- a/scripts/polynomial/ppjumps.m
+++ b/scripts/polynomial/ppjumps.m
@@ -59,26 +59,25 @@ endfunction
 
 
 %!test
 %! p = [1 6 11 6];
 %! x = linspace (5, 6, 4);
 %! y = polyval (p, x);
 %! pp = spline (x, y);
 %! jj = ppjumps (pp);
-%! assert (jj, [0 0], eps)
+%! assert (jj, [0 0], eps);
 
 %!test
-%!
 %! breaks = [0 1 2];
 %! pp1 = poly (-[1 2 3]);
 %! pp2 = poly (-([1 2 3]+1));
 %! pp = mkpp (breaks, [pp1;pp2]);
-%! assert (ppjumps (pp), 0, eps)
+%! assert (ppjumps (pp), 0, eps);
 
 %!test
-%!
 %! breaks = [0 1 2];
 %! pp1 = poly (-[1 2 3]);
 %! pp2 = poly (([1 2 3]+1));
 %! pp = mkpp (breaks, [pp1;pp2]);
 %! j  = - 2 * polyval (pp1, 1);
-%! assert (ppjumps (pp), j, eps)
+%! assert (ppjumps (pp), j, eps);
+
diff --git a/scripts/polynomial/ppval.m b/scripts/polynomial/ppval.m
--- a/scripts/polynomial/ppval.m
+++ b/scripts/polynomial/ppval.m
@@ -97,20 +97,26 @@ function yi = ppval (pp, xi)
 
   ##
   #if (d == 1)
   #  yi = reshape (yi, sxi);
   #endif
 
 endfunction
 
-%!shared b,c,pp,pp2,xi,abserr
-%! b = 1:3; c = ones(2); pp=mkpp(b,c);abserr = 1e-14;pp2=mkpp(b,[c;c],2);
+
+%!shared b, c, pp, pp2, xi, abserr
+%! b = 1:3;
+%! c = ones (2);
+%! pp = mkpp (b, c);
+%! abserr = 1e-14;
+%! pp2 = mkpp (b, [c;c], 2);
 %! xi = [1.1 1.3 1.9 2.1];
-%!assert (ppval(pp,1.1), 1.1, abserr);
-%!assert (ppval(pp,2.1), 1.1, abserr);
-%!assert (ppval(pp,xi), [1.1 1.3 1.9 1.1], abserr);
-%!assert (ppval(pp,xi.'), [1.1 1.3 1.9 1.1].', abserr);
-%!assert (ppval(pp2,1.1), [1.1;1.1], abserr);
-%!assert (ppval(pp2,2.1), [1.1;1.1], abserr);
-%!assert (ppval(pp2,xi), [1.1 1.3 1.9 1.1;1.1 1.3 1.9 1.1], abserr);
-%!assert (ppval(pp2,xi'), [1.1 1.3 1.9 1.1;1.1 1.3 1.9 1.1], abserr);
-%!assert (size(ppval(pp2,[xi;xi])), [2 2 4]);
+%!assert (ppval (pp, 1.1), 1.1, abserr)
+%!assert (ppval (pp, 2.1), 1.1, abserr)
+%!assert (ppval (pp, xi), [1.1 1.3 1.9 1.1], abserr)
+%!assert (ppval (pp, xi.'), [1.1 1.3 1.9 1.1].', abserr)
+%!assert (ppval (pp2, 1.1), [1.1;1.1], abserr)
+%!assert (ppval (pp2, 2.1), [1.1;1.1], abserr)
+%!assert (ppval (pp2, xi), [1.1 1.3 1.9 1.1;1.1 1.3 1.9 1.1], abserr)
+%!assert (ppval (pp2, xi'), [1.1 1.3 1.9 1.1;1.1 1.3 1.9 1.1], abserr)
+%!assert (size (ppval (pp2, [xi;xi])), [2 2 4])
+
diff --git a/scripts/polynomial/residue.m b/scripts/polynomial/residue.m
--- a/scripts/polynomial/residue.m
+++ b/scripts/polynomial/residue.m
@@ -28,40 +28,40 @@
 ## {B(s)\over A(s)} = \sum_{m=1}^M {r_m\over (s-p_m)^e_m}
 ##   + \sum_{i=1}^N k_i s^{N-i}.
 ## $$
 ## @end tex
 ## @ifnottex
 ##
 ## @example
 ## @group
-##  B(s)    M       r(m)         N
-##  ---- = SUM -------------  + SUM k(i)*s^(N-i)
-##  A(s)   m=1 (s-p(m))^e(m)    i=1
+## B(s)    M       r(m)         N
+## ---- = SUM -------------  + SUM k(i)*s^(N-i)
+## A(s)   m=1 (s-p(m))^e(m)    i=1
 ## @end group
 ## @end example
 ##
 ## @end ifnottex
 ## @noindent
 ## where @math{M} is the number of poles (the length of the @var{r},
 ## @var{p}, and @var{e}), the @var{k} vector is a polynomial of order @math{N-1}
 ## representing the direct contribution, and the @var{e} vector specifies
 ## the multiplicity of the m-th residue's pole.
 ##
 ## For example,
 ##
 ## @example
 ## @group
 ## b = [1, 1, 1];
 ## a = [1, -5, 8, -4];
-## [r, p, k, e] = residue (b, a);
-##      @result{} r = [-2; 7; 3]
-##      @result{} p = [2; 2; 1]
-##      @result{} k = [](0x0)
-##      @result{} e = [1; 2; 1]
+## [r, p, k, e] = residue (b, a)
+##    @result{} r = [-2; 7; 3]
+##    @result{} p = [2; 2; 1]
+##    @result{} k = [](0x0)
+##    @result{} e = [1; 2; 1]
 ## @end group
 ## @end example
 ##
 ## @noindent
 ## which represents the following partial fraction expansion
 ## @tex
 ## $$
 ## {s^2+s+1\over s^3-5s^2+8s-4} = {-2\over s-2} + {7\over (s-2)^2} + {3\over s-1}
@@ -90,53 +90,52 @@
 ##
 ## For example:
 ##
 ## @example
 ## @group
 ## r = [-2; 7; 3];
 ## p = [2; 2; 1];
 ## k = [1, 0];
-## [b, a] = residue (r, p, k);
-##      @result{} b = [1, -5, 9, -3, 1]
-##      @result{} a = [1, -5, 8, -4]
+## [b, a] = residue (r, p, k)
+##    @result{} b = [1, -5, 9, -3, 1]
+##    @result{} a = [1, -5, 8, -4]
 ##
 ## where mpoles is used to determine e = [1; 2; 1]
-##
 ## @end group
 ## @end example
 ##
 ## Alternatively the multiplicity may be defined explicitly, for example,
 ##
 ## @example
 ## @group
 ## r = [7; 3; -2];
 ## p = [2; 1; 2];
 ## k = [1, 0];
 ## e = [2; 1; 1];
-## [b, a] = residue (r, p, k, e);
-##      @result{} b = [1, -5, 9, -3, 1]
-##      @result{} a = [1, -5, 8, -4]
+## [b, a] = residue (r, p, k, e)
+##    @result{} b = [1, -5, 9, -3, 1]
+##    @result{} a = [1, -5, 8, -4]
 ## @end group
 ## @end example
 ##
 ## @noindent
 ## which represents the following partial fraction expansion
 ## @tex
 ## $$
 ## {-2\over s-2} + {7\over (s-2)^2} + {3\over s-1} + s = {s^4-5s^3+9s^2-3s+1\over s^3-5s^2+8s-4}
 ## $$
 ## @end tex
 ## @ifnottex
 ##
 ## @example
 ## @group
-##     -2        7        3         s^4 - 5s^3 + 9s^2 - 3s + 1
-##    ----- + ------- + ----- + s = --------------------------
-##    (s-2)   (s-2)^2   (s-1)          s^3 - 5s^2 + 8s - 4
+##  -2        7        3         s^4 - 5s^3 + 9s^2 - 3s + 1
+## ----- + ------- + ----- + s = --------------------------
+## (s-2)   (s-2)^2   (s-1)          s^3 - 5s^2 + 8s - 4
 ## @end group
 ## @end example
 ##
 ## @end ifnottex
 ## @seealso{mpoles, poly, roots, conv, deconv}
 ## @end deftypefn
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
@@ -347,74 +346,77 @@ function [pnum, pden, e] = rresidue (r, 
   pnum(abs (pnum) < small) = 0;
   pden(abs (pden) < small) = 0;
 
   pnum = polyreduce (pnum);
   pden = polyreduce (pden);
 
 endfunction
 
+
 %!test
 %! b = [1, 1, 1];
 %! a = [1, -5, 8, -4];
 %! [r, p, k, e] = residue (b, a);
-%! assert (abs (r - [-2; 7; 3]) < 1e-12
-%!   && abs (p - [2; 2; 1]) < 1e-12
-%!   && isempty (k)
-%!   && e == [1; 2; 1]);
+%! assert (r, [-2; 7; 3], 1e-12);
+%! assert (p, [2; 2; 1], 1e-12);
+%! assert (isempty (k));
+%! assert (e, [1; 2; 1]);
 %! k = [1 0];
 %! b = conv (k, a) + prepad (b, numel (k) + numel (a) - 1, 0);
 %! a = a;
 %! [br, ar] = residue (r, p, k);
-%! assert ((abs (br - b) < 1e-12
-%!   && abs (ar - a) < 1e-12));
+%! assert (br, b, 1e-12);
+%! assert (ar, a, 1e-12);
 %! [br, ar] = residue (r, p, k, e);
-%! assert ((abs (br - b) < 1e-12
-%!   && abs (ar - a) < 1e-12));
+%! assert (br, b, 1e-12);
+%! assert (ar, a, 1e-12);
 
 %!test
 %! b = [1, 0, 1];
 %! a = [1, 0, 18, 0, 81];
 %! [r, p, k, e] = residue (b, a);
 %! r1 = [-5i; 12; +5i; 12]/54;
 %! p1 = [+3i; +3i; -3i; -3i];
-%! assert (abs (r - r1) < 1e-12 && abs (p - p1) < 1e-12
-%!   && isempty (k)
-%!   && e == [1; 2; 1; 2]);
+%! assert (r, r1, 1e-12);
+%! assert (p, p1, 1e-12);
+%! assert (isempty (k));
+%! assert (e, [1; 2; 1; 2]);
 %! [br, ar] = residue (r, p, k);
-%! assert ((abs (br - b) < 1e-12
-%!   && abs (ar - a) < 1e-12));
+%! assert (br, b, 1e-12);
+%! assert (ar, a, 1e-12);
 
 %!test
 %! r = [7; 3; -2];
 %! p = [2; 1; 2];
 %! k = [1 0];
 %! e = [2; 1; 1];
 %! [b, a] = residue (r, p, k, e);
-%! assert ((abs (b - [1, -5, 9, -3, 1]) < 1e-12
-%!   && abs (a - [1, -5, 8, -4]) < 1e-12));
+%! assert (b, [1, -5, 9, -3, 1], 1e-12);
+%! assert (a, [1, -5, 8, -4], 1e-12);
 %! [rr, pr, kr, er] = residue (b, a);
-%! [jnk, n] = mpoles(p);
-%! assert ((abs (rr - r(n)) < 1e-12
-%!   && abs (pr - p(n)) < 1e-12
-%!   && abs (kr - k) < 1e-12
-%!   && abs (er - e(n)) < 1e-12));
+%! [jnk, n] = mpoles (p);
+%! assert (rr, r(n), 1e-12);
+%! assert (pr, p(n), 1e-12);
+%! assert (kr, k, 1e-12);
+%! assert (er, e(n), 1e-12);
 
 %!test
 %! b = [1];
 %! a = [1, 10, 25];
 %! [r, p, k, e] = residue (b, a);
 %! r1 = [0; 1];
 %! p1 = [-5; -5];
-%! assert (abs (r - r1) < 1e-12 && abs (p - p1) < 1e-12
-%!   && isempty (k)
-%!   && e == [1; 2]);
+%! assert (r, r1, 1e-12);
+%! assert (p, p1, 1e-12);
+%! assert (isempty (k));
+%! assert (e, [1; 2]);
 %! [br, ar] = residue (r, p, k);
-%! assert ((abs (br - b) < 1e-12
-%!   && abs (ar - a) < 1e-12));
+%! assert (br, b, 1e-12);
+%! assert (ar, a, 1e-12);
 
 ## The following test is due to Bernard Grung (bug #34266)
 %!xtest
 %! z1 =  7.0372976777e6;
 %! p1 = -3.1415926536e9;
 %! p2 = -4.9964813512e8;
 %! r1 = -(1 + z1/p1)/(1 - p1/p2)/p2/p1;
 %! r2 = -(1 + z1/p2)/(1 - p2/p1)/p2/p1;
@@ -424,8 +426,9 @@ endfunction
 %! p = [p1; p2; 0; 0];
 %! k = [];
 %! e = [1; 1; 1; 2];
 %! b = [1, z1];
 %! a = [1, -(p1 + p2), p1*p2, 0, 0];
 %! [br, ar] = residue (r, p, k, e);
 %! assert (br, b, 1e-8);
 %! assert (ar, a, 1e-8);
+
diff --git a/scripts/polynomial/roots.m b/scripts/polynomial/roots.m
--- a/scripts/polynomial/roots.m
+++ b/scripts/polynomial/roots.m
@@ -113,29 +113,27 @@ function r = roots (v)
       r = zeros (n - f(m), 1);
     endif
   else
     r = [];
   endif
 
 endfunction
 
+
 %!test
 %! p = [poly([3 3 3 3]), 0 0 0 0];
 %! r = sort (roots (p));
-%! assert (r, [0; 0; 0; 0; 3; 3; 3; 3], 0.001)
-
-%!assert(all (all (abs (roots ([1, -6, 11, -6]) - [3; 2; 1]) < sqrt (eps))));
-
-%!assert(isempty (roots ([])));
-
-%!error roots ([1, 2; 3, 4]);
+%! assert (r, [0; 0; 0; 0; 3; 3; 3; 3], 0.001);
 
-%!assert(isempty (roots (1)));
-
-%!error roots ([1, 2; 3, 4]);
-
-%!error roots ([1 Inf 1]);
-
-%!error roots ([1 NaN 1]);
+%!assert (isempty (roots ([])))
+%!assert (isempty (roots (1)))
+%!assert (roots ([1, -6, 11, -6]), [3; 2; 1], sqrt (eps))
 
 %!assert(roots ([1e-200, -1e200, 1]), 1e-200)
 %!assert(roots ([1e-200, -1e200 * 1i, 1]), -1e-200 * 1i)
+
+%!error roots ()
+%!error roots (1,2)
+%!error roots ([1, 2; 3, 4])
+%!error <inputs must not contain Inf or NaN> roots ([1 Inf 1])
+%!error <inputs must not contain Inf or NaN> roots ([1 NaN 1])
+
diff --git a/scripts/polynomial/spline.m b/scripts/polynomial/spline.m
--- a/scripts/polynomial/spline.m
+++ b/scripts/polynomial/spline.m
@@ -242,18 +242,18 @@ function ret = spline (x, y, xi)
     ret = ppval (ret, xi);
   endif
 
 endfunction
 
 
 %!demo
 %! x = 0:10; y = sin (x);
-%! xspline = 0:0.1:10; yspline = spline (x,y,xspline);
-%! title ("spline fit to points from sin(x)");
+%! xspline = 0:0.1:10;  yspline = spline (x,y,xspline);
+%! title ("spline fit to points from sin (x)");
 %! plot (xspline,sin(xspline),"r", xspline,yspline,"g-", x,y,"b+");
 %! legend ("original", "interpolation", "interpolation points");
 %! %--------------------------------------------------------
 %! % confirm that interpolated function matches the original
 
 %!shared x,y,abserr
 %! x = [0:10]; y = sin (x); abserr = 1e-14;
 %!assert (spline (x,y,x), y, abserr)
@@ -261,17 +261,17 @@ endfunction
 %!assert (spline (x',y',x'), y', abserr)
 %!assert (spline (x',y',x), y, abserr)
 %!assert (isempty (spline (x',y',[])))
 %!assert (isempty (spline (x,y,[])))
 %!assert (spline (x,[y;y],x), [spline(x,y,x);spline(x,y,x)], abserr)
 %!assert (spline (x,[y;y],x'), [spline(x,y,x);spline(x,y,x)], abserr)
 %!assert (spline (x',[y;y],x), [spline(x,y,x);spline(x,y,x)], abserr)
 %!assert (spline (x',[y;y],x'), [spline(x,y,x);spline(x,y,x)], abserr)
-%! y = cos(x) + i*sin(x);
+%! y = cos (x) + i*sin (x);
 %!assert (spline (x,y,x), y, abserr)
 %!assert (real (spline (x,y,x)), real (y), abserr)
 %!assert (real (spline (x,y,x.')), real (y).', abserr)
 %!assert (real (spline (x.',y.',x.')), real (y).', abserr)
 %!assert (real (spline (x.',y,x)), real (y), abserr)
 %!assert (imag (spline (x,y,x)), imag (y), abserr)
 %!assert (imag (spline (x,y,x.')), imag (y).', abserr)
 %!assert (imag (spline (x.',y.',x.')), imag (y).', abserr)
diff --git a/scripts/set/intersect.m b/scripts/set/intersect.m
--- a/scripts/set/intersect.m
+++ b/scripts/set/intersect.m
@@ -82,34 +82,35 @@ function [c, ia, ib] = intersect (a, b, 
 
 endfunction
 
 
 %!# Test the routine for index vectors ia and ib
 %!test
 %! a = [3 2 4 5 7 6 5 1 0 13 13];
 %! b = [3 5 12 1 1 7];
-%! [c,ia,ib] = intersect(a,b);
-%! assert(c,[1 3 5 7]);
-%! assert(ia,[8 1 7 5]);
-%! assert(ib,[5 1 2 6]);
-%! assert(a(ia),c);
-%! assert(b(ib),c);
+%! [c,ia,ib] = intersect (a, b);
+%! assert (c, [1 3 5 7]);
+%! assert (ia, [8 1 7 5]);
+%! assert (ib, [5 1 2 6]);
+%! assert (a(ia), c);
+%! assert (b(ib), c);
 %!test
 %! a = [1,1,2;1,4,5;2,1,7];
 %! b = [1,4,5;2,3,4;1,1,2;9,8,7];
-%! [c,ia,ib] = intersect(a,b,'rows');
-%! assert(c,[1,1,2;1,4,5]);
-%! assert(ia,[1;2]);
-%! assert(ib,[3;1]);
-%! assert(a(ia,:),c);
-%! assert(b(ib,:),c);
+%! [c,ia,ib] = intersect (a, b, "rows");
+%! assert (c, [1,1,2;1,4,5]);
+%! assert (ia, [1;2]);
+%! assert (ib, [3;1]);
+%! assert (a(ia,:), c);
+%! assert (b(ib,:), c);
 %!test
 %! a = [1 1 1 2 2 2];
 %! b = [1 2 3 4 5 6];
-%! c = intersect(a,b);
+%! c = intersect (a, b);
 %! assert(c, [1,2]);
 %!test
 %! a = [1 2 3 4; 5 6 7 8; 9 10 11 12];
-%! [b, ia, ib] = intersect(a, a, "rows");
-%! assert(b, a);
-%! assert(ia, [1:3]');
-%! assert(ib, [1:3]');
+%! [b, ia, ib] = intersect (a, a, "rows");
+%! assert (b, a);
+%! assert (ia, [1:3]');
+%! assert (ib, [1:3]');
+
diff --git a/scripts/set/ismember.m b/scripts/set/ismember.m
--- a/scripts/set/ismember.m
+++ b/scripts/set/ismember.m
@@ -25,43 +25,43 @@
 ## true (1) if @code{A(i,j)} is in @var{s} and false (0) if it is not.  If a
 ## second output argument is requested, the index into @var{s} of each of the
 ## matching elements is also returned.
 ##
 ## @example
 ## @group
 ## a = [3, 10, 1];
 ## s = [0:9];
-## [tf, s_idx] = ismember (a, s);
+## [tf, s_idx] = ismember (a, s)
 ##      @result{} tf = [1, 0, 1]
 ##      @result{} s_idx = [4, 0, 2]
 ## @end group
 ## @end example
 ##
 ## The inputs, @var{A} and @var{s}, may also be cell arrays.
 ##
 ## @example
 ## @group
-## a = @{'abc'@};
-## s = @{'abc', 'def'@};
-## [tf, s_idx] = ismember (a, s);
+## a = @{"abc"@};
+## s = @{"abc", "def"@};
+## [tf, s_idx] = ismember (a, s)
 ##      @result{} tf = [1, 0]
 ##      @result{} s_idx = [1, 0]
 ## @end group
 ## @end example
 ##
 ## With the optional third argument @code{"rows"}, and matrices
 ## @var{A} and @var{s} with the same number of columns, compare rows in
 ## @var{A} with the rows in @var{s}.
 ##
 ## @example
 ## @group
 ## a = [1:3; 5:7; 4:6];
 ## s = [0:2; 1:3; 2:4; 3:5; 4:6];
-## [tf, s_idx] = ismember(a, s, 'rows');
+## [tf, s_idx] = ismember(a, s, "rows")
 ##      @result{} tf = logical ([1; 0; 1])
 ##      @result{} s_idx = [2; 0; 5];
 ## @end group
 ## @end example
 ##
 ## @seealso{unique, union, intersect, setxor, setdiff}
 ## @end deftypefn
 
@@ -128,82 +128,89 @@ function [tf, a_idx] = ismember (A, s, v
         a_idx = max (0, jj - na);
       endif
 
     endif
   endif
 
 endfunction
 
-%!assert (ismember ({''}, {'abc', 'def'}), false);
-%!assert (ismember ('abc', {'abc', 'def'}), true);
-%!assert (isempty (ismember ([], [1, 2])), true);
-%!assert (isempty (ismember ({}, {'a', 'b'})), true);
-%!assert (ismember ('', {'abc', 'def'}), false);
-%!fail ('ismember ([], {1, 2})');
-%!fail ('ismember ({[]}, {1, 2})');
-%!fail ('ismember ({}, {1, 2})');
-%!fail ('ismember ({1}, {''1'', ''2''})');
-%!fail ('ismember (1, ''abc'')');
-%!fail ('ismember ({''1''}, {''1'', ''2''},''rows'')');
-%!fail ('ismember ([1 2 3], [5 4 3 1], ''rows'')');
-%!assert (ismember ({'foo', 'bar'}, {'foobar'}), logical ([0, 0]));
-%!assert (ismember ({'foo'}, {'foobar'}), false);
-%!assert (ismember ({'bar'}, {'foobar'}), false);
-%!assert (ismember ({'bar'}, {'foobar', 'bar'}), true);
-%!assert (ismember ({'foo', 'bar'}, {'foobar', 'bar'}), logical ([0, 1]));
-%!assert (ismember ({'xfb', 'f', 'b'}, {'fb', 'b'}), logical ([0, 0, 1]));
-%!assert (ismember ("1", "0123456789."), true);
+
+%!assert (ismember ({""}, {"abc", "def"}), false)
+%!assert (ismember ("abc", {"abc", "def"}), true)
+%!assert (isempty (ismember ([], [1, 2])), true)
+%!assert (isempty (ismember ({}, {'a', 'b'})), true)
+%!assert (ismember ("", {"abc", "def"}), false)
+%!fail ("ismember ([], {1, 2})")
+%!fail ("ismember ({[]}, {1, 2})")
+%!fail ("ismember ({}, {1, 2})")
+%!fail ("ismember ({1}, {'1', '2'})")
+%!fail ("ismember (1, 'abc')")
+%!fail ("ismember ({'1'}, {'1' '2'},'rows')")
+%!fail ("ismember ([1 2 3], [5 4 3 1], 'rows')")
+%!assert (ismember ({"foo", "bar"}, {"foobar"}), [false false])
+%!assert (ismember ({"foo"}, {"foobar"}), false)
+%!assert (ismember ({"bar"}, {"foobar"}), false)
+%!assert (ismember ({"bar"}, {"foobar", "bar"}), true)
+%!assert (ismember ({"foo", "bar"}, {"foobar", "bar"}), [false true])
+%!assert (ismember ({"xfb", "f", "b"}, {"fb", "b"}), [false false true])
+%!assert (ismember ("1", "0123456789."), true)
 
 %!test
 %! [result, a_idx] = ismember ([1, 2], []);
-%! assert (result, logical ([0, 0]))
+%! assert (result, [false false])
 %! assert (a_idx, [0, 0]);
 
 %!test
 %! [result, a_idx] = ismember ([], [1, 2]);
 %! assert (result, logical ([]))
 %! assert (a_idx, []);
 
 %!test
-%! [result, a_idx] = ismember ({'a', 'b'}, '');
-%! assert (result, logical ([0, 0]))
+%! [result, a_idx] = ismember ({"a", "b"}, "");
+%! assert (result, [false false])
 %! assert (a_idx, [0, 0]);
 
 %!test
-%! [result, a_idx] = ismember ({'a', 'b'}, {});
-%! assert (result, logical ([0, 0]))
+%! [result, a_idx] = ismember ({"a", "b"}, {});
+%! assert (result, [false false])
 %! assert (a_idx, [0, 0]);
 
 %!test
-%! [result, a_idx] = ismember ('', {'a', 'b'});
+%! [result, a_idx] = ismember ("", {"a", "b"});
 %! assert (result, false)
 %! assert (a_idx, 0);
 
 %!test
-%! [result, a_idx] = ismember ({}, {'a', 'b'});
+%! [result, a_idx] = ismember ({}, {"a", "b"});
 %! assert (result, logical ([]))
 %! assert (a_idx, []);
 
 %!test
 %! [result, a_idx] = ismember([1 2 3 4 5], [3]);
-%! assert (all (result == logical ([0 0 1 0 0])) && all (a_idx == [0 0 1 0 0]));
+%! assert (result, logical ([0 0 1 0 0]))
+%! assert (a_idx , [0 0 1 0 0]);
 
 %!test
 %! [result, a_idx] = ismember([1 6], [1 2 3 4 5 1 6 1]);
-%! assert (all (result == logical ([1 1])) && a_idx(2) == 7);
+%! assert (result, [true true]);
+%! assert (a_idx(2), 7);
 
 %!test
 %! [result, a_idx] = ismember ([3,10,1], [0,1,2,3,4,5,6,7,8,9]);
-%! assert (all (result == logical ([1, 0, 1])) && all (a_idx == [4, 0, 2]));
+%! assert (result, [true false true]);
+%! assert (a_idx, [4, 0, 2]);
 
 %!test
 %! [result, a_idx] = ismember ("1.1", "0123456789.1");
-%! assert (all (result == logical ([1, 1, 1])) && all (a_idx == [12, 11, 12]));
+%! assert (result, [true true true]);
+%! assert (a_idx, [12, 11, 12]);
 
 %!test
-%! [result, a_idx] = ismember([1:3; 5:7; 4:6], [0:2; 1:3; 2:4; 3:5; 4:6], 'rows');
-%! assert (all (result == logical ([1; 0; 1])) && all (a_idx == [2; 0; 5]));
+%! [result, a_idx] = ismember ([1:3; 5:7; 4:6], [0:2; 1:3; 2:4; 3:5; 4:6], "rows");
+%! assert (result, [true; false; true]);
+%! assert (a_idx, [2; 0; 5]);
 
 %!test
-%! [result, a_idx] = ismember([1.1,1.2,1.3; 2.1,2.2,2.3; 10,11,12], [1.1,1.2,1.3; 10,11,12; 2.12,2.22,2.32], 'rows');
-%! assert (all (result == logical ([1; 0; 1])) && all (a_idx == [1; 0; 2]));
+%! [result, a_idx] = ismember ([1.1,1.2,1.3; 2.1,2.2,2.3; 10,11,12], [1.1,1.2,1.3; 10,11,12; 2.12,2.22,2.32], "rows");
+%! assert (result, [true; false; true]);
+%! assert (a_idx, [1; 0; 2]);
 
diff --git a/scripts/set/powerset.m b/scripts/set/powerset.m
--- a/scripts/set/powerset.m
+++ b/scripts/set/powerset.m
@@ -76,8 +76,9 @@ function p = powerset (a, byrows_arg)
 
 endfunction
 
 
 %!test
 %! c = sort (cellstr ({ [], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]}));
 %! p = sort (cellstr (powerset ([1, 2, 3])));
 %! assert (p, c);
+
diff --git a/scripts/set/setdiff.m b/scripts/set/setdiff.m
--- a/scripts/set/setdiff.m
+++ b/scripts/set/setdiff.m
@@ -85,21 +85,23 @@ function [c, i] = setdiff (a, b, varargi
       if (size (c, 1) != 1 && size (b, 1) == 1)
         c = c.';
       endif
     endif
   endif
 
 endfunction
 
-%!assert(setdiff(["bb";"zz";"bb";"zz"],["bb";"cc";"bb"],"rows"), "zz")
-%!assert(setdiff(["b";"z";"b";"z"],["b";"c";"b"],"rows"), "z")
-%!assert(setdiff(["b";"z";"b";"z"],["b";"c";"b"]), "z")
-%!assert(setdiff([1, 1; 2, 2; 3, 3; 4, 4], [1, 1; 2, 2; 4, 4], "rows"), [3 3])
-%!assert(setdiff([1; 2; 3; 4], [1; 2; 4], "rows"), 3)
-%!assert(setdiff([1, 2; 3, 4], [1, 2; 3, 6], "rows"), [3, 4])
-%!assert(setdiff({"one","two";"three","four"},{"one","two";"three","six"}), {"four"})
+
+%!assert (setdiff (["bb";"zz";"bb";"zz"], ["bb";"cc";"bb"], "rows"), "zz")
+%!assert (setdiff (["b";"z";"b";"z"], ["b";"c";"b"], "rows"), "z")
+%!assert (setdiff (["b";"z";"b";"z"], ["b";"c";"b"]), "z")
+%!assert (setdiff ([1, 1; 2, 2; 3, 3; 4, 4], [1, 1; 2, 2; 4, 4], "rows"), [3 3])
+%!assert (setdiff ([1; 2; 3; 4], [1; 2; 4], "rows"), 3)
+%!assert (setdiff ([1, 2; 3, 4], [1, 2; 3, 6], "rows"), [3, 4])
+%!assert (setdiff ({"one","two";"three","four"}, {"one","two";"three","six"}), {"four"})
 
 %!test
-%! a = [3, 1, 4, 1, 5]; b = [1, 2, 3, 4];
+%! a = [3, 1, 4, 1, 5];  b = [1, 2, 3, 4];
 %! [y, i] = setdiff (a, b.');
-%! assert(y, [5]);
-%! assert(y, a(i));
+%! assert (y, [5]);
+%! assert (y, a(i));
+
diff --git a/scripts/set/setxor.m b/scripts/set/setxor.m
--- a/scripts/set/setxor.m
+++ b/scripts/set/setxor.m
@@ -14,17 +14,17 @@
 ## for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} setxor (@var{a}, @var{b})
-## @deftypefnx {Function File} {} setxor (@var{a}, @var{b}, 'rows')
+## @deftypefnx {Function File} {} setxor (@var{a}, @var{b}, "rows")
 ## @deftypefnx {Function File} {[@var{c}, @var{ia}, @var{ib}] =} setxor (@var{a}, @var{b})
 ##
 ## Return the elements exclusive to @var{a} or @var{b}, sorted in ascending
 ## order.  If @var{a} and @var{b} are both column vectors return a column
 ## vector, otherwise return a row vector.
 ## @var{a}, @var{b} may be cell arrays of string(s).
 ##
 ## With three output arguments, return index vectors @var{ia} and @var{ib}
@@ -86,16 +86,17 @@ function [c, ia, ib] = setxor (a, b, var
   endif
   if (nargout > 1)
     ia = ia(i(i <= na));
     ib = ib(i(i > na) - na);
   endif
 
 endfunction
 
-%!assert(setxor([1,2,3],[2,3,4]),[1,4])
-%!assert(setxor({'a'}, {'a', 'b'}), {'b'});
+
+%!assert (setxor ([1,2,3],[2,3,4]),[1,4])
+%!assert (setxor ({'a'}, {'a', 'b'}), {'b'})
 %!test
-%! a = [3, 1, 4, 1, 5]; b = [1, 2, 3, 4];
+%! a = [3, 1, 4, 1, 5];  b = [1, 2, 3, 4];
 %! [y, ia, ib] = setxor (a, b.');
-%! assert(y, [2, 5]);
-%! assert(y, sort([a(ia), b(ib)]));
+%! assert (y, [2, 5]);
+%! assert (y, sort([a(ia), b(ib)]));
 
diff --git a/scripts/set/union.m b/scripts/set/union.m
--- a/scripts/set/union.m
+++ b/scripts/set/union.m
@@ -22,38 +22,37 @@
 ## @deftypefnx {Function File} {} union (@var{a}, @var{b}, "rows")
 ## Return the set of elements that are in either of the sets @var{a} and
 ## @var{b}.  @var{a}, @var{b} may be cell arrays of string(s).
 ## For example:
 ##
 ## @example
 ## @group
 ## union ([1, 2, 4], [2, 3, 5])
-##      @result{} [1, 2, 3, 4, 5]
+##     @result{} [1, 2, 3, 4, 5]
 ## @end group
 ## @end example
 ##
 ## If the optional third input argument is the string "rows" each row of
 ## the matrices @var{a} and @var{b} will be considered an element of sets.
 ## For example:
 ##
 ## @example
 ## @group
-## union([1, 2; 2, 3], [1, 2; 3, 4], "rows")
-##      @result{}  1   2
-##     2   3
-##     3   4
+## union ([1, 2; 2, 3], [1, 2; 3, 4], "rows")
+##    @result{}  1   2
+##        2   3
+##        3   4
 ## @end group
 ## @end example
 ##
 ## @deftypefnx {Function File} {[@var{c}, @var{ia}, @var{ib}] =} union (@var{a}, @var{b})
 ##
 ## Return index vectors @var{ia} and @var{ib} such that @code{a(ia)} and
-## @code{b(ib)} are
-## disjoint sets whose union is @var{c}.
+## @code{b(ib)} are disjoint sets whose union is @var{c}.
 ##
 ## @seealso{intersect, setdiff, unique}
 ## @end deftypefn
 
 ## Author: jwe
 
 function [y, ia, ib] = union (a, b, varargin)
 
@@ -79,23 +78,22 @@ function [y, ia, ib] = union (a, b, vara
   else
     [y, i] = unique (y, varargin{:});
     ia = i(i <= na);
     ib = i(i > na) - na;
   endif
 
 endfunction
 
-%!assert(all (all (union ([1, 2, 4], [2, 3, 5]) == [1, 2, 3, 4, 5])));
 
-%!assert(all (all (union ([1; 2; 4], [2, 3, 5]) == [1, 2, 3, 4, 5])));
-
-%!assert(all (all (union ([1, 2, 3], [5; 7; 9]) == [1, 2, 3, 5, 7, 9])));
-
-%!error union (1);
-
-%!error union (1, 2, 3);
+%!assert (union ([1, 2, 4], [2, 3, 5]), [1, 2, 3, 4, 5]);
+%!assert (union ([1; 2; 4], [2, 3, 5]), [1, 2, 3, 4, 5]);
+%!assert (union ([1, 2, 3], [5; 7; 9]), [1, 2, 3, 5, 7, 9]);
 
 %!test
-%! a = [3, 1, 4, 1, 5]; b = [1, 2, 3, 4];
+%! a = [3, 1, 4, 1, 5];  b = [1, 2, 3, 4];
 %! [y, ia, ib] = union (a, b.');
-%! assert(y, [1, 2, 3, 4, 5]);
-%! assert(y, sort([a(ia), b(ib)]));
+%! assert (y, [1, 2, 3, 4, 5]);
+%! assert (y, sort ([a(ia), b(ib)]));
+
+%!error union (1)
+%!error union (1, 2, 3)
+
diff --git a/scripts/set/unique.m b/scripts/set/unique.m
--- a/scripts/set/unique.m
+++ b/scripts/set/unique.m
@@ -158,57 +158,59 @@ function [y, i, j] = unique (x, varargin
       i(idx+1) = [];
     else
       i(idx) = [];
     endif
   endif
 
 endfunction
 
-%!assert(unique([1 1 2; 1 2 1; 1 1 2]),[1;2])
-%!assert(unique([1 1 2; 1 0 1; 1 1 2],'rows'),[1 0 1; 1 1 2])
-%!assert(unique([]),[])
-%!assert(unique([1]),[1])
-%!assert(unique([1 2]),[1 2])
-%!assert(unique([1;2]),[1;2])
-%!assert(unique([1,NaN,Inf,NaN,Inf]),[1,Inf,NaN,NaN])
-%!assert(unique({'Foo','Bar','Foo'}),{'Bar','Foo'})
-%!assert(unique({'Foo','Bar','FooBar'}'),{'Bar','Foo','FooBar'}')
-%!assert(unique(zeros(1,0)), zeros(0,1))
-%!assert(unique(zeros(1,0), 'rows'), zeros(1,0))
-%!assert(unique(cell(1,0)), cell(0,1))
-%!assert(unique({}), {})
-%!assert(unique([1,2,2,3,2,4], 'rows'), [1,2,2,3,2,4])
-%!assert(unique([1,2,2,3,2,4]), [1,2,3,4])
-%!assert(unique([1,2,2,3,2,4]', 'rows'), [1,2,3,4]')
-%!assert(unique(sparse([2,0;2,0])), [0,2]')
-%!assert(unique(sparse([1,2;2,3])), [1,2,3]')
-%!assert(unique([1,2,2,3,2,4]', 'rows'), [1,2,3,4]')
-%!assert(unique(single([1,2,2,3,2,4]), 'rows'), single([1,2,2,3,2,4]))
-%!assert(unique(single([1,2,2,3,2,4])), single([1,2,3,4]))
-%!assert(unique(single([1,2,2,3,2,4]'), 'rows'), single([1,2,3,4]'))
-%!assert(unique(uint8([1,2,2,3,2,4]), 'rows'), uint8([1,2,2,3,2,4]))
-%!assert(unique(uint8([1,2,2,3,2,4])), uint8([1,2,3,4]))
-%!assert(unique(uint8([1,2,2,3,2,4]'), 'rows'), uint8([1,2,3,4]'))
+
+%!assert (unique ([1 1 2; 1 2 1; 1 1 2]),[1;2])
+%!assert (unique ([1 1 2; 1 0 1; 1 1 2],"rows"),[1 0 1; 1 1 2])
+%!assert (unique ([]),[])
+%!assert (unique ([1]),[1])
+%!assert (unique ([1 2]),[1 2])
+%!assert (unique ([1;2]),[1;2])
+%!assert (unique ([1,NaN,Inf,NaN,Inf]),[1,Inf,NaN,NaN])
+%!assert (unique ({"Foo","Bar","Foo"}),{"Bar","Foo"})
+%!assert (unique ({"Foo","Bar","FooBar"}'),{"Bar","Foo","FooBar"}')
+%!assert (unique (zeros (1,0)), zeros (0,1))
+%!assert (unique (zeros (1,0), "rows"), zeros (1,0))
+%!assert (unique (cell (1,0)), cell (0,1))
+%!assert (unique ({}), {})
+%!assert (unique ([1,2,2,3,2,4], "rows"), [1,2,2,3,2,4])
+%!assert (unique ([1,2,2,3,2,4]), [1,2,3,4])
+%!assert (unique ([1,2,2,3,2,4]', "rows"), [1,2,3,4]')
+%!assert (unique (sparse ([2,0;2,0])), [0,2]')
+%!assert (unique (sparse ([1,2;2,3])), [1,2,3]')
+%!assert (unique ([1,2,2,3,2,4]', "rows"), [1,2,3,4]')
+%!assert (unique (single ([1,2,2,3,2,4]), "rows"), single ([1,2,2,3,2,4]))
+%!assert (unique (single ([1,2,2,3,2,4])), single ([1,2,3,4]))
+%!assert (unique (single ([1,2,2,3,2,4]'), "rows"), single ([1,2,3,4]'))
+%!assert (unique (uint8 ([1,2,2,3,2,4]), "rows"), uint8 ([1,2,2,3,2,4]))
+%!assert (unique (uint8 ([1,2,2,3,2,4])), uint8 ([1,2,3,4]))
+%!assert (unique (uint8 ([1,2,2,3,2,4]'), "rows"), uint8 ([1,2,3,4]'))
 %!test
-%! [a,i,j] = unique([1,1,2,3,3,3,4]);
-%! assert(a,[1,2,3,4])
-%! assert(i,[2,3,6,7])
-%! assert(j,[1,1,2,3,3,3,4])
+%! [a,i,j] = unique ([1,1,2,3,3,3,4]);
+%! assert (a, [1,2,3,4]);
+%! assert (i, [2,3,6,7]);
+%! assert (j, [1,1,2,3,3,3,4]);
 %!
 %!test
-%! [a,i,j] = unique([1,1,2,3,3,3,4]','first');
-%! assert(a,[1,2,3,4]')
-%! assert(i,[1,3,4,7]')
-%! assert(j,[1,1,2,3,3,3,4]')
+%! [a,i,j] = unique ([1,1,2,3,3,3,4]', "first");
+%! assert (a, [1,2,3,4]');
+%! assert (i, [1,3,4,7]');
+%! assert (j, [1,1,2,3,3,3,4]');
 %!
 %!test
-%! [a,i,j] = unique({'z'; 'z'; 'z'});
-%! assert(a,{'z'})
-%! assert(i,[3]')
-%! assert(j,[1,1,1]')
+%! [a,i,j] = unique ({"z"; "z"; "z"});
+%! assert (a, {"z"});
+%! assert (i, [3]');
+%! assert (j, [1;1;1]);
 %!
 %!test
-%! A=[1,2,3;1,2,3];
-%! [a,i,j] = unique(A,'rows');
-%! assert(a,[1,2,3])
-%! assert(A(i,:),a)
-%! assert(a(j,:),A)
+%! A = [1,2,3;1,2,3];
+%! [a,i,j] = unique (A, "rows");
+%! assert (a, [1,2,3]);
+%! assert (A(i,:), a);
+%! assert (a(j,:), A);
+
diff --git a/scripts/signal/autoreg_matrix.m b/scripts/signal/autoreg_matrix.m
--- a/scripts/signal/autoreg_matrix.m
+++ b/scripts/signal/autoreg_matrix.m
@@ -45,18 +45,19 @@ function X = autoreg_matrix (y, k)
   for j = 1 : k;
     X(:, j+1) = [(zeros (j, 1)); y(1:T-j)];
   endfor
 
 endfunction
 
 
 %!test
-%! K=4;
+%! K = 4;
 %! A = zeros(1,K+1);
 %! A(1) = 1;
 %! B = eye(K+1);
 %! B(:,1) = 1;
-%! assert (autoreg_matrix(A,K),B);
+%! assert (autoreg_matrix (A,K), B);
 
-%!error autoreg_matrix()
-%!error autoreg_matrix(1)
-%!error autoreg_matrix(ones(4,1),5)
+%!error autoreg_matrix ()
+%!error autoreg_matrix (1)
+%!error autoreg_matrix (ones (4,1), 5)
+
diff --git a/scripts/signal/bartlett.m b/scripts/signal/bartlett.m
--- a/scripts/signal/bartlett.m
+++ b/scripts/signal/bartlett.m
@@ -43,21 +43,23 @@ function c = bartlett (m)
   else
     m = m - 1;
     n = fix (m / 2);
     c = [2*(0:n)/m, 2-2*(n+1:m)/m]';
   endif
 
 endfunction
 
-%!assert (bartlett (1), 1);
-%!assert (bartlett (2), zeros (2,1));
-%!assert (bartlett (16), fliplr (bartlett (16)));
-%!assert (bartlett (15), fliplr (bartlett (15)));
+
+%!assert (bartlett (1), 1)
+%!assert (bartlett (2), zeros (2,1))
+%!assert (bartlett (16), fliplr (bartlett (16)))
+%!assert (bartlett (15), fliplr (bartlett (15)))
 %!test
 %! N = 9;
 %! A = bartlett (N);
-%! assert (A (ceil (N/2)), 1);
+%! assert (A(ceil (N/2)), 1);
 
-%!error bartlett ();
-%!error bartlett (0.5);
-%!error bartlett (-1);
-%!error bartlett (ones(1,4));
+%!error bartlett ()
+%!error bartlett (0.5)
+%!error bartlett (-1)
+%!error bartlett (ones (1,4))
+
diff --git a/scripts/signal/blackman.m b/scripts/signal/blackman.m
--- a/scripts/signal/blackman.m
+++ b/scripts/signal/blackman.m
@@ -42,22 +42,24 @@ function c = blackman (m)
   else
     m = m - 1;
     k = (0 : m)' / m;
     c = 0.42 - 0.5 * cos (2 * pi * k) + 0.08 * cos (4 * pi * k);
   endif
 
 endfunction
 
-%!assert (blackman (1), 1);
-%!assert (blackman (2), zeros(2,1), 1e-6);
-%!assert (blackman (16), fliplr (blackman (16)));
-%!assert (blackman (15), fliplr (blackman (15)));
+
+%!assert (blackman (1), 1)
+%!assert (blackman (2), zeros (2,1), 1e-6)
+%!assert (blackman (16), fliplr (blackman (16)))
+%!assert (blackman (15), fliplr (blackman (15)))
 %!test
 %! N = 9;
 %! A = blackman (N);
 %! assert (A (ceil (N/2)), 1, 1e-6);
 %! assert ([A(1), A(length (A))], zeros (1, 2), 1e-6);
 
-%!error blackman ();
-%!error blackman (0.5);
-%!error blackman (-1);
-%!error blackman (ones(1,4));
+%!error blackman ()
+%!error blackman (0.5)
+%!error blackman (-1)
+%!error blackman (ones (1,4))
+
diff --git a/scripts/signal/detrend.m b/scripts/signal/detrend.m
--- a/scripts/signal/detrend.m
+++ b/scripts/signal/detrend.m
@@ -62,28 +62,29 @@ function y = detrend (x, p = 1)
   y = x - b * (b \ x);
 
   if (m == 1)
     y = y';
   endif
 
 endfunction
 
-%!test
-%! N=32;
-%! x = (0:1:N-1)/N + 2;
-%! y = detrend(x);
-%! assert(all (all (abs (y) < 20*eps)));
 
 %!test
-%! N=32;
+%! N = 32;
+%! x = (0:1:N-1)/N + 2;
+%! y = detrend (x);
+%! assert (abs (y(:)) < 20*eps);
+
+%!test
+%! N = 32;
 %! t = (0:1:N-1)/N;
 %! x = t .* t + 2;
-%! y = detrend(x,2);
-%! assert(all (all (abs (y) < 30*eps)));
+%! y = detrend (x,2);
+%! assert (abs (y(:)) < 30*eps);
 
 %!test
-%! N=32;
+%! N = 32;
 %! t = (0:1:N-1)/N;
 %! x = [t;4*t-3]';
-%! y = detrend(x);
-%! assert(all (all (abs (y) < 20*eps)));
+%! y = detrend (x);
+%! assert (abs (y(:)) < 20*eps);
 
diff --git a/scripts/signal/fftconv.m b/scripts/signal/fftconv.m
--- a/scripts/signal/fftconv.m
+++ b/scripts/signal/fftconv.m
@@ -79,28 +79,29 @@ endfunction
 %!  assert (fftconv (c, y), [3, 3, 3], 5*eps);
 %!  assert (fftconv (x, c), [3; 3; 3], 5*eps);
 %!  assert (fftconv (y, c), [3, 3, 3], 5*eps);
 %!  assert (fftconv (b, c), 6, 5*eps);
 
 %!test
 %!  a = 1:10;
 %!  b = 1:3;
-%!  assert (size(conv(a,b)), [1, numel(a)+numel(b)-1])
-%!  assert (size(conv(b,a)), [1, numel(a)+numel(b)-1])
+%!  assert (size (conv (a,b)), [1, numel(a)+numel(b)-1])
+%!  assert (size (conv (b,a)), [1, numel(a)+numel(b)-1])
 
 %!  a = (1:10).';
 %!  b = 1:3;
-%!  assert (size(conv(a,b)), [numel(a)+numel(b)-1, 1])
-%!  assert (size(conv(b,a)), [numel(a)+numel(b)-1, 1])
+%!  assert (size (conv (a,b)), [numel(a)+numel(b)-1, 1])
+%!  assert (size (conv (b,a)), [numel(a)+numel(b)-1, 1])
 
 %!test
 %!  a = 1:10;
 %!  b = (1:3).';
-%!  assert (size(conv(a,b)), [1, numel(a)+numel(b)-1])
-%!  assert (size(conv(b,a)), [1, numel(a)+numel(b)-1])
+%!  assert (size (conv (a,b)), [1, numel(a)+numel(b)-1])
+%!  assert (size (conv (b,a)), [1, numel(a)+numel(b)-1])
 
 %% Test input validation
-%!error fftconv (1);
-%!error fftconv (1,2,3,4);
-%!error fftconv ([1, 2; 3, 4], 3);
-%!error fftconv (2, []);
-%!error fftconv ([1,1], [2,2] , [3, 4]);
+%!error fftconv (1)
+%!error fftconv (1,2,3,4)
+%!error fftconv ([1, 2; 3, 4], 3)
+%!error fftconv (2, [])
+%!error fftconv ([1,1], [2,2] , [3, 4])
+
diff --git a/scripts/signal/fftfilt.m b/scripts/signal/fftfilt.m
--- a/scripts/signal/fftfilt.m
+++ b/scripts/signal/fftfilt.m
@@ -109,43 +109,43 @@ function y = fftfilt (b, x, n)
     y(:, idx) = round (y(:, idx));
   endif
 
 endfunction
 
 
 %!shared b, x, r
 %!test
-%!  b = [1 1];
-%!  x = [1, zeros(1,9)];
-%!  assert(fftfilt(b,  x  ), [1 1 0 0 0 0 0 0 0 0]  , eps);
-%!  assert(fftfilt(b,  x.'), [1 1 0 0 0 0 0 0 0 0].', eps);
-%!  assert(fftfilt(b.',x  ), [1 1 0 0 0 0 0 0 0 0]  , eps);
-%!  assert(fftfilt(b.',x.'), [1 1 0 0 0 0 0 0 0 0].', eps);
+%! b = [1 1];
+%! x = [1, zeros(1,9)];
+%! assert (fftfilt (b,  x  ), [1 1 0 0 0 0 0 0 0 0]  , eps);
+%! assert (fftfilt (b,  x.'), [1 1 0 0 0 0 0 0 0 0].', eps);
+%! assert (fftfilt (b.',x  ), [1 1 0 0 0 0 0 0 0 0]  , eps);
+%! assert (fftfilt (b.',x.'), [1 1 0 0 0 0 0 0 0 0].', eps);
 
 %!test
-%!  r = sqrt(1/2) * (1+i);
-%!  b = b*r;
-%!  assert(fftfilt(b, x  ), r*[1 1 0 0 0 0 0 0 0 0]  , eps);
-%!  assert(fftfilt(b, r*x), r*r*[1 1 0 0 0 0 0 0 0 0], eps);
-%!  assert(fftfilt(b, x.'), r*[1 1 0 0 0 0 0 0 0 0].', eps);
+%! r = sqrt (1/2) * (1+i);
+%! b = b*r;
+%! assert (fftfilt (b, x  ), r*[1 1 0 0 0 0 0 0 0 0]  , eps);
+%! assert (fftfilt (b, r*x), r*r*[1 1 0 0 0 0 0 0 0 0], eps);
+%! assert (fftfilt (b, x.'), r*[1 1 0 0 0 0 0 0 0 0].', eps);
 
 %!test
-%!  b = [1 1];
-%!  x = zeros (10,3); x(1,1)=-1; x(1,2)=1;
-%!  y0 = zeros (10,3); y0(1:2,1)=-1; y0(1:2,2)=1;
-%!  y = fftfilt (b, x);
-%!  assert (y,y0);
+%! b = [1 1];
+%! x = zeros (10,3); x(1,1)=-1; x(1,2)=1;
+%! y0 = zeros (10,3); y0(1:2,1)=-1; y0(1:2,2)=1;
+%! y = fftfilt (b, x);
+%! assert (y,y0);
 
 %!test
-%!  b  = rand (10, 1);
-%!  x  = rand (10, 1);
-%!  y0 = filter (b, 1, x);
-%!  y  = filter (b, 1, x);
-%!  assert (y, y0);
+%! b  = rand (10, 1);
+%! x  = rand (10, 1);
+%! y0 = filter (b, 1, x);
+%! y  = filter (b, 1, x);
+%! assert (y, y0);
 
 %% Test input validation
 %!error fftfilt (1)
 %!error fftfilt (1, 2, 3, 4)
 %!error fftfilt (ones (2), 1)
 %!error fftfilt (2, ones (3,3,3))
 %!error fftfilt (2, 1, ones (2))
 
diff --git a/scripts/signal/fftshift.m b/scripts/signal/fftshift.m
--- a/scripts/signal/fftshift.m
+++ b/scripts/signal/fftshift.m
@@ -82,50 +82,50 @@ function retval = fftshift (x, dim)
   endif
 
 endfunction
 
 
 %!test
 %!  x = [0:7];
 %!  y = fftshift (x);
-%!  assert(y, [4 5 6 7 0 1 2 3]);
-%!  assert(fftshift (y), x);
+%!  assert (y, [4 5 6 7 0 1 2 3]);
+%!  assert (fftshift (y), x);
 
 %!test
 %!  x = [0:6];
 %!  y = fftshift (x);
-%!  assert(y, [4 5 6 0 1 2 3]);
-%!  assert(fftshift (y), [1 2 3 4 5 6 0]);
+%!  assert (y, [4 5 6 0 1 2 3]);
+%!  assert (fftshift (y), [1 2 3 4 5 6 0]);
 
 %!test
 %!  x = [0:7]';
 %!  y = fftshift (x);
-%!  assert(y, [4;5;6;7;0;1;2;3]);
-%!  assert(fftshift (y), x);
+%!  assert (y, [4;5;6;7;0;1;2;3]);
+%!  assert (fftshift (y), x);
 
 %!test
 %!  x = [0:6]';
 %!  y = fftshift (x);
-%!  assert(y, [4;5;6;0;1;2;3]);
-%!  assert(fftshift (y), [1;2;3;4;5;6;0]);
+%!  assert (y, [4;5;6;0;1;2;3]);
+%!  assert (fftshift (y), [1;2;3;4;5;6;0]);
 
 %!test
 %!  x = [0:3];
 %!  x = [x;2*x;3*x+1;4*x+1];
 %!  y = fftshift (x);
-%!  assert(y, [[7 10 1 4];[9 13 1 5];[2 3 0 1];[4 6 0 2]]);
-%!  assert(fftshift (y), x);
+%!  assert (y, [[7 10 1 4];[9 13 1 5];[2 3 0 1];[4 6 0 2]]);
+%!  assert (fftshift (y), x);
 
 %!test
 %!  x = [0:3];
 %!  x = [x;2*x;3*x+1;4*x+1];
 %!  y = fftshift (x,1);
-%!  assert(y, [[1 4 7 10];[1 5 9 13];[0 1 2 3];[0 2 4 6]]);
-%!  assert(fftshift (y,1), x);
+%!  assert (y, [[1 4 7 10];[1 5 9 13];[0 1 2 3];[0 2 4 6]]);
+%!  assert (fftshift (y,1), x);
 
 %!test
 %!  x = [0:3];
 %!  x = [x;2*x;3*x+1;4*x+1];
 %!  y = fftshift (x,2);
-%!  assert(y, [[2 3 0 1];[4 6 0 2];[7 10 1 4];[9 13 1 5]]);
-%!  assert(fftshift (y,2), x);
+%!  assert (y, [[2 3 0 1];[4 6 0 2];[7 10 1 4];[9 13 1 5]]);
+%!  assert (fftshift (y,2), x);
 
diff --git a/scripts/signal/filter2.m b/scripts/signal/filter2.m
--- a/scripts/signal/filter2.m
+++ b/scripts/signal/filter2.m
@@ -19,23 +19,23 @@
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{y} =} filter2 (@var{b}, @var{x})
 ## @deftypefnx {Function File} {@var{y} =} filter2 (@var{b}, @var{x}, @var{shape})
 ## Apply the 2-D FIR filter @var{b} to @var{x}.  If the argument
 ## @var{shape} is specified, return an array of the desired shape.
 ## Possible values are:
 ##
 ## @table @asis
-## @item 'full'
+## @item "full"
 ## pad @var{x} with zeros on all sides before filtering.
 ##
-## @item 'same'
+## @item "same"
 ## unpadded @var{x} (default)
 ##
-## @item 'valid'
+## @item "valid"
 ## trim @var{x} after filtering so edge effects are no included.
 ## @end table
 ##
 ## Note this is just a variation on convolution, with the parameters
 ## reversed and @var{b} rotated 180 degrees.
 ## @seealso{conv2}
 ## @end deftypefn
 
diff --git a/scripts/signal/freqz.m b/scripts/signal/freqz.m
--- a/scripts/signal/freqz.m
+++ b/scripts/signal/freqz.m
@@ -164,34 +164,35 @@ function [h_r, f_r] = freqz (b, a, n, re
     f_r = f;
   else
     ## Plot and don't return values.
     freqz_plot (f, h);
   endif
 
 endfunction
 
+
 %!test # correct values and fft-polyval consistency
 %! # butterworth filter, order 2, cutoff pi/2 radians
 %! b = [0.292893218813452  0.585786437626905  0.292893218813452];
 %! a = [1  0  0.171572875253810];
-%! [h,w] = freqz(b,a,32);
-%! assert(h(1),1,10*eps);
-%! assert(abs(h(17)).^2,0.5,10*eps);
-%! assert(h,freqz(b,a,w),10*eps); # fft should be consistent with polyval
+%! [h,w] = freqz (b,a,32);
+%! assert (h(1),1,10*eps);
+%! assert (abs (h(17)).^2,0.5,10*eps);
+%! assert (h,freqz (b,a,w),10*eps); # fft should be consistent with polyval
 
 %!test # whole-half consistency
 %! b = [1 1 1]/3; # 3-sample average
-%! [h,w] = freqz(b,1,32,'whole');
-%! assert(h(2:16),conj(h(32:-1:18)),20*eps);
-%! [h2,w2] = freqz(b,1,16,'half');
-%! assert(h(1:16),h2,20*eps);
-%! assert(w(1:16),w2,20*eps);
+%! [h,w] = freqz (b,1,32,"whole");
+%! assert (h(2:16),conj (h(32:-1:18)),20*eps);
+%! [h2,w2] = freqz (b,1,16,"half");
+%! assert (h(1:16),h2,20*eps);
+%! assert (w(1:16),w2,20*eps);
 
 %!test # Sampling frequency properly interpreted
 %! b = [1 1 1]/3; a = [1 0.2];
-%! [h,f] = freqz(b,a,16,320);
-%! assert(f,[0:15]'*10,10*eps);
-%! [h2,f2] = freqz(b,a,[0:15]*10,320);
-%! assert(f2,[0:15]*10,10*eps);
-%! assert(h,h2.',20*eps);
-%! [h3,f3] = freqz(b,a,32,'whole',320);
-%! assert(f3,[0:31]'*10,10*eps);
+%! [h,f] = freqz (b,a,16,320);
+%! assert (f,[0:15]'*10,10*eps);
+%! [h2,f2] = freqz (b,a,[0:15]*10,320);
+%! assert (f2,[0:15]*10,10*eps);
+%! assert (h,h2.',20*eps);
+%! [h3,f3] = freqz (b,a,32,"whole",320);
+%! assert (f3,[0:31]'*10,10*eps);
diff --git a/scripts/signal/hamming.m b/scripts/signal/hamming.m
--- a/scripts/signal/hamming.m
+++ b/scripts/signal/hamming.m
@@ -41,21 +41,23 @@ function c = hamming (m)
     c = 1;
   else
     m = m - 1;
     c = 0.54 - 0.46 * cos (2 * pi * (0:m)' / m);
   endif
 
 endfunction
 
-%!assert (hamming (1), 1);
-%!assert (hamming (2), (0.54 - 0.46)*ones(2,1));
-%!assert (hamming (16), fliplr (hamming (16)));
-%!assert (hamming (15), fliplr (hamming (15)));
+
+%!assert (hamming (1), 1)
+%!assert (hamming (2), (0.54 - 0.46)*ones (2,1))
+%!assert (hamming (16), fliplr (hamming (16)))
+%!assert (hamming (15), fliplr (hamming (15)))
 %!test
 %! N = 15;
 %! A = hamming (N);
 %! assert (A (ceil (N/2)), 1);
 
-%!error hamming ();
-%!error hamming (0.5);
-%!error hamming (-1);
-%!error hamming (ones(1,4));
+%!error hamming ()
+%!error hamming (0.5)
+%!error hamming (-1)
+%!error hamming (ones (1,4))
+
diff --git a/scripts/signal/hanning.m b/scripts/signal/hanning.m
--- a/scripts/signal/hanning.m
+++ b/scripts/signal/hanning.m
@@ -41,21 +41,23 @@ function c = hanning (m)
     c = 1;
   else
     m = m - 1;
     c = 0.5 - 0.5 * cos (2 * pi * (0 : m)' / m);
   endif
 
 endfunction
 
+
 %!assert (hanning (1), 1);
-%!assert (hanning (2), zeros(2,1));
+%!assert (hanning (2), zeros (2,1));
 %!assert (hanning (16), fliplr (hanning (16)));
 %!assert (hanning (15), fliplr (hanning (15)));
 %!test
 %! N = 15;
 %! A = hanning (N);
-%! assert (A (ceil (N/2)), 1);
+%! assert (A(ceil (N/2)), 1);
 
-%!error hanning ();
-%!error hanning (0.5);
-%!error hanning (-1);
-%!error hanning (ones(1,4));
+%!error hanning ()
+%!error hanning (0.5)
+%!error hanning (-1)
+%!error hanning (ones(1,4))
+
diff --git a/scripts/signal/ifftshift.m b/scripts/signal/ifftshift.m
--- a/scripts/signal/ifftshift.m
+++ b/scripts/signal/ifftshift.m
@@ -64,53 +64,54 @@ function retval = ifftshift (x, dim)
       retval = x(idx{:});
     else
       error ("ifftshift: expecting vector or matrix argument");
     endif
   endif
 
 endfunction
 
+
 %!test
-%!  x = [0:7];
-%!  y = ifftshift (x);
-%!  assert(y, [4 5 6 7 0 1 2 3]);
-%!  assert(ifftshift (y), x);
+%! x = [0:7];
+%! y = ifftshift (x);
+%! assert (y, [4 5 6 7 0 1 2 3]);
+%! assert (ifftshift (y), x);
 
 %!test
-%!  x = [0:6];
-%!  y = ifftshift (x);
-%!  assert(y, [3 4 5 6 0 1 2]);
-%!  assert(ifftshift (y), [6 0 1 2 3 4 5]);
+%! x = [0:6];
+%! y = ifftshift (x);
+%! assert (y, [3 4 5 6 0 1 2]);
+%! assert (ifftshift (y), [6 0 1 2 3 4 5]);
 
 %!test
-%!  x = [0:7]';
-%!  y = ifftshift (x);
-%!  assert(y, [4;5;6;7;0;1;2;3]);
-%!  assert(ifftshift (y), x);
+%! x = [0:7]';
+%! y = ifftshift (x);
+%! assert (y, [4;5;6;7;0;1;2;3]);
+%! assert (ifftshift (y), x);
 
 %!test
-%!  x = [0:6]';
-%!  y = ifftshift (x);
-%!  assert(y, [3;4;5;6;0;1;2]);
-%!  assert(ifftshift (y), [6;0;1;2;3;4;5]);
+%! x = [0:6]';
+%! y = ifftshift (x);
+%! assert (y, [3;4;5;6;0;1;2]);
+%! assert (ifftshift (y), [6;0;1;2;3;4;5]);
 
 %!test
-%!  x = [0:3];
-%!  x = [x;2*x;3*x+1;4*x+1];
-%!  y = ifftshift (x);
-%!  assert(y, [[7 10 1 4];[9 13 1 5];[2 3 0 1];[4 6 0 2]]);
-%!  assert(ifftshift (y), x);
+%! x = [0:3];
+%! x = [x;2*x;3*x+1;4*x+1];
+%! y = ifftshift (x);
+%! assert (y, [[7 10 1 4];[9 13 1 5];[2 3 0 1];[4 6 0 2]]);
+%! assert (ifftshift (y), x);
 
 %!test
-%!  x = [0:3];
-%!  x = [x;2*x;3*x+1;4*x+1];
-%!  y = ifftshift (x,1);
-%!  assert(y, [[1 4 7 10];[1 5 9 13];[0 1 2 3];[0 2 4 6]]);
-%!  assert(ifftshift (y,1), x);
+%! x = [0:3];
+%! x = [x;2*x;3*x+1;4*x+1];
+%! y = ifftshift (x,1);
+%! assert (y, [[1 4 7 10];[1 5 9 13];[0 1 2 3];[0 2 4 6]]);
+%! assert (ifftshift (y,1), x);
 
 %!test
-%!  x = [0:3];
-%!  x = [x;2*x;3*x+1;4*x+1];
-%!  y = ifftshift (x,2);
-%!  assert(y, [[2 3 0 1];[4 6 0 2];[7 10 1 4];[9 13 1 5]]);
-%!  assert(ifftshift (y,2), x);
+%! x = [0:3];
+%! x = [x;2*x;3*x+1;4*x+1];
+%! y = ifftshift (x,2);
+%! assert (y, [[2 3 0 1];[4 6 0 2];[7 10 1 4];[9 13 1 5]]);
+%! assert (ifftshift (y,2), x);
 
diff --git a/scripts/signal/sinc.m b/scripts/signal/sinc.m
--- a/scripts/signal/sinc.m
+++ b/scripts/signal/sinc.m
@@ -42,13 +42,14 @@ function result = sinc (x)
   if (any (i(:)))
     t = pi * x(i);
     result(i) = sin (t) ./ t;
   endif
 
 endfunction
 
 
-%!assert (sinc (0), 1);
-%!assert (sinc (1), 0,1e-6);
+%!assert (sinc (0), 1)
+%!assert (sinc (1), 0,1e-6)
 %!assert (sinc (1/2), 2/pi, 1e-6)
 
 %!error sinc()
+
diff --git a/scripts/signal/sinetone.m b/scripts/signal/sinetone.m
--- a/scripts/signal/sinetone.m
+++ b/scripts/signal/sinetone.m
@@ -59,9 +59,10 @@ function retval = sinetone (freq, rate, 
 
   for k = 1:n
     retval (:, k) = ampl(k) * sin (2 * pi * (1:ns) / rate * freq(k))';
   endfor
 
 endfunction
 
 
-%!assert (size (sinetone (18e6, 150e6, 19550/150e6, 1)), [19550, 1]);
+%!assert (size (sinetone (18e6, 150e6, 19550/150e6, 1)), [19550, 1])
+
diff --git a/scripts/signal/sinewave.m b/scripts/signal/sinewave.m
--- a/scripts/signal/sinewave.m
+++ b/scripts/signal/sinewave.m
@@ -39,17 +39,19 @@ function x = sinewave (m, n, d)
     endif
     x = sin (((1 : m) + d - 1) * 2 * pi / n);
   else
     print_usage ();
   endif
 
 endfunction
 
-%!assert (sinewave (1), 0);
-%!assert (sinewave (1, 4, 1), 1);
-%!assert (sinewave (1, 12, 1), 1/2, 1e-6);
-%!assert (sinewave (1, 12, 2), sqrt (3)/2, 1e-6);
-%!assert (sinewave (1, 20, 1), (sqrt (5)-1)/4, 1e-6);
-%!assert (sinewave (1), sinewave (1, 1,0));
-%!assert (sinewave (3, 4), sinewave(3, 4, 0));
 
-%!error sinewave ();
+%!assert (sinewave (1), 0)
+%!assert (sinewave (1, 4, 1), 1)
+%!assert (sinewave (1, 12, 1), 1/2, 1e-6)
+%!assert (sinewave (1, 12, 2), sqrt (3)/2, 1e-6)
+%!assert (sinewave (1, 20, 1), (sqrt (5)-1)/4, 1e-6)
+%!assert (sinewave (1), sinewave (1, 1,0))
+%!assert (sinewave (3, 4), sinewave (3, 4, 0))
+
+%!error sinewave ()
+
diff --git a/scripts/signal/unwrap.m b/scripts/signal/unwrap.m
--- a/scripts/signal/unwrap.m
+++ b/scripts/signal/unwrap.m
@@ -84,73 +84,75 @@ function retval = unwrap (x, tol, dim)
   r = cumsum (p, dim);
 
   ## Now add the "steps" to the original data and put output in the
   ## same shape as originally.
   retval = x + r;
 
 endfunction
 
+
 %!function t = __xassert(a,b,tol)
 %!  if (nargin == 1)
-%!    t = all(a(:));
+%!    t = all (a(:));
 %!  else
 %!    if (nargin == 2)
 %!      tol = 0;
 %!    endif
-%!    if (any (size(a) != size(b)))
+%!    if (any (size (a) != size (b)))
 %!      t = 0;
-%!    elseif (any (abs(a(:) - b(:)) > tol))
+%!    elseif (any (abs (a(:) - b(:)) > tol))
 %!      t = 0;
 %!    else
 %!      t = 1;
 %!    endif
 %!  endif
 %!endfunction
 %!
 %!test
 %!
 %! i = 0;
 %! t = [];
 %!
 %! r = [0:100];                        # original vector
-%! w = r - 2*pi*floor((r+pi)/(2*pi));  # wrapped into [-pi,pi]
+%! w = r - 2*pi*floor ((r+pi)/(2*pi)); # wrapped into [-pi,pi]
 %! tol = 1e3*eps;                      # maximum expected deviation
 %!
-%! t(++i) = __xassert(r, unwrap(w), tol);               #unwrap single row
-%! t(++i) = __xassert(r', unwrap(w'), tol);             #unwrap single column
-%! t(++i) = __xassert([r',r'], unwrap([w',w']), tol);   #unwrap 2 columns
-%! t(++i) = __xassert([r;r], unwrap([w;w],[],2), tol);  #check that dim works
-%! t(++i) = __xassert(r+10, unwrap(10+w), tol);         #check r(1)>pi works
+%! t(++i) = __xassert (r, unwrap (w), tol);              #unwrap single row
+%! t(++i) = __xassert (r', unwrap (w'), tol);            #unwrap single column
+%! t(++i) = __xassert ([r',r'], unwrap ([w',w']), tol);  #unwrap 2 columns
+%! t(++i) = __xassert ([r;r], unwrap ([w;w],[],2), tol); #check that dim works
+%! t(++i) = __xassert (r+10, unwrap (10+w), tol);        #check r(1)>pi works
 %!
-%! t(++i) = __xassert(w', unwrap(w',[],2));  #unwrap col by rows should not change it
-%! t(++i) = __xassert(w, unwrap(w,[],1));    #unwrap row by cols should not change it
-%! t(++i) = __xassert([w;w], unwrap([w;w])); #unwrap 2 rows by cols should not change them
+%! t(++i) = __xassert (w', unwrap (w',[],2));  #unwrap col by rows should not change it
+%! t(++i) = __xassert (w, unwrap (w,[],1));    #unwrap row by cols should not change it
+%! t(++i) = __xassert ([w;w], unwrap ([w;w])); #unwrap 2 rows by cols should not change them
 %!
 %! ## verify that setting tolerance too low will cause bad results.
-%! t(++i) = __xassert(any(abs(r - unwrap(w,0.8)) > 100));
+%! t(++i) = __xassert (any (abs (r - unwrap (w,0.8)) > 100));
 %!
-%! assert(all(t));
+%! assert (all (t));
 %!
 %!test
 %! A = [pi*(-4), pi*(-2+1/6), pi/4, pi*(2+1/3), pi*(4+1/2), pi*(8+2/3), pi*(16+1), pi*(32+3/2), pi*64];
-%! assert (unwrap(A), unwrap(A, pi));
-%! assert (unwrap(A, pi), unwrap(A, pi, 2));
-%! assert (unwrap(A', pi), unwrap(A', pi, 1));
+%! assert (unwrap (A), unwrap (A, pi));
+%! assert (unwrap (A, pi), unwrap (A, pi, 2));
+%! assert (unwrap (A', pi), unwrap (A', pi, 1));
 %!
 %!test
 %! A = [pi*(-4); pi*(2+1/3); pi*(16+1)];
 %! B = [pi*(-2+1/6); pi*(4+1/2); pi*(32+3/2)];
 %! C = [pi/4; pi*(8+2/3); pi*64];
 %! D = [pi*(-2+1/6); pi*(2+1/3); pi*(8+2/3)];
 %! E(:, :, 1) = [A, B, C, D];
 %! E(:, :, 2) = [A+B, B+C, C+D, D+A];
 %! F(:, :, 1) = [unwrap(A), unwrap(B), unwrap(C), unwrap(D)];
 %! F(:, :, 2) = [unwrap(A+B), unwrap(B+C), unwrap(C+D), unwrap(D+A)];
-%! assert (unwrap(E), F);
+%! assert (unwrap (E), F);
 %!
 %!test
 %! A = [0, 2*pi, 4*pi, 8*pi, 16*pi, 65536*pi];
 %! B = [pi*(-2+1/6), pi/4, pi*(2+1/3), pi*(4+1/2), pi*(8+2/3), pi*(16+1), pi*(32+3/2), pi*64];
-%! assert (unwrap(A), zeros(1, length(A)));
-%! assert (diff(unwrap(B), 1)<2*pi, true(1, length(B)-1));
-%!
+%! assert (unwrap (A), zeros (1, length (A)));
+%! assert (diff (unwrap (B), 1) < 2*pi, true (1, length (B)-1));
+
 %!error unwrap()
+
diff --git a/scripts/sparse/bicg.m b/scripts/sparse/bicg.m
--- a/scripts/sparse/bicg.m
+++ b/scripts/sparse/bicg.m
@@ -35,18 +35,18 @@
 ##
 ## @var{A} can be passed as a matrix or as a function handle or
 ## inline function @code{f} such that @code{f(x, "notransp") = A*x}
 ## and @code{f(x, "transp") = A'*x}.
 ##
 ## The preconditioner @var{P} is given as @code{P = M1 * M2}.
 ## Both @var{M1} and @var{M2} can be passed as a matrix or as
 ## a function handle or inline function @code{g} such that
-## @code{g(x, 'notransp') = M1 \ x} or @code{g(x, 'notransp') = M2 \ x} and
-## @code{g(x, 'transp') = M1' \ x} or @code{g(x, 'transp') = M2' \ x}.
+## @code{g(x, "notransp") = M1 \ x} or @code{g(x, "notransp") = M2 \ x} and
+## @code{g(x, "transp") = M1' \ x} or @code{g(x, "transp") = M2' \ x}.
 ##
 ## If called with more than one output parameter
 ##
 ## @itemize @minus
 ## @item @var{flag} indicates the exit status:
 ## @itemize @minus
 ## @item 0: iteration converged to the within the chosen tolerance
 ##
@@ -223,17 +223,16 @@ endfunction;
 %! A = spdiags ([-2*ones(n,1) 4*ones(n,1) -ones(n,1)], -1:1, n, n);
 %! b = sum (A, 2);
 %! tol = 1e-8;
 %! maxit = 15;
 %! M1 = spdiags ([ones(n,1)/(-2) ones(n,1)],-1:0, n, n);
 %! M2 = spdiags ([4*ones(n,1) -ones(n,1)], 0:1, n, n);
 %! [x, flag, relres, iter, resvec] = bicg (A, b, tol, maxit, M1, M2);
 %! assert (x, ones (size (b)), 1e-7);
-%!
 
 %!function y = afun (x, t, a)
 %!  switch t
 %!   case "notransp"
 %!     y = a * x;
 %!   case "transp"
 %!     y = a' * x;
 %!  endswitch
@@ -255,8 +254,9 @@ endfunction;
 %!test
 %! n = 100;
 %! tol = 1e-8;
 %! a = sprand (n, n, .1);
 %! A = a' * a + 100 * eye (n);
 %! b = sum (A, 2);
 %! [x, flag, relres, iter, resvec] = bicg (A, b, tol, [], diag (diag (A)));
 %! assert (x, ones (size (b)), 1e-7);
+
diff --git a/scripts/sparse/bicgstab.m b/scripts/sparse/bicgstab.m
--- a/scripts/sparse/bicgstab.m
+++ b/scripts/sparse/bicgstab.m
@@ -241,8 +241,9 @@ endfunction
 %!test
 %! n = 100;
 %! tol = 1e-8;
 %! a = sprand (n, n, .1);
 %! A = a'*a + 100 * eye (n);
 %! b = sum (A, 2);
 %! [x, flag, relres, iter, resvec] = bicgstab (A, b, tol, [], diag (diag (A)));
 %! assert (x, ones (size (b)), 1e-7);
+
diff --git a/scripts/sparse/gmres.m b/scripts/sparse/gmres.m
--- a/scripts/sparse/gmres.m
+++ b/scripts/sparse/gmres.m
@@ -44,16 +44,17 @@
 ## The preconditioner @var{P} is given as @code{P = M1 * M2}.
 ## Both @var{M1} and @var{M2} can be passed as a matrix, function handle, or
 ## inline function @code{g} such that @code{g(x) = M1\x} or @code{g(x) = M2\x}.
 ##
 ## Besides the vector @var{x}, additional outputs are:
 ##
 ## @itemize @minus
 ## @item @var{flag} indicates the exit status:
+##
 ## @table @asis
 ## @item 0 : iteration converged to within the specified tolerance
 ##
 ## @item 1 : maximum number of iterations exceeded
 ##
 ## @item 2 : unused, but skipped for compatibility
 ##
 ## @item 3 : algorithm reached stagnation
@@ -192,27 +193,28 @@ function [x, flag, presn, it, resids] = 
 
 endfunction
 
 
 %!shared A, b, dim
 %! dim = 100;
 %!test
 %! A = spdiags ([-ones(dim,1) 2*ones(dim,1) ones(dim,1)], [-1:1], dim, dim);
-%! b = ones(dim, 1);
-%! x = gmres (A, b, 10, 1e-10, dim, @(x) x./diag(A), [],  b);
-%! assert(x, A\b, 1e-9*norm(x,inf));
+%! b = ones (dim, 1);
+%! x = gmres (A, b, 10, 1e-10, dim, @(x) x ./ diag (A), [], b);
+%! assert (x, A\b, 1e-9*norm (x, Inf));
 %!
 %!test
-%! x = gmres (A, b, dim, 1e-10, 1e4, @(x) diag(diag(A))\x, [],  b);
-%! assert(x, A\b, 1e-7*norm(x,inf));
+%! x = gmres (A, b, dim, 1e-10, 1e4, @(x) diag (diag (A)) \ x, [], b);
+%! assert(x, A\b, 1e-7*norm (x, Inf));
 %!
 %!test
 %! A = spdiags ([[1./(2:2:2*(dim-1)) 0]; 1./(1:2:2*dim-1); [0 1./(2:2:2*(dim-1))]]', -1:1, dim, dim);
 %! A = A'*A;
 %! b = rand (dim, 1);
-%! [x, resids] = gmres (@(x) A*x, b, dim, 1e-10, dim, @(x) x./diag(A), [],  []);
-%! assert(x, A\b, 1e-9*norm(x,inf))
-%! x = gmres (@(x) A*x, b, dim, 1e-10, 1e6, @(x) diag(diag(A))\x, [],  []);
-%! assert(x, A\b, 1e-9*norm(x,inf));
+%! [x, resids] = gmres (@(x) A*x, b, dim, 1e-10, dim, @(x) x./diag (A), [], []);
+%! assert (x, A\b, 1e-9*norm (x, Inf));
+%! x = gmres (@(x) A*x, b, dim, 1e-10, 1e6, @(x) diag (diag (A)) \ x, [], []);
+%! assert (x, A\b, 1e-9*norm (x, Inf));
 %!test
-%! x =  gmres (@(x) A*x, b, dim, 1e-10, 1e6, @(x) x./diag(A), [],  []);
-%! assert(x, A\b, 1e-7*norm(x,inf));
+%! x = gmres (@(x) A*x, b, dim, 1e-10, 1e6, @(x) x./diag(A), [], []);
+%! assert (x, A\b, 1e-7*norm (x, Inf));
+
diff --git a/scripts/sparse/gplot.m b/scripts/sparse/gplot.m
--- a/scripts/sparse/gplot.m
+++ b/scripts/sparse/gplot.m
@@ -75,10 +75,10 @@ endfunction
 %!       4  , 0];
 %!
 %! clf;
 %! gplot (A, xy, "o-");
 %! set (get (gca, ("children")), "markersize", 12);
 %! title ("gplot() of Binary Tree Adjacency matrix");
 
 %% Mark graphical function as tested by demo block
-%!assert (1);
+%!assert (1)
 
diff --git a/scripts/sparse/nonzeros.m b/scripts/sparse/nonzeros.m
--- a/scripts/sparse/nonzeros.m
+++ b/scripts/sparse/nonzeros.m
@@ -29,12 +29,13 @@ function t = nonzeros (s)
 
   [~, ~, t] = find (s);
 
   t = t(:);
 
 endfunction
 
 
-%!assert(nonzeros([1,2;3,0]),[1;3;2])
-%!assert(nonzeros([1,2,3,0]),[1;2;3])
-%!assert(nonzeros(sparse([1,2;3,0])),[1;3;2])
-%!assert(nonzeros(sparse([1,2,3,0])),[1;2;3])
+%!assert (nonzeros ([1,2;3,0]), [1;3;2])
+%!assert (nonzeros ([1,2,3,0]), [1;2;3])
+%!assert (nonzeros (sparse ([1,2;3,0])), [1;3;2])
+%!assert (nonzeros (sparse ([1,2,3,0])), [1;2;3])
+
diff --git a/scripts/sparse/pcg.m b/scripts/sparse/pcg.m
--- a/scripts/sparse/pcg.m
+++ b/scripts/sparse/pcg.m
@@ -119,87 +119,87 @@
 ## verifying this assumption.
 ## @end itemize
 ##
 ## Let us consider a trivial problem with a diagonal matrix (we exploit the
 ## sparsity of A)
 ##
 ## @example
 ## @group
-##      n = 10;
-##      A = diag (sparse (1:n));
-##      b = rand (n, 1);
-##      [l, u, p, q] = luinc (A, 1.e-3);
+## n = 10;
+## A = diag (sparse (1:n));
+## b = rand (n, 1);
+## [l, u, p, q] = luinc (A, 1.e-3);
 ## @end group
 ## @end example
 ##
 ## @sc{Example 1:} Simplest use of @code{pcg}
 ##
 ## @example
-##   x = pcg(A,b)
+## x = pcg (A,b)
 ## @end example
 ##
 ## @sc{Example 2:} @code{pcg} with a function which computes
 ## @code{@var{A} * @var{x}}
 ##
 ## @example
 ## @group
-##   function y = apply_a (x)
-##     y = [1:N]'.*x;
-##   endfunction
+## function y = apply_a (x)
+##   y = [1:N]' .* x;
+## endfunction
 ##
-##   x = pcg ("apply_a", b)
+## x = pcg ("apply_a", b)
 ## @end group
 ## @end example
 ##
 ## @sc{Example 3:} @code{pcg} with a preconditioner: @var{l} * @var{u}
 ##
 ## @example
-## x = pcg (A, b, 1.e-6, 500, l*u);
+## x = pcg (A, b, 1.e-6, 500, l*u)
 ## @end example
 ##
 ## @sc{Example 4:} @code{pcg} with a preconditioner: @var{l} * @var{u}.
 ## Faster than @sc{Example 3} since lower and upper triangular matrices
 ## are easier to invert
 ##
 ## @example
-## x = pcg (A, b, 1.e-6, 500, l, u);
+## x = pcg (A, b, 1.e-6, 500, l, u)
 ## @end example
 ##
 ## @sc{Example 5:} Preconditioned iteration, with full diagnostics.  The
 ## preconditioner (quite strange, because even the original matrix
 ## @var{A} is trivial) is defined as a function
 ##
 ## @example
 ## @group
-##   function y = apply_m (x)
-##     k = floor (length (x) - 2);
-##     y = x;
-##     y(1:k) = x(1:k)./[1:k]';
-##   endfunction
+## function y = apply_m (x)
+##   k = floor (length (x) - 2);
+##   y = x;
+##   y(1:k) = x(1:k) ./ [1:k]';
+## endfunction
 ##
-##   [x, flag, relres, iter, resvec, eigest] = ...
-##                      pcg (A, b, [], [], "apply_m");
-##   semilogy (1:iter+1, resvec);
+## [x, flag, relres, iter, resvec, eigest] = ...
+##                    pcg (A, b, [], [], "apply_m");
+## semilogy (1:iter+1, resvec);
 ## @end group
 ## @end example
 ##
 ## @sc{Example 6:} Finally, a preconditioner which depends on a
 ## parameter @var{k}.
 ##
 ## @example
 ## @group
-##   function y = apply_M (x, varargin)
+## function y = apply_M (x, varargin)
 ##   K = varargin@{1@};
 ##   y = x;
-##   y(1:K) = x(1:K)./[1:K]';
-##   endfunction
+##   y(1:K) = x(1:K) ./ [1:K]';
+## endfunction
 ##
-##   [x, flag, relres, iter, resvec, eigest] = ...
-##        pcg (A, b, [], [], "apply_m", [], [], 3)
+## [x, flag, relres, iter, resvec, eigest] = ...
+##      pcg (A, b, [], [], "apply_m", [], [], 3)
 ## @end group
 ## @end example
 ##
 ## References:
 ##
 ## @enumerate
 ## @item
 ## C.T. Kelley, @cite{Iterative Methods for Linear and Nonlinear Equations},
@@ -211,18 +211,17 @@
 ## available online at @url{http://www-users.cs.umn.edu/~saad/books.html}
 ## @end enumerate
 ##
 ## @seealso{sparse, pcr}
 ## @end deftypefn
 
 ## Author: Piotr Krzyzanowski <piotr.krzyzanowski@mimuw.edu.pl>
 ## Modified by: Vittoria Rezzonico <vittoria.rezzonico@epfl.ch>
-##    - Add the ability to provide the pre-conditioner as two separate
-## matrices
+##  - Add the ability to provide the pre-conditioner as two separate matrices
 
 function [x, flag, relres, iter, resvec, eigest] = pcg (A, b, tol, maxit, m1, m2, x0, varargin)
 
   ## M = M1*M2
 
   if (nargin < 7 || isempty (x0))
     x = zeros (size (b));
   else
@@ -429,17 +428,16 @@ endfunction
 %!  printf ("Condition number estimate is %g\n", eigest(2) / eigest(1));
 %!  printf ("Actual condition number is   %g\n", cond (A));
 %!  title ("Convergence history");
 %!  semilogy ([0:iter], resvec, ["o-g";"+-r"]);
 %!  xlabel ("Iteration"); ylabel ("log(||b-Ax||)");
 %!  legend ("absolute residual", "absolute preconditioned residual");
 
 %!demo
-%!
 %!  # Full output from pcg, including the eigenvalue estimates
 %!  # We use the 1-D Laplacian matrix for A, and cond(A) = O(N^2)
 %!  # and that's the reason we need some preconditioner; here we take
 %!  # a very simple and not powerful Jacobi preconditioner,
 %!  # which is the diagonal of A
 %!
 %!  N = 100;
 %!  A = zeros (N, N);
diff --git a/scripts/sparse/pcr.m b/scripts/sparse/pcr.m
--- a/scripts/sparse/pcr.m
+++ b/scripts/sparse/pcr.m
@@ -96,71 +96,72 @@
 ## 1,2, @dots{}, @var{iter}+1}.
 ## @end itemize
 ##
 ## Let us consider a trivial problem with a diagonal matrix (we exploit the
 ## sparsity of A)
 ##
 ## @example
 ## @group
-##      n = 10;
-##      A = sparse (diag (1:n));
-##      b = rand (N, 1);
+## n = 10;
+## A = sparse (diag (1:n));
+## b = rand (N, 1);
 ## @end group
 ## @end example
 ##
 ## @sc{Example 1:} Simplest use of @code{pcr}
 ##
 ## @example
-##   x = pcr (A, b)
+## x = pcr (A, b)
 ## @end example
 ##
 ## @sc{Example 2:} @code{pcr} with a function which computes
 ## @code{@var{A} * @var{x}}.
 ##
 ## @example
 ## @group
-##   function y = apply_a (x)
-##     y = [1:10]'.*x;
-##   endfunction
+## function y = apply_a (x)
+##   y = [1:10]' .* x;
+## endfunction
 ##
-##   x = pcr ("apply_a", b)
+## x = pcr ("apply_a", b)
 ## @end group
 ## @end example
 ##
 ## @sc{Example 3:}  Preconditioned iteration, with full diagnostics.  The
 ## preconditioner (quite strange, because even the original matrix
 ## @var{A} is trivial) is defined as a function
 ##
 ## @example
 ## @group
-##   function y = apply_m (x)
-##     k = floor (length(x)-2);
-##     y = x;
-##     y(1:k) = x(1:k)./[1:k]';
-##   endfunction
+## function y = apply_m (x)
+##   k = floor (length (x) - 2);
+##   y = x;
+##   y(1:k) = x(1:k) ./ [1:k]';
+## endfunction
 ##
-##   [x, flag, relres, iter, resvec] = ...
-##                      pcr (A, b, [], [], "apply_m")
-##   semilogy([1:iter+1], resvec);
+## [x, flag, relres, iter, resvec] = ...
+##                    pcr (A, b, [], [], "apply_m")
+## semilogy ([1:iter+1], resvec);
 ## @end group
 ## @end example
 ##
 ## @sc{Example 4:} Finally, a preconditioner which depends on a
 ## parameter @var{k}.
 ##
 ## @example
 ## @group
-##   function y = apply_m (x, varargin)
-##     k = varargin@{1@};
-##     y = x; y(1:k) = x(1:k)./[1:k]';
-##   endfunction
+## function y = apply_m (x, varargin)
+##   k = varargin@{1@};
+##   y = x;
+##   y(1:k) = x(1:k) ./ [1:k]';
+## endfunction
 ##
-##   [x, flag, relres, iter, resvec] = ...
-##                      pcr (A, b, [], [], "apply_m"', [], 3)
+## [x, flag, relres, iter, resvec] = ...
+##                    pcr (A, b, [], [], "apply_m"', [], 3)
 ## @end group
 ## @end example
 ##
 ## References:
 ##
 ##      [1] W. Hackbusch, @cite{Iterative Solution of Large Sparse Systems of
 ##      Equations}, section 9.5.4; Springer, 1994
 ##
@@ -297,110 +298,110 @@ function [x, flag, relres, iter, resvec]
       warning ("system matrix singular or preconditioner indefinite?\n");
     endif
   endif
 
 endfunction
 
 
 %!demo
-%!  # Simplest usage of PCR (see also 'help pcr')
+%! # Simplest usage of PCR (see also 'help pcr')
 %!
-%!  N = 20;
-%!  A = diag (linspace (-3.1,3,N)); b = rand (N,1);
-%!  y = A \ b;  # y is the true solution
-%!  x = pcr (A,b);
-%!  printf ("The solution relative error is %g\n", norm (x-y) / norm (y));
+%! N = 20;
+%! A = diag (linspace (-3.1,3,N)); b = rand (N,1);
+%! y = A \ b;  # y is the true solution
+%! x = pcr (A,b);
+%! printf ("The solution relative error is %g\n", norm (x-y) / norm (y));
 %!
-%!  # You shouldn't be afraid if PCR issues some warning messages in this
-%!  # example: watch out in the second example, why it takes N iterations
-%!  # of PCR to converge to (a very accurate, by the way) solution
+%! # You shouldn't be afraid if PCR issues some warning messages in this
+%! # example: watch out in the second example, why it takes N iterations
+%! # of PCR to converge to (a very accurate, by the way) solution
 
 %!demo
-%!  # Full output from PCR
-%!  # We use this output to plot the convergence history
+%! # Full output from PCR
+%! # We use this output to plot the convergence history
 %!
-%!  N = 20;
-%!  A = diag (linspace(-3.1,30,N)); b = rand (N,1);
-%!  X = A \ b;  # X is the true solution
-%!  [x, flag, relres, iter, resvec] = pcr (A,b);
-%!  printf ("The solution relative error is %g\n", norm (x-X) / norm (X));
-%!  clf;
-%!  title ("Convergence history");
-%!  xlabel ("Iteration"); ylabel ("log(||b-Ax||/||b||)");
-%!  semilogy ([0:iter], resvec/resvec(1), "o-g;relative residual;");
+%! N = 20;
+%! A = diag (linspace (-3.1,30,N)); b = rand (N,1);
+%! X = A \ b;  # X is the true solution
+%! [x, flag, relres, iter, resvec] = pcr (A,b);
+%! printf ("The solution relative error is %g\n", norm (x-X) / norm (X));
+%! clf;
+%! title ("Convergence history");
+%! xlabel ("Iteration"); ylabel ("log(||b-Ax||/||b||)");
+%! semilogy ([0:iter], resvec/resvec(1), "o-g;relative residual;");
 
 %!demo
-%!  # Full output from PCR
-%!  # We use indefinite matrix based on the Hilbert matrix, with one
-%!  # strongly negative eigenvalue
-%!  # Hilbert matrix is extremely ill conditioned, so is ours,
-%!  # and that's why PCR WILL have problems
+%! # Full output from PCR
+%! # We use indefinite matrix based on the Hilbert matrix, with one
+%! # strongly negative eigenvalue
+%! # Hilbert matrix is extremely ill conditioned, so is ours,
+%! # and that's why PCR WILL have problems
 %!
-%!  N = 10;
-%!  A = hilb (N); A(1,1) = -A(1,1); b = rand (N,1);
-%!  X = A \ b;  # X is the true solution
-%!  printf ("Condition number of A is   %g\n", cond (A));
-%!  [x, flag, relres, iter, resvec] = pcr (A,b,[],200);
-%!  if (flag == 3)
-%!    printf ("PCR breakdown.  System matrix is [close to] singular\n");
-%!  end
-%!  clf;
-%!  title ("Convergence history");
-%!  xlabel ("Iteration"); ylabel ("log(||b-Ax||)");
-%!  semilogy ([0:iter], resvec, "o-g;absolute residual;");
+%! N = 10;
+%! A = hilb (N); A(1,1) = -A(1,1); b = rand (N,1);
+%! X = A \ b;  # X is the true solution
+%! printf ("Condition number of A is   %g\n", cond (A));
+%! [x, flag, relres, iter, resvec] = pcr (A,b,[],200);
+%! if (flag == 3)
+%!   printf ("PCR breakdown.  System matrix is [close to] singular\n");
+%! end
+%! clf;
+%! title ("Convergence history");
+%! xlabel ("Iteration"); ylabel ("log(||b-Ax||)");
+%! semilogy ([0:iter], resvec, "o-g;absolute residual;");
 
 %!demo
-%!  # Full output from PCR
-%!  # We use an indefinite matrix based on the 1-D Laplacian matrix for A,
-%!  # and here we have cond(A) = O(N^2)
-%!  # That's the reason we need some preconditioner; here we take
-%!  # a very simple and not powerful Jacobi preconditioner,
-%!  # which is the diagonal of A
+%! # Full output from PCR
+%! # We use an indefinite matrix based on the 1-D Laplacian matrix for A,
+%! # and here we have cond(A) = O(N^2)
+%! # That's the reason we need some preconditioner; here we take
+%! # a very simple and not powerful Jacobi preconditioner,
+%! # which is the diagonal of A
 %!
-%!  # Note that we use here indefinite preconditioners!
+%! # Note that we use here indefinite preconditioners!
 %!
-%!  N = 100;
-%!  A = zeros (N,N);
-%!  for i=1:N-1 # form 1-D Laplacian matrix
-%!    A(i:i+1,i:i+1) = [2 -1; -1 2];
-%!  endfor
-%!  A = [A, zeros(size(A)); zeros(size(A)), -A];
-%!  b = rand (2*N,1);
-%!  X = A \ b;  # X is the true solution
-%!  maxit = 80;
-%!  printf ("System condition number is %g\n", cond (A));
-%!  # No preconditioner: the convergence is very slow!
+%! N = 100;
+%! A = zeros (N,N);
+%! for i=1:N-1 # form 1-D Laplacian matrix
+%!   A(i:i+1,i:i+1) = [2 -1; -1 2];
+%! endfor
+%! A = [A, zeros(size(A)); zeros(size(A)), -A];
+%! b = rand (2*N,1);
+%! X = A \ b;  # X is the true solution
+%! maxit = 80;
+%! printf ("System condition number is %g\n", cond (A));
+%! # No preconditioner: the convergence is very slow!
 %!
-%!  [x, flag, relres, iter, resvec] = pcr (A,b,[],maxit);
-%!  clf;
-%!  title ("Convergence history");
-%!  xlabel ("Iteration"); ylabel ("log(||b-Ax||)");
-%!  semilogy ([0:iter], resvec, "o-g;NO preconditioning: absolute residual;");
+%! [x, flag, relres, iter, resvec] = pcr (A,b,[],maxit);
+%! clf;
+%! title ("Convergence history");
+%! xlabel ("Iteration"); ylabel ("log(||b-Ax||)");
+%! semilogy ([0:iter], resvec, "o-g;NO preconditioning: absolute residual;");
 %!
-%!  pause (1);
-%!  # Test Jacobi preconditioner: it will not help much!!!
+%! pause (1);
+%! # Test Jacobi preconditioner: it will not help much!!!
 %!
-%!  M = diag (diag (A)); # Jacobi preconditioner
-%!  [x, flag, relres, iter, resvec] = pcr (A,b,[],maxit,M);
-%!  hold on;
-%!  semilogy ([0:iter],resvec,"o-r;JACOBI preconditioner: absolute residual;");
+%! M = diag (diag (A)); # Jacobi preconditioner
+%! [x, flag, relres, iter, resvec] = pcr (A,b,[],maxit,M);
+%! hold on;
+%! semilogy ([0:iter],resvec,"o-r;JACOBI preconditioner: absolute residual;");
 %!
-%!  pause (1);
-%!  # Test nonoverlapping block Jacobi preconditioner: this one should give
-%!  # some convergence speedup!
+%! pause (1);
+%! # Test nonoverlapping block Jacobi preconditioner: this one should give
+%! # some convergence speedup!
 %!
-%!  M = zeros (N,N); k = 4;
-%!  for i=1:k:N # get k x k diagonal blocks of A
-%!    M(i:i+k-1,i:i+k-1) = A(i:i+k-1,i:i+k-1);
-%!  endfor
-%!  M = [M, zeros(size (M)); zeros(size(M)), -M];
-%!  [x, flag, relres, iter, resvec] = pcr (A,b,[],maxit,M);
-%!  semilogy ([0:iter], resvec, "o-b;BLOCK JACOBI preconditioner: absolute residual;");
-%!  hold off;
+%! M = zeros (N,N); k = 4;
+%! for i=1:k:N # get k x k diagonal blocks of A
+%!   M(i:i+k-1,i:i+k-1) = A(i:i+k-1,i:i+k-1);
+%! endfor
+%! M = [M, zeros(size (M)); zeros(size(M)), -M];
+%! [x, flag, relres, iter, resvec] = pcr (A,b,[],maxit,M);
+%! semilogy ([0:iter], resvec, "o-b;BLOCK JACOBI preconditioner: absolute residual;");
+%! hold off;
 
 %!test
 %! # solve small indefinite diagonal system
 %!
 %! N = 10;
 %! A = diag (linspace (-10.1,10,N)); b = ones (N,1);
 %! X = A \ b;  # X is the true solution
 %! [x, flag] = pcr (A,b,[],N+1);
diff --git a/scripts/sparse/spaugment.m b/scripts/sparse/spaugment.m
--- a/scripts/sparse/spaugment.m
+++ b/scripts/sparse/spaugment.m
@@ -17,29 +17,28 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{s} =} spaugment (@var{A}, @var{c})
 ## Create the augmented matrix of @var{A}.  This is given by
 ##
 ## @example
 ## @group
-## [@var{c} * eye(@var{m}, @var{m}),@var{A}; @var{A}', zeros(@var{n},
-## @var{n})]
+## [@var{c} * eye(@var{m}, @var{m}), @var{A};
+##             @var{A}', zeros(@var{n}, @var{n})]
 ## @end group
 ## @end example
 ##
 ## @noindent
 ## This is related to the least squares solution of
-## @code{@var{A} \\ @var{b}}, by
+## @code{@var{A} \ @var{b}}, by
 ##
 ## @example
 ## @group
-## @var{s} * [ @var{r} / @var{c}; x] = [@var{b}, zeros(@var{n},
-## columns(@var{b})]
+## @var{s} * [ @var{r} / @var{c}; x] = [ @var{b}, zeros(@var{n}, columns(@var{b})) ]
 ## @end group
 ## @end example
 ##
 ## @noindent
 ## where @var{r} is the residual error
 ##
 ## @example
 ## @var{r} = @var{b} - @var{A} * @var{x}
@@ -48,17 +47,17 @@
 ## As the matrix @var{s} is symmetric indefinite it can be factorized
 ## with @code{lu}, and the minimum norm solution can therefore be found
 ## without the need for a @code{qr} factorization.  As the residual
 ## error will be @code{zeros (@var{m}, @var{m})} for under determined
 ## problems, and example can be
 ##
 ## @example
 ## @group
-## m = 11; n = 10; mn = max(m ,n);
+## m = 11; n = 10; mn = max (m, n);
 ## A = spdiags ([ones(mn,1), 10*ones(mn,1), -ones(mn,1)],
 ##              [-1, 0, 1], m, n);
 ## x0 = A \ ones (m,1);
 ## s = spaugment (A);
 ## [L, U, P, Q] = lu (s);
 ## x1 = Q * (U \ (L \ (P  * [ones(m,1); zeros(n,1)])));
 ## x1 = x1(end - n + 1 : end);
 ## @end group
@@ -86,17 +85,19 @@ function s = spaugment (A, c)
   elseif (!isscalar (c))
     error ("spaugment: C must be a scalar");
   endif
 
   [m, n] = size (A);
   s = [ c * speye(m, m), A; A', sparse(n, n)];
 endfunction
 
+
 %!testif HAVE_UMFPACK
-%! m = 11; n = 10; mn = max(m ,n);
+%! m = 11; n = 10; mn = max (m ,n);
 %! A = spdiags ([ones(mn,1), 10*ones(mn,1), -ones(mn,1)],[-1,0,1], m, n);
 %! x0 = A \ ones (m,1);
 %! s = spaugment (A);
 %! [L, U, P, Q] = lu (s);
 %! x1 = Q * (U \ (L \ (P  * [ones(m,1); zeros(n,1)])));
 %! x1 = x1(end - n + 1 : end);
-%! assert (x1, x0, 1e-6)
+%! assert (x1, x0, 1e-6);
+
diff --git a/scripts/sparse/spconvert.m b/scripts/sparse/spconvert.m
--- a/scripts/sparse/spconvert.m
+++ b/scripts/sparse/spconvert.m
@@ -60,8 +60,9 @@ endfunction
 
 %% Test input validation
 %!error spconvert ()
 %!error spconvert (1, 2)
 %!error spconvert ({[1 2 3]})
 %!error spconvert ([1 2])
 %!error spconvert ([1 2 3i])
 %!error spconvert ([1 2 3 4 5])
+
diff --git a/scripts/sparse/spdiags.m b/scripts/sparse/spdiags.m
--- a/scripts/sparse/spdiags.m
+++ b/scripts/sparse/spdiags.m
@@ -37,17 +37,17 @@
 ## diagonal, and positive values of @var{c} diagonals above the main
 ## diagonal.
 ##
 ## For example:
 ##
 ## @example
 ## @group
 ## spdiags (reshape (1:12, 4, 3), [-1 0 1], 5, 4)
-## @result{}    5 10  0  0
+##    @result{} 5 10  0  0
 ##       1  6 11  0
 ##       0  2  7 12
 ##       0  0  3  8
 ##       0  0  0  4
 ## @end group
 ## @end example
 ##
 ## @end deftypefn
@@ -82,13 +82,12 @@ function [A, c] = spdiags (v, c, m, n)
     j = j + offset(i);
     i = j-c(:)(i);
     idx = i > 0 & i <= m & j > 0 & j <= n;
     A = sparse (i(idx), j(idx), v(idx), m, n);
   endif
 
 endfunction
 
-%!test
-%assert(spdiags(zeros(1,0),1,1,1),0)
 
-%!test
-%assert(spdiags(zeros(0,1),1,1,1),0)
+%!assert (spdiags (zeros (1,0),1,1,1), sparse (0))
+%!assert (spdiags (zeros (0,1),1,1,1), sparse (0))
+
diff --git a/scripts/sparse/speye.m b/scripts/sparse/speye.m
--- a/scripts/sparse/speye.m
+++ b/scripts/sparse/speye.m
@@ -45,13 +45,15 @@ function s = speye (m, n)
       error ("speye: invalid matrix dimension");
     endif
   endif
 
   lo = min ([m, n]);
   s = sparse (1:lo, 1:lo, 1, m, n);
 endfunction
 
-%!assert(issparse(speye(4)))
-%!assert(speye(4),sparse(1:4,1:4,1))
-%!assert(speye(2,4),sparse(1:2,1:2,1,2,4))
-%!assert(speye(4,2),sparse(1:2,1:2,1,4,2))
-%!assert(speye([4,2]),sparse(1:2,1:2,1,4,2))
+
+%!assert (issparse (speye (4)))
+%!assert (speye (4), sparse (1:4,1:4,1))
+%!assert (speye (2,4), sparse (1:2,1:2,1,2,4))
+%!assert (speye (4,2), sparse (1:2,1:2,1,4,2))
+%!assert (speye ([4,2]), sparse (1:2,1:2,1,4,2))
+
diff --git a/scripts/sparse/spfun.m b/scripts/sparse/spfun.m
--- a/scripts/sparse/spfun.m
+++ b/scripts/sparse/spfun.m
@@ -37,13 +37,14 @@ function y = spfun (f, S)
   if (isa (f, "function_handle") || isa (f, "inline function"))
     y = sparse (i, j, f(v), m, n);
   else
     y = sparse(i, j, feval (f, v), m, n);
   endif
 
 endfunction
 
-%!assert(spfun('exp',[1,2;3,0]),sparse([exp(1),exp(2);exp(3),0]))
-%!assert(spfun('exp',sparse([1,2;3,0])),sparse([exp(1),exp(2);exp(3),0]))
-%!assert(spfun(@exp,[1,2;3,0]),sparse([exp(1),exp(2);exp(3),0]))
-%!assert(spfun(@exp,sparse([1,2;3,0])),sparse([exp(1),exp(2);exp(3),0]))
 
+%!assert (spfun ("exp", [1,2;3,0]), sparse ([exp(1),exp(2);exp(3),0]))
+%!assert (spfun ("exp", sparse ([1,2;3,0])), sparse ([exp(1),exp(2);exp(3),0]))
+%!assert (spfun (@exp, [1,2;3,0]), sparse ([exp(1),exp(2);exp(3),0]))
+%!assert (spfun (@exp, sparse ([1,2;3,0])), sparse ([exp(1),exp(2);exp(3),0]))
+
diff --git a/scripts/sparse/spones.m b/scripts/sparse/spones.m
--- a/scripts/sparse/spones.m
+++ b/scripts/sparse/spones.m
@@ -30,11 +30,13 @@ function r = spones (S)
 
   [i, j, v] = find (S);
   [m, n] = size (S);
 
   r = sparse (i, j, 1, m, n);
 
 endfunction
 
-%!assert(issparse(spones([1,2;3,0])))
-%!assert(spones([1,2;3,0]),sparse([1,1;1,0]))
-%!assert(spones(sparse([1,2;3,0])),sparse([1,1;1,0]))
+
+%!assert (issparse (spones ([1,2;3,0])))
+%!assert (spones ([1,2;3,0]), sparse ([1,1;1,0]))
+%!assert (spones (sparse ([1,2;3,0])), sparse ([1,1;1,0]))
+
diff --git a/scripts/sparse/sprand.m b/scripts/sparse/sprand.m
--- a/scripts/sparse/sprand.m
+++ b/scripts/sparse/sprand.m
@@ -49,16 +49,17 @@ function S = sprand (m, n, d)
   elseif ( nargin == 3)
     S = __sprand_impl__ (m, n, d, "sprand", @rand);
   else
     print_usage ();
   endif
 
 endfunction
 
+
 %!test
 %! s = sprand (4, 10, 0.1);
 %! assert (size (s), [4, 10]);
 %! assert (nnz (s) / numel (s), 0.1);
 
 %% Test 1-input calling form
 %!test
 %! s = sprand (sparse ([1 2 3], [3 2 3], [2 2 2]));
@@ -66,17 +67,17 @@ endfunction
 %! assert (sort (i), [1 2 3]');
 %! assert (sort (j), [2 3 3]');
 %! assert (all (v > 0 & v < 1));
 
 %% Test input validation
 %!error sprand ()
 %!error sprand (1, 2)
 %!error sprand (1, 2, 3, 4)
-%!error sprand (ones(3), 3, 0.5)
+%!error sprand (ones (3), 3, 0.5)
 %!error sprand (3.5, 3, 0.5)
 %!error sprand (0, 3, 0.5)
-%!error sprand (3, ones(3), 0.5)
+%!error sprand (3, ones (3), 0.5)
 %!error sprand (3, 3.5, 0.5)
 %!error sprand (3, 0, 0.5)
 %!error sprand (3, 3, -1)
 %!error sprand (3, 3, 2)
 
diff --git a/scripts/sparse/sprandn.m b/scripts/sparse/sprandn.m
--- a/scripts/sparse/sprandn.m
+++ b/scripts/sparse/sprandn.m
@@ -19,17 +19,17 @@
 ## Original version by Paul Kienzle distributed as free software in the
 ## public domain.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} sprandn (@var{m}, @var{n}, @var{d})
 ## @deftypefnx {Function File} {} sprandn (@var{s})
 ## Generate a random sparse matrix.  The size of the matrix will be
 ## @var{m} by @var{n}, with a density of values given by @var{d}.
-## @var{d} should be between 0 and 1. Values will be normally
+## @var{d} should be between 0 and 1.  Values will be normally
 ## distributed with mean of zero and variance 1.
 ##
 ## If called with a single matrix argument, a random sparse matrix is
 ## generated wherever the matrix @var{S} is non-zero.
 ## @seealso{sprand, sprandsym}
 ## @end deftypefn
 
 ## Author: Paul Kienzle <pkienzle@users.sf.net>
diff --git a/scripts/sparse/sprandsym.m b/scripts/sparse/sprandsym.m
--- a/scripts/sparse/sprandsym.m
+++ b/scripts/sparse/sprandsym.m
@@ -17,17 +17,17 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} sprandsym (@var{n}, @var{d})
 ## @deftypefnx {Function File} {} sprandsym (@var{s})
 ## Generate a symmetric random sparse matrix.  The size of the matrix will be
 ## @var{n} by @var{n}, with a density of values given by @var{d}.
-## @var{d} should be between 0 and 1. Values will be normally
+## @var{d} should be between 0 and 1.  Values will be normally
 ## distributed with mean of zero and variance 1.
 ##
 ## If called with a single matrix argument, a random sparse matrix is
 ## generated wherever the matrix @var{S} is non-zero in its lower
 ## triangular part.
 ## @seealso{sprand, sprandn}
 ## @end deftypefn
 
@@ -146,16 +146,17 @@ function r = pick_rand_diag (n, k)
   ## Add final d
   d(end+1) = d(end) + 2;
 
   ## Pick a random r using this distribution
   r = d(sum (cumsum (p) < rand) + 1);
 
 endfunction
 
+
 %!test
 %! s = sprandsym (10, 0.1);
 %! assert (issparse (s));
 %! assert (issymmetric (s));
 %! assert (size (s), [10, 10]);
 %! assert (nnz (s) / numel (s), 0.1, .01);
 
 %% Test 1-input calling form
@@ -163,14 +164,14 @@ endfunction
 %! s = sprandsym (sparse ([1 2 3], [3 2 3], [2 2 2]));
 %! [i, j] = find (s);
 %! assert (sort (i), [2 3]');
 %! assert (sort (j), [2 3]');
 
 %% Test input validation
 %!error sprandsym ()
 %!error sprandsym (1, 2, 3)
-%!error sprandsym (ones(3), 0.5)
+%!error sprandsym (ones (3), 0.5)
 %!error sprandsym (3.5, 0.5)
 %!error sprandsym (0, 0.5)
 %!error sprandsym (3, -1)
 %!error sprandsym (3, 2)
 
diff --git a/scripts/sparse/spstats.m b/scripts/sparse/spstats.m
--- a/scripts/sparse/spstats.m
+++ b/scripts/sparse/spstats.m
@@ -54,12 +54,13 @@ function [count, mean, var] = spstats (S
     diff = S - sparse (i, j, mean(j), n, m);
     var = sum (diff .* diff) ./ (count - 1);
   endif
 
 endfunction
 
 
 %!test
-%! [n,m,v] = spstats([1 2 1 2 3 4],[2 2 1 1 1 1]);
-%! assert(n,sparse([4,2]));
-%! assert(m,sparse([10/4,3/2]),10*eps);
-%! assert(v,sparse([5/3,1/2]),10*eps);
+%! [n,m,v] = spstats ([1 2 1 2 3 4],[2 2 1 1 1 1]);
+%! assert (n, sparse ([4,2]));
+%! assert (m, sparse ([10/4,3/2]), 10*eps);
+%! assert (v, sparse ([5/3,1/2]), 10*eps);
+
diff --git a/scripts/sparse/spy.m b/scripts/sparse/spy.m
--- a/scripts/sparse/spy.m
+++ b/scripts/sparse/spy.m
@@ -67,9 +67,10 @@ function spy (x, varargin)
 endfunction
 
 
 %!demo
 %! clf;
 %! spy (sprand (10,10, 0.2));
 
 %% Mark graphical function as tested by demo block
-%!assert (1);
+%!assert (1)
+
diff --git a/scripts/sparse/svds.m b/scripts/sparse/svds.m
--- a/scripts/sparse/svds.m
+++ b/scripts/sparse/svds.m
@@ -24,19 +24,19 @@
 ## @deftypefnx {Function File} {[@var{u}, @var{s}, @var{v}] =} svds (@dots{})
 ## @deftypefnx {Function File} {[@var{u}, @var{s}, @var{v}, @var{flag}] =} svds (@dots{})
 ##
 ## Find a few singular values of the matrix @var{A}.  The singular values
 ## are calculated using
 ##
 ## @example
 ## @group
-## [@var{m}, @var{n}] = size(@var{A})
-## @var{s} = eigs([sparse(@var{m}, @var{m}), @var{A};
-##                     @var{A}', sparse(@var{n}, @var{n})])
+## [@var{m}, @var{n}] = size (@var{A});
+## @var{s} = eigs ([sparse(@var{m}, @var{m}), @var{A};
+##                      @var{A}', sparse(@var{n}, @var{n})])
 ## @end group
 ## @end example
 ##
 ## The eigenvalues returned by @code{eigs} correspond to the singular values
 ## of @var{A}.  The number of singular values to calculate is given by @var{k}
 ## and defaults to 6.
 ##
 ## The argument @var{sigma} specifies which singular values to find.  When
@@ -236,16 +236,17 @@ function [u, s, v, flag] = svds (A, k, s
 
     if (nargout > 3)
       flag = norm (A*v - u*s, 1) > root2 * opts.tol * norm (A, 1);
     endif
   endif
 
 endfunction
 
+
 %!shared n, k, A, u, s, v, opts, rand_state, randn_state
 %! n = 100;
 %! k = 7;
 %! A = sparse ([3:n,1:n,1:(n-2)],[1:(n-2),1:n,3:n],[ones(1,n-2),0.4*n*ones(1,n),ones(1,n-2)]);
 %! [u,s,v] = svd (full (A));
 %! s = diag (s);
 %! [~, idx] = sort (abs(s));
 %! s = s(idx);
diff --git a/scripts/sparse/treelayout.m b/scripts/sparse/treelayout.m
--- a/scripts/sparse/treelayout.m
+++ b/scripts/sparse/treelayout.m
@@ -197,16 +197,17 @@ function [x_coordinate, y_coordinate, he
     ## Calculate the x coordinates (the known values are the position
     ## of most left and most right descendants).
     x_coordinate = (x_coordinate_l + x_coordinate_r) / 2;
 
     height = num_nodes - max_ht - 1;
   endif
 endfunction
 
+
 %!test
 %! % Compute a simple tree layout
 %! [x, y, h, s] = treelayout ([0, 1, 2, 2]);
 %! assert (x, [1.5, 1.5, 2, 1]);
 %! assert (y, [3, 2, 1, 1]);
 %! assert (h, 2);
 %! assert (s, 2);
 
@@ -220,8 +221,9 @@ endfunction
 
 %!test
 %! % Compute a simple tree layout with defined postorder permutation
 %! [x, y, h, s] = treelayout ([0, 1, 2, 2], [4, 2, 3, 1]);
 %! assert (x, [0, 0, 0, 1]);
 %! assert (y, [0, 0, 0, 3]);
 %! assert (h, 0);
 %! assert (s, 1);
+
diff --git a/scripts/specfun/bessel.m b/scripts/specfun/bessel.m
--- a/scripts/specfun/bessel.m
+++ b/scripts/specfun/bessel.m
@@ -86,9 +86,10 @@
 ## return @code{NaN}.
 ## @end enumerate
 ## @end deftypefn
 
 function bessel ()
   error ("bessel: you must use besselj, bessely, besseli, or besselk");
 endfunction
 
+
 %!error bessel ()
diff --git a/scripts/specfun/beta.m b/scripts/specfun/beta.m
--- a/scripts/specfun/beta.m
+++ b/scripts/specfun/beta.m
@@ -50,33 +50,35 @@ function retval = beta (a, b)
   if (! isreal (a) || ! isreal (b))
     error ("beta: inputs A and B must be real");
   endif
 
   retval = real (exp (gammaln (a) + gammaln (b) - gammaln (a+b)));
 
 endfunction
 
+
 %!test
-%! a=[1, 1.5, 2, 3];
-%! b=[4, 3, 2, 1];
-%! v1=beta(a,b);
-%! v2=beta(b,a);
-%! v3=gamma(a).*gamma(b)./gamma(a+b);
-%! assert(all(abs(v1-v2)<sqrt(eps)) && all(abs(v2-v3)<sqrt(eps)));
+%! a = [1, 1.5, 2, 3];
+%! b = [4, 3, 2, 1];
+%! v1 = beta (a,b);
+%! v2 = beta (b,a);
+%! v3 = gamma (a).*gamma (b) ./ gamma (a+b);
+%! assert (v1, v2, sqrt (eps));
+%! assert (v2, v3, sqrt (eps));
 
-%!error beta();
-
-%!error beta(1);
-
-%!assert (1, beta (1, 1))
+%!assert (beta (1, 1), 1)
 
 %!test
 %! a = 2:10;
 %! tol = 10 * max (a) * eps;
-%! assert (-a, beta (-1./a, 1), tol)
-%! assert (-a, beta (1, -1./a), tol)
+%! assert (-a, beta (-1./a, 1), tol);
+%! assert (-a, beta (1, -1./a), tol);
 
 %!test
 %! a = 0.25 + (0:5) * 0.5;
 %! tol = 10 * max (a) * eps;
-%! assert (zeros (size (a)), beta (a, -a), tol)
-%! assert (zeros (size (a)), beta (-a, a), tol)
+%! assert (zeros (size (a)), beta (a, -a), tol);
+%! assert (zeros (size (a)), beta (-a, a), tol);
+
+%!error beta ()
+%!error beta (1)
+
diff --git a/scripts/specfun/betaln.m b/scripts/specfun/betaln.m
--- a/scripts/specfun/betaln.m
+++ b/scripts/specfun/betaln.m
@@ -45,13 +45,13 @@ function retval = betaln (a, b)
     print_usage ();
   endif
 
   retval = gammaln (a) + gammaln (b) - gammaln (a + b);
 
 endfunction
 
 
-%!assert (betaln (3,4), log (beta(3,4)),eps);
+%!assert (betaln (3,4), log (beta (3,4)), eps)
 
 %% Test input validation
 %!error (betaln (1))
 %!error (betaln (1,2,3))
diff --git a/scripts/specfun/factor.m b/scripts/specfun/factor.m
--- a/scripts/specfun/factor.m
+++ b/scripts/specfun/factor.m
@@ -77,19 +77,20 @@ function [x, n] = factor (q)
   if (nargout > 1)
     idx = find ([0, x] != [x, 0]);
     x = x(idx(1:length(idx)-1));
     n = diff (idx);
   endif
 
 endfunction
 
+
+%!assert (factor (1), 1)
 %!test
-%!  assert(factor(1),1);
-%!  for i=2:20
-%!     p = factor(i);
-%!     assert(prod(p),i);
-%!     assert(all(isprime(p)));
-%!     [p,n] = factor(i);
-%!     assert(prod(p.^n),i);
-%!     assert(all([0,p]!=[p,0]));
-%!  endfor
+%! for i = 2:20
+%!   p = factor (i);
+%!   assert (prod (p), i);
+%!   assert (all (isprime (p)));
+%!   [p,n] = factor (i);
+%!   assert (prod (p.^n), i);
+%!   assert (all ([0,p] != [p,0]));
+%! endfor
 
diff --git a/scripts/specfun/factorial.m b/scripts/specfun/factorial.m
--- a/scripts/specfun/factorial.m
+++ b/scripts/specfun/factorial.m
@@ -30,13 +30,16 @@ function x = factorial (n)
   if (nargin != 1)
     print_usage ();
   elseif (any (n(:) < 0 | n(:) != fix (n(:))))
     error ("factorial: N must all be non-negative integers");
   endif
   x = round (gamma (n+1));
 endfunction
 
-%!assert (factorial(5), prod(1:5))
-%!assert (factorial([1,2;3,4]), [1,2;6,24])
-%!assert (factorial(70), exp(sum(log(1:70))), -128*eps)
-%!fail ('factorial(5.5)', "must all be non-negative integers")
-%!fail ('factorial(-3)', "must all be non-negative integers")
+
+%!assert (factorial (5), prod (1:5))
+%!assert (factorial ([1,2;3,4]), [1,2;6,24])
+%!assert (factorial (70), exp (sum (log (1:70))), -128*eps)
+
+%!fail ("factorial (5.5)", "must all be non-negative integers")
+%!fail ("factorial (-3)", "must all be non-negative integers")
+
diff --git a/scripts/specfun/isprime.m b/scripts/specfun/isprime.m
--- a/scripts/specfun/isprime.m
+++ b/scripts/specfun/isprime.m
@@ -75,13 +75,15 @@ function t = isprime (x)
 
   else
     print_usage ();
   endif
 
 endfunction
 
 
-%!assert (isprime (4), logical (0));
-%!assert (isprime (3), logical (1));
-%!assert (isprime (magic (3)), logical ([0, 0, 0; 1, 1, 1; 0, 0, 1]));
+%!assert (isprime (3), true)
+%!assert (isprime (4), false)
+%!assert (isprime (magic (3)), logical ([0, 0, 0; 1, 1, 1; 0, 0, 1]))
+
 %!error isprime ()
 %!error isprime (1, 2)
+
diff --git a/scripts/specfun/lcm.m b/scripts/specfun/lcm.m
--- a/scripts/specfun/lcm.m
+++ b/scripts/specfun/lcm.m
@@ -46,16 +46,16 @@ function l = lcm (varargin)
       l(msk) = 0;
     endfor
   else
     print_usage ();
   endif
 
 endfunction
 
-%!assert(lcm (3, 5, 7, 15) == 105);
+
+%!assert (lcm (3, 5, 7, 15), 105)
 
 %!error lcm ();
-
 %!test
 %! s.a = 1;
-%! fail("lcm (s)");
+%! fail ("lcm (s)");
 
diff --git a/scripts/specfun/legendre.m b/scripts/specfun/legendre.m
--- a/scripts/specfun/legendre.m
+++ b/scripts/specfun/legendre.m
@@ -38,17 +38,17 @@
 ## P^m_n(x) = (-1)^m (1-x^2)^{m/2}{d^m\over {dx^m}}P_n (x)
 ## $$
 ## @end tex
 ## @ifnottex
 ##
 ## @example
 ## @group
 ##  m        m       2  m/2   d^m
-## P(x) = (-1) * (1-x  )    * ----  P (x)
+## P(x) = (-1) * (1-x  )    * ----  P(x)
 ##  n                         dx^m   n
 ## @end group
 ## @end example
 ##
 ## @end ifnottex
 ##
 ## @noindent
 ## with Legendre polynomial of degree @var{n}:
@@ -57,30 +57,30 @@
 ## $$
 ## P(x) = {1\over{2^n n!}}\biggl({d^n\over{dx^n}}(x^2 - 1)^n\biggr)
 ## $$
 ## @end tex
 ## @ifnottex
 ##
 ## @example
 ## @group
-##           1     d^n   2    n
-## P (x) = ------ [----(x - 1)  ]
-##  n      2^n n!  dx^n
+##           1    d^n   2    n
+## P(x) = ------ [----(x - 1) ]
+##  n     2^n n!  dx^n
 ## @end group
 ## @end example
 ##
 ## @end ifnottex
 ##
 ## @noindent
 ## @code{legendre (3, [-1.0, -0.9, -0.8])} returns the matrix:
 ##
 ## @example
 ## @group
-##  x  |   -1.0   |   -0.9   |  -0.8
+##  x  |   -1.0   |   -0.9   |   -0.8
 ## ------------------------------------
 ## m=0 | -1.00000 | -0.47250 | -0.08000
 ## m=1 |  0.00000 | -1.99420 | -1.98000
 ## m=2 |  0.00000 | -2.56500 | -4.32000
 ## m=3 |  0.00000 | -1.24229 | -3.24000
 ## @end group
 ## @end example
 ##
@@ -95,38 +95,38 @@
 ## $$
 ## SP^0_n (x) = P^0_n (x)
 ## $$
 ## @end tex
 ## @ifnottex
 ##
 ## @example
 ## @group
-##   0       0
-## SP (x) = P (x)
-##   n       n
+##   0      0
+## SP(x) = P(x)
+##   n      n
 ## @end group
 ## @end example
 ##
 ## @end ifnottex
 ##
 ## For Legendre functions of degree n and order m:
 ##
 ## @tex
 ## $$
 ## SP^m_n (x) = P^m_n (x)(-1)^m\biggl({2(n-m)!\over{(n+m)!}}\biggl)^{0.5}
 ## $$
 ## @end tex
 ## @ifnottex
 ##
 ## @example
 ## @group
-##   m       m          m    2(n-m)! 0.5
-## SP (x) = P (x) * (-1)  * [-------]
-##   n       n               (n+m)!
+##   m      m         m    2(n-m)! 0.5
+## SP(x) = P(x) * (-1)  * [-------]
+##   n      n              (n+m)!
 ## @end group
 ## @end example
 ##
 ## @end ifnottex
 ##
 ## If the optional argument @var{normalization} is @code{"norm"},
 ## compute the fully normalized associated Legendre function.
 ## The fully normalized associated Legendre function is related
@@ -138,19 +138,19 @@
 ## $$
 ## NP^m_n (x) = P^m_n (x)(-1)^m\biggl({(n+0.5)(n-m)!\over{(n+m)!}}\biggl)^{0.5}
 ## $$
 ## @end tex
 ## @ifnottex
 ##
 ## @example
 ## @group
-##   m       m          m    (n+0.5)(n-m)! 0.5
-## NP (x) = P (x) * (-1)  * [-------------]
-##   n       n                   (n+m)!
+##   m      m         m    (n+0.5)(n-m)! 0.5
+## NP(x) = P(x) * (-1)  * [-------------]
+##   n      n                  (n+m)!
 ## @end group
 ## @end example
 ##
 ## @end ifnottex
 ## @end deftypefn
 
 ## Author: Marco Caliari <marco.caliari@univr.it>
 
@@ -281,35 +281,36 @@ endfunction
 
 %!test
 %! result = legendre (150, 0);
 %! ## This agrees with Matlab's result.
 %! assert (result(end), 3.7532741115719e+306, 0.0000000000001e+306);
 
 %!test
 %! result = legendre (0, 0:0.1:1);
-%! assert (result, full(ones(1,11)));
+%! assert (result, full (ones (1,11)));
 
 %!test
 %! result = legendre (3, [-1,0,1;1,0,-1]);
 %! ## Test matrix input
 %! expected(:,:,1) = [-1,1;0,0;0,0;0,0];
 %! expected(:,:,2) = [0,0;1.5,1.5;0,0;-15,-15];
 %! expected(:,:,3) = [1,-1;0,0;0,0;0,0];
 %! assert (result, expected);
 
 %!test
 %! result = legendre (3, [-1,0,1;1,0,-1]');
 %! expected(:,:,1) = [-1,0,1;0,1.5,0;0,0,0;0,-15,0];
 %! expected(:,:,2) = [1,0,-1;0,1.5,0;0,0,0;0,-15,0];
 %! assert (result, expected);
 
 %% Check correct invocation
-%!error legendre ();
-%!error legendre (1);
-%!error legendre (1,2,3,4);
-%!error legendre ([1, 2], [-1, 0, 1]);
-%!error legendre (-1, [-1, 0, 1]);
-%!error legendre (1.1, [-1, 0, 1]);
-%!error legendre (1, [-1+i, 0, 1]);
-%!error legendre (1, [-2, 0, 1]);
-%!error legendre (1, [-1, 0, 2]);
-%!error legendre (1, [-1, 0, 1], "badnorm");
+%!error legendre ()
+%!error legendre (1)
+%!error legendre (1,2,3,4)
+%!error legendre ([1, 2], [-1, 0, 1])
+%!error legendre (-1, [-1, 0, 1])
+%!error legendre (1.1, [-1, 0, 1])
+%!error legendre (1, [-1+i, 0, 1])
+%!error legendre (1, [-2, 0, 1])
+%!error legendre (1, [-1, 0, 2])
+%!error legendre (1, [-1, 0, 1], "badnorm")
+
diff --git a/scripts/specfun/nchoosek.m b/scripts/specfun/nchoosek.m
--- a/scripts/specfun/nchoosek.m
+++ b/scripts/specfun/nchoosek.m
@@ -136,17 +136,17 @@ function A = nchoosek (v, k)
     endfor
     clear cA b;
     A = A.';
   endif
 endfunction
 
 
 %!assert (nchoosek (80,10), bincoeff (80,10))
-%!assert (nchoosek(1:5,3), [1:3;1,2,4;1,2,5;1,3,4;1,3,5;1,4,5;2:4;2,3,5;2,4,5;3:5])
+%!assert (nchoosek (1:5,3), [1:3;1,2,4;1,2,5;1,3,4;1,3,5;1,4,5;2:4;2,3,5;2,4,5;3:5])
 
 %% Test input validation
 %!warning nchoosek (100,45);
 %!error nchoosek ("100", 45)
 %!error nchoosek (100, "45")
 %!error nchoosek (100, ones (2,2))
 %!error nchoosek (repmat (100, [2 2]), 45)
 %!error nchoosek (100, -45)
diff --git a/scripts/specfun/nthroot.m b/scripts/specfun/nthroot.m
--- a/scripts/specfun/nthroot.m
+++ b/scripts/specfun/nthroot.m
@@ -76,21 +76,22 @@ function y = nthroot (x, n)
       y = ((n-1)*y + x ./ (y.^(n-1))) / n;
       y = merge (finite (y), y, x);
     endif
 
   endif
 
 endfunction
 
-%!assert (nthroot(-32,5), -2);
-%!assert (nthroot(81,4), 3);
-%!assert (nthroot(Inf,4), Inf);
-%!assert (nthroot(-Inf,7), -Inf);
-%!assert (nthroot(-Inf,-7), 0);
+
+%!assert (nthroot (-32,5), -2);
+%!assert (nthroot (81,4), 3);
+%!assert (nthroot (Inf,4), Inf);
+%!assert (nthroot (-Inf,7), -Inf);
+%!assert (nthroot (-Inf,-7), 0);
 
 %% Test input validation
 %!error (nthroot ())
 %!error (nthroot (1))
 %!error (nthroot (1,2,3))
 %!error (nthroot (1+j,2))
 %!error (nthroot (1,[1 2]))
 %!error (nthroot (1,0))
diff --git a/scripts/specfun/perms.m b/scripts/specfun/perms.m
--- a/scripts/specfun/perms.m
+++ b/scripts/specfun/perms.m
@@ -59,15 +59,16 @@ function A = perms (v)
         A(idx,i) = v(j);
         A(idx,i+1:j) = B(:,i:j-1);
         idx += k;
       endfor
     endfor
   endif
 endfunction
 
-%!error perms ();
-%!error perms (1, 2);
 
-%!assert (perms ([1,2,3]), [1,2,3;2,1,3;1,3,2;2,3,1;3,1,2;3,2,1]);
-%!assert (perms (1:3), perms ([1,2,3]));
+%!assert (perms ([1,2,3]), [1,2,3;2,1,3;1,3,2;2,3,1;3,1,2;3,2,1])
+%!assert (perms (1:3), perms ([1,2,3]))
+%!assert (perms (int8 ([1,2,3])), int8 ([1,2,3;2,1,3;1,3,2;2,3,1;3,1,2;3,2,1]))
 
-%!assert (perms (int8([1,2,3])), int8([1,2,3;2,1,3;1,3,2;2,3,1;3,1,2;3,2,1]));
+%!error perms ()
+%!error perms (1, 2)
+
diff --git a/scripts/specfun/pow2.m b/scripts/specfun/pow2.m
--- a/scripts/specfun/pow2.m
+++ b/scripts/specfun/pow2.m
@@ -49,21 +49,22 @@ function y = pow2 (f, e)
   elseif (nargin == 2)
     y = f .* (2 .^ e);
   else
     print_usage ();
   endif
 
 endfunction
 
+
 %!test
 %! x = [3, 0, -3];
 %! v = [8, 1, .125];
-%! assert(all (abs (pow2 (x) - v) < sqrt (eps)));
+%! assert (pow2 (x), v, sqrt (eps));
 
 %!test
 %! x = [3, 0, -3, 4, 0, -4, 5, 0, -5];
 %! y = [-2, -2, -2, 1, 1, 1, 3, 3, 3];
 %! z = x .* (2 .^ y);
-%! assert(all (abs (pow2 (x,y) - z) < sqrt (eps)));
+%! assert (pow2 (x,y), z, sqrt (eps));
 
-%!error pow2();
+%!error pow2 ()
 
diff --git a/scripts/specfun/primes.m b/scripts/specfun/primes.m
--- a/scripts/specfun/primes.m
+++ b/scripts/specfun/primes.m
@@ -88,15 +88,15 @@ function x = primes (n)
          173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, ...
          233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, ...
          293, 307, 311, 313, 317, 331, 337, 347, 349];
     x = a(a <= n);
   endif
 
 endfunction
 
-%!error primes ();
-%!error primes (1, 2);
+
+%!assert (size (primes (350)), [1, 70])
+%!assert (primes (357)(end), 353)
 
-%!assert (size (primes (350)), [1, 70]);
-%!assert (size (primes (350)), [1, 70]);
+%!error primes ()
+%!error primes (1, 2)
 
-%!assert (primes (357)(end), 353);
diff --git a/scripts/specfun/reallog.m b/scripts/specfun/reallog.m
--- a/scripts/specfun/reallog.m
+++ b/scripts/specfun/reallog.m
@@ -28,13 +28,16 @@ function y = reallog (x)
     print_usage ();
   elseif (iscomplex (x) || any (x(:) < 0))
     error ("reallog: produced complex result");
   else
     y = log (x);
   endif
 endfunction
 
-%!assert (log(1:5),reallog(1:5))
+
+%!assert (log (1:5), reallog (1:5))
 %!test
 %! x = rand (10,10);
-%! assert (log(x),reallog(x))
-%!error (reallog(-1))
+%! assert (log (x),reallog (x));
+
+%!error <produced complex result> reallog (-1)
+
diff --git a/scripts/specfun/realpow.m b/scripts/specfun/realpow.m
--- a/scripts/specfun/realpow.m
+++ b/scripts/specfun/realpow.m
@@ -30,16 +30,19 @@ function z = realpow (x, y)
   else
     z = x .^ y;
     if (iscomplex (z))
       error ("realpow: produced complex result");
     endif
   endif
 endfunction
 
+
 %!assert (power (1:10, 0.5:0.5:5), realpow (1:10, 0.5:0.5:5))
 %!assert ([1:10] .^ [0.5:0.5:5], realpow (1:10, 0.5:0.5:5))
 %!test
 %! x = rand (10,10);
 %! y = randn (10,10);
-%! assert (x.^y,realpow(x,y))
-%!assert (realpow(1i,2),-1)
-%!error (realpow(-1, 1/2))
+%! assert (x.^y, realpow (x,y));
+%!assert (realpow (1i,2), -1)
+
+%!error <produced complex result> realpow (-1, 1/2)
+
diff --git a/scripts/specfun/realsqrt.m b/scripts/specfun/realsqrt.m
--- a/scripts/specfun/realsqrt.m
+++ b/scripts/specfun/realsqrt.m
@@ -28,13 +28,16 @@ function y = realsqrt (x)
     print_usage ();
   elseif (iscomplex (x) || any (x(:) < 0))
     error ("realsqrt: produced complex result");
   else
     y = sqrt (x);
   endif
 endfunction
 
-%!assert (sqrt(1:5),realsqrt(1:5))
+
+%!assert (sqrt (1:5), realsqrt (1:5))
 %!test
 %! x = rand (10,10);
-%! assert (sqrt(x),realsqrt(x))
-%!error (realsqrt(-1))
+%! assert (sqrt (x), realsqrt (x));
+
+%!error <produced complex result> realsqrt (-1)
+
diff --git a/scripts/special-matrix/hadamard.m b/scripts/special-matrix/hadamard.m
--- a/scripts/special-matrix/hadamard.m
+++ b/scripts/special-matrix/hadamard.m
@@ -160,16 +160,16 @@ function h = h28 ()
        1 -1 1 1 -1 -1 1 1 -1 -1 -1 1 -1 -1 1 1 -1 1 1 1 -1 -1 1 1 -1 -1 1 -1];
 endfunction
 
 
 %!assert (hadamard (1), 1)
 %!assert (hadamard (2), [1,1;1,-1])
 %!test
 %! for n = [1,2,4,8,12,24,48,20,28,2^9]
-%!   h = hadamard(n);
+%!   h = hadamard (n);
 %!   assert (norm (h*h' - n*eye (n)), 0);
 %! endfor
 
 %!error hadamard ()
 %!error hadamard (1,2)
 %!error <N must be 2\^k\*p> hadamard (5)
 
diff --git a/scripts/special-matrix/hankel.m b/scripts/special-matrix/hankel.m
--- a/scripts/special-matrix/hankel.m
+++ b/scripts/special-matrix/hankel.m
@@ -24,17 +24,17 @@
 ## not the same as the first element of @var{r}, the last element of
 ## @var{c} is used.  If the second argument is omitted, it is assumed to
 ## be a vector of zeros with the same size as @var{c}.
 ##
 ## A Hankel matrix formed from an m-vector @var{c}, and an n-vector
 ## @var{r}, has the elements
 ## @tex
 ## $$
-## H (i, j) = \cases{c_{i+j-1},&$i+j-1\le m$;\cr r_{i+j-m},&otherwise.\cr}
+## H(i, j) = \cases{c_{i+j-1},&$i+j-1\le m$;\cr r_{i+j-m},&otherwise.\cr}
 ## $$
 ## @end tex
 ## @ifnottex
 ##
 ## @example
 ## @group
 ## H(i,j) = c(i+j-1),  i+j-1 <= m;
 ## H(i,j) = r(i+j-m),  otherwise
@@ -86,13 +86,13 @@ endfunction
 %!assert (hankel (1), [1])
 %!assert (hankel ([1, 2]), [1, 2; 2, 0])
 %!assert (hankel ([1, 2], [2; -1; -3]), [1, 2, -1; 2, -1, -3])
 %!assert (hankel (1:3), [1,2,3;2,3,0;3,0,0])
 %!assert (hankel (1:3,3:6), [1,2,3,4;2,3,4,5;3,4,5,6])
 %!assert (hankel (1:3,3:4), [1,2;2,3;3,4])
 %!assert (hankel (1:3,4:6), [1,2,3;2,3,5;3,5,6])
 
-%!error hankel ();
-%!error hankel (1, 2, 3);
+%!error hankel ()
+%!error hankel (1, 2, 3)
 %!error <C must be a vector> hankel ([1, 2; 3, 4])
 %!error <C and R must be vectors> hankel (1:4, [1, 2; 3, 4])
 
diff --git a/scripts/special-matrix/hilb.m b/scripts/special-matrix/hilb.m
--- a/scripts/special-matrix/hilb.m
+++ b/scripts/special-matrix/hilb.m
@@ -17,38 +17,38 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} hilb (@var{n})
 ## Return the Hilbert matrix of order @var{n}.  The @math{i,j} element
 ## of a Hilbert matrix is defined as
 ## @tex
 ## $$
-## H (i, j) = {1 \over (i + j - 1)}
+## H(i, j) = {1 \over (i + j - 1)}
 ## $$
 ## @end tex
 ## @ifnottex
 ##
 ## @example
-## H (i, j) = 1 / (i + j - 1)
+## H(i, j) = 1 / (i + j - 1)
 ## @end example
 ##
 ## @end ifnottex
 ##
 ## Hilbert matrices are close to being singular which make them difficult to
 ## invert with numerical routines.
 ## Comparing the condition number of a random matrix 5x5 matrix with that of
 ## a Hilbert matrix of order 5 reveals just how difficult the problem is.
 ##
 ## @example
 ## @group
 ## cond (rand (5))
-##     @result{} 14.392
+##    @result{} 14.392
 ## cond (hilb (5))
-##     @result{} 4.7661e+05
+##    @result{} 4.7661e+05
 ## @end group
 ## @end example
 ##
 ## @seealso{invhilb}
 ## @end deftypefn
 
 ## Author: jwe
 
@@ -70,10 +70,10 @@ function retval = hilb (n)
 endfunction
 
 
 %!assert (hilb (2), [1, 1/2; 1/2, 1/3])
 %!assert (hilb (3), [1, 1/2, 1/3; 1/2, 1/3, 1/4; 1/3, 1/4, 1/5])
 
 %!error hilb ()
 %!error hilb (1, 2)
-%!error <N must be a scalar integer> hilb (ones(2))
+%!error <N must be a scalar integer> hilb (ones (2))
 
diff --git a/scripts/special-matrix/invhilb.m b/scripts/special-matrix/invhilb.m
--- a/scripts/special-matrix/invhilb.m
+++ b/scripts/special-matrix/invhilb.m
@@ -115,14 +115,14 @@ endfunction
 %!assert (invhilb (1), 1)
 %!assert (invhilb (2), [4, -6; -6, 12])
 %!test
 %! result4 = [16  , -120 , 240  , -140;
 %!            -120, 1200 , -2700, 1680;
 %!            240 , -2700, 6480 , -4200;
 %!            -140, 1680 , -4200, 2800];
 %! assert (invhilb (4), result4);
-%!assert (abs (invhilb (7) * hilb (7) - eye (7)) < sqrt (eps))
+%!assert (invhilb (7) * hilb (7), eye (7), sqrt (eps))
 
 %!error invhilb ()
 %!error invhilb (1, 2)
 %!error <N must be a scalar integer> invhilb ([1, 2])
 
diff --git a/scripts/special-matrix/magic.m b/scripts/special-matrix/magic.m
--- a/scripts/special-matrix/magic.m
+++ b/scripts/special-matrix/magic.m
@@ -75,23 +75,23 @@ function A = magic(n)
     A([I,I+m],I) = A([I+m,I],I);
 
   endif
 
 endfunction
 
 
 %!test
-%! for i=3:30
+%! for i = 3:30
 %!   A = magic (i);
 %!   assert (norm(diff([sum(diag(A)),sum(diag(flipud(A))),sum(A),sum(A')])),0);
 %! endfor
 
 %!assert (isempty (magic (0)))
-%!assert (magic(1), 1)
+%!assert (magic (1), 1)
 
 %% Test input validation
 %!error magic ()
 %!error magic (1, 2)
 %!error <N must be a positive integer not equal to 2> magic (1.5)
 %!error <N must be a positive integer not equal to 2> magic (-1)
 %!error <N must be a positive integer not equal to 2> magic (2)
 
diff --git a/scripts/special-matrix/rosser.m b/scripts/special-matrix/rosser.m
--- a/scripts/special-matrix/rosser.m
+++ b/scripts/special-matrix/rosser.m
@@ -39,10 +39,14 @@ function retval = rosser ()
             407,  -192,   196,   611,     8,    44,    59,   -23;
              -8,   -71,    61,     8,   411,  -599,   208,   208;
             -52,   -43,    49,    44,  -599,   411,   208,   208;
             -49,    -8,     8,    59,   208,   208,    99,  -911;
              29,   -44,    52,   -23,   208,   208,  -911,    99];
 
 endfunction
 
-%!assert (size(rosser()), [8,8])
-%!error (rosser(1))
+
+%!assert (size (rosser ()), [8,8])
+%!assert (rosser ()([1, end]), [611, 99])
+
+%!error (rosser (1))
+
diff --git a/scripts/special-matrix/vander.m b/scripts/special-matrix/vander.m
--- a/scripts/special-matrix/vander.m
+++ b/scripts/special-matrix/vander.m
@@ -74,22 +74,22 @@ function retval = vander (c, n)
   endfor
 
 endfunction
 
 
 %!test
 %! c = [0,1,2,3];
 %! expect = [0,0,0,1; 1,1,1,1; 8,4,2,1; 27,9,3,1];
-%! assert(vander (c), expect);
+%! assert (vander (c), expect);
 
 %!assert (vander (1), 1)
 %!assert (vander ([1, 2, 3]), vander ([1; 2; 3]))
 %!assert (vander ([1, 2, 3]), [1, 1, 1; 4, 2, 1; 9, 3, 1])
 %!assert (vander ([1, 2, 3]*i), [-1, i, 1; -4, 2i, 1; -9, 3i, 1])
 
-%!assert(vander (2, 3), [4, 2, 1])
-%!assert(vander ([2, 3], 3), [4, 2, 1; 9, 3, 1])
+%!assert (vander (2, 3), [4, 2, 1])
+%!assert (vander ([2, 3], 3), [4, 2, 1; 9, 3, 1])
 
-%!error vander ();
-%!error vander (1, 2, 3);
-%!error <polynomial C must be a vector> vander ([1, 2; 3, 4]);
+%!error vander ()
+%!error vander (1, 2, 3)
+%!error <polynomial C must be a vector> vander ([1, 2; 3, 4])
 
diff --git a/scripts/startup/__finish__.m b/scripts/startup/__finish__.m
--- a/scripts/startup/__finish__.m
+++ b/scripts/startup/__finish__.m
@@ -32,10 +32,11 @@ function __finish__ ()
   if (exist ("finish", "file"))
     ## No arg list here since finish might be a script.
     finish;
   endif
 
 endfunction
 
 
+
 ## No test needed for internal helper function.
 %!assert (1)
diff --git a/scripts/statistics/base/center.m b/scripts/statistics/base/center.m
--- a/scripts/statistics/base/center.m
+++ b/scripts/statistics/base/center.m
@@ -60,24 +60,26 @@ function retval = center (x, dim)
   if (n == 0)
     retval = x;
   else
     retval = bsxfun (@minus, x, mean (x, dim));
   endif
 
 endfunction
 
-%!assert(center ([1,2,3]), [-1,0,1])
-%!assert(center (single([1,2,3])), single([-1,0,1]))
-%!assert(center (int8 ([1,2,3])), [-1,0,1])
-%!assert(center (logical ([1, 0, 0, 1])), [0.5, -0.5, -0.5, 0.5])
-%!assert(center (ones (3,2,0,2)), zeros (3,2,0,2))
-%!assert(center (ones (3,2,0,2, 'single')), zeros (3,2,0,2, 'single'))
-%!assert(center (magic (3)), [3,-4,1;-2,0,2;-1,4,-3])
-%!assert(center ([1 2 3; 6 5 4], 2), [-1 0 1; 1 0 -1])
+
+%!assert (center ([1,2,3]), [-1,0,1])
+%!assert (center (single ([1,2,3])), single ([-1,0,1]))
+%!assert (center (int8 ([1,2,3])), [-1,0,1])
+%!assert (center (logical ([1, 0, 0, 1])), [0.5, -0.5, -0.5, 0.5])
+%!assert (center (ones (3,2,0,2)), zeros (3,2,0,2))
+%!assert (center (ones (3,2,0,2, "single")), zeros (3,2,0,2, "single"))
+%!assert (center (magic (3)), [3,-4,1;-2,0,2;-1,4,-3])
+%!assert (center ([1 2 3; 6 5 4], 2), [-1 0 1; 1 0 -1])
 
 %% Test input validation
 %!error center ()
 %!error center (1, 2, 3)
-%!error center (1, ones(2,2))
+%!error center (1, ones (2,2))
 %!error center (1, 1.5)
 %!error center (1, 0)
 %!error center (1, 3)
+
diff --git a/scripts/statistics/base/cloglog.m b/scripts/statistics/base/cloglog.m
--- a/scripts/statistics/base/cloglog.m
+++ b/scripts/statistics/base/cloglog.m
@@ -22,17 +22,17 @@
 ## @tex
 ## $$
 ## {\rm cloglog}(x) = - \log (- \log (x))
 ## $$
 ## @end tex
 ## @ifnottex
 ##
 ## @example
-## cloglog(x) = - log (- log (@var{x}))
+## cloglog (x) = - log (- log (@var{x}))
 ## @end example
 ##
 ## @end ifnottex
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Complementary log-log function
 
@@ -41,15 +41,17 @@ function y = cloglog (x)
   if (nargin != 1)
     print_usage ();
   endif
 
   y = - log (- log (x));
 
 endfunction
 
-%!assert(cloglog(0), -Inf)
-%!assert(cloglog(1), Inf)
-%!assert(cloglog(1/e), 0)
+
+%!assert (cloglog (0), -Inf)
+%!assert (cloglog (1), Inf)
+%!assert (cloglog (1/e), 0)
 
 %% Test input validation
 %!error cloglog ()
 %!error cloglog (1, 2)
+
diff --git a/scripts/statistics/base/corr.m b/scripts/statistics/base/corr.m
--- a/scripts/statistics/base/corr.m
+++ b/scripts/statistics/base/corr.m
@@ -28,17 +28,17 @@
 ## @tex
 ## $$
 ## {\rm corr}(x,y) = {{\rm cov}(x,y) \over {\rm std}(x) {\rm std}(y)}
 ## $$
 ## @end tex
 ## @ifnottex
 ##
 ## @example
-## corr(x,y) = cov(x,y)/(std(x)*std(y))
+## corr (x,y) = cov (x,y) / (std (x) * std (y))
 ## @end example
 ##
 ## @end ifnottex
 ## If called with one argument, compute @code{corr (@var{x}, @var{x})},
 ## the correlation between the columns of @var{x}.
 ## @seealso{cov}
 ## @end deftypefn
 
@@ -51,17 +51,17 @@ function retval = corr (x, y = [])
   if (nargin < 1 || nargin > 2)
     print_usage ();
   endif
 
   ## Input validation is done by cov.m.  Don't repeat tests here
 
   ## Special case, scalar is always 100% correlated with itself
   if (isscalar (x))
-    if (isa (x, 'single'))
+    if (isa (x, "single"))
       retval = single (1);
     else
       retval = 1;
     endif
     return;
   endif
 
   ## No check for division by zero error, which happens only when
@@ -84,29 +84,29 @@ endfunction
 %! cc1 = corr (x);
 %! cc2 = corr (x, x);
 %! assert (size (cc1) == [10, 10] && size (cc2) == [10, 10]);
 %! assert (cc1, cc2, sqrt (eps));
 
 %!test
 %! x = [1:3]';
 %! y = [3:-1:1]';
-%! assert (corr (x,y), -1, 5*eps)
-%! assert (corr (x,flipud (y)), 1, 5*eps)
-%! assert (corr ([x, y]), [1 -1; -1 1], 5*eps)
+%! assert (corr (x, y), -1, 5*eps);
+%! assert (corr (x, flipud (y)), 1, 5*eps);
+%! assert (corr ([x, y]), [1 -1; -1 1], 5*eps);
 
 %!test
 %! x = single ([1:3]');
 %! y = single ([3:-1:1]');
-%! assert (corr (x,y), single (-1), 5*eps)
-%! assert (corr (x,flipud (y)), single (1), 5*eps)
-%! assert (corr ([x, y]), single ([1 -1; -1 1]), 5*eps)
+%! assert (corr (x, y), single (-1), 5*eps);
+%! assert (corr (x, flipud (y)), single (1), 5*eps);
+%! assert (corr ([x, y]), single ([1 -1; -1 1]), 5*eps);
 
-%!assert (corr (5), 1);
-%!assert (corr (single(5)), single(1));
+%!assert (corr (5), 1)
+%!assert (corr (single(5)), single(1))
 
 %% Test input validation
-%!error corr ();
-%!error corr (1, 2, 3);
-%!error corr ([1; 2], ["A", "B"]);
-%!error corr (ones (2,2,2));
-%!error corr (ones (2,2), ones (2,2,2));
+%!error corr ()
+%!error corr (1, 2, 3)
+%!error corr ([1; 2], ["A", "B"])
+%!error corr (ones (2,2,2))
+%!error corr (ones (2,2), ones (2,2,2))
 
diff --git a/scripts/statistics/base/cov.m b/scripts/statistics/base/cov.m
--- a/scripts/statistics/base/cov.m
+++ b/scripts/statistics/base/cov.m
@@ -81,17 +81,17 @@ function c = cov (x, y = [], opt = 0)
   endif
 
   if (opt != 0 && opt != 1)
     error ("cov: normalization OPT must be 0 or 1");
   endif
 
   ## Special case, scalar has zero covariance
   if (isscalar (x))
-    if (isa (x, 'single'))
+    if (isa (x, "single"))
       c = single (0);
     else
       c = 0;
     endif
     return;
   endif
 
   if (isrow (x))
@@ -116,50 +116,50 @@ function c = cov (x, y = [], opt = 0)
 
 endfunction
 
 
 %!test
 %! x = rand (10);
 %! cx1 = cov (x);
 %! cx2 = cov (x, x);
-%! assert(size (cx1) == [10, 10] && size (cx2) == [10, 10]);
-%! assert(cx1, cx2, 1e1*eps);
+%! assert (size (cx1) == [10, 10] && size (cx2) == [10, 10]);
+%! assert (cx1, cx2, 1e1*eps);
 
 %!test
 %! x = [1:3]';
 %! y = [3:-1:1]';
-%! assert (cov (x,y), -1, 5*eps)
-%! assert (cov (x,flipud (y)), 1, 5*eps)
-%! assert (cov ([x, y]), [1 -1; -1 1], 5*eps)
+%! assert (cov (x, y), -1, 5*eps);
+%! assert (cov (x, flipud (y)), 1, 5*eps);
+%! assert (cov ([x, y]), [1 -1; -1 1], 5*eps);
 
 %!test
 %! x = single ([1:3]');
 %! y = single ([3:-1:1]');
-%! assert (cov (x,y), single (-1), 5*eps)
-%! assert (cov (x,flipud (y)), single (1), 5*eps)
-%! assert (cov ([x, y]), single ([1 -1; -1 1]), 5*eps)
+%! assert (cov (x, y), single (-1), 5*eps);
+%! assert (cov (x, flipud (y)), single (1), 5*eps);
+%! assert (cov ([x, y]), single ([1 -1; -1 1]), 5*eps);
 
 %!test
 %! x = [1:5];
 %! c = cov (x);
 %! assert (isscalar (c));
 %! assert (c, 2.5);
 
-%!assert(cov (5), 0);
-%!assert(cov (single(5)), single(0));
+%!assert(cov (5), 0)
+%!assert(cov (single(5)), single(0))
 
 %!test
 %! x = [1:5];
 %! c = cov (x, 0);
 %! assert(c, 2.5);
 %! c = cov (x, 1);
 %! assert(c, 2);
 
 %% Test input validation
-%!error cov ();
-%!error cov (1, 2, 3, 4);
-%!error cov ([1; 2], ["A", "B"]);
-%!error cov (ones (2,2,2));
-%!error cov (ones (2,2), ones (2,2,2));
-%!error cov (1, 3);
-%!error cov (ones (2,2), ones (3,2));
+%!error cov ()
+%!error cov (1, 2, 3, 4)
+%!error cov ([1; 2], ["A", "B"])
+%!error cov (ones (2,2,2))
+%!error cov (ones (2,2), ones (2,2,2))
+%!error cov (1, 3)
+%!error cov (ones (2,2), ones (3,2))
 
diff --git a/scripts/statistics/base/gls.m b/scripts/statistics/base/gls.m
--- a/scripts/statistics/base/gls.m
+++ b/scripts/statistics/base/gls.m
@@ -135,11 +135,11 @@ endfunction
 %!error gls (1, 2)
 %!error gls (1, 2, 3, 4)
 %!error gls ([true, true], [1, 2], ones (2))
 %!error gls ([1, 2], [true, true], ones (2))
 %!error gls ([1, 2], [1, 2], true (2))
 %!error gls (ones (2,2,2), ones (2,2), ones (4,4))
 %!error gls (ones (2,2), ones (2,2,2), ones (4,4))
 %!error gls (ones (2,2), ones (2,2), ones (4,4,4))
-%!error gls (ones(1,2), ones(2,2), ones (2,2))
-%!error gls (ones(2,2), ones(2,2), ones (2,2))
+%!error gls (ones (1,2), ones (2,2), ones (2,2))
+%!error gls (ones (2,2), ones (2,2), ones (2,2))
 
diff --git a/scripts/statistics/base/histc.m b/scripts/statistics/base/histc.m
--- a/scripts/statistics/base/histc.m
+++ b/scripts/statistics/base/histc.m
@@ -163,14 +163,15 @@ endfunction
 %! n = histc (x, 0:10);
 %! assert (n, [repmat(100, 1, 10), 1]);
 
 %!test
 %! x = repmat (linspace (0, 10, 1001), [2, 1, 3]);
 %! n = histc (x, 0:10, 2);
 %! assert (n, repmat ([repmat(100, 1, 10), 1], [2, 1, 3]));
 
-%!error histc ();
-%!error histc (1);
-%!error histc (1, 2, 3, 4);
-%!error histc ([1:10 1+i], 2);
-%!error histc (1:10, []);
-%!error histc (1, 1, 3);
+%!error histc ()
+%!error histc (1)
+%!error histc (1, 2, 3, 4)
+%!error histc ([1:10 1+i], 2)
+%!error histc (1:10, [])
+%!error histc (1, 1, 3)
+
diff --git a/scripts/statistics/base/iqr.m b/scripts/statistics/base/iqr.m
--- a/scripts/statistics/base/iqr.m
+++ b/scripts/statistics/base/iqr.m
@@ -55,18 +55,18 @@ function y = iqr (x, dim)
       error ("iqr: DIM must be an integer and a valid dimension");
     endif
   endif
 
   ## This code is a bit heavy, but is needed until empirical_inv
   ## can take a matrix, rather than just a vector argument.
   n = sz(dim);
   sz(dim) = 1;
-  if (isa (x, 'single'))
-    y = zeros (sz, 'single');
+  if (isa (x, "single"))
+    y = zeros (sz, "single");
   else
     y = zeros (sz);
   endif
   stride = prod (sz(1:dim-1));
   for i = 1 : nel / n;
     offset = i;
     offset2 = 0;
     while (offset > stride)
@@ -77,22 +77,22 @@ function y = iqr (x, dim)
     rng = [0 : n-1] * stride + offset;
 
     y(i) = diff (empirical_inv ([1/4, 3/4], x(rng)));
   endfor
 
 endfunction
 
 
-%!assert (iqr (1:101), 50);
-%!assert (iqr (single(1:101)), single(50));
+%!assert (iqr (1:101), 50)
+%!assert (iqr (single (1:101)), single (50))
 
 %%!test
 %%! x = [1:100];
 %%! n = iqr (x, 0:10);
 %%! assert (n, [repmat(100, 1, 10), 1]);
 
-%!error iqr ();
-%!error iqr (1, 2, 3);
-%!error iqr (1);
-%!error iqr (['A'; 'B']);
-%!error iqr (1:10, 3);
+%!error iqr ()
+%!error iqr (1, 2, 3)
+%!error iqr (1)
+%!error iqr (['A'; 'B'])
+%!error iqr (1:10, 3)
 
diff --git a/scripts/statistics/base/kendall.m b/scripts/statistics/base/kendall.m
--- a/scripts/statistics/base/kendall.m
+++ b/scripts/statistics/base/kendall.m
@@ -94,20 +94,20 @@ function tau = kendall (x, y = [])
     endif
     if (rows (y) != n)
       error ("kendall: X and Y must have the same number of observations");
     else
       x = [x, y];
     endif
   endif
 
-  if (isa (x, 'single') || isa (y, 'single'))
-    cls = 'single';
+  if (isa (x, "single") || isa (y, "single"))
+    cls = "single";
   else
-    cls = 'double';
+    cls = "double";
   endif
   r   = ranks (x);
   m   = sign (kron (r, ones (n, 1, cls)) - kron (ones (n, 1, cls), r));
   tau = corr (m);
 
   if (nargin == 2)
     tau = tau(1 : c, (c + 1) : columns (x));
   endif
@@ -116,19 +116,20 @@ endfunction
 
 
 %!test
 %! x = [1:2:10];
 %! y = [100:10:149];
 %! assert (kendall (x,y), 1, 5*eps);
 %! assert (kendall (x,fliplr (y)), -1, 5*eps);
 
-%!assert (kendall (logical(1)), 1);
-%!assert (kendall (single(1)), single(1));
+%!assert (kendall (logical (1)), 1)
+%!assert (kendall (single (1)), single (1))
 
 %% Test input validation
-%!error kendall ();
-%!error kendall (1, 2, 3);
-%!error kendall (['A'; 'B']);
-%!error kendall (ones(2,1), ['A'; 'B']);
-%!error kendall (ones (2,2,2));
-%!error kendall (ones (2,2), ones (2,2,2));
-%!error kendall (ones (2,2), ones (3,2));
+%!error kendall ()
+%!error kendall (1, 2, 3)
+%!error kendall (['A'; 'B'])
+%!error kendall (ones (2,1), ['A'; 'B'])
+%!error kendall (ones (2,2,2))
+%!error kendall (ones (2,2), ones (2,2,2))
+%!error kendall (ones (2,2), ones (3,2))
+
diff --git a/scripts/statistics/base/kurtosis.m b/scripts/statistics/base/kurtosis.m
--- a/scripts/statistics/base/kurtosis.m
+++ b/scripts/statistics/base/kurtosis.m
@@ -24,17 +24,17 @@
 ## $$
 ##  {\rm kurtosis} (x) = {1\over N \sigma^4} \sum_{i=1}^N (x_i-\bar{x})^4 - 3
 ## $$
 ## where $\bar{x}$ is the mean value of $x$.
 ## @end tex
 ## @ifnottex
 ##
 ## @example
-## kurtosis (x) = N^(-1) std(x)^(-4) sum ((x - mean(x)).^4) - 3
+## kurtosis (x) = 1/N std(x)^(-4) sum ((x - mean(x)).^4) - 3
 ## @end example
 ##
 ## @end ifnottex
 ## If @var{x} is a matrix, return the kurtosis over the
 ## first non-singleton dimension of the matrix.  If the optional
 ## @var{dim} argument is given, operate along this dimension.
 ##
 ## Note: The definition of kurtosis above yields a kurtosis of zero for the
@@ -82,19 +82,19 @@ function retval = kurtosis (x, dim)
 endfunction
 
 
 %!test
 %! x = [-1; 0; 0; 0; 1];
 %! y = [x, 2*x];
 %! assert (kurtosis (y), [-1.4, -1.4], sqrt (eps));
 
-%!assert (kurtosis (single(1)), single(0));
+%!assert (kurtosis (single (1)), single (0))
 
 %% Test input validation
 %!error kurtosis ()
 %!error kurtosis (1, 2, 3)
 %!error kurtosis (['A'; 'B'])
-%!error kurtosis (1, ones(2,2))
+%!error kurtosis (1, ones (2,2))
 %!error kurtosis (1, 1.5)
 %!error kurtosis (1, 0)
 %!error kurtosis (1, 3)
 
diff --git a/scripts/statistics/base/logit.m b/scripts/statistics/base/logit.m
--- a/scripts/statistics/base/logit.m
+++ b/scripts/statistics/base/logit.m
@@ -22,17 +22,17 @@
 ## @tex
 ## $$
 ## {\rm logit}(p) = \log\Big({p \over 1-p}\Big)
 ## $$
 ## @end tex
 ## @ifnottex
 ##
 ## @example
-## logit(@var{p}) = log (@var{p} / (1-@var{p}))
+## logit (@var{p}) = log (@var{p} / (1-@var{p}))
 ## @end example
 ##
 ## @end ifnottex
 ## @seealso{logistic_cdf}
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Logit transformation
@@ -45,15 +45,16 @@ function y = logit (p)
 
   y = logistic_inv (p);
 
 endfunction
 
 
 %!test
 %! p = [0.01:0.01:0.99];
-%! assert(logit (p), log (p ./ (1-p)), 25*eps)
+%! assert (logit (p), log (p ./ (1-p)), 25*eps);
 
-%!assert(logit ([-1, 0, 0.5, 1, 2]), [NaN, -Inf, 0, +Inf, NaN])
+%!assert (logit ([-1, 0, 0.5, 1, 2]), [NaN, -Inf, 0, +Inf, NaN])
 
 %% Test input validation
 %!error logit ()
 %!error logit (1, 2)
+
diff --git a/scripts/statistics/base/mahalanobis.m b/scripts/statistics/base/mahalanobis.m
--- a/scripts/statistics/base/mahalanobis.m
+++ b/scripts/statistics/base/mahalanobis.m
@@ -66,15 +66,16 @@ function retval = mahalanobis (x, y)
   winv = inv (w);
 
   retval = (xm - ym) * winv * (xm - ym)';
 
 endfunction
 
 
 %% Test input validation
-%!error mahalanobis ();
-%!error mahalanobis (1, 2, 3);
-%!error mahalanobis ('A', 'B');
-%!error mahalanobis ([1, 2], ['A', 'B']);
-%!error mahalanobis (ones (2,2,2));
-%!error mahalanobis (ones (2,2), ones (2,2,2));
-%!error mahalanobis (ones (2,2), ones (2,3));
+%!error mahalanobis ()
+%!error mahalanobis (1, 2, 3)
+%!error mahalanobis ('A', 'B')
+%!error mahalanobis ([1, 2], ['A', 'B'])
+%!error mahalanobis (ones (2,2,2))
+%!error mahalanobis (ones (2,2), ones (2,2,2))
+%!error mahalanobis (ones (2,2), ones (2,3))
+
diff --git a/scripts/statistics/base/mean.m b/scripts/statistics/base/mean.m
--- a/scripts/statistics/base/mean.m
+++ b/scripts/statistics/base/mean.m
@@ -122,30 +122,30 @@ function y = mean (x, opt1, opt2)
 
 endfunction
 
 
 %!test
 %! x = -10:10;
 %! y = x';
 %! z = [y, y+10];
-%! assert(mean (x) == 0);
-%! assert(mean (y) == 0);
-%! assert(mean (z) == [0, 10]);
+%! assert (mean (x), 0);
+%! assert (mean (y), 0);
+%! assert (mean (z), [0, 10]);
 
-%!assert(mean (magic(3), 1), [5, 5, 5]);
-%!assert(mean (magic(3), 2), [5; 5; 5]);
-%!assert(mean ([2 8], 'g'), 4);
-%!assert(mean ([4 4 2], 'h'), 3);
-%!assert(mean (logical ([1 0 1 1])), 0.75);
-%!assert(mean (single ([1 0 1 1])), single (0.75));
+%!assert (mean (magic (3), 1), [5, 5, 5])
+%!assert (mean (magic (3), 2), [5; 5; 5])
+%!assert (mean ([2 8], "g"), 4)
+%!assert (mean ([4 4 2], "h"), 3)
+%!assert (mean (logical ([1 0 1 1])), 0.75)
+%!assert (mean (single ([1 0 1 1])), single (0.75))
 
 %% Test input validation
-%!error mean ();
-%!error mean (1, 2, 3, 4);
-%!error mean ({1:5});
-%!error mean (1, 2, 3);
-%!error mean (1, ones(2,2));
-%!error mean (1, 1.5);
-%!error mean (1, 0);
-%!error mean (1, 3);
-%!error mean (1, 'b');
+%!error mean ()
+%!error mean (1, 2, 3, 4)
+%!error mean ({1:5})
+%!error mean (1, 2, 3)
+%!error mean (1, ones(2,2))
+%!error mean (1, 1.5)
+%!error mean (1, 0)
+%!error mean (1, 3)
+%!error mean (1, "b")
 
diff --git a/scripts/statistics/base/meansq.m b/scripts/statistics/base/meansq.m
--- a/scripts/statistics/base/meansq.m
+++ b/scripts/statistics/base/meansq.m
@@ -68,22 +68,22 @@ function y = meansq (x, dim)
     endif
   endif
 
   y = sumsq (x, dim) / sz(dim);
 
 endfunction
 
 
-%!assert(meansq (1:5), 11);
-%!assert(meansq (single(1:5)), single(11));
-%!assert(meansq (magic (4)), [94.5, 92.5, 92.5, 94.5]);
-%!assert(meansq (magic (4), 2), [109.5; 77.5; 77.5; 109.5]);
+%!assert (meansq (1:5), 11)
+%!assert (meansq (single (1:5)), single (11))
+%!assert (meansq (magic (4)), [94.5, 92.5, 92.5, 94.5])
+%!assert (meansq (magic (4), 2), [109.5; 77.5; 77.5; 109.5])
 
 %% Test input validation
 %!error meansq ()
 %!error meansq (1, 2, 3)
-%!error meansq (['A'; 'B']);
-%!error meansq (1, ones(2,2))
+%!error meansq (['A'; 'B'])
+%!error meansq (1, ones (2,2))
 %!error meansq (1, 1.5)
 %!error meansq (1, 0)
 %!error meansq (1, 3)
 
diff --git a/scripts/statistics/base/median.m b/scripts/statistics/base/median.m
--- a/scripts/statistics/base/median.m
+++ b/scripts/statistics/base/median.m
@@ -29,19 +29,19 @@
 ##   \cases{x(\lceil N/2\rceil), & $N$ odd;\cr
 ##           (x(N/2)+x(N/2+1))/2, & $N$ even.}
 ## $$
 ## @end tex
 ## @ifnottex
 ##
 ## @example
 ## @group
-##             x(ceil(N/2)),             N odd
-## median(x) =
-##             (x(N/2) + x((N/2)+1))/2,  N even
+##               x(ceil(N/2))             N odd
+## median (x) =
+##              (x(N/2) + x((N/2)+1))/2   N even
 ## @end group
 ## @end example
 ##
 ## @end ifnottex
 ## If @var{x} is a matrix, compute the median value for each
 ## column and return them in a row vector.  If the optional @var{dim}
 ## argument is given, operate along this dimension.
 ## @seealso{mean, mode}
@@ -89,25 +89,25 @@ endfunction
 
 
 %!test
 %! x = [1, 2, 3, 4, 5, 6];
 %! x2 = x';
 %! y = [1, 2, 3, 4, 5, 6, 7];
 %! y2 = y';
 %!
-%! assert(median (x) == median (x2) && median (x) == 3.5);
-%! assert(median (y) == median (y2) && median (y) == 4);
-%! assert(median ([x2, 2*x2]) == [3.5, 7]);
-%! assert(median ([y2, 3*y2]) == [4, 12]);
+%! assert (median (x) == median (x2) && median (x) == 3.5);
+%! assert (median (y) == median (y2) && median (y) == 4);
+%! assert (median ([x2, 2*x2]), [3.5, 7]);
+%! assert (median ([y2, 3*y2]), [4, 12]);
 
-%!assert(median (single([1,2,3])), single(2));
-%!assert(median ([1,2,NaN;4,5,6;NaN,8,9]), [NaN, 5, NaN]);
+%!assert (median (single ([1,2,3])), single (2))
+%!assert (median ([1,2,NaN;4,5,6;NaN,8,9]), [NaN, 5, NaN])
 
 %% Test input validation
-%!error median ();
-%!error median (1, 2, 3);
-%!error median ({1:5});
-%!error median (['A'; 'B']);
-%!error median (1, ones(2,2));
-%!error median (1, 1.5);
-%!error median (1, 0);
+%!error median ()
+%!error median (1, 2, 3)
+%!error median ({1:5})
+%!error median (['A'; 'B'])
+%!error median (1, ones(2,2))
+%!error median (1, 1.5)
+%!error median (1, 0)
 
diff --git a/scripts/statistics/base/mode.m b/scripts/statistics/base/mode.m
--- a/scripts/statistics/base/mode.m
+++ b/scripts/statistics/base/mode.m
@@ -111,25 +111,25 @@ endfunction
 %! [m, f, c] = mode (a);
 %! [m2, f2, c2] = mode (full (a));
 %! assert (m, sparse (m2));
 %! assert (f, sparse (f2));
 %! c_exp(1:length(a)) = { sparse (0) };
 %! assert (c ,c_exp);
 %! assert (c2,c_exp );
 
-%!assert(mode ([2,3,1,2,3,4],1),[2,3,1,2,3,4]);
-%!assert(mode ([2,3,1,2,3,4],2),2);
-%!assert(mode ([2,3,1,2,3,4]),2);
-%!assert(mode (single([2,3,1,2,3,4])), single(2));
-%!assert(mode (int8([2,3,1,2,3,4])), int8(2));
+%!assert (mode ([2,3,1,2,3,4],1),[2,3,1,2,3,4])
+%!assert (mode ([2,3,1,2,3,4],2),2)
+%!assert (mode ([2,3,1,2,3,4]),2)
+%!assert (mode (single ([2,3,1,2,3,4])), single (2))
+%!assert (mode (int8 ([2,3,1,2,3,4])), int8 (2))
 
-%!assert(mode ([2;3;1;2;3;4],1),2);
-%!assert(mode ([2;3;1;2;3;4],2),[2;3;1;2;3;4]);
-%!assert(mode ([2;3;1;2;3;4]),2);
+%!assert (mode ([2;3;1;2;3;4],1),2)
+%!assert (mode ([2;3;1;2;3;4],2),[2;3;1;2;3;4])
+%!assert (mode ([2;3;1;2;3;4]),2)
 
 %!shared x
 %! x(:,:,1) = toeplitz (1:3);
 %! x(:,:,2) = circshift (toeplitz (1:3), 1);
 %! x(:,:,3) = circshift (toeplitz (1:3), 2);
 %!test
 %! [m, f, c] = mode (x, 1);
 %! assert (reshape (m, [3, 3]), [1 1 1; 2 2 2; 1 1 1]);
@@ -155,13 +155,13 @@ endfunction
 %! assert (c{2}, [1; 2; 3]);
 %! assert (c{3}, [1; 2; 3]);
 
 %% Test input validation
 %!error mode ()
 %!error mode (1, 2, 3)
 %!error mode ({1 2 3})
 %!error mode (['A'; 'B'])
-%!error mode (1, ones(2,2))
+%!error mode (1, ones (2,2))
 %!error mode (1, 1.5)
 %!error mode (1, 0)
 %!error mode (1, 3)
 
diff --git a/scripts/statistics/base/moment.m b/scripts/statistics/base/moment.m
--- a/scripts/statistics/base/moment.m
+++ b/scripts/statistics/base/moment.m
@@ -38,16 +38,17 @@
 ##
 ## @end ifnottex
 ##
 ## If @var{x} is a matrix, return the row vector containing the
 ## @var{p}-th moment of each column.
 ##
 ## The optional string @var{type} specifies the type of moment to be computed.
 ## Valid options are:
+##
 ## @table @asis
 ## @item "c"
 ##   Central Moment.  The moment about the mean defined as
 ## @tex
 ## $$
 ## {\sum_{i=1}^N (x_i - \bar{x})^p \over N}
 ## $$
 ## @end tex
@@ -67,34 +68,34 @@
 ## $$
 ## {\sum_{i=1}^N {\left| x_i \right|}^p \over N}
 ## $$
 ## @end tex
 ## @ifnottex
 ##
 ## @example
 ## @group
-## 1/N SUM_i ( abs(x(i)) )^p
+## 1/N SUM_i ( abs (x(i)) )^p
 ## @end group
 ## @end example
 ##
 ## @end ifnottex
 ##
 ## @item "ac"
 ##   Absolute Central Moment.  Defined as
 ## @tex
 ## $$
 ## {\sum_{i=1}^N {\left| x_i - \bar{x} \right|}^p \over N}
 ## $$
 ## @end tex
 ## @ifnottex
 ##
 ## @example
 ## @group
-## 1/N SUM_i ( abs(x(i) - mean(x)) )^p
+## 1/N SUM_i ( abs (x(i) - mean(x)) )^p
 ## @end group
 ## @end example
 ##
 ## @end ifnottex
 ## @end table
 ##
 ## If the optional argument @var{dim} is given, operate along this dimension.
 ##
@@ -173,26 +174,26 @@ function m = moment (x, p, opt1, opt2)
 endfunction
 
 
 %!test
 %! x = rand (10);
 %! assert (moment (x,1), mean (x), 1e1*eps);
 %! assert (moment (x,2), meansq (x), 1e1*eps);
 %! assert (moment (x,1,2), mean (x,2), 1e1*eps);
-%! assert (moment (x,1,'c'), mean (center (x)), 1e1*eps);
-%! assert (moment (x,1,'a'), mean (abs (x)), 1e1*eps);
+%! assert (moment (x,1,"c"), mean (center (x)), 1e1*eps);
+%! assert (moment (x,1,"a"), mean (abs (x)), 1e1*eps);
 
-%!assert (moment (single([1 2 3]),1), single(2));
+%!assert (moment (single ([1 2 3]), 1), single (2))
 
 %% Test input validation
 %!error moment ()
 %!error moment (1)
 %!error moment (1, 2, 3, 4, 5)
 %!error moment (['A'; 'B'], 2)
-%!error moment (ones(2,0,3), 2)
+%!error moment (ones (2,0,3), 2)
 %!error moment (1, true)
-%!error moment (1, ones(2,2))
+%!error moment (1, ones (2,2))
 %!error moment (1, 2, 3, 4)
-%!error moment (1, 2, ones(2,2))
+%!error moment (1, 2, ones (2,2))
 %!error moment (1, 2, 1.5)
 %!error moment (1, 2, 4)
 
diff --git a/scripts/statistics/base/ols.m b/scripts/statistics/base/ols.m
--- a/scripts/statistics/base/ols.m
+++ b/scripts/statistics/base/ols.m
@@ -116,29 +116,59 @@ function [beta, sigma, r] = ols (y, x)
   else
     beta = u \ (u' \ (x' * y));
   endif
 
   if (isargout (2) || isargout (3))
     r = y - x * beta;
   endif
   if (isargout (2))
+
+    ## z is of full rank, avoid the SVD in rnk
+    if (p == 0)
+      rnk = columns (z);
+    else
+      rnk = rank (z);
+    endif
+
     sigma = r' * r / (nr - rnk);
   endif
 
 endfunction
 
 
 %!test
 %! x = [1:5]';
 %! y = 3*x + 2;
 %! x = [x, ones(5,1)];
-%! assert (ols(y,x), [3; 2], 50*eps)
+%! assert (ols (y,x), [3; 2], 50*eps)
+
+%!test
+%! x = [1, 2; 3, 4];
+%! y = [1; 2];
+%! [b, s, r] = ols (x, y);
+%! assert (b, [1.4, 2], 2*eps);
+%! assert (s, [0.2, 0; 0, 0], 2*eps);
+%! assert (r, [-0.4, 0; 0.2, 0], 2*eps);
+
+%!test
+%! x = [1, 2; 3, 4];
+%! y = [1; 2];
+%! [b, s] = ols (x, y);
+%! assert (b, [1.4, 2], 2*eps);
+%! assert (s, [0.2, 0; 0, 0], 2*eps);
+
+%!test
+%! x = [1, 2; 3, 4];
+%! y = [1; 2];
+%! b = ols (x, y);
+%! assert (b, [1.4, 2], 2*eps);
 
 %% Test input validation
-%!error ols ();
-%!error ols (1);
-%!error ols (1, 2, 3);
-%!error ols ([true, true], [1, 2]);
-%!error ols ([1, 2], [true, true]);
-%!error ols (ones (2,2,2), ones (2,2));
-%!error ols (ones (2,2), ones (2,2,2));
-%!error ols (ones(1,2), ones(2,2));
+%!error ols ()
+%!error ols (1)
+%!error ols (1, 2, 3)
+%!error ols ([true, true], [1, 2])
+%!error ols ([1, 2], [true, true])
+%!error ols (ones (2,2,2), ones (2,2))
+%!error ols (ones (2,2), ones (2,2,2))
+%!error ols (ones (1,2), ones (2,2))
+
diff --git a/scripts/statistics/base/ppplot.m b/scripts/statistics/base/ppplot.m
--- a/scripts/statistics/base/ppplot.m
+++ b/scripts/statistics/base/ppplot.m
@@ -74,11 +74,11 @@ function [p, y] = ppplot (x, dist, varar
     plot (p, y);
     axis ([0, 1, 0, 1]);
   endif
 
 endfunction
 
 
 %% Test input validation
-%!error ppplot ();
-%!error ppplot (ones(2,2));
+%!error ppplot ()
+%!error ppplot (ones (2,2))
 
diff --git a/scripts/statistics/base/prctile.m b/scripts/statistics/base/prctile.m
--- a/scripts/statistics/base/prctile.m
+++ b/scripts/statistics/base/prctile.m
@@ -168,8 +168,9 @@ endfunction
 %!error prctile ()
 %!error prctile (1, 2, 3, 4)
 %!error prctile (['A'; 'B'], 10)
 %!error prctile (1:10, [true, false])
 %!error prctile (1:10, ones (2,2))
 %!error prctile (1, 1, 1.5)
 %!error prctile (1, 1, 0)
 %!error prctile (1, 1, 3)
+
diff --git a/scripts/statistics/base/probit.m b/scripts/statistics/base/probit.m
--- a/scripts/statistics/base/probit.m
+++ b/scripts/statistics/base/probit.m
@@ -31,14 +31,15 @@ function y = probit (p)
   if (nargin != 1)
     print_usage ();
   endif
 
   y = stdnormal_inv (p);
 
 endfunction
 
-%!assert(probit([-1, 0, 0.5, 1, 2]), [NaN, -Inf, 0, Inf, NaN]);
+
+%!assert (probit ([-1, 0, 0.5, 1, 2]), [NaN, -Inf, 0, Inf, NaN])
 
 %% Test input validation
 %!error probit ()
 %!error probit (1, 2)
 
diff --git a/scripts/statistics/base/quantile.m b/scripts/statistics/base/quantile.m
--- a/scripts/statistics/base/quantile.m
+++ b/scripts/statistics/base/quantile.m
@@ -46,20 +46,20 @@
 ##
 ## @item Method 3: SAS definition: nearest even order statistic.
 ## @end enumerate
 ##
 ## Continuous sample quantile methods 4 through 9, where p(k) is the linear
 ## interpolation function respecting each methods' representative cdf.
 ##
 ## @enumerate 4
-## @item Method 4: p(k) = k / n. That is, linear interpolation of the
+## @item Method 4: p(k) = k / n.  That is, linear interpolation of the
 ## empirical cdf.
 ##
-## @item Method 5: p(k) = (k - 0.5) / n. That is a piecewise linear function
+## @item Method 5: p(k) = (k - 0.5) / n.  That is a piecewise linear function
 ## where the knots are the values midway through the steps of the empirical
 ## cdf.
 ##
 ## @item Method 6: p(k) = k / (n + 1).
 ##
 ## @item Method 7: p(k) = (k - 1) / (n - 1).
 ##
 ## @item Method 8: p(k) = (k - 1/3) / (n + 1/3).  The resulting quantile
@@ -152,138 +152,138 @@ function q = quantile (x, p = [], dim = 
 
 endfunction
 
 
 %!test
 %! p = 0.5;
 %! x = sort (rand (11));
 %! q = quantile (x, p);
-%! assert (q, x(6,:))
+%! assert (q, x(6,:));
 %! x = x.';
 %! q = quantile (x, p, 2);
 %! assert (q, x(:,6));
 
 %!test
 %! p = [0.00, 0.25, 0.50, 0.75, 1.00];
 %! x = [1; 2; 3; 4];
 %! a = [1.0000   1.0000   2.0000   3.0000   4.0000
 %!      1.0000   1.5000   2.5000   3.5000   4.0000
 %!      1.0000   1.0000   2.0000   3.0000   4.0000
 %!      1.0000   1.0000   2.0000   3.0000   4.0000
 %!      1.0000   1.5000   2.5000   3.5000   4.0000
 %!      1.0000   1.2500   2.5000   3.7500   4.0000
 %!      1.0000   1.7500   2.5000   3.2500   4.0000
 %!      1.0000   1.4167   2.5000   3.5833   4.0000
 %!      1.0000   1.4375   2.5000   3.5625   4.0000];
-%! for m = (1:9)
+%! for m = 1:9
 %!   q = quantile (x, p, 1, m).';
-%!   assert (q, a(m,:), 0.0001)
+%!   assert (q, a(m,:), 0.0001);
 %! endfor
 
 %!test
 %! p = [0.00, 0.25, 0.50, 0.75, 1.00];
 %! x = [1; 2; 3; 4; 5];
 %! a = [1.0000   2.0000   3.0000   4.0000   5.0000
 %!      1.0000   2.0000   3.0000   4.0000   5.0000
 %!      1.0000   1.0000   2.0000   4.0000   5.0000
 %!      1.0000   1.2500   2.5000   3.7500   5.0000
 %!      1.0000   1.7500   3.0000   4.2500   5.0000
 %!      1.0000   1.5000   3.0000   4.5000   5.0000
 %!      1.0000   2.0000   3.0000   4.0000   5.0000
 %!      1.0000   1.6667   3.0000   4.3333   5.0000
 %!      1.0000   1.6875   3.0000   4.3125   5.0000];
-%! for m = (1:9)
+%! for m = 1:9
 %!   q = quantile (x, p, 1, m).';
-%!   assert (q, a(m,:), 0.0001)
+%!   assert (q, a(m,:), 0.0001);
 %! endfor
 
 %!test
 %! p = [0.00, 0.25, 0.50, 0.75, 1.00];
 %! x = [1; 2; 5; 9];
 %! a = [1.0000   1.0000   2.0000   5.0000   9.0000
 %!      1.0000   1.5000   3.5000   7.0000   9.0000
 %!      1.0000   1.0000   2.0000   5.0000   9.0000
 %!      1.0000   1.0000   2.0000   5.0000   9.0000
 %!      1.0000   1.5000   3.5000   7.0000   9.0000
 %!      1.0000   1.2500   3.5000   8.0000   9.0000
 %!      1.0000   1.7500   3.5000   6.0000   9.0000
 %!      1.0000   1.4167   3.5000   7.3333   9.0000
 %!      1.0000   1.4375   3.5000   7.2500   9.0000];
-%! for m = (1:9)
+%! for m = 1:9
 %!   q = quantile (x, p, 1, m).';
-%!   assert (q, a(m,:), 0.0001)
+%!   assert (q, a(m,:), 0.0001);
 %! endfor
 
 %!test
 %! p = [0.00, 0.25, 0.50, 0.75, 1.00];
 %! x = [1; 2; 5; 9; 11];
 %! a = [1.0000    2.0000    5.0000    9.0000   11.0000
 %!      1.0000    2.0000    5.0000    9.0000   11.0000
 %!      1.0000    1.0000    2.0000    9.0000   11.0000
 %!      1.0000    1.2500    3.5000    8.0000   11.0000
 %!      1.0000    1.7500    5.0000    9.5000   11.0000
 %!      1.0000    1.5000    5.0000   10.0000   11.0000
 %!      1.0000    2.0000    5.0000    9.0000   11.0000
 %!      1.0000    1.6667    5.0000    9.6667   11.0000
 %!      1.0000    1.6875    5.0000    9.6250   11.0000];
-%! for m = (1:9)
+%! for m = 1:9
 %!   q = quantile (x, p, 1, m).';
-%!   assert (q, a(m,:), 0.0001)
+%!   assert (q, a(m,:), 0.0001);
 %! endfor
 
 %!test
 %! p = [0.00, 0.25, 0.50, 0.75, 1.00];
 %! x = [16; 11; 15; 12; 15;  8; 11; 12;  6; 10];
 %! a = [6.0000   10.0000   11.0000   15.0000   16.0000
 %!      6.0000   10.0000   11.5000   15.0000   16.0000
 %!      6.0000    8.0000   11.0000   15.0000   16.0000
 %!      6.0000    9.0000   11.0000   13.5000   16.0000
 %!      6.0000   10.0000   11.5000   15.0000   16.0000
 %!      6.0000    9.5000   11.5000   15.0000   16.0000
 %!      6.0000   10.2500   11.5000   14.2500   16.0000
 %!      6.0000    9.8333   11.5000   15.0000   16.0000
 %!      6.0000    9.8750   11.5000   15.0000   16.0000];
-%! for m = (1:9)
+%! for m = 1:9
 %!   q = quantile (x, p, 1, m).';
-%!   assert (q, a(m,:), 0.0001)
+%!   assert (q, a(m,:), 0.0001);
 %! endfor
 
 %!test
 %! p = [0.00, 0.25, 0.50, 0.75, 1.00];
 %! x = [-0.58851;  0.40048;  0.49527; -2.551500; -0.52057; ...
 %!      -0.17841; 0.057322; -0.62523;  0.042906;  0.12337];
 %! a = [-2.551474  -0.588505  -0.178409   0.123366   0.495271
 %!      -2.551474  -0.588505  -0.067751   0.123366   0.495271
 %!      -2.551474  -0.625231  -0.178409   0.123366   0.495271
 %!      -2.551474  -0.606868  -0.178409   0.090344   0.495271
 %!      -2.551474  -0.588505  -0.067751   0.123366   0.495271
 %!      -2.551474  -0.597687  -0.067751   0.192645   0.495271
 %!      -2.551474  -0.571522  -0.067751   0.106855   0.495271
 %!      -2.551474  -0.591566  -0.067751   0.146459   0.495271
 %!      -2.551474  -0.590801  -0.067751   0.140686   0.495271];
-%! for m = (1:9)
+%! for m = 1:9
 %!   q = quantile (x, p, 1, m).';
-%!   assert (q, a(m,:), 0.0001)
+%!   assert (q, a(m,:), 0.0001);
 %! endfor
 
 %!test
 %! p = 0.5;
 %! x = [0.112600, 0.114800, 0.052100, 0.236400, 0.139300
 %!      0.171800, 0.727300, 0.204100, 0.453100, 0.158500
 %!      0.279500, 0.797800, 0.329600, 0.556700, 0.730700
 %!      0.428800, 0.875300, 0.647700, 0.628700, 0.816500
 %!      0.933100, 0.931200, 0.963500, 0.779600, 0.846100];
 %! tol = 0.00001;
 %! x(5,5) = NaN;
-%! assert (quantile(x, p, 1), [0.27950, 0.79780, 0.32960, 0.55670, 0.44460], tol);
+%! assert (quantile (x, p, 1), [0.27950, 0.79780, 0.32960, 0.55670, 0.44460], tol);
 %! x(1,1) = NaN;
-%! assert (quantile(x, p, 1), [0.35415, 0.79780, 0.32960, 0.55670, 0.44460], tol);
+%! assert (quantile (x, p, 1), [0.35415, 0.79780, 0.32960, 0.55670, 0.44460], tol);
 %! x(3,3) = NaN;
-%! assert (quantile(x, p, 1), [0.35415, 0.79780, 0.42590, 0.55670, 0.44460], tol);
+%! assert (quantile (x, p, 1), [0.35415, 0.79780, 0.42590, 0.55670, 0.44460], tol);
 
 %!test
 %! sx = [2, 3, 4];
 %! x = rand (sx);
 %! dim = 2;
 %! p = 0.5;
 %! yobs = quantile (x, p, dim);
 %! yexp = median (x, dim);
diff --git a/scripts/statistics/base/range.m b/scripts/statistics/base/range.m
--- a/scripts/statistics/base/range.m
+++ b/scripts/statistics/base/range.m
@@ -45,17 +45,18 @@ function y = range (x, dim)
     y = max (x) - min (x);
   else
     y = max (x, [], dim) - min (x, [], dim);
   endif
 
 endfunction
 
 
-%!assert(range (1:10), 9);
-%!assert(range (single(1:10)), single(9));
-%!assert(range (magic (3)), [5, 8, 5]);
-%!assert(range (magic (3), 2), [7; 4; 7]);
-%!assert(range (2), 0);
+%!assert (range (1:10), 9)
+%!assert (range (single (1:10)), single (9))
+%!assert (range (magic (3)), [5, 8, 5])
+%!assert (range (magic (3), 2), [7; 4; 7])
+%!assert (range (2), 0)
 
 %% Test input validation
 %!error range ()
 %!error range (1, 2, 3)
+
diff --git a/scripts/statistics/base/ranks.m b/scripts/statistics/base/ranks.m
--- a/scripts/statistics/base/ranks.m
+++ b/scripts/statistics/base/ranks.m
@@ -81,22 +81,22 @@ function y = ranks (x, dim)
     if (dim != 1)
       y = permute (y, perm);
     endif
   endif
 
 endfunction
 
 
-%!assert(ranks (1:2:10), 1:5);
-%!assert(ranks (10:-2:1), 5:-1:1);
-%!assert(ranks ([2, 1, 2, 4]), [2.5, 1, 2.5, 4]);
-%!assert(ranks (ones(1, 5)), 3*ones(1, 5));
-%!assert(ranks (1e6*ones(1, 5)), 3*ones(1, 5));
-%!assert(ranks (rand (1, 5), 1), ones(1, 5));
+%!assert (ranks (1:2:10), 1:5)
+%!assert (ranks (10:-2:1), 5:-1:1)
+%!assert (ranks ([2, 1, 2, 4]), [2.5, 1, 2.5, 4])
+%!assert (ranks (ones (1, 5)), 3*ones (1, 5))
+%!assert (ranks (1e6*ones (1, 5)), 3*ones (1, 5))
+%!assert (ranks (rand (1, 5), 1), ones (1, 5))
 
 %% Test input validation
 %!error ranks ()
 %!error ranks (1, 2, 3)
 %!error ranks ({1, 2})
 %!error ranks (['A'; 'B'])
 %!error ranks (1, 1.5)
 %!error ranks (1, 0)
diff --git a/scripts/statistics/base/run_count.m b/scripts/statistics/base/run_count.m
--- a/scripts/statistics/base/run_count.m
+++ b/scripts/statistics/base/run_count.m
@@ -88,26 +88,26 @@ function retval = run_count (x, n, dim)
 
   if (dim != 1)
     retval = ipermute (retval, perm);
   endif
 
 endfunction
 
 
-%!assert(run_count (magic(3), 4), [1,0,1;1,0,1;0,1,0;0,0,0])
-%!assert(run_count (magic(3), 4, 2), [1,0,1;1,0,1;0,1,0;0,0,0]')
-%!assert(run_count (5:-1:1, 5), [5, 0, 0, 0, 0])
-%!assert(run_count (ones(3), 4), [0,0,0;0,0,0;1,1,1;0,0,0])
+%!assert (run_count (magic (3), 4), [1,0,1;1,0,1;0,1,0;0,0,0])
+%!assert (run_count (magic (3), 4, 2), [1,0,1;1,0,1;0,1,0;0,0,0]')
+%!assert (run_count (5:-1:1, 5), [5, 0, 0, 0, 0])
+%!assert (run_count (ones (3), 4), [0,0,0;0,0,0;1,1,1;0,0,0])
 
 %% Test input validation
 %!error run_count ()
 %!error run_count (1)
 %!error run_count (1, 2, 3, 4)
 %!error run_count ({1, 2}, 3)
 %!error run_count (['A'; 'A'; 'B'], 3)
-%!error run_count (1:5, ones(2,2))
+%!error run_count (1:5, ones (2,2))
 %!error run_count (1:5, 1.5)
 %!error run_count (1:5, -2)
-%!error run_count (1:5, 3, ones(2,2))
+%!error run_count (1:5, 3, ones (2,2))
 %!error run_count (1:5, 3, 1.5)
 %!error run_count (1:5, 3, 0)
 
diff --git a/scripts/statistics/base/runlength.m b/scripts/statistics/base/runlength.m
--- a/scripts/statistics/base/runlength.m
+++ b/scripts/statistics/base/runlength.m
@@ -47,20 +47,21 @@ function [count, value] = runlength (x)
   count = diff ([0 idx]);
   if (nargout == 2)
     value = x(idx);
   endif
 
 endfunction
 
 
-%!assert (runlength([2 2 0 4 4 4 0 1 1 1 1]), [2 1 3 1 4]);
-%!assert (runlength([2 2 0 4 4 4 0 1 1 1 1]'), [2 1 3 1 4]);
+%!assert (runlength ([2 2 0 4 4 4 0 1 1 1 1]), [2 1 3 1 4])
+%!assert (runlength ([2 2 0 4 4 4 0 1 1 1 1]'), [2 1 3 1 4])
 %!test
 %! [c, v] = runlength ([2 2 0 4 4 4 0 1 1 1 1]);
 %! assert (c, [2 1 3 1 4]);
 %! assert (v, [2 0 4 0 1]);
 
 %% Test input validation
 %!error runlength ()
 %!error runlength (1, 2)
 %!error runlength (['A'; 'B'])
-%!error runlength (ones(2,2))
+%!error runlength (ones (2,2))
+
diff --git a/scripts/statistics/base/skewness.m b/scripts/statistics/base/skewness.m
--- a/scripts/statistics/base/skewness.m
+++ b/scripts/statistics/base/skewness.m
@@ -24,17 +24,17 @@
 ## $$
 ## {\rm skewness} (x) = {1\over N \sigma^3} \sum_{i=1}^N (x_i-\bar{x})^3
 ## $$
 ## where $\bar{x}$ is the mean value of $x$.
 ## @end tex
 ## @ifnottex
 ##
 ## @example
-## skewness (x) = N^(-1) std(x)^(-3) sum ((x - mean(x)).^3)
+## skewness (x) = 1/N std(x)^(-3) sum ((x - mean(x)).^3)
 ## @end example
 ##
 ## @end ifnottex
 ##
 ## @noindent
 ## If @var{x} is a matrix, return the skewness along the
 ## first non-singleton dimension of the matrix.  If the optional
 ## @var{dim} argument is given, operate along this dimension.
@@ -74,27 +74,28 @@ function retval = skewness (x, dim)
   s = std (x, [], dim);
   idx = find (s > 0);
   x = sum (x .^ 3, dim);
   retval(idx) = x(idx) ./ (n * s(idx) .^ 3);
 
 endfunction
 
 
-%!assert(skewness ([-1,0,1]), 0);
-%!assert(skewness ([-2,0,1]) < 0);
-%!assert(skewness ([-1,0,2]) > 0);
-%!assert(skewness ([-3,0,1]) == -1*skewness([-1,0,3]));
+%!assert (skewness ([-1,0,1]), 0)
+%!assert (skewness ([-2,0,1]) < 0)
+%!assert (skewness ([-1,0,2]) > 0)
+%!assert (skewness ([-3,0,1]) == -1*skewness ([-1,0,3]))
 %!test
 %! x = [0; 0; 0; 1];
 %! y = [x, 2*x];
 %! assert(all (abs (skewness (y) - [0.75, 0.75]) < sqrt (eps)));
 
-%!assert (skewness (single(1)), single(0));
+%!assert (skewness (single (1)), single (0))
 
 %% Test input validation
 %!error skewness ()
 %!error skewness (1, 2, 3)
 %!error skewness (['A'; 'B'])
-%!error skewness (1, ones(2,2))
+%!error skewness (1, ones (2,2))
 %!error skewness (1, 1.5)
 %!error skewness (1, 0)
 %!error skewness (1, 3)
+
diff --git a/scripts/statistics/base/spearman.m b/scripts/statistics/base/spearman.m
--- a/scripts/statistics/base/spearman.m
+++ b/scripts/statistics/base/spearman.m
@@ -64,31 +64,32 @@ function rho = spearman (x, y = [])
     endif
     if (rows (x) != rows (y))
       error ("spearman: X and Y must have the same number of observations");
     endif
     rho = corr (ranks (x), ranks (y));
   endif
 
   ## Restore class cleared by ranks
-  if (isa (x, 'single') || isa (y, 'single'))
+  if (isa (x, "single") || isa (y, "single"))
     rho = single (rho);
   endif
 
 endfunction
 
 
 %!test
 %! x = 1:10;
 %! y = exp (x);
 %! assert (spearman (x,y), 1, 5*eps);
 %! assert (spearman (x,-y), -1, 5*eps);
 
-%!assert(spearman ([1 2 3], [-1 1 -2]), -0.5, 5*eps)
+%!assert (spearman ([1 2 3], [-1 1 -2]), -0.5, 5*eps)
 
 %% Test input validation
-%!error spearman ();
-%!error spearman (1, 2, 3);
-%!error spearman (['A'; 'B']);
-%!error spearman (ones(1,2), {1, 2});
-%!error spearman (ones (2,2,2));
-%!error spearman (ones (2,2), ones (2,2,2));
-%!error spearman (ones (2,2), ones (3,2));
+%!error spearman ()
+%!error spearman (1, 2, 3)
+%!error spearman (['A'; 'B'])
+%!error spearman (ones (1,2), {1, 2})
+%!error spearman (ones (2,2,2))
+%!error spearman (ones (2,2), ones (2,2,2))
+%!error spearman (ones (2,2), ones (3,2))
+
diff --git a/scripts/statistics/base/statistics.m b/scripts/statistics/base/statistics.m
--- a/scripts/statistics/base/statistics.m
+++ b/scripts/statistics/base/statistics.m
@@ -76,14 +76,14 @@ endfunction
 %! assert (std (x), s(7,:), eps);
 %! assert (skewness (x), s(8,:), eps);
 %! assert (kurtosis (x), s(9,:), eps);
 
 %% Test input validation
 %!error statistics ()
 %!error statistics (1, 2, 3)
 %!error statistics (['A'; 'B'])
-%!error statistics (1, ones(2,2))
+%!error statistics (1, ones (2,2))
 %!error statistics (1, 1.5)
 %!error statistics (1, 0)
 %!error statistics (1, 3)
 %!error statistics (1)
 
diff --git a/scripts/statistics/base/std.m b/scripts/statistics/base/std.m
--- a/scripts/statistics/base/std.m
+++ b/scripts/statistics/base/std.m
@@ -87,41 +87,41 @@ function retval = std (x, opt = 0, dim)
     if (!(isscalar (dim) && dim == fix (dim))
         || !(1 <= dim && dim <= nd))
       error ("std: DIM must be an integer and a valid dimension");
     endif
   endif
 
   n = sz(dim);
   if (n == 1 || isempty (x))
-    if (isa (x, 'single'))
-      retval = zeros (sz, 'single');
+    if (isa (x, "single"))
+      retval = zeros (sz, "single");
     else
       retval = zeros (sz);
     endif
   else
     retval = sqrt (sumsq (center (x, dim), dim) / (n - 1 + opt));
   endif
 
 endfunction
 
 
 %!test
 %! x = ones (10, 2);
 %! y = [1, 3];
-%! assert(std (x) == [0, 0]);
-%! assert(std (y), sqrt (2), sqrt (eps));
-%! assert(std (x, 0, 2), zeros (10, 1));
+%! assert (std (x), [0, 0]);
+%! assert (std (y), sqrt (2), sqrt (eps));
+%! assert (std (x, 0, 2), zeros (10, 1));
 
-%!assert(std (ones (3, 1, 2), 0, 2), zeros (3, 1, 2));
-%!assert(std ([1 2], 0), sqrt(2)/2, 5*eps);
-%!assert(std ([1 2], 1), 0.5, 5*eps);
-%!assert(std(1), 0);
-%!assert(std(single(1)), single(0));
-%!assert(std([]), []);
-%!assert(std(ones (1,3,0,2)), ones (1,3,0,2));
+%!assert (std (ones (3, 1, 2), 0, 2), zeros (3, 1, 2));
+%!assert (std ([1 2], 0), sqrt (2)/2, 5*eps);
+%!assert (std ([1 2], 1), 0.5, 5*eps);
+%!assert (std (1), 0);
+%!assert (std (single (1)), single (0));
+%!assert (std ([]), []);
+%!assert (std (ones (1,3,0,2)), ones (1,3,0,2));
 
 %% Test input validation
-%!error std ();
-%!error std (1, 2, 3, 4);
+%!error std ()
+%!error std (1, 2, 3, 4)
 %!error std (['A'; 'B'])
-%!error std (1, -1);
+%!error std (1, -1)
 
diff --git a/scripts/statistics/base/table.m b/scripts/statistics/base/table.m
--- a/scripts/statistics/base/table.m
+++ b/scripts/statistics/base/table.m
@@ -66,8 +66,9 @@ endfunction
 %!error table (1, 2, 3)
 %!error table (ones (2))
 %!error table ([true true])
 %!error table (ones (2,1), true (2,1))
 %!error table (true (2,1), ones (2,1))
 %!error table (ones (2,2), ones (2,1))
 %!error table (ones (2,1), ones (2,2))
 %!error table (ones (2,1), ones (3,1))
+
diff --git a/scripts/statistics/base/var.m b/scripts/statistics/base/var.m
--- a/scripts/statistics/base/var.m
+++ b/scripts/statistics/base/var.m
@@ -46,16 +46,19 @@
 ## @item 0:
 ##   normalize with @math{N-1}, provides the best unbiased estimator of the
 ## variance [default]
 ##
 ## @item 1:
 ##   normalizes with @math{N}, this provides the second moment around the mean
 ## @end table
 ##
+## If @math{N==1} the value of @var{opt} is ignored and normalization 
+## by @math{N} is used.
+##
 ## If the optional argument @var{dim} is given, operate along this dimension.
 ## @seealso{cov, std, skewness, kurtosis, moment}
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Compute variance
 
 function retval = var (x, opt = 0, dim)
@@ -84,35 +87,35 @@ function retval = var (x, opt = 0, dim)
     if (!(isscalar (dim) && dim == fix (dim))
         || !(1 <= dim && dim <= nd))
       error ("var: DIM must be an integer and a valid dimension");
     endif
   endif
 
   n = sz(dim);
   if (n == 1)
-    if (isa (x, 'single'))
-      retval = zeros (sz, 'single');
+    if (isa (x, "single"))
+      retval = zeros (sz, "single");
     else
       retval = zeros (sz);
     endif
   elseif (numel (x) > 0)
     retval = sumsq (center (x, dim), dim) / (n - 1 + opt);
   else
     error ("var: X must not be empty");
   endif
 
 endfunction
 
 
-%!assert(var (13), 0);
-%!assert(var (single(13)), single(0));
-%!assert(var ([1,2,3]), 1);
-%!assert(var ([1,2,3], 1), 2/3, eps);
-%!assert(var ([1,2,3], [], 1), [0,0,0]);
+%!assert (var (13), 0)
+%!assert (var (single (13)), single (0))
+%!assert (var ([1,2,3]), 1)
+%!assert (var ([1,2,3], 1), 2/3, eps)
+%!assert (var ([1,2,3], [], 1), [0,0,0])
 
 %% Test input validation
 %!error var ()
 %!error var (1,2,3,4)
 %!error var (['A'; 'B'])
-%!error var (1, -1);
-%!error var ([],1)
+%!error var (1, -1)
+%!error var ([], 1)
 
diff --git a/scripts/statistics/base/zscore.m b/scripts/statistics/base/zscore.m
--- a/scripts/statistics/base/zscore.m
+++ b/scripts/statistics/base/zscore.m
@@ -16,23 +16,23 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {[@var{z}, @var{mu}, @var{sigma}] =} zscore (@var{x})
 ## @deftypefnx {Function File} {[@var{z}, @var{mu}, @var{sigma}] =} zscore (@var{x}, @var{opt})
 ## @deftypefnx {Function File} {[@var{z}, @var{mu}, @var{sigma}] =} zscore (@var{x}, @var{opt}, @var{dim})
 ## If @var{x} is a vector, subtract its mean and divide by its standard
-## deviation. If the standard deviation is zero, divide by 1 instead.
+## deviation.  If the standard deviation is zero, divide by 1 instead.
 ## The optional parameter @var{opt} determines the normalization to use
 ## when computing the standard deviation and is the same as the
 ## corresponding parameter for @code{std}.
 ##
 ## If @var{x} is a matrix, do the above along the first non-singleton
-## dimension. If the third optional argument @var{dim} is given, operate
+## dimension.  If the third optional argument @var{dim} is given, operate
 ## along this dimension.
 ##
 ## The mean and standard deviation along @var{dim} are given in @var{mu}
 ## and @var{sigma} respectively.
 ##
 ## @seealso{mean, std, center}
 ## @end deftypefn
 
@@ -84,23 +84,23 @@ function [z, mu, sigma] = zscore (x, opt
     s(s==0) = 1;
     ## FIXME: Use normal broadcasting once we can disable that warning
     z = bsxfun (@rdivide, bsxfun (@minus, x, mu), s);
   endif
 
 endfunction
 
 
-%!assert(zscore ([1,2,3]), [-1,0,1])
-%!assert(zscore (single([1,2,3])), single([-1,0,1]))
-%!assert(zscore (int8([1,2,3])), [-1,0,1])
-%!assert(zscore (ones (3,2,2,2)), zeros (3,2,2,2))
-%!assert(zscore ([2,0,-2;0,2,0;-2,-2,2]), [1,0,-1;0,1,0;-1,-1,1])
+%!assert (zscore ([1,2,3]), [-1,0,1])
+%!assert (zscore (single ([1,2,3])), single ([-1,0,1]))
+%!assert (zscore (int8 ([1,2,3])), [-1,0,1])
+%!assert (zscore (ones (3,2,2,2)), zeros (3,2,2,2))
+%!assert (zscore ([2,0,-2;0,2,0;-2,-2,2]), [1,0,-1;0,1,0;-1,-1,1])
 
 %% Test input validation
 %!error zscore ()
 %!error zscore (1, 2, 3)
 %!error zscore (['A'; 'B'])
-%!error zscore (1, ones(2,2))
+%!error zscore (1, ones (2,2))
 %!error zscore (1, 1.5)
 %!error zscore (1, 1, 0)
 %!error zscore (1, 3)
 
diff --git a/scripts/statistics/distributions/betacdf.m b/scripts/statistics/distributions/betacdf.m
--- a/scripts/statistics/distributions/betacdf.m
+++ b/scripts/statistics/distributions/betacdf.m
@@ -64,30 +64,30 @@ function cdf = betacdf (x, a, b)
   endif
 
 endfunction
 
 
 %!shared x,y
 %! x = [-1 0 0.5 1 2];
 %! y = [0 0 0.75 1 1];
-%!assert(betacdf (x, ones(1,5), 2*ones(1,5)), y);
-%!assert(betacdf (x, 1, 2*ones(1,5)), y);
-%!assert(betacdf (x, ones(1,5), 2), y);
-%!assert(betacdf (x, [0 1 NaN 1 1], 2), [NaN 0 NaN 1 1]);
-%!assert(betacdf (x, 1, 2*[0 1 NaN 1 1]), [NaN 0 NaN 1 1]);
-%!assert(betacdf ([x(1:2) NaN x(4:5)], 1, 2), [y(1:2) NaN y(4:5)]);
+%!assert (betacdf (x, ones (1,5), 2*ones (1,5)), y)
+%!assert (betacdf (x, 1, 2*ones (1,5)), y)
+%!assert (betacdf (x, ones (1,5), 2), y)
+%!assert (betacdf (x, [0 1 NaN 1 1], 2), [NaN 0 NaN 1 1])
+%!assert (betacdf (x, 1, 2*[0 1 NaN 1 1]), [NaN 0 NaN 1 1])
+%!assert (betacdf ([x(1:2) NaN x(4:5)], 1, 2), [y(1:2) NaN y(4:5)])
 
 %% Test class of input preserved
-%!assert(betacdf ([x, NaN], 1, 2), [y, NaN]);
-%!assert(betacdf (single([x, NaN]), 1, 2), single([y, NaN]));
-%!assert(betacdf ([x, NaN], single(1), 2), single([y, NaN]));
-%!assert(betacdf ([x, NaN], 1, single(2)), single([y, NaN]));
+%!assert (betacdf ([x, NaN], 1, 2), [y, NaN])
+%!assert (betacdf (single ([x, NaN]), 1, 2), single ([y, NaN]))
+%!assert (betacdf ([x, NaN], single (1), 2), single ([y, NaN]))
+%!assert (betacdf ([x, NaN], 1, single (2)), single ([y, NaN]))
 
 %% Test input validation
 %!error betacdf ()
 %!error betacdf (1)
 %!error betacdf (1,2)
 %!error betacdf (1,2,3,4)
-%!error betacdf (ones(3),ones(2),ones(2))
-%!error betacdf (ones(2),ones(3),ones(2))
-%!error betacdf (ones(2),ones(2),ones(3))
+%!error betacdf (ones (3), ones (2), ones (2))
+%!error betacdf (ones (2), ones (3), ones (2))
+%!error betacdf (ones (2), ones (2), ones (3))
 
diff --git a/scripts/statistics/distributions/betainv.m b/scripts/statistics/distributions/betainv.m
--- a/scripts/statistics/distributions/betainv.m
+++ b/scripts/statistics/distributions/betainv.m
@@ -104,33 +104,33 @@ function inv = betainv (x, a, b)
     inv(k) = y_new;
   endif
 
 endfunction
 
 
 %!shared x
 %! x = [-1 0 0.75 1 2];
-%!assert(betainv (x, ones(1,5), 2*ones(1,5)), [NaN 0 0.5 1 NaN]);
-%!assert(betainv (x, 1, 2*ones(1,5)), [NaN 0 0.5 1 NaN]);
-%!assert(betainv (x, ones(1,5), 2), [NaN 0 0.5 1 NaN]);
-%!assert(betainv (x, [1 0 NaN 1 1], 2), [NaN NaN NaN 1 NaN]);
-%!assert(betainv (x, 1, 2*[1 0 NaN 1 1]), [NaN NaN NaN 1 NaN]);
-%!assert(betainv ([x(1:2) NaN x(4:5)], 1, 2), [NaN 0 NaN 1 NaN]);
+%!assert (betainv (x, ones (1,5), 2*ones (1,5)), [NaN 0 0.5 1 NaN])
+%!assert (betainv (x, 1, 2*ones (1,5)), [NaN 0 0.5 1 NaN])
+%!assert (betainv (x, ones (1,5), 2), [NaN 0 0.5 1 NaN])
+%!assert (betainv (x, [1 0 NaN 1 1], 2), [NaN NaN NaN 1 NaN])
+%!assert (betainv (x, 1, 2*[1 0 NaN 1 1]), [NaN NaN NaN 1 NaN])
+%!assert (betainv ([x(1:2) NaN x(4:5)], 1, 2), [NaN 0 NaN 1 NaN])
 
 %% Test class of input preserved
-%!assert(betainv ([x, NaN], 1, 2), [NaN 0 0.5 1 NaN NaN]);
-%!assert(betainv (single([x, NaN]), 1, 2), single([NaN 0 0.5 1 NaN NaN]));
-%!assert(betainv ([x, NaN], single(1), 2), single([NaN 0 0.5 1 NaN NaN]));
-%!assert(betainv ([x, NaN], 1, single(2)), single([NaN 0 0.5 1 NaN NaN]));
+%!assert (betainv ([x, NaN], 1, 2), [NaN 0 0.5 1 NaN NaN])
+%!assert (betainv (single ([x, NaN]), 1, 2), single ([NaN 0 0.5 1 NaN NaN]))
+%!assert (betainv ([x, NaN], single (1), 2), single ([NaN 0 0.5 1 NaN NaN]))
+%!assert (betainv ([x, NaN], 1, single (2)), single ([NaN 0 0.5 1 NaN NaN]))
 
 %% Test input validation
 %!error betainv ()
 %!error betainv (1)
 %!error betainv (1,2)
 %!error betainv (1,2,3,4)
-%!error betainv (ones(3),ones(2),ones(2))
-%!error betainv (ones(2),ones(3),ones(2))
-%!error betainv (ones(2),ones(2),ones(3))
+%!error betainv (ones (3), ones (2), ones (2))
+%!error betainv (ones (2), ones (3), ones (2))
+%!error betainv (ones (2), ones (2), ones (3))
 %!error betainv (i, 2, 2)
 %!error betainv (2, i, 2)
 %!error betainv (2, 2, i)
 
diff --git a/scripts/statistics/distributions/betapdf.m b/scripts/statistics/distributions/betapdf.m
--- a/scripts/statistics/distributions/betapdf.m
+++ b/scripts/statistics/distributions/betapdf.m
@@ -90,41 +90,41 @@ function pdf = betapdf (x, a, b)
   pdf(k) = Inf;
 
 endfunction
 
 
 %!shared x,y
 %! x = [-1 0 0.5 1 2];
 %! y = [0 2 1 0 0];
-%!assert(betapdf (x, ones(1,5), 2*ones(1,5)), y);
-%!assert(betapdf (x, 1, 2*ones(1,5)), y);
-%!assert(betapdf (x, ones(1,5), 2), y);
-%!assert(betapdf (x, [0 NaN 1 1 1], 2), [NaN NaN y(3:5)]);
-%!assert(betapdf (x, 1, 2*[0 NaN 1 1 1]), [NaN NaN y(3:5)]);
-%!assert(betapdf ([x, NaN], 1, 2), [y, NaN]);
+%!assert (betapdf (x, ones (1,5), 2*ones (1,5)), y)
+%!assert (betapdf (x, 1, 2*ones (1,5)), y)
+%!assert (betapdf (x, ones (1,5), 2), y)
+%!assert (betapdf (x, [0 NaN 1 1 1], 2), [NaN NaN y(3:5)])
+%!assert (betapdf (x, 1, 2*[0 NaN 1 1 1]), [NaN NaN y(3:5)])
+%!assert (betapdf ([x, NaN], 1, 2), [y, NaN])
 
 %% Test class of input preserved
-%!assert(betapdf (single([x, NaN]), 1, 2), single([y, NaN]));
-%!assert(betapdf ([x, NaN], single(1), 2), single([y, NaN]));
-%!assert(betapdf ([x, NaN], 1, single(2)), single([y, NaN]));
+%!assert (betapdf (single ([x, NaN]), 1, 2), single ([y, NaN]))
+%!assert (betapdf ([x, NaN], single (1), 2), single ([y, NaN]))
+%!assert (betapdf ([x, NaN], 1, single (2)), single ([y, NaN]))
 
 %% Beta (1/2,1/2) == arcsine distribution
 %!test
 %! x = rand (10,1);
 %! y = 1./(pi * sqrt (x.*(1-x)));
-%! assert(betapdf (x, 1/2, 1/2), y, 50*eps);
+%! assert (betapdf (x, 1/2, 1/2), y, 50*eps);
 
 %% Test large input values to betapdf
-%!assert (betapdf(0.5, 1000, 1000), 35.678, 1e-3)
+%!assert (betapdf (0.5, 1000, 1000), 35.678, 1e-3)
 
 %% Test input validation
 %!error betapdf ()
 %!error betapdf (1)
 %!error betapdf (1,2)
 %!error betapdf (1,2,3,4)
-%!error betapdf (ones(3),ones(2),ones(2))
-%!error betapdf (ones(2),ones(3),ones(2))
-%!error betapdf (ones(2),ones(2),ones(3))
+%!error betapdf (ones (3), ones (2), ones (2))
+%!error betapdf (ones (2), ones (3), ones (2))
+%!error betapdf (ones (2), ones (2), ones (3))
 %!error betapdf (i, 2, 2)
 %!error betapdf (2, i, 2)
 %!error betapdf (2, 2, i)
 
diff --git a/scripts/statistics/distributions/betarnd.m b/scripts/statistics/distributions/betarnd.m
--- a/scripts/statistics/distributions/betarnd.m
+++ b/scripts/statistics/distributions/betarnd.m
@@ -98,40 +98,40 @@ function rnd = betarnd (a, b, varargin)
     k = (a > 0) & (a < Inf) & (b > 0) & (b < Inf);
     r = randg (a(k));
     rnd(k) = r ./ (r + randg (b(k)));
   endif
 
 endfunction
 
 
-%!assert(size (betarnd (1,2)), [1, 1]);
-%!assert(size (betarnd (ones(2,1), 2)), [2, 1]);
-%!assert(size (betarnd (ones(2,2), 2)), [2, 2]);
-%!assert(size (betarnd (1, 2*ones(2,1))), [2, 1]);
-%!assert(size (betarnd (1, 2*ones(2,2))), [2, 2]);
-%!assert(size (betarnd (1, 2, 3)), [3, 3]);
-%!assert(size (betarnd (1, 2, [4 1])), [4, 1]);
-%!assert(size (betarnd (1, 2, 4, 1)), [4, 1]);
+%!assert (size (betarnd (1,2)), [1, 1])
+%!assert (size (betarnd (ones (2,1), 2)), [2, 1])
+%!assert (size (betarnd (ones (2,2), 2)), [2, 2])
+%!assert (size (betarnd (1, 2*ones (2,1))), [2, 1])
+%!assert (size (betarnd (1, 2*ones (2,2))), [2, 2])
+%!assert (size (betarnd (1, 2, 3)), [3, 3])
+%!assert (size (betarnd (1, 2, [4 1])), [4, 1])
+%!assert (size (betarnd (1, 2, 4, 1)), [4, 1])
 
 %% Test class of input preserved
-%!assert(class (betarnd (1, 2)), "double");
-%!assert(class (betarnd (single(1), 2)), "single");
-%!assert(class (betarnd (single([1 1]), 2)), "single");
-%!assert(class (betarnd (1, single(2))), "single");
-%!assert(class (betarnd (1, single([2 2]))), "single");
+%!assert (class (betarnd (1, 2)), "double")
+%!assert (class (betarnd (single (1), 2)), "single")
+%!assert (class (betarnd (single ([1 1]), 2)), "single")
+%!assert (class (betarnd (1, single (2))), "single")
+%!assert (class (betarnd (1, single ([2 2]))), "single")
 
 %% Test input validation
 %!error betarnd ()
 %!error betarnd (1)
-%!error betarnd (ones(3),ones(2))
-%!error betarnd (ones(2),ones(3))
+%!error betarnd (ones (3), ones (2))
+%!error betarnd (ones (2), ones (3))
 %!error betarnd (i, 2)
 %!error betarnd (2, i)
 %!error betarnd (1,2, -1)
-%!error betarnd (1,2, ones(2))
+%!error betarnd (1,2, ones (2))
 %!error binornd (1,2, [2 -1 2])
-%!error betarnd (1,2, 1, ones(2))
+%!error betarnd (1,2, 1, ones (2))
 %!error betarnd (1,2, 1, -1)
-%!error betarnd (ones(2,2), 2, 3)
-%!error betarnd (ones(2,2), 2, [3, 2])
-%!error betarnd (ones(2,2), 2, 2, 3)
+%!error betarnd (ones (2,2), 2, 3)
+%!error betarnd (ones (2,2), 2, [3, 2])
+%!error betarnd (ones (2,2), 2, 2, 3)
 
diff --git a/scripts/statistics/distributions/binocdf.m b/scripts/statistics/distributions/binocdf.m
--- a/scripts/statistics/distributions/binocdf.m
+++ b/scripts/statistics/distributions/binocdf.m
@@ -66,33 +66,33 @@ function cdf = binocdf (x, n, p)
   endif
 
 endfunction
 
 
 %!shared x,y
 %! x = [-1 0 1 2 3];
 %! y = [0 1/4 3/4 1 1];
-%!assert(binocdf (x, 2*ones(1,5), 0.5*ones(1,5)), y);
-%!assert(binocdf (x, 2, 0.5*ones(1,5)), y);
-%!assert(binocdf (x, 2*ones(1,5), 0.5), y);
-%!assert(binocdf (x, 2*[0 -1 NaN 1.1 1], 0.5), [0 NaN NaN NaN 1]);
-%!assert(binocdf (x, 2, 0.5*[0 -1 NaN 3 1]), [0 NaN NaN NaN 1]);
-%!assert(binocdf ([x(1:2) NaN x(4:5)], 2, 0.5), [y(1:2) NaN y(4:5)]);
+%!assert (binocdf (x, 2*ones (1,5), 0.5*ones (1,5)), y)
+%!assert (binocdf (x, 2, 0.5*ones (1,5)), y)
+%!assert (binocdf (x, 2*ones (1,5), 0.5), y)
+%!assert (binocdf (x, 2*[0 -1 NaN 1.1 1], 0.5), [0 NaN NaN NaN 1])
+%!assert (binocdf (x, 2, 0.5*[0 -1 NaN 3 1]), [0 NaN NaN NaN 1])
+%!assert (binocdf ([x(1:2) NaN x(4:5)], 2, 0.5), [y(1:2) NaN y(4:5)])
 
 %% Test class of input preserved
-%!assert(binocdf ([x, NaN], 2, 0.5), [y, NaN]);
-%!assert(binocdf (single([x, NaN]), 2, 0.5), single([y, NaN]));
-%!assert(binocdf ([x, NaN], single(2), 0.5), single([y, NaN]));
-%!assert(binocdf ([x, NaN], 2, single(0.5)), single([y, NaN]));
+%!assert (binocdf ([x, NaN], 2, 0.5), [y, NaN])
+%!assert (binocdf (single ([x, NaN]), 2, 0.5), single ([y, NaN]))
+%!assert (binocdf ([x, NaN], single (2), 0.5), single ([y, NaN]))
+%!assert (binocdf ([x, NaN], 2, single (0.5)), single ([y, NaN]))
 
 %% Test input validation
 %!error binocdf ()
 %!error binocdf (1)
 %!error binocdf (1,2)
 %!error binocdf (1,2,3,4)
-%!error binocdf (ones(3),ones(2),ones(2))
-%!error binocdf (ones(2),ones(3),ones(2))
-%!error binocdf (ones(2),ones(2),ones(3))
+%!error binocdf (ones (3), ones (2), ones (2))
+%!error binocdf (ones (2), ones (3), ones (2))
+%!error binocdf (ones (2), ones (2), ones (3))
 %!error binocdf (i, 2, 2)
 %!error binocdf (2, i, 2)
 %!error binocdf (2, 2, i)
 
diff --git a/scripts/statistics/distributions/binoinv.m b/scripts/statistics/distributions/binoinv.m
--- a/scripts/statistics/distributions/binoinv.m
+++ b/scripts/statistics/distributions/binoinv.m
@@ -83,33 +83,33 @@ function inv = binoinv (x, n, p)
     endif
   endif
 
 endfunction
 
 
 %!shared x
 %! x = [-1 0 0.5 1 2];
-%!assert(binoinv (x, 2*ones(1,5), 0.5*ones(1,5)), [NaN 0 1 2 NaN]);
-%!assert(binoinv (x, 2, 0.5*ones(1,5)), [NaN 0 1 2 NaN]);
-%!assert(binoinv (x, 2*ones(1,5), 0.5), [NaN 0 1 2 NaN]);
-%!assert(binoinv (x, 2*[0 -1 NaN 1.1 1], 0.5), [NaN NaN NaN NaN NaN]);
-%!assert(binoinv (x, 2, 0.5*[0 -1 NaN 3 1]), [NaN NaN NaN NaN NaN]);
-%!assert(binoinv ([x(1:2) NaN x(4:5)], 2, 0.5), [NaN 0 NaN 2 NaN]);
+%!assert (binoinv (x, 2*ones (1,5), 0.5*ones (1,5)), [NaN 0 1 2 NaN])
+%!assert (binoinv (x, 2, 0.5*ones (1,5)), [NaN 0 1 2 NaN])
+%!assert (binoinv (x, 2*ones (1,5), 0.5), [NaN 0 1 2 NaN])
+%!assert (binoinv (x, 2*[0 -1 NaN 1.1 1], 0.5), [NaN NaN NaN NaN NaN])
+%!assert (binoinv (x, 2, 0.5*[0 -1 NaN 3 1]), [NaN NaN NaN NaN NaN])
+%!assert (binoinv ([x(1:2) NaN x(4:5)], 2, 0.5), [NaN 0 NaN 2 NaN])
 
 %% Test class of input preserved
-%!assert(binoinv ([x, NaN], 2, 0.5), [NaN 0 1 2 NaN NaN]);
-%!assert(binoinv (single([x, NaN]), 2, 0.5), single([NaN 0 1 2 NaN NaN]));
-%!assert(binoinv ([x, NaN], single(2), 0.5), single([NaN 0 1 2 NaN NaN]));
-%!assert(binoinv ([x, NaN], 2, single(0.5)), single([NaN 0 1 2 NaN NaN]));
+%!assert (binoinv ([x, NaN], 2, 0.5), [NaN 0 1 2 NaN NaN])
+%!assert (binoinv (single ([x, NaN]), 2, 0.5), single ([NaN 0 1 2 NaN NaN]))
+%!assert (binoinv ([x, NaN], single (2), 0.5), single ([NaN 0 1 2 NaN NaN]))
+%!assert (binoinv ([x, NaN], 2, single (0.5)), single ([NaN 0 1 2 NaN NaN]))
 
 %% Test input validation
 %!error binoinv ()
 %!error binoinv (1)
 %!error binoinv (1,2)
 %!error binoinv (1,2,3,4)
-%!error binoinv (ones(3),ones(2),ones(2))
-%!error binoinv (ones(2),ones(3),ones(2))
-%!error binoinv (ones(2),ones(2),ones(3))
+%!error binoinv (ones (3), ones (2), ones (2))
+%!error binoinv (ones (2), ones (3), ones (2))
+%!error binoinv (ones (2), ones (2), ones (3))
 %!error binoinv (i, 2, 2)
 %!error binoinv (2, i, 2)
 %!error binoinv (2, 2, i)
 
diff --git a/scripts/statistics/distributions/binopdf.m b/scripts/statistics/distributions/binopdf.m
--- a/scripts/statistics/distributions/binopdf.m
+++ b/scripts/statistics/distributions/binopdf.m
@@ -70,32 +70,32 @@ endfunction
 %!shared x,y,tol
 %! if (ismac ())
 %!   tol = eps ();
 %! else
 %!   tol = 0;
 %! endif
 %! x = [-1 0 1 2 3];
 %! y = [0 1/4 1/2 1/4 0];
-%!assert(binopdf (x, 2*ones(1,5), 0.5*ones(1,5)), y, tol);
-%!assert(binopdf (x, 2, 0.5*ones(1,5)), y, tol);
-%!assert(binopdf (x, 2*ones(1,5), 0.5), y, tol);
-%!assert(binopdf (x, 2*[0 -1 NaN 1.1 1], 0.5), [0 NaN NaN NaN 0]);
-%!assert(binopdf (x, 2, 0.5*[0 -1 NaN 3 1]), [0 NaN NaN NaN 0]);
-%!assert(binopdf ([x, NaN], 2, 0.5), [y, NaN], tol);
+%!assert (binopdf (x, 2*ones (1,5), 0.5*ones (1,5)), y, tol)
+%!assert (binopdf (x, 2, 0.5*ones (1,5)), y, tol)
+%!assert (binopdf (x, 2*ones (1,5), 0.5), y, tol)
+%!assert (binopdf (x, 2*[0 -1 NaN 1.1 1], 0.5), [0 NaN NaN NaN 0])
+%!assert (binopdf (x, 2, 0.5*[0 -1 NaN 3 1]), [0 NaN NaN NaN 0])
+%!assert (binopdf ([x, NaN], 2, 0.5), [y, NaN], tol)
 
 %% Test class of input preserved
-%!assert(binopdf (single([x, NaN]), 2, 0.5), single([y, NaN]));
-%!assert(binopdf ([x, NaN], single(2), 0.5), single([y, NaN]));
-%!assert(binopdf ([x, NaN], 2, single(0.5)), single([y, NaN]));
+%!assert (binopdf (single ([x, NaN]), 2, 0.5), single ([y, NaN]))
+%!assert (binopdf ([x, NaN], single (2), 0.5), single ([y, NaN]))
+%!assert (binopdf ([x, NaN], 2, single (0.5)), single ([y, NaN]))
 
 %% Test input validation
 %!error binopdf ()
 %!error binopdf (1)
 %!error binopdf (1,2)
 %!error binopdf (1,2,3,4)
-%!error binopdf (ones(3),ones(2),ones(2))
-%!error binopdf (ones(2),ones(3),ones(2))
-%!error binopdf (ones(2),ones(2),ones(3))
+%!error binopdf (ones (3), ones (2), ones (2))
+%!error binopdf (ones (2), ones (3), ones (2))
+%!error binopdf (ones (2), ones (2), ones (3))
 %!error binopdf (i, 2, 2)
 %!error binopdf (2, i, 2)
 %!error binopdf (2, 2, i)
 
diff --git a/scripts/statistics/distributions/binornd.m b/scripts/statistics/distributions/binornd.m
--- a/scripts/statistics/distributions/binornd.m
+++ b/scripts/statistics/distributions/binornd.m
@@ -115,40 +115,40 @@ function rnd = binornd (n, p, varargin)
   endif
 
 endfunction
 
 
 %!assert (binornd (0, 0, 1), 0)
 %!assert (binornd ([0, 0], [0, 0], 1, 2), [0, 0])
 
-%!assert(size (binornd (2, 1/2)), [1, 1]);
-%!assert(size (binornd (2*ones(2,1), 1/2)), [2, 1]);
-%!assert(size (binornd (2*ones(2,2), 1/2)), [2, 2]);
-%!assert(size (binornd (2, 1/2*ones(2,1))), [2, 1]);
-%!assert(size (binornd (2, 1/2*ones(2,2))), [2, 2]);
-%!assert(size (binornd (2, 1/2, 3)), [3, 3]);
-%!assert(size (binornd (2, 1/2, [4 1])), [4, 1]);
-%!assert(size (binornd (2, 1/2, 4, 1)), [4, 1]);
+%!assert (size (binornd (2, 1/2)), [1, 1])
+%!assert (size (binornd (2*ones (2,1), 1/2)), [2, 1])
+%!assert (size (binornd (2*ones (2,2), 1/2)), [2, 2])
+%!assert (size (binornd (2, 1/2*ones (2,1))), [2, 1])
+%!assert (size (binornd (2, 1/2*ones (2,2))), [2, 2])
+%!assert (size (binornd (2, 1/2, 3)), [3, 3])
+%!assert (size (binornd (2, 1/2, [4 1])), [4, 1])
+%!assert (size (binornd (2, 1/2, 4, 1)), [4, 1])
 
 %% Test class of input preserved
-%!assert(class (binornd (2, 0.5)), "double");
-%!assert(class (binornd (single(2), 0.5)), "single");
-%!assert(class (binornd (single([2 2]), 0.5)), "single");
-%!assert(class (binornd (2, single(0.5))), "single");
-%!assert(class (binornd (2, single([0.5 0.5]))), "single");
+%!assert (class (binornd (2, 0.5)), "double")
+%!assert (class (binornd (single (2), 0.5)), "single")
+%!assert (class (binornd (single ([2 2]), 0.5)), "single")
+%!assert (class (binornd (2, single (0.5))), "single")
+%!assert (class (binornd (2, single ([0.5 0.5]))), "single")
 
 %% Test input validation
 %!error binornd ()
 %!error binornd (1)
-%!error binornd (ones(3),ones(2))
-%!error binornd (ones(2),ones(3))
+%!error binornd (ones (3), ones (2))
+%!error binornd (ones (2), ones (3))
 %!error binornd (i, 2)
 %!error binornd (2, i)
 %!error binornd (1,2, -1)
-%!error binornd (1,2, ones(2))
+%!error binornd (1,2, ones (2))
 %!error binornd (1,2, [2 -1 2])
-%!error binornd (1,2, 1, ones(2))
+%!error binornd (1,2, 1, ones (2))
 %!error binornd (1,2, 1, -1)
-%!error binornd (ones(2,2), 2, 3)
-%!error binornd (ones(2,2), 2, [3, 2])
-%!error binornd (ones(2,2), 2, 2, 3)
+%!error binornd (ones (2,2), 2, 3)
+%!error binornd (ones (2,2), 2, [3, 2])
+%!error binornd (ones (2,2), 2, 2, 3)
 
diff --git a/scripts/statistics/distributions/cauchy_cdf.m b/scripts/statistics/distributions/cauchy_cdf.m
--- a/scripts/statistics/distributions/cauchy_cdf.m
+++ b/scripts/statistics/distributions/cauchy_cdf.m
@@ -60,32 +60,32 @@ function cdf = cauchy_cdf (x, location =
   endif
 
 endfunction
 
 
 %!shared x,y
 %! x = [-1 0 0.5 1 2];
 %! y = 1/pi * atan ((x-1) / 2) + 1/2;
-%!assert(cauchy_cdf (x, ones(1,5), 2*ones(1,5)), y);
-%!assert(cauchy_cdf (x, 1, 2*ones(1,5)), y);
-%!assert(cauchy_cdf (x, ones(1,5), 2), y);
-%!assert(cauchy_cdf (x, [-Inf 1 NaN 1 Inf], 2), [NaN y(2) NaN y(4) NaN]);
-%!assert(cauchy_cdf (x, 1, 2*[0 1 NaN 1 Inf]), [NaN y(2) NaN y(4) NaN]);
-%!assert(cauchy_cdf ([x(1:2) NaN x(4:5)], 1, 2), [y(1:2) NaN y(4:5)]);
+%!assert (cauchy_cdf (x, ones (1,5), 2*ones (1,5)), y)
+%!assert (cauchy_cdf (x, 1, 2*ones (1,5)), y)
+%!assert (cauchy_cdf (x, ones (1,5), 2), y)
+%!assert (cauchy_cdf (x, [-Inf 1 NaN 1 Inf], 2), [NaN y(2) NaN y(4) NaN])
+%!assert (cauchy_cdf (x, 1, 2*[0 1 NaN 1 Inf]), [NaN y(2) NaN y(4) NaN])
+%!assert (cauchy_cdf ([x(1:2) NaN x(4:5)], 1, 2), [y(1:2) NaN y(4:5)])
 
 %% Test class of input preserved
-%!assert(cauchy_cdf ([x, NaN], 1, 2), [y, NaN]);
-%!assert(cauchy_cdf (single([x, NaN]), 1, 2), single([y, NaN]), eps("single"));
-%!assert(cauchy_cdf ([x, NaN], single(1), 2), single([y, NaN]), eps("single"));
-%!assert(cauchy_cdf ([x, NaN], 1, single(2)), single([y, NaN]), eps("single"));
+%!assert (cauchy_cdf ([x, NaN], 1, 2), [y, NaN])
+%!assert (cauchy_cdf (single ([x, NaN]), 1, 2), single ([y, NaN]), eps ("single"))
+%!assert (cauchy_cdf ([x, NaN], single (1), 2), single ([y, NaN]), eps ("single"))
+%!assert (cauchy_cdf ([x, NaN], 1, single (2)), single ([y, NaN]), eps ("single"))
 
 %% Test input validation
 %!error cauchy_cdf ()
 %!error cauchy_cdf (1,2)
 %!error cauchy_cdf (1,2,3,4)
-%!error cauchy_cdf (ones(3),ones(2),ones(2))
-%!error cauchy_cdf (ones(2),ones(3),ones(2))
-%!error cauchy_cdf (ones(2),ones(2),ones(3))
+%!error cauchy_cdf (ones (3), ones (2), ones (2))
+%!error cauchy_cdf (ones (2), ones (3), ones (2))
+%!error cauchy_cdf (ones (2), ones (2), ones (3))
 %!error cauchy_cdf (i, 2, 2)
 %!error cauchy_cdf (2, i, 2)
 %!error cauchy_cdf (2, 2, i)
 
diff --git a/scripts/statistics/distributions/cauchy_inv.m b/scripts/statistics/distributions/cauchy_inv.m
--- a/scripts/statistics/distributions/cauchy_inv.m
+++ b/scripts/statistics/distributions/cauchy_inv.m
@@ -67,32 +67,32 @@ function inv = cauchy_inv (x, location =
     inv(k) = location(k) - scale(k) .* cot (pi * x(k));
   endif
 
 endfunction
 
 
 %!shared x
 %! x = [-1 0 0.5 1 2];
-%!assert(cauchy_inv (x, ones(1,5), 2*ones(1,5)), [NaN -Inf 1 Inf NaN], eps);
-%!assert(cauchy_inv (x, 1, 2*ones(1,5)), [NaN -Inf 1 Inf NaN], eps);
-%!assert(cauchy_inv (x, ones(1,5), 2), [NaN -Inf 1 Inf NaN], eps);
-%!assert(cauchy_inv (x, [1 -Inf NaN Inf 1], 2), [NaN NaN NaN NaN NaN]);
-%!assert(cauchy_inv (x, 1, 2*[1 0 NaN Inf 1]), [NaN NaN NaN NaN NaN]);
-%!assert(cauchy_inv ([x(1:2) NaN x(4:5)], 1, 2), [NaN -Inf NaN Inf NaN]);
+%!assert (cauchy_inv (x, ones (1,5), 2*ones (1,5)), [NaN -Inf 1 Inf NaN], eps)
+%!assert (cauchy_inv (x, 1, 2*ones (1,5)), [NaN -Inf 1 Inf NaN], eps)
+%!assert (cauchy_inv (x, ones (1,5), 2), [NaN -Inf 1 Inf NaN], eps)
+%!assert (cauchy_inv (x, [1 -Inf NaN Inf 1], 2), [NaN NaN NaN NaN NaN])
+%!assert (cauchy_inv (x, 1, 2*[1 0 NaN Inf 1]), [NaN NaN NaN NaN NaN])
+%!assert (cauchy_inv ([x(1:2) NaN x(4:5)], 1, 2), [NaN -Inf NaN Inf NaN])
 
 %% Test class of input preserved
-%!assert(cauchy_inv ([x, NaN], 1, 2), [NaN -Inf 1 Inf NaN NaN], eps);
-%!assert(cauchy_inv (single([x, NaN]), 1, 2), single([NaN -Inf 1 Inf NaN NaN]), eps("single"));
-%!assert(cauchy_inv ([x, NaN], single(1), 2), single([NaN -Inf 1 Inf NaN NaN]), eps("single"));
-%!assert(cauchy_inv ([x, NaN], 1, single(2)), single([NaN -Inf 1 Inf NaN NaN]), eps("single"));
+%!assert (cauchy_inv ([x, NaN], 1, 2), [NaN -Inf 1 Inf NaN NaN], eps)
+%!assert (cauchy_inv (single ([x, NaN]), 1, 2), single ([NaN -Inf 1 Inf NaN NaN]), eps ("single"))
+%!assert (cauchy_inv ([x, NaN], single (1), 2), single ([NaN -Inf 1 Inf NaN NaN]), eps ("single"))
+%!assert (cauchy_inv ([x, NaN], 1, single (2)), single ([NaN -Inf 1 Inf NaN NaN]), eps ("single"))
 
 %% Test input validation
 %!error cauchy_inv ()
 %!error cauchy_inv (1,2)
 %!error cauchy_inv (1,2,3,4)
-%!error cauchy_inv (ones(3),ones(2),ones(2))
-%!error cauchy_inv (ones(2),ones(3),ones(2))
-%!error cauchy_inv (ones(2),ones(2),ones(3))
+%!error cauchy_inv (ones (3), ones (2), ones (2))
+%!error cauchy_inv (ones (2), ones (3), ones (2))
+%!error cauchy_inv (ones (2), ones (2), ones (3))
 %!error cauchy_inv (i, 2, 2)
 %!error cauchy_inv (2, i, 2)
 %!error cauchy_inv (2, 2, i)
 
diff --git a/scripts/statistics/distributions/cauchy_pdf.m b/scripts/statistics/distributions/cauchy_pdf.m
--- a/scripts/statistics/distributions/cauchy_pdf.m
+++ b/scripts/statistics/distributions/cauchy_pdf.m
@@ -62,36 +62,36 @@ function pdf = cauchy_pdf (x, location =
   endif
 
 endfunction
 
 
 %!shared x,y
 %! x = [-1 0 0.5 1 2];
 %! y = 1/pi * ( 2 ./ ((x-1).^2 + 2^2) );
-%!assert(cauchy_pdf (x, ones(1,5), 2*ones(1,5)), y);
-%!assert(cauchy_pdf (x, 1, 2*ones(1,5)), y);
-%!assert(cauchy_pdf (x, ones(1,5), 2), y);
-%!assert(cauchy_pdf (x, [-Inf 1 NaN 1 Inf], 2), [NaN y(2) NaN y(4) NaN]);
-%!assert(cauchy_pdf (x, 1, 2*[0 1 NaN 1 Inf]), [NaN y(2) NaN y(4) NaN]);
-%!assert(cauchy_pdf ([x, NaN], 1, 2), [y, NaN]);
+%!assert (cauchy_pdf (x, ones (1,5), 2*ones (1,5)), y)
+%!assert (cauchy_pdf (x, 1, 2*ones (1,5)), y)
+%!assert (cauchy_pdf (x, ones (1,5), 2), y)
+%!assert (cauchy_pdf (x, [-Inf 1 NaN 1 Inf], 2), [NaN y(2) NaN y(4) NaN])
+%!assert (cauchy_pdf (x, 1, 2*[0 1 NaN 1 Inf]), [NaN y(2) NaN y(4) NaN])
+%!assert (cauchy_pdf ([x, NaN], 1, 2), [y, NaN])
 
 %% Test class of input preserved
-%!assert(cauchy_pdf (single([x, NaN]), 1, 2), single([y, NaN]), eps("single"));
-%!assert(cauchy_pdf ([x, NaN], single(1), 2), single([y, NaN]), eps("single"));
-%!assert(cauchy_pdf ([x, NaN], 1, single(2)), single([y, NaN]), eps("single"));
+%!assert (cauchy_pdf (single ([x, NaN]), 1, 2), single ([y, NaN]), eps ("single"))
+%!assert (cauchy_pdf ([x, NaN], single (1), 2), single ([y, NaN]), eps ("single"))
+%!assert (cauchy_pdf ([x, NaN], 1, single (2)), single ([y, NaN]), eps ("single"))
 
 %% Cauchy (0,1) == Student's T distribution with 1 DOF
 %!test
 %! x = rand (10, 1);
-%! assert(cauchy_pdf (x, 0, 1), tpdf (x, 1), eps);
+%! assert (cauchy_pdf (x, 0, 1), tpdf (x, 1), eps);
 
 %% Test input validation
 %!error cauchy_pdf ()
 %!error cauchy_pdf (1,2)
 %!error cauchy_pdf (1,2,3,4)
-%!error cauchy_pdf (ones(3),ones(2),ones(2))
-%!error cauchy_pdf (ones(2),ones(3),ones(2))
-%!error cauchy_pdf (ones(2),ones(2),ones(3))
+%!error cauchy_pdf (ones (3), ones (2), ones (2))
+%!error cauchy_pdf (ones (2), ones (3), ones (2))
+%!error cauchy_pdf (ones (2), ones (2), ones (3))
 %!error cauchy_pdf (i, 2, 2)
 %!error cauchy_pdf (2, i, 2)
 %!error cauchy_pdf (2, 2, i)
 
diff --git a/scripts/statistics/distributions/cauchy_rnd.m b/scripts/statistics/distributions/cauchy_rnd.m
--- a/scripts/statistics/distributions/cauchy_rnd.m
+++ b/scripts/statistics/distributions/cauchy_rnd.m
@@ -93,40 +93,40 @@ function rnd = cauchy_rnd (location, sca
 
     k = !isinf (location) & (scale > 0) & (scale < Inf);
     rnd(k) = location(k)(:) - cot (pi * rand (sum (k(:)), 1)) .* scale(k)(:);
   endif
 
 endfunction
 
 
-%!assert(size (cauchy_rnd (1,2)), [1, 1]);
-%!assert(size (cauchy_rnd (ones(2,1), 2)), [2, 1]);
-%!assert(size (cauchy_rnd (ones(2,2), 2)), [2, 2]);
-%!assert(size (cauchy_rnd (1, 2*ones(2,1))), [2, 1]);
-%!assert(size (cauchy_rnd (1, 2*ones(2,2))), [2, 2]);
-%!assert(size (cauchy_rnd (1, 2, 3)), [3, 3]);
-%!assert(size (cauchy_rnd (1, 2, [4 1])), [4, 1]);
-%!assert(size (cauchy_rnd (1, 2, 4, 1)), [4, 1]);
+%!assert (size (cauchy_rnd (1,2)), [1, 1])
+%!assert (size (cauchy_rnd (ones (2,1), 2)), [2, 1])
+%!assert (size (cauchy_rnd (ones (2,2), 2)), [2, 2])
+%!assert (size (cauchy_rnd (1, 2*ones (2,1))), [2, 1])
+%!assert (size (cauchy_rnd (1, 2*ones (2,2))), [2, 2])
+%!assert (size (cauchy_rnd (1, 2, 3)), [3, 3])
+%!assert (size (cauchy_rnd (1, 2, [4 1])), [4, 1])
+%!assert (size (cauchy_rnd (1, 2, 4, 1)), [4, 1])
 
 %% Test class of input preserved
-%!assert(class (cauchy_rnd (1, 2)), "double");
-%!assert(class (cauchy_rnd (single(1), 2)), "single");
-%!assert(class (cauchy_rnd (single([1 1]), 2)), "single");
-%!assert(class (cauchy_rnd (1, single(2))), "single");
-%!assert(class (cauchy_rnd (1, single([2 2]))), "single");
+%!assert (class (cauchy_rnd (1, 2)), "double")
+%!assert (class (cauchy_rnd (single (1), 2)), "single")
+%!assert (class (cauchy_rnd (single ([1 1]), 2)), "single")
+%!assert (class (cauchy_rnd (1, single (2))), "single")
+%!assert (class (cauchy_rnd (1, single ([2 2]))), "single")
 
 %% Test input validation
 %!error cauchy_rnd ()
 %!error cauchy_rnd (1)
-%!error cauchy_rnd (ones(3),ones(2))
-%!error cauchy_rnd (ones(2),ones(3))
+%!error cauchy_rnd (ones (3), ones (2))
+%!error cauchy_rnd (ones (2), ones (3))
 %!error cauchy_rnd (i, 2)
 %!error cauchy_rnd (2, i)
 %!error cauchy_rnd (1,2, -1)
-%!error cauchy_rnd (1,2, ones(2))
+%!error cauchy_rnd (1,2, ones (2))
 %!error cauchy_rnd (1,2, [2 -1 2])
-%!error cauchy_rnd (1,2, 1, ones(2))
+%!error cauchy_rnd (1,2, 1, ones (2))
 %!error cauchy_rnd (1,2, 1, -1)
-%!error cauchy_rnd (ones(2,2), 2, 3)
-%!error cauchy_rnd (ones(2,2), 2, [3, 2])
-%!error cauchy_rnd (ones(2,2), 2, 2, 3)
+%!error cauchy_rnd (ones (2,2), 2, 3)
+%!error cauchy_rnd (ones (2,2), 2, [3, 2])
+%!error cauchy_rnd (ones (2,2), 2, 2, 3)
 
diff --git a/scripts/statistics/distributions/chi2cdf.m b/scripts/statistics/distributions/chi2cdf.m
--- a/scripts/statistics/distributions/chi2cdf.m
+++ b/scripts/statistics/distributions/chi2cdf.m
@@ -47,27 +47,27 @@ function cdf = chi2cdf (x, n)
   cdf = gamcdf (x, n/2, 2);
 
 endfunction
 
 
 %!shared x,y
 %! x = [-1 0 0.5 1 2];
 %! y = [0, 1 - exp(-x(2:end)/2)];
-%!assert(chi2cdf (x, 2*ones(1,5)), y, eps);
-%!assert(chi2cdf (x, 2), y, eps);
-%!assert(chi2cdf (x, 2*[1 0 NaN 1 1]), [y(1) NaN NaN y(4:5)], eps);
-%!assert(chi2cdf ([x(1:2) NaN x(4:5)], 2), [y(1:2) NaN y(4:5)], eps);
+%!assert (chi2cdf (x, 2*ones (1,5)), y, eps)
+%!assert (chi2cdf (x, 2), y, eps)
+%!assert (chi2cdf (x, 2*[1 0 NaN 1 1]), [y(1) NaN NaN y(4:5)], eps)
+%!assert (chi2cdf ([x(1:2) NaN x(4:5)], 2), [y(1:2) NaN y(4:5)], eps)
 
 %% Test class of input preserved
-%!assert(chi2cdf ([x, NaN], 2), [y, NaN], eps);
-%!assert(chi2cdf (single([x, NaN]), 2), single([y, NaN]), eps("single"));
-%!assert(chi2cdf ([x, NaN], single(2)), single([y, NaN]), eps("single"));
+%!assert (chi2cdf ([x, NaN], 2), [y, NaN], eps)
+%!assert (chi2cdf (single ([x, NaN]), 2), single ([y, NaN]), eps ("single"))
+%!assert (chi2cdf ([x, NaN], single (2)), single ([y, NaN]), eps ("single"))
 
 %% Test input validation
 %!error chi2cdf ()
 %!error chi2cdf (1)
 %!error chi2cdf (1,2,3)
-%!error chi2cdf (ones(3),ones(2))
-%!error chi2cdf (ones(2),ones(3))
+%!error chi2cdf (ones (3), ones (2))
+%!error chi2cdf (ones (2), ones (3))
 %!error chi2cdf (i, 2)
 %!error chi2cdf (2, i)
 
diff --git a/scripts/statistics/distributions/chi2inv.m b/scripts/statistics/distributions/chi2inv.m
--- a/scripts/statistics/distributions/chi2inv.m
+++ b/scripts/statistics/distributions/chi2inv.m
@@ -46,27 +46,27 @@ function inv = chi2inv (x, n)
 
   inv = gaminv (x, n/2, 2);
 
 endfunction
 
 
 %!shared x
 %! x = [-1 0 0.3934693402873666 1 2];
-%!assert(chi2inv (x, 2*ones(1,5)), [NaN 0 1 Inf NaN], 5*eps);
-%!assert(chi2inv (x, 2), [NaN 0 1 Inf NaN], 5*eps);
-%!assert(chi2inv (x, 2*[0 1 NaN 1 1]), [NaN 0 NaN Inf NaN], 5*eps);
-%!assert(chi2inv ([x(1:2) NaN x(4:5)], 2), [NaN 0 NaN Inf NaN], 5*eps);
+%!assert (chi2inv (x, 2*ones (1,5)), [NaN 0 1 Inf NaN], 5*eps)
+%!assert (chi2inv (x, 2), [NaN 0 1 Inf NaN], 5*eps)
+%!assert (chi2inv (x, 2*[0 1 NaN 1 1]), [NaN 0 NaN Inf NaN], 5*eps)
+%!assert (chi2inv ([x(1:2) NaN x(4:5)], 2), [NaN 0 NaN Inf NaN], 5*eps)
 
 %% Test class of input preserved
-%!assert(chi2inv ([x, NaN], 2), [NaN 0 1 Inf NaN NaN], 5*eps);
-%!assert(chi2inv (single([x, NaN]), 2), single([NaN 0 1 Inf NaN NaN]), 5*eps("single"));
-%!assert(chi2inv ([x, NaN], single(2)), single([NaN 0 1 Inf NaN NaN]), 5*eps("single"));
+%!assert (chi2inv ([x, NaN], 2), [NaN 0 1 Inf NaN NaN], 5*eps)
+%!assert (chi2inv (single ([x, NaN]), 2), single ([NaN 0 1 Inf NaN NaN]), 5*eps ("single"))
+%!assert (chi2inv ([x, NaN], single (2)), single ([NaN 0 1 Inf NaN NaN]), 5*eps ("single"))
 
 %% Test input validation
 %!error chi2inv ()
 %!error chi2inv (1)
 %!error chi2inv (1,2,3)
-%!error chi2inv (ones(3),ones(2))
-%!error chi2inv (ones(2),ones(3))
+%!error chi2inv (ones (3), ones (2))
+%!error chi2inv (ones (2), ones (3))
 %!error chi2inv (i, 2)
 %!error chi2inv (2, i)
 
diff --git a/scripts/statistics/distributions/chi2pdf.m b/scripts/statistics/distributions/chi2pdf.m
--- a/scripts/statistics/distributions/chi2pdf.m
+++ b/scripts/statistics/distributions/chi2pdf.m
@@ -47,26 +47,26 @@ function pdf = chi2pdf (x, n)
   pdf = gampdf (x, n/2, 2);
 
 endfunction
 
 
 %!shared x,y
 %! x = [-1 0 0.5 1 Inf];
 %! y = [0, 1/2 * exp(-x(2:5)/2)];
-%!assert(chi2pdf (x, 2*ones(1,5)), y);
-%!assert(chi2pdf (x, 2), y);
-%!assert(chi2pdf (x, 2*[1 0 NaN 1 1]), [y(1) NaN NaN y(4:5)]);
-%!assert(chi2pdf ([x, NaN], 2), [y, NaN]);
+%!assert (chi2pdf (x, 2*ones (1,5)), y)
+%!assert (chi2pdf (x, 2), y)
+%!assert (chi2pdf (x, 2*[1 0 NaN 1 1]), [y(1) NaN NaN y(4:5)])
+%!assert (chi2pdf ([x, NaN], 2), [y, NaN])
 
 %% Test class of input preserved
-%!assert(chi2pdf (single([x, NaN]), 2), single([y, NaN]));
-%!assert(chi2pdf ([x, NaN], single(2)), single([y, NaN]));
+%!assert (chi2pdf (single ([x, NaN]), 2), single ([y, NaN]))
+%!assert (chi2pdf ([x, NaN], single (2)), single ([y, NaN]))
 
 %% Test input validation
 %!error chi2pdf ()
 %!error chi2pdf (1)
 %!error chi2pdf (1,2,3)
-%!error chi2pdf (ones(3),ones(2))
-%!error chi2pdf (ones(2),ones(3))
+%!error chi2pdf (ones (3), ones (2))
+%!error chi2pdf (ones (2), ones (3))
 %!error chi2pdf (i, 2)
 %!error chi2pdf (2, i)
 
diff --git a/scripts/statistics/distributions/chi2rnd.m b/scripts/statistics/distributions/chi2rnd.m
--- a/scripts/statistics/distributions/chi2rnd.m
+++ b/scripts/statistics/distributions/chi2rnd.m
@@ -89,32 +89,32 @@ function rnd = chi2rnd (n, varargin)
 
     k = (n > 0) | (n < Inf);
     rnd(k) = 2 * randg (n(k)/2);
   endif
 
 endfunction
 
 
-%!assert(size (chi2rnd (2)), [1, 1]);
-%!assert(size (chi2rnd (ones(2,1))), [2, 1]);
-%!assert(size (chi2rnd (ones(2,2))), [2, 2]);
-%!assert(size (chi2rnd (1, 3)), [3, 3]);
-%!assert(size (chi2rnd (1, [4 1])), [4, 1]);
-%!assert(size (chi2rnd (1, 4, 1)), [4, 1]);
+%!assert (size (chi2rnd (2)), [1, 1])
+%!assert (size (chi2rnd (ones (2,1))), [2, 1])
+%!assert (size (chi2rnd (ones (2,2))), [2, 2])
+%!assert (size (chi2rnd (1, 3)), [3, 3])
+%!assert (size (chi2rnd (1, [4 1])), [4, 1])
+%!assert (size (chi2rnd (1, 4, 1)), [4, 1])
 
 %% Test class of input preserved
-%!assert(class (chi2rnd (2)), "double");
-%!assert(class (chi2rnd (single(2))), "single");
-%!assert(class (chi2rnd (single([2 2]))), "single");
+%!assert (class (chi2rnd (2)), "double")
+%!assert (class (chi2rnd (single (2))), "single")
+%!assert (class (chi2rnd (single ([2 2]))), "single")
 
 %% Test input validation
 %!error chi2rnd ()
-%!error chi2rnd (ones(3),ones(2))
-%!error chi2rnd (ones(2),ones(3))
+%!error chi2rnd (ones (3), ones (2))
+%!error chi2rnd (ones (2), ones (3))
 %!error chi2rnd (i)
 %!error chi2rnd (1, -1)
-%!error chi2rnd (1, ones(2))
+%!error chi2rnd (1, ones (2))
 %!error chi2rnd (1, [2 -1 2])
-%!error chi2rnd (ones(2,2), 3)
-%!error chi2rnd (ones(2,2), [3, 2])
-%!error chi2rnd (ones(2,2), 2, 3)
+%!error chi2rnd (ones (2,2), 3)
+%!error chi2rnd (ones (2,2), [3, 2])
+%!error chi2rnd (ones (2,2), 2, 3)
 
diff --git a/scripts/statistics/distributions/discrete_cdf.m b/scripts/statistics/distributions/discrete_cdf.m
--- a/scripts/statistics/distributions/discrete_cdf.m
+++ b/scripts/statistics/distributions/discrete_cdf.m
@@ -53,29 +53,29 @@ function cdf = discrete_cdf (x, v, p)
   cdf(k) = [0 ; cumsum(p(vi))](lookup (vs, x(k)) + 1);
 
 endfunction
 
 
 %!shared x,v,p,y
 %! x = [-1 0.1 1.1 1.9 3];
 %! v = 0.1:0.2:1.9;
-%! p = 1/length(v) * ones(1, length(v));
+%! p = 1/length(v) * ones (1, length(v));
 %! y = [0 0.1 0.6 1 1];
-%!assert(discrete_cdf ([x, NaN], v, p), [y, NaN], eps);
+%!assert (discrete_cdf ([x, NaN], v, p), [y, NaN], eps)
 
 %% Test class of input preserved
-%!assert(discrete_cdf (single([x, NaN]), v, p), single([y, NaN]), 2*eps("single"));
-%!assert(discrete_cdf ([x, NaN], single(v), p), single([y, NaN]), 2*eps("single"));
-%!assert(discrete_cdf ([x, NaN], v, single(p)), single([y, NaN]), 2*eps("single"));
+%!assert (discrete_cdf (single ([x, NaN]), v, p), single ([y, NaN]), 2*eps ("single"))
+%!assert (discrete_cdf ([x, NaN], single (v), p), single ([y, NaN]), 2*eps ("single"))
+%!assert (discrete_cdf ([x, NaN], v, single (p)), single ([y, NaN]), 2*eps ("single"))
 
 %% Test input validation
 %!error discrete_cdf ()
 %!error discrete_cdf (1)
 %!error discrete_cdf (1,2)
 %!error discrete_cdf (1,2,3,4)
-%!error discrete_cdf (1, ones(2), ones(2,1))
-%!error discrete_cdf (1, [1 ; NaN], ones(2,1))
-%!error discrete_cdf (1, ones(2,1), ones(1,1))
-%!error discrete_cdf (1, ones(2,1), [1 -1])
-%!error discrete_cdf (1, ones(2,1), [1 NaN])
-%!error discrete_cdf (1, ones(2,1), [0  0])
+%!error discrete_cdf (1, ones (2), ones (2,1))
+%!error discrete_cdf (1, [1 ; NaN], ones (2,1))
+%!error discrete_cdf (1, ones (2,1), ones (1,1))
+%!error discrete_cdf (1, ones (2,1), [1 -1])
+%!error discrete_cdf (1, ones (2,1), [1 NaN])
+%!error discrete_cdf (1, ones (2,1), [0  0])
 
diff --git a/scripts/statistics/distributions/discrete_inv.m b/scripts/statistics/distributions/discrete_inv.m
--- a/scripts/statistics/distributions/discrete_inv.m
+++ b/scripts/statistics/distributions/discrete_inv.m
@@ -68,28 +68,28 @@ function inv = discrete_inv (x, v, p)
   inv(k) = v(length (p) - lookup (sort (p, "descend"), x(k)) + 1);
 
 endfunction
 
 
 %!shared x,v,p,y
 %! x = [-1 0 0.1 0.5 1 2];
 %! v = 0.1:0.2:1.9;
-%! p = 1/length(v) * ones(1, length(v));
+%! p = 1/length(v) * ones (1, length(v));
 %! y = [NaN v(1) v(1) v(end/2) v(end) NaN];
-%!assert(discrete_inv ([x, NaN], v, p), [y, NaN], eps);
+%!assert (discrete_inv ([x, NaN], v, p), [y, NaN], eps)
 
 %% Test class of input preserved
-%!assert(discrete_inv (single([x, NaN]), v, p), single([y, NaN]), eps("single"));
-%!assert(discrete_inv ([x, NaN], single(v), p), single([y, NaN]), eps("single"));
-%!assert(discrete_inv ([x, NaN], v, single(p)), single([y, NaN]), eps("single"));
+%!assert (discrete_inv (single ([x, NaN]), v, p), single ([y, NaN]), eps ("single"))
+%!assert (discrete_inv ([x, NaN], single (v), p), single ([y, NaN]), eps ("single"))
+%!assert (discrete_inv ([x, NaN], v, single (p)), single ([y, NaN]), eps ("single"))
 
 %% Test input validation
 %!error discrete_inv ()
 %!error discrete_inv (1)
 %!error discrete_inv (1,2)
 %!error discrete_inv (1,2,3,4)
-%!error discrete_inv (1, ones(2), ones(2,1))
-%!error discrete_inv (1, ones(2,1), ones(1,1))
-%!error discrete_inv (1, ones(2,1), [1 NaN])
-%!error discrete_inv (1, ones(2,1), [1 -1])
-%!error discrete_inv (1, ones(2,1), [0  0])
+%!error discrete_inv (1, ones (2), ones (2,1))
+%!error discrete_inv (1, ones (2,1), ones (1,1))
+%!error discrete_inv (1, ones (2,1), [1 NaN])
+%!error discrete_inv (1, ones (2,1), [1 -1])
+%!error discrete_inv (1, ones (2,1), [0  0])
 
diff --git a/scripts/statistics/distributions/discrete_pdf.m b/scripts/statistics/distributions/discrete_pdf.m
--- a/scripts/statistics/distributions/discrete_pdf.m
+++ b/scripts/statistics/distributions/discrete_pdf.m
@@ -57,29 +57,29 @@ function pdf = discrete_pdf (x, v, p)
   pdf(k) = p([0 ; vi](lookup (vs, x(k), 'm') + 1) + 1);
 
 endfunction
 
 
 %!shared x,v,p,y
 %! x = [-1 0.1 1.1 1.9 3];
 %! v = 0.1:0.2:1.9;
-%! p = 1/length(v) * ones(1, length(v));
+%! p = 1/length (v) * ones (1, length (v));
 %! y = [0 0.1 0.1 0.1 0];
-%!assert(discrete_pdf ([x, NaN], v, p), [y, NaN], 5*eps);
+%!assert (discrete_pdf ([x, NaN], v, p), [y, NaN], 5*eps)
 
 %% Test class of input preserved
-%!assert(discrete_pdf (single([x, NaN]), v, p), single([y, NaN]), 5*eps("single"));
-%!assert(discrete_pdf ([x, NaN], single(v), p), single([y, NaN]), 5*eps("single"));
-%!assert(discrete_pdf ([x, NaN], v, single(p)), single([y, NaN]), 5*eps("single"));
+%!assert (discrete_pdf (single ([x, NaN]), v, p), single ([y, NaN]), 5*eps ("single"))
+%!assert (discrete_pdf ([x, NaN], single (v), p), single ([y, NaN]), 5*eps ("single"))
+%!assert (discrete_pdf ([x, NaN], v, single (p)), single ([y, NaN]), 5*eps ("single"))
 
 %% Test input validation
 %!error discrete_pdf ()
 %!error discrete_pdf (1)
 %!error discrete_pdf (1,2)
 %!error discrete_pdf (1,2,3,4)
-%!error discrete_pdf (1, ones(2), ones(2,1))
-%!error discrete_pdf (1, [1 ; NaN], ones(2,1))
-%!error discrete_pdf (1, ones(2,1), ones(1,1))
-%!error discrete_pdf (1, ones(2,1), [1 -1])
-%!error discrete_pdf (1, ones(2,1), [1 NaN])
-%!error discrete_pdf (1, ones(2,1), [0  0])
+%!error discrete_pdf (1, ones (2), ones (2,1))
+%!error discrete_pdf (1, [1 ; NaN], ones (2,1))
+%!error discrete_pdf (1, ones (2,1), ones (1,1))
+%!error discrete_pdf (1, ones (2,1), [1 -1])
+%!error discrete_pdf (1, ones (2,1), [1 NaN])
+%!error discrete_pdf (1, ones (2,1), [0  0])
 
diff --git a/scripts/statistics/distributions/discrete_rnd.m b/scripts/statistics/distributions/discrete_rnd.m
--- a/scripts/statistics/distributions/discrete_rnd.m
+++ b/scripts/statistics/distributions/discrete_rnd.m
@@ -72,33 +72,33 @@ function rnd = discrete_rnd (v, p, varar
   endif
 
   rnd = v(lookup (cumsum (p(1:end-1)) / sum (p), rand (sz)) + 1);
   rnd = reshape (rnd, sz);
 
 endfunction
 
 
-%!assert(size (discrete_rnd (1:2, 1:2, 3)), [3, 3]);
-%!assert(size (discrete_rnd (1:2, 1:2, [4 1])), [4, 1]);
-%!assert(size (discrete_rnd (1:2, 1:2, 4, 1)), [4, 1]);
+%!assert (size (discrete_rnd (1:2, 1:2, 3)), [3, 3])
+%!assert (size (discrete_rnd (1:2, 1:2, [4 1])), [4, 1])
+%!assert (size (discrete_rnd (1:2, 1:2, 4, 1)), [4, 1])
 
 %% Test class of input preserved
-%!assert(class (discrete_rnd (1:2, 1:2)), "double");
-%!assert(class (discrete_rnd (single(1:2), 1:2)), "single");
+%!assert (class (discrete_rnd (1:2, 1:2)), "double")
+%!assert (class (discrete_rnd (single (1:2), 1:2)), "single")
 ## FIXME: Maybe this should work, maybe it shouldn't.
 #%!assert(class (discrete_rnd (1:2, single(1:2))), "single");
 
 %% Test input validation
 %!error discrete_rnd ()
 %!error discrete_rnd (1)
 %!error discrete_rnd (1:2,1:2, -1)
-%!error discrete_rnd (1:2,1:2, ones(2))
+%!error discrete_rnd (1:2,1:2, ones (2))
 %!error discrete_rnd (1:2,1:2, [2 -1 2])
-%!error discrete_rnd (1:2,1:2, 1, ones(2))
+%!error discrete_rnd (1:2,1:2, 1, ones (2))
 %!error discrete_rnd (1:2,1:2, 1, -1)
 %% test v,p verification
-%!error discrete_rnd (1, ones(2), ones(2,1))
-%!error discrete_rnd (1, ones(2,1), ones(1,1))
-%!error discrete_rnd (1, ones(2,1), [1 -1])
-%!error discrete_rnd (1, ones(2,1), [1 NaN])
-%!error discrete_rnd (1, ones(2,1), [0  0])
+%!error discrete_rnd (1, ones (2), ones (2,1))
+%!error discrete_rnd (1, ones (2,1), ones (1,1))
+%!error discrete_rnd (1, ones (2,1), [1 -1])
+%!error discrete_rnd (1, ones (2,1), [1 NaN])
+%!error discrete_rnd (1, ones (2,1), [0  0])
 
diff --git a/scripts/statistics/distributions/empirical_cdf.m b/scripts/statistics/distributions/empirical_cdf.m
--- a/scripts/statistics/distributions/empirical_cdf.m
+++ b/scripts/statistics/distributions/empirical_cdf.m
@@ -41,22 +41,22 @@ function cdf = empirical_cdf (x, data)
 
 endfunction
 
 
 %!shared x,v,y
 %! x = [-1 0.1 1.1 1.9 3];
 %! v = 0.1:0.2:1.9;
 %! y = [0 0.1 0.6 1 1];
-%!assert(empirical_cdf (x, v), y, eps);
-%!assert(empirical_cdf ([x(1) NaN x(3:5)], v), [0 NaN 0.6 1 1], eps);
+%!assert (empirical_cdf (x, v), y, eps)
+%!assert (empirical_cdf ([x(1) NaN x(3:5)], v), [0 NaN 0.6 1 1], eps)
 
 %% Test class of input preserved
-%!assert(empirical_cdf ([x, NaN], v), [y, NaN], eps);
-%!assert(empirical_cdf (single([x, NaN]), v), single([y, NaN]), eps);
-%!assert(empirical_cdf ([x, NaN], single(v)), single([y, NaN]), eps);
+%!assert (empirical_cdf ([x, NaN], v), [y, NaN], eps)
+%!assert (empirical_cdf (single ([x, NaN]), v), single ([y, NaN]), eps)
+%!assert (empirical_cdf ([x, NaN], single (v)), single ([y, NaN]), eps)
 
 %% Test input validation
 %!error empirical_cdf ()
 %!error empirical_cdf (1)
 %!error empirical_cdf (1,2,3)
-%!error empirical_cdf (1, ones(2))
+%!error empirical_cdf (1, ones (2))
 
diff --git a/scripts/statistics/distributions/empirical_inv.m b/scripts/statistics/distributions/empirical_inv.m
--- a/scripts/statistics/distributions/empirical_inv.m
+++ b/scripts/statistics/distributions/empirical_inv.m
@@ -41,21 +41,21 @@ function inv = empirical_inv (x, data)
 
 endfunction
 
 
 %!shared x,v,y
 %! x = [-1 0 0.1 0.5 1 2];
 %! v = 0.1:0.2:1.9;
 %! y = [NaN v(1) v(1) v(end/2) v(end) NaN];
-%!assert(empirical_inv (x, v), y, eps);
+%!assert (empirical_inv (x, v), y, eps)
 
 %% Test class of input preserved
-%!assert(empirical_inv ([x, NaN], v), [y, NaN], eps);
-%!assert(empirical_inv (single([x, NaN]), v), single([y, NaN]), eps);
-%!assert(empirical_inv ([x, NaN], single(v)), single([y, NaN]), eps);
+%!assert (empirical_inv ([x, NaN], v), [y, NaN], eps)
+%!assert (empirical_inv (single ([x, NaN]), v), single ([y, NaN]), eps)
+%!assert (empirical_inv ([x, NaN], single (v)), single ([y, NaN]), eps)
 
 %% Test input validation
 %!error empirical_inv ()
 %!error empirical_inv (1)
 %!error empirical_inv (1,2,3)
-%!error empirical_inv (1, ones(2))
+%!error empirical_inv (1, ones (2))
 
diff --git a/scripts/statistics/distributions/empirical_pdf.m b/scripts/statistics/distributions/empirical_pdf.m
--- a/scripts/statistics/distributions/empirical_pdf.m
+++ b/scripts/statistics/distributions/empirical_pdf.m
@@ -41,20 +41,20 @@ function pdf = empirical_pdf (x, data)
 
 endfunction
 
 
 %!shared x,v,y
 %! x = [-1 0.1 1.1 1.9 3];
 %! v = 0.1:0.2:1.9;
 %! y = [0 0.1 0.1 0.1 0];
-%!assert(empirical_pdf (x, v), y);
+%!assert (empirical_pdf (x, v), y)
 
 %% Test class of input preserved
-%!assert(empirical_pdf (single(x), v), single (y));
-%!assert(empirical_pdf (x, single(v)), single (y));
+%!assert (empirical_pdf (single (x), v), single (y))
+%!assert (empirical_pdf (x, single (v)), single (y))
 
 %% Test input validation
 %!error empirical_pdf ()
 %!error empirical_pdf (1)
 %!error empirical_pdf (1,2,3)
-%!error empirical_inv (1, ones(2))
+%!error empirical_inv (1, ones (2))
 
diff --git a/scripts/statistics/distributions/empirical_rnd.m b/scripts/statistics/distributions/empirical_rnd.m
--- a/scripts/statistics/distributions/empirical_rnd.m
+++ b/scripts/statistics/distributions/empirical_rnd.m
@@ -48,22 +48,22 @@ function rnd = empirical_rnd (data, vara
     error ("empirical_rnd: DATA must be a vector");
   endif
 
   rnd = discrete_rnd (data, ones (size (data)), varargin{:});
 
 endfunction
 
 
-%!assert(size (empirical_rnd (ones (3, 1))), [3, 1]);
-%!assert(size (empirical_rnd (1:2, [4 1])), [4, 1]);
-%!assert(size (empirical_rnd (1:2, 4, 1)), [4, 1]);
+%!assert (size (empirical_rnd (ones (3, 1))), [3, 1])
+%!assert (size (empirical_rnd (1:2, [4 1])), [4, 1])
+%!assert (size (empirical_rnd (1:2, 4, 1)), [4, 1])
 
 %% Test class of input preserved
-%!assert(class (empirical_rnd (1:2, 1)), "double");
-%!assert(class (empirical_rnd (single(1:2), 1)), "single");
+%!assert (class (empirical_rnd (1:2, 1)), "double")
+%!assert (class (empirical_rnd (single (1:2), 1)), "single")
 
 %% Test input validation
 %!error empirical_rnd ()
-%!error empirical_rnd (ones(2), 1)
+%!error empirical_rnd (ones (2), 1)
 %% test data verification
-%!error empirical_rnd (ones(2), 1, 1)
+%!error empirical_rnd (ones (2), 1, 1)
 
diff --git a/scripts/statistics/distributions/expcdf.m b/scripts/statistics/distributions/expcdf.m
--- a/scripts/statistics/distributions/expcdf.m
+++ b/scripts/statistics/distributions/expcdf.m
@@ -66,26 +66,26 @@ function cdf = expcdf (x, lambda)
   endif
 
 endfunction
 
 
 %!shared x,y
 %! x = [-1 0 0.5 1 Inf];
 %! y = [0, 1 - exp(-x(2:end)/2)];
-%!assert(expcdf (x, 2*ones(1,5)), y);
-%!assert(expcdf (x, 2), y);
-%!assert(expcdf (x, 2*[1 0 NaN 1 1]), [y(1) NaN NaN y(4:5)]);
+%!assert (expcdf (x, 2*ones (1,5)), y)
+%!assert (expcdf (x, 2), y)
+%!assert (expcdf (x, 2*[1 0 NaN 1 1]), [y(1) NaN NaN y(4:5)])
 
 %% Test class of input preserved
-%!assert(expcdf ([x, NaN], 2), [y, NaN]);
-%!assert(expcdf (single([x, NaN]), 2), single([y, NaN]));
-%!assert(expcdf ([x, NaN], single(2)), single([y, NaN]));
+%!assert (expcdf ([x, NaN], 2), [y, NaN])
+%!assert (expcdf (single ([x, NaN]), 2), single ([y, NaN]))
+%!assert (expcdf ([x, NaN], single (2)), single ([y, NaN]))
 
 %% Test input validation
 %!error expcdf ()
 %!error expcdf (1)
 %!error expcdf (1,2,3)
-%!error expcdf (ones(3),ones(2))
-%!error expcdf (ones(2),ones(3))
+%!error expcdf (ones (3), ones (2))
+%!error expcdf (ones (2), ones (3))
 %!error expcdf (i, 2)
 %!error expcdf (2, i)
 
diff --git a/scripts/statistics/distributions/expinv.m b/scripts/statistics/distributions/expinv.m
--- a/scripts/statistics/distributions/expinv.m
+++ b/scripts/statistics/distributions/expinv.m
@@ -69,27 +69,27 @@ function inv = expinv (x, lambda)
     inv(k) = - lambda(k) .* log (1 - x(k));
   endif
 
 endfunction
 
 
 %!shared x
 %! x = [-1 0 0.3934693402873666 1 2];
-%!assert(expinv (x, 2*ones(1,5)), [NaN 0 1 Inf NaN], eps);
-%!assert(expinv (x, 2), [NaN 0 1 Inf NaN], eps);
-%!assert(expinv (x, 2*[1 0 NaN 1 1]), [NaN NaN NaN Inf NaN], eps);
-%!assert(expinv ([x(1:2) NaN x(4:5)], 2), [NaN 0 NaN Inf NaN], eps);
+%!assert (expinv (x, 2*ones (1,5)), [NaN 0 1 Inf NaN], eps)
+%!assert (expinv (x, 2), [NaN 0 1 Inf NaN], eps)
+%!assert (expinv (x, 2*[1 0 NaN 1 1]), [NaN NaN NaN Inf NaN], eps)
+%!assert (expinv ([x(1:2) NaN x(4:5)], 2), [NaN 0 NaN Inf NaN], eps)
 
 %% Test class of input preserved
-%!assert(expinv ([x, NaN], 2), [NaN 0 1 Inf NaN NaN], eps);
-%!assert(expinv (single([x, NaN]), 2), single([NaN 0 1 Inf NaN NaN]), eps);
-%!assert(expinv ([x, NaN], single(2)), single([NaN 0 1 Inf NaN NaN]), eps);
+%!assert (expinv ([x, NaN], 2), [NaN 0 1 Inf NaN NaN], eps)
+%!assert (expinv (single ([x, NaN]), 2), single ([NaN 0 1 Inf NaN NaN]), eps)
+%!assert (expinv ([x, NaN], single (2)), single ([NaN 0 1 Inf NaN NaN]), eps)
 
 %% Test input validation
 %!error expinv ()
 %!error expinv (1)
 %!error expinv (1,2,3)
-%!error expinv (ones(3),ones(2))
-%!error expinv (ones(2),ones(3))
+%!error expinv (ones (3), ones (2))
+%!error expinv (ones (2), ones (3))
 %!error expinv (i, 2)
 %!error expinv (2, i)
 
diff --git a/scripts/statistics/distributions/exppdf.m b/scripts/statistics/distributions/exppdf.m
--- a/scripts/statistics/distributions/exppdf.m
+++ b/scripts/statistics/distributions/exppdf.m
@@ -60,25 +60,25 @@ function pdf = exppdf (x, lambda)
   endif
 
 endfunction
 
 
 %!shared x,y
 %! x = [-1 0 0.5 1 Inf];
 %! y = gampdf (x, 1, 2);
-%!assert(exppdf (x, 2*ones(1,5)), y);
-%!assert(exppdf (x, 2*[1 0 NaN 1 1]), [y(1) NaN NaN y(4:5)]);
-%!assert(exppdf ([x, NaN], 2), [y, NaN]);
+%!assert (exppdf (x, 2*ones (1,5)), y)
+%!assert (exppdf (x, 2*[1 0 NaN 1 1]), [y(1) NaN NaN y(4:5)])
+%!assert (exppdf ([x, NaN], 2), [y, NaN])
 
 %% Test class of input preserved
-%!assert(exppdf (single([x, NaN]), 2), single([y, NaN]));
-%!assert(exppdf ([x, NaN], single(2)), single([y, NaN]));
+%!assert (exppdf (single ([x, NaN]), 2), single ([y, NaN]))
+%!assert (exppdf ([x, NaN], single (2)), single ([y, NaN]))
 
 %% Test input validation
 %!error exppdf ()
 %!error exppdf (1)
 %!error exppdf (1,2,3)
-%!error exppdf (ones(3),ones(2))
-%!error exppdf (ones(2),ones(3))
+%!error exppdf (ones (3), ones (2))
+%!error exppdf (ones (2), ones (3))
 %!error exppdf (i, 2)
 %!error exppdf (2, i)
 
diff --git a/scripts/statistics/distributions/exprnd.m b/scripts/statistics/distributions/exprnd.m
--- a/scripts/statistics/distributions/exprnd.m
+++ b/scripts/statistics/distributions/exprnd.m
@@ -86,32 +86,32 @@ function rnd = exprnd (lambda, varargin)
 
     k = (lambda > 0) & (lambda < Inf);
     rnd(k) = rande (sum (k(:)), 1) .* lambda(k)(:);
   endif
 
 endfunction
 
 
-%!assert(size (exprnd (2)), [1, 1]);
-%!assert(size (exprnd (ones(2,1))), [2, 1]);
-%!assert(size (exprnd (ones(2,2))), [2, 2]);
-%!assert(size (exprnd (1, 3)), [3, 3]);
-%!assert(size (exprnd (1, [4 1])), [4, 1]);
-%!assert(size (exprnd (1, 4, 1)), [4, 1]);
+%!assert (size (exprnd (2)), [1, 1])
+%!assert (size (exprnd (ones (2,1))), [2, 1])
+%!assert (size (exprnd (ones (2,2))), [2, 2])
+%!assert (size (exprnd (1, 3)), [3, 3])
+%!assert (size (exprnd (1, [4 1])), [4, 1])
+%!assert (size (exprnd (1, 4, 1)), [4, 1])
 
 %% Test class of input preserved
-%!assert(class (exprnd (1)), "double");
-%!assert(class (exprnd (single(1))), "single");
-%!assert(class (exprnd (single([1 1]))), "single");
+%!assert (class (exprnd (1)), "double")
+%!assert (class (exprnd (single (1))), "single")
+%!assert (class (exprnd (single ([1 1]))), "single")
 
 %% Test input validation
 %!error exprnd ()
 %!error exprnd (1, -1)
-%!error exprnd (1, ones(2))
+%!error exprnd (1, ones (2))
 %!error exprnd (i)
 %!error exprnd (1, [2 -1 2])
 %!error exprnd (1, 2, -1)
-%!error exprnd (1, 2, ones(2))
-%!error exprnd (ones(2,2), 3)
-%!error exprnd (ones(2,2), [3, 2])
-%!error exprnd (ones(2,2), 2, 3)
+%!error exprnd (1, 2, ones (2))
+%!error exprnd (ones (2,2), 3)
+%!error exprnd (ones (2,2), [3, 2])
+%!error exprnd (ones (2,2), 2, 3)
 
diff --git a/scripts/statistics/distributions/fcdf.m b/scripts/statistics/distributions/fcdf.m
--- a/scripts/statistics/distributions/fcdf.m
+++ b/scripts/statistics/distributions/fcdf.m
@@ -64,33 +64,33 @@ function cdf = fcdf (x, m, n)
   endif
 
 endfunction
 
 
 %!shared x,y
 %! x = [-1 0 0.5 1 2 Inf];
 %! y = [0 0 1/3 1/2 2/3 1];
-%!assert(fcdf (x, 2*ones(1,6), 2*ones(1,6)), y, eps);
-%!assert(fcdf (x, 2, 2*ones(1,6)), y, eps);
-%!assert(fcdf (x, 2*ones(1,6), 2), y, eps);
-%!assert(fcdf (x, [0 NaN Inf 2 2 2], 2), [NaN NaN NaN y(4:6)], eps);
-%!assert(fcdf (x, 2, [0 NaN Inf 2 2 2]), [NaN NaN NaN y(4:6)], eps);
-%!assert(fcdf ([x(1:2) NaN x(4:6)], 2, 2), [y(1:2) NaN y(4:6)], eps);
+%!assert (fcdf (x, 2*ones (1,6), 2*ones (1,6)), y, eps)
+%!assert (fcdf (x, 2, 2*ones (1,6)), y, eps)
+%!assert (fcdf (x, 2*ones (1,6), 2), y, eps)
+%!assert (fcdf (x, [0 NaN Inf 2 2 2], 2), [NaN NaN NaN y(4:6)], eps)
+%!assert (fcdf (x, 2, [0 NaN Inf 2 2 2]), [NaN NaN NaN y(4:6)], eps)
+%!assert (fcdf ([x(1:2) NaN x(4:6)], 2, 2), [y(1:2) NaN y(4:6)], eps)
 
 %% Test class of input preserved
-%!assert(fcdf ([x, NaN], 2, 2), [y, NaN], eps);
-%!assert(fcdf (single([x, NaN]), 2, 2), single([y, NaN]), eps("single"));
-%!assert(fcdf ([x, NaN], single(2), 2), single([y, NaN]), eps("single"));
-%!assert(fcdf ([x, NaN], 2, single(2)), single([y, NaN]), eps("single"));
+%!assert (fcdf ([x, NaN], 2, 2), [y, NaN], eps)
+%!assert (fcdf (single ([x, NaN]), 2, 2), single ([y, NaN]), eps ("single"))
+%!assert (fcdf ([x, NaN], single (2), 2), single ([y, NaN]), eps ("single"))
+%!assert (fcdf ([x, NaN], 2, single (2)), single ([y, NaN]), eps ("single"))
 
 %% Test input validation
 %!error fcdf ()
 %!error fcdf (1)
 %!error fcdf (1,2)
 %!error fcdf (1,2,3,4)
-%!error fcdf (ones(3),ones(2),ones(2))
-%!error fcdf (ones(2),ones(3),ones(2))
-%!error fcdf (ones(2),ones(2),ones(3))
+%!error fcdf (ones (3), ones (2), ones (2))
+%!error fcdf (ones (2), ones (3), ones (2))
+%!error fcdf (ones (2), ones (2), ones (3))
 %!error fcdf (i, 2, 2)
 %!error fcdf (2, i, 2)
 %!error fcdf (2, 2, i)
 
diff --git a/scripts/statistics/distributions/finv.m b/scripts/statistics/distributions/finv.m
--- a/scripts/statistics/distributions/finv.m
+++ b/scripts/statistics/distributions/finv.m
@@ -61,33 +61,33 @@ function inv = finv (x, m, n)
               .* n(k) ./ m(k));
   endif
 
 endfunction
 
 
 %!shared x
 %! x = [-1 0 0.5 1 2];
-%!assert(finv (x, 2*ones(1,5), 2*ones(1,5)), [NaN 0 1 Inf NaN]);
-%!assert(finv (x, 2, 2*ones(1,5)), [NaN 0 1 Inf NaN]);
-%!assert(finv (x, 2*ones(1,5), 2), [NaN 0 1 Inf NaN]);
-%!assert(finv (x, [2 -Inf NaN Inf 2], 2), [NaN NaN NaN NaN NaN]);
-%!assert(finv (x, 2, [2 -Inf NaN Inf 2]), [NaN NaN NaN NaN NaN]);
-%!assert(finv ([x(1:2) NaN x(4:5)], 2, 2), [NaN 0 NaN Inf NaN]);
+%!assert (finv (x, 2*ones (1,5), 2*ones (1,5)), [NaN 0 1 Inf NaN])
+%!assert (finv (x, 2, 2*ones (1,5)), [NaN 0 1 Inf NaN])
+%!assert (finv (x, 2*ones (1,5), 2), [NaN 0 1 Inf NaN])
+%!assert (finv (x, [2 -Inf NaN Inf 2], 2), [NaN NaN NaN NaN NaN])
+%!assert (finv (x, 2, [2 -Inf NaN Inf 2]), [NaN NaN NaN NaN NaN])
+%!assert (finv ([x(1:2) NaN x(4:5)], 2, 2), [NaN 0 NaN Inf NaN])
 
 %% Test class of input preserved
-%!assert(finv ([x, NaN], 2, 2), [NaN 0 1 Inf NaN NaN]);
-%!assert(finv (single([x, NaN]), 2, 2), single([NaN 0 1 Inf NaN NaN]));
-%!assert(finv ([x, NaN], single(2), 2), single([NaN 0 1 Inf NaN NaN]));
-%!assert(finv ([x, NaN], 2, single(2)), single([NaN 0 1 Inf NaN NaN]));
+%!assert (finv ([x, NaN], 2, 2), [NaN 0 1 Inf NaN NaN])
+%!assert (finv (single ([x, NaN]), 2, 2), single ([NaN 0 1 Inf NaN NaN]))
+%!assert (finv ([x, NaN], single (2), 2), single ([NaN 0 1 Inf NaN NaN]))
+%!assert (finv ([x, NaN], 2, single (2)), single ([NaN 0 1 Inf NaN NaN]))
 
 %% Test input validation
 %!error finv ()
 %!error finv (1)
 %!error finv (1,2)
 %!error finv (1,2,3,4)
-%!error finv (ones(3),ones(2),ones(2))
-%!error finv (ones(2),ones(3),ones(2))
-%!error finv (ones(2),ones(2),ones(3))
+%!error finv (ones (3), ones (2), ones (2))
+%!error finv (ones (2), ones (3), ones (2))
+%!error finv (ones (2), ones (2), ones (3))
 %!error finv (i, 2, 2)
 %!error finv (2, i, 2)
 %!error finv (2, 2, i)
 
diff --git a/scripts/statistics/distributions/fpdf.m b/scripts/statistics/distributions/fpdf.m
--- a/scripts/statistics/distributions/fpdf.m
+++ b/scripts/statistics/distributions/fpdf.m
@@ -69,37 +69,37 @@ function pdf = fpdf (x, m, n)
 endfunction
 
 
 %% F (x, 1, m) == T distribution (sqrt (x), m) / sqrt (x)
 %!test
 %! x = rand (10,1);
 %! x = x(x > 0.1 & x < 0.9);
 %! y = tpdf (sqrt (x), 2) ./ sqrt (x);
-%! assert(fpdf (x, 1, 2), y, 5*eps);
+%! assert (fpdf (x, 1, 2), y, 5*eps);
 
 %!shared x,y
 %! x = [-1 0 0.5 1 2];
 %! y = [0 0 4/9 1/4 1/9];
-%!assert(fpdf (x, 2*ones(1,5), 2*ones(1,5)), y, eps);
-%!assert(fpdf (x, 2, 2*ones(1,5)), y, eps);
-%!assert(fpdf (x, 2*ones(1,5), 2), y, eps);
-%!assert(fpdf (x, [0 NaN Inf 2 2], 2), [NaN NaN NaN y(4:5)], eps);
-%!assert(fpdf (x, 2, [0 NaN Inf 2 2]), [NaN NaN NaN y(4:5)], eps);
-%!assert(fpdf ([x, NaN], 2, 2), [y, NaN], eps);
+%!assert (fpdf (x, 2*ones (1,5), 2*ones (1,5)), y, eps)
+%!assert (fpdf (x, 2, 2*ones (1,5)), y, eps)
+%!assert (fpdf (x, 2*ones (1,5), 2), y, eps)
+%!assert (fpdf (x, [0 NaN Inf 2 2], 2), [NaN NaN NaN y(4:5)], eps)
+%!assert (fpdf (x, 2, [0 NaN Inf 2 2]), [NaN NaN NaN y(4:5)], eps)
+%!assert (fpdf ([x, NaN], 2, 2), [y, NaN], eps)
 
 %% Test class of input preserved
-%!assert(fpdf (single([x, NaN]), 2, 2), single([y, NaN]), eps("single"));
-%!assert(fpdf ([x, NaN], single(2), 2), single([y, NaN]), eps("single"));
-%!assert(fpdf ([x, NaN], 2, single(2)), single([y, NaN]), eps("single"));
+%!assert (fpdf (single ([x, NaN]), 2, 2), single ([y, NaN]), eps ("single"))
+%!assert (fpdf ([x, NaN], single (2), 2), single ([y, NaN]), eps ("single"))
+%!assert (fpdf ([x, NaN], 2, single (2)), single ([y, NaN]), eps ("single"))
 
 %% Test input validation
 %!error fpdf ()
 %!error fpdf (1)
 %!error fpdf (1,2)
 %!error fpdf (1,2,3,4)
-%!error fpdf (ones(3),ones(2),ones(2))
-%!error fpdf (ones(2),ones(3),ones(2))
-%!error fpdf (ones(2),ones(2),ones(3))
+%!error fpdf (ones (3), ones (2), ones (2))
+%!error fpdf (ones (2), ones (3), ones (2))
+%!error fpdf (ones (2), ones (2), ones (3))
 %!error fpdf (i, 2, 2)
 %!error fpdf (2, i, 2)
 %!error fpdf (2, 2, i)
 
diff --git a/scripts/statistics/distributions/frnd.m b/scripts/statistics/distributions/frnd.m
--- a/scripts/statistics/distributions/frnd.m
+++ b/scripts/statistics/distributions/frnd.m
@@ -93,40 +93,40 @@ function rnd = frnd (m, n, varargin)
 
     k = (m > 0) & (m < Inf) & (n > 0) & (n < Inf);
     rnd(k) = n(k) ./ m(k) .* randg (m(k)/2) ./ randg (n(k)/2);
   endif
 
 endfunction
 
 
-%!assert(size (frnd (1,2)), [1, 1]);
-%!assert(size (frnd (ones(2,1), 2)), [2, 1]);
-%!assert(size (frnd (ones(2,2), 2)), [2, 2]);
-%!assert(size (frnd (1, 2*ones(2,1))), [2, 1]);
-%!assert(size (frnd (1, 2*ones(2,2))), [2, 2]);
-%!assert(size (frnd (1, 2, 3)), [3, 3]);
-%!assert(size (frnd (1, 2, [4 1])), [4, 1]);
-%!assert(size (frnd (1, 2, 4, 1)), [4, 1]);
+%!assert (size (frnd (1,2)), [1, 1])
+%!assert (size (frnd (ones (2,1), 2)), [2, 1])
+%!assert (size (frnd (ones (2,2), 2)), [2, 2])
+%!assert (size (frnd (1, 2*ones (2,1))), [2, 1])
+%!assert (size (frnd (1, 2*ones (2,2))), [2, 2])
+%!assert (size (frnd (1, 2, 3)), [3, 3])
+%!assert (size (frnd (1, 2, [4 1])), [4, 1])
+%!assert (size (frnd (1, 2, 4, 1)), [4, 1])
 
 %% Test class of input preserved
-%!assert(class (frnd (1, 2)), "double");
-%!assert(class (frnd (single(1), 2)), "single");
-%!assert(class (frnd (single([1 1]), 2)), "single");
-%!assert(class (frnd (1, single(2))), "single");
-%!assert(class (frnd (1, single([2 2]))), "single");
+%!assert (class (frnd (1, 2)), "double")
+%!assert (class (frnd (single (1), 2)), "single")
+%!assert (class (frnd (single ([1 1]), 2)), "single")
+%!assert (class (frnd (1, single (2))), "single")
+%!assert (class (frnd (1, single ([2 2]))), "single")
 
 %% Test input validation
 %!error frnd ()
 %!error frnd (1)
-%!error frnd (ones(3),ones(2))
-%!error frnd (ones(2),ones(3))
+%!error frnd (ones (3), ones (2))
+%!error frnd (ones (2), ones (3))
 %!error frnd (i, 2)
 %!error frnd (2, i)
 %!error frnd (1,2, -1)
-%!error frnd (1,2, ones(2))
+%!error frnd (1,2, ones (2))
 %!error frnd (1, 2, [2 -1 2])
-%!error frnd (1,2, 1, ones(2))
+%!error frnd (1,2, 1, ones (2))
 %!error frnd (1,2, 1, -1)
-%!error frnd (ones(2,2), 2, 3)
-%!error frnd (ones(2,2), 2, [3, 2])
-%!error frnd (ones(2,2), 2, 2, 3)
+%!error frnd (ones (2,2), 2, 3)
+%!error frnd (ones (2,2), 2, [3, 2])
+%!error frnd (ones (2,2), 2, 2, 3)
 
diff --git a/scripts/statistics/distributions/gamcdf.m b/scripts/statistics/distributions/gamcdf.m
--- a/scripts/statistics/distributions/gamcdf.m
+++ b/scripts/statistics/distributions/gamcdf.m
@@ -61,31 +61,31 @@ function cdf = gamcdf (x, a, b)
   endif
 
 endfunction
 
 
 %!shared x,y
 %! x = [-1 0 0.5 1 2 Inf];
 %! y = [0, gammainc(x(2:end), 1)];
-%!assert(gamcdf (x, ones(1,6), ones(1,6)), y);
-%!assert(gamcdf (x, 1, ones(1,6)), y);
-%!assert(gamcdf (x, ones(1,6), 1), y);
-%!assert(gamcdf (x, [0 -Inf NaN Inf 1 1], 1), [NaN NaN NaN NaN y(5:6)]);
-%!assert(gamcdf (x, 1, [0 -Inf NaN Inf 1 1]), [NaN NaN NaN NaN y(5:6)]);
-%!assert(gamcdf ([x(1:2) NaN x(4:6)], 1, 1), [y(1:2) NaN y(4:6)]);
+%!assert (gamcdf (x, ones (1,6), ones (1,6)), y)
+%!assert (gamcdf (x, 1, ones (1,6)), y)
+%!assert (gamcdf (x, ones (1,6), 1), y)
+%!assert (gamcdf (x, [0 -Inf NaN Inf 1 1], 1), [NaN NaN NaN NaN y(5:6)])
+%!assert (gamcdf (x, 1, [0 -Inf NaN Inf 1 1]), [NaN NaN NaN NaN y(5:6)])
+%!assert (gamcdf ([x(1:2) NaN x(4:6)], 1, 1), [y(1:2) NaN y(4:6)])
 
 %% Test class of input preserved
-%!assert(gamcdf ([x, NaN], 1, 1), [y, NaN]);
-%!assert(gamcdf (single([x, NaN]), 1, 1), single([y, NaN]), eps("single"));
+%!assert (gamcdf ([x, NaN], 1, 1), [y, NaN])
+%!assert (gamcdf (single ([x, NaN]), 1, 1), single ([y, NaN]), eps ("single"))
 
 %% Test input validation
 %!error gamcdf ()
 %!error gamcdf (1)
 %!error gamcdf (1,2)
 %!error gamcdf (1,2,3,4)
-%!error gamcdf (ones(3),ones(2),ones(2))
-%!error gamcdf (ones(2),ones(3),ones(2))
-%!error gamcdf (ones(2),ones(2),ones(3))
+%!error gamcdf (ones (3), ones (2), ones (2))
+%!error gamcdf (ones (2), ones (3), ones (2))
+%!error gamcdf (ones (2), ones (2), ones (3))
 %!error gamcdf (i, 2, 2)
 %!error gamcdf (2, i, 2)
 %!error gamcdf (2, 2, i)
 
diff --git a/scripts/statistics/distributions/gaminv.m b/scripts/statistics/distributions/gaminv.m
--- a/scripts/statistics/distributions/gaminv.m
+++ b/scripts/statistics/distributions/gaminv.m
@@ -97,33 +97,33 @@ function inv = gaminv (x, a, b)
     inv(k) = y_new;
   endif
 
 endfunction
 
 
 %!shared x
 %! x = [-1 0 0.63212055882855778 1 2];
-%!assert(gaminv (x, ones(1,5), ones(1,5)), [NaN 0 1 Inf NaN], eps);
-%!assert(gaminv (x, 1, ones(1,5)), [NaN 0 1 Inf NaN], eps);
-%!assert(gaminv (x, ones(1,5), 1), [NaN 0 1 Inf NaN], eps);
-%!assert(gaminv (x, [1 -Inf NaN Inf 1], 1), [NaN NaN NaN NaN NaN]);
-%!assert(gaminv (x, 1, [1 -Inf NaN Inf 1]), [NaN NaN NaN NaN NaN]);
-%!assert(gaminv ([x(1:2) NaN x(4:5)], 1, 1), [NaN 0 NaN Inf NaN]);
+%!assert (gaminv (x, ones (1,5), ones (1,5)), [NaN 0 1 Inf NaN], eps)
+%!assert (gaminv (x, 1, ones (1,5)), [NaN 0 1 Inf NaN], eps)
+%!assert (gaminv (x, ones (1,5), 1), [NaN 0 1 Inf NaN], eps)
+%!assert (gaminv (x, [1 -Inf NaN Inf 1], 1), [NaN NaN NaN NaN NaN])
+%!assert (gaminv (x, 1, [1 -Inf NaN Inf 1]), [NaN NaN NaN NaN NaN])
+%!assert (gaminv ([x(1:2) NaN x(4:5)], 1, 1), [NaN 0 NaN Inf NaN])
 
 %% Test class of input preserved
-%!assert(gaminv ([x, NaN], 1, 1), [NaN 0 1 Inf NaN NaN], eps);
-%!assert(gaminv (single([x, NaN]), 1, 1), single([NaN 0 1 Inf NaN NaN]), eps("single"));
-%!assert(gaminv ([x, NaN], single(1), 1), single([NaN 0 1 Inf NaN NaN]), eps("single"));
-%!assert(gaminv ([x, NaN], 1, single(1)), single([NaN 0 1 Inf NaN NaN]), eps("single"));
+%!assert (gaminv ([x, NaN], 1, 1), [NaN 0 1 Inf NaN NaN], eps)
+%!assert (gaminv (single ([x, NaN]), 1, 1), single ([NaN 0 1 Inf NaN NaN]), eps ("single"))
+%!assert (gaminv ([x, NaN], single (1), 1), single ([NaN 0 1 Inf NaN NaN]), eps ("single"))
+%!assert (gaminv ([x, NaN], 1, single (1)), single ([NaN 0 1 Inf NaN NaN]), eps ("single"))
 
 %% Test input validation
 %!error gaminv ()
 %!error gaminv (1)
 %!error gaminv (1,2)
 %!error gaminv (1,2,3,4)
-%!error gaminv (ones(3),ones(2),ones(2))
-%!error gaminv (ones(2),ones(3),ones(2))
-%!error gaminv (ones(2),ones(2),ones(3))
+%!error gaminv (ones (3), ones (2), ones (2))
+%!error gaminv (ones (2), ones (3), ones (2))
+%!error gaminv (ones (2), ones (2), ones (3))
 %!error gaminv (i, 2, 2)
 %!error gaminv (2, i, 2)
 %!error gaminv (2, 2, i)
 
diff --git a/scripts/statistics/distributions/gampdf.m b/scripts/statistics/distributions/gampdf.m
--- a/scripts/statistics/distributions/gampdf.m
+++ b/scripts/statistics/distributions/gampdf.m
@@ -72,32 +72,32 @@ function pdf = gampdf (x, a, b)
   endif
 
 endfunction
 
 
 %!shared x,y
 %! x = [-1 0 0.5 1 Inf];
 %! y = [0 exp(-x(2:end))];
-%!assert(gampdf (x, ones(1,5), ones(1,5)), y);
-%!assert(gampdf (x, 1, ones(1,5)), y);
-%!assert(gampdf (x, ones(1,5), 1), y);
-%!assert(gampdf (x, [0 -Inf NaN Inf 1], 1), [NaN NaN NaN NaN y(5)]);
-%!assert(gampdf (x, 1, [0 -Inf NaN Inf 1]), [NaN NaN NaN 0 y(5)]);
-%!assert(gampdf ([x, NaN], 1, 1), [y, NaN]);
+%!assert (gampdf (x, ones (1,5), ones (1,5)), y)
+%!assert (gampdf (x, 1, ones (1,5)), y)
+%!assert (gampdf (x, ones (1,5), 1), y)
+%!assert (gampdf (x, [0 -Inf NaN Inf 1], 1), [NaN NaN NaN NaN y(5)])
+%!assert (gampdf (x, 1, [0 -Inf NaN Inf 1]), [NaN NaN NaN 0 y(5)])
+%!assert (gampdf ([x, NaN], 1, 1), [y, NaN])
 
 %% Test class of input preserved
-%!assert(gampdf (single([x, NaN]), 1, 1), single([y, NaN]));
-%!assert(gampdf ([x, NaN], single(1), 1), single([y, NaN]));
-%!assert(gampdf ([x, NaN], 1, single(1)), single([y, NaN]));
+%!assert (gampdf (single ([x, NaN]), 1, 1), single ([y, NaN]))
+%!assert (gampdf ([x, NaN], single (1), 1), single ([y, NaN]))
+%!assert (gampdf ([x, NaN], 1, single (1)), single ([y, NaN]))
 
 %% Test input validation
 %!error gampdf ()
 %!error gampdf (1)
 %!error gampdf (1,2)
 %!error gampdf (1,2,3,4)
-%!error gampdf (ones(3),ones(2),ones(2))
-%!error gampdf (ones(2),ones(3),ones(2))
-%!error gampdf (ones(2),ones(2),ones(3))
+%!error gampdf (ones (3), ones (2), ones (2))
+%!error gampdf (ones (2), ones (3), ones (2))
+%!error gampdf (ones (2), ones (2), ones (3))
 %!error gampdf (i, 2, 2)
 %!error gampdf (2, i, 2)
 %!error gampdf (2, 2, i)
 
diff --git a/scripts/statistics/distributions/gamrnd.m b/scripts/statistics/distributions/gamrnd.m
--- a/scripts/statistics/distributions/gamrnd.m
+++ b/scripts/statistics/distributions/gamrnd.m
@@ -96,40 +96,40 @@ function rnd = gamrnd (a, b, varargin)
 
     k = (a > 0) & (a < Inf) & (b > 0) & (b < Inf);
     rnd(k) = b(k) .* randg (a(k));
   endif
 
 endfunction
 
 
-%!assert(size (gamrnd (1,2)), [1, 1]);
-%!assert(size (gamrnd (ones(2,1), 2)), [2, 1]);
-%!assert(size (gamrnd (ones(2,2), 2)), [2, 2]);
-%!assert(size (gamrnd (1, 2*ones(2,1))), [2, 1]);
-%!assert(size (gamrnd (1, 2*ones(2,2))), [2, 2]);
-%!assert(size (gamrnd (1, 2, 3)), [3, 3]);
-%!assert(size (gamrnd (1, 2, [4 1])), [4, 1]);
-%!assert(size (gamrnd (1, 2, 4, 1)), [4, 1]);
+%!assert (size (gamrnd (1,2)), [1, 1])
+%!assert (size (gamrnd (ones (2,1), 2)), [2, 1])
+%!assert (size (gamrnd (ones (2,2), 2)), [2, 2])
+%!assert (size (gamrnd (1, 2*ones (2,1))), [2, 1])
+%!assert (size (gamrnd (1, 2*ones (2,2))), [2, 2])
+%!assert (size (gamrnd (1, 2, 3)), [3, 3])
+%!assert (size (gamrnd (1, 2, [4 1])), [4, 1])
+%!assert (size (gamrnd (1, 2, 4, 1)), [4, 1])
 
 %% Test class of input preserved
-%!assert(class (gamrnd (1, 2)), "double");
-%!assert(class (gamrnd (single(1), 2)), "single");
-%!assert(class (gamrnd (single([1 1]), 2)), "single");
-%!assert(class (gamrnd (1, single(2))), "single");
-%!assert(class (gamrnd (1, single([2 2]))), "single");
+%!assert (class (gamrnd (1, 2)), "double")
+%!assert (class (gamrnd (single (1), 2)), "single")
+%!assert (class (gamrnd (single ([1 1]), 2)), "single")
+%!assert (class (gamrnd (1, single (2))), "single")
+%!assert (class (gamrnd (1, single ([2 2]))), "single")
 
 %% Test input validation
 %!error gamrnd ()
 %!error gamrnd (1)
-%!error gamrnd (ones(3),ones(2))
-%!error gamrnd (ones(2),ones(3))
+%!error gamrnd (ones (3), ones (2))
+%!error gamrnd (ones (2), ones (3))
 %!error gamrnd (i, 2)
 %!error gamrnd (2, i)
 %!error gamrnd (1,2, -1)
-%!error gamrnd (1,2, ones(2))
+%!error gamrnd (1,2, ones (2))
 %!error gamrnd (1, 2, [2 -1 2])
-%!error gamrnd (1,2, 1, ones(2))
+%!error gamrnd (1,2, 1, ones (2))
 %!error gamrnd (1,2, 1, -1)
-%!error gamrnd (ones(2,2), 2, 3)
-%!error gamrnd (ones(2,2), 2, [3, 2])
-%!error gamrnd (ones(2,2), 2, 2, 3)
+%!error gamrnd (ones (2,2), 2, 3)
+%!error gamrnd (ones (2,2), 2, [3, 2])
+%!error gamrnd (ones (2,2), 2, 2, 3)
 
diff --git a/scripts/statistics/distributions/geocdf.m b/scripts/statistics/distributions/geocdf.m
--- a/scripts/statistics/distributions/geocdf.m
+++ b/scripts/statistics/distributions/geocdf.m
@@ -63,27 +63,27 @@ function cdf = geocdf (x, p)
   endif
 
 endfunction
 
 
 %!shared x,y
 %! x = [-1 0 1 Inf];
 %! y = [0 0.5 0.75 1];
-%!assert(geocdf (x, 0.5*ones(1,4)), y);
-%!assert(geocdf (x, 0.5), y);
-%!assert(geocdf (x, 0.5*[-1 NaN 4 1]), [NaN NaN NaN y(4)]);
-%!assert(geocdf ([x(1:2) NaN x(4)], 0.5), [y(1:2) NaN y(4)]);
+%!assert (geocdf (x, 0.5*ones (1,4)), y)
+%!assert (geocdf (x, 0.5), y)
+%!assert (geocdf (x, 0.5*[-1 NaN 4 1]), [NaN NaN NaN y(4)])
+%!assert (geocdf ([x(1:2) NaN x(4)], 0.5), [y(1:2) NaN y(4)])
 
 %% Test class of input preserved
-%!assert(geocdf ([x, NaN], 0.5), [y, NaN]);
-%!assert(geocdf (single([x, NaN]), 0.5), single([y, NaN]));
-%!assert(geocdf ([x, NaN], single(0.5)), single([y, NaN]));
+%!assert (geocdf ([x, NaN], 0.5), [y, NaN])
+%!assert (geocdf (single ([x, NaN]), 0.5), single ([y, NaN]))
+%!assert (geocdf ([x, NaN], single (0.5)), single ([y, NaN]))
 
 %% Test input validation
 %!error geocdf ()
 %!error geocdf (1)
 %!error geocdf (1,2,3)
-%!error geocdf (ones(3),ones(2))
-%!error geocdf (ones(2),ones(3))
+%!error geocdf (ones (3), ones (2))
+%!error geocdf (ones (2), ones (3))
 %!error geocdf (i, 2)
 %!error geocdf (2, i)
 
diff --git a/scripts/statistics/distributions/geoinv.m b/scripts/statistics/distributions/geoinv.m
--- a/scripts/statistics/distributions/geoinv.m
+++ b/scripts/statistics/distributions/geoinv.m
@@ -59,27 +59,27 @@ function inv = geoinv (x, p)
     inv(k) = max (ceil (log (1 - x(k)) ./ log (1 - p(k))) - 1, 0);
   endif
 
 endfunction
 
 
 %!shared x
 %! x = [-1 0 0.75 1 2];
-%!assert(geoinv (x, 0.5*ones(1,5)), [NaN 0 1 Inf NaN]);
-%!assert(geoinv (x, 0.5), [NaN 0 1 Inf NaN]);
-%!assert(geoinv (x, 0.5*[1 -1 NaN 4 1]), [NaN NaN NaN NaN NaN]);
-%!assert(geoinv ([x(1:2) NaN x(4:5)], 0.5), [NaN 0 NaN Inf NaN]);
+%!assert (geoinv (x, 0.5*ones (1,5)), [NaN 0 1 Inf NaN])
+%!assert (geoinv (x, 0.5), [NaN 0 1 Inf NaN])
+%!assert (geoinv (x, 0.5*[1 -1 NaN 4 1]), [NaN NaN NaN NaN NaN])
+%!assert (geoinv ([x(1:2) NaN x(4:5)], 0.5), [NaN 0 NaN Inf NaN])
 
 %% Test class of input preserved
-%!assert(geoinv ([x, NaN], 0.5), [NaN 0 1 Inf NaN NaN]);
-%!assert(geoinv (single([x, NaN]), 0.5), single([NaN 0 1 Inf NaN NaN]));
-%!assert(geoinv ([x, NaN], single(0.5)), single([NaN 0 1 Inf NaN NaN]));
+%!assert (geoinv ([x, NaN], 0.5), [NaN 0 1 Inf NaN NaN])
+%!assert (geoinv (single ([x, NaN]), 0.5), single ([NaN 0 1 Inf NaN NaN]))
+%!assert (geoinv ([x, NaN], single (0.5)), single ([NaN 0 1 Inf NaN NaN]))
 
 %% Test input validation
 %!error geoinv ()
 %!error geoinv (1)
 %!error geoinv (1,2,3)
-%!error geoinv (ones(3),ones(2))
-%!error geoinv (ones(2),ones(3))
+%!error geoinv (ones (3), ones (2))
+%!error geoinv (ones (2), ones (3))
 %!error geoinv (i, 2)
 %!error geoinv (2, i)
 
diff --git a/scripts/statistics/distributions/geopdf.m b/scripts/statistics/distributions/geopdf.m
--- a/scripts/statistics/distributions/geopdf.m
+++ b/scripts/statistics/distributions/geopdf.m
@@ -60,26 +60,26 @@ function pdf = geopdf (x, p)
   endif
 
 endfunction
 
 
 %!shared x,y
 %! x = [-1 0 1 Inf];
 %! y = [0, 1/2, 1/4, NaN];
-%!assert(geopdf (x, 0.5*ones(1,4)), y);
-%!assert(geopdf (x, 0.5), y);
-%!assert(geopdf (x, 0.5*[-1 NaN 4 1]), [NaN NaN NaN y(4)]);
-%!assert(geopdf ([x, NaN], 0.5), [y, NaN]);
+%!assert (geopdf (x, 0.5*ones (1,4)), y)
+%!assert (geopdf (x, 0.5), y)
+%!assert (geopdf (x, 0.5*[-1 NaN 4 1]), [NaN NaN NaN y(4)])
+%!assert (geopdf ([x, NaN], 0.5), [y, NaN])
 
 %% Test class of input preserved
-%!assert(geopdf (single([x, NaN]), 0.5), single([y, NaN]), 5*eps("single"));
-%!assert(geopdf ([x, NaN], single(0.5)), single([y, NaN]), 5*eps("single"));
+%!assert (geopdf (single ([x, NaN]), 0.5), single ([y, NaN]), 5*eps ("single"))
+%!assert (geopdf ([x, NaN], single (0.5)), single ([y, NaN]), 5*eps ("single"))
 
 %% Test input validation
 %!error geopdf ()
 %!error geopdf (1)
 %!error geopdf (1,2,3)
-%!error geopdf (ones(3),ones(2))
-%!error geopdf (ones(2),ones(3))
+%!error geopdf (ones (3), ones (2))
+%!error geopdf (ones (2), ones (3))
 %!error geopdf (i, 2)
 %!error geopdf (2, i)
 
diff --git a/scripts/statistics/distributions/geornd.m b/scripts/statistics/distributions/geornd.m
--- a/scripts/statistics/distributions/geornd.m
+++ b/scripts/statistics/distributions/geornd.m
@@ -93,33 +93,33 @@ function rnd = geornd (p, varargin)
 
     k = (p == 0);
     rnd(k) = Inf;
   endif
 
 endfunction
 
 
-%!assert(size (geornd (0.5)), [1, 1]);
-%!assert(size (geornd (0.5*ones(2,1))), [2, 1]);
-%!assert(size (geornd (0.5*ones(2,2))), [2, 2]);
-%!assert(size (geornd (0.5, 3)), [3, 3]);
-%!assert(size (geornd (0.5, [4 1])), [4, 1]);
-%!assert(size (geornd (0.5, 4, 1)), [4, 1]);
+%!assert (size (geornd (0.5)), [1, 1])
+%!assert (size (geornd (0.5*ones (2,1))), [2, 1])
+%!assert (size (geornd (0.5*ones (2,2))), [2, 2])
+%!assert (size (geornd (0.5, 3)), [3, 3])
+%!assert (size (geornd (0.5, [4 1])), [4, 1])
+%!assert (size (geornd (0.5, 4, 1)), [4, 1])
 
 %% Test class of input preserved
-%!assert(class (geornd (0.5)), "double");
-%!assert(class (geornd (single(0.5))), "single");
-%!assert(class (geornd (single([0.5 0.5]))), "single");
-%!assert(class (geornd (single(0))), "single");
-%!assert(class (geornd (single(1))), "single");
+%!assert (class (geornd (0.5)), "double")
+%!assert (class (geornd (single (0.5))), "single")
+%!assert (class (geornd (single ([0.5 0.5]))), "single")
+%!assert (class (geornd (single (0))), "single")
+%!assert (class (geornd (single (1))), "single")
 
 %% Test input validation
 %!error geornd ()
-%!error geornd (ones(3),ones(2))
-%!error geornd (ones(2),ones(3))
+%!error geornd (ones (3), ones (2))
+%!error geornd (ones (2), ones (3))
 %!error geornd (i)
 %!error geornd (1, -1)
-%!error geornd (1, ones(2))
+%!error geornd (1, ones (2))
 %!error geornd (1, [2 -1 2])
-%!error geornd (ones(2,2), 2, 3)
-%!error geornd (ones(2,2), 3, 2)
+%!error geornd (ones (2,2), 2, 3)
+%!error geornd (ones (2,2), 3, 2)
 
diff --git a/scripts/statistics/distributions/hygecdf.m b/scripts/statistics/distributions/hygecdf.m
--- a/scripts/statistics/distributions/hygecdf.m
+++ b/scripts/statistics/distributions/hygecdf.m
@@ -71,39 +71,39 @@ function cdf = hygecdf (x, t, m, n)
   endif
 
 endfunction
 
 
 %!shared x,y
 %! x = [-1 0 1 2 3];
 %! y = [0 1/6 5/6 1 1];
-%!assert(hygecdf (x, 4*ones(1,5), 2, 2), y, eps);
-%!assert(hygecdf (x, 4, 2*ones(1,5), 2), y, eps);
-%!assert(hygecdf (x, 4, 2, 2*ones(1,5)), y, eps);
-%!assert(hygecdf (x, 4*[1 -1 NaN 1.1 1], 2, 2), [y(1) NaN NaN NaN y(5)], eps);
-%!assert(hygecdf (x, 4, 2*[1 -1 NaN 1.1 1], 2), [y(1) NaN NaN NaN y(5)], eps);
-%!assert(hygecdf (x, 4, 5, 2), [NaN NaN NaN NaN NaN]);
-%!assert(hygecdf (x, 4, 2, 2*[1 -1 NaN 1.1 1]), [y(1) NaN NaN NaN y(5)], eps);
-%!assert(hygecdf (x, 4, 2, 5), [NaN NaN NaN NaN NaN]);
-%!assert(hygecdf ([x(1:2) NaN x(4:5)], 4, 2, 2), [y(1:2) NaN y(4:5)], eps);
+%!assert (hygecdf (x, 4*ones (1,5), 2, 2), y, eps)
+%!assert (hygecdf (x, 4, 2*ones (1,5), 2), y, eps)
+%!assert (hygecdf (x, 4, 2, 2*ones (1,5)), y, eps)
+%!assert (hygecdf (x, 4*[1 -1 NaN 1.1 1], 2, 2), [y(1) NaN NaN NaN y(5)], eps)
+%!assert (hygecdf (x, 4, 2*[1 -1 NaN 1.1 1], 2), [y(1) NaN NaN NaN y(5)], eps)
+%!assert (hygecdf (x, 4, 5, 2), [NaN NaN NaN NaN NaN])
+%!assert (hygecdf (x, 4, 2, 2*[1 -1 NaN 1.1 1]), [y(1) NaN NaN NaN y(5)], eps)
+%!assert (hygecdf (x, 4, 2, 5), [NaN NaN NaN NaN NaN])
+%!assert (hygecdf ([x(1:2) NaN x(4:5)], 4, 2, 2), [y(1:2) NaN y(4:5)], eps)
 
 %% Test class of input preserved
-%!assert(hygecdf ([x, NaN], 4, 2, 2), [y, NaN], eps);
-%!assert(hygecdf (single([x, NaN]), 4, 2, 2), single([y, NaN]), eps("single"));
-%!assert(hygecdf ([x, NaN], single(4), 2, 2), single([y, NaN]), eps("single"));
-%!assert(hygecdf ([x, NaN], 4, single(2), 2), single([y, NaN]), eps("single"));
-%!assert(hygecdf ([x, NaN], 4, 2, single(2)), single([y, NaN]), eps("single"));
+%!assert (hygecdf ([x, NaN], 4, 2, 2), [y, NaN], eps)
+%!assert (hygecdf (single ([x, NaN]), 4, 2, 2), single ([y, NaN]), eps ("single"))
+%!assert (hygecdf ([x, NaN], single (4), 2, 2), single ([y, NaN]), eps ("single"))
+%!assert (hygecdf ([x, NaN], 4, single (2), 2), single ([y, NaN]), eps ("single"))
+%!assert (hygecdf ([x, NaN], 4, 2, single (2)), single ([y, NaN]), eps ("single"))
 
 %% Test input validation
 %!error hygecdf ()
 %!error hygecdf (1)
 %!error hygecdf (1,2)
 %!error hygecdf (1,2,3)
 %!error hygecdf (1,2,3,4,5)
-%!error hygecdf (ones(2), ones(3), 1, 1)
-%!error hygecdf (1, ones(2), ones(3), 1)
-%!error hygecdf (1, 1, ones(2), ones(3))
+%!error hygecdf (ones (2), ones (3), 1, 1)
+%!error hygecdf (1, ones (2), ones (3), 1)
+%!error hygecdf (1, 1, ones (2), ones (3))
 %!error hygecdf (i, 2, 2, 2)
 %!error hygecdf (2, i, 2, 2)
 %!error hygecdf (2, 2, i, 2)
 %!error hygecdf (2, 2, 2, i)
 
diff --git a/scripts/statistics/distributions/hygeinv.m b/scripts/statistics/distributions/hygeinv.m
--- a/scripts/statistics/distributions/hygeinv.m
+++ b/scripts/statistics/distributions/hygeinv.m
@@ -75,40 +75,40 @@ function inv = hygeinv (x, t, m, n)
     endfor
   endif
 
 endfunction
 
 
 %!shared x
 %! x = [-1 0 0.5 1 2];
-%!assert(hygeinv (x, 4*ones(1,5), 2*ones(1,5), 2*ones(1,5)), [NaN 0 1 2 NaN]);
-%!assert(hygeinv (x, 4*ones(1,5), 2, 2), [NaN 0 1 2 NaN]);
-%!assert(hygeinv (x, 4, 2*ones(1,5), 2), [NaN 0 1 2 NaN]);
-%!assert(hygeinv (x, 4, 2, 2*ones(1,5)), [NaN 0 1 2 NaN]);
-%!assert(hygeinv (x, 4*[1 -1 NaN 1.1 1], 2, 2), [NaN NaN NaN NaN NaN]);
-%!assert(hygeinv (x, 4, 2*[1 -1 NaN 1.1 1], 2), [NaN NaN NaN NaN NaN]);
-%!assert(hygeinv (x, 4, 5, 2), [NaN NaN NaN NaN NaN]);
-%!assert(hygeinv (x, 4, 2, 2*[1 -1 NaN 1.1 1]), [NaN NaN NaN NaN NaN]);
-%!assert(hygeinv (x, 4, 2, 5), [NaN NaN NaN NaN NaN]);
-%!assert(hygeinv ([x(1:2) NaN x(4:5)], 4, 2, 2), [NaN 0 NaN 2 NaN]);
+%!assert (hygeinv (x, 4*ones (1,5), 2*ones (1,5), 2*ones (1,5)), [NaN 0 1 2 NaN])
+%!assert (hygeinv (x, 4*ones (1,5), 2, 2), [NaN 0 1 2 NaN])
+%!assert (hygeinv (x, 4, 2*ones (1,5), 2), [NaN 0 1 2 NaN])
+%!assert (hygeinv (x, 4, 2, 2*ones (1,5)), [NaN 0 1 2 NaN])
+%!assert (hygeinv (x, 4*[1 -1 NaN 1.1 1], 2, 2), [NaN NaN NaN NaN NaN])
+%!assert (hygeinv (x, 4, 2*[1 -1 NaN 1.1 1], 2), [NaN NaN NaN NaN NaN])
+%!assert (hygeinv (x, 4, 5, 2), [NaN NaN NaN NaN NaN])
+%!assert (hygeinv (x, 4, 2, 2*[1 -1 NaN 1.1 1]), [NaN NaN NaN NaN NaN])
+%!assert (hygeinv (x, 4, 2, 5), [NaN NaN NaN NaN NaN])
+%!assert (hygeinv ([x(1:2) NaN x(4:5)], 4, 2, 2), [NaN 0 NaN 2 NaN])
 
 %% Test class of input preserved
-%!assert(hygeinv ([x, NaN], 4, 2, 2), [NaN 0 1 2 NaN NaN]);
-%!assert(hygeinv (single([x, NaN]), 4, 2, 2), single([NaN 0 1 2 NaN NaN]));
-%!assert(hygeinv ([x, NaN], single(4), 2, 2), single([NaN 0 1 2 NaN NaN]));
-%!assert(hygeinv ([x, NaN], 4, single(2), 2), single([NaN 0 1 2 NaN NaN]));
-%!assert(hygeinv ([x, NaN], 4, 2, single(2)), single([NaN 0 1 2 NaN NaN]));
+%!assert (hygeinv ([x, NaN], 4, 2, 2), [NaN 0 1 2 NaN NaN])
+%!assert (hygeinv (single ([x, NaN]), 4, 2, 2), single ([NaN 0 1 2 NaN NaN]))
+%!assert (hygeinv ([x, NaN], single (4), 2, 2), single ([NaN 0 1 2 NaN NaN]))
+%!assert (hygeinv ([x, NaN], 4, single (2), 2), single ([NaN 0 1 2 NaN NaN]))
+%!assert (hygeinv ([x, NaN], 4, 2, single (2)), single ([NaN 0 1 2 NaN NaN]))
 
 %% Test input validation
 %!error hygeinv ()
 %!error hygeinv (1)
 %!error hygeinv (1,2)
 %!error hygeinv (1,2,3)
 %!error hygeinv (1,2,3,4,5)
-%!error hygeinv (ones(2), ones(3), 1, 1)
-%!error hygeinv (1, ones(2), ones(3), 1)
-%!error hygeinv (1, 1, ones(2), ones(3))
+%!error hygeinv (ones (2), ones (3), 1, 1)
+%!error hygeinv (1, ones (2), ones (3), 1)
+%!error hygeinv (1, 1, ones (2), ones (3))
 %!error hygeinv (i, 2, 2, 2)
 %!error hygeinv (2, i, 2, 2)
 %!error hygeinv (2, 2, i, 2)
 %!error hygeinv (2, 2, 2, i)
 
diff --git a/scripts/statistics/distributions/hygepdf.m b/scripts/statistics/distributions/hygepdf.m
--- a/scripts/statistics/distributions/hygepdf.m
+++ b/scripts/statistics/distributions/hygepdf.m
@@ -75,38 +75,38 @@ function pdf = hygepdf (x, t, m, n)
   endif
 
 endfunction
 
 
 %!shared x,y
 %! x = [-1 0 1 2 3];
 %! y = [0 1/6 4/6 1/6 0];
-%!assert(hygepdf (x, 4*ones(1,5), 2, 2), y);
-%!assert(hygepdf (x, 4, 2*ones(1,5), 2), y);
-%!assert(hygepdf (x, 4, 2, 2*ones(1,5)), y);
-%!assert(hygepdf (x, 4*[1 -1 NaN 1.1 1], 2, 2), [0 NaN NaN NaN 0]);
-%!assert(hygepdf (x, 4, 2*[1 -1 NaN 1.1 1], 2), [0 NaN NaN NaN 0]);
-%!assert(hygepdf (x, 4, 5, 2), [NaN NaN NaN NaN NaN]);
-%!assert(hygepdf (x, 4, 2, 2*[1 -1 NaN 1.1 1]), [0 NaN NaN NaN 0]);
-%!assert(hygepdf (x, 4, 2, 5), [NaN NaN NaN NaN NaN]);
-%!assert(hygepdf ([x, NaN], 4, 2, 2), [y, NaN], eps);
+%!assert (hygepdf (x, 4*ones (1,5), 2, 2), y)
+%!assert (hygepdf (x, 4, 2*ones (1,5), 2), y)
+%!assert (hygepdf (x, 4, 2, 2*ones (1,5)), y)
+%!assert (hygepdf (x, 4*[1 -1 NaN 1.1 1], 2, 2), [0 NaN NaN NaN 0])
+%!assert (hygepdf (x, 4, 2*[1 -1 NaN 1.1 1], 2), [0 NaN NaN NaN 0])
+%!assert (hygepdf (x, 4, 5, 2), [NaN NaN NaN NaN NaN])
+%!assert (hygepdf (x, 4, 2, 2*[1 -1 NaN 1.1 1]), [0 NaN NaN NaN 0])
+%!assert (hygepdf (x, 4, 2, 5), [NaN NaN NaN NaN NaN])
+%!assert (hygepdf ([x, NaN], 4, 2, 2), [y, NaN], eps)
 
 %% Test class of input preserved
-%!assert(hygepdf (single([x, NaN]), 4, 2, 2), single([y, NaN]));
-%!assert(hygepdf ([x, NaN], single(4), 2, 2), single([y, NaN]));
-%!assert(hygepdf ([x, NaN], 4, single(2), 2), single([y, NaN]));
-%!assert(hygepdf ([x, NaN], 4, 2, single(2)), single([y, NaN]));
+%!assert (hygepdf (single ([x, NaN]), 4, 2, 2), single ([y, NaN]))
+%!assert (hygepdf ([x, NaN], single (4), 2, 2), single ([y, NaN]))
+%!assert (hygepdf ([x, NaN], 4, single (2), 2), single ([y, NaN]))
+%!assert (hygepdf ([x, NaN], 4, 2, single (2)), single ([y, NaN]))
 
 %% Test input validation
 %!error hygepdf ()
 %!error hygepdf (1)
 %!error hygepdf (1,2)
 %!error hygepdf (1,2,3)
 %!error hygepdf (1,2,3,4,5)
-%!error hygepdf (1, ones(3),ones(2),ones(2))
-%!error hygepdf (1, ones(2),ones(3),ones(2))
-%!error hygepdf (1, ones(2),ones(2),ones(3))
+%!error hygepdf (1, ones (3), ones (2), ones (2))
+%!error hygepdf (1, ones (2), ones (3), ones (2))
+%!error hygepdf (1, ones (2), ones (2), ones (3))
 %!error hygepdf (i, 2, 2, 2)
 %!error hygepdf (2, i, 2, 2)
 %!error hygepdf (2, 2, i, 2)
 %!error hygepdf (2, 2, 2, i)
 
diff --git a/scripts/statistics/distributions/hygernd.m b/scripts/statistics/distributions/hygernd.m
--- a/scripts/statistics/distributions/hygernd.m
+++ b/scripts/statistics/distributions/hygernd.m
@@ -105,44 +105,44 @@ function rnd = hygernd (t, m, n, varargi
       p = hygepdf (v, t(i), m(i), n(i));
       rnd(i) = v(lookup (cumsum (p(1 : end-1)) / sum (p), rn(i)) + 1);
     endfor
   endif
 
 endfunction
 
 
-%!assert(size (hygernd (4,2,2)), [1, 1]);
-%!assert(size (hygernd (4*ones(2,1), 2,2)), [2, 1]);
-%!assert(size (hygernd (4*ones(2,2), 2,2)), [2, 2]);
-%!assert(size (hygernd (4, 2*ones(2,1), 2)), [2, 1]);
-%!assert(size (hygernd (4, 2*ones(2,2), 2)), [2, 2]);
-%!assert(size (hygernd (4, 2, 2*ones(2,1))), [2, 1]);
-%!assert(size (hygernd (4, 2, 2*ones(2,2))), [2, 2]);
-%!assert(size (hygernd (4, 2, 2, 3)), [3, 3]);
-%!assert(size (hygernd (4, 2, 2, [4 1])), [4, 1]);
-%!assert(size (hygernd (4, 2, 2, 4, 1)), [4, 1]);
+%!assert (size (hygernd (4,2,2)), [1, 1])
+%!assert (size (hygernd (4*ones (2,1), 2,2)), [2, 1])
+%!assert (size (hygernd (4*ones (2,2), 2,2)), [2, 2])
+%!assert (size (hygernd (4, 2*ones (2,1), 2)), [2, 1])
+%!assert (size (hygernd (4, 2*ones (2,2), 2)), [2, 2])
+%!assert (size (hygernd (4, 2, 2*ones (2,1))), [2, 1])
+%!assert (size (hygernd (4, 2, 2*ones (2,2))), [2, 2])
+%!assert (size (hygernd (4, 2, 2, 3)), [3, 3])
+%!assert (size (hygernd (4, 2, 2, [4 1])), [4, 1])
+%!assert (size (hygernd (4, 2, 2, 4, 1)), [4, 1])
 
-%!assert(class (hygernd (4,2,2)), "double");
-%!assert(class (hygernd (single(4),2,2)), "single");
-%!assert(class (hygernd (single([4 4]),2,2)), "single");
-%!assert(class (hygernd (4,single(2),2)), "single");
-%!assert(class (hygernd (4,single([2 2]),2)), "single");
-%!assert(class (hygernd (4,2,single(2))), "single");
-%!assert(class (hygernd (4,2,single([2 2]))), "single");
+%!assert (class (hygernd (4,2,2)), "double")
+%!assert (class (hygernd (single (4),2,2)), "single")
+%!assert (class (hygernd (single ([4 4]),2,2)), "single")
+%!assert (class (hygernd (4,single (2),2)), "single")
+%!assert (class (hygernd (4,single ([2 2]),2)), "single")
+%!assert (class (hygernd (4,2,single (2))), "single")
+%!assert (class (hygernd (4,2,single ([2 2]))), "single")
 
 %% Test input validation
 %!error hygernd ()
 %!error hygernd (1)
 %!error hygernd (1,2)
-%!error hygernd (ones(3),ones(2),ones(2), 2)
-%!error hygernd (ones(2),ones(3),ones(2), 2)
-%!error hygernd (ones(2),ones(2),ones(3), 2)
+%!error hygernd (ones (3), ones (2), ones (2), 2)
+%!error hygernd (ones (2), ones (3), ones (2), 2)
+%!error hygernd (ones (2), ones (2), ones (3), 2)
 %!error hygernd (i, 2, 2)
 %!error hygernd (2, i, 2)
 %!error hygernd (2, 2, i)
 %!error hygernd (4,2,2, -1)
-%!error hygernd (4,2,2, ones(2))
+%!error hygernd (4,2,2, ones (2))
 %!error hygernd (4,2,2, [2 -1 2])
-%!error hygernd (4*ones(2),2,2, 3)
-%!error hygernd (4*ones(2),2,2, [3, 2])
-%!error hygernd (4*ones(2),2,2, 3, 2)
+%!error hygernd (4*ones (2),2,2, 3)
+%!error hygernd (4*ones (2),2,2, [3, 2])
+%!error hygernd (4*ones (2),2,2, 3, 2)
 
diff --git a/scripts/statistics/distributions/kolmogorov_smirnov_cdf.m b/scripts/statistics/distributions/kolmogorov_smirnov_cdf.m
--- a/scripts/statistics/distributions/kolmogorov_smirnov_cdf.m
+++ b/scripts/statistics/distributions/kolmogorov_smirnov_cdf.m
@@ -85,11 +85,11 @@ function cdf = kolmogorov_smirnov_cdf (x
   endif
 
 endfunction
 
 
 %% Test input validation
 %!error kolmogorov_smirnov_cdf ()
 %!error kolmogorov_smirnov_cdf (1,2,3)
-%!error kolmogorov_smirnov_cdf (1, ones(2))
+%!error kolmogorov_smirnov_cdf (1, ones (2))
 %!error kolmogorov_smirnov_cdf ([], 1)
 
diff --git a/scripts/statistics/distributions/laplace_cdf.m b/scripts/statistics/distributions/laplace_cdf.m
--- a/scripts/statistics/distributions/laplace_cdf.m
+++ b/scripts/statistics/distributions/laplace_cdf.m
@@ -39,18 +39,18 @@ function cdf = laplace_cdf (x)
   cdf = (1 + sign (x) .* (1 - exp (- abs (x)))) / 2;
 
 endfunction
 
 
 %!shared x,y
 %! x = [-Inf -log(2) 0 log(2) Inf];
 %! y = [0, 1/4, 1/2, 3/4, 1]; 
-%!assert(laplace_cdf ([x, NaN]), [y, NaN]);
+%!assert (laplace_cdf ([x, NaN]), [y, NaN])
 
 %% Test class of input preserved
-%!assert(laplace_cdf (single([x, NaN])), single([y, NaN]));
+%!assert (laplace_cdf (single ([x, NaN])), single ([y, NaN]))
 
 %% Test input validation
 %!error laplace_cdf ()
 %!error laplace_cdf (1,2)
 %!error laplace_cdf (i)
 
diff --git a/scripts/statistics/distributions/laplace_inv.m b/scripts/statistics/distributions/laplace_inv.m
--- a/scripts/statistics/distributions/laplace_inv.m
+++ b/scripts/statistics/distributions/laplace_inv.m
@@ -46,19 +46,19 @@ function inv = laplace_inv (x)
   inv(k) = ((x(k) < 1/2) .* log (2 * x(k))
             - (x(k) > 1/2) .* log (2 * (1 - x(k))));
 
 endfunction
 
 
 %!shared x
 %! x = [-1 0 0.5 1 2];
-%!assert(laplace_inv (x), [NaN -Inf 0 Inf NaN]);
+%!assert (laplace_inv (x), [NaN -Inf 0 Inf NaN])
 
 %% Test class of input preserved
-%!assert(laplace_inv ([x, NaN]), [NaN -Inf 0 Inf NaN NaN]);
-%!assert(laplace_inv (single([x, NaN])), single([NaN -Inf 0 Inf NaN NaN]));
+%!assert (laplace_inv ([x, NaN]), [NaN -Inf 0 Inf NaN NaN])
+%!assert (laplace_inv (single ([x, NaN])), single ([NaN -Inf 0 Inf NaN NaN]))
 
 %% Test input validation
 %!error laplace_inv ()
 %!error laplace_inv (1,2)
 %!error laplace_inv (i)
 
diff --git a/scripts/statistics/distributions/laplace_pdf.m b/scripts/statistics/distributions/laplace_pdf.m
--- a/scripts/statistics/distributions/laplace_pdf.m
+++ b/scripts/statistics/distributions/laplace_pdf.m
@@ -39,18 +39,18 @@ function pdf = laplace_pdf (x)
   pdf = exp (- abs (x)) / 2;
 
 endfunction
 
 
 %!shared x,y
 %! x = [-Inf -log(2) 0 log(2) Inf];
 %! y = [0, 1/4, 1/2, 1/4, 0]; 
-%!assert(laplace_pdf ([x, NaN]), [y, NaN]);
+%!assert (laplace_pdf ([x, NaN]), [y, NaN])
 
 %% Test class of input preserved
-%!assert(laplace_pdf (single([x, NaN])), single([y, NaN]));
+%!assert (laplace_pdf (single ([x, NaN])), single ([y, NaN]))
 
 %% Test input validation
 %!error laplace_pdf ()
 %!error laplace_pdf (1,2)
 %!error laplace_pdf (i)
 
diff --git a/scripts/statistics/distributions/laplace_rnd.m b/scripts/statistics/distributions/laplace_rnd.m
--- a/scripts/statistics/distributions/laplace_rnd.m
+++ b/scripts/statistics/distributions/laplace_rnd.m
@@ -55,20 +55,20 @@ function rnd = laplace_rnd (varargin)
   endif
 
   tmp = rand (sz);
   rnd = (tmp < 1/2) .* log (2 * tmp) - (tmp > 1/2) .* log (2 * (1 - tmp));
 
 endfunction
 
 
-%!assert(size (laplace_rnd (3)), [3, 3]);
-%!assert(size (laplace_rnd ([4 1])), [4, 1]);
-%!assert(size (laplace_rnd (4,1)), [4, 1]);
+%!assert (size (laplace_rnd (3)), [3, 3])
+%!assert (size (laplace_rnd ([4 1])), [4, 1])
+%!assert (size (laplace_rnd (4,1)), [4, 1])
 
 %% Test input validation
 %!error laplace_rnd ()
 %!error laplace_rnd (-1)
-%!error laplace_rnd (ones(2))
+%!error laplace_rnd (ones (2))
 %!error laplace_rnd ([2 -1 2])
-%!error laplace_rnd (1, ones(2))
+%!error laplace_rnd (1, ones (2))
 %!error laplace_rnd (1, -1)
 
diff --git a/scripts/statistics/distributions/logistic_cdf.m b/scripts/statistics/distributions/logistic_cdf.m
--- a/scripts/statistics/distributions/logistic_cdf.m
+++ b/scripts/statistics/distributions/logistic_cdf.m
@@ -39,18 +39,18 @@ function cdf = logistic_cdf (x)
   cdf = 1 ./ (1 + exp (-x));
 
 endfunction
 
 
 %!shared x,y
 %! x = [-Inf -log(3) 0 log(3) Inf];
 %! y = [0, 1/4, 1/2, 3/4, 1]; 
-%!assert(logistic_cdf ([x, NaN]), [y, NaN], eps);
+%!assert (logistic_cdf ([x, NaN]), [y, NaN], eps)
 
 %% Test class of input preserved
-%!assert(logistic_cdf (single([x, NaN])), single([y, NaN]), eps ("single"));
+%!assert (logistic_cdf (single ([x, NaN])), single ([y, NaN]), eps ("single"))
 
 %% Test input validation
 %!error logistic_cdf ()
 %!error logistic_cdf (1,2)
 %!error logistic_cdf (i)
 
diff --git a/scripts/statistics/distributions/logistic_inv.m b/scripts/statistics/distributions/logistic_inv.m
--- a/scripts/statistics/distributions/logistic_inv.m
+++ b/scripts/statistics/distributions/logistic_inv.m
@@ -51,19 +51,19 @@ function inv = logistic_inv (x)
   k = (x > 0) & (x < 1);
   inv(k) = - log (1 ./ x(k) - 1);
 
 endfunction
 
 
 %!shared x
 %! x = [-1 0 0.5 1 2];
-%!assert(logistic_inv (x), [NaN -Inf 0 Inf NaN]);
+%!assert (logistic_inv (x), [NaN -Inf 0 Inf NaN])
 
 %% Test class of input preserved
-%!assert(logistic_inv ([x, NaN]), [NaN -Inf 0 Inf NaN NaN]);
-%!assert(logistic_inv (single([x, NaN])), single([NaN -Inf 0 Inf NaN NaN]));
+%!assert (logistic_inv ([x, NaN]), [NaN -Inf 0 Inf NaN NaN])
+%!assert (logistic_inv (single ([x, NaN])), single ([NaN -Inf 0 Inf NaN NaN]))
 
 %% Test input validation
 %!error logistic_inv ()
 %!error logistic_inv (1,2)
 %!error logistic_inv (i)
 
diff --git a/scripts/statistics/distributions/logistic_pdf.m b/scripts/statistics/distributions/logistic_pdf.m
--- a/scripts/statistics/distributions/logistic_pdf.m
+++ b/scripts/statistics/distributions/logistic_pdf.m
@@ -39,18 +39,18 @@ function pdf = logistic_pdf (x)
   pdf = cdf .* (1 - cdf);
 
 endfunction
 
 
 %!shared x,y
 %! x = [-Inf -log(4) 0 log(4) Inf];
 %! y = [0, 0.16, 1/4, 0.16, 0]; 
-%!assert(logistic_pdf ([x, NaN]), [y, NaN], eps);
+%!assert (logistic_pdf ([x, NaN]), [y, NaN], eps)
 
 %% Test class of input preserved
-%!assert(logistic_pdf (single([x, NaN])), single([y, NaN]), eps ("single"));
+%!assert (logistic_pdf (single ([x, NaN])), single ([y, NaN]), eps ("single"))
 
 %% Test input validation
 %!error logistic_pdf ()
 %!error logistic_pdf (1,2)
 %!error logistic_pdf (i)
 
diff --git a/scripts/statistics/distributions/logistic_rnd.m b/scripts/statistics/distributions/logistic_rnd.m
--- a/scripts/statistics/distributions/logistic_rnd.m
+++ b/scripts/statistics/distributions/logistic_rnd.m
@@ -54,20 +54,20 @@ function rnd = logistic_rnd (varargin)
     sz = [varargin{:}];
   endif
 
   rnd = - log (1 ./ rand (sz) - 1);
 
 endfunction
 
 
-%!assert(size (logistic_rnd (3)), [3, 3]);
-%!assert(size (logistic_rnd ([4 1])), [4, 1]);
-%!assert(size (logistic_rnd (4,1)), [4, 1]);
+%!assert (size (logistic_rnd (3)), [3, 3])
+%!assert (size (logistic_rnd ([4 1])), [4, 1])
+%!assert (size (logistic_rnd (4,1)), [4, 1])
 
 %% Test input validation
 %!error logistic_rnd ()
 %!error logistic_rnd (-1)
-%!error logistic_rnd (ones(2))
+%!error logistic_rnd (ones (2))
 %!error logistic_rnd ([2 -1 2])
-%!error logistic_rnd (1, ones(2))
+%!error logistic_rnd (1, ones (2))
 %!error logistic_rnd (1, -1)
 
diff --git a/scripts/statistics/distributions/logncdf.m b/scripts/statistics/distributions/logncdf.m
--- a/scripts/statistics/distributions/logncdf.m
+++ b/scripts/statistics/distributions/logncdf.m
@@ -69,32 +69,32 @@ function cdf = logncdf (x, mu = 0, sigma
   endif
 
 endfunction
 
 
 %!shared x,y
 %! x = [-1 0 1 e Inf];
 %! y = [0, 0, 0.5, 1/2+1/2*erf(1/2), 1];
-%!assert(logncdf (x, zeros(1,5), sqrt(2)*ones(1,5)), y);
-%!assert(logncdf (x, 0, sqrt(2)*ones(1,5)), y);
-%!assert(logncdf (x, zeros(1,5), sqrt(2)), y);
-%!assert(logncdf (x, [0 1 NaN 0 1], sqrt(2)), [0 0 NaN y(4:5)]);
-%!assert(logncdf (x, 0, sqrt(2)*[0 NaN Inf 1 1]), [NaN NaN NaN y(4:5)]);
-%!assert(logncdf ([x(1:3) NaN x(5)], 0, sqrt(2)), [y(1:3) NaN y(5)]);
+%!assert (logncdf (x, zeros (1,5), sqrt(2)*ones (1,5)), y)
+%!assert (logncdf (x, 0, sqrt(2)*ones (1,5)), y)
+%!assert (logncdf (x, zeros (1,5), sqrt(2)), y)
+%!assert (logncdf (x, [0 1 NaN 0 1], sqrt(2)), [0 0 NaN y(4:5)])
+%!assert (logncdf (x, 0, sqrt(2)*[0 NaN Inf 1 1]), [NaN NaN NaN y(4:5)])
+%!assert (logncdf ([x(1:3) NaN x(5)], 0, sqrt(2)), [y(1:3) NaN y(5)])
 
 %% Test class of input preserved
-%!assert(logncdf ([x, NaN], 0, sqrt(2)), [y, NaN]);
-%!assert(logncdf (single([x, NaN]), 0, sqrt(2)), single([y, NaN]), eps("single"));
-%!assert(logncdf ([x, NaN], single(0), sqrt(2)), single([y, NaN]), eps("single"));
-%!assert(logncdf ([x, NaN], 0, single(sqrt(2))), single([y, NaN]), eps("single"));
+%!assert (logncdf ([x, NaN], 0, sqrt(2)), [y, NaN])
+%!assert (logncdf (single ([x, NaN]), 0, sqrt(2)), single ([y, NaN]), eps ("single"))
+%!assert (logncdf ([x, NaN], single (0), sqrt(2)), single ([y, NaN]), eps ("single"))
+%!assert (logncdf ([x, NaN], 0, single (sqrt(2))), single ([y, NaN]), eps ("single"))
 
 %% Test input validation
 %!error logncdf ()
 %!error logncdf (1,2)
 %!error logncdf (1,2,3,4)
-%!error logncdf (ones(3),ones(2),ones(2))
-%!error logncdf (ones(2),ones(3),ones(2))
-%!error logncdf (ones(2),ones(2),ones(3))
+%!error logncdf (ones (3), ones (2), ones (2))
+%!error logncdf (ones (2), ones (3), ones (2))
+%!error logncdf (ones (2), ones (2), ones (3))
 %!error logncdf (i, 2, 2)
 %!error logncdf (2, i, 2)
 %!error logncdf (2, 2, i)
 
diff --git a/scripts/statistics/distributions/logninv.m b/scripts/statistics/distributions/logninv.m
--- a/scripts/statistics/distributions/logninv.m
+++ b/scripts/statistics/distributions/logninv.m
@@ -68,32 +68,32 @@ function inv = logninv (x, mu = 0, sigma
     inv(k) = exp (mu(k)) .* exp (sigma(k) .* stdnormal_inv (x(k)));
   endif
 
 endfunction
 
 
 %!shared x
 %! x = [-1 0 0.5 1 2];
-%!assert(logninv (x, ones(1,5), ones(1,5)), [NaN 0 e Inf NaN]);
-%!assert(logninv (x, 1, ones(1,5)), [NaN 0 e Inf NaN]);
-%!assert(logninv (x, ones(1,5), 1), [NaN 0 e Inf NaN]);
-%!assert(logninv (x, [1 1 NaN 0 1], 1), [NaN 0 NaN Inf NaN]);
-%!assert(logninv (x, 1, [1 0 NaN Inf 1]), [NaN NaN NaN NaN NaN]);
-%!assert(logninv ([x(1:2) NaN x(4:5)], 1, 2), [NaN 0 NaN Inf NaN]);
+%!assert (logninv (x, ones (1,5), ones (1,5)), [NaN 0 e Inf NaN])
+%!assert (logninv (x, 1, ones (1,5)), [NaN 0 e Inf NaN])
+%!assert (logninv (x, ones (1,5), 1), [NaN 0 e Inf NaN])
+%!assert (logninv (x, [1 1 NaN 0 1], 1), [NaN 0 NaN Inf NaN])
+%!assert (logninv (x, 1, [1 0 NaN Inf 1]), [NaN NaN NaN NaN NaN])
+%!assert (logninv ([x(1:2) NaN x(4:5)], 1, 2), [NaN 0 NaN Inf NaN])
 
 %% Test class of input preserved
-%!assert(logninv ([x, NaN], 1, 1), [NaN 0 e Inf NaN NaN]);
-%!assert(logninv (single([x, NaN]), 1, 1), single([NaN 0 e Inf NaN NaN]));
-%!assert(logninv ([x, NaN], single(1), 1), single([NaN 0 e Inf NaN NaN]));
-%!assert(logninv ([x, NaN], 1, single(1)), single([NaN 0 e Inf NaN NaN]));
+%!assert (logninv ([x, NaN], 1, 1), [NaN 0 e Inf NaN NaN])
+%!assert (logninv (single ([x, NaN]), 1, 1), single ([NaN 0 e Inf NaN NaN]))
+%!assert (logninv ([x, NaN], single (1), 1), single ([NaN 0 e Inf NaN NaN]))
+%!assert (logninv ([x, NaN], 1, single (1)), single ([NaN 0 e Inf NaN NaN]))
 
 %% Test input validation
 %!error logninv ()
 %!error logninv (1,2)
 %!error logninv (1,2,3,4)
-%!error logninv (ones(3),ones(2),ones(2))
-%!error logninv (ones(2),ones(3),ones(2))
-%!error logninv (ones(2),ones(2),ones(3))
+%!error logninv (ones (3), ones (2), ones (2))
+%!error logninv (ones (2), ones (3), ones (2))
+%!error logninv (ones (2), ones (2), ones (3))
 %!error logninv (i, 2, 2)
 %!error logninv (2, i, 2)
 %!error logninv (2, 2, i)
 
diff --git a/scripts/statistics/distributions/lognpdf.m b/scripts/statistics/distributions/lognpdf.m
--- a/scripts/statistics/distributions/lognpdf.m
+++ b/scripts/statistics/distributions/lognpdf.m
@@ -66,31 +66,31 @@ function pdf = lognpdf (x, mu = 0, sigma
   endif
 
 endfunction
 
 
 %!shared x,y
 %! x = [-1 0 e Inf];
 %! y = [0, 0, 1/(e*sqrt(2*pi)) * exp(-1/2), 0];
-%!assert(lognpdf (x, zeros(1,4), ones(1,4)), y, eps);
-%!assert(lognpdf (x, 0, ones(1,4)), y, eps);
-%!assert(lognpdf (x, zeros(1,4), 1), y, eps);
-%!assert(lognpdf (x, [0 1 NaN 0], 1), [0 0 NaN y(4)], eps);
-%!assert(lognpdf (x, 0, [0 NaN Inf 1]), [NaN NaN NaN y(4)], eps);
-%!assert(lognpdf ([x, NaN], 0, 1), [y, NaN], eps);
+%!assert (lognpdf (x, zeros (1,4), ones (1,4)), y, eps)
+%!assert (lognpdf (x, 0, ones (1,4)), y, eps)
+%!assert (lognpdf (x, zeros (1,4), 1), y, eps)
+%!assert (lognpdf (x, [0 1 NaN 0], 1), [0 0 NaN y(4)], eps)
+%!assert (lognpdf (x, 0, [0 NaN Inf 1]), [NaN NaN NaN y(4)], eps)
+%!assert (lognpdf ([x, NaN], 0, 1), [y, NaN], eps)
 
 %% Test class of input preserved
-%!assert(lognpdf (single([x, NaN]), 0, 1), single([y, NaN]), eps("single"));
-%!assert(lognpdf ([x, NaN], single(0), 1), single([y, NaN]), eps("single"));
-%!assert(lognpdf ([x, NaN], 0, single(1)), single([y, NaN]), eps("single"));
+%!assert (lognpdf (single ([x, NaN]), 0, 1), single ([y, NaN]), eps ("single"))
+%!assert (lognpdf ([x, NaN], single (0), 1), single ([y, NaN]), eps ("single"))
+%!assert (lognpdf ([x, NaN], 0, single (1)), single ([y, NaN]), eps ("single"))
 
 %% Test input validation
 %!error lognpdf ()
 %!error lognpdf (1,2)
 %!error lognpdf (1,2,3,4)
-%!error lognpdf (ones(3),ones(2),ones(2))
-%!error lognpdf (ones(2),ones(3),ones(2))
-%!error lognpdf (ones(2),ones(2),ones(3))
+%!error lognpdf (ones (3), ones (2), ones (2))
+%!error lognpdf (ones (2), ones (3), ones (2))
+%!error lognpdf (ones (2), ones (2), ones (3))
 %!error lognpdf (i, 2, 2)
 %!error lognpdf (2, i, 2)
 %!error lognpdf (2, 2, i)
 
diff --git a/scripts/statistics/distributions/lognrnd.m b/scripts/statistics/distributions/lognrnd.m
--- a/scripts/statistics/distributions/lognrnd.m
+++ b/scripts/statistics/distributions/lognrnd.m
@@ -93,40 +93,40 @@ function rnd = lognrnd (mu, sigma, varar
 
     k = (sigma < 0) | (sigma == Inf);
     rnd(k) = NaN;
   endif
 
 endfunction
 
 
-%!assert(size (lognrnd (1,2)), [1, 1]);
-%!assert(size (lognrnd (ones(2,1), 2)), [2, 1]);
-%!assert(size (lognrnd (ones(2,2), 2)), [2, 2]);
-%!assert(size (lognrnd (1, 2*ones(2,1))), [2, 1]);
-%!assert(size (lognrnd (1, 2*ones(2,2))), [2, 2]);
-%!assert(size (lognrnd (1, 2, 3)), [3, 3]);
-%!assert(size (lognrnd (1, 2, [4 1])), [4, 1]);
-%!assert(size (lognrnd (1, 2, 4, 1)), [4, 1]);
+%!assert (size (lognrnd (1,2)), [1, 1])
+%!assert (size (lognrnd (ones (2,1), 2)), [2, 1])
+%!assert (size (lognrnd (ones (2,2), 2)), [2, 2])
+%!assert (size (lognrnd (1, 2*ones (2,1))), [2, 1])
+%!assert (size (lognrnd (1, 2*ones (2,2))), [2, 2])
+%!assert (size (lognrnd (1, 2, 3)), [3, 3])
+%!assert (size (lognrnd (1, 2, [4 1])), [4, 1])
+%!assert (size (lognrnd (1, 2, 4, 1)), [4, 1])
 
 %% Test class of input preserved
-%!assert(class (lognrnd (1, 2)), "double");
-%!assert(class (lognrnd (single(1), 2)), "single");
-%!assert(class (lognrnd (single([1 1]), 2)), "single");
-%!assert(class (lognrnd (1, single(2))), "single");
-%!assert(class (lognrnd (1, single([2 2]))), "single");
+%!assert (class (lognrnd (1, 2)), "double")
+%!assert (class (lognrnd (single (1), 2)), "single")
+%!assert (class (lognrnd (single ([1 1]), 2)), "single")
+%!assert (class (lognrnd (1, single (2))), "single")
+%!assert (class (lognrnd (1, single ([2 2]))), "single")
 
 %% Test input validation
 %!error lognrnd ()
 %!error lognrnd (1)
-%!error lognrnd (ones(3),ones(2))
-%!error lognrnd (ones(2),ones(3))
+%!error lognrnd (ones (3), ones (2))
+%!error lognrnd (ones (2), ones (3))
 %!error lognrnd (i, 2)
 %!error lognrnd (2, i)
 %!error lognrnd (1,2, -1)
-%!error lognrnd (1,2, ones(2))
+%!error lognrnd (1,2, ones (2))
 %!error lognrnd (1, 2, [2 -1 2])
-%!error lognrnd (1,2, 1, ones(2))
+%!error lognrnd (1,2, 1, ones (2))
 %!error lognrnd (1,2, 1, -1)
-%!error lognrnd (ones(2,2), 2, 3)
-%!error lognrnd (ones(2,2), 2, [3, 2])
-%!error lognrnd (ones(2,2), 2, 2, 3)
+%!error lognrnd (ones (2,2), 2, 3)
+%!error lognrnd (ones (2,2), 2, [3, 2])
+%!error lognrnd (ones (2,2), 2, 2, 3)
 
diff --git a/scripts/statistics/distributions/nbincdf.m b/scripts/statistics/distributions/nbincdf.m
--- a/scripts/statistics/distributions/nbincdf.m
+++ b/scripts/statistics/distributions/nbincdf.m
@@ -73,33 +73,33 @@ function cdf = nbincdf (x, n, p)
   endif
 
 endfunction
 
 
 %!shared x,y
 %! x = [-1 0 1 2 Inf];
 %! y = [0 1/2 3/4 7/8 1];
-%!assert(nbincdf (x, ones(1,5), 0.5*ones(1,5)), y);
-%!assert(nbincdf (x, 1, 0.5*ones(1,5)), y);
-%!assert(nbincdf (x, ones(1,5), 0.5), y);
-%!assert(nbincdf ([x(1:3) 0 x(5)], [0 1 NaN 1.5 Inf], 0.5), [NaN 1/2 NaN nbinpdf(0,1.5,0.5) NaN], eps);
-%!assert(nbincdf (x, 1, 0.5*[-1 NaN 4 1 1]), [NaN NaN NaN y(4:5)]);
-%!assert(nbincdf ([x(1:2) NaN x(4:5)], 1, 0.5), [y(1:2) NaN y(4:5)]);
+%!assert (nbincdf (x, ones (1,5), 0.5*ones (1,5)), y)
+%!assert (nbincdf (x, 1, 0.5*ones (1,5)), y)
+%!assert (nbincdf (x, ones (1,5), 0.5), y)
+%!assert (nbincdf ([x(1:3) 0 x(5)], [0 1 NaN 1.5 Inf], 0.5), [NaN 1/2 NaN nbinpdf(0,1.5,0.5) NaN], eps)
+%!assert (nbincdf (x, 1, 0.5*[-1 NaN 4 1 1]), [NaN NaN NaN y(4:5)])
+%!assert (nbincdf ([x(1:2) NaN x(4:5)], 1, 0.5), [y(1:2) NaN y(4:5)])
 
 %% Test class of input preserved
-%!assert(nbincdf ([x, NaN], 1, 0.5), [y, NaN]);
-%!assert(nbincdf (single([x, NaN]), 1, 0.5), single([y, NaN]));
-%!assert(nbincdf ([x, NaN], single(1), 0.5), single([y, NaN]));
-%!assert(nbincdf ([x, NaN], 1, single(0.5)), single([y, NaN]));
+%!assert (nbincdf ([x, NaN], 1, 0.5), [y, NaN])
+%!assert (nbincdf (single ([x, NaN]), 1, 0.5), single ([y, NaN]))
+%!assert (nbincdf ([x, NaN], single (1), 0.5), single ([y, NaN]))
+%!assert (nbincdf ([x, NaN], 1, single (0.5)), single ([y, NaN]))
 
 %% Test input validation
 %!error nbincdf ()
 %!error nbincdf (1)
 %!error nbincdf (1,2)
 %!error nbincdf (1,2,3,4)
-%!error nbincdf (ones(3),ones(2),ones(2))
-%!error nbincdf (ones(2),ones(3),ones(2))
-%!error nbincdf (ones(2),ones(2),ones(3))
+%!error nbincdf (ones (3), ones (2), ones (2))
+%!error nbincdf (ones (2), ones (3), ones (2))
+%!error nbincdf (ones (2), ones (2), ones (3))
 %!error nbincdf (i, 2, 2)
 %!error nbincdf (2, i, 2)
 %!error nbincdf (2, 2, i)
 
diff --git a/scripts/statistics/distributions/nbininv.m b/scripts/statistics/distributions/nbininv.m
--- a/scripts/statistics/distributions/nbininv.m
+++ b/scripts/statistics/distributions/nbininv.m
@@ -95,34 +95,34 @@ function inv = nbininv (x, n, p)
   endif
   inv(k) = m;
 
 endfunction
 
 
 %!shared x
 %! x = [-1 0 3/4 1 2];
-%!assert(nbininv (x, ones(1,5), 0.5*ones(1,5)), [NaN 0 1 Inf NaN]);
-%!assert(nbininv (x, 1, 0.5*ones(1,5)), [NaN 0 1 Inf NaN]);
-%!assert(nbininv (x, ones(1,5), 0.5), [NaN 0 1 Inf NaN]);
-%!assert(nbininv (x, [1 0 NaN Inf 1], 0.5), [NaN NaN NaN NaN NaN]);
-%!assert(nbininv (x, [1 0 1.5 Inf 1], 0.5), [NaN NaN 2 NaN NaN]);
-%!assert(nbininv (x, 1, 0.5*[1 -Inf NaN Inf 1]), [NaN NaN NaN NaN NaN]);
-%!assert(nbininv ([x(1:2) NaN x(4:5)], 1, 0.5), [NaN 0 NaN Inf NaN]);
+%!assert (nbininv (x, ones (1,5), 0.5*ones (1,5)), [NaN 0 1 Inf NaN])
+%!assert (nbininv (x, 1, 0.5*ones (1,5)), [NaN 0 1 Inf NaN])
+%!assert (nbininv (x, ones (1,5), 0.5), [NaN 0 1 Inf NaN])
+%!assert (nbininv (x, [1 0 NaN Inf 1], 0.5), [NaN NaN NaN NaN NaN])
+%!assert (nbininv (x, [1 0 1.5 Inf 1], 0.5), [NaN NaN 2 NaN NaN])
+%!assert (nbininv (x, 1, 0.5*[1 -Inf NaN Inf 1]), [NaN NaN NaN NaN NaN])
+%!assert (nbininv ([x(1:2) NaN x(4:5)], 1, 0.5), [NaN 0 NaN Inf NaN])
 
 %% Test class of input preserved
-%!assert(nbininv ([x, NaN], 1, 0.5), [NaN 0 1 Inf NaN NaN]);
-%!assert(nbininv (single([x, NaN]), 1, 0.5), single([NaN 0 1 Inf NaN NaN]));
-%!assert(nbininv ([x, NaN], single(1), 0.5), single([NaN 0 1 Inf NaN NaN]));
-%!assert(nbininv ([x, NaN], 1, single(0.5)), single([NaN 0 1 Inf NaN NaN]));
+%!assert (nbininv ([x, NaN], 1, 0.5), [NaN 0 1 Inf NaN NaN])
+%!assert (nbininv (single ([x, NaN]), 1, 0.5), single ([NaN 0 1 Inf NaN NaN]))
+%!assert (nbininv ([x, NaN], single (1), 0.5), single ([NaN 0 1 Inf NaN NaN]))
+%!assert (nbininv ([x, NaN], 1, single (0.5)), single ([NaN 0 1 Inf NaN NaN]))
 
 %% Test input validation
 %!error nbininv ()
 %!error nbininv (1)
 %!error nbininv (1,2)
 %!error nbininv (1,2,3,4)
-%!error nbininv (ones(3),ones(2),ones(2))
-%!error nbininv (ones(2),ones(3),ones(2))
-%!error nbininv (ones(2),ones(2),ones(3))
+%!error nbininv (ones (3), ones (2), ones (2))
+%!error nbininv (ones (2), ones (3), ones (2))
+%!error nbininv (ones (2), ones (2), ones (3))
 %!error nbininv (i, 2, 2)
 %!error nbininv (2, i, 2)
 %!error nbininv (2, 2, i)
 
diff --git a/scripts/statistics/distributions/nbinpdf.m b/scripts/statistics/distributions/nbinpdf.m
--- a/scripts/statistics/distributions/nbinpdf.m
+++ b/scripts/statistics/distributions/nbinpdf.m
@@ -71,32 +71,32 @@ function pdf = nbinpdf (x, n, p)
   
 
 endfunction
 
 
 %!shared x,y
 %! x = [-1 0 1 2 Inf];
 %! y = [0 1/2 1/4 1/8 NaN];
-%!assert(nbinpdf (x, ones(1,5), 0.5*ones(1,5)), y);
-%!assert(nbinpdf (x, 1, 0.5*ones(1,5)), y);
-%!assert(nbinpdf (x, ones(1,5), 0.5), y);
-%!assert(nbinpdf (x, [0 1 NaN 1.5 Inf], 0.5), [NaN 1/2 NaN 1.875*0.5^1.5/4 NaN], eps);
-%!assert(nbinpdf (x, 1, 0.5*[-1 NaN 4 1 1]), [NaN NaN NaN y(4:5)]);
-%!assert(nbinpdf ([x, NaN], 1, 0.5), [y, NaN]);
+%!assert (nbinpdf (x, ones (1,5), 0.5*ones (1,5)), y)
+%!assert (nbinpdf (x, 1, 0.5*ones (1,5)), y)
+%!assert (nbinpdf (x, ones (1,5), 0.5), y)
+%!assert (nbinpdf (x, [0 1 NaN 1.5 Inf], 0.5), [NaN 1/2 NaN 1.875*0.5^1.5/4 NaN], eps)
+%!assert (nbinpdf (x, 1, 0.5*[-1 NaN 4 1 1]), [NaN NaN NaN y(4:5)])
+%!assert (nbinpdf ([x, NaN], 1, 0.5), [y, NaN])
 
 %% Test class of input preserved
-%!assert(nbinpdf (single([x, NaN]), 1, 0.5), single([y, NaN]));
-%!assert(nbinpdf ([x, NaN], single(1), 0.5), single([y, NaN]));
-%!assert(nbinpdf ([x, NaN], 1, single(0.5)), single([y, NaN]));
+%!assert (nbinpdf (single ([x, NaN]), 1, 0.5), single ([y, NaN]))
+%!assert (nbinpdf ([x, NaN], single (1), 0.5), single ([y, NaN]))
+%!assert (nbinpdf ([x, NaN], 1, single (0.5)), single ([y, NaN]))
 
 %% Test input validation
 %!error nbinpdf ()
 %!error nbinpdf (1)
 %!error nbinpdf (1,2)
 %!error nbinpdf (1,2,3,4)
-%!error nbinpdf (ones(3),ones(2),ones(2))
-%!error nbinpdf (ones(2),ones(3),ones(2))
-%!error nbinpdf (ones(2),ones(2),ones(3))
+%!error nbinpdf (ones (3), ones (2), ones (2))
+%!error nbinpdf (ones (2), ones (3), ones (2))
+%!error nbinpdf (ones (2), ones (2), ones (3))
 %!error nbinpdf (i, 2, 2)
 %!error nbinpdf (2, i, 2)
 %!error nbinpdf (2, 2, i)
 
diff --git a/scripts/statistics/distributions/nbinrnd.m b/scripts/statistics/distributions/nbinrnd.m
--- a/scripts/statistics/distributions/nbinrnd.m
+++ b/scripts/statistics/distributions/nbinrnd.m
@@ -101,40 +101,40 @@ function rnd = nbinrnd (n, p, varargin)
 
     k = (n > 0) & (n < Inf) & (p > 0) & (p <= 1);
     rnd(k) = randp ((1 - p(k)) ./ p(k) .* randg (n(k)));
   endif
 
 endfunction
 
 
-%!assert(size (nbinrnd (2, 1/2)), [1, 1]);
-%!assert(size (nbinrnd (2*ones(2,1), 1/2)), [2, 1]);
-%!assert(size (nbinrnd (2*ones(2,2), 1/2)), [2, 2]);
-%!assert(size (nbinrnd (2, 1/2*ones(2,1))), [2, 1]);
-%!assert(size (nbinrnd (2, 1/2*ones(2,2))), [2, 2]);
-%!assert(size (nbinrnd (2, 1/2, 3)), [3, 3]);
-%!assert(size (nbinrnd (2, 1/2, [4 1])), [4, 1]);
-%!assert(size (nbinrnd (2, 1/2, 4, 1)), [4, 1]);
+%!assert (size (nbinrnd (2, 1/2)), [1, 1])
+%!assert (size (nbinrnd (2*ones (2,1), 1/2)), [2, 1])
+%!assert (size (nbinrnd (2*ones (2,2), 1/2)), [2, 2])
+%!assert (size (nbinrnd (2, 1/2*ones (2,1))), [2, 1])
+%!assert (size (nbinrnd (2, 1/2*ones (2,2))), [2, 2])
+%!assert (size (nbinrnd (2, 1/2, 3)), [3, 3])
+%!assert (size (nbinrnd (2, 1/2, [4 1])), [4, 1])
+%!assert (size (nbinrnd (2, 1/2, 4, 1)), [4, 1])
 
 %% Test class of input preserved
-%!assert(class (nbinrnd (2, 1/2)), "double");
-%!assert(class (nbinrnd (single(2), 1/2)), "single");
-%!assert(class (nbinrnd (single([2 2]), 1/2)), "single");
-%!assert(class (nbinrnd (2, single(1/2))), "single");
-%!assert(class (nbinrnd (2, single([1/2 1/2]))), "single");
+%!assert (class (nbinrnd (2, 1/2)), "double")
+%!assert (class (nbinrnd (single (2), 1/2)), "single")
+%!assert (class (nbinrnd (single ([2 2]), 1/2)), "single")
+%!assert (class (nbinrnd (2, single (1/2))), "single")
+%!assert (class (nbinrnd (2, single ([1/2 1/2]))), "single")
 
 %% Test input validation
 %!error nbinrnd ()
 %!error nbinrnd (1)
-%!error nbinrnd (ones(3),ones(2))
-%!error nbinrnd (ones(2),ones(3))
+%!error nbinrnd (ones (3), ones (2))
+%!error nbinrnd (ones (2), ones (3))
 %!error nbinrnd (i, 2)
 %!error nbinrnd (2, i)
 %!error nbinrnd (1,2, -1)
-%!error nbinrnd (1,2, ones(2))
+%!error nbinrnd (1,2, ones (2))
 %!error nbinrnd (1, 2, [2 -1 2])
-%!error nbinrnd (1,2, 1, ones(2))
+%!error nbinrnd (1,2, 1, ones (2))
 %!error nbinrnd (1,2, 1, -1)
-%!error nbinrnd (ones(2,2), 2, 3)
-%!error nbinrnd (ones(2,2), 2, [3, 2])
-%!error nbinrnd (ones(2,2), 2, 2, 3)
+%!error nbinrnd (ones (2,2), 2, 3)
+%!error nbinrnd (ones (2,2), 2, [3, 2])
+%!error nbinrnd (ones (2,2), 2, 2, 3)
 
diff --git a/scripts/statistics/distributions/normcdf.m b/scripts/statistics/distributions/normcdf.m
--- a/scripts/statistics/distributions/normcdf.m
+++ b/scripts/statistics/distributions/normcdf.m
@@ -68,32 +68,32 @@ function cdf = normcdf (x, mu = 0, sigma
   endif
 
 endfunction
 
 
 %!shared x,y
 %! x = [-Inf 1 2 Inf];
 %! y = [0, 0.5, 1/2*(1+erf(1/sqrt(2))), 1];
-%!assert(normcdf (x, ones(1,4), ones(1,4)), y);
-%!assert(normcdf (x, 1, ones(1,4)), y);
-%!assert(normcdf (x, ones(1,4), 1), y);
-%!assert(normcdf (x, [0 -Inf NaN Inf], 1), [y(1) NaN NaN NaN]);
-%!assert(normcdf (x, 1, [Inf NaN -1 0]), [NaN NaN NaN NaN]);
-%!assert(normcdf ([x(1:2) NaN x(4)], 1, 1), [y(1:2) NaN y(4)]);
+%!assert (normcdf (x, ones (1,4), ones (1,4)), y)
+%!assert (normcdf (x, 1, ones (1,4)), y)
+%!assert (normcdf (x, ones (1,4), 1), y)
+%!assert (normcdf (x, [0 -Inf NaN Inf], 1), [y(1) NaN NaN NaN])
+%!assert (normcdf (x, 1, [Inf NaN -1 0]), [NaN NaN NaN NaN])
+%!assert (normcdf ([x(1:2) NaN x(4)], 1, 1), [y(1:2) NaN y(4)])
 
 %% Test class of input preserved
-%!assert(normcdf ([x, NaN], 1, 1), [y, NaN]);
-%!assert(normcdf (single([x, NaN]), 1, 1), single([y, NaN]), eps("single"));
-%!assert(normcdf ([x, NaN], single(1), 1), single([y, NaN]), eps("single"));
-%!assert(normcdf ([x, NaN], 1, single(1)), single([y, NaN]), eps("single"));
+%!assert (normcdf ([x, NaN], 1, 1), [y, NaN])
+%!assert (normcdf (single ([x, NaN]), 1, 1), single ([y, NaN]), eps ("single"))
+%!assert (normcdf ([x, NaN], single (1), 1), single ([y, NaN]), eps ("single"))
+%!assert (normcdf ([x, NaN], 1, single (1)), single ([y, NaN]), eps ("single"))
 
 %% Test input validation
 %!error normcdf ()
 %!error normcdf (1,2)
 %!error normcdf (1,2,3,4)
-%!error normcdf (ones(3),ones(2),ones(2))
-%!error normcdf (ones(2),ones(3),ones(2))
-%!error normcdf (ones(2),ones(2),ones(3))
+%!error normcdf (ones (3), ones (2), ones (2))
+%!error normcdf (ones (2), ones (3), ones (2))
+%!error normcdf (ones (2), ones (2), ones (3))
 %!error normcdf (i, 2, 2)
 %!error normcdf (2, i, 2)
 %!error normcdf (2, 2, i)
 
diff --git a/scripts/statistics/distributions/norminv.m b/scripts/statistics/distributions/norminv.m
--- a/scripts/statistics/distributions/norminv.m
+++ b/scripts/statistics/distributions/norminv.m
@@ -62,32 +62,32 @@ function inv = norminv (x, mu = 0, sigma
     inv(k) = mu(k) + sigma(k) .* stdnormal_inv (x(k));
   endif
 
 endfunction
 
 
 %!shared x
 %! x = [-1 0 0.5 1 2];
-%!assert(norminv (x, ones(1,5), ones(1,5)), [NaN -Inf 1 Inf NaN]);
-%!assert(norminv (x, 1, ones(1,5)), [NaN -Inf 1 Inf NaN]);
-%!assert(norminv (x, ones(1,5), 1), [NaN -Inf 1 Inf NaN]);
-%!assert(norminv (x, [1 -Inf NaN Inf 1], 1), [NaN NaN NaN NaN NaN]);
-%!assert(norminv (x, 1, [1 0 NaN Inf 1]), [NaN NaN NaN NaN NaN]);
-%!assert(norminv ([x(1:2) NaN x(4:5)], 1, 1), [NaN -Inf NaN Inf NaN]);
+%!assert (norminv (x, ones (1,5), ones (1,5)), [NaN -Inf 1 Inf NaN])
+%!assert (norminv (x, 1, ones (1,5)), [NaN -Inf 1 Inf NaN])
+%!assert (norminv (x, ones (1,5), 1), [NaN -Inf 1 Inf NaN])
+%!assert (norminv (x, [1 -Inf NaN Inf 1], 1), [NaN NaN NaN NaN NaN])
+%!assert (norminv (x, 1, [1 0 NaN Inf 1]), [NaN NaN NaN NaN NaN])
+%!assert (norminv ([x(1:2) NaN x(4:5)], 1, 1), [NaN -Inf NaN Inf NaN])
 
 %% Test class of input preserved
-%!assert(norminv ([x, NaN], 1, 1), [NaN -Inf 1 Inf NaN NaN]);
-%!assert(norminv (single([x, NaN]), 1, 1), single([NaN -Inf 1 Inf NaN NaN]));
-%!assert(norminv ([x, NaN], single(1), 1), single([NaN -Inf 1 Inf NaN NaN]));
-%!assert(norminv ([x, NaN], 1, single(1)), single([NaN -Inf 1 Inf NaN NaN]));
+%!assert (norminv ([x, NaN], 1, 1), [NaN -Inf 1 Inf NaN NaN])
+%!assert (norminv (single ([x, NaN]), 1, 1), single ([NaN -Inf 1 Inf NaN NaN]))
+%!assert (norminv ([x, NaN], single (1), 1), single ([NaN -Inf 1 Inf NaN NaN]))
+%!assert (norminv ([x, NaN], 1, single (1)), single ([NaN -Inf 1 Inf NaN NaN]))
 
 %% Test input validation
 %!error norminv ()
 %!error norminv (1,2)
 %!error norminv (1,2,3,4)
-%!error norminv (ones(3),ones(2),ones(2))
-%!error norminv (ones(2),ones(3),ones(2))
-%!error norminv (ones(2),ones(2),ones(3))
+%!error norminv (ones (3), ones (2), ones (2))
+%!error norminv (ones (2), ones (3), ones (2))
+%!error norminv (ones (2), ones (2), ones (3))
 %!error norminv (i, 2, 2)
 %!error norminv (2, i, 2)
 %!error norminv (2, 2, i)
 
diff --git a/scripts/statistics/distributions/normpdf.m b/scripts/statistics/distributions/normpdf.m
--- a/scripts/statistics/distributions/normpdf.m
+++ b/scripts/statistics/distributions/normpdf.m
@@ -68,31 +68,31 @@ function pdf = normpdf (x, mu = 0, sigma
   endif
 
 endfunction
 
 
 %!shared x,y
 %! x = [-Inf 1 2 Inf];
 %! y = 1/sqrt(2*pi)*exp (-(x-1).^2/2);
-%!assert(normpdf (x, ones(1,4), ones(1,4)), y);
-%!assert(normpdf (x, 1, ones(1,4)), y);
-%!assert(normpdf (x, ones(1,4), 1), y);
-%!assert(normpdf (x, [0 -Inf NaN Inf], 1), [y(1) NaN NaN NaN]);
-%!assert(normpdf (x, 1, [Inf NaN -1 0]), [NaN NaN NaN NaN]);
-%!assert(normpdf ([x, NaN], 1, 1), [y, NaN]);
+%!assert (normpdf (x, ones (1,4), ones (1,4)), y)
+%!assert (normpdf (x, 1, ones (1,4)), y)
+%!assert (normpdf (x, ones (1,4), 1), y)
+%!assert (normpdf (x, [0 -Inf NaN Inf], 1), [y(1) NaN NaN NaN])
+%!assert (normpdf (x, 1, [Inf NaN -1 0]), [NaN NaN NaN NaN])
+%!assert (normpdf ([x, NaN], 1, 1), [y, NaN])
 
 %% Test class of input preserved
-%!assert(normpdf (single([x, NaN]), 1, 1), single([y, NaN]), eps("single"));
-%!assert(normpdf ([x, NaN], single(1), 1), single([y, NaN]), eps("single"));
-%!assert(normpdf ([x, NaN], 1, single(1)), single([y, NaN]), eps("single"));
+%!assert (normpdf (single ([x, NaN]), 1, 1), single ([y, NaN]), eps ("single"))
+%!assert (normpdf ([x, NaN], single (1), 1), single ([y, NaN]), eps ("single"))
+%!assert (normpdf ([x, NaN], 1, single (1)), single ([y, NaN]), eps ("single"))
 
 %% Test input validation
 %!error normpdf ()
 %!error normpdf (1,2)
 %!error normpdf (1,2,3,4)
-%!error normpdf (ones(3),ones(2),ones(2))
-%!error normpdf (ones(2),ones(3),ones(2))
-%!error normpdf (ones(2),ones(2),ones(3))
+%!error normpdf (ones (3), ones (2), ones (2))
+%!error normpdf (ones (2), ones (3), ones (2))
+%!error normpdf (ones (2), ones (2), ones (3))
 %!error normpdf (i, 2, 2)
 %!error normpdf (2, i, 2)
 %!error normpdf (2, 2, i)
 
diff --git a/scripts/statistics/distributions/normrnd.m b/scripts/statistics/distributions/normrnd.m
--- a/scripts/statistics/distributions/normrnd.m
+++ b/scripts/statistics/distributions/normrnd.m
@@ -92,40 +92,40 @@ function rnd = normrnd (mu, sigma, varar
     rnd = mu + sigma .* randn (sz);
     k = isnan (mu) | isinf (mu) | !(sigma > 0) | !(sigma < Inf);
     rnd(k) = NaN;
   endif
 
 endfunction
 
 
-%!assert(size (normrnd (1,2)), [1, 1]);
-%!assert(size (normrnd (ones(2,1), 2)), [2, 1]);
-%!assert(size (normrnd (ones(2,2), 2)), [2, 2]);
-%!assert(size (normrnd (1, 2*ones(2,1))), [2, 1]);
-%!assert(size (normrnd (1, 2*ones(2,2))), [2, 2]);
-%!assert(size (normrnd (1, 2, 3)), [3, 3]);
-%!assert(size (normrnd (1, 2, [4 1])), [4, 1]);
-%!assert(size (normrnd (1, 2, 4, 1)), [4, 1]);
+%!assert (size (normrnd (1,2)), [1, 1])
+%!assert (size (normrnd (ones (2,1), 2)), [2, 1])
+%!assert (size (normrnd (ones (2,2), 2)), [2, 2])
+%!assert (size (normrnd (1, 2*ones (2,1))), [2, 1])
+%!assert (size (normrnd (1, 2*ones (2,2))), [2, 2])
+%!assert (size (normrnd (1, 2, 3)), [3, 3])
+%!assert (size (normrnd (1, 2, [4 1])), [4, 1])
+%!assert (size (normrnd (1, 2, 4, 1)), [4, 1])
 
 %% Test class of input preserved
-%!assert(class (normrnd (1, 2)), "double");
-%!assert(class (normrnd (single(1), 2)), "single");
-%!assert(class (normrnd (single([1 1]), 2)), "single");
-%!assert(class (normrnd (1, single(2))), "single");
-%!assert(class (normrnd (1, single([2 2]))), "single");
+%!assert (class (normrnd (1, 2)), "double")
+%!assert (class (normrnd (single (1), 2)), "single")
+%!assert (class (normrnd (single ([1 1]), 2)), "single")
+%!assert (class (normrnd (1, single (2))), "single")
+%!assert (class (normrnd (1, single ([2 2]))), "single")
 
 %% Test input validation
 %!error normrnd ()
 %!error normrnd (1)
-%!error normrnd (ones(3),ones(2))
-%!error normrnd (ones(2),ones(3))
+%!error normrnd (ones (3), ones (2))
+%!error normrnd (ones (2), ones (3))
 %!error normrnd (i, 2)
 %!error normrnd (2, i)
 %!error normrnd (1,2, -1)
-%!error normrnd (1,2, ones(2))
+%!error normrnd (1,2, ones (2))
 %!error normrnd (1, 2, [2 -1 2])
-%!error normrnd (1,2, 1, ones(2))
+%!error normrnd (1,2, 1, ones (2))
 %!error normrnd (1,2, 1, -1)
-%!error normrnd (ones(2,2), 2, 3)
-%!error normrnd (ones(2,2), 2, [3, 2])
-%!error normrnd (ones(2,2), 2, 2, 3)
+%!error normrnd (ones (2,2), 2, 3)
+%!error normrnd (ones (2,2), 2, [3, 2])
+%!error normrnd (ones (2,2), 2, 2, 3)
 
diff --git a/scripts/statistics/distributions/poisscdf.m b/scripts/statistics/distributions/poisscdf.m
--- a/scripts/statistics/distributions/poisscdf.m
+++ b/scripts/statistics/distributions/poisscdf.m
@@ -63,28 +63,28 @@ function cdf = poisscdf (x, lambda)
     cdf(k) = 1 - gammainc (lambda(k), floor (x(k)) + 1);
   endif
 
 endfunction
 
 
 %!shared x,y
 %! x = [-1 0 1 2 Inf];
-%! y = [0, gammainc(1, (x(2:4) +1), 'upper'), 1];
-%!assert(poisscdf (x, ones(1,5)), y);
-%!assert(poisscdf (x, 1), y);
-%!assert(poisscdf (x, [1 0 NaN 1 1]), [y(1) NaN NaN y(4:5)]);
-%!assert(poisscdf ([x(1:2) NaN Inf x(5)], 1), [y(1:2) NaN 1 y(5)]);
+%! y = [0, gammainc(1, (x(2:4) +1), "upper"), 1];
+%!assert (poisscdf (x, ones (1,5)), y)
+%!assert (poisscdf (x, 1), y)
+%!assert (poisscdf (x, [1 0 NaN 1 1]), [y(1) NaN NaN y(4:5)])
+%!assert (poisscdf ([x(1:2) NaN Inf x(5)], 1), [y(1:2) NaN 1 y(5)])
 
 %% Test class of input preserved
-%!assert(poisscdf ([x, NaN], 1), [y, NaN]);
-%!assert(poisscdf (single([x, NaN]), 1), single([y, NaN]), eps("single"));
-%!assert(poisscdf ([x, NaN], single(1)), single([y, NaN]), eps("single"));
+%!assert (poisscdf ([x, NaN], 1), [y, NaN])
+%!assert (poisscdf (single ([x, NaN]), 1), single ([y, NaN]), eps ("single"))
+%!assert (poisscdf ([x, NaN], single (1)), single ([y, NaN]), eps ("single"))
 
 %% Test input validation
 %!error poisscdf ()
 %!error poisscdf (1)
 %!error poisscdf (1,2,3)
-%!error poisscdf (ones(3),ones(2))
-%!error poisscdf (ones(2),ones(3))
+%!error poisscdf (ones (3), ones (2))
+%!error poisscdf (ones (2), ones (3))
 %!error poisscdf (i, 2)
 %!error poisscdf (2, i)
 
diff --git a/scripts/statistics/distributions/poissinv.m b/scripts/statistics/distributions/poissinv.m
--- a/scripts/statistics/distributions/poissinv.m
+++ b/scripts/statistics/distributions/poissinv.m
@@ -77,27 +77,27 @@ function inv = poissinv (x, lambda)
     endif
   endwhile
 
 endfunction
 
 
 %!shared x
 %! x = [-1 0 0.5 1 2];
-%!assert(poissinv (x, ones(1,5)), [NaN 0 1 Inf NaN]);
-%!assert(poissinv (x, 1), [NaN 0 1 Inf NaN]);
-%!assert(poissinv (x, [1 0 NaN 1 1]), [NaN NaN NaN Inf NaN]);
-%!assert(poissinv ([x(1:2) NaN x(4:5)], 1), [NaN 0 NaN Inf NaN]);
+%!assert (poissinv (x, ones (1,5)), [NaN 0 1 Inf NaN])
+%!assert (poissinv (x, 1), [NaN 0 1 Inf NaN])
+%!assert (poissinv (x, [1 0 NaN 1 1]), [NaN NaN NaN Inf NaN])
+%!assert (poissinv ([x(1:2) NaN x(4:5)], 1), [NaN 0 NaN Inf NaN])
 
 %% Test class of input preserved
-%!assert(poissinv ([x, NaN], 1), [NaN 0 1 Inf NaN NaN]);
-%!assert(poissinv (single([x, NaN]), 1), single([NaN 0 1 Inf NaN NaN]));
-%!assert(poissinv ([x, NaN], single(1)), single([NaN 0 1 Inf NaN NaN]));
+%!assert (poissinv ([x, NaN], 1), [NaN 0 1 Inf NaN NaN])
+%!assert (poissinv (single ([x, NaN]), 1), single ([NaN 0 1 Inf NaN NaN]))
+%!assert (poissinv ([x, NaN], single (1)), single ([NaN 0 1 Inf NaN NaN]))
 
 %% Test input validation
 %!error poissinv ()
 %!error poissinv (1)
 %!error poissinv (1,2,3)
-%!error poissinv (ones(3),ones(2))
-%!error poissinv (ones(2),ones(3))
+%!error poissinv (ones (3), ones (2))
+%!error poissinv (ones (2), ones (3))
 %!error poissinv (i, 2)
 %!error poissinv (2, i)
 
diff --git a/scripts/statistics/distributions/poisspdf.m b/scripts/statistics/distributions/poisspdf.m
--- a/scripts/statistics/distributions/poisspdf.m
+++ b/scripts/statistics/distributions/poisspdf.m
@@ -60,26 +60,26 @@ function pdf = poisspdf (x, lambda)
   endif
 
 endfunction
 
 
 %!shared x,y
 %! x = [-1 0 1 2 Inf];
 %! y = [0, exp(-1)*[1 1 0.5], 0];
-%!assert(poisspdf (x, ones(1,5)), y, eps);
-%!assert(poisspdf (x, 1), y, eps);
-%!assert(poisspdf (x, [1 0 NaN 1 1]), [y(1) NaN NaN y(4:5)], eps);
-%!assert(poisspdf ([x, NaN], 1), [y, NaN], eps);
+%!assert (poisspdf (x, ones (1,5)), y, eps)
+%!assert (poisspdf (x, 1), y, eps)
+%!assert (poisspdf (x, [1 0 NaN 1 1]), [y(1) NaN NaN y(4:5)], eps)
+%!assert (poisspdf ([x, NaN], 1), [y, NaN], eps)
 
 %% Test class of input preserved
-%!assert(poisspdf (single([x, NaN]), 1), single([y, NaN]), eps("single"));
-%!assert(poisspdf ([x, NaN], single(1)), single([y, NaN]), eps("single"));
+%!assert (poisspdf (single ([x, NaN]), 1), single ([y, NaN]), eps ("single"))
+%!assert (poisspdf ([x, NaN], single (1)), single ([y, NaN]), eps ("single"))
 
 %% Test input validation
 %!error poisspdf ()
 %!error poisspdf (1)
 %!error poisspdf (1,2,3)
-%!error poisspdf (ones(3),ones(2))
-%!error poisspdf (ones(2),ones(3))
+%!error poisspdf (ones (3), ones (2))
+%!error poisspdf (ones (2), ones (3))
 %!error poisspdf (i, 2)
 %!error poisspdf (2, i)
 
diff --git a/scripts/statistics/distributions/poissrnd.m b/scripts/statistics/distributions/poissrnd.m
--- a/scripts/statistics/distributions/poissrnd.m
+++ b/scripts/statistics/distributions/poissrnd.m
@@ -89,32 +89,32 @@ function rnd = poissrnd (lambda, varargi
 
     k = (lambda > 0) & (lambda < Inf);
     rnd(k) = randp (lambda(k));
   endif
 
 endfunction
 
 
-%!assert(size (poissrnd (2)), [1, 1]);
-%!assert(size (poissrnd (ones(2,1))), [2, 1]);
-%!assert(size (poissrnd (ones(2,2))), [2, 2]);
-%!assert(size (poissrnd (1, 3)), [3, 3]);
-%!assert(size (poissrnd (1, [4 1])), [4, 1]);
-%!assert(size (poissrnd (1, 4, 1)), [4, 1]);
+%!assert (size (poissrnd (2)), [1, 1])
+%!assert (size (poissrnd (ones (2,1))), [2, 1])
+%!assert (size (poissrnd (ones (2,2))), [2, 2])
+%!assert (size (poissrnd (1, 3)), [3, 3])
+%!assert (size (poissrnd (1, [4 1])), [4, 1])
+%!assert (size (poissrnd (1, 4, 1)), [4, 1])
 
 %% Test class of input preserved
-%!assert(class (poissrnd (2)), "double");
-%!assert(class (poissrnd (single(2))), "single");
-%!assert(class (poissrnd (single([2 2]))), "single");
+%!assert (class (poissrnd (2)), "double")
+%!assert (class (poissrnd (single (2))), "single")
+%!assert (class (poissrnd (single ([2 2]))), "single")
 
 %% Test input validation
 %!error poissrnd ()
 %!error poissrnd (1, -1)
-%!error poissrnd (1, ones(2))
-%!error poissrnd (1, 2, ones(2))
+%!error poissrnd (1, ones (2))
+%!error poissrnd (1, 2, ones (2))
 %!error poissrnd (i)
 %!error poissrnd (1, 2, -1)
 %!error poissrnd (1, [2 -1 2])
-%!error poissrnd (ones(2,2), 3)
-%!error poissrnd (ones(2,2), [3, 2])
-%!error poissrnd (ones(2,2), 2, 3)
+%!error poissrnd (ones (2,2), 3)
+%!error poissrnd (ones (2,2), [3, 2])
+%!error poissrnd (ones (2,2), 2, 3)
 
diff --git a/scripts/statistics/distributions/stdnormal_cdf.m b/scripts/statistics/distributions/stdnormal_cdf.m
--- a/scripts/statistics/distributions/stdnormal_cdf.m
+++ b/scripts/statistics/distributions/stdnormal_cdf.m
@@ -40,18 +40,18 @@ function cdf = stdnormal_cdf (x)
   cdf = erfc (x / (-sqrt(2))) / 2;
 
 endfunction
 
 
 %!shared x,y
 %! x = [-Inf 0 1 Inf];
 %! y = [0, 0.5, 1/2*(1+erf(1/sqrt(2))), 1];
-%!assert(stdnormal_cdf ([x, NaN]), [y, NaN]);
+%!assert (stdnormal_cdf ([x, NaN]), [y, NaN])
 
 %% Test class of input preserved
-%!assert(stdnormal_cdf (single([x, NaN])), single([y, NaN]), eps("single"));
+%!assert (stdnormal_cdf (single ([x, NaN])), single ([y, NaN]), eps ("single"))
 
 %% Test input validation
 %!error stdnormal_cdf ()
 %!error stdnormal_cdf (1,2)
 %!error stdnormal_cdf (i)
 
diff --git a/scripts/statistics/distributions/stdnormal_inv.m b/scripts/statistics/distributions/stdnormal_inv.m
--- a/scripts/statistics/distributions/stdnormal_inv.m
+++ b/scripts/statistics/distributions/stdnormal_inv.m
@@ -39,19 +39,19 @@ function inv = stdnormal_inv (x)
 
   inv = sqrt (2) * erfinv (2 * x - 1);
 
 endfunction
 
 
 %!shared x
 %! x = [-1 0 0.5 1 2];
-%!assert(stdnormal_inv (x), [NaN -Inf 0 Inf NaN]);
+%!assert (stdnormal_inv (x), [NaN -Inf 0 Inf NaN])
 
 %% Test class of input preserved
-%!assert(stdnormal_inv ([x, NaN]), [NaN -Inf 0 Inf NaN NaN]);
-%!assert(stdnormal_inv (single([x, NaN])), single([NaN -Inf 0 Inf NaN NaN]));
+%!assert (stdnormal_inv ([x, NaN]), [NaN -Inf 0 Inf NaN NaN])
+%!assert (stdnormal_inv (single ([x, NaN])), single ([NaN -Inf 0 Inf NaN NaN]))
 
 %% Test input validation
 %!error stdnormal_inv ()
 %!error stdnormal_inv (1,2)
 %!error stdnormal_inv (i)
 
diff --git a/scripts/statistics/distributions/stdnormal_pdf.m b/scripts/statistics/distributions/stdnormal_pdf.m
--- a/scripts/statistics/distributions/stdnormal_pdf.m
+++ b/scripts/statistics/distributions/stdnormal_pdf.m
@@ -40,18 +40,18 @@ function pdf = stdnormal_pdf (x)
   pdf = (2 * pi)^(- 1/2) * exp (- x .^ 2 / 2);
 
 endfunction
 
 
 %!shared x,y
 %! x = [-Inf 0 1 Inf];
 %! y = 1/sqrt(2*pi)*exp (-x.^2/2);
-%!assert(stdnormal_pdf ([x, NaN]), [y, NaN], eps);
+%!assert (stdnormal_pdf ([x, NaN]), [y, NaN], eps)
 
 %% Test class of input preserved
-%!assert(stdnormal_pdf (single([x, NaN])), single([y, NaN]), eps("single"));
+%!assert (stdnormal_pdf (single ([x, NaN])), single ([y, NaN]), eps ("single"))
 
 %% Test input validation
 %!error stdnormal_pdf ()
 %!error stdnormal_pdf (1,2)
 %!error stdnormal_pdf (i)
 
diff --git a/scripts/statistics/distributions/stdnormal_rnd.m b/scripts/statistics/distributions/stdnormal_rnd.m
--- a/scripts/statistics/distributions/stdnormal_rnd.m
+++ b/scripts/statistics/distributions/stdnormal_rnd.m
@@ -55,20 +55,20 @@ function rnd = stdnormal_rnd (varargin)
     sz = [varargin{:}];
   endif
 
   rnd = randn (sz);
 
 endfunction
 
 
-%!assert(size (stdnormal_rnd (3)), [3, 3]);
-%!assert(size (stdnormal_rnd ([4 1])), [4, 1]);
-%!assert(size (stdnormal_rnd (4,1)), [4, 1]);
+%!assert (size (stdnormal_rnd (3)), [3, 3])
+%!assert (size (stdnormal_rnd ([4 1])), [4, 1])
+%!assert (size (stdnormal_rnd (4,1)), [4, 1])
 
 %% Test input validation
 %!error stdnormal_rnd ()
 %!error stdnormal_rnd (-1)
-%!error stdnormal_rnd (ones(2))
+%!error stdnormal_rnd (ones (2))
 %!error stdnormal_rnd ([2 -1 2])
-%!error stdnormal_rnd (1, ones(2))
+%!error stdnormal_rnd (1, ones (2))
 %!error stdnormal_rnd (1, -1)
 
diff --git a/scripts/statistics/distributions/tcdf.m b/scripts/statistics/distributions/tcdf.m
--- a/scripts/statistics/distributions/tcdf.m
+++ b/scripts/statistics/distributions/tcdf.m
@@ -68,27 +68,27 @@ function cdf = tcdf (x, n)
   cdf(k) = 1;
 
 endfunction
 
 
 %!shared x,y
 %! x = [-Inf 0 1 Inf];
 %! y = [0 1/2 3/4 1];
-%!assert(tcdf (x, ones(1,4)), y, eps);
-%!assert(tcdf (x, 1), y, eps);
-%!assert(tcdf (x, [0 1 NaN 1]), [NaN 1/2 NaN 1], eps);
-%!assert(tcdf ([x(1:2) NaN x(4)], 1), [y(1:2) NaN y(4)], eps);
+%!assert (tcdf (x, ones (1,4)), y, eps)
+%!assert (tcdf (x, 1), y, eps)
+%!assert (tcdf (x, [0 1 NaN 1]), [NaN 1/2 NaN 1], eps)
+%!assert (tcdf ([x(1:2) NaN x(4)], 1), [y(1:2) NaN y(4)], eps)
 
 %% Test class of input preserved
-%!assert(tcdf ([x, NaN], 1), [y, NaN], eps);
-%!assert(tcdf (single([x, NaN]), 1), single([y, NaN]), eps("single"));
-%!assert(tcdf ([x, NaN], single(1)), single([y, NaN]), eps("single"));
+%!assert (tcdf ([x, NaN], 1), [y, NaN], eps)
+%!assert (tcdf (single ([x, NaN]), 1), single ([y, NaN]), eps ("single"))
+%!assert (tcdf ([x, NaN], single (1)), single ([y, NaN]), eps ("single"))
 
 %% Test input validation
 %!error tcdf ()
 %!error tcdf (1)
 %!error tcdf (1,2,3)
-%!error tcdf (ones(3),ones(2))
-%!error tcdf (ones(2),ones(3))
+%!error tcdf (ones (3), ones (2))
+%!error tcdf (ones (2), ones (3))
 %!error tcdf (i, 2)
 %!error tcdf (2, i)
 
diff --git a/scripts/statistics/distributions/tinv.m b/scripts/statistics/distributions/tinv.m
--- a/scripts/statistics/distributions/tinv.m
+++ b/scripts/statistics/distributions/tinv.m
@@ -82,27 +82,27 @@ function inv = tinv (x, n)
     inv(k) = stdnormal_inv (x(k));
   endif
 
 endfunction
 
 
 %!shared x
 %! x = [-1 0 0.5 1 2];
-%!assert(tinv (x, ones(1,5)), [NaN -Inf 0 Inf NaN]);
-%!assert(tinv (x, 1), [NaN -Inf 0 Inf NaN], eps);
-%!assert(tinv (x, [1 0 NaN 1 1]), [NaN NaN NaN Inf NaN], eps);
-%!assert(tinv ([x(1:2) NaN x(4:5)], 1), [NaN -Inf NaN Inf NaN]);
+%!assert (tinv (x, ones (1,5)), [NaN -Inf 0 Inf NaN])
+%!assert (tinv (x, 1), [NaN -Inf 0 Inf NaN], eps)
+%!assert (tinv (x, [1 0 NaN 1 1]), [NaN NaN NaN Inf NaN], eps)
+%!assert (tinv ([x(1:2) NaN x(4:5)], 1), [NaN -Inf NaN Inf NaN])
 
 %% Test class of input preserved
-%!assert(tinv ([x, NaN], 1), [NaN -Inf 0 Inf NaN NaN], eps);
-%!assert(tinv (single([x, NaN]), 1), single([NaN -Inf 0 Inf NaN NaN]), eps("single"));
-%!assert(tinv ([x, NaN], single(1)), single([NaN -Inf 0 Inf NaN NaN]), eps("single"));
+%!assert (tinv ([x, NaN], 1), [NaN -Inf 0 Inf NaN NaN], eps)
+%!assert (tinv (single ([x, NaN]), 1), single ([NaN -Inf 0 Inf NaN NaN]), eps ("single"))
+%!assert (tinv ([x, NaN], single (1)), single ([NaN -Inf 0 Inf NaN NaN]), eps ("single"))
 
 %% Test input validation
 %!error tinv ()
 %!error tinv (1)
 %!error tinv (1,2,3)
-%!error tinv (ones(3),ones(2))
-%!error tinv (ones(2),ones(3))
+%!error tinv (ones (3), ones (2))
+%!error tinv (ones (2), ones (3))
 %!error tinv (i, 2)
 %!error tinv (2, i)
 
diff --git a/scripts/statistics/distributions/tpdf.m b/scripts/statistics/distributions/tpdf.m
--- a/scripts/statistics/distributions/tpdf.m
+++ b/scripts/statistics/distributions/tpdf.m
@@ -63,31 +63,31 @@ function pdf = tpdf (x, n)
   endif
 
 endfunction
 
 
 %!test
 %! x = rand (10,1);
 %! y = 1./(pi * (1 + x.^2));
-%! assert(tpdf (x, 1), y, 5*eps);
+%! assert (tpdf (x, 1), y, 5*eps);
 
 %!shared x,y
 %! x = [-Inf 0 0.5 1 Inf];
 %! y = 1./(pi * (1 + x.^2));
-%!assert(tpdf (x, ones(1,5)), y, eps);
-%!assert(tpdf (x, 1), y, eps);
-%!assert(tpdf (x, [0 NaN 1 1 1]), [NaN NaN y(3:5)], eps);
+%!assert (tpdf (x, ones (1,5)), y, eps)
+%!assert (tpdf (x, 1), y, eps)
+%!assert (tpdf (x, [0 NaN 1 1 1]), [NaN NaN y(3:5)], eps)
 
 %% Test class of input preserved
-%!assert(tpdf ([x, NaN], 1), [y, NaN], eps);
-%!assert(tpdf (single([x, NaN]), 1), single([y, NaN]), eps("single"));
-%!assert(tpdf ([x, NaN], single(1)), single([y, NaN]), eps("single"));
+%!assert (tpdf ([x, NaN], 1), [y, NaN], eps)
+%!assert (tpdf (single ([x, NaN]), 1), single ([y, NaN]), eps ("single"))
+%!assert (tpdf ([x, NaN], single (1)), single ([y, NaN]), eps ("single"))
 
 %% Test input validation
 %!error tpdf ()
 %!error tpdf (1)
 %!error tpdf (1,2,3)
-%!error tpdf (ones(3),ones(2))
-%!error tpdf (ones(2),ones(3))
+%!error tpdf (ones (3), ones (2))
+%!error tpdf (ones (2), ones (3))
 %!error tpdf (i, 2)
 %!error tpdf (2, i)
 
diff --git a/scripts/statistics/distributions/trnd.m b/scripts/statistics/distributions/trnd.m
--- a/scripts/statistics/distributions/trnd.m
+++ b/scripts/statistics/distributions/trnd.m
@@ -86,32 +86,32 @@ function rnd = trnd (n, varargin)
 
     k = (n > 0) & (n < Inf);
     rnd(k) = randn (sum (k(:)), 1) ./ sqrt (2*randg (n(k)/2) ./ n(k))(:);
   endif
 
 endfunction
 
 
-%!assert(size (trnd (2)), [1, 1]);
-%!assert(size (trnd (ones(2,1))), [2, 1]);
-%!assert(size (trnd (ones(2,2))), [2, 2]);
-%!assert(size (trnd (1, 3)), [3, 3]);
-%!assert(size (trnd (1, [4 1])), [4, 1]);
-%!assert(size (trnd (1, 4, 1)), [4, 1]);
+%!assert (size (trnd (2)), [1, 1])
+%!assert (size (trnd (ones (2,1))), [2, 1])
+%!assert (size (trnd (ones (2,2))), [2, 2])
+%!assert (size (trnd (1, 3)), [3, 3])
+%!assert (size (trnd (1, [4 1])), [4, 1])
+%!assert (size (trnd (1, 4, 1)), [4, 1])
 
 %% Test class of input preserved
-%!assert(class (trnd (1)), "double");
-%!assert(class (trnd (single(1))), "single");
-%!assert(class (trnd (single([1 1]))), "single");
+%!assert (class (trnd (1)), "double")
+%!assert (class (trnd (single (1))), "single")
+%!assert (class (trnd (single ([1 1]))), "single")
 
 %% Test input validation
 %!error trnd ()
 %!error trnd (1, -1)
-%!error trnd (1, ones(2))
+%!error trnd (1, ones (2))
 %!error trnd (i)
 %!error trnd (1, [2 -1 2])
-%!error trnd (1, 2, ones(2))
+%!error trnd (1, 2, ones (2))
 %!error trnd (1, 2, -1)
-%!error trnd (ones(2,2), 3)
-%!error trnd (ones(2,2), [3, 2])
-%!error trnd (ones(2,2), 2, 3)
+%!error trnd (ones (2,2), 3)
+%!error trnd (ones (2,2), [3, 2])
+%!error trnd (ones (2,2), 2, 3)
 
diff --git a/scripts/statistics/distributions/unidcdf.m b/scripts/statistics/distributions/unidcdf.m
--- a/scripts/statistics/distributions/unidcdf.m
+++ b/scripts/statistics/distributions/unidcdf.m
@@ -63,27 +63,27 @@ function cdf = unidcdf (x, n)
   endif
 
 endfunction
 
 
 %!shared x,y
 %! x = [0 1 2.5 10 11];
 %! y = [0, 0.1 0.2 1.0 1.0];
-%!assert(unidcdf (x, 10*ones(1,5)), y);
-%!assert(unidcdf (x, 10), y);
-%!assert(unidcdf (x, 10*[0 1 NaN 1 1]), [NaN 0.1 NaN y(4:5)]);
-%!assert(unidcdf ([x(1:2) NaN Inf x(5)], 10), [y(1:2) NaN 1 y(5)]);
+%!assert (unidcdf (x, 10*ones (1,5)), y)
+%!assert (unidcdf (x, 10), y)
+%!assert (unidcdf (x, 10*[0 1 NaN 1 1]), [NaN 0.1 NaN y(4:5)])
+%!assert (unidcdf ([x(1:2) NaN Inf x(5)], 10), [y(1:2) NaN 1 y(5)])
 
 %% Test class of input preserved
-%!assert(unidcdf ([x, NaN], 10), [y, NaN]);
-%!assert(unidcdf (single([x, NaN]), 10), single([y, NaN]));
-%!assert(unidcdf ([x, NaN], single(10)), single([y, NaN]));
+%!assert (unidcdf ([x, NaN], 10), [y, NaN])
+%!assert (unidcdf (single ([x, NaN]), 10), single ([y, NaN]))
+%!assert (unidcdf ([x, NaN], single (10)), single ([y, NaN]))
 
 %% Test input validation
 %!error unidcdf ()
 %!error unidcdf (1)
 %!error unidcdf (1,2,3)
-%!error unidcdf (ones(3),ones(2))
-%!error unidcdf (ones(2),ones(3))
+%!error unidcdf (ones (3), ones (2))
+%!error unidcdf (ones (2), ones (3))
 %!error unidcdf (i, 2)
 %!error unidcdf (2, i)
 
diff --git a/scripts/statistics/distributions/unidinv.m b/scripts/statistics/distributions/unidinv.m
--- a/scripts/statistics/distributions/unidinv.m
+++ b/scripts/statistics/distributions/unidinv.m
@@ -55,27 +55,27 @@ function inv = unidinv (x, n)
     inv(k) = floor (x(k) .* n(k));
   endif
 
 endfunction
 
 
 %!shared x
 %! x = [-1 0 0.5 1 2];
-%!assert(unidinv (x, 10*ones(1,5)), [NaN NaN 5 10 NaN], eps);
-%!assert(unidinv (x, 10), [NaN NaN 5 10 NaN], eps);
-%!assert(unidinv (x, 10*[0 1 NaN 1 1]), [NaN NaN NaN 10 NaN], eps);
-%!assert(unidinv ([x(1:2) NaN x(4:5)], 10), [NaN NaN NaN 10 NaN], eps);
+%!assert (unidinv (x, 10*ones (1,5)), [NaN NaN 5 10 NaN], eps)
+%!assert (unidinv (x, 10), [NaN NaN 5 10 NaN], eps)
+%!assert (unidinv (x, 10*[0 1 NaN 1 1]), [NaN NaN NaN 10 NaN], eps)
+%!assert (unidinv ([x(1:2) NaN x(4:5)], 10), [NaN NaN NaN 10 NaN], eps)
 
 %% Test class of input preserved
-%!assert(unidinv ([x, NaN], 10), [NaN NaN 5 10 NaN NaN], eps);
-%!assert(unidinv (single([x, NaN]), 10), single([NaN NaN 5 10 NaN NaN]), eps);
-%!assert(unidinv ([x, NaN], single(10)), single([NaN NaN 5 10 NaN NaN]), eps);
+%!assert (unidinv ([x, NaN], 10), [NaN NaN 5 10 NaN NaN], eps)
+%!assert (unidinv (single ([x, NaN]), 10), single ([NaN NaN 5 10 NaN NaN]), eps)
+%!assert (unidinv ([x, NaN], single (10)), single ([NaN NaN 5 10 NaN NaN]), eps)
 
 %% Test input validation
 %!error unidinv ()
 %!error unidinv (1)
 %!error unidinv (1,2,3)
-%!error unidinv (ones(3),ones(2))
-%!error unidinv (ones(2),ones(3))
+%!error unidinv (ones (3), ones (2))
+%!error unidinv (ones (2), ones (3))
 %!error unidinv (i, 2)
 %!error unidinv (2, i)
 
diff --git a/scripts/statistics/distributions/unidpdf.m b/scripts/statistics/distributions/unidpdf.m
--- a/scripts/statistics/distributions/unidpdf.m
+++ b/scripts/statistics/distributions/unidpdf.m
@@ -62,26 +62,26 @@ function pdf = unidpdf (x, n)
   endif
 
 endfunction
 
 
 %!shared x,y
 %! x = [-1 0 1 2 10 11];
 %! y = [0 0 0.1 0.1 0.1 0];
-%!assert(unidpdf (x, 10*ones(1,6)), y);
-%!assert(unidpdf (x, 10), y);
-%!assert(unidpdf (x, 10*[0 NaN 1 1 1 1]), [NaN NaN y(3:6)]);
-%!assert(unidpdf ([x, NaN], 10), [y, NaN]);
+%!assert (unidpdf (x, 10*ones (1,6)), y)
+%!assert (unidpdf (x, 10), y)
+%!assert (unidpdf (x, 10*[0 NaN 1 1 1 1]), [NaN NaN y(3:6)])
+%!assert (unidpdf ([x, NaN], 10), [y, NaN])
 
 %% Test class of input preserved
-%!assert(unidpdf (single([x, NaN]), 10), single([y, NaN]));
-%!assert(unidpdf ([x, NaN], single(10)), single([y, NaN]));
+%!assert (unidpdf (single ([x, NaN]), 10), single ([y, NaN]))
+%!assert (unidpdf ([x, NaN], single (10)), single ([y, NaN]))
 
 %% Test input validation
 %!error unidpdf ()
 %!error unidpdf (1)
 %!error unidpdf (1,2,3)
-%!error unidpdf (ones(3),ones(2))
-%!error unidpdf (ones(2),ones(3))
+%!error unidpdf (ones (3), ones (2))
+%!error unidpdf (ones (2), ones (3))
 %!error unidpdf (i, 2)
 %!error unidpdf (2, i)
 
diff --git a/scripts/statistics/distributions/unidrnd.m b/scripts/statistics/distributions/unidrnd.m
--- a/scripts/statistics/distributions/unidrnd.m
+++ b/scripts/statistics/distributions/unidrnd.m
@@ -86,26 +86,26 @@ function rnd = unidrnd (n, varargin)
 
     k = ! (n > 0 & n == fix (n));
     rnd(k) = NaN;
   endif
 
 endfunction
 
 
-%!assert(size (unidrnd (2)), [1, 1]);
-%!assert(size (unidrnd (ones(2,1))), [2, 1]);
-%!assert(size (unidrnd (ones(2,2))), [2, 2]);
-%!assert(size (unidrnd (10, [4 1])), [4, 1]);
-%!assert(size (unidrnd (10, 4, 1)), [4, 1]);
+%!assert (size (unidrnd (2)), [1, 1])
+%!assert (size (unidrnd (ones (2,1))), [2, 1])
+%!assert (size (unidrnd (ones (2,2))), [2, 2])
+%!assert (size (unidrnd (10, [4 1])), [4, 1])
+%!assert (size (unidrnd (10, 4, 1)), [4, 1])
 
 %% Test class of input preserved
-%!assert(class (unidrnd (2)), "double");
-%!assert(class (unidrnd (single(2))), "single");
-%!assert(class (unidrnd (single([2 2]))), "single");
+%!assert (class (unidrnd (2)), "double")
+%!assert (class (unidrnd (single (2))), "single")
+%!assert (class (unidrnd (single ([2 2]))), "single")
 
 %% Test input validation
 %!error unidrnd ()
 %!error unidrnd (10, [1;2;3])
-%!error unidrnd (10, 2, ones(2))
-%!error unidrnd (10*ones(2), 2, 1)
+%!error unidrnd (10, 2, ones (2))
+%!error unidrnd (10*ones (2), 2, 1)
 %!error unidrnd (i)
 
diff --git a/scripts/statistics/distributions/unifcdf.m b/scripts/statistics/distributions/unifcdf.m
--- a/scripts/statistics/distributions/unifcdf.m
+++ b/scripts/statistics/distributions/unifcdf.m
@@ -67,32 +67,32 @@ function cdf = unifcdf (x, a = 0, b = 1)
   endif
 
 endfunction
 
 
 %!shared x,y
 %! x = [-1 0 0.5 1 2] + 1;
 %! y = [0 0 0.5 1 1];
-%!assert(unifcdf (x, ones(1,5), 2*ones(1,5)), y);
-%!assert(unifcdf (x, 1, 2*ones(1,5)), y);
-%!assert(unifcdf (x, ones(1,5), 2), y);
-%!assert(unifcdf (x, [2 1 NaN 1 1], 2), [NaN 0 NaN 1 1]);
-%!assert(unifcdf (x, 1, 2*[0 1 NaN 1 1]), [NaN 0 NaN 1 1]);
-%!assert(unifcdf ([x(1:2) NaN x(4:5)], 1, 2), [y(1:2) NaN y(4:5)]);
+%!assert (unifcdf (x, ones (1,5), 2*ones (1,5)), y)
+%!assert (unifcdf (x, 1, 2*ones (1,5)), y)
+%!assert (unifcdf (x, ones (1,5), 2), y)
+%!assert (unifcdf (x, [2 1 NaN 1 1], 2), [NaN 0 NaN 1 1])
+%!assert (unifcdf (x, 1, 2*[0 1 NaN 1 1]), [NaN 0 NaN 1 1])
+%!assert (unifcdf ([x(1:2) NaN x(4:5)], 1, 2), [y(1:2) NaN y(4:5)])
 
 %% Test class of input preserved
-%!assert(unifcdf ([x, NaN], 1, 2), [y, NaN]);
-%!assert(unifcdf (single([x, NaN]), 1, 2), single([y, NaN]));
-%!assert(unifcdf ([x, NaN], single(1), 2), single([y, NaN]));
-%!assert(unifcdf ([x, NaN], 1, single(2)), single([y, NaN]));
+%!assert (unifcdf ([x, NaN], 1, 2), [y, NaN])
+%!assert (unifcdf (single ([x, NaN]), 1, 2), single ([y, NaN]))
+%!assert (unifcdf ([x, NaN], single (1), 2), single ([y, NaN]))
+%!assert (unifcdf ([x, NaN], 1, single (2)), single ([y, NaN]))
 
 %% Test input validation
 %!error unifcdf ()
 %!error unifcdf (1,2)
 %!error unifcdf (1,2,3,4)
-%!error unifcdf (ones(3),ones(2),ones(2))
-%!error unifcdf (ones(2),ones(3),ones(2))
-%!error unifcdf (ones(2),ones(2),ones(3))
+%!error unifcdf (ones (3), ones (2), ones (2))
+%!error unifcdf (ones (2), ones (3), ones (2))
+%!error unifcdf (ones (2), ones (2), ones (3))
 %!error unifcdf (i, 2, 2)
 %!error unifcdf (2, i, 2)
 %!error unifcdf (2, 2, i)
 
diff --git a/scripts/statistics/distributions/unifinv.m b/scripts/statistics/distributions/unifinv.m
--- a/scripts/statistics/distributions/unifinv.m
+++ b/scripts/statistics/distributions/unifinv.m
@@ -60,32 +60,32 @@ function inv = unifinv (x, a = 0, b = 1)
     inv(k) = a(k) + x(k) .* (b(k) - a(k));
   endif
 
 endfunction
 
 
 %!shared x
 %! x = [-1 0 0.5 1 2];
-%!assert(unifinv (x, ones(1,5), 2*ones(1,5)), [NaN 1 1.5 2 NaN]);
-%!assert(unifinv (x, 1, 2*ones(1,5)), [NaN 1 1.5 2 NaN]);
-%!assert(unifinv (x, ones(1,5), 2), [NaN 1 1.5 2 NaN]);
-%!assert(unifinv (x, [1 2 NaN 1 1], 2), [NaN NaN NaN 2 NaN]);
-%!assert(unifinv (x, 1, 2*[1 0 NaN 1 1]), [NaN NaN NaN 2 NaN]);
-%!assert(unifinv ([x(1:2) NaN x(4:5)], 1, 2), [NaN 1 NaN 2 NaN]);
+%!assert (unifinv (x, ones (1,5), 2*ones (1,5)), [NaN 1 1.5 2 NaN])
+%!assert (unifinv (x, 1, 2*ones (1,5)), [NaN 1 1.5 2 NaN])
+%!assert (unifinv (x, ones (1,5), 2), [NaN 1 1.5 2 NaN])
+%!assert (unifinv (x, [1 2 NaN 1 1], 2), [NaN NaN NaN 2 NaN])
+%!assert (unifinv (x, 1, 2*[1 0 NaN 1 1]), [NaN NaN NaN 2 NaN])
+%!assert (unifinv ([x(1:2) NaN x(4:5)], 1, 2), [NaN 1 NaN 2 NaN])
 
 %% Test class of input preserved
-%!assert(unifinv ([x, NaN], 1, 2), [NaN 1 1.5 2 NaN NaN]);
-%!assert(unifinv (single([x, NaN]), 1, 2), single([NaN 1 1.5 2 NaN NaN]));
-%!assert(unifinv ([x, NaN], single(1), 2), single([NaN 1 1.5 2 NaN NaN]));
-%!assert(unifinv ([x, NaN], 1, single(2)), single([NaN 1 1.5 2 NaN NaN]));
+%!assert (unifinv ([x, NaN], 1, 2), [NaN 1 1.5 2 NaN NaN])
+%!assert (unifinv (single ([x, NaN]), 1, 2), single ([NaN 1 1.5 2 NaN NaN]))
+%!assert (unifinv ([x, NaN], single (1), 2), single ([NaN 1 1.5 2 NaN NaN]))
+%!assert (unifinv ([x, NaN], 1, single (2)), single ([NaN 1 1.5 2 NaN NaN]))
 
 %% Test input validation
 %!error unifinv ()
 %!error unifinv (1,2)
 %!error unifinv (1,2,3,4)
-%!error unifinv (ones(3),ones(2),ones(2))
-%!error unifinv (ones(2),ones(3),ones(2))
-%!error unifinv (ones(2),ones(2),ones(3))
+%!error unifinv (ones (3), ones (2), ones (2))
+%!error unifinv (ones (2), ones (3), ones (2))
+%!error unifinv (ones (2), ones (2), ones (3))
 %!error unifinv (i, 2, 2)
 %!error unifinv (2, i, 2)
 %!error unifinv (2, 2, i)
 
diff --git a/scripts/statistics/distributions/unifpdf.m b/scripts/statistics/distributions/unifpdf.m
--- a/scripts/statistics/distributions/unifpdf.m
+++ b/scripts/statistics/distributions/unifpdf.m
@@ -63,31 +63,31 @@ function pdf = unifpdf (x, a = 0, b = 1)
   endif
 
 endfunction
 
 
 %!shared x,y
 %! x = [-1 0 0.5 1 2] + 1;
 %! y = [0 1 1 1 0];
-%!assert(unifpdf (x, ones(1,5), 2*ones(1,5)), y);
-%!assert(unifpdf (x, 1, 2*ones(1,5)), y);
-%!assert(unifpdf (x, ones(1,5), 2), y);
-%!assert(unifpdf (x, [2 NaN 1 1 1], 2), [NaN NaN y(3:5)]);
-%!assert(unifpdf (x, 1, 2*[0 NaN 1 1 1]), [NaN NaN y(3:5)]);
-%!assert(unifpdf ([x, NaN], 1, 2), [y, NaN]);
+%!assert (unifpdf (x, ones (1,5), 2*ones (1,5)), y)
+%!assert (unifpdf (x, 1, 2*ones (1,5)), y)
+%!assert (unifpdf (x, ones (1,5), 2), y)
+%!assert (unifpdf (x, [2 NaN 1 1 1], 2), [NaN NaN y(3:5)])
+%!assert (unifpdf (x, 1, 2*[0 NaN 1 1 1]), [NaN NaN y(3:5)])
+%!assert (unifpdf ([x, NaN], 1, 2), [y, NaN])
 
 %% Test class of input preserved
-%!assert(unifpdf (single([x, NaN]), 1, 2), single([y, NaN]));
-%!assert(unifpdf (single([x, NaN]), single(1), 2), single([y, NaN]));
-%!assert(unifpdf ([x, NaN], 1, single(2)), single([y, NaN]));
+%!assert (unifpdf (single ([x, NaN]), 1, 2), single ([y, NaN]))
+%!assert (unifpdf (single ([x, NaN]), single (1), 2), single ([y, NaN]))
+%!assert (unifpdf ([x, NaN], 1, single (2)), single ([y, NaN]))
 
 %% Test input validation
 %!error unifpdf ()
 %!error unifpdf (1,2)
 %!error unifpdf (1,2,3,4)
-%!error unifpdf (ones(3),ones(2),ones(2))
-%!error unifpdf (ones(2),ones(3),ones(2))
-%!error unifpdf (ones(2),ones(2),ones(3))
+%!error unifpdf (ones (3), ones (2), ones (2))
+%!error unifpdf (ones (2), ones (3), ones (2))
+%!error unifpdf (ones (2), ones (2), ones (3))
 %!error unifpdf (i, 2, 2)
 %!error unifpdf (2, i, 2)
 %!error unifpdf (2, 2, i)
 
diff --git a/scripts/statistics/distributions/unifrnd.m b/scripts/statistics/distributions/unifrnd.m
--- a/scripts/statistics/distributions/unifrnd.m
+++ b/scripts/statistics/distributions/unifrnd.m
@@ -93,40 +93,40 @@ function rnd = unifrnd (a, b, varargin)
 
     k = !(-Inf < a) | !(a < b) | !(b < Inf);
     rnd(k) = NaN;
   endif
 
 endfunction
 
 
-%!assert(size (unifrnd (1,2)), [1, 1]);
-%!assert(size (unifrnd (ones(2,1), 2)), [2, 1]);
-%!assert(size (unifrnd (ones(2,2), 2)), [2, 2]);
-%!assert(size (unifrnd (1, 2*ones(2,1))), [2, 1]);
-%!assert(size (unifrnd (1, 2*ones(2,2))), [2, 2]);
-%!assert(size (unifrnd (1, 2, 3)), [3, 3]);
-%!assert(size (unifrnd (1, 2, [4 1])), [4, 1]);
-%!assert(size (unifrnd (1, 2, 4, 1)), [4, 1]);
+%!assert (size (unifrnd (1,2)), [1, 1])
+%!assert (size (unifrnd (ones (2,1), 2)), [2, 1])
+%!assert (size (unifrnd (ones (2,2), 2)), [2, 2])
+%!assert (size (unifrnd (1, 2*ones (2,1))), [2, 1])
+%!assert (size (unifrnd (1, 2*ones (2,2))), [2, 2])
+%!assert (size (unifrnd (1, 2, 3)), [3, 3])
+%!assert (size (unifrnd (1, 2, [4 1])), [4, 1])
+%!assert (size (unifrnd (1, 2, 4, 1)), [4, 1])
 
 %% Test class of input preserved
-%!assert(class (unifrnd (1, 2)), "double");
-%!assert(class (unifrnd (single(1), 2)), "single");
-%!assert(class (unifrnd (single([1 1]), 2)), "single");
-%!assert(class (unifrnd (1, single(2))), "single");
-%!assert(class (unifrnd (1, single([2 2]))), "single");
+%!assert (class (unifrnd (1, 2)), "double")
+%!assert (class (unifrnd (single (1), 2)), "single")
+%!assert (class (unifrnd (single ([1 1]), 2)), "single")
+%!assert (class (unifrnd (1, single (2))), "single")
+%!assert (class (unifrnd (1, single ([2 2]))), "single")
 
 %% Test input validation
 %!error unifrnd ()
 %!error unifrnd (1)
-%!error unifrnd (ones(3),ones(2))
-%!error unifrnd (ones(2),ones(3))
+%!error unifrnd (ones (3), ones (2))
+%!error unifrnd (ones (2), ones (3))
 %!error unifrnd (i, 2)
 %!error unifrnd (2, i)
 %!error unifrnd (1,2, -1)
-%!error unifrnd (1,2, ones(2))
+%!error unifrnd (1,2, ones (2))
 %!error unifrnd (1, 2, [2 -1 2])
-%!error unifrnd (1,2, 1, ones(2))
+%!error unifrnd (1,2, 1, ones (2))
 %!error unifrnd (1,2, 1, -1)
-%!error unifrnd (ones(2,2), 2, 3)
-%!error unifrnd (ones(2,2), 2, [3, 2])
-%!error unifrnd (ones(2,2), 2, 2, 3)
+%!error unifrnd (ones (2,2), 2, 3)
+%!error unifrnd (ones (2,2), 2, [3, 2])
+%!error unifrnd (ones (2,2), 2, 2, 3)
 
diff --git a/scripts/statistics/distributions/wblcdf.m b/scripts/statistics/distributions/wblcdf.m
--- a/scripts/statistics/distributions/wblcdf.m
+++ b/scripts/statistics/distributions/wblcdf.m
@@ -83,31 +83,31 @@ function cdf = wblcdf (x, scale = 1, sha
   endif
 
 endfunction
 
 
 %!shared x,y
 %! x = [-1 0 0.5 1 Inf];
 %! y = [0, 1-exp(-x(2:4)), 1];
-%!assert(wblcdf (x, ones(1,5), ones(1,5)), y);
-%!assert(wblcdf (x, 1, ones(1,5)), y);
-%!assert(wblcdf (x, ones(1,5), 1), y);
-%!assert(wblcdf (x, [0 1 NaN Inf 1], 1), [NaN 0 NaN NaN 1]);
-%!assert(wblcdf (x, 1, [0 1 NaN Inf 1]), [NaN 0 NaN NaN 1]);
-%!assert(wblcdf ([x(1:2) NaN x(4:5)], 1, 1), [y(1:2) NaN y(4:5)]);
+%!assert (wblcdf (x, ones (1,5), ones (1,5)), y)
+%!assert (wblcdf (x, 1, ones (1,5)), y)
+%!assert (wblcdf (x, ones (1,5), 1), y)
+%!assert (wblcdf (x, [0 1 NaN Inf 1], 1), [NaN 0 NaN NaN 1])
+%!assert (wblcdf (x, 1, [0 1 NaN Inf 1]), [NaN 0 NaN NaN 1])
+%!assert (wblcdf ([x(1:2) NaN x(4:5)], 1, 1), [y(1:2) NaN y(4:5)])
 
 %% Test class of input preserved
-%!assert(wblcdf ([x, NaN], 1, 1), [y, NaN]);
-%!assert(wblcdf (single([x, NaN]), 1, 1), single([y, NaN]));
-%!assert(wblcdf ([x, NaN], single(1), 1), single([y, NaN]));
-%!assert(wblcdf ([x, NaN], 1, single(1)), single([y, NaN]));
+%!assert (wblcdf ([x, NaN], 1, 1), [y, NaN])
+%!assert (wblcdf (single ([x, NaN]), 1, 1), single ([y, NaN]))
+%!assert (wblcdf ([x, NaN], single (1), 1), single ([y, NaN]))
+%!assert (wblcdf ([x, NaN], 1, single (1)), single ([y, NaN]))
 
 %% Test input validation
 %!error wblcdf ()
 %!error wblcdf (1,2,3,4)
-%!error wblcdf (ones(3),ones(2),ones(2))
-%!error wblcdf (ones(2),ones(3),ones(2))
-%!error wblcdf (ones(2),ones(2),ones(3))
+%!error wblcdf (ones (3), ones (2), ones (2))
+%!error wblcdf (ones (2), ones (3), ones (2))
+%!error wblcdf (ones (2), ones (2), ones (3))
 %!error wblcdf (i, 2, 2)
 %!error wblcdf (2, i, 2)
 %!error wblcdf (2, 2, i)
 
diff --git a/scripts/statistics/distributions/wblinv.m b/scripts/statistics/distributions/wblinv.m
--- a/scripts/statistics/distributions/wblinv.m
+++ b/scripts/statistics/distributions/wblinv.m
@@ -69,31 +69,31 @@ function inv = wblinv (x, scale = 1, sha
     inv(k) = scale(k) .* (- log (1 - x(k))) .^ (1 ./ shape(k));
   endif
 
 endfunction
 
 
 %!shared x
 %! x = [-1 0 0.63212055882855778 1 2];
-%!assert(wblinv (x, ones(1,5), ones(1,5)), [NaN 0 1 Inf NaN], eps);
-%!assert(wblinv (x, 1, ones(1,5)), [NaN 0 1 Inf NaN], eps);
-%!assert(wblinv (x, ones(1,5), 1), [NaN 0 1 Inf NaN], eps);
-%!assert(wblinv (x, [1 -1 NaN Inf 1], 1), [NaN NaN NaN NaN NaN]);
-%!assert(wblinv (x, 1, [1 -1 NaN Inf 1]), [NaN NaN NaN NaN NaN]);
-%!assert(wblinv ([x(1:2) NaN x(4:5)], 1, 1), [NaN 0 NaN Inf NaN]);
+%!assert (wblinv (x, ones (1,5), ones (1,5)), [NaN 0 1 Inf NaN], eps)
+%!assert (wblinv (x, 1, ones (1,5)), [NaN 0 1 Inf NaN], eps)
+%!assert (wblinv (x, ones (1,5), 1), [NaN 0 1 Inf NaN], eps)
+%!assert (wblinv (x, [1 -1 NaN Inf 1], 1), [NaN NaN NaN NaN NaN])
+%!assert (wblinv (x, 1, [1 -1 NaN Inf 1]), [NaN NaN NaN NaN NaN])
+%!assert (wblinv ([x(1:2) NaN x(4:5)], 1, 1), [NaN 0 NaN Inf NaN])
 
 %% Test class of input preserved
-%!assert(wblinv ([x, NaN], 1, 1), [NaN 0 1 Inf NaN NaN], eps);
-%!assert(wblinv (single([x, NaN]), 1, 1), single([NaN 0 1 Inf NaN NaN]), eps("single"));
-%!assert(wblinv ([x, NaN], single(1), 1), single([NaN 0 1 Inf NaN NaN]), eps("single"));
-%!assert(wblinv ([x, NaN], 1, single(1)), single([NaN 0 1 Inf NaN NaN]), eps("single"));
+%!assert (wblinv ([x, NaN], 1, 1), [NaN 0 1 Inf NaN NaN], eps)
+%!assert (wblinv (single ([x, NaN]), 1, 1), single ([NaN 0 1 Inf NaN NaN]), eps ("single"))
+%!assert (wblinv ([x, NaN], single (1), 1), single ([NaN 0 1 Inf NaN NaN]), eps ("single"))
+%!assert (wblinv ([x, NaN], 1, single (1)), single ([NaN 0 1 Inf NaN NaN]), eps ("single"))
 
 %% Test input validation
 %!error wblinv ()
 %!error wblinv (1,2,3,4)
-%!error wblinv (ones(3),ones(2),ones(2))
-%!error wblinv (ones(2),ones(3),ones(2))
-%!error wblinv (ones(2),ones(2),ones(3))
+%!error wblinv (ones (3), ones (2), ones (2))
+%!error wblinv (ones (2), ones (3), ones (2))
+%!error wblinv (ones (2), ones (2), ones (3))
 %!error wblinv (i, 2, 2)
 %!error wblinv (2, i, 2)
 %!error wblinv (2, 2, i)
 
diff --git a/scripts/statistics/distributions/wblpdf.m b/scripts/statistics/distributions/wblpdf.m
--- a/scripts/statistics/distributions/wblpdf.m
+++ b/scripts/statistics/distributions/wblpdf.m
@@ -25,17 +25,17 @@
 ## Weibull distribution with scale parameter @var{scale} and shape
 ## parameter @var{shape} which is given by
 ## @tex
 ## $$  {shape \over scale^{shape}} \cdot x^{shape-1} \cdot e^{-({x \over scale})^{shape}} $$
 ## @end tex
 ## @ifnottex
 ##
 ## @example
-##    shape * scale^(-shape) * x^(shape-1) * exp (-(x/scale)^shape)
+## shape * scale^(-shape) * x^(shape-1) * exp (-(x/scale)^shape)
 ## @end example
 ##
 ## @end ifnottex
 ## @noindent
 ## for @var{x} @geq{} 0.
 ##
 ## Default values are @var{scale} = 1, @var{shape} = 1.
 ## @end deftypefn
@@ -83,30 +83,30 @@ function pdf = wblpdf (x, scale = 1, sha
   endif
 
 endfunction
 
 
 %!shared x,y
 %! x = [-1 0 0.5 1 Inf];
 %! y = [0, exp(-x(2:4)), NaN];
-%!assert(wblpdf (x, ones(1,5), ones(1,5)), y);
-%!assert(wblpdf (x, 1, ones(1,5)), y);
-%!assert(wblpdf (x, ones(1,5), 1), y);
-%!assert(wblpdf (x, [0 NaN Inf 1 1], 1), [NaN NaN NaN y(4:5)]);
-%!assert(wblpdf (x, 1, [0 NaN Inf 1 1]), [NaN NaN NaN y(4:5)]);
-%!assert(wblpdf ([x, NaN], 1, 1), [y, NaN]);
+%!assert (wblpdf (x, ones (1,5), ones (1,5)), y)
+%!assert (wblpdf (x, 1, ones (1,5)), y)
+%!assert (wblpdf (x, ones (1,5), 1), y)
+%!assert (wblpdf (x, [0 NaN Inf 1 1], 1), [NaN NaN NaN y(4:5)])
+%!assert (wblpdf (x, 1, [0 NaN Inf 1 1]), [NaN NaN NaN y(4:5)])
+%!assert (wblpdf ([x, NaN], 1, 1), [y, NaN])
 
 %% Test class of input preserved
-%!assert(wblpdf (single([x, NaN]), 1, 1), single([y, NaN]));
-%!assert(wblpdf ([x, NaN], single(1), 1), single([y, NaN]));
-%!assert(wblpdf ([x, NaN], 1, single(1)), single([y, NaN]));
+%!assert (wblpdf (single ([x, NaN]), 1, 1), single ([y, NaN]))
+%!assert (wblpdf ([x, NaN], single (1), 1), single ([y, NaN]))
+%!assert (wblpdf ([x, NaN], 1, single (1)), single ([y, NaN]))
 
 %% Test input validation
 %!error wblpdf ()
 %!error wblpdf (1,2,3,4)
-%!error wblpdf (ones(3),ones(2),ones(2))
-%!error wblpdf (ones(2),ones(3),ones(2))
-%!error wblpdf (ones(2),ones(2),ones(3))
+%!error wblpdf (ones (3), ones (2), ones (2))
+%!error wblpdf (ones (2), ones (3), ones (2))
+%!error wblpdf (ones (2), ones (2), ones (3))
 %!error wblpdf (i, 2, 2)
 %!error wblpdf (2, i, 2)
 %!error wblpdf (2, 2, i)
 
diff --git a/scripts/statistics/distributions/wblrnd.m b/scripts/statistics/distributions/wblrnd.m
--- a/scripts/statistics/distributions/wblrnd.m
+++ b/scripts/statistics/distributions/wblrnd.m
@@ -93,40 +93,40 @@ function rnd = wblrnd (scale, shape, var
 
     k = (scale <= 0) | (scale == Inf) | (shape <= 0) | (shape == Inf);
     rnd(k) = NaN;
   endif
 
 endfunction
 
 
-%!assert(size (wblrnd (1,2)), [1, 1]);
-%!assert(size (wblrnd (ones(2,1), 2)), [2, 1]);
-%!assert(size (wblrnd (ones(2,2), 2)), [2, 2]);
-%!assert(size (wblrnd (1, 2*ones(2,1))), [2, 1]);
-%!assert(size (wblrnd (1, 2*ones(2,2))), [2, 2]);
-%!assert(size (wblrnd (1, 2, 3)), [3, 3]);
-%!assert(size (wblrnd (1, 2, [4 1])), [4, 1]);
-%!assert(size (wblrnd (1, 2, 4, 1)), [4, 1]);
+%!assert (size (wblrnd (1,2)), [1, 1])
+%!assert (size (wblrnd (ones (2,1), 2)), [2, 1])
+%!assert (size (wblrnd (ones (2,2), 2)), [2, 2])
+%!assert (size (wblrnd (1, 2*ones (2,1))), [2, 1])
+%!assert (size (wblrnd (1, 2*ones (2,2))), [2, 2])
+%!assert (size (wblrnd (1, 2, 3)), [3, 3])
+%!assert (size (wblrnd (1, 2, [4 1])), [4, 1])
+%!assert (size (wblrnd (1, 2, 4, 1)), [4, 1])
 
 %% Test class of input preserved
-%!assert(class (wblrnd (1, 2)), "double");
-%!assert(class (wblrnd (single(1), 2)), "single");
-%!assert(class (wblrnd (single([1 1]), 2)), "single");
-%!assert(class (wblrnd (1, single(2))), "single");
-%!assert(class (wblrnd (1, single([2 2]))), "single");
+%!assert (class (wblrnd (1, 2)), "double")
+%!assert (class (wblrnd (single (1), 2)), "single")
+%!assert (class (wblrnd (single ([1 1]), 2)), "single")
+%!assert (class (wblrnd (1, single (2))), "single")
+%!assert (class (wblrnd (1, single ([2 2]))), "single")
 
 %% Test input validation
 %!error wblrnd ()
 %!error wblrnd (1)
-%!error wblrnd (ones(3),ones(2))
-%!error wblrnd (ones(2),ones(3))
+%!error wblrnd (ones (3), ones (2))
+%!error wblrnd (ones (2), ones (3))
 %!error wblrnd (i, 2)
 %!error wblrnd (2, i)
 %!error wblrnd (1,2, -1)
-%!error wblrnd (1,2, ones(2))
+%!error wblrnd (1,2, ones (2))
 %!error wblrnd (1, 2, [2 -1 2])
-%!error wblrnd (1,2, 1, ones(2))
+%!error wblrnd (1,2, 1, ones (2))
 %!error wblrnd (1,2, 1, -1)
-%!error wblrnd (ones(2,2), 2, 3)
-%!error wblrnd (ones(2,2), 2, [3, 2])
-%!error wblrnd (ones(2,2), 2, 2, 3)
+%!error wblrnd (ones (2,2), 2, 3)
+%!error wblrnd (ones (2,2), 2, [3, 2])
+%!error wblrnd (ones (2,2), 2, 2, 3)
 
diff --git a/scripts/statistics/tests/kolmogorov_smirnov_test.m b/scripts/statistics/tests/kolmogorov_smirnov_test.m
--- a/scripts/statistics/tests/kolmogorov_smirnov_test.m
+++ b/scripts/statistics/tests/kolmogorov_smirnov_test.m
@@ -105,22 +105,23 @@ function [pval, ks] = kolmogorov_smirnov
   endif
 
   if (nargout == 0)
     printf ("pval: %g\n", pval);
   endif
 
 endfunction
 
-%!error <Invalid call to kolmogorov_smirnov_test>
-%!  kolmogorov_smirnov_test (1);
-%!error <kolmogorov_smirnov_test: X must be a vector>
-%!  kolmogorov_smirnov_test ({}, "unif", 2, 4);
-%!error <kolmogorov_smirnov_test: no not_a_distcdf or not_a_dist_cdf function found>
+
+## test for recognition of unifcdf function
+%!assert (kolmogorov_smirnov_test (0:100, "unif", 0, 100), 1.0, eps)
+## test for recognition of logistic_cdf function
+%!assert (kolmogorov_smirnov_test (0:100, "logistic"), 0)
+## test for  F < G
+%!assert (kolmogorov_smirnov_test (50:100, "unif", 0, 50, "<"))
+
+%!error kolmogorov_smirnov_test (1)
+%!error <X must be a vector> kolmogorov_smirnov_test ({}, "unif", 2, 4)
+%!error <no not_a_distcdf or not_a_dist_cdf function found>
 %!  kolmogorov_smirnov_test (1, "not_a_dist");
-%!error <kolmogorov_smirnov_test: alternative bla not recognized>
-%!  kolmogorov_smirnov_test (1, "unif", 2, 4, "bla");
-%!test # for recognition of unifcdf function
-%!  assert (kolmogorov_smirnov_test (0:100, "unif", 0, 100), 1.0, eps);
-%!test # for recognition of logistic_cdf function
-%!  assert (kolmogorov_smirnov_test (0:100, "logistic"), 0);
-%!test # F < G
-%!  assert (kolmogorov_smirnov_test (50:100, "unif", 0, 50, "<"));
+%!error <alternative foo not recognized>
+%!  kolmogorov_smirnov_test (1, "unif", 2, 4, "foo");
+
diff --git a/scripts/statistics/tests/kruskal_wallis_test.m b/scripts/statistics/tests/kruskal_wallis_test.m
--- a/scripts/statistics/tests/kruskal_wallis_test.m
+++ b/scripts/statistics/tests/kruskal_wallis_test.m
@@ -89,10 +89,11 @@ function [pval, k, df] = kruskal_wallis_
   pval = 1 - chi2cdf (k, df);
 
   if (nargout == 0)
     printf ("pval: %g\n", pval);
   endif
 
 endfunction
 
+
 ## Test with ties
-%!assert (abs(kruskal_wallis_test([86 86], [74]) - 0.157299207050285) < 0.0000000000001)
+%!assert (abs (kruskal_wallis_test ([86 86], [74]) - 0.157299207050285) < 0.0000000000001)
diff --git a/scripts/strings/base2dec.m b/scripts/strings/base2dec.m
--- a/scripts/strings/base2dec.m
+++ b/scripts/strings/base2dec.m
@@ -19,17 +19,17 @@
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} base2dec (@var{s}, @var{base})
 ## Convert @var{s} from a string of digits in base @var{base} to a decimal
 ## integer (base 10).
 ##
 ## @example
 ## @group
 ## base2dec ("11120", 3)
-##      @result{} 123
+##    @result{} 123
 ## @end group
 ## @end example
 ##
 ## If @var{s} is a string matrix, return a column vector with one value per
 ## row of @var{s}.  If a row contains invalid symbols then the
 ## corresponding value will be NaN@.  
 ##
 ## If @var{s} is a cell array of strings, return a column vector with one
@@ -37,17 +37,17 @@
 ##
 ## If @var{base} is a string, the characters of @var{base} are used as the
 ## symbols for the digits of @var{s}.  Space (' ') may not be used as a
 ## symbol.
 ##
 ## @example
 ## @group
 ## base2dec ("yyyzx", "xyz")
-##      @result{} 123
+##    @result{} 123
 ## @end group
 ## @end example
 ## @seealso{dec2base, bin2dec, hex2dec}
 ## @end deftypefn
 
 ## Author: Daniel Calvelo <dcalvelo@yahoo.com>
 ## Adapted-by: Paul Kienzle <pkienzle@kienzle.powernet.co.uk>
 
@@ -93,22 +93,22 @@ function out = base2dec (s, base)
 
   ## Multiply the resulting digits by the appropriate power
   ## and sum the rows.
   out = s * (base .^ (columns(s)-1 : -1 : 0)');
 
 endfunction
 
 
-%!assert(base2dec ("11120", 3), 123);
-%!assert(base2dec ("yyyzx", "xyz"), 123);
-%!assert(base2dec ("-1", 2), NaN);
-%!assert(base2dec ({"A1", "1A"}, 16), [161; 26]);
+%!assert (base2dec ("11120", 3), 123)
+%!assert (base2dec ("yyyzx", "xyz"), 123)
+%!assert (base2dec ("-1", 2), NaN)
+%!assert (base2dec ({"A1", "1A"}, 16), [161; 26])
 
 %%Test input validation
-%!error base2dec ();
-%!error base2dec ("11120");
-%!error base2dec ("11120", 3, 4);
-%!error base2dec ("11120", "1231");
-%!error base2dec ("11120", "12 3");
-%!error base2dec ("11120", ones(2));
-%!error base2dec ("11120", 37);
+%!error base2dec ()
+%!error base2dec ("11120")
+%!error base2dec ("11120", 3, 4)
+%!error base2dec ("11120", "1231")
+%!error base2dec ("11120", "12 3")
+%!error base2dec ("11120", ones (2))
+%!error base2dec ("11120", 37)
 
diff --git a/scripts/strings/bin2dec.m b/scripts/strings/bin2dec.m
--- a/scripts/strings/bin2dec.m
+++ b/scripts/strings/bin2dec.m
@@ -45,18 +45,18 @@ function d = bin2dec (s)
     print_usage ();
   endif
 
   d = base2dec (s, 2);
 
 endfunction
 
 
-%!assert(bin2dec ("0000"), 0);
-%!assert(bin2dec ("1110"), 14);
-%!assert(bin2dec ("11111111111111111111111111111111111111111111111111111"), 2^53-1);
-%!assert(bin2dec ({"1110", "1111"}), [14; 15]);
+%!assert (bin2dec ("0000"), 0)
+%!assert (bin2dec ("1110"), 14)
+%!assert (bin2dec ("11111111111111111111111111111111111111111111111111111"), 2^53-1)
+%!assert (bin2dec ({"1110", "1111"}), [14; 15])
 
 %%Test input validation
-%!error bin2dec ();
-%!error bin2dec (1);
-%!error bin2dec ("1", 2);
+%!error bin2dec ()
+%!error bin2dec (1)
+%!error bin2dec ("1", 2)
 
diff --git a/scripts/strings/blanks.m b/scripts/strings/blanks.m
--- a/scripts/strings/blanks.m
+++ b/scripts/strings/blanks.m
@@ -47,19 +47,19 @@ function s = blanks (n)
   ## If 1:n is empty, the following expression will create an empty
   ## character string.  Otherwise, it will create a row vector.
   s(1:n) = " ";
 
 endfunction
 
 
 ## There really isn't that much to test here
-%!assert(blanks (0), "")
-%!assert(blanks (5), "     ")
-%!assert(blanks (10), "          ")
+%!assert (blanks (0), "")
+%!assert (blanks (5), "     ")
+%!assert (blanks (10), "          ")
 
 %% Test input validation
 %!error blanks ()
 %!error blanks (1, 2)
 %!error blanks (ones (2))
 %!error blanks (2.1)
 %!error blanks (-2)
 
diff --git a/scripts/strings/cstrcat.m b/scripts/strings/cstrcat.m
--- a/scripts/strings/cstrcat.m
+++ b/scripts/strings/cstrcat.m
@@ -19,26 +19,25 @@
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} cstrcat (@var{s1}, @var{s2}, @dots{})
 ## Return a string containing all the arguments concatenated
 ## horizontally.  Trailing white space is preserved.  For example:
 ##
 ## @example
 ## @group
 ## cstrcat ("ab   ", "cd")
-##      @result{} "ab   cd"
+##       @result{} "ab   cd"
 ## @end group
 ## @end example
 ##
 ## @example
 ## @group
 ## s = [ "ab"; "cde" ];
 ## cstrcat (s, s, s)
-##      @result{} ans =
-##         "ab ab ab "
+##      @result{} "ab ab ab "
 ##         "cdecdecde"
 ## @end group
 ## @end example
 ## @seealso{strcat, char, strvcat}
 ## @end deftypefn
 
 ## Author: jwe
 
@@ -60,11 +59,11 @@ endfunction
 %!assert (cstrcat ("ab ", "ab "), "ab ab ")
 ## 2d
 %!assert (cstrcat (["ab ";"cde"], ["ab ";"cde"]), ["ab ab ";"cdecde"])
 
 %!assert (cstrcat ("foo", "bar"), "foobar")
 %!assert (cstrcat (["a"; "bb"], ["foo"; "bar"]), ["a foo"; "bbbar"])
 
 %% Test input validation
-%!error cstrcat ();
-%!error cstrcat (1, 2);
+%!error cstrcat ()
+%!error cstrcat (1, 2)
 
diff --git a/scripts/strings/deblank.m b/scripts/strings/deblank.m
--- a/scripts/strings/deblank.m
+++ b/scripts/strings/deblank.m
@@ -70,20 +70,20 @@ function s = deblank (s)
 
   else
     error ("deblank: S argument must be a string or cellstring");
   endif
 
 endfunction
 
 
-%!assert (deblank (" f o o \0"), " f o o");
-%!assert (deblank ('   '), '');
-%!assert (deblank ("   "), "");
-%!assert (deblank (""), "");
-%!assert (deblank ({}), {});
-%!assert (deblank ({" abc   ", {"   def   "}}), {" abc", {"   def"}});
+%!assert (deblank (" f o o \0"), " f o o")
+%!assert (deblank ('   '), '')
+%!assert (deblank ("   "), "")
+%!assert (deblank (""), "")
+%!assert (deblank ({}), {})
+%!assert (deblank ({" abc   ", {"   def   "}}), {" abc", {"   def"}})
 
-%!error <Invalid call to deblank> deblank ();
-%!error <Invalid call to deblank> deblank ("foo", "bar");
-%!error <argument must be a string> deblank (1);
-%!error <argument must be a string> deblank ({[]});
+%!error <Invalid call to deblank> deblank ()
+%!error <Invalid call to deblank> deblank ("foo", "bar")
+%!error <argument must be a string> deblank (1)
+%!error <argument must be a string> deblank ({[]})
 
diff --git a/scripts/strings/dec2base.m b/scripts/strings/dec2base.m
--- a/scripts/strings/dec2base.m
+++ b/scripts/strings/dec2base.m
@@ -20,32 +20,32 @@
 ## @deftypefn  {Function File} {} dec2base (@var{d}, @var{base})
 ## @deftypefnx {Function File} {} dec2base (@var{d}, @var{base}, @var{len})
 ## Return a string of symbols in base @var{base} corresponding to
 ## the non-negative integer @var{d}.
 ##
 ## @example
 ## @group
 ## dec2base (123, 3)
-##      @result{} "11120"
+##    @result{} "11120"
 ## @end group
 ## @end example
 ##
 ## If @var{d} is a matrix or cell array, return a string matrix with one
 ## row per element in @var{d}, padded with leading zeros to the width of 
 ## the largest value.
 ##
 ## If @var{base} is a string then the characters of @var{base} are used as
 ## the symbols for the digits of @var{d}.  Space (' ') may not be used
 ## as a symbol.
 ##
 ## @example
 ## @group
 ## dec2base (123, "aei")
-##      @result{} "eeeia"
+##    @result{} "eeeia"
 ## @end group
 ## @end example
 ##
 ## The optional third argument, @var{len}, specifies the minimum
 ## number of digits in the result.
 ## @seealso{base2dec, dec2bin, dec2hex}
 ## @end deftypefn
 
@@ -114,47 +114,47 @@ function retval = dec2base (d, base, len
       && length (retval) != 1 && ! any (retval(:,1) != symbols(1)))
     retval = retval(:,2:end);
   endif
 
 endfunction
 
 
 %!test
-%! s0 = '';
+%! s0 = "";
 %! for n = 1:13
 %!   for b = 2:16
 %!     pp = dec2base (b^n+1, b);
-%!     assert (dec2base(b^n, b), ['1',s0,'0']);
-%!     assert (dec2base(b^n+1, b), ['1',s0,'1']);
+%!     assert (dec2base (b^n, b), ['1',s0,'0']);
+%!     assert (dec2base (b^n+1, b), ['1',s0,'1']);
 %!   endfor
 %!   s0 = [s0,'0'];
 %! endfor
 
 %!test
-%! digits='0123456789ABCDEF';
+%! digits = "0123456789ABCDEF";
 %! for n = 1:13
 %!   for b = 2:16
-%!     pm = dec2base(b^n-1, b);
+%!     pm = dec2base (b^n-1, b);
 %!     assert (length (pm), n);
-%!     assert (all (pm==digits(b)));
+%!     assert (all (pm == digits(b)));
 %!   endfor
 %! endfor
 
 %!test
 %! for b = 2:16
 %!   assert (dec2base (0, b), '0');
 %! endfor
 
-%!assert(dec2base (0, 2, 4), "0000");
-%!assert(dec2base (2^51-1, 2), ...
-%!       '111111111111111111111111111111111111111111111111111');
-%!assert(dec2base(uint64(2)^63-1, 16), '7FFFFFFFFFFFFFFF');
-%!assert(dec2base([1, 2; 3, 4], 2, 3), ["001"; "011"; "010"; "100"]);
-%!assert(dec2base({1, 2; 3, 4}, 2, 3), ["001"; "011"; "010"; "100"]);
+%!assert (dec2base (0, 2, 4), "0000")
+%!assert (dec2base (2^51-1, 2), ...
+%!        "111111111111111111111111111111111111111111111111111")
+%!assert (dec2base (uint64 (2)^63-1, 16), "7FFFFFFFFFFFFFFF")
+%!assert (dec2base ([1, 2; 3, 4], 2, 3), ["001"; "011"; "010"; "100"])
+%!assert (dec2base ({1, 2; 3, 4}, 2, 3), ["001"; "011"; "010"; "100"])
 
 %%Test input validation
 %!error dec2base ()
 %!error dec2base (1)
 %!error dec2base (1, 2, 3, 4)
 %!error dec2base ("A")
 %!error dec2base (2i)
 %!error dec2base (-1)
diff --git a/scripts/strings/dec2bin.m b/scripts/strings/dec2bin.m
--- a/scripts/strings/dec2bin.m
+++ b/scripts/strings/dec2bin.m
@@ -48,16 +48,16 @@ function b = dec2bin (d, len)
     b = dec2base (d, 2, len);
   else
     print_usage ();
   endif
 
 endfunction
 
 
-%!assert(dec2bin (14), "1110");
-%!assert(dec2bin (14, 6), "001110");
-%!assert(dec2bin ({1, 2; 3, 4}), ["001"; "011"; "010"; "100"]);
+%!assert (dec2bin (14), "1110")
+%!assert (dec2bin (14, 6), "001110")
+%!assert (dec2bin ({1, 2; 3, 4}), ["001"; "011"; "010"; "100"])
 
 %%Test input validation
-%!error dec2bin ();
-%!error dec2bin (1, 2, 3);
+%!error dec2bin ()
+%!error dec2bin (1, 2, 3)
 
diff --git a/scripts/strings/dec2hex.m b/scripts/strings/dec2hex.m
--- a/scripts/strings/dec2hex.m
+++ b/scripts/strings/dec2hex.m
@@ -48,16 +48,16 @@ function h = dec2hex (d, len)
     h = dec2base (d, 16, len);
   else
     print_usage ();
   endif
 
 endfunction
 
 
-%!assert(dec2hex (2748), "ABC");
-%!assert(dec2hex (2748, 5), "00ABC");
-%!assert(dec2hex ({2748, 2746}), ["ABC"; "ABA"]);
+%!assert (dec2hex (2748), "ABC")
+%!assert (dec2hex (2748, 5), "00ABC")
+%!assert (dec2hex ({2748, 2746}), ["ABC"; "ABA"])
 
 %% Test input validation
-%!error dec2hex ();
-%!error dec2hex (1, 2, 3);
+%!error dec2hex ()
+%!error dec2hex (1, 2, 3)
 
diff --git a/scripts/strings/findstr.m b/scripts/strings/findstr.m
--- a/scripts/strings/findstr.m
+++ b/scripts/strings/findstr.m
@@ -128,16 +128,16 @@ function v = findstr (s, t, overlap = tr
   if (iscolumn (v))
     v = v.';
   endif
 
 endfunction
 
 
 %!assert (findstr ("abababa", "a"), [1, 3, 5, 7])
-%!assert (findstr ("abababa", "aba"), [1, 3, 5]);
-%!assert (findstr ("aba", "abababa", 0), [1, 5]);
+%!assert (findstr ("abababa", "aba"), [1, 3, 5])
+%!assert (findstr ("aba", "abababa", 0), [1, 5])
 
 %% Test input validation
 %!error findstr ()
-%!error findstr ("foo", "bar", 3, 4);
-%!error findstr (["AB" ; "CD"], "C");
+%!error findstr ("foo", "bar", 3, 4)
+%!error <must have only one non-singleton dimension> findstr (["AB" ; "CD"], "C")
 
diff --git a/scripts/strings/hex2dec.m b/scripts/strings/hex2dec.m
--- a/scripts/strings/hex2dec.m
+++ b/scripts/strings/hex2dec.m
@@ -48,18 +48,18 @@ function d = hex2dec (s)
     print_usage ();
   endif
 
   d = base2dec (s, 16);
 
 endfunction
 
 
-%!assert(hex2dec ("0000"), 0);
-%!assert(hex2dec ("1FFFFFFFFFFFFF"), 2^53-1);
-%!assert(hex2dec (["12b"; "12B"]), [299; 299]);
-%!assert(hex2dec ({"A1", "1A"}), [161; 26]);
+%!assert (hex2dec ("0000"), 0)
+%!assert (hex2dec ("1FFFFFFFFFFFFF"), 2^53-1)
+%!assert (hex2dec (["12b"; "12B"]), [299; 299])
+%!assert (hex2dec ({"A1", "1A"}), [161; 26])
 
 %%Test input validation
-%!error hex2dec ();
-%!error hex2dec (1);
-%!error hex2dec ("1", 2);
+%!error hex2dec ()
+%!error hex2dec (1)
+%!error hex2dec ("1", 2)
 
diff --git a/scripts/strings/index.m b/scripts/strings/index.m
--- a/scripts/strings/index.m
+++ b/scripts/strings/index.m
@@ -23,17 +23,17 @@
 ## string @var{s}, or 0 if no occurrence is found.  @var{s} may also be a
 ## string array or cell array of strings.
 ##
 ## For example:
 ##
 ## @example
 ## @group
 ## index ("Teststring", "t")
-##      @result{} 4
+##    @result{} 4
 ## @end group
 ## @end example
 ##
 ## If @var{direction} is @samp{"first"}, return the first element found.
 ## If @var{direction} is @samp{"last"}, return the last element found.
 ##
 ## @seealso{find, rindex}
 ## @end deftypefn
@@ -79,30 +79,31 @@ function n = index (s, t, direction = "f
     endif
   else
     error ('index: DIRECTION must be either "first" or "last"');
   endif
 
 endfunction
 
 
-%!assert (index ("foobarbaz", "b") == 4 && index ("foobarbaz", "z") == 9);
+%!assert (index ("foobarbaz", "b"), 4)
+%!assert (index ("foobarbaz", "z"), 9)
 
-%!assert (index("astringbstringcstring", "s"), 2)
-%!assert (index("astringbstringcstring", "st"), 2)
-%!assert (index("astringbstringcstring", "str"), 2)
-%!assert (index("astringbstringcstring", "string"), 2)
-%!assert (index("abc---", "abc+++"), 0)
+%!assert (index ("astringbstringcstring", "s"), 2)
+%!assert (index ("astringbstringcstring", "st"), 2)
+%!assert (index ("astringbstringcstring", "str"), 2)
+%!assert (index ("astringbstringcstring", "string"), 2)
+%!assert (index ("abc---", "abc+++"), 0)
 
 ## test everything out in reverse
-%!assert (index("astringbstringcstring", "s", "last"), 16)
-%!assert (index("astringbstringcstring", "st", "last"), 16)
-%!assert (index("astringbstringcstring", "str", "last"), 16)
-%!assert (index("astringbstringcstring", "string", "last"), 16)
-%!assert (index("abc---", "abc+++", "last"), 0)
+%!assert (index ("astringbstringcstring", "s", "last"), 16)
+%!assert (index ("astringbstringcstring", "st", "last"), 16)
+%!assert (index ("astringbstringcstring", "str", "last"), 16)
+%!assert (index ("astringbstringcstring", "string", "last"), 16)
+%!assert (index ("abc---", "abc+++", "last"), 0)
 
 %!test
 %! str = char ("Hello", "World", "Goodbye", "World");
 %! assert (index (str, "o"), [5; 2; 2; 2]);
 %! assert (index (str, "o", "last"), [5; 2; 3; 2]);
 %! str = cellstr (str);
 %! assert (index (str, "o"), [5; 2; 2; 2]);
 %! assert (index (str, "o", "last"), [5; 2; 3; 2]);
diff --git a/scripts/strings/isletter.m b/scripts/strings/isletter.m
--- a/scripts/strings/isletter.m
+++ b/scripts/strings/isletter.m
@@ -31,10 +31,12 @@ function retval = isletter (s)
   if (nargin != 1)
     print_usage ();
   endif
 
   retval = isalpha (s);
 
 endfunction
 
-%!error isletter();
-%!error isletter("a", "b");
+
+%!error isletter ()
+%!error isletter ("a", "b")
+
diff --git a/scripts/strings/mat2str.m b/scripts/strings/mat2str.m
--- a/scripts/strings/mat2str.m
+++ b/scripts/strings/mat2str.m
@@ -123,25 +123,25 @@ function s = mat2str (x, n = 15, cls = "
 
   if (strcmp ("class", cls))
     s = cstrcat (class (x), "(", s, ")");
   endif
 
 endfunction
 
 
-%!assert (mat2str (0.7), "0.7");
-%!assert (mat2str (pi), "3.14159265358979");
-%!assert (mat2str (pi, 5), "3.1416");
-%!assert (mat2str (single (pi), 5, "class"), "single(3.1416)");
+%!assert (mat2str (0.7), "0.7")
+%!assert (mat2str (pi), "3.14159265358979")
+%!assert (mat2str (pi, 5), "3.1416")
+%!assert (mat2str (single (pi), 5, "class"), "single(3.1416)")
 %!assert (mat2str ([-1/3 + i/7; 1/3 - i/7], [4 2]), "[-0.3333+0.14i;0.3333-0.14i]")
 %!assert (mat2str ([-1/3 +i/7; 1/3 -i/7], [4 2]), "[-0.3333+0i 0+0.14i;0.3333+0i -0-0.14i]")
-%!assert (mat2str (int16 ([1 -1]), 'class'), "int16([1 -1])")
-%!assert (mat2str (true), "true");
-%!assert (mat2str (false), "false");
-%!assert (mat2str (logical (eye (2))), "[true false;false true]");
+%!assert (mat2str (int16 ([1 -1]), "class"), "int16([1 -1])")
+%!assert (mat2str (true), "true")
+%!assert (mat2str (false), "false")
+%!assert (mat2str (logical (eye (2))), "[true false;false true]")
 
 %% Test input validation
 %!error mat2str ()
 %!error mat2str (1,2,3,4)
 %!error mat2str (["Hello"])
-%!error mat2str (ones(3,3,2))
+%!error <X must be two dimensional> mat2str (ones(3,3,2))
 
diff --git a/scripts/strings/rindex.m b/scripts/strings/rindex.m
--- a/scripts/strings/rindex.m
+++ b/scripts/strings/rindex.m
@@ -47,17 +47,18 @@ function n = rindex (s, t)
     print_usage ();
   endif
 
   n = index (s, t, "last");
 
 endfunction
 
 
-%!assert(rindex ("foobarbaz", "b") == 7 && rindex ("foobarbaz", "o") == 3);
+%!assert (rindex ("foobarbaz", "b"), 7)
+%!assert (rindex ("foobarbaz", "o"), 3)
 
 %!test
 %! str = char ("Hello", "World", "Goodbye", "World");
 %! assert (rindex (str, "o"), [5; 2; 3; 2]);
 %! str = cellstr (str);
 %! assert (rindex (str, "o"), [5; 2; 3; 2]);
 
 %% Test input validation
diff --git a/scripts/strings/str2num.m b/scripts/strings/str2num.m
--- a/scripts/strings/str2num.m
+++ b/scripts/strings/str2num.m
@@ -22,19 +22,18 @@
 ## Convert the string (or character array) @var{s} to a number (or an
 ## array).  Examples:
 ##
 ## @example
 ## @group
 ## str2num ("3.141596")
 ##       @result{} 3.141596
 ##
-## str2num (["1, 2, 3"; "4, 5, 6"]);
-##       @result{} ans =
-##          1  2  3
+## str2num (["1, 2, 3"; "4, 5, 6"])
+##       @result{} 1  2  3
 ##          4  5  6
 ## @end group
 ## @end example
 ##
 ## The optional second output, @var{state}, is logically true when the
 ## conversion is successful.  If the conversion fails the numeric output,
 ## @var{x}, is empty and @var{state} is false.
 ##
@@ -64,18 +63,18 @@ function [m, state] = str2num (s)
   if (ischar (m))
     m = [];
     state = false;
   endif
 
 endfunction
 
 
-%!assert(str2num ("-1.3e2"), -130);
-%!assert(str2num ("[1, 2; 3, 4]"), [1, 2; 3, 4]);
+%!assert (str2num ("-1.3e2"), -130)
+%!assert (str2num ("[1, 2; 3, 4]"), [1, 2; 3, 4])
 
 %!test
 %! [x, state] = str2num ("pi");
 %! assert (state);
 %! [x, state] = str2num ("Hello World");
 %! assert (! state);
 
 %% Test input validation
diff --git a/scripts/strings/strcat.m b/scripts/strings/strcat.m
--- a/scripts/strings/strcat.m
+++ b/scripts/strings/strcat.m
@@ -25,27 +25,27 @@
 ## For numerical input, each element is converted to the
 ## corresponding ASCII character.  Trailing white space is eliminated.
 ## For example:
 ##
 ## @example
 ## @group
 ## s = [ "ab"; "cde" ];
 ## strcat (s, s, s)
-##      @result{} ans =
+##     @result{}
 ##         "ab ab ab "
 ##         "cdecdecde"
 ## @end group
 ## @end example
 ##
 ## @example
 ## @group
 ## s = @{ "ab"; "cde" @};
 ## strcat (s, s, s)
-##      @result{} ans =
+##     @result{}
 ##         @{
 ##           [1,1] = ababab
 ##           [2,1] = cdecdecde
 ##         @}
 ## @end group
 ## @end example
 ##
 ## @seealso{cstrcat, char, strvcat}
@@ -91,37 +91,36 @@ function st = strcat (varargin)
   else
     print_usage ();
   endif
 
 endfunction
 
 ## test the dimensionality
 ## 1d
-%!assert(strcat("ab ", "ab "), "abab")
-%!assert(strcat({"ab "}, "ab "), {"ab ab"})
-%!assert(strcat("ab ", {"ab "}), {"abab "})
-%!assert(strcat({"ab "}, {"ab "}), {"ab ab "})
-%!assert(strcat("", "ab"), "ab")
-%!assert(strcat("", {"ab"}, {""}), {"ab"})
+%!assert (strcat ("ab ", "ab "), "abab")
+%!assert (strcat ({"ab "}, "ab "), {"ab ab"})
+%!assert (strcat ("ab ", {"ab "}), {"abab "})
+%!assert (strcat ({"ab "}, {"ab "}), {"ab ab "})
+%!assert (strcat ("", "ab"), "ab")
+%!assert (strcat ("", {"ab"}, {""}), {"ab"})
 ## 2d
-%!assert(strcat(["ab ";"cde"], ["ab ";"cde"]), ["abab  ";"cdecde"])
+%!assert (strcat (["ab ";"cde"], ["ab ";"cde"]), ["abab  ";"cdecde"])
 
 ## test for deblanking implied trailing spaces of character input
-%!assert((strcmp (strcat ("foo", "bar"), "foobar")
-%!        && strcmp (strcat (["a"; "bb"], ["foo"; "bar"]), ["afoo "; "bbbar"])));
+%!assert (strcat ("foo", "bar"), "foobar")
+%!assert (strcat (["a"; "bb"], ["foo"; "bar"]), ["afoo "; "bbbar"])
 
 ## test for mixing character and cell inputs
-%!assert(all (strcmp (strcat ("a", {"bc", "de"}, "f"), {"abcf", "adef"})))
+%!assert (strcat ("a", {"bc", "de"}, "f"), {"abcf", "adef"})
 
 ## test for scalar strings with vector strings
-%!assert(all (strcmp (strcat (["a"; "b"], "c"), ["ac"; "bc"])))
+%!assert (strcat (["a"; "b"], "c"), ["ac"; "bc"])
 
 ## test with cells with strings of differing lengths
-%!assert(all (strcmp (strcat ({"a", "bb"}, "ccc"), {"accc", "bbccc"})))
-%!assert(all (strcmp (strcat ("a", {"bb", "ccc"}), {"abb", "accc"})))
-
-%!error strcat ();
+%!assert (all (strcmp (strcat ({"a", "bb"}, "ccc"), {"accc", "bbccc"})))
+%!assert (all (strcmp (strcat ("a", {"bb", "ccc"}), {"abb", "accc"})))
 
 %!assert (strcat (1, 2), strcat (char(1), char(2)))
+%!assert (strcat ("", 2), strcat ([], char(2)))
 
-%!assert (strcat ('', 2), strcat ([], char(2)))
+%!error strcat ()
 
diff --git a/scripts/strings/strjust.m b/scripts/strings/strjust.m
--- a/scripts/strings/strjust.m
+++ b/scripts/strings/strjust.m
@@ -27,21 +27,21 @@
 ## Null characters are replaced by spaces.  All other character
 ## data are treated as non-white space.
 ##
 ## Example:
 ##
 ## @example
 ## @group
 ## strjust (["a"; "ab"; "abc"; "abcd"])
-##      @result{} ans =
-##            a
-##           ab
-##          abc
-##         abcd
+##      @result{}
+##         "   a"
+##         "  ab"
+##         " abc"
+##         "abcd"
 ## @end group
 ## @end example
 ## @seealso{deblank, strrep, strtrim, untabify}
 ## @end deftypefn
 
 function y = strjust (s, pos = "right")
 
   if (nargin < 1 || nargin > 2)
@@ -92,21 +92,21 @@ function y = strjust (s, pos = "right")
   ## Create a blank matrix and position the nonblank characters.
   y = repmat (" ", nr, nc);
   y(sub2ind ([nr, nc], idx, jdx)) = s(nonbl);
 
 endfunction
 
 
 %!assert (strjust (["a"; "ab"; "abc"; "abcd"]),
-%!        ["   a";"  ab"; " abc"; "abcd"]);
+%!        ["   a";"  ab"; " abc"; "abcd"])
 %!assert (strjust ([" a"; "  ab"; "abc"; "abcd"], "left"),
-%!        ["a   "; "ab  "; "abc "; "abcd"]);
+%!        ["a   "; "ab  "; "abc "; "abcd"])
 %!assert (strjust (["a"; "ab"; "abc"; "abcd"], "CENTER"),
-%!        [" a  "; " ab"; "abc "; "abcd"]);
-%!assert (strjust (["";""]), "");
+%!        [" a  "; " ab"; "abc "; "abcd"])
+%!assert (strjust (["";""]), "")
 
 %% Test input validation
 %!error <Invalid call to strjust> strjust ()
 %!error <Invalid call to strjust> strjust (["a";"ab"], "center", 1)
-%!error <S must be a string> strjust (ones(3,3))
-%!error <S must be a string> strjust (char (ones(3,3,3)))
+%!error <S must be a string> strjust (ones (3,3))
+%!error <S must be a string> strjust (char (ones (3,3,3)))
 
diff --git a/scripts/strings/strmatch.m b/scripts/strings/strmatch.m
--- a/scripts/strings/strmatch.m
+++ b/scripts/strings/strmatch.m
@@ -92,28 +92,28 @@ function idx = strmatch (s, A, exact)
       B = regexprep (A(idx), "[ \\0]+$", '');
       idx = idx(strcmp (s, B));
     endif
   endif
 
 endfunction
 
 
-%!assert (strmatch("a", {"aaa", "bab", "bbb"}), 1);
-%!assert (strmatch ("apple", "apple juice"), 1);
-%!assert (strmatch ("apple", ["apple pie"; "apple juice"; "an apple"]), [1; 2]);
-%!assert (strmatch ("apple", {"apple pie"; "apple juice"; "tomato"}), [1; 2]);
-%!assert (strmatch ("apple pie", "apple"), []);
-%!assert (strmatch ("a ", "a"), 1);
-%!assert (strmatch ("a", "a \0", "exact"), 1);
-%!assert (strmatch ("a b", {"a b", "a c", "c d"}), 1);
-%!assert (strmatch ("", {"", "foo", "bar", ""}), [1, 4]);
-%!assert (strmatch ('', { '', '% comment', 'var a = 5', ''}, 'exact'), [1,4]);
+%!assert (strmatch ("a", {"aaa", "bab", "bbb"}), 1)
+%!assert (strmatch ("apple", "apple juice"), 1)
+%!assert (strmatch ("apple", ["apple pie"; "apple juice"; "an apple"]), [1; 2])
+%!assert (strmatch ("apple", {"apple pie"; "apple juice"; "tomato"}), [1; 2])
+%!assert (strmatch ("apple pie", "apple"), [])
+%!assert (strmatch ("a ", "a"), 1)
+%!assert (strmatch ("a", "a \0", "exact"), 1)
+%!assert (strmatch ("a b", {"a b", "a c", "c d"}), 1)
+%!assert (strmatch ("", {"", "foo", "bar", ""}), [1, 4])
+%!assert (strmatch ('', { '', '% comment', 'var a = 5', ''}, 'exact'), [1,4])
 
 %% Test input validation
-%!error <Invalid call to strmatch> strmatch();
-%!error <Invalid call to strmatch> strmatch("a");
-%!error <Invalid call to strmatch> strmatch("a", "aaa", "exact", 1);
-%!error <S must be a string> strmatch(1, "aaa");
-%!error <S must be a string> strmatch(char ("a", "bb"), "aaa");
-%!error <A must be a string> strmatch("a", 1);
-%!error <A must be a string> strmatch("a", {"hello", [1]});
+%!error <Invalid call to strmatch> strmatch ()
+%!error <Invalid call to strmatch> strmatch ("a")
+%!error <Invalid call to strmatch> strmatch ("a", "aaa", "exact", 1)
+%!error <S must be a string> strmatch (1, "aaa")
+%!error <S must be a string> strmatch (char ("a", "bb"), "aaa")
+%!error <A must be a string> strmatch ("a", 1)
+%!error <A must be a string> strmatch ("a", {"hello", [1]})
 
diff --git a/scripts/strings/strsplit.m b/scripts/strings/strsplit.m
--- a/scripts/strings/strsplit.m
+++ b/scripts/strings/strsplit.m
@@ -27,25 +27,25 @@
 ## 2-D character arrays are split at separators and at the original column
 ## boundaries.
 ##
 ## Example:
 ##
 ## @example
 ## @group
 ## strsplit ("a,b,c", ",")
-##        @result{}
+##       @result{}
 ##           @{
 ##             [1,1] = a
 ##             [1,2] = b
 ##             [1,3] = c
 ##           @}
 ##
 ## strsplit (["a,b" ; "cde"], ",")
-##        @result{}
+##       @result{}
 ##           @{
 ##             [1,1] = a
 ##             [1,2] = b
 ##             [1,3] = cde
 ##           @}
 ## @end group
 ## @end example
 ## @seealso{strtok}
@@ -109,10 +109,10 @@ endfunction
 %!assert (strsplit (["a,bc";",de"], ", ", true), {"a", "bc", "de"})
 
 %% Test input validation
 %!error strsplit ()
 %!error strsplit ("abc")
 %!error strsplit ("abc", "b", true, 4)
 %!error <S and SEP must be string values> strsplit (123, "b")
 %!error <S and SEP must be string values> strsplit ("abc", 1)
-%!error <STRIP_EMPTY must be a scalar value> strsplit ("abc", "def", ones(3,3))
+%!error <STRIP_EMPTY must be a scalar value> strsplit ("abc", "def", ones (3,3))
 
diff --git a/scripts/strings/strtok.m b/scripts/strings/strtok.m
--- a/scripts/strings/strtok.m
+++ b/scripts/strings/strtok.m
@@ -185,40 +185,40 @@ endfunction
 %! assert (t{5}, "this");
 %! assert (r{5}, "");
 %! assert (t{6}, "this");
 %! assert (r{6}, " ");
 %! assert (t{7}, "");
 %! assert (r{7}, "");
 
 %% Simple check for 2, 3, and 4 delimeters
-%!assert(strtok ("this is", "i "), "th");
-%!assert(strtok ("this is", "ij "), "th");
-%!assert(strtok ("this is", "ijk "), "th");
+%!assert (strtok ("this is", "i "), "th")
+%!assert (strtok ("this is", "ij "), "th")
+%!assert (strtok ("this is", "ijk "), "th")
 
 %% Test all cases for 8 delimiters since a different
 %!# algorithm is used when more than 7 delimiters
-%!assert (strtok ("","jklmnop "), "");
-%!assert (strtok ("this","jklmnop "), "this");
-%!assert (strtok ("this ","jklmnop "), "this");
-%!assert (strtok ("this is","jklmnop "), "this");
-%!assert (strtok (" this","jklmnop "), "this");
-%!assert (strtok (" this ","jklmnop "), "this");
-%!assert (strtok (" ","jklmnop "), ""(1:0));
+%!assert (strtok ("","jklmnop "), "")
+%!assert (strtok ("this","jklmnop "), "this")
+%!assert (strtok ("this ","jklmnop "), "this")
+%!assert (strtok ("this is","jklmnop "), "this")
+%!assert (strtok (" this","jklmnop "), "this")
+%!assert (strtok (" this ","jklmnop "), "this")
+%!assert (strtok (" ","jklmnop "), ""(1:0))
 
 %% Test 'bad' string orientations
 %!assert (strtok (" this ".'), "this".');   # delimiter at start and end
 %!assert (strtok (" this ".',"jkl "), "this".');
 
 %% Test with TAB, LF, VT, FF, and CR
 %!test
 %! for ch = "\t\n\v\f\r"
 %!   [t, r] = strtok (cstrcat ("beg", ch, "end"));
 %!   assert (t, "beg");
-%!   assert (r, cstrcat (ch, "end"))
+%!   assert (r, cstrcat (ch, "end"));
 %! endfor
 
 %% Test input validation
 %!error strtok ()
 %!error strtok ("a", "b", "c")
 %!error <STR must be a string> strtok (1, "b")
 %!error <STR cannot be a 2-D> strtok (char ("hello", "world"), "l")
 
diff --git a/scripts/strings/strtrim.m b/scripts/strings/strtrim.m
--- a/scripts/strings/strtrim.m
+++ b/scripts/strings/strtrim.m
@@ -69,20 +69,20 @@ function s = strtrim (s)
 
   else
     error ("strtrim: S argument must be a string or cellstring");
   endif
 
 endfunction
 
 
-%!assert (strtrim ("    abc  "), "abc");
-%!assert (strtrim ("  "), "");
-%!assert (strtrim ("abc"), "abc");
-%!assert (strtrim ([" abc   "; "   def   "]), ["abc  "; "  def"]);
-%!assert (strtrim ({" abc   "; "   def   "}), {"abc"; "def"});
-%!assert (strtrim ({" abc   ", {"   def   "}}), {"abc", {"def"}});
+%!assert (strtrim ("    abc  "), "abc")
+%!assert (strtrim ("  "), "")
+%!assert (strtrim ("abc"), "abc")
+%!assert (strtrim ([" abc   "; "   def   "]), ["abc  "; "  def"])
+%!assert (strtrim ({" abc   "; "   def   "}), {"abc"; "def"})
+%!assert (strtrim ({" abc   ", {"   def   "}}), {"abc", {"def"}})
 
-%!error <Invalid call to strtrim> strtrim ();
-%!error <Invalid call to strtrim> strtrim ("abc", "def");
-%!error <argument must be a string> strtrim (1);
-%!error <argument must be a string> strtrim ({[]});
+%!error <Invalid call to strtrim> strtrim ()
+%!error <Invalid call to strtrim> strtrim ("abc", "def")
+%!error <argument must be a string> strtrim (1)
+%!error <argument must be a string> strtrim ({[]})
 
diff --git a/scripts/strings/strtrunc.m b/scripts/strings/strtrunc.m
--- a/scripts/strings/strtrunc.m
+++ b/scripts/strings/strtrunc.m
@@ -50,22 +50,22 @@ function s = strtrunc (s, n)
     endif
   else
     error ("strtrunc: S must be a character string or a cell array of strings");
   endif
 
 endfunction
 
 
-%!assert (strtrunc("abcdefg", 4), "abcd");
-%!assert (strtrunc("abcdefg", 10), "abcdefg");
-%!assert (strtrunc(char ("abcdef", "fedcba"), 3), ["abc"; "fed"]);
-%!assert (strtrunc({"abcdef", "fedcba"}, 3), {"abc", "fed"});
-%!assert (strtrunc({"", "1", "21", "321"}, 1), {"", "1", "2", "3"})
-%!assert (strtrunc({"1", "", "2"}, 1), {"1", "", "2"})
+%!assert (strtrunc ("abcdefg", 4), "abcd")
+%!assert (strtrunc ("abcdefg", 10), "abcdefg")
+%!assert (strtrunc (char ("abcdef", "fedcba"), 3), ["abc"; "fed"])
+%!assert (strtrunc ({"abcdef", "fedcba"}, 3), {"abc", "fed"})
+%!assert (strtrunc ({"", "1", "21", "321"}, 1), {"", "1", "2", "3"})
+%!assert (strtrunc ({"1", "", "2"}, 1), {"1", "", "2"})
 %!test
 %! cstr = {"line1"; ["line2"; "line3"]; "line4"};
 %! y = strtrunc (cstr, 4);
 %! assert (size (y), [3, 1]); 
 %! assert (size (y{2}), [2, 4]); 
 %! assert (y{2}, repmat ("line", 2, 1));
 
 %% Test input validation
diff --git a/scripts/strings/substr.m b/scripts/strings/substr.m
--- a/scripts/strings/substr.m
+++ b/scripts/strings/substr.m
@@ -87,22 +87,22 @@ function t = substr (s, offset, len)
     error ("substr: No overlap with chosen values of OFFSET and LEN");
   endif
 
   t = s(:, offset:eos);
 
 endfunction
 
 
-%!assert (substr ("This is a test string", 6, 9), "is a test");
-%!assert (substr ("This is a test string", -11), "test string");
-%!assert (substr ("This is a test string", -11, 4), "test");
-%!assert (substr ("This is a test string", -11, -7), "test");
-%!assert (substr ("This is a test string", 1, -7), "This is a test");
-%!assert (isempty (substr ("This is a test string", 1, 0)));
+%!assert (substr ("This is a test string", 6, 9), "is a test")
+%!assert (substr ("This is a test string", -11), "test string")
+%!assert (substr ("This is a test string", -11, 4), "test")
+%!assert (substr ("This is a test string", -11, -7), "test")
+%!assert (substr ("This is a test string", 1, -7), "This is a test")
+%!assert (isempty (substr ("This is a test string", 1, 0)))
 
 %% Test input validation
 %!error substr ()
 %!error substr ("foo", 2, 3, 4)
 %!error substr (ones (5, 1), 1, 1)
 %!error substr ("foo", ones(2,2))
 %!error substr ("foo", 1, ones(2,2))
 %!error substr ("foo", 0)
diff --git a/scripts/strings/validatestring.m b/scripts/strings/validatestring.m
--- a/scripts/strings/validatestring.m
+++ b/scripts/strings/validatestring.m
@@ -133,22 +133,23 @@ function str = validatestring (str, stra
              errstr, str, sprintf ("%s, ", strarray{match_idx})(1:end-2));
     endif
   endif
 
 endfunction
 
 
 %!shared strarray
-%!  strarray = {"octave" "Oct" "octopus" "octaves"};
+%! strarray = {"octave" "Oct" "octopus" "octaves"};
 %!assert (validatestring ("octave", strarray), "octave")
 %!assert (validatestring ("oct", strarray), "Oct")
 %!assert (validatestring ("octa", strarray), "octave")
-%!  strarray = {"abc1" "def" "abc2"};
+%! strarray = {"abc1" "def" "abc2"};
 %!assert (validatestring ("d", strarray), "def")
+
 %!error <'xyz' does not match any> validatestring ("xyz", strarray)
 %!error <Function: DUMMY_TEST> validatestring ("xyz", strarray, "DUMMY_TEST")
 %!error <Function: DUMMY_TEST Variable: DUMMY_VAR:> validatestring ("xyz", strarray, "DUMMY_TEST", "DUMMY_VAR")
 %!error <Function: DUMMY_TEST Variable: DUMMY_VAR Argument position 5> validatestring ("xyz", strarray, "DUMMY_TEST", "DUMMY_VAR", 5)
 %!error <multiple unique matches were found for 'abc'> validatestring ("abc", strarray)
 
 %% Test input validation
 %!error validatestring ("xyz")
diff --git a/scripts/testfun/demo.m b/scripts/testfun/demo.m
--- a/scripts/testfun/demo.m
+++ b/scripts/testfun/demo.m
@@ -14,75 +14,75 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Command} {} demo @var{name}
 ## @deftypefnx {Command} {} demo @var{name} @var{n}
-## @deftypefnx {Function File} {} demo ('@var{name}')
-## @deftypefnx {Function File} {} demo ('@var{name}', @var{n})
+## @deftypefnx {Function File} {} demo ("@var{name}")
+## @deftypefnx {Function File} {} demo ("@var{name}", @var{n})
 ##
 ## Run example code block @var{n} associated with the function @var{name}.
 ## If @var{n} is not specified, all examples are run.
 ##
 ## Examples are stored in the script file, or in a file with the same
 ## name but no extension located on Octave's load path.  To keep examples
 ## separate from regular script code, all lines are prefixed by @code{%!}.  Each
 ## example must also be introduced by the keyword 'demo' flush left to the
 ## prefix with no intervening spaces.  The remainder of the example can
 ## contain arbitrary Octave code.  For example:
 ##
 ## @example
 ## @group
-##   %!demo
-##   %! t = 0:0.01:2*pi;
-##   %! x = sin (t);
-##   %! plot (t,x);
-##   %! %-------------------------------------------------
-##   %! % the figure window shows one cycle of a sine wave
+## %!demo
+## %! t = 0:0.01:2*pi;
+## %! x = sin (t);
+## %! plot (t, x);
+## %! %-------------------------------------------------
+## %! % the figure window shows one cycle of a sine wave
 ## @end group
 ## @end example
 ##
 ## Note that the code is displayed before it is executed, so a simple
 ## comment at the end suffices for labeling what is being shown.  It is
 ## generally not necessary to use @code{disp} or @code{printf} within the demo.
 ##
 ## Demos are run in a function environment with no access to external
 ## variables.  This means that every demo must have separate initialization
 ## code.  Alternatively, all demos can be combined into a single large demo
 ## with the code
 ##
 ## @example
-##    %! input("Press <enter> to continue: ","s");
+## %! input("Press <enter> to continue: ","s");
 ## @end example
 ##
 ## @noindent
 ## between the sections, but this is discouraged.  Other techniques
 ## to avoid multiple initialization blocks include using multiple plots
 ## with a new @code{figure} command between each plot, or using @code{subplot}
 ## to put multiple plots in the same window.
 ##
 ## Also, because demo evaluates within a function context, you cannot
 ## define new functions inside a demo.  If you must have function blocks,
 ## rather than just anonymous functions or inline functions, you will have to
-## use @code{eval(example('function',n))} to see them.  Because eval only
+## use @code{eval(example("function",n))} to see them.  Because eval only
 ## evaluates one line, or one statement if the statement crosses
 ## multiple lines, you must wrap your demo in "if 1 <demo stuff> endif"
 ## with the 'if' on the same line as 'demo'.  For example:
 ##
 ## @example
 ## @group
-##   %!demo if 1
-##   %!  function y=f(x)
-##   %!    y=x;
-##   %!  endfunction
-##   %!  f(3)
-##   %! endif
+## %!demo if 1
+## %!  function y=f(x)
+## %!    y=x;
+## %!  endfunction
+## %!  f(3)
+## %! endif
 ## @end group
 ## @end example
 ##
 ## @seealso{test, example}
 ## @end deftypefn
 
 ## FIXME: modify subplot so that gnuplot_has_multiplot == 0 causes it to
 ## use the current figure window but pause if not plotting in the
@@ -144,14 +144,15 @@ function demo (name, n)
   endfor
 
 endfunction
 
 
 %!demo
 %! t = 0:0.01:2*pi;
 %! x = sin (t);
-%! plot (t,x);
+%! plot (t, x);
 %! %-------------------------------------------------
 %! % the figure window shows one cycle of a sine wave
 
-%!error demo ();
-%!error demo (1, 2, 3);
+%!error demo ()
+%!error demo (1, 2, 3)
+
diff --git a/scripts/testfun/example.m b/scripts/testfun/example.m
--- a/scripts/testfun/example.m
+++ b/scripts/testfun/example.m
@@ -14,22 +14,22 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Command} {} example @var{name}
 ## @deftypefnx {Command} {} example @var{name} @var{n}
-## @deftypefnx {Function File} {} example ('@var{name}')
-## @deftypefnx {Function File} {} example ('@var{name}', @var{n})
+## @deftypefnx {Function File} {} example ("@var{name}")
+## @deftypefnx {Function File} {} example ("@var{name}", @var{n})
 ## @deftypefnx {Function File} {[@var{s}, @var{idx}] =} example (@dots{})
 ##
 ## Display the code for example @var{n} associated with the function
-## '@var{name}', but do not run it.  If @var{n} is not specified, all examples
+## "@var{name}", but do not run it.  If @var{n} is not specified, all examples
 ## are displayed.
 ##
 ## When called with output arguments, the examples are returned in the form of
 ## a string @var{s}, with @var{idx} indicating the ending position of the
 ## various examples.
 ##
 ## See @code{demo} for a complete explanation.
 ## @seealso{demo, test}
@@ -81,26 +81,26 @@ function [code_r, idx_r] = example (name
     endfor
   endif
 
 endfunction
 
 
 ## WARNING: don't modify the demos without modifying the tests!
 %!demo
-%! example ('example');
+%! example ("example");
 
 %!demo
 %! clf;
-%! t=0:0.01:2*pi; x = sin(t);
+%! t = 0:0.01:2*pi;  x = sin (t);
 %! plot (t,x)
 
-%!assert (example('example',1), "\n example ('example');");
+%!assert (example ("example",1), "\n example (\"example\");");
 %!test
-%! [code, idx] = example ('example');
+%! [code, idx] = example ("example");
 %! assert (code, ...
-%!         "\n example ('example');\n clf;\n t=0:0.01:2*pi; x = sin(t);\n plot (t,x)")
-%! assert (idx, [1, 23, 69]);
+%!         "\n example (\"example\");\n clf;\n t = 0:0.01:2*pi;  x = sin (t);\n plot (t,x)")
+%! assert (idx, [1, 23, 73]);
 
 %% Test input validation
 %!error example
-%!error example ('example', 3, 5)
+%!error example ("example", 3, 5)
 
diff --git a/scripts/testfun/fail.m b/scripts/testfun/fail.m
--- a/scripts/testfun/fail.m
+++ b/scripts/testfun/fail.m
@@ -17,17 +17,17 @@
 ## <http://www.gnu.org/licenses/>.
 ##
 ## Original version by Paul Kienzle distributed as free software in the
 ## public domain.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} fail (@var{code})
 ## @deftypefnx {Function File} {} fail (@var{code}, @var{pattern})
-## @deftypefnx {Function File} {} fail (@var{code}, 'warning', @var{pattern})
+## @deftypefnx {Function File} {} fail (@var{code}, "warning", @var{pattern})
 ##
 ## Return true if @var{code} fails with an error message matching
 ## @var{pattern}, otherwise produce an error.  Note that @var{code}
 ## is a string and if @var{code} runs successfully, the error produced is:
 ##
 ## @example
 ##           expected error but got none
 ## @end example
@@ -125,20 +125,21 @@ function ret = fail (code, pattern, warn
   endif
 
   ## If we get here, then code didn't fail or error didn't match.
   error (msg);
 
 endfunction
 
 
-%!fail ('[1,2]*[2,3]', 'nonconformant')
+%!fail ("[1,2]*[2,3]", "nonconformant")
 %!fail ("fail('[1,2]*[2;3]', 'nonconformant')", "expected error <nonconformant> but got none")
 %!fail ("fail('[1,2]*[2,3]','usage:')", "expected error <usage:>\nbut got.*nonconformant")
-%!fail ("warning('test warning')", 'warning','test warning');
+%!fail ("warning('test warning')", "warning", "test warning");
 
 ##% !fail ("warning('next test')",'warning','next test');  ## only allowed one warning test?!?
 
 %% Test that fail() itself will generate an error
-%!error fail ("1");
-%!error <undefined> fail ('a*[2;3]', 'nonconformant')
-%!error <expected error>  fail ('a*[2,3]', 'usage:')
-%!error <warning failure> fail ("warning('warning failure')", 'warning', 'success')
+%!error fail ("1")
+%!error <undefined> fail ("a*[2;3]", "nonconformant")
+%!error <expected error>  fail ("a*[2,3]", "usage:")
+%!error <warning failure> fail ("warning('warning failure')", "warning", "success")
+
diff --git a/scripts/testfun/speed.m b/scripts/testfun/speed.m
--- a/scripts/testfun/speed.m
+++ b/scripts/testfun/speed.m
@@ -351,73 +351,73 @@ endfunction
 
 
 %% FIXME: Demos with declared functions do not work.  See bug #31815.
 %%        A workaround has been hacked by not declaring the functions
 %%        but using eval to create them in the proper context.
 %%        Unfortunately, we can't remove them from the user's workspace
 %%        because of another bug (#34497).
 %!demo
-%!  fstr_build_orig = cstrcat (
-%!    "function x = build_orig (n)\n",
-%!    "  ## extend the target vector on the fly\n",
-%!    "  for i=0:n-1, x([1:100]+i*100) = 1:100; endfor\n",
-%!    "endfunction");
-%!  fstr_build = cstrcat (
-%!    "function x = build (n)\n",
-%!    "  ## preallocate the target vector\n",
-%!    "  x = zeros (1, n*100);\n",
-%!    "  for i=0:n-1, x([1:100]+i*100) = 1:100; endfor\n",
-%!    "endfunction");
+%! fstr_build_orig = cstrcat (
+%!   "function x = build_orig (n)\n",
+%!   "  ## extend the target vector on the fly\n",
+%!   "  for i=0:n-1, x([1:100]+i*100) = 1:100; endfor\n",
+%!   "endfunction");
+%! fstr_build = cstrcat (
+%!   "function x = build (n)\n",
+%!   "  ## preallocate the target vector\n",
+%!   "  x = zeros (1, n*100);\n",
+%!   "  for i=0:n-1, x([1:100]+i*100) = 1:100; endfor\n",
+%!   "endfunction");
 %!
-%!  disp ("-----------------------");
-%!  disp (fstr_build_orig);
-%!  disp ("-----------------------");
-%!  disp (fstr_build);
-%!  disp ("-----------------------");
+%! disp ("-----------------------");
+%! disp (fstr_build_orig);
+%! disp ("-----------------------");
+%! disp (fstr_build);
+%! disp ("-----------------------");
 %!
-%!  ## Eval functions strings to create them in the current context
-%!  eval (fstr_build_orig);
-%!  eval (fstr_build);
+%! ## Eval functions strings to create them in the current context
+%! eval (fstr_build_orig);
+%! eval (fstr_build);
 %!
-%!  disp ("Preallocated vector test.\nThis takes a little while...");
-%!  speed("build (n)", "", 1000, "build_orig (n)");
-%!  clear -f build build_orig
-%!  disp ("-----------------------");
-%!  disp ("Note how much faster it is to pre-allocate a vector.");
-%!  disp ("Notice the peak speedup ratio.");
+%! disp ("Preallocated vector test.\nThis takes a little while...");
+%! speed("build (n)", "", 1000, "build_orig (n)");
+%! clear -f build build_orig
+%! disp ("-----------------------");
+%! disp ("Note how much faster it is to pre-allocate a vector.");
+%! disp ("Notice the peak speedup ratio.");
 
 %!demo
-%!  fstr_build_orig = cstrcat (
-%!    "function x = build_orig (n)\n",
-%!    "  for i=0:n-1, x([1:100]+i*100) = 1:100; endfor\n",
-%!    "endfunction");
-%!  fstr_build = cstrcat (
-%!    "function x = build (n)\n",
-%!    "  idx = [1:100]';\n",
-%!    "  x = idx(:,ones(1,n));\n",
-%!    "  x = reshape (x, 1, n*100);\n",
-%!    "endfunction");
+%! fstr_build_orig = cstrcat (
+%!   "function x = build_orig (n)\n",
+%!   "  for i=0:n-1, x([1:100]+i*100) = 1:100; endfor\n",
+%!   "endfunction");
+%! fstr_build = cstrcat (
+%!   "function x = build (n)\n",
+%!   "  idx = [1:100]';\n",
+%!   "  x = idx(:,ones(1,n));\n",
+%!   "  x = reshape (x, 1, n*100);\n",
+%!   "endfunction");
 %!
-%!  disp ("-----------------------");
-%!  disp (fstr_build_orig);
-%!  disp ("-----------------------");
-%!  disp (fstr_build);
-%!  disp ("-----------------------");
+%! disp ("-----------------------");
+%! disp (fstr_build_orig);
+%! disp ("-----------------------");
+%! disp (fstr_build);
+%! disp ("-----------------------");
 %!
-%!  ## Eval functions strings to create them in the current context
-%!  eval (fstr_build_orig);
-%!  eval (fstr_build);
+%! ## Eval functions strings to create them in the current context
+%! eval (fstr_build_orig);
+%! eval (fstr_build);
 %!
-%!  disp ("Vectorized test.\nThis takes a little while...");
-%!  speed("build (n)", "", 1000, "build_orig (n)");
-%!  clear -f build build_orig
-%!  disp ("-----------------------");
-%!  disp ("This time, the for loop is done away with entirely.");
-%!  disp ("Notice how much bigger the speedup is than in example 1.");
+%! disp ("Vectorized test.\nThis takes a little while...");
+%! speed("build (n)", "", 1000, "build_orig (n)");
+%! clear -f build build_orig
+%! disp ("-----------------------");
+%! disp ("This time, the for loop is done away with entirely.");
+%! disp ("Notice how much bigger the speedup is than in example 1.");
 
 %!test
 %! [order, n, T_f1, T_f2] = speed ("airy (x)", "x = rand (n, 10)", [100, 1000]);
 %! assert (isstruct (order));
 %! assert (size (order), [1, 1]);
 %! assert (fieldnames (order), {"p"; "a"});
 %! assert (isnumeric (n));
 %! assert (length (n) > 10);
@@ -436,11 +436,11 @@ endfunction
 %! assert (isnumeric (n));
 %! assert (length (n) > 10);
 %! assert (isnumeric (T_f1));
 %! assert (size (T_f1), size (n));
 %! assert (isnumeric (T_f2));
 %! assert (length (T_f2) > 10);
 
 %% Test input validation
-%!error speed ();
-%!error speed (1, 2, 3, 4, 5, 6, 7);
+%!error speed ()
+%!error speed (1, 2, 3, 4, 5, 6, 7)
 
diff --git a/scripts/testfun/test.m b/scripts/testfun/test.m
--- a/scripts/testfun/test.m
+++ b/scripts/testfun/test.m
@@ -14,61 +14,61 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Command} {} test @var{name}
 ## @deftypefnx {Command} {} test @var{name} quiet|normal|verbose
-## @deftypefnx {Function File} {} test ('@var{name}', 'quiet|normal|verbose', @var{fid})
-## @deftypefnx {Function File} {} test ([], 'explain', @var{fid})
+## @deftypefnx {Function File} {} test ("@var{name}", "quiet|normal|verbose", @var{fid})
+## @deftypefnx {Function File} {} test ([], "explain", @var{fid})
 ## @deftypefnx {Function File} {@var{success} =} test (@dots{})
 ## @deftypefnx {Function File} {[@var{n}, @var{max}] =} test (@dots{})
-## @deftypefnx {Function File} {[@var{code}, @var{idx}] =} test ('@var{name}', 'grabdemo')
+## @deftypefnx {Function File} {[@var{code}, @var{idx}] =} test ("@var{name}", "grabdemo")
 ##
 ## Perform tests from the first file in the loadpath matching @var{name}.
 ## @code{test} can be called as a command or as a function.  Called with
 ## a single argument @var{name}, the tests are run interactively and stop
 ## after the first error is encountered.
 ##
 ## With a second argument the tests which are performed and the amount of
 ## output is selected.
 ##
 ## @table @asis
-## @item 'quiet'
+## @item "quiet"
 ##  Don't report all the tests as they happen, just the errors.
 ##
-## @item 'normal'
+## @item "normal"
 ## Report all tests as they happen, but don't do tests which require
 ## user interaction.
 ##
-## @item 'verbose'
+## @item "verbose"
 ## Do tests which require user interaction.
 ## @end table
 ##
 ## The argument @var{fid} can be used to allow batch processing.  Errors
 ## can be written to the already open file defined by @var{fid}, and
 ## hopefully when Octave crashes this file will tell you what was happening
 ## when it did.  You can use @code{stdout} if you want to see the results as
 ## they happen.  You can also give a file name rather than an @var{fid}, in
 ## which case the contents of the file will be replaced with the log from
 ## the current test.
 ##
 ## Called with a single output argument @var{success}, @code{test} returns
 ## true if all of the tests were successful.  Called with two output arguments
 ## @var{n} and @var{max}, the number of successful tests and the total number
 ## of tests in the file @var{name} are returned.
 ##
-## If the second argument is the string 'grabdemo', the contents of the demo
+## If the second argument is the string "grabdemo", the contents of the demo
 ## blocks are extracted but not executed.  Code for all code blocks is
 ## concatenated and returned as @var{code} with @var{idx} being a vector of
 ## positions of the ends of the demo blocks.
 ##
-## If the second argument is 'explain', then @var{name} is ignored and an
+## If the second argument is "explain", then @var{name} is ignored and an
 ## explanation of the line markers used is written to the file @var{fid}.
 ## @seealso{assert, fail, error, demo, example}
 ## @end deftypefn
 
 ## FIXME: * Consider using keyword fail rather then error?  This allows us
 ## to make a functional form of error blocks, which means we
 ## can include them in test sections which means that we can use
 ## octave flow control for both kinds of tests.
diff --git a/scripts/time/addtodate.m b/scripts/time/addtodate.m
--- a/scripts/time/addtodate.m
+++ b/scripts/time/addtodate.m
@@ -72,17 +72,17 @@ function d = addtodate (d, q, f)
     error ("addtodate: Invalid time unit: %s", f);
   endif
 
 endfunction
 
 
 ## tests
 %!shared d
-%!  d = datenum (2008, 1, 1);
+%! d = datenum (2008, 1, 1);
 ## Identity
 %!assert (addtodate (d, 0, "year"), d)
 %!assert (addtodate (d, 0, "month"), d)
 %!assert (addtodate (d, 0, "day"), d)
 %!assert (addtodate (d, 0, "hour"), d)
 %!assert (addtodate (d, 0, "minute"), d)
 %!assert (addtodate (d, 0, "second"), d)
 %!assert (addtodate (d, 0, "millisecond"), d)
diff --git a/scripts/time/asctime.m b/scripts/time/asctime.m
--- a/scripts/time/asctime.m
+++ b/scripts/time/asctime.m
@@ -42,13 +42,13 @@ function retval = asctime (tm_struct)
 
   retval = strftime ("%a %b %d %H:%M:%S %Y\n", tm_struct);
 
 endfunction
 
 
 %!test
 %! t = time ();
-%! assert(strcmp (asctime (localtime (t)), ctime (t)));
+%! assert (strcmp (asctime (localtime (t)), ctime (t)));
 
-%!error asctime ();
-%!error asctime (1, 2);
+%!error asctime ()
+%!error asctime (1, 2)
 
diff --git a/scripts/time/clock.m b/scripts/time/clock.m
--- a/scripts/time/clock.m
+++ b/scripts/time/clock.m
@@ -52,10 +52,10 @@ function retval = clock ()
   retval(5) = tm.min;
   retval(6) = tm.sec + tm.usec / 1e6;
 
 endfunction
 
 %!test
 %! t1 = clock;
 %! t2 = str2num (strftime ("[%Y, %m, %d, %H, %M, %S]", localtime (time ())));
-%! assert(etime (t1, t2) < 1);
+%! assert (etime (t1, t2) < 1);
 
diff --git a/scripts/time/ctime.m b/scripts/time/ctime.m
--- a/scripts/time/ctime.m
+++ b/scripts/time/ctime.m
@@ -21,17 +21,17 @@
 ## Convert a value returned from @code{time} (or any other non-negative
 ## integer), to the local time and return a string of the same form as
 ## @code{asctime}.  The function @code{ctime (time)} is equivalent to
 ## @code{asctime (localtime (time))}.  For example:
 ##
 ## @example
 ## @group
 ## ctime (time ())
-##      @result{} "Mon Feb 17 01:15:06 1997"
+##    @result{} "Mon Feb 17 01:15:06 1997"
 ## @end group
 ## @end example
 ## @seealso{asctime, time, localtime}
 ## @end deftypefn
 
 ## Author: jwe
 
 function retval = ctime (t)
@@ -42,13 +42,13 @@ function retval = ctime (t)
 
   retval = asctime (localtime (t));
 
 endfunction
 
 
 %!test
 %! t = time ();
-%! assert(strcmp (asctime (localtime (t)), ctime (t)));
+%! assert (strcmp (asctime (localtime (t)), ctime (t)));
 
-%!error ctime ();
-%!error ctime (1, 2);
+%!error ctime ()
+%!error ctime (1, 2)
 
diff --git a/scripts/time/date.m b/scripts/time/date.m
--- a/scripts/time/date.m
+++ b/scripts/time/date.m
@@ -20,24 +20,25 @@
 ## @deftypefn {Function File} {} date ()
 ## Return the current date as a character string in the form DD-MMM-YYYY@.
 ##
 ## For example:
 ##
 ## @example
 ## @group
 ## date ()
-##      @result{} "20-Aug-1993"
+##   @result{} "20-Aug-1993"
 ## @end group
 ## @end example
 ## @seealso{now, clock, datestr, localtime}
 ## @end deftypefn
 
 ## Author: jwe
 
 function retval = date ()
 
   retval = strftime ("%d-%b-%Y", localtime (time ()));
 
 endfunction
 
-%!assert(strcmp (date (), strftime ("%d-%b-%Y", localtime (time ()))));
 
+%!assert (strcmp (date (), strftime ("%d-%b-%Y", localtime (time ()))))
+
diff --git a/scripts/time/datenum.m b/scripts/time/datenum.m
--- a/scripts/time/datenum.m
+++ b/scripts/time/datenum.m
@@ -154,29 +154,29 @@ endfunction
 %! n = [730990; 517712] + part;
 %! assert (datenum (t), n, 2*eps);
 %! ## Check that vectors can have either orientation
 %! t = t';
 %! n = n';
 %! assert (datenum (t(1,:), t(2,:), t(3,:), t(4,:), t(5,:), t(6,:)), n, 2*eps);
 
 ## Test mixed vectors and scalars
-%!assert (datenum([2008;2009], 1, 1), [datenum(2008, 1, 1);datenum(2009, 1, 1)]);
-%!assert (datenum(2008, [1;2], 1), [datenum(2008, 1, 1);datenum(2008, 2, 1)]);
-%!assert (datenum(2008, 1, [1;2]), [datenum(2008, 1, 1);datenum(2008, 1, 2)]);
-%!assert (datenum([2008;2009], [1;2], 1), [datenum(2008, 1, 1);datenum(2009, 2, 1)]);
-%!assert (datenum([2008;2009], 1, [1;2]), [datenum(2008, 1, 1);datenum(2009, 1, 2)]);
-%!assert (datenum(2008, [1;2], [1;2]), [datenum(2008, 1, 1);datenum(2008, 2, 2)]);
+%!assert (datenum ([2008;2009],1,1), [datenum(2008,1,1);datenum(2009,1,1)])
+%!assert (datenum (2008, [1;2], 1), [datenum(2008,1,1);datenum(2008,2,1)])
+%!assert (datenum (2008, 1, [1;2]), [datenum(2008,1,1);datenum(2008,1,2)])
+%!assert (datenum ([2008;2009], [1;2], 1), [datenum(2008,1,1);datenum(2009,2,1)])
+%!assert (datenum ([2008;2009], 1, [1;2]), [datenum(2008,1,1);datenum(2009,1,2)])
+%!assert (datenum (2008, [1;2], [1;2]), [datenum(2008,1,1);datenum(2008,2,2)])
 ## And the other orientation
-%!assert (datenum([2008 2009], 1, 1), [datenum(2008, 1, 1) datenum(2009, 1, 1)]);
-%!assert (datenum(2008, [1 2], 1), [datenum(2008, 1, 1) datenum(2008, 2, 1)]);
-%!assert (datenum(2008, 1, [1 2]), [datenum(2008, 1, 1) datenum(2008, 1, 2)]);
-%!assert (datenum([2008 2009], [1 2], 1), [datenum(2008, 1, 1) datenum(2009, 2, 1)]);
-%!assert (datenum([2008 2009], 1, [1 2]), [datenum(2008, 1, 1) datenum(2009, 1, 2)]);
-%!assert (datenum(2008, [1 2], [1 2]), [datenum(2008, 1, 1) datenum(2008, 2, 2)]);
+%!assert (datenum ([2008 2009], 1, 1), [datenum(2008,1,1) datenum(2009,1,1)])
+%!assert (datenum (2008, [1 2], 1), [datenum(2008,1,1) datenum(2008,2,1)])
+%!assert (datenum (2008, 1, [1 2]), [datenum(2008,1,1) datenum(2008,1,2)])
+%!assert (datenum ([2008 2009], [1 2], 1), [datenum(2008,1,1) datenum(2009,2,1)])
+%!assert (datenum ([2008 2009], 1, [1 2]), [datenum(2008,1,1) datenum(2009,1,2)])
+%!assert (datenum (2008, [1 2], [1 2]), [datenum(2008,1,1) datenum(2008,2,2)])
 ## Test string and cellstr inputs
 %!assert (datenum ("5/19/2001"), 730990)
 %!assert (datenum ({"5/19/2001"}), 730990)
 %!assert (datenum (char ("5/19/2001", "6/6/1944")), [730990; 710189])
 %!assert (datenum ({"5/19/2001", "6/6/1944"}), [730990; 710189])
 
 %% Test input validation
 %!error datenum ()
diff --git a/scripts/time/datetick.m b/scripts/time/datetick.m
--- a/scripts/time/datetick.m
+++ b/scripts/time/datetick.m
@@ -60,17 +60,17 @@ endfunction
 %!demo
 %! clf;
 %! yr = 1988:2:2002;
 %! yr = datenum (yr,1,1);
 %! pr = [12.1 13.3 12.6 13.1 13.3 14.1 14.4 15.2];
 %! plot (yr, pr);
 %! xlabel ("year");
 %! ylabel ("average price");
-%! ax = gca ();
+%! ax = gca;
 %! set (ax, "xtick", datenum (1990:5:2005,1,1));
 %! datetick (2, "keepticks");
 %! set (ax, "ytick", 12:16);
 
 ## Remove from test statistics.  No real tests possible.
 %!assert (1)
 
 function __datetick__ (varargin)
diff --git a/scripts/time/datevec.m b/scripts/time/datevec.m
--- a/scripts/time/datevec.m
+++ b/scripts/time/datevec.m
@@ -292,13 +292,13 @@ endfunction
 %!assert (datevec ("15:38"), [nowvec(1:3),15,38,0])
 %!assert (datevec ("03:38 PM"), [nowvec(1:3),15,38,0])
 %!assert (datevec ("03/13/1962"), [1962,3,13,0,0,0])
 
 %% Test millisecond format FFF
 %!assert (datevec ("15:38:21.25", "HH:MM:SS.FFF"), [nowvec(1:3),15,38,21.025])
 
 # Other tests
-%!assert (datenum (datevec ([-1e4:1e4])), [-1e4:1e4]')
+%!assert (datenum (datevec ([-1e4:1e4])), [-1e4:1e4]');
 %!test
 %! t = linspace (-2e5, 2e5, 10993);
 %! assert (all (abs (datenum (datevec (t)) - t') < 1e-5));
 
diff --git a/scripts/time/eomday.m b/scripts/time/eomday.m
--- a/scripts/time/eomday.m
+++ b/scripts/time/eomday.m
@@ -49,17 +49,17 @@ endfunction
 %!assert (eomday ([-4:4],2), [29,28,28,28,29,28,28,28,29])
 %!assert (eomday ([-901,901],2), [28,28])
 %!assert (eomday ([-100,100],2), [28,28])
 %!assert (eomday ([-900,900],2), [28,28])
 %!assert (eomday ([-400,400],2), [29,29])
 %!assert (eomday ([-800,800],2), [29,29])
 %!assert (eomday (2001,1:12), [31,28,31,30,31,30,31,31,30,31,30,31])
 %!assert (eomday (1:3,1:3), [31,28,31])
-%!assert (eomday (1:2000,2)', datevec(datenum(1:2000,3,0))(:,3))
+%!assert (eomday (1:2000,2)', datevec (datenum (1:2000,3,0))(:,3))
 %!assert ([1900:1999](find(eomday(1900:1999,2*ones(1,100))==29)), [1904,1908,1912,1916,1920,1924,1928,1932,1936,1940,1944,1948,1952,1956,1960,1964,1968,1972,1976,1980,1984,1988,1992,1996])
 %!assert (eomday ([2004;2005], [2;2]), [29;28])
 
 %% Test input validation
 %!error eomday ()
 %!error eomday (1)
 %!error eomday (1,2,3)
 
diff --git a/scripts/time/etime.m b/scripts/time/etime.m
--- a/scripts/time/etime.m
+++ b/scripts/time/etime.m
@@ -46,24 +46,24 @@ function secs = etime (t2, t1)
   [~, s2] = datenum (t2);
   [~, s1] = datenum (t1);
 
   secs = s2 - s1;
 
 endfunction
 
 
-%!assert (etime ([1900,12,31,23,59,59],[1901,1,1,0,0,0]),-1)
-%!assert (etime ([1900,2,28,23,59,59],[1900,3,1,0,0,0]),-1)
-%!assert (etime ([2000,2,28,23,59,59],[2000,3,1,0,0,0]),-86401)
-%!assert (etime ([1996,2,28,23,59,59],[1996,3,1,0,0,0]),-86401)
+%!assert (etime ([1900,12,31,23,59,59], [1901,1,1,0,0,0]), -1)
+%!assert (etime ([1900,2,28,23,59,59], [1900,3,1,0,0,0]), -1)
+%!assert (etime ([2000,2,28,23,59,59], [2000,3,1,0,0,0]), -86401)
+%!assert (etime ([1996,2,28,23,59,59], [1996,3,1,0,0,0]), -86401)
 %!test
 %! t1 = [1900,12,31,23,59,59; 1900,2,28,23,59,59];
 %! t2 = [1901,1,1,0,0,0; 1900,3,1,0,0,0];
-%! assert(etime(t2, t1), [1;1]);
+%! assert (etime (t2, t1), [1;1]);
 
 %!test
 %! t1 = [1993, 8, 20, 4, 56, 1];
 %! t2 = [1993, 8, 21, 4, 56, 1];
 %! t3 = [1993, 8, 20, 5, 56, 1];
 %! t4 = [1993, 8, 20, 4, 57, 1];
 %! t5 = [1993, 8, 20, 4, 56, 14];
 %!
diff --git a/scripts/time/is_leap_year.m b/scripts/time/is_leap_year.m
--- a/scripts/time/is_leap_year.m
+++ b/scripts/time/is_leap_year.m
@@ -21,17 +21,17 @@
 ## @deftypefnx {Function File} {} is_leap_year (@var{year})
 ## Return true if @var{year} is a leap year and false otherwise.  If no
 ## year is specified, @code{is_leap_year} uses the current year.
 ## For example:
 ##
 ## @example
 ## @group
 ## is_leap_year (2000)
-##      @result{} 1
+##    @result{} 1
 ## @end group
 ## @end example
 ## @seealso{weekday, eomday, calendar}
 ## @end deftypefn
 
 ## Author: jwe
 
 function retval = is_leap_year (year)
@@ -51,10 +51,10 @@ endfunction
 
 
 %!assert (is_leap_year (2000), true)
 %!assert (is_leap_year (1976), true)
 %!assert (is_leap_year (1000), false)
 %!assert (is_leap_year (1800), false)
 %!assert (is_leap_year (1600), true)
 
-%!error is_leap_year (1, 2);
+%!error is_leap_year (1, 2)
 
diff --git a/scripts/time/now.m b/scripts/time/now.m
--- a/scripts/time/now.m
+++ b/scripts/time/now.m
@@ -49,13 +49,14 @@ function t = now ()
   ##
   ## mktime(gmtime(0)) does indeed return the offset from Greenwich to the
   ## local time zone, but we need to account for daylight savings time
   ## changing by an hour the offset from CUT for part of the year.
 
 endfunction
 
 
-%!assert (isnumeric (now ()));
-%!assert (now () > 0);
-%!assert (now () <= now ());
+%!assert (isnumeric (now ()))
+%!assert (now () > 0)
+%!assert (now () <= now ())
 
-%!error now (1);
+%!error now (1)
+
diff --git a/src/DLD-FUNCTIONS/__delaunayn__.cc b/src/DLD-FUNCTIONS/__delaunayn__.cc
--- a/src/DLD-FUNCTIONS/__delaunayn__.cc
+++ b/src/DLD-FUNCTIONS/__delaunayn__.cc
@@ -44,24 +44,31 @@ along with Octave; see the file COPYING.
 
 #include <iostream>
 #include <string>
 
 #include "Cell.h"
 #include "defun-dld.h"
 #include "error.h"
 #include "oct-obj.h"
+#include "unwind-prot.h"
 
 #if defined (HAVE_QHULL)
 # include "oct-qhull.h"
 # if defined (NEED_QHULL_VERSION)
 char qh_version[] = "__delaunayn__.oct 2007-08-21";
 # endif
 #endif
 
+static void
+close_fcn (FILE *f)
+{
+  gnulib::fclose (f);
+}
+
 DEFUN_DLD (__delaunayn__, args, ,
            "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {@var{T} =} __delaunayn__ (@var{pts})\n\
 @deftypefnx {Loadable Function} {@var{T} =} __delaunayn__ (@var{pts}, @var{options})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 
 {
@@ -116,20 +123,34 @@ Undocumented internal function.\n\
       double *pt_array = p.fortran_vec ();
       boolT ismalloc = false;
 
       // Qhull flags argument is not const char*
       OCTAVE_LOCAL_BUFFER (char, flags, 9 + options.length());
 
       sprintf (flags, "qhull d %s", options.c_str ());
 
-      // Replace the 0 pointer with stdout for debugging information
-      FILE *outfile = 0;
+      unwind_protect frame;
+
+      // Replace the outfile pointer with stdout for debugging information.
+#if defined (OCTAVE_HAVE_WINDOWS_FILESYSTEM) && ! defined (OCTAVE_HAVE_POSIX_FILESYSTEM)
+      FILE *outfile = gnulib::fopen ("NUL", "w");
+#else
+      FILE *outfile = gnulib::fopen ("/dev/null", "w");
+#endif
       FILE *errfile = stderr;
-      
+
+      if (outfile)
+        frame.add_fcn (close_fcn, outfile);
+      else
+        {
+          error ("__delaunayn__: unable to create temporary file for output");
+          return retval;
+        }
+
       int exitcode = qh_new_qhull (dim, n, pt_array, 
                                    ismalloc, flags, outfile, errfile);
       if (! exitcode)
         {
           // triangulate non-simplicial facets
           qh_triangulate ();
 
           facetT *facet;
diff --git a/src/DLD-FUNCTIONS/__init_fltk__.cc b/src/DLD-FUNCTIONS/__init_fltk__.cc
--- a/src/DLD-FUNCTIONS/__init_fltk__.cc
+++ b/src/DLD-FUNCTIONS/__init_fltk__.cc
@@ -1163,22 +1163,22 @@ private:
     Fl_Window::resize (xx, yy, ww, hh);
 
     Matrix pos (1,4,0);
     pos(0) = xx;
     pos(1) = yy;
     pos(2) = ww;
     pos(3) = hh - status_h - menu_h;
 
-    fp.set_position (pos);
+    fp.set_boundingbox (pos, true);
   }
 
   void draw (void)
   {
-    Matrix pos = fp.get_position ().matrix_value ();
+    Matrix pos = fp.get_boundingbox (true);
     Fl_Window::resize (pos(0), pos(1), pos(2), pos(3) + status_h + menu_h);
 
     return Fl_Window::draw ();
   }
 
   int handle (int event)
   {
     graphics_handle gh;
@@ -1291,22 +1291,22 @@ private:
                       pixel2status (ax_obj, pos_x, pos_y,
                                     Fl::event_x (), Fl::event_y ());
                     else
                       view2status (ax_obj);
                     axes::properties& ap =
                       dynamic_cast<axes::properties&> (ax_obj.get_properties ());
 
                     double x0, y0, x1, y1;
-                    Matrix pos = fp.get_position ().matrix_value ();
+                    Matrix pos = fp.get_boundingbox (true);
                     pixel2pos (ax_obj, pos_x, pos_y, x0, y0);
                     pixel2pos (ax_obj, Fl::event_x (), Fl::event_y (), x1, y1);
 
                     if (gui_mode == pan_zoom)
-                      ap.translate_view (x0 - x1, y0 - y1);
+                      ap.translate_view (x0, x1, y0, y1);
                     else if (gui_mode == rotate_zoom)
                       {
                         double daz, del;
                         daz = (Fl::event_x () - pos_x) / pos(2) * 360;
                         del = (Fl::event_y () - pos_y) / pos(3) * 360;
                         ap.rotate_view (del, daz);
                       }
 
@@ -2050,16 +2050,17 @@ This function is currently implemented o
 }
 
 DEFUN_DLD (gui_mode, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{mode} =} gui_mode ()\n\
 @deftypefnx {Built-in Function} {} gui_mode (@var{mode})\n\
 Query or set the GUI mode for the current graphics toolkit.\n\
 The @var{mode} argument can be one of the following strings:\n\
+\n\
 @table @asis\n\
 @item '2d'\n\
 Allows panning and zooming of current axes.\n\
 \n\
 @item '3d'\n\
 Allows rotating and zooming of current axes.\n\
 \n\
 @item 'none'\n\
diff --git a/src/DLD-FUNCTIONS/__voronoi__.cc b/src/DLD-FUNCTIONS/__voronoi__.cc
--- a/src/DLD-FUNCTIONS/__voronoi__.cc
+++ b/src/DLD-FUNCTIONS/__voronoi__.cc
@@ -39,24 +39,31 @@ qhull command
 #include <list>
 
 #include "lo-ieee.h"
 
 #include "Cell.h"
 #include "defun-dld.h"
 #include "error.h"
 #include "oct-obj.h"
+#include "unwind-prot.h"
 
 #if defined (HAVE_QHULL)
 # include "oct-qhull.h"
 # if defined (NEED_QHULL_VERSION)
 char qh_version[] = "__voronoi__.oct 2007-07-24";
 # endif
 #endif
 
+static void
+close_fcn (FILE *f)
+{
+  gnulib::fclose (f);
+}
+
 DEFUN_DLD (__voronoi__, args, ,
         "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {@var{C}, @var{F} =} __voronoi__ (@var{caller}, @var{pts})\n\
 @deftypefnx {Loadable Function} {@var{C}, @var{F} =} __voronoi__ (@var{caller}, @var{pts}, @var{options})\n\
 @deftypefnx {Loadable Function} {@var{C}, @var{F}, @var{Inf_Pts} =} __voronoi__ (@dots{})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
@@ -110,20 +117,34 @@ Undocumented internal function.\n\
           error ("%s: OPTIONS must be a string, cell array of strings, or empty",
                  caller.c_str ());
           return retval;
         }
     }
 
   boolT ismalloc = false;
 
-  // Replace the 0 pointer with stdout for debugging information
-  FILE *outfile = 0;
+  unwind_protect frame;
+
+  // Replace the outfile pointer with stdout for debugging information.
+#if defined (OCTAVE_HAVE_WINDOWS_FILESYSTEM) && ! defined (OCTAVE_HAVE_POSIX_FILESYSTEM)
+  FILE *outfile = gnulib::fopen ("NUL", "w");
+#else
+  FILE *outfile = gnulib::fopen ("/dev/null", "w");
+#endif
   FILE *errfile = stderr;
 
+  if (outfile)
+    frame.add_fcn (close_fcn, outfile);
+  else
+    {
+      error ("__voronoi__: unable to create temporary file for output");
+      return retval;
+    }
+
   // qh_new_qhull command and points arguments are not const...
 
   std::string cmd = "qhull v" + options;
 
   OCTAVE_LOCAL_BUFFER (char, cmd_str, cmd.length () + 1);
 
   strcpy (cmd_str, cmd.c_str ());
 
diff --git a/src/DLD-FUNCTIONS/besselj.cc b/src/DLD-FUNCTIONS/besselj.cc
--- a/src/DLD-FUNCTIONS/besselj.cc
+++ b/src/DLD-FUNCTIONS/besselj.cc
@@ -526,20 +526,20 @@ DEFUN_DLD (airy, args, nargout,
 @deftypefn {Loadable Function} {[@var{a}, @var{ierr}] =} airy (@var{k}, @var{z}, @var{opt})\n\
 Compute Airy functions of the first and second kind, and their\n\
 derivatives.\n\
 \n\
 @example\n\
 @group\n\
  K   Function   Scale factor (if 'opt' is supplied)\n\
 ---  --------   ---------------------------------------\n\
- 0   Ai (Z)     exp ((2/3) * Z * sqrt (Z))\n\
- 1   dAi(Z)/dZ  exp ((2/3) * Z * sqrt (Z))\n\
- 2   Bi (Z)     exp (-abs (real ((2/3) * Z *sqrt (Z))))\n\
- 3   dBi(Z)/dZ  exp (-abs (real ((2/3) * Z *sqrt (Z))))\n\
+ 0   Ai (Z)     exp (2/3 * Z * sqrt (Z))\n\
+ 1   dAi(Z)/dZ  exp (2/3 * Z * sqrt (Z))\n\
+ 2   Bi (Z)     exp (-abs (real (2/3 * Z *sqrt (Z))))\n\
+ 3   dBi(Z)/dZ  exp (-abs (real (2/3 * Z *sqrt (Z))))\n\
 @end group\n\
 @end example\n\
 \n\
 The function call @code{airy (@var{z})} is equivalent to\n\
 @code{airy (0, @var{z})}.\n\
 \n\
 The result is the same size as @var{z}.\n\
 \n\
diff --git a/src/DLD-FUNCTIONS/betainc.cc b/src/DLD-FUNCTIONS/betainc.cc
--- a/src/DLD-FUNCTIONS/betainc.cc
+++ b/src/DLD-FUNCTIONS/betainc.cc
@@ -45,18 +45,18 @@ Return the regularized incomplete Beta f
 @c Set example in small font to prevent overfull line\n\
 \n\
 @smallexample\n\
 @group\n\
 @c spacing appears odd here, but is correct after Makeinfo\n\
                                      x\n\
                           1         /\n\
 betainc (x, a, b) = -----------    | t^(a-1) (1-t)^(b-1) dt.\n\
-                     beta (a, b)    /\n\
-                                 t=0\n\
+                     beta (a, b)   /\n\
+                                t=0\n\
 @end group\n\
 @end smallexample\n\
 \n\
 @end ifnottex\n\
 \n\
 If @var{x} has more than one component, both @var{a} and @var{b} must be\n\
 scalars.  If @var{x} is a scalar, @var{a} and @var{b} must be of\n\
 compatible dimensions.\n\
diff --git a/src/DLD-FUNCTIONS/cellfun.cc b/src/DLD-FUNCTIONS/cellfun.cc
--- a/src/DLD-FUNCTIONS/cellfun.cc
+++ b/src/DLD-FUNCTIONS/cellfun.cc
@@ -252,18 +252,18 @@ get_mapper_fun_options (const octave_val
 DEFUN_DLD (cellfun, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {} cellfun (@var{name}, @var{C})\n\
 @deftypefnx {Loadable Function} {} cellfun (\"size\", @var{C}, @var{k})\n\
 @deftypefnx {Loadable Function} {} cellfun (\"isclass\", @var{C}, @var{class})\n\
 @deftypefnx {Loadable Function} {} cellfun (@var{func}, @var{C})\n\
 @deftypefnx {Loadable Function} {} cellfun (@var{func}, @var{C}, @var{D})\n\
 @deftypefnx {Loadable Function} {[@var{a}, @dots{}] =} cellfun (@dots{})\n\
-@deftypefnx {Loadable Function} {} cellfun (@dots{}, 'ErrorHandler', @var{errfunc})\n\
-@deftypefnx {Loadable Function} {} cellfun (@dots{}, 'UniformOutput', @var{val})\n\
+@deftypefnx {Loadable Function} {} cellfun (@dots{}, \"ErrorHandler\", @var{errfunc})\n\
+@deftypefnx {Loadable Function} {} cellfun (@dots{}, \"UniformOutput\", @var{val})\n\
 \n\
 Evaluate the function named @var{name} on the elements of the cell array\n\
 @var{C}.  Elements in @var{C} are passed on to the named function\n\
 individually.  The function @var{name} can be one of the functions\n\
 \n\
 @table @code\n\
 @item isempty\n\
 Return 1 for empty elements.\n\
@@ -298,17 +298,17 @@ function (in a character string).  In th
 argument, the function must accept a single argument named @var{x}, and\n\
 it must return a string value.  The function can take one or more arguments,\n\
 with the inputs arguments given by @var{C}, @var{D}, etc.  Equally the\n\
 function can return one or more output arguments.  For example:\n\
 \n\
 @example\n\
 @group\n\
 cellfun (\"atan2\", @{1, 0@}, @{0, 1@})\n\
-     @result{}ans = [1.57080   0.00000]\n\
+     @result{} [ 1.57080   0.00000 ]\n\
 @end group\n\
 @end example\n\
 \n\
 The number of output arguments of @code{cellfun} matches the number of output\n\
 arguments of the function.  The outputs of the function will be collected\n\
 into the output arguments of @code{cellfun} like this:\n\
 \n\
 @example\n\
@@ -325,48 +325,48 @@ endfunction\n\
            1 4 9\n\
 @end group\n\
 @end example\n\
 \n\
 Note that per default the output argument(s) are arrays of the same size as\n\
 the input arguments.  Input arguments that are singleton (1x1) cells will be\n\
 automatically expanded to the size of the other arguments.\n\
 \n\
-If the parameter 'UniformOutput' is set to true (the default), then the\n\
+If the parameter \"UniformOutput\" is set to true (the default), then the\n\
 function must return scalars which will be concatenated into the return\n\
-array(s).  If 'UniformOutput' is false, the outputs are concatenated into a\n\
+array(s).  If \"UniformOutput\" is false, the outputs are concatenated into a\n\
 cell array (or cell arrays).  For example:\n\
 \n\
 @example\n\
 @group\n\
 cellfun (\"tolower\", @{\"Foo\", \"Bar\", \"FooBar\"@},\n\
-         \"UniformOutput\",false)\n\
-@result{} ans = @{\"foo\", \"bar\", \"foobar\"@}\n\
+         \"UniformOutput\", false)\n\
+@result{} @{\"foo\", \"bar\", \"foobar\"@}\n\
 @end group\n\
 @end example\n\
 \n\
-Given the parameter 'ErrorHandler', then @var{errfunc} defines a function to\n\
-call in case @var{func} generates an error.  The form of the function is\n\
+Given the parameter \"ErrorHandler\", then @var{errfunc} defines a function\n\
+to call in case @var{func} generates an error.  The form of the function is\n\
 \n\
 @example\n\
 function [@dots{}] = errfunc (@var{s}, @dots{})\n\
 @end example\n\
 \n\
 @noindent\n\
 where there is an additional input argument to @var{errfunc} relative to\n\
 @var{func}, given by @var{s}.  This is a structure with the elements\n\
 'identifier', 'message' and 'index', giving respectively the error\n\
 identifier, the error message, and the index into the input arguments\n\
 of the element that caused the error.  For example:\n\
 \n\
 @example\n\
 @group\n\
 function y = foo (s, x), y = NaN; endfunction\n\
-cellfun (\"factorial\", @{-1,2@}, 'ErrorHandler', @@foo)\n\
-@result{} ans = [NaN 2]\n\
+cellfun (\"factorial\", @{-1,2@}, \"ErrorHandler\", @@foo)\n\
+@result{} [NaN 2]\n\
 @end group\n\
 @end example\n\
 \n\
 Use @code{cellfun} intelligently.  The @code{cellfun} function is a\n\
 useful tool for avoiding loops.  It is often used with anonymous\n\
 function handles; however, calling an anonymous function involves an\n\
 overhead quite comparable to the overhead of an m-file function.\n\
 Passing a handle to a built-in function is faster, because the\n\
@@ -1037,61 +1037,61 @@ The named function can also take more th
 the input arguments given as third input argument @var{b}, fourth\n\
 input argument @var{c}, @dots{}  If given more than one array input\n\
 argument then all input arguments must have the same sizes, for\n\
 example:\n\
 \n\
 @example\n\
 @group\n\
 arrayfun (@@atan2, [1, 0], [0, 1])\n\
-@result{} ans = [1.5708   0.0000]\n\
+     @result{} [ 1.5708   0.0000 ]\n\
 @end group\n\
 @end example\n\
 \n\
 If the parameter @var{val} after a further string input argument\n\
 \"UniformOutput\" is set @code{true} (the default), then the named\n\
 function @var{func} must return a single element which then will be\n\
 concatenated into the return value and is of type matrix.  Otherwise,\n\
 if that parameter is set to @code{false}, then the outputs are\n\
 concatenated in a cell array.  For example:\n\
 \n\
 @example\n\
 @group\n\
 arrayfun (@@(x,y) x:y, \"abc\", \"def\", \"UniformOutput\", false)\n\
-@result{} ans =\n\
-    @{\n\
-      [1,1] = abcd\n\
-      [1,2] = bcde\n\
-      [1,3] = cdef\n\
-    @}\n\
+@result{}\n\
+   @{\n\
+     [1,1] = abcd\n\
+     [1,2] = bcde\n\
+     [1,3] = cdef\n\
+   @}\n\
 @end group\n\
 @end example\n\
 \n\
 If more than one output arguments are given then the named function\n\
 must return the number of return values that also are expected, for\n\
 example:\n\
 \n\
 @example\n\
 @group\n\
 [A, B, C] = arrayfun (@@find, [10; 0], \"UniformOutput\", false)\n\
 @result{}\n\
 A =\n\
 @{\n\
-  [1,1] =  1\n\
-  [2,1] = [](0x0)\n\
+   [1,1] =  1\n\
+   [2,1] = [](0x0)\n\
 @}\n\
 B =\n\
 @{\n\
-  [1,1] =  1\n\
-  [2,1] = [](0x0)\n\
+   [1,1] =  1\n\
+   [2,1] = [](0x0)\n\
 @}\n\
 C =\n\
 @{\n\
-  [1,1] =  10\n\
-  [2,1] = [](0x0)\n\
+   [1,1] =  10\n\
+   [2,1] = [](0x0)\n\
 @}\n\
 @end group\n\
 @end example\n\
 \n\
 If the parameter @var{errfunc} after a further string input argument\n\
 \"ErrorHandler\" is another string, a function handle, an inline\n\
 function, or an anonymous function, then @var{errfunc} defines a\n\
 function to call in the case that @var{func} generates an error.\n\
@@ -1110,21 +1110,21 @@ the array elements that caused the error
 argument of @var{errfunc} must have the same size as the output\n\
 argument of @var{func}, otherwise a real error is thrown.  For\n\
 example:\n\
 \n\
 @example\n\
 @group\n\
 function y = ferr (s, x), y = \"MyString\"; endfunction\n\
 arrayfun (@@str2num, [1234],\n\
-           \"UniformOutput\", false, \"ErrorHandler\", @@ferr)\n\
-@result{} ans =\n\
-    @{\n\
+          \"UniformOutput\", false, \"ErrorHandler\", @@ferr)\n\
+@result{}\n\
+   @{\n\
      [1,1] = MyString\n\
-    @}\n\
+   @}\n\
 @end group\n\
 @end example\n\
 \n\
 @seealso{spfun, cellfun, structfun}\n\
 @end deftypefn")
 {
   octave_value_list retval;
   int nargin = args.length ();
@@ -1805,34 +1805,34 @@ DEFUN_DLD (num2cell, args, ,
 @deftypefn  {Loadable Function} {@var{C} =} num2cell (@var{A})\n\
 @deftypefnx {Loadable Function} {@var{C} =} num2cell (@var{A}, @var{dim})\n\
 Convert the numeric matrix @var{A} to a cell array.  If @var{dim} is\n\
 defined, the value @var{C} is of dimension 1 in this dimension and the\n\
 elements of @var{A} are placed into @var{C} in slices.  For example:\n\
 \n\
 @example\n\
 @group\n\
-num2cell([1,2;3,4])\n\
-     @result{} ans =\n\
-        @{\n\
-          [1,1] =  1\n\
-          [2,1] =  3\n\
-          [1,2] =  2\n\
-          [2,2] =  4\n\
-        @}\n\
-num2cell([1,2;3,4],1)\n\
-     @result{} ans =\n\
-        @{\n\
-          [1,1] =\n\
-             1\n\
-             3\n\
-          [1,2] =\n\
-             2\n\
-             4\n\
-        @}\n\
+num2cell ([1,2;3,4])\n\
+   @result{}\n\
+      @{\n\
+        [1,1] =  1\n\
+        [2,1] =  3\n\
+        [1,2] =  2\n\
+        [2,2] =  4\n\
+      @}\n\
+num2cell ([1,2;3,4],1)\n\
+   @result{}\n\
+      @{\n\
+        [1,1] =\n\
+           1\n\
+           3\n\
+        [1,2] =\n\
+           2\n\
+           4\n\
+      @}\n\
 @end group\n\
 @end example\n\
 \n\
 @seealso{mat2cell}\n\
 @end deftypefn")
 {
   int nargin =  args.length();
   octave_value retval;
@@ -2144,35 +2144,36 @@ to the dimensions of @var{A}, then it is
 == size (@var{A}, i)}.\n\
 \n\
 Given a single dimensional argument @var{r}, the other dimensional\n\
 arguments are assumed to equal @code{size (@var{A},@var{i})}.\n\
 \n\
 An example of the use of mat2cell is\n\
 \n\
 @example\n\
-mat2cell (reshape(1:16,4,4),[3,1],[3,1])\n\
-@result{} @{\n\
-  [1,1] =\n\
+mat2cell (reshape (1:16,4,4), [3,1], [3,1])\n\
+@result{}\n\
+@{\n\
+   [1,1] =\n\
 \n\
-     1   5   9\n\
-     2   6  10\n\
-     3   7  11\n\
-\n\
-  [2,1] =\n\
+      1   5   9\n\
+      2   6  10\n\
+      3   7  11\n\
 \n\
-     4   8  12\n\
+   [2,1] =\n\
 \n\
-  [1,2] =\n\
+      4   8  12\n\
+\n\
+   [1,2] =\n\
 \n\
-    13\n\
-    14\n\
-    15\n\
+     13\n\
+     14\n\
+     15\n\
 \n\
-  [2,2] = 16\n\
+   [2,2] = 16\n\
 @}\n\
 @end example\n\
 @seealso{num2cell, cell2mat}\n\
 @end deftypefn")
 {
   int nargin = args.length();
   octave_value retval;
 
@@ -2425,20 +2426,20 @@ slicing is done along the first non-sing
 
 DEFUN_DLD (cellindexmat, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{y} =} cellindexmat (@var{x}, @var{varargin})\n\
 Given a cell array of matrices @var{x}, this function computes\n\
 \n\
 @example\n\
 @group\n\
-  Y = cell (size (X));\n\
-  for i = 1:numel (X)\n\
-    Y@{i@} = X@{i@}(varargin@{:@});\n\
-  endfor\n\
+Y = cell (size (X));\n\
+for i = 1:numel (X)\n\
+  Y@{i@} = X@{i@}(varargin@{:@});\n\
+endfor\n\
 @end group\n\
 @end example\n\
 @seealso{cellslices, cellfun}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () >= 1)
     {
diff --git a/src/DLD-FUNCTIONS/chol.cc b/src/DLD-FUNCTIONS/chol.cc
--- a/src/DLD-FUNCTIONS/chol.cc
+++ b/src/DLD-FUNCTIONS/chol.cc
@@ -60,19 +60,19 @@ get_chol_l (const CHOLT& fact)
                        MatrixType (MatrixType::Lower));
 }
 
 DEFUN_DLD (chol, args, nargout,
 "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {@var{R} =} chol (@var{A})\n\
 @deftypefnx {Loadable Function} {[@var{R}, @var{p}] =} chol (@var{A})\n\
 @deftypefnx {Loadable Function} {[@var{R}, @var{p}, @var{Q}] =} chol (@var{S})\n\
-@deftypefnx {Loadable Function} {[@var{R}, @var{p}, @var{Q}] =} chol (@var{S}, 'vector')\n\
-@deftypefnx {Loadable Function} {[@var{L}, @dots{}] =} chol (@dots{}, 'lower')\n\
-@deftypefnx {Loadable Function} {[@var{L}, @dots{}] =} chol (@dots{}, 'upper')\n\
+@deftypefnx {Loadable Function} {[@var{R}, @var{p}, @var{Q}] =} chol (@var{S}, \"vector\")\n\
+@deftypefnx {Loadable Function} {[@var{L}, @dots{}] =} chol (@dots{}, \"lower\")\n\
+@deftypefnx {Loadable Function} {[@var{L}, @dots{}] =} chol (@dots{}, \"upper\")\n\
 @cindex Cholesky factorization\n\
 Compute the Cholesky@tie{}factor, @var{R}, of the symmetric positive definite\n\
 matrix @var{A}, where\n\
 @tex\n\
 $ R^T R = A $.\n\
 @end tex\n\
 @ifnottex\n\
 \n\
@@ -98,43 +98,43 @@ is the factorization of @code{@var{A}(@v
 \n\
 @example\n\
 @var{R}' * @var{R} = @var{Q}' * @var{A} * @var{Q}.\n\
 @end example\n\
 \n\
 @end ifnottex\n\
 \n\
 The sparsity preserving permutation is generally returned as a matrix.\n\
-However, given the flag 'vector', @var{Q} will be returned as a vector\n\
+However, given the flag \"vector\", @var{Q} will be returned as a vector\n\
 such that\n\
 @tex\n\
 $ R^T R = A (Q, Q)$.\n\
 @end tex\n\
 @ifnottex\n\
 \n\
 @example\n\
 @var{R}' * @var{R} = @var{A}(@var{Q}, @var{Q}).\n\
 @end example\n\
 \n\
 @end ifnottex\n\
 \n\
-Called with either a sparse or full matrix and using the 'lower' flag,\n\
+Called with either a sparse or full matrix and using the \"lower\" flag,\n\
 @code{chol} returns the lower triangular factorization such that\n\
 @tex\n\
 $ L L^T = A $.\n\
 @end tex\n\
 @ifnottex\n\
 \n\
 @example\n\
 @var{L} * @var{L}' = @var{A}.\n\
 @end example\n\
 \n\
 @end ifnottex\n\
 \n\
-For full matrices, if the 'lower' flag is set only the lower triangular part\n\
+For full matrices, if the \"lower\" flag is set only the lower triangular part\n\
 of the matrix is used for the factorization, otherwise the upper triangular\n\
 part is used.\n\
 \n\
 In general the lower triangular factorization is significantly faster for\n\
 sparse matrices.\n\
 @seealso{cholinv, chol2inv}\n\
 @end deftypefn")
 {
diff --git a/src/DLD-FUNCTIONS/colamd.cc b/src/DLD-FUNCTIONS/colamd.cc
--- a/src/DLD-FUNCTIONS/colamd.cc
+++ b/src/DLD-FUNCTIONS/colamd.cc
@@ -646,17 +646,17 @@ DEFUN_DLD (etree, args, nargout,
 @deftypefn  {Loadable Function} {@var{p} =} etree (@var{S})\n\
 @deftypefnx {Loadable Function} {@var{p} =} etree (@var{S}, @var{typ})\n\
 @deftypefnx {Loadable Function} {[@var{p}, @var{q}] =} etree (@var{S}, @var{typ})\n\
 \n\
 Return the elimination tree for the matrix @var{S}.  By default @var{S}\n\
 is assumed to be symmetric and the symmetric elimination tree is\n\
 returned.  The argument @var{typ} controls whether a symmetric or\n\
 column elimination tree is returned.  Valid values of @var{typ} are\n\
-'sym' or 'col', for symmetric or column elimination tree respectively\n\
+\"sym\" or \"col\", for symmetric or column elimination tree respectively\n\
 \n\
 Called with a second argument, @code{etree} also returns the postorder\n\
 permutations on the tree.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
diff --git a/src/DLD-FUNCTIONS/config-module.awk b/src/DLD-FUNCTIONS/config-module.awk
--- a/src/DLD-FUNCTIONS/config-module.awk
+++ b/src/DLD-FUNCTIONS/config-module.awk
@@ -66,12 +66,12 @@ BEGIN {
       {
         printf ("DLD-FUNCTIONS/%s.df: CPPFLAGS += %s\n",
                 basename, cppflags[i]);
         printf ("DLD_FUNCTIONS_%s_la_CPPFLAGS = $(AM_CPPFLAGS) %s\n",
                 basename, cppflags[i]);
       }
     printf ("DLD_FUNCTIONS_%s_la_LDFLAGS = -avoid-version -module $(NO_UNDEFINED_LDFLAG) %s $(OCT_LINK_OPTS)\n",
             basename, ldflags[i]);
-    printf ("DLD_FUNCTIONS_%s_la_LIBADD = liboctinterp.la ../liboctave/liboctave.la ../libcruft/libcruft.la %s $(OCT_LINK_DEPS)\n",
+    printf ("DLD_FUNCTIONS_%s_la_LIBADD = $(DLD_LIBOCTINTERP_LIBADD) ../liboctave/liboctave.la ../libcruft/libcruft.la %s $(OCT_LINK_DEPS)\n",
             basename, libraries[i]);
   }
 }
diff --git a/src/DLD-FUNCTIONS/convhulln.cc b/src/DLD-FUNCTIONS/convhulln.cc
--- a/src/DLD-FUNCTIONS/convhulln.cc
+++ b/src/DLD-FUNCTIONS/convhulln.cc
@@ -35,24 +35,31 @@ 2006-05-01 Tom Holroyd
 
 #include <sstream>
 
 #include "Cell.h"
 #include "defun-dld.h"
 #include "error.h"
 #include "oct-obj.h"
 #include "parse.h"
+#include "unwind-prot.h"
 
 #if defined (HAVE_QHULL)
 # include "oct-qhull.h"
 # if defined (NEED_QHULL_VERSION)
 char qh_version[] = "convhulln.oct 2007-07-24";
 # endif
 #endif
 
+static void
+close_fcn (FILE *f)
+{
+  gnulib::fclose (f);
+}
+
 DEFUN_DLD (convhulln, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {@var{h} =} convhulln (@var{pts})\n\
 @deftypefnx {Loadable Function} {@var{h} =} convhulln (@var{pts}, @var{options})\n\
 @deftypefnx {Loadable Function} {[@var{h}, @var{v}] =} convhulln (@dots{})\n\
 Compute the convex hull of the set of points @var{pts} which is a matrix\n\
 of size [n, dim] containing n points in a space of dimension dim.\n\
 The hull @var{h} is an index vector into the set of points and specifies\n\
@@ -123,20 +130,34 @@ convex hull is calculated.\n\n\
         {
           error ("convhulln: OPTIONS must be a string, cell array of strings, or empty");
           return retval;
         }
      }
 
   boolT ismalloc = false;
 
-  // Replace the 0 pointer with stdout for debugging information.
-  FILE *outfile = 0;
+  unwind_protect frame;
+
+  // Replace the outfile pointer with stdout for debugging information.
+#if defined (OCTAVE_HAVE_WINDOWS_FILESYSTEM) && ! defined (OCTAVE_HAVE_POSIX_FILESYSTEM)
+  FILE *outfile = gnulib::fopen ("NUL", "w");
+#else
+  FILE *outfile = gnulib::fopen ("/dev/null", "w");
+#endif
   FILE *errfile = stderr;
-      
+
+  if (outfile)
+    frame.add_fcn (close_fcn, outfile);
+  else
+    {
+      error ("convhulln: unable to create temporary file for output");
+      return retval;
+    }
+
   // qh_new_qhull command and points arguments are not const...
 
   std::string cmd = "qhull" + options;
 
   OCTAVE_LOCAL_BUFFER (char, cmd_str, cmd.length () + 1);
 
   strcpy (cmd_str, cmd.c_str ());
 
@@ -263,21 +284,26 @@ convex hull is calculated.\n\n\
 #endif
 
   return retval;
 }
 
 /*
 %!testif HAVE_QHULL
 %! cube = [0 0 0;1 0 0;1 1 0;0 1 0;0 0 1;1 0 1;1 1 1;0 1 1];
-%! [h, v] = convhulln (cube);
-%! assert (size (h), [6 4]); 
-%! h = sortrows (sort (h, 2), [1:4]);
-%! assert (h, [1 2 3 4; 1 2 5 6; 1 4 5 8; 2 3 6 7; 3 4 7 8; 5 6 7 8]);
+%! [h, v] = convhulln (cube, "Qt");
+%! assert (size (h), [12 3]); 
+%! h = sortrows (sort (h, 2), [1:3]);
+%! assert (h, [1 2 4; 1 2 6; 1 4 8; 1 5 6; 1 5 8; 2 3 4; 2 3 7; 2 6 7; 3 4 7; 4 7 8; 5 6 7; 5 7 8]);
 %! assert (v, 1, 10*eps);
+%! [h2, v2] = convhulln (cube); % Test defaut option = "Qt"
+%! assert (size (h2), size (h))
+%! h2 = sortrows (sort (h2, 2), [1:3]);
+%! assert (h2, h);
+%! assert (v2, v, 10*eps);
 
 %!testif HAVE_QHULL
 %! cube = [0 0 0;1 0 0;1 1 0;0 1 0;0 0 1;1 0 1;1 1 1;0 1 1];
 %! [h, v] = convhulln (cube, "QJ");
 %! assert (size (h), [12 3]); 
 %! assert (sortrows (sort (h, 2), [1:3]), [1 2 4; 1 2 5; 1 4 5; 2 3 4; 2 3 6; 2 5 6; 3 4 8; 3 6 7; 3 7 8; 4 5 8; 5 6 8; 6 7 8]);
 %! assert (v, 1.0, 1e6*eps);
 
diff --git a/src/DLD-FUNCTIONS/dlmread.cc b/src/DLD-FUNCTIONS/dlmread.cc
--- a/src/DLD-FUNCTIONS/dlmread.cc
+++ b/src/DLD-FUNCTIONS/dlmread.cc
@@ -168,17 +168,17 @@ separation character is defined by @var{
 \n\
 Given two scalar arguments @var{r0} and @var{c0}, these define the starting\n\
 row and column of the data to be read.  These values are indexed from zero,\n\
 such that the first row corresponds to an index of zero.\n\
 \n\
 The @var{range} parameter may be a 4-element vector containing the upper\n\
 left and lower right corner @code{[@var{R0},@var{C0},@var{R1},@var{C1}]}\n\
 where the lowest index value is zero.  Alternatively, a spreadsheet style\n\
-range such as 'A2..Q15' or 'T1:AA5' can be used.  The lowest alphabetical\n\
+range such as \"A2..Q15\" or \"T1:AA5\" can be used.  The lowest alphabetical\n\
 index 'A' refers to the first column.  The lowest row index is 1.\n\
 \n\
 @var{file} should be a file name or file id given by @code{fopen}.  In the\n\
 latter case, the file is read until end of file is reached.\n\
 \n\
 The \"emptyvalue\" option may be used to specify the value used to fill empty\n\
 fields.  The default is zero.\n\
 @seealso{csvread, textscan, textread, dlmwrite}\n\
diff --git a/src/DLD-FUNCTIONS/dot.cc b/src/DLD-FUNCTIONS/dot.cc
--- a/src/DLD-FUNCTIONS/dot.cc
+++ b/src/DLD-FUNCTIONS/dot.cc
@@ -257,19 +257,19 @@ DEFUN_DLD (blkmm, args, ,
 Compute products of matrix blocks.  The blocks are given as\n\
 2-dimensional subarrays of the arrays @var{A}, @var{B}.\n\
 The size of @var{A} must have the form @code{[m,k,@dots{}]} and\n\
 size of @var{B} must be @code{[k,n,@dots{}]}.  The result is\n\
 then of size @code{[m,n,@dots{}]} and is computed as follows:\n\
 \n\
 @example\n\
 @group\n\
-  for i = 1:prod (size (@var{A})(3:end))\n\
-    @var{C}(:,:,i) = @var{A}(:,:,i) * @var{B}(:,:,i)\n\
-  endfor\n\
+for i = 1:prod (size (@var{A})(3:end))\n\
+  @var{C}(:,:,i) = @var{A}(:,:,i) * @var{B}(:,:,i)\n\
+endfor\n\
 @end group\n\
 @end example\n\
 @end deftypefn")
 {
   octave_value retval;
   int nargin = args.length ();
 
   if (nargin != 2)
diff --git a/src/DLD-FUNCTIONS/eigs.cc b/src/DLD-FUNCTIONS/eigs.cc
--- a/src/DLD-FUNCTIONS/eigs.cc
+++ b/src/DLD-FUNCTIONS/eigs.cc
@@ -179,42 +179,42 @@ is the corresponding eigenvector.  If gi
 @end ifinfo\n\
 \n\
 The argument @var{sigma} determines which eigenvalues are returned.\n\
 @var{sigma} can be either a scalar or a string.  When @var{sigma} is a\n\
 scalar, the @var{k} eigenvalues closest to @var{sigma} are returned.  If\n\
 @var{sigma} is a string, it must have one of the following values.\n\
 \n\
 @table @asis\n\
-@item 'lm'\n\
+@item \"lm\"\n\
 Largest Magnitude (default).\n\
 \n\
-@item 'sm'\n\
+@item \"sm\"\n\
 Smallest Magnitude.\n\
 \n\
-@item 'la'\n\
+@item \"la\"\n\
 Largest Algebraic (valid only for real symmetric problems).\n\
 \n\
-@item 'sa'\n\
+@item \"sa\"\n\
 Smallest Algebraic (valid only for real symmetric problems).\n\
 \n\
-@item 'be'\n\
+@item \"be\"\n\
 Both Ends, with one more from the high-end if @var{k} is odd (valid only for\n\
 real symmetric problems).\n\
 \n\
-@item 'lr'\n\
+@item \"lr\"\n\
 Largest Real part (valid only for complex or unsymmetric problems).\n\
 \n\
-@item 'sr'\n\
+@item \"sr\"\n\
 Smallest Real part (valid only for complex or unsymmetric problems).\n\
 \n\
-@item 'li'\n\
+@item \"li\"\n\
 Largest Imaginary part (valid only for complex or unsymmetric problems).\n\
 \n\
-@item 'si'\n\
+@item \"si\"\n\
 Smallest Imaginary part (valid only for complex or unsymmetric problems).\n\
 @end table\n\
 \n\
 If @var{opts} is given, it is a structure defining possible options that\n\
 @code{eigs} should use.  The fields of the @var{opts} structure are:\n\
 \n\
 @table @code\n\
 @item issym\n\
@@ -265,20 +265,20 @@ a function handle, an inline function, o
 string it holds the name of the function to use.\n\
 \n\
 @var{af} is a function of the form @code{y = af (x)}\n\
 where the required return value of @var{af} is determined by\n\
 the value of @var{sigma}.  The four possible forms are\n\
 \n\
 @table @code\n\
 @item A * x\n\
-if @var{sigma} is not given or is a string other than 'sm'.\n\
+if @var{sigma} is not given or is a string other than \"sm\".\n\
 \n\
 @item A \\ x\n\
-if @var{sigma} is 0 or 'sm'.\n\
+if @var{sigma} is 0 or \"sm\".\n\
 \n\
 @item (A - sigma * I) \\ x\n\
 for the standard eigenvalue problem, where @code{I} is the identity matrix of\n\
 the same size as @var{A}.\n\
 \n\
 @item (A - sigma * B) \\ x\n\
 for the general eigenvalue problem.\n\
 @end table\n\
diff --git a/src/DLD-FUNCTIONS/fftw.cc b/src/DLD-FUNCTIONS/fftw.cc
--- a/src/DLD-FUNCTIONS/fftw.cc
+++ b/src/DLD-FUNCTIONS/fftw.cc
@@ -29,86 +29,86 @@ along with Octave; see the file COPYING.
 #include "oct-fftw.h"
 
 #include "defun-dld.h"
 #include "error.h"
 #include "ov.h"
 
 DEFUN_DLD (fftw, args, ,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {@var{method} =} fftw ('planner')\n\
-@deftypefnx {Loadable Function} {} fftw ('planner', @var{method})\n\
-@deftypefnx {Loadable Function} {@var{wisdom} =} fftw ('dwisdom')\n\
-@deftypefnx {Loadable Function} {} fftw ('dwisdom', @var{wisdom})\n\
+@deftypefn  {Loadable Function} {@var{method} =} fftw (\"planner\")\n\
+@deftypefnx {Loadable Function} {} fftw (\"planner\", @var{method})\n\
+@deftypefnx {Loadable Function} {@var{wisdom} =} fftw (\"dwisdom\")\n\
+@deftypefnx {Loadable Function} {} fftw (\"dwisdom\", @var{wisdom})\n\
 \n\
 Manage @sc{fftw} wisdom data.  Wisdom data can be used to significantly\n\
 accelerate the calculation of the FFTs, but implies an initial cost\n\
 in its calculation.  When the @sc{fftw} libraries are initialized, they read\n\
 a system wide wisdom file (typically in @file{/etc/fftw/wisdom}), allowing\n\
 wisdom to be shared between applications other than Octave.  Alternatively,\n\
 the @code{fftw} function can be used to import wisdom.  For example,\n\
 \n\
 @example\n\
-@var{wisdom} = fftw ('dwisdom')\n\
+@var{wisdom} = fftw (\"dwisdom\")\n\
 @end example\n\
 \n\
 @noindent\n\
 will save the existing wisdom used by Octave to the string @var{wisdom}.\n\
 This string can then be saved to a file and restored using the @code{save}\n\
 and @code{load} commands respectively.  This existing wisdom can be\n\
 reimported as follows\n\
 \n\
 @example\n\
-fftw ('dwisdom', @var{wisdom})\n\
+fftw (\"dwisdom\", @var{wisdom})\n\
 @end example\n\
 \n\
 If @var{wisdom} is an empty matrix, then the wisdom used is cleared.\n\
 \n\
 During the calculation of Fourier transforms further wisdom is generated.\n\
 The fashion in which this wisdom is generated is also controlled by\n\
 the @code{fftw} function.  There are five different manners in which the\n\
 wisdom can be treated:\n\
 \n\
 @table @asis\n\
-@item 'estimate'\n\
+@item \"estimate\"\n\
 Specifies that no run-time measurement of the optimal means of\n\
 calculating a particular is performed, and a simple heuristic is used\n\
 to pick a (probably sub-optimal) plan.  The advantage of this method is\n\
 that there is little or no overhead in the generation of the plan, which\n\
 is appropriate for a Fourier transform that will be calculated once.\n\
 \n\
-@item 'measure'\n\
+@item \"measure\"\n\
 In this case a range of algorithms to perform the transform is considered\n\
 and the best is selected based on their execution time.\n\
 \n\
-@item 'patient'\n\
-Similar to 'measure', but a wider range of algorithms is considered.\n\
+@item \"patient\"\n\
+Similar to \"measure\", but a wider range of algorithms is considered.\n\
 \n\
-@item 'exhaustive'\n\
-Like 'measure', but all possible algorithms that may be used to\n\
+@item \"exhaustive\"\n\
+Like \"measure\", but all possible algorithms that may be used to\n\
 treat the transform are considered.\n\
 \n\
-@item 'hybrid'\n\
+@item \"hybrid\"\n\
 As run-time measurement of the algorithm can be expensive, this is a\n\
-compromise where 'measure' is used for transforms up to the size of 8192\n\
-and beyond that the 'estimate' method is used.\n\
+compromise where \"measure\" is used for transforms up to the size of 8192\n\
+and beyond that the \"estimate\" method is used.\n\
 @end table\n\
 \n\
-The default method is 'estimate'.  The current method can\n\
+The default method is \"estimate\".  The current method can\n\
 be queried with\n\
 \n\
 @example\n\
-@var{method} = fftw ('planner')\n\
+@var{method} = fftw (\"planner\")\n\
 @end example\n\
 \n\
 @noindent\n\
 or set by using\n\
 \n\
 @example\n\
-fftw ('planner', @var{method})\n\
+fftw (\"planner\", @var{method})\n\
 @end example\n\
 \n\
 Note that calculated wisdom will be lost when restarting Octave.  However,\n\
 the wisdom data can be reloaded if it is saved to a file as described\n\
 above.  Saved wisdom files should not be used on different platforms since\n\
 they will not be efficient and the point of calculating the wisdom is lost.\n\
 @seealso{fft, ifft, fft2, ifft2, fftn, ifftn}\n\
 @end deftypefn")
diff --git a/src/DLD-FUNCTIONS/filter.cc b/src/DLD-FUNCTIONS/filter.cc
--- a/src/DLD-FUNCTIONS/filter.cc
+++ b/src/DLD-FUNCTIONS/filter.cc
@@ -299,19 +299,19 @@ equation:\n\
  1 \\le n \\le P\n\
 $$\n\
 @end tex\n\
 @ifnottex\n\
 @c Set example in small font to prevent overfull line\n\
 \n\
 @smallexample\n\
 @group\n\
-   N                   M\n\
-  SUM a(k+1) y(n-k) = SUM b(k+1) x(n-k)      for 1<=n<=length(x)\n\
-  k=0                 k=0\n\
+ N                   M\n\
+SUM a(k+1) y(n-k) = SUM b(k+1) x(n-k)    for 1<=n<=length(x)\n\
+k=0                 k=0\n\
 @end group\n\
 @end smallexample\n\
 \n\
 @end ifnottex\n\
 \n\
 @noindent\n\
 where\n\
 @ifnottex\n\
@@ -328,19 +328,19 @@ y_n = -\\sum_{k=1}^N c_{k+1} y_{n-k} + \
  1 \\le n \\le P\n\
 $$\n\
 @end tex\n\
 @ifnottex\n\
 @c Set example in small font to prevent overfull line\n\
 \n\
 @smallexample\n\
 @group\n\
-            N                   M\n\
-  y(n) = - SUM c(k+1) y(n-k) + SUM d(k+1) x(n-k)  for 1<=n<=length(x)\n\
-           k=1                 k=0\n\
+          N                   M\n\
+y(n) = - SUM c(k+1) y(n-k) + SUM d(k+1) x(n-k)  for 1<=n<=length(x)\n\
+         k=1                 k=0\n\
 @end group\n\
 @end smallexample\n\
 \n\
 @end ifnottex\n\
 \n\
 @noindent\n\
 where\n\
 @ifnottex\n\
@@ -365,23 +365,23 @@ system function:\n\
 H(z) = {\\displaystyle\\sum_{k=0}^M d_{k+1} z^{-k}\n\
         \\over 1 + \\displaystyle\\sum_{k+1}^N c_{k+1} z^{-k}}\n\
 $$\n\
 @end tex\n\
 @ifnottex\n\
 \n\
 @example\n\
 @group\n\
-             M\n\
-            SUM d(k+1) z^(-k)\n\
-            k=0\n\
-  H(z) = ----------------------\n\
-               N\n\
-          1 + SUM c(k+1) z^(-k)\n\
-              k=1\n\
+          M\n\
+         SUM d(k+1) z^(-k)\n\
+         k=0\n\
+H(z) = ---------------------\n\
+            N\n\
+       1 + SUM c(k+1) z^(-k)\n\
+           k=1\n\
 @end group\n\
 @end example\n\
 \n\
 @end ifnottex\n\
 @seealso{filter2, fftfilt, freqz}\n\
 @end deftypefn")
 {
   octave_value_list retval;
diff --git a/src/DLD-FUNCTIONS/find.cc b/src/DLD-FUNCTIONS/find.cc
--- a/src/DLD-FUNCTIONS/find.cc
+++ b/src/DLD-FUNCTIONS/find.cc
@@ -342,40 +342,40 @@ DEFUN_DLD (find, args, nargout,
 Return a vector of indices of nonzero elements of a matrix, as a row if\n\
 @var{x} is a row vector or as a column otherwise.  To obtain a single index\n\
 for each matrix element, Octave pretends that the columns of a matrix form\n\
 one long vector (like Fortran arrays are stored).  For example:\n\
 \n\
 @example\n\
 @group\n\
 find (eye (2))\n\
-     @result{} [ 1; 4 ]\n\
+  @result{} [ 1; 4 ]\n\
 @end group\n\
 @end example\n\
 \n\
 If two outputs are requested, @code{find} returns the row and column\n\
 indices of nonzero elements of a matrix.  For example:\n\
 \n\
 @example\n\
 @group\n\
 [i, j] = find (2 * eye (2))\n\
-     @result{} i = [ 1; 2 ]\n\
-     @result{} j = [ 1; 2 ]\n\
+    @result{} i = [ 1; 2 ]\n\
+    @result{} j = [ 1; 2 ]\n\
 @end group\n\
 @end example\n\
 \n\
 If three outputs are requested, @code{find} also returns a vector\n\
 containing the nonzero values.  For example:\n\
 \n\
 @example\n\
 @group\n\
 [i, j, v] = find (3 * eye (2))\n\
-     @result{} i = [ 1; 2 ]\n\
-     @result{} j = [ 1; 2 ]\n\
-     @result{} v = [ 3; 3 ]\n\
+       @result{} i = [ 1; 2 ]\n\
+       @result{} j = [ 1; 2 ]\n\
+       @result{} v = [ 3; 3 ]\n\
 @end group\n\
 @end example\n\
 \n\
 If two inputs are given, @var{n} indicates the maximum number of\n\
 elements to find from the beginning of the matrix or vector.\n\
 \n\
 If three inputs are given, @var{direction} should be one of \"first\" or\n\
 \"last\", requesting only the first or last @var{n} indices, respectively.\n\
diff --git a/src/DLD-FUNCTIONS/gammainc.cc b/src/DLD-FUNCTIONS/gammainc.cc
--- a/src/DLD-FUNCTIONS/gammainc.cc
+++ b/src/DLD-FUNCTIONS/gammainc.cc
@@ -45,18 +45,18 @@ Compute the normalized incomplete gamma 
 @end tex\n\
 @ifnottex\n\
 \n\
 @example\n\
 @group\n\
                                  x\n\
                        1        /\n\
 gammainc (x, a) = ---------    | exp (-t) t^(a-1) dt\n\
-                   gamma (a)    /\n\
-                             t=0\n\
+                  gamma (a)    /\n\
+                            t=0\n\
 @end group\n\
 @end example\n\
 \n\
 @end ifnottex\n\
 with the limiting value of 1 as @var{x} approaches infinity.\n\
 The standard notation is @math{P(a,x)}, e.g., Abramowitz and Stegun (6.5.1).\n\
 \n\
 If @var{a} is scalar, then @code{gammainc (@var{x}, @var{a})} is returned\n\
diff --git a/src/DLD-FUNCTIONS/gcd.cc b/src/DLD-FUNCTIONS/gcd.cc
--- a/src/DLD-FUNCTIONS/gcd.cc
+++ b/src/DLD-FUNCTIONS/gcd.cc
@@ -438,25 +438,24 @@ DEFUN_DLD (gcd, args, nargout,
 @deftypefnx {Loadable Function} {[@var{g}, @var{v1}, @dots{}] =} gcd (@var{a1}, @var{a2}, @dots{})\n\
 \n\
 Compute the greatest common divisor of @var{a1}, @var{a2}, @dots{}.  If more\n\
 than one argument is given all arguments must be the same size or scalar.\n\
 In this case the greatest common divisor is calculated for each element\n\
 individually.  All elements must be ordinary or Gaussian (complex)\n\
 integers.  Note that for Gaussian integers, the gcd is not unique up to\n\
 units (multiplication by 1, -1, @var{i} or -@var{i}), so an arbitrary\n\
-greatest common divisor amongst four possible is returned.  For example,\n\
+greatest common divisor amongst four possible is returned.\n\
 \n\
-@noindent\n\
-and\n\
+Example code:\n\
 \n\
 @example\n\
 @group\n\
 gcd ([15, 9], [20, 18])\n\
-    @result{}  5  9\n\
+   @result{}  5  9\n\
 @end group\n\
 @end example\n\
 \n\
 Optional return arguments @var{v1}, etc., contain integer vectors such\n\
 that,\n\
 \n\
 @tex\n\
 $g = v_1 a_1 + v_2 a_2 + \\cdots$\n\
diff --git a/src/DLD-FUNCTIONS/givens.cc b/src/DLD-FUNCTIONS/givens.cc
--- a/src/DLD-FUNCTIONS/givens.cc
+++ b/src/DLD-FUNCTIONS/givens.cc
@@ -51,18 +51,18 @@ Return a 2 by 2 orthogonal matrix\n\
 @code{@var{g} [@var{x}; @var{y}] = [*; 0]} with @var{x} and @var{y} scalars.\n\
 @end ifnottex\n\
 \n\
 For example:\n\
 \n\
 @example\n\
 @group\n\
 givens (1, 1)\n\
-     @result{}   0.70711   0.70711\n\
-         -0.70711   0.70711\n\
+   @result{}   0.70711   0.70711\n\
+       -0.70711   0.70711\n\
 @end group\n\
 @end example\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
diff --git a/src/DLD-FUNCTIONS/hex2num.cc b/src/DLD-FUNCTIONS/hex2num.cc
--- a/src/DLD-FUNCTIONS/hex2num.cc
+++ b/src/DLD-FUNCTIONS/hex2num.cc
@@ -39,18 +39,18 @@ Typecast the 16 character hexadecimal ch
 double precision number.  If fewer than 16 characters are given the\n\
 strings are right padded with '0' characters.\n\
 \n\
 Given a string matrix, @code{hex2num} treats each row as a separate\n\
 number.\n\
 \n\
 @example\n\
 @group\n\
-hex2num ([\"4005bf0a8b145769\";\"4024000000000000\"])\n\
-@result{} [2.7183; 10.000]\n\
+hex2num ([\"4005bf0a8b145769\"; \"4024000000000000\"])\n\
+   @result{} [2.7183; 10.000]\n\
 @end group\n\
 @end example\n\
 @seealso{num2hex, hex2dec, dec2hex}\n\
 @end deftypefn")
 {
   int nargin = args.length ();
   octave_value retval;
 
@@ -125,17 +125,17 @@ hex2num ([\"4005bf0a8b145769\";\"4024000
 DEFUN_DLD (num2hex, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{s} =} num2hex (@var{n})\n\
 Typecast a double precision number or vector to a 16 character hexadecimal\n\
 string of the IEEE 754 representation of the number.  For example:\n\
 \n\
 @example\n\
 @group\n\
-num2hex ([-1, 1, e, Inf, NaN, NA]);\n\
+num2hex ([-1, 1, e, Inf, NaN, NA])\n\
 @result{} \"bff0000000000000\n\
     3ff0000000000000\n\
     4005bf0a8b145769\n\
     7ff0000000000000\n\
     fff8000000000000\n\
     7ff00000000007a2\"\n\
 @end group\n\
 @end example\n\
diff --git a/src/DLD-FUNCTIONS/kron.cc b/src/DLD-FUNCTIONS/kron.cc
--- a/src/DLD-FUNCTIONS/kron.cc
+++ b/src/DLD-FUNCTIONS/kron.cc
@@ -240,27 +240,27 @@ dispatch_kron (const octave_value& a, co
 
 DEFUN_DLD (kron, args, , "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {} kron (@var{A}, @var{B})\n\
 @deftypefnx {Loadable Function} {} kron (@var{A1}, @var{A2}, @dots{})\n\
 Form the Kronecker product of two or more matrices, defined block by \n\
 block as\n\
 \n\
 @example\n\
-x = [a(i, j) b]\n\
+x = [ a(i,j)*b ]\n\
 @end example\n\
 \n\
 For example:\n\
 \n\
 @example\n\
 @group\n\
 kron (1:4, ones (3, 1))\n\
-      @result{}  1  2  3  4\n\
-          1  2  3  4\n\
-          1  2  3  4\n\
+     @result{}  1  2  3  4\n\
+         1  2  3  4\n\
+         1  2  3  4\n\
 @end group\n\
 @end example\n\
 \n\
 If there are more than two input arguments @var{A1}, @var{A2}, @dots{}, \n\
 @var{An} the Kronecker product is computed as\n\
 \n\
 @example\n\
 kron (kron (@var{A1}, @var{A2}), @dots{}, @var{An})\n\
diff --git a/src/DLD-FUNCTIONS/lu.cc b/src/DLD-FUNCTIONS/lu.cc
--- a/src/DLD-FUNCTIONS/lu.cc
+++ b/src/DLD-FUNCTIONS/lu.cc
@@ -64,17 +64,17 @@ get_lu_u (const base_lu<MT>& fact)
 DEFUN_DLD (lu, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {[@var{L}, @var{U}] =} lu (@var{A})\n\
 @deftypefnx {Loadable Function} {[@var{L}, @var{U}, @var{P}] =} lu (@var{A})\n\
 @deftypefnx {Loadable Function} {[@var{L}, @var{U}, @var{P}, @var{Q}] =} lu (@var{S})\n\
 @deftypefnx {Loadable Function} {[@var{L}, @var{U}, @var{P}, @var{Q}, @var{R}] =} lu (@var{S})\n\
 @deftypefnx {Loadable Function} {[@dots{}] =} lu (@var{S}, @var{thres})\n\
 @deftypefnx {Loadable Function} {@var{y} =} lu (@dots{})\n\
-@deftypefnx {Loadable Function} {[@dots{}] =} lu (@dots{}, 'vector')\n\
+@deftypefnx {Loadable Function} {[@dots{}] =} lu (@dots{}, \"vector\")\n\
 @cindex LU decomposition\n\
 Compute the LU@tie{}decomposition of @var{A}.  If @var{A} is full\n\
 subroutines from\n\
 @sc{lapack} are used and if @var{A} is sparse then @sc{umfpack} is used.  The\n\
 result is returned in a permuted form, according to the optional return\n\
 value @var{P}.  For example, given the matrix @code{a = [1, 2; 3, 4]},\n\
 \n\
 @example\n\
@@ -120,17 +120,17 @@ This typically leads to a sparser and mo
 An additional input argument @var{thres}, that defines the pivoting\n\
 threshold can be given.  @var{thres} can be a scalar, in which case\n\
 it defines the @sc{umfpack} pivoting tolerance for both symmetric and\n\
 unsymmetric cases.  If @var{thres} is a 2-element vector, then the first\n\
 element defines the pivoting tolerance for the unsymmetric @sc{umfpack}\n\
 pivoting strategy and the second for the symmetric strategy.  By default,\n\
 the values defined by @code{spparms} are used ([0.1, 0.001]).\n\
 \n\
-Given the string argument 'vector', @code{lu} returns the values of @var{P}\n\
+Given the string argument \"vector\", @code{lu} returns the values of @var{P}\n\
 and @var{Q} as vector values, such that for full matrix, @code{@var{A}\n\
 (@var{P},:) = @var{L} * @var{U}}, and @code{@var{R}(@var{P},:) * @var{A}\n\
 (:, @var{Q}) = @var{L} * @var{U}}.\n\
 \n\
 With two output arguments, returns the permuted forms of the upper and\n\
 lower triangular matrices, such that @code{@var{A} = @var{L} * @var{U}}.\n\
 With one output argument @var{y}, then the matrix returned by the @sc{lapack}\n\
 routines is returned.  If the input matrix is sparse then the matrix @var{L}\n\
@@ -607,32 +607,32 @@ column vectors (rank-1 update) or matric
 (rank-k update).\n\
 Optionally, row-pivoted updating can be used by supplying\n\
 a row permutation (pivoting) matrix @var{P};\n\
 in that case, an updated permutation matrix is returned.\n\
 Note that if @var{L}, @var{U}, @var{P} is a pivoted LU@tie{}factorization\n\
 as obtained by @code{lu}:\n\
 \n\
 @example\n\
-  [@var{L}, @var{U}, @var{P}] = lu (@var{A});\n\
+[@var{L}, @var{U}, @var{P}] = lu (@var{A});\n\
 @end example\n\
 \n\
 @noindent\n\
 then a factorization of @xcode{@var{A}+@var{x}*@var{y}.'} can be obtained\n\
 either as\n\
 \n\
 @example\n\
-  [@var{L1}, @var{U1}] = lu (@var{L}, @var{U}, @var{P}*@var{x}, @var{y})\n\
+[@var{L1}, @var{U1}] = lu (@var{L}, @var{U}, @var{P}*@var{x}, @var{y})\n\
 @end example\n\
 \n\
 @noindent\n\
 or\n\
 \n\
 @example\n\
-  [@var{L1}, @var{U1}, @var{P1}] = lu (@var{L}, @var{U}, @var{P}, @var{x}, @var{y})\n\
+[@var{L1}, @var{U1}, @var{P1}] = lu (@var{L}, @var{U}, @var{P}, @var{x}, @var{y})\n\
 @end example\n\
 \n\
 The first form uses the unpivoted algorithm, which is faster, but less\n\
 stable.  The second form uses a slower pivoted algorithm, which is more\n\
 stable.\n\
 \n\
 The matrix case is done as a sequence of rank-1 updates;\n\
 thus, for large enough k, it will be both faster and more accurate to\n\
diff --git a/src/DLD-FUNCTIONS/luinc.cc b/src/DLD-FUNCTIONS/luinc.cc
--- a/src/DLD-FUNCTIONS/luinc.cc
+++ b/src/DLD-FUNCTIONS/luinc.cc
@@ -86,17 +86,17 @@ factors.  The default is @code{false}.\n
 @item thresh\n\
 Defines the pivot threshold in the interval [0,1].  Values outside that\n\
 range are ignored.\n\
 @end table\n\
 \n\
 All other fields in @var{opts} are ignored.  The outputs from @code{luinc}\n\
 are the same as for @code{lu}.\n\
 \n\
-Given the string argument 'vector', @code{luinc} returns the values of\n\
+Given the string argument \"vector\", @code{luinc} returns the values of\n\
 @var{p} @var{q} as vector values.\n\
 @seealso{sparse, lu}\n\
 @end deftypefn")
 {
   int nargin = args.length ();
   octave_value_list retval;
 
   if (nargin == 0)
diff --git a/src/DLD-FUNCTIONS/matrix_type.cc b/src/DLD-FUNCTIONS/matrix_type.cc
--- a/src/DLD-FUNCTIONS/matrix_type.cc
+++ b/src/DLD-FUNCTIONS/matrix_type.cc
@@ -34,69 +34,69 @@ along with Octave; see the file COPYING.
 #include "ov-re-sparse.h"
 #include "ov-cx-sparse.h"
 #include "MatrixType.h"
 #include "oct-locbuf.h"
 
 DEFUN_DLD (matrix_type, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {@var{type} =} matrix_type (@var{A})\n\
-@deftypefnx {Loadable Function} {@var{type} =} matrix_type (@var{A}, 'nocompute')\n\
+@deftypefnx {Loadable Function} {@var{type} =} matrix_type (@var{A}, \"nocompute\")\n\
 @deftypefnx {Loadable Function} {@var{A} =} matrix_type (@var{A}, @var{type})\n\
-@deftypefnx {Loadable Function} {@var{A} =} matrix_type (@var{A}, 'upper', @var{perm})\n\
-@deftypefnx {Loadable Function} {@var{A} =} matrix_type (@var{A}, 'lower', @var{perm})\n\
-@deftypefnx {Loadable Function} {@var{A} =} matrix_type (@var{A}, 'banded', @var{nl}, @var{nu})\n\
+@deftypefnx {Loadable Function} {@var{A} =} matrix_type (@var{A}, \"upper\", @var{perm})\n\
+@deftypefnx {Loadable Function} {@var{A} =} matrix_type (@var{A}, \"lower\", @var{perm})\n\
+@deftypefnx {Loadable Function} {@var{A} =} matrix_type (@var{A}, \"banded\", @var{nl}, @var{nu})\n\
 Identify the matrix type or mark a matrix as a particular type.  This allows\n\
 more rapid solutions of linear equations involving @var{A} to be performed.\n\
 Called with a single argument, @code{matrix_type} returns the type of the\n\
 matrix and caches it for future use.  Called with more than one argument,\n\
 @code{matrix_type} allows the type of the matrix to be defined.\n\
 \n\
-If the option 'nocompute' is given, the function will not attempt to guess\n\
+If the option \"nocompute\" is given, the function will not attempt to guess\n\
 the type if it is still unknown.  This is useful for debugging purposes.\n\
 \n\
 The possible matrix types depend on whether the matrix is full or sparse, and\n\
 can be one of the following\n\
 \n\
 @table @asis\n\
-@item 'unknown'\n\
+@item \"unknown\"\n\
 Remove any previously cached matrix type, and mark type as unknown.\n\
 \n\
-@item 'full'\n\
+@item \"full\"\n\
 Mark the matrix as full.\n\
 \n\
-@item 'positive definite'\n\
+@item \"positive definite\"\n\
 Probable full positive definite matrix.\n\
 \n\
-@item 'diagonal'\n\
+@item \"diagonal\"\n\
 Diagonal matrix.  (Sparse matrices only)\n\
 \n\
-@item 'permuted diagonal'\n\
+@item \"permuted diagonal\"\n\
 Permuted Diagonal matrix.  The permutation does not need to be specifically\n\
 indicated, as the structure of the matrix explicitly gives this.  (Sparse\n\
 matrices only)\n\
 \n\
-@item 'upper'\n\
+@item \"upper\"\n\
 Upper triangular.  If the optional third argument @var{perm} is given, the\n\
 matrix is assumed to be a permuted upper triangular with the permutations\n\
 defined by the vector @var{perm}.\n\
 \n\
-@item 'lower'\n\
+@item \"lower\"\n\
 Lower triangular.  If the optional third argument @var{perm} is given, the\n\
 matrix is assumed to be a permuted lower triangular with the permutations\n\
 defined by the vector @var{perm}.\n\
 \n\
-@item 'banded'\n\
-@itemx 'banded positive definite'\n\
+@item \"banded\"\n\
+@itemx \"banded positive definite\"\n\
 Banded matrix with the band size of @var{nl} below the diagonal and @var{nu}\n\
 above it.  If @var{nl} and @var{nu} are 1, then the matrix is tridiagonal and\n\
 treated with specialized code.  In addition the matrix can be marked as\n\
 probably a positive definite.  (Sparse matrices only)\n\
 \n\
-@item 'singular'\n\
+@item \"singular\"\n\
 The matrix is assumed to be singular and will be treated with a minimum norm\n\
 solution.\n\
 \n\
 @end table\n\
 \n\
 Note that the matrix type will be discovered automatically on the first\n\
 attempt to solve a linear equation involving @var{A}.  Therefore\n\
 @code{matrix_type} is only useful to give Octave hints of the matrix type.\n\
diff --git a/src/DLD-FUNCTIONS/max.cc b/src/DLD-FUNCTIONS/max.cc
--- a/src/DLD-FUNCTIONS/max.cc
+++ b/src/DLD-FUNCTIONS/max.cc
@@ -571,17 +571,17 @@ DEFUN_DLD (cummin, args, nargout,
 @deftypefnx {Loadable Function} {} cummin (@var{x}, @var{dim})\n\
 @deftypefnx {Loadable Function} {[@var{w}, @var{iw}] =} cummin (@var{x})\n\
 Return the cumulative minimum values along dimension @var{dim}.  If @var{dim}\n\
 is unspecified it defaults to column-wise operation.  For example:\n\
 \n\
 @example\n\
 @group\n\
 cummin ([5 4 6 2 3 1])\n\
-    @result{}  5  4  4  2  2  1\n\
+   @result{}  5  4  4  2  2  1\n\
 @end group\n\
 @end example\n\
 \n\
 \n\
 The call\n\
 \n\
 @example\n\
   [w, iw] = cummin (x)\n\
@@ -613,17 +613,17 @@ DEFUN_DLD (cummax, args, nargout,
 @deftypefnx {Loadable Function} {} cummax (@var{x}, @var{dim})\n\
 @deftypefnx {Loadable Function} {[@var{w}, @var{iw}] =} cummax (@var{x})\n\
 Return the cumulative maximum values along dimension @var{dim}.  If @var{dim}\n\
 is unspecified it defaults to column-wise operation.  For example:\n\
 \n\
 @example\n\
 @group\n\
 cummax ([1 3 2 6 4 5])\n\
-    @result{}  1  3  3  6  6  6\n\
+   @result{}  1  3  3  6  6  6\n\
 @end group\n\
 @end example\n\
 \n\
 The call\n\
 \n\
 @example\n\
 [w, iw] = cummax (x, dim)\n\
 @end example\n\
diff --git a/src/DLD-FUNCTIONS/nproc.cc b/src/DLD-FUNCTIONS/nproc.cc
--- a/src/DLD-FUNCTIONS/nproc.cc
+++ b/src/DLD-FUNCTIONS/nproc.cc
@@ -30,16 +30,17 @@ along with Octave; see the file COPYING.
 DEFUN_DLD (nproc, args, nargout,
    "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {} nproc ()\n\
 @deftypefnx {Loadable Function} {} nproc (@var{query})\n\
 Return the current number of available processors.\n\
 \n\
 If called with the optional argument @var{query}, modify how processors\n\
 are counted as follows:\n\
+\n\
 @table @code\n\
 @item all\n\
 total number of processors.\n\
 \n\
 @item current\n\
 processors available to the current process.\n\
 \n\
 @item overridable\n\
diff --git a/src/DLD-FUNCTIONS/oct-qhull.h b/src/DLD-FUNCTIONS/oct-qhull.h
--- a/src/DLD-FUNCTIONS/oct-qhull.h
+++ b/src/DLD-FUNCTIONS/oct-qhull.h
@@ -22,17 +22,23 @@ along with Octave; see the file COPYING.
 
 #if !defined (octave_oct_qhull_h)
 #define octave_oct_qhull_h 1
 
 #include <cstdio>
 
 extern "C" {
 
-#if defined (HAVE_QHULL_LIBQHULL_H) || defined (HAVE_QHULL_QHULL_H)
+#if defined (HAVE_LIBQHULL_LIBQHULL_H)
+# include <libqhull/libqhull.h>
+# include <libqhull/qset.h>
+# include <libqhull/geom.h>
+# include <libqhull/poly.h>
+# include <libqhull/io.h>
+#elif defined (HAVE_QHULL_LIBQHULL_H) || defined (HAVE_QHULL_QHULL_H)
 # if defined (HAVE_QHULL_LIBQHULL_H)
 #  include <qhull/libqhull.h>
 # else
 #  include <qhull/qhull.h>
 # endif
 # include <qhull/qset.h>
 # include <qhull/geom.h>
 # include <qhull/poly.h>
diff --git a/src/DLD-FUNCTIONS/qr.cc b/src/DLD-FUNCTIONS/qr.cc
--- a/src/DLD-FUNCTIONS/qr.cc
+++ b/src/DLD-FUNCTIONS/qr.cc
@@ -108,17 +108,17 @@ squares problems\n\
 @tex\n\
 $$\n\
 \\min_x \\left\\Vert A x - b \\right\\Vert_2\n\
 $$\n\
 @end tex\n\
 @ifnottex\n\
 \n\
 @example\n\
-@code{min norm(A x - b)}\n\
+min norm(A x - b)\n\
 @end example\n\
 \n\
 @end ifnottex\n\
 for overdetermined systems of equations (i.e.,\n\
 @tex\n\
 $A$\n\
 @end tex\n\
 @ifnottex\n\
diff --git a/src/DLD-FUNCTIONS/quadcc.cc b/src/DLD-FUNCTIONS/quadcc.cc
--- a/src/DLD-FUNCTIONS/quadcc.cc
+++ b/src/DLD-FUNCTIONS/quadcc.cc
@@ -1480,17 +1480,17 @@ using the doubly-adaptive Clenshaw-Curti
 in @cite{Increasing the Reliability of Adaptive Quadrature Using Explicit\n\
 Interpolants}.\n\
 @var{f} is a function handle, inline function, or string\n\
 containing the name of the function to evaluate.\n\
 The function @var{f} must be vectorized and must return a vector of output\n\
 values if given a vector of input values.  For example,\n\
 \n\
 @example\n\
-   f = @@(x) x .* sin (1./x) .* sqrt (abs (1 - x));\n\
+f = @@(x) x .* sin (1./x) .* sqrt (abs (1 - x));\n\
 @end example\n\
 \n\
 @noindent\n\
 which uses the element-by-element `dot' form for all operators.\n\
 \n\
 @var{a} and @var{b} are the lower and upper limits of integration.  Either\n\
 or both limits may be infinite.  @code{quadcc} handles an inifinite limit\n\
 by substituting the variable of integration with @code{x=tan(pi/2*u)}.\n\
@@ -1500,17 +1500,17 @@ the integration procedure.  The default 
 \n\
 The optional argument @var{sing} contains a list of points where the\n\
 integrand has known singularities, or discontinuities\n\
 in any of its derivatives, inside the integration interval.\n\
 For the example above, which has a discontinuity at x=1, the call to\n\
 @code{quadcc} would be as follows\n\
 \n\
 @example\n\
-   int = quadcc (f, a, b, 1.0e-6, [ 1 ]);\n\
+int = quadcc (f, a, b, 1.0e-6, [ 1 ]);\n\
 @end example\n\
 \n\
 The result of the integration is returned in @var{q}.\n\
 @var{err} is an estimate of the absolute integration error and\n\
 @var{nr_points} is the number of points at which the integrand was evaluated.\n\
 If the adaptive integration did not converge, the value of\n\
 @var{err} will be larger than the requested tolerance.  Therefore, it is\n\
 recommended to verify this value for difficult integrands.\n\
diff --git a/src/DLD-FUNCTIONS/qz.cc b/src/DLD-FUNCTIONS/qz.cc
--- a/src/DLD-FUNCTIONS/qz.cc
+++ b/src/DLD-FUNCTIONS/qz.cc
@@ -317,19 +317,19 @@ generalized eigenvalues of @math{(A - s 
 $$ W^T A = { \\rm diag }(\\lambda)W^T B $$\n\
 $$ AA = Q^T AZ, BB = Q^T BZ $$\n\
 @end tex\n\
 @ifnottex\n\
 \n\
 @example\n\
 @group\n\
 \n\
-    A * V = B * V * diag (@var{lambda})\n\
-    W' * A = diag (@var{lambda}) * W' * B\n\
-    AA = Q * A * Z, BB = Q * B * Z\n\
+A * V = B * V * diag (@var{lambda})\n\
+W' * A = diag (@var{lambda}) * W' * B\n\
+AA = Q * A * Z, BB = Q * B * Z\n\
 \n\
 @end group\n\
 @end example\n\
 \n\
 @end ifnottex\n\
 with @var{Q} and @var{Z} orthogonal (unitary)= @var{I}\n\
 \n\
 @item @code{[AA,BB,Z@{, @var{lambda}@}] = qz (@var{A}, @var{B}, @var{opt})}\n\
@@ -339,16 +339,17 @@ for (e.g.) solution of discrete time alg
 Form 3 is not available for complex matrices, and does not compute\n\
 the generalized eigenvectors @var{V}, @var{W}, nor the orthogonal matrix\n\
 @var{Q}.\n\
 \n\
 @table @var\n\
 @item opt\n\
 for ordering eigenvalues of the GEP pencil.  The leading block\n\
 of the revised pencil contains all eigenvalues that satisfy:\n\
+\n\
 @table @asis\n\
 @item \"N\"\n\
 = unordered (default)\n\
 \n\
 @item \"S\"\n\
 = small: leading block has all |lambda| @leq{} 1\n\
 \n\
 @item \"B\"\n\
diff --git a/src/DLD-FUNCTIONS/regexp.cc b/src/DLD-FUNCTIONS/regexp.cc
--- a/src/DLD-FUNCTIONS/regexp.cc
+++ b/src/DLD-FUNCTIONS/regexp.cc
@@ -452,16 +452,17 @@ The matched pattern @var{pat} can includ
 operators, including:\n\
 \n\
 @table @code\n\
 @item .\n\
 Match any character\n\
 \n\
 @item * + ? @{@}\n\
 Repetition operators, representing\n\
+\n\
 @table @code\n\
 @item *\n\
 Match zero or more times\n\
 \n\
 @item +\n\
 Match one or more times\n\
 \n\
 @item ?\n\
@@ -1073,17 +1074,17 @@ Replace occurrences of pattern @var{pat}
 \n\
 The pattern is a regular expression as documented for @code{regexp}.\n\
 @xref{doc-regexp,,regexp}.\n\
 \n\
 The replacement string may contain @code{$i}, which substitutes\n\
 for the ith set of parentheses in the match string.  For example,\n\
 \n\
 @example\n\
-regexprep(\"Bill Dunn\",'(\\w+) (\\w+)','$2, $1')\n\
+regexprep (\"Bill Dunn\", '(\\w+) (\\w+)', '$2, $1')\n\
 @end example\n\
 \n\
 @noindent\n\
 returns \"Dunn, Bill\"\n\
 \n\
 Options in addition to those of @code{regexp} are\n\
 \n\
 @table @samp\n\
diff --git a/src/DLD-FUNCTIONS/spparms.cc b/src/DLD-FUNCTIONS/spparms.cc
--- a/src/DLD-FUNCTIONS/spparms.cc
+++ b/src/DLD-FUNCTIONS/spparms.cc
@@ -35,18 +35,18 @@ along with Octave; see the file COPYING.
 
 DEFUN_DLD (spparms, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} { } spparms ()\n\
 @deftypefnx {Loadable Function} {@var{vals} =} spparms ()\n\
 @deftypefnx {Loadable Function} {[@var{keys}, @var{vals}] =} spparms ()\n\
 @deftypefnx {Loadable Function} {@var{val} =} spparms (@var{key})\n\
 @deftypefnx {Loadable Function} { } spparms (@var{vals})\n\
-@deftypefnx {Loadable Function} { } spparms ('defaults')\n\
-@deftypefnx {Loadable Function} { } spparms ('tight')\n\
+@deftypefnx {Loadable Function} { } spparms (\"defaults\")\n\
+@deftypefnx {Loadable Function} { } spparms (\"tight\")\n\
 @deftypefnx {Loadable Function} { } spparms (@var{key}, @var{val})\n\
 Query or set the parameters used by the sparse solvers and factorization\n\
 functions.  The first four calls above get information about the current\n\
 settings, while the others change the current settings.  The parameters are\n\
 stored as pairs of keys and values, where the values are all floats and the\n\
 keys are one of the following strings:\n\
 \n\
 @table @samp\n\
@@ -92,19 +92,19 @@ by the @sc{lapack} banded solvers (defau
 @item umfpack\n\
 Flag whether the @sc{umfpack} or mmd solvers are used for the LU, '\\' and\n\
 '/' operations (default 1)\n\
 @end table\n\
 \n\
 The value of individual keys can be set with\n\
 @code{spparms (@var{key}, @var{val})}.\n\
 The default values can be restored with the special keyword\n\
-'defaults'.  The special keyword 'tight' can be used to set the mmd solvers\n\
-to attempt a sparser solution at the potential cost of longer running\n\
-time.\n\
+\"defaults\".  The special keyword \"tight\" can be used to set the mmd\n\
+solvers to attempt a sparser solution at the potential cost of longer\n\
+running time.\n\
 @end deftypefn")
 {
   octave_value_list retval;
   int nargin = args.length ();
 
   if (nargin == 0)
     {
       if (nargout == 0)
diff --git a/src/DLD-FUNCTIONS/strfind.cc b/src/DLD-FUNCTIONS/strfind.cc
--- a/src/DLD-FUNCTIONS/strfind.cc
+++ b/src/DLD-FUNCTIONS/strfind.cc
@@ -159,17 +159,17 @@ then @var{idx} is a cell array of vector
 above.  Examples:\n\
 \n\
 @example\n\
 @group\n\
 strfind (\"abababa\", \"aba\")\n\
      @result{} [1, 3, 5]\n\
 \n\
 strfind (@{\"abababa\", \"bebebe\", \"ab\"@}, \"aba\")\n\
-     @result{} ans =\n\
+     @result{}\n\
         @{\n\
           [1,1] =\n\
 \n\
              1   3   5\n\
 \n\
           [1,2] = [](1x0)\n\
           [1,3] = [](1x0)\n\
         @}\n\
@@ -326,17 +326,17 @@ DEFUN_DLD (strrep, args, ,
 @deftypefn  {Loadable Function} {} strrep (@var{s}, @var{ptn}, @var{rep})\n\
 @deftypefnx {Loadable Function} {} strrep (@var{s}, @var{ptn}, @var{rep}, \"overlaps\", @var{o})\n\
 Replace all occurrences of the substring @var{ptn} in the string @var{s}\n\
 with the string @var{rep} and return the result.  For example:\n\
 \n\
 @example\n\
 @group\n\
 strrep (\"This is a test string\", \"is\", \"&%$\")\n\
-     @result{} \"Th&%$ &%$ a test string\"\n\
+    @result{}  \"Th&%$ &%$ a test string\"\n\
 @end group\n\
 @end example\n\
 \n\
 @var{s} may also be a cell array of strings, in which case the replacement is\n\
 done for each element and a cell array is returned.\n\
 @seealso{regexprep, strfind, findstr}\n\
 @end deftypefn")
 {
diff --git a/src/DLD-FUNCTIONS/sub2ind.cc b/src/DLD-FUNCTIONS/sub2ind.cc
--- a/src/DLD-FUNCTIONS/sub2ind.cc
+++ b/src/DLD-FUNCTIONS/sub2ind.cc
@@ -177,18 +177,18 @@ Convert a linear index to subscripts.\n\
 \n\
 The following example shows how to convert the linear index @code{8}\n\
 in a 3-by-3 matrix into a subscript.  The matrix is linearly indexed\n\
 moving from one column to next, filling up all rows in each column.\n\
 \n\
 @example\n\
 @group\n\
 [r, c] = ind2sub ([3, 3], 8)\n\
-@result{} r =  2\n\
-   c =  3\n\
+    @result{} r =  2\n\
+    @result{} c =  3\n\
 @end group\n\
 @end example\n\
 @seealso{sub2ind}\n\
 @end deftypefn")
 {
   int nargin = args.length ();
   octave_value_list retval;
 
diff --git a/src/DLD-FUNCTIONS/syl.cc b/src/DLD-FUNCTIONS/syl.cc
--- a/src/DLD-FUNCTIONS/syl.cc
+++ b/src/DLD-FUNCTIONS/syl.cc
@@ -48,17 +48,17 @@ A X + X B + C = 0\n\
 @end example\n\
 \n\
 @end ifnottex\n\
 using standard @sc{lapack} subroutines.  For example:\n\
 \n\
 @example\n\
 @group\n\
 syl ([1, 2; 3, 4], [5, 6; 7, 8], [9, 10; 11, 12])\n\
-     @result{} [ -0.50000, -0.66667; -0.66667, -0.50000 ]\n\
+   @result{} [ -0.50000, -0.66667; -0.66667, -0.50000 ]\n\
 @end group\n\
 @end example\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
diff --git a/src/DLD-FUNCTIONS/symrcm.cc b/src/DLD-FUNCTIONS/symrcm.cc
--- a/src/DLD-FUNCTIONS/symrcm.cc
+++ b/src/DLD-FUNCTIONS/symrcm.cc
@@ -417,17 +417,17 @@ transpose (octave_idx_type N, const octa
 // An implementation of the Cuthill-McKee algorithm.
 DEFUN_DLD (symrcm, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{p} =} symrcm (@var{S})\n\
 Return the symmetric reverse Cuthill-McKee permutation of @var{S}.\n\
 @var{p} is a permutation vector such that\n\
 @code{@var{S}(@var{p}, @var{p})} tends to have its diagonal elements\n\
 closer to the diagonal than @var{S}.  This is a good preordering for LU\n\
-or Cholesky@tie{}factorization of matrices that come from 'long, skinny'\n\
+or Cholesky@tie{}factorization of matrices that come from ``long, skinny''\n\
 problems.  It works for both symmetric and asymmetric @var{S}.\n\
 \n\
 The algorithm represents a heuristic approach to the NP-complete\n\
 bandwidth minimization problem.  The implementation is based in the\n\
 descriptions found in\n\
 \n\
 E. Cuthill, J. McKee. @cite{Reducing the Bandwidth of Sparse Symmetric\n\
 Matrices}. Proceedings of the 24th ACM National Conference, 157--172\n\
diff --git a/src/DLD-FUNCTIONS/time.cc b/src/DLD-FUNCTIONS/time.cc
--- a/src/DLD-FUNCTIONS/time.cc
+++ b/src/DLD-FUNCTIONS/time.cc
@@ -144,17 +144,17 @@ gmtime (time ())\n\
            hour = 7\n\
            mday = 17\n\
            mon = 1\n\
            year = 97\n\
            wday = 1\n\
            yday = 47\n\
            isdst = 0\n\
            zone = CST\n\
-         @}\n\
+        @}\n\
 @end group\n\
 @end example\n\
 @seealso{strftime, strptime, localtime, mktime, time, now, date, clock, datenum, datestr, datevec, calendar, weekday}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1)
@@ -208,17 +208,17 @@ localtime (time ())\n\
            hour = 1\n\
            mday = 17\n\
            mon = 1\n\
            year = 97\n\
            wday = 1\n\
            yday = 47\n\
            isdst = 0\n\
            zone = CST\n\
-         @}\n\
+        @}\n\
 @end group\n\
 @end example\n\
 @seealso{strftime, strptime, gmtime, mktime, time, now, date, clock, datenum, datestr, datevec, calendar, weekday}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1)
@@ -324,17 +324,17 @@ Padding is with zeros by default; for fi
 number, padding can be changed or inhibited by following the @samp{%}\n\
 with one of the modifiers described below.  Unknown field specifiers are\n\
 copied as normal characters.  All other characters are copied to the\n\
 output without change.  For example:\n\
 \n\
 @example\n\
 @group\n\
 strftime (\"%r (%Z) %A %e %B %Y\", localtime (time ()))\n\
-     @result{} \"01:15:06 AM (CST) Monday 17 February 1997\"\n\
+      @result{} \"01:15:06 AM (CST) Monday 17 February 1997\"\n\
 @end group\n\
 @end example\n\
 \n\
 Octave's @code{strftime} function supports a superset of the ANSI C\n\
 field specifiers.\n\
 \n\
 @noindent\n\
 Literal character fields:\n\
diff --git a/src/DLD-FUNCTIONS/typecast.cc b/src/DLD-FUNCTIONS/typecast.cc
--- a/src/DLD-FUNCTIONS/typecast.cc
+++ b/src/DLD-FUNCTIONS/typecast.cc
@@ -90,30 +90,30 @@ DEFUN_DLD (typecast, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} typecast (@var{x}, @var{class})\n\
 Return a new array @var{y} resulting from interpreting the data of\n\
 @var{x} in memory as data of the numeric class @var{class}.  Both the class\n\
 of @var{x} and @var{class} must be one of the built-in numeric classes:\n\
 \n\
 @example\n\
 @group\n\
-  \"logical\"\n\
-  \"char\"\n\
-  \"int8\"\n\
-  \"int16\"\n\
-  \"int32\"\n\
-  \"int64\"\n\
-  \"uint8\"\n\
-  \"uint16\"\n\
-  \"uint32\"\n\
-  \"uint64\"\n\
-  \"double\"\n\
-  \"single\"\n\
-  \"double complex\"\n\
-  \"single complex\"\n\
+\"logical\"\n\
+\"char\"\n\
+\"int8\"\n\
+\"int16\"\n\
+\"int32\"\n\
+\"int64\"\n\
+\"uint8\"\n\
+\"uint16\"\n\
+\"uint32\"\n\
+\"uint64\"\n\
+\"double\"\n\
+\"single\"\n\
+\"double complex\"\n\
+\"single complex\"\n\
 @end group\n\
 @end example\n\
 \n\
 @noindent\n\
 the last two are reserved for @var{class}; they indicate that a\n\
 complex-valued result is requested.  Complex arrays are stored in memory as\n\
 consecutive pairs of real numbers.  The sizes of integer types are given by\n\
 their bit counts.  Both logical and char are typically one byte wide;\n\
@@ -124,18 +124,18 @@ the return value is a row vector, otherw
 bit length of @var{x} is not divisible by that of @var{class}, an error\n\
 occurs.\n\
 \n\
 An example of the use of typecast on a little-endian machine is\n\
 \n\
 @example\n\
 @group\n\
 @var{x} = uint16 ([1, 65535]);\n\
-typecast (@var{x}, 'uint8')\n\
-@result{} [   0,   1, 255, 255]\n\
+typecast (@var{x}, \"uint8\")\n\
+  @result{} [   0,   1, 255, 255]\n\
 @end group\n\
 @end example\n\
 @seealso{cast, bitunpack, bitpack, swapbytes}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 2)
@@ -275,27 +275,27 @@ DEFUN_DLD (bitpack, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{y} =} bitpack (@var{x}, @var{class})\n\
 Return a new array @var{y} resulting from interpreting an array\n\
 @var{x} as raw bit patterns for data of the numeric class @var{class}.\n\
 @var{class} must be one of the built-in numeric classes:\n\
 \n\
 @example\n\
 @group\n\
-  \"char\"\n\
-  \"int8\"\n\
-  \"int16\"\n\
-  \"int32\"\n\
-  \"int64\"\n\
-  \"uint8\"\n\
-  \"uint16\"\n\
-  \"uint32\"\n\
-  \"uint64\"\n\
-  \"double\"\n\
-  \"single\"\n\
+\"char\"\n\
+\"int8\"\n\
+\"int16\"\n\
+\"int32\"\n\
+\"int64\"\n\
+\"uint8\"\n\
+\"uint16\"\n\
+\"uint32\"\n\
+\"uint64\"\n\
+\"double\"\n\
+\"single\"\n\
 @end group\n\
 @end example\n\
 \n\
 The number of elements of @var{x} should be divisible by the bit length of\n\
 @var{class}.  If it is not, excess bits are discarded.  Bits come in\n\
 increasing order of significance, i.e., @code{x(1)} is bit 0, @code{x(2)} is\n\
 bit 1, etc.  The result is a row vector if @var{x} is a row vector, otherwise\n\
 it is a column vector.\n\
@@ -383,27 +383,27 @@ do_bitunpack (const ArrayType& array)
 DEFUN_DLD (bitunpack, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{y} =} bitunpack (@var{x})\n\
 Return an array @var{y} corresponding to the raw bit patterns of\n\
 @var{x}.  @var{x} must belong to one of the built-in numeric classes:\n\
 \n\
 @example\n\
 @group\n\
-  \"char\"\n\
-  \"int8\"\n\
-  \"int16\"\n\
-  \"int32\"\n\
-  \"int64\"\n\
-  \"uint8\"\n\
-  \"uint16\"\n\
-  \"uint32\"\n\
-  \"uint64\"\n\
-  \"double\"\n\
-  \"single\"\n\
+\"char\"\n\
+\"int8\"\n\
+\"int16\"\n\
+\"int32\"\n\
+\"int64\"\n\
+\"uint8\"\n\
+\"uint16\"\n\
+\"uint32\"\n\
+\"uint64\"\n\
+\"double\"\n\
+\"single\"\n\
 @end group\n\
 @end example\n\
 \n\
 The result is a row vector if @var{x} is a row vector; otherwise, it is a\n\
 column vector.\n\
 @seealso{bitpack, typecast}\n\
 @end deftypefn")
 {
diff --git a/src/DLD-FUNCTIONS/urlwrite.cc b/src/DLD-FUNCTIONS/urlwrite.cc
--- a/src/DLD-FUNCTIONS/urlwrite.cc
+++ b/src/DLD-FUNCTIONS/urlwrite.cc
@@ -871,17 +871,17 @@ s = urlread (\"http://user:password@@exa
 GET and POST requests can be specified by @var{method} and @var{param}.\n\
 The parameter @var{method} is either @samp{get} or @samp{post}\n\
 and @var{param} is a cell array of parameter and value pairs.\n\
 For example:\n\
 \n\
 @example\n\
 @group\n\
 s = urlread (\"http://www.google.com/search\", \"get\",\n\
-             @{\"query\", \"octave\"@});\n\
+            @{\"query\", \"octave\"@});\n\
 @end group\n\
 @end example\n\
 @seealso{urlwrite}\n\
 @end deftypefn")
 {
   // Octave's return value
   octave_value_list retval;
 
diff --git a/src/Makefile.am b/src/Makefile.am
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -279,16 +279,17 @@ octinclude_HEADERS = \
   oct-stdstrm.h \
   oct-stream.h \
   oct-strstrm.h \
   oct.h \
   octave.h \
   ops.h \
   pager.h \
   parse.h \
+  parse-private.h \
   pr-output.h \
   procstream.h \
   profiler.h \
   sighandlers.h \
   siglist.h \
   sparse-xdiv.h \
   sparse-xpow.h \
   symtab.h \
@@ -479,19 +480,21 @@ include DLD-FUNCTIONS/module.mk
 	$(srcdir)/DLD-FUNCTIONS/config-module.sh $(top_srcdir)
 
 include OPERATORS/module.mk
 include TEMPLATE-INST/module.mk
 
 if AMCOND_ENABLE_DYNAMIC_LINKING
   OCT_FILES = $(DLD_FUNCTIONS_LIBS:.la=.oct)
   OCT_STAMP_FILES = $(subst DLD-FUNCTIONS/,DLD-FUNCTIONS/$(am__leading_dot),$(DLD_FUNCTIONS_LIBS:.la=.oct-stamp))
+  DLD_LIBOCTINTERP_LIBADD = liboctinterp.la
 else
   OCT_FILES =
   OCT_STAMP_FILES =
+  DLD_LIBOCTINTERP_LIBADD =
 endif
 
 liboctinterp_la_SOURCES = \
   $(DIST_SRC) \
   $(OPERATORS_SRC) \
   $(TEMPLATE_INST_SRC)
 
 nodist_liboctinterp_la_SOURCES = \
diff --git a/src/data.cc b/src/data.cc
--- a/src/data.cc
+++ b/src/data.cc
@@ -114,17 +114,17 @@ are nonzero.\n\
 \n\
 For a matrix argument, return a row vector of logical ones and\n\
 zeros with each element indicating whether all of the elements of the\n\
 corresponding column of the matrix are nonzero.  For example:\n\
 \n\
 @example\n\
 @group\n\
 all ([2, 3; 1, 0]))\n\
-     @result{} [ 1, 0 ]\n\
+    @result{} [ 1, 0 ]\n\
 @end group\n\
 @end example\n\
 \n\
 If the optional argument @var{dim} is supplied, work along dimension\n\
 @var{dim}.\n\
 @seealso{any}\n\
 @end deftypefn")
 {
@@ -163,27 +163,27 @@ is nonzero.\n\
 \n\
 For a matrix argument, return a row vector of logical ones and\n\
 zeros with each element indicating whether any of the elements of the\n\
 corresponding column of the matrix are nonzero.  For example:\n\
 \n\
 @example\n\
 @group\n\
 any (eye (2, 4))\n\
-     @result{} [ 1, 1, 0, 0 ]\n\
+ @result{} [ 1, 1, 0, 0 ]\n\
 @end group\n\
 @end example\n\
 \n\
 If the optional argument @var{dim} is supplied, work along dimension\n\
 @var{dim}.  For example:\n\
 \n\
 @example\n\
 @group\n\
 any (eye (2, 4), 2)\n\
-     @result{} [ 1; 1 ]\n\
+ @result{} [ 1; 1 ]\n\
 @end group\n\
 @end example\n\
 @seealso{all}\n\
 @end deftypefn")
 {
   ANY_ALL (any);
 }
 
@@ -360,18 +360,18 @@ Compute the element-by-element square ro
 @var{x} and @var{y}.  This is equivalent to\n\
 @code{sqrt (@var{x}.^2 + @var{y}.^2)}, but calculated in a manner that\n\
 avoids overflows for large values of @var{x} or @var{y}.\n\
 @code{hypot} can also be called with more than 2 arguments; in this case,\n\
 the arguments are accumulated from left to right:\n\
 \n\
 @example\n\
 @group\n\
-  hypot (hypot (@var{x}, @var{y}), @var{z})\n\
-  hypot (hypot (hypot (@var{x}, @var{y}), @var{z}), @var{w}), etc.\n\
+hypot (hypot (@var{x}, @var{y}), @var{z})\n\
+hypot (hypot (hypot (@var{x}, @var{y}), @var{z}), @var{w}), etc.\n\
 @end group\n\
 @end example\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
@@ -1088,24 +1088,24 @@ Cumulative product of elements along dim
 %!assert (cumprod (single([2, 3; 4, 5]), 2), single([2, 6; 4, 20]));
 
  */
 
 DEFUN (cumsum, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} cumsum (@var{x})\n\
 @deftypefnx {Built-in Function} {} cumsum (@var{x}, @var{dim})\n\
-@deftypefnx {Built-in Function} {} cumsum (@dots{}, 'native')\n\
-@deftypefnx {Built-in Function} {} cumsum (@dots{}, 'double')\n\
-@deftypefnx {Built-in Function} {} cumsum (@dots{}, 'extra')\n\
+@deftypefnx {Built-in Function} {} cumsum (@dots{}, \"native\")\n\
+@deftypefnx {Built-in Function} {} cumsum (@dots{}, \"double\")\n\
+@deftypefnx {Built-in Function} {} cumsum (@dots{}, \"extra\")\n\
 Cumulative sum of elements along dimension @var{dim}.  If @var{dim}\n\
 is omitted, it defaults to the first non-singleton dimension.\n\
 \n\
-See @code{sum} for an explanation of the optional parameters 'native',\n\
-'double', and 'extra'.\n\
+See @code{sum} for an explanation of the optional parameters \"native\",\n\
+\"double\", and \"extra\".\n\
 @seealso{sum, cumprod}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   bool isnative = false;
@@ -1251,20 +1251,20 @@ Return a diagonal matrix with vector @va
 second argument is optional.  If it is positive, the vector is placed on\n\
 the @var{k}-th super-diagonal.  If it is negative, it is placed on the\n\
 @var{-k}-th sub-diagonal.  The default value of @var{k} is 0, and the\n\
 vector is placed on the main diagonal.  For example:\n\
 \n\
 @example\n\
 @group\n\
 diag ([1, 2, 3], 1)\n\
-     @result{}  0  1  0  0\n\
-         0  0  2  0\n\
-         0  0  0  3\n\
-         0  0  0  0\n\
+   @result{}  0  1  0  0\n\
+       0  0  2  0\n\
+       0  0  0  3\n\
+       0  0  0  0\n\
 @end group\n\
 @end example\n\
 \n\
 @noindent\n\
 The 3-input form returns a diagonal matrix with vector @var{v} on the main\n\
 diagonal and the resulting matrix being of size @var{m} rows x @var{n}\n\
 columns.\n\
 \n\
@@ -1861,17 +1861,17 @@ DEFUN (horzcat, args, ,
 @deftypefn {Built-in Function} {} horzcat (@var{array1}, @var{array2}, @dots{}, @var{arrayN})\n\
 Return the horizontal concatenation of N-D array objects, @var{array1},\n\
 @var{array2}, @dots{}, @var{arrayN} along dimension 2.\n\
 \n\
 Arrays may also be concatenated horizontally using the syntax for creating\n\
 new matrices.  For example:\n\
 \n\
 @example\n\
-@var{hcat} = [ @var{array1}, @var{array2}, @dots{} ];\n\
+@var{hcat} = [ @var{array1}, @var{array2}, @dots{} ]\n\
 @end example\n\
 @seealso{cat, vertcat}\n\
 @end deftypefn")
 {
   return do_cat (args, -2, "horzcat");
 }
 
 /*
@@ -2070,17 +2070,17 @@ DEFUN (vertcat, args, ,
 @deftypefn {Built-in Function} {} vertcat (@var{array1}, @var{array2}, @dots{}, @var{arrayN})\n\
 Return the vertical concatenation of N-D array objects, @var{array1},\n\
 @var{array2}, @dots{}, @var{arrayN} along dimension 1.\n\
 \n\
 Arrays may also be concatenated vertically using the syntax for creating\n\
 new matrices.  For example:\n\
 \n\
 @example\n\
-@var{vcat} = [ @var{array1}; @var{array2}; @dots{} ];\n\
+@var{vcat} = [ @var{array1}; @var{array2}; @dots{} ]\n\
 @end example\n\
 @seealso{cat, horzcat}\n\
 @end deftypefn")
 {
   return do_cat (args, -1, "vertcat");
 }
 
 /*
@@ -2095,47 +2095,46 @@ DEFUN (cat, args, ,
 Return the concatenation of N-D array objects, @var{array1},\n\
 @var{array2}, @dots{}, @var{arrayN} along dimension @var{dim}.\n\
 \n\
 @example\n\
 @group\n\
 A = ones (2, 2);\n\
 B = zeros (2, 2);\n\
 cat (2, A, B)\n\
-    @result{} 1 1 0 0\n\
-       1 1 0 0\n\
+  @result{} 1 1 0 0\n\
+     1 1 0 0\n\
 @end group\n\
 @end example\n\
 \n\
 Alternatively, we can concatenate @var{A} and @var{B} along the\n\
-second dimension the following way:\n\
+second dimension in the following way:\n\
 \n\
 @example\n\
 @group\n\
-[A, B].\n\
+[A, B]\n\
 @end group\n\
 @end example\n\
 \n\
 @var{dim} can be larger than the dimensions of the N-D array objects\n\
 and the result will thus have @var{dim} dimensions as the\n\
 following example shows:\n\
 \n\
 @example\n\
 @group\n\
 cat (4, ones (2, 2), zeros (2, 2))\n\
-    @result{} ans =\n\
-\n\
-       ans(:,:,1,1) =\n\
-\n\
-         1 1\n\
-         1 1\n\
-\n\
-       ans(:,:,1,2) =\n\
-         0 0\n\
-         0 0\n\
+  @result{} ans(:,:,1,1) =\n\
+\n\
+       1 1\n\
+       1 1\n\
+\n\
+     ans(:,:,1,2) =\n\
+\n\
+       0 0\n\
+       0 0\n\
 @end group\n\
 @end example\n\
 @seealso{horzcat, vertcat}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () > 0)
@@ -2381,18 +2380,18 @@ DEFUN (ndims, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} ndims (@var{a})\n\
 Return the number of dimensions of @var{a}.\n\
 For any array, the result will always be larger than or equal to 2.\n\
 Trailing singleton dimensions are not counted.\n\
 \n\
 @example\n\
 @group\n\
-  ndims (ones (4, 1, 2, 1))\n\
-     @result{} 3\n\
+ndims (ones (4, 1, 2, 1))\n\
+    @result{} 3\n\
 @end group\n\
 @end example\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1)
     retval = args(0).ndims ();
@@ -2406,26 +2405,26 @@ DEFUN (numel, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} numel (@var{a})\n\
 @deftypefnx {Built-in Function} {} numel (@var{a}, @var{idx1}, @var{idx2}, @dots{})\n\
 Return the number of elements in the object @var{a}.\n\
 Optionally, if indices @var{idx1}, @var{idx2}, @dots{} are supplied,\n\
 return the number of elements that would result from the indexing\n\
 \n\
 @example\n\
-  @var{a}(@var{idx1}, @var{idx2}, @dots{})\n\
+@var{a}(@var{idx1}, @var{idx2}, @dots{})\n\
 @end example\n\
 \n\
 Note that the indices do not have to be numerical.  For example,\n\
 \n\
 @example\n\
 @group\n\
-  @var{a} = 1;\n\
-  @var{b} = ones (2, 3);\n\
-  numel (@var{a}, @var{b});\n\
+@var{a} = 1;\n\
+@var{b} = ones (2, 3);\n\
+numel (@var{a}, @var{b})\n\
 @end group\n\
 @end example\n\
 \n\
 @noindent\n\
 will return 6, as this is the number of ways to index with @var{b}.\n\
 \n\
 This method is also called when an object appears as lvalue with cs-list\n\
 indexing, i.e., @code{object@{@dots{}@}} or @code{object(@dots{}).field}.\n\
@@ -2458,31 +2457,31 @@ Return the number of rows and columns of
 With one input argument and one output argument, the result is returned\n\
 in a row vector.  If there are multiple output arguments, the number of\n\
 rows is assigned to the first, and the number of columns to the second,\n\
 etc.  For example:\n\
 \n\
 @example\n\
 @group\n\
 size ([1, 2; 3, 4; 5, 6])\n\
-     @result{} [ 3, 2 ]\n\
+   @result{} [ 3, 2 ]\n\
 \n\
 [nr, nc] = size ([1, 2; 3, 4; 5, 6])\n\
-     @result{} nr = 3\n\
-     @result{} nc = 2\n\
+    @result{} nr = 3\n\
+    @result{} nc = 2\n\
 @end group\n\
 @end example\n\
 \n\
 If given a second argument, @code{size} will return the size of the\n\
 corresponding dimension.  For example,\n\
 \n\
 @example\n\
 @group\n\
 size ([1, 2; 3, 4; 5, 6], 2)\n\
-     @result{} 2\n\
+    @result{} 2\n\
 @end group\n\
 @end example\n\
 \n\
 @noindent\n\
 returns the number of columns in the given matrix.\n\
 @seealso{numel}\n\
 @end deftypefn")
 {
@@ -2645,41 +2644,42 @@ Return the number of columns of @var{a}.
 
   return retval;
 }
 
 DEFUN (sum, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} sum (@var{x})\n\
 @deftypefnx {Built-in Function} {} sum (@var{x}, @var{dim})\n\
-@deftypefnx {Built-in Function} {} sum (@dots{}, 'native')\n\
-@deftypefnx {Built-in Function} {} sum (@dots{}, 'double')\n\
-@deftypefnx {Built-in Function} {} sum (@dots{}, 'extra')\n\
+@deftypefnx {Built-in Function} {} sum (@dots{}, \"native\")\n\
+@deftypefnx {Built-in Function} {} sum (@dots{}, \"double\")\n\
+@deftypefnx {Built-in Function} {} sum (@dots{}, \"extra\")\n\
 Sum of elements along dimension @var{dim}.  If @var{dim} is\n\
 omitted, it defaults to the first non-singleton dimension.\n\
 \n\
-If the optional argument 'native' is given, then the sum is performed\n\
+If the optional argument \"native\" is given, then the sum is performed\n\
 in the same type as the original argument, rather than in the default\n\
 double type.  For example:\n\
 \n\
 @example\n\
 @group\n\
 sum ([true, true])\n\
-  @result{} 2\n\
-sum ([true, true], 'native')\n\
-  @result{} true\n\
+   @result{} 2\n\
+sum ([true, true], \"native\")\n\
+   @result{} true\n\
 @end group\n\
 @end example\n\
 \n\
-On the contrary, if 'double' is given, the sum is performed in double\n\
+On the contrary, if \"double\" is given, the sum is performed in double\n\
 precision even for single precision inputs.\n\
 \n\
-For double precision inputs, 'extra' indicates that a more accurate algorithm\n\
-than straightforward summation is to be used.  For single precision inputs,\n\
-'extra' is the same as 'double'.  Otherwise, 'extra' has no effect.\n\
+For double precision inputs, \"extra\" indicates that a more accurate\n\
+algorithm than straightforward summation is to be used.  For single precision\n\
+inputs, \"extra\" is the same as \"double\".  Otherwise, \"extra\" has no\n\
+effect.\n\
 @seealso{cumsum, sumsq, prod}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   bool isnative = false;
@@ -3005,18 +3005,17 @@ Return a complex result from real argume
 return the complex result @code{@var{x} + 0i}.  With 2 real arguments,\n\
 return the complex result @code{@var{re} + @var{im}}.  @code{complex} can\n\
 often be more convenient than expressions such as @code{a + i*b}.\n\
 For example:\n\
 \n\
 @example\n\
 @group\n\
 complex ([1, 2], [3, 4])\n\
-@result{}\n\
-   1 + 3i   2 + 4i\n\
+  @result{} [ 1 + 3i   2 + 4i ]\n\
 @end group\n\
 @end example\n\
 @seealso{real, imag, iscomplex}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
@@ -3939,19 +3938,18 @@ Return a scalar, matrix or N-dimensional
 to the IEEE representation for positive infinity.\n\
 \n\
 Infinity is produced when results are too large to be represented using the\n\
 the IEEE floating point format for numbers.  Two common examples which\n\
 produce infinity are division by zero and overflow.\n\
 \n\
 @example\n\
 @group\n\
-[1/0 e^800]\n\
-@result{}\n\
-Inf   Inf\n\
+[ 1/0 e^800 ]\n\
+@result{} Inf   Inf\n\
 @end group\n\
 @end example\n\
 \n\
 When called with no arguments, return a scalar with the value @samp{Inf}.\n\
 When called with a single argument, return a square matrix with the dimension\n\
 specified.  When called with more than one scalar argument the first two\n\
 arguments are taken as the number of rows and columns and any further\n\
 arguments specify additional matrix dimensions.\n\
@@ -4534,19 +4532,19 @@ return a square @nospell{NxN} identity m
 supplied two scalar arguments (@var{m}, @var{n}), @code{eye} takes them to be\n\
 the number of rows and columns.  If given a vector with two elements,\n\
 @code{eye} uses the values of the elements as the number of rows and columns,\n\
 respectively.  For example:\n\
 \n\
 @example\n\
 @group\n\
 eye (3)\n\
-     @result{}  1  0  0\n\
-         0  1  0\n\
-         0  0  1\n\
+ @result{}  1  0  0\n\
+     0  1  0\n\
+     0  0  1\n\
 @end group\n\
 @end example\n\
 \n\
 The following expressions all produce the same result:\n\
 \n\
 @example\n\
 @group\n\
 eye (2)\n\
@@ -4778,28 +4776,30 @@ Resize @var{x} cutting off elements as n
 \n\
 In the result, element with certain indices is equal to the corresponding\n\
 element of @var{x} if the indices are within the bounds of @var{x};\n\
 otherwise, the element is set to zero.\n\
 \n\
 In other words, the statement\n\
 \n\
 @example\n\
-  y = resize (x, dv);\n\
+y = resize (x, dv)\n\
 @end example\n\
 \n\
 @noindent\n\
 is equivalent to the following code:\n\
 \n\
 @example\n\
 @group\n\
-  y = zeros (dv, class (x));\n\
-  sz = min (dv, size (x));\n\
-  for i = 1:length (sz), idx@{i@} = 1:sz(i); endfor\n\
-  y(idx@{:@}) = x(idx@{:@});\n\
+y = zeros (dv, class (x));\n\
+sz = min (dv, size (x));\n\
+for i = 1:length (sz)\n\
+  idx@{i@} = 1:sz(i);\n\
+endfor\n\
+y(idx@{:@}) = x(idx@{:@});\n\
 @end group\n\
 @end example\n\
 \n\
 @noindent\n\
 but is performed more efficiently.\n\
 \n\
 If only @var{m} is supplied, and it is a scalar, the dimension of the\n\
 result is @var{m}-by-@var{m}.\n\
@@ -4868,18 +4868,18 @@ whose elements are taken from the matrix
 matrix are accessed in column-major order (like Fortran arrays are stored).\n\
 \n\
 The following code demonstrates reshaping a 1x4 row vector into a 2x2 square\n\
 matrix.\n\
 \n\
 @example\n\
 @group\n\
 reshape ([1, 2, 3, 4], 2, 2)\n\
-     @result{}  1  3\n\
-         2  4\n\
+      @result{}  1  3\n\
+          2  4\n\
 @end group\n\
 @end example\n\
 \n\
 @noindent\n\
 Note that the total number of elements in the original\n\
 matrix (@code{prod (size (@var{A}))}) must match the total number of elements\n\
 in the new matrix (@code{prod ([@var{m} @var{n} @dots{}])}).\n\
 \n\
@@ -5431,17 +5431,17 @@ DEFUN (plus, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} plus (@var{x}, @var{y})\n\
 @deftypefnx {Built-in Function} {} plus (@var{x1}, @var{x2}, @dots{})\n\
 This function and @w{@xcode{x + y}} are equivalent.\n\
 If more arguments are given, the summation is applied\n\
 cumulatively from left to right:\n\
 \n\
 @example\n\
-  (@dots{}((x1 + x2) + x3) + @dots{})\n\
+(@dots{}((x1 + x2) + x3) + @dots{})\n\
 @end example\n\
 \n\
 At least one argument is required.\n\
 @seealso{minus}\n\
 @end deftypefn")
 {
   return binary_assoc_op_defun_body (octave_value::op_add,
                                      octave_value::op_add_eq, args);
@@ -5462,17 +5462,17 @@ DEFUN (mtimes, args, ,
 @deftypefn  {Built-in Function} {} mtimes (@var{x}, @var{y})\n\
 @deftypefnx {Built-in Function} {} mtimes (@var{x1}, @var{x2}, @dots{})\n\
 Return the matrix multiplication product of inputs.\n\
 This function and @w{@xcode{x * y}} are equivalent.\n\
 If more arguments are given, the multiplication is applied\n\
 cumulatively from left to right:\n\
 \n\
 @example\n\
-  (@dots{}((x1 * x2) * x3) * @dots{})\n\
+(@dots{}((x1 * x2) * x3) * @dots{})\n\
 @end example\n\
 \n\
 At least one argument is required.\n\
 @seealso{times}\n\
 @end deftypefn")
 {
   return binary_assoc_op_defun_body (octave_value::op_mul,
                                      octave_value::op_mul_eq, args);
@@ -5574,17 +5574,17 @@ DEFUN (times, args, ,
 @deftypefn  {Built-in Function} {} times (@var{x}, @var{y})\n\
 @deftypefnx {Built-in Function} {} times (@var{x1}, @var{x2}, @dots{})\n\
 Return the element-by-element multiplication product of inputs.\n\
 This function and @w{@xcode{x .* y}} are equivalent.\n\
 If more arguments are given, the multiplication is applied\n\
 cumulatively from left to right:\n\
 \n\
 @example\n\
-  (@dots{}((x1 .* x2) .* x3) .* @dots{})\n\
+(@dots{}((x1 .* x2) .* x3) .* @dots{})\n\
 @end example\n\
 \n\
 At least one argument is required.\n\
 @seealso{mtimes}\n\
 @end deftypefn")
 {
   return binary_assoc_op_defun_body (octave_value::op_el_mul,
                                      octave_value::op_el_mul_eq, args);
@@ -5633,17 +5633,17 @@ DEFUN (and, args, ,
 @deftypefn  {Built-in Function} {} and (@var{x}, @var{y})\n\
 @deftypefnx {Built-in Function} {} and (@var{x1}, @var{x2}, @dots{})\n\
 Return the logical AND of @var{x} and @var{y}.\n\
 This function is equivalent to @w{@code{x & y}}.\n\
 If more arguments are given, the logical and is applied\n\
 cumulatively from left to right:\n\
 \n\
 @example\n\
-  (@dots{}((x1 & x2) & x3) & @dots{})\n\
+(@dots{}((x1 & x2) & x3) & @dots{})\n\
 @end example\n\
 \n\
 At least one argument is required.\n\
 @seealso{or, not, xor}\n\
 @end deftypefn")
 {
   return binary_assoc_op_defun_body (octave_value::op_el_and,
                                      octave_value::op_el_and_eq, args);
@@ -5654,17 +5654,17 @@ DEFUN (or, args, ,
 @deftypefn  {Built-in Function} {} or (@var{x}, @var{y})\n\
 @deftypefnx {Built-in Function} {} or (@var{x1}, @var{x2}, @dots{})\n\
 Return the logical OR of @var{x} and @var{y}.\n\
 This function is equivalent to @w{@code{x | y}}.\n\
 If more arguments are given, the logical or is applied\n\
 cumulatively from left to right:\n\
 \n\
 @example\n\
-  (@dots{}((x1 | x2) | x3) | @dots{})\n\
+(@dots{}((x1 | x2) | x3) | @dots{})\n\
 @end example\n\
 \n\
 At least one argument is required.\n\
 @seealso{and, not, xor}\n\
 @end deftypefn")
 {
   return binary_assoc_op_defun_body (octave_value::op_el_or,
                                      octave_value::op_el_or_eq, args);
@@ -5693,17 +5693,17 @@ will set the variable @code{elapsed_time
 the most recent call to the function @code{tic}.\n\
 \n\
 If called with one output argument then this function returns a scalar\n\
 of type @code{uint64} and the wall-clock timer is not started.\n\
 \n\
 @example\n\
 @group\n\
 t = tic; sleep (5); (double (tic ()) - double (t)) * 1e-6\n\
-     @result{} 5\n\
+      @result{} 5\n\
 @end group\n\
 @end example\n\
 \n\
 Nested timing with @code{tic} and @code{toc} is not supported.\n\
 Therefore @code{toc} will always return the elapsed time from the most\n\
 recent call to @code{tic}.\n\
 \n\
 If you are more interested in the CPU time that your process used, you\n\
@@ -5855,55 +5855,55 @@ DEFUN (sort, args, nargout,
 Return a copy of @var{x} with the elements arranged in increasing\n\
 order.  For matrices, @code{sort} orders the elements within columns\n\
 \n\
 For example:\n\
 \n\
 @example\n\
 @group\n\
 sort ([1, 2; 2, 3; 3, 1])\n\
-     @result{}  1  1\n\
-         2  2\n\
-         3  3\n\
+   @result{}  1  1\n\
+       2  2\n\
+       3  3\n\
 @end group\n\
 @end example\n\
 \n\
 If the optional argument @var{dim} is given, then the matrix is sorted\n\
 along the dimension defined by @var{dim}.  The optional argument @code{mode}\n\
 defines the order in which the values will be sorted.  Valid values of\n\
-@code{mode} are `ascend' or `descend'.\n\
+@code{mode} are \"ascend\" or \"descend\".\n\
 \n\
 The @code{sort} function may also be used to produce a matrix\n\
 containing the original row indices of the elements in the sorted\n\
 matrix.  For example:\n\
 \n\
 @example\n\
 @group\n\
 [s, i] = sort ([1, 2; 2, 3; 3, 1])\n\
-     @result{} s = 1  1\n\
-            2  2\n\
-            3  3\n\
-     @result{} i = 1  3\n\
-            2  1\n\
-            3  2\n\
+  @result{} s = 1  1\n\
+         2  2\n\
+         3  3\n\
+  @result{} i = 1  3\n\
+         2  1\n\
+         3  2\n\
 @end group\n\
 @end example\n\
 \n\
 For equal elements, the indices are such that equal elements are listed\n\
 in the order in which they appeared in the original list.\n\
 \n\
 Sorting of complex entries is done first by magnitude (@code{abs (@var{z})})\n\
 and for any ties by phase angle (@code{angle (z)}).  For example:\n\
 \n\
 @example\n\
 @group\n\
 sort ([1+i; 1; 1-i])\n\
-     @result{} 1 + 0i\n\
-        1 - 1i\n\
-        1 + 1i\n\
+    @result{} 1 + 0i\n\
+       1 - 1i\n\
+       1 + 1i\n\
 @end group\n\
 @end example\n\
 \n\
 NaN values are treated as being greater than any other value and are sorted\n\
 to the end of the list.\n\
 \n\
 The @code{sort} function may also be used to sort strings and cell arrays\n\
 of strings, in which case ASCII dictionary order (uppercase 'A' precedes\n\
diff --git a/src/dirfns.cc b/src/dirfns.cc
--- a/src/dirfns.cc
+++ b/src/dirfns.cc
@@ -549,51 +549,52 @@ system-dependent error message.\n\
 DEFUN (glob, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} glob (@var{pattern})\n\
 Given an array of pattern strings (as a char array or a cell array) in\n\
 @var{pattern}, return a cell array of file names that match any of\n\
 them, or an empty cell array if no patterns match.  The pattern strings are\n\
 interpreted as filename globbing patterns (as they are used by Unix shells).\n\
 Within a pattern\n\
+\n\
 @table @code\n\
 @itemx *\n\
 matches any string, including the null string,\n\
 @itemx ?\n\
 matches any single character, and\n\
 \n\
 @item [@dots{}]\n\
 matches any of the enclosed characters.\n\
 @end table\n\
 \n\
 Tilde expansion\n\
 is performed on each of the patterns before looking for matching file\n\
 names.  For example:\n\
 \n\
 @example\n\
 ls\n\
-     @result{}\n\
-        file1  file2  file3  myfile1 myfile1b\n\
+   @result{}\n\
+      file1  file2  file3  myfile1 myfile1b\n\
 glob (\"*file1\")\n\
-     @result{}\n\
-        @{\n\
-          [1,1] = file1\n\
-          [2,1] = myfile1\n\
-        @}\n\
+   @result{}\n\
+      @{\n\
+        [1,1] = file1\n\
+        [2,1] = myfile1\n\
+      @}\n\
 glob (\"myfile?\")\n\
-     @result{}\n\
-        @{\n\
-          [1,1] = myfile1\n\
-        @}\n\
+   @result{}\n\
+      @{\n\
+        [1,1] = myfile1\n\
+      @}\n\
 glob (\"file[12]\")\n\
-     @result{}\n\
-        @{\n\
-          [1,1] = file1\n\
-          [2,1] = file2\n\
-        @}\n\
+   @result{}\n\
+      @{\n\
+        [1,1] = file1\n\
+        [2,1] = file2\n\
+      @}\n\
 @end example\n\
 @seealso{ls, dir, readdir}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1)
     {
@@ -682,20 +683,20 @@ fnmatch (\"a*b\", @{\"ab\"; \"axyzb\"; \
     print_usage ();
 
   return retval;
 }
 
 DEFUN (filesep, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} filesep ()\n\
-@deftypefnx {Built-in Function} {} filesep ('all')\n\
+@deftypefnx {Built-in Function} {} filesep (\"all\")\n\
 Return the system-dependent character used to separate directory names.\n\
 \n\
-If 'all' is given, the function returns all valid file separators in\n\
+If \"all\" is given, the function returns all valid file separators in\n\
 the form of a string.  The list of file separators is system-dependent.\n\
 It is @samp{/} (forward slash) under UNIX or @w{Mac OS X}, @samp{/} and\n\
 @samp{\\} (forward and backward slashes) under Windows.\n\
 @seealso{pathsep}\n\
 @end deftypefn")
 {
   octave_value retval;
 
diff --git a/src/error.cc b/src/error.cc
--- a/src/error.cc
+++ b/src/error.cc
@@ -1482,17 +1482,17 @@ initialize_default_warning_state (void)
   set_warning_state ("Octave:noninteger-range-as-index", "error");
 
 }
 
 DEFUN (lasterror, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{lasterr} =} lasterror ()\n\
 @deftypefnx {Built-in Function} {} lasterror (@var{err})\n\
-@deftypefnx {Built-in Function} {} lasterror ('reset')\n\
+@deftypefnx {Built-in Function} {} lasterror (\"reset\")\n\
 Query or set the last error message structure.  When called without\n\
 arguments, return a structure containing the last error message and other\n\
 information related to this error.  The elements of the structure are:\n\
 \n\
 @table @asis\n\
 @item 'message'\n\
 The text of the last error message\n\
 \n\
@@ -1518,17 +1518,17 @@ The line number at which the error occur
 An optional field with the column number at which the error occurred\n\
 @end table\n\
 @end table\n\
 \n\
 The last error structure may be set by passing a scalar structure, @var{err},\n\
 as input.  Any fields of @var{err} that match those above are set while any\n\
 unspecified fields are initialized with default values.\n\
 \n\
-If @code{lasterror} is called with the argument 'reset', all fields are\n\
+If @code{lasterror} is called with the argument \"reset\", all fields are\n\
 set to their default values.\n\
 @seealso{lasterr}\n\
 @end deftypefn")
 {
   octave_value retval;
   int nargin = args.length();
 
   unwind_protect frame;
diff --git a/src/file-io.cc b/src/file-io.cc
--- a/src/file-io.cc
+++ b/src/file-io.cc
@@ -1067,17 +1067,17 @@ converted.\n\
     print_usage ();
 
   return retval;
 }
 
 DEFUN (fscanf, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {[@var{val}, @var{count}, @var{errmsg}] =} fscanf (@var{fid}, @var{template}, @var{size})\n\
-+@deftypefnx {Built-in Function} {[@var{v1}, @var{v2}, @dots{}, @var{count}] =} fscanf (@var{fid}, @var{template}, @var{locale})\n\
+@deftypefnx {Built-in Function} {[@var{v1}, @var{v2}, @dots{}, @var{count}] =} fscanf (@var{fid}, @var{template}, @var{locale})\n\
 In the first form, read from @var{fid} according to @var{template},\n\
 returning the result in the matrix @var{val}.\n\
 \n\
 The optional argument @var{size} specifies the amount of data to read\n\
 and may be one of\n\
 \n\
 @table @code\n\
 @item Inf\n\
@@ -1106,19 +1106,19 @@ conversions.\n\
 The number of items successfully read is returned in @var{count}.\n\
 \n\
 If an error occurs, @var{errmsg} contains a system-dependent error message.\n\
 \n\
 In the second form, read from @var{fid} according to @var{template},\n\
 with each conversion specifier in @var{template} corresponding to a\n\
 single scalar return value.  This form is more `C-like', and also\n\
 compatible with previous versions of Octave.  The number of successful\n\
-conversions is returned in @var{count}. It permits to explicitly\n\
-specify a locale to take into account langage specific features, \n\
-such as decimal separator. This operation restores the previous locales\n\
+conversions is returned in @var{count}.  It permits to explicitly\n\
+specify a locale to take into account language specific features, \n\
+such as decimal separator.  This operation restores the previous locales\n\
 setting at the end of the conversion.\n\
 @ifclear OCTAVE_MANUAL\n\
 \n\
 See the Formatted Input section of the GNU Octave manual for a\n\
 complete description of the syntax of the template string.\n\
 @end ifclear\n\
 @seealso{scanf, sscanf, fread, fprintf, fgets, fputs}\n\
 @end deftypefn")
@@ -1334,17 +1334,17 @@ is returned in @var{pos}.\n\
 %!test
 %! assert(sscanf('1,2', '%f', 'C'), 1)
 %! assert(sscanf('1,2', '%f', 'fr_FR'), 1.2)
 */
 
 DEFUN (scanf, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {[@var{val}, @var{count}, @var{errmsg}] =} scanf (@var{template}, @var{size})\n\
-@deftypefnx {Built-in Function} {[@var{v1}, @var{v2}, @dots{}, @var{count}]] =} scanf (@var{template}, @var{locale}))\n\
+@deftypefnx {Built-in Function} {[@var{v1}, @var{v2}, @dots{}, @var{count}] =} scanf (@var{template}, @var{locale})\n\
 This is equivalent to calling @code{fscanf} with @var{fid} = @code{stdin}.\n\
 \n\
 It is currently not useful to call @code{scanf} in interactive\n\
 programs.\n\
 @seealso{fscanf, sscanf, printf}\n\
 @end deftypefn")
 {
   int nargin = args.length ();
@@ -1848,19 +1848,20 @@ open for writing.\n\
 For example:\n\
 \n\
 @example\n\
 @group\n\
 fid = popen (\"ls -ltr / | tail -3\", \"r\");\n\
 while (ischar (s = fgets (fid)))\n\
   fputs (stdout, s);\n\
 endwhile\n\
-     @print{} drwxr-xr-x  33 root  root  3072 Feb 15 13:28 etc\n\
-     @print{} drwxr-xr-x   3 root  root  1024 Feb 15 13:28 lib\n\
-     @print{} drwxrwxrwt  15 root  root  2048 Feb 17 14:53 tmp\n\
+\n\
+   @print{} drwxr-xr-x  33 root  root  3072 Feb 15 13:28 etc\n\
+   @print{} drwxr-xr-x   3 root  root  1024 Feb 15 13:28 lib\n\
+   @print{} drwxrwxrwt  15 root  root  2048 Feb 17 14:53 tmp\n\
 @end group\n\
 @end example\n\
 @end deftypefn")
 {
   octave_value retval = -1;
 
   int nargin = args.length ();
 
@@ -2221,16 +2222,17 @@ this system.  The name of this directory
 
 DEFUNX ("SEEK_SET", FSEEK_SET, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} SEEK_SET ()\n\
 @deftypefnx {Built-in Function} {} SEEK_CUR ()\n\
 @deftypefnx {Built-in Function} {} SEEK_END ()\n\
 Return the numerical value to pass to @code{fseek} to perform\n\
 one of the following actions:\n\
+\n\
 @table @code\n\
 @item SEEK_SET\n\
 Position file relative to the beginning.\n\
 \n\
 @item SEEK_CUR\n\
 Position file relative to the current position.\n\
 \n\
 @item SEEK_END\n\
diff --git a/src/graphics.cc b/src/graphics.cc
--- a/src/graphics.cc
+++ b/src/graphics.cc
@@ -3024,28 +3024,57 @@ root_figure::properties::update_units (v
       ss(0) = 0;
       ss(1) = 0;
       ss(2) *= 2.54 / dpi;
       ss(3) *= 2.54 / dpi;
     }
   else if (xunits.compare ("normalized"))
     {
       ss = Matrix (1, 4, 1.0);
+      ss(0) = 0;
+      ss(1) = 0;
     }
   else if (xunits.compare ("points"))
     {
       ss(0) = 0;
       ss(1) = 0;
       ss(2) *= 72 / dpi;
       ss(3) *= 72 / dpi;
     }
 
   set_screensize (ss);
 }
 
+Matrix
+root_figure::properties::get_boundingbox (bool internal, const Matrix&) const
+{
+  Matrix screen_size = screen_size_pixels ();
+  Matrix pos = Matrix (1, 4, 0);
+  pos(2) = screen_size(0);
+  pos(3) = screen_size(1);
+  return pos;
+}
+
+/*
+%!test
+%! set (0, "units", "pixels")
+%! sz = get (0, "screensize") - [1, 1, 0, 0];
+%! dpi = get (0, "screenpixelsperinch");
+%! set (0, "units", "inches")
+%! assert (get (0, "screensize"), sz / dpi, 0.5 / dpi) 
+%! set (0, "units", "centimeters")
+%! assert (get (0, "screensize"), sz / dpi * 2.54, 0.5 / dpi * 2.54)
+%! set (0, "units", "points")
+%! assert (get (0, "screensize"), sz / dpi * 72, 0.5 / dpi * 72)
+%! set (0, "units", "normalized")
+%! assert (get (0, "screensize"), [0.0, 0.0, 1.0, 1.0])
+%! set (0, "units", "pixels")
+%! assert (get (0, "screensize"), sz + [1, 1, 0, 0])
+*/
+
 void
 root_figure::properties::remove_child (const graphics_handle& gh)
 {
   gh_manager::pop_figure (gh);
 
   graphics_handle cf = gh_manager::current_figure ();
 
   xset (0, "currentfigure", cf.value ());
@@ -3220,31 +3249,36 @@ figure::properties::map_to_boundingbox (
 
 void
 figure::properties::set_position (const octave_value& v,
                                   bool do_notify_toolkit)
 {
   if (! error_state)
     {
       Matrix old_bb, new_bb;
-
-      old_bb = get_boundingbox ();
-      position.set (v, true, do_notify_toolkit);
-      new_bb = get_boundingbox ();
+      bool modified = false;
+
+      old_bb = get_boundingbox (true);
+      modified = position.set (v, false, do_notify_toolkit);
+      new_bb = get_boundingbox (true);
 
       if (old_bb != new_bb)
         {
           if (old_bb(2) != new_bb(2) || old_bb(3) != new_bb(3))
             {
               execute_resizefcn ();
               update_boundingbox ();
             }
         }
 
-      mark_modified ();
+      if (modified)
+        {
+          position.run_listeners (POSTSET);
+          mark_modified ();
+        }
     }
 }
 
 void
 figure::properties::set_outerposition (const octave_value& v,
                                        bool do_notify_toolkit)
 {
   if (! error_state)
@@ -3460,76 +3494,215 @@ papersize_from_type (const caseless_str 
 }
 
 void
 figure::properties::update_paperunits (const caseless_str& old_paperunits)
 {
   Matrix pos = get_paperposition ().matrix_value ();
   Matrix sz = get_papersize ().matrix_value ();
 
-  pos (0) = pos (0) / sz(0);
-  pos (1) = pos (1) / sz(1);
-  pos (2) = pos (2) / sz(0);
-  pos (3) = pos (3) / sz(1);
-
+  pos(0) /= sz(0);
+  pos(1) /= sz(1);
+  pos(2) /= sz(0);
+  pos(3) /= sz(1);
+
+  std::string porient = get_paperorientation ();
   caseless_str punits = get_paperunits ();
   caseless_str typ = get_papertype ();
 
   if (typ.compare ("<custom>"))
     {
       if (old_paperunits.compare ("centimeters"))
         {
-          sz (0) = sz (0) / 2.54;
-          sz (1) = sz (1) / 2.54;
+          sz(0) /= 2.54;
+          sz(1) /= 2.54;
         }
       else if (old_paperunits.compare ("points"))
         {
-          sz (0) = sz (0) / 72.0;
-          sz (1) = sz (1) / 72.0;
+          sz(0) /= 72.0;
+          sz(1) /= 72.0;
         }
 
       if (punits.compare ("centimeters"))
         {
-          sz(0) = sz(0) * 2.54;
-          sz(1) = sz(1) * 2.54;
-        }
-      else if (old_paperunits.compare ("points"))
-        {
-          sz (0) = sz (0) * 72.0;
-          sz (1) = sz (1) * 72.0;
+          sz(0) *= 2.54;
+          sz(1) *= 2.54;
+        }
+      else if (punits.compare ("points"))
+        {
+          sz(0) *= 72.0;
+          sz(1) *= 72.0;
         }
     }
   else
-    sz = papersize_from_type (punits, typ);
-
-  pos (0) = pos (0) * sz(0);
-  pos (1) = pos (1) * sz(1);
-  pos (2) = pos (2) * sz(0);
-  pos (3) = pos (3) * sz(1);
+    {
+      sz = papersize_from_type (punits, typ);
+      if (porient == "landscape")
+        std::swap (sz(0), sz(1));
+    }
+
+  pos(0) *= sz(0);
+  pos(1) *= sz(1);
+  pos(2) *= sz(0);
+  pos(3) *= sz(1);
 
   papersize.set (octave_value (sz));
   paperposition.set (octave_value (pos));
 }
 
 void
 figure::properties::update_papertype (void)
 {
   caseless_str typ = get_papertype ();
-
   if (! typ.compare ("<custom>"))
-    // Call papersize.set rather than set_papersize to avoid loops between
-    // update_papersize and update_papertype
-    papersize.set (octave_value (papersize_from_type (get_paperunits (), typ)));
+    {
+      Matrix sz = papersize_from_type (get_paperunits (), typ);
+      if (get_paperorientation () == "landscape")
+        std::swap (sz(0), sz(1));
+      // Call papersize.set rather than set_papersize to avoid loops
+      // between update_papersize and update_papertype
+      papersize.set (octave_value (sz));
+    }
 }
 
 void
 figure::properties::update_papersize (void)
 {
-  papertype.set ("<custom>");
-}
+  Matrix sz = get_papersize ().matrix_value ();
+  if (sz(0) > sz(1))
+    {
+      std::swap (sz(0), sz(1));
+      papersize.set (octave_value (sz));
+      paperorientation.set (octave_value ("landscape"));
+    }
+  else
+    {
+      paperorientation.set ("portrait");
+    }
+  std::string punits = get_paperunits ();
+  if (punits == "centimeters")
+    {
+      sz(0) /= 2.54;
+      sz(1) /= 2.54;
+    }
+  else if (punits == "points")
+    {
+      sz(0) = 72.0;
+      sz(1) = 72.0;
+    }
+  if (punits == "normalized")
+    {
+      caseless_str typ = get_papertype ();
+      if (get_papertype () == "<custom>")
+        error ("set: can't set the papertype to <custom> when the paperunits is normalized");
+    }
+  else
+    {
+      // TODO - the papersizes info is also in papersize_from_type().
+      // Both should be rewritten to avoid the duplication.
+      std::string typ = "<custom>";
+      const double mm2in = 1.0 / 25.4;
+      const double tol = 0.01;
+
+      if (std::abs (sz(0) - 8.5) + std::abs (sz(1) - 11.0) < tol)
+        typ = "usletter";
+      else if (std::abs (sz(0) - 8.5) + std::abs (sz(1) - 14.0) < tol)
+        typ = "uslegal";
+      else if (std::abs (sz(0) - 11.0) + std::abs (sz(1) - 17.0) < tol)
+        typ = "tabloid";
+      else if (std::abs (sz(0) - 841.0 * mm2in) + std::abs (sz(1) - 1198.0 * mm2in) < tol)
+        typ = "a0";
+      else if (std::abs (sz(0) - 594.0 * mm2in) + std::abs (sz(1) - 841.0 * mm2in) < tol)
+        typ = "a1";
+      else if (std::abs (sz(0) - 420.0 * mm2in) + std::abs (sz(1) - 594.0 * mm2in) < tol)
+        typ = "a2";
+      else if (std::abs (sz(0) - 297.0 * mm2in) + std::abs (sz(1) - 420.0 * mm2in) < tol)
+        typ = "a3";
+      else if (std::abs (sz(0) - 210.0 * mm2in) + std::abs (sz(1) - 297.0 * mm2in) < tol)
+        typ = "a4";
+      else if (std::abs (sz(0) - 148.0 * mm2in) + std::abs (sz(1) - 210.0 * mm2in) < tol)
+        typ = "a5";
+      else if (std::abs (sz(0) - 1029.0 * mm2in) + std::abs (sz(1) - 1456.0 * mm2in) < tol)
+        typ = "b0";
+      else if (std::abs (sz(0) - 728.0 * mm2in) + std::abs (sz(1) - 1028.0 * mm2in) < tol)
+        typ = "b1";
+      else if (std::abs (sz(0) - 514.0 * mm2in) + std::abs (sz(1) - 728.0 * mm2in) < tol)
+        typ = "b2";
+      else if (std::abs (sz(0) - 364.0 * mm2in) + std::abs (sz(1) - 514.0 * mm2in) < tol)
+        typ = "b3";
+      else if (std::abs (sz(0) - 257.0 * mm2in) + std::abs (sz(1) - 364.0 * mm2in) < tol)
+        typ = "b4";
+      else if (std::abs (sz(0) - 182.0 * mm2in) + std::abs (sz(1) - 257.0 * mm2in) < tol)
+        typ = "b5";
+      else if (std::abs (sz(0) - 9.0)  + std::abs (sz(1) - 12.0) < tol)
+        typ = "arch-a";
+      else if (std::abs (sz(0) - 12.0) + std::abs (sz(1) - 18.0) < tol)
+        typ = "arch-b";
+      else if (std::abs (sz(0) - 18.0) + std::abs (sz(1) - 24.0) < tol)
+        typ = "arch-c";
+      else if (std::abs (sz(0) - 24.0) + std::abs (sz(1) - 36.0) < tol)
+        typ = "arch-d";
+      else if (std::abs (sz(0) - 36.0) + std::abs (sz(1) - 48.0) < tol)
+        typ = "arch-e";
+      else if (std::abs (sz(0) - 8.5)  + std::abs (sz(1) - 11.0) < tol)
+        typ = "a";
+      else if (std::abs (sz(0) - 11.0) + std::abs (sz(1) - 17.0) < tol)
+        typ = "b";
+      else if (std::abs (sz(0) - 17.0) + std::abs (sz(1) - 22.0) < tol)
+        typ = "c";
+      else if (std::abs (sz(0) - 22.0) + std::abs (sz(1) - 34.0) < tol)
+        typ = "d";
+      else if (std::abs (sz(0) - 34.0) + std::abs (sz(1) - 43.0) < tol)
+        typ = "e";
+      // Call papertype.set rather than set_papertype to avoid loops between
+      // update_papersize and update_papertype
+      papertype.set (typ);
+    }
+}
+
+void
+figure::properties::update_paperorientation (void)
+{
+  std::string porient = get_paperorientation ();
+  Matrix sz = get_papersize ().matrix_value ();
+  Matrix pos = get_paperposition ().matrix_value ();
+  if ((sz(0) > sz(1) && porient == "portrait")
+      || (sz(0) < sz(1) && porient == "landscape"))
+    {
+      std::swap (sz(0), sz(1));
+      std::swap (pos(0), pos(1));
+      std::swap (pos(2), pos(3));
+      // Call papertype.set rather than set_papertype to avoid loops
+      // between update_papersize and update_papertype
+      papersize.set (octave_value (sz));
+      paperposition.set (octave_value (pos));
+    }
+}
+
+/*
+%!test
+%! figure (1, "visible", false);
+%! tol = 100 * eps ();
+%! set (gcf (), "paperorientation", "PORTRAIT")
+%! set (gcf (), "paperunits", "inches")
+%! set (gcf (), "papertype", "USletter")
+%! assert (get (gcf (), "papersize"), [8.5, 11.0], tol)
+%! set (gcf (), "paperorientation", "Landscape")
+%! assert (get (gcf (), "papersize"), [11.0, 8.5], tol)
+%! set (gcf (), "paperunits", "centimeters")
+%! assert (get (gcf (), "papersize"), [11.0, 8.5] * 2.54, tol)
+%! set (gcf (), "papertype", "a4");
+%! assert (get (gcf (), "papersize"), [29.7, 21.0], tol)
+%! set (gcf (), "paperunits", "inches", "papersize", [8.5, 11.0])
+%! assert (get (gcf (), "papertype"), "usletter")
+%! assert (get (gcf (), "paperorientation"), "portrait")
+%! set (gcf (), "papersize", [11.0, 8.5])
+%! assert (get (gcf (), "papertype"), "usletter")
+%! assert (get (gcf (), "paperorientation"), "landscape")
+*/
 
 void
 figure::properties::set_units (const octave_value& v)
 {
   if (! error_state)
     {
       caseless_str old_units = get_units ();
       if (units.set (v, true))
@@ -3538,19 +3711,30 @@ figure::properties::set_units (const oct
           mark_modified ();
         }
     }
 }
 
 void
 figure::properties::update_units (const caseless_str& old_units)
 {
-  set_position (convert_position (get_position ().matrix_value (), old_units,
-                                  get_units (), screen_size_pixels ()));
-}
+  position.set (convert_position (get_position ().matrix_value (), old_units,
+                                  get_units (), screen_size_pixels ()), false);
+}
+
+/*
+%!test
+%! figure (1, "visible", false)
+%! set (0, "units", "pixels")
+%! rsz = get (0, "screensize");
+%! set (gcf (), "units", "pixels")
+%! fsz = get (gcf (), "position");
+%! set (gcf (), "units", "normalized")
+%! assert (get (gcf (), "position"), (fsz - [1, 1, 0, 0]) ./ rsz([3, 4, 3, 4]))
+*/
 
 std::string
 figure::properties::get_title (void) const
 {
   if (is_numbertitle ())
     {
       std::ostringstream os;
       std::string nm = get_name ();
@@ -5803,22 +5987,16 @@ axes::properties::calc_ticks_and_lims (a
             {
               tmp = tmp_lims(0);
               tmp_lims(0) = -tmp_lims(1);
               tmp_lims(1) = -tmp;
             }
         }
       lims = tmp_lims;
     }
-  else
-    {
-      // adjust min and max tics if they are out of limits
-      i1 = static_cast<int> (std::ceil (lo / tick_sep));
-      i2 = static_cast<int> (gnulib::floor (hi / tick_sep));
-    }
 
   Matrix tmp_ticks (1, i2-i1+1);
   for (int i = 0; i <= i2-i1; i++)
     {
       tmp_ticks (i) = tick_sep * (i+i1);
       if (is_logscale)
         tmp_ticks (i) = std::pow (10., tmp_ticks (i));
     }
@@ -5827,17 +6005,17 @@ axes::properties::calc_ticks_and_lims (a
       Matrix rev_ticks (1, i2-i1+1);
       rev_ticks = -tmp_ticks;
       for (int i = 0; i <= i2-i1; i++)
         tmp_ticks (i) = rev_ticks (i2-i1-i);
     }
 
   ticks = tmp_ticks;
 
-  int n = is_logscale ? 9 : 4;
+  int n = is_logscale ? 8 : 4;
   Matrix tmp_mticks (1, n * (tmp_ticks.numel () - 1));
 
   for (int i = 0; i < tmp_ticks.numel ()-1; i++)
     {
       double d = (tmp_ticks (i+1) - tmp_ticks (i)) / (n+1);
       for (int j = 0; j < n; j++)
         {
           tmp_mticks (n*i+j) = tmp_ticks (i) + d * (j+1);
@@ -6390,16 +6568,68 @@ double force_in_range (const double x, c
   if (x < lower)
     { return lower; }
   else if (x > upper)
     { return upper; }
   else
     { return x; }
 }
 
+static Matrix
+do_zoom (double val, double factor, const Matrix& lims, bool is_logscale)
+{
+  Matrix new_lims = lims;
+
+  double lo = lims(0);
+  double hi = lims(1);
+
+  bool is_negative = lo < 0 && hi < 0;
+
+  if (is_logscale)
+    {
+      if (is_negative)
+        {
+          double tmp = hi;
+          hi = std::log10 (-lo);
+          lo = std::log10 (-tmp);
+          val = std::log10 (-val);
+        }
+      else
+        {
+          hi = std::log10 (hi);
+          lo = std::log10 (lo);
+          val = std::log10 (val);
+        }
+    }
+
+  // Perform the zooming
+  lo = val + factor * (lo - val);
+  hi = val + factor * (hi - val);
+
+  if (is_logscale)
+    {
+      if (is_negative)
+        {
+          double tmp = -std::pow (10.0, hi);
+          hi = -std::pow (10.0, lo);
+          lo = tmp;
+        }
+      else
+        {
+          lo = std::pow (10.0, lo);
+          hi = std::pow (10.0, hi);
+        }
+    }
+
+  new_lims(0) = lo;
+  new_lims(1) = hi;
+
+  return new_lims;
+}
+
 void
 axes::properties::zoom_about_point (double x, double y, double factor,
                                     bool push_to_zoom_stack)
 {
   // FIXME: Do we need error checking here?
   Matrix xlims = get_xlim ().matrix_value ();
   Matrix ylims = get_ylim ().matrix_value ();
 
@@ -6412,21 +6642,18 @@ axes::properties::zoom_about_point (doub
   get_children_limits (minx, maxx, min_pos_x, max_neg_x, kids, 'x');
 
   double miny = octave_Inf;
   double maxy = -octave_Inf;
   double min_pos_y = octave_Inf;
   double max_neg_y = -octave_Inf;
   get_children_limits (miny, maxy, min_pos_y, max_neg_y, kids, 'y');
 
-  // Perform the zooming
-  xlims (0) = x + factor * (xlims (0) - x);
-  xlims (1) = x + factor * (xlims (1) - x);
-  ylims (0) = y + factor * (ylims (0) - y);
-  ylims (1) = y + factor * (ylims (1) - y);
+  xlims = do_zoom (x, factor, xlims, xscale_is ("log"));
+  ylims = do_zoom (y, factor, ylims, yscale_is ("log"));
 
   zoom (xlims, ylims, push_to_zoom_stack);
 }
 
 void
 axes::properties::zoom (const Matrix& xl, const Matrix& yl, bool push_to_zoom_stack)
 {
   if (push_to_zoom_stack)
@@ -6442,18 +6669,78 @@ axes::properties::zoom (const Matrix& xl
   ylim = yl;
   ylimmode = "manual";
 
   update_transform ();
   update_xlim (false);
   update_ylim (false);
 }
 
-void
-axes::properties::translate_view (double delta_x, double delta_y)
+static Matrix
+do_translate (double x0, double x1, const Matrix& lims, bool is_logscale)
+{
+  Matrix new_lims = lims;
+
+  double lo = lims(0);
+  double hi = lims(1);
+
+  bool is_negative = lo < 0 && hi < 0;
+
+  double delta;
+
+  if (is_logscale)
+    {
+      if (is_negative)
+        {
+          double tmp = hi;
+          hi = std::log10 (-lo);
+          lo = std::log10 (-tmp);
+          x0 = -x0;
+          x1 = -x1;
+        }
+      else
+        {
+          hi = std::log10 (hi);
+          lo = std::log10 (lo);
+        }
+
+      delta = std::log10 (x0) - std::log10 (x1);
+    }
+  else
+    {
+      delta = x0 - x1;
+    }
+
+  // Perform the translation
+  lo += delta;
+  hi += delta;
+
+  if (is_logscale)
+    {
+      if (is_negative)
+        {
+          double tmp = -std::pow (10.0, hi);
+          hi = -std::pow (10.0, lo);
+          lo = tmp;
+        }
+      else
+        {
+          lo = std::pow (10.0, lo);
+          hi = std::pow (10.0, hi);
+        }
+    }
+
+  new_lims(0) = lo;
+  new_lims(1) = hi;
+
+  return new_lims;
+}
+
+void
+axes::properties::translate_view (double x0, double x1, double y0, double y1)
 {
   // FIXME: Do we need error checking here?
   Matrix xlims = get_xlim ().matrix_value ();
   Matrix ylims = get_ylim ().matrix_value ();
 
   // Get children axes limits
   Matrix kids = get_children ();
   double minx = octave_Inf;
@@ -6463,20 +6750,18 @@ axes::properties::translate_view (double
   get_children_limits (minx, maxx, min_pos_x, max_neg_x, kids, 'x');
 
   double miny = octave_Inf;
   double maxy = -octave_Inf;
   double min_pos_y = octave_Inf;
   double max_neg_y = -octave_Inf;
   get_children_limits (miny, maxy, min_pos_y, max_neg_y, kids, 'y');
 
-  xlims (0) += delta_x;
-  xlims (1) += delta_x;
-  ylims (0) += delta_y;
-  ylims (1) += delta_y;
+  xlims = do_translate (x0, x1, xlims, xscale_is ("log"));
+  ylims = do_translate (y0, y1, ylims, yscale_is ("log"));
 
   zoom (xlims, ylims, false);
 }
 
 void
 axes::properties::rotate_view (double delta_el, double delta_az)
 {
   Matrix v = get_view ().matrix_value ();
diff --git a/src/graphics.h.in b/src/graphics.h.in
--- a/src/graphics.h.in
+++ b/src/graphics.h.in
@@ -217,32 +217,26 @@ class log_scaler : public base_scaler
 {
 public:
   log_scaler (void) { }
 
   Matrix scale (const Matrix& m) const
     {
       Matrix retval (m.rows (), m.cols ());
 
-      if (m.any_element_is_positive ())
-        do_scale (m.data (), retval.fortran_vec (), m.numel ());
-      else
-        do_neg_scale (m.data (), retval.fortran_vec (), m.numel ());
+      do_scale (m.data (), retval.fortran_vec (), m.numel ());
 
       return retval;
     }
 
   NDArray scale (const NDArray& m) const
     {
       NDArray retval (m.dims ());
 
-      if (m.any_element_is_positive ())
-        do_scale (m.data (), retval.fortran_vec (), m.numel ());
-      else
-        do_neg_scale (m.data (), retval.fortran_vec (), m.numel ());
+      do_scale (m.data (), retval.fortran_vec (), m.numel ());
 
       return retval;
     }
 
   double scale (double d) const
     { return log10 (d); }
 
   double unscale (double d) const
@@ -250,37 +244,72 @@ public:
 
   base_scaler* clone (void) const
     { return new log_scaler (); }
 
 private:
   void do_scale (const double *src, double *dest, int n) const
     {
       for (int i = 0; i < n; i++)
-        dest[i] = log10(src[i]);
+        dest[i] = log10 (src[i]);
+    }
+};
+
+class neg_log_scaler : public base_scaler
+{
+public:
+  neg_log_scaler (void) { }
+
+  Matrix scale (const Matrix& m) const
+    {
+      Matrix retval (m.rows (), m.cols ());
+
+      do_scale (m.data (), retval.fortran_vec (), m.numel ());
+
+      return retval;
     }
 
-  void do_neg_scale (const double *src, double *dest, int n) const
+  NDArray scale (const NDArray& m) const
+    {
+      NDArray retval (m.dims ());
+
+      do_scale (m.data (), retval.fortran_vec (), m.numel ());
+
+      return retval;
+    }
+
+  double scale (double d) const
+    { return -log10 (-d); }
+
+  double unscale (double d) const
+    { return -pow (10.0, -d); }
+
+  base_scaler* clone (void) const
+    { return new neg_log_scaler (); }
+
+private:
+  void do_scale (const double *src, double *dest, int n) const
     {
       for (int i = 0; i < n; i++)
-        dest[i] = -log10(-src[i]);
+        dest[i] = -log10 (-src[i]);
     }
 };
 
 class scaler
 {
 public:
   scaler (void) : rep (new base_scaler ()) { }
 
   scaler (const scaler& s) : rep (s.rep->clone()) { }
 
   scaler (const std::string& s)
     : rep (s == "log"
            ? new log_scaler ()
-           : (s == "linear" ? new lin_scaler () : new base_scaler ()))
+           : (s == "neglog" ? new neg_log_scaler ()
+              : (s == "linear" ? new lin_scaler () : new base_scaler ())))
     { }
 
   ~scaler (void) { delete rep; }
 
   Matrix scale (const Matrix& m) const
     { return rep->scale (m); }
 
   NDArray scale (const NDArray& m) const
@@ -313,16 +342,18 @@ public:
       if (rep)
         {
           delete rep;
           rep = 0;
         }
 
       if (s == "log")
         rep = new log_scaler ();
+      else if (s == "neglog")
+        rep = new neg_log_scaler ();
       else if (s == "linear")
         rep = new lin_scaler ();
       else
         rep = new base_scaler ();
 
       return *this;
     }
 
@@ -2305,17 +2336,17 @@ private:
 
   // FIXME -- default toolkit should be configurable.
 
   gtk_manager (void)
     : dtk ("gnuplot"), available_toolkits (), loaded_toolkits () { }
 
   ~gtk_manager (void) { }
 
-  static void create_instance (void);
+  OCTINTERP_API static void create_instance (void);
 
   static bool instance_ok (void)
   {
     bool retval = true;
 
     if (! instance)
       create_instance ();
 
@@ -2326,17 +2357,17 @@ private:
         retval = false;
       }
 
     return retval;
   }
 
   static void cleanup_instance (void) { delete instance; instance = 0; }
 
-  static gtk_manager *instance;
+  OCTINTERP_API static gtk_manager *instance;
 
   // The name of the default toolkit.
   std::string dtk;
 
   // The list of toolkits that we know about.
   std::set<std::string> available_toolkits;
 
   // The list of toolkits we have actually loaded.
@@ -3118,16 +3149,19 @@ private:
 class OCTINTERP_API root_figure : public base_graphics_object
 {
 public:
   class OCTINTERP_API properties : public base_properties
   {
   public:
     void remove_child (const graphics_handle& h);
 
+    Matrix get_boundingbox (bool internal = false,
+                            const Matrix& parent_pix_size = Matrix ()) const;
+
     // See the genprops.awk script for an explanation of the
     // properties declarations.
 
     // FIXME -- it seems strange to me that the diary, diaryfile,
     // echo, format, formatspacing, language, and recursionlimit
     // properties are here.  WTF do they have to do with graphics?
     // Also note that these properties (and the monitorpositions,
     // pointerlocation, and pointerwindow properties) are not yet used
@@ -3335,17 +3369,17 @@ public:
 
     BEGIN_PROPERTIES (figure)
       any_property __plot_stream__ h , Matrix ()
       bool_property __enhanced__ h , "on"
       radio_property nextplot , "new|{add}|replacechildren|replace"
       callback_property closerequestfcn , "closereq"
       handle_property currentaxes S , graphics_handle ()
       array_property colormap , jet_colormap ()
-      radio_property paperorientation , "{portrait}|landscape|rotated"
+      radio_property paperorientation U , "{portrait}|landscape|rotated"
       color_property color , color_property (color_values (1, 1, 1), radio_values ("none"))
       array_property alphamap , Matrix (64, 1, 1)
       string_property currentcharacter r , ""
       handle_property currentobject r , graphics_handle ()
       array_property currentpoint r , Matrix (2, 1, 0)
       bool_property dockcontrols , "off"
       bool_property doublebuffer , "on"
       string_property filename , ""
@@ -3658,17 +3692,17 @@ public:
     { return get_transform ().untransform (px, py, (x_zlim(0)+x_zlim(1))/2); }
 
     ColumnVector coord2pixel (double x, double y, double z) const
     { return get_transform ().transform (x, y, z); }
 
     void zoom_about_point (double x, double y, double factor,
                            bool push_to_zoom_stack = true);
     void zoom (const Matrix& xl, const Matrix& yl, bool push_to_zoom_stack = true);
-    void translate_view (double delta_x, double delta_y);
+    void translate_view (double x0, double x1, double y0, double y1);
     void rotate_view (double delta_az, double delta_el);
     void unzoom (void);
     void clear_zoom_stack (void);
 
     void update_units (const caseless_str& old_units);
 
     void update_fontunits (const caseless_str& old_fontunits);
 
@@ -3809,19 +3843,42 @@ public:
       // hidden properties for alignment of subplots
       radio_property autopos_tag h , "{none}|subplot"
    END_PROPERTIES
 
   protected:
     void init (void);
 
   private:
-    void update_xscale (void) { sx = get_xscale (); }
-    void update_yscale (void) { sy = get_yscale (); }
-    void update_zscale (void) { sz = get_zscale (); }
+
+    std::string
+    get_scale (const std::string& scale, const Matrix& lims)
+    {
+      std::string retval = scale;
+
+      if (scale == "log" && lims.numel () > 1 && lims(0) < 0 && lims(1) < 0)
+        retval = "neglog";
+
+      return retval;
+    }
+
+    void update_xscale (void)
+    {
+      sx = get_scale (get_xscale (), xlim.get ().matrix_value ());
+    }
+
+    void update_yscale (void)
+    {
+      sy = get_scale (get_yscale (), ylim.get ().matrix_value ());
+    }
+
+    void update_zscale (void)
+    {
+      sz = get_scale (get_zscale (), zlim.get ().matrix_value ());
+    }
 
     void update_view (void) { sync_positions (); }
     void update_dataaspectratio (void) { sync_positions (); }
     void update_dataaspectratiomode (void) { sync_positions (); }
     void update_plotboxaspectratio (void) { sync_positions (); }
     void update_plotboxaspectratiomode (void) { sync_positions (); }
 
     void update_layer (void) { update_axes_layout (); }
@@ -3963,46 +4020,52 @@ public:
     {
       if (xtickmode.is ("auto"))
         calc_ticks_and_lims (xlim, xtick, xmtick, xlimmode.is ("auto"), xscale.is ("log"));
       if (xticklabelmode.is ("auto"))
         calc_ticklabels (xtick, xticklabel, xscale.is ("log"));
 
       fix_limits (xlim);
 
+      update_xscale ();
+
       if (do_clr_zoom)
         zoom_stack.clear ();
 
       update_axes_layout ();
     }
 
     void update_ylim (bool do_clr_zoom = true)
     {
       if (ytickmode.is ("auto"))
         calc_ticks_and_lims (ylim, ytick, ymtick, ylimmode.is ("auto"), yscale.is ("log"));
       if (yticklabelmode.is ("auto"))
         calc_ticklabels (ytick, yticklabel, yscale.is ("log"));
 
       fix_limits (ylim);
 
+      update_yscale ();
+
       if (do_clr_zoom)
         zoom_stack.clear ();
 
       update_axes_layout ();
     }
 
     void update_zlim (void)
     {
       if (ztickmode.is ("auto"))
         calc_ticks_and_lims (zlim, ztick, zmtick, zlimmode.is ("auto"), zscale.is ("log"));
       if (zticklabelmode.is ("auto"))
         calc_ticklabels (ztick, zticklabel, zscale.is ("log"));
 
       fix_limits (zlim);
 
+      update_zscale ();
+
       zoom_stack.clear ();
 
       update_axes_layout ();
     }
 
   };
 
 private:
diff --git a/src/help.cc b/src/help.cc
--- a/src/help.cc
+++ b/src/help.cc
@@ -582,17 +582,17 @@ parameters.\n\
   pair_type ("global",
     "-*- texinfo -*-\n\
 @deftypefn {Keyword} {} global\n\
 Declare variables to have global scope.\n\
 \n\
 @example\n\
 @group\n\
 global @var{x};\n\
-if isempty (@var{x})\n\
+if (isempty (@var{x}))\n\
   x = 1;\n\
 endif\n\
 @end group\n\
 @end example\n\
 @seealso{persistent}\n\
 @end deftypefn"),
 
   pair_type ("if",
diff --git a/src/lex.ll b/src/lex.ll
--- a/src/lex.ll
+++ b/src/lex.ll
@@ -63,16 +63,17 @@ along with Octave; see the file COPYING.
 #include "comment-list.h"
 #include "defun.h"
 #include "error.h"
 #include "gripes.h"
 #include "input.h"
 #include "lex.h"
 #include "ov.h"
 #include "parse.h"
+#include "parse-private.h"
 #include "pt-all.h"
 #include "symtab.h"
 #include "token.h"
 #include "toplev.h"
 #include "utils.h"
 #include "variables.h"
 #include <oct-parse.h>
 #include <oct-gperf.h>
@@ -1108,18 +1109,17 @@ do_comma_insert_check (void)
 void
 reset_parser (void)
 {
   // Start off on the right foot.
   BEGIN (INITIAL);
 
   parser_end_of_input = false;
 
-  while (! symtab_context.empty ())
-    symtab_context.pop ();
+  parser_symtab_context.clear ();
 
   // We do want a prompt by default.
   promptflag = 1;
 
   // We are not in a block comment.
   block_comment_nesting_level = 0;
 
   // Error may have occurred inside some brackets, braces, or parentheses.
@@ -1492,20 +1492,36 @@ is_keyword_token (const std::string& s)
         case continue_kw:
         case else_kw:
         case otherwise_kw:
         case return_kw:
         case unwind_protect_cleanup_kw:
           lexer_flags.at_beginning_of_statement = true;
           break;
 
+        case static_kw:
+          if ((reading_fcn_file || reading_script_file
+               || reading_classdef_file)
+              && ! curr_fcn_file_full_name.empty ())
+            warning_with_id ("Octave:deprecated-keyword",
+                             "the `static' keyword is obsolete and will be removed from a future version of Octave; please use `persistent' instead; near line %d of file `%s'",
+                             input_line_number,
+                             curr_fcn_file_full_name.c_str ());
+          else
+            warning_with_id ("Octave:deprecated-keyword",
+                             "the `static' keyword is obsolete and will be removed from a future version of Octave; please use `persistent' instead; near line %d",
+                             input_line_number);
+          // fall through ...
+
+        case persistent_kw:
+          break;
+
         case case_kw:
         case elseif_kw:
         case global_kw:
-        case static_kw:
         case until_kw:
           break;
 
         case end_kw:
           if (! reading_classdef_file
               && (inside_any_object_index ()
                   || (lexer_flags.defining_func
                       && ! (lexer_flags.looking_at_return_list
@@ -3446,17 +3462,24 @@ lexical_feedback::init (void)
 
   // Set of identifiers that might be local variable names is empty.
   pending_local_variables.clear ();
 }
 
 bool
 is_keyword (const std::string& s)
 {
-  return octave_kw_hash::in_word_set (s.c_str (), s.length ()) != 0;
+  // Parsing function names like "set.property_name" inside
+  // classdef-style class definitions is simplified by handling the
+  // "set" and "get" portions of the names using the same mechanism as
+  // is used for keywords.  However, they are not really keywords in
+  // the language, so omit them from the list of possible keywords.
+
+  return (octave_kw_hash::in_word_set (s.c_str (), s.length ()) != 0
+          && ! (s == "set" || s == "get"));
 }
 
 DEFUN (iskeyword, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} iskeyword ()\n\
 @deftypefnx {Built-in Function} {} iskeyword (@var{name})\n\
 Return true if @var{name} is an Octave keyword.  If @var{name}\n\
 is omitted, return a list of keywords.\n\
@@ -3469,20 +3492,32 @@ is omitted, return a list of keywords.\n
 
   string_vector argv = args.make_argv ("iskeyword");
 
   if (error_state)
     return retval;
 
   if (argc == 1)
     {
+      // Neither set and get are keywords.  See the note in the
+      // is_keyword function for additional details.
+
       string_vector lst (TOTAL_KEYWORDS);
 
+      int j = 0;
+
       for (int i = 0; i < TOTAL_KEYWORDS; i++)
-        lst[i] = wordlist[i].name;
+        {
+          std::string tmp = wordlist[i].name;
+
+          if (! (tmp == "set" || tmp == "get"))
+            lst[j++] = tmp;
+        }
+
+      lst.resize (j);
 
       retval = Cell (lst.sort ());
     }
   else if (argc == 2)
     {
       retval = is_keyword (argv[1]);
     }
   else
@@ -3670,17 +3705,17 @@ display_token (int tok)
     case BREAK: std::cerr << "BREAK\n"; break;
     case CONTINUE: std::cerr << "CONTINUE\n"; break;
     case FUNC_RET: std::cerr << "FUNC_RET\n"; break;
     case UNWIND: std::cerr << "UNWIND\n"; break;
     case CLEANUP: std::cerr << "CLEANUP\n"; break;
     case TRY: std::cerr << "TRY\n"; break;
     case CATCH: std::cerr << "CATCH\n"; break;
     case GLOBAL: std::cerr << "GLOBAL\n"; break;
-    case STATIC: std::cerr << "STATIC\n"; break;
+    case PERSISTENT: std::cerr << "PERSISTENT\n"; break;
     case FCN_HANDLE: std::cerr << "FCN_HANDLE\n"; break;
     case END_OF_INPUT: std::cerr << "END_OF_INPUT\n\n"; break;
     case LEXICAL_ERROR: std::cerr << "LEXICAL_ERROR\n\n"; break;
     case FCN: std::cerr << "FCN\n"; break;
     case CLOSE_BRACE: std::cerr << "CLOSE_BRACE\n"; break;
     case SCRIPT_FILE: std::cerr << "SCRIPT_FILE\n"; break;
     case FUNCTION_FILE: std::cerr << "FUNCTION_FILE\n"; break;
     case SUPERCLASSREF: std::cerr << "SUPERCLASSREF\n"; break;
diff --git a/src/load-path.cc b/src/load-path.cc
--- a/src/load-path.cc
+++ b/src/load-path.cc
@@ -514,23 +514,50 @@ load_path::do_initialize (bool set_initi
       xpath = tpath;
 
       if (! sys_path.empty ())
         xpath += dir_path::path_sep_str () + sys_path;
     }
   else
     xpath = sys_path;
 
-  do_set (xpath, false);
+  do_set (xpath, false, true);
 }
 
 void
-load_path::do_clear (void)
+load_path::do_clear (std::set<std::string>& new_elts)
 {
-  dir_info_list.clear ();
+  bool warn_default_path_clobbered = false;
+  for (dir_info_list_iterator i = dir_info_list.begin();
+       i != dir_info_list.end();
+       /* conditionally advance iterator in loop body */)
+    {
+      //Don't remove it if it's gonna be added again, but remove it from
+      //list of items to add, to avoid duplicates later on
+      std::set<std::string>::iterator j = new_elts.find(i->dir_name);
+      if (j != new_elts.end())
+        {
+          new_elts.erase(j);
+          i++;
+        }
+      else
+        {
+          //Warn if removing a default directory and not immediately adding
+          //it back again
+          if(i->is_init)
+            warn_default_path_clobbered = true;
+          i = dir_info_list.erase(i);
+        }
+    }
+
+  if (warn_default_path_clobbered)
+    warning_with_id ("Octave:remove-init-dir",
+                     "default load path altered.  Some built-in functions may "
+                     "not be found.  Try restoredefaultpath() to recover it.");
+
   fcn_map.clear ();
   private_fcn_map.clear ();
   method_map.clear ();
 }
 
 static std::list<std::string>
 split_path (const std::string& p)
 {
@@ -560,33 +587,34 @@ split_path (const std::string& p)
 
   if (! elt.empty ())
     retval.push_back (elt);
 
   return retval;
 }
 
 void
-load_path::do_set (const std::string& p, bool warn)
+load_path::do_set (const std::string& p, bool warn, bool is_init)
 {
-  std::list<std::string> elts = split_path (p);
+  std::list<std::string> elts_l = split_path (p);
+  std::set<std::string> elts(elts_l.begin(), elts_l.end());
 
   // Temporarily disable add hook.
 
   unwind_protect frame;
   frame.protect_var (add_hook);
 
   add_hook = 0;
 
-  do_clear ();
-
-  for (std::list<std::string>::const_iterator i = elts.begin ();
+  do_clear (elts);
+
+  for (std::set<std::string>::const_iterator i = elts.begin ();
        i != elts.end ();
        i++)
-    do_append (*i, warn);
+    do_append (*i, warn, is_init);
 
   // Restore add hook and execute for all newly added directories.
   frame.run_top ();
 
   for (dir_info_list_iterator i = dir_info_list.begin ();
        i != dir_info_list.end ();
        i++)
     {
@@ -594,20 +622,20 @@ load_path::do_set (const std::string& p,
         add_hook (i->dir_name);
     }
 
   // Always prepend current directory.
   do_prepend (".", warn);
 }
 
 void
-load_path::do_append (const std::string& dir, bool warn)
+load_path::do_append (const std::string& dir, bool warn, bool is_init)
 {
   if (! dir.empty ())
-    do_add (dir, true, warn);
+    do_add (dir, true, warn, is_init);
 }
 
 void
 load_path::do_prepend (const std::string& dir, bool warn)
 {
   if (! dir.empty ())
     do_add (dir, false, warn);
 }
@@ -626,17 +654,18 @@ strip_trailing_separators (const std::st
 
   if (k < dir.length ())
     dir.resize (k);
 
   return dir;
 }
 
 void
-load_path::do_add (const std::string& dir_arg, bool at_end, bool warn)
+load_path::do_add (const std::string& dir_arg, bool at_end, bool warn,
+                   bool is_init)
 {
   size_t len = dir_arg.length ();
 
   if (len > 1 && dir_arg.substr (len-2) == "//")
     warning_with_id ("Octave:recursive-path-search",
                      "trailing `//' is no longer special in search path elements");
 
   std::string dir = file_ops::tilde_expand (dir_arg);
@@ -651,16 +680,17 @@ load_path::do_add (const std::string& di
     {
       file_stat fs (dir);
 
       if (fs)
         {
           if (fs.is_dir ())
             {
               dir_info di (dir);
+              di.is_init = is_init;
 
               if (! error_state)
                 {
                   if (at_end)
                     dir_info_list.push_back (di);
                   else
                     dir_info_list.push_front (di);
 
@@ -2132,17 +2162,17 @@ Add @var{dir1}, @dots{} to the current f
 directory name to the current path.  If @var{option} is \"-end\"\n\
 or 1, append the directory name to the current path.\n\
 Directories added to the path must exist.\n\
 \n\
 In addition to accepting individual directory arguments, lists of\n\
 directory names separated by @code{pathsep} are also accepted.  For example:\n\
 \n\
 @example\n\
-addpath (\"dir1:/dir2:~/dir3\");\n\
+addpath (\"dir1:/dir2:~/dir3\")\n\
 @end example\n\
 @seealso{path, rmpath, genpath, pathdef, savepath, pathsep}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   // Originally written by Bill Denney and Etienne Grossman.  Heavily
   // modified and translated to C++ by jwe.
@@ -2243,17 +2273,17 @@ DEFUN (rmpath, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} rmpath (@var{dir1}, @dots{})\n\
 Remove @var{dir1}, @dots{} from the current function search path.\n\
 \n\
 In addition to accepting individual directory arguments, lists of\n\
 directory names separated by @code{pathsep} are also accepted.  For example:\n\
 \n\
 @example\n\
-rmpath (\"dir1:/dir2:~/dir3\");\n\
+rmpath (\"dir1:/dir2:~/dir3\")\n\
 @end example\n\
 @seealso{path, addpath, genpath, pathdef, savepath, pathsep}\n\
 @end deftypefn")
 {
   // Originally by Etienne Grossmann. Heavily modified and translated
   // to C++ by jwe.
 
   octave_value retval;
diff --git a/src/load-path.h b/src/load-path.h
--- a/src/load-path.h
+++ b/src/load-path.h
@@ -51,17 +51,20 @@ public:
   {
     if (instance_ok ())
       instance->do_initialize (set_initial_path);
   }
 
   static void clear (void)
   {
     if (instance_ok ())
-      instance->do_clear ();
+      {
+        std::set<std::string> no_new_elts;
+        instance->do_clear (no_new_elts);
+      }
   }
 
   static void set (const std::string& p, bool warn = false)
   {
     if (instance_ok ())
       instance->do_set (p, warn);
   }
 
@@ -289,62 +292,65 @@ private:
     typedef method_file_map_type::const_iterator const_method_file_map_iterator;
     typedef method_file_map_type::iterator method_file_map_iterator;
 
     // This default constructor is only provided so we can create a
     // std::map of dir_info objects.  You should not use this
     // constructor for any other purpose.
     dir_info (void)
       : dir_name (), abs_dir_name (), is_relative (false),
-        dir_mtime (), dir_time_last_checked (), all_files (),
-        fcn_files (), private_file_map (), method_file_map ()
+        is_init(false), dir_mtime (), dir_time_last_checked (),
+        all_files (), fcn_files (), private_file_map (), method_file_map ()
       { }
 
     dir_info (const std::string& d)
       : dir_name (d), abs_dir_name (), is_relative (false),
-        dir_mtime (), dir_time_last_checked (), all_files (),
-        fcn_files (), private_file_map (), method_file_map ()
+        is_init(false), dir_mtime (), dir_time_last_checked (),
+        all_files (), fcn_files (), private_file_map (), method_file_map ()
     {
       initialize ();
     }
 
     dir_info (const dir_info& di)
       : dir_name (di.dir_name), abs_dir_name (di.abs_dir_name),
         is_relative (di.is_relative),
+        is_init (di.is_init),
         dir_mtime (di.dir_mtime),
         dir_time_last_checked (di.dir_time_last_checked),
         all_files (di.all_files), fcn_files (di.fcn_files),
         private_file_map (di.private_file_map),
         method_file_map (di.method_file_map) { }
 
     ~dir_info (void) { }
 
     dir_info& operator = (const dir_info& di)
     {
       if (&di != this)
         {
           dir_name = di.dir_name;
           abs_dir_name = di.abs_dir_name;
           is_relative = di.is_relative;
+          is_init = di.is_init;
           dir_mtime = di.dir_mtime;
           dir_time_last_checked = di.dir_time_last_checked;
           all_files = di.all_files;
           fcn_files = di.fcn_files;
           private_file_map = di.private_file_map;
           method_file_map = di.method_file_map;
         }
 
       return *this;
     }
 
     void update (void);
 
     std::string dir_name;
     std::string abs_dir_name;
     bool is_relative;
+    bool is_init; //Was this directory set by init? Warn when clearing it.
     octave_time dir_mtime;
     octave_time dir_time_last_checked;
     string_vector all_files;
     string_vector fcn_files;
     fcn_file_map_type private_file_map;
     method_file_map_type method_file_map;
 
   private:
@@ -466,25 +472,26 @@ private:
                      const string_vector& fcn_files, bool at_end);
 
   void move_method_map (const std::string& dir, bool at_end);
 
   void move (std::list<dir_info>::iterator i, bool at_end);
 
   void do_initialize (bool set_initial_path);
 
-  void do_clear (void);
+  void do_clear (std::set<std::string>& new_elts);
 
-  void do_set (const std::string& p, bool warn);
+  void do_set (const std::string& p, bool warn, bool is_init=false);
 
-  void do_append (const std::string& dir, bool warn);
+  void do_append (const std::string& dir, bool warn, bool is_init=false);
 
   void do_prepend (const std::string& dir, bool warn);
 
-  void do_add (const std::string& dir, bool at_end, bool warn);
+  void do_add (const std::string& dir, bool at_end, bool warn,
+               bool is_init=false);
 
   void remove_fcn_map (const std::string& dir, const string_vector& fcn_files);
 
   void remove_private_fcn_map (const std::string& dir);
 
   void remove_method_map (const std::string& dir);
 
   bool do_remove (const std::string& dir);
diff --git a/src/load-save.cc b/src/load-save.cc
--- a/src/load-save.cc
+++ b/src/load-save.cc
@@ -644,17 +644,17 @@ Force Octave to assume the file is in Oc
 
   if (error_state)
     return retval;
 
   int i = 1;
   std::string orig_fname = "";
 
   // Function called with Matlab-style ["filename", options] syntax
-  if (argc > 1 && argv[1].at(0) != '-')
+  if (argc > 1 && ! argv[1].empty () && argv[1].at(0) != '-')
     {
       orig_fname = argv[1];
       i++;
     }
 
   // It isn't necessary to have the default load format stored in a
   // user preference variable since we can determine the type of file
   // as we are reading.
@@ -1527,16 +1527,17 @@ Use the gzip algorithm to compress the f
 that are compressed with gzip outside of octave, and gzip can equally be\n\
 used to convert the files for backward compatibility.\n\
 This option is only available if Octave was built with a link to the zlib\n\
 libraries.\n\
 @end table\n\
 \n\
 The list of variables to save may use wildcard patterns containing\n\
 the following special characters:\n\
+\n\
 @table @code\n\
 @item ?\n\
 Match any single character.\n\
 \n\
 @item *\n\
 Match zero or more characters.\n\
 \n\
 @item [ @var{list} ]\n\
diff --git a/src/mappers.cc b/src/mappers.cc
--- a/src/mappers.cc
+++ b/src/mappers.cc
@@ -381,17 +381,17 @@ DEFUN (ceil, args, ,
 @deftypefn {Mapping Function} {} ceil (@var{x})\n\
 Return the smallest integer not less than @var{x}.  This is equivalent to\n\
 rounding towards positive infinity.  If @var{x} is\n\
 complex, return @code{ceil (real (@var{x})) + ceil (imag (@var{x})) * I}.\n\
 \n\
 @example\n\
 @group\n\
 ceil ([-2.7, 2.7])\n\
-   @result{}  -2   3\n\
+    @result{} -2    3\n\
 @end group\n\
 @end example\n\
 @seealso{floor, round, fix}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
     retval = args(0).ceil ();
@@ -537,18 +537,18 @@ Compute the error function,\n\
 @ifnottex\n\
 \n\
 @example\n\
 @group\n\
 @c spacing appears odd here, but is correct after Makeinfo\n\
                           z\n\
                          /\n\
 erf (z) = (2/sqrt (pi)) | e^(-t^2) dt\n\
-                         /\n\
-                      t=0\n\
+                        /\n\
+                     t=0\n\
 @end group\n\
 @end example\n\
 \n\
 @end ifnottex\n\
 @seealso{erfc, erfcx, erfinv}\n\
 @end deftypefn")
 {
   octave_value retval;
@@ -590,17 +590,17 @@ erf (z) = (2/sqrt (pi)) | e^(-t^2) dt\n\
 */
 
 DEFUN (erfinv, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} erfinv (@var{x})\n\
 Compute the inverse error function, i.e., @var{y} such that\n\
 \n\
 @example\n\
-  erf (@var{y}) == @var{x}\n\
+erf (@var{y}) == @var{x}\n\
 @end example\n\
 @seealso{erf, erfc, erfcx}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
     retval = args(0).erfinv ();
   else
@@ -807,17 +807,17 @@ DEFUN (fix, args, ,
 @deftypefn {Mapping Function} {} fix (@var{x})\n\
 Truncate fractional portion of @var{x} and return the integer portion.  This\n\
 is equivalent to rounding towards zero.  If @var{x} is complex, return\n\
 @code{fix (real (@var{x})) + fix (imag (@var{x})) * I}.\n\
 \n\
 @example\n\
 @group\n\
 fix ([-2.7, 2.7])\n\
-   @result{} -2   2\n\
+   @result{} -2    2\n\
 @end group\n\
 @end example\n\
 @seealso{ceil, floor, round}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
     retval = args(0).fix ();
@@ -842,17 +842,17 @@ DEFUN (floor, args, ,
 @deftypefn {Mapping Function} {} floor (@var{x})\n\
 Return the largest integer not greater than @var{x}.  This is equivalent to\n\
 rounding towards negative infinity.  If @var{x} is\n\
 complex, return @code{floor (real (@var{x})) + floor (imag (@var{x})) * I}.\n\
 \n\
 @example\n\
 @group\n\
 floor ([-2.7, 2.7])\n\
-     @result{} -3   2\n\
+     @result{} -3    2\n\
 @end group\n\
 @end example\n\
 @seealso{ceil, round, fix}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
     retval = args(0).floor ();
@@ -884,18 +884,18 @@ Compute the Gamma function,\n\
 @ifnottex\n\
 \n\
 @example\n\
 @group\n\
 @c spacing appears odd here, but is correct after Makeinfo\n\
               infinity\n\
              /\n\
 gamma (z) = | t^(z-1) exp (-t) dt.\n\
-             /\n\
-          t=0\n\
+            /\n\
+         t=0\n\
 @end group\n\
 @end example\n\
 \n\
 @end ifnottex\n\
 @seealso{gammainc, lgamma}\n\
 @end deftypefn")
 {
   octave_value retval;
@@ -1117,17 +1117,17 @@ DEFUN (isinf, args, ,
 @deftypefn {Mapping Function} {} isinf (@var{x})\n\
 Return a logical array which is true where the elements of @var{x} are\n\
 are infinite and false where they are not.\n\
 For example:\n\
 \n\
 @example\n\
 @group\n\
 isinf ([13, Inf, NA, NaN])\n\
-     @result{} [ 0, 1, 0, 0 ]\n\
+      @result{} [ 0, 1, 0, 0 ]\n\
 @end group\n\
 @end example\n\
 @seealso{isfinite, isnan, isna}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
     retval = args(0).isinf ();
@@ -1258,17 +1258,17 @@ DEFUN (isnan, args, ,
 @deftypefn {Mapping Function} {} isnan (@var{x})\n\
 Return a logical array which is true where the elements of @var{x} are\n\
 NaN values and false where they are not.\n\
 NA values are also considered NaN values.  For example:\n\
 \n\
 @example\n\
 @group\n\
 isnan ([13, Inf, NA, NaN])\n\
-     @result{} [ 0, 0, 1, 1 ]\n\
+      @result{} [ 0, 0, 1, 1 ]\n\
 @end group\n\
 @end example\n\
 @seealso{isna, isinf, isfinite}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
     retval = args(0).isnan ();
@@ -1614,17 +1614,17 @@ DEFUN (round, args, ,
 @deftypefn {Mapping Function} {} round (@var{x})\n\
 Return the integer nearest to @var{x}.  If @var{x} is complex, return\n\
 @code{round (real (@var{x})) + round (imag (@var{x})) * I}.  If there\n\
 are two nearest integers, return the one further away from zero.\n\
 \n\
 @example\n\
 @group\n\
 round ([-2.7, 2.7])\n\
-     @result{} -3   3\n\
+     @result{} -3    3\n\
 @end group\n\
 @end example\n\
 @seealso{ceil, floor, fix, roundb}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
     retval = args(0).round ();
@@ -1951,17 +1951,17 @@ DEFUNX ("tolower", Ftolower, args, ,
 @deftypefnx {Mapping Function} {} lower (@var{s})\n\
 Return a copy of the string or cell string @var{s}, with each uppercase\n\
 character replaced by the corresponding lowercase one; non-alphabetic\n\
 characters are left unchanged.  For example:\n\
 \n\
 @example\n\
 @group\n\
 tolower (\"MiXeD cAsE 123\")\n\
-     @result{} \"mixed case 123\"\n\
+      @result{} \"mixed case 123\"\n\
 @end group\n\
 @end example\n\
 @seealso{toupper}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
     retval = args(0).xtolower ();
@@ -2002,17 +2002,17 @@ DEFUNX ("toupper", Ftoupper, args, ,
 @deftypefnx {Mapping Function} {} upper (@var{s})\n\
 Return a copy of the string or cell string @var{s}, with each lowercase\n\
 character replaced by the corresponding uppercase one; non-alphabetic\n\
 characters are left unchanged.  For example:\n\
 \n\
 @example\n\
 @group\n\
 toupper (\"MiXeD cAsE 123\")\n\
-     @result{} \"MIXED CASE 123\"\n\
+      @result{} \"MIXED CASE 123\"\n\
 @end group\n\
 @end example\n\
 @seealso{tolower}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
     retval = args(0).xtoupper ();
diff --git a/src/oct-parse.yy b/src/oct-parse.yy
--- a/src/oct-parse.yy
+++ b/src/oct-parse.yy
@@ -63,16 +63,17 @@ along with Octave; see the file COPYING.
 #include "oct-hist.h"
 #include "oct-map.h"
 #include "ov-fcn-handle.h"
 #include "ov-usr-fcn.h"
 #include "ov-null-mat.h"
 #include "toplev.h"
 #include "pager.h"
 #include "parse.h"
+#include "parse-private.h"
 #include "pt-all.h"
 #include "pt-eval.h"
 #include "symtab.h"
 #include "token.h"
 #include "unwind-prot.h"
 #include "utils.h"
 #include "variables.h"
 
@@ -121,17 +122,17 @@ static int max_function_depth = 0;
 // FALSE if we are still at the primary function. Subfunctions can
 // only be declared inside function files.
 static int parsing_subfunctions = false;
 
 // Have we found an explicit end to a function?
 static bool endfunction_found = false;
 
 // Keep track of symbol table information when parsing functions.
-std::stack<symbol_table::scope_id> symtab_context;
+symtab_context parser_symtab_context;
 
 // Name of the current class when we are parsing class methods or
 // constructors.
 std::string current_class_name;
 
 // TRUE means we are in the process of autoloading a function.
 static bool autoloading = false;
 
@@ -360,21 +361,18 @@ make_statement (T *arg)
   return new tree_statement (arg, comment);
 }
 
 #define ABORT_PARSE \
   do \
     { \
       global_command = 0; \
       yyerrok; \
-      if (! symtab_context.empty ()) \
-        { \
-          symbol_table::set_scope (symtab_context.top ()); \
-          symtab_context.pop (); \
-        } \
+      if (! parser_symtab_context.empty ()) \
+        parser_symtab_context.pop (); \
       if (interactive || forced_interactive) \
         YYACCEPT; \
       else \
         YYABORT; \
     } \
   while (0)
 
 %}
@@ -441,17 +439,17 @@ make_statement (T *arg)
 %token <tok_val> END
 %token <tok_val> DQ_STRING SQ_STRING
 %token <tok_val> FOR PARFOR WHILE DO UNTIL
 %token <tok_val> IF ELSEIF ELSE
 %token <tok_val> SWITCH CASE OTHERWISE
 %token <tok_val> BREAK CONTINUE FUNC_RET
 %token <tok_val> UNWIND CLEANUP
 %token <tok_val> TRY CATCH
-%token <tok_val> GLOBAL STATIC
+%token <tok_val> GLOBAL PERSISTENT
 %token <tok_val> FCN_HANDLE
 %token <tok_val> PROPERTIES METHODS EVENTS ENUMERATION
 %token <tok_val> METAQUERY
 %token <tok_val> SUPERCLASSREF
 %token <tok_val> GET SET
 
 // Other tokens.
 %token END_OF_INPUT LEXICAL_ERROR
@@ -992,19 +990,19 @@ parsing_decl_list
                 : // empty
                   { lexer_flags.looking_at_decl_list = true; }
 
 declaration     : GLOBAL parsing_decl_list decl1
                   {
                     $$ = make_decl_command (GLOBAL, $1, $3);
                     lexer_flags.looking_at_decl_list = false;
                   }
-                | STATIC parsing_decl_list decl1
+                | PERSISTENT parsing_decl_list decl1
                   {
-                    $$ = make_decl_command (STATIC, $1, $3);
+                    $$ = make_decl_command (PERSISTENT, $1, $3);
                     lexer_flags.looking_at_decl_list = false;
                   }
                 ;
 
 decl1           : decl2
                   { $$ = new tree_decl_init_list ($1); }
                 | decl1 decl2
                   {
@@ -1219,17 +1217,18 @@ except_command  : UNWIND stash_comment o
 
 push_fcn_symtab : // empty
                   {
                     current_function_depth++;
 
                     if (max_function_depth < current_function_depth)
                       max_function_depth = current_function_depth;
 
-                    symtab_context.push (symbol_table::current_scope ());
+                    parser_symtab_context.push ();
+
                     symbol_table::set_scope (symbol_table::alloc_scope ());
 
                     if (! reading_script_file && current_function_depth == 1
                         && ! parsing_subfunctions)
                       primary_fcn_scope = symbol_table::current_scope ();
 
                     if (reading_script_file && current_function_depth > 1)
                       yyerror ("nested functions not implemented in this context");
@@ -1241,17 +1240,17 @@ push_fcn_symtab : // empty
 // ===========================
 
 param_list_beg  : '('
                   {
                     lexer_flags.looking_at_parameter_list = true;
 
                     if (lexer_flags.looking_at_function_handle)
                       {
-                        symtab_context.push (symbol_table::current_scope ());
+                        parser_symtab_context.push ();
                         symbol_table::set_scope (symbol_table::alloc_scope ());
                         lexer_flags.looking_at_function_handle--;
                         lexer_flags.looking_at_anon_fcn_args = true;
                       }
                   }
                 ;
 
 param_list_end  : ')'
@@ -1390,21 +1389,23 @@ fcn_name        : identifier
 
                     lexer_flags.parsed_function_name.top () = true;
                     lexer_flags.maybe_classdef_get_set_method = false;
 
                     $$ = $1;
                   }
                 | GET '.' identifier
                   {
+                    lexer_flags.parsed_function_name.top () = true;
                     lexer_flags.maybe_classdef_get_set_method = false;
                     $$ = $3;
                   }
                 | SET '.' identifier
                   {
+                    lexer_flags.parsed_function_name.top () = true;
                     lexer_flags.maybe_classdef_get_set_method = false;
                     $$ = $3;
                   }
                 ;
 
 function1       : fcn_name function2
                   {
                     std::string fname = $1->name ();
@@ -2117,22 +2118,20 @@ make_anon_fcn_handle (tree_parameter_lis
   // FIXME -- need to get these from the location of the @ symbol.
   int l = input_line_number;
   int c = current_input_column;
 
   tree_parameter_list *ret_list = 0;
 
   symbol_table::scope_id fcn_scope = symbol_table::current_scope ();
 
-  if (symtab_context.empty ())
+  if (parser_symtab_context.empty ())
     panic_impossible ();
 
-  symbol_table::set_scope (symtab_context.top ());
-
-  symtab_context.pop ();
+  parser_symtab_context.pop ();
 
   stmt->set_print_flag (false);
 
   tree_statement_list *body = new tree_statement_list (stmt);
 
   body->mark_as_anon_function_body ();
 
   tree_anon_fcn_handle *retval
@@ -2965,21 +2964,20 @@ finish_function (tree_parameter_list *re
     }
 
   return retval;
 }
 
 static void
 recover_from_parsing_function (void)
 {
-  if (symtab_context.empty ())
+  if (parser_symtab_context.empty ())
     panic_impossible ();
 
-  symbol_table::set_scope (symtab_context.top ());
-  symtab_context.pop ();
+  parser_symtab_context.pop ();
 
   if (reading_fcn_file && current_function_depth == 1
       && ! parsing_subfunctions)
     parsing_subfunctions = true;
 
   current_function_depth--;
 
   lexer_flags.defining_func--;
@@ -3084,19 +3082,19 @@ make_decl_command (int tok, token *tok_v
   int c = tok_val->column ();
 
   switch (tok)
     {
     case GLOBAL:
       retval = new tree_global_command (lst, l, c);
       break;
 
-    case STATIC:
+    case PERSISTENT:
       if (current_function_depth > 0)
-        retval = new tree_static_command (lst, l, c);
+        retval = new tree_persistent_command (lst, l, c);
       else
         {
           if (reading_script_file)
             warning ("ignoring persistent declaration near line %d of file `%s'",
                      l, curr_fcn_file_full_name.c_str ());
           else
             warning ("ignoring persistent declaration near line %d", l);
         }
@@ -3510,17 +3508,21 @@ parse_fcn_file (const std::string& ff, c
           else if (! force_script && looking_at_classdef_keyword (ffile))
             {
               file_type = "classdef";
 
               Vecho_executing_commands = ECHO_OFF;
 
               reading_classdef_file = true;
               reading_fcn_file = false;
-              reading_script_file = false;
+              // FIXME -- Should classdef files be handled as
+              // scripts or separately?  Currently, without setting up
+              // for reading script files, parsing classdef files
+              // fails.
+              reading_script_file = true;
             }
           else
             {
               file_type = "script";
 
               Vecho_executing_commands = ECHO_OFF;
 
               reading_classdef_file = false;
@@ -4212,19 +4214,19 @@ any sort (@pxref{Function Handles}).  Hi
 the only way to call user-supplied functions in strings, but\n\
 function handles are now preferred due to the cleaner syntax they\n\
 offer.  For example,\n\
 \n\
 @example\n\
 @group\n\
 @var{f} = @@exp;\n\
 feval (@var{f}, 1)\n\
-     @result{} 2.7183\n\
+    @result{} 2.7183\n\
 @var{f} (1)\n\
-     @result{} 2.7183\n\
+    @result{} 2.7183\n\
 @end group\n\
 @end example\n\
 \n\
 @noindent\n\
 are equivalent ways to call the function referred to by @var{f}.  If it\n\
 cannot be predicted beforehand that @var{f} is a function handle or the\n\
 function name in a string, @code{feval} can be used instead.\n\
 @end deftypefn")
@@ -4452,17 +4454,17 @@ Parse the string @var{try} and evaluate 
 program.  If that fails, evaluate the optional string @var{catch}.\n\
 The string @var{try} is evaluated in the current context,\n\
 so any results remain available after @code{eval} returns.\n\
 \n\
 The following example makes the variable @var{a} with the approximate\n\
 value 3.1416 available.\n\
 \n\
 @example\n\
-eval(\"a = acos(-1);\");\n\
+eval (\"a = acos(-1);\");\n\
 @end example\n\
 \n\
 If an error occurs during the evaluation of @var{try} the @var{catch}\n\
 string is evaluated, as the following example shows:\n\
 \n\
 @example\n\
 @group\n\
 eval ('error (\"This is a bad example\");',\n\
diff --git a/src/octave.gperf b/src/octave.gperf
--- a/src/octave.gperf
+++ b/src/octave.gperf
@@ -55,16 +55,17 @@ enum octave_kw_id
   get_kw,
   global_kw,
   if_kw,
   magic_file_kw,
   magic_line_kw,
   methods_kw,
   otherwise_kw,
   parfor_kw,
+  persistent_kw,
   properties_kw,
   return_kw,
   set_kw,
   static_kw,
   switch_kw,
   try_kw,
   until_kw,
   unwind_protect_kw,
@@ -101,21 +102,21 @@ events, EVENTS, events_kw
 for, FOR, for_kw
 function, FCN, function_kw
 get, GET, get_kw
 global, GLOBAL, global_kw
 if, IF, if_kw
 methods, METHODS, methods_kw
 otherwise, OTHERWISE, otherwise_kw
 parfor, PARFOR, parfor_kw
-persistent, STATIC, static_kw
+persistent, PERSISTENT, persistent_kw
 properties, PROPERTIES, properties_kw
 return, FUNC_RET, return_kw
 set, SET, set_kw
-static, STATIC, static_kw
+static, PERSISTENT, static_kw
 switch, SWITCH, switch_kw
 try, TRY, try_kw
 until, UNTIL, until_kw
 unwind_protect, UNWIND, unwind_protect_kw
 unwind_protect_cleanup, CLEANUP, unwind_protect_cleanup_kw
 while, WHILE, while_kw
 __FILE__, DQ_STRING, magic_file_kw
 __LINE__, NUM, magic_line_kw
diff --git a/src/ov-base.cc b/src/ov-base.cc
--- a/src/ov-base.cc
+++ b/src/ov-base.cc
@@ -1533,21 +1533,21 @@ DEFUN (sparse_auto_mutate, args, nargout
 @deftypefnx {Built-in Function} {} sparse_auto_mutate (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls whether Octave will\n\
 automatically mutate sparse matrices to full matrices to save memory.\n\
 For example:\n\
 \n\
 @example\n\
 @group\n\
 s = speye (3);\n\
-sparse_auto_mutate (false)\n\
+sparse_auto_mutate (false);\n\
 s(:, 1) = 1;\n\
 typeinfo (s)\n\
 @result{} sparse matrix\n\
-sparse_auto_mutate (true)\n\
+sparse_auto_mutate (true);\n\
 s(1, :) = 1;\n\
 typeinfo (s)\n\
 @result{} matrix\n\
 @end group\n\
 @end example\n\
 \n\
 When called from inside a function with the \"local\" option, the variable is\n\
 changed locally for the function and any subroutines it calls.  The original\n\
diff --git a/src/ov-cell.cc b/src/ov-cell.cc
--- a/src/ov-cell.cc
+++ b/src/ov-cell.cc
@@ -1390,34 +1390,34 @@ DEFUN (struct2cell, args, ,
 @deftypefn {Built-in Function} {} struct2cell (@var{S})\n\
 Create a new cell array from the objects stored in the struct object.\n\
 If @var{f} is the number of fields in the structure, the resulting\n\
 cell array will have a dimension vector corresponding to\n\
 @code{[@var{F} size(@var{S})]}.  For example:\n\
 \n\
 @example\n\
 @group\n\
-  s = struct('name', @{'Peter', 'Hannah', 'Robert'@},\n\
-             'age', @{23, 16, 3@});\n\
-  c = struct2cell(s)\n\
-     @result{} c = @{1x1x3 Cell Array@}\n\
-  c(1,1,:)(:)\n\
-     @result{} ans =\n\
-        @{\n\
-          [1,1] = Peter\n\
-          [2,1] = Hannah\n\
-          [3,1] = Robert\n\
-        @}\n\
-  c(2,1,:)(:)\n\
-     @result{} ans =\n\
-        @{\n\
-          [1,1] = 23\n\
-          [2,1] = 16\n\
-          [3,1] = 3\n\
-        @}\n\
+s = struct (\"name\", @{\"Peter\", \"Hannah\", \"Robert\"@},\n\
+           \"age\", @{23, 16, 3@});\n\
+c = struct2cell (s)\n\
+   @result{} c = @{1x1x3 Cell Array@}\n\
+c(1,1,:)(:)\n\
+   @result{}\n\
+      @{\n\
+        [1,1] = Peter\n\
+        [2,1] = Hannah\n\
+        [3,1] = Robert\n\
+      @}\n\
+c(2,1,:)(:)\n\
+   @result{}\n\
+      @{\n\
+        [1,1] = 23\n\
+        [2,1] = 16\n\
+        [3,1] = 3\n\
+      @}\n\
 @end group\n\
 @end example\n\
 \n\
 @seealso{cell2struct, fieldnames}\n\
 @end deftypefn")
 {
   octave_value retval;
 
diff --git a/src/ov-null-mat.cc b/src/ov-null-mat.cc
--- a/src/ov-null-mat.cc
+++ b/src/ov-null-mat.cc
@@ -91,16 +91,17 @@ octave_null_sq_str::numeric_conversion_f
 DEFUN (isnull, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} isnull (@var{x})\n\
 Return true if @var{x} is a special null matrix, string, or single quoted\n\
 string.  Indexed assignment with such a value on the right-hand side should\n\
 delete array elements.  This function should be used when overloading\n\
 indexed assignment for user-defined classes instead of @code{isempty}, to\n\
 distinguish the cases:\n\
+\n\
 @table @asis\n\
 @item @code{A(I) = []}\n\
 This should delete elements if @code{I} is nonempty.\n\
 \n\
 @item @code{X = []; A(I) = X}\n\
 This should give an error if @code{I} is nonempty.\n\
 @end table\n\
 @seealso{isempty, isindex}\n\
diff --git a/src/ov-struct.cc b/src/ov-struct.cc
--- a/src/ov-struct.cc
+++ b/src/ov-struct.cc
@@ -2028,25 +2028,25 @@ DEFUN (cell2struct, args, ,
 @deftypefn {Built-in Function} {} cell2struct (@var{cell}, @var{fields}, @var{dim})\n\
 Convert @var{cell} to a structure.  The number of fields in @var{fields}\n\
 must match the number of elements in @var{cell} along dimension @var{dim},\n\
 that is @code{numel (@var{fields}) == size (@var{cell}, @var{dim})}.\n\
 If @var{dim} is omitted, a value of 1 is assumed.\n\
 \n\
 @example\n\
 @group\n\
-A = cell2struct (@{'Peter', 'Hannah', 'Robert';\n\
+A = cell2struct (@{\"Peter\", \"Hannah\", \"Robert\";\n\
                    185, 170, 168@},\n\
-                 @{'Name','Height'@}, 1);\n\
+                 @{\"Name\",\"Height\"@}, 1);\n\
 A(1)\n\
-     @result{} ans =\n\
-        @{\n\
-          Name   = Peter\n\
-          Height = 185\n\
-        @}\n\
+   @result{}\n\
+      @{\n\
+        Name   = Peter\n\
+        Height = 185\n\
+      @}\n\
 \n\
 @end group\n\
 @end example\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
diff --git a/src/ov-usr-fcn.cc b/src/ov-usr-fcn.cc
--- a/src/ov-usr-fcn.cc
+++ b/src/ov-usr-fcn.cc
@@ -382,20 +382,22 @@ octave_user_function::do_multi_index_op 
     {
       ::error ("max_recursion_depth exceeded");
       return retval;
     }
 
   // Save old and set current symbol table context, for
   // eval_undefined_error().
 
-  octave_call_stack::push (this, local_scope, call_depth);
+  int context = is_anonymous_function () ? 0 : call_depth;
+
+  octave_call_stack::push (this, local_scope, context);
   frame.add_fcn (octave_call_stack::pop);
 
-  if (call_depth > 0)
+  if (call_depth > 0 && ! is_anonymous_function ())
     {
       symbol_table::push_context ();
 
       frame.add_fcn (symbol_table::pop_context);
     }
 
   string_vector arg_names = args.name_tags ();
 
@@ -695,17 +697,17 @@ This feature does not work on builtin fu
 
 DEFUN (nargout, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} nargout ()\n\
 @deftypefnx {Built-in Function} {} nargout (@var{fcn})\n\
 Within a function, return the number of values the caller expects to\n\
 receive.  If called with the optional argument @var{fcn}, a function\n\
 name or handle, return the number of declared output values that the\n\
-function can produce. If the final output argument is @var{varargout}\n\
+function can produce.  If the final output argument is @var{varargout}\n\
 the returned value is negative.\n\
 \n\
 For example,\n\
 \n\
 @example\n\
 f ()\n\
 @end example\n\
 \n\
@@ -721,22 +723,24 @@ will cause @code{nargout} to return 2 in
 @code{f}.\n\
 \n\
 In the second usage,\n\
 \n\
 @example\n\
 nargout (@@histc) \% or nargout ('histc')\n\
 @end example\n\
 \n\
+@noindent\n\
 will return 2, because @code{histc} has two outputs, whereas\n\
 \n\
 @example\n\
 nargout (@@deal)\n\
 @end example\n\
 \n\
+@noindent\n\
 will return -1, because @code{deal} has a variable number of outputs.\n\
 \n\
 At the top level, @code{nargout} with no argument is undefined.\n\
 @code{nargout} does not work on builtin functions.\n\
 @code{nargout} returns -1 for all anonymous functions.\n\
 @seealso{nargin, varargin, isargout, varargout, nthargout}\n\
 @end deftypefn")
 {
diff --git a/src/ov.cc b/src/ov.cc
--- a/src/ov.cc
+++ b/src/ov.cc
@@ -2806,22 +2806,22 @@ The @samp{subs} field may be either @sam
 of index values.\n\
 \n\
 The following example shows how to extract the two first columns of\n\
 a matrix\n\
 \n\
 @example\n\
 @group\n\
 val = magic(3)\n\
-     @result{} val = [ 8   1   6\n\
-                3   5   7\n\
-                4   9   2 ]\n\
+    @result{} val = [ 8   1   6\n\
+               3   5   7\n\
+               4   9   2 ]\n\
 idx.type = \"()\";\n\
 idx.subs = @{\":\", 1:2@};\n\
-subsref(val, idx)\n\
+subsref (val, idx)\n\
      @result{} [ 8   1\n\
           3   5\n\
           4   9 ]\n\
 @end group\n\
 @end example\n\
 \n\
 @noindent\n\
 Note that this is the same as writing @code{val(:,1:2)}.\n\
@@ -2868,23 +2868,23 @@ are @samp{\"()\"}, @samp{\"@{@}\"}, and 
 The @samp{subs} field may be either @samp{\":\"} or a cell array\n\
 of index values.\n\
 \n\
 The following example shows how to set the two first columns of a\n\
 3-by-3 matrix to zero.\n\
 \n\
 @example\n\
 @group\n\
-val = magic(3);\n\
+val = magic (3);\n\
 idx.type = \"()\";\n\
 idx.subs = @{\":\", 1:2@};\n\
 subsasgn (val, idx, 0)\n\
-     @result{} [ 0   0   6\n\
-          0   0   7\n\
-          0   0   2 ]\n\
+     @result{}  [ 0   0   6\n\
+           0   0   7\n\
+           0   0   2 ]\n\
 @end group\n\
 @end example\n\
 \n\
 Note that this is the same as writing @code{val(:,1:2) = 0}.\n\
 \n\
 If @var{idx} is an empty structure array with fields @samp{type}\n\
 and @samp{subs}, return @var{rhs}.\n\
 @seealso{subsref, substruct}\n\
diff --git a/src/parse-private.h b/src/parse-private.h
new file mode 100644
--- /dev/null
+++ b/src/parse-private.h
@@ -0,0 +1,96 @@
+/*
+
+Copyright (C) 2012 John W. Eaton
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 3 of the License, or (at your
+option) any later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, see
+<http://www.gnu.org/licenses/>.
+
+*/
+
+#if !defined (octave_parse_private_h)
+#define octave_parse_private_h 1
+
+#include <stack>
+
+#include "symtab.h"
+
+// Keep track of symbol table information when parsing functions.
+class symtab_context
+{
+private:
+
+  class frame
+  {
+  public:
+    frame (symbol_table::scope_id s, symbol_table::scope_id c)
+      : m_scope (s), m_context (c) { }
+
+    frame (const frame& f) : m_scope (f.m_scope), m_context (f.m_context) { }
+
+    frame& operator = (const frame& f)
+    {
+      if (&f != this)
+        {
+          m_scope = f.m_scope;
+          m_context = f.m_context;
+        }
+
+      return *this;
+    }
+
+    ~frame (void) { }
+
+    symbol_table::scope_id scope (void) const { return m_scope; }
+    symbol_table::scope_id context (void) const { return m_context; }
+
+  private:
+
+    symbol_table::scope_id m_scope;
+    symbol_table::scope_id m_context;
+  };
+
+  std::stack<frame> frame_stack;
+
+public:
+  symtab_context (void) : frame_stack () { }
+
+  void clear (void)
+  {
+    while (! frame_stack.empty ())
+      frame_stack.pop ();
+  }
+
+  bool empty (void) const { return frame_stack.empty (); }
+
+  void pop (void)
+  {
+    frame tmp = frame_stack.top ();
+
+    symbol_table::set_scope_and_context (tmp.scope (), tmp.context ());
+
+    frame_stack.pop ();
+  }
+
+  void push (void)
+  {
+    frame_stack.push (frame (symbol_table::current_scope (),
+                             symbol_table::current_context ()));
+  }
+};
+
+extern symtab_context parser_symtab_context;
+
+#endif
diff --git a/src/parse.h b/src/parse.h
--- a/src/parse.h
+++ b/src/parse.h
@@ -57,19 +57,16 @@ extern std::stack<std::string> help_buf;
 extern bool line_editing;
 
 // TRUE means we printed messages about reading startup files.
 extern bool reading_startup_message_printed;
 
 // TRUE means input is coming from startup file.
 extern bool input_from_startup_file;
 
-// Keep track of symbol table information when parsing functions.
-extern std::stack<symbol_table::scope_id> symtab_context;
-
 // Name of the current class when we are parsing class methods or
 // constructors.
 extern std::string current_class_name;
 
 extern OCTINTERP_API std::string
 get_help_from_file (const std::string& nm, bool& symbol_found,
                     std::string& file);
 
diff --git a/src/pr-output.cc b/src/pr-output.cc
--- a/src/pr-output.cc
+++ b/src/pr-output.cc
@@ -3371,18 +3371,18 @@ octave_print_internal (std::ostream&, co
 DEFUN (rats, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} rats (@var{x}, @var{len})\n\
 Convert @var{x} into a rational approximation represented as a string.\n\
 You can convert the string back into a matrix as follows:\n\
 \n\
 @example\n\
 @group\n\
-   r = rats(hilb(4));\n\
-   x = str2num(r)\n\
+r = rats (hilb (4));\n\
+x = str2num (r)\n\
 @end group\n\
 @end example\n\
 \n\
 The optional second argument defines the maximum length of the string\n\
 representing the elements of @var{x}.  By default @var{len} is 9.\n\
 @seealso{format, rat}\n\
 @end deftypefn")
 {
diff --git a/src/profiler.cc b/src/profiler.cc
--- a/src/profiler.cc
+++ b/src/profiler.cc
@@ -380,21 +380,21 @@ profile_data_accumulator::get_hierarchic
 
   return retval;
 }
 
 double
 profile_data_accumulator::query_time (void) const
 {
   octave_time now;
-  // FIXME -- this should be removed at some point...  See bug 34210.
-#if defined (__CYGWIN__) || defined (__MINGW32__)
-  volatile
-#endif
-    double dnow = now.double_value ();
+
+  // FIXME -- is this volatile declaration really needed?
+  // See bug #34210 for additional details.
+  volatile double dnow = now.double_value ();
+
   return dnow;
 }
 
 void
 profile_data_accumulator::add_current_time (void)
 {
   const double t = query_time ();
   assert (last_time >= 0.0 && last_time <= t);
diff --git a/src/pt-bp.cc b/src/pt-bp.cc
--- a/src/pt-bp.cc
+++ b/src/pt-bp.cc
@@ -106,17 +106,17 @@ tree_breakpoint::do_decl_command (tree_d
 
 void
 tree_breakpoint::visit_global_command (tree_global_command& cmd)
 {
   do_decl_command (cmd);
 }
 
 void
-tree_breakpoint::visit_static_command (tree_static_command& cmd)
+tree_breakpoint::visit_persistent_command (tree_persistent_command& cmd)
 {
   do_decl_command (cmd);
 }
 
 void
 tree_breakpoint::visit_decl_elt (tree_decl_elt&)
 {
   panic_impossible ();
diff --git a/src/pt-bp.h b/src/pt-bp.h
--- a/src/pt-bp.h
+++ b/src/pt-bp.h
@@ -53,17 +53,17 @@ tree_breakpoint : public tree_walker
   void visit_break_command (tree_break_command&);
 
   void visit_colon_expression (tree_colon_expression&);
 
   void visit_continue_command (tree_continue_command&);
 
   void visit_global_command (tree_global_command&);
 
-  void visit_static_command (tree_static_command&);
+  void visit_persistent_command (tree_persistent_command&);
 
   void visit_decl_elt (tree_decl_elt&);
 
   void visit_decl_init_list (tree_decl_init_list&);
 
   void visit_while_command (tree_while_command&);
 
   void visit_do_until_command (tree_do_until_command&);
diff --git a/src/pt-check.cc b/src/pt-check.cc
--- a/src/pt-check.cc
+++ b/src/pt-check.cc
@@ -100,17 +100,17 @@ tree_checker::do_decl_command (tree_decl
 
 void
 tree_checker::visit_global_command (tree_global_command& cmd)
 {
   do_decl_command (cmd);
 }
 
 void
-tree_checker::visit_static_command (tree_static_command& cmd)
+tree_checker::visit_persistent_command (tree_persistent_command& cmd)
 {
   do_decl_command (cmd);
 }
 
 void
 tree_checker::visit_decl_elt (tree_decl_elt& cmd)
 {
   tree_identifier *id = cmd.ident ();
diff --git a/src/pt-check.h b/src/pt-check.h
--- a/src/pt-check.h
+++ b/src/pt-check.h
@@ -46,17 +46,17 @@ public:
   void visit_break_command (tree_break_command&);
 
   void visit_colon_expression (tree_colon_expression&);
 
   void visit_continue_command(tree_continue_command&);
 
   void visit_global_command (tree_global_command&);
 
-  void visit_static_command (tree_static_command&);
+  void visit_persistent_command (tree_persistent_command&);
 
   void visit_decl_elt (tree_decl_elt&);
 
   void visit_decl_init_list (tree_decl_init_list&);
 
   void visit_simple_for_command (tree_simple_for_command&);
 
   void visit_complex_for_command (tree_complex_for_command&);
diff --git a/src/pt-decl.cc b/src/pt-decl.cc
--- a/src/pt-decl.cc
+++ b/src/pt-decl.cc
@@ -127,21 +127,21 @@ void
 tree_global_command::accept (tree_walker& tw)
 {
   tw.visit_global_command (*this);
 }
 
 // Static.
 
 tree_command *
-tree_static_command::dup (symbol_table::scope_id scope,
+tree_persistent_command::dup (symbol_table::scope_id scope,
                           symbol_table::context_id context) const
 {
   return
-    new tree_static_command (init_list ? init_list->dup (scope, context) : 0,
-                             line (), column ());
+    new tree_persistent_command (init_list ? init_list->dup (scope, context) : 0,
+                                 line (), column ());
 }
 
 void
-tree_static_command::accept (tree_walker& tw)
+tree_persistent_command::accept (tree_walker& tw)
 {
-  tw.visit_static_command (*this);
+  tw.visit_persistent_command (*this);
 }
diff --git a/src/pt-decl.h b/src/pt-decl.h
--- a/src/pt-decl.h
+++ b/src/pt-decl.h
@@ -202,40 +202,40 @@ private:
 
   // No copying!
 
   tree_global_command (const tree_global_command&);
 
   tree_global_command& operator = (const tree_global_command&);
 };
 
-// Static.
+// Persistent.
 
 class
-tree_static_command : public tree_decl_command
+tree_persistent_command : public tree_decl_command
 {
 public:
 
-  tree_static_command (int l = -1, int c = -1)
-    : tree_decl_command ("static", l, c) { }
+  tree_persistent_command (int l = -1, int c = -1)
+    : tree_decl_command ("persistent", l, c) { }
 
-  tree_static_command (tree_decl_init_list *t, int l = -1, int c = -1)
-    : tree_decl_command ("static", t, l, c) { }
+  tree_persistent_command (tree_decl_init_list *t, int l = -1, int c = -1)
+    : tree_decl_command ("persistent", t, l, c) { }
 
-  ~tree_static_command (void) { }
+  ~tree_persistent_command (void) { }
 
   tree_command *dup (symbol_table::scope_id scope,
                      symbol_table::context_id context) const;
 
   void accept (tree_walker& tw);
 
 private:
 
   static void do_init (tree_decl_elt& elt);
 
   // No copying!
 
-  tree_static_command (const tree_static_command&);
+  tree_persistent_command (const tree_persistent_command&);
 
-  tree_static_command& operator = (const tree_static_command&);
+  tree_persistent_command& operator = (const tree_persistent_command&);
 };
 
 #endif
diff --git a/src/pt-eval.cc b/src/pt-eval.cc
--- a/src/pt-eval.cc
+++ b/src/pt-eval.cc
@@ -210,17 +210,17 @@ tree_evaluator::visit_global_command (tr
 {
   if (debug_mode)
     do_breakpoint (cmd.is_breakpoint ());
 
   do_decl_init_list (do_global_init, cmd.initializer_list ());
 }
 
 void
-tree_evaluator::visit_static_command (tree_static_command& cmd)
+tree_evaluator::visit_persistent_command (tree_persistent_command& cmd)
 {
   if (debug_mode)
     do_breakpoint (cmd.is_breakpoint ());
 
   do_decl_init_list (do_static_init, cmd.initializer_list ());
 }
 
 void
diff --git a/src/pt-eval.h b/src/pt-eval.h
--- a/src/pt-eval.h
+++ b/src/pt-eval.h
@@ -55,17 +55,17 @@ public:
   void visit_break_command (tree_break_command&);
 
   void visit_colon_expression (tree_colon_expression&);
 
   void visit_continue_command (tree_continue_command&);
 
   void visit_global_command (tree_global_command&);
 
-  void visit_static_command (tree_static_command&);
+  void visit_persistent_command (tree_persistent_command&);
 
   void visit_decl_elt (tree_decl_elt&);
 
   void visit_decl_init_list (tree_decl_init_list&);
 
   void visit_simple_for_command (tree_simple_for_command&);
 
   void visit_complex_for_command (tree_complex_for_command&);
diff --git a/src/pt-idx.cc b/src/pt-idx.cc
--- a/src/pt-idx.cc
+++ b/src/pt-idx.cc
@@ -172,23 +172,23 @@ make_subs_cell (tree_argument_list *args
         }
     }
 
   return retval;
 }
 
 static inline octave_value_list
 make_value_list (tree_argument_list *args, const string_vector& arg_nm,
-                 const octave_value *object)
+                 const octave_value *object, bool rvalue = true)
 {
   octave_value_list retval;
 
   if (args)
     {
-      if (object && args->has_magic_end () && object->is_undefined ())
+      if (rvalue && object && args->has_magic_end () && object->is_undefined ())
         gripe_invalid_inquiry_subscript ();
       else
         retval = args->convert_to_const_vector (object);
     }
 
   if (! error_state)
     {
       octave_idx_type n = retval.length ();
@@ -471,17 +471,17 @@ tree_index_expression::lvalue (void)
           if (error_state)
             break;
 
           switch (type[i])
             {
             case '(':
               {
                 octave_value_list tidx
-                  = make_value_list (*p_args, *p_arg_nm, &tmp);
+                  = make_value_list (*p_args, *p_arg_nm, &tmp, false);
 
                 idx.push_back (tidx);
 
                 if (i < n - 1)
                   {
                     if (type[i+1] == '.')
                       {
                         tmpidx.push_back (tidx);
@@ -491,17 +491,17 @@ tree_index_expression::lvalue (void)
                       error ("() must be followed by . or close the index chain");
                   }
               }
               break;
 
             case '{':
               {
                 octave_value_list tidx
-                  = make_value_list (*p_args, *p_arg_nm, &tmp);
+                  = make_value_list (*p_args, *p_arg_nm, &tmp, false);
 
                 if (tmp.is_undefined ())
                   {
                     if (tidx.has_magic_colon ())
                       gripe_invalid_inquiry_subscript ();
                     else
                       tmp = Cell ();
                   }
@@ -596,16 +596,28 @@ tree_index_expression::lvalue (void)
 
     }
 
   return retval;
 }
 
 /*
 %!test
+%! clear x
+%! clear y
+%! y = 3;
+%! x(y(end)) = 1;
+%! assert (x, [0, 0, 1]);
+%! clear x
+%! clear y
+%! y = {3};
+%! x(y{end}) = 1;
+%! assert (x, [0, 0, 1]);
+
+%!test
 %! x = {1, 2, 3};
 %! [x{:}] = deal (4, 5, 6);
 %! assert (x, {4, 5, 6});
 
 %!test
 %! [x.a, x.b.c] = deal (1, 2);
 %! assert (x.a == 1 && x.b.c == 2);
 
diff --git a/src/pt-mat.cc b/src/pt-mat.cc
--- a/src/pt-mat.cc
+++ b/src/pt-mat.cc
@@ -1395,19 +1395,19 @@ DEFUN (string_fill_char, args, nargout,
 Query or set the internal variable used to pad all rows of a character\n\
 matrix to the same length.  It must be a single character.  The default\n\
 value is @code{\" \"} (a single space).  For example:\n\
 \n\
 @example\n\
 @group\n\
 string_fill_char (\"X\");\n\
 [ \"these\"; \"are\"; \"strings\" ]\n\
-     @result{} \"theseXX\"\n\
-        \"areXXXX\"\n\
-        \"strings\"\n\
+     @result{}  \"theseXX\"\n\
+         \"areXXXX\"\n\
+         \"strings\"\n\
 @end group\n\
 @end example\n\
 \n\
 When called from inside a function with the \"local\" option, the variable is\n\
 changed locally for the function and any subroutines it calls.  The original\n\
 variable value is restored when exiting the function.\n\
 @end deftypefn")
 {
diff --git a/src/pt-pr-code.cc b/src/pt-pr-code.cc
--- a/src/pt-pr-code.cc
+++ b/src/pt-pr-code.cc
@@ -160,17 +160,17 @@ tree_print_code::do_decl_command (tree_d
 
 void
 tree_print_code::visit_global_command (tree_global_command& cmd)
 {
   do_decl_command (cmd);
 }
 
 void
-tree_print_code::visit_static_command (tree_static_command& cmd)
+tree_print_code::visit_persistent_command (tree_persistent_command& cmd)
 {
   do_decl_command (cmd);
 }
 
 void
 tree_print_code::visit_decl_elt (tree_decl_elt& cmd)
 {
   tree_identifier *id = cmd.ident ();
diff --git a/src/pt-pr-code.h b/src/pt-pr-code.h
--- a/src/pt-pr-code.h
+++ b/src/pt-pr-code.h
@@ -62,17 +62,17 @@ public:
   void visit_break_command (tree_break_command&);
 
   void visit_colon_expression (tree_colon_expression&);
 
   void visit_continue_command (tree_continue_command&);
 
   void visit_global_command (tree_global_command&);
 
-  void visit_static_command (tree_static_command&);
+  void visit_persistent_command (tree_persistent_command&);
 
   void visit_decl_elt (tree_decl_elt&);
 
   void visit_decl_init_list (tree_decl_init_list&);
 
   void visit_simple_for_command (tree_simple_for_command&);
 
   void visit_complex_for_command (tree_complex_for_command&);
diff --git a/src/pt-walk.h b/src/pt-walk.h
--- a/src/pt-walk.h
+++ b/src/pt-walk.h
@@ -25,17 +25,17 @@ along with Octave; see the file COPYING.
 
 class tree_anon_fcn_handle;
 class tree_argument_list;
 class tree_binary_expression;
 class tree_break_command;
 class tree_colon_expression;
 class tree_continue_command;
 class tree_global_command;
-class tree_static_command;
+class tree_persistent_command;
 class tree_decl_elt;
 class tree_decl_init_list;
 class tree_simple_for_command;
 class tree_complex_for_command;
 class octave_user_script;
 class octave_user_function;
 class tree_function_def;
 class tree_identifier;
@@ -87,17 +87,17 @@ public:
 
   virtual void
   visit_continue_command (tree_continue_command&) = 0;
 
   virtual void
   visit_global_command (tree_global_command&) = 0;
 
   virtual void
-  visit_static_command (tree_static_command&) = 0;
+  visit_persistent_command (tree_persistent_command&) = 0;
 
   virtual void
   visit_decl_elt (tree_decl_elt&) = 0;
 
   virtual void
   visit_decl_init_list (tree_decl_init_list&) = 0;
 
   virtual void
diff --git a/src/sighandlers.cc b/src/sighandlers.cc
--- a/src/sighandlers.cc
+++ b/src/sighandlers.cc
@@ -74,32 +74,44 @@ static bool Vsigterm_dumps_octave_core =
 // List of signals we have caught since last call to octave_signal_handler.
 static bool octave_signals_caught[NSIG];
 
 // Signal handler return type.
 #ifndef BADSIG
 #define BADSIG (void (*)(int))-1
 #endif
 
+// The following is a workaround for an apparent bug in GCC 4.1.2 and
+// possibly earlier versions.  See Octave bug report #30685 for details.
+#if defined (__GNUC__)
+# if ! (__GNUC__ > 4 \
+        || (__GNUC__ == 4 && (__GNUC_MINOR__ > 1 \
+                              || (__GNUC_MINOR__ == 1 && __GNUC_PATCHLEVEL__ > 2))))
+#  undef GNULIB_NAMESPACE
+#  define GNULIB_NAMESPACE
+#  warning "disabling GNULIB_NAMESPACE for signal functions -- consider upgrading to a current version of GCC"
+# endif
+#endif
+
 #define BLOCK_SIGNAL(sig, nvar, ovar) \
   do \
     { \
-      gnulib::sigemptyset (&nvar); \
-      gnulib::sigaddset (&nvar, sig); \
-      gnulib::sigemptyset (&ovar); \
-      gnulib::sigprocmask (SIG_BLOCK, &nvar, &ovar); \
+      GNULIB_NAMESPACE::sigemptyset (&nvar); \
+      GNULIB_NAMESPACE::sigaddset (&nvar, sig); \
+      GNULIB_NAMESPACE::sigemptyset (&ovar); \
+      GNULIB_NAMESPACE::sigprocmask (SIG_BLOCK, &nvar, &ovar); \
     } \
   while (0)
 
 #if !defined (SIGCHLD) && defined (SIGCLD)
 #define SIGCHLD SIGCLD
 #endif
 
 #define BLOCK_CHILD(nvar, ovar) BLOCK_SIGNAL (SIGCHLD, nvar, ovar)
-#define UNBLOCK_CHILD(ovar) gnulib::sigprocmask (SIG_SETMASK, &ovar, 0)
+#define UNBLOCK_CHILD(ovar) GNULIB_NAMESPACE::sigprocmask (SIG_SETMASK, &ovar, 0)
 
 // Called from octave_quit () to actually do something about the signals
 // we have caught.
 
 void
 octave_signal_handler (void)
 {
   // The list of signals is relatively short, so we will just go
@@ -180,17 +192,17 @@ my_friendly_exit (const char *sig_name, 
           MINGW_SIGNAL_CLEANUP ();
 
           exit (1);
         }
       else
         {
           octave_set_signal_handler (sig_number, SIG_DFL);
 
-          gnulib::raise (sig_number);
+          GNULIB_NAMESPACE::raise (sig_number);
         }
     }
 }
 
 sig_handler *
 octave_set_signal_handler (int sig, sig_handler *handler,
                            bool restart_syscalls)
 {
@@ -211,20 +223,20 @@ octave_set_signal_handler (int sig, sig_
 #if defined (SIGALRM)
   else
 #endif
   // FIXME -- Do we also need to explicitly disable SA_RESTART?
   if (restart_syscalls)
     act.sa_flags |= SA_RESTART;
 #endif
 
-  gnulib::sigemptyset (&act.sa_mask);
-  gnulib::sigemptyset (&oact.sa_mask);
+  GNULIB_NAMESPACE::sigemptyset (&act.sa_mask);
+  GNULIB_NAMESPACE::sigemptyset (&oact.sa_mask);
 
-  gnulib::sigaction (sig, &act, &oact);
+  GNULIB_NAMESPACE::sigaction (sig, &act, &oact);
 
   return oact.sa_handler;
 }
 
 static void
 generic_sig_handler (int sig)
 {
   my_friendly_exit (strsignal (sig), sig);
diff --git a/src/strfns.cc b/src/strfns.cc
--- a/src/strfns.cc
+++ b/src/strfns.cc
@@ -59,23 +59,23 @@ is outside the ASCII range (0-255).\n\
 For cell arrays, each element is concatenated separately.  Cell arrays\n\
 converted through\n\
 @code{char} can mostly be converted back with @code{cellstr}.\n\
 For example:\n\
 \n\
 @example\n\
 @group\n\
 char ([97, 98, 99], \"\", @{\"98\", \"99\", 100@}, \"str1\", [\"ha\", \"lf\"])\n\
-     @result{} [\"abc    \"\n\
-         \"       \"\n\
-         \"98     \"\n\
-         \"99     \"\n\
-         \"d      \"\n\
-         \"str1   \"\n\
-         \"half   \"]\n\
+   @result{} [\"abc    \"\n\
+       \"       \"\n\
+       \"98     \"\n\
+       \"99     \"\n\
+       \"d      \"\n\
+       \"str1   \"\n\
+       \"half   \"]\n\
 @end group\n\
 @end example\n\
 @seealso{strvcat, cellstr}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
@@ -190,22 +190,22 @@ is outside the ASCII range (0-255).\n\
 For cell arrays, each element is concatenated separately.  Cell arrays\n\
 converted through\n\
 @code{strvcat} can mostly be converted back with @code{cellstr}.\n\
 For example:\n\
 \n\
 @example\n\
 @group\n\
 strvcat ([97, 98, 99], \"\", @{\"98\", \"99\", 100@}, \"str1\", [\"ha\", \"lf\"])\n\
-     @result{} [\"abc    \"\n\
-         \"98     \"\n\
-         \"99     \"\n\
-         \"d      \"\n\
-         \"str1   \"\n\
-         \"half   \"]\n\
+      @result{} [\"abc    \"\n\
+          \"98     \"\n\
+          \"99     \"\n\
+          \"d      \"\n\
+          \"str1   \"\n\
+          \"half   \"]\n\
 @end group\n\
 @end example\n\
 @seealso{char, strcat, cstrcat}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
@@ -660,17 +660,17 @@ DEFUN (strncmp, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} strncmp (@var{s1}, @var{s2}, @var{n})\n\
 Return 1 if the first @var{n} characters of strings @var{s1} and @var{s2} are\n\
 the same, and 0 otherwise.\n\
 \n\
 @example\n\
 @group\n\
 strncmp (\"abce\", \"abcd\", 3)\n\
-     @result{} 1\n\
+      @result{} 1\n\
 @end group\n\
 @end example\n\
 \n\
 If either @var{s1} or @var{s2} is a cell array of strings, then an array\n\
 of the same size is returned, containing the values described above for\n\
 every member of the cell array.  The other argument may also be a cell\n\
 array of strings (of the same size or with only one element), char matrix\n\
 or character string.\n\
@@ -862,19 +862,19 @@ columns with an overall maximum width of
 If @var{width} is not specified, the width of the terminal screen is used.\n\
 Newline characters are used to break the lines in the output string.\n\
 For example:\n\
 @c Set example in small font to prevent overfull line\n\
 \n\
 @smallexample\n\
 @group\n\
 list_in_columns (@{\"abc\", \"def\", \"ghijkl\", \"mnop\", \"qrs\", \"tuv\"@}, 20)\n\
-     @result{} ans = abc     mnop\n\
-            def     qrs\n\
-            ghijkl  tuv\n\
+     @result{} abc     mnop\n\
+        def     qrs\n\
+        ghijkl  tuv\n\
 \n\
 whos ans\n\
      @result{}\n\
      Variables in the current scope:\n\
 \n\
        Attr Name        Size                     Bytes  Class\n\
        ==== ====        ====                     =====  =====\n\
             ans         1x37                        37  char\n\
diff --git a/src/syscalls.cc b/src/syscalls.cc
--- a/src/syscalls.cc
+++ b/src/syscalls.cc
@@ -264,20 +264,21 @@ do\n\
     sleep (0.1);\n\
     fclear (out);\n\
   else\n\
     done = true;\n\
   endif\n\
 until (done)\n\
 fclose (out);\n\
 waitpid (pid);\n\
-     @print{} these\n\
-     @print{} strings\n\
-     @print{} some\n\
-     @print{} are\n\
+\n\
+   @print{} these\n\
+   @print{} strings\n\
+   @print{} some\n\
+   @print{} are\n\
 @end example\n\
 \n\
 Note that @code{popen2}, unlike @code{popen}, will not \"reap\" the\n\
 child process.  If you don't use @code{waitpid} to check the child's\n\
 exit status, it will linger until Octave exits.\n\
 @end deftypefn")
 {
   octave_value_list retval;
@@ -944,35 +945,35 @@ corresponding system error message.\n\
 If @var{file} is a symbolic link, @code{stat} will return information\n\
 about the actual file that is referenced by the link.  Use @code{lstat}\n\
 if you want information about the symbolic link itself.\n\
 \n\
 For example:\n\
 \n\
 @example\n\
 [s, err, msg] = stat (\"/vmlinuz\")\n\
-      @result{} s =\n\
-        @{\n\
-          atime = 855399756\n\
-          rdev = 0\n\
-          ctime = 847219094\n\
-          uid = 0\n\
-          size = 389218\n\
-          blksize = 4096\n\
-          mtime = 847219094\n\
-          gid = 6\n\
-          nlink = 1\n\
-          blocks = 768\n\
-          mode = -rw-r--r--\n\
-          modestr = -rw-r--r--\n\
-          ino = 9316\n\
-          dev = 2049\n\
-        @}\n\
-     @result{} err = 0\n\
-     @result{} msg =\n\
+  @result{} s =\n\
+     @{\n\
+       atime = 855399756\n\
+       rdev = 0\n\
+       ctime = 847219094\n\
+       uid = 0\n\
+       size = 389218\n\
+       blksize = 4096\n\
+       mtime = 847219094\n\
+       gid = 6\n\
+       nlink = 1\n\
+       blocks = 768\n\
+       mode = -rw-r--r--\n\
+       modestr = -rw-r--r--\n\
+       ino = 9316\n\
+       dev = 2049\n\
+     @}\n\
+  @result{} err = 0\n\
+  @result{} msg =\n\
 @end example\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   if (args.length () == 1)
     {
       if (args(0).is_scalar_type ())
@@ -1198,23 +1199,23 @@ Return the hostname of the system where 
 DEFUN (uname, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {[@var{uts}, @var{err}, @var{msg}] =} uname ()\n\
 Return system information in the structure.  For example:\n\
 \n\
 @example\n\
 @group\n\
 uname ()\n\
-     @result{} @{\n\
-           sysname = x86_64\n\
-           nodename = segfault\n\
-           release = 2.6.15-1-amd64-k8-smp\n\
-           version = Linux\n\
-           machine = #2 SMP Thu Feb 23 04:57:49 UTC 2006\n\
-         @}\n\
+   @result{} @{\n\
+         sysname = x86_64\n\
+         nodename = segfault\n\
+         release = 2.6.15-1-amd64-k8-smp\n\
+         version = Linux\n\
+         machine = #2 SMP Thu Feb 23 04:57:49 UTC 2006\n\
+      @}\n\
 @end group\n\
 @end example\n\
 \n\
 If successful, @var{err} is 0 and @var{msg} is an empty string.\n\
 Otherwise, @var{err} is nonzero and @var{msg} contains a\n\
 system-dependent error message.\n\
 @end deftypefn")
 {
diff --git a/src/variables.cc b/src/variables.cc
--- a/src/variables.cc
+++ b/src/variables.cc
@@ -356,17 +356,17 @@ DEFUN (isglobal, args, ,
 @deftypefn {Built-in Function} {} isglobal (@var{name})\n\
 Return true if @var{name} is a globally visible variable.\n\
 For example:\n\
 \n\
 @example\n\
 @group\n\
 global x\n\
 isglobal (\"x\")\n\
-     @result{} 1\n\
+   @result{} 1\n\
 @end group\n\
 @end example\n\
 @seealso{isvarname, exist}\n\
 @end deftypefn")
 {
   return do_isglobal (args);
 }
 
@@ -1793,16 +1793,17 @@ DEFUN (whos, args, nargout,
 Provide detailed information on currently defined variables matching the\n\
 given patterns.  Options and pattern syntax are the same as for the\n\
 @code{who} command.  Extended information about each variable is\n\
 summarized in a table with the following default entries.\n\
 \n\
 @table @asis\n\
 @item Attr\n\
 Attributes of the listed variable.  Possible attributes are:\n\
+\n\
 @table @asis\n\
 @item blank\n\
 Variable in local scope\n\
 \n\
 @item @code{a}\n\
 Automatic variable.  An automatic variable is one created by the\n\
 interpreter, for example @code{argn}.\n\
 \n\
@@ -2293,16 +2294,17 @@ variables (local and global) are cleared
 names matching the arguments are cleared.  For example, suppose you have\n\
 defined a function @code{foo}, and then hidden it by performing the\n\
 assignment @code{foo = 2}.  Executing the command @kbd{clear foo} once\n\
 will clear the variable definition and restore the definition of\n\
 @code{foo} as a function.  Executing @kbd{clear foo} a second time will\n\
 clear the function definition.\n\
 \n\
 The following options are available in both long and short form\n\
+\n\
 @table @code\n\
 @item -all, -a\n\
 Clears all local and global user-defined variables and all functions\n\
 from the symbol table.\n\
 \n\
 @item -exclusive, -x\n\
 Clears the variables that don't match the following pattern.\n\
 \n\
diff --git a/test/Makefile.am b/test/Makefile.am
--- a/test/Makefile.am
+++ b/test/Makefile.am
@@ -18,16 +18,17 @@
 # along with Octave; see the file COPYING.  If not, see
 # <http://www.gnu.org/licenses/>.
 
 include $(top_srcdir)/build-aux/common.mk
 
 FCN_FILES = \
   fntests.m \
   test_args.m \
+  test_bug_31371.m \
   test_diag_perm.m \
   test_error.m \
   test_eval-catch.m \
   test_for.m \
   test_func.m \
   test_global.m \
   test_if.m \
   test_index.m \
@@ -44,16 +45,17 @@ FCN_FILES = \
   test_struct.m \
   test_switch.m \
   test_system.m \
   test_transpose.m \
   test_try.m \
   test_unwind.m \
   test_while.m
 
+include bug-35448/module.mk
 include classes/module.mk
 include class-concat/module.mk
 include ctor-vs-method/module.mk
 include fcn-handle-derived-resolution/module.mk
 
 check: test_sparse.m test_bc_overloads.m
 	$(top_builddir)/run-octave --norc --silent --no-history $(srcdir)/fntests.m $(srcdir)
 
diff --git a/test/bug-35448/fA.m b/test/bug-35448/fA.m
new file mode 100644
--- /dev/null
+++ b/test/bug-35448/fA.m
@@ -0,0 +1,10 @@
+# fA.m
+function y = fA (x, f)
+  global gfun
+  if nargin < 2
+    y = fA (x, gfun);
+  else
+    w = feval (f, x);
+    y = feval (@fB, w);
+  endif
+endfunction
diff --git a/test/bug-35448/fB.m b/test/bug-35448/fB.m
new file mode 100644
--- /dev/null
+++ b/test/bug-35448/fB.m
@@ -0,0 +1,4 @@
+# fB.m
+function y = fB (x)
+  y = x;
+endfunction
diff --git a/test/bug-35448/fC.m b/test/bug-35448/fC.m
new file mode 100644
--- /dev/null
+++ b/test/bug-35448/fC.m
@@ -0,0 +1,4 @@
+# fC.m
+function y = fC (x)
+  y = x;
+endfunction
diff --git a/test/bug-35448/module.mk b/test/bug-35448/module.mk
new file mode 100644
--- /dev/null
+++ b/test/bug-35448/module.mk
@@ -0,0 +1,7 @@
+bug_35448_FCN_FILES = \
+  bug-35448/fA.m \
+  bug-35448/fB.m \
+  bug-35448/fC.m \
+  class-concat/test_bug_35448.m
+
+FCN_FILES += $(bug_35448_FCN_FILES)
diff --git a/test/bug-35448/test_bug_35448.m b/test/bug-35448/test_bug_35448.m
new file mode 100644
--- /dev/null
+++ b/test/bug-35448/test_bug_35448.m
@@ -0,0 +1,11 @@
+%!test
+%! global gfun
+%! gfun = @fB;
+%! y = fA (e);
+%! assert (y, e);
+
+%!test
+%! global gfun
+%! gfun = @fC;
+%! y = fA (e);
+%! assert (y, e);
diff --git a/test/fntests.m b/test/fntests.m
--- a/test/fntests.m
+++ b/test/fntests.m
@@ -260,36 +260,40 @@ try
   puts ("\nFixed test scripts:\n\n");
   for i = 1:length (testdirs)
     [p, n, xf, sk] = run_test_dir (fid, testdirs{i});
     dp += p;
     dn += n;
     dxf += xf;
     dsk += sk;
   endfor
-  printf ("\nSummary:\n\n  PASS %6d\n", dp);
+  puts ("\nSummary:\n\n");
   nfail = dn - dp;
-  printf ("  FAIL %6d\n", nfail);
+  printf ("  PASS    %6d\n", dp);
+  printf ("  FAIL    %6d\n", nfail);
   if (dxf > 0)
-    if (dxf > 1)
-      t1 = "were";
-      t2 = "failures";
-    else
-      t1 = "was";
-      t2 = "failure";
-    endif
-    printf ("\nThere %s %d expected %s (see fntests.log for details).\n",
-            t1, dxf, t2);
-    puts ("\nExpected failures are known bugs.  Please help improve Octave\n");
-    puts ("by contributing fixes for them.\n");
+    printf ("  XFAIL   %6d\n", dxf);
   endif
   if (dsk > 0)
-    printf ("\nThere were %d skipped tests (see fntests.log for details).\n", dsk);
-    puts ("Skipped tests are features that are disabled in this version of Octave\n");
-    puts ("because the needed libraries were not present when Octave was built.\n");
+    printf ("  SKIPPED %6d\n", dsk);
+  endif
+  puts ("\n");
+  puts ("See the file test/fntests.log for additional details.\n");
+  if (dxf > 0)
+    puts ("\n");
+    puts ("Expected failures (listed as XFAIL above) are known bugs.\n");
+    puts ("Please help improve Octave by contributing fixes for them.\n");
+  endif
+  if (dsk > 0)
+    puts ("\n");
+    puts ("Tests are most often skipped because the features they require\n");
+    puts ("have been disabled.  Features are most often disabled because\n");
+    puts ("they require dependencies that were not present when Octave\n");
+    puts ("was built.  The configure script should have printed a summary\n");
+    puts ("at the end of its run indicating which dependencies were not found.\n");
   endif
 
   ## Weed out deprecated and private functions
   weed_idx = cellfun (@isempty, regexp (files_with_tests, '\bdeprecated\b|\bprivate\b', 'once'));
   files_with_tests = files_with_tests(weed_idx);
   weed_idx = cellfun (@isempty, regexp (files_with_no_tests, '\bdeprecated\b|\bprivate\b', 'once'));
   files_with_no_tests = files_with_no_tests(weed_idx);
 
diff --git a/test/test_bug_31371.m b/test/test_bug_31371.m
new file mode 100644
--- /dev/null
+++ b/test/test_bug_31371.m
@@ -0,0 +1,41 @@
+%!test
+%! % Work around MATLAB bug where f(x)(y) is invalid syntax
+%! % (This bug does not apply to Octave)
+%!
+%! C = @(fcn,x) fcn(x);
+%! C2 = @(fcn,x,y) fcn(x,y);
+%! 
+%! % Church Booleans
+%! T = @(t,f) t;
+%! F = @(t,f) f;
+%! 
+%! % Church Numerals
+%! Zero  = @(fcn,x) x;
+%! One   = @(fcn,x) fcn(x);
+%! Two   = @(fcn,x) fcn(fcn(x));
+%! Three = @(fcn,x) fcn(fcn(fcn(x)));
+%! Four  = @(fcn,x) fcn(fcn(fcn(fcn(x))));
+%! 
+%! % Arithmetic Operations
+%! Inc = @(a) @(f,x) f(a(f,x)); % Increment
+%! Add = @(a,b) @(f,x) a(f,b(f,x));
+%! Mult = @(a,b) @(f,x) a(@(x) b(f,x),x);
+%! Dec = @(a) @(f,x) C(a(@(g) @(h) h(g(f)), @(u) x), @(u) u); % Decrement
+%! Sub = @(a,b) b(Dec, a);
+%! 
+%! % Renderer - Convert church numeral to "real" number
+%! Render = @(n) n(@(n) n+1,0);
+%! 
+%! % Predicates
+%! Iszero = @(n) n(@(x) F, T);
+%! 
+%! % Y combinator implements recursion
+%! Ycomb = @(f) C(@(g) f(@(x) C(g(g), x)), ...
+%!                @(g) f(@(x) C(g(g), x)));
+%!
+%! Factorial = Ycomb(@(f) @(n) C(C2(Iszero(n), ...
+%!                   @(d) One, @(d) Mult(n, f(Dec(n)))),0));
+%! 
+%! assert (Render (Factorial (Two)), 2)
+%! assert (Render (Factorial (Three)), 6)
+%! assert (Render (Factorial (Four)), 24)
diff --git a/test/test_io.m b/test/test_io.m
--- a/test/test_io.m
+++ b/test/test_io.m
@@ -222,16 +222,18 @@
 %!test
 %! matrix1 = rand (100, 2);
 %! save -ascii matrix.ascii matrix1
 %! matrix2 = load ("matrix.ascii");
 %! assert (matrix1, matrix2, 1e-9)
 %!
 %! delete matrix.ascii;
 
+%!error <unable to find file> load ("")
+
 %% FIXME: This test is disabled as it writes to stdout and there is no easy
 %% way to recover output.  Need to spawn new octave process and pipe stdout
 %% somewhere to treat this case.
 %% test/octave.test/io/puts-1.m
 %!#test
 %! puts ("foo\n");
 
 %% test/octave.test/io/puts-2.m
