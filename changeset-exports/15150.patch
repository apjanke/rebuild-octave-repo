# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1344636444 14400
#      Fri Aug 10 18:07:24 2012 -0400
# Branch gui
# Node ID 2eb789da13c37a6e399bb3f0c2179e17b8fa24fc
# Parent  bfc220d1de673c61654203c93d89f3ad13616221
# Parent  62a35ae7d6a2666f27a55f7357e5b3b4eae6d218
periodic merge of default to gui

diff --git a/configure.ac b/configure.ac
--- a/configure.ac
+++ b/configure.ac
@@ -261,20 +261,20 @@ case "$canonical_host_type" in
 #ifndef _MSC_VER
 #error "Not MSVC compiler"
 #endif
 ])], have_msvc=yes, have_msvc=no)
     AC_MSG_RESULT([$have_msvc])
   ;;
 esac
 
-### gnulib initialization
+### gnulib initialization: part 1
+### Must take place immediately after a compiler is determined
 
 gl_EARLY
-gl_INIT
 
 ### Check version number when using gcc.
 
 gcc_version=`$CC -v 2>&1 | grep "^.*gcc version" | \
   sed -e 's/^.*g.. version *//' -e 's/cygnus-//' -e 's/egcs-//'`
 case "$gcc_version" in
   [12].*)
     warn_gcc_version="gcc version $gcc_version is likely to cause problems"
@@ -545,26 +545,26 @@ fi
 AC_SUBST(F77_TOLOWER)
 AC_SUBST(F77_APPEND_UNDERSCORE)
 AC_SUBST(F77_APPEND_EXTRA_UNDERSCORE)
 
 if test -z "$F77"; then
   AC_MSG_ERROR([in order to build Octave, you must have a compatible Fortran compiler or wrapper script for f2c that functions as a Fortran compiler installed and in your path.  See the file INSTALL for more information.])
 fi
 
-OCTAVE_CHECK_FORTRAN_HAVE_ISNAN
+OCTAVE_CHECK_FUNC_FORTRAN_ISNAN
 F77_ISNAN_MACRO=
-if test "x$octave_cv_fortran_have_isnan" = xno; then
+if test "x$octave_cv_func_fortran_isnan" = xno; then
    AC_MSG_NOTICE([substituting ISNAN(X) with X.NE.X in Fortran sources])
    F77_ISNAN_MACRO="s|ISNAN(\(@<:@^)@:>@*\))|(\1.NE.\1)|"
 fi
 AC_SUBST(F77_ISNAN_MACRO)
 
-OCTAVE_CHECK_FORTRAN_INTEGER_SIZE
-if test "x$octave_cv_fortran_integer_size" = xno; then
+OCTAVE_CHECK_SIZEOF_FORTRAN_INTEGER
+if test "x$octave_cv_sizeof_fortran_integer" = xno; then
   if $USE_64_BIT_IDX_T; then
     case "$F77" in
       *gfortran*)
         case "$F77_INTEGER_8_FLAG" in
           *-fdefault-integer-8*)
           ;;
           *)
             case "$FFLAGS" in
@@ -572,27 +572,27 @@ if test "x$octave_cv_fortran_integer_siz
                 AC_MSG_NOTICE([setting -fdefault-integer-8 in F77_INTEGER_8_FLAG instead of FFLAGS])
                 FFLAGS=`echo $FFLAGS | sed 's/-fdefault-integer-8//g'`
                 F77_INTEGER_8_FLAG="-fdefault-integer-8"
               ;;
               *)
                 AC_MSG_NOTICE([adding -fdefault-integer-8 to F77_INTEGER_8_FLAG])
                 F77_INTEGER_8_FLAG="-fdefault-integer-8"
                 ## Invalidate the cache and try again.
-                $as_unset octave_cv_fortran_integer_size
+                $as_unset octave_cv_sizeof_fortran_integer
               ;;
             esac
           ;;
         esac
       ;;
     esac
-    if test -z "$octave_cv_fortran_integer_size"; then
-      OCTAVE_CHECK_FORTRAN_INTEGER_SIZE
+    if test -z "$octave_cv_sizeof_fortran_integer"; then
+      OCTAVE_CHECK_SIZEOF_FORTRAN_INTEGER
     fi
-    if test "x$octave_cv_fortran_integer_size" = xno; then
+    if test "x$octave_cv_sizeof_fortran_integer" = xno; then
       AC_MSG_ERROR([in order to build Octave with 64-bit indexing support your Fortran compiler must have an option for setting the default integer size to 8 bytes.  See the file INSTALL for more information.])
     fi
   else
     AC_MSG_ERROR([your Fortran compiler must have an option to make integers the same size as octave_idx_type ($OCTAVE_IDX_TYPE).  See the file INSTALL for more information.])
   fi
 fi
 AC_SUBST(F77_INTEGER_8_FLAG)
 
@@ -602,22 +602,22 @@ AC_SUBST(FC)
 OCTAVE_F77_FLAG(-ffloat-store, [
 AC_MSG_RESULT([setting F77_FLOAT_STORE_FLAG to -ffloat-store])
 F77_FLOAT_STORE_FLAG=-ffloat-store
 AC_SUBST(F77_FLOAT_STORE_FLAG)
 ])
 
 ### Check for the Qhull library
 
-OCTAVE_CHECK_LIBRARY(qhull, QHull,
+OCTAVE_CHECK_LIB(qhull, QHull,
   [Qhull library not found -- this will result in loss of functionality of some geometry functions.],
   [libqhull/libqhull.h qhull/libqhull.h libqhull.h qhull/qhull.h qhull.h], [qh_qhull], [], [],
   [warn_qhull=
    OCTAVE_CHECK_QHULL_VERSION
-   OCTAVE_CHECK_QHULL_OK([TEXINFO_QHULL="@set HAVE_QHULL"
+   OCTAVE_CHECK_LIB_QHULL_OK([TEXINFO_QHULL="@set HAVE_QHULL"
      AC_DEFINE(HAVE_QHULL, 1, [Define to 1 if Qhull is available.])], [
      warn_qhull="Qhull library found, but does not seem to work properly -- this will result in loss of functionality of some geometry functions.  Please try recompiling the library with -fno-strict-aliasing."])])
 
 ### Check for PCRE regex library.
 
 REGEX_LIBS=
 
 pcre_fail_msg="to build Octave, you must have the PCRE library and header files installed"
@@ -655,17 +655,17 @@ if test $ac_cv_pcre_h_macros_present = y
     [AC_MSG_ERROR([$pcre_fail_msg])])
   LIBS="$save_LIBS"
 else
   AC_MSG_ERROR([$pcre_fail_msg])
 fi
 
 ### Check for ZLIB library.
 
-OCTAVE_CHECK_LIBRARY(z, ZLIB,
+OCTAVE_CHECK_LIB(z, ZLIB,
   [ZLIB library not found.  Octave will not be able to save or load compressed data files or HDF5 files.],
   [zlib.h], [gzclearerr])
 
 ### Check for the LLVM library
 dnl
 dnl LLVM is odd and has its own pkg-config like script.  We should probably
 dnl check for existence and ???.
 dnl
@@ -754,67 +754,68 @@ LIBS="$save_LIBS"
 LDFLAGS="$save_LDFLAGS"
 
 ### Check for HDF5 library.
 
 save_CPPFLAGS="$CPPFLAGS"
 CPPFLAGS="$Z_CPPFLAGS $CPPFLAGS"
 save_LIBS="$LIBS"
 LIBS="$Z_LDFLAGS $Z_LIBS $LIBS"
-OCTAVE_CHECK_LIBRARY(hdf5, HDF5,
+OCTAVE_CHECK_LIB(hdf5, HDF5,
   [HDF5 library not found.  Octave will not be able to save or load HDF5 data files.],
   [hdf5.h], [H5Gget_num_objs], [], [],
   [warn_hdf5=
-   OCTAVE_HDF5_HAS_ENFORCED_16_API
+   OCTAVE_CHECK_HDF5_HAS_VER_16_API
    TEXINFO_HDF5="@set HAVE_HDF5"
-   AC_DEFINE(HAVE_HDF5, 1, [Define to 1 if HDF5 is available and newer than version 1.6.])
+   AC_DEFINE(HAVE_HDF5, 1,
+     [Define to 1 if HDF5 is available and newer than version 1.6.])
    if test "$have_msvc" = "yes"; then
-     OCTAVE_HDF5_DLL
+     OCTAVE_CHECK_LIB_HDF5_DLL
    fi
-   ])
+  ])
 CPPFLAGS="$save_CPPFLAGS"
 LIBS="$save_LIBS"
 
 ### Check for FFTW library.  Default to Fortran FFTPACK if it is not available.
 
 ## Check for FFTW header and library.
-OCTAVE_CHECK_LIBRARY(fftw3, FFTW3,
+OCTAVE_CHECK_LIB(fftw3, FFTW3,
   [FFTW3 library not found.  The slower FFTPACK library will be used instead.],
   [fftw3.h], [fftw_plan_dft_1d])
 
-OCTAVE_CHECK_LIBRARY(fftw3f, FFTW3F,
+OCTAVE_CHECK_LIB(fftw3f, FFTW3F,
   [FFTW3F library not found.  The slower FFTPACK library will be used instead.],
   [fftw3.h], [fftwf_plan_dft_1d])
 
 AM_CONDITIONAL([AMCOND_HAVE_FFTW],
   [test -n "$FFTW3_LIBS" && test -n "$FFTW3F_LIBS"])
 
 ## Subdirectory of libcruft to build if FFTW is not found:
 FFT_DIR="fftpack"
 AC_SUBST(FFT_DIR)
 
 ### Check for GLPK library and header.
 
 save_CPPFLAGS="$CPPFLAGS"
 CPPFLAGS="$Z_CPPFLAGS $CPPFLAGS"
 save_LIBS="$LIBS"
 LIBS="$Z_LDFLAGS $Z_LIBS $LIBS"
-OCTAVE_CHECK_LIBRARY(glpk, GLPK,
+OCTAVE_CHECK_LIB(glpk, GLPK,
   [GLPK library not found.  The glpk function for solving linear programs will be disabled.],
   [glpk/glpk.h glpk.h], [_glp_lpx_simplex])
 LIBS="$save_LIBS"
 CPPFLAGS="$save_CPPFLAGS"
 
 ### Checks for cURL header and library.
 
 save_CPPFLAGS="$CPPFLAGS"
 CPPFLAGS="$Z_CPPFLAGS $CPPFLAGS"
 save_LIBS="$LIBS"
 LIBS="$Z_LDFLAGS $Z_LIBS $LIBS"
-OCTAVE_CHECK_LIBRARY(curl, cURL,
+OCTAVE_CHECK_LIB(curl, cURL,
   [cURL library not found.  The ftp objects, urlread and urlwrite functions will be disabled.],
   [curl/curl.h], [curl_easy_escape])
 LIBS="$save_LIBS"
 CPPFLAGS="$save_CPPFLAGS"
 
 ### Check for either of Graphics/ImageMagick++ libraries
 
 AC_ARG_WITH([magick],
@@ -919,17 +920,17 @@ AC_ARG_WITH([opengl],
      native_graphics=false
    else
      check_opengl=true
    fi],
   [check_opengl=true])
 
 ## Check for OpenGL library
 if $check_opengl; then
-  OCTAVE_OPENGL
+  OCTAVE_CHECK_LIB_OPENGL
 fi
 
 GRAPHICS_LIBS=
 GRAPHICS_CFLAGS=
 
 if test -z "$OPENGL_LIBS"; then
   if $check_opengl; then
     warn_fltk_opengl="OpenGL libs (GL and GLU) not found.  Native graphics will be disabled."
@@ -1170,17 +1171,17 @@ if test x$ax_blas_ok = xno || test x$ax_
 fi
 
 ### Check for the qrupdate library
 
 ## No need to adjust FFLAGS because only link is attempted. 
 ## Must supply proper LIBS, however.
 save_LIBS="$LIBS"
 LIBS="$LAPACK_LIBS $BLAS_LIBS $FLIBS $LIBS"
-OCTAVE_CHECK_LIBRARY(qrupdate, qrupdate,
+OCTAVE_CHECK_LIB(qrupdate, qrupdate,
   [qrupdate not found.  The QR & Cholesky updating functions will be slow.],
   [],
   [sqr1up],
   [Fortran 77], [don't use qrupdate, disable QR & Cholesky updating functions])
 
 if test "$octave_qrupdate_ok" = yes; then
   LIBS="$LIBS $QRUPDATE_LIBS"
   AC_LANG_PUSH([Fortran 77])
@@ -1193,114 +1194,114 @@ if test "$octave_qrupdate_ok" = yes; the
     AC_DEFINE(HAVE_QRUPDATE_LUU, 1, [Define to 1 if qrupdate supports LU updates.])
   fi
   AC_LANG_POP([Fortran 77])
 fi
 LIBS="$save_LIBS"
 
 ### Check for AMD library
 
-OCTAVE_CHECK_LIBRARY(amd, AMD,
+OCTAVE_CHECK_LIB(amd, AMD,
   [AMD library not found.  This will result in some lack of functionality for sparse matrices.],
   [suitesparse/amd.h ufsparse/amd.h amd/amd.h amd.h],
   [amd_postorder],
   [], [don't use AMD library, disable some sparse matrix functionality])
 
 ### Check for CAMD library
 
-OCTAVE_CHECK_LIBRARY(camd, CAMD,
+OCTAVE_CHECK_LIB(camd, CAMD,
   [CAMD library not found.  This will result in some lack of functionality for sparse matrices.],
   [suitesparse/camd.h ufsparse/camd.h amd/camd.h camd.h],
   [camd_postorder],
   [], [don't use CAMD library, disable some sparse matrix functionality])
 
 ### Check for COLAMD library
 
-OCTAVE_CHECK_LIBRARY(colamd, COLAMD,
+OCTAVE_CHECK_LIB(colamd, COLAMD,
   [COLAMD library not found.  This will result in some lack of functionality for sparse matrices.],
   [suitesparse/colamd.h ufsparse/colamd.h amd/colamd.h colamd.h],
   [colamd],
   [], [don't use COLAMD library, disable some sparse matrix functionality])
 
 ### Check for CCOLAMD library
 
-OCTAVE_CHECK_LIBRARY(ccolamd, CCOLAMD,
+OCTAVE_CHECK_LIB(ccolamd, CCOLAMD,
   [CCOLAMD library not found.  This will result in some lack of functionality for sparse matrices.],
   [suitesparse/ccolamd.h ufsparse/ccolamd.h amd/ccolamd.h ccolamd.h],
   [ccolamd],
   [], [don't use CCOLAMD library, disable some sparse matrix functionality])
 
 ### Check for CHOLMOD library.  If your cholmod library requires cblas,
 ### then you will need to configure with --with-cholmod="-lcholmod -lcblas".
 
 save_LIBS="$LIBS"
 LIBS="$COLAMD_LDFLAGS $COLAMD_LIBS $AMD_LDFLAGS $AMD_LIBS $LAPACK_LIBS $BLAS_LIBS $FLIBS $LIBS"
-OCTAVE_CHECK_LIBRARY(cholmod, CHOLMOD,
+OCTAVE_CHECK_LIB(cholmod, CHOLMOD,
   [CHOLMOD library not found.  This will result in some lack of functionality for sparse matrices.],
   [suitesparse/cholmod.h ufsparse/cholmod.h cholmod/cholmod.h cholmod.h],
   [cholmod_start],
   [], [don't use CHOLMOD library, disable some sparse matrix functionality])
 LIBS="$save_LIBS"
 
 ### Check for CXSparse library
 
-OCTAVE_CHECK_LIBRARY(cxsparse, CXSparse,
+OCTAVE_CHECK_LIB(cxsparse, CXSparse,
   [CXSparse library not found.  This will result in some lack of functionality for sparse matrices.],
   [suitesparse/cs.h ufsparse/cs.h amd/cs.h cs.h],
   [cs_di_sqr],
   [C++], [don't use CXSparse library, disable some sparse matrix functionality])
 
 ### Check for UMFPACK library.
 
 save_LIBS="$LIBS"
 save_CPPFLAGS="$CPPFLAGS"
 LIBS="$AMD_LDFLAGS $AMD_LIBS $BLAS_LIBS $FLIBS $LIBS"
 CPPFLAGS="$AMD_CPPFLAGS $CPPFLAGS"
-OCTAVE_CHECK_LIBRARY(umfpack, UMFPACK,
+OCTAVE_CHECK_LIB(umfpack, UMFPACK,
   [UMFPACK not found.  This will result in some lack of functionality for sparse matrices.],
   [suitesparse/umfpack.h ufsparse/umfpack.h umfpack/umfpack.h umfpack.h],
   [umfpack_zi_get_determinant],
   [], [don't use UMFPACK, disable some sparse matrix functionality])
 CPPFLAGS="$save_CPPFLAGS"
 LIBS="$save_LIBS"
 
 if test -z "$UMFPACK_LIBS"; then
   ## Invalidate the cache and try again with -lcblas.
   $as_unset ac_cv_lib_umfpack_umfpack_zi_get_determinant
   save_LIBS="$LIBS"
   LIBS="-lcblas $AMD_LDFLAGS $AMD_LIBS $BLAS_LIBS $FLIBS $LIBS"
-  OCTAVE_CHECK_LIBRARY(umfpack, UMFPACK,
+  OCTAVE_CHECK_LIB(umfpack, UMFPACK,
     [UMFPACK not found.  This will result in some lack of functionality for sparse matrices.],
     [suitesparse/umfpack.h ufsparse/umfpack.h umfpack/umfpack.h umfpack.h],
     [umfpack_zi_get_determinant],
     [], [don't use UMFPACK, disable some sparse matrix functionality])
   if test -n "$UMFPACK_LIBS"; then
     UMFPACK_LIBS="$UMFPACK_LIBS -lcblas"
   fi
   LIBS="$save_LIBS"
 fi
 
 if test -n "$UMFPACK_LIBS"; then
   save_LIBS="$LIBS";
   LIBS="$UMFPACK_LIBS $AMD_LIBS $BLAS_LIBS $FLIBS $LIBS"
-  OCTAVE_UMFPACK_SEPERATE_SPLIT
+  OCTAVE_UMFPACK_SEPARATE_SPLIT
   LIBS="$save_LIBS"
 fi
 
 ### Check for ARPACK library.
 
 save_LIBS="$LIBS"
 LIBS="$LAPACK_LIBS $BLAS_LIBS $FLIBS $LIBS"
-OCTAVE_CHECK_LIBRARY(arpack, ARPACK,
+OCTAVE_CHECK_LIB(arpack, ARPACK,
   [ARPACK not found.  The eigs function will be disabled.],
   [],
   [dseupd],
   [Fortran 77], [don't use the ARPACK library, disable eigs function],
   [warn_arpack=
-   OCTAVE_CHECK_ARPACK_OK([
+   OCTAVE_CHECK_LIB_ARPACK_OK([
      AC_DEFINE(HAVE_ARPACK, 1, [Define to 1 if ARPACK is available.])], [
      warn_arpack="ARPACK library found, but does not seem to work properly -- disabling eigs function"])])
 LIBS="$save_LIBS"
 
 ### Check for readline library.
 
 OCTAVE_ENABLE_READLINE
 
@@ -1830,20 +1831,20 @@ AC_STRUCT_TIMEZONE
 
 ## Does compiler have support for new friend template declarations?
 OCTAVE_CXX_NEW_FRIEND_TEMPLATE_DECL
 
 ## Does reinterpret_cast fail for function pointers?
 OCTAVE_CXX_BROKEN_REINTERPRET_CAST
 
 ## Check if C++ compiler allows placement delete.
-OCTAVE_PLACEMENT_DELETE
+OCTAVE_CXX_PLACEMENT_DELETE
 
 ## Check if C++ compiler can auto allocate variable sized arrays.
-OCTAVE_DYNAMIC_AUTO_ARRAYS
+OCTAVE_CXX_DYNAMIC_AUTO_ARRAYS
 
 ## Check that C compiler and libraries support IEEE754 data format.
 OCTAVE_IEEE754_DATA_FORMAT
 
 ## Is C++ runtime library ISO compliant?
 OCTAVE_CXX_ISO_COMPLIANT_LIBRARY
 
 ## Are bit_and, bit_or, and bit_xor defined as templated operators?
@@ -1859,16 +1860,22 @@ OCTAVE_CXX_COMPLEX_REFERENCE_ACCESSORS
 OCTAVE_FAST_INT_OPS
 
 ## Does the C compiler handle alloca() and const correctly?
 AC_FUNC_ALLOCA
 
 ## Does the C compiler support Automake subdir-objects option?
 AM_PROG_CC_C_O 
 
+### gnulib initialization: part 2
+### After all include and path modifications have taken place
+### and at the same priority level as function checks.
+
+gl_INIT
+
 ### Checks for functions and variables.
 
 AC_CHECK_FUNCS(basename canonicalize_file_name \
   chmod dup2 endgrent endpwent execvp expm1 expm1f fork \
   getegid geteuid getgid getgrent getgrgid getgrnam getpgrp getpid \
   getppid getpwent getpwuid getuid getwd _kbhit kill \
   lgamma lgammaf lgamma_r lgammaf_r localtime_r log1p log1pf \
   mkstemp pipe putenv \
@@ -1898,19 +1905,19 @@ double tgamma (double);
 #if defined (__cplusplus)
 }
 #endif
 ])
 AC_LANG_POP(C++)
 
 ## Look in <cmath> for the IEEE functions isnan, isinf, isfinite that we need.
 
-OCTAVE_CMATH_FUNC(isnan)
-OCTAVE_CMATH_FUNC(isinf)
-OCTAVE_CMATH_FUNC(isfinite)
+OCTAVE_CHECK_FUNC_CMATH(isnan)
+OCTAVE_CHECK_FUNC_CMATH(isinf)
+OCTAVE_CHECK_FUNC_CMATH(isfinite)
 
 dnl Would like to get rid of this cruft, and just have
 dnl
 dnl   AC_CHECK_FUNCS(finite isnan isinf)
 dnl
 dnl instead, but that used to fail on some systems...
 dnl
 dnl Also just using AC_CHECK_FUNCS doesn't seem to work to find isinf
@@ -1983,33 +1990,44 @@ esac
 AC_CHECK_FUNCS(getrusage)
 case "$canonical_host_type" in
   *-*-cygwin*)
     AC_DEFINE(RUSAGE_TIMES_ONLY, 1, [Define to 1 if your struct rusage only has time information.])
   ;;
 esac
 
 ## Check for CGDisplayBitsPerPixel function on Mac OSX systems with Carbon
-OCTAVE_CARBON_CGDISPLAYBITSPERPIXEL
+if test $have_framework_carbon = "yes"; then
+  OCTAVE_CARBON_CGDISPLAYBITSPERPIXEL
+fi
 
 OCTAVE_SMART_PUTENV
 
 AC_CHECK_FUNCS(getpwnam, [], [AC_CHECK_LIB(sun, getpwnam)])
 
 AC_FUNC_CLOSEDIR_VOID
 
-## Return type of matherr() 
-AC_MSG_CHECKING([for struct exception in math.h])
-AC_LINK_IFELSE([AC_LANG_PROGRAM([[#include <math.h>]],
-  [[struct exception *x; x->type; x->name;]])],
-  [AC_MSG_RESULT(yes)
-   AC_DEFINE(EXCEPTION_IN_MATH, 1,
-     [Define to 1 if your math.h declares struct exception for matherr().])],
-  [AC_MSG_RESULT(no)])
-
+## Check return type of matherr() 
+AC_CACHE_CHECK([for struct exception in math.h],
+  [octave_cv_func_matherr_type],
+  [AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+      #include <math.h>
+      ]], [[
+      struct exception *x;
+      x->type;
+      x->name;
+      ]])],
+    octave_cv_func_matherr_type=yes,
+    octave_cv_func_matherr_type=no)
+  ])
+if test $octave_cv_func_matherr_type = "yes"; then
+  AC_DEFINE(EXCEPTION_IN_MATH, 1,
+    [Define to 1 if math.h declares struct exception for matherr().])
+fi
+ 
 ## Signal stuff.
 
 AC_CHECK_DECLS([sys_siglist], [], [],
 [#include <signal.h>
 /* NetBSD declares sys_siglist in unistd.h.  */
 #if HAVE_UNISTD_H
 # include <unistd.h>
 #endif
diff --git a/m4/acinclude.m4 b/m4/acinclude.m4
--- a/m4/acinclude.m4
+++ b/m4/acinclude.m4
@@ -32,465 +32,195 @@ m4_define([m4_ifblank],
 dnl
 ifdef([m4_ifnblank],[],[
 m4_define([m4_ifnblank],
 [m4_if(m4_translit([[$1]],  [ ][	][
 ]), [], [$3], [$2])])])
 dnl
 dnl ----------------------------------------------------------------------
 dnl
-dnl Figure out the hardware-vendor-os info.
-dnl
-AC_DEFUN([OCTAVE_HOST_TYPE],
-[AC_CANONICAL_HOST
-if test -z "$host"; then
-  host=unknown
-fi
-canonical_host_type=$host
-if test "$host" = unknown; then
-  AC_MSG_WARN([configuring Octave for unknown system type
-])
-fi
-AC_SUBST(canonical_host_type)])
-dnl
-dnl Set default value for a variable and substitute it.
-dnl
-AC_DEFUN([OCTAVE_SET_DEFAULT],
-[ifelse($#, 2, [: ${$1=$2}
-])dnl
-AC_MSG_RESULT([defining $1 to be $$1])
-AC_SUBST($1)])
-dnl
-dnl Check for ar.
-dnl
-AC_DEFUN([OCTAVE_PROG_AR],
-[if test -z "$AR"; then
-  AR=ar
-fi
-AC_SUBST(AR)
 
-if test -z "$ARFLAGS"; then
-  ARFLAGS="rc"
-fi
-AC_SUBST(ARFLAGS)
-])
-dnl
-dnl Check for unordered map headers and whether tr1 namespace is
-dnl required.
-dnl
-AC_DEFUN([OCTAVE_UNORDERED_MAP_HEADERS], [
-AC_CHECK_HEADERS([unordered_map], [], [
-  AC_CHECK_HEADERS([tr1/unordered_map])])
-AC_CACHE_CHECK([whether unordered_map requires tr1 namespace],
-  [octave_cv_header_require_tr1_namespace],
-  [AC_LANG_PUSH(C++)
-  octave_cv_header_require_tr1_namespace=no
-  if test "$ac_cv_header_unordered_map" = "yes"; then
-    ## Have <unordered_map>, but still have to check whether
-    ## tr1 namespace is required (like MSVC, for instance).
-    AC_COMPILE_IFELSE([
-      AC_LANG_PROGRAM([
-        #include <unordered_map>
-      ], [
-        std::unordered_map<int,int> m;
-      ])], octave_cv_header_require_tr1_namespace=no, octave_cv_header_require_tr1_namespace=yes)
-  elif test "$ac_cv_header_tr1_unordered_map" = "yes"; then
-    octave_cv_header_require_tr1_namespace=yes
-  fi
-  AC_LANG_POP(C++)])
-  if test "$octave_cv_header_require_tr1_namespace" = "yes"; then
-    AC_DEFINE(USE_UNORDERED_MAP_WITH_TR1, 1, [Define to 1 if unordered_map requires the use of tr1 namespace.])
-  fi
-])
-dnl
-dnl Check if the compiler supports placement delete.
 dnl
-AC_DEFUN([OCTAVE_PLACEMENT_DELETE],
-[AC_CACHE_CHECK([whether <new> defines placement delete operator],
-octave_cv_placement_delete,
-[AC_LANG_PUSH(C++)
-AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[#include <new>]],
-[[operator delete((void *)0, (void *)0);]])],
-octave_cv_placement_delete=yes, octave_cv_placement_delete=no)])
-if test $octave_cv_placement_delete = yes; then
-AC_DEFINE(HAVE_PLACEMENT_DELETE,1,[Define to 1 if C++ supports operator delete(void *, void *).])
-fi
-AC_LANG_POP(C++)
-])
-dnl
-dnl Check if the compiler dynamic auto arrays.
-dnl
-AC_DEFUN([OCTAVE_DYNAMIC_AUTO_ARRAYS],
-[AC_CACHE_CHECK([whether C++ supports dynamic auto arrays],
-octave_cv_dynamic_auto_arrays,
-[AC_LANG_PUSH(C++)
-AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[]],
-[[void test(char *); int length(); char x[length()]; test(x);]])],
-octave_cv_dynamic_auto_arrays=yes, octave_cv_dynamic_auto_arrays=no)])
-if test $octave_cv_dynamic_auto_arrays = yes; then
-AC_DEFINE(HAVE_DYNAMIC_AUTO_ARRAYS,1,[Define to 1 if C++ supports dynamic auto arrays.])
-fi
-AC_LANG_POP(C++)
-])
-dnl
-dnl Check if the C++ library has the bit_and, bit_or, and bit_xor
-dnl templates defined.
+dnl Alphabetical list of macros in the OCTAVE_ namespace
 dnl
-AC_DEFUN([OCTAVE_CXX_BITWISE_OP_TEMPLATES],
-[AC_CACHE_CHECK([whether bit_and, bit_or, bit_xor are defined in the C++ library],
-octave_cv_cxx_bitwise_op_templates,
-[AC_LANG_PUSH(C++)
-AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[#include <functional>]],
-[[int x = 0;
-int y = 1;
-int z1 = std::bit_and<int>() (x, y);
-int z2 = std::bit_or<int>() (x, y);
-int z3 = std::bit_xor<int>() (x, y);]])],
-octave_cv_cxx_bitwise_op_templates=yes, octave_cv_cxx_bitwise_op_templates=no)])
-if test $octave_cv_cxx_bitwise_op_templates = yes; then
-AC_DEFINE(HAVE_CXX_BITWISE_OP_TEMPLATES,1,[Define to 1 if C++ library has templated bitwise operators.])
-fi
-AC_LANG_POP(C++)
-])
-dnl
-dnl Check if the C++ library has functions to set real and imaginary
-dnl parts of complex numbers independently.
-dnl
-AC_DEFUN([OCTAVE_CXX_COMPLEX_SETTERS],
-[AC_CACHE_CHECK([whether complex class can set components independently],
-octave_cv_cxx_complex_setters,
-[AC_LANG_PUSH(C++)
-AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[#include <complex>]],
-[[std::complex<double> x; x.real (1.0); x.imag (2.0);]])],
-octave_cv_cxx_complex_setters=yes, octave_cv_cxx_complex_setters=no)])
-if test $octave_cv_cxx_complex_setters = yes; then
-AC_DEFINE(HAVE_CXX_COMPLEX_SETTERS,1,[Define to 1 if C++ complex class has void real (T) and void imag (T) methods.])
-fi
-AC_LANG_POP(C++)
-])
-dnl
-dnl Check if the C++ library has functions to access real and imaginary
-dnl parts of complex numbers independently via references.
-dnl
-AC_DEFUN([OCTAVE_CXX_COMPLEX_REFERENCE_ACCESSORS],
-[AC_CACHE_CHECK([whether complex class can reference components independently],
-octave_cv_cxx_complex_reference_accessors,
-[AC_LANG_PUSH(C++)
-AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[#include <complex>]],
-[[std::complex<double> x; x.real () = 1.0; x.imag () = 1.0;]])],
-octave_cv_cxx_complex_reference_accessors=yes, octave_cv_cxx_complex_reference_accessors=no)])
-if test $octave_cv_cxx_complex_reference_accessors = yes; then
-AC_DEFINE(HAVE_CXX_COMPLEX_REFERENCE_ACCESSORS,1,[Define to 1 if C++ complex class has T& real (void) and T& imag (void) methods.])
-fi
-AC_LANG_POP(C++)
-])
+
 dnl
 dnl Check if the Carbon Framework defines CGDisplayBitsPerPixel.
 dnl
-AC_DEFUN([OCTAVE_CARBON_CGDISPLAYBITSPERPIXEL],
-[AC_CACHE_CHECK([whether CGDisplayBitsPerPixel is defined in the Carbon Framework],
-octave_cv_carbon_cgdisplaybitsperpixel,
-[AC_LANG_PUSH(C++)
-AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
-#include <Carbon/Carbon.h>
-]], [[
-CGDirectDisplayID display = CGMainDisplayID ();
-size_t depth = CGDisplayBitsPerPixel (display);
-]])],
-octave_cv_carbon_cgdisplaybitsperpixel=yes, octave_cv_carbon_cgdisplaybitsperpixel=no)])
-if test $octave_cv_carbon_cgdisplaybitsperpixel = yes; then
-AC_DEFINE(HAVE_CARBON_CGDISPLAYBITSPERPIXEL,1,[Define to 1 if Carbon Framework has CGDisplayBitsPerPixel.])
-fi
-AC_LANG_POP(C++)
-])
-dnl
-dnl The following test is from Karl Berry's Kpathsearch library.  I'm
-dnl including it here in case we someday want to make the use of
-dnl kpathsea optional.
-dnl
-dnl Some BSD putenv's, e.g., FreeBSD, do malloc/free's on the environment.
-dnl This test program is due to Mike Hibler <mike@cs.utah.edu>.
-dnl We don't actually need to run this if we don't have putenv, but it
-dnl doesn't hurt.
-dnl 
-AC_DEFUN([OCTAVE_SMART_PUTENV],
-[AC_MSG_CHECKING([whether putenv uses malloc])
-AC_CACHE_VAL(octave_cv_func_putenv_malloc,
-[AC_RUN_IFELSE([AC_LANG_SOURCE([[
-#define VAR	"YOW_VAR"
-#define STRING1 "GabbaGabbaHey"
-#define STRING2 "Yow!!"		/* should be shorter than STRING1 */
-extern char *getenv (); /* in case char* and int don't mix gracefully */
-main ()
-{
-  char *str1, *rstr1, *str2, *rstr2;
-  str1 = getenv (VAR);
-  if (str1)
-    exit (1);
-  str1 = malloc (strlen (VAR) + 1 + strlen (STRING1) + 1);
-  if (str1 == 0)
-    exit (2);
-  strcpy (str1, VAR);
-  strcat (str1, "=");
-  strcat (str1, STRING1);
-  if (putenv (str1) < 0)
-    exit (3);
-  rstr1 = getenv (VAR);
-  if (rstr1 == 0)
-    exit (4);
-  rstr1 -= strlen (VAR) + 1;
-  if (strncmp (rstr1, VAR, strlen (VAR)))
-    exit (5);
-  str2 = malloc (strlen (VAR) + 1 + strlen (STRING2) + 1);
-  if (str2 == 0 || str1 == str2)
-    exit (6);
-  strcpy (str2, VAR);
-  strcat (str2, "=");
-  strcat (str2, STRING2);
-  if (putenv (str2) < 0)
-    exit (7);
-  rstr2 = getenv (VAR);
-  if (rstr2 == 0)
-    exit (8);
-  rstr2 -= strlen (VAR) + 1;
-#if 0
-  printf ("rstr1=0x%x, rstr2=0x%x\n", rstr1, rstr2);
-  /*
-   * If string from first call was reused for the second call,
-   * you had better not do a free on the first string!
-   */
-  if (rstr1 == rstr2)
-          printf ("#define SMART_PUTENV\n");
-  else
-          printf ("#undef SMART_PUTENV\n");
-#endif
-  exit (rstr1 == rstr2 ? 0 : 1);
-}]])], octave_cv_func_putenv_malloc=yes, octave_cv_func_putenv_malloc=no,
-    octave_cv_func_putenv_malloc=no)])dnl
-AC_MSG_RESULT([$octave_cv_func_putenv_malloc])
-if test $octave_cv_func_putenv_malloc = yes; then
-  AC_DEFINE(SMART_PUTENV,1,[To quiet autoheader.])
-fi])
-dnl
-dnl Check if C++ compiler needs the new friend template declaration
-dnl syntax. 
-dnl
-AC_DEFUN([OCTAVE_CXX_NEW_FRIEND_TEMPLATE_DECL], [
-  AC_REQUIRE([AC_PROG_CXX])
-  AC_MSG_CHECKING([for C++ support for new friend template declaration])
-  AC_CACHE_VAL(octave_cv_cxx_new_friend_template_decl, [
-    AC_LANG_PUSH(C++)
-    rm -f conftest.h
-    cat > conftest.h <<EOB
-       struct A {
-	 friend int operator== (const A&, const A&);
-	 A (int) { }
-       };
-
-       template <class T> int
-       operator== (const T&, const T&)
-       {
-	 return 0;
-       }
-EOB
-    AC_LINK_IFELSE([AC_LANG_PROGRAM([[#include "conftest.h"]],
-      [[A a (1);
-        return a == A(1);]])],
-      [octave_cv_cxx_new_friend_template_decl=no],
-      [octave_cv_cxx_new_friend_template_decl=yes])
+AC_DEFUN([OCTAVE_CARBON_CGDISPLAYBITSPERPIXEL], [
+  AC_CACHE_CHECK([whether CGDisplayBitsPerPixel is defined in the Carbon Framework],
+    [octave_cv_func_carbon_cgdisplaybitsperpixel],
+    [AC_LANG_PUSH(C++)
+    AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+        #include <Carbon/Carbon.h>
+        ]], [[
+        CGDirectDisplayID display = CGMainDisplayID ();
+        size_t depth = CGDisplayBitsPerPixel (display);
+      ]])],
+      octave_cv_func_carbon_cgdisplaybitsperpixel=yes,
+      octave_cv_func_carbon_cgdisplaybitsperpixel=no)
     AC_LANG_POP(C++)
   ])
-  AC_MSG_RESULT([$octave_cv_cxx_new_friend_template_decl])
-  if test $octave_cv_cxx_new_friend_template_decl = yes; then
-    AC_DEFINE(CXX_NEW_FRIEND_TEMPLATE_DECL,1,[Define to 1 if your compiler supports `<>' stuff for template friends.])
+  if test $octave_cv_func_carbon_cgdisplaybitsperpixel = yes; then
+    AC_DEFINE(HAVE_CARBON_CGDISPLAYBITSPERPIXEL, 1,
+      [Define to 1 if Carbon Framework has CGDisplayBitsPerPixel.])
   fi
 ])
 dnl
 dnl Check if C compiler handles FLAG command line option.  If two
 dnl arguments are specified, execute the second arg as shell commands.
 dnl Otherwise, add FLAG to CFLAGS if the compiler accepts the flag.
 dnl
 AC_DEFUN([OCTAVE_CC_FLAG], [
   ac_safe=`echo "$1" | sed 'y% ./+-:=%___p___%'`
   AC_MSG_CHECKING([whether ${CC-cc} accepts $1])
-  AC_CACHE_VAL(octave_cv_cc_flag_$ac_safe, [
-    AC_LANG_PUSH(C)
+  AC_CACHE_VAL([octave_cv_cc_flag_$ac_safe],
+    [AC_LANG_PUSH(C)
     XCFLAGS="$CFLAGS"
     CFLAGS="$CFLAGS $1"
     AC_LINK_IFELSE([AC_LANG_PROGRAM([], [])],
-      eval "octave_cv_cc_flag_$ac_safe=yes",
-      eval "octave_cv_cc_flag_$ac_safe=no")
+      [eval "octave_cv_cc_flag_$ac_safe=yes"],
+      [eval "octave_cv_cc_flag_$ac_safe=no"])
     CFLAGS="$XCFLAGS"
     AC_LANG_POP(C)
   ])
   if eval "test \"`echo '$octave_cv_cc_flag_'$ac_safe`\" = yes"; then
     AC_MSG_RESULT(yes)
-    ifelse([$2], , [
-      CFLAGS="$CFLAGS $1"
+    ifelse([$2], , 
+      [CFLAGS="$CFLAGS $1"
       AC_MSG_RESULT([adding $1 to CFLAGS])], [$2])
   else
     AC_MSG_RESULT(no)
     ifelse([$3], , , [$3])
   fi
 ])
 dnl
-dnl Check if C++ compiler handles FLAG command line option.  If two
-dnl arguments are specified, execute the second arg as shell commands.
-dnl Otherwise, add FLAG to CXXFLAGS if the compiler accepts the flag.
+dnl Check whether a math mapper function is available in <cmath>.
+dnl Will define HAVE_CMATH_FUNC if there is a double variant and
+dnl HAVE_CMATH_FUNCF if there is a float variant.
+dnl Currently capable of checking for functions with single 
+dnl argument and returning bool/int/real.
 dnl
-AC_DEFUN([OCTAVE_CXX_FLAG], [
-  ac_safe=`echo "$1" | sed 'y%./+-:=%__p___%'`
-  AC_MSG_CHECKING([whether ${CXX-g++} accepts $1])
-  AC_CACHE_VAL(octave_cv_cxx_flag_$ac_safe, [
-    AC_LANG_PUSH(C++)
-    XCXXFLAGS="$CXXFLAGS"
-    CXXFLAGS="$CXXFLAGS $1"
-    AC_LINK_IFELSE([AC_LANG_PROGRAM([], [])],
-      eval "octave_cv_cxx_flag_$ac_safe=yes",
-      eval "octave_cv_cxx_flag_$ac_safe=no")
-    CXXFLAGS="$XCXXFLAGS"
+AC_DEFUN([OCTAVE_CHECK_FUNC_CMATH], [
+  ac_safe=`echo "$1" | sed 'y% ./+-:=%___p___%'`
+
+  AC_CACHE_CHECK([for std::$1 in <cmath>],
+    [octave_cv_func_cmath_$ac_safe],
+    [AC_LANG_PUSH(C++)
+    AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+        #include <cmath>
+        void take_func (bool (*func) (double x));
+        void take_func (int (*func) (double x));
+        void take_func (double (*func) (double x));
+        ]], [[
+        take_func(std::$1);
+        ]])],
+      [eval "octave_cv_func_cmath_$ac_safe=yes"],
+      [eval "octave_cv_func_cmath_$ac_safe=no"])
     AC_LANG_POP(C++)
   ])
-  if eval "test \"`echo '$octave_cv_cxx_flag_'$ac_safe`\" = yes"; then
-    AC_MSG_RESULT(yes)
-    ifelse([$2], , [
-      CXXFLAGS="$CXXFLAGS $1"
-      AC_MSG_RESULT([adding $1 to CXXFLAGS])], [$2])
-  else
-    AC_MSG_RESULT(no)
-    ifelse([$3], , , [$3])
+  if eval "test \"`echo '$octave_cv_func_cmath_'$ac_safe`\" = yes"; then
+    AC_DEFINE(AS_TR_CPP([[HAVE_CMATH_][$1]]), 1,
+      [Define to 1 if <cmath> provides $1.])
   fi
-])
-dnl
-dnl Check if Fortran compiler handles FLAG command line option.  If
-dnl two arguments are specified, execute the second arg as shell
-dnl commands.  Otherwise, add FLAG to FFLAGS if the compiler accepts
-dnl the flag.
-dnl
-AC_DEFUN([OCTAVE_F77_FLAG], [
-  ac_safe=`echo "$1" | sed 'y%./+-:=%__p___%'`
-  AC_MSG_CHECKING([whether ${F77-g77} accepts $1])
-  AC_CACHE_VAL(octave_cv_f77_flag_$ac_safe, [
-    AC_LANG_PUSH(Fortran 77)
-    XFFLAGS="$FFLAGS"
-    FFLAGS="$FFLAGS $1"
-    AC_LINK_IFELSE([AC_LANG_PROGRAM([], [])],
-      eval "octave_cv_f77_flag_$ac_safe=yes",
-      eval "octave_cv_f77_flag_$ac_safe=no")
-    FFLAGS="$XFFLAGS"
-    AC_LANG_POP(Fortran 77)
+
+  AC_CACHE_CHECK([for std::$1 (float variant) in <cmath>],
+    [octave_cv_func_cmath_f$ac_safe],
+    [AC_LANG_PUSH(C++)
+    AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+        #include <cmath>
+        void take_func (bool (*func) (float x));
+        void take_func (int (*func) (float x));
+        void take_func (float (*func) (float x));
+        ]], [[
+        take_func(std::$1);
+        ]])],
+      [eval "octave_cv_func_cmath_f$ac_safe=yes"],
+      [eval "octave_cv_func_cmath_f$ac_safe=no"])
+    AC_LANG_POP(C++)
   ])
-  if eval "test \"`echo '$octave_cv_f77_flag_'$ac_safe`\" = yes"; then
-    AC_MSG_RESULT(yes)
-    ifelse([$2], , [
-      FFLAGS="$FFLAGS $1"
-      AC_MSG_RESULT([adding $1 to FFLAGS])], [$2])
-  else
-    AC_MSG_RESULT(no)
-    ifelse([$3], , , [$3])
+  if eval "test \"`echo '$octave_cv_func_cmath_f'$ac_safe`\" = yes"; then
+    AC_DEFINE(AS_TR_CPP([[HAVE_CMATH_][$1][F]]), 1,
+      [Define to 1 if <cmath> provides float variant of $1.])
   fi
 ])
 dnl
 dnl Check if Fortran compiler has the intrinsic function ISNAN.
 dnl
-AC_DEFUN([OCTAVE_CHECK_FORTRAN_HAVE_ISNAN], [
-  AC_LANG_PUSH(Fortran 77)
+AC_DEFUN([OCTAVE_CHECK_FUNC_FORTRAN_ISNAN], [
   AC_CACHE_CHECK([whether $F77 has the intrinsic function ISNAN],
-                 [octave_cv_fortran_have_isnan],
-[AC_COMPILE_IFELSE(
-[      program foo
+    [octave_cv_func_fortran_isnan],
+    [AC_LANG_PUSH(Fortran 77)
+    AC_COMPILE_IFELSE(
+[[      program foo
       implicit none
       real x
       double precision y
       if (isnan(x)) then
-         print *, 'x is NaN'
+        print *, 'x is NaN'
       end if
       if (isnan(y)) then
-         print *, 'y is NaN'
+        print *, 'y is NaN'
       end if
-      end program], [octave_cv_fortran_have_isnan=yes], [octave_cv_fortran_have_isnan=no]
-)])
-  AC_LANG_POP(Fortran 77)      
+      end program
+]],
+      octave_cv_func_fortran_isnan=yes, octave_cv_func_fortran_isnan=no)
+    AC_LANG_POP(Fortran 77)      
+  ])
 ])
 dnl
-dnl Check if the default Fortran INTEGER is 64 bits wide.
+dnl Check if function gluTessCallback is called with "(...)".
 dnl
-AC_DEFUN([OCTAVE_CHECK_FORTRAN_INTEGER_SIZE], [
-  octave_fintsize_save_FFLAGS="$FFLAGS"
-  FFLAGS="$FFLAGS $F77_INTEGER_8_FLAG"
-  AC_LANG_PUSH(Fortran 77)
-  AC_CACHE_CHECK([whether $F77 generates correct size integers],
-                 [octave_cv_fortran_integer_size],
-[AC_COMPILE_IFELSE(
-[      subroutine foo(n, in, out)
-      integer n, in(n), out(n)
-      integer i
-      do 10 i = 1, n
-        out(i) = in(i)
-   10 continue
-      return
-      end],
-[mv conftest.$ac_objext fintsize.$ac_objext
-
-  octave_fintsize_save_LIBS="$LIBS"
-  LIBS="fintsize.$ac_objext $[]_AC_LANG_PREFIX[]LIBS"
-  AC_LANG_PUSH(C)dnl
-  AC_RUN_IFELSE([AC_LANG_PROGRAM([[#include <assert.h>]], [[
-#ifdef USE_64_BIT_IDX_T
-#if IDX_TYPE_LONG
-  typedef long octave_idx_type;
-#else
-  typedef int octave_idx_type;
-#endif
-#else
-  typedef int octave_idx_type;
-#endif
-  octave_idx_type n = 2;
-  octave_idx_type in[2];
-  octave_idx_type out[2];
-  in[0] = 13;
-  in[0] = 42;
-  F77_FUNC(foo,FOO) (&n, &in, &out);
-  assert (in[0] == out[0] && in[1] == out[1]);
-]])],
-  [octave_cv_fortran_integer_size=yes],
-  [octave_cv_fortran_integer_size=no],
-  [octave_cv_fortran_integer_size=yes])
-  AC_LANG_POP(C)dnl
-  LIBS="$octave_fintsize_save_LIBS"
-rm -f conftest.$ac_objext fintsize.$ac_objext
-], [
-  rm -f conftest.$ac_objext
-  AC_MSG_FAILURE([cannot compile a simple Fortran program])
-  octave_cv_fortran_integer_size=no])])
-  AC_LANG_POP(Fortran 77)
-  FFLAGS="$octave_fintsize_save_FFLAGS"
+AC_DEFUN([OCTAVE_CHECK_FUNC_GLUTESSCALLBACK_THREEDOTS], [
+  AC_CACHE_CHECK([whether gluTessCallback is called with "(...)"],
+    [octave_cv_func_glutesscallback_threedots],
+    [AC_LANG_PUSH(C++)
+    AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+        #ifdef HAVE_GL_GLU_H
+        # include <GL/glu.h>
+        #elif defined HAVE_OPENGL_GLU_H || defined HAVE_FRAMEWORK_OPENGL
+        # include <OpenGL/glu.h>
+        #endif
+        ]], [[
+        GLvoid (*func)(...);
+        gluTessCallback(0, 0, func);
+        ]])],
+      octave_cv_func_glutesscallback_threedots=yes,
+      octave_cv_func_glutesscallback_threedots=no)
+    AC_LANG_POP(C++)
+  ])
+  if test $octave_cv_func_glutesscallback_threedots = "yes"; then
+    AC_DEFINE(HAVE_GLUTESSCALLBACK_THREEDOTS, 1, 
+      [Define to 1 if gluTessCallback is called with (...).])
+  fi
 ])
 dnl
-dnl Add warning to final summary.
+dnl Check whether HDF5 library has version 1.6 API functions.
 dnl
-AC_DEFUN([OCTAVE_CONFIGURE_WARNING], [
-  AC_MSG_WARN([$][$1])
-  m4_set_add([summary_warning_list], [$1])
+AC_DEFUN([OCTAVE_CHECK_HDF5_HAS_VER_16_API], [
+  AC_CACHE_CHECK([whether HDF5 library has enforced version 1.6 API],
+    [octave_cv_hdf5_has_ver_16_api],
+    [AC_LINK_IFELSE([AC_LANG_PROGRAM([[
+      #include <hdf5.h>
+      ]], [[
+      H5Eset_auto (0, 0);
+      ]])],
+      octave_cv_hdf5_has_ver_16_api=yes,
+      octave_cv_hdf5_has_ver_16_api=no)
+  ])
+  if test "$octave_cv_hdf5_has_ver_16_api" != "yes"; then
+    AC_DEFINE(HAVE_HDF5_18, 1, [Define to 1 if >=HDF5-1.8 is available.])
+  fi
 ])
 dnl
-dnl Print final summary.
+dnl Usage:
+dnl OCTAVE_CHECK_LIB(LIBRARY, DOC-NAME, WARN-MSG, HEADER, FUNC,
+dnl                  LANG, DOC-STRING, EXTRA-CHECK)
 dnl
-AC_DEFUN([OCTAVE_CONFIGURE_WARNING_SUMMARY], [
-  m4_set_foreach([summary_warning_list], [elt], [
-    if test -n "[$]elt"; then
-      AC_MSG_WARN([$]elt)
-      warn_msg_printed=true
-    fi])
-])
-dnl
-dnl OCTAVE_CHECK_LIBRARY(LIBRARY, DOC-NAME, WARN-MSG, HEADER, FUNC,
-dnl                      LANG, DOC-STRING, EXTRA-CHECK)
-dnl
-AC_DEFUN([OCTAVE_CHECK_LIBRARY], [
+AC_DEFUN([OCTAVE_CHECK_LIB], [
   AC_ARG_WITH([$1-includedir],
     [AS_HELP_STRING([--with-$1-includedir=DIR],
       [look for $2 include files in DIR])],
     [m4_toupper([$1])_CPPFLAGS="-I$withval"])
   AC_SUBST(m4_toupper([$1])_CPPFLAGS)
 
   AC_ARG_WITH([$1-libdir],
     [AS_HELP_STRING([--with-$1-libdir=DIR],
@@ -520,661 +250,65 @@ AC_DEFUN([OCTAVE_CHECK_LIBRARY], [
     ;;
   esac
 
   [TEXINFO_]m4_toupper([$1])=
   warn_$1="$3"
   m4_set_add([summary_warning_list], [warn_$1])
 
   if test -n "$m4_toupper([$1])_LIBS"; then
-    octave_check_library_save_CPPFLAGS="$CPPFLAGS"
+    octave_check_lib_save_CPPFLAGS="$CPPFLAGS"
     CPPFLAGS="$m4_toupper([$1])_CPPFLAGS $CPPFLAGS"
     m4_ifnblank([$6], [AC_LANG_PUSH($6)])
     octave_$1_check_for_lib=false
     m4_ifblank([$4], [octave_$1_check_for_lib=true],
                [AC_CHECK_HEADERS($4, [octave_$1_check_for_lib=true; break])])
     if $octave_$1_check_for_lib; then
-      octave_check_library_save_LDFLAGS="$LDFLAGS"
+      octave_check_lib_save_LDFLAGS="$LDFLAGS"
       LDFLAGS="$m4_toupper([$1])_LDFLAGS $LDFLAGS"
-      octave_check_library_save_LIBS="$LIBS"
+      octave_check_lib_save_LIBS="$LIBS"
       LIBS="$m4_toupper([$1])_LIBS $LIBS"
       octave_$1_ok=no
       AC_MSG_CHECKING([for $5 in $m4_toupper([$1])_LIBS])
       AC_LINK_IFELSE([AC_LANG_CALL([], [$5])],
-	[octave_$1_ok=yes])
+        [octave_$1_ok=yes])
       AC_MSG_RESULT([$octave_$1_ok])
       if test $octave_$1_ok = yes; then
-	m4_ifblank([$8], [
-	  warn_$1=
-	  AC_DEFINE([HAVE_]m4_toupper([$1]), 1,
+        m4_ifblank([$8], [
+          warn_$1=
+          AC_DEFINE([HAVE_]m4_toupper([$1]), 1,
             [Define to 1 if $2 is available.])
-	  [TEXINFO_]m4_toupper([$1])="@set [HAVE_]m4_toupper([$1])"], [$8])
+          [TEXINFO_]m4_toupper([$1])="@set [HAVE_]m4_toupper([$1])"], [$8])
       fi
-      LIBS="$octave_check_library_save_LIBS"
-      LDFLAGS="$octave_check_library_save_LDFLAGS"
+      LIBS="$octave_check_lib_save_LIBS"
+      LDFLAGS="$octave_check_lib_save_LDFLAGS"
     fi
     m4_ifnblank([$6], [AC_LANG_POP($6)])
-    CPPFLAGS="$octave_check_library_save_CPPFLAGS"
+    CPPFLAGS="$octave_check_lib_save_CPPFLAGS"
   fi
   AC_SUBST(m4_toupper([$1])_LIBS)
   AC_SUBST([TEXINFO_]m4_toupper([$1]))
   if test -n "$warn_$1"; then
     AC_MSG_WARN([$warn_$1])
     m4_toupper([$1])_LIBS=
   fi
 ])
 dnl
-dnl Check for flex.
-dnl
-AC_DEFUN([OCTAVE_PROG_FLEX], [
-### For now, don't define LEXLIB to be -lfl -- we don't use anything in
-### it, and it might not be installed.
-###
-### Also make sure that we generate an interactive scanner if we are
-### using flex.
-  AC_PROG_LEX
-  case "$LEX" in
-    flex*)
-      LFLAGS="-I"
-      AC_MSG_RESULT([defining LFLAGS to be $LFLAGS])
-      LEXLIB=
-    ;;
-    *)
-      LEX='$(top_srcdir)/build-aux/missing flex'
-      warn_flex="
-
-I didn't find flex, but it's only a problem if you need to reconstruct
-lex.cc, which is the case if you're building from VCS sources.
-"
-      OCTAVE_CONFIGURE_WARNING([warn_flex])
-    ;;
-  esac
-  AC_SUBST(LFLAGS)
-])
-dnl
-dnl Check for bison.
-dnl
-AC_DEFUN([OCTAVE_PROG_BISON], [
-  AC_PROG_YACC
-  case "$YACC" in
-    bison*)
-    ;;
-    *)
-      YACC='$(top_srcdir)/build-aux/missing bison'
-      warn_bison="
-
-I didn't find bison, but it's only a problem if you need to
-reconstruct parse.cc, which is the case if you're building from VCS
-sources.
-
-"
-      OCTAVE_CONFIGURE_WARNING([warn_bison])
-    ;;
-  esac
-])
-dnl
-dnl What pager should we use?
-dnl
-AC_DEFUN([OCTAVE_PROG_PAGER],
-[if test "$cross_compiling" = yes; then
-  DEFAULT_PAGER=less
-  AC_MSG_RESULT([assuming $DEFAULT_PAGER exists on $canonical_host_type host])
-  AC_SUBST(DEFAULT_PAGER)
-else
-  octave_possible_pagers="less more page pg"
-  case "$canonical_host_type" in
-    *-*-cygwin* | *-*-mingw32* | *-*-msdosmsvc)
-      octave_possible_pagers="$octave_possible_pagers more.com"
-    ;;
-  esac
-
-  AC_CHECK_PROGS(DEFAULT_PAGER, $octave_possible_pagers, [])
-  if test -z "$DEFAULT_PAGER"; then
-    warn_less="I couldn't find \`less', \`more', \`page', or \`pg'"
-    OCTAVE_CONFIGURE_WARNING([warn_less])
-  fi
-fi
-])
-dnl
-dnl Check for gnuplot.
-dnl
-AC_DEFUN([OCTAVE_PROG_GNUPLOT], [
-gp_names="gnuplot"
-gp_default="gnuplot"
-if test "$cross_compiling" = yes; then
-  GNUPLOT="$gp_default"
-  AC_MSG_RESULT([assuming $GNUPLOT exists on $canonical_host_type host])
-else
-  AC_CHECK_PROGS(GNUPLOT, [$gp_names])
-  if test -z "$GNUPLOT"; then
-    GNUPLOT="$gp_default"
-    warn_gnuplot="
-
-gnuplot not found.  It isn't necessary to have gnuplot installed, but
-without native graphics or gnuplot you won't be able to use any of
-Octave's plotting commands.
-"
-    OCTAVE_CONFIGURE_WARNING([warn_gnuplot])
-  fi
-fi
-AC_SUBST(GNUPLOT)
-])
-dnl
-dnl Check for gperf.
-dnl
-AC_DEFUN([OCTAVE_PROG_GPERF], [
-  AC_CHECK_PROG(GPERF, gperf, gperf, [])
-  if test -z "$GPERF"; then
-    GPERF='$(top_srcdir)/build-aux/missing gperf'
-    warn_gperf="
-
-I didn't find gperf, but it's only a problem if you need to
-reconstruct oct-gperf.h 
-"
-    OCTAVE_CONFIGURE_WARNING([warn_gperf])
-  fi
-  AC_SUBST(GPERF)
-])
-dnl
-dnl Check for ghostscript.
-dnl
-AC_DEFUN([OCTAVE_PROG_GHOSTSCRIPT], [
-  case "$canonical_host_type" in
-    *-*-mingw* | *-*-msdosmsvc)
-      gs_names="gswin32c gs mgs"
-    ;;
-    *)
-      gs_names="gs"
-    ;;
-  esac
-  AC_CHECK_PROGS(GHOSTSCRIPT, [$gs_names])
-  if test -z "$GHOSTSCRIPT"; then
-    GHOSTSCRIPT='$(top_srcdir)/build-aux/missing gs'
-    warn_ghostscript="
-
-I didn't find ghostscript, so reconstructing figures for the manual
-will fail, and saving graphics in some output formats will fail when
-using Octave
-"
-
-    OCTAVE_CONFIGURE_WARNING([warn_ghostscript])
-  fi
-  AC_SUBST(GHOSTSCRIPT)
-])
-dnl
-dnl Check for makeinfo.
-dnl
-AC_DEFUN([OCTAVE_PROG_MAKEINFO],
-dnl use MKINFO, not MAKEINFO, for variable name because Automake automatically
-dnl defines a value for MAKEINFO even when it does not exist which will then
-dnl fool the 'test -z' line.
-  [AC_CHECK_PROG(MKINFO, makeinfo, makeinfo, [])
-   if test -z "$MKINFO"; then
-     AC_MSG_ERROR([makeinfo program required for reading documentation])
-   fi
-])
-dnl
-dnl Check for texi2dvi.
-dnl
-AC_DEFUN([OCTAVE_PROG_TEXI2DVI], [
-  AC_CHECK_PROG(TEXI2DVI, texi2dvi, texi2dvi, [])
-  if test -z "$TEXI2DVI"; then
-    TEXI2DVI='$(top_srcdir)/build-aux/missing texi2dvi'
-    warn_texi2dvi="
-
-I didn't find texi2dvi, but it's only a problem if you need to
-reconstruct the DVI version of the manual
-"
-    OCTAVE_CONFIGURE_WARNING([warn_texi2dvi])
-  fi
-  AC_SUBST(TEXI2DVI)
-])
-dnl
-dnl Check for texi2pdf.
-dnl
-AC_DEFUN([OCTAVE_PROG_TEXI2PDF], [
-  AC_REQUIRE([OCTAVE_PROG_TEXI2DVI])
-  AC_CHECK_PROG(TEXI2PDF, texi2pdf, texi2pdf, [])
-  if test -z "$TEXI2PDF"; then
-    missing=true;
-    if test -n "$TEXI2DVI"; then
-      TEXI2PDF="$TEXI2DVI --pdf"
-      missing=false;
-    fi
-  else
-    missing=false;
-  fi
-  if $missing; then
-    TEXI2PDF='$(top_srcdir)/build-aux/missing texi2pdf'
-    warn_texi2pdf="
-
-I didn't find texi2pdf, but it's only a problem if you need to
-reconstruct the PDF version of the manual
-"
-    OCTAVE_CONFIGURE_WARNING([warn_texi2pdf])
-  fi
-  AC_SUBST(TEXI2PDF)
-])
-dnl
-dnl Check if the C++ library is ISO compliant.
-dnl FIXME: This is obviously very simplistic, and trivially fooled.
-dnl
-AC_DEFUN([OCTAVE_CXX_ISO_COMPLIANT_LIBRARY], [
-  AC_REQUIRE([AC_PROG_CXX])
-  AC_MSG_CHECKING([if C++ library is ISO compliant])
-  AC_CACHE_VAL(octave_cv_cxx_iso_compliant_library, [
-    AC_LANG_PUSH(C++)
-    rm -f conftest.h
-### Omitting cwctype for now, since it is broken with gcc-3.0.x and
-### possibly other versions...
-    for inc in algorithm bitset cassert cctype cerrno cfloat ciso646 \
-	climits clocale cmath complex csetjmp csignal cstdarg cstddef \
-	cstdio cstdlib cstring ctime cwchar deque exception \
-	fstream functional iomanip ios iosfwd iostream istream iterator \
-	limits list locale map memory new numeric ostream queue set \
-	sstream stack stdexcept streambuf string strstream typeinfo \
-	utility valarray vector; do
-      echo "#include <$inc>" >> conftest.h
-    done
-    AC_LINK_IFELSE([AC_LANG_PROGRAM([[#include "conftest.h"]],
-      [[std::bitset<50> flags;
-        flags.set();
-        int digits = std::numeric_limits<unsigned long>::digits;
-        digits = 0;]])],
-      [octave_cv_cxx_iso_compliant_library=yes],
-      [octave_cv_cxx_iso_compliant_library=no])
-    AC_LANG_POP(C++)
-  ])
-  AC_MSG_RESULT([$octave_cv_cxx_iso_compliant_library])
-  if test $octave_cv_cxx_iso_compliant_library = yes; then
-    AC_DEFINE(CXX_ISO_COMPLIANT_LIBRARY, 1, [Define to 1 if your C++ runtime library is ISO compliant.])
-  fi
-])
-dnl
-dnl Allow the user disable support for command line editing using GNU
-dnl readline.
-dnl
-dnl OCTAVE_ENABLE_READLINE
-AC_DEFUN([OCTAVE_ENABLE_READLINE], [
-  USE_READLINE=true
-  READLINE_LIBS=
-  AC_ARG_ENABLE(readline,
-    [  --enable-readline       use readline library (default is yes)],
-    [if test "$enableval" = no; then
-       USE_READLINE=false
-       warn_readline="command editing and history features require GNU Readline"
-     fi])
-  if $USE_READLINE; then
-    save_LIBS="$LIBS"
-    LIBS="$TERM_LIBS"
-    AC_CHECK_LIB(readline, rl_set_keyboard_input_timeout, [
-      READLINE_LIBS="-lreadline"
-      AC_DEFINE(USE_READLINE, 1, [Define to 1 to use the readline library.])
-    ], [
-      AC_MSG_WARN([I need GNU Readline 4.2 or later])
-      AC_MSG_ERROR([this is fatal unless you specify --disable-readline])
-    ])
-    LIBS="$save_LIBS"
-  fi
-  AC_SUBST(READLINE_LIBS)
-])
-dnl
-dnl Check if C++ reinterpret cast works for function pointers.
-dnl
-AC_DEFUN([OCTAVE_CXX_BROKEN_REINTERPRET_CAST], [
-  AC_REQUIRE([AC_PROG_CXX])
-  AC_LANG_PUSH(C++)
-  AC_CACHE_CHECK([for broken C++ reinterpret_cast],
-    octave_cv_cxx_broken_reinterpret_cast, [
-    AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[#include <cmath>]], [[
-      typedef double (*fptr) (double);
-      fptr psin = sin;
-      void *vptr = reinterpret_cast<void *> (psin);
-      psin = reinterpret_cast<fptr> (vptr);]])],
-      octave_cv_cxx_broken_reinterpret_cast=no,
-      octave_cv_cxx_broken_reinterpret_cast=yes)])
-  if test $octave_cv_cxx_broken_reinterpret_cast = yes ; then
-    AC_DEFINE(CXX_BROKEN_REINTERPRET_CAST, 1, [Define to 1 if C++ reinterpret_cast fails for function pointers.])
-fi
-  AC_LANG_POP(C++)])
-dnl
-dnl Find find program.
-dnl
-# Prefer GNU find if found.
-AN_MAKEVAR([FIND],  [OCTAVE_PROG_FIND])
-AN_PROGRAM([gfind], [OCTAVE_PROG_FIND])
-AN_PROGRAM([find],  [OCTAVE_PROG_FIND])
-AC_DEFUN([OCTAVE_PROG_FIND],
-[AC_CHECK_PROGS(FIND, gfind find, )])
-dnl
-dnl Find sed program.
-dnl
-# Check for a fully-functional sed program, that truncates
-# as few characters as possible and that supports "\(X\|Y\)"
-# style regular expression alternation.  Prefer GNU sed if found.
-AC_DEFUN([OCTAVE_PROG_SED],
-[AC_MSG_CHECKING([for a usable sed])
-if test -z "$SED"; then
-  AC_CACHE_VAL(ac_cv_path_sed, [
-  # Loop through the user's path and test for sed and gsed.
-  # Then use that list of sed's as ones to test for truncation.
-  _AS_PATH_WALK([$PATH],
-    [for ac_prog in sed gsed; do
-      for ac_exec_ext in '' $ac_executable_extensions; do
-	if AS_EXECUTABLE_P(["$as_dir/$ac_prog$ac_exec_ext"]); then
-	  _sed_list="$_sed_list $as_dir/$ac_prog$ac_exec_ext"
-	fi
-      done
-    done
-    ])
-    AS_TMPDIR(sed)
-    _max=0
-    _count=0
-    # Add /usr/xpg4/bin/sed as it is typically found on Solaris
-    # along with /bin/sed that truncates output.
-    for _sed in $_sed_list /usr/xpg4/bin/sed; do
-      test ! -f ${_sed} && break
-      cat /dev/null > "$tmp/sed.in"
-      _count=0
-      echo $ECHO_N "0123456789$ECHO_C" >"$tmp/sed.in"
-      # Check for GNU sed and select it if it is found.
-      if "${_sed}" --version 2>&1 < /dev/null | egrep '(GNU)' > /dev/null; then
-	octave_cv_path_sed=${_sed}
-	break;
-      fi
-      # Reject if RE alternation is not handled.
-      if test "`echo 'this and that' | ${_sed} -n 's/\(this\|that\).*$/\1/p'`" != "this"; then
-        continue;
-      fi
-      while true; do
-	cat "$tmp/sed.in" "$tmp/sed.in" >"$tmp/sed.tmp"
-	mv "$tmp/sed.tmp" "$tmp/sed.in"
-	cp "$tmp/sed.in" "$tmp/sed.nl"
-	echo >>"$tmp/sed.nl"
-	${_sed} -e 's/a$//' < "$tmp/sed.nl" >"$tmp/sed.out" || break
-	cmp -s "$tmp/sed.out" "$tmp/sed.nl" || break
-	# 10000 chars as input seems more than enough
-	test $_count -gt 10 && break
-	_count=`expr $_count + 1`
-	if test $_count -gt $_max; then
-	  _max=$_count
-	  octave_cv_path_sed=$_sed
-	fi
-      done
-    done
-    rm -rf "$tmp"
-  ])
-  SED=$octave_cv_path_sed
-  if test -z "$SED"; then
-    AC_MSG_ERROR([no usable version of sed found])
-  fi
-fi
-AC_SUBST(SED)
-AC_MSG_RESULT([$SED])
-])
-dnl
-dnl Find Perl program.
-dnl
-AC_DEFUN([OCTAVE_PROG_PERL],
-[AC_CHECK_PROG(PERL, perl, perl, [])
-  AC_SUBST(PERL)
-])
-dnl
-dnl Find Python program.
-dnl
-AC_DEFUN([OCTAVE_PROG_PYTHON],
-[AC_CHECK_PROG(PYTHON, python, python, [])
-  AC_SUBST(PYTHON)
-])
-dnl
-dnl Find desktop-file-install program.
-dnl
-AC_DEFUN([OCTAVE_PROG_DESKTOP_FILE_INSTALL],
-[AC_CHECK_PROG(DESKTOP_FILE_INSTALL, desktop-file-install, desktop-file-install, [])
-  AC_SUBST(DESKTOP_FILE_INSTALL)
-])
-dnl
-dnl Check for IEEE 754 data format.
-dnl
-AC_DEFUN([OCTAVE_IEEE754_DATA_FORMAT],
-[AC_MSG_CHECKING([for IEEE 754 data format])
-AC_CACHE_VAL(octave_cv_ieee754_data_format,
-[AC_RUN_IFELSE([AC_LANG_SOURCE([[
-int
-main (void) 
-{
-  typedef union { unsigned char c[8]; double d; } ieeebytes;
-   
-  ieeebytes l = {0x1c, 0xbc, 0x6e, 0xf2, 0x54, 0x8b, 0x11, 0x43};
-  ieeebytes b = {0x43, 0x11, 0x8b, 0x54, 0xf2, 0x6e, 0xbc, 0x1c};
-
-  return l.d != 1234567891234567.0 && b.d != 1234567891234567.0;
-}]])],
-  octave_cv_ieee754_data_format=yes,
-  octave_cv_ieee754_data_format=no,
-  octave_cv_ieee754_data_format=yes)])
-if test "$cross_compiling" = yes; then
-  AC_MSG_RESULT([$octave_cv_ieee754_data_format assumed for cross compilation])
-else
-  AC_MSG_RESULT([$octave_cv_ieee754_data_format])
-fi
-if test "$octave_cv_ieee754_data_format" = yes; then
-  AC_DEFINE(HAVE_IEEE754_DATA_FORMAT, 1, [Define to 1 if your system uses IEEE 754 data format.])
-else
-  ## If the format is unknown, then you will probably not have a
-  ## useful system, so we will abort here.  Anyone wishing to
-  ## experiment with building Octave on a system without IEEE
-  ## floating point should be capable of removing this check and
-  ## the one in the octave_ieee_init function in liboctave/lo-ieee.cc.
-  AC_MSG_ERROR([IEEE 754 data format required for building Octave])
-fi
-])
-dnl
-dnl Check for UMFPACK separately split complex matrix and RHS.  Note
-dnl that as umfpack.h can be in three different places, rather than
-dnl include it, just declare the functions needed.
-dnl
-dnl Assumes that the check for umfpack has already been performed.
-dnl
-AC_DEFUN([OCTAVE_UMFPACK_SEPERATE_SPLIT],
-[AC_MSG_CHECKING([for UMFPACK seperate complex matrix and rhs split])
-AC_CACHE_VAL(octave_cv_umfpack_seperate_split,
-[AC_RUN_IFELSE([AC_LANG_SOURCE([[
-#include <stdlib.h>
-#if defined (HAVE_UFSPARSE_UMFPACK_h)
-#include <ufsparse/umfpack.h>
-#elif defined (HAVE_UMFPACK_UMFPACK_H)
-#include <umfpack/umfpack.h>
-#elif defined (HAVE_UMFPACK_H)
-#include <umfpack.h>
-#endif
-int n = 5;
-int Ap[] = {0, 2, 5, 9, 10, 12};
-int Ai[]  = {0, 1, 0, 2, 4, 1, 2, 3, 4, 2, 1, 4};
-double Ax[] = {2., 0., 3., 0., 3., 0., -1., 0., 4., 0., 4., 0., 
-	      -3., 0., 1., 0., 2., 0., 2., 0., 6., 0., 1., 0.};
-double br[] = {8., 45., -3., 3., 19.};
-double bi[] = {0., 0., 0., 0., 0.};
-int main (void)
-{
-  double *null = (double *) NULL ;
-  double *x = (double *)malloc (2 * n * sizeof(double));
-  int i ;
-  void *Symbolic, *Numeric ;
-  (void) umfpack_zi_symbolic (n, n, Ap, Ai, Ax, null, &Symbolic, null, null) ;
-  (void) umfpack_zi_numeric (Ap, Ai, Ax, null, Symbolic, &Numeric, null, null) ;
-  umfpack_zi_free_symbolic (&Symbolic) ;
-  (void) umfpack_zi_solve (0, Ap, Ai, Ax, null, x, null, br, bi, 
-		Numeric, null, null) ;
-  umfpack_zi_free_numeric (&Numeric) ;
-  for (i = 0; i < n; i++, x+=2) 
-    if (fabs(*x - i - 1.) > 1.e-13)
-      return (1);
-  return (0) ;
-}
-]])],
-  octave_cv_umfpack_seperate_split=yes,
-  octave_cv_umfpack_seperate_split=no,
-  octave_cv_umfpack_seperate_split=yes)])
-if test "$cross_compiling" = yes; then
-  AC_MSG_RESULT([$octave_cv_umfpack_seperate_split assumed for cross compilation])
-else
-  AC_MSG_RESULT([$octave_cv_umfpack_seperate_split])
-fi
-if test "$octave_cv_umfpack_seperate_split" = yes; then
-  AC_DEFINE(UMFPACK_SEPARATE_SPLIT, 1, [Define to 1 if the UMFPACK Complex solver allow matrix and RHS to be split independently.])
-fi
-])
-dnl
-dnl Check whether using HDF5 DLL under Windows.  This is done by
-dnl testing for a data symbol in the HDF5 library, which would
-dnl require the definition of _HDF5USEDL_ under MSVC compiler.
-dnl
-AC_DEFUN([OCTAVE_HDF5_DLL], [
-  AC_CACHE_CHECK([if _HDF5USEDLL_ needs to be defined],octave_cv_hdf5_dll, [
-    AC_TRY_LINK([#include <hdf5.h>], [hid_t x = H5T_NATIVE_DOUBLE; return x],
-      octave_cv_hdf5_dll=no, [
-      save_CFLAGS="$CFLAGS"
-      CFLAGS="$CFLAGS -DWIN32 -D_HDF5USEDLL_"
-      save_LIBS="$LIBS"
-      LIBS="$HDF5_LIBS $LIBS"
-      AC_TRY_LINK([#include <hdf5.h>], [hid_t x = H5T_NATIVE_DOUBLE; return x],
-        octave_cv_hdf5_dll=yes,
-	octave_cv_hdf5_dll=no)
-      CFLAGS="$save_CFLAGS"
-      LIBS="$save_LIBS"])])
-  if test "$octave_cv_hdf5_dll" = yes; then
-    AC_DEFINE(_HDF5USEDLL_, 1, [Define to 1 if using HDF5 dll (Win32).])
-  fi])
-dnl
-dnl Check whether HDF5 library has version 1.6 API functions.
-dnl
-AC_DEFUN([OCTAVE_HDF5_HAS_ENFORCED_16_API], [
-  AC_CACHE_CHECK([whether HDF5 library has enforced version 1.6 API],
-    octave_cv_hdf5_has_enforced_16_api, [
-    AC_TRY_LINK([
-#include <hdf5.h>
-], [
-  H5Eset_auto (0, 0);], [
-      octave_cv_hdf5_has_enforced_16_api=yes], [
-      octave_cv_hdf5_has_enforced_16_api=no])])
-  if test "$octave_cv_hdf5_has_enforced_16_api" != "yes"; then
-    AC_DEFINE(HAVE_HDF5_18, 1, [Define to 1 if >=HDF5-1.8 is available.])
-  fi
-])
-dnl
-dnl Check for the Qhull version.
-dnl
-AC_DEFUN([OCTAVE_CHECK_QHULL_VERSION],
-  [AC_CACHE_CHECK([for qh_version in $QHULL_LIBS],
-    octave_cv_lib_qhull_version,  [
-      AC_LINK_IFELSE([AC_LANG_PROGRAM([[
-#include <stdio.h>
-#if defined (HAVE_LIBQHULL_LIBQHULL_H)
-# include <libqhull/libqhull.h>
-# include <libqhull/qset.h>
-# include <libqhull/geom.h>
-# include <libqhull/poly.h>
-# include <libqhull/io.h>
-#elif defined (HAVE_QHULL_LIBQHULL_H) || defined (HAVE_QHULL_QHULL_H)
-# if defined (HAVE_QHULL_LIBQHULL_H)
-#  include <qhull/libqhull.h>
-# else
-#  include <qhull/qhull.h>
-# endif
-# include <qhull/qset.h>
-# include <qhull/geom.h>
-# include <qhull/poly.h>
-# include <qhull/io.h>
-#elif defined (HAVE_LIBQHULL_H) || defined (HAVE_QHULL_H)
-# if defined (HAVE_LIBQHULL_H)
-#  include <libqhull.h>
-# else
-#  include <qhull.h>
-# endif
-# include <qset.h>
-# include <geom.h>
-# include <poly.h>
-# include <io.h>
-#endif
-]], [[
-const char *tmp = qh_version;
-]])], [octave_cv_lib_qhull_version=yes], [octave_cv_lib_qhull_version=no])])
-  if test "$octave_cv_lib_qhull_version" = no; then
-    AC_DEFINE(NEED_QHULL_VERSION, 1,
-      [Define to 1 if the Qhull library needs a qh_version variable defined.])
-  fi
-])
-dnl
-dnl Check whether Qhull works (does not crash).
-dnl
-AC_DEFUN([OCTAVE_CHECK_QHULL_OK],
-  [AC_CACHE_CHECK([whether the qhull library works],
-    octave_cv_lib_qhull_ok, [
-      AC_RUN_IFELSE([AC_LANG_PROGRAM([[
-#include <stdio.h>
-#if defined (HAVE_LIBQHULL_LIBQHULL_H)
-# include <libqhull/libqhull.h>
-# include <libqhull/qset.h>
-# include <libqhull/geom.h>
-# include <libqhull/poly.h>
-# include <libqhull/io.h>
-#elif defined (HAVE_QHULL_LIBQHULL_H) || defined (HAVE_QHULL_QHULL_H)
-# if defined (HAVE_QHULL_LIBQHULL_H)
-#  include <qhull/libqhull.h>
-# else
-#  include <qhull/qhull.h>
-# endif
-# include <qhull/qset.h>
-# include <qhull/geom.h>
-# include <qhull/poly.h>
-# include <qhull/io.h>
-#elif defined (HAVE_LIBQHULL_H) || defined (HAVE_QHULL_H)
-# if defined (HAVE_LIBQHULL_H)
-#  include <libqhull.h>
-# else
-#  include <qhull.h>
-# endif
-# include <qset.h>
-# include <geom.h>
-# include <poly.h>
-# include <io.h>
-#endif
-#ifdef NEED_QHULL_VERSION
-char *qh_version = "version";
-#endif
-]], [[
-int dim = 2;
-int n = 4;
-coordT points[8] = { -0.5, -0.5, -0.5, 0.5, 0.5, -0.5, 0.5, 0.5 };
-boolT ismalloc = 0;
-return qh_new_qhull (dim, n, points, ismalloc, "qhull ", 0, stderr); 
-]])],
-  [octave_cv_lib_qhull_ok=yes],
-  [octave_cv_lib_qhull_ok=no],
-  [octave_cv_lib_qhull_ok=yes])])
-  if test "$octave_cv_lib_qhull_ok" = "yes"; then
-    $1
-  else
-    $2
-  fi
-])
-dnl
 dnl Check whether ARPACK works (does not crash).
 dnl
 dnl Using a pure Fortran program doesn't seem to crash when linked
 dnl with the buggy ARPACK library but the C++ program does.  Maybe it
 dnl is the memory allocation that exposes the bug and using statically
 dnl allocated arrays in Fortran does not?
 dnl
-AC_DEFUN([OCTAVE_CHECK_ARPACK_OK], [
+AC_DEFUN([OCTAVE_CHECK_LIB_ARPACK_OK], [
   AC_LANG_PUSH(C++)
   AC_CACHE_CHECK([whether the arpack library works],
-    [octave_cv_lib_arpack_ok], [
-      AC_RUN_IFELSE([AC_LANG_PROGRAM([[
+    [octave_cv_lib_arpack_ok],
+    [AC_RUN_IFELSE([AC_LANG_PROGRAM([[
 // External functions from ARPACK library
 extern "C" int
 F77_FUNC (dnaupd, DNAUPD) (int&, const char *, const int&, const char *,
                            int&, const double&, double*, const int&,
                            double*, const int&, int*, int*, double*,
                            double*, const int&, int&, long int, long int);
 
 extern "C" int
@@ -1280,164 +414,1240 @@ doit (void)
   for (int i = 0; i < k + 1; i++)
     dr[i] = di[i] = 0.;
 
   int rvec = 1;
 
   double sigmar = 0.0;
   double sigmai = 0.0;
 
-  // In Octave, this is n*(k+1), but k+2 avoids segfault
+  // In Octave, this is n*(k+1), but n*(k+2) avoids segfault
   double *z = new double [n * (k + 1)];
 
   F77_FUNC (dneupd, DNEUPD) (rvec, "A", sel, dr, di, z, n, sigmar,
                              sigmai, workev, "I", n, "LM", k, tol,
                              resid, p, v, n, ip, ipntr, workd,
                              workl, lwork, info, 1L, 1L, 2L);
 }
+
 ]], [[
+
   for (int i = 0; i < 10; i++)
     doit ();
-]])],
-  [octave_cv_lib_arpack_ok=yes],
-  [octave_cv_lib_arpack_ok=no],
-  [octave_cv_lib_arpack_ok=yes])])
+    ]])],
+    octave_cv_lib_arpack_ok=yes,
+    octave_cv_lib_arpack_ok=no,
+    octave_cv_lib_arpack_ok=yes)
+  ])
   AC_LANG_POP(C++)
   if test "$octave_cv_lib_arpack_ok" = "yes"; then
     $1
   else
     $2
   fi
 ])
 dnl
+dnl Check whether using HDF5 DLL under Windows.  This is done by
+dnl testing for a data symbol in the HDF5 library, which would
+dnl require the definition of _HDF5USEDL_ under MSVC compiler.
+dnl
+AC_DEFUN([OCTAVE_CHECK_LIB_HDF5_DLL], [
+  AC_CACHE_CHECK([if _HDF5USEDLL_ needs to be defined],
+    [octave_cv_lib_hdf5_dll],
+    [AC_LINK_IFELSE([AC_LANG_PROGRAM([[
+        #include <hdf5.h>
+        ]], [[
+        hid_t x = H5T_NATIVE_DOUBLE;
+        return x
+      ]])],
+      [octave_cv_lib_hdf5_dll=no],
+      [save_CFLAGS="$CFLAGS"
+      CFLAGS="$CFLAGS -DWIN32 -D_HDF5USEDLL_"
+      save_LIBS="$LIBS"
+      LIBS="$HDF5_LIBS $LIBS"
+      AC_LINK_IFELSE([AC_LANG_PROGRAM([[
+          #include <hdf5.h>
+          ]], [[
+          hid_t x = H5T_NATIVE_DOUBLE;
+          return x
+        ]])],
+        octave_cv_lib_hdf5_dll=yes,
+        octave_cv_lib_hdf5_dll=no)
+      CFLAGS="$save_CFLAGS"
+      LIBS="$save_LIBS"
+    ])
+  ])
+  if test "$octave_cv_lib_hdf5_dll" = yes; then
+    AC_DEFINE(_HDF5USEDLL_, 1, [Define to 1 if using HDF5 dll (Win32).])
+  fi
+])
+dnl
 dnl Check for OpenGL.  If found, define OPENGL_LIBS.
 dnl
 dnl FIXME: The following tests should probably check for the
 dnl libraries separately.
 dnl
 dnl FIXME: Should we allow a way to specify a directory for OpenGL
 dnl libraries and header files?
 dnl
-AC_DEFUN([OCTAVE_OPENGL], [
-OPENGL_LIBS=
+AC_DEFUN([OCTAVE_CHECK_LIB_OPENGL], [
+  OPENGL_LIBS=
 
-### On MacOSX systems the OpenGL framework can be used
-OCTAVE_HAVE_FRAMEWORK(OpenGL, [
-#include <OpenGL/gl.h>
-#include <OpenGL/glu.h> ], [GLint par; glGetIntegerv (GL_VIEWPORT, &par);],
-  [have_framework_opengl="yes"], [have_framework_opengl="no"])
+  ## On MacOSX systems the OpenGL framework can be used
+  OCTAVE_HAVE_FRAMEWORK(OpenGL, [[
+    #include <OpenGL/gl.h>
+    #include <OpenGL/glu.h>
+    ]], [[
+    GLint par; glGetIntegerv (GL_VIEWPORT, &par);
+    ]],
+    have_framework_opengl=yes, have_framework_opengl=no)
 
-if test $have_framework_opengl = "yes"; then
-  AC_DEFINE(HAVE_FRAMEWORK_OPENGL, 1, [Define to 1 if framework OPENGL is available.])
-  OPENGL_LIBS="-Wl,-framework -Wl,OpenGL"
-  AC_MSG_NOTICE([adding -Wl,-framework -Wl,OpenGL to OPENGL_LIBS])
-  OCTAVE_GLUTESSCALLBACK_THREEDOTS
-else
-  case $canonical_host_type in
-    *-*-mingw32* | *-*-msdosmsvc)
-      AC_CHECK_HEADERS(windows.h)
-    ;;
-  esac
-  have_opengl_incs=no
-  AC_CHECK_HEADERS([GL/gl.h OpenGL/gl.h], [
-    AC_CHECK_HEADERS([GL/glu.h OpenGL/glu.h], [
-      have_opengl_incs=yes; break], [], [
+  if test $have_framework_opengl = "yes"; then
+    AC_DEFINE(HAVE_FRAMEWORK_OPENGL, 1,
+      [Define to 1 if framework OPENGL is available.])
+    OPENGL_LIBS="-Wl,-framework -Wl,OpenGL"
+    AC_MSG_NOTICE([adding -Wl,-framework -Wl,OpenGL to OPENGL_LIBS])
+    OCTAVE_CHECK_FUNC_GLUTESSCALLBACK_THREEDOTS
+  else
+    case $canonical_host_type in
+      *-*-mingw32* | *-*-msdosmsvc)
+        AC_CHECK_HEADERS(windows.h)
+      ;;
+    esac
+    have_opengl_incs=no
+    AC_CHECK_HEADERS([GL/gl.h OpenGL/gl.h],
+      [AC_CHECK_HEADERS([GL/glu.h OpenGL/glu.h],
+        [have_opengl_incs=yes; break], [], [
 #ifdef HAVE_WINDOWS_H
 #include <windows.h>
 #endif
-    ])
-    break
-    ], [], [
+      ])
+      break
+      ], [], [
 #ifdef HAVE_WINDOWS_H
-#include <windows.h>
+# include <windows.h>
 #endif
     ])
 
-  if test "$have_opengl_incs" = "yes"; then
-    case $canonical_host_type in
-      *-*-mingw32* | *-*-msdosmsvc)
-        save_LIBS="$LIBS"
-        LIBS="$LIBS -lopengl32"
-        AC_MSG_CHECKING([for glEnable in -lopengl32])
-        AC_TRY_LINK([
-#if HAVE_WINDOWS_H
-#include <windows.h>
-#endif
-#if defined (HAVE_GL_GL_H)
-#include <GL/gl.h>
-#elif defined (HAVE_OPENGL_GL_H)
-#include <OpenGL/gl.h>
-#endif
-], [glEnable(GL_SMOOTH);], OPENGL_LIBS="-lopengl32 -lglu32")
-        LIBS="$save_LIBS"
-        if test "x$OPENGL_LIBS" != "x"; then
-          AC_MSG_RESULT(yes)
-        else
-          AC_MSG_RESULT(no)
-        fi
-        ;;
-      *)
-        AC_CHECK_LIB(GL, glEnable, OPENGL_LIBS="-lGL -lGLU")
-        ;;
-    esac
+    if test "$have_opengl_incs" = "yes"; then
+      case $canonical_host_type in
+        *-*-mingw32* | *-*-msdosmsvc)
+          save_LIBS="$LIBS"
+          LIBS="$LIBS -lopengl32"
+          AC_MSG_CHECKING([for glEnable in -lopengl32])
+          AC_LINK_IFELSE([AC_LANG_PROGRAM([[
+            #if HAVE_WINDOWS_H
+            # include <windows.h>
+            #endif
+            #if defined (HAVE_GL_GL_H)
+            # include <GL/gl.h>
+            #elif defined (HAVE_OPENGL_GL_H)
+            # include <OpenGL/gl.h>
+            #endif
+            ]], [[ 
+            glEnable(GL_SMOOTH);
+            ]])], [OPENGL_LIBS="-lopengl32 -lglu32"])
+
+          LIBS="$save_LIBS"
+          if test "x$OPENGL_LIBS" != "x"; then
+            AC_MSG_RESULT(yes)
+          else
+            AC_MSG_RESULT(no)
+          fi
+          ;;
+        *)
+          ## Non-Mac, Non-Windows systems use this check
+          AC_CHECK_LIB(GL, [glEnable], [OPENGL_LIBS="-lGL -lGLU"])
+          ;;
+      esac
+    fi
   fi
-fi
-AC_SUBST(OPENGL_LIBS)
+  AC_SUBST(OPENGL_LIBS)
 ])
 dnl
-dnl Check if function gluTessCallback is called with "(...)".
+dnl Check whether Qhull works (does not crash).
 dnl
-AC_DEFUN([OCTAVE_GLUTESSCALLBACK_THREEDOTS],
-[AC_CACHE_CHECK([whether gluTessCallback is called with "(...)"],
-octave_cv_glutesscallback_threedots,
-[AC_LANG_PUSH(C++)
-AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
-#ifdef HAVE_GL_GLU_H
-#include <GL/glu.h>
-#elif defined HAVE_OPENGL_GLU_H || defined HAVE_FRAMEWORK_OPENGL
-#include <OpenGL/glu.h>
-#endif]],
-[[GLvoid (*func)(...); gluTessCallback(0, 0, func);]])],
-octave_cv_glutesscallback_threedots="yes", octave_cv_glutesscallback_threedots="no")])
-AC_LANG_POP(C++)
-if test $octave_cv_glutesscallback_threedots = "yes"; then
-  AC_DEFINE(HAVE_GLUTESSCALLBACK_THREEDOTS, 1, 
-    [Define to 1 if gluTessCallback is called with (...).])
-fi
+AC_DEFUN([OCTAVE_CHECK_LIB_QHULL_OK], [
+  AC_CACHE_CHECK([whether the qhull library works],
+    [octave_cv_lib_qhull_ok],
+    [AC_RUN_IFELSE([AC_LANG_PROGRAM([[
+        #include <stdio.h>
+        #if defined (HAVE_LIBQHULL_LIBQHULL_H)
+        # include <libqhull/libqhull.h>
+        # include <libqhull/qset.h>
+        # include <libqhull/geom.h>
+        # include <libqhull/poly.h>
+        # include <libqhull/io.h>
+        #elif defined (HAVE_QHULL_LIBQHULL_H) || defined (HAVE_QHULL_QHULL_H)
+        # if defined (HAVE_QHULL_LIBQHULL_H)
+        #  include <qhull/libqhull.h>
+        # else
+        #  include <qhull/qhull.h>
+        # endif
+        # include <qhull/qset.h>
+        # include <qhull/geom.h>
+        # include <qhull/poly.h>
+        # include <qhull/io.h>
+        #elif defined (HAVE_LIBQHULL_H) || defined (HAVE_QHULL_H)
+        # if defined (HAVE_LIBQHULL_H)
+        #  include <libqhull.h>
+        # else
+        #  include <qhull.h>
+        # endif
+        # include <qset.h>
+        # include <geom.h>
+        # include <poly.h>
+        # include <io.h>
+        #endif
+        #ifdef NEED_QHULL_VERSION
+          char *qh_version = "version";
+        #endif
+        ]], [[
+        int dim = 2;
+        int n = 4;
+        coordT points[8] = { -0.5, -0.5, -0.5, 0.5, 0.5, -0.5, 0.5, 0.5 };
+        boolT ismalloc = 0;
+        return qh_new_qhull (dim, n, points, ismalloc, "qhull ", 0, stderr); 
+      ]])],
+      octave_cv_lib_qhull_ok=yes,
+      octave_cv_lib_qhull_ok=no,
+      octave_cv_lib_qhull_ok=yes)
+  ])
+  if test "$octave_cv_lib_qhull_ok" = "yes"; then
+    $1
+  else
+    $2
+  fi
 ])
 dnl
 dnl Check for support of OpenMP with a given compiler flag.
 dnl If found define HAVE_OPENMP and add the compile flag
 dnl to CFLAGS and CXXFLAGS.
 dnl
-AC_DEFUN([OCTAVE_CHECK_OPENMP],
-[AC_MSG_CHECKING([for support of OpenMP])
-XCFLAGS="$CFLAGS"
-CFLAGS="$CFLAGS $1"
-AC_CACHE_VAL(octave_cv_check_openmp,[
-AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
-#include <omp.h>
-#include <stdio.h>
-]], [[
-int main(int argc, char* argv[])
-{
-  _Pragma("omp parallel")  
-  printf("Hello, world.\n");
-  return 0;
-}
-]])],octave_cv_openmp=yes, octave_cv_openmmp=no, octave_cv_openmp=no)])
-AC_MSG_RESULT($octave_cv_openmp)
-if test "$octave_cv_openmp" = yes; then
-  AC_DEFINE(HAVE_OPENMP,1,[Define to 1 if compiler supports OpenMP.])
-  CXXFLAGS="$CXXFLAGS $1"
-else
-  CFLAGS="$XCFLAGS"
-fi
+AC_DEFUN([OCTAVE_CHECK_OPENMP], [
+  AC_MSG_CHECKING([for support of OpenMP])
+  XCFLAGS="$CFLAGS"
+  CFLAGS="$CFLAGS $1"
+  AC_CACHE_VAL([octave_cv_check_openmp],
+    [AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+        #include <omp.h>
+        #include <stdio.h>
+        ]], [[
+        int main(int argc, char* argv[])
+        {
+          _Pragma("omp parallel")  
+          printf("Hello, world.\n");
+          return 0;
+        }
+      ]])],
+      octave_cv_openmp=yes, octave_cv_openmmp=no, octave_cv_openmp=no)
+  ])
+  AC_MSG_RESULT([$octave_cv_openmp])
+  if test "$octave_cv_openmp" = yes; then
+    AC_DEFINE(HAVE_OPENMP, 1, [Define to 1 if compiler supports OpenMP.])
+    CXXFLAGS="$CXXFLAGS $1"
+  else
+    CFLAGS="$XCFLAGS"
+  fi
+])
+dnl
+dnl Check for the Qhull version.
+dnl
+AC_DEFUN([OCTAVE_CHECK_QHULL_VERSION], [
+  AC_CACHE_CHECK([for qh_version in $QHULL_LIBS],
+    [octave_cv_lib_qhull_version],
+    [AC_LINK_IFELSE([AC_LANG_PROGRAM([[
+        #include <stdio.h>
+        #if defined (HAVE_LIBQHULL_LIBQHULL_H)
+        # include <libqhull/libqhull.h>
+        # include <libqhull/qset.h>
+        # include <libqhull/geom.h>
+        # include <libqhull/poly.h>
+        # include <libqhull/io.h>
+        #elif defined (HAVE_QHULL_LIBQHULL_H) || defined (HAVE_QHULL_QHULL_H)
+        # if defined (HAVE_QHULL_LIBQHULL_H)
+        #  include <qhull/libqhull.h>
+        # else
+        #  include <qhull/qhull.h>
+        # endif
+        # include <qhull/qset.h>
+        # include <qhull/geom.h>
+        # include <qhull/poly.h>
+        # include <qhull/io.h>
+        #elif defined (HAVE_LIBQHULL_H) || defined (HAVE_QHULL_H)
+        # if defined (HAVE_LIBQHULL_H)
+        #  include <libqhull.h>
+        # else
+        #  include <qhull.h>
+        # endif
+        # include <qset.h>
+        # include <geom.h>
+        # include <poly.h>
+        # include <io.h>
+        #endif
+        ]], [[
+        const char *tmp = qh_version;
+      ]])], 
+      octave_cv_lib_qhull_version=yes, octave_cv_lib_qhull_version=no)
+  ])
+  if test "$octave_cv_lib_qhull_version" = no; then
+    AC_DEFINE(NEED_QHULL_VERSION, 1,
+      [Define to 1 if the Qhull library needs a qh_version variable defined.])
+  fi
+])
+dnl
+dnl Check if the default Fortran INTEGER is 64 bits wide.
+dnl
+AC_DEFUN([OCTAVE_CHECK_SIZEOF_FORTRAN_INTEGER], [
+  AC_CACHE_CHECK([whether $F77 generates correct size integers],
+    [octave_cv_sizeof_fortran_integer],
+    [octave_fintsize_save_FFLAGS="$FFLAGS"
+    FFLAGS="$FFLAGS $F77_INTEGER_8_FLAG"
+    AC_LANG_PUSH(Fortran 77)
+    AC_COMPILE_IFELSE(
+[[      subroutine foo(n, in, out)
+      integer n, in(n), out(n)
+      integer i
+      do 10 i = 1, n
+        out(i) = in(i)
+   10 continue
+      return
+      end
+]],
+      [mv conftest.$ac_objext fintsize.$ac_objext
+      octave_fintsize_save_LIBS="$LIBS"
+      LIBS="fintsize.$ac_objext $[]_AC_LANG_PREFIX[]LIBS"
+      AC_LANG_PUSH(C)
+      AC_RUN_IFELSE([AC_LANG_PROGRAM([[
+          #include <assert.h> ]], [[
+          #ifdef USE_64_BIT_IDX_T
+          #if IDX_TYPE_LONG
+            typedef long octave_idx_type;
+          #else
+            typedef int octave_idx_type;
+          #endif
+          #else
+            typedef int octave_idx_type;
+          #endif
+          octave_idx_type n = 2;
+          octave_idx_type in[2];
+          octave_idx_type out[2];
+          in[0] = 13;
+          in[0] = 42;
+          F77_FUNC(foo,FOO) (&n, &in, &out);
+          assert (in[0] == out[0] && in[1] == out[1]);
+        ]])],
+        octave_cv_sizeof_fortran_integer=yes,
+        octave_cv_sizeof_fortran_integer=no,
+        octave_cv_sizeof_fortran_integer=yes)
+      AC_LANG_POP(C)
+      LIBS="$octave_fintsize_save_LIBS"
+      rm -f conftest.$ac_objext fintsize.$ac_objext],
+      [rm -f conftest.$ac_objext
+      AC_MSG_FAILURE([cannot compile a simple Fortran program])
+      octave_cv_sizeof_fortran_integer=no])
+    AC_LANG_POP(Fortran 77)
+    FFLAGS="$octave_fintsize_save_FFLAGS"
+  ])
+])
+dnl
+dnl Add warning to final summary.
+dnl
+AC_DEFUN([OCTAVE_CONFIGURE_WARNING], [
+  AC_MSG_WARN([$][$1])
+  m4_set_add([summary_warning_list], [$1])
+])
+dnl
+dnl Print final summary.
+dnl
+AC_DEFUN([OCTAVE_CONFIGURE_WARNING_SUMMARY], [
+  m4_set_foreach([summary_warning_list], [elt], [
+    if test -n "[$]elt"; then
+      AC_MSG_WARN([$]elt)
+      warn_msg_printed=true
+    fi])
+])
+dnl
+dnl Check if the C++ library has the bit_and, bit_or, and bit_xor
+dnl templates defined.
+dnl
+AC_DEFUN([OCTAVE_CXX_BITWISE_OP_TEMPLATES], [
+  AC_CACHE_CHECK([whether bit_and, bit_or, bit_xor are defined in the C++ library],
+    [octave_cv_cxx_bitwise_op_templates],
+    [AC_LANG_PUSH(C++)
+    AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+        #include <functional>
+        ]], [[
+        int x = 0;
+        int y = 1;
+        int z1 = std::bit_and<int>() (x, y);
+        int z2 = std::bit_or<int>() (x, y);
+        int z3 = std::bit_xor<int>() (x, y);
+      ]])],
+      octave_cv_cxx_bitwise_op_templates=yes,
+      octave_cv_cxx_bitwise_op_templates=no)
+    AC_LANG_POP(C++)
+  ])
+  if test $octave_cv_cxx_bitwise_op_templates = yes; then
+    AC_DEFINE(HAVE_CXX_BITWISE_OP_TEMPLATES, 1,
+      [Define to 1 if C++ library has templated bitwise operators.])
+  fi
+])
+dnl
+dnl Check if C++ reinterpret cast works for function pointers.
+dnl
+AC_DEFUN([OCTAVE_CXX_BROKEN_REINTERPRET_CAST],
+  [AC_REQUIRE([AC_PROG_CXX])
+  AC_CACHE_CHECK([for broken C++ reinterpret_cast],
+    [octave_cv_cxx_broken_reinterpret_cast],
+    [AC_LANG_PUSH(C++)
+    AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+        #include <cmath> ]], [[
+        typedef double (*fptr) (double);
+        fptr psin = sin;
+        void *vptr = reinterpret_cast<void *> (psin);
+        psin = reinterpret_cast<fptr> (vptr);
+      ]])],
+      octave_cv_cxx_broken_reinterpret_cast=no,
+      octave_cv_cxx_broken_reinterpret_cast=yes)
+    AC_LANG_POP(C++)
+  ])
+  if test $octave_cv_cxx_broken_reinterpret_cast = yes ; then
+    AC_DEFINE(CXX_BROKEN_REINTERPRET_CAST, 1,
+      [Define to 1 if C++ reinterpret_cast fails for function pointers.])
+  fi
+])
+dnl
+dnl Check if the C++ library has functions to access real and imaginary
+dnl parts of complex numbers independently via references.
+dnl
+AC_DEFUN([OCTAVE_CXX_COMPLEX_REFERENCE_ACCESSORS], [
+  AC_CACHE_CHECK([whether complex class can reference components independently],
+    [octave_cv_cxx_complex_reference_accessors],
+    [AC_LANG_PUSH(C++)
+    AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+        #include <complex>
+        ]], [[
+        std::complex<double> x;
+        x.real () = 1.0;
+        x.imag () = 1.0;
+      ]])],
+      octave_cv_cxx_complex_reference_accessors=yes,
+      octave_cv_cxx_complex_reference_accessors=no)
+    AC_LANG_POP(C++)
+  ])
+  if test $octave_cv_cxx_complex_reference_accessors = yes; then
+    AC_DEFINE(HAVE_CXX_COMPLEX_REFERENCE_ACCESSORS, 1,
+      [Define to 1 if C++ complex class has T& real (void) and T& imag (void) methods.])
+  fi
+])
+dnl
+dnl Check if the C++ library has functions to set real and imaginary
+dnl parts of complex numbers independently.
+dnl
+AC_DEFUN([OCTAVE_CXX_COMPLEX_SETTERS], [
+  AC_CACHE_CHECK([whether complex class can set components independently],
+    [octave_cv_cxx_complex_setters],
+    [AC_LANG_PUSH(C++)
+    AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+        #include <complex>
+        ]], [[
+        std::complex<double> x;
+        x.real (1.0);
+        x.imag (2.0);
+      ]])],
+      octave_cv_cxx_complex_setters=yes, octave_cv_cxx_complex_setters=no)
+    AC_LANG_POP(C++)
+  ])
+  if test $octave_cv_cxx_complex_setters = yes; then
+    AC_DEFINE(HAVE_CXX_COMPLEX_SETTERS, 1, 
+      [Define to 1 if C++ complex class has void real (T) and void imag (T) methods.])
+  fi
+])
+dnl
+dnl Check if the compiler supports dynamic auto arrays.
+dnl
+AC_DEFUN([OCTAVE_CXX_DYNAMIC_AUTO_ARRAYS], [
+  AC_CACHE_CHECK([whether C++ supports dynamic auto arrays],
+    [octave_cv_cxx_dynamic_auto_arrays],
+    [AC_LANG_PUSH(C++)
+    AC_COMPILE_IFELSE([AC_LANG_PROGRAM([], [[
+        void test(char *);
+        int length();
+        char x[length()];
+        test(x);
+      ]])],
+      octave_cv_cxx_dynamic_auto_arrays=yes, 
+      octave_cv_cxx_dynamic_auto_arrays=no)
+    AC_LANG_POP(C++)
+  ])
+  if test $octave_cv_cxx_dynamic_auto_arrays = yes; then
+    AC_DEFINE(HAVE_DYNAMIC_AUTO_ARRAYS, 1,
+      [Define to 1 if C++ supports dynamic auto arrays.])
+  fi
+])
+dnl
+dnl Check if C++ compiler handles FLAG command line option.  If two
+dnl arguments are specified, execute the second arg as shell commands.
+dnl Otherwise, add FLAG to CXXFLAGS if the compiler accepts the flag.
+dnl
+AC_DEFUN([OCTAVE_CXX_FLAG], [
+  ac_safe=`echo "$1" | sed 'y%./+-:=%__p___%'`
+  AC_MSG_CHECKING([whether ${CXX-g++} accepts $1])
+  AC_CACHE_VAL([octave_cv_cxx_flag_$ac_safe],
+    [AC_LANG_PUSH(C++)
+    XCXXFLAGS="$CXXFLAGS"
+    CXXFLAGS="$CXXFLAGS $1"
+    AC_LINK_IFELSE([AC_LANG_PROGRAM([], [])],
+      eval "octave_cv_cxx_flag_$ac_safe=yes",
+      eval "octave_cv_cxx_flag_$ac_safe=no")
+    CXXFLAGS="$XCXXFLAGS"
+    AC_LANG_POP(C++)
+  ])
+  if eval "test \"`echo '$octave_cv_cxx_flag_'$ac_safe`\" = yes"; then
+    AC_MSG_RESULT(yes)
+    ifelse([$2], ,
+      [CXXFLAGS="$CXXFLAGS $1"
+      AC_MSG_RESULT([adding $1 to CXXFLAGS])], [$2])
+  else
+    AC_MSG_RESULT(no)
+    ifelse([$3], , , [$3])
+  fi
+])
+dnl
+dnl Check if the C++ library is ISO compliant.
+dnl FIXME: This is obviously very simplistic, and trivially fooled.
+dnl
+AC_DEFUN([OCTAVE_CXX_ISO_COMPLIANT_LIBRARY], [
+  AC_REQUIRE([AC_PROG_CXX])
+  AC_MSG_CHECKING([if C++ library is ISO compliant])
+  AC_CACHE_VAL([octave_cv_cxx_iso_compliant_library],
+    [AC_LANG_PUSH(C++)
+    rm -f conftest.h
+    ## Omitting cwctype for now, since it is broken with gcc-3.0.x and
+    ## possibly other versions...
+    for inc in algorithm bitset cassert cctype cerrno cfloat ciso646 \
+        climits clocale cmath complex csetjmp csignal cstdarg cstddef \
+        cstdio cstdlib cstring ctime cwchar deque exception \
+        fstream functional iomanip ios iosfwd iostream istream iterator \
+        limits list locale map memory new numeric ostream queue set \
+        sstream stack stdexcept streambuf string strstream typeinfo \
+        utility valarray vector; do
+      echo "#include <$inc>" >> conftest.h
+    done
+    AC_LINK_IFELSE([AC_LANG_PROGRAM([[
+        #include "conftest.h"
+        ]], [[
+        std::bitset<50> flags;
+        flags.set();
+        int digits = std::numeric_limits<unsigned long>::digits;
+        digits = 0;
+      ]])],
+      octave_cv_cxx_iso_compliant_library=yes,
+      octave_cv_cxx_iso_compliant_library=no)
+    AC_LANG_POP(C++)
+  ])
+  AC_MSG_RESULT([$octave_cv_cxx_iso_compliant_library])
+  if test $octave_cv_cxx_iso_compliant_library = yes; then
+    AC_DEFINE(CXX_ISO_COMPLIANT_LIBRARY, 1, 
+      [Define to 1 if your C++ runtime library is ISO compliant.])
+  fi
+])
+dnl
+dnl Check if C++ compiler needs the new friend template declaration
+dnl syntax. 
+dnl
+AC_DEFUN([OCTAVE_CXX_NEW_FRIEND_TEMPLATE_DECL], [
+  AC_REQUIRE([AC_PROG_CXX])
+  AC_MSG_CHECKING([for C++ support for new friend template declaration])
+  AC_CACHE_VAL([octave_cv_cxx_new_friend_template_decl],
+    [AC_LANG_PUSH(C++)
+    rm -f conftest.h
+    cat > conftest.h <<EOB
+       struct A {
+         friend int operator== (const A&, const A&);
+         A (int) { }
+       };
+
+       template <class T> int
+       operator== (const T&, const T&)
+       {
+         return 0;
+       }
+EOB
+    AC_LINK_IFELSE([AC_LANG_PROGRAM([[
+        #include "conftest.h"
+        ]], [[
+        A a (1);
+        return a == A(1);
+      ]])],
+      octave_cv_cxx_new_friend_template_decl=no,
+      octave_cv_cxx_new_friend_template_decl=yes)
+    AC_LANG_POP(C++)
+  ])
+  AC_MSG_RESULT([$octave_cv_cxx_new_friend_template_decl])
+  if test $octave_cv_cxx_new_friend_template_decl = yes; then
+    AC_DEFINE(CXX_NEW_FRIEND_TEMPLATE_DECL, 1,
+      [Define to 1 if your compiler supports `<>' stuff for template friends.])
+  fi
+])
+dnl
+dnl Check if the compiler supports placement delete.
+dnl
+AC_DEFUN([OCTAVE_CXX_PLACEMENT_DELETE], [
+  AC_CACHE_CHECK([whether <new> defines placement delete operator],
+    [octave_cv_cxx_placement_delete],
+    [AC_LANG_PUSH(C++)
+    AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+        #include <new>
+        ]], [[
+        operator delete((void *)0, (void *)0);
+      ]])],
+      octave_cv_cxx_placement_delete=yes, 
+      octave_cv_cxx_placement_delete=no)
+    AC_LANG_POP(C++)
+  ])
+  if test $octave_cv_cxx_placement_delete = yes; then
+    AC_DEFINE(HAVE_PLACEMENT_DELETE, 1,
+      [Define to 1 if C++ supports operator delete(void *, void *).])
+  fi
+])
+dnl
+dnl Allow the user disable support for command line editing using GNU
+dnl readline.
+dnl
+AC_DEFUN([OCTAVE_ENABLE_READLINE], [
+  USE_READLINE=true
+  READLINE_LIBS=
+  AC_ARG_ENABLE(readline,
+    [AS_HELP_STRING([--enable-readline],
+      [use readline library (default is yes)])],
+    [if test "$enableval" = no; then
+       USE_READLINE=false
+       warn_readline="command editing and history features require GNU Readline"
+     fi])
+  if $USE_READLINE; then
+    save_LIBS="$LIBS"
+    LIBS="$TERM_LIBS"
+    AC_CHECK_LIB(readline, rl_set_keyboard_input_timeout,
+      [READLINE_LIBS="-lreadline"
+      AC_DEFINE(USE_READLINE, 1, [Define to 1 to use the readline library.])
+      ],
+      [AC_MSG_WARN([I need GNU Readline 4.2 or later])
+      AC_MSG_ERROR([this is fatal unless you specify --disable-readline])
+    ])
+    LIBS="$save_LIBS"
+  fi
+  AC_SUBST(READLINE_LIBS)
+])
+dnl
+dnl Check if Fortran compiler handles FLAG command line option.  If
+dnl two arguments are specified, execute the second arg as shell
+dnl commands.  Otherwise, add FLAG to FFLAGS if the compiler accepts
+dnl the flag.
+dnl
+AC_DEFUN([OCTAVE_F77_FLAG], [
+  ac_safe=`echo "$1" | sed 'y%./+-:=%__p___%'`
+  AC_MSG_CHECKING([whether ${F77-g77} accepts $1])
+  AC_CACHE_VAL(octave_cv_f77_flag_$ac_safe, [
+    AC_LANG_PUSH(Fortran 77)
+    XFFLAGS="$FFLAGS"
+    FFLAGS="$FFLAGS $1"
+    AC_LINK_IFELSE([AC_LANG_PROGRAM([], [])],
+      eval "octave_cv_f77_flag_$ac_safe=yes",
+      eval "octave_cv_f77_flag_$ac_safe=no")
+    FFLAGS="$XFFLAGS"
+    AC_LANG_POP(Fortran 77)
+  ])
+  if eval "test \"`echo '$octave_cv_f77_flag_'$ac_safe`\" = yes"; then
+    AC_MSG_RESULT(yes)
+    ifelse([$2], ,
+      [FFLAGS="$FFLAGS $1"
+      AC_MSG_RESULT([adding $1 to FFLAGS])], [$2])
+  else
+    AC_MSG_RESULT(no)
+    ifelse([$3], , , [$3])
+  fi
 ])
 dnl
+dnl Check whether fast signed integer arithmetics using bit tricks
+dnl can be used in oct-inttypes.h.  Defines HAVE_FAST_INT_OPS if
+dnl the following conditions hold:
+dnl 1. Signed numbers are represented by twos complement
+dnl    (see <http://en.wikipedia.org/wiki/Two%27s_complement>)
+dnl 2. static_cast to unsigned int counterpart works like interpreting
+dnl    the signed bit pattern as unsigned (and is thus zero-cost).
+dnl 3. Signed addition and subtraction yield the same bit results as unsigned.
+dnl    (We use casts to prevent optimization interference, so there is no
+dnl     need for things like -ftrapv).
+dnl 4. Bit operations on signed integers work like on unsigned integers,
+dnl    except for the shifts.  Shifts are arithmetic.
+dnl
+AC_DEFUN([OCTAVE_FAST_INT_OPS], [
+  AC_CACHE_CHECK([whether fast integer arithmetics is usable],
+    [octave_cv_fast_int_ops],
+    [AC_LANG_PUSH(C++)
+    AC_RUN_IFELSE([AC_LANG_PROGRAM([[
+        #include <limits>
+        template<class UT, class ST>
+        static bool 
+        do_test (UT, ST)
+        {
+          volatile ST s = std::numeric_limits<ST>::min () / 3;
+          volatile UT u = static_cast<UT> (s);
+          if (*(reinterpret_cast<volatile ST *> (&u)) != s) return true;
+          
+          u = 0; u = ~u;
+          if (*(reinterpret_cast<volatile ST *> (&u)) != -1) return true;
+          
+          ST sx, sy;
+          sx = std::numeric_limits<ST>::max () / 2 + 1;
+          sy = std::numeric_limits<ST>::max () / 2 + 2;
+          if (static_cast<ST> (static_cast<UT> (sx) + static_cast<UT> (sy))
+              != std::numeric_limits<ST>::min () + 1) return true;
+          if (static_cast<ST> (static_cast<UT> (sx) - static_cast<UT> (sy))
+              != -1) return true;
+          
+          if ((sx & sy) != (static_cast<UT> (sx) & static_cast<UT> (sy)))
+            return true;
+          if ((sx | sy) != (static_cast<UT> (sx) | static_cast<UT> (sy)))
+            return true;
+          if ((sx ^ sy) != (static_cast<UT> (sx) ^ static_cast<UT> (sy)))
+            return true;
+          if ((-1 >> 1) != -1) return true;
+          return false;
+        }
+      
+        #define DO_TEST(T) \
+          if (do_test (static_cast<unsigned T> (0), static_cast<signed T> (0)))\
+            return sizeof (T);
+
+        ]],[[
+
+        DO_TEST(char)
+        DO_TEST(short)
+        DO_TEST(int)
+        DO_TEST(long)
+        #if (defined(HAVE_LONG_LONG_INT) && defined(HAVE_UNSIGNED_LONG_LONG_INT))
+          DO_TEST(long long)
+        #endif
+      ]])],
+      octave_cv_fast_int_ops=yes,
+      octave_cv_fast_int_ops=no,
+      octave_cv_fast_int_ops=yes)
+    AC_LANG_POP(C++)
+  ])
+  if test $octave_cv_fast_int_ops = yes; then
+    AC_DEFINE(HAVE_FAST_INT_OPS, 1,
+      [Define to 1 if signed integers use two's complement.])
+  fi
+])
+dnl
+dnl Check to see if the compiler and the linker can handle the flags
+dnl "-framework $1" for the given prologue $2 and the given body $3 of
+dnl a source file.  Arguments 2 and 3 optionally can also be empty.
+dnl Add options (lower case letters $1) "--with-framework-$1" and
+dnl "--without-framework-$1".  If this test is successful then perform
+dnl $4, otherwise do $5.
+dnl
+AC_DEFUN([OCTAVE_HAVE_FRAMEWORK], [
+  AC_MSG_CHECKING([whether ${LD-ld} accepts -framework $1])
+  AC_CACHE_VAL([octave_cv_framework_$1],
+    [XLDFLAGS="$LDFLAGS"
+    LDFLAGS="$LDFLAGS -framework $1"
+    AC_LANG_PUSH(C++)
+    AC_LINK_IFELSE([AC_LANG_PROGRAM([$2], [$3])],
+      eval "octave_cv_framework_$1=yes",
+      eval "octave_cv_framework_$1=no")
+    AC_LANG_POP(C++)
+    LDFLAGS="$XLDFLAGS"
+  ])
+  if test "$octave_cv_framework_$1" = "yes"; then
+    AC_MSG_RESULT(yes)
+    AC_ARG_WITH(framework-m4_tolower($1),
+      [AS_HELP_STRING([--without-framework-m4_tolower($1)], 
+        [don't use framework $1])],
+         with_have_framework=$withval, with_have_framework=yes)
+    if test "$with_have_framework" = "yes"; then
+      [$4]
+    else
+      AC_MSG_NOTICE([framework rejected by --without-framework-m4_tolower($1)])
+      [$5]
+    fi
+  else
+    AC_MSG_RESULT(no)
+    [$5]
+  fi
+])
+dnl
+dnl Figure out the hardware-vendor-os info.
+dnl
+dnl Hanging '])' in AC_MSG_WARN is for adding newline to output
+dnl
+AC_DEFUN([OCTAVE_HOST_TYPE], [
+  AC_CANONICAL_HOST
+  if test -z "$host"; then
+    host=unknown
+  fi
+  canonical_host_type=$host
+  if test "$host" = unknown; then
+    AC_MSG_WARN([configuring Octave for unknown system type
+])
+  fi
+  AC_SUBST(canonical_host_type)
+])
+dnl
+dnl Check for IEEE 754 data format.
+dnl
+AC_DEFUN([OCTAVE_IEEE754_DATA_FORMAT], [
+  AC_MSG_CHECKING([for IEEE 754 data format])
+  AC_CACHE_VAL([octave_cv_ieee754_data_format],
+    [AC_RUN_IFELSE([AC_LANG_SOURCE([[
+        int
+        main (void) 
+        {
+          typedef union { unsigned char c[8]; double d; } ieeebytes;
+           
+          ieeebytes l = {0x1c, 0xbc, 0x6e, 0xf2, 0x54, 0x8b, 0x11, 0x43};
+          ieeebytes b = {0x43, 0x11, 0x8b, 0x54, 0xf2, 0x6e, 0xbc, 0x1c};
+
+          return l.d != 1234567891234567.0 && b.d != 1234567891234567.0;
+        }
+      ]])],
+      octave_cv_ieee754_data_format=yes,
+      octave_cv_ieee754_data_format=no,
+      octave_cv_ieee754_data_format=yes)
+  ])
+  if test "$cross_compiling" = yes; then
+    AC_MSG_RESULT([$octave_cv_ieee754_data_format assumed for cross compilation])
+  else
+    AC_MSG_RESULT([$octave_cv_ieee754_data_format])
+  fi
+  if test "$octave_cv_ieee754_data_format" = yes; then
+    AC_DEFINE(HAVE_IEEE754_DATA_FORMAT, 1,
+      [Define to 1 if your system uses IEEE 754 data format.])
+  else
+    ## If the format is unknown, then you will probably not have a
+    ## useful system, so we will abort here.  Anyone wishing to
+    ## experiment with building Octave on a system without IEEE
+    ## floating point should be capable of removing this check and
+    ## the one in the octave_ieee_init function in liboctave/lo-ieee.cc.
+    AC_MSG_ERROR([IEEE 754 data format required for building Octave])
+  fi
+])
+dnl
+dnl Check for ar.
+dnl
+AC_DEFUN([OCTAVE_PROG_AR], [
+  if test -z "$AR"; then
+    AR=ar
+  fi
+  AC_SUBST(AR)
+
+  if test -z "$ARFLAGS"; then
+    ARFLAGS="rc"
+  fi
+  AC_SUBST(ARFLAGS)
+])
+dnl
+dnl Check for bison.
+dnl
+AC_DEFUN([OCTAVE_PROG_BISON], [
+  AC_PROG_YACC
+  case "$YACC" in
+    bison*)
+    ;;
+    *)
+      YACC='$(top_srcdir)/build-aux/missing bison'
+      warn_bison="
+
+I didn't find bison, but it's only a problem if you need to
+reconstruct parse.cc, which is the case if you're building from VCS
+sources.
+"
+      OCTAVE_CONFIGURE_WARNING([warn_bison])
+    ;;
+  esac
+])
+dnl
+dnl Find desktop-file-install program.
+dnl
+AC_DEFUN([OCTAVE_PROG_DESKTOP_FILE_INSTALL], [
+  AC_CHECK_PROG(DESKTOP_FILE_INSTALL, desktop-file-install, desktop-file-install, [])
+  AC_SUBST(DESKTOP_FILE_INSTALL)
+])
+dnl
+dnl Find find program.
+dnl
+# Prefer GNU find if found.
+AN_MAKEVAR([FIND],  [OCTAVE_PROG_FIND])
+AN_PROGRAM([gfind], [OCTAVE_PROG_FIND])
+AN_PROGRAM([find],  [OCTAVE_PROG_FIND])
+AC_DEFUN([OCTAVE_PROG_FIND], [
+  AC_CHECK_PROGS(FIND, [gfind find])
+])
+dnl
+dnl Check for flex.
+dnl
+AC_DEFUN([OCTAVE_PROG_FLEX], [
+  ## For now, don't define LEXLIB to be -lfl -- we don't use anything in
+  ## it, and it might not be installed.
+  ##
+  ## Also make sure that we generate an interactive scanner if we are
+  ## using flex.
+  AC_PROG_LEX
+  case "$LEX" in
+    flex*)
+      LFLAGS="-I"
+      AC_MSG_RESULT([defining LFLAGS to be $LFLAGS])
+      LEXLIB=
+    ;;
+    *)
+      LEX='$(top_srcdir)/build-aux/missing flex'
+      warn_flex="
+
+I didn't find flex, but it's only a problem if you need to reconstruct
+lex.cc, which is the case if you're building from VCS sources.
+"
+      OCTAVE_CONFIGURE_WARNING([warn_flex])
+    ;;
+  esac
+  AC_SUBST(LFLAGS)
+])
+dnl
+dnl Check for ghostscript.
+dnl
+AC_DEFUN([OCTAVE_PROG_GHOSTSCRIPT], [
+  case "$canonical_host_type" in
+    *-*-mingw* | *-*-msdosmsvc)
+      gs_names="gswin32c gs mgs"
+    ;;
+    *)
+      gs_names="gs"
+    ;;
+  esac
+  AC_CHECK_PROGS(GHOSTSCRIPT, [$gs_names])
+  if test -z "$GHOSTSCRIPT"; then
+    GHOSTSCRIPT='$(top_srcdir)/build-aux/missing gs'
+    warn_ghostscript="
+
+I didn't find ghostscript, so reconstructing figures for the manual
+will fail, and saving graphics in some output formats will fail when
+using Octave
+"
+    OCTAVE_CONFIGURE_WARNING([warn_ghostscript])
+  fi
+  AC_SUBST(GHOSTSCRIPT)
+])
+dnl
+dnl Check for gnuplot.
+dnl
+AC_DEFUN([OCTAVE_PROG_GNUPLOT], [
+  gp_names="gnuplot"
+  gp_default="gnuplot"
+  if test "$cross_compiling" = yes; then
+    GNUPLOT="$gp_default"
+    AC_MSG_RESULT([assuming $GNUPLOT exists on $canonical_host_type host])
+  else
+    AC_CHECK_PROGS(GNUPLOT, [$gp_names])
+    if test -z "$GNUPLOT"; then
+      GNUPLOT="$gp_default"
+      warn_gnuplot="
+
+gnuplot not found.  It isn't necessary to have gnuplot installed, but
+without native graphics or gnuplot you won't be able to use any of
+Octave's plotting commands.
+"
+      OCTAVE_CONFIGURE_WARNING([warn_gnuplot])
+    fi
+  fi
+  AC_SUBST(GNUPLOT)
+])
+dnl
+dnl Check for gperf.
+dnl
+AC_DEFUN([OCTAVE_PROG_GPERF], [
+  AC_CHECK_PROG(GPERF, gperf, gperf, [])
+  if test -z "$GPERF"; then
+    GPERF='$(top_srcdir)/build-aux/missing gperf'
+    warn_gperf="
+
+I didn't find gperf, but it's only a problem if you need to
+reconstruct oct-gperf.h 
+"
+    OCTAVE_CONFIGURE_WARNING([warn_gperf])
+  fi
+  AC_SUBST(GPERF)
+])
+dnl
+dnl Check for makeinfo.
+dnl
+AC_DEFUN([OCTAVE_PROG_MAKEINFO], [
+  dnl use MKINFO, not MAKEINFO, for variable name because Automake
+  dnl automatically defines a value for MAKEINFO even when it does not
+  dnl exist which will then fool the 'test -z' line.
+  AC_CHECK_PROG(MKINFO, makeinfo, makeinfo, [])
+  if test -z "$MKINFO"; then
+    AC_MSG_ERROR([makeinfo program required for reading documentation])
+  fi
+])
+dnl
+dnl What pager should we use?
+dnl
+AC_DEFUN([OCTAVE_PROG_PAGER], [
+  if test "$cross_compiling" = yes; then
+    DEFAULT_PAGER=less
+    AC_MSG_RESULT([assuming $DEFAULT_PAGER exists on $canonical_host_type host])
+    AC_SUBST(DEFAULT_PAGER)
+  else
+    octave_possible_pagers="less more page pg"
+    case "$canonical_host_type" in
+      *-*-cygwin* | *-*-mingw32* | *-*-msdosmsvc)
+        octave_possible_pagers="$octave_possible_pagers more.com"
+      ;;
+    esac
+
+    AC_CHECK_PROGS(DEFAULT_PAGER, $octave_possible_pagers, [])
+    if test -z "$DEFAULT_PAGER"; then
+      warn_less="I couldn't find \`less', \`more', \`page', or \`pg'"
+      OCTAVE_CONFIGURE_WARNING([warn_less])
+    fi
+  fi
+])
+dnl
+dnl Find Perl program.
+dnl
+AC_DEFUN([OCTAVE_PROG_PERL], [
+  AC_CHECK_PROG(PERL, perl, perl, [])
+  AC_SUBST(PERL)
+])
+dnl
+dnl Find Python program.
+dnl
+AC_DEFUN([OCTAVE_PROG_PYTHON], [
+  AC_CHECK_PROG(PYTHON, python, python, [])
+  AC_SUBST(PYTHON)
+])
+dnl
+dnl Find sed program.
+dnl
+# Check for a fully-functional sed program, that truncates
+# as few characters as possible and that supports "\(X\|Y\)"
+# style regular expression alternation.  Prefer GNU sed if found.
+AC_DEFUN([OCTAVE_PROG_SED], [
+  AC_MSG_CHECKING([for a usable sed])
+  if test -z "$SED"; then
+    AC_CACHE_VAL([octave_cv_prog_sed],
+      [# Loop through the user's path and search for sed and gsed.
+      # Next, test potential sed programs in list for truncation.
+      _AS_PATH_WALK([$PATH],
+        [for ac_prog in sed gsed; do
+          for ac_exec_ext in '' $ac_executable_extensions; do
+            if AS_EXECUTABLE_P(["$as_dir/$ac_prog$ac_exec_ext"]); then
+              _sed_list="$_sed_list $as_dir/$ac_prog$ac_exec_ext"
+            fi
+          done
+        done
+      ])
+      AS_TMPDIR(sed)
+      _max=0
+      _count=0
+      # Add /usr/xpg4/bin/sed as it is typically found on Solaris
+      # along with /bin/sed that truncates output.
+      for _sed in $_sed_list /usr/xpg4/bin/sed; do
+        test ! -f ${_sed} && break
+        cat /dev/null > "$tmp/sed.in"
+        _count=0
+        echo $ECHO_N "0123456789$ECHO_C" >"$tmp/sed.in"
+        # Check for GNU sed and select it if it is found.
+        if "${_sed}" --version 2>&1 < /dev/null | egrep '(GNU)' > /dev/null; then
+          octave_cv_prog_sed=${_sed}
+          break;
+        fi
+        # Reject if RE alternation is not handled.
+        if test "`echo 'this and that' | ${_sed} -n 's/\(this\|that\).*$/\1/p'`" != "this"; then
+          continue;
+        fi
+        while true; do
+          cat "$tmp/sed.in" "$tmp/sed.in" >"$tmp/sed.tmp"
+          mv "$tmp/sed.tmp" "$tmp/sed.in"
+          cp "$tmp/sed.in" "$tmp/sed.nl"
+          echo >>"$tmp/sed.nl"
+          ${_sed} -e 's/a$//' < "$tmp/sed.nl" >"$tmp/sed.out" || break
+          cmp -s "$tmp/sed.out" "$tmp/sed.nl" || break
+          # 10000 chars as input seems more than enough
+          test $_count -gt 10 && break
+          _count=`expr $_count + 1`
+          if test $_count -gt $_max; then
+            _max=$_count
+            octave_cv_prog_sed=$_sed
+          fi
+        done
+      done
+      rm -rf "$tmp"
+    ])
+    SED=$octave_cv_prog_sed
+    if test -z "$SED"; then
+      AC_MSG_ERROR([no usable version of sed found])
+    fi
+  fi
+  AC_SUBST(SED)
+  AC_MSG_RESULT([$SED])
+])
+dnl
+dnl Check for texi2dvi.
+dnl
+AC_DEFUN([OCTAVE_PROG_TEXI2DVI], [
+  AC_CHECK_PROG(TEXI2DVI, texi2dvi, texi2dvi, [])
+  if test -z "$TEXI2DVI"; then
+    TEXI2DVI='$(top_srcdir)/build-aux/missing texi2dvi'
+    warn_texi2dvi="
+
+I didn't find texi2dvi, but it's only a problem if you need to
+reconstruct the DVI version of the manual
+"
+    OCTAVE_CONFIGURE_WARNING([warn_texi2dvi])
+  fi
+  AC_SUBST(TEXI2DVI)
+])
+dnl
+dnl Check for texi2pdf.
+dnl
+AC_DEFUN([OCTAVE_PROG_TEXI2PDF], [
+  AC_REQUIRE([OCTAVE_PROG_TEXI2DVI])
+  AC_CHECK_PROG(TEXI2PDF, texi2pdf, texi2pdf, [])
+  if test -z "$TEXI2PDF"; then
+    missing=true;
+    if test -n "$TEXI2DVI"; then
+      TEXI2PDF="$TEXI2DVI --pdf"
+      missing=false;
+    fi
+  else
+    missing=false;
+  fi
+  if $missing; then
+    TEXI2PDF='$(top_srcdir)/build-aux/missing texi2pdf'
+    warn_texi2pdf="
+
+I didn't find texi2pdf, but it's only a problem if you need to
+reconstruct the PDF version of the manual
+"
+    OCTAVE_CONFIGURE_WARNING([warn_texi2pdf])
+  fi
+  AC_SUBST(TEXI2PDF)
+])
+dnl
+dnl Set default value for a variable and substitute it.
+dnl
+AC_DEFUN([OCTAVE_SET_DEFAULT], [
+  ifelse($#, 2, [: ${$1=$2}
+])dnl
+  AC_MSG_RESULT([defining $1 to be $$1])
+  AC_SUBST($1)
+])
+dnl
+dnl Check for UMFPACK separately split complex matrix and RHS.
+dnl
+dnl Macro assumes that the check for umfpack has already been performed.
+dnl
+AC_DEFUN([OCTAVE_UMFPACK_SEPARATE_SPLIT], [
+  AC_MSG_CHECKING([for UMFPACK separate complex matrix and rhs split])
+  AC_CACHE_VAL(octave_cv_umfpack_separate_split,
+    [AC_RUN_IFELSE([AC_LANG_SOURCE([[
+        #include <stdlib.h>
+        #if defined (HAVE_SUITESPARSE_UMFPACK_H)
+        # include <suitesparse/umfpack.h>
+        #elif defined (HAVE_UFSPARSE_UMFPACK_H)
+        # include <ufsparse/umfpack.h>
+        #elif defined (HAVE_UMFPACK_UMFPACK_H)
+        # include <umfpack/umfpack.h>
+        #elif defined (HAVE_UMFPACK_H)
+        # include <umfpack.h>
+        #endif
+        int n = 5;
+        int Ap[] = {0, 2, 5, 9, 10, 12};
+        int Ai[]  = {0, 1, 0, 2, 4, 1, 2, 3, 4, 2, 1, 4};
+        double Ax[] = {2., 0., 3., 0., 3., 0., -1., 0., 4., 0., 4., 0., 
+                      -3., 0., 1., 0., 2., 0., 2., 0., 6., 0., 1., 0.};
+        double br[] = {8., 45., -3., 3., 19.};
+        double bi[] = {0., 0., 0., 0., 0.};
+        int main (void)
+        {
+          double *null = (double *) NULL ;
+          double *x = (double *)malloc (2 * n * sizeof(double));
+          int i ;
+          void *Symbolic, *Numeric ;
+          (void) umfpack_zi_symbolic (n, n, Ap, Ai, Ax, null, &Symbolic, null, null) ;
+          (void) umfpack_zi_numeric (Ap, Ai, Ax, null, Symbolic, &Numeric, null, null) ;
+          umfpack_zi_free_symbolic (&Symbolic) ;
+          (void) umfpack_zi_solve (0, Ap, Ai, Ax, null, x, null, br, bi, 
+                                   Numeric, null, null) ;
+          umfpack_zi_free_numeric (&Numeric) ;
+          for (i = 0; i < n; i++, x+=2) 
+            if (fabs(*x - i - 1.) > 1.e-13)
+              return (1);
+          return (0) ;
+        }
+      ]])],
+      octave_cv_umfpack_separate_split=yes,
+      octave_cv_umfpack_separate_split=no,
+      octave_cv_umfpack_separate_split=yes)
+  ])
+  if test "$cross_compiling" = yes; then
+    AC_MSG_RESULT([$octave_cv_umfpack_separate_split assumed for cross compilation])
+  else
+    AC_MSG_RESULT([$octave_cv_umfpack_separate_split])
+  fi
+  if test "$octave_cv_umfpack_separate_split" = yes; then
+    AC_DEFINE(UMFPACK_SEPARATE_SPLIT, 1, 
+      [Define to 1 if the UMFPACK Complex solver allows matrix and RHS to be split independently.])
+  fi
+])
+dnl
+dnl Check for unordered map headers and whether tr1 namespace is
+dnl required.
+dnl
+AC_DEFUN([OCTAVE_UNORDERED_MAP_HEADERS], [
+  AC_CHECK_HEADERS([unordered_map], [],
+    [AC_CHECK_HEADERS([tr1/unordered_map])])
+  AC_CACHE_CHECK([whether unordered_map requires tr1 namespace], 
+    [octave_cv_header_require_tr1_namespace],
+    [AC_LANG_PUSH(C++)
+    octave_cv_header_require_tr1_namespace=no
+    if test "$ac_cv_header_unordered_map" = "yes"; then
+      ## Have <unordered_map>, but still have to check whether
+      ## tr1 namespace is required (like MSVC, for instance).
+      AC_COMPILE_IFELSE(
+        [AC_LANG_PROGRAM([[
+          #include <unordered_map>
+          ]], [[
+          std::unordered_map<int,int> m;
+        ]])],
+        octave_cv_header_require_tr1_namespace=no, 
+        octave_cv_header_require_tr1_namespace=yes)
+    elif test "$ac_cv_header_tr1_unordered_map" = "yes"; then
+      octave_cv_header_require_tr1_namespace=yes
+    fi
+    AC_LANG_POP(C++)
+  ])
+  if test "$octave_cv_header_require_tr1_namespace" = "yes"; then
+    AC_DEFINE(USE_UNORDERED_MAP_WITH_TR1, 1, 
+      [Define to 1 if unordered_map requires the use of tr1 namespace.])
+  fi
+])
+
+dnl         End of macros written by Octave developers
+dnl ------------------------------------------------------------
+dnl
+
+dnl
+dnl    The following macros were taken from other sources. 
+dnl ------------------------------------------------------------
+
+dnl
 dnl Configure paths for FreeType2
 dnl Marcelo Magallon 2001-10-26, based on gtk.m4 by Owen Taylor
 dnl
 dnl Copyright 2001, 2003 by
 dnl David Turner, Robert Wilhelm, and Werner Lemberg.
 dnl
 dnl This file is part of the FreeType project, and may only be used, modified,
 dnl and distributed under the terms of the FreeType project license,
@@ -1452,106 +1662,105 @@ dnl that program.
 dnl
 dnl serial 2
 dnl
 dnl AC_CHECK_FT2([MINIMUM-VERSION [, ACTION-IF-FOUND [, ACTION-IF-NOT-FOUND]]])
 dnl Test for FreeType 2, and define FT2_CFLAGS and FT2_LIBS.
 dnl MINIMUM-VERSION is what libtool reports; the default is `7.0.1' (this is
 dnl FreeType 2.0.4).
 dnl
-AC_DEFUN([AC_CHECK_FT2],
-  [dnl Get the cflags and libraries from the freetype-config script
-   dnl
-   AC_ARG_WITH([ft-prefix],
-     dnl don't quote AS_HELP_STRING!
-     AS_HELP_STRING([--with-ft-prefix=PREFIX],
-                    [Prefix where FreeType is installed (optional)]),
-     [ft_config_prefix="$withval"],
-     [ft_config_prefix=""])
-  
-   AC_ARG_WITH([ft-exec-prefix],
-     dnl don't quote AS_HELP_STRING!
-     AS_HELP_STRING([--with-ft-exec-prefix=PREFIX],
-                    [Exec prefix where FreeType is installed (optional)]),
-     [ft_config_exec_prefix="$withval"],
-     [ft_config_exec_prefix=""])
+AC_DEFUN([AC_CHECK_FT2], [
+  dnl
+  dnl Get the cflags and libraries from the freetype-config script
+  dnl
+  AC_ARG_WITH([ft-prefix],
+    dnl don't quote AS_HELP_STRING!
+    AS_HELP_STRING([--with-ft-prefix=PREFIX],
+                   [Prefix where FreeType is installed (optional)]),
+    [ft_config_prefix="$withval"],
+    [ft_config_prefix=""])
+ 
+  AC_ARG_WITH([ft-exec-prefix],
+    dnl don't quote AS_HELP_STRING!
+    AS_HELP_STRING([--with-ft-exec-prefix=PREFIX],
+                   [Exec prefix where FreeType is installed (optional)]),
+    [ft_config_exec_prefix="$withval"],
+    [ft_config_exec_prefix=""])
 
-   AC_ARG_ENABLE([freetypetest],
-     dnl don't quote AS_HELP_STRING!
-     AS_HELP_STRING([--disable-freetypetest],
-                    [Do not try to compile and run a test FreeType program]),
-     [],
-     [enable_fttest=yes])
+  AC_ARG_ENABLE([freetypetest],
+    [AS_HELP_STRING([--disable-freetypetest],
+                   [Do not try to compile and run a test FreeType program])],
+    [],
+    [enable_fttest=yes])
 
-   if test x$ft_config_exec_prefix != x ; then
-     ft_config_args="$ft_config_args --exec-prefix=$ft_config_exec_prefix"
-     if test x${FT2_CONFIG+set} != xset ; then
-       FT2_CONFIG=$ft_config_exec_prefix/bin/freetype-config
-     fi
-   fi
+  if test x$ft_config_exec_prefix != x ; then
+    ft_config_args="$ft_config_args --exec-prefix=$ft_config_exec_prefix"
+    if test x${FT2_CONFIG+set} != xset ; then
+      FT2_CONFIG=$ft_config_exec_prefix/bin/freetype-config
+    fi
+  fi
 
-   if test x$ft_config_prefix != x ; then
-     ft_config_args="$ft_config_args --prefix=$ft_config_prefix"
-     if test x${FT2_CONFIG+set} != xset ; then
-       FT2_CONFIG=$ft_config_prefix/bin/freetype-config
-     fi
-   fi
+  if test x$ft_config_prefix != x ; then
+    ft_config_args="$ft_config_args --prefix=$ft_config_prefix"
+    if test x${FT2_CONFIG+set} != xset ; then
+      FT2_CONFIG=$ft_config_prefix/bin/freetype-config
+    fi
+  fi
 
-   AC_PATH_PROG([FT2_CONFIG], [freetype-config], [no])
+  AC_PATH_PROG([FT2_CONFIG], [freetype-config], [no])
 
-   min_ft_version=m4_if([$1], [], [7.0.1], [$1])
-   AC_MSG_CHECKING([for FreeType -- version >= $min_ft_version])
-   no_ft=""
-   if test "$FT2_CONFIG" = "no" ; then
-     no_ft=yes
-   else
-     FT2_CFLAGS=`$FT2_CONFIG $ft_config_args --cflags`
-     FT2_LIBS=`$FT2_CONFIG $ft_config_args --libs`
-     ft_config_major_version=`$FT2_CONFIG $ft_config_args --version | \
-       sed 's/\([[0-9]]*\).\([[0-9]]*\).\([[0-9]]*\)/\1/'`
-     ft_config_minor_version=`$FT2_CONFIG $ft_config_args --version | \
-       sed 's/\([[0-9]]*\).\([[0-9]]*\).\([[0-9]]*\)/\2/'`
-     ft_config_micro_version=`$FT2_CONFIG $ft_config_args --version | \
-       sed 's/\([[0-9]]*\).\([[0-9]]*\).\([[0-9]]*\)/\3/'`
-     ft_min_major_version=`echo $min_ft_version | \
-       sed 's/\([[0-9]]*\).\([[0-9]]*\).\([[0-9]]*\)/\1/'`
-     ft_min_minor_version=`echo $min_ft_version | \
-       sed 's/\([[0-9]]*\).\([[0-9]]*\).\([[0-9]]*\)/\2/'`
-     ft_min_micro_version=`echo $min_ft_version | \
-       sed 's/\([[0-9]]*\).\([[0-9]]*\).\([[0-9]]*\)/\3/'`
-     if test x$enable_fttest = xyes ; then
-       ft_config_is_lt=""
-       if test $ft_config_major_version -lt $ft_min_major_version ; then
-         ft_config_is_lt=yes
-       else
-         if test $ft_config_major_version -eq $ft_min_major_version ; then
-           if test $ft_config_minor_version -lt $ft_min_minor_version ; then
-             ft_config_is_lt=yes
-           else
+  min_ft_version=m4_if([$1], [], [7.0.1], [$1])
+  AC_MSG_CHECKING([for FreeType -- version >= $min_ft_version])
+  no_ft=""
+  if test "$FT2_CONFIG" = "no" ; then
+    no_ft=yes
+  else
+    FT2_CFLAGS=`$FT2_CONFIG $ft_config_args --cflags`
+    FT2_LIBS=`$FT2_CONFIG $ft_config_args --libs`
+    ft_config_major_version=`$FT2_CONFIG $ft_config_args --version | \
+      sed 's/\([[0-9]]*\).\([[0-9]]*\).\([[0-9]]*\)/\1/'`
+    ft_config_minor_version=`$FT2_CONFIG $ft_config_args --version | \
+      sed 's/\([[0-9]]*\).\([[0-9]]*\).\([[0-9]]*\)/\2/'`
+    ft_config_micro_version=`$FT2_CONFIG $ft_config_args --version | \
+      sed 's/\([[0-9]]*\).\([[0-9]]*\).\([[0-9]]*\)/\3/'`
+    ft_min_major_version=`echo $min_ft_version | \
+      sed 's/\([[0-9]]*\).\([[0-9]]*\).\([[0-9]]*\)/\1/'`
+    ft_min_minor_version=`echo $min_ft_version | \
+      sed 's/\([[0-9]]*\).\([[0-9]]*\).\([[0-9]]*\)/\2/'`
+    ft_min_micro_version=`echo $min_ft_version | \
+      sed 's/\([[0-9]]*\).\([[0-9]]*\).\([[0-9]]*\)/\3/'`
+    if test x$enable_fttest = xyes ; then
+      ft_config_is_lt=""
+      if test $ft_config_major_version -lt $ft_min_major_version ; then
+        ft_config_is_lt=yes
+      else
+        if test $ft_config_major_version -eq $ft_min_major_version ; then
+          if test $ft_config_minor_version -lt $ft_min_minor_version ; then
+            ft_config_is_lt=yes
+          else
             if test $ft_config_minor_version -eq $ft_min_minor_version ; then
-               if test $ft_config_micro_version -lt $ft_min_micro_version ; then
-                 ft_config_is_lt=yes
-               fi
-             fi
-           fi
-         fi
-       fi
-       if test x$ft_config_is_lt = xyes ; then
-         no_ft=yes
-       else
-         ac_save_CFLAGS="$CFLAGS"
-         ac_save_LIBS="$LIBS"
-         CFLAGS="$CFLAGS $FT2_CFLAGS"
-         LIBS="$FT2_LIBS $LIBS"
-
-         dnl
-         dnl Sanity checks for the results of freetype-config to some extent.
-         dnl
-         AC_RUN_IFELSE([
-             AC_LANG_SOURCE([[
+              if test $ft_config_micro_version -lt $ft_min_micro_version ; then
+                ft_config_is_lt=yes
+              fi
+            fi
+          fi
+        fi
+      fi
+      if test x$ft_config_is_lt = xyes ; then
+        no_ft=yes
+      else
+        ac_save_CFLAGS="$CFLAGS"
+        ac_save_LIBS="$LIBS"
+        CFLAGS="$CFLAGS $FT2_CFLAGS"
+        LIBS="$FT2_LIBS $LIBS"
+        dnl
+        dnl Sanity checks for the results of freetype-config to some extent.
+        dnl
+        AC_RUN_IFELSE([
+          AC_LANG_SOURCE([[
 
 #include <ft2build.h>
 #include FT_FREETYPE_H
 #include <stdio.h>
 #include <stdlib.h>
 
 int
 main()
@@ -1565,218 +1774,74 @@ main()
     return 1;
   else
   {
     FT_Done_FreeType(library);
     return 0;
   }
 }
 
-             ]])
-           ],
-           [],
-           [no_ft=yes],
-           [echo $ECHO_N "cross compiling; assuming OK... $ECHO_C"])
+              ]]
+            )],
+            [],
+            [no_ft=yes],
+            [echo $ECHO_N "cross compiling; assuming OK... $ECHO_C"])
 
-         CFLAGS="$ac_save_CFLAGS"
-         LIBS="$ac_save_LIBS"
-       fi             dnl test $ft_config_version -lt $ft_min_version
-     fi               dnl test x$enable_fttest = xyes
-   fi                 dnl test "$FT2_CONFIG" = "no"
+        CFLAGS="$ac_save_CFLAGS"
+        LIBS="$ac_save_LIBS"
+      fi             dnl test $ft_config_version -lt $ft_min_version
+    fi               dnl test x$enable_fttest = xyes
+  fi                 dnl test "$FT2_CONFIG" = "no"
 
-   if test x$no_ft = x ; then
-     AC_MSG_RESULT([yes])
-     m4_if([$2], [], [:], [$2])
-   else
-     AC_MSG_RESULT([no])
-     if test "$FT2_CONFIG" = "no" ; then
-     warn_ft2_config = "
+  if test x$no_ft = x ; then
+    AC_MSG_RESULT([yes])
+    m4_if([$2], [], [:], [$2])
+  else
+    AC_MSG_RESULT([no])
+    if test "$FT2_CONFIG" = "no" ; then
+      warn_ft2_config = "
 
 The freetype-config script installed by FreeType 2 could not be found.
 If FreeType 2 was installed in PREFIX, make sure PREFIX/bin is in your
 path, or set the FT2_CONFIG environment variable to the full path to
 freetype-config.
 "
-       OCTAVE_CONFIGURE_WARNING([warn_ft2_config])
-     else
-       if test x$ft_config_is_lt = xyes ; then
-       warn_ft2_too_old="
+      OCTAVE_CONFIGURE_WARNING([warn_ft2_config])
+    else
+      if test x$ft_config_is_lt = xyes ; then
+        warn_ft2_too_old="
 
 Your installed version of the FreeType 2 library is too old. If you
 have different versions of FreeType 2, make sure that correct values
 for --with-ft-prefix or --with-ft-exec-prefix are used, or set the
 FT2_CONFIG environment variable to the full path to freetype-config.
 "
-         OCTAVE_CONFIGURE_WARNING([warn_ft2_too_old])
-       else
-         warn_ft2_failed="
+        OCTAVE_CONFIGURE_WARNING([warn_ft2_too_old])
+      else
+        warn_ft2_failed="
 
 The FreeType test program failed to run. If your system uses shared
 libraries and they are installed outside the normal system library
 path, make sure the variable LD_LIBRARY_PATH (or whatever is
 appropiate for your system) is correctly set.
 "
-         OCTAVE_CONFIGURE_WARNING([warn_ft2_failed])
-       fi
-     fi
+        OCTAVE_CONFIGURE_WARNING([warn_ft2_failed])
+      fi
+    fi
 
-     FT2_CFLAGS=""
-     FT2_LIBS=""
-     m4_if([$3], [], [:], [$3])
-   fi
+    FT2_CFLAGS=""
+    FT2_LIBS=""
+    m4_if([$3], [], [:], [$3])
+  fi
 
-   AC_SUBST([FT2_CFLAGS])
-   AC_SUBST([FT2_LIBS])])
+  AC_SUBST([FT2_CFLAGS])
+  AC_SUBST([FT2_LIBS])
+])
 dnl end of freetype2.m4
 
-dnl
-dnl Check whether a math mapper function is available in <cmath>.
-dnl Will define HAVE_CMATH_FUNC if there is a double variant and
-dnl HAVE_CMATH_FUNCF if there is a float variant.
-dnl Currently capable of checking for functions with single 
-dnl argument and returning bool/int/real.
-dnl
-AC_DEFUN([OCTAVE_CMATH_FUNC],[
-AC_MSG_CHECKING([for std::$1 in <cmath>])
-AC_LANG_PUSH(C++)
-AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
-#include <cmath>
-void take_func (bool (*func) (double x));
-void take_func (int (*func) (double x));
-void take_func (double (*func) (double x));
-]],
-[[
-take_func(std::$1);
-]])],
-[AC_MSG_RESULT([yes])
- AC_DEFINE(HAVE_CMATH_[]AS_TR_CPP($1),1,[Define to 1 if <cmath> provides $1.])],
-[AC_MSG_RESULT([no])])
-AC_MSG_CHECKING([for std::$1 (float variant) in <cmath>])
-AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
-#include <cmath>
-void take_func (bool (*func) (float x));
-void take_func (int (*func) (float x));
-void take_func (float (*func) (float x));
-]],
-[[
-take_func(std::$1);
-]])],
-[AC_MSG_RESULT([yes])
- AC_DEFINE(HAVE_CMATH_[]AS_TR_CPP($1)F,1,[Define to 1 if <cmath> provides float variant of $1.])],
-[AC_MSG_RESULT([no])])
-AC_LANG_POP(C++)
-])
-
-dnl
-dnl Check whether fast signed integer arithmetics using bit tricks
-dnl can be used in oct-inttypes.h.  Defines HAVE_FAST_INT_OPS if
-dnl the following conditions hold:
-dnl 1. Signed numbers are represented by twos complement
-dnl    (see <http://en.wikipedia.org/wiki/Two%27s_complement>)
-dnl 2. static_cast to unsigned int counterpart works like interpreting
-dnl    the signed bit pattern as unsigned (and is thus zero-cost).
-dnl 3. Signed addition and subtraction yield the same bit results as unsigned.
-dnl    (We use casts to prevent optimization interference, so there is no
-dnl     need for things like -ftrapv).
-dnl 4. Bit operations on signed integers work like on unsigned integers,
-dnl    except for the shifts.  Shifts are arithmetic.
-dnl
-AC_DEFUN([OCTAVE_FAST_INT_OPS],
-[AC_CACHE_CHECK([whether fast integer arithmetics is usable],
-octave_cv_fast_int_ops,
-[AC_LANG_PUSH(C++)
-AC_RUN_IFELSE([AC_LANG_PROGRAM([[
-#include <limits>
-template<class UT, class ST>
-static bool 
-do_test (UT, ST)
-{
-  volatile ST s = std::numeric_limits<ST>::min () / 3;
-  volatile UT u = static_cast<UT> (s);
-  if (*(reinterpret_cast<volatile ST *> (&u)) != s) return true;
-  
-  u = 0; u = ~u;
-  if (*(reinterpret_cast<volatile ST *> (&u)) != -1) return true;
-  
-  ST sx, sy;
-  sx = std::numeric_limits<ST>::max () / 2 + 1;
-  sy = std::numeric_limits<ST>::max () / 2 + 2;
-  if (static_cast<ST> (static_cast<UT> (sx) + static_cast<UT> (sy))
-      != std::numeric_limits<ST>::min () + 1) return true;
-  if (static_cast<ST> (static_cast<UT> (sx) - static_cast<UT> (sy))
-      != -1) return true;
-  
-  if ((sx & sy) != (static_cast<UT> (sx) & static_cast<UT> (sy)))
-    return true;
-  if ((sx | sy) != (static_cast<UT> (sx) | static_cast<UT> (sy)))
-    return true;
-  if ((sx ^ sy) != (static_cast<UT> (sx) ^ static_cast<UT> (sy)))
-    return true;
-  if ((-1 >> 1) != -1) return true;
-  return false;
-}
-
-#define DO_TEST(T) \
-if (do_test (static_cast<unsigned T> (0), static_cast<signed T> (0))) \
-  return sizeof (T);
-]],[[
-  DO_TEST(char)
-  DO_TEST(short)
-  DO_TEST(int)
-  DO_TEST(long)
-#if (defined(HAVE_LONG_LONG_INT) && defined(HAVE_UNSIGNED_LONG_LONG_INT))
-  DO_TEST(long long)
-#endif
-]])],
-   [octave_cv_fast_int_ops=yes],
-   [octave_cv_fast_int_ops=no],
-   [octave_cv_fast_int_ops=yes])
-AC_LANG_POP(C++)])
-if test $octave_cv_fast_int_ops = yes; then
-  AC_DEFINE(HAVE_FAST_INT_OPS, 1,
-    [Define to 1 if signed integers use two's complement.])
-fi
-])
-dnl
-dnl Check to see if the compiler and the linker can handle the flags
-dnl "-framework $1" for the given prologue $2 and the given body $3 of
-dnl a source file.  Arguments 2 and 3 optionally can also be empty.
-dnl Add options (lower case letters $1) "--with-framework-$1" and
-dnl "--without-framework-$1".  If this test is successful then perform
-dnl $4, otherwise do $5.
-dnl
-AC_DEFUN([OCTAVE_HAVE_FRAMEWORK], [
-  AC_MSG_CHECKING([whether ${LD-ld} accepts -framework $1])
-  AC_CACHE_VAL(octave_cv_framework_$1, [
-    XLDFLAGS="$LDFLAGS"
-    LDFLAGS="$LDFLAGS -framework $1"
-    AC_LANG_PUSH(C++)
-    AC_LINK_IFELSE([AC_LANG_PROGRAM([$2], [$3])],
-      eval "octave_cv_framework_$1=yes",
-      eval "octave_cv_framework_$1=no")
-    AC_LANG_POP(C++)
-    LDFLAGS="$XLDFLAGS"
-  ])
-  if test "$octave_cv_framework_$1" = "yes"; then
-    AC_MSG_RESULT(yes)
-    AC_ARG_WITH(framework-m4_tolower($1),
-      [AS_HELP_STRING([--without-framework-m4_tolower($1)], 
-        [don't use framework $1])],
-         with_have_framework=$withval, with_have_framework="yes")
-    if test "$with_have_framework" = "yes"; then
-      [$4]
-    else
-      AC_MSG_NOTICE([framework rejected by --without-framework-m4_tolower($1)])
-      [$5]
-    fi
-  else
-    AC_MSG_RESULT(no)
-    [$5]
-  fi
-])
 
 ##############################################################################
 ##############################################################################
 
 # pkg.m4 - Macros to locate and utilise pkg-config.            -*- Autoconf -*-
 # 
 # Copyright  2004 Scott James Remnant <scott@netsplit.com>.
 #
@@ -1928,17 +1993,78 @@ To get pkg-config, see <http://pkg-confi
 		[$4])
 else
 	$1[]_CFLAGS=$pkg_cv_[]$1[]_CFLAGS
 	$1[]_LIBS=$pkg_cv_[]$1[]_LIBS
         AC_MSG_RESULT([yes])
 	ifelse([$3], , :, [$3])
 fi[]dnl
 ])# PKG_CHECK_MODULES
+dnl end of pkg.m4
 
 dnl
-dnl Include external macros.
+dnl The following test is from Karl Berry's Kpathsearch library.  I'm
+dnl including it here in case we someday want to make the use of
+dnl kpathsea optional.
 dnl
-
-m4_include([m4/ax_pthread.m4])
-m4_include([m4/ax_blas.m4])
-m4_include([m4/ax_blas_f77_func.m4])
-m4_include([m4/ax_lapack.m4])
+dnl Some BSD putenv's, e.g., FreeBSD, do malloc/free's on the environment.
+dnl This test program is due to Mike Hibler <mike@cs.utah.edu>.
+dnl We don't actually need to run this if we don't have putenv, but it
+dnl doesn't hurt.
+dnl 
+AC_DEFUN([OCTAVE_SMART_PUTENV],
+[AC_MSG_CHECKING([whether putenv uses malloc])
+AC_CACHE_VAL(octave_cv_func_putenv_malloc,
+[AC_RUN_IFELSE([AC_LANG_SOURCE([[
+#define VAR	"YOW_VAR"
+#define STRING1 "GabbaGabbaHey"
+#define STRING2 "Yow!!"		/* should be shorter than STRING1 */
+extern char *getenv (); /* in case char* and int don't mix gracefully */
+main ()
+{
+  char *str1, *rstr1, *str2, *rstr2;
+  str1 = getenv (VAR);
+  if (str1)
+    exit (1);
+  str1 = malloc (strlen (VAR) + 1 + strlen (STRING1) + 1);
+  if (str1 == 0)
+    exit (2);
+  strcpy (str1, VAR);
+  strcat (str1, "=");
+  strcat (str1, STRING1);
+  if (putenv (str1) < 0)
+    exit (3);
+  rstr1 = getenv (VAR);
+  if (rstr1 == 0)
+    exit (4);
+  rstr1 -= strlen (VAR) + 1;
+  if (strncmp (rstr1, VAR, strlen (VAR)))
+    exit (5);
+  str2 = malloc (strlen (VAR) + 1 + strlen (STRING2) + 1);
+  if (str2 == 0 || str1 == str2)
+    exit (6);
+  strcpy (str2, VAR);
+  strcat (str2, "=");
+  strcat (str2, STRING2);
+  if (putenv (str2) < 0)
+    exit (7);
+  rstr2 = getenv (VAR);
+  if (rstr2 == 0)
+    exit (8);
+  rstr2 -= strlen (VAR) + 1;
+#if 0
+  printf ("rstr1=0x%x, rstr2=0x%x\n", rstr1, rstr2);
+  /*
+   * If string from first call was reused for the second call,
+   * you had better not do a free on the first string!
+   */
+  if (rstr1 == rstr2)
+          printf ("#define SMART_PUTENV\n");
+  else
+          printf ("#undef SMART_PUTENV\n");
+#endif
+  exit (rstr1 == rstr2 ? 0 : 1);
+}]])], octave_cv_func_putenv_malloc=yes, octave_cv_func_putenv_malloc=no,
+    octave_cv_func_putenv_malloc=no)])dnl
+AC_MSG_RESULT([$octave_cv_func_putenv_malloc])
+if test $octave_cv_func_putenv_malloc = yes; then
+  AC_DEFINE(SMART_PUTENV,1,[To quiet autoheader.])
+fi])
diff --git a/src/interp-core/jit-typeinfo.cc b/src/interp-core/jit-typeinfo.cc
--- a/src/interp-core/jit-typeinfo.cc
+++ b/src/interp-core/jit-typeinfo.cc
@@ -1101,16 +1101,24 @@ jit_typeinfo::jit_typeinfo (llvm::Module
   binary_ops.resize (octave_value::num_binary_ops);
   for (size_t i = 0; i < octave_value::num_binary_ops; ++i)
     {
       octave_value::binary_op op = static_cast<octave_value::binary_op> (i);
       std::string op_name = octave_value::binary_op_as_string (op);
       binary_ops[i].stash_name ("binary" + op_name);
     }
 
+  unary_ops.resize (octave_value::num_unary_ops);
+  for (size_t i = 0; i < octave_value::num_unary_ops; ++i)
+    {
+      octave_value::unary_op op = static_cast<octave_value::unary_op> (i);
+      std::string op_name = octave_value::unary_op_as_string (op);
+      unary_ops[i].stash_name ("unary" + op_name);
+    }
+
   for (int op = 0; op < octave_value::num_binary_ops; ++op)
     {
       llvm::Twine fn_name ("octave_jit_binary_any_any_");
       fn_name = fn_name + llvm::Twine (op);
 
       fn = create_function (jit_convention::internal, fn_name, any, any, any);
       fn.mark_can_error ();
       llvm::BasicBlock *block = fn.new_block ();
@@ -1146,30 +1154,21 @@ jit_typeinfo::jit_typeinfo (llvm::Module
   release_fn.stash_name ("release");
 
   // release matrix
   fn = create_function (jit_convention::external, "octave_jit_release_matrix",
                         0, matrix);
   fn.add_mapping (engine, &octave_jit_release_matrix);
   release_fn.add_overload (fn);
 
-  // release scalar
-  fn = create_identity (scalar);
-  release_fn.add_overload (fn);
-
-  // release complex
-  fn = create_identity (complex);
-  release_fn.add_overload (fn);
-
-  // release index
-  fn = create_identity (index);
-  release_fn.add_overload (fn);
+  // copy
+  copy_fn.stash_name ("copy");
+  copy_fn.add_overload (create_identity (scalar));
 
   // now for binary scalar operations
-  // FIXME: Finish all operations
   add_binary_op (scalar, octave_value::op_add, llvm::Instruction::FAdd);
   add_binary_op (scalar, octave_value::op_sub, llvm::Instruction::FSub);
   add_binary_op (scalar, octave_value::op_mul, llvm::Instruction::FMul);
   add_binary_op (scalar, octave_value::op_el_mul, llvm::Instruction::FMul);
 
   add_binary_fcmp (scalar, octave_value::op_lt, llvm::CmpInst::FCMP_ULT);
   add_binary_fcmp (scalar, octave_value::op_le, llvm::CmpInst::FCMP_ULE);
   add_binary_fcmp (scalar, octave_value::op_eq, llvm::CmpInst::FCMP_UEQ);
@@ -1219,16 +1218,58 @@ jit_typeinfo::jit_typeinfo (llvm::Module
   // can take on.
   fn = create_function (jit_convention::external,
                         "octave_jit_pow_scalar_scalar", complex, scalar,
                         scalar);
   fn.add_mapping (engine, &octave_jit_pow_scalar_scalar);
   binary_ops[octave_value::op_pow].add_overload (fn);
   binary_ops[octave_value::op_el_pow].add_overload (fn);
 
+  // now for unary scalar operations
+  // FIXME: Impelment not
+  fn = create_function (jit_convention::internal, "octave_jit_++", scalar,
+                        scalar);
+  body = fn.new_block ();
+  builder.SetInsertPoint (body);
+  {
+    llvm::Value *one = llvm::ConstantFP::get (scalar_t, 1);
+    llvm::Value *val = fn.argument (builder, 0);
+    val = builder.CreateFAdd (val, one);
+    fn.do_return (builder, val);
+  }
+  unary_ops[octave_value::op_incr].add_overload (fn);
+
+  fn = create_function (jit_convention::internal, "octave_jit_--", scalar,
+                        scalar);
+  body = fn.new_block ();
+  builder.SetInsertPoint (body);
+  {
+    llvm::Value *one = llvm::ConstantFP::get (scalar_t, 1);
+    llvm::Value *val = fn.argument (builder, 0);
+    val = builder.CreateFSub (val, one);
+    fn.do_return (builder, val);
+  }
+  unary_ops[octave_value::op_decr].add_overload (fn);
+
+  fn = create_function (jit_convention::internal, "octave_jit_uminus", scalar,
+                        scalar);
+  body = fn.new_block ();
+  builder.SetInsertPoint (body);
+  {
+    llvm::Value *mone = llvm::ConstantFP::get (scalar_t, -1);
+    llvm::Value *val = fn.argument (builder, 0);
+    val = builder.CreateFMul (val, mone);
+    fn.do_return (builder, val);
+  }
+
+  fn = create_identity (scalar);
+  unary_ops[octave_value::op_uplus].add_overload (fn);
+  unary_ops[octave_value::op_transpose].add_overload (fn);
+  unary_ops[octave_value::op_hermitian].add_overload (fn);
+
   // now for binary complex operations
   add_binary_op (complex, octave_value::op_add, llvm::Instruction::FAdd);
   add_binary_op (complex, octave_value::op_sub, llvm::Instruction::FSub);
 
   fn = create_function (jit_convention::internal,
                         "octave_jit_*_complex_complex", complex, complex,
                         complex);
   body = fn.new_block ();
diff --git a/src/interp-core/jit-typeinfo.h b/src/interp-core/jit-typeinfo.h
--- a/src/interp-core/jit-typeinfo.h
+++ b/src/interp-core/jit-typeinfo.h
@@ -471,16 +471,21 @@ public:
     return instance->do_type_of (ov);
   }
 
   static const jit_operation& binary_op (int op)
   {
     return instance->do_binary_op (op);
   }
 
+  static const jit_operation& unary_op (int op)
+  {
+    return instance->do_unary_op (op);
+  }
+
   static const jit_operation& grab (void) { return instance->grab_fn; }
 
   static const jit_function& get_grab (jit_type *type)
   {
     return instance->grab_fn.overload (type);
   }
 
   static const jit_operation& release (void)
@@ -488,16 +493,21 @@ public:
     return instance->release_fn;
   }
 
   static const jit_function& get_release (jit_type *type)
   {
     return instance->release_fn.overload (type);
   }
 
+  static const jit_operation& copy (void)
+  {
+    return instance->copy_fn;
+  }
+
   static const jit_operation& print_value (void)
   {
     return instance->print_fn;
   }
 
   static const jit_operation& for_init (void)
   {
     return instance->for_init_fn;
@@ -602,16 +612,22 @@ private:
   jit_type *do_type_of (const octave_value &ov) const;
 
   const jit_operation& do_binary_op (int op) const
   {
     assert (static_cast<size_t>(op) < binary_ops.size ());
     return binary_ops[op];
   }
 
+  const jit_operation& do_unary_op (int op) const
+  {
+    assert (static_cast<size_t> (op) < unary_ops.size ());
+    return unary_ops[op];
+  }
+
   const jit_operation& do_cast (jit_type *to)
   {
     static jit_operation null_function;
     if (! to)
       return null_function;
 
     size_t id = to->type_id ();
     if (id >= casts.size ())
@@ -732,18 +748,20 @@ private:
   jit_type *complex;
   jit_type *unknown_function;
   std::map<size_t, jit_type *> ints;
   std::map<std::string, jit_type *> builtins;
 
   llvm::StructType *complex_ret;
 
   std::vector<jit_operation> binary_ops;
+  std::vector<jit_operation> unary_ops;
   jit_operation grab_fn;
   jit_operation release_fn;
+  jit_operation copy_fn;
   jit_operation print_fn;
   jit_operation for_init_fn;
   jit_operation for_check_fn;
   jit_operation for_index_fn;
   jit_operation logically_true_fn;
   jit_operation make_range_fn;
   jit_paren_subsref paren_subsref_fn;
   jit_paren_subsasgn paren_subsasgn_fn;
diff --git a/src/interp-core/mex.cc b/src/interp-core/mex.cc
--- a/src/interp-core/mex.cc
+++ b/src/interp-core/mex.cc
@@ -30,19 +30,19 @@ along with Octave; see the file COPYING.
 #include <cctype>
 
 #include <set>
 
 #include "f77-fcn.h"
 #include "lo-ieee.h"
 #include "oct-locbuf.h"
 
+#include "Cell.h"
 // mxArray must be declared as a class before including mexproto.h.
-class mxArray;
-#include "Cell.h"
+#include "mxarray.h"
 #include "mexproto.h"
 #include "oct-map.h"
 #include "oct-obj.h"
 #include "ov.h"
 #include "ov-mex-fcn.h"
 #include "ov-usr-fcn.h"
 #include "pager.h"
 #include "parse.h"
diff --git a/src/interp-core/pt-jit.cc b/src/interp-core/pt-jit.cc
--- a/src/interp-core/pt-jit.cc
+++ b/src/interp-core/pt-jit.cc
@@ -576,25 +576,43 @@ jit_convert::visit_fcn_handle (tree_fcn_
 
 void
 jit_convert::visit_parameter_list (tree_parameter_list&)
 {
   throw jit_fail_exception ();
 }
 
 void
-jit_convert::visit_postfix_expression (tree_postfix_expression&)
+jit_convert::visit_postfix_expression (tree_postfix_expression& tpe)
 {
-  throw jit_fail_exception ();
+  octave_value::unary_op etype = tpe.op_type ();
+  tree_expression *operand = tpe.operand ();
+  jit_value *operandv = visit (operand);
+
+  const jit_operation& fn = jit_typeinfo::unary_op (etype);
+  result = create_checked (fn, operandv);
+
+  if (etype == octave_value::op_incr || etype == octave_value::op_decr)
+    {
+      jit_value *ret = create_checked (&jit_typeinfo::copy, operandv);
+      do_assign (operand, result);
+      result = ret;
+    }
 }
 
 void
-jit_convert::visit_prefix_expression (tree_prefix_expression&)
+jit_convert::visit_prefix_expression (tree_prefix_expression& tpe)
 {
-  throw jit_fail_exception ();
+  octave_value::unary_op etype = tpe.op_type ();
+  tree_expression *operand = tpe.operand ();
+  const jit_operation& fn = jit_typeinfo::unary_op (etype);
+  result = create_checked (fn, visit (operand));
+
+  if (etype == octave_value::op_incr || etype == octave_value::op_decr)
+    do_assign (operand, result);
 }
 
 void
 jit_convert::visit_return_command (tree_return_command&)
 {
   throw jit_fail_exception ();
 }
 
@@ -602,22 +620,30 @@ void
 jit_convert::visit_return_list (tree_return_list&)
 {
   throw jit_fail_exception ();
 }
 
 void
 jit_convert::visit_simple_assignment (tree_simple_assignment& tsa)
 {
-  if (tsa.op_type () != octave_value::op_asn_eq)
-    throw jit_fail_exception ("Unsupported assign");
-
-  // resolve rhs
   tree_expression *rhs = tsa.right_hand_side ();
   jit_value *rhsv = visit (rhs);
+  octave_value::assign_op op = tsa.op_type ();
+
+  if (op != octave_value::op_asn_eq)
+    {
+      // do the equivlent binary operation, then assign. This is always correct,
+      // but isn't always optimal.
+      tree_expression *lhs = tsa.left_hand_side ();
+      jit_value *lhsv = visit (lhs);
+      octave_value::binary_op bop = octave_value::assign_op_to_binary_op (op);
+      const jit_operation& fn = jit_typeinfo::binary_op (bop);
+      rhsv = create_checked (fn, lhsv, rhsv);
+    }
 
   result = do_assign (tsa.left_hand_side (), rhsv);
 }
 
 void
 jit_convert::visit_statement (tree_statement& stmt)
 {
   tree_command *cmd = stmt.command ();
@@ -892,22 +918,21 @@ jit_convert::do_assign (const std::strin
     }
 
   return var;
 }
 
 jit_value *
 jit_convert::visit (tree& tee)
 {
-  result = 0;
-  tee.accept (*this);
+  unwind_protect prot;
+  prot.protect_var (result);
 
-  jit_value *ret = result;
-  result = 0;
-  return ret;
+  tee.accept (*this);
+  return result;
 }
 
 void
 jit_convert::append_users_term (jit_terminator *term)
 {
   for (size_t i = 0; i < term->successor_count (); ++i)
     {
       if (term->alive (i))
@@ -1115,35 +1140,35 @@ jit_convert::release_temp (jit_block& ab
     {
       jit_instruction *instr = *iter;
 
       // check for temporaries that require release and live across
       // multiple blocks
       if (instr->needs_release ())
         {
           jit_block *fu_block = instr->first_use_block ();
-          if (fu_block && fu_block != &ablock)
+          if (fu_block && fu_block != &ablock && instr->needs_release ())
             temp.insert (instr);
         }
 
       if (isa<jit_call> (instr))
         {
           // place releases for temporary arguments
           for (size_t i = 0; i < instr->argument_count (); ++i)
             {
               jit_value *arg = instr->argument (i);
-              if (arg->needs_release ())
-                {
-                  jit_call *release = create<jit_call> (&jit_typeinfo::release,
-                                                        arg);
-                  release->infer ();
-                  ablock.insert_after (iter, release);
-                  ++iter;
-                  temp.erase (arg);
-                }
+              if (! arg->needs_release ())
+                continue;
+
+              jit_call *release = create<jit_call> (&jit_typeinfo::release,
+                                                    arg);
+              release->infer ();
+              ablock.insert_after (iter, release);
+              ++iter;
+              temp.erase (arg);
             }
         }
     }
 
   if (! temp.size () || ! isa<jit_error_check> (ablock.terminator ()))
     return;
 
   // FIXME: If we support try/catch or unwind_protect final_block may not be the
@@ -1172,16 +1197,19 @@ jit_convert::release_dead_phi (jit_block
       jit_use *use = phi->first_use ();
       if (phi->use_count () == 1 && isa<jit_assign> (use->user ()))
         {
           // instead of releasing on assign, release on all incomming branches,
           // this can get rid of casts inside loops
           for (size_t i = 0; i < phi->argument_count (); ++i)
             {
               jit_value *arg = phi->argument (i);
+              if (! arg->needs_release ())
+                continue;
+
               jit_block *inc = phi->incomming (i);
               jit_block *split = inc->maybe_split (*this, ablock);
               jit_terminator *term = split->terminator ();
               jit_call *release = create<jit_call> (jit_typeinfo::release, arg);
               release->infer ();
               split->insert_before (term, release);
             }
 
@@ -1481,17 +1509,18 @@ jit_convert::convert_llvm::visit (jit_as
       if (ol.valid ())
         assign.stash_llvm (ol.call (builder, new_value));
     }
 
   jit_value *overwrite = assign.overwrite ();
   if (isa<jit_assign_base> (overwrite))
     {
       const jit_function& ol = jit_typeinfo::get_release (overwrite->type ());
-      ol.call (builder, overwrite);
+      if (ol.valid ())
+        ol.call (builder, overwrite);
     }
 }
 
 void
 jit_convert::convert_llvm::visit (jit_argument&)
 {}
 
 void
@@ -1943,9 +1972,31 @@ Test some simple cases that compile.
 %!test
 %! m = [1 2 3];
 %! for i=1:1001
 %!   m = sin (m);
 %!   break;
 %! endfor
 %! assert (m == sin ([1  2 3]));
 
+%!test
+%! i = 0;
+%! while i < 10
+%!   i += 1;
+%! endwhile
+%! assert (i == 10);
+
+%!test
+%! i = 0;
+%! while i < 10
+%!   a = ++i;
+%! endwhile
+%! assert (i == 10);
+%! assert (a == 10);
+%!test
+%! i = 0;
+%! while i < 10
+%!   a = i++;
+%! endwhile
+%! assert (i == 10);
+%! assert (a == 9);
+
 */
diff --git a/src/octave-value/ov-base-diag.cc b/src/octave-value/ov-base-diag.cc
--- a/src/octave-value/ov-base-diag.cc
+++ b/src/octave-value/ov-base-diag.cc
@@ -24,16 +24,17 @@ along with Octave; see the file COPYING.
 #include <config.h>
 #endif
 
 #include <iostream>
 
 #include "mach-info.h"
 #include "lo-ieee.h"
 
+#include "mxarray.h"
 #include "ov-base.h"
 #include "ov-base-mat.h"
 #include "pr-output.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-stream.h"
 #include "ops.h"
 
diff --git a/src/octave-value/ov-base.cc b/src/octave-value/ov-base.cc
--- a/src/octave-value/ov-base.cc
+++ b/src/octave-value/ov-base.cc
@@ -29,16 +29,17 @@ along with Octave; see the file COPYING.
 
 #include <iostream>
 
 #include "lo-ieee.h"
 #include "lo-mappers.h"
 
 #include "defun.h"
 #include "gripes.h"
+#include "mxarray.h"
 #include "oct-map.h"
 #include "oct-obj.h"
 #include "oct-lvalue.h"
 #include "oct-stream.h"
 #include "ops.h"
 #include "ov-base.h"
 #include "ov-cell.h"
 #include "ov-ch-mat.h"
diff --git a/src/octave-value/ov-base.h b/src/octave-value/ov-base.h
--- a/src/octave-value/ov-base.h
+++ b/src/octave-value/ov-base.h
@@ -27,24 +27,24 @@ along with Octave; see the file COPYING.
 #include <cstdlib>
 
 #include <iosfwd>
 #include <list>
 #include <string>
 
 #include "Range.h"
 #include "data-conv.h"
-#include "mxarray.h"
 #include "mx-base.h"
 #include "str-vec.h"
 
 #include "error.h"
 #include "oct-hdf5.h"
 
 class Cell;
+class mxArray;
 class octave_map;
 class octave_scalar_map;
 class octave_value;
 class octave_value_list;
 class octave_stream;
 class octave_function;
 class octave_user_function;
 class octave_user_script;
diff --git a/src/octave-value/ov-bool-mat.cc b/src/octave-value/ov-bool-mat.cc
--- a/src/octave-value/ov-bool-mat.cc
+++ b/src/octave-value/ov-bool-mat.cc
@@ -29,16 +29,17 @@ along with Octave; see the file COPYING.
 #include <vector>
 
 #include "lo-ieee.h"
 #include "mx-base.h"
 #include "oct-locbuf.h"
 
 #include "defun.h"
 #include "gripes.h"
+#include "mxarray.h"
 #include "oct-obj.h"
 #include "ops.h"
 #include "ov-base.h"
 #include "ov-base-mat.h"
 #include "ov-base-mat.cc"
 #include "ov-bool.h"
 #include "ov-bool-mat.h"
 #include "ov-re-mat.h"
diff --git a/src/octave-value/ov-bool-sparse.cc b/src/octave-value/ov-bool-sparse.cc
--- a/src/octave-value/ov-bool-sparse.cc
+++ b/src/octave-value/ov-bool-sparse.cc
@@ -25,16 +25,19 @@ along with Octave; see the file COPYING.
 #include <config.h>
 #endif
 
 #include <climits>
 
 #include <iostream>
 #include <vector>
 
+#include "dim-vector.h"
+
+#include "mxarray.h"
 #include "ov-base.h"
 #include "ov-scalar.h"
 #include "ov-bool.h"
 #include "ov-bool-mat.h"
 #include "gripes.h"
 #include "ops.h"
 #include "oct-locbuf.h"
 
diff --git a/src/octave-value/ov-bool.cc b/src/octave-value/ov-bool.cc
--- a/src/octave-value/ov-bool.cc
+++ b/src/octave-value/ov-bool.cc
@@ -24,16 +24,17 @@ along with Octave; see the file COPYING.
 #include <config.h>
 #endif
 
 #include <iostream>
 
 #include "mx-base.h"
 
 #include "gripes.h"
+#include "mxarray.h"
 #include "oct-obj.h"
 #include "ops.h"
 #include "ov-bool.h"
 #include "ov-bool-mat.h"
 #include "ov-base.h"
 #include "ov-base-scalar.h"
 #include "ov-base-scalar.cc"
 #include "ov-re-mat.h"
diff --git a/src/octave-value/ov-cell.cc b/src/octave-value/ov-cell.cc
--- a/src/octave-value/ov-cell.cc
+++ b/src/octave-value/ov-cell.cc
@@ -34,16 +34,17 @@ along with Octave; see the file COPYING.
 #include "Array-util.h"
 #include "byte-swap.h"
 #include "lo-utils.h"
 #include "quit.h"
 #include "oct-locbuf.h"
 
 #include "defun.h"
 #include "error.h"
+#include "mxarray.h"
 #include "ov-cell.h"
 #include "oct-obj.h"
 #include "unwind-prot.h"
 #include "utils.h"
 #include "ov-base-mat.h"
 #include "ov-base-mat.cc"
 #include "ov-re-mat.h"
 #include "ov-scalar.h"
diff --git a/src/octave-value/ov-ch-mat.cc b/src/octave-value/ov-ch-mat.cc
--- a/src/octave-value/ov-ch-mat.cc
+++ b/src/octave-value/ov-ch-mat.cc
@@ -26,16 +26,17 @@ along with Octave; see the file COPYING.
 #endif
 
 #include <cctype>
 #include <iostream>
 
 #include "lo-ieee.h"
 #include "mx-base.h"
 
+#include "mxarray.h"
 #include "ov-base.h"
 #include "ov-base-mat.h"
 #include "ov-base-mat.cc"
 #include "ov-ch-mat.h"
 #include "gripes.h"
 #include "pr-output.h"
 
 template class octave_base_matrix<charNDArray>;
diff --git a/src/octave-value/ov-class.cc b/src/octave-value/ov-class.cc
--- a/src/octave-value/ov-class.cc
+++ b/src/octave-value/ov-class.cc
@@ -37,16 +37,17 @@ along with Octave; see the file COPYING.
 #include "error.h"
 #include "file-ops.h"
 #include "gripes.h"
 #include "load-path.h"
 #include "ls-hdf5.h"
 #include "ls-oct-ascii.h"
 #include "ls-oct-binary.h"
 #include "ls-utils.h"
+#include "mxarray.h"
 #include "oct-lvalue.h"
 #include "ov-class.h"
 #include "ov-fcn.h"
 #include "ov-usr-fcn.h"
 #include "pager.h"
 #include "parse.h"
 #include "pr-output.h"
 #include "toplev.h"
diff --git a/src/octave-value/ov-complex.cc b/src/octave-value/ov-complex.cc
--- a/src/octave-value/ov-complex.cc
+++ b/src/octave-value/ov-complex.cc
@@ -25,16 +25,17 @@ along with Octave; see the file COPYING.
 #endif
 
 #include <iostream>
 
 #include "lo-ieee.h"
 #include "lo-specfun.h"
 #include "lo-mappers.h"
 
+#include "mxarray.h"
 #include "oct-obj.h"
 #include "oct-stream.h"
 #include "ops.h"
 #include "ov-complex.h"
 #include "ov-flt-complex.h"
 #include "ov-base.h"
 #include "ov-base-scalar.h"
 #include "ov-base-scalar.cc"
diff --git a/src/octave-value/ov-cx-mat.cc b/src/octave-value/ov-cx-mat.cc
--- a/src/octave-value/ov-cx-mat.cc
+++ b/src/octave-value/ov-cx-mat.cc
@@ -32,16 +32,17 @@ along with Octave; see the file COPYING.
 #include "lo-ieee.h"
 #include "lo-specfun.h"
 #include "lo-mappers.h"
 #include "mx-base.h"
 #include "mach-info.h"
 #include "oct-locbuf.h"
 
 #include "gripes.h"
+#include "mxarray.h"
 #include "oct-obj.h"
 #include "oct-stream.h"
 #include "ops.h"
 #include "ov-base.h"
 #include "ov-base-mat.h"
 #include "ov-base-mat.cc"
 #include "ov-complex.h"
 #include "ov-cx-mat.h"
diff --git a/src/octave-value/ov-cx-sparse.cc b/src/octave-value/ov-cx-sparse.cc
--- a/src/octave-value/ov-cx-sparse.cc
+++ b/src/octave-value/ov-cx-sparse.cc
@@ -29,16 +29,17 @@ along with Octave; see the file COPYING.
 
 #include <iostream>
 #include <vector>
 
 #include "lo-specfun.h"
 #include "lo-mappers.h"
 #include "oct-locbuf.h"
 
+#include "mxarray.h"
 #include "ov-base.h"
 #include "ov-scalar.h"
 #include "ov-complex.h"
 #include "gripes.h"
 
 #include "ov-re-sparse.h"
 #include "ov-cx-sparse.h"
 
diff --git a/src/octave-value/ov-float.cc b/src/octave-value/ov-float.cc
--- a/src/octave-value/ov-float.cc
+++ b/src/octave-value/ov-float.cc
@@ -28,16 +28,17 @@ along with Octave; see the file COPYING.
 
 #include "data-conv.h"
 #include "mach-info.h"
 #include "lo-specfun.h"
 #include "lo-mappers.h"
 
 #include "defun.h"
 #include "gripes.h"
+#include "mxarray.h"
 #include "oct-obj.h"
 #include "oct-stream.h"
 #include "ov-scalar.h"
 #include "ov-float.h"
 #include "ov-base.h"
 #include "ov-base-scalar.h"
 #include "ov-base-scalar.cc"
 #include "ov-flt-re-mat.h"
diff --git a/src/octave-value/ov-flt-complex.cc b/src/octave-value/ov-flt-complex.cc
--- a/src/octave-value/ov-flt-complex.cc
+++ b/src/octave-value/ov-flt-complex.cc
@@ -25,16 +25,17 @@ along with Octave; see the file COPYING.
 #endif
 
 #include <iostream>
 
 #include "lo-ieee.h"
 #include "lo-specfun.h"
 #include "lo-mappers.h"
 
+#include "mxarray.h"
 #include "oct-obj.h"
 #include "oct-stream.h"
 #include "ops.h"
 #include "ov-complex.h"
 #include "ov-base.h"
 #include "ov-base-scalar.h"
 #include "ov-base-scalar.cc"
 #include "ov-flt-cx-mat.h"
diff --git a/src/octave-value/ov-flt-cx-mat.cc b/src/octave-value/ov-flt-cx-mat.cc
--- a/src/octave-value/ov-flt-cx-mat.cc
+++ b/src/octave-value/ov-flt-cx-mat.cc
@@ -32,16 +32,17 @@ along with Octave; see the file COPYING.
 #include "lo-ieee.h"
 #include "lo-specfun.h"
 #include "lo-mappers.h"
 #include "mx-base.h"
 #include "mach-info.h"
 #include "oct-locbuf.h"
 
 #include "gripes.h"
+#include "mxarray.h"
 #include "oct-obj.h"
 #include "oct-stream.h"
 #include "ops.h"
 #include "ov-base.h"
 #include "ov-base-mat.h"
 #include "ov-base-mat.cc"
 #include "ov-complex.h"
 #include "ov-flt-complex.h"
diff --git a/src/octave-value/ov-flt-re-mat.cc b/src/octave-value/ov-flt-re-mat.cc
--- a/src/octave-value/ov-flt-re-mat.cc
+++ b/src/octave-value/ov-flt-re-mat.cc
@@ -37,16 +37,17 @@ along with Octave; see the file COPYING.
 #include "lo-mappers.h"
 #include "mach-info.h"
 #include "mx-base.h"
 #include "quit.h"
 #include "oct-locbuf.h"
 
 #include "defun.h"
 #include "gripes.h"
+#include "mxarray.h"
 #include "oct-obj.h"
 #include "oct-lvalue.h"
 #include "oct-stream.h"
 #include "ops.h"
 #include "ov-base.h"
 #include "ov-base-mat.h"
 #include "ov-base-mat.cc"
 #include "ov-scalar.h"
diff --git a/src/octave-value/ov-intx.h b/src/octave-value/ov-intx.h
--- a/src/octave-value/ov-intx.h
+++ b/src/octave-value/ov-intx.h
@@ -26,16 +26,17 @@ along with Octave; see the file COPYING.
 #include <iosfwd>
 #include <string>
 
 #include "mx-base.h"
 #include "oct-alloc.h"
 #include "str-vec.h"
 
 #include "error.h"
+#include "mxarray.h"
 #include "oct-stream.h"
 #include "ov-base.h"
 #include "ov-base-int.h"
 #include "ov-typeinfo.h"
 #include "gripes.h"
 
 #include "ov-re-mat.h"
 #include "ov-scalar.h"
diff --git a/src/octave-value/ov-perm.cc b/src/octave-value/ov-perm.cc
--- a/src/octave-value/ov-perm.cc
+++ b/src/octave-value/ov-perm.cc
@@ -20,17 +20,19 @@ along with Octave; see the file COPYING.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "byte-swap.h"
+#include "dim-vector.h"
 
+#include "mxarray.h"
 #include "ov-perm.h"
 #include "ov-re-mat.h"
 #include "ov-scalar.h"
 #include "error.h"
 #include "gripes.h"
 #include "ops.h"
 #include "pr-output.h"
 
diff --git a/src/octave-value/ov-range.cc b/src/octave-value/ov-range.cc
--- a/src/octave-value/ov-range.cc
+++ b/src/octave-value/ov-range.cc
@@ -27,16 +27,17 @@ along with Octave; see the file COPYING.
 #include <iostream>
 
 #include "lo-ieee.h"
 #include "lo-utils.h"
 
 #include "defun.h"
 #include "variables.h"
 #include "gripes.h"
+#include "mxarray.h"
 #include "ops.h"
 #include "oct-obj.h"
 #include "ov-range.h"
 #include "ov-re-mat.h"
 #include "ov-scalar.h"
 #include "pr-output.h"
 
 #include "byte-swap.h"
diff --git a/src/octave-value/ov-re-mat.cc b/src/octave-value/ov-re-mat.cc
--- a/src/octave-value/ov-re-mat.cc
+++ b/src/octave-value/ov-re-mat.cc
@@ -37,16 +37,17 @@ along with Octave; see the file COPYING.
 #include "lo-mappers.h"
 #include "mach-info.h"
 #include "mx-base.h"
 #include "quit.h"
 #include "oct-locbuf.h"
 
 #include "defun.h"
 #include "gripes.h"
+#include "mxarray.h"
 #include "oct-obj.h"
 #include "oct-lvalue.h"
 #include "oct-stream.h"
 #include "ops.h"
 #include "ov-base.h"
 #include "ov-base-mat.h"
 #include "ov-base-mat.cc"
 #include "ov-scalar.h"
diff --git a/src/octave-value/ov-re-sparse.cc b/src/octave-value/ov-re-sparse.cc
--- a/src/octave-value/ov-re-sparse.cc
+++ b/src/octave-value/ov-re-sparse.cc
@@ -29,16 +29,17 @@ along with Octave; see the file COPYING.
 
 #include <iostream>
 #include <vector>
 
 #include "lo-specfun.h"
 #include "lo-mappers.h"
 #include "oct-locbuf.h"
 
+#include "mxarray.h"
 #include "ov-base.h"
 #include "ov-scalar.h"
 #include "gripes.h"
 
 #include "ls-hdf5.h"
 
 #include "ov-re-sparse.h"
 
diff --git a/src/octave-value/ov-scalar.cc b/src/octave-value/ov-scalar.cc
--- a/src/octave-value/ov-scalar.cc
+++ b/src/octave-value/ov-scalar.cc
@@ -28,16 +28,17 @@ along with Octave; see the file COPYING.
 
 #include "data-conv.h"
 #include "mach-info.h"
 #include "lo-specfun.h"
 #include "lo-mappers.h"
 
 #include "defun.h"
 #include "gripes.h"
+#include "mxarray.h"
 #include "oct-obj.h"
 #include "oct-stream.h"
 #include "ov-scalar.h"
 #include "ov-float.h"
 #include "ov-base.h"
 #include "ov-base-scalar.h"
 #include "ov-base-scalar.cc"
 #include "ov-re-mat.h"
diff --git a/src/octave-value/ov-struct.cc b/src/octave-value/ov-struct.cc
--- a/src/octave-value/ov-struct.cc
+++ b/src/octave-value/ov-struct.cc
@@ -25,16 +25,17 @@ along with Octave; see the file COPYING.
 #endif
 
 #include <iostream>
 
 #include "Cell.h"
 #include "defun.h"
 #include "error.h"
 #include "gripes.h"
+#include "mxarray.h"
 #include "oct-lvalue.h"
 #include "ov-struct.h"
 #include "unwind-prot.h"
 #include "utils.h"
 #include "variables.h"
 
 #include "Array-util.h"
 #include "oct-locbuf.h"
diff --git a/src/octave-value/ov.cc b/src/octave-value/ov.cc
--- a/src/octave-value/ov.cc
+++ b/src/octave-value/ov.cc
@@ -478,16 +478,55 @@ octave_value::assign_op_as_string (assig
 
     default:
       retval = "<unknown>";
     }
 
   return retval;
 }
 
+octave_value::binary_op
+octave_value::assign_op_to_binary_op (assign_op op)
+{
+  switch (op)
+    {
+    case op_add_eq:
+      return op_add;
+    case op_sub_eq:
+      return op_sub;
+    case op_mul_eq:
+      return op_mul;
+    case op_div_eq:
+      return op_div;
+    case op_ldiv_eq:
+      return op_ldiv;
+    case op_pow_eq:
+      return op_pow;
+    case op_lshift_eq:
+      return op_lshift;
+    case op_rshift_eq:
+      return op_rshift;
+    case op_el_mul_eq:
+      return op_el_mul;
+    case op_el_div_eq:
+      return op_el_div;
+    case op_el_ldiv_eq:
+      return op_el_ldiv;
+    case op_el_pow_eq:
+      return op_el_pow;
+    case op_el_and_eq:
+      return op_el_and;
+    case op_el_or_eq:
+      return op_el_or;
+    default:
+      return unknown_binary_op;
+    }
+
+}
+
 octave_value::assign_op
 octave_value::binary_op_to_assign_op (binary_op op)
 {
   assign_op retval;
 
   switch (op)
     {
     case op_add:
diff --git a/src/octave-value/ov.h b/src/octave-value/ov.h
--- a/src/octave-value/ov.h
+++ b/src/octave-value/ov.h
@@ -29,26 +29,26 @@ along with Octave; see the file COPYING.
 #include <iosfwd>
 #include <string>
 #include <list>
 
 #include "Range.h"
 #include "data-conv.h"
 #include "idx-vector.h"
 #include "mach-info.h"
-#include "mxarray.h"
 #include "mx-base.h"
 #include "oct-alloc.h"
 #include "oct-time.h"
 #include "str-vec.h"
 
 #include "oct-hdf5.h"
 #include "oct-sort.h"
 
 class Cell;
+class mxArray;
 class octave_map;
 class octave_scalar_map;
 class Octave_map;
 class octave_stream;
 class octave_function;
 class octave_user_function;
 class octave_fcn_handle;
 class octave_fcn_inline;
@@ -140,16 +140,18 @@ public:
     op_el_ldiv_eq,
     op_el_pow_eq,
     op_el_and_eq,
     op_el_or_eq,
     num_assign_ops,
     unknown_assign_op
   };
 
+  static binary_op assign_op_to_binary_op (assign_op);
+
   static assign_op binary_op_to_assign_op (binary_op);
 
   static std::string unary_op_as_string (unary_op);
   static std::string unary_op_fcn_name (unary_op);
 
   static std::string binary_op_as_string (binary_op);
   static std::string binary_op_fcn_name (binary_op);
 
