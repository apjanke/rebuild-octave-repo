# HG changeset patch
# User Jordi Guti√©rrez Hermoso <jordigh@octave.org>
# Date 1343327785 14400
#      Thu Jul 26 14:36:25 2012 -0400
# Node ID f23e607480722fcbf3a791f45e6480bf5db5d174
# Parent  a031f7d515b26ced8229f3bffd1a7637db9cbe56
# Parent  75d1bc2fd6d2d70131282c8d822be21a1df4d58b
Merge in Doug's changes

diff --git a/liboctave/Array-util.cc b/liboctave/Array-util.cc
--- a/liboctave/Array-util.cc
+++ b/liboctave/Array-util.cc
@@ -421,17 +421,17 @@ get_ra_idx (octave_idx_type idx, const d
   return retval;
 }
 
 dim_vector
 zero_dims_inquire (const Array<idx_vector>& ia, const dim_vector& rhdv)
 {
   int ial = ia.length (), rhdvl = rhdv.length ();
   dim_vector rdv = dim_vector::alloc (ial);
-  bool *scalar = new bool[ial], *colon = new bool[ial];
+  bool *scalar = new bool [ial], *colon = new bool [ial];
   // Mark scalars and colons, count non-scalar indices.
   int nonsc = 0;
   bool all_colons = true;
   for (int i = 0; i < ial; i++)
     {
       // FIXME -- should we check for length() instead?
       scalar[i] = ia(i).is_scalar ();
       colon[i] = ia(i).is_colon ();
diff --git a/liboctave/Array.cc b/liboctave/Array.cc
--- a/liboctave/Array.cc
+++ b/liboctave/Array.cc
@@ -644,17 +644,17 @@ public:
     : cext (0), sext (0), dext (0), n (0)
     {
       int l = ndv.length ();
       assert (odv.length () == l);
       octave_idx_type ld = 1;
       int i = 0;
       for (; i < l-1 && ndv(i) == odv(i); i++) ld *= ndv(i);
       n = l - i;
-      cext = new octave_idx_type[3*n];
+      cext = new octave_idx_type [3*n];
       // Trick to avoid three allocations
       sext = cext + n;
       dext = sext + n;
 
       octave_idx_type sld = ld, dld = ld;
       for (int j = 0; j < n; j++)
         {
           cext[j] = std::min (ndv(i+j), odv(i+j));
diff --git a/liboctave/DASPK.cc b/liboctave/DASPK.cc
--- a/liboctave/DASPK.cc
+++ b/liboctave/DASPK.cc
@@ -140,17 +140,17 @@ ddaspk_j (const double& time, const doub
       tmp_deriv.elem (i) = deriv[i];
       tmp_state.elem (i) = state[i];
     }
 
   Matrix tmp_pd = user_jac (tmp_state, tmp_deriv, time, cj);
 
   for (octave_idx_type j = 0; j < nn; j++)
     for (octave_idx_type i = 0; i < nn; i++)
-      pd [nn * j + i] = tmp_pd.elem (i, j);
+      pd[nn * j + i] = tmp_pd.elem (i, j);
 
   END_INTERRUPT_WITH_EXCEPTIONS;
 
   return 0;
 }
 
 ColumnVector
 DASPK::do_integrate (double tout)
diff --git a/liboctave/DASRT.cc b/liboctave/DASRT.cc
--- a/liboctave/DASRT.cc
+++ b/liboctave/DASRT.cc
@@ -116,17 +116,17 @@ ddasrt_j (const double& time, const doub
       tmp_deriv.elem (i) = deriv[i];
       tmp_state.elem (i) = state[i];
     }
 
   Matrix tmp_pd = (*user_jsub) (tmp_state, tmp_deriv, time, cj);
 
   for (octave_idx_type j = 0; j < nn; j++)
     for (octave_idx_type i = 0; i < nn; i++)
-      pd [nn * j + i] = tmp_pd.elem (i, j);
+      pd[nn * j + i] = tmp_pd.elem (i, j);
 
   END_INTERRUPT_WITH_EXCEPTIONS;
 
   return 0;
 }
 
 static octave_idx_type
 ddasrt_g (const octave_idx_type& neq, const double& t, const double *state,
diff --git a/liboctave/DASSL.cc b/liboctave/DASSL.cc
--- a/liboctave/DASSL.cc
+++ b/liboctave/DASSL.cc
@@ -114,17 +114,17 @@ ddassl_j (const double& time, const doub
       tmp_deriv.elem (i) = deriv[i];
       tmp_state.elem (i) = state[i];
     }
 
   Matrix tmp_pd = user_jac (tmp_state, tmp_deriv, time, cj);
 
   for (octave_idx_type j = 0; j < nn; j++)
     for (octave_idx_type i = 0; i < nn; i++)
-      pd [nn * j + i] = tmp_pd.elem (i, j);
+      pd[nn * j + i] = tmp_pd.elem (i, j);
 
   END_INTERRUPT_WITH_EXCEPTIONS;
 
   return 0;
 }
 
 ColumnVector
 DASSL::do_integrate (double tout)
diff --git a/liboctave/LSODE.cc b/liboctave/LSODE.cc
--- a/liboctave/LSODE.cc
+++ b/liboctave/LSODE.cc
@@ -98,17 +98,17 @@ lsode_j (const octave_idx_type& neq, con
   // NOTE: this won't work if LSODE passes copies of the state vector.
   //       In that case we have to create a temporary vector object
   //       and copy.
 
   tmp_jac = (*user_jac) (*tmp_x, time);
 
   for (octave_idx_type j = 0; j < neq; j++)
     for (octave_idx_type i = 0; i < neq; i++)
-      pd [nrowpd * j + i] = tmp_jac (i, j);
+      pd[nrowpd * j + i] = tmp_jac (i, j);
 
   END_INTERRUPT_WITH_EXCEPTIONS;
 
   return 0;
 }
 
 ColumnVector
 LSODE::do_integrate (double tout)
diff --git a/liboctave/MatrixType.cc b/liboctave/MatrixType.cc
--- a/liboctave/MatrixType.cc
+++ b/liboctave/MatrixType.cc
@@ -46,17 +46,17 @@ MatrixType::MatrixType (void)
 
 MatrixType::MatrixType (const MatrixType &a)
   : typ (a.typ), sp_bandden (a.sp_bandden), bandden (a.bandden),
     upper_band (a.upper_band), lower_band (a.lower_band),
     dense (a.dense), full (a.full), nperm (a.nperm), perm (0)
 {
   if (nperm != 0)
     {
-      perm = new octave_idx_type[nperm];
+      perm = new octave_idx_type [nperm];
       for (octave_idx_type i = 0; i < nperm; i++)
         perm[i] = a.perm[i];
     }
 }
 
 template<class T>
 MatrixType::matrix_type
 matrix_real_probe (const MArray<T>& a)
@@ -69,17 +69,17 @@ matrix_real_probe (const MArray<T>& a)
 
   if (ncols == nrows)
     {
       bool upper = true;
       bool lower = true;
       bool hermitian = true;
 
       // do the checks for lower/upper/hermitian all in one pass.
-      OCTAVE_LOCAL_BUFFER(T, diag, ncols);
+      OCTAVE_LOCAL_BUFFER (T, diag, ncols);
 
       for (octave_idx_type j = 0;
            j < ncols && upper; j++)
         {
           T d = a.elem (j,j);
           upper = upper && (d != zero);
           lower = lower && (d != zero);
           hermitian = hermitian && (d > zero);
@@ -127,17 +127,17 @@ matrix_complex_probe (const MArray<std::
 
   if (ncols == nrows)
     {
       bool upper = true;
       bool lower = true;
       bool hermitian = true;
 
       // do the checks for lower/upper/hermitian all in one pass.
-      OCTAVE_LOCAL_BUFFER(T, diag, ncols);
+      OCTAVE_LOCAL_BUFFER (T, diag, ncols);
 
       for (octave_idx_type j = 0;
            j < ncols && upper; j++)
         {
           std::complex<T> d = a.elem (j,j);
           upper = upper && (d != zero);
           lower = lower && (d != zero);
           hermitian = hermitian && (d.real () > zero && d.imag () == zero);
@@ -250,22 +250,22 @@ MatrixType::MatrixType (const SparseMatr
           for (octave_idx_type j = 0; j < i; j++)
             found[j] = true;
           for (octave_idx_type j = i; j < nrows; j++)
             found[j] = false;
 
           for (octave_idx_type j = i; j < nm; j++)
             {
               if ((a.cidx (j+1) > a.cidx (j) + 1)  ||
-                  ((a.cidx (j+1) == a.cidx (j) + 1) && found [a.ridx (j)]))
+                  ((a.cidx (j+1) == a.cidx (j) + 1) && found[a.ridx (j)]))
                 {
                   tmp_typ = MatrixType::Full;
                   break;
                 }
-              found [a.ridx (j)] = true;
+              found[a.ridx (j)] = true;
             }
         }
       typ = tmp_typ;
     }
 
   if (typ == MatrixType::Full)
     {
       // Search for banded, upper and lower triangular matrices
@@ -343,17 +343,17 @@ MatrixType::MatrixType (const SparseMatr
           // Search for a permuted triangular matrix, and test if
           // permutation is singular
 
           // FIXME
           // Perhaps this should be based on a dmperm algorithm
           bool found = false;
 
           nperm = ncols;
-          perm = new octave_idx_type[ncols];
+          perm = new octave_idx_type [ncols];
 
           for (octave_idx_type i = 0; i < ncols; i++)
             perm[i] = -1;
 
           for (octave_idx_type i = 0; i < nm; i++)
             {
               found = false;
 
@@ -382,28 +382,28 @@ MatrixType::MatrixType (const SparseMatr
                     if (perm[i] == -1)
                       perm[i] = k++;
                 }
             }
           else if (a.cidx (nm) == a.cidx (ncols))
             {
               nperm = nrows;
               delete [] perm;
-              perm = new octave_idx_type[nrows];
+              perm = new octave_idx_type [nrows];
               OCTAVE_LOCAL_BUFFER (octave_idx_type, tmp, nrows);
 
               for (octave_idx_type i = 0; i < nrows; i++)
                 {
                   perm[i] = -1;
                   tmp[i] = -1;
                 }
 
               for (octave_idx_type j = 0; j < ncols; j++)
                 for (octave_idx_type i = a.cidx (j); i < a.cidx (j+1); i++)
-                    perm [a.ridx (i)] = j;
+                    perm[a.ridx (i)] = j;
 
               found = true;
               for (octave_idx_type i = 0; i < nm; i++)
                 if (perm[i] == -1)
                   {
                     found = false;
                     break;
                   }
@@ -571,22 +571,22 @@ MatrixType::MatrixType (const SparseComp
           for (octave_idx_type j = 0; j < i; j++)
             found[j] = true;
           for (octave_idx_type j = i; j < nrows; j++)
             found[j] = false;
 
           for (octave_idx_type j = i; j < nm; j++)
             {
               if ((a.cidx (j+1) > a.cidx (j) + 1)  ||
-                  ((a.cidx (j+1) == a.cidx (j) + 1) && found [a.ridx (j)]))
+                  ((a.cidx (j+1) == a.cidx (j) + 1) && found[a.ridx (j)]))
                 {
                   tmp_typ = MatrixType::Full;
                   break;
                 }
-              found [a.ridx (j)] = true;
+              found[a.ridx (j)] = true;
             }
         }
       typ = tmp_typ;
     }
 
   if (typ == MatrixType::Full)
     {
       // Search for banded, upper and lower triangular matrices
@@ -664,17 +664,17 @@ MatrixType::MatrixType (const SparseComp
           // Search for a permuted triangular matrix, and test if
           // permutation is singular
 
           // FIXME
           // Perhaps this should be based on a dmperm algorithm
           bool found = false;
 
           nperm = ncols;
-          perm = new octave_idx_type[ncols];
+          perm = new octave_idx_type [ncols];
 
           for (octave_idx_type i = 0; i < ncols; i++)
             perm[i] = -1;
 
           for (octave_idx_type i = 0; i < nm; i++)
             {
               found = false;
 
@@ -703,28 +703,28 @@ MatrixType::MatrixType (const SparseComp
                     if (perm[i] == -1)
                       perm[i] = k++;
                 }
             }
           else if (a.cidx (nm) == a.cidx (ncols))
             {
               nperm = nrows;
               delete [] perm;
-              perm = new octave_idx_type[nrows];
+              perm = new octave_idx_type [nrows];
               OCTAVE_LOCAL_BUFFER (octave_idx_type, tmp, nrows);
 
               for (octave_idx_type i = 0; i < nrows; i++)
                 {
                   perm[i] = -1;
                   tmp[i] = -1;
                 }
 
               for (octave_idx_type j = 0; j < ncols; j++)
                 for (octave_idx_type i = a.cidx (j); i < a.cidx (j+1); i++)
-                    perm [a.ridx (i)] = j;
+                    perm[a.ridx (i)] = j;
 
               found = true;
               for (octave_idx_type i = 0; i < nm; i++)
                 if (perm[i] == -1)
                   {
                     found = false;
                     break;
                   }
@@ -871,17 +871,17 @@ MatrixType::MatrixType (const matrix_typ
     bandden (0), upper_band (0), lower_band (0),
     dense (false), full (_full), nperm (0), perm (0)
 {
   if ((t == MatrixType::Permuted_Upper || t == MatrixType::Permuted_Lower) &&
       np > 0 && p != 0)
     {
       typ = t;
       nperm = np;
-      perm = new octave_idx_type[nperm];
+      perm = new octave_idx_type [nperm];
       for (octave_idx_type i = 0; i < nperm; i++)
         perm[i] = p[i];
     }
   else
     (*current_liboctave_warning_handler) ("Invalid matrix type");
 }
 
 MatrixType::MatrixType (const matrix_type t, const octave_idx_type ku,
@@ -984,17 +984,17 @@ MatrixType::type (const SparseMatrix &a)
   upper_band = tmp_typ.upper_band;
   lower_band = tmp_typ.lower_band;
   dense = tmp_typ.dense;
   full = tmp_typ.full;
   nperm = tmp_typ.nperm;
 
   if (nperm != 0)
     {
-      perm = new octave_idx_type[nperm];
+      perm = new octave_idx_type [nperm];
       for (octave_idx_type i = 0; i < nperm; i++)
         perm[i] = tmp_typ.perm[i];
     }
 
   return typ;
 }
 
 int
@@ -1017,17 +1017,17 @@ MatrixType::type (const SparseComplexMat
   upper_band = tmp_typ.upper_band;
   lower_band = tmp_typ.lower_band;
   dense = tmp_typ.dense;
   full = tmp_typ.full;
   nperm = tmp_typ.nperm;
 
   if (nperm != 0)
     {
-      perm = new octave_idx_type[nperm];
+      perm = new octave_idx_type [nperm];
       for (octave_idx_type i = 0; i < nperm; i++)
         perm[i] = tmp_typ.perm[i];
     }
 
   return typ;
 }
 
 int
@@ -1044,17 +1044,17 @@ MatrixType::type (const Matrix &a)
 
   MatrixType tmp_typ (a);
   typ = tmp_typ.typ;
   full = tmp_typ.full;
   nperm = tmp_typ.nperm;
 
   if (nperm != 0)
     {
-      perm = new octave_idx_type[nperm];
+      perm = new octave_idx_type [nperm];
       for (octave_idx_type i = 0; i < nperm; i++)
         perm[i] = tmp_typ.perm[i];
     }
 
   return typ;
 }
 
 int
@@ -1071,17 +1071,17 @@ MatrixType::type (const ComplexMatrix &a
 
   MatrixType tmp_typ (a);
   typ = tmp_typ.typ;
   full = tmp_typ.full;
   nperm = tmp_typ.nperm;
 
   if (nperm != 0)
     {
-      perm = new octave_idx_type[nperm];
+      perm = new octave_idx_type [nperm];
       for (octave_idx_type i = 0; i < nperm; i++)
         perm[i] = tmp_typ.perm[i];
     }
 
   return typ;
 }
 
 int
@@ -1098,17 +1098,17 @@ MatrixType::type (const FloatMatrix &a)
 
   MatrixType tmp_typ (a);
   typ = tmp_typ.typ;
   full = tmp_typ.full;
   nperm = tmp_typ.nperm;
 
   if (nperm != 0)
     {
-      perm = new octave_idx_type[nperm];
+      perm = new octave_idx_type [nperm];
       for (octave_idx_type i = 0; i < nperm; i++)
         perm[i] = tmp_typ.perm[i];
     }
 
   return typ;
 }
 
 int
@@ -1125,17 +1125,17 @@ MatrixType::type (const FloatComplexMatr
 
   MatrixType tmp_typ (a);
   typ = tmp_typ.typ;
   full = tmp_typ.full;
   nperm = tmp_typ.nperm;
 
   if (nperm != 0)
     {
-      perm = new octave_idx_type[nperm];
+      perm = new octave_idx_type [nperm];
       for (octave_idx_type i = 0; i < nperm; i++)
         perm[i] = tmp_typ.perm[i];
     }
 
   return typ;
 }
 
 void
@@ -1220,17 +1220,17 @@ MatrixType::mark_as_unsymmetric (void)
            typ == MatrixType::Unknown)
     typ = MatrixType::Full;
 }
 
 void
 MatrixType::mark_as_permuted (const octave_idx_type np, const octave_idx_type *p)
 {
   nperm = np;
-  perm = new octave_idx_type[nperm];
+  perm = new octave_idx_type [nperm];
   for (octave_idx_type i = 0; i < nperm; i++)
     perm[i] = p[i];
 
   if (typ == MatrixType::Diagonal || typ == MatrixType::Permuted_Diagonal)
     typ = MatrixType::Permuted_Diagonal;
   else if (typ == MatrixType::Upper || typ == MatrixType::Permuted_Upper)
     typ = MatrixType::Permuted_Upper;
   else if (typ == MatrixType::Lower || typ == MatrixType::Permuted_Lower)
diff --git a/liboctave/Sparse-perm-op-defs.h b/liboctave/Sparse-perm-op-defs.h
--- a/liboctave/Sparse-perm-op-defs.h
+++ b/liboctave/Sparse-perm-op-defs.h
@@ -66,17 +66,17 @@ SM octinternal_do_mul_pm_sm (const PermM
       gripe_nonconformant ("operator *", p.rows (), p.cols (), a.rows (), a.cols ());
       return SM ();
     }
 
   if (p.is_row_perm ())
     {
       // Form the column permutation and then call the colpm_sm routine.
       const octave_idx_type *prow = p.pvec ().data ();
-      OCTAVE_LOCAL_BUFFER(octave_idx_type, pcol, nr);
+      OCTAVE_LOCAL_BUFFER (octave_idx_type, pcol, nr);
       for (octave_idx_type i = 0; i < nr; ++i)
         pcol[prow[i]] = i;
       return octinternal_do_mul_colpm_sm (pcol, a);
     }
   else
     return octinternal_do_mul_colpm_sm (p.pvec ().data (), a);
 }
 
diff --git a/liboctave/Sparse.cc b/liboctave/Sparse.cc
--- a/liboctave/Sparse.cc
+++ b/liboctave/Sparse.cc
@@ -171,23 +171,23 @@ Sparse<T>::SparseRep::change_length (oct
   // We shall skip reallocation if we have less than 1/frac extra elements to
   // discard.
   static const int frac = 5;
   if (nz > nzmx || nz < nzmx - nzmx/frac)
     {
       // Reallocate.
       octave_idx_type min_nzmx = std::min (nz, nzmx);
 
-      octave_idx_type * new_ridx = new octave_idx_type[nz];
+      octave_idx_type * new_ridx = new octave_idx_type [nz];
       copy_or_memcpy (min_nzmx, r, new_ridx);
 
       delete [] r;
       r = new_ridx;
 
-      T * new_data = new T[nz];
+      T * new_data = new T [nz];
       copy_or_memcpy (min_nzmx, d, new_data);
 
       delete [] d;
       d = new_data;
 
       nzmx = nz;
     }
 }
diff --git a/liboctave/Sparse.h b/liboctave/Sparse.h
--- a/liboctave/Sparse.h
+++ b/liboctave/Sparse.h
@@ -67,32 +67,32 @@ protected:
     octave_idx_type *r;
     octave_idx_type *c;
     octave_idx_type nzmx;
     octave_idx_type nrows;
     octave_idx_type ncols;
     octave_refcount<int> count;
 
     SparseRep (void)
-      : d (0), r (0), c (new octave_idx_type[1]), nzmx (0), nrows (0),
+      : d (0), r (0), c (new octave_idx_type [1]), nzmx (0), nrows (0),
       ncols (0), count (1)
       {
         c[0] = 0;
       }
 
     SparseRep (octave_idx_type n)
       : d (0), r (0), c (new octave_idx_type [n+1]), nzmx (0), nrows (n),
       ncols (n), count (1)
       {
         for (octave_idx_type i = 0; i < n + 1; i++)
           c[i] = 0;
       }
 
     SparseRep (octave_idx_type nr, octave_idx_type nc, octave_idx_type nz = 0)
-      : d (new T[nz]), r (new octave_idx_type[nz]),
+      : d (new T [nz]), r (new octave_idx_type [nz]),
       c (new octave_idx_type [nc+1]), nzmx (nz), nrows (nr),
       ncols (nc), count (1)
       {
         c[nc] = nz;
         for (octave_idx_type i = 0; i < nc; i++)
           c[i] = 0;
       }
 
diff --git a/liboctave/dim-vector.h b/liboctave/dim-vector.h
--- a/liboctave/dim-vector.h
+++ b/liboctave/dim-vector.h
@@ -61,31 +61,31 @@ private:
   octave_idx_type& ndims (void) const { return rep[-1]; }
 
   octave_idx_type& count (void) const { return rep[-2]; }
 
   // Construct a new rep with count = 1 and ndims given.
 
   static octave_idx_type *newrep (int ndims)
   {
-    octave_idx_type *r = new octave_idx_type[ndims + 2];
+    octave_idx_type *r = new octave_idx_type [ndims + 2];
 
     *r++ = 1;
     *r++ = ndims;
 
     return r;
   }
 
   // Clone this->rep.
 
   octave_idx_type *clonerep (void)
   {
     int l = ndims ();
 
-    octave_idx_type *r = new octave_idx_type[l + 2];
+    octave_idx_type *r = new octave_idx_type [l + 2];
 
     *r++ = 1;
     *r++ = l;
 
     for (int i = 0; i < l; i++)
       r[i] = rep[i];
 
     return r;
@@ -95,17 +95,17 @@ private:
 
   octave_idx_type *resizerep (int n, octave_idx_type fill_value)
   {
     int l = ndims ();
 
     if (n < 2)
       n = 2;
 
-    octave_idx_type *r = new octave_idx_type[n + 2];
+    octave_idx_type *r = new octave_idx_type [n + 2];
 
     *r++ = 1;
     *r++ = n;
 
     if (l > n)
       l = n;
 
     int j;
diff --git a/liboctave/eigs-base.cc b/liboctave/eigs-base.cc
--- a/liboctave/eigs-base.cc
+++ b/liboctave/eigs-base.cc
@@ -1964,17 +1964,17 @@ EigsRealNonSymmetricMatrix (const M& m, 
       if (info2 == 0)
         {
           octave_idx_type jj = 0;
           for (octave_idx_type i = 0; i < k+1; i++)
             {
               if (dr[i] == 0.0 && di[i] == 0.0 && jj == 0)
                 jj++;
               else
-                d [i-jj] = Complex (dr[i], di[i]);
+                d[i-jj] = Complex (dr[i], di[i]);
             }
           if (jj == 0 && !rvec)
             for (octave_idx_type i = 0; i < k; i++)
               d[i] = d[i+1];
 
           octave_idx_type k2 = k / 2;
           for (octave_idx_type i = 0; i < k2; i++)
             {
@@ -2350,17 +2350,17 @@ EigsRealNonSymmetricMatrixShift (const M
       if (info2 == 0)
         {
           octave_idx_type jj = 0;
           for (octave_idx_type i = 0; i < k+1; i++)
             {
               if (dr[i] == 0.0 && di[i] == 0.0 && jj == 0)
                 jj++;
               else
-                d [i-jj] = Complex (dr[i], di[i]);
+                d[i-jj] = Complex (dr[i], di[i]);
             }
           if (jj == 0 && !rvec)
             for (octave_idx_type i = 0; i < k; i++)
               d[i] = d[i+1];
 
           octave_idx_type k2 = k / 2;
           for (octave_idx_type i = 0; i < k2; i++)
             {
@@ -2662,17 +2662,17 @@ EigsRealNonSymmetricFunc (EigsFunc fun, 
       if (info2 == 0)
         {
           octave_idx_type jj = 0;
           for (octave_idx_type i = 0; i < k+1; i++)
             {
               if (dr[i] == 0.0 && di[i] == 0.0 && jj == 0)
                 jj++;
               else
-                d [i-jj] = Complex (dr[i], di[i]);
+                d[i-jj] = Complex (dr[i], di[i]);
             }
           if (jj == 0 && !rvec)
             for (octave_idx_type i = 0; i < k; i++)
               d[i] = d[i+1];
 
           octave_idx_type k2 = k / 2;
           for (octave_idx_type i = 0; i < k2; i++)
             {
diff --git a/liboctave/idx-vector.cc b/liboctave/idx-vector.cc
--- a/liboctave/idx-vector.cc
+++ b/liboctave/idx-vector.cc
@@ -320,17 +320,17 @@ idx_vector::idx_scalar_rep::as_array (vo
 DEFINE_OCTAVE_ALLOCATOR(idx_vector::idx_vector_rep);
 
 template <class T>
 idx_vector::idx_vector_rep::idx_vector_rep (const Array<T>& nda)
   : data (0), len (nda.numel ()), ext (0), aowner (0), orig_dims (nda.dims ())
 {
   if (len != 0)
     {
-      octave_idx_type *d = new octave_idx_type[len];
+      octave_idx_type *d = new octave_idx_type [len];
       for (octave_idx_type i = 0; i < len; i++)
         d[i] = convert_index (nda.xelem (i), err, ext);
       data = d;
 
       if (err)
       {
         delete [] data;
         gripe_invalid_index ();
@@ -380,17 +380,17 @@ idx_vector::idx_vector_rep::idx_vector_r
     }
 }
 
 idx_vector::idx_vector_rep::idx_vector_rep (bool b)
   : data (0), len (b ? 1 : 0), ext (0), aowner (0), orig_dims (len, len)
 {
   if (len != 0)
     {
-      octave_idx_type *d = new octave_idx_type[1];
+      octave_idx_type *d = new octave_idx_type [1];
       d[0] = 0;
       data = d;
       ext = 1;
     }
 }
 
 idx_vector::idx_vector_rep::idx_vector_rep (const Array<bool>& bnda,
                                             octave_idx_type nnz)
@@ -402,17 +402,17 @@ idx_vector::idx_vector_rep::idx_vector_r
   const dim_vector dv = bnda.dims ();
 
   if (! dv.all_zero ())
     orig_dims = ((dv.length () == 2 && dv(0) == 1)
                  ? dim_vector (1, len) : dim_vector (len, 1));
 
   if (len != 0)
     {
-      octave_idx_type *d = new octave_idx_type[len];
+      octave_idx_type *d = new octave_idx_type [len];
 
       octave_idx_type ntot = bnda.length ();
 
       octave_idx_type k = 0;
       for (octave_idx_type i = 0; i < ntot; i++)
         if (bnda.xelem (i))
           d[k++] = i;
 
@@ -430,17 +430,17 @@ idx_vector::idx_vector_rep::idx_vector_r
 
   dim_vector dv = bnda.dims ();
 
   orig_dims = ((dv.length () == 2 && dv(0) == 1)
                ? dim_vector (1, len) : orig_dims = dim_vector (len, 1));
 
   if (len != 0)
     {
-      octave_idx_type *d = new octave_idx_type[len];
+      octave_idx_type *d = new octave_idx_type [len];
 
       octave_idx_type nnz = bnda.nnz ();
 
       octave_idx_type k = 0;
       // FIXME: I hope this is OK, i.e. the element iterated this way are correctly ordered.
       for (octave_idx_type i = 0; i < nnz; i++)
         {
           if (bnda.data (i))
@@ -484,17 +484,17 @@ idx_vector::idx_vector_rep::sort_uniq_cl
 
   // This is wrapped in auto_ptr so that we don't leak on out-of-memory.
   std::auto_ptr<idx_vector_rep> new_rep (
     new idx_vector_rep (0, len, ext, orig_dims, DIRECT));
 
   if (ext > len*xlog2 (1.0 + len))
     {
       // Use standard sort via octave_sort.
-      octave_idx_type *new_data = new octave_idx_type[len];
+      octave_idx_type *new_data = new octave_idx_type [len];
       new_rep->data = new_data;
 
       std::copy (data, data + len, new_data);
       octave_sort<octave_idx_type> lsort;
       lsort.set_compare (ASCENDING);
       lsort.sort (new_data, len);
 
       if (uniq)
@@ -519,31 +519,31 @@ idx_vector::idx_vector_rep::sort_uniq_cl
         new_len += has[i];
 
       new_rep->len = new_len;
       if (new_rep->orig_dims.length () == 2 && new_rep->orig_dims(0) == 1)
         new_rep->orig_dims = dim_vector (1, new_len);
       else
         new_rep->orig_dims = dim_vector (new_len, 1);
 
-      octave_idx_type *new_data = new octave_idx_type[new_len];
+      octave_idx_type *new_data = new octave_idx_type [new_len];
       new_rep->data = new_data;
 
       for (octave_idx_type i = 0, j = 0; i < ext; i++)
         if (has[i])
           new_data[j++] = i;
     }
   else
     {
       // Use two-pass bucket sort.
       OCTAVE_LOCAL_BUFFER_INIT (octave_idx_type, cnt, ext, 0);
       for (octave_idx_type i = 0; i < len; i++)
         cnt[data[i]]++;
 
-      octave_idx_type *new_data = new octave_idx_type[len];
+      octave_idx_type *new_data = new octave_idx_type [len];
       new_rep->data = new_data;
 
       for (octave_idx_type i = 0, j = 0; i < ext; i++)
         {
           for (octave_idx_type k = 0; k < cnt[i]; k++)
             new_data[j++] = i;
         }
     }
@@ -561,17 +561,17 @@ idx_vector::idx_vector_rep::sort_idx (Ar
   if (ext > len*xlog2 (1.0 + len))
     {
       // Use standard sort via octave_sort.
       idx.clear (orig_dims);
       octave_idx_type *idx_data = idx.fortran_vec ();
       for (octave_idx_type i = 0; i < len; i++)
         idx_data[i] = i;
 
-      octave_idx_type *new_data = new octave_idx_type[len];
+      octave_idx_type *new_data = new octave_idx_type [len];
       new_rep->data = new_data;
       std::copy (data, data + len, new_data);
 
       octave_sort<octave_idx_type> lsort;
       lsort.set_compare (ASCENDING);
       lsort.sort (new_data, idx_data, len);
     }
   else
@@ -580,17 +580,17 @@ idx_vector::idx_vector_rep::sort_idx (Ar
       OCTAVE_LOCAL_BUFFER_INIT (octave_idx_type, cnt, ext, 0);
 
       for (octave_idx_type i = 0; i < len; i++)
         cnt[data[i]]++;
 
       idx.clear (orig_dims);
       octave_idx_type *idx_data = idx.fortran_vec ();
 
-      octave_idx_type *new_data = new octave_idx_type[len];
+      octave_idx_type *new_data = new octave_idx_type [len];
       new_rep->data = new_data;
 
       for (octave_idx_type i = 0, k = 0; i < ext; i++)
         {
           octave_idx_type j = cnt[i];
           cnt[i] = k;
           k += j;
         }
@@ -649,17 +649,17 @@ idx_vector::idx_vector_rep::as_array (vo
 DEFINE_OCTAVE_ALLOCATOR(idx_vector::idx_mask_rep);
 
 idx_vector::idx_mask_rep::idx_mask_rep (bool b)
   : data (0), len (b ? 1 : 0), ext (0), lsti (-1), lste (-1),
     aowner (0), orig_dims (len, len)
 {
   if (len != 0)
     {
-      bool *d = new bool[1];
+      bool *d = new bool [1];
       d[0] = true;
       data = d;
       ext = 1;
     }
 }
 
 idx_vector::idx_mask_rep::idx_mask_rep (const Array<bool>& bnda,
                                         octave_idx_type nnz)
@@ -1205,17 +1205,17 @@ idx_vector::inverse_permutation (octave_
 idx_vector
 idx_vector::unmask (void) const
 {
   if (idx_class () == class_mask)
     {
       idx_mask_rep * r = dynamic_cast<idx_mask_rep *> (rep);
       const bool *data = r->get_data ();
       octave_idx_type ext = r->extent (0), len = r->length (0);
-      octave_idx_type *idata = new octave_idx_type[len];
+      octave_idx_type *idata = new octave_idx_type [len];
 
       for (octave_idx_type i = 0, j = 0; i < ext; i++)
         if (data[i])
           idata[j++] = i;
 
       ext = len > 0 ? idata[len - 1] + 1 : 0;
 
       return new idx_vector_rep (idata, len, ext, r->orig_dimensions (),
diff --git a/liboctave/oct-alloc.cc b/liboctave/oct-alloc.cc
--- a/liboctave/oct-alloc.cc
+++ b/liboctave/oct-alloc.cc
@@ -27,17 +27,17 @@ along with Octave; see the file COPYING.
 #include <new>
 
 #include "oct-alloc.h"
 
 void *
 octave_allocator::alloc (size_t size)
 {
   if (size != item_size)
-    return ::new char[size];
+    return ::new char [size];
 
   if (! head)
     {
       if (! grow ())
         return 0;
     }
 
   link *tmp = head;
diff --git a/liboctave/oct-locbuf.cc b/liboctave/oct-locbuf.cc
--- a/liboctave/oct-locbuf.cc
+++ b/liboctave/oct-locbuf.cc
@@ -69,21 +69,21 @@ octave_chunk_buffer::octave_chunk_buffer
     {
       // Big buffers (> 1/8 chunk) will be allocated as stand-alone and
       // won't disrupt the chain.
 
       if (size > chunk_size >> 3)
         {
           // Use new [] to get std::bad_alloc if out of memory.
 
-          dat = new char[size];
+          dat = new char [size];
           return;
         }
 
-      dat = new char[chunk_size];
+      dat = new char [chunk_size];
       chunk = top = dat;
       left = chunk_size;
     }
 
   // Now allocate memory from the chunk and update state.
 
   cnk = chunk;
   dat = top;
diff --git a/liboctave/oct-locbuf.h b/liboctave/oct-locbuf.h
--- a/liboctave/oct-locbuf.h
+++ b/liboctave/oct-locbuf.h
@@ -33,17 +33,17 @@ along with Octave; see the file COPYING.
 template <class T>
 class octave_local_buffer
 {
 public:
   octave_local_buffer (size_t size)
     : data (0)
     {
       if (size)
-        data = new T[size];
+        data = new T [size];
     }
   ~octave_local_buffer (void) { delete [] data; }
   operator T *() const { return data; }
 
 private:
   T *data;
 
   // No copying!
@@ -199,15 +199,15 @@ public:
   T *buf = _buffer_ ## buf
 
 #endif
 
 // Note: we use weird variables in the for loop to avoid warnings
 // about shadowed parameters.
 
 #define OCTAVE_LOCAL_BUFFER_INIT(T, buf, size, value) \
-  OCTAVE_LOCAL_BUFFER(T, buf, size); \
+  OCTAVE_LOCAL_BUFFER (T, buf, size); \
   for (size_t _buf_iter = 0, _buf_size = size; \
         _buf_iter < _buf_size; _buf_iter++) \
     buf[_buf_iter] = value
 
 #endif
 
diff --git a/liboctave/oct-mem.h b/liboctave/oct-mem.h
--- a/liboctave/oct-mem.h
+++ b/liboctave/oct-mem.h
@@ -123,26 +123,26 @@ DEFINE_POD_FILL (octave_int<T>)
 // Uninitialized allocation. Will not initialize memory for complex and octave_int.
 // Memory allocated by octave_new should be freed by octave_delete.
 template <class T>
 inline T *no_ctor_new (size_t n)
 {
   // Some systems let us allocate > 2GB memory even though size_t, which is either
   // buggy or completely cuckoo, so let's check here to stay safe.
   safe_size_comp (n, sizeof (T));
-  return new T[n];
+  return new T [n];
 }
 template <class T>
 inline void no_ctor_delete (T *ptr)
 { delete [] ptr; }
 
 #define DEFINE_POD_NEW_DELETE(T) \
 template <> \
 inline T *no_ctor_new<T > (size_t n) \
-{ return reinterpret_cast<T *> (new char[safe_size_comp (n, sizeof (T))]); } \
+{ return reinterpret_cast<T *> (new char [safe_size_comp (n, sizeof (T))]); } \
 template <> \
 inline void no_ctor_delete<T > (T *ptr) \
 { delete [] reinterpret_cast<char *> (ptr); }
 
 DEFINE_POD_NEW_DELETE (Complex)
 DEFINE_POD_NEW_DELETE (FloatComplex)
 
 DEFINE_POD_NEW_DELETE (octave_int8)
diff --git a/liboctave/oct-sort.cc b/liboctave/oct-sort.cc
--- a/liboctave/oct-sort.cc
+++ b/liboctave/oct-sort.cc
@@ -537,17 +537,17 @@ octave_sort<T>::MergeState::getmem (octa
     return;
 
   need = roundupsize (need);
   /* Don't realloc!  That can cost cycles to copy the old data, but
    * we don't care what's in the block.
    */
   delete [] a;
   delete [] ia; // Must do this or fool possible next getmemi.
-  a = new T[need];
+  a = new T [need];
   alloced = need;
 
 }
 
 template <class T>
 void
 octave_sort<T>::MergeState::getmemi (octave_idx_type need)
 {
@@ -556,18 +556,18 @@ octave_sort<T>::MergeState::getmemi (oct
 
   need = roundupsize (need);
   /* Don't realloc!  That can cost cycles to copy the old data, but
    * we don't care what's in the block.
    */
   delete [] a;
   delete [] ia;
 
-  a = new T[need];
-  ia = new octave_idx_type[need];
+  a = new T [need];
+  ia = new octave_idx_type [need];
   alloced = need;
 }
 
 /* Merge the na elements starting at pa with the nb elements starting at pb
  * in a stable way, in-place.  na and nb must be > 0, and pa + na == pb.
  * Must also have that *pb < *pa, that pa[na-1] belongs at the end of the
  * merge, and should have na <= nb.  See listsort.txt for more info.
  * Return 0 if successful, -1 if error.
diff --git a/liboctave/oct-time.cc b/liboctave/oct-time.cc
--- a/liboctave/oct-time.cc
+++ b/liboctave/oct-time.cc
@@ -170,17 +170,17 @@ octave_base_tm::strftime (const std::str
 
       char *buf = 0;
       size_t bufsize = STRFTIME_BUF_INITIAL_SIZE;
       size_t chars_written = 0;
 
       while (chars_written == 0)
         {
           delete [] buf;
-          buf = new char[bufsize];
+          buf = new char [bufsize];
           buf[0] = '\0';
 
           chars_written = nstrftime (buf, bufsize, fmt_str, &t, 0, 0);
 
           bufsize *= 2;
         }
 
 #if defined (HAVE_STRUCT_TM_TM_ZONE)
diff --git a/liboctave/sparse-base-chol.cc b/liboctave/sparse-base-chol.cc
--- a/liboctave/sparse-base-chol.cc
+++ b/liboctave/sparse-base-chol.cc
@@ -52,17 +52,17 @@ sparse_base_chol<chol_type, chol_elt, p_
   Si = static_cast<octave_idx_type *>(S->i);
   Sx = static_cast<chol_elt *>(S->x);
   pdest = 0;
   ncol = S->ncol;
 
   for (k = 0; k < ncol; k++)
     {
       p = Sp[k];
-      pend = Sp [k+1];
+      pend = Sp[k+1];
       Sp[k] = pdest;
       for (; p < pend; p++)
         {
           sik = Sx[p];
           if (CHOLMOD_IS_NONZERO (sik))
             {
               if (p != pdest)
                 {
diff --git a/liboctave/sparse-dmsolve.cc b/liboctave/sparse-dmsolve.cc
--- a/liboctave/sparse-dmsolve.cc
+++ b/liboctave/sparse-dmsolve.cc
@@ -54,17 +54,17 @@ dmsolve_extract (const MSparse<T> &A, co
       nz = 0;
       for (octave_idx_type j = cst ; j < cend ; j++)
         {
           octave_idx_type qq = (Q ? Q[j] : j);
           B.xcidx (j - cst) = nz;
           for (octave_idx_type p = A.cidx (qq) ; p < A.cidx (qq+1) ; p++)
             {
               octave_quit ();
-              octave_idx_type r = (Pinv ? Pinv [A.ridx (p)] : A.ridx (p));
+              octave_idx_type r = (Pinv ? Pinv[A.ridx (p)] : A.ridx (p));
               if (r >= rst && r < rend)
                 {
                   B.xdata (nz) = A.data (p);
                   B.xridx (nz++) = r - rst ;
                 }
             }
         }
       B.xcidx (cend - cst) = nz ;
@@ -77,26 +77,26 @@ dmsolve_extract (const MSparse<T> &A, co
       nz = 0;
       for (octave_idx_type j = cst ; j < cend ; j++)
         {
           octave_idx_type qq = (Q ? Q[j] : j);
           B.xcidx (j - cst) = nz;
           for (octave_idx_type p = A.cidx (qq) ; p < A.cidx (qq+1) ; p++)
             {
               octave_quit ();
-              octave_idx_type r = (Pinv ? Pinv [A.ridx (p)] : A.ridx (p));
+              octave_idx_type r = (Pinv ? Pinv[A.ridx (p)] : A.ridx (p));
               if (r >= rst && r < rend)
                 {
-                  X [r-rst] = A.data (p);
+                  X[r-rst] = A.data (p);
                   B.xridx (nz++) = r - rst ;
                 }
             }
           sort.sort (ri + B.xcidx (j - cst), nz - B.xcidx (j - cst));
           for (octave_idx_type p = B.cidx (j - cst); p < nz; p++)
-            B.xdata (p) = X [B.xridx (p)];
+            B.xdata (p) = X[B.xridx (p)];
         }
       B.xcidx (cend - cst) = nz ;
     }
 
   return B;
 }
 
 #if !defined (CXX_NEW_FRIEND_TEMPLATE_DECL)
@@ -165,17 +165,17 @@ dmsolve_insert (MArray<T> &a, const MArr
   octave_idx_type nc = b.cols ();
   for (octave_idx_type j = 0; j < nc; j++)
     {
       octave_idx_type aoff = (c + j) * anr;
       octave_idx_type boff = j * nr;
       for (octave_idx_type i = 0; i < nr; i++)
         {
           octave_quit ();
-          ax [Q [r + i] + aoff] = bx [i + boff];
+          ax[Q[r + i] + aoff] = bx[i + boff];
         }
     }
 }
 
 #if !defined (CXX_NEW_FRIEND_TEMPLATE_DECL)
 static void
 dmsolve_insert (MArray<double> &a, const MArray<double> &b,
                const octave_idx_type *Q, octave_idx_type r, octave_idx_type c);
@@ -202,17 +202,17 @@ dmsolve_insert (MSparse<T> &a, const MSp
   // First count the number of elements in the final array
   octave_idx_type nel = a.xcidx (c) + b.nnz ();
 
   if (c + b_cols < nc)
     nel += a.xcidx (nc) - a.xcidx (c + b_cols);
 
   for (octave_idx_type i = c; i < c + b_cols; i++)
     for (octave_idx_type j = a.xcidx (i); j < a.xcidx (i+1); j++)
-      if (Qinv [a.xridx (j)] < r || Qinv [a.xridx (j)] >= r + b_rows)
+      if (Qinv[a.xridx (j)] < r || Qinv[a.xridx (j)] >= r + b_rows)
         nel++;
 
   OCTAVE_LOCAL_BUFFER (T, X, nr);
   octave_sort<octave_idx_type> sort;
   MSparse<T> tmp (a);
   a = MSparse<T> (nr, nc, nel);
   octave_idx_type *ri = a.xridx ();
 
@@ -226,33 +226,33 @@ dmsolve_insert (MSparse<T> &a, const MSp
 
   octave_idx_type ii = a.xcidx (c);
 
   for (octave_idx_type i = c; i < c + b_cols; i++)
     {
       octave_quit ();
 
       for (octave_idx_type j = tmp.xcidx (i); j < tmp.xcidx (i+1); j++)
-        if (Qinv [tmp.xridx (j)] < r ||  Qinv [tmp.xridx (j)] >= r + b_rows)
+        if (Qinv[tmp.xridx (j)] < r ||  Qinv[tmp.xridx (j)] >= r + b_rows)
           {
-            X [tmp.xridx (j)] = tmp.xdata (j);
+            X[tmp.xridx (j)] = tmp.xdata (j);
             a.xridx (ii++) = tmp.xridx (j);
           }
 
       octave_quit ();
 
       for (octave_idx_type j = b.cidx (i-c); j < b.cidx (i-c+1); j++)
         {
-          X [Q [r + b.ridx (j)]] = b.data (j);
-          a.xridx (ii++) = Q [r + b.ridx (j)];
+          X[Q[r + b.ridx (j)]] = b.data (j);
+          a.xridx (ii++) = Q[r + b.ridx (j)];
         }
 
       sort.sort (ri + a.xcidx (i), ii - a.xcidx (i));
       for (octave_idx_type p = a.xcidx (i); p < ii; p++)
-        a.xdata (p) = X [a.xridx (p)];
+        a.xdata (p) = X[a.xridx (p)];
       a.xcidx (i+1) = ii;
     }
 
   for (octave_idx_type i = c + b_cols; i < nc; i++)
     {
       for (octave_idx_type j = tmp.xcidx (i); j < tmp.cidx (i+1); j++)
         {
           a.xdata (ii) = tmp.xdata (j);
@@ -327,17 +327,17 @@ dmsolve_permute (MSparse<RT> &a, const M
           octave_idx_type r = p[b.ridx (i)];
           X[r] = b.data (i);
           a.xridx (nz++) = p[b.ridx (i)];
         }
       sort.sort (ri + a.xcidx (j), nz - a.xcidx (j));
       for (octave_idx_type i = a.cidx (j); i < nz; i++)
         {
           octave_quit ();
-          a.xdata (i) = X [a.xridx (i)];
+          a.xdata (i) = X[a.xridx (i)];
         }
       a.xcidx (j+1) = nz;
     }
 }
 
 #if !defined (CXX_NEW_FRIEND_TEMPLATE_DECL)
 static void
 dmsolve_permute (MSparse<double> &a, const MSparse<double>& b,
diff --git a/src/DLD-FUNCTIONS/ccolamd.cc b/src/DLD-FUNCTIONS/ccolamd.cc
--- a/src/DLD-FUNCTIONS/ccolamd.cc
+++ b/src/DLD-FUNCTIONS/ccolamd.cc
@@ -159,63 +159,63 @@ colamd, symamd, and other related orderi
 
       // Check for user-passed knobs
       if (nargin > 1)
         {
           NDArray User_knobs = args(1).array_value ();
           int nel_User_knobs = User_knobs.length ();
 
           if (nel_User_knobs > 0)
-            knobs [CCOLAMD_LU] = (User_knobs (0) != 0);
+            knobs[CCOLAMD_LU] = (User_knobs(0) != 0);
           if (nel_User_knobs > 1)
-            knobs [CCOLAMD_DENSE_ROW]  = User_knobs (1);
+            knobs[CCOLAMD_DENSE_ROW] = User_knobs(1);
           if (nel_User_knobs > 2)
-            knobs [CCOLAMD_DENSE_COL]  = User_knobs (2);
+            knobs[CCOLAMD_DENSE_COL] = User_knobs(2);
           if (nel_User_knobs > 3)
-            knobs [CCOLAMD_AGGRESSIVE] = (User_knobs (3) != 0);
+            knobs[CCOLAMD_AGGRESSIVE] = (User_knobs(3) != 0);
           if (nel_User_knobs > 4)
-            spumoni = (User_knobs (4) != 0);
+            spumoni = (User_knobs(4) != 0);
 
           // print knob settings if spumoni is set
           if (spumoni)
             {
               octave_stdout << "\nccolamd version " << CCOLAMD_MAIN_VERSION << "."
                             <<  CCOLAMD_SUB_VERSION << ", " << CCOLAMD_DATE
-                            << ":\nknobs(1): " << User_knobs (0) << ", order for ";
-              if ( knobs [CCOLAMD_LU] != 0)
+                            << ":\nknobs(1): " << User_knobs(0) << ", order for ";
+              if (knobs[CCOLAMD_LU] != 0)
                 octave_stdout << "lu (A)\n";
               else
                 octave_stdout << "chol (A'*A)\n";
 
-              if (knobs [CCOLAMD_DENSE_ROW] >= 0)
-                octave_stdout << "knobs(2): " << User_knobs (1)
+              if (knobs[CCOLAMD_DENSE_ROW] >= 0)
+                octave_stdout << "knobs(2): " << User_knobs(1)
                               << ", rows with > max (16,"
-                              << knobs [CCOLAMD_DENSE_ROW] << "*sqrt (size(A,2)))"
+                              << knobs[CCOLAMD_DENSE_ROW] << "*sqrt (size(A,2)))"
                               << " entries removed\n";
               else
-                octave_stdout << "knobs(2): " << User_knobs (1)
+                octave_stdout << "knobs(2): " << User_knobs(1)
                               << ", no dense rows removed\n";
 
-              if (knobs [CCOLAMD_DENSE_COL] >= 0)
-                octave_stdout << "knobs(3): " << User_knobs (2)
+              if (knobs[CCOLAMD_DENSE_COL] >= 0)
+                octave_stdout << "knobs(3): " << User_knobs(2)
                               << ", cols with > max (16,"
-                              << knobs [CCOLAMD_DENSE_COL] << "*sqrt (size(A)))"
+                              << knobs[CCOLAMD_DENSE_COL] << "*sqrt (size(A)))"
                               << " entries removed\n";
               else
-                octave_stdout << "knobs(3): " << User_knobs (2)
+                octave_stdout << "knobs(3): " << User_knobs(2)
                               << ", no dense columns removed\n";
 
-              if (knobs [CCOLAMD_AGGRESSIVE] != 0)
+              if (knobs[CCOLAMD_AGGRESSIVE] != 0)
                 octave_stdout << "knobs(4): " << User_knobs(3)
                               << ", aggressive absorption: yes";
               else
                 octave_stdout << "knobs(4): " << User_knobs(3)
                               << ", aggressive absorption: no";
 
-              octave_stdout << "knobs(5): " << User_knobs (4)
+              octave_stdout << "knobs(5): " << User_knobs(4)
                             << ", statistics and knobs printed\n";
             }
         }
 
       octave_idx_type n_row, n_col, nnz;
       octave_idx_type *ridx, *cidx;
       SparseComplexMatrix scm;
       SparseMatrix sm;
@@ -254,22 +254,22 @@ colamd, symamd, and other related orderi
           nnz = sm.nnz ();
           ridx = sm.xridx ();
           cidx = sm.xcidx ();
         }
 
       // Allocate workspace for ccolamd
       OCTAVE_LOCAL_BUFFER (octave_idx_type, p, n_col+1);
       for (octave_idx_type i = 0; i < n_col+1; i++)
-        p[i] = cidx [i];
+        p[i] = cidx[i];
 
       octave_idx_type Alen = CCOLAMD_NAME (_recommended) (nnz, n_row, n_col);
       OCTAVE_LOCAL_BUFFER (octave_idx_type, A, Alen);
       for (octave_idx_type i = 0; i < nnz; i++)
-        A[i] = ridx [i];
+        A[i] = ridx[i];
 
       OCTAVE_LOCAL_BUFFER (octave_idx_type, stats, CCOLAMD_STATS);
 
       if (nargin > 2)
         {
           NDArray in_cmember = args(2).array_value ();
           octave_idx_type cslen = in_cmember.length ();
           OCTAVE_LOCAL_BUFFER (octave_idx_type, cmember, cslen);
@@ -310,17 +310,17 @@ colamd, symamd, and other related orderi
       if (spumoni > 0)
         CCOLAMD_NAME (_report) (stats) ;
 
       // Return the stats vector
       if (nargout == 2)
         {
           NDArray out_stats (dim_vector (1, CCOLAMD_STATS));
           for (octave_idx_type i = 0 ; i < CCOLAMD_STATS ; i++)
-            out_stats (i) = stats [i] ;
+            out_stats(i) = stats[i] ;
           retval(1) = out_stats;
 
           // fix stats (5) and (6), for 1-based information on
           // jumbled matrix.  note that this correction doesn't
           // occur if symamd returns FALSE
           out_stats (CCOLAMD_INFO1) ++ ;
           out_stats (CCOLAMD_INFO2) ++ ;
         }
@@ -414,46 +414,46 @@ colamd, symamd, and other related orderi
 
       // Check for user-passed knobs
       if (nargin > 1)
         {
           NDArray User_knobs = args(1).array_value ();
           int nel_User_knobs = User_knobs.length ();
 
           if (nel_User_knobs > 0)
-            knobs [CCOLAMD_DENSE_ROW] = User_knobs (0);
+            knobs[CCOLAMD_DENSE_ROW] = User_knobs(0);
           if (nel_User_knobs > 0)
-            knobs [CCOLAMD_AGGRESSIVE] = User_knobs (1);
+            knobs[CCOLAMD_AGGRESSIVE] = User_knobs(1);
           if (nel_User_knobs > 1)
-            spumoni = static_cast<int> (User_knobs (2));
+            spumoni = static_cast<int> (User_knobs(2));
 
           // print knob settings if spumoni is set
           if (spumoni)
             {
               octave_stdout << "\ncsymamd version " << CCOLAMD_MAIN_VERSION << "."
                             <<  CCOLAMD_SUB_VERSION << ", " << CCOLAMD_DATE << "\n";
 
-              if (knobs [CCOLAMD_DENSE_ROW] >= 0)
-                octave_stdout << "knobs(1): " << User_knobs (0)
+              if (knobs[CCOLAMD_DENSE_ROW] >= 0)
+                octave_stdout << "knobs(1): " << User_knobs(0)
                               << ", rows/cols with > max (16,"
-                              << knobs [CCOLAMD_DENSE_ROW] << "*sqrt (size(A,2)))"
+                              << knobs[CCOLAMD_DENSE_ROW] << "*sqrt (size(A,2)))"
                               << " entries removed\n";
               else
-                octave_stdout << "knobs(1): " << User_knobs (0)
+                octave_stdout << "knobs(1): " << User_knobs(0)
                               << ", no dense rows/cols removed\n";
 
-              if (knobs [CCOLAMD_AGGRESSIVE] != 0)
+              if (knobs[CCOLAMD_AGGRESSIVE] != 0)
                 octave_stdout << "knobs(2): " << User_knobs(1)
                               << ", aggressive absorption: yes";
               else
                 octave_stdout << "knobs(2): " << User_knobs(1)
                               << ", aggressive absorption: no";
 
 
-              octave_stdout << "knobs(3): " << User_knobs (2)
+              octave_stdout << "knobs(3): " << User_knobs(2)
                             << ", statistics and knobs printed\n";
             }
         }
 
       octave_idx_type n_row, n_col;
       octave_idx_type *ridx, *cidx;
       SparseMatrix sm;
       SparseComplexMatrix scm;
@@ -538,17 +538,17 @@ colamd, symamd, and other related orderi
 
       retval(0) = out_perm;
 
       // Return the stats vector
       if (nargout == 2)
         {
           NDArray out_stats (dim_vector (1, CCOLAMD_STATS));
           for (octave_idx_type i = 0 ; i < CCOLAMD_STATS ; i++)
-            out_stats (i) = stats [i] ;
+            out_stats(i) = stats[i] ;
           retval(1) = out_stats;
 
           // fix stats (5) and (6), for 1-based information on
           // jumbled matrix.  note that this correction doesn't
           // occur if symamd returns FALSE
           out_stats (CCOLAMD_INFO1) ++ ;
           out_stats (CCOLAMD_INFO2) ++ ;
         }
@@ -557,17 +557,17 @@ colamd, symamd, and other related orderi
       if (spumoni > 0)
         CSYMAMD_NAME (_report) (stats) ;
 
       // Return the stats vector
       if (nargout == 2)
         {
           NDArray out_stats (dim_vector (1, CCOLAMD_STATS));
           for (octave_idx_type i = 0 ; i < CCOLAMD_STATS ; i++)
-            out_stats (i) = stats [i] ;
+            out_stats(i) = stats[i] ;
           retval(1) = out_stats;
 
           // fix stats (5) and (6), for 1-based information on
           // jumbled matrix.  note that this correction doesn't
           // occur if symamd returns FALSE
           out_stats (CCOLAMD_INFO1) ++ ;
           out_stats (CCOLAMD_INFO2) ++ ;
         }
diff --git a/src/DLD-FUNCTIONS/colamd.cc b/src/DLD-FUNCTIONS/colamd.cc
--- a/src/DLD-FUNCTIONS/colamd.cc
+++ b/src/DLD-FUNCTIONS/colamd.cc
@@ -58,38 +58,38 @@ static void
 symetree (const octave_idx_type *ridx, const octave_idx_type *cidx,
           octave_idx_type *Parent, octave_idx_type *P, octave_idx_type n)
 {
   OCTAVE_LOCAL_BUFFER (octave_idx_type, Flag, n);
   OCTAVE_LOCAL_BUFFER (octave_idx_type, Pinv, (P ? n : 0));
   if (P)
     // If P is present then compute Pinv, the inverse of P
     for (octave_idx_type k = 0 ; k < n ; k++)
-      Pinv [P [k]] = k ;
+      Pinv[P[k]] = k ;
 
   for (octave_idx_type k = 0 ; k < n ; k++)
     {
       // L(k,:) pattern: all nodes reachable in etree from nz in A(0:k-1,k)
-      Parent [k] = n ;                // parent of k is not yet known
-      Flag [k] = k ;                  // mark node k as visited
-      octave_idx_type kk = (P) ? (P [k]) : (k) ;  // kth original, or permuted, column
-      octave_idx_type p2 = cidx [kk+1] ;
-      for (octave_idx_type p = cidx [kk] ; p < p2 ; p++)
+      Parent[k] = n ;                // parent of k is not yet known
+      Flag[k] = k ;                  // mark node k as visited
+      octave_idx_type kk = (P) ? (P[k]) : (k) ;  // kth original, or permuted, column
+      octave_idx_type p2 = cidx[kk+1] ;
+      for (octave_idx_type p = cidx[kk] ; p < p2 ; p++)
         {
           // A (i,k) is nonzero (original or permuted A)
-          octave_idx_type i = (Pinv) ? (Pinv [ridx [p]]) : (ridx [p]) ;
+          octave_idx_type i = (Pinv) ? (Pinv[ridx[p]]) : (ridx[p]) ;
           if (i < k)
             {
               // follow path from i to root of etree, stop at flagged node
-              for ( ; Flag [i] != k ; i = Parent [i])
+              for ( ; Flag[i] != k ; i = Parent[i])
                 {
                   // find parent of i if not yet determined
-                  if (Parent [i] == n)
-                    Parent [i] = k ;
-                  Flag [i] = k ;        // mark i as visited
+                  if (Parent[i] == n)
+                    Parent[i] = k ;
+                  Flag[i] = k ;        // mark i as visited
                 }
             }
         }
     }
 }
 
 // The elimination tree post-ordering code below is taken from SuperLU
 static inline octave_idx_type
@@ -294,42 +294,42 @@ Ng, Oak Ridge National Laboratory.  (see
 
       // Check for user-passed knobs
       if (nargin == 2)
         {
           NDArray User_knobs = args(1).array_value ();
           int nel_User_knobs = User_knobs.length ();
 
           if (nel_User_knobs > 0)
-            knobs [COLAMD_DENSE_ROW] = User_knobs (0);
+            knobs[COLAMD_DENSE_ROW] = User_knobs(0);
           if (nel_User_knobs > 1)
-            knobs [COLAMD_DENSE_COL] = User_knobs (1) ;
+            knobs[COLAMD_DENSE_COL] = User_knobs(1) ;
           if (nel_User_knobs > 2)
-            spumoni = static_cast<int> (User_knobs (2));
+            spumoni = static_cast<int> (User_knobs(2));
 
           // print knob settings if spumoni is set
           if (spumoni)
             {
 
               octave_stdout << "\ncolamd version " << COLAMD_MAIN_VERSION << "."
                             <<  COLAMD_SUB_VERSION << ", " << COLAMD_DATE << ":\n";
 
-              if (knobs [COLAMD_DENSE_ROW] >= 0)
+              if (knobs[COLAMD_DENSE_ROW] >= 0)
                 octave_stdout << "knobs(1): " << User_knobs (0)
                               << ", rows with > max (16,"
-                              << knobs [COLAMD_DENSE_ROW] << "*sqrt (size(A,2)))"
+                              << knobs[COLAMD_DENSE_ROW] << "*sqrt (size(A,2)))"
                               << " entries removed\n";
               else
                 octave_stdout << "knobs(1): " << User_knobs (0)
                               << ", only completely dense rows removed\n";
 
-              if (knobs [COLAMD_DENSE_COL] >= 0)
+              if (knobs[COLAMD_DENSE_COL] >= 0)
                 octave_stdout << "knobs(2): " << User_knobs (1)
                               << ", cols with > max (16,"
-                              << knobs [COLAMD_DENSE_COL] << "*sqrt (size(A)))"
+                              << knobs[COLAMD_DENSE_COL] << "*sqrt (size(A)))"
                               << " entries removed\n";
               else
                 octave_stdout << "knobs(2): " << User_knobs (1)
                               << ", only completely dense columns removed\n";
 
               octave_stdout << "knobs(3): " << User_knobs (2)
                             << ", statistics and knobs printed\n";
 
@@ -375,22 +375,22 @@ Ng, Oak Ridge National Laboratory.  (see
           nnz = sm.nnz ();
           ridx = sm.xridx ();
           cidx = sm.xcidx ();
         }
 
       // Allocate workspace for colamd
       OCTAVE_LOCAL_BUFFER (octave_idx_type, p, n_col+1);
       for (octave_idx_type i = 0; i < n_col+1; i++)
-        p[i] = cidx [i];
+        p[i] = cidx[i];
 
       octave_idx_type Alen = COLAMD_NAME (_recommended) (nnz, n_row, n_col);
       OCTAVE_LOCAL_BUFFER (octave_idx_type, A, Alen);
       for (octave_idx_type i = 0; i < nnz; i++)
-        A[i] = ridx [i];
+        A[i] = ridx[i];
 
       // Order the columns (destroys A)
       OCTAVE_LOCAL_BUFFER (octave_idx_type, stats, COLAMD_STATS);
       if (! COLAMD_NAME () (n_row, n_col, Alen, A, p, knobs, stats))
         {
           COLAMD_NAME (_report) (stats) ;
           error ("colamd: internal error!");
           return retval;
@@ -410,30 +410,30 @@ Ng, Oak Ridge National Laboratory.  (see
       coletree (ridx, colbeg, colend, etree, n_row, n_col);
 
       // Calculate the tree post-ordering
       tree_postorder (n_col, etree, colbeg);
 
       // return the permutation vector
       NDArray out_perm (dim_vector (1, n_col));
       for (octave_idx_type i = 0; i < n_col; i++)
-        out_perm(i) = p[colbeg [i]] + 1;
+        out_perm(i) = p[colbeg[i]] + 1;
 
       retval(0) = out_perm;
 
       // print stats if spumoni > 0
       if (spumoni > 0)
         COLAMD_NAME (_report) (stats) ;
 
       // Return the stats vector
       if (nargout == 2)
         {
           NDArray out_stats (dim_vector (1, COLAMD_STATS));
           for (octave_idx_type i = 0 ; i < COLAMD_STATS ; i++)
-            out_stats (i) = stats [i] ;
+            out_stats(i) = stats[i] ;
           retval(1) = out_stats;
 
           // fix stats (5) and (6), for 1-based information on
           // jumbled matrix.  note that this correction doesn't
           // occur if symamd returns FALSE
           out_stats (COLAMD_INFO1) ++ ;
           out_stats (COLAMD_INFO2) ++ ;
         }
@@ -529,25 +529,25 @@ Ng, Oak Ridge National Laboratory.  (see
 
       // Check for user-passed knobs
       if (nargin == 2)
         {
           NDArray User_knobs = args(1).array_value ();
           int nel_User_knobs = User_knobs.length ();
 
           if (nel_User_knobs > 0)
-            knobs [COLAMD_DENSE_ROW] = User_knobs (COLAMD_DENSE_ROW);
+            knobs[COLAMD_DENSE_ROW] = User_knobs(COLAMD_DENSE_ROW);
           if (nel_User_knobs > 1)
             spumoni = static_cast<int> (User_knobs (1));
         }
 
       // print knob settings if spumoni is set
       if (spumoni > 0)
         octave_stdout << "symamd: dense row/col fraction: "
-                      << knobs [COLAMD_DENSE_ROW] << std::endl;
+                      << knobs[COLAMD_DENSE_ROW] << std::endl;
 
       octave_idx_type n_row, n_col;
       octave_idx_type *ridx, *cidx;
       SparseMatrix sm;
       SparseComplexMatrix scm;
 
       if (args(0).is_sparse_type ())
         {
@@ -603,30 +603,30 @@ Ng, Oak Ridge National Laboratory.  (see
 
       // Calculate the tree post-ordering
       OCTAVE_LOCAL_BUFFER (octave_idx_type, post, n_col + 1);
       tree_postorder (n_col, etree, post);
 
       // return the permutation vector
       NDArray out_perm (dim_vector (1, n_col));
       for (octave_idx_type i = 0; i < n_col; i++)
-        out_perm(i) = perm[post [i]] + 1;
+        out_perm(i) = perm[post[i]] + 1;
 
       retval(0) = out_perm;
 
       // print stats if spumoni > 0
       if (spumoni > 0)
         SYMAMD_NAME (_report) (stats) ;
 
       // Return the stats vector
       if (nargout == 2)
         {
           NDArray out_stats (dim_vector (1, COLAMD_STATS));
           for (octave_idx_type i = 0 ; i < COLAMD_STATS ; i++)
-            out_stats (i) = stats [i] ;
+            out_stats(i) = stats[i] ;
           retval(1) = out_stats;
 
           // fix stats (5) and (6), for 1-based information on
           // jumbled matrix.  note that this correction doesn't
           // occur if symamd returns FALSE
           out_stats (COLAMD_INFO1) ++ ;
           out_stats (COLAMD_INFO2) ++ ;
         }
diff --git a/src/DLD-FUNCTIONS/spparms.cc b/src/DLD-FUNCTIONS/spparms.cc
--- a/src/DLD-FUNCTIONS/spparms.cc
+++ b/src/DLD-FUNCTIONS/spparms.cc
@@ -121,17 +121,17 @@ running time.\n\
     }
   else if (nargin == 1)
     {
       if (args(0).is_string ())
         {
           std::string str = args(0).string_value ();
           int len = str.length ();
           for (int i = 0; i < len; i++)
-            str [i] = tolower (str [i]);
+            str[i] = tolower (str[i]);
 
           if (str == "defaults")
             octave_sparse_params::defaults ();
           else if (str == "tight")
             octave_sparse_params::tight ();
           else
             {
               double val = octave_sparse_params::get_key (str);
diff --git a/src/DLD-FUNCTIONS/symbfact.cc b/src/DLD-FUNCTIONS/symbfact.cc
--- a/src/DLD-FUNCTIONS/symbfact.cc
+++ b/src/DLD-FUNCTIONS/symbfact.cc
@@ -265,28 +265,28 @@ factorization as determined by @var{typ}
             {
               A1 = A;
               A2 = F;
             }
 
           // count the total number of entries in L
           octave_idx_type lnz = 0 ;
           for (octave_idx_type j = 0 ; j < n ; j++)
-            lnz += ColCount [j] ;
+            lnz += ColCount[j];
 
 
           // allocate the output matrix L (pattern-only)
           SparseBoolMatrix L (n, n, lnz);
 
           // initialize column pointers
           lnz = 0;
           for (octave_idx_type j = 0 ; j < n ; j++)
             {
               L.xcidx(j) = lnz;
-              lnz += ColCount [j];
+              lnz += ColCount[j];
             }
           L.xcidx(n) = lnz;
 
 
           /* create a copy of the column pointers */
           octave_idx_type *W = First;
           for (octave_idx_type j = 0 ; j < n ; j++)
             W[j] = L.xcidx (j);
@@ -297,21 +297,21 @@ factorization as determined by @var{typ}
           octave_idx_type *Rp = static_cast<octave_idx_type *>(R->p);
           octave_idx_type *Ri = static_cast<octave_idx_type *>(R->i);
 
           // compute L one row at a time
           for (octave_idx_type k = 0 ; k < n ; k++)
             {
               // get the kth row of L and store in the columns of L
               CHOLMOD_NAME (row_subtree) (A1, A2, k, Parent, R, cm) ;
-              for (octave_idx_type p = 0 ; p < Rp [1] ; p++)
-                L.xridx (W [Ri [p]]++) = k ;
+              for (octave_idx_type p = 0 ; p < Rp[1] ; p++)
+                L.xridx (W[Ri[p]]++) = k ;
 
               // add the diagonal entry
-              L.xridx (W [k]++) = k ;
+              L.xridx (W[k]++) = k ;
             }
 
           // free workspace
           cholmod_free_sparse (&R, cm) ;
 
 
           // transpose L to get R, or leave as is
           if (nargin < 3)
diff --git a/src/DLD-FUNCTIONS/symrcm.cc b/src/DLD-FUNCTIONS/symrcm.cc
--- a/src/DLD-FUNCTIONS/symrcm.cc
+++ b/src/DLD-FUNCTIONS/symrcm.cc
@@ -400,17 +400,17 @@ transpose (octave_idx_type N, const octa
     }
   cidx2[N] = nz;
   w[N] = nz;
 
   for (octave_idx_type j = 0; j < N; j++)
     for (octave_idx_type k = cidx[j]; k < cidx[j + 1]; k++)
       {
         OCTAVE_QUIT;
-        octave_idx_type q = w [ridx[k]]++;
+        octave_idx_type q = w[ridx[k]]++;
         ridx2[q] = j;
       }
 }
 
 // An implementation of the Cuthill-McKee algorithm.
 DEFUN_DLD (symrcm, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{p} =} symrcm (@var{S})\n\
diff --git a/src/help.cc b/src/help.cc
--- a/src/help.cc
+++ b/src/help.cc
@@ -757,17 +757,17 @@ Begin a while loop.\n\
 
 // Return a copy of the operator or keyword names.
 static string_vector
 names (const map_type& lst)
 {
   string_vector retval (lst.size ());
   int j = 0;
   for (map_iter iter = lst.begin (); iter != lst.end (); iter ++)
-    retval [j++] = iter->first;
+    retval[j++] = iter->first;
   return retval;
 }
 
 const static map_type operators_map (operators, operators + size (operators));
 const static map_type keywords_map (keywords, keywords + size (keywords));
 const static string_vector keyword_names = names (keywords_map);
 
 // FIXME -- It's not likely that this does the right thing now.
@@ -1213,21 +1213,21 @@ Undocumented internal function.\n\
 // FIXME -- Are we sure this function always does the right thing?
 inline bool
 file_is_in_dir (const std::string filename, const std::string dir)
 {
   if (filename.find (dir) == 0)
     {
       const int dir_len = dir.size ();
       const int filename_len = filename.size ();
-      const int max_allowed_seps = file_ops::is_dir_sep (dir [dir_len-1]) ? 0 : 1;
+      const int max_allowed_seps = file_ops::is_dir_sep (dir[dir_len-1]) ? 0 : 1;
 
       int num_seps = 0;
       for (int i = dir_len; i < filename_len; i++)
-        if (file_ops::is_dir_sep (filename [i]))
+        if (file_ops::is_dir_sep (filename[i]))
           num_seps ++;
 
       return (num_seps <= max_allowed_seps);
     }
   else
     return false;
 }
 
diff --git a/src/jit-typeinfo.cc b/src/jit-typeinfo.cc
--- a/src/jit-typeinfo.cc
+++ b/src/jit-typeinfo.cc
@@ -63,17 +63,17 @@ std::ostream& jit_print (std::ostream& o
 // function that jit code calls
 extern "C" void
 octave_jit_print_any (const char *name, octave_base_value *obv)
 {
   obv->print_with_name (octave_stdout, name, true);
 }
 
 extern "C" void
-octave_jit_print_double (const char *name, double value)
+octave_jit_print_scalar (const char *name, double value)
 {
   // FIXME: We should avoid allocating a new octave_scalar each time
   octave_value ov (value);
   ov.print_with_name (octave_stdout, name);
 }
 
 extern "C" octave_base_value*
 octave_jit_binary_any_any (octave_value::binary_op op, octave_base_value *lhs,
@@ -609,16 +609,23 @@ jit_function::do_return (llvm::IRBuilder
         builder.CreateRet (rval);
     }
   else
     builder.CreateRetVoid ();
 
   llvm::verifyFunction (*llvm_function);
 }
 
+void
+jit_function::do_add_mapping (llvm::ExecutionEngine *engine, void *fn)
+{
+  assert (valid ());
+  engine->addGlobalMapping (llvm_function, fn);
+}
+
 std::ostream&
 operator<< (std::ostream& os, const jit_function& fn)
 {
   llvm::Function *lfn = fn.to_llvm ();
   os << "jit_function: cc=" << fn.call_conv;
   llvm::raw_os_ostream llvm_out (os);
   lfn->print (llvm_out);
   llvm_out.flush ();
@@ -791,16 +798,17 @@ jit_typeinfo::jit_typeinfo (llvm::Module
 
   // any with anything is an any op
   jit_function fn;
   jit_type *binary_op_type = intN (sizeof (octave_value::binary_op) * 8);
   llvm::Type *llvm_bo_type = binary_op_type->to_llvm ();
   jit_function any_binary = create_function (jit_convention::external,
                                              "octave_jit_binary_any_any",
                                              any, binary_op_type, any, any);
+  any_binary.add_mapping (engine, &octave_jit_binary_any_any);
   any_binary.mark_can_error ();
   binary_ops.resize (octave_value::num_binary_ops);
   for (size_t i = 0; i < octave_value::num_binary_ops; ++i)
     {
       octave_value::binary_op op = static_cast<octave_value::binary_op> (i);
       std::string op_name = octave_value::binary_op_as_string (op);
       binary_ops[i].stash_name ("binary" + op_name);
     }
@@ -822,33 +830,37 @@ jit_typeinfo::jit_typeinfo (llvm::Module
                                           fn.argument (builder, 1));
       fn.do_return (builder, ret);
       binary_ops[op].add_overload (fn);
     }
 
   // grab any
   fn = create_function (jit_convention::external, "octave_jit_grab_any", any,
                         any);
+  fn.add_mapping (engine, &octave_jit_grab_any);
   grab_fn.add_overload (fn);
   grab_fn.stash_name ("grab");
 
   // grab matrix
   fn = create_function (jit_convention::external, "octave_jit_grab_matrix",
                         matrix, matrix);
+  fn.add_mapping (engine, &octave_jit_grab_matrix);
   grab_fn.add_overload (fn);
 
   // release any
   fn = create_function (jit_convention::external, "octave_jit_release_any", 0,
                         any);
+  fn.add_mapping (engine, &octave_jit_release_any);
   release_fn.add_overload (fn);
   release_fn.stash_name ("release");
 
   // release matrix
   fn = create_function (jit_convention::external, "octave_jit_release_matrix",
                         0, matrix);
+  fn.add_mapping (engine, &octave_jit_release_matrix);
   release_fn.add_overload (fn);
 
   // release scalar
   fn = create_identity (scalar);
   release_fn.add_overload (fn);
 
   // release complex
   fn = create_identity (complex);
@@ -869,16 +881,17 @@ jit_typeinfo::jit_typeinfo (llvm::Module
   add_binary_fcmp (scalar, octave_value::op_le, llvm::CmpInst::FCMP_ULE);
   add_binary_fcmp (scalar, octave_value::op_eq, llvm::CmpInst::FCMP_UEQ);
   add_binary_fcmp (scalar, octave_value::op_ge, llvm::CmpInst::FCMP_UGE);
   add_binary_fcmp (scalar, octave_value::op_gt, llvm::CmpInst::FCMP_UGT);
   add_binary_fcmp (scalar, octave_value::op_ne, llvm::CmpInst::FCMP_UNE);
 
   jit_function gripe_div0 = create_function (jit_convention::external,
                                              "gripe_divide_by_zero", 0);
+  gripe_div0.add_mapping (engine, &gripe_divide_by_zero);
   gripe_div0.mark_can_error ();
 
   // divide is annoying because it might error
   fn = create_function (jit_convention::internal,
                         "octave_jit_div_scalar_scalar", scalar, scalar, scalar);
   fn.mark_can_error ();
 
   llvm::BasicBlock *body = fn.new_block ();
@@ -909,16 +922,17 @@ jit_typeinfo::jit_typeinfo (llvm::Module
   binary_ops[octave_value::op_el_ldiv].add_overload (fn);
 
   // In general, the result of scalar ^ scalar is a complex number. We might be
   // able to improve on this if we keep track of the range of values varaibles
   // can take on.
   fn = create_function (jit_convention::external,
                         "octave_jit_pow_scalar_scalar", complex, scalar,
                         scalar);
+  fn.add_mapping (engine, &octave_jit_pow_scalar_scalar);
   binary_ops[octave_value::op_pow].add_overload (fn);
   binary_ops[octave_value::op_el_pow].add_overload (fn);
 
   // now for binary complex operations
   add_binary_op (complex, octave_value::op_add, llvm::Instruction::FAdd);
   add_binary_op (complex, octave_value::op_sub, llvm::Instruction::FSub);
 
   fn = create_function (jit_convention::internal,
@@ -970,27 +984,29 @@ jit_typeinfo::jit_typeinfo (llvm::Module
   }
 
   binary_ops[octave_value::op_mul].add_overload (fn);
   binary_ops[octave_value::op_el_mul].add_overload (fn);
 
   jit_function complex_div = create_function (jit_convention::external,
                                               "octave_jit_complex_div",
                                               complex, complex, complex);
+  complex_div.add_mapping (engine, &octave_jit_complex_div);
   complex_div.mark_can_error ();
   binary_ops[octave_value::op_div].add_overload (fn);
   binary_ops[octave_value::op_ldiv].add_overload (fn);
 
   fn = mirror_binary (complex_div);
   binary_ops[octave_value::op_ldiv].add_overload (fn);
   binary_ops[octave_value::op_el_ldiv].add_overload (fn);
 
   fn = create_function (jit_convention::external,
                         "octave_jit_pow_complex_complex", complex, complex,
                         complex);
+  fn.add_mapping (engine, &octave_jit_pow_complex_complex);
   binary_ops[octave_value::op_pow].add_overload (fn);
   binary_ops[octave_value::op_el_pow].add_overload (fn);
 
   fn = create_function (jit_convention::internal,
                         "octave_jit_*_scalar_complex", complex, scalar,
                         complex);
   jit_function mul_scalar_complex = fn;
   body = fn.new_block ();
@@ -1046,36 +1062,38 @@ jit_typeinfo::jit_typeinfo (llvm::Module
     llvm::Value *real = builder.CreateFSub (lhs, complex_real (rhs));
     fn.do_return (builder, complex_real (rhs, real));
   }
   binary_ops[octave_value::op_sub].add_overload (fn);
 
   fn = create_function (jit_convention::external,
                         "octave_jit_pow_scalar_complex", complex, scalar,
                         complex);
+  fn.add_mapping (engine, &octave_jit_pow_scalar_complex);
   binary_ops[octave_value::op_pow].add_overload (fn);
   binary_ops[octave_value::op_el_pow].add_overload (fn);
 
   fn = create_function (jit_convention::external,
                         "octave_jit_pow_complex_scalar", complex, complex,
                         scalar);
+  fn.add_mapping (engine, &octave_jit_pow_complex_scalar);
   binary_ops[octave_value::op_pow].add_overload (fn);
   binary_ops[octave_value::op_el_pow].add_overload (fn);
 
   // now for binary index operators
   add_binary_op (index, octave_value::op_add, llvm::Instruction::Add);
 
   // and binary bool operators
   add_binary_op (boolean, octave_value::op_el_or, llvm::Instruction::Or);
   add_binary_op (boolean, octave_value::op_el_and, llvm::Instruction::And);
 
   // now for printing functions
   print_fn.stash_name ("print");
-  add_print (any);
-  add_print (scalar);
+  add_print (any, reinterpret_cast<void *> (&octave_jit_print_any));
+  add_print (scalar, reinterpret_cast<void *> (&octave_jit_print_scalar));
 
   // initialize for loop
   for_init_fn.stash_name ("for_init");
 
   fn = create_function (jit_convention::internal, "octave_jit_for_range_init",
                         index, range);
   body = fn.new_block ();
   builder.SetInsertPoint (body);
@@ -1122,16 +1140,17 @@ jit_typeinfo::jit_typeinfo (llvm::Module
   for_index_fn.add_overload (fn);
 
   // logically true
   logically_true_fn.stash_name ("logically_true");
 
   jit_function gripe_nantl
     = create_function (jit_convention::external,
                        "octave_jit_gripe_nan_to_logical_conversion", 0);
+  gripe_nantl.add_mapping (engine, &octave_jit_gripe_nan_to_logical_conversion);
   gripe_nantl.mark_can_error ();
 
   fn = create_function (jit_convention::internal,
                         "octave_jit_logically_true_scalar", boolean, scalar);
   fn.mark_can_error ();
 
   body = fn.new_block ();
   builder.SetInsertPoint (body);
@@ -1159,16 +1178,17 @@ jit_typeinfo::jit_typeinfo (llvm::Module
   logically_true_fn.add_overload (fn);
 
   // make_range
   // FIXME: May be benificial to implement all in LLVM
   make_range_fn.stash_name ("make_range");
   jit_function compute_nelem
     = create_function (jit_convention::external, "octave_jit_compute_nelem",
                        index, scalar, scalar, scalar);
+  compute_nelem.add_mapping (engine, &octave_jit_compute_nelem);
 
   fn = create_function (jit_convention::internal, "octave_jit_make_range",
                         range, scalar, scalar, scalar);
   body = fn.new_block ();
   builder.SetInsertPoint (body);
   {
     llvm::Value *base = fn.argument (builder, 0);
     llvm::Value *limit = fn.argument (builder, 1);
@@ -1188,20 +1208,22 @@ jit_typeinfo::jit_typeinfo (llvm::Module
   make_range_fn.add_overload (fn);
 
   // paren_subsref
   jit_type *jit_int = intN (sizeof (int) * 8);
   llvm::Type *int_t = jit_int->to_llvm ();
   jit_function ginvalid_index
     = create_function (jit_convention::external, "octave_jit_ginvalid_index",
                        0);
+  ginvalid_index.add_mapping (engine, &octave_jit_ginvalid_index);
   jit_function gindex_range = create_function (jit_convention::external,
                                                "octave_jit_gindex_range",
                                                0, jit_int, jit_int, index,
                                                index);
+  gindex_range.add_mapping (engine, &octave_jit_gindex_range);
 
   fn = create_function (jit_convention::internal, "()subsref", scalar, matrix,
                         scalar);
   fn.mark_can_error ();
 
   body = fn.new_block ();
   builder.SetInsertPoint (body);
   {
@@ -1265,16 +1287,17 @@ jit_typeinfo::jit_typeinfo (llvm::Module
   paren_subsref_fn.add_overload (fn);
 
   // paren subsasgn
   paren_subsasgn_fn.stash_name ("()subsasgn");
 
   jit_function resize_paren_subsasgn
     = create_function (jit_convention::external,
                        "octave_jit_paren_subsasgn_impl", matrix, index, scalar);
+  resize_paren_subsasgn.add_mapping (engine, &octave_jit_paren_subsasgn_impl);
   fn = create_function (jit_convention::internal, "octave_jit_paren_subsasgn",
                         matrix, matrix, scalar, scalar);
   fn.mark_can_error ();
   body = fn.new_block ();
   builder.SetInsertPoint (body);
   {
     llvm::Value *one = llvm::ConstantInt::get (index_t, 1);
 
@@ -1333,52 +1356,59 @@ jit_typeinfo::jit_typeinfo (llvm::Module
     merge->addIncoming (mat, success);
     fn.do_return (builder, merge);
   }
   paren_subsasgn_fn.add_overload (fn);
 
   fn = create_function (jit_convention::external,
                         "octave_jit_paren_subsasgn_matrix_range", matrix,
                         matrix, range, scalar);
+  fn.add_mapping (engine, &octave_jit_paren_subsasgn_matrix_range);
   fn.mark_can_error ();
   paren_subsasgn_fn.add_overload (fn);
 
   casts[any->type_id ()].stash_name ("(any)");
   casts[scalar->type_id ()].stash_name ("(scalar)");
   casts[complex->type_id ()].stash_name ("(complex)");
   casts[matrix->type_id ()].stash_name ("(matrix)");
 
   // cast any <- matrix
   fn = create_function (jit_convention::external, "octave_jit_cast_any_matrix",
                         any, matrix);
+  fn.add_mapping (engine, &octave_jit_cast_any_matrix);
   casts[any->type_id ()].add_overload (fn);
 
   // cast matrix <- any
   fn = create_function (jit_convention::external, "octave_jit_cast_matrix_any",
                         matrix, any);
+  fn.add_mapping (engine, &octave_jit_cast_matrix_any);
   casts[matrix->type_id ()].add_overload (fn);
 
   // cast any <- scalar
   fn = create_function (jit_convention::external, "octave_jit_cast_any_scalar",
                         any, scalar);
+  fn.add_mapping (engine, &octave_jit_cast_any_scalar);
   casts[any->type_id ()].add_overload (fn);
 
   // cast scalar <- any
   fn = create_function (jit_convention::external, "octave_jit_cast_scalar_any",
                         scalar, any);
+  fn.add_mapping (engine, &octave_jit_cast_scalar_any);
   casts[scalar->type_id ()].add_overload (fn);
 
   // cast any <- complex
   fn = create_function (jit_convention::external, "octave_jit_cast_any_complex",
                         any, complex);
+  fn.add_mapping (engine, &octave_jit_cast_any_complex);
   casts[any->type_id ()].add_overload (fn);
 
   // cast complex <- any
   fn = create_function (jit_convention::external, "octave_jit_cast_complex_any",
                         complex, any);
+  fn.add_mapping (engine, &octave_jit_cast_complex_any);
   casts[complex->type_id ()].add_overload (fn);
 
   // cast complex <- scalar
   fn = create_function (jit_convention::internal,
                         "octave_jit_cast_complex_scalar", complex, scalar);
   body = fn.new_block ();
   builder.SetInsertPoint (body);
   {
@@ -1440,22 +1470,23 @@ jit_typeinfo::jit_typeinfo (llvm::Module
 
       args[0] = any;
       casts[btype->type_id ()].add_overload (jit_function (any_id, btype,
                                                            args));
     }
 }
 
 void
-jit_typeinfo::add_print (jit_type *ty)
+jit_typeinfo::add_print (jit_type *ty, void *fptr)
 {
   std::stringstream name;
   name << "octave_jit_print_" << ty->name ();
   jit_function fn = create_function (jit_convention::external, name.str (), 0,
                                      intN (8), ty);
+  fn.add_mapping (engine, fptr);
   print_fn.add_overload (fn);
 }
 
 // FIXME: cp between add_binary_op, add_binary_icmp, and add_binary_fcmp
 void
 jit_typeinfo::add_binary_op (jit_type *ty, int op, int llvm_op)
 {
   std::stringstream fname;
@@ -1541,19 +1572,19 @@ jit_typeinfo::create_identity (jit_type 
       fn.do_return (builder, fn.argument (builder, 0));
       return identities[id] = fn;
     }
 
   return identities[id];
 }
 
 llvm::Value *
-jit_typeinfo::do_insert_error_check (llvm::IRBuilderD& builder)
+jit_typeinfo::do_insert_error_check (llvm::IRBuilderD& abuilder)
 {
-  return builder.CreateLoad (lerror_state);
+  return abuilder.CreateLoad (lerror_state);
 }
 
 void
 jit_typeinfo::add_builtin (const std::string& name)
 {
   jit_type *btype = new_type (name, any, any->to_llvm ());
   builtins[name] = btype;
 
diff --git a/src/jit-typeinfo.h b/src/jit-typeinfo.h
--- a/src/jit-typeinfo.h
+++ b/src/jit-typeinfo.h
@@ -226,16 +226,22 @@ public:
 
   // Use an existing function, but change the argument types. The new argument
   // types must behave the same for the current calling convention.
   jit_function (const jit_function& fn, jit_type *aresult,
                 const std::vector<jit_type *>& aargs);
 
   jit_function (const jit_function& fn);
 
+  template <typename T>
+  void add_mapping (llvm::ExecutionEngine *engine, T fn)
+  {
+    do_add_mapping (engine, reinterpret_cast<void *> (fn));
+  }
+
   bool valid (void) const { return llvm_function; }
 
   std::string name (void) const;
 
   llvm::BasicBlock *new_block (const std::string& aname = "body",
                                llvm::BasicBlock *insert_before = 0);
 
   llvm::Value *call (llvm::IRBuilderD& builder,
@@ -284,16 +290,18 @@ public:
   jit_type *argument_type (size_t idx) const
   {
     assert (idx < args.size ());
     return args[idx];
   }
 
   const std::vector<jit_type *>& arguments (void) const { return args; }
 private:
+  void do_add_mapping (llvm::ExecutionEngine *engine, void *fn);
+
   llvm::Module *module;
   llvm::Function *llvm_function;
   jit_type *mresult;
   std::vector<jit_type *> args;
   jit_convention::type call_conv;
   bool mcan_error;
 };
 
@@ -528,17 +536,17 @@ private:
   {
     return do_cast (to).overload (from);
   }
 
   jit_type *new_type (const std::string& name, jit_type *parent,
                       llvm::Type *llvm_type);
 
 
-  void add_print (jit_type *ty);
+  void add_print (jit_type *ty, void *fptr);
 
   void add_binary_op (jit_type *ty, int op, int llvm_op);
 
   void add_binary_icmp (jit_type *ty, int op, int llvm_op);
 
   void add_binary_fcmp (jit_type *ty, int op, int llvm_op);
 
   jit_function create_function (jit_convention::type cc,
diff --git a/src/ls-mat5.cc b/src/ls-mat5.cc
--- a/src/ls-mat5.cc
+++ b/src/ls-mat5.cc
@@ -1931,17 +1931,17 @@ save_mat5_array_length (const double* va
     {
       int size = 8;
 
       if (save_as_floats)
         {
           bool too_large_for_float = false;
           for (octave_idx_type i = 0; i < nel; i++)
             {
-              double tmp = val [i];
+              double tmp = val[i];
 
               if (! (xisnan (tmp) || xisinf (tmp))
                   && fabs (tmp) > FLT_MAX)
                 {
                   too_large_for_float = true;
                   break;
                 }
             }
diff --git a/src/pt-eval.cc b/src/pt-eval.cc
--- a/src/pt-eval.cc
+++ b/src/pt-eval.cc
@@ -1029,16 +1029,21 @@ tree_evaluator::visit_unwind_protect_com
 }
 
 void
 tree_evaluator::visit_while_command (tree_while_command& cmd)
 {
   if (error_state)
     return;
 
+#if HAVE_LLVM
+  if (jiter.execute (cmd))
+    return;
+#endif
+
   unwind_protect frame;
 
   frame.protect_var (in_loop_command);
 
   in_loop_command = true;
 
   tree_expression *expr = cmd.condition ();
 
diff --git a/src/pt-idx.cc b/src/pt-idx.cc
--- a/src/pt-idx.cc
+++ b/src/pt-idx.cc
@@ -527,17 +527,17 @@ tree_index_expression::lvalue (void)
                 octave_value tidx = get_struct_index (p_arg_nm, p_dyn_field);
                 if (error_state)
                   break;
 
                 bool autoconv = (tmp.is_zero_by_zero ()
                                  && (tmp.is_matrix_type () || tmp.is_string ()
                                      || tmp.is_cell ()));
 
-                if (i > 0 && type [i-1] == '(')
+                if (i > 0 && type[i-1] == '(')
                   {
                     octave_value_list pidx = idx.back ();
 
                     // Use octave_map, not octave_scalar_map so that the
                     // dimensions are 0x0, not 1x1.
                     if (tmp.is_undefined ())
                       {
                         if (pidx.has_magic_colon ())
diff --git a/src/pt-jit.cc b/src/pt-jit.cc
--- a/src/pt-jit.cc
+++ b/src/pt-jit.cc
@@ -87,16 +87,20 @@ jit_convert::jit_convert (llvm::Module *
 
   construct_ssa ();
 
   // initialize the worklist to instructions derived from constants
   for (std::list<jit_value *>::iterator iter = constants.begin ();
        iter != constants.end (); ++iter)
     append_users (*iter);
 
+  // the entry block terminator may be a regular branch statement
+  if (entry_block->terminator ())
+    push_worklist (entry_block->terminator ());
+
   // FIXME: Describe algorithm here
   while (worklist.size ())
     {
       jit_instruction *next = worklist.front ();
       worklist.pop_front ();
       next->stash_in_worklist (false);
 
       if (next->infer ())
@@ -1470,16 +1474,33 @@ tree_jit::execute (tree_simple_for_comma
       info = new jit_info (*this, cmd);
       cmd.stash_info (info);
     }
 
   return info->execute ();
 }
 
 bool
+tree_jit::execute (tree_while_command& cmd)
+{
+  if (! initialize ())
+    return false;
+
+  jit_info *info = cmd.get_info ();
+  if (! info || ! info->match ())
+    {
+      delete info;
+      info = new jit_info (*this, cmd);
+      cmd.stash_info (info);
+    }
+
+  return info->execute ();
+}
+
+bool
 tree_jit::initialize (void)
 {
   if (engine)
     return true;
 
   if (! module)
     {
       llvm::InitializeNativeTarget ();
@@ -1703,9 +1724,17 @@ Test some simple cases that compile.
 %!    z(end-counter+1:end) = 0;
 %!  endif
 %!endfunction
 
 %!test
 %! test_set = gen_test (10000);
 %! assert (all (vectorized (test_set, 3) == loopy (test_set, 3)));
 
+%!test
+%! niter = 1001;
+%! i = 0;
+%! while (i < niter)
+%!   i = i + 1;
+%! endwhile
+%! assert (i == niter);
+
 */
diff --git a/src/pt-jit.h b/src/pt-jit.h
--- a/src/pt-jit.h
+++ b/src/pt-jit.h
@@ -401,16 +401,18 @@ tree_jit
 {
 public:
   tree_jit (void);
 
   ~tree_jit (void);
 
   bool execute (tree_simple_for_command& cmd);
 
+  bool execute (tree_while_command& cmd);
+
   llvm::ExecutionEngine *get_engine (void) const { return engine; }
 
   llvm::Module *get_module (void) const { return module; }
 
   void optimize (llvm::Function *fn);
  private:
   bool initialize (void);
 
diff --git a/src/pt-loop.cc b/src/pt-loop.cc
--- a/src/pt-loop.cc
+++ b/src/pt-loop.cc
@@ -45,16 +45,19 @@ along with Octave; see the file COPYING.
 // While.
 
 tree_while_command::~tree_while_command (void)
 {
   delete expr;
   delete list;
   delete lead_comm;
   delete trail_comm;
+#ifdef HAVE_LLVM
+  delete compiled;
+#endif
 }
 
 tree_command *
 tree_while_command::dup (symbol_table::scope_id scope,
                          symbol_table::context_id context) const
 {
   return new tree_while_command (expr ? expr->dup (scope, context) : 0,
                                  list ? list->dup (scope, context) : 0,
@@ -93,17 +96,19 @@ tree_do_until_command::accept (tree_walk
 tree_simple_for_command::~tree_simple_for_command (void)
 {
   delete lhs;
   delete expr;
   delete maxproc;
   delete list;
   delete lead_comm;
   delete trail_comm;
+#ifdef HAVE_LLVM
   delete compiled;
+#endif
 }
 
 tree_command *
 tree_simple_for_command::dup (symbol_table::scope_id scope,
                               symbol_table::context_id context) const
 {
   return new tree_simple_for_command
     (parallel, lhs ? lhs->dup (scope, context) : 0,
diff --git a/src/pt-loop.h b/src/pt-loop.h
--- a/src/pt-loop.h
+++ b/src/pt-loop.h
@@ -42,63 +42,93 @@ class jit_info;
 
 class
 tree_while_command : public tree_command
 {
 public:
 
   tree_while_command (int l = -1, int c = -1)
     : tree_command (l, c), expr (0), list (0), lead_comm (0),
-      trail_comm (0) { }
+      trail_comm (0)
+#ifdef HAVE_LLVM
+    , compiled (0)
+#endif
+  { }
 
   tree_while_command (tree_expression *e,
                       octave_comment_list *lc = 0,
                       octave_comment_list *tc = 0,
                       int l = -1, int c = -1)
     : tree_command (l, c), expr (e), list (0), lead_comm (lc),
-      trail_comm (tc) { }
+      trail_comm (tc)
+#ifdef HAVE_LLVM
+    , compiled (0)
+#endif
+  { }
 
   tree_while_command (tree_expression *e, tree_statement_list *lst,
                       octave_comment_list *lc = 0,
                       octave_comment_list *tc = 0,
                       int l = -1, int c = -1)
     : tree_command (l, c), expr (e), list (lst), lead_comm (lc),
-      trail_comm (tc) { }
+      trail_comm (tc)
+#ifdef HAVE_LLVM
+    , compiled (0)
+#endif
+  { }
 
   ~tree_while_command (void);
 
   tree_expression *condition (void) { return expr; }
 
   tree_statement_list *body (void) { return list; }
 
   octave_comment_list *leading_comment (void) { return lead_comm; }
 
   octave_comment_list *trailing_comment (void) { return trail_comm; }
 
   tree_command *dup (symbol_table::scope_id scope,
                      symbol_table::context_id context) const;
 
   void accept (tree_walker& tw);
 
+#ifdef HAVE_LLVM
+  // some functions use by tree_jit
+  jit_info *get_info (void) const
+  {
+    return compiled;
+  }
+
+  void stash_info (jit_info *jinfo)
+  {
+    compiled = jinfo;
+  }
+#endif
+
 protected:
 
   // Expression to test.
   tree_expression *expr;
 
   // List of commands to execute.
   tree_statement_list *list;
 
   // Comment preceding WHILE token.
   octave_comment_list *lead_comm;
 
   // Comment preceding ENDWHILE token.
   octave_comment_list *trail_comm;
 
 private:
 
+#ifdef HAVE_LLVM
+  // compiled version of the loop
+  jit_info *compiled;
+#endif
+
   // No copying!
 
   tree_while_command (const tree_while_command&);
 
   tree_while_command& operator = (const tree_while_command&);
 };
 
 // Do-Until.
@@ -143,28 +173,36 @@ private:
 
 class
 tree_simple_for_command : public tree_command
 {
 public:
 
   tree_simple_for_command (int l = -1, int c = -1)
     : tree_command (l, c), parallel (false), lhs (0), expr (0),
-      maxproc (0), list (0), lead_comm (0), trail_comm (0), compiled (0) { }
+      maxproc (0), list (0), lead_comm (0), trail_comm (0)
+#ifdef HAVE_LLVM
+    , compiled (0)
+#endif
+  { }
 
   tree_simple_for_command (bool parallel_arg, tree_expression *le,
                            tree_expression *re,
                            tree_expression *maxproc_arg,
                            tree_statement_list *lst,
                            octave_comment_list *lc = 0,
                            octave_comment_list *tc = 0,
                            int l = -1, int c = -1)
     : tree_command (l, c), parallel (parallel_arg), lhs (le),
       expr (re), maxproc (maxproc_arg), list (lst),
-      lead_comm (lc), trail_comm (tc), compiled (0) { }
+      lead_comm (lc), trail_comm (tc)
+#ifdef HAVE_LLVM
+    , compiled (0)
+#endif
+  { }
 
   ~tree_simple_for_command (void);
 
   bool in_parallel (void) { return parallel; }
 
   tree_expression *left_hand_side (void) { return lhs; }
 
   tree_expression *control_expr (void) { return expr; }
@@ -177,26 +215,28 @@ public:
 
   octave_comment_list *trailing_comment (void) { return trail_comm; }
 
   tree_command *dup (symbol_table::scope_id scope,
                      symbol_table::context_id context) const;
 
   void accept (tree_walker& tw);
 
+#ifdef HAVE_LLVM
   // some functions use by tree_jit
   jit_info *get_info (void) const
   {
     return compiled;
   }
 
   void stash_info (jit_info *jinfo)
   {
     compiled = jinfo;
   }
+#endif
 
 private:
   // TRUE means operate in parallel (subject to the value of the
   // maxproc expression).
   bool parallel;
 
   // Expression to modify.
   tree_expression *lhs;
diff --git a/src/utils.cc b/src/utils.cc
--- a/src/utils.cc
+++ b/src/utils.cc
@@ -465,17 +465,17 @@ fcn_file_in_path (const std::string& nam
     {
       if (octave_env::absolute_pathname (name))
         {
           file_stat fs (name);
 
           if (fs.exists ())
             retval = name;
         }
-      else if (len > 2 && name [len - 2] == '.' && name [len - 1] == 'm')
+      else if (len > 2 && name[len - 2] == '.' && name[len - 1] == 'm')
         retval = load_path::find_fcn_file (name.substr (0, len-2));
       else
         {
           std::string fname = name;
           size_t pos = name.find_first_of (Vfilemarker);
           if (pos != std::string::npos)
             fname = name.substr (0, pos);
 
@@ -522,18 +522,18 @@ oct_file_in_path (const std::string& nam
     {
       if (octave_env::absolute_pathname (name))
         {
           file_stat fs (name);
 
           if (fs.exists ())
             retval = name;
         }
-      else if (len > 4 && name [len - 4] == '.' && name [len - 3] == 'o'
-               && name [len - 2] == 'c' && name [len - 1] == 't')
+      else if (len > 4 && name[len - 4] == '.' && name[len - 3] == 'o'
+               && name[len - 2] == 'c' && name[len - 1] == 't')
         retval = load_path::find_oct_file (name.substr (0, len-4));
       else
         retval = load_path::find_oct_file (name);
     }
 
   return retval;
 }
 
@@ -551,18 +551,18 @@ mex_file_in_path (const std::string& nam
     {
       if (octave_env::absolute_pathname (name))
         {
           file_stat fs (name);
 
           if (fs.exists ())
             retval = name;
         }
-      else if (len > 4 && name [len - 4] == '.' && name [len - 3] == 'm'
-               && name [len - 2] == 'e' && name [len - 1] == 'x')
+      else if (len > 4 && name[len - 4] == '.' && name[len - 3] == 'm'
+               && name[len - 2] == 'e' && name[len - 1] == 'x')
         retval = load_path::find_mex_file (name.substr (0, len-4));
       else
         retval = load_path::find_mex_file (name);
     }
 
   return retval;
 }
 
diff --git a/src/variables.cc b/src/variables.cc
--- a/src/variables.cc
+++ b/src/variables.cc
@@ -1554,17 +1554,17 @@ do_who (int argc, const string_vector& a
           // It would be better to refecat symbol_info_list to not store the
           // symbol records and then use it in load-save.cc (do_load) to
           // implement this option there so that the variables are never
           // stored at all.
           if (i == argc - 1)
             error ("whos: -file argument must be followed by a file name");
           else
             {
-              std::string nm = argv [i + 1];
+              std::string nm = argv[i + 1];
 
               unwind_protect frame;
 
               // Set up temporary scope.
 
               symbol_table::scope_id tmp_scope = symbol_table::alloc_scope ();
               frame.add_fcn (symbol_table::erase_scope, tmp_scope);
 
diff --git a/src/zfstream.cc b/src/zfstream.cc
--- a/src/zfstream.cc
+++ b/src/zfstream.cc
@@ -398,30 +398,30 @@ gzfilebuf::enable_buffer ()
 {
   // If internal buffer required, allocate one
   if (own_buffer && !buffer)
   {
     // Check for buffered vs. "unbuffered"
     if (buffer_size > 0)
     {
       // Allocate internal buffer
-      buffer = new char_type[buffer_size];
+      buffer = new char_type [buffer_size];
       // Get area starts empty and will be expanded by underflow as need arises
       this->setg (buffer, buffer, buffer);
       // Setup entire internal buffer as put area.
       // The one-past-end pointer actually points to the last element of the buffer,
       // so that overflow(c) can safely add the extra character c to the sequence.
       // These pointers remain in place for the duration of the buffer
       this->setp (buffer, buffer + buffer_size - 1);
     }
     else
     {
       // Even in "unbuffered" case, (small?) get buffer is still required
       buffer_size = SMALLBUFSIZE;
-      buffer = new char_type[buffer_size];
+      buffer = new char_type [buffer_size];
       this->setg (buffer, buffer, buffer);
       // "Unbuffered" means no put buffer
       this->setp (0, 0);
     }
   }
   else
   {
     // If buffer already allocated, reset buffer pointers just to make sure no
