# HG changeset patch
# User Rik <rdrider0-list@yahoo.com>
# Date 1256315294 25200
#      Fri Oct 23 09:28:14 2009 -0700
# Node ID 09da0bd914121d86be5270a1f99e611793045b55
# Parent  95ad9c2a27e2e168b6b1853aefd1b259ed8199d3
Periodic grammar check of Octave documentation files to ensure common format

Use double spaces after a period at start of new sentence
Do not use @iftex blocks where @tex block is sufficient

diff --git a/doc/ChangeLog b/doc/ChangeLog
--- a/doc/ChangeLog
+++ b/doc/ChangeLog
@@ -1,8 +1,13 @@
+2009-10-23  Rik <octave@nomad.inbox5.com>
+
+	* various: Periodic grammar check of Octave documentation files to ensure
+	a standardized format.
+
 2009-10-20  Rik <octave@nomad.inbox5.com>
 
 	* interpreter/Makefile.in: Clean Makefile.in and remove a few
 	non-functional targets
 
 2009-10-13  Rik <octave@nomad.inbox5.com>
 
 	* various: Fix various incorrect usages of deffn and deftypefn macros
diff --git a/doc/interpreter/container.txi b/doc/interpreter/container.txi
--- a/doc/interpreter/container.txi
+++ b/doc/interpreter/container.txi
@@ -18,17 +18,17 @@
 
 @node Data Containers
 @chapter Data Containers
 @cindex containers
 
 Octave includes support for two different mechanisms to contain
 arbitrary data types in the same variable.  Structures, which are C-like,
 and are indexed with named fields, and cell arrays, where each element
-of the array can have a different data type and or shape. Multiple
+of the array can have a different data type and or shape.  Multiple
 input arguments and return values of functions are organized as
 another data container, the comma separated list.
 
 @menu
 * Data Structures::
 * Cell Arrays::
 * Comma Separated Lists::
 @end menu
@@ -154,17 +154,17 @@ a
             @}
           @}
         @}
 @end group
 @end example
 
 @noindent
 This prevents long and confusing output from large deeply nested
-structures. The number of levels to print for nested structures can be
+structures.  The number of levels to print for nested structures can be
 set with the function @code{struct_levels_to_print}:
 
 @DOCSTRING(struct_levels_to_print)
 
 Functions can return structures.  For example, the following function
 separates the real and complex parts of a matrix and stores them in two
 elements of the same structure variable.
 
@@ -199,17 +199,16 @@ f (rand (2) + rand (2) * I)
         @}
 @end group
 @end example
 
 Function return lists can include structure elements, and they may be
 indexed like any other variable.  For example,
 
 @example
-@group
 [ x.u, x.s(2:3,2:3), x.v ] = svd ([1, 2; 3, 4]);
 x
      @result{} x =
         @{
           u =
 
             -0.40455  -0.91451
             -0.91451   0.40455
@@ -221,29 +220,28 @@ x
              0.00000   0.00000   0.36597
 
           v =
 
             -0.57605   0.81742
             -0.81742  -0.57605
 
         @}
-@end group
 @end example
 
 It is also possible to cycle through all the elements of a structure in
 a loop, using a special form of the @code{for} statement
 (@pxref{Looping Over Structure Elements}).
 
 @node Structure Arrays
 @subsection Structure Arrays
 
 A structure array is a particular instance of a structure, where each of
 the fields of the structure is represented by a cell array.  Each of
-these cell arrays has the same dimensions. Conceptually, a structure
+these cell arrays has the same dimensions.  Conceptually, a structure
 array can also be seen as an array of structures with identical
 fields.  An example of the creation of a structure array is
 
 @example
 @group
 x(1).a = "string1";
 x(2).a = "string2";
 x(1).b = 1;
@@ -338,31 +336,33 @@ size(x)
 @end group
 @end example
 
 Elements can be deleted from a structure array in a similar manner to a
 numerical array, by assigning the elements to an empty matrix.  For
 example
 
 @example
+@group
 in = struct ("call1", @{x, Inf, "last"@}, 
              "call2", @{x, Inf, "first"@})
      @result{} in =
         @{
           1x3 struct array containing the fields:
 
             call1
             call2
         @}
 
 in(1) = [];
 in.call1
      @result{}
        ans = Inf
        ans = last
+@end group
 @end example
 
 @node Creating Structures
 @subsection Creating Structures
 
 As well as indexing a structure with ".", Octave can create a structure
 with the @code{struct} command.  @code{struct} takes pairs of arguments,
 where the first argument in the pair is the fieldname to include in the
@@ -380,51 +380,55 @@ struct ("field1", 1, "field2", 2)
 @end group
 @end example
 
 If the values passed to @code{struct} are a mix of scalar and cell
 arrays, then the scalar arguments are expanded to create a 
 structure array with a consistent dimension.  For example
 
 @example
+@group
 s = struct ("field1", @{1, "one"@}, "field2", @{2, "two"@},
         "field3", 3);
 s.field1
      @result{} 
         ans =  1
         ans = one
 
 s.field2
      @result{}
         ans =  2
         ans = two
 
 s.field3
      @result{}
         ans =  3
         ans =  3
+@end group
 @end example
 
 If you want to create a struct which contains a cell array as an
 individual field, you have to put it into another cell array like in
 the following example:
 
 @example
+@group
 struct ("field1", @{@{1, "one"@}@}, "field2", 2)
      @result{} ans =
         @{
           field1 =
         
         @{
           [1,1] =  1
           [1,2] = one
         @}
         
           field2 =  2
         @}
+@end group
  @end example       
 
 @DOCSTRING(struct)
 
 The function @code{isstruct} can be used to test if an object is a
 structure or a structure array.
 
 @DOCSTRING(isstruct)
@@ -549,17 +553,17 @@ Details on indexing cell arrays are expl
 In general nested cell arrays are displayed hierarchically as in the
 previous example.  In some circumstances it makes sense to reference
 them by their index, and this can be performed by the @code{celldisp}
 function.
 
 @DOCSTRING(celldisp)
 
 To test if an object is a cell array, use the @code{iscell}
-function. For example:
+function.  For example:
 
 @example
 @group
 iscell(c)
      @result{} ans = 1
 
 iscell(3)
      @result{} ans = 0
@@ -631,17 +635,17 @@ is possible to convert numerical arrays 
 @DOCSTRING(mat2cell)
 
 @node Indexing Cell Arrays
 @subsection Indexing Cell Arrays
 
 As shown in @pxref{Basic Usage of Cell Arrays} elements can be
 extracted from cell arrays using the @samp{@{} and @samp{@}}
 operators.  If you want to extract or access subarrays which are still 
-cell arrays, you need to use the @samp{(} and @samp{)} operators. The
+cell arrays, you need to use the @samp{(} and @samp{)} operators.  The
 following example illustrates the difference:
 
 @example
 @group
 c = @{"1", "2", "3"; "a", "b", "c"; "4", "5", "6"@};
 c@{2,3@}
      @result{} ans = c
 
@@ -706,17 +710,17 @@ c([1, 2], :) = c([2, 1], :)
           [1,3] =  6
           [2,3] =  3
         @}
 @end group
 @end example
 
 Accessing multiple elements of a cell array with the @samp{@{} and
 @samp{@}} operators will result in a comma-separated list of all the
-requested elements (@pxref{Comma Separated Lists}). Using the
+requested elements (@pxref{Comma Separated Lists}).  Using the
 @samp{@{} and @samp{@}} operators the first two rows in the above
 example can be swapped back like this:
 
 @example
 @group
 [c@{[1,2], :@}] = deal(c@{[2, 1], :@})
      @result{} = 
         @{
@@ -874,21 +878,23 @@ x = [1 0 1 0 0 1 1; 0 0 0 0 0 0 7];
 Here, @samp{@var{x}, 2, "last"} is a comma separated list constituting
 the input arguments of @code{find}.  @code{find} returns a comma
 separated list of output arguments which is assigned element by
 element to the comma separated list @samp{@var{i}, @var{j}}.
 
 Another example of where comma separated lists are used is in the
 creation of a new array with @code{[]} (@pxref{Matrices}) or the
 creation of a cell array with @code{@{@}} (@pxref{Basic Usage of Cell
-Arrays}). In the expressions 
+Arrays}).  In the expressions 
 
 @example
+@group
 a = [1, 2, 3, 4];
 c = @{4, 5, 6, 7@};
+@end group
 @end example
 
 @noindent
 both @samp{1, 2, 3, 4} and @samp{4, 5, 6, 7} are comma separated lists.
 
 Comma separated lists cannot be directly manipulated by the
 user.  However, both structure arrays and cell arrays can be converted
 into comma separated lists, and thus used in place of explicitly
@@ -900,18 +906,18 @@ as will be shown in the following subsec
 * Comma Separated Lists Generated from Structure Arrays::
 @end menu
 
 @node Comma Separated Lists Generated from Cell Arrays
 @subsection Comma Separated Lists Generated from Cell Arrays
 
 As has been mentioned above (@pxref{Indexing Cell Arrays}), elements
 of a cell array can be extracted into a comma separated list with the
-@code{@{} and @code{@}} operators. By surrounding this list with
-@code{[} and @code{]}, it can be concatenated into an array. For example:
+@code{@{} and @code{@}} operators.  By surrounding this list with
+@code{[} and @code{]}, it can be concatenated into an array.  For example:
 
 @example
 @group
 a = @{1, [2, 3], 4, 5, 6@};
 b = [a@{1:4@}]
      @result{} b =
          1   2   3   4
 @end group
diff --git a/doc/interpreter/expr.txi b/doc/interpreter/expr.txi
--- a/doc/interpreter/expr.txi
+++ b/doc/interpreter/expr.txi
@@ -616,21 +616,23 @@ True if @var{x} is greater than @var{y}.
 @opindex ~=
 True if @var{x} is not equal to @var{y}.
 @end table
 
 For complex numbers, the following ordering is defined:
 @var{z1} < @var{z2}
 iff
 @example
+@group
   abs(@var{z1}) < abs(@var{z2}) 
   || (abs(@var{z1}) == abs(@var{z2}) && arg(@var{z1}) < arg(@var{z2}))
+@end group
 @end example
 This is consistent with the ordering used by @dfn{max}, @dfn{min} and @dfn{sort},
-but is not consistent with Matlab, which only compares the real parts.
+but is not consistent with @sc{matlab}, which only compares the real parts.
 
 String comparisons may also be performed with the @code{strcmp}
 function, not with the comparison operators listed above.
 @xref{Strings}.
 
 @DOCSTRING(isequal)
 
 @DOCSTRING(isequalwithequalnans)
diff --git a/doc/interpreter/oop.txi b/doc/interpreter/oop.txi
--- a/doc/interpreter/oop.txi
+++ b/doc/interpreter/oop.txi
@@ -320,47 +320,51 @@ Finally, objects can equally be used lik
 method
 
 @DOCSTRING(colon)
 
 @node Indexed Assignment Optimization
 @subsection Indexed Assignment Optimization
 
 Octave's ubiquitous lazily-copied pass-by-value semantics implies 
-a problem for performance of user-defined subsasgn methods. Imagine
+a problem for performance of user-defined subsasgn methods.  Imagine
 a call to subsasgn:
 
 @example
+@group
   ss = substruct ("()",@{1@});
   x = subsasgn (x, ss, 1);
+@end group
 @end example
 
 and the corresponding method looking like this:
 
 @example
+@group
   function x = subsasgn (x, ss, val)
     @dots{}
     x.myfield(ss.subs@{1@}) = val;
   endfunction
+@end group
 @end example
 
 The problem is that on entry to the subsasgn method, @code{x} is still
 referenced from the caller's scope, which means that the method will 
 first need to unshare (copy) @code{x} and @code{x.myfield} before performing
-the assignment. Upon completing the call, unless an error occurs,
+the assignment.  Upon completing the call, unless an error occurs,
 the result is immediately assigned to @code{x} in the caller's scope,
-so that the previous value of @code{x.myfield} is forgotten. Hence, the
+so that the previous value of @code{x.myfield} is forgotten.  Hence, the
 Octave language implies a copy of N elements (N being the size of
 @code{x.myfield}), where modifying just a single element would actually
-suffice, i.e. degrades a constant-time operation to linear-time one.
+suffice, i.e., degrades a constant-time operation to linear-time one.
 This may be a real problem for user classes that intrinsically store large
 arrays.
 
 To partially solve the problem, Octave uses a special optimization for
-user-defined subsasgn methods coded as m-files. When the method
+user-defined subsasgn methods coded as m-files.  When the method
 gets called as a result of the built-in assignment syntax (not direct subsasgn
 call as shown above), i.e.
 
 @example
   x(1) = 1;
 @end example
 
 @b{AND} if the subsasgn method is declared with identical input and output argument,
@@ -368,31 +372,33 @@ like in the example above, then Octave w
 the caller's scope; therefore, any changes made to @code{x} during the method
 execution will directly affect the caller's copy as well.
 This allows, for instance, defining a polynomial class where modifying a single
 element takes constant time.
 
 It is important to understand the implications that this optimization brings.
 Since no extra copy of @code{x} in the caller's scope will exist, it is @i{solely}
 the callee's responsibility to not leave @code{x} in an invalid state if an error
-occurs throughout the execution. Also, if the method partially changes @code{x}
+occurs throughout the execution.  Also, if the method partially changes @code{x}
 and then errors out, the changes @i{will} affect @code{x} in the caller's scope.
 Deleting or completely replacing @code{x} inside subsasgn will not do anything,
 however, only indexed assignments matter.
 
 Since this optimization may change the way code works (especially if badly written),
 a built-in variable @code{optimize_subsasgn_calls} is provided to control it.
 It is on by default.
 Another option to avoid the effect is to declare subsasgn methods with different
 output and input arguments, like this:
 
 @example
+@group
   function y = subsasgn (x, ss, val)
     @dots{}
   endfunction
+@end group
 @end example
 
 @node Overloading Objects
 @section Overloading Objects
 
 @menu
 * Function Overloading::
 * Operator Overloading::
@@ -571,24 +577,26 @@ function in the class constructor.  As i
 class, the octave programmer will create a struct that contains the
 data fields required by the class, and then call the class function to
 indicate that an object is to be created from the struct.  Creating a
 child of an existing object is done by creating an object of the
 parent class and providing that object as the third argument of the
 class function.
 
 This is easily demonstrated by example.  Suppose the programmer needs
-an FIR filter, i.e. a filter with a numerator polynomial but a unity
+an FIR filter, i.e., a filter with a numerator polynomial but a unity
 denominator polynomial.  In traditional octave programming, this would
 be performed as follows.
 
 @example
+@group
 octave:1> x = [some data vector];
 octave:2> n = [some coefficient vector];
 octave:3> y = filter (n, 1, x);
+@end group
 @end example
 
 The equivalent class could be implemented in a class directory
 @@FIRfilter that is on the octave path.  The constructor is a file
 FIRfilter.m in the class directory.
 
 @classfile{@@FIRfilter,FIRfilter.m}
 
@@ -620,75 +628,83 @@ As before, we need a @code{display} meth
 Note that we have used the polynomial field of the struct to display
 the filter coefficients.
 
 Once we have the class constructor and display method, we may create
 an object by calling the class constructor.  We may also check the
 class type and examine the underlying structure.
 
 @example
+@group
 octave:1> f=FIRfilter(polynomial([1 1 1]/3))
 f.polynomial = 0.333333 + 0.333333 * X + 0.333333 * X ^ 2
 octave:2> class(f)
 ans = FIRfilter
 octave:3> isa(f,"FIRfilter")
 ans =  1
 octave:4> isa(f,"polynomial")
 ans =  1
 octave:5> struct(f)
 ans = 
 @{
 polynomial = 0.333333 + 0.333333 * X + 0.333333 * X ^ 2
 @}
+@end group
 @end example
 
 We only need to define a method to actually process data with our
 filter and our class is usable.  It is also useful to provide a means
 of changing the data stored in the class.  Since the fields in the
 underlying struct are private by default, we could provide a mechanism
 to access the fields.  The @code{subsref} method may be used for both.
 
 @classfile{@@FIRfilter,subsref.m}
 
 The "()" case allows us to filter data using the polynomial provided
 to the constructor.
 
 @example
+@group
 octave:2> f=FIRfilter(polynomial([1 1 1]/3));
 octave:3> x=ones(5,1);
 octave:4> y=f(x)
 y =
 
    0.33333
    0.66667
    1.00000
    1.00000
    1.00000
+@end group
 @end example
 
 The "." case allows us to view the contents of the polynomial field.
 
 @example
+@group
 octave:1> f=FIRfilter(polynomial([1 1 1]/3));
 octave:2> f.polynomial
 ans = 0.333333 + 0.333333 * X + 0.333333 * X ^ 2
+@end group
 @end example
 
 In order to change the contents of the object, we need to define a
 @code{subsasgn} method.  For example, we may make the polynomial field
 publicly writeable.
 
 @classfile{@@FIRfilter,subsasgn.m}
 
 So that
 
 @example
+@group
 octave:6> f=FIRfilter();
 octave:7> f.polynomial = polynomial([1 2 3]);
 f.polynomial = 1 + 2 * X + 3 * X ^ 2
+@end group
 @end example
 
 
 Defining the FIRfilter class as a child of the polynomial class
 implies that and FIRfilter object may be used any place that a
 polynomial may be used.  This is not a normal use of a filter, so that
 aggregation may be a more sensible design approach.  In this case, the
 polynomial is simply a field in the class structure.  A class
diff --git a/doc/interpreter/plot.txi b/doc/interpreter/plot.txi
--- a/doc/interpreter/plot.txi
+++ b/doc/interpreter/plot.txi
@@ -28,19 +28,19 @@
 * Graphics Data Structures::    
 * Advanced Plotting::           
 @end menu
 
 @node Introduction to Plotting
 @section Introduction to Plotting
 
 Earlier versions of Octave provided plotting through the use of
-gnuplot. This capability is still available.  But, a newer plotting
+gnuplot.  This capability is still available.  But, a newer plotting
 capability is provided by access to OpenGL.  Which plotting system
-is used is controlled by the @code{backend} function. (See @ref{Graphics Backends}.)
+is used is controlled by the @code{backend} function.  (See @ref{Graphics Backends}.)
 
 The function call @code{backend("fltk")} selects the fltk/OpenGL system, and
 @code{backend("gnuplot")} selects the gnuplot system.
 The two systems may be used selectively through the use of the @code{backend}
 property of the graphics handle for each figure.  This is
 explained in @ref{Graphics Data Structures}.
 
 @node High-Level Plotting
@@ -553,17 +553,17 @@ figure window, call the @code{close} fun
 
 All text objects, including titles, labels, legends, and text, include
 the property 'interpreter', this property determines the manner in which
 special control sequences in the text are rendered.  If the interpreter
 is set to 'none', then no rendering occurs.  At this point the 'latex'
 option is not implemented and so the 'latex' interpreter also does not
 interpret the text.
 
-The 'tex' option implements a subset of @sc{TeX} functionality in the
+The 'tex' option implements a subset of @TeX{} functionality in the
 rendering of the text.  This allows the insertion of special characters
 such as Greek or mathematical symbols within the text.  The special
 characters are also inserted with a code starting with the back-slash
 (\) character, as in the table @ref{tab:extended}.
 
 In addition, the formatting of the text can be changed within the string
 with the codes
 
@@ -758,17 +758,17 @@ width 0.6pt \tabskip=0pt\cr
 @item @tab  \prod       @tab \surd        @tab  \cdot    @tab
 @item @tab  \neg        @tab  \wedge      @tab \vee      @tab
 @item @tab  \Leftrightarrow @tab \Leftarrow @tab \Uparrow @tab
 @item @tab  \Rightarrow @tab \Downarrow   @tab \diamond  @tab
 @item @tab  \copyright  @tab  \lfloor     @tab  \lceil   @tab
 @item @tab  \rfloor     @tab  \rceil      @tab  \int     @tab
 @end multitable
 @end ifnottex
-@caption{Available special characters in @sc{TeX} mode}
+@caption{Available special characters in @TeX{} mode}
 @end float
 
 A complete example showing the capabilities of the extended text is
 
 @example
 @group
 x = 0:0.01:3;
 plot(x,erf(x));
@@ -782,17 +782,17 @@ text(0.65, 0.6175, strcat('\leftarrow x 
 @end example
 
 @ifnotinfo
 @noindent
 The result of which can be seen in @ref{fig:extendedtext}
 
 @float Figure,fig:extendedtext
 @center @image{extended,4in}
-@caption{Example of inclusion of text with the @sc{TeX} interpreter}
+@caption{Example of inclusion of text with the @TeX{} interpreter}
 @end float
 @end ifnotinfo
 
 @node Printing Plots
 @subsection Printing Plots
 @cindex printing plots
 
 The @code{print} command allows you to save plots in a variety of
@@ -849,39 +849,39 @@ at the Octave prompt should display a th
 @subsection Introduction to Graphics Structures
 @cindex introduction to graphics structures
 @anchor{doc-graphics structures}
 
 The graphics functions use pointers, which are of class graphics_handle,
 in order to address the data structures which control
 graphical displays.
 A graphics handle may point any one of a number of different object types.
-The objects are the graphics data structures. The types of objects
+The objects are the graphics data structures.  The types of objects
 are: @code{figure}, @code{axes},
 @code{line}, @code{text}, @code{patch},
 @code{surface}, @code{text} and @code{image}.
 
 Each of these objects has a function by the
 same name. and, each of these functions returns a graphics handle pointing
-to an object of corresponding type. In addition there are several functions
+to an object of corresponding type.  In addition there are several functions
 which operate on properties of the graphics objects and which return handles: the functions @code{ plot}
 and @code{plot3}
 return a handle pointing to an object of type line, the function @code{subplot}
 returns a handle pointing to an object of type axes, the function @code{fill} returns a
 handle pointing to an object of type patch, the functions @code{area}, @code{bar},
 @code{barh}, @code{contour}, @code{contourf}, @code{contour3}, @code{surf}, @code{mesh},
 @code{surfc}, @code{meshc},
 @code{errorbar}, @code{quiver}, @code{quiver3}, @code{scatter}, @code{scatter3},
 @code{stair}, @code{stem}, @code{stem3} each return a handle as documented
 in @ref{doc-datasources,, Data Sources}.
 
 
 The graphics objects are arranged in a hierarchy:
 
-1. The root is at 0.  i.e. @code{get(0)} returns the properties of the root
+1. The root is at 0.  i.e., @code{get(0)} returns the properties of the root
    object.
 
 2. Below the root are @code{figure} objects.
 
 3. Below the @code{figure} objects are @code{axes}.
 
 4. Below the @code{axes} objects are
 @code{line}, @code{text}, @code{patch},
@@ -889,32 +889,32 @@ 4. Below the @code{axes} objects are
 
 Graphics handles may be distinguished from function handles (@ref{Function Handles})
 by means of the function @code{ishandle()}.  @code{ishandle} returns true if its
 argument is a handle of a graphics object.  In addition, the figure object
 may be tested using @code{isfigure()}.  @code{isfigure} returns true only if its
 argument is a handle of a figure.
 ishghandle() is synonymous with ishandle().  The @code{whos} function can be used
 to show the object type of each currently defined graphics handle.  (Note: this is
-not true today, but it is, I hope, considered an error in whos. It may be better
+not true today, but it is, I hope, considered an error in whos.  It may be better
 to have whos just show graphics_handle as the class, and provide a new function
 which, given a graphics handle, returns its object type.  This could generalize
 the ishandle() functions and, in fact, replace them.)
 
 The @code{get} and @code{set} commands are
-used to obtain and set the values of properties of graphics objects. In addition,
+used to obtain and set the values of properties of graphics objects.  In addition,
 the @code{get} command may be used to obtain property names.
 
 For example, the property "type" of the graphics object pointed to by the graphics
 handle h may be displayed by:
 
 @code{get(h, "type")}
 
 The properties and their current values are returned by @code{get(h)}
-where h is a handle of a graphics object. If only the names of the
+where h is a handle of a graphics object.  If only the names of the
 allowed properties are wanted they may be displayed by:
 @code{get(h, "");}
 
 Thus, for example,
 @c @example
 @smallformat
 @group
 @verbatim
@@ -997,20 +997,20 @@ The root figure has index 0.  Its proper
 @code{get(0,"")}.
 The uses of @code{get()} and @code{set()} are further explained in
 @ref{doc-get,,get}, @ref{doc-set,,set}.
 
 @node Graphics Objects
 @subsection Graphics Objects
 @cindex graphics objects
 
-The hierarchy of graphics objects was explained above. (See 
+The hierarchy of graphics objects was explained above.  (See 
 @ref{Introduction to Graphics Structures}.  Here the
 specific objects are described, and the properties contained in
-these objects are discussed. Keep in mind that
+these objects are discussed.  Keep in mind that
 graphics objects are always referenced by @dfn{handle}.
 
 @table @asis
 @c @group
 @item root figure
 @cindex root figure graphics object
 @cindex graphics object, root figure
 the top level of the hierarchy and the parent of all figure objects.
@@ -1440,17 +1440,17 @@ Either @code{"top"} or @code{"bottom"}.
 @item xcolor
 @item xdir
 Either @code{"forward"} or @code{"reverse"}.
 @item xgrid
 Either @code{"on"} or @code{"off"} to toggle display of grid lines.
 @item xlabel
 Indices to text objects for the axes labels.
 @item xlim
-Two-element vector defining the limits for the x axis.
+Two-element vector defining the limits for the x-axis.
 Setting this property also forces the corresponding mode
 property to be set to @code{"manual"}.
 @item xlimmode
 Either @code{"manual"} or @code{"auto"}.
 @item xminorgrid 
 Either @code{"on"} or @code{"off"} to toggle display of minor grid lines.
 @item xminortick
 @item xscale
@@ -1500,17 +1500,17 @@ Either @code{"manual"} or @code{"auto"}.
 @item zcolor
 @item zdir
 Either @code{"forward"} or @code{"reverse"}.
 @item zgrid
 Either @code{"on"} or @code{"off"} to toggle display of grid lines.
 @item zlabel
 Indices to text objects for the axes labels.
 @item zlim
-Two-element vector defining the limits for z axis.
+Two-element vector defining the limits for z-axis.
 Setting this property also forces the corresponding mode
 property to be set to @code{"manual"}.
 @item zlimmode
 Either @code{"manual"} or @code{"auto"}.
 @item zminorgrid 
 Either @code{"on"} or @code{"off"} to toggle display of minor grid lines.
 @item zminortick
 @item zscale
diff --git a/doc/interpreter/tips.txi b/doc/interpreter/tips.txi
--- a/doc/interpreter/tips.txi
+++ b/doc/interpreter/tips.txi
@@ -80,96 +80,104 @@ copyright to anyone else, then place you
 @section Tips for Making Code Run Faster.
 @cindex execution speed
 @cindex speedups
 
 Here are some ways of improving the execution speed of Octave programs.
 
 @itemize @bullet
 @item
-Vectorize loops. For instance, rather than
+Vectorize loops.  For instance, rather than
 @example
+@group
 for i = 1:n-1
   a(i) = b(i+1) - b(i);
 endfor
+@end group
 @end example
 
 write
 
 @example
 a = b(2:n) - b(1:n-1);
 @end example
 
-This is especially important for loops with "cheap" bodies. Often it suffices to vectorize
-just the innermost loop to get acceptable performance. A general rule of thumb is that the
+This is especially important for loops with "cheap" bodies.  Often it suffices to vectorize
+just the innermost loop to get acceptable performance.  A general rule of thumb is that the
 "order" of the vectorized body should be greater or equal to the "order" of the enclosing loop.
 
 @item
-Use built-in and library functions if possible. Built-in and compiled functions are very fast.
+Use built-in and library functions if possible.  Built-in and compiled functions are very fast.
 Even with a m-file library function, chances are good that it is already optimized, or will be
 optimized more in a future release.
 
 @item
-Avoid computing costly intermediate results multiple times. Octave currently
+Avoid computing costly intermediate results multiple times.  Octave currently
 does not eliminate common subexpressions.
 Also, certain internal computation results are cached for variables.
 For instance, if a matrix variable is used multiple times as an index,
 checking the indices (and internal conversion to integers) is only done once.
 
 @item
-Be aware of lazy copies (copy-on-write). When a copy of an object
-is created, the data is not immediately copied, but rather shared. The actual
-copying is postponed until the copied data needs to be modified. For example:
+Be aware of lazy copies (copy-on-write).  When a copy of an object
+is created, the data is not immediately copied, but rather shared.  The actual
+copying is postponed until the copied data needs to be modified.  For example:
 
 @example
+@group
 a = zeros (1000); # create a 1000x1000 matrix
 b = a; # no copying done here
 b(1) = 1; # copying done here
+@end group
 @end example
 
 Lazy copying applies to whole Octave objects such as matrices, cells, struct,
 and also individual cell or struct elements (not array elements).
 
 Additionally, index expressions also use lazy copying when Octave can determine
-that the indexed portion is contiguous in memory. For example:
+that the indexed portion is contiguous in memory.  For example:
 
 @example
+@group
 a = zeros (1000); # create a 1000x1000 matrix
 b = a(:,10:100); # no copying done here
 b = a(10:100,:); # copying done here
+@end group
 @end example
 
 This applies to arrays (matrices), cell arrays, and structs indexed using ().
 Index expressions generating cs-lists can also benefit of shallow copying
-in some cases. In particular, when @var{a} is a struct array, expressions like
+in some cases.  In particular, when @var{a} is a struct array, expressions like
 @code{@{a.x@}, @{a(:,2).x@}} will use lazy copying, so that data can be shared
 between a struct array and a cell array.
 
 Most indexing expressions do not live longer than their `parent' objects.
 In rare cases, however, a lazily copied slice outlasts its parent, in which
 case it becomes orphaned, still occupying unnecessarily more memory than needed.
 To provide a remedy working in most real cases,
 Octave checks for orphaned lazy slices at certain situations, when a value
 is stored into a "permanent" location, such as a named variable or cell or
-struct element, and possibly economizes them. For example
+struct element, and possibly economizes them.  For example
 
 @example
+@group
 a = zeros (1000); # create a 1000x1000 matrix
 b = a(:,10:100); # lazy slice
 a = []; # the original a array is still allocated
 c@{1@} = b; # b is reallocated at this point
+@end group
 @end example
 
 @item
-Avoid deep recursion. Function calls to m-file functions carry a relatively significant overhead,
-so rewriting a recursion as a loop often helps. Also, note that the maximum level of recursion is
+Avoid deep recursion.  Function calls to m-file functions carry a relatively significant overhead,
+so rewriting a recursion as a loop often helps.  Also, note that the maximum level of recursion is
 limited.
 
 @item
-Avoid resizing matrices unnecessarily. When building a single result
+Avoid resizing matrices unnecessarily.  When building a single result
 matrix from a series of calculations, set the size of the result matrix
 first, then insert values into it.  Write
 
 @example
 @group
 result = zeros (big_n, big_m)
 for i = over:and_over
   r1 = @dots{}
@@ -187,44 +195,48 @@ instead of
 result = [];
 for i = ever:and_ever
   result = [ result, new_value() ];
 endfor
 @end group
 @end example
 
 Sometimes the number of items can't be computed in advance, and stack-like operations
-are needed. When elements are being repeatedly inserted at/removed from the end of an
+are needed.  When elements are being repeatedly inserted at/removed from the end of an
 array, Octave detects it as stack usage and attempts to use a smarter memory management
-strategy preallocating the array in bigger chunks. Likewise works for cell and
+strategy preallocating the array in bigger chunks.  Likewise works for cell and
 struct arrays.
 
 @example
+@group
 a = [];
 while (condition)
   @dots{}
   a(end+1) = value; # "push" operation
   @dots{}
   a(end) = []; # "pop" operation
   @dots{}
 endwhile
+@end group
 @end example
 
 @item
-Use @code{cellfun} intelligently. The @code{cellfun} function is a useful tool
-for avoiding loops. @xref{Processing Data in Cell Arrays}.
+Use @code{cellfun} intelligently.  The @code{cellfun} function is a useful tool
+for avoiding loops.  @xref{Processing Data in Cell Arrays}.
 @code{cellfun} is often use with anonymous function handles; however, calling
 an anonymous function involves an overhead quite comparable to the overhead
-of an m-file function. Passing a handle to a built-in function is faster,
-because the interpreter is not involved in the internal loop. For example:
+of an m-file function.  Passing a handle to a built-in function is faster,
+because the interpreter is not involved in the internal loop.  For example:
 
 @example
+@group
 a = @{@dots{}@}
 v = cellfun (@@(x) det(x), a); # compute determinants
 v = cellfun (@@det, a); # faster
+@end group
 @end example
 
 @item
 Avoid calling @code{eval} or @code{feval} excessively, because
 they require Octave to parse input or look up the name of a function in
 the symbol table.
 
 If you are using @code{eval} as an exception handling mechanism and not
diff --git a/scripts/io/strread.m b/scripts/io/strread.m
--- a/scripts/io/strread.m
+++ b/scripts/io/strread.m
@@ -17,18 +17,18 @@
 ## -*- texinfo -*-
 ## @deftypefn {Function File}  {[@var{a}, @dots{}] =} strread (@var{str})
 ## @deftypefnx {Function File}  {[@var{a}, @dots{}] =} strread (@var{str}, @var{format})
 ## @deftypefnx {Function File} {[@var{a}, @dots{}] =} strread (@var{str}, @var{format}, @
 ## @var{prop1}, @var{value1}, @dots{})
 ## Read data from a string.
 ##
 ## The string @var{str} is split into words that are repeatedly matched to the
-## specifiers in @var{format}. The first word is matched to the first specifier,
-## the second to the second specifier and so forth. If there are more words than
+## specifiers in @var{format}.  The first word is matched to the first specifier,
+## the second to the second specifier and so forth.  If there are more words than
 ## specifiers, the process is repeated until all words have been processed.
 ##
 ## The string @var{format} describes how the words in @var{str} should be parsed.
 ## It may contain any combination of the following specifiers:
 ## @table @code
 ## @item %s
 ## The word is parsed as a string.
 ## @item %d
diff --git a/scripts/io/textread.m b/scripts/io/textread.m
--- a/scripts/io/textread.m
+++ b/scripts/io/textread.m
@@ -16,19 +16,19 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File}  {[@var{a}, @dots{}] =} textread (@var{filename})
 ## @deftypefnx {Function File}  {[@var{a}, @dots{}] =} textread (@var{filename}, @var{format})
 ## @deftypefnx {Function File} {[@var{a}, @dots{}] =} textread (@var{filename}, @var{format}, @
 ## @var{prop1}, @var{value1}, @dots{})
 ## Read data from a text file.
 ##
-## The file @var{filename} is read and parsed according to @var{format}. The
+## The file @var{filename} is read and parsed according to @var{format}.  The
 ## function behaves like @code{strread} except it works by parsing a file instead
-## of a string. See the documentation of @code{strread} for details.
+## of a string.  See the documentation of @code{strread} for details.
 ## In addition to the options supported by @code{strread}, this function
 ## supports one more:
 ## @itemize
 ## @item "headerlines":
 ## @end itemize
 ## The first @var{value} number of lines of @var{str} are skipped.
 ## @seealso{strread, load, dlmread, fscanf}
 ## @end deftypefn
diff --git a/scripts/miscellaneous/mkoctfile.m b/scripts/miscellaneous/mkoctfile.m
--- a/scripts/miscellaneous/mkoctfile.m
+++ b/scripts/miscellaneous/mkoctfile.m
@@ -59,17 +59,16 @@
 ## (or .mex if --mex is specified) unless linking
 ## a stand-alone executable.
 ##
 ## @item -p VAR
 ## @itemx --print VAR
 ## Print the configuration variable VAR.  Recognized variables are: 
 ##
 ## @example             
-## @group
 ##    ALL_CFLAGS                FFTW_LIBS     
 ##    ALL_CXXFLAGS              FLIBS       
 ##    ALL_FFLAGS                FPICFLAG      
 ##    ALL_LDFLAGS               INCFLAGS      
 ##    BLAS_LIBS                 LDFLAGS             
 ##    CC                        LD_CXX              
 ##    CFLAGS                    LD_STATIC_FLAG
 ##    CPICFLAG                  LFLAGS              
@@ -80,17 +79,16 @@
 ##    DEPEND_EXTRA_SED_PATTERN  LIBS        
 ##    DEPEND_FLAGS              OCTAVE_LIBS   
 ##    DL_LD                     RDYNAMIC_FLAG 
 ##    DL_LDFLAGS                RLD_FLAG      
 ##    F2C                       SED         
 ##    F2CFLAGS                  XTRA_CFLAGS   
 ##    F77                       XTRA_CXXFLAGS 
 ##    FFLAGS
-## @end group
 ## @end example
 ##
 ## @item --link-stand-alone
 ## Link a stand-alone executable file.
 ##
 ## @item --mex
 ## Assume we are creating a MEX file.  Set the default output extension 
 ## to ".mex".
diff --git a/scripts/optimization/fminunc.m b/scripts/optimization/fminunc.m
--- a/scripts/optimization/fminunc.m
+++ b/scripts/optimization/fminunc.m
@@ -21,39 +21,39 @@
 ## -*- texinfo -*-
 ## @deftypefn{Function File} {} fminunc (@var{fcn}, @var{x0}, @var{options})
 ## @deftypefnx{Function File} {[@var{x}, @var{fvec}, @var{info}, @var{output}, @var{grad}, @var{hess}]} = fminunc (@var{fcn}, @dots{})
 ## Solve a unconstrained optimization problem defined by the function @var{fcn}.
 ## @var{fcn} should accepts a vector (array) defining the unknown variables,
 ## and return the objective function value, optionally with gradient.
 ## In other words, this function attempts to determine a vector @var{x} such 
 ## that @code{@var{fcn} (@var{x})} is a local minimum.
-## @var{x0} determines a starting guess. The shape of @var{x0} is preserved
+## @var{x0} determines a starting guess.  The shape of @var{x0} is preserved
 ## in all calls to @var{fcn}, but otherwise it is treated as a column vector.
 ## @var{options} is a structure specifying additional options.
 ## Currently, @code{fminunc} recognizes these options:
 ## @code{"FunValCheck"}, @code{"OutputFcn"}, @code{"TolX"},
 ## @code{"TolFun"}, @code{"MaxIter"}, @code{"MaxFunEvals"}, 
 ## @code{"GradObj"}, @code{"FinDiffType"}.
 ##
 ## If @code{"GradObj"} is @code{"on"}, it specifies that @var{fcn},
 ## called with 2 output arguments, also returns the Jacobian matrix
 ## of right-hand sides at the requested point.  @code{"TolX"} specifies
 ## the termination tolerance in the unknown variables, while 
-## @code{"TolFun"} is a tolerance for equations. Default is @code{1e-7}
+## @code{"TolFun"} is a tolerance for equations.  Default is @code{1e-7}
 ## for both @code{"TolX"} and @code{"TolFun"}.
 ## 
 ## For description of the other options, see @code{optimset}.
 ##
 ## On return, @var{fval} contains the value of the function @var{fcn}
 ## evaluated at @var{x}, and @var{info} may be one of the following values:
 ## 
 ## @table @asis
 ## @item 1
-## Converged to a solution point. Relative gradient error is less than specified
+## Converged to a solution point.  Relative gradient error is less than specified
 ## by TolFun.
 ## @item 2
 ## Last relative step size was less that TolX.
 ## @item 3
 ## Last relative decrease in func value was less than TolF. 
 ## @item 0
 ## Iteration limit exceeded.
 ## @item -3
diff --git a/scripts/optimization/glpk.m b/scripts/optimization/glpk.m
--- a/scripts/optimization/glpk.m
+++ b/scripts/optimization/glpk.m
@@ -136,101 +136,101 @@
 ## A structure containing the following parameters used to define the
 ## behavior of solver.  Missing elements in the structure take on default
 ## values, so you only need to set the elements that you wish to change
 ## from the default.
 ## 
 ## Integer parameters:
 ## 
 ## @table @code
-## @item msglev (@code{LPX_K_MSGLEV}, default: 1)
+## @item msglev (@w{@code{LPX_K_MSGLEV}}, default: 1)
 ## Level of messages output by solver routines:
 ## @table @asis
 ## @item 0
 ## No output.
 ## @item 1
 ## Error messages only.
 ## @item 2
 ## Normal output .
 ## @item 3
 ## Full output (includes informational messages).
 ## @end table
 ## 
-## @item scale (@code{LPX_K_SCALE}, default: 1)
+## @item scale (@w{@code{LPX_K_SCALE}}, default: 1)
 ## Scaling option: 
 ## @table @asis
 ## @item 0
 ## No scaling.
 ## @item 1
 ## Equilibration scaling.
 ## @item 2
 ## Geometric mean scaling, then equilibration scaling.
 ## @end table
 ## 
-## @item dual	 (@code{LPX_K_DUAL}, default: 0)
+## @item dual	 (@w{@code{LPX_K_DUAL}}, default: 0)
 ## Dual simplex option:
 ## @table @asis
 ## @item 0
 ## Do not use the dual simplex.
 ## @item 1
 ## If initial basic solution is dual feasible, use the dual simplex.
 ## @end table
 ## 
-## @item price	 (@code{LPX_K_PRICE}, default: 1)
+## @item price	 (@w{@code{LPX_K_PRICE}}, default: 1)
 ## Pricing option (for both primal and dual simplex):
 ## @table @asis
 ## @item 0
 ## Textbook pricing.
 ## @item 1
 ## Steepest edge pricing.
 ## @end table
 ##   
-## @item round	 (@code{LPX_K_ROUND}, default: 0)
+## @item round	 (@w{@code{LPX_K_ROUND}}, default: 0)
 ## Solution rounding option:
 ## @table @asis
 ## @item 0
 ## Report all primal and dual values "as is".
 ## @item 1
 ## Replace tiny primal and dual values by exact zero.
 ## @end table
 ## 
-## @item itlim	 (@code{LPX_K_ITLIM}, default: -1)
+## @item itlim	 (@w{@code{LPX_K_ITLIM}}, default: -1)
 ## Simplex iterations limit.  If this value is positive, it is decreased by
 ## one each time when one simplex iteration has been performed, and
 ## reaching zero value signals the solver to stop the search.  Negative
 ## value means no iterations limit.
 ## 
-## @item itcnt (@code{LPX_K_OUTFRQ}, default: 200)
+## @item itcnt (@w{@code{LPX_K_OUTFRQ}}, default: 200)
 ## Output frequency, in iterations.  This parameter specifies how
 ## frequently the solver sends information about the solution to the
 ## standard output.
 ## 
-## @item branch (@code{LPX_K_BRANCH}, default: 2)
+## @item branch (@w{@code{LPX_K_BRANCH}}, default: 2)
 ## Branching heuristic option (for MIP only):
 ## @table @asis
 ## @item 0
 ## Branch on the first variable.
 ## @item 1
 ## Branch on the last variable.
 ## @item 2
 ## Branch using a heuristic by Driebeck and Tomlin.
 ## @end table
 ## 
-## @item btrack (@code{LPX_K_BTRACK}, default: 2)
+## @item btrack (@w{@code{LPX_K_BTRACK}}, default: 2)
 ## Backtracking heuristic option (for MIP only):
 ## @table @asis
 ## @item 0
 ## Depth first search.
 ## @item 1
 ## Breadth first search.
 ## @item 2
 ## Backtrack using the best projection heuristic.
 ## @end table        
 ## 
-## @item presol (@code{LPX_K_PRESOL}, default: 1)
+## @item presol (@w{@code{LPX_K_PRESOL}}, default: 1)
 ## If this flag is set, the routine lpx_simplex solves the problem using
 ## the built-in LP presolver.  Otherwise the LP presolver is not used.
 ## 
 ## @item lpsolver (default: 1)
 ## Select which solver to use.  If the problem is a MIP problem this flag
 ## will be ignored.
 ## @table @asis
 ## @item 1
@@ -242,68 +242,68 @@
 ## If this parameter is nonzero, save a copy of the problem in
 ## CPLEX LP format to the file @file{"outpb.lp"}.  There is currently no
 ## way to change the name of the output file.
 ## @end table
 ## 
 ## Real parameters:
 ## 
 ## @table @code
-## @item relax (@code{LPX_K_RELAX}, default: 0.07)
+## @item relax (@w{@code{LPX_K_RELAX}}, default: 0.07)
 ## Relaxation parameter used in the ratio test.  If it is zero, the textbook
 ## ratio test is used.  If it is non-zero (should be positive), Harris'
 ## two-pass ratio test is used.  In the latter case on the first pass of the
 ## ratio test basic variables (in the case of primal simplex) or reduced
 ## costs of non-basic variables (in the case of dual simplex) are allowed
 ## to slightly violate their bounds, but not more than
 ## @code{relax*tolbnd} or @code{relax*toldj (thus, @code{relax} is a
 ## percentage of @code{tolbnd} or @code{toldj}}.
 ## 
-## @item tolbnd (@code{LPX_K_TOLBND}, default: 10e-7)
+## @item tolbnd (@w{@code{LPX_K_TOLBND}}, default: 10e-7)
 ## Relative tolerance used to check if the current basic solution is primal
 ## feasible.  It is not recommended that you change this parameter unless you
 ## have a detailed understanding of its purpose.
 ## 
-## @item toldj (@code{LPX_K_TOLDJ}, default: 10e-7)
+## @item toldj (@w{@code{LPX_K_TOLDJ}}, default: 10e-7)
 ## Absolute tolerance used to check if the current basic solution is dual
 ## feasible.  It is not recommended that you change this parameter unless you
 ## have a detailed understanding of its purpose.
 ## 
-## @item tolpiv (@code{LPX_K_TOLPIV}, default: 10e-9)
+## @item tolpiv (@w{@code{LPX_K_TOLPIV}}, default: 10e-9)
 ## Relative tolerance used to choose eligible pivotal elements of the
 ## simplex table.  It is not recommended that you change this parameter unless you
 ## have a detailed understanding of its purpose.
 ## 
-## @item objll (@code{LPX_K_OBJLL}, default: -DBL_MAX)
+## @item objll (@w{@code{LPX_K_OBJLL}}, default: -DBL_MAX)
 ## Lower limit of the objective function.  If on the phase II the objective
 ## function reaches this limit and continues decreasing, the solver stops
 ## the search.  This parameter is used in the dual simplex method only.
 ## 
-## @item objul (@code{LPX_K_OBJUL}, default: +DBL_MAX)
+## @item objul (@w{@code{LPX_K_OBJUL}}, default: +DBL_MAX)
 ## Upper limit of the objective function.  If on the phase II the objective
 ## function reaches this limit and continues increasing, the solver stops
 ## the search.  This parameter is used in the dual simplex only.
 ## 
-## @item tmlim (@code{LPX_K_TMLIM}, default: -1.0)
+## @item tmlim (@w{@code{LPX_K_TMLIM}}, default: -1.0)
 ## Searching time limit, in seconds.  If this value is positive, it is
 ## decreased each time when one simplex iteration has been performed by the
 ## amount of time spent for the iteration, and reaching zero value signals
 ## the solver to stop the search.  Negative value means no time limit.
 ## 
-## @item outdly (@code{LPX_K_OUTDLY}, default: 0.0)
+## @item outdly (@w{@code{LPX_K_OUTDLY}}, default: 0.0)
 ## Output delay, in seconds.  This parameter specifies how long the solver
 ## should delay sending information about the solution to the standard
 ## output.  Non-positive value means no delay.
 ## 
-## @item tolint (@code{LPX_K_TOLINT}, default: 10e-5)
+## @item tolint (@w{@code{LPX_K_TOLINT}}, default: 10e-5)
 ## Relative tolerance used to check if the current basic solution is integer
 ## feasible.  It is not recommended that you change this parameter unless
 ## you have a detailed understanding of its purpose.
 ## 
-## @item tolobj (@code{LPX_K_TOLOBJ}, default: 10e-7)
+## @item tolobj (@w{@code{LPX_K_TOLOBJ}}, default: 10e-7)
 ## Relative tolerance used to check if the value of the objective function
 ## is not better than in the best known integer feasible solution.  It is
 ## not recommended that you change this parameter unless you have a
 ## detailed understanding of its purpose.
 ## @end table
 ## @end table
 ## 
 ## Output values:
@@ -313,73 +313,73 @@
 ## The optimizer (the value of the decision variables at the optimum).
 ## @item fopt
 ## The optimum value of the objective function.
 ## @item status
 ## Status of the optimization.
 ## 
 ## Simplex Method:
 ## @table @asis
-## @item 180 (@code{LPX_OPT})
+## @item 180 (@w{@code{LPX_OPT}})
 ## Solution is optimal.
-## @item 181 (@code{LPX_FEAS})
+## @item 181 (@w{@code{LPX_FEAS}})
 ## Solution is feasible.
-## @item 182 (@code{LPX_INFEAS})
+## @item 182 (@w{@code{LPX_INFEAS}})
 ## Solution is infeasible.
-## @item 183 (@code{LPX_NOFEAS})
+## @item 183 (@w{@code{LPX_NOFEAS}})
 ## Problem has no feasible solution.
-## @item 184 (@code{LPX_UNBND})
+## @item 184 (@w{@code{LPX_UNBND}})
 ## Problem has no unbounded solution.
-## @item 185 (@code{LPX_UNDEF})
+## @item 185 (@w{@code{LPX_UNDEF}})
 ## Solution status is undefined.
 ## @end table
 ## Interior Point Method:
 ## @table @asis
-## @item 150 (@code{LPX_T_UNDEF})
+## @item 150 (@w{@code{LPX_T_UNDEF}})
 ## The interior point method is undefined.
-## @item 151 (@code{LPX_T_OPT})
+## @item 151 (@w{@code{LPX_T_OPT}})
 ## The interior point method is optimal.
 ## @end table
 ## Mixed Integer Method:
 ## @table @asis
-## @item 170 (@code{LPX_I_UNDEF})
+## @item 170 (@w{@code{LPX_I_UNDEF}})
 ## The status is undefined.
-## @item 171 (@code{LPX_I_OPT})
+## @item 171 (@w{@code{LPX_I_OPT}})
 ## The solution is integer optimal.
-## @item 172 (@code{LPX_I_FEAS})
+## @item 172 (@w{@code{LPX_I_FEAS}})
 ## Solution integer feasible but its optimality has not been proven
-## @item 173 (@code{LPX_I_NOFEAS})
+## @item 173 (@w{@code{LPX_I_NOFEAS}})
 ## No integer feasible solution.
 ## @end table
 ## @noindent
 ## If an error occurs, @var{status} will contain one of the following
 ## codes:
 ##
 ## @table @asis
-## @item 204 (@code{LPX_E_FAULT})
+## @item 204 (@w{@code{LPX_E_FAULT}})
 ## Unable to start the search.
-## @item 205 (@code{LPX_E_OBJLL})
+## @item 205 (@w{@code{LPX_E_OBJLL}})
 ## Objective function lower limit reached.
-## @item 206 (@code{LPX_E_OBJUL})
+## @item 206 (@w{@code{LPX_E_OBJUL}})
 ## Objective function upper limit reached.
-## @item 207 (@code{LPX_E_ITLIM})
+## @item 207 (@w{@code{LPX_E_ITLIM}})
 ## Iterations limit exhausted.
-## @item 208 (@code{LPX_E_TMLIM})
+## @item 208 (@w{@code{LPX_E_TMLIM}})
 ## Time limit exhausted.
-## @item 209 (@code{LPX_E_NOFEAS})
+## @item 209 (@w{@code{LPX_E_NOFEAS}})
 ## No feasible solution.
-## @item 210 (@code{LPX_E_INSTAB})
+## @item 210 (@w{@code{LPX_E_INSTAB}})
 ## Numerical instability.
-## @item 211 (@code{LPX_E_SING})
+## @item 211 (@w{@code{LPX_E_SING}})
 ## Problems with basis matrix.
-## @item 212 (@code{LPX_E_NOCONV})
+## @item 212 (@w{@code{LPX_E_NOCONV}})
 ## No convergence (interior).
-## @item 213 (@code{LPX_E_NOPFS})
+## @item 213 (@w{@code{LPX_E_NOPFS}})
 ## No primal feasible solution (LP presolver).
-## @item 214 (@code{LPX_E_NODFS})
+## @item 214 (@w{@code{LPX_E_NODFS}})
 ## No dual feasible solution (LP presolver).
 ## @end table
 ## @item extra
 ## A data structure containing the following fields:
 ## @table @code
 ## @item lambda
 ## Dual variables.
 ## @item redcosts
@@ -405,17 +405,17 @@
 ## ub = [];
 ## ctype = "UUU";
 ## vartype = "CCC";
 ## s = -1;
 ## 
 ## param.msglev = 1;
 ## param.itlim = 100;
 ## 
-## [xmin, fmin, status, extra] = @dots{}
+## [xmin, fmin, status, extra] = ...
 ##    glpk (c, a, b, lb, ub, ctype, vartype, s, param);
 ## @end group
 ## @end example
 ## @end deftypefn
 
 ## Author: Nicolo' Giorgetti <giorgetti@dii.unisi.it>
 ## Adapted-by: jwe
 
diff --git a/scripts/plot/__marching_cube__.m b/scripts/plot/__marching_cube__.m
--- a/scripts/plot/__marching_cube__.m
+++ b/scripts/plot/__marching_cube__.m
@@ -30,49 +30,53 @@
 ## three--dimensional numeric arrays.  The orientation of the triangles
 ## is choosen such that the normals point from the higher values to the
 ## lower values.
 ##
 ## Optionally the color data @var{col} can be passed to this function
 ## whereas computed vertices color data @var{c} is returned as third
 ## argument.
 ##
-## The marching cube algorithm is well known and described eg. at
-## Wikipedia. The triangulation lookup table and the edge table used
+## The marching cube algorithm is well known and described, for example, at
+## Wikipedia.  The triangulation lookup table and the edge table used
 ## here are based on Cory Gene Bloyd's implementation and can be found
 ## beyond other surface and geometry stuff at Paul Bourke's website
 ## @uref{http://local.wasp.uwa.edu.au/~pbourke/geometry/polygonise}.
 ##
 ## For example,
 ## @example
+## @group
 ## N = 20;
 ## lin = linspace(0, 2, N);
 ## [x, y, z] = meshgrid (lin, lin, lin);
 ##
 ## c = (x-.5).^2 + (y-.5).^2 + (z-.5).^2;
 ## [t, p] = __marching_cube__ (x, y, z, c, .5);
 ##
 ## figure ();
 ## trimesh (t, p(:,1), p(:,2), p(:,3));
+## @end group
 ## @end example
 ##
 ## Instead of the @command{trimesh} function the @command{patch}
-## function can be used to visualize the geometry. For example,
+## function can be used to visualize the geometry.  For example,
 ##
 ## @example
+## @group
 ## figure (); view (-38, 20);
 ## pa = patch ("Faces", t, "Vertices", p, "FaceVertexCData", p, \
 ##             "FaceColor", "interp", "EdgeColor", "none");
 ##
 ## ## Revert normals
 ## set (pa, "VertexNormals", -get(pa, "VertexNormals"));
 ##
 ## ## Set lightning (available with the JHandles package)
 ## # set (pa, "FaceLighting", "gouraud");
 ## # light( "Position", [1 1 5]);
+## @end group
 ## @end example
 ##
 ## @end deftypefn
 
 ## Author: Martin Helm <martin@mhelm.de>
 
 function [T, p, col] = __marching_cube__ (xx, yy, zz, c, iso, colors)
   
diff --git a/scripts/plot/contourc.m b/scripts/plot/contourc.m
--- a/scripts/plot/contourc.m
+++ b/scripts/plot/contourc.m
@@ -22,17 +22,17 @@
 ## Parameters @var{x}, @var{y} and @var{vn} are optional.
 ##
 ## The return value @var{lev} is a vector of the contour levels.
 ## The return value @var{c} is a 2 by @var{n} matrix containing the
 ## contour lines in the following format
 ##
 ## @example
 ## @group
-## @var{c} = [lev1, x1, x2, @dots{}, levn, x1, x2, @dots{} 
+## @var{c} = [lev1, x1, x2, @dots{}, levn, x1, x2, ... 
 ##      len1, y1, y2, @dots{}, lenn, y1, y2, @dots{}]
 ## @end group
 ## @end example
 ##
 ## @noindent
 ## in which contour line @var{n} has a level (height) of @var{levn} and
 ## length of @var{lenn}.
 ## 
diff --git a/scripts/plot/isosurface.m b/scripts/plot/isosurface.m
--- a/scripts/plot/isosurface.m
+++ b/scripts/plot/isosurface.m
@@ -31,17 +31,17 @@
 ## argument @var{fv} can directly be taken as an input argument for the 
 ## @command{patch} function.
 ##
 ## If called with further input arguments @var{x}, @var{y} and @var{z}
 ## which are three--dimensional arrays with the same size than @var{val}
 ## then the volume data is taken at those given points.
 ##
 ## The string input argument "noshare" is only for compatibility and
-## has no effect. If given the string input argument
+## has no effect.  If given the string input argument
 ## "verbose" then print messages to the command line interface about the
 ## current progress.
 ##
 ## If called with the input argument @var{col} which is a
 ## three-dimensional array of the same size than @var{val} then take
 ## those values for the interpolation of coloring the isosurface
 ## geometry.  Add the field @var{FaceVertexCData} to the structure
 ## array @var{fv}.
@@ -51,19 +51,21 @@
 ## @var{c} as seperate arrays instead of a single structure array.
 ##
 ## If called with no output argument then directly process the
 ## isosurface geometry with the @command{patch} command.
 ##
 ## For example
 ##
 ## @example
+## @group
 ## [x, y, z] = meshgrid (1:5, 1:5, 1:5);
 ## val = rand (5, 5, 5);
 ## isosurface (x, y, z, val, .5);
+## @end group
 ## @end example
 ##
 ## will directly draw a random isosurface geometry in a graphics window.
 ## Another example for an isosurface geometry with different additional
 ## coloring
 ##
 ## @example
 ## N = 15;    ## Increase number of vertices in each direction
diff --git a/scripts/plot/print.m b/scripts/plot/print.m
--- a/scripts/plot/print.m
+++ b/scripts/plot/print.m
@@ -66,17 +66,17 @@
 ##   @itemx pstex
 ##   @itemx pslatex
 ##     Generate a @LaTeX{} (or @TeX{}) file for labels, and eps/ps for
 ## graphics.  The file produced by @code{epslatexstandalone} can be
 ## processed directly by @LaTeX{}.  The other formats are intended to
 ## be included in a @LaTeX{} (or @TeX{}) document.  The @code{tex} device
 ## is the same as the @code{epslatex} device.
 ##   @item tikz
-##     Generate a LaTeX file using gnuplot's Lua/TikZ terminal.
+##     Generate a @LaTeX{} file using gnuplot's Lua/TikZ terminal.
 ##   @item ill
 ##   @itemx aifm
 ##     Adobe Illustrator
 ##   @item cdr
 ##   @itemx corel
 ##     CorelDraw
 ##   @item dxf
 ##     AutoCAD
diff --git a/scripts/plot/xlabel.m b/scripts/plot/xlabel.m
--- a/scripts/plot/xlabel.m
+++ b/scripts/plot/xlabel.m
@@ -17,17 +17,17 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} xlabel (@var{string})
 ## @deftypefnx {Function File} {} ylabel (@var{string})
 ## @deftypefnx {Function File} {} zlabel (@var{string})
 ## @deftypefnx {Function File} {} xlabel (@var{h}, @var{string})
-## Specify x, y, and z axis labels for the current figure.  If @var{h} is
+## Specify x-, y-, and z-axis labels for the current figure.  If @var{h} is
 ## specified then label the axis defined by @var{h}.
 ## @seealso{plot, semilogx, semilogy, loglog, polar, mesh, contour,
 ## bar, stairs, title}
 ## @end deftypefn
 
 ## Author: jwe
 
 function retval = xlabel (varargin)
diff --git a/scripts/polynomial/polyaffine.m b/scripts/polynomial/polyaffine.m
--- a/scripts/polynomial/polyaffine.m
+++ b/scripts/polynomial/polyaffine.m
@@ -11,17 +11,17 @@
 ## GNU General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this program; If not, see <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} polyaffine (@var{f}, @var{mu})
 ## Return the coefficients of the polynomial whose coefficients are given by
-## vector @var{f} after an affine tranformation. If @var{f} is the vector
+## vector @var{f} after an affine tranformation.  If @var{f} is the vector
 ## representing the polynomial f(x), then @var{g} = polytrans (@var{f},
 ## @var{mu}) is the vector representing 
 ## @example
 ## g(x) = f((x-@var{mu}(1))/@var{mu}(2)).
 ## @end example
 ## 
 ## @seealso{polyval}
 ## @end deftypefn
diff --git a/src/DLD-FUNCTIONS/betainc.cc b/src/DLD-FUNCTIONS/betainc.cc
--- a/src/DLD-FUNCTIONS/betainc.cc
+++ b/src/DLD-FUNCTIONS/betainc.cc
@@ -32,23 +32,21 @@ along with Octave; see the file COPYING.
 #include "gripes.h"
 #include "oct-obj.h"
 #include "utils.h"
 
 DEFUN_DLD (betainc, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} betainc (@var{x}, @var{a}, @var{b})\n\
 Return the incomplete Beta function,\n\
-@iftex\n\
 @tex\n\
 $$\n\
  \\beta (x, a, b) = B (a, b)^{-1} \\int_0^x t^{(a-z)} (1-t)^{(b-1)} dt.\n\
 $$\n\
 @end tex\n\
-@end iftex\n\
 @ifnottex\n\
 \n\
 @c Set example in small font to prevent overfull line\n\
 @smallexample\n\
                                       x\n\
                                      /\n\
 betainc (x, a, b) = beta (a, b)^(-1) | t^(a-1) (1-t)^(b-1) dt.\n\
                                      /\n\
diff --git a/src/DLD-FUNCTIONS/chol.cc b/src/DLD-FUNCTIONS/chol.cc
--- a/src/DLD-FUNCTIONS/chol.cc
+++ b/src/DLD-FUNCTIONS/chol.cc
@@ -58,71 +58,63 @@ DEFUN_DLD (chol, args, nargout,
 @deftypefn {Loadable Function} {@var{r} =} chol (@var{a})\n\
 @deftypefnx {Loadable Function} {[@var{r}, @var{p}] =} chol (@var{a})\n\
 @deftypefnx {Loadable Function} {[@var{r}, @var{p}, @var{q}] =} chol (@var{s})\n\
 @deftypefnx {Loadable Function} {[@var{r}, @var{p}, @var{q}] =} chol (@var{s}, 'vector')\n\
 @deftypefnx {Loadable Function} {[@var{l}, @dots{}] =} chol (@dots{}, 'lower')\n\
 @cindex Cholesky factorization\n\
 Compute the Cholesky factor, @var{r}, of the symmetric positive definite\n\
 matrix @var{a}, where\n\
-@iftex\n\
 @tex\n\
 $ R^T R = A $.\n\
 @end tex\n\
-@end iftex\n\
 @ifnottex\n\
 \n\
 @example\n\
 @var{r}' * @var{r} = @var{a}.\n\
 @end example\n\
 @end ifnottex\n\
 \n\
 Called with one output argument @code{chol} fails if @var{a} or @var{s} is\n\
 not positive definite.  With two or more output arguments @var{p} flags\n\
 whether the matrix was positive definite and @code{chol} does not fail.  A\n\
 zero value indicated that the matrix was positive definite and the @var{r}\n\
 gives the factorization, and @var{p} will have a positive value otherwise.\n\
 \n\
 If called with 3 outputs then a sparsity preserving row/column permutation\n\
 is applied to @var{a} prior to the factorization.  That is @var{r}\n\
 is the factorization of @code{@var{a}(@var{q},@var{q})} such that\n\
-@iftex\n\
 @tex\n\
 $ R^T R = Q^T A Q$.\n\
 @end tex\n\
-@end iftex\n\
 @ifnottex\n\
 \n\
 @example\n\
 @var{r}' * @var{r} = @var{q}' * @var{a} * @var{q}.\n\
 @end example\n\
 @end ifnottex\n\
 \n\
 The sparsity preserving permutation is generally returned as a matrix.\n\
 However, given the flag 'vector', @var{q} will be returned as a vector\n\
 such that\n\
-@iftex\n\
 @tex\n\
 $ R^T R = A (Q, Q)$.\n\
 @end tex\n\
-@end iftex\n\
 @ifnottex\n\
 \n\
 @example\n\
 @var{r}' * @var{r} = a (@var{q}, @var{q}).\n\
 @end example\n\
 @end ifnottex\n\
 \n\
 Called with either a sparse or full matrix and using the 'lower' flag,\n\
 @code{chol} returns the lower triangular factorization such that\n\
-@iftex\n\
 @tex\n\
 $ L L^T = A $.\n\
 @end tex\n\
-@end iftex\n\
 @ifnottex\n\
 \n\
 @example\n\
 @var{l} * @var{l}' = @var{a}.\n\
 @end example\n\
 @end ifnottex\n\
 \n\
 In general the lower triangular factorization is significantly faster for\n\
diff --git a/src/DLD-FUNCTIONS/dassl.cc b/src/DLD-FUNCTIONS/dassl.cc
--- a/src/DLD-FUNCTIONS/dassl.cc
+++ b/src/DLD-FUNCTIONS/dassl.cc
@@ -175,23 +175,21 @@ dassl_user_jacobian (const ColumnVector&
       DASSL_ABORT (); \
     } \
   while (0)
 
 DEFUN_DLD (dassl, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {[@var{x}, @var{xdot}, @var{istate}, @var{msg}] =} dassl (@var{fcn}, @var{x_0}, @var{xdot_0}, @var{t}, @var{t_crit})\n\
 Solve the set of differential-algebraic equations\n\
-@iftex\n\
 @tex\n\
 $$ 0 = f (x, \\dot{x}, t) $$\n\
 with\n\
 $$ x(t_0) = x_0, \\dot{x}(t_0) = \\dot{x}_0 $$\n\
 @end tex\n\
-@end iftex\n\
 @ifnottex\n\
 \n\
 @example\n\
 0 = f (x, xdot, t)\n\
 @end example\n\
 \n\
 @noindent\n\
 with\n\
@@ -221,24 +219,22 @@ residuals for the set of equations.  It 
 in which @var{x}, @var{xdot}, and @var{res} are vectors, and @var{t} is a\n\
 scalar.\n\
 \n\
 If @var{fcn} is a two-element string array or a two-element cell array\n\
 of strings, inline functions, or function handles, the first element names\n\
 the function @math{f} described above, and the second element names a\n\
 function to compute the modified Jacobian\n\
 \n\
-@iftex\n\
 @tex\n\
 $$\n\
 J = {\\partial f \\over \\partial x}\n\
   + c {\\partial f \\over \\partial \\dot{x}}\n\
 $$\n\
 @end tex\n\
-@end iftex\n\
 @ifnottex\n\
 @example\n\
 @group\n\
       df       df\n\
 jac = -- + c ------\n\
       dx     d xdot\n\
 @end group\n\
 @end example\n\
diff --git a/src/DLD-FUNCTIONS/eigs.cc b/src/DLD-FUNCTIONS/eigs.cc
--- a/src/DLD-FUNCTIONS/eigs.cc
+++ b/src/DLD-FUNCTIONS/eigs.cc
@@ -235,17 +235,17 @@ The maximum number of iterations.  The d
 \n\
 @item p\n\
 The number of Lanzcos basis vectors to use.  More vectors will result in\n\
 faster convergence, but a larger amount of memory.  The optimal value of 'p'\n\
 is problem dependent and should be in the range @var{k} to @var{n}.  The\n\
 default value is @code{2 * @var{k}}.\n\
 \n\
 @item v0\n\
-The starting vector for the computation.  The default is to have @sc{Arpack}\n\
+The starting vector for the computation.  The default is to have @sc{arpack}\n\
 randomly generate a starting vector.\n\
 \n\
 @item disp\n\
 The level of diagnostic printout.  If @code{disp} is 0 then there is no\n\
 printout.  The default value is 1.\n\
 \n\
 @item cholB\n\
 Flag if @code{chol (@var{b})} is passed rather than @var{b}.  The default is\n\
diff --git a/src/DLD-FUNCTIONS/filter.cc b/src/DLD-FUNCTIONS/filter.cc
--- a/src/DLD-FUNCTIONS/filter.cc
+++ b/src/DLD-FUNCTIONS/filter.cc
@@ -281,93 +281,83 @@ filter (MArray<T>& b, MArray<T>& a, MArr
 DEFUN_DLD (filter, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {y =} filter (@var{b}, @var{a}, @var{x})\n\
 @deftypefnx {Loadable Function} {[@var{y}, @var{sf}] =} filter (@var{b}, @var{a}, @var{x}, @var{si})\n\
 @deftypefnx {Loadable Function} {[@var{y}, @var{sf}] =} filter (@var{b}, @var{a}, @var{x}, [], @var{dim})\n\
 @deftypefnx {Loadable Function} {[@var{y}, @var{sf}] =} filter (@var{b}, @var{a}, @var{x}, @var{si}, @var{dim})\n\
 Return the solution to the following linear, time-invariant difference\n\
 equation:\n\
-@iftex\n\
 @tex\n\
 $$\n\
 \\sum_{k=0}^N a_{k+1} y_{n-k} = \\sum_{k=0}^M b_{k+1} x_{n-k}, \\qquad\n\
  1 \\le n \\le P\n\
 $$\n\
 @end tex\n\
-@end iftex\n\
 @ifnottex\n\
 \n\
 @c Set example in small font to prevent overfull line\n\
 @smallexample\n\
    N                   M\n\
   SUM a(k+1) y(n-k) = SUM b(k+1) x(n-k)      for 1<=n<=length(x)\n\
   k=0                 k=0\n\
 @end smallexample\n\
 @end ifnottex\n\
 \n\
 @noindent\n\
 where\n\
 @ifnottex\n\
  N=length(a)-1 and M=length(b)-1.\n\
 @end ifnottex\n\
-@iftex\n\
 @tex\n\
  $a \\in \\Re^{N-1}$, $b \\in \\Re^{M-1}$, and $x \\in \\Re^P$.\n\
 @end tex\n\
-@end iftex\n\
 over the first non-singleton dimension of @var{x} or over @var{dim} if\n\
 supplied.  An equivalent form of this equation is:\n\
-@iftex\n\
 @tex\n\
 $$\n\
 y_n = -\\sum_{k=1}^N c_{k+1} y_{n-k} + \\sum_{k=0}^M d_{k+1} x_{n-k}, \\qquad\n\
  1 \\le n \\le P\n\
 $$\n\
 @end tex\n\
-@end iftex\n\
 @ifnottex\n\
 \n\
 @c Set example in small font to prevent overfull line\n\
 @smallexample\n\
             N                   M\n\
   y(n) = - SUM c(k+1) y(n-k) + SUM d(k+1) x(n-k)  for 1<=n<=length(x)\n\
            k=1                 k=0\n\
 @end smallexample\n\
 @end ifnottex\n\
 \n\
 @noindent\n\
 where\n\
 @ifnottex\n\
  c = a/a(1) and d = b/a(1).\n\
 @end ifnottex\n\
-@iftex\n\
 @tex\n\
 $c = a/a_1$ and $d = b/a_1$.\n\
 @end tex\n\
-@end iftex\n\
 \n\
 If the fourth argument @var{si} is provided, it is taken as the\n\
 initial state of the system and the final state is returned as\n\
 @var{sf}.  The state vector is a column vector whose length is\n\
 equal to the length of the longest coefficient vector minus one.\n\
 If @var{si} is not supplied, the initial state vector is set to all\n\
 zeros.\n\
 \n\
 In terms of the z-transform, y is the result of passing the discrete-\n\
 time signal x through a system characterized by the following rational\n\
 system function:\n\
-@iftex\n\
 @tex\n\
 $$\n\
 H(z) = {\\displaystyle\\sum_{k=0}^M d_{k+1} z^{-k}\n\
         \\over 1 + \\displaystyle\\sum_{k+1}^N c_{k+1} z^{-k}}\n\
 $$\n\
 @end tex\n\
-@end iftex\n\
 @ifnottex\n\
 \n\
 @example\n\
 @group\n\
              M\n\
             SUM d(k+1) z^(-k)\n\
             k=0\n\
   H(z) = ----------------------\n\
diff --git a/src/DLD-FUNCTIONS/fltk_backend.cc b/src/DLD-FUNCTIONS/fltk_backend.cc
--- a/src/DLD-FUNCTIONS/fltk_backend.cc
+++ b/src/DLD-FUNCTIONS/fltk_backend.cc
@@ -962,17 +962,17 @@ DEFUN_DLD (__fltk_maxtime__, args, ,"")
     }
 
   return retval;
 }
 
 DEFUN_DLD (fltk_mouse_wheel_zoom, args, ,
 "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} fltk_mouse_wheel_zoom ([@var{speed}])\n\
-Returns the current mouse wheel zoom factor in the fltk backend. If\n\
+Returns the current mouse wheel zoom factor in the fltk backend.  If\n\
 the @var{speed} argument is given, set the mouse zoom factor to this\n\
 value.\n\
 @end deftypefn")
 {
   octave_value retval = wheel_zoom_speed;
 
   if (args.length () == 1)
     {
diff --git a/src/DLD-FUNCTIONS/gammainc.cc b/src/DLD-FUNCTIONS/gammainc.cc
--- a/src/DLD-FUNCTIONS/gammainc.cc
+++ b/src/DLD-FUNCTIONS/gammainc.cc
@@ -32,23 +32,21 @@ along with Octave; see the file COPYING.
 #include "gripes.h"
 #include "oct-obj.h"
 #include "utils.h"
 
 DEFUN_DLD (gammainc, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} gammainc (@var{x}, @var{a})\n\
 Compute the normalized incomplete gamma function,\n\
-@iftex\n\
 @tex\n\
 $$\n\
  \\gamma (x, a) = {\\displaystyle\\int_0^x e^{-t} t^{a-1} dt \\over \\Gamma (a)}\n\
 $$\n\
 @end tex\n\
-@end iftex\n\
 @ifnottex\n\
 \n\
 @smallexample\n\
                                 x\n\
                       1        /\n\
 gammainc (x, a) = ---------    | exp (-t) t^(a-1) dt\n\
                   gamma (a)    /\n\
                             t=0\n\
diff --git a/src/DLD-FUNCTIONS/givens.cc b/src/DLD-FUNCTIONS/givens.cc
--- a/src/DLD-FUNCTIONS/givens.cc
+++ b/src/DLD-FUNCTIONS/givens.cc
@@ -30,29 +30,27 @@ along with Octave; see the file COPYING.
 #include "defun-dld.h"
 #include "error.h"
 #include "oct-obj.h"
 
 DEFUN_DLD (givens, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{g} =} givens (@var{x}, @var{y})\n\
 @deftypefnx {Loadable Function} {[@var{c}, @var{s}] =} givens (@var{x}, @var{y})\n\
-@iftex\n\
 @tex\n\
 Return a $2\\times 2$ orthogonal matrix\n\
 $$\n\
  G = \\left[\\matrix{c & s\\cr -s'& c\\cr}\\right]\n\
 $$\n\
 such that\n\
 $$\n\
  G \\left[\\matrix{x\\cr y}\\right] = \\left[\\matrix{\\ast\\cr 0}\\right]\n\
 $$\n\
 with $x$ and $y$ scalars.\n\
 @end tex\n\
-@end iftex\n\
 @ifnottex\n\
 Return a 2 by 2 orthogonal matrix\n\
 @code{@var{g} = [@var{c} @var{s}; -@var{s}' @var{c}]} such that\n\
 @code{@var{g} [@var{x}; @var{y}] = [*; 0]} with @var{x} and @var{y} scalars.\n\
 @end ifnottex\n\
 \n\
 For example,\n\
 \n\
diff --git a/src/DLD-FUNCTIONS/hess.cc b/src/DLD-FUNCTIONS/hess.cc
--- a/src/DLD-FUNCTIONS/hess.cc
+++ b/src/DLD-FUNCTIONS/hess.cc
@@ -42,25 +42,23 @@ DEFUN_DLD (hess, args, nargout,
 @deftypefnx {Loadable Function} {[@var{p}, @var{h}] =} hess (@var{a})\n\
 @cindex Hessenberg decomposition\n\
 Compute the Hessenberg decomposition of the matrix @var{a}.\n\
 \n\
 The Hessenberg decomposition is usually used as the first step in an\n\
 eigenvalue computation, but has other applications as well (see Golub,\n\
 Nash, and Van Loan, IEEE Transactions on Automatic Control, 1979).  The\n\
 Hessenberg decomposition is\n\
-@iftex\n\
 @tex\n\
 $$\n\
 A = PHP^T\n\
 $$\n\
 where $P$ is a square unitary matrix ($P^HP = I$), and $H$\n\
 is upper Hessenberg ($H_{i,j} = 0, \\forall i \\ge j+1$).\n\
 @end tex\n\
-@end iftex\n\
 @ifnottex\n\
 @code{p * h * p' = a} where @code{p} is a square unitary matrix\n\
 (@code{p' * p = I}, using complex-conjugate transposition) and @code{h}\n\
 is upper Hessenberg (@code{i >= j+1 => h (i, j) = 0}).\n\
 @end ifnottex\n\
 @end deftypefn")
 {
   octave_value_list retval;
diff --git a/src/DLD-FUNCTIONS/matrix_type.cc b/src/DLD-FUNCTIONS/matrix_type.cc
--- a/src/DLD-FUNCTIONS/matrix_type.cc
+++ b/src/DLD-FUNCTIONS/matrix_type.cc
@@ -46,17 +46,17 @@ DEFUN_DLD (matrix_type, args, ,
 @deftypefnx {Loadable Function} {@var{a} =} matrix_type (@var{a}, 'banded', @var{nl}, @var{nu})\n\
 Identify the matrix type or mark a matrix as a particular type.  This allows rapid\n\
 for solutions of linear equations involving @var{a} to be performed.  Called with a\n\
 single argument, @code{matrix_type} returns the type of the matrix and caches it for\n\
 future use.  Called with more than one argument, @code{matrix_type} allows the type\n\
 of the matrix to be defined.\n\
 \n\
 If the option 'nocompute' is given, the function will not attempt to guess the type if it is\n\
-still unknown. This is useful for debugging purposes.\n\
+still unknown.  This is useful for debugging purposes.\n\
 \n\
 The possible matrix types depend on whether the matrix is full or sparse, and can be\n\
 one of the following\n\
 \n\
 @table @asis\n\
 @item 'unknown'\n\
 Remove any previously cached matrix type, and mark type as unknown\n\
 \n\
diff --git a/src/DLD-FUNCTIONS/qr.cc b/src/DLD-FUNCTIONS/qr.cc
--- a/src/DLD-FUNCTIONS/qr.cc
+++ b/src/DLD-FUNCTIONS/qr.cc
@@ -98,45 +98,39 @@ r =\n\
 \n\
   -3.16228  -4.42719\n\
    0.00000  -0.63246\n\
 @end group\n\
 @end example\n\
 \n\
 The @code{qr} factorization has applications in the solution of least\n\
 squares problems\n\
-@iftex\n\
 @tex\n\
 $$\n\
 \\min_x \\left\\Vert A x - b \\right\\Vert_2\n\
 $$\n\
 @end tex\n\
-@end iftex\n\
 @ifnottex\n\
 \n\
 @example\n\
 @code{min norm(A x - b)}\n\
 @end example\n\
 \n\
 @end ifnottex\n\
 for overdetermined systems of equations (i.e.,\n\
-@iftex\n\
 @tex\n\
 $A$\n\
 @end tex\n\
-@end iftex\n\
 @ifnottex\n\
 @code{a}\n\
 @end ifnottex\n\
  is a tall, thin matrix).  The QR factorization is\n\
-@iftex\n\
 @tex\n\
 $QR = A$ where $Q$ is an orthogonal matrix and $R$ is upper triangular.\n\
 @end tex\n\
-@end iftex\n\
 @ifnottex\n\
 @code{q * r = a} where @code{q} is an orthogonal matrix and @code{r} is\n\
 upper triangular.\n\
 @end ifnottex\n\
 \n\
 If given a second argument of '0', @code{qr} returns an economy-sized\n\
 QR factorization, omitting zero rows of @var{R} and the corresponding\n\
 columns of @var{Q}.\n\
diff --git a/src/DLD-FUNCTIONS/qz.cc b/src/DLD-FUNCTIONS/qz.cc
--- a/src/DLD-FUNCTIONS/qz.cc
+++ b/src/DLD-FUNCTIONS/qz.cc
@@ -208,36 +208,32 @@ DEFUN_DLD (qz, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{lambda} =} qz (@var{a}, @var{b})\n\
 Generalized eigenvalue problem @math{A x = s B x},\n\
 @var{QZ} decomposition.  There are three ways to call this function:\n\
 @enumerate\n\
 @item @code{lambda = qz(A,B)}\n\
 \n\
 Computes the generalized eigenvalues\n\
-@iftex\n\
 @tex\n\
 $\\lambda$\n\
 @end tex\n\
-@end iftex\n\
 @ifnottex\n\
 @var{lambda}\n\
 @end ifnottex\n\
 of @math{(A - s B)}.\n\
 @item @code{[AA, BB, Q, Z, V, W, lambda] = qz (A, B)}\n\
 \n\
 Computes qz decomposition, generalized eigenvectors, and \n\
 generalized eigenvalues of @math{(A - sB)}\n\
-@iftex\n\
 @tex\n\
 $$ AV = BV{ \\rm diag }(\\lambda) $$\n\
 $$ W^T A = { \\rm diag }(\\lambda)W^T B $$\n\
 $$ AA = Q^T AZ, BB = Q^T BZ $$\n\
 @end tex\n\
-@end iftex\n\
 @ifnottex\n\
 @example\n\
 @group\n\
 \n\
     A*V = B*V*diag(lambda)\n\
     W'*A = diag(lambda)*W'*B\n\
     AA = Q'*A*Z, BB = Q'*B*Z\n\
 \n\
diff --git a/src/DLD-FUNCTIONS/rand.cc b/src/DLD-FUNCTIONS/rand.cc
--- a/src/DLD-FUNCTIONS/rand.cc
+++ b/src/DLD-FUNCTIONS/rand.cc
@@ -1020,18 +1020,18 @@ D 50 p1284, 1994\n\
 */
 
 DEFUN_DLD (randperm, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} randperm (@var{n})\n\
 @deftypefnx {Loadable Function} {} randperm (@var{n}, @var{m})\n\
 Return a row vector containing a random permutation of @code{1:@var{n}}.\n\
 If @var{m} is supplied, return @var{m} permutations,\n\
-one in each row of a NxM matrix. The complexity is O(M*N) in both time and\n\
-memory. The randomization is performed using rand().\n\
+one in each row of a NxM matrix.  The complexity is O(M*N) in both time and\n\
+memory.  The randomization is performed using rand().\n\
 All permutations are equally likely.\n\
 @seealso{perms}\n\
 @end deftypefn")
 {
   int nargin = args.length ();
   octave_value retval;
 
   if (nargin == 1 || nargin == 2)
diff --git a/src/DLD-FUNCTIONS/schur.cc b/src/DLD-FUNCTIONS/schur.cc
--- a/src/DLD-FUNCTIONS/schur.cc
+++ b/src/DLD-FUNCTIONS/schur.cc
@@ -42,210 +42,168 @@ DEFUN_DLD (schur, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{s} =} schur (@var{a})\n\
 @deftypefnx {Loadable Function} {[@var{u}, @var{s}] =} schur (@var{a}, @var{opt})\n\
 @cindex Schur decomposition\n\
 The Schur decomposition is used to compute eigenvalues of a\n\
 square matrix, and has applications in the solution of algebraic\n\
 Riccati equations in control (see @code{are} and @code{dare}).\n\
 @code{schur} always returns\n\
-@iftex\n\
 @tex\n\
 $S = U^T A U$\n\
 @end tex\n\
-@end iftex\n\
 @ifnottex\n\
 @code{s = u' * a * u}\n\
 @end ifnottex\n\
 where\n\
-@iftex\n\
 @tex\n\
 $U$\n\
 @end tex\n\
-@end iftex\n\
 @ifnottex\n\
 @code{u}\n\
 @end ifnottex\n\
  is a unitary matrix\n\
-@iftex\n\
 @tex\n\
 ($U^T U$ is identity)\n\
 @end tex\n\
-@end iftex\n\
 @ifnottex\n\
 (@code{u'* u} is identity)\n\
 @end ifnottex\n\
 and\n\
-@iftex\n\
 @tex\n\
 $S$\n\
 @end tex\n\
-@end iftex\n\
 @ifnottex\n\
 @code{s}\n\
 @end ifnottex\n\
 is upper triangular.  The eigenvalues of\n\
-@iftex\n\
 @tex\n\
 $A$ (and $S$)\n\
 @end tex\n\
-@end iftex\n\
 @ifnottex\n\
 @code{a} (and @code{s})\n\
 @end ifnottex\n\
 are the diagonal elements of\n\
-@iftex\n\
 @tex\n\
 $S$.\n\
 @end tex\n\
-@end iftex\n\
 @ifnottex\n\
 @code{s}.\n\
 @end ifnottex\n\
 If the matrix\n\
-@iftex\n\
 @tex\n\
 $A$\n\
 @end tex\n\
-@end iftex\n\
 @ifnottex\n\
 @code{a}\n\
 @end ifnottex\n\
 is real, then the real Schur decomposition is computed, in which the\n\
 matrix\n\
-@iftex\n\
 @tex\n\
 $U$\n\
 @end tex\n\
-@end iftex\n\
 @ifnottex\n\
 @code{u}\n\
 @end ifnottex\n\
 is orthogonal and\n\
-@iftex\n\
 @tex\n\
 $S$\n\
 @end tex\n\
-@end iftex\n\
 @ifnottex\n\
 @code{s}\n\
 @end ifnottex\n\
 is block upper triangular\n\
 with blocks of size at most\n\
-@iftex\n\
 @tex\n\
 $2\\times 2$\n\
 @end tex\n\
-@end iftex\n\
 @ifnottex\n\
 @code{2 x 2}\n\
 @end ifnottex\n\
 along the diagonal.  The diagonal elements of\n\
-@iftex\n\
 @tex\n\
 $S$\n\
 @end tex\n\
-@end iftex\n\
 @ifnottex\n\
 @code{s}\n\
 @end ifnottex\n\
 (or the eigenvalues of the\n\
-@iftex\n\
 @tex\n\
 $2\\times 2$\n\
 @end tex\n\
-@end iftex\n\
 @ifnottex\n\
 @code{2 x 2}\n\
 @end ifnottex\n\
 blocks, when\n\
 appropriate) are the eigenvalues of\n\
-@iftex\n\
 @tex\n\
 $A$\n\
 @end tex\n\
-@end iftex\n\
 @ifnottex\n\
 @code{a}\n\
 @end ifnottex\n\
 and\n\
-@iftex\n\
 @tex\n\
 $S$.\n\
 @end tex\n\
-@end iftex\n\
 @ifnottex\n\
 @code{s}.\n\
 @end ifnottex\n\
 \n\
 The eigenvalues are optionally ordered along the diagonal according to\n\
 the value of @code{opt}.  @code{opt = \"a\"} indicates that all\n\
 eigenvalues with negative real parts should be moved to the leading\n\
 block of\n\
-@iftex\n\
 @tex\n\
 $S$\n\
 @end tex\n\
-@end iftex\n\
 @ifnottex\n\
 @code{s}\n\
 @end ifnottex\n\
 (used in @code{are}), @code{opt = \"d\"} indicates that all eigenvalues\n\
 with magnitude less than one should be moved to the leading block of\n\
-@iftex\n\
 @tex\n\
 $S$\n\
 @end tex\n\
-@end iftex\n\
 @ifnottex\n\
 @code{s}\n\
 @end ifnottex\n\
 (used in @code{dare}), and @code{opt = \"u\"}, the default, indicates that\n\
 no ordering of eigenvalues should occur.  The leading\n\
-@iftex\n\
 @tex\n\
 $k$\n\
 @end tex\n\
-@end iftex\n\
 @ifnottex\n\
 @code{k}\n\
 @end ifnottex\n\
 columns of\n\
-@iftex\n\
 @tex\n\
 $U$\n\
 @end tex\n\
-@end iftex\n\
 @ifnottex\n\
 @code{u}\n\
 @end ifnottex\n\
 always span the\n\
-@iftex\n\
 @tex\n\
 $A$-invariant\n\
 @end tex\n\
-@end iftex\n\
 @ifnottex\n\
 @code{a}-invariant\n\
 @end ifnottex\n\
 subspace corresponding to the\n\
-@iftex\n\
 @tex\n\
 $k$\n\
 @end tex\n\
-@end iftex\n\
 @ifnottex\n\
 @code{k}\n\
 @end ifnottex\n\
 leading eigenvalues of\n\
-@iftex\n\
 @tex\n\
 $S$.\n\
 @end tex\n\
-@end iftex\n\
 @ifnottex\n\
 @code{s}.\n\
 @end ifnottex\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
diff --git a/src/DLD-FUNCTIONS/svd.cc b/src/DLD-FUNCTIONS/svd.cc
--- a/src/DLD-FUNCTIONS/svd.cc
+++ b/src/DLD-FUNCTIONS/svd.cc
@@ -38,37 +38,33 @@ along with Octave; see the file COPYING.
 #include "utils.h"
 
 DEFUN_DLD (svd, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{s} =} svd (@var{a})\n\
 @deftypefnx {Loadable Function} {[@var{u}, @var{s}, @var{v}] =} svd (@var{a})\n\
 @cindex singular value decomposition\n\
 Compute the singular value decomposition of @var{a}\n\
-@iftex\n\
 @tex\n\
 $$\n\
  A = U S V^H\n\
 $$\n\
 @end tex\n\
-@end iftex\n\
 @ifnottex\n\
 \n\
 @example\n\
 A = U*S*V'\n\
 @end example\n\
 @end ifnottex\n\
 \n\
 The function @code{svd} normally returns the vector of singular values.\n\
 If asked for three return values, it computes\n\
-@iftex\n\
 @tex\n\
 $U$, $S$, and $V$.\n\
 @end tex\n\
-@end iftex\n\
 @ifnottex\n\
 U, S, and V.\n\
 @end ifnottex\n\
 For example,\n\
 \n\
 @example\n\
 svd (hilb (3))\n\
 @end example\n\
diff --git a/src/DLD-FUNCTIONS/syl.cc b/src/DLD-FUNCTIONS/syl.cc
--- a/src/DLD-FUNCTIONS/syl.cc
+++ b/src/DLD-FUNCTIONS/syl.cc
@@ -32,23 +32,21 @@ along with Octave; see the file COPYING.
 #include "gripes.h"
 #include "oct-obj.h"
 #include "utils.h"
 
 DEFUN_DLD (syl, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{x} =} syl (@var{a}, @var{b}, @var{c})\n\
 Solve the Sylvester equation\n\
-@iftex\n\
 @tex\n\
 $$\n\
  A X + X B + C = 0\n\
 $$\n\
 @end tex\n\
-@end iftex\n\
 @ifnottex\n\
 \n\
 @example\n\
 A X + X B + C = 0\n\
 @end example\n\
 @end ifnottex\n\
 using standard @sc{lapack} subroutines.  For example,\n\
 \n\
diff --git a/src/DLD-FUNCTIONS/typecast.cc b/src/DLD-FUNCTIONS/typecast.cc
--- a/src/DLD-FUNCTIONS/typecast.cc
+++ b/src/DLD-FUNCTIONS/typecast.cc
@@ -84,40 +84,42 @@ reinterpret_copy (const void *data, octa
     }
 }
 
 
 DEFUN_DLD (typecast, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} typecast (@var{x}, @var{class})\n\
 Returns a new array @var{y} resulting from interpreting the data of\n\
-@var{x} in memory as data of the numeric class @var{class}. Both the class\n\
+@var{x} in memory as data of the numeric class @var{class}.  Both the class\n\
 of @var{x} and @var{class} must be one of the built-in numeric classes:\n\
 \n\
 @example\n\
+@group\n\
   \"logical\"\n\
   \"char\"\n\
   \"int8\"\n\
   \"int16\"\n\
   \"int32\"\n\
   \"int64\"\n\
   \"uint8\"\n\
   \"uint16\"\n\
   \"uint32\"\n\
   \"uint64\"\n\
   \"double\"\n\
   \"single\"\n\
   \"double complex\"\n\
   \"single complex\"\n\
+@end group\n\
 @end example\n\
 \n\
 the last two are reserved for @var{class}; they indicate that a complex-valued result\n\
-is requested. Complex arrays are stored in memory as consecutive pairs of real numbers.\n\
-The sizes of integer types are given by their bit counts. Both logical and char are typically\n\
-one byte wide; however, this is not guaranteed by C++. If your system is IEEE conformant,\n\
+is requested.  Complex arrays are stored in memory as consecutive pairs of real numbers.\n\
+The sizes of integer types are given by their bit counts.  Both logical and char are typically\n\
+one byte wide; however, this is not guaranteed by C++.  If your system is IEEE conformant,\n\
 single and double should be 4 bytes and 8 bytes wide, respectively.\n\
 \"logical\" is not allowed for @var{class}.\n\
 If the input is a row vector, the return value is a row vector, otherwise it is a column vector.\n\
 If the bit length of @var{x} is not divisible by that of @var{class}, an error occurs.\n\
 @seealso{bitunpack,bitpack}\n\
 \n\
 An example of the use of typecast on a little-endian machine is\n\
 \n\
@@ -264,35 +266,37 @@ do_bitpack (const boolNDArray& bitp)
       return ArrayType ();
     }
 }
 
 DEFUN_DLD (bitpack, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{y} =} bitpack (@var{x}, @var{class})\n\
 Returns a new array @var{y} resulting from interpreting a logical array @var{x}\n\
-as raw bit pattern for data of the numeric class @var{class}. @var{class} must be\n\
+as raw bit pattern for data of the numeric class @var{class}.  @var{class} must be\n\
 one of the built-in numeric classes:\n\
 \n\
 @example\n\
+@group\n\
   \"char\"\n\
   \"int8\"\n\
   \"int16\"\n\
   \"int32\"\n\
   \"int64\"\n\
   \"uint8\"\n\
   \"uint16\"\n\
   \"uint32\"\n\
   \"uint64\"\n\
   \"double\"\n\
   \"single\"\n\
+@end group\n\
 @end example\n\
 \n\
 The number of elements of @var{x} should be divisible by the bit length of @var{class}.\n\
-If it is not, excess bits are discarded. Bits come in increasing order of significance, i.e.\n\
+If it is not, excess bits are discarded.  Bits come in increasing order of significance, i.e.\n\
 @code{x(1)} is bit 0, @code{x(2)} is bit 1, etc.\n\
 The result is a row vector if @var{x} is a row vector, otherwise it is a column vector.\n\
 @seealso{bitunpack,typecast,bitget,bitset}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 2 && args(0).is_bool_type ())
@@ -373,27 +377,29 @@ do_bitunpack (const ArrayType& array)
 
 DEFUN_DLD (bitunpack, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{y} =} bitpack (@var{x})\n\
 Returns a logical array @var{y} corresponding to the raw bit pattern of @var{x}.\n\
 @var{x} must belong to one of the built-in numeric classes:\n\
 \n\
 @example\n\
+@group\n\
   \"char\"\n\
   \"int8\"\n\
   \"int16\"\n\
   \"int32\"\n\
   \"int64\"\n\
   \"uint8\"\n\
   \"uint16\"\n\
   \"uint32\"\n\
   \"uint64\"\n\
   \"double\"\n\
   \"single\"\n\
+@end group\n\
 @end example\n\
 \n\
 The result is a row vector if @var{x} is a row vector, otherwise it is a column vector.\n\
 @seealso{bitpack,typecast,bitget,bitset}\n\
 @end deftypefn")
 {
   octave_value retval;
 
diff --git a/src/data.cc b/src/data.cc
--- a/src/data.cc
+++ b/src/data.cc
@@ -2424,17 +2424,17 @@ DEFUN (numel, args, ,
 @deftypefnx {Built-in Function} {} numel (@var{a}, @var{idx1}, @var{idx2}, @dots{})\n\
 Returns the number of elements in the object @var{a}.\n\
 Optionally, if indices @var{idx1}, @var{idx2}, @dots{} are supplied,\n\
 return the number of elements that would result from the indexing\n\
 @example\n\
   @var{a}(@var{idx1}, @var{idx2}, @dots{})\n\
 @end example\n\
 This method is also called when an object appears as lvalue with cs-list\n\
-indexing, i.e. @code{object@{@dots{}@}} or @code{object(@dots{}).field}.\n\
+indexing, i.e., @code{object@{@dots{}@}} or @code{object(@dots{}).field}.\n\
 @seealso{size}\n\
 @end deftypefn")
 {
   octave_value retval;
   octave_idx_type nargin = args.length ();
 
   if (nargin == 1)
     retval = args(0).numel ();
@@ -2670,18 +2670,18 @@ sum ([true, true], 'native')\n\
   @result{} true\n\
 @end group\n\
 @end example\n\
   \n\
 On the contrary, if 'double' is given, the sum is performed in double precision\n\
 even for single precision inputs.\n\
 \n\
 For double precision inputs, 'extra' indicates that a more accurate algorithm\n\
-than straightforward summation is to be used. For single precision inputs, 'extra' is\n\
-the same as 'double'. Otherwise, 'extra' has no effect.\n\
+than straightforward summation is to be used.  For single precision inputs, 'extra' is\n\
+the same as 'double'.  Otherwise, 'extra' has no effect.\n\
 @seealso{cumsum, sumsq, prod}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   bool isnative = false;
@@ -2995,19 +2995,21 @@ DEFUN (complex, args, ,
 @deftypefnx {Built-in Function} {} complex (@var{re}, @var{im})\n\
 Return a complex result from real arguments.  With 1 real argument @var{x},\n\
 return the complex result @code{@var{x} + 0i}.  With 2 real arguments,\n\
 return the complex result @code{@var{re} + @var{im}}.  @code{complex} can\n\
 often be more convenient than expressions such as @code{a + i*b}.\n\
 For example:\n\
 \n\
 @example\n\
+@group\n\
 complex ([1, 2], [3, 4])\n\
 @result{}\n\
    1 + 3i   2 + 4i\n\
+@end group\n\
 @end example\n\
 @seealso{real, imag, iscomplex}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
@@ -4643,17 +4645,17 @@ DEFUN (linspace, args, ,
 Return a row vector with @var{n} linearly spaced elements between\n\
 @var{base} and @var{limit}.  If the number of elements is greater than one,\n\
 then the @var{base} and @var{limit} are always included in\n\
 the range.  If @var{base} is greater than @var{limit}, the elements are\n\
 stored in decreasing order.  If the number of points is not specified, a\n\
 value of 100 is used.\n\
 \n\
 The @code{linspace} function always returns a row vector if both\n\
-@var{base} and @var{limit} are scalars. If one of them or both are column\n\
+@var{base} and @var{limit} are scalars.  If one of them or both are column\n\
 vectors, @code{linspace} returns a matrix.\n\
 \n\
 For compatibility with @sc{matlab}, return the second argument if\n\
 fewer than two values are requested.\n\
 @end deftypefn")
 {
   octave_value retval;
 
@@ -6379,27 +6381,29 @@ do_merge (const Array<bool>& mask,
                          fval.INTX ## _array_value ()); \
     }
 
 DEFUN (merge, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} merge (@var{mask}, @var{tval}, @var{fval})\n\
 @deftypefnx {Built-in Function} {} ifelse (@var{mask}, @var{tval}, @var{fval})\n\
 Merges elements of @var{true_val} and @var{false_val}, depending on the value of\n\
-@var{mask}. If @var{mask} is a logical scalar, the other two arguments can be\n\
-arbitrary values. Otherwise, @var{mask} must be a logical array, and @var{tval},\n\
+@var{mask}.  If @var{mask} is a logical scalar, the other two arguments can be\n\
+arbitrary values.  Otherwise, @var{mask} must be a logical array, and @var{tval},\n\
 @var{fval} should be arrays of matching class, or cell arrays.\n\
 In the scalar mask case, @var{tval} is returned if @var{mask} is true, otherwise\n\
 @var{fval} is returned.\n\
 \n\
 In the array mask case, both @var{tval} and @var{fval} must be either scalars or\n\
-arrays with dimensions equal to @var{mask}. The result is constructed as follows:\n\
+arrays with dimensions equal to @var{mask}.  The result is constructed as follows:\n\
 @example\n\
+@group\n\
 result(mask) = tval(mask);\n\
 result(! mask) = fval(! mask);\n\
+@end group\n\
 @end example\n\
 \n\
 @var{mask} can also be arbitrary numeric type, in which case\n\
 it is first converted to logical.\n\
 @seealso{logical}\n\
 @end deftypefn")
 {
   int nargin = args.length ();
diff --git a/src/file-io.cc b/src/file-io.cc
--- a/src/file-io.cc
+++ b/src/file-io.cc
@@ -394,17 +394,17 @@ If there are no more characters to read,
     print_usage ();
 
   return retval;
 }
 
 DEFUN (fskipl, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} fskipl (@var{fid}, @var{count})\n\
-Skips a given number of lines, i.e. discards characters until an end-of-line\n\
+Skips a given number of lines, i.e., discards characters until an end-of-line\n\
 is met exactly @var{count}-times, or end-of-file occurs.\n\
 Returns the number of lines skipped (end-of-line sequences encountered).\n\
 If @var{count} is omitted, it defaults to 1. @var{count} may also be\n\
 @code{Inf}, in which case lines are skipped to the end of file.\n\
 This form is suitable for counting lines in a file.\n\
 @seealso{fgetl, fgets}\n\
 @end deftypefn")
 {
diff --git a/src/mappers.cc b/src/mappers.cc
--- a/src/mappers.cc
+++ b/src/mappers.cc
@@ -504,23 +504,21 @@ Compute the hyperbolic cosine for each e
 %!error cosh (1, 2);
 
 */
 
 DEFUN (erf, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} erf (@var{z})\n\
 Computes the error function,\n\
-@iftex\n\
 @tex\n\
 $$\n\
  {\\rm erf} (z) = {2 \\over \\sqrt{\\pi}}\\int_0^z e^{-t^2} dt\n\
 $$\n\
 @end tex\n\
-@end iftex\n\
 @ifnottex\n\
 \n\
 @example\n\
 @group\n\
                          z\n\
                         /\n\
 erf (z) = (2/sqrt (pi)) | e^(-t^2) dt\n\
                         /\n\
@@ -569,21 +567,19 @@ erf (z) = (2/sqrt (pi)) | e^(-t^2) dt\n\
 
 
 */
 
 DEFUN (erfc, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} erfc (@var{z})\n\
 Computes the complementary error function,\n\
-@iftex\n\
 @tex\n\
 $1 - {\\rm erf} (z)$.\n\
 @end tex\n\
-@end iftex\n\
 @ifnottex\n\
 @code{1 - erf (@var{z})}.\n\
 @end ifnottex\n\
 @seealso{erf, erfinv}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
@@ -770,23 +766,21 @@ floor ([-2.7, 2.7])\n\
 %!error floor (1, 2);
 
 */
 
 DEFUN (gamma, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} gamma (@var{z})\n\
 Computes the Gamma function,\n\
-@iftex\n\
 @tex\n\
 $$\n\
  \\Gamma (z) = \\int_0^\\infty t^{z-1} e^{-t} dt.\n\
 $$\n\
 @end tex\n\
-@end iftex\n\
 @ifnottex\n\
 \n\
 @example\n\
 @group\n\
             infinity\n\
             /\n\
 gamma (z) = | t^(z-1) exp (-t) dt.\n\
             /\n\
diff --git a/src/pr-output.cc b/src/pr-output.cc
--- a/src/pr-output.cc
+++ b/src/pr-output.cc
@@ -3581,32 +3581,32 @@ it switches to an exponential @samp{e} f
 @item long\n\
 Fixed point format with 15 significant figures in a field that is a maximum\n\
 of 20 characters wide.\n\
 \n\
 As with the @samp{short} format, Octave will switch to an exponential\n\
 @samp{e} format if it is unable to format a matrix properly using the\n\
 current format.\n\
 \n\
-@item  short e\n\
+@item short e\n\
 @itemx long e\n\
 Exponential format.  The number to be represented is split between a mantissa\n\
 and an exponent (power of 10).  The mantissa has 5 significant digits in the\n\
 short format and 15 digits in the long format.\n\
 For example, with the @samp{short e} format, @code{pi} is displayed as\n\
 @code{3.1416e+00}.\n\
 \n\
-@item  short E\n\
+@item short E\n\
 @itemx long E\n\
 Identical to @samp{short e} or @samp{long e} but displays an uppercase\n\
 @samp{E} to indicate the exponent.\n\
 For example, with the @samp{long E} format, @code{pi} is displayed as\n\
 @code{3.14159265358979E+00}.\n\
 \n\
-@item  short g\n\
+@item short g\n\
 @itemx long g\n\
 Optimally choose between fixed point and exponential format based on\n\
 the magnitude of the number.\n\
 For example, with the @samp{short g} format,\n\
 @code{pi .^ [2; 4; 8; 16; 32]} is displayed as\n\
 \n\
 @example\n\
 @group\n\
diff --git a/src/utils.cc b/src/utils.cc
--- a/src/utils.cc
+++ b/src/utils.cc
@@ -1254,17 +1254,17 @@ octave_sleep (double seconds)
       octave_sleep (sec);
       octave_usleep (usec);
     }
 }
 
 DEFUN (isindex, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} isindex (@var{ind}, @var{n})\n\
-Returns true if @var{ind} is a valid index. Valid indices can be\n\
+Returns true if @var{ind} is a valid index.  Valid indices can be\n\
 either positive integers (though possibly real data), or logical arrays.\n\
 If present, @var{n} specifies the extent of the dimension to be indexed.\n\
 Note that, if possible, the internal conversion result is cached so that\n\
 subsequent indexing will not perform the checking again.\n\
 @end deftypefn")
 {
   octave_value retval;
   int nargin = args.length ();
