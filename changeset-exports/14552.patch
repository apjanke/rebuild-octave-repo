# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1334196420 14400
#      Wed Apr 11 22:07:00 2012 -0400
# Node ID 86854d032a377fe9f335ce32524104f54c925323
# Parent  60ed9260399abf05f9704ff7381426c5126bc091
maint: miscellaneous style fixes for .m files

* audio/mu2lin.m, deprecated/cut.m, general/cplxpair.m,
general/genvarname.m, geometry/rectint.m, help/gen_doc_cache.m,
image/hsv2rgb.m, image/rainbow.m, io/textscan.m,
miscellaneous/bzip2.m, miscellaneous/compare_versions.m,
miscellaneous/fact.m, miscellaneous/menu.m, optimization/fminbnd.m,
optimization/fminunc.m, optimization/fzero.m, optimization/sqp.m,
plot/__gnuplot_drawnow__.m, plot/axis.m, plot/findobj.m,
plot/legend.m, plot/peaks.m, plot/private/__errplot__.m,
plot/private/__fltk_print__.m, plot/private/__go_draw_axes__.m,
plot/private/__patch__.m, polynomial/pchip.m, polynomial/residue.m,
signal/periodogram.m, sparse/sprandsym.m, statistics/base/moment.m,
statistics/distributions/expcdf.m, statistics/distributions/expinv.m,
statistics/distributions/exppdf.m, statistics/tests/prop_test_2.m,
statistics/tests/sign_test.m, statistics/tests/t_test.m,
statistics/tests/t_test_2.m, statistics/tests/t_test_regression.m,
strings/regexptranslate.m, time/datetick.m:
Style fixes.

diff --git a/scripts/audio/mu2lin.m b/scripts/audio/mu2lin.m
--- a/scripts/audio/mu2lin.m
+++ b/scripts/audio/mu2lin.m
@@ -36,31 +36,31 @@ function y = mu2lin (x, n = 0)
   if (nargin == 2)
     if (n != 0 && n != 8 && n != 16)
       error ("mu2lin: N must be either 0, 8, or 16");
     endif
   elseif (nargin != 1)
     print_usage ();
   endif
 
-  ulaw = [32124, 31100, 30076, 29052, 28028, 27004, 25980, 24956, \
-          23932, 22908, 21884, 20860, 19836, 18812, 17788, 16764, \
-          15996, 15484, 14972, 14460, 13948, 13436, 12924, 12412, \
-          11900, 11388, 10876, 10364,  9852,  9340,  8828,  8316, \
-           7932,  7676,  7420,  7164,  6908,  6652,  6396,  6140, \
-           5884,  5628,  5372,  5116,  4860,  4604,  4348,  4092, \
-           3900,  3772,  3644,  3516,  3388,  3260,  3132,  3004, \
-           2876,  2748,  2620,  2492,  2364,  2236,  2108,  1980, \
-           1884,  1820,  1756,  1692,  1628,  1564,  1500,  1436, \
-           1372,  1308,  1244,  1180,  1116,  1052,   988,   924, \
-            876,   844,   812,   780,   748,   716,   684,   652, \
-            620,   588,   556,   524,   492,   460,   428,   396, \
-            372,   356,   340,   324,   308,   292,   276,   260, \
-            244,   228,   212,   196,   180,   164,   148,   132, \
-            120,   112,   104,    96,    88,    80,    72,    64, \
+  ulaw = [32124, 31100, 30076, 29052, 28028, 27004, 25980, 24956, ...
+          23932, 22908, 21884, 20860, 19836, 18812, 17788, 16764, ...
+          15996, 15484, 14972, 14460, 13948, 13436, 12924, 12412, ...
+          11900, 11388, 10876, 10364,  9852,  9340,  8828,  8316, ...
+           7932,  7676,  7420,  7164,  6908,  6652,  6396,  6140, ...
+           5884,  5628,  5372,  5116,  4860,  4604,  4348,  4092, ...
+           3900,  3772,  3644,  3516,  3388,  3260,  3132,  3004, ...
+           2876,  2748,  2620,  2492,  2364,  2236,  2108,  1980, ...
+           1884,  1820,  1756,  1692,  1628,  1564,  1500,  1436, ...
+           1372,  1308,  1244,  1180,  1116,  1052,   988,   924, ...
+            876,   844,   812,   780,   748,   716,   684,   652, ...
+            620,   588,   556,   524,   492,   460,   428,   396, ...
+            372,   356,   340,   324,   308,   292,   276,   260, ...
+            244,   228,   212,   196,   180,   164,   148,   132, ...
+            120,   112,   104,    96,    88,    80,    72,    64, ...
              56,    48,    40,    32,    24,    16,     8,     0 ];
 
   ulaw = [ -ulaw, ulaw ];
 
   ## Set the shape of y to that of x overwrites the contents of y with
   ## ulaw of x.
   y = x;
   y(:) = ulaw (x + 1);
diff --git a/scripts/deprecated/cut.m b/scripts/deprecated/cut.m
--- a/scripts/deprecated/cut.m
+++ b/scripts/deprecated/cut.m
@@ -46,26 +46,26 @@ function group = cut (x, breaks)
 
   if (nargin != 2)
     print_usage ();
   endif
 
   if (!isvector (x))
     error ("cut: X must be a vector");
   endif
-  if isscalar (breaks)
+  if (isscalar (breaks))
     breaks = linspace (min (x), max (x), breaks + 1);
     breaks(1) = breaks(1) - 1;
-  elseif isvector (breaks)
+  elseif (isvector (breaks))
     breaks = sort (breaks);
   else
     error ("cut: BREAKS must be a scalar or vector");
   endif
 
   group = NaN (size (x));
   m = length (breaks);
-  if any (k = find ((x >= min (breaks)) & (x < max (breaks))))
+  if (any (k = find ((x >= min (breaks)) & (x < max (breaks)))))
     n = length (k);
     group(k) = sum ((ones (m, 1) * reshape (x(k), 1, n))
                     >= (reshape (breaks, m, 1) * ones (1, n)));
   endif
 
 endfunction
diff --git a/scripts/general/cplxpair.m b/scripts/general/cplxpair.m
--- a/scripts/general/cplxpair.m
+++ b/scripts/general/cplxpair.m
@@ -47,17 +47,17 @@
 ## FIXME: Why doesn't exp(2i*pi*[0:4]'/5) produce exact conjugates. Does
 ## FIXME:    it in Matlab?  The reason is that complex pairs are supposed
 ## FIXME:    to be exact conjugates, and not rely on a tolerance test.
 
 ## 2006-05-12 David Bateman - Modified for NDArrays
 
 function y = cplxpair (z, tol, dim)
 
-  if nargin < 1 || nargin > 3
+  if (nargin < 1 || nargin > 3)
     print_usage ();
   endif
 
   if (length (z) == 0)
     y = zeros (size (z));
     return;
   endif
 
diff --git a/scripts/general/genvarname.m b/scripts/general/genvarname.m
--- a/scripts/general/genvarname.m
+++ b/scripts/general/genvarname.m
@@ -153,25 +153,25 @@ function varname = genvarname (str, excl
     excluded = any (strcmp (str{i}, exclusions));
     if (excluded && ismember (str{i}(end), "0":"9"))
       ## if it is not unique and ends with a digit, add an underscore to
       ## make the variable name more readable ("x1_1" instead of "x11")
       str{i}(end+1) = "_";
     endif
     varname(i) = str(i);
     idx = 0;
-    while excluded
+    while (excluded)
       idx++;
       varname{i} = sprintf("%s%d", str{i}, idx);
       excluded = any (strcmp (varname{i}, exclusions));
     endwhile
     exclusions(end+1) = varname(i);
   endfor
 
-  if strinput
+  if (strinput)
     varname = varname{1};
   endif
 
 endfunction
 
 
 ## a single argument
 %!assert (genvarname ("a"), "a")
diff --git a/scripts/geometry/rectint.m b/scripts/geometry/rectint.m
--- a/scripts/geometry/rectint.m
+++ b/scripts/geometry/rectint.m
@@ -38,17 +38,17 @@ function area = rectint (a, b)
   if (nargin != 2)
     print_usage ();
   elseif (ndims (a) != 2 || ndims (b) != 2)
     error ("rectint: expecting arguments to be 2-d arrays");
   elseif (columns (a) != 4)
     error ("rectint: A must have 4 columns");
   elseif (columns (b) != 4)
     error ("rectint: B must have 4 columns");
-  elseif any ([a(:,3:4);b(:,3:4)](:) < 0)
+  elseif (any ([a(:,3:4);b(:,3:4)](:) < 0))
     error ("rectint: all widths and heights must be > 0");
   endif
 
   ## This runs faster if the number of rows of a is greater than the
   ## number of rows of b.  Swap them and transpose to make it run
   ## faster.
   swapinputs = false ();
   if (rows (a) > rows (b))
@@ -100,17 +100,17 @@ function area = rectint (a, b)
     mask = r1y1mid & r1y2large;
     area(mask,i) .*= r2(i,4) - r1(mask,2);
     ## the range goes from r1x min to r1x max
     mask = r1y1mid & r1y2mid;
     area(mask,i) .*= r1(mask,4) - r1(mask,2);
 
   endfor
 
-  if swapinputs
+  if (swapinputs)
     area = area';
   endif
 
 endfunction
 
 
 ## Exactly overlapping
 %!assert (rectint ([0 0 1 1], [0 0 1 1]), 1)
diff --git a/scripts/help/gen_doc_cache.m b/scripts/help/gen_doc_cache.m
--- a/scripts/help/gen_doc_cache.m
+++ b/scripts/help/gen_doc_cache.m
@@ -29,29 +29,29 @@
 ## operators, etc. is generated.
 ##
 ## @seealso{lookfor, path}
 ## @end deftypefn
 
 function gen_doc_cache (out_file = "doc-cache", directory = [])
 
   ## Check input
-  if (!ischar (out_file))
+  if (! ischar (out_file))
     print_usage ();
   endif
 
   ## Generate cache
   if (isempty (directory))
     cache = gen_builtin_cache ();
   elseif (iscell (directory))
-    if all(cellfun (@ischar, directory))
+    if (all (cellfun (@ischar, directory)))
       cache = gen_doc_cache_in_dir (directory);
     else
       error ("gen_doc_cache: cell must contain only strings");
-    end
+    endif
   elseif (ischar (directory))
      cache = gen_doc_cache_in_dir (directory);
   else
      error ("gen_doc_cache: second input argument must be a string or a cell of strings");
   endif
 
   ## Save cache
   if (! isempty (cache))
@@ -115,37 +115,37 @@ function cache = create_cache (list)
 endfunction
 
 function cache = gen_doc_cache_in_dir (directory)
 
   ## If 'directory' is not in the current path, add it so we search it
   dir_in_path = ismember (directory, strsplit (path (), pathsep ()));
 
   # dirs not in path
-  if !iscell (directory)
+  if (! iscell (directory))
     directory = {directory};
-  end
+  endif
   dirs_notpath = {directory{!dir_in_path}};
 
   # add them
-  if !isempty (dirs_notpath)
+  if (! isempty (dirs_notpath))
     cellfun (@addpath, dirs_notpath);
-  end
+  endif
 
   # create cache
   func = @(s_) create_cache (__list_functions__ (s_));
   cache = cellfun (func, directory, 'UniformOutput', false);
 
   # concatenate results
   cache = [cache{:}];
 
   #remove dirs form path
-  if !isempty (dirs_notpath)
+  if (! isempty (dirs_notpath))
     cellfun (@rmpath, dirs_notpath);
-  end
+  endif
 
 endfunction
 
 function cache = gen_builtin_cache ()
   operators = __operators__ ();
   keywords = __keywords__ ();
   builtins = __builtins__ ();
   list = {operators{:}, keywords{:}, builtins{:}};
diff --git a/scripts/image/hsv2rgb.m b/scripts/image/hsv2rgb.m
--- a/scripts/image/hsv2rgb.m
+++ b/scripts/image/hsv2rgb.m
@@ -54,17 +54,17 @@ function rgb_map = hsv2rgb (hsv_map)
     is_image = false;
   endif
 
   if (! ismatrix (hsv_map) || columns (hsv_map) != 3)
     error ("hsv2rgb: argument must be a matrix of size nx3");
   endif
 
   ## set values <0 to 0 and >1 to 1
-  hsv_map = (hsv_map >= 0 & hsv_map <= 1) .* hsv_map \
+  hsv_map = (hsv_map >= 0 & hsv_map <= 1) .* hsv_map ...
       + (hsv_map < 0) .* 0 + (hsv_map > 1);
 
   ## fill rgb map with v*(1-s)
   rgb_map = kron ([1, 1, 1], hsv_map(:,3) .* (1 - hsv_map(:,2)));
 
   ## red(hue-2/3)=green(hue)=blue(hue-1/3)
   ## apply modulo 1 for red and blue
   t = hsv_map(:,1);
diff --git a/scripts/image/rainbow.m b/scripts/image/rainbow.m
--- a/scripts/image/rainbow.m
+++ b/scripts/image/rainbow.m
@@ -43,26 +43,25 @@ function map = rainbow (n)
     print_usage ();
   endif
 
   if (n == 1)
     map = [1, 0, 0];
   elseif (n > 1)
     x = linspace (0, 1, n)';
 
-    r = (x < 2/5) \
-        + (x >= 2/5 & x < 3/5) .* (-5 * x + 3) \
-        + (x >= 4/5) .* (10/3 * x - 8/3);
+    r = ((x < 2/5)
+         + (x >= 2/5 & x < 3/5) .* (-5 * x + 3)
+         + (x >= 4/5) .* (10/3 * x - 8/3));
 
-    g = (x < 2/5) .* (5/2 * x) \
-        + (x >= 2/5 & x < 3/5) \
-        + (x >= 3/5 & x < 4/5) .* (-5 * x + 4);
+    g = ((x < 2/5) .* (5/2 * x)
+         + (x >= 2/5 & x < 3/5)
+         + (x >= 3/5 & x < 4/5) .* (-5 * x + 4));
 
-    b = (x >= 3/5 & x < 4/5) .* (5 * x - 3) \
-        + (x >= 4/5);
+    b = (x >= 3/5 & x < 4/5) .* (5 * x - 3) + (x >= 4/5);
 
     map = [r, g, b];
   else
     map = [];
   endif
 
 endfunction
 
diff --git a/scripts/io/textscan.m b/scripts/io/textscan.m
--- a/scripts/io/textscan.m
+++ b/scripts/io/textscan.m
@@ -229,20 +229,20 @@ function [C, position] = textscan (fid, 
 endfunction
 
 
 ## Collect consecutive columns of same class into one cell column
 function C = colloutp (C)
 
   ## Start at rightmost column and work backwards to avoid ptr mixup
   ii = numel (C);
-  while ii > 1
+  while (ii > 1)
     clss1 = class (C{ii});
     jj = ii;
-    while  (jj > 1 && strcmp (clss1, class (C{jj - 1})))
+    while (jj > 1 && strcmp (clss1, class (C{jj - 1})))
       ## Column to the left is still same class; check next column to the left
       --jj;
     endwhile
     if (jj < ii)
       ## Concatenate columns into current column
       C{jj} = [C{jj : ii}];
       ## Wipe concatenated columns to the right, resume search to the left
       C(jj+1 : ii) = [];
diff --git a/scripts/miscellaneous/bzip2.m b/scripts/miscellaneous/bzip2.m
--- a/scripts/miscellaneous/bzip2.m
+++ b/scripts/miscellaneous/bzip2.m
@@ -26,17 +26,17 @@
 ## are silently overwritten.  If @var{outdir} is defined the compressed
 ## files are placed in this directory.
 ## @seealso{bunzip2, gzip, zip, tar}
 ## @end deftypefn
 
 function entries = bzip2 (varargin)
 
   if (nargin == 1 || nargin == 2)
-    if nargout == 0
+    if (nargout == 0)
       __xzip__ ("bzip2", "bz2", "bzip2 %s", varargin{:});
     else
       entries = __xzip__ ("bzip2", "bz2", "bzip2 %s", varargin{:});
     endif
   else
     print_usage ();
   endif
 
diff --git a/scripts/miscellaneous/compare_versions.m b/scripts/miscellaneous/compare_versions.m
--- a/scripts/miscellaneous/compare_versions.m
+++ b/scripts/miscellaneous/compare_versions.m
@@ -136,32 +136,32 @@ function out = compare_versions (v1, v2,
   if (length (v1c) < maxcharlen)
     v1c(length(v1c)+1:maxcharlen) = "\0";
   endif
   if (length (v2c) < maxcharlen)
     v2c(length(v2c)+1:maxcharlen) = "\0";
   endif
 
   ## Determine the operator.
-  if any (ismember (operator, "="))
+  if (any (ismember (operator, "=")))
     equal_op = true;
   else
     equal_op = false;
   endif
-  if any (ismember (operator, "~!"))
+  if (any (ismember (operator, "~!")))
     not_op = true;
   else
     not_op = false;
   endif
-  if any (ismember (operator, "<"))
+  if (any (ismember (operator, "<")))
     lt_op = true;
   else
     lt_op = false;
   endif
-  if any (ismember (operator, ">"))
+  if (any (ismember (operator, ">")))
     gt_op = true;
   else
     gt_op = false;
   endif
 
   ## Make sure that we don't have conflicting operators.
   if (gt_op && lt_op)
     error ("compare_versions: OPERATOR cannot contain both greater and less than symbols");
diff --git a/scripts/miscellaneous/fact.m b/scripts/miscellaneous/fact.m
--- a/scripts/miscellaneous/fact.m
+++ b/scripts/miscellaneous/fact.m
@@ -19,18 +19,18 @@
 
 ## -*- texinfo -*-
 ## @deftypefn  {Command} {} fact
 ## @deftypefnx {Function File} {T =} fact()
 ## Display an amazing and random fact about the world's greatest hacker.
 ## @end deftypefn
 
 
-function f = fact()
-  persistent wisdom = \
+function f = fact ()
+  persistent wisdom = ...
       {
        "Richard Stallman takes notes in binary.";
        "Richard Stallman doesn't need sudo. I will make him a sandwich anyway.";
        "Richard Stallman is my shephurd, and I am his GNU.";
        "Richard Stallman doesn't wget, Richard Stallman wdemands!";
        "Richard Stallman can touch MC Hammer.";
        "Richard Stallman doesn't read web pages. They write to him.";
        "Richard Stallman gets 9 bits to the byte.";
@@ -235,33 +235,34 @@ function f = fact()
        "Richard Stallman's beard trimmings can cure cancer. Too bad he never shaves.";
        "Richard Stallman's doesn't kill a process; he just dares it to stay running.";
        "Richard Stallman exists because he compiled himself into being.";
        "Richard Stallman's first words were in binary. When they couldn't understand him, he wrote a parser.";
        "Richard Stallman doesn't need any codecs, he just opens a multimedia file with Emacs, and reads the bytes of the file as plain text. He then performs all the necessary decoding in his mind. But he refuses to decode files encrypted with DRM, although his mind is able to.";
        };
 
   w = wisdom{randi([1, numel(wisdom)])};
-  if nargout > 0
+  if (nargout > 0)
     f = w;
   else
     w = wordwrap (w);
     printf ("%s", w);
   endif
 endfunction
 
 function out = wordwrap (w)
   cols = terminal_size ()(2);
   wc = strsplit (w, " ");
   out = "\n";
   i = 1;
   numwords = numel (wc);
-  while i <= numwords;
+  while (i <= numwords);
     line = wc{i};
-    while (i < numwords && length (newline = cstrcat (line, " ", wc{i+1})) < cols)
+    while (i < numwords
+           && length (newline = cstrcat (line, " ", wc{i+1})) < cols)
       line = newline;
       i++;
     endwhile
     out = cstrcat (out, line, "\n");
     i++;
   endwhile
-  out = cstrcat(out, "\n");
+  out = cstrcat (out, "\n");
 endfunction
\ No newline at end of file
diff --git a/scripts/miscellaneous/menu.m b/scripts/miscellaneous/menu.m
--- a/scripts/miscellaneous/menu.m
+++ b/scripts/miscellaneous/menu.m
@@ -46,17 +46,17 @@ function num = menu (title, varargin)
 
   ## Process Supplied Options
   if (nargin == 2)
     ## List in a cell array
     if (iscell (varargin{1}))
       varargin = varargin{1};
       nopt = length (varargin);
       for i = 1:nopt
-        while iscell (varargin{i})
+        while (iscell (varargin{i}))
           varargin{i} = varargin{i}{1};
         endwhile
       endfor
     else
       nopt = nargin - 1;
     endif
   else
     ## List with random elements in it - pick the first always
diff --git a/scripts/optimization/fminbnd.m b/scripts/optimization/fminbnd.m
--- a/scripts/optimization/fminbnd.m
+++ b/scripts/optimization/fminbnd.m
@@ -51,18 +51,18 @@
 
 ## PKG_ADD: ## Discard result to avoid polluting workspace with ans at startup.
 ## PKG_ADD: [~] = __all_opts__ ("fminbnd");
 
 function [x, fval, info, output] = fminbnd (fun, xmin, xmax, options = struct ())
 
   ## Get default options if requested.
   if (nargin == 1 && ischar (fun) && strcmp (fun, 'defaults'))
-    x = optimset ("MaxIter", Inf, "MaxFunEvals", Inf, "TolX", 1e-8, \
-    "OutputFcn", [], "FunValCheck", "off");
+    x = optimset ("MaxIter", Inf, "MaxFunEvals", Inf, "TolX", 1e-8,
+                  "OutputFcn", [], "FunValCheck", "off");
     return;
   endif
 
   if (nargin < 2 || nargin > 4)
     print_usage ();
   endif
 
   if (ischar (fun))
diff --git a/scripts/optimization/fminunc.m b/scripts/optimization/fminunc.m
--- a/scripts/optimization/fminunc.m
+++ b/scripts/optimization/fminunc.m
@@ -79,21 +79,21 @@
 
 ## PKG_ADD: ## Discard result to avoid polluting workspace with ans at startup.
 ## PKG_ADD: [~] = __all_opts__ ("fminunc");
 
 function [x, fval, info, output, grad, hess] = fminunc (fcn, x0, options = struct ())
 
   ## Get default options if requested.
   if (nargin == 1 && ischar (fcn) && strcmp (fcn, 'defaults'))
-    x = optimset ("MaxIter", 400, "MaxFunEvals", Inf, \
-    "GradObj", "off", "TolX", 1e-7, "TolFun", 1e-7,
-    "OutputFcn", [], "FunValCheck", "off",
-    "FinDiffType", "central",
-    "TypicalX", [], "AutoScaling", "off");
+    x = optimset ("MaxIter", 400, "MaxFunEvals", Inf,
+                  "GradObj", "off", "TolX", 1e-7, "TolFun", 1e-7,
+                  "OutputFcn", [], "FunValCheck", "off",
+                  "FinDiffType", "central",
+                  "TypicalX", [], "AutoScaling", "off");
     return;
   endif
 
   if (nargin < 2 || nargin > 3 || ! ismatrix (x0))
     print_usage ();
   endif
 
   if (ischar (fcn))
diff --git a/scripts/optimization/fzero.m b/scripts/optimization/fzero.m
--- a/scripts/optimization/fzero.m
+++ b/scripts/optimization/fzero.m
@@ -95,18 +95,18 @@
 
 ## PKG_ADD: ## Discard result to avoid polluting workspace with ans at startup.
 ## PKG_ADD: [~] = __all_opts__ ("fzero");
 
 function [x, fval, info, output] = fzero (fun, x0, options = struct ())
 
   ## Get default options if requested.
   if (nargin == 1 && ischar (fun) && strcmp (fun, 'defaults'))
-    x = optimset ("MaxIter", Inf, "MaxFunEvals", Inf, "TolX", 1e-8, \
-    "OutputFcn", [], "FunValCheck", "off");
+    x = optimset ("MaxIter", Inf, "MaxFunEvals", Inf, "TolX", 1e-8,
+                  "OutputFcn", [], "FunValCheck", "off");
     return;
   endif
 
   if (nargin < 2 || nargin > 3)
     print_usage ();
   endif
 
   if (ischar (fun))
diff --git a/scripts/optimization/sqp.m b/scripts/optimization/sqp.m
--- a/scripts/optimization/sqp.m
+++ b/scripts/optimization/sqp.m
@@ -692,18 +692,18 @@ endfunction
 function res = cf_ub_lb (x, lbidx, ubidx)
 
   ## combine constraint function with ub and lb
   global __sqp_cifcn__ __sqp_lb__ __sqp_ub__
 
   if (isempty (__sqp_cifcn__))
     res = [x(lbidx,1)-__sqp_lb__; __sqp_ub__-x(ubidx,1)];
   else
-    res = [feval(__sqp_cifcn__,x); \
-           x(lbidx,1)-__sqp_lb__; __sqp_ub__-x(ubidx,1)];
+    res = [feval(__sqp_cifcn__,x); x(lbidx,1)-__sqp_lb__;
+           __sqp_ub__-x(ubidx,1)];
   endif
 
 endfunction
 
 
 function res = cigrad_ub_lb (x, bgrad)
 
   global __sqp_cif__
diff --git a/scripts/plot/__gnuplot_drawnow__.m b/scripts/plot/__gnuplot_drawnow__.m
--- a/scripts/plot/__gnuplot_drawnow__.m
+++ b/scripts/plot/__gnuplot_drawnow__.m
@@ -254,19 +254,19 @@ function enhanced = gnuplot_set_term (pl
           size_str = "";
           warning ("gnuplot_set_term: size is zero");
         endif
       else
         ## A specified size take priority over the figure properies.
         size_str = "";
       endif
     else
-      if isempty (h)
+      if (isempty (h))
         disp ("gnuplot_set_term: figure handle is empty");
-      elseif !isfigure(h)
+      elseif (! isfigure (h))
         disp ("gnuplot_set_term: not a figure handle");
       endif
       title_str = "";
       size_str = "";
     endif
 
     ## Set the gnuplot terminal (type, enhanced, title, options & size).
     term_str = sprintf ("set terminal %s", term);
diff --git a/scripts/plot/axis.m b/scripts/plot/axis.m
--- a/scripts/plot/axis.m
+++ b/scripts/plot/axis.m
@@ -175,17 +175,17 @@ function curr_axis = __axis__ (ca, ax, v
       set (ca, "ydir", "normal");
 
       ## aspect ratio
     elseif (strcmpi (ax, "image"))
       __axis__ (ca, "equal");
       __do_tight_option__ (ca);
     elseif (strcmpi (ax, "square"))
       set (ca, "plotboxaspectratio", [1, 1, 1]);
-    elseif  (strcmp (ax, "equal"))
+    elseif (strcmp (ax, "equal"))
       if (strcmp (get (get (ca, "parent"), "__graphics_toolkit__"), "gnuplot"))
         ## FIXME - gnuplot applies the aspect ratio activepostionproperty.
         set (ca, "activepositionproperty", "position");
         ## The following line is a trick used to trigger the recalculation of
         ## aspect related magnitudes even if the aspect ratio is the same
         ## (useful with the x11 gnuplot terminal after a window resize)
         set (ca, "dataaspectratiomode", "auto");
       endif
@@ -316,17 +316,17 @@ function lims = __get_tight_lims__ (ca, 
   if (isempty (kids))
     ## Return the current limits.
     lims = get (ca, strcat (ax, "lim"));
   else
     data = get (kids, strcat (ax, "data"));
     scale = get (ca, strcat (ax, "scale"));
     if (! iscell (data))
       data = {data};
-    end
+    endif
     if (strcmp (scale, "log"))
       tmp = data;
       data = cellfun (@(x) x(x>0), tmp, "uniformoutput", false);
       n = cellfun (@isempty, data);
       data(n) = cellfun (@(x) x(x<0), tmp(n), "uniformoutput", false);
     endif
     data = cellfun (@(x) x(isfinite(x)), data, "uniformoutput", false);
     data = data(! cellfun ("isempty", data));
@@ -341,17 +341,17 @@ function lims = __get_tight_lims__ (ca, 
 
 endfunction
 
 function __do_tight_option__ (ca)
 
   set (ca,
        "xlim", __get_tight_lims__ (ca, "x"),
        "ylim", __get_tight_lims__ (ca, "y"));
-  if __calc_dimensions__ (ca) > 2
+  if (__calc_dimensions__ (ca) > 2)
     set (ca, "zlim", __get_tight_lims__ (ca, "z"));
   endif
 
 endfunction
 
 
 %!demo
 %! clf;
diff --git a/scripts/plot/findobj.m b/scripts/plot/findobj.m
--- a/scripts/plot/findobj.m
+++ b/scripts/plot/findobj.m
@@ -143,42 +143,42 @@ function h = findobj (varargin)
         ## Parameter/value pairs.
         if (na + 1 <= numel (args))
           pname{np} = args{na};
           na = na + 1;
           pvalue{np} = args{na};
           na = na + 1;
           if (na <= numel(args))
             if (ischar (args{na}))
-              if strcmpi(args{na}, "-and")
+              if (strcmpi (args{na}, "-and"))
                 logicaloperator{np} = "and";
                 na = na+1;
-              elseif strcmpi(args{na}, "-or")
+              elseif (strcmpi (args{na}, "-or"))
                 logicaloperator{np} = "or";
                 na = na+1;
-              elseif strcmpi(args{na}, "-xor")
+              elseif (strcmpi (args{na}, "-xor"))
                 logicaloperator{np} = "xor";
                 na = na+1;
-              elseif strcmpi(args{na}, "-not")
+              elseif (strcmpi (args{na}, "-not"))
                 logicaloperator{np} = "not";
                 na = na+1;
               endif
             else
               error ("findobj: properties and options must be strings");
             endif
           else
             logicaloperator{np} = "and";
           endif
           np = np + 1;
         else
           error ("findobj: inconsistent number of arguments");
         endif
       else
         ## This is sloppy ... but works like Matlab.
-        if strcmpi(args{na}, "-not")
+        if (strcmpi (args{na}, "-not"))
           h = [];
           return
         endif
         na = na + 1;
       endif
     else
       error ("findobj: properties and options must be strings");
     endif
@@ -208,17 +208,17 @@ function h = findobj (varargin)
         fieldindex = find (strcmpi (fields, pname{np}), 1);
         if (numel (fieldindex))
           pname{np} = fields{fieldindex};
           if (property(np))
             match = 1;
           else
             if (regularexpression(np))
               match = regexp (p.(pname{np}), pvalue{np});
-              if isempty (match)
+              if (isempty (match))
                 match = 0;
               endif
             elseif (numel (p.(pname{np})) == numel (pvalue{np}))
               if (ischar (pvalue{np}))
                 match = strcmpi (pvalue{np}, p.(pname{np}));
               else
                 match = (pvalue{np} == p.(pname{np}));
               endif
diff --git a/scripts/plot/legend.m b/scripts/plot/legend.m
--- a/scripts/plot/legend.m
+++ b/scripts/plot/legend.m
@@ -299,17 +299,17 @@ function [hlegend2, hobjects2, hplot2, t
       set (hlegend, "box", "off", "visible", "off");
     endif
   elseif (nargs == 0 && !(strcmp (position, "default") &&
                           strcmp (orientation, "default")))
     if (! isempty (hlegend))
       hax = getfield (get (hlegend, "userdata"), "handle");
       [hplots, text_strings] = __getlegenddata__ (hlegend);
 
-      if  (strcmp (position, "default"))
+      if (strcmp (position, "default"))
         h = legend (hax, hplots, text_strings, "orientation", orientation);
       elseif (strcmp (orientation, "default"))
         if (outside)
           h = legend (hax, hplots, text_strings, "location",
                       strcat (position, "outside"));
         else
           h = legend (hax, hplots, text_strings, "location", position);
         endif
diff --git a/scripts/plot/peaks.m b/scripts/plot/peaks.m
--- a/scripts/plot/peaks.m
+++ b/scripts/plot/peaks.m
@@ -50,32 +50,32 @@
 ## Expression for the peaks function was taken from the following paper:
 ## http://www.control.hut.fi/Kurssit/AS-74.115/Material/GENALGgoga.pdf
 
 function [X_out, Y_out, Z_out] = peaks (x, y)
 
   if (nargin == 0)
     x = y = linspace (-3, 3, 49);
   elseif (nargin == 1)
-    if length(x) > 1
+    if (length (x) > 1)
       y = x;
     else
       x = y = linspace (-3, 3, x);
     endif
   endif
 
   if (isvector (x) && isvector (y))
     [X, Y] = meshgrid (x, y);
   else
     X = x;
     Y = y;
   endif
 
-  Z = 3 * (1 - X) .^ 2 .* exp(- X .^ 2 - (Y + 1) .^ 2) \
-      - 10 * (X / 5 - X .^ 3 - Y .^ 5) .* exp(- X .^ 2 - Y .^ 2) \
+  Z = 3 * (1 - X) .^ 2 .* exp(- X .^ 2 - (Y + 1) .^ 2) ...
+      - 10 * (X / 5 - X .^ 3 - Y .^ 5) .* exp(- X .^ 2 - Y .^ 2) ...
       - 1 / 3 * exp(- (X + 1) .^ 2 - Y .^ 2);
 
   if (nargout == 0)
     surf (x, y, Z);
   elseif (nargout == 1)
     X_out = Z;
   else
     X_out = X;
diff --git a/scripts/plot/private/__errplot__.m b/scripts/plot/private/__errplot__.m
--- a/scripts/plot/private/__errplot__.m
+++ b/scripts/plot/private/__errplot__.m
@@ -214,17 +214,17 @@ function h = __errplot__ (fstr, p, varar
     else
       [hlgnd, tlgnd] = __getlegenddata__ (hlegend);
     endif
  
     hlgnd(end+1) = hg;
     tlgnd(end+1) = fmt.key;
 
     legend (gca(), hlgnd, tlgnd);
-  end 
+  endif
 
 endfunction
 
 function [xdata, ydata] = errorbar_data (xdata, ydata, ldata, udata,
                                          xldata, xudata, ifmt,
                                          xscale, yscale)
   if (strcmp (xscale, "linear"))
     dx = 0.01 * (max (xdata(:)) - min (xdata(:)));
diff --git a/scripts/plot/private/__fltk_print__.m b/scripts/plot/private/__fltk_print__.m
--- a/scripts/plot/private/__fltk_print__.m
+++ b/scripts/plot/private/__fltk_print__.m
@@ -148,17 +148,17 @@ function opts = __fltk_print__ (opts)
 
   opts.pipeline = pipeline;
 
   ## Tell gl2ps to use different rendering options for 2D plots
   haxes = findall (opts.figure, "type", "axes");
   vw = get (haxes, "view");
   if (iscell (vw))
     vw = vertcat (vw{:});
-  end
+  endif
   is2D = all (abs (vw(:,2)) == 90);
   if (is2D)
     gl2ps_device{end} = [gl2ps_device{end}, "is2D"];
   endif
 
   for n = 1:numel(pipeline)
     if (opts.debug)
       fprintf ("fltk-pipeline: '%s'\n", pipeline{n});
diff --git a/scripts/plot/private/__go_draw_axes__.m b/scripts/plot/private/__go_draw_axes__.m
--- a/scripts/plot/private/__go_draw_axes__.m
+++ b/scripts/plot/private/__go_draw_axes__.m
@@ -2317,17 +2317,17 @@ function str = no_super_sub_scripts (str
   endif
   for marker = "_^" 
     for m = 1 : numel(labels)
       n1 = strfind (labels{m}, sprintf ("\\%s", marker));
       n2 = strfind (labels{m}, marker);
       if (! isempty (n1))
         n1 = n1 + 1;
         n2 = setdiff (n2, n1);
-      end
+      endif
       for n = numel(n2):-1:1
         labels{m} = [labels{m}(1:n2(n)-1), "\\", labels{m}(n2(n):end)];
       endfor
     endfor
   endfor
   if (iscellstr (str))
     str = labels;
   else
diff --git a/scripts/plot/private/__patch__.m b/scripts/plot/private/__patch__.m
--- a/scripts/plot/private/__patch__.m
+++ b/scripts/plot/private/__patch__.m
@@ -321,17 +321,17 @@ function args = setvertexdata (args)
     endif
     args = {"facecolor", fc, args{:}};
   endif
 
   [nr, nc] = size (x);
   if (nr == 1 && nc > 1)
     nr = nc;
     nc = 1;
-  end
+  endif
   if (!isempty (z))
     vert = [x(:), y(:), z(:)];
   else
     vert = [x(:), y(:)];
   endif
   faces = reshape (1:numel(x), nr, nc);
   faces = faces';
 
diff --git a/scripts/polynomial/pchip.m b/scripts/polynomial/pchip.m
--- a/scripts/polynomial/pchip.m
+++ b/scripts/polynomial/pchip.m
@@ -74,34 +74,34 @@ function ret = pchip (x, y, xi)
   ## make row vector
   x = x(:).';
   n = length (x);
 
   ## Check the size and shape of y
   if (isvector (y))
     y = y(:).'; ##row vector
     szy = size (y);
-    if !(size_equal (x, y))
+    if (! size_equal (x, y))
       error ("pchip: length of X and Y must match")
     endif
   else
     szy = size (y);
     if (n != szy(end))
       error ("pchip: length of X and last dimension of Y must match")
     endif
     y = reshape (y, [prod(szy(1:end-1)), szy(end)]);
   endif
 
   h = diff (x);
   if (all (h < 0))
     x = fliplr (x);
     h = diff (x);
     y = fliplr (y);
   elseif (any (h <= 0))
-    error("pchip: X must be strictly monotonic");
+    error ("pchip: X must be strictly monotonic");
   endif
 
   f1 = y(:, 1:n-1);
 
   ## Compute derivatives.
   d = __pchip_deriv__ (x, y, 2);
   d1 = d(:, 1:n-1);
   d2 = d(:, 2:n);
diff --git a/scripts/polynomial/residue.m b/scripts/polynomial/residue.m
--- a/scripts/polynomial/residue.m
+++ b/scripts/polynomial/residue.m
@@ -280,29 +280,29 @@ function [pnum, pden, e] = rresidue (r, 
   if (nargin < 4)
     toler = [];
   endif
 
   if (nargin < 3)
     k = [];
   endif
 
-  if numel (e)
+  if (numel (e))
     indx = 1:numel(p);
   else
     [e, indx] = mpoles (p, toler, 0);
     p = p (indx);
     r = r (indx);
   endif
 
   indx = 1:numel(p);
 
   for n = indx
     pn = [1, -p(n)];
-    if n == 1
+    if (n == 1)
       pden = pn;
     else
       pden = conv (pden, pn);
     endif
   endfor
 
   ## D is the order of the denominator
   ## K is the order of the direct polynomial
diff --git a/scripts/signal/periodogram.m b/scripts/signal/periodogram.m
--- a/scripts/signal/periodogram.m
+++ b/scripts/signal/periodogram.m
@@ -117,17 +117,17 @@ function [pxx, f] = periodogram (x, vara
     error ("nfft must be scalar");
   endif
   if (isempty (nfft))
     nfft = max (256, 2.^ceil (log2 (r)));
   endif
 
   if (strcmp (range, "onesided"))
     range = 1;
-  elseif strcmp (range, "twosided")
+  elseif (strcmp (range, "twosided"))
     range = 2;
   else
     range = 2-isreal (x);
   endif
 
   ## compute periodogram
 
   if (r>nfft)
diff --git a/scripts/sparse/sprandsym.m b/scripts/sparse/sprandsym.m
--- a/scripts/sparse/sprandsym.m
+++ b/scripts/sparse/sprandsym.m
@@ -114,17 +114,17 @@ function r = pick_rand_diag (n, k)
   ## distribution function for computing the random number of entries on
   ## the diagonal R.
   ##
   ## Thanks to Zsbán Ambrus <ambrus@math.bme.hu> for most of the ideas
   ## of the implementation here, especially how to do the computation
   ## numerically to avoid overflow.
 
   ## Degenerate case
-  if k == 1
+  if (k == 1)
     r = 1;
     return
   endif
 
   ## Compute the stuff described above
   a = n*(n - 1)/2;
   d = [mod(k,2):2:min(n,k)-2];
   m = (k - d)/2;
diff --git a/scripts/statistics/base/moment.m b/scripts/statistics/base/moment.m
--- a/scripts/statistics/base/moment.m
+++ b/scripts/statistics/base/moment.m
@@ -160,17 +160,17 @@ function m = moment (x, p, opt1, opt2)
     endif
   endif
 
   n = sz(dim);
 
   if (any (type == "c"))
     x = center (x, dim);
   endif
-  if any (type == "a")
+  if (any (type == "a"))
     x = abs (x);
   endif
 
   m = sum (x .^ p, dim) / n;
 
 endfunction
 
 
diff --git a/scripts/statistics/distributions/expcdf.m b/scripts/statistics/distributions/expcdf.m
--- a/scripts/statistics/distributions/expcdf.m
+++ b/scripts/statistics/distributions/expcdf.m
@@ -54,20 +54,20 @@ function cdf = expcdf (x, lambda)
 
   k = isnan (x) | !(lambda > 0);
   cdf(k) = NaN;
 
   k = (x == Inf) & (lambda > 0);
   cdf(k) = 1;
 
   k = (x > 0) & (x < Inf) & (lambda > 0);
-  if isscalar (lambda)
-    cdf(k) = 1 - exp (- x(k) / lambda);
+  if (isscalar (lambda))
+    cdf(k) = 1 - exp (-x(k) / lambda);
   else
-    cdf(k) = 1 - exp (- x(k) ./ lambda(k));
+    cdf(k) = 1 - exp (-x(k) ./ lambda(k));
   endif
 
 endfunction
 
 
 %!shared x,y
 %! x = [-1 0 0.5 1 Inf];
 %! y = [0, 1 - exp(-x(2:end)/2)];
diff --git a/scripts/statistics/distributions/expinv.m b/scripts/statistics/distributions/expinv.m
--- a/scripts/statistics/distributions/expinv.m
+++ b/scripts/statistics/distributions/expinv.m
@@ -58,17 +58,17 @@ function inv = expinv (x, lambda)
   else
     inv = NaN (size (x));
   endif
 
   k = (x == 1) & (lambda > 0);
   inv(k) = Inf;
 
   k = (x >= 0) & (x < 1) & (lambda > 0);
-  if isscalar (lambda)
+  if (isscalar (lambda))
     inv(k) = - lambda * log (1 - x(k));
   else
     inv(k) = - lambda(k) .* log (1 - x(k));
   endif
 
 endfunction
 
 
diff --git a/scripts/statistics/distributions/exppdf.m b/scripts/statistics/distributions/exppdf.m
--- a/scripts/statistics/distributions/exppdf.m
+++ b/scripts/statistics/distributions/exppdf.m
@@ -48,20 +48,20 @@ function pdf = exppdf (x, lambda)
   else
     pdf = zeros (size (x));
   endif
 
   k = isnan (x) | !(lambda > 0);
   pdf(k) = NaN;
 
   k = (x >= 0) & (x < Inf) & (lambda > 0);
-  if isscalar (lambda)
-    pdf(k) = exp (- x(k) / lambda) / lambda;
+  if (isscalar (lambda))
+    pdf(k) = exp (-x(k) / lambda) / lambda;
   else
-    pdf(k) = exp (- x(k) ./ lambda(k)) ./ lambda(k);
+    pdf(k) = exp (-x(k) ./ lambda(k)) ./ lambda(k);
   endif
 
 endfunction
 
 
 %!shared x,y
 %! x = [-1 0 0.5 1 Inf];
 %! y = gampdf (x, 1, 2);
diff --git a/scripts/statistics/tests/prop_test_2.m b/scripts/statistics/tests/prop_test_2.m
--- a/scripts/statistics/tests/prop_test_2.m
+++ b/scripts/statistics/tests/prop_test_2.m
@@ -60,19 +60,19 @@ function [pval, z] = prop_test_2 (x1, n1
     alt  = "!=";
   endif
 
   if (! ischar (alt))
     error ("prop_test_2: ALT must be a string");
   endif
   if (strcmp (alt, "!=") || strcmp (alt, "<>"))
     pval = 2 * min (cdf, 1 - cdf);
-  elseif strcmp (alt, ">")
+  elseif (strcmp (alt, ">"))
     pval = 1 - cdf;
-  elseif strcmp (alt, "<")
+  elseif (strcmp (alt, "<"))
     pval = cdf;
   else
     error ("prop_test_2: option %s not recognized", alt);
   endif
 
   if (nargout == 0)
     printf ("  pval: %g\n", pval);
   endif
diff --git a/scripts/statistics/tests/sign_test.m b/scripts/statistics/tests/sign_test.m
--- a/scripts/statistics/tests/sign_test.m
+++ b/scripts/statistics/tests/sign_test.m
@@ -63,19 +63,19 @@ function [pval, b, n] = sign_test (x, y,
     alt  = "!=";
   endif
 
   if (! ischar (alt))
     error ("sign_test: ALT must be a string");
   endif
   if (strcmp (alt, "!=") || strcmp (alt, "<>"))
     pval = 2 * min (cdf, 1 - cdf);
-  elseif strcmp (alt, ">")
+  elseif (strcmp (alt, ">"))
     pval = 1 - cdf;
-  elseif strcmp (alt, "<")
+  elseif (strcmp (alt, "<"))
     pval = cdf;
   else
     error ("sign_test: option %s not recognized", alt);
   endif
 
   if (nargout == 0)
     printf ("  pval: %g\n", pval);
   endif
diff --git a/scripts/statistics/tests/t_test.m b/scripts/statistics/tests/t_test.m
--- a/scripts/statistics/tests/t_test.m
+++ b/scripts/statistics/tests/t_test.m
@@ -63,19 +63,19 @@ function [pval, t, df] = t_test (x, m, a
     alt  = "!=";
   endif
 
   if (! ischar (alt))
     error ("t_test: ALT must be a string");
   endif
   if (strcmp (alt, "!=") || strcmp (alt, "<>"))
     pval = 2 * min (cdf, 1 - cdf);
-  elseif strcmp (alt, ">")
+  elseif (strcmp (alt, ">"))
     pval = 1 - cdf;
-  elseif strcmp (alt, "<")
+  elseif (strcmp (alt, "<"))
     pval = cdf;
   else
     error ("t_test: option %s not recognized", alt);
   endif
 
   if (nargout == 0)
     printf ("  pval: %g\n", pval);
   endif
diff --git a/scripts/statistics/tests/t_test_2.m b/scripts/statistics/tests/t_test_2.m
--- a/scripts/statistics/tests/t_test_2.m
+++ b/scripts/statistics/tests/t_test_2.m
@@ -64,19 +64,19 @@ function [pval, t, df] = t_test_2 (x, y,
     alt = "!=";
   endif
 
   if (! ischar (alt))
     error ("t_test_2: ALT must be a string");
   endif
   if (strcmp (alt, "!=") || strcmp (alt, "<>"))
     pval = 2 * min (cdf, 1 - cdf);
-  elseif strcmp (alt, ">")
+  elseif (strcmp (alt, ">"))
     pval = 1 - cdf;
-  elseif strcmp (alt, "<")
+  elseif (strcmp (alt, "<"))
     pval = cdf;
   else
     error ("t_test_2: option %s not recognized", alt);
   endif
 
   if (nargout == 0)
     printf ("  pval: %g\n", pval);
   endif
diff --git a/scripts/statistics/tests/t_test_regression.m b/scripts/statistics/tests/t_test_regression.m
--- a/scripts/statistics/tests/t_test_regression.m
+++ b/scripts/statistics/tests/t_test_regression.m
@@ -76,19 +76,19 @@ function [pval, t, df] = t_test_regressi
   y      = reshape (y, T, 1);
   [b, v] = ols (y, x);
   df     = T - k;
   t      = (rr * b - r) / sqrt (v * rr * inv (x' * x) * rr');
   cdf    = tcdf (t, df);
 
   if (strcmp (alt, "!=") || strcmp (alt, "<>"))
     pval = 2 * min (cdf, 1 - cdf);
-  elseif strcmp (alt, ">")
+  elseif (strcmp (alt, ">"))
     pval = 1 - cdf;
-  elseif strcmp (alt, "<")
+  elseif (strcmp (alt, "<"))
     pval = cdf;
   else
     error ("t_test_regression: the value `%s' for alt is not possible", alt);
   endif
 
   if (nargout == 0)
     printf ("pval: %g\n", pval);
   endif
diff --git a/scripts/strings/regexptranslate.m b/scripts/strings/regexptranslate.m
--- a/scripts/strings/regexptranslate.m
+++ b/scripts/strings/regexptranslate.m
@@ -48,17 +48,17 @@
 ## @end example
 ##
 ## @end table
 ## @seealso{regexp, regexpi, regexprep}
 ## @end deftypefn
 
 function y = regexptranslate (op, s)
 
-  if nargin != 2
+  if (nargin != 2)
     print_usage ();
   endif
 
   if (! ischar (op))
     error ("regexptranslate: operation OP must be a string");
   endif
 
   op = tolower (op);
diff --git a/scripts/time/datetick.m b/scripts/time/datetick.m
--- a/scripts/time/datetick.m
+++ b/scripts/time/datetick.m
@@ -194,32 +194,32 @@ function __datetick__ (varargin)
         xmax = datenum (sep * ceil (maxyear / sep), 1, 1);
         nticks = ceil (maxyear / sep) - floor (minyear / sep) + 1;
       endif
     endif
     ticks = xmin + [0 : nticks - 1] / (nticks - 1) * (xmax - xmin);
   endif
 
   if (isempty (form))
-    r = max(ticks) - min(ticks);
-    if r < 10/60/24
+    r = max (ticks) - min (ticks);
+    if (r < 10/60/24)
       ## minutes and seconds
       form = 13;
-    elseif r < 2
+    elseif (r < 2)
       ## hours
       form = 15;
-    elseif r < 15
+    elseif (r < 15)
       ## days
       form = 8;
-    elseif r < 365
+    elseif (r < 365)
       ## FIXME -- FORM should be 19 for European users who use dd/mm
       ## instead of mm/dd.  How can that be determined automatically?
       ## months
       form = 6;
-    elseif r < 90*12
+    elseif (r < 90*12)
       ## quarters
       form = 27;
     else
       ## years
       form = 10;
     endif
   endif
 
