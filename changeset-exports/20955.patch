# HG changeset patch
# User Rik <rik@octave.org>
# Date 1450635302 28800
#      Sun Dec 20 10:15:02 2015 -0800
# Node ID 77f5591878bf4033d33aa5c01262467acf22cc15
# Parent  6982def1d416d3a44895fa6d0e1a2cfed764cdd7
maint: Use '! expr' rather than '!expr' to conform to coding guidelines.

* dialog.h, documentation-dock-widget.cc, files-dock-widget.cc,
find-files-dialog.cc, file-editor-tab.cc, file-editor.cc, find-dialog.cc,
octave-qscintilla.cc, main-window.cc, parser.cc, resource-manager.cc,
workspace-view.cc, data.cc, dlmread.cc, gl-render.cc, gl2ps-renderer.cc,
graphics.cc, graphics.in.h, ls-hdf5.cc, ls-mat5.cc, ls-oct-binary.cc, lsode.cc,
mappers.cc, pt-jit.cc, regexp.cc, spparms.cc, symtab.h, utils.cc, zfstream.cc,
__eigs__.cc, __glpk__.cc, __init_fltk__.cc, ccolamd.cc, colamd.cc,
ov-base-diag.cc, ov-base-int.cc, ov-base-sparse.cc, ov-bool-mat.cc,
ov-bool-sparse.cc, ov-bool.cc, ov-class.cc, ov-cx-sparse.cc, ov-fcn-handle.cc,
ov-fcn-inline.cc, ov-java.cc, ov-perm.cc, ov-re-sparse.cc, ov-str-mat.cc,
ov-struct.cc, ov.cc, pt-mat.cc, Array.cc, Array.h, CMatrix.cc, CSparse.cc,
MatrixType.cc, PermMatrix.cc, Sparse.h, dMatrix.cc, dSparse.cc, fCMatrix.cc,
fMatrix.cc, idx-vector.cc, CollocWt.h, SparseCmplxLU.cc, SparseCmplxQR.cc,
SparseQR.cc, SparsedbleLU.cc, base-qr.cc, eigs-base.cc, oct-fftw.cc,
randmtzig.c, sparse-dmsolve.cc, kpse.cc, lo-regexp.cc, oct-locbuf.h,
url-transfer.cc, url-transfer.h, bitset.m, interp2.m, __isequal__.m,
inpolygon.m, questdlg.m, help.m, compare_versions.m, substruct.m,
configure_make.m, whitebg.m, __marching_cube__.m, struct2hdl.m, polyfit.m,
spline.m, unique.m, svds.m, ellipke.m, binoinv.m, hygepdf.m, nbininv.m,
poissinv.m, tcdf.m, unidcdf.m, unidpdf.m, dec2base.m, assert.m, weekday.m,
mkoctfile.in.cc:
maint: Use '! expr' rather than '!expr' to conform to coding guidelines.

diff --git a/libgui/src/dialog.h b/libgui/src/dialog.h
--- a/libgui/src/dialog.h
+++ b/libgui/src/dialog.h
@@ -55,17 +55,17 @@ public:
 
   void signal_dialog (const QString& message, const QString& title,
                       const QString& icon, const QStringList& button,
                       const QString& defbutton, const QStringList& role)
   {
 
     // Use the last button in the list as the reject result, i.e., when no
     // button is pressed such as in the case of the upper right close tab.
-    if (!button.isEmpty ())
+    if (! button.isEmpty ())
       dialog_button = button.last ();
 
     QString xicon = icon;
     if (xicon.isEmpty ())
       xicon = "none";
 
     emit create_dialog (message, title, xicon, button, defbutton, role);
   };
diff --git a/libgui/src/documentation-dock-widget.cc b/libgui/src/documentation-dock-widget.cc
--- a/libgui/src/documentation-dock-widget.cc
+++ b/libgui/src/documentation-dock-widget.cc
@@ -56,15 +56,15 @@ documentation_dock_widget::selectAll ()
 {
   _webinfo->selectAll ();
 }
 
 void
 documentation_dock_widget::showDoc (const QString &name)
 {
   // show the doc pane without focus for carrying on typing in the console
-  if (!isVisible ())
+  if (! isVisible ())
     setVisible (true);
   raise ();
 
   _webinfo->load_ref (name);
 
 }
diff --git a/libgui/src/files-dock-widget.cc b/libgui/src/files-dock-widget.cc
--- a/libgui/src/files-dock-widget.cc
+++ b/libgui/src/files-dock-widget.cc
@@ -807,18 +807,18 @@ files_dock_widget::notice_settings (cons
   _file_tree_view->setAlternatingRowColors (
     settings->value (_columns_shown_keys.at (4),true).toBool ());
   _file_tree_view->setModel (_file_system_model);
 
   // enable the buttons to sync octave/browser dir
   // only if this is not done by default
   _sync_octave_dir
     = settings->value ("filesdockwidget/sync_octave_directory",false).toBool ();
-  _sync_octave_directory_action->setEnabled (!_sync_octave_dir);
-  _sync_browser_directory_action->setEnabled (!_sync_octave_dir);
+  _sync_octave_directory_action->setEnabled (! _sync_octave_dir);
+  _sync_browser_directory_action->setEnabled (! _sync_octave_dir);
 
   if (_sync_octave_dir)
     display_directory (_octave_dir);  // sync browser to octave dir
 
 }
 
 void
 files_dock_widget::popdownmenu_home (bool)
diff --git a/libgui/src/find-files-dialog.cc b/libgui/src/find-files-dialog.cc
--- a/libgui/src/find-files-dialog.cc
+++ b/libgui/src/find-files-dialog.cc
@@ -251,17 +251,17 @@ find_files_dialog::start_find ()
   find_files_model *m = static_cast<find_files_model *> (_file_list->model ());
   m->clear ();
 
   QDirIterator::IteratorFlags flags = QDirIterator::NoIteratorFlags;
   if (_recurse_dirs_check->isChecked ())
     flags |= QDirIterator::Subdirectories;
 
   QDir::Filters filters = QDir::Dirs|QDir::NoDotAndDotDot|QDir::Files;
-  if (!_name_case_check->isChecked ())
+  if (! _name_case_check->isChecked ())
     filters |=  QDir::CaseSensitive;
 
   QStringList nameFilters;
   nameFilters.append (_file_name_edit->text ());
 
   if (_dir_iterator) delete _dir_iterator;
 
   _dir_iterator = new QDirIterator (_start_dir_edit->text (), nameFilters,
@@ -363,17 +363,17 @@ find_files_dialog::look_for_files ()
     }
 }
 
 bool find_files_dialog::is_match (const QFileInfo &info)
 {
   bool match = true;
   if (info.isDir ())
     {
-      if (!_include_dirs_check->isChecked ()) match = false;
+      if (! _include_dirs_check->isChecked ()) match = false;
       if (_contains_text_check->isChecked ()) match = false;
     }
   else
     {
       // a file
       if (_contains_text_check->isChecked ())
         {
           match = false;
@@ -389,17 +389,17 @@ bool find_files_dialog::is_match (const 
               Qt::CaseSensitivity cs = _content_case_check->isChecked () ?
                                        Qt::CaseInsensitive : Qt::CaseSensitive;
 
               do
                 {
                   line = stream.readLine ();
                   match = line.contains (match_str, cs);
                 }
-              while (!line.isNull () && match == false);
+              while (! line.isNull () && match == false);
             }
 
         }
     }
 
   return match;
 }
 
diff --git a/libgui/src/m-editor/file-editor-tab.cc b/libgui/src/m-editor/file-editor-tab.cc
--- a/libgui/src/m-editor/file-editor-tab.cc
+++ b/libgui/src/m-editor/file-editor-tab.cc
@@ -358,19 +358,19 @@ file_editor_tab::handle_context_menu_edi
   emit request_open_file (filename);
 }
 
 void
 file_editor_tab::set_file_name (const QString& fileName)
 {
   // update tracked file if we really have a file on disk
   QStringList trackedFiles = _file_system_watcher.files ();
-  if (!trackedFiles.isEmpty ())
+  if (! trackedFiles.isEmpty ())
     _file_system_watcher.removePath (_file_name);
-  if (!fileName.isEmpty ())
+  if (! fileName.isEmpty ())
     _file_system_watcher.addPath (fileName);
   _file_name = fileName;
 
   // update lexer after _file_name change
   update_lexer ();
 
   // update the file editor with current editing directory
   emit editor_state_changed (_copy_available, _is_octave_file);
@@ -558,17 +558,17 @@ file_editor_tab::update_lexer ()
                 update_apis_file = true;
             }
           }
         else  // no octave file, just add extension
           {
             _prep_apis_file = prep_apis_path + lexer->lexer () + ".pap";
           }
 
-      if (update_apis_file || !_lexer_apis->loadPrepared (_prep_apis_file))
+      if (update_apis_file || ! _lexer_apis->loadPrepared (_prep_apis_file))
         {
           // no prepared info loaded, prepare and save if possible
 
           // create raw apis info
           QString keyword;
           QStringList keyword_list;
           int i,j;
 
@@ -1065,26 +1065,26 @@ file_editor_tab::find (const QWidget *ID
 
   // The find_dialog feature doesn't need a slot for return info.
   // Rather than Qt::DeleteOnClose, let the find feature hang about
   // in case it contains useful information like previous searches
   // and so on.  Perhaps one find dialog for the whole editor is
   // better, but individual find dialogs has the nice feature of
   // retaining position per file editor tabs, which can be undocked.
 
-  if (!_find_dialog)
+  if (! _find_dialog)
     {
       _find_dialog = new find_dialog (_edit_area,
                                       qobject_cast<QWidget *> (sender ()));
       connect (_find_dialog, SIGNAL (finished (int)),
                this, SLOT (handle_find_dialog_finished (int)));
       _find_dialog->setWindowModality (Qt::NonModal);
       _find_dialog_geometry = _find_dialog->geometry ();
     }
-  else if (!_find_dialog->isVisible ())
+  else if (! _find_dialog->isVisible ())
     {
       _find_dialog->setGeometry (_find_dialog_geometry);
       QPoint p = _find_dialog->pos ();
       _find_dialog->move(p.x ()+10, p.y ()+10);
     }
 
   _find_dialog->show ();
   _find_dialog_is_visible = true;
@@ -1378,17 +1378,17 @@ file_editor_tab::load_file (const QStrin
   // get the absolute path
   QFileInfo file_info = QFileInfo (fileName);
   QString file_to_load;
   if (file_info.exists ())
     file_to_load = file_info.canonicalFilePath ();
   else
     file_to_load = fileName;
   QFile file (file_to_load);
-  if (!file.open (QFile::ReadOnly))
+  if (! file.open (QFile::ReadOnly))
     return file.errorString ();
 
   // read the file
   QTextStream in (&file);
   // set the desired codec
   QTextCodec *codec = QTextCodec::codecForName (_encoding.toAscii ());
   in.setCodec(codec);
 
@@ -1519,17 +1519,17 @@ file_editor_tab::save_file (const QStrin
   QFile file (file_to_save);
 
   // stop watching file
   QStringList trackedFiles = _file_system_watcher.files ();
   if (trackedFiles.contains (file_to_save))
     _file_system_watcher.removePath (file_to_save);
 
   // open the file for writing
-  if (!file.open (QIODevice::WriteOnly))
+  if (! file.open (QIODevice::WriteOnly))
     {
       // Unsuccessful, begin watching file again if it was being
       // watched previously.
       if (trackedFiles.contains (file_to_save))
         _file_system_watcher.addPath (file_to_save);
 
       // Create a NonModal message about error.
       QMessageBox* msgBox
@@ -1827,17 +1827,17 @@ file_editor_tab::handle_save_file_as_ans
 
 void
 file_editor_tab::file_has_changed (const QString&)
 {
   // Prevent popping up multiple message boxes when the file has
   // been changed multiple times by temporarily removing from the
   // file watcher.
   QStringList trackedFiles = _file_system_watcher.files ();
-  if (!trackedFiles.isEmpty ())
+  if (! trackedFiles.isEmpty ())
     _file_system_watcher.removePath (_file_name);
 
   if (QFile::exists (_file_name))
     {
       if (_always_reload_changed_files)
 
               load_file (_file_name);
 
@@ -2057,17 +2057,17 @@ void
 file_editor_tab::file_name_query (const QWidget *ID)
 {
   // A zero (null pointer) means that all file editor tabs
   // should respond, otherwise just the desired file editor tab.
   if (ID != this && ID != 0)
     return;
 
   // Unnamed files shouldn't be transmitted.
-  if (!_file_name.isEmpty ())
+  if (! _file_name.isEmpty ())
     emit add_filename_to_list (_file_name, _encoding, this);
 }
 
 void
 file_editor_tab::handle_file_reload_answer (int decision)
 {
   if (decision == QMessageBox::Yes)
     {
diff --git a/libgui/src/m-editor/file-editor.cc b/libgui/src/m-editor/file-editor.cc
--- a/libgui/src/m-editor/file-editor.cc
+++ b/libgui/src/m-editor/file-editor.cc
@@ -84,17 +84,17 @@ file_editor::check_closing (void)
   QStringList fet_encodings;
   QStringList fet_index;
 
   // over all open tabs
   for (editor_tab_map_const_iterator p = editor_tab_map.begin ();
        p != editor_tab_map.end (); p++)
     {
       QString file_name = p->first;   // get file name of tab
-      if (!file_name.isEmpty ())      // do not append unnamed files
+      if (! file_name.isEmpty ())      // do not append unnamed files
         {
           fetFileNames.append (file_name);
           fet_encodings.append (editor_tab_map[file_name].encoding);
           QString index;
           fet_index.append (index.setNum
              (_tab_widget->indexOf (editor_tab_map[file_name].fet_ID)));
         }
     }
@@ -476,17 +476,17 @@ file_editor::request_open_file (const QS
                     }
                   else
                     {
                       // File does not exist, should it be created?
                       bool create_file = true;
                       QMessageBox *msgBox;
                       QSettings *settings = resource_manager::get_settings ();
 
-                      if (!settings->value ("editor/create_new_file", false).toBool ())
+                      if (! settings->value ("editor/create_new_file", false).toBool ())
                         {
                           msgBox = new QMessageBox (QMessageBox::Question,
                                                     tr ("Octave Editor"),
                                                     tr ("File\n%1\ndoes not exist. "
                                                         "Do you want to create it?").arg (openFileName),
                                                     QMessageBox::NoButton,0);
                           QPushButton *create_button =
                             msgBox->addButton (tr ("Create"), QMessageBox::YesRole);
@@ -500,17 +500,17 @@ file_editor::request_open_file (const QS
 
                           delete msgBox;
                         }
 
                       if (create_file)
                         {
                           // create the file and call the editor again
                           QFile file (openFileName);
-                          if (!file.open (QIODevice::WriteOnly))
+                          if (! file.open (QIODevice::WriteOnly))
                             {
                               // error opening the file
                               msgBox = new QMessageBox (QMessageBox::Critical,
                                                         tr ("Octave Editor"),
                                                         tr ("Could not open file\n%1\nfor write: %2.").
                                                         arg (openFileName).arg (file.errorString ()),
                                                         QMessageBox::Ok, this);
 
@@ -591,17 +591,17 @@ file_editor::check_conflict_save (const 
   for (int i = 0; i < _tab_widget->count (); i++)
     {
       if (_tab_widget->widget (i) == saveFileObject)
         {
           saveFileWidget = _tab_widget->widget (i);
           break;
         }
     }
-  if (!saveFileWidget)
+  if (! saveFileWidget)
     {
       // Create a NonModal message about error.
       QMessageBox *msgBox
         = new QMessageBox (QMessageBox::Critical, tr ("Octave Editor"),
                            tr ("The associated file editor tab has disappeared."),
                            QMessageBox::Ok, 0);
 
       msgBox->setWindowModality (Qt::NonModal);
@@ -1120,17 +1120,17 @@ void file_editor::create_context_menu (Q
   menu->addAction (_run_selection_action);
 }
 
 void
 file_editor::toggle_preference (const QString& preference, bool def)
 {
   QSettings *settings = resource_manager::get_settings ();
   bool old = settings->value (preference,def).toBool ();
-  settings->setValue (preference,!old);
+  settings->setValue (preference,! old);
   notice_settings (settings);
 }
 
 void
 file_editor::show_line_numbers (bool)
 {
   toggle_preference ("editor/showLineNumbers",true);
 }
diff --git a/libgui/src/m-editor/find-dialog.cc b/libgui/src/m-editor/find-dialog.cc
--- a/libgui/src/m-editor/find-dialog.cc
+++ b/libgui/src/m-editor/find-dialog.cc
@@ -248,17 +248,17 @@ find_dialog::init_search_text ()
   // set focus to "Find what" and select all text
   _search_line_edit->setFocus();
   _search_line_edit->selectAll();
 }
 
 void
 find_dialog::find_next ()
 {
-  find (!_backward_check_box->isChecked ());
+  find (! _backward_check_box->isChecked ());
 }
 
 void
 find_dialog::find_prev ()
 {
   find (_backward_check_box->isChecked ());
 }
 
diff --git a/libgui/src/m-editor/octave-qscintilla.cc b/libgui/src/m-editor/octave-qscintilla.cc
--- a/libgui/src/m-editor/octave-qscintilla.cc
+++ b/libgui/src/m-editor/octave-qscintilla.cc
@@ -151,17 +151,17 @@ octave_qscintilla::get_global_textcursor
 bool
 octave_qscintilla::get_actual_word ()
 {
   QPoint global_pos, local_pos;
   get_global_textcursor_pos (&global_pos, &local_pos);
   _word_at_cursor = wordAtPoint (local_pos);
   QString lexer_name = lexer ()->lexer ();
   return ((lexer_name == "octave" || lexer_name == "matlab")
-          && !_word_at_cursor.isEmpty ());
+          && ! _word_at_cursor.isEmpty ());
 }
 
 // call documentation or help on the current word
 void
 octave_qscintilla::context_help_doc (bool documentation)
 {
   if (get_actual_word ())
     contextmenu_help_doc (documentation);
@@ -203,30 +203,30 @@ octave_qscintilla::contextMenuEvent (QCo
     }
   else
     {
       // context menu by keyboard or other: get point of text cursor
       get_global_textcursor_pos (&global_pos, &local_pos);
       QRect editor_rect = geometry ();      // editor rect mapped to global
       editor_rect.moveTopLeft
       (parentWidget ()->mapToGlobal (editor_rect.topLeft ()));
-      if (!editor_rect.contains (global_pos))  // is cursor outside editor?
+      if (! editor_rect.contains (global_pos))  // is cursor outside editor?
         global_pos = editor_rect.topLeft ();   // yes, take top left corner
     }
 
   // additional custom entries of the context menu
   context_menu->addSeparator ();   // separator before custom entries
 
   // help menu: get the position of the mouse or the text cursor
   // (only for octave files)
   QString lexer_name = lexer ()->lexer ();
   if (lexer_name == "octave" || lexer_name == "matlab")
     {
       _word_at_cursor = wordAtPoint (local_pos);
-      if (!_word_at_cursor.isEmpty ())
+      if (! _word_at_cursor.isEmpty ())
         {
           context_menu->addAction (tr ("Help on") + " " + _word_at_cursor,
                                    this, SLOT (contextmenu_help (bool)));
           context_menu->addAction (tr ("Documentation on")
                                    + " " + _word_at_cursor,
                                    this, SLOT (contextmenu_doc (bool)));
           context_menu->addAction (tr ("Edit") + " " + _word_at_cursor,
                                    this, SLOT (contextmenu_edit (bool)));
diff --git a/libgui/src/main-window.cc b/libgui/src/main-window.cc
--- a/libgui/src/main-window.cc
+++ b/libgui/src/main-window.cc
@@ -722,17 +722,17 @@ main_window::notice_settings (const QSet
     {"GRAPHIC", ":/actions/icons/graphic_logo_"},
     {"LETTER",  ":/actions/icons/letter_logo_"},
     {"", ""} // end marker has empty name
   };
 
   int count = 0;
   int icon_set_found = 0; // default
 
-  while (!widget_icon_data[count].name.isEmpty ())
+  while (! widget_icon_data[count].name.isEmpty ())
     {
       // while not end of data
       if (widget_icon_data[count].name == icon_set)
         {
           // data of desired icon set found
           icon_set_found = count;
           break;
         }
@@ -1034,17 +1034,17 @@ main_window::closeEvent (QCloseEvent *e)
   queue_command (cmd);
 }
 
 void
 main_window::read_settings (void)
 {
   QSettings *settings = resource_manager::get_settings ();
 
-  if (!settings)
+  if (! settings)
     {
       qDebug ("Error: QSettings pointer from resource manager is NULL.");
       return;
     }
 
   set_window_layout (settings);
 
   // restore the list of the last directories
@@ -1116,17 +1116,17 @@ main_window::set_window_layout (QSetting
 
   show ();
 }
 
 void
 main_window::write_settings (void)
 {
   QSettings *settings = resource_manager::get_settings ();
-  if (!settings)
+  if (! settings)
     {
       qDebug ("Error: QSettings pointer from resource manager is NULL.");
       return;
     }
 
   settings->setValue ("MainWindow/geometry", saveGeometry ());
   settings->setValue ("MainWindow/windowState", saveState ());
   // write the list of recent used directories
@@ -2171,17 +2171,17 @@ main_window::queue_debug (QString debug_
     octave_link::post_event (this, &main_window::execute_debug_callback);
 }
 
 void
 main_window::execute_debug_callback ()
 {
   bool repost = false;          // flag for reposting event for this callback
 
-  if (!_dbg_queue->isEmpty ())  // list can not be empty here, just to make sure
+  if (! _dbg_queue->isEmpty ())  // list can not be empty here, just to make sure
     {
       _dbg_queue_mutex.lock (); // critical path
       QString debug = _dbg_queue->takeFirst ();
       if (_dbg_queue->isEmpty ())
         _dbg_processing.release ();  // cmd queue empty, processing will stop
       else
         repost = true;          // not empty, repost at end
       _dbg_queue_mutex.unlock ();
diff --git a/libgui/src/qtinfo/parser.cc b/libgui/src/qtinfo/parser.cc
--- a/libgui/src/qtinfo/parser.cc
+++ b/libgui/src/qtinfo/parser.cc
@@ -109,25 +109,25 @@ parser::open_file (QFileInfo & file_info
         {
           ips.read (buffer, sizeof (buffer));
           result.append (buffer, ips.gcount ());
         }
 
       QBuffer *io = new QBuffer (this);
       io->setData (result);
 
-      if (!io->open (QIODevice::ReadOnly | QIODevice::Text))
+      if (! io->open (QIODevice::ReadOnly | QIODevice::Text))
         return 0;
 
       iodevice = io;
     }
   else
     {
       QFile *io = new QFile (file_info.absoluteFilePath ());
-      if (!io->open (QIODevice::ReadOnly | QIODevice::Text))
+      if (! io->open (QIODevice::ReadOnly | QIODevice::Text))
         return 0;
       iodevice = io;
     }
 
   return iodevice;
 }
 
 int
@@ -171,32 +171,32 @@ parser::search_node (const QString& node
       if (! io)
         {
           return QString ();
         }
 
       seek (io, realPos);
 
       QString text = get_next_node (io);
-      if (!text.isEmpty())
+      if (! text.isEmpty())
         {
           return text;
         }
 
       io->close ();
       delete io;
     }
 
   return QString ();
 }
 
 QString
 parser::search_node (const QString& node, QIODevice *io)
 {
-  while (!io->atEnd ())
+  while (! io->atEnd ())
     {
       QString text = get_next_node (io);
       if (node == get_node_name (text))
         {
           return text;
         }
     }
 
@@ -206,17 +206,17 @@ parser::search_node (const QString& node
 QString
 parser::get_next_node (QIODevice *io)
 {
   QString text;
   QByteArray line, line_buffer;
   char c;
   int i;
 
-  while (!io->atEnd ())
+  while (! io->atEnd ())
     {
       io->getChar (&c);
       if (c)
         {
           // first char is not equal 0
           io->ungetChar (c);
           line = io->readLine ();
         }
@@ -550,17 +550,17 @@ parser::real_position (int pos, QFileInf
     }
   real_pos = pos - sum + header + 2;
 }
 
 void
 parser::seek (QIODevice *io, int pos)
 {
   char ch;
-  while (!io->atEnd () && pos > 0)
+  while (! io->atEnd () && pos > 0)
     {
       io->getChar (&ch);
       pos--;
     }
 }
 
 static void
 replace (QString& text, const QRegExp& re, const QString& after)
diff --git a/libgui/src/resource-manager.cc b/libgui/src/resource-manager.cc
--- a/libgui/src/resource-manager.cc
+++ b/libgui/src/resource-manager.cc
@@ -112,23 +112,23 @@ resource_manager::config_translators (QT
     }
 
   if (language == "SYSTEM")
     language = QLocale::system ().name ();    // get system wide locale
 
   // load the translator file for qt strings
   loaded = qt_tr->load ("qt_" + language, qt_trans_dir);
 
-  if (!loaded) // try lower case
+  if (! loaded) // try lower case
     qt_tr->load ("qt_" + language.toLower (), qt_trans_dir);
 
   // load the translator file for qscintilla settings
   loaded = qsci_tr->load ("qscintilla_" + language, qt_trans_dir);
 
-  if (!loaded) // try lower case
+  if (! loaded) // try lower case
     qsci_tr->load ("qscintilla_" + language.toLower (), qt_trans_dir);
 
   // load the translator file for gui strings
   gui_tr->load (language, get_gui_translation_dir ());
 }
 
 bool
 resource_manager::instance_ok (void)
@@ -180,17 +180,17 @@ resource_manager::do_get_settings_file (
 void
 resource_manager::do_reload_settings (void)
 {
   if (! QFile::exists (settings_file))
     {
       QDir ("/").mkpath (settings_directory);
       QFile qt_settings (default_qt_settings_file ());
 
-      if (!qt_settings.open (QFile::ReadOnly))
+      if (! qt_settings.open (QFile::ReadOnly))
         return;
 
       QTextStream in (&qt_settings);
       QString settings_text = in.readAll ();
       qt_settings.close ();
 
       // Get the default monospaced font
 #if defined (HAVE_QFONT_MONOSPACE)
diff --git a/libgui/src/workspace-view.cc b/libgui/src/workspace-view.cc
--- a/libgui/src/workspace-view.cc
+++ b/libgui/src/workspace-view.cc
@@ -457,17 +457,17 @@ workspace_view::notice_settings (const Q
   for (i = 0; i < _columns_shown_keys.size (); i++)
     {
       view->setColumnHidden ( i + 1,
             ! settings->value (_columns_shown_keys.at (i),true).toBool ());
     }
 
   QString tool_tip;
 
-  if (!settings->value ("workspaceview/hide_tool_tips",false).toBool ())
+  if (! settings->value ("workspaceview/hide_tool_tips",false).toBool ())
     {
       tool_tip  = QString (tr ("View the variables in the active workspace.<br>"));
       tool_tip += QString (tr ("Colors for variable attributes:"));
       for (i = 0; i < resource_manager::storage_class_chars ().length (); i++)
         {
           tool_tip +=
             QString ("<div style=\"background-color:%1;color:#000000\">%2</div>")
             .arg (_model->storage_class_color (i).name ())
diff --git a/libinterp/corefcn/data.cc b/libinterp/corefcn/data.cc
--- a/libinterp/corefcn/data.cc
+++ b/libinterp/corefcn/data.cc
@@ -996,17 +996,17 @@ negative numbers or when the values are 
               boolNDArray tmp = arg.bool_array_value (); \
 \
               retval = boolNDArray (tmp.BOOL_FCN (dim)); \
             } \
           else if (arg.is_char_matrix ()) \
             { \
               error (#FCN, ": invalid char type"); \
             } \
-          else if (!isdouble && arg.is_single_type ()) \
+          else if (! isdouble && arg.is_single_type ()) \
             { \
               if (arg.is_complex_type ()) \
                 { \
                   FloatComplexNDArray tmp = \
                     arg.float_complex_array_value (); \
 \
                   retval = tmp.FCN (dim); \
                 } \
@@ -1036,17 +1036,17 @@ negative numbers or when the values are 
             } \
         } \
       else if (arg.is_bool_type ()) \
         { \
           boolNDArray tmp = arg.bool_array_value (); \
 \
           retval = tmp.FCN (dim); \
         } \
-      else if (!isdouble && arg.is_single_type ()) \
+      else if (! isdouble && arg.is_single_type ()) \
         { \
           if (arg.is_real_type ()) \
             { \
               FloatNDArray tmp = arg.float_array_value (); \
 \
               retval = tmp.FCN (dim); \
             } \
           else if (arg.is_complex_type ()) \
@@ -1952,21 +1952,21 @@ do_cat (const octave_value_list& xargs, 
             all_sq_strings_p = false;
           if (all_dq_strings_p && ! args(i).is_dq_string ())
             all_dq_strings_p = false;
           if (all_real_p && ! args(i).is_real_type ())
             all_real_p = false;
           if (all_cmplx_p && ! (args(i).is_complex_type ()
               || args(i).is_real_type ()))
             all_cmplx_p = false;
-          if (!any_sparse_p && args(i).is_sparse_type ())
+          if (! any_sparse_p && args(i).is_sparse_type ())
             any_sparse_p = true;
-          if (!any_cell_p && args(i).is_cell ())
+          if (! any_cell_p && args(i).is_cell ())
             any_cell_p = true;
-          if (!any_class_p && args(i).is_object ())
+          if (! any_class_p && args(i).is_object ())
             any_class_p = true;
         }
 
       if (any_cell_p && ! any_class_p && ! first_elem_is_struct)
         {
           for (int i = 0; i < n_args; i++)
             {
               if (! args(i).is_cell ())
diff --git a/libinterp/corefcn/dlmread.cc b/libinterp/corefcn/dlmread.cc
--- a/libinterp/corefcn/dlmread.cc
+++ b/libinterp/corefcn/dlmread.cc
@@ -113,37 +113,37 @@ parse_range_spec (const octave_value& ra
               ch = is.peek ();
 
               if (ch == '.' || ch == ':')
                 {
                   ch = is.get ();
                   if (ch == '.')
                     {
                       ch = is.get ();
-                      if (!is || ch != '.')
+                      if (! is || ch != '.')
                         stat = false;
                     }
 
                   rup = idx_max - 1;
                   cup = idx_max - 1;
                 }
               else
                 {
                   rup = rlo;
                   cup = clo;
-                  if (!is || !is.eof ())
+                  if (! is || ! is.eof ())
                     stat = false;
                 }
             }
         }
 
-      if (stat && is && !is.eof ())
+      if (stat && is && ! is.eof ())
         stat = read_cell_spec (is, rup, cup);
 
-      if (!is || !is.eof ())
+      if (! is || ! is.eof ())
         stat = false;
     }
   else if (range_spec.is_real_matrix () && range_spec.numel () == 4)
     {
       ColumnVector range(range_spec.vector_value ());
       // double --> unsigned int
       rlo = static_cast<octave_idx_type> (range(0));
       clo = static_cast<octave_idx_type> (range(1));
@@ -246,17 +246,17 @@ fill empty fields.  The default is zero.
   octave_idx_type r0 = 0;
   octave_idx_type c0 = 0;
   octave_idx_type r1 = idx_max-1;
   octave_idx_type c1 = idx_max-1;
   if (nargin > 2)
     {
       if (nargin == 3)
         {
-          if (!parse_range_spec (args(2), r0, c0, r1, c1))
+          if (! parse_range_spec (args(2), r0, c0, r1, c1))
             error ("dlmread: error parsing RANGE");
         }
       else if (nargin == 4)
         {
           r0 = args(2).idx_type_value ();
           c0 = args(3).idx_type_value ();
         }
 
@@ -291,17 +291,17 @@ fill empty fields.  The default is zero.
   while (getline (*input, line))
     {
       // Skip blank lines for compatibility.
       if (line.find_first_not_of (" \t") == std::string::npos)
         continue;
 
       // To be compatible with matlab, blank separator should
       // correspond to whitespace as delimter.
-      if (!sep.length ())
+      if (! sep.length ())
         {
           size_t n = line.find_first_of (",:; \t",
                                          line.find_first_of ("0123456789"));
           if (n == std::string::npos)
             {
               sep = " \t";
               sepflag = true;
             }
@@ -407,17 +407,17 @@ fill empty fields.  The default is zero.
                     cdata(i,j++) = x;
                   else
                     rdata(i,j++) = x;
                 }
               else
                 {
                   double y = octave_read_double (tmp_stream);
 
-                  if (!iscmplx && y != 0.)
+                  if (! iscmplx && y != 0.)
                     {
                       iscmplx = true;
                       cdata = ComplexMatrix (rdata);
                     }
 
                   if (iscmplx)
                     cdata(i,j++) = Complex (x, y);
                   else
diff --git a/libinterp/corefcn/gl-render.cc b/libinterp/corefcn/gl-render.cc
--- a/libinterp/corefcn/gl-render.cc
+++ b/libinterp/corefcn/gl-render.cc
@@ -1188,17 +1188,17 @@ opengl_renderer::draw_axes_y_grid (const
                           zpTick, zpTick,
                           signum (xPlaneN-xPlane)*fx*yticklen,
                           0., 0., 1, mirror);
 
       // tick texts
       if (yticklabels.numel () > 0)
         {
           int halign = (ystate == AXE_HORZ_DIR
-                        ? 1 : (!xyzSym || y2Dright ? 0 : 2));
+                        ? 1 : (! xyzSym || y2Dright ? 0 : 2));
           int valign = (ystate == AXE_VERT_DIR ? 1 : 2);
 
           if (tick_along_z)
             render_ticktexts (yticks, yticklabels, y_min, y_max, xpTick,
                               zpTick+signum (zpTick-zpTickN)*fz*ytickoffset,
                               1, halign, valign, wmax, hmax);
           else
             render_ticktexts (yticks, yticklabels, y_min, y_max,
diff --git a/libinterp/corefcn/gl2ps-renderer.cc b/libinterp/corefcn/gl2ps-renderer.cc
--- a/libinterp/corefcn/gl2ps-renderer.cc
+++ b/libinterp/corefcn/gl2ps-renderer.cc
@@ -40,17 +40,17 @@ along with Octave; see the file COPYING.
 #include "sysdep.h"
 
 void
 glps_renderer::draw (const graphics_object& go, const std::string& print_cmd)
 {
   static bool in_draw = false;
   static std::string old_print_cmd;
 
-  if (!in_draw)
+  if (! in_draw)
     {
       unwind_protect frame;
 
       frame.protect_var (in_draw);
 
       in_draw = true;
 
       GLint gl2ps_term;
diff --git a/libinterp/corefcn/graphics.cc b/libinterp/corefcn/graphics.cc
--- a/libinterp/corefcn/graphics.cc
+++ b/libinterp/corefcn/graphics.cc
@@ -5535,17 +5535,17 @@ axes::properties::update_axes_layout (vo
   fz = (z_max - z_min) / sqrt (dir(0)*dir(0) + dir(1)*dir(1));
 
   unwind_protect frame;
   frame.protect_var (updating_axes_layout);
   updating_axes_layout = true;
 
   xySym = (xd*yd*(xPlane-xPlaneN)*(yPlane-yPlaneN) > 0);
   zSign = (zd*(zPlane-zPlaneN) <= 0);
-  xyzSym = zSign ? xySym : !xySym;
+  xyzSym = zSign ? xySym : ! xySym;
   xpTick = (zSign ? xPlaneN : xPlane);
   ypTick = (zSign ? yPlaneN : yPlane);
   zpTick = (zSign ? zPlane : zPlaneN);
   xpTickN = (zSign ? xPlane : xPlaneN);
   ypTickN = (zSign ? yPlane : yPlaneN);
   zpTickN = (zSign ? zPlaneN : zPlane);
 
   // 2D mode
@@ -5785,25 +5785,25 @@ axes::properties::update_ylabel_position
   frame.protect_var (updating_ylabel_position);
   updating_ylabel_position = true;
 
   if (! is_empty)
     {
       if (ylabel_props.horizontalalignmentmode_is ("auto"))
         {
           ylabel_props.set_horizontalalignment
-            (ystate > AXE_DEPTH_DIR ? "center" : (!xyzSym ? "left" : "right"));
+            (ystate > AXE_DEPTH_DIR ? "center" : (! xyzSym ? "left" : "right"));
 
           ylabel_props.set_horizontalalignmentmode ("auto");
         }
 
       if (ylabel_props.verticalalignmentmode_is ("auto"))
         {
           ylabel_props.set_verticalalignment
-            (ystate == AXE_VERT_DIR && !y2Dright ? "bottom" : "top");
+            (ystate == AXE_VERT_DIR && ! y2Dright ? "bottom" : "top");
 
           ylabel_props.set_verticalalignmentmode ("auto");
         }
     }
 
   if (ylabel_props.positionmode_is ("auto")
       || ylabel_props.rotationmode_is ("auto"))
     {
@@ -5835,17 +5835,17 @@ axes::properties::update_ylabel_position
       else
         p(0) += (signum (xpTick - xpTickN) * fx * ytickoffset);
 
       p = xform.transform (p(0), p(1), p(2), false);
 
       switch (ystate)
         {
         case AXE_ANY_DIR:
-          p(0) += (!xyzSym ? wmax : -wmax);
+          p(0) += (! xyzSym ? wmax : -wmax);
           p(1) += hmax;
           break;
 
         case AXE_VERT_DIR:
           p(0) += (y2Dright ? wmax : -wmax);
           angle = 90;
           break;
 
@@ -5958,17 +5958,17 @@ axes::properties::update_zlabel_position
           if (camAuto)
             {
               p(0) -= wmax;
               angle = 90;
             }
 
           // FIXME: what's the correct offset?
           //
-          //   p[0] += (!xySym ? wmax : -wmax);
+          //   p[0] += (! xySym ? wmax : -wmax);
           //   p[1] += (zSign ? hmax : -hmax);
 
           break;
 
         case AXE_VERT_DIR:
           p(0) -= wmax;
           angle = 90;
           break;
diff --git a/libinterp/corefcn/graphics.in.h b/libinterp/corefcn/graphics.in.h
--- a/libinterp/corefcn/graphics.in.h
+++ b/libinterp/corefcn/graphics.in.h
@@ -604,17 +604,17 @@ protected:
         octave_idx_type nel = chm.rows ();
         string_vector strings (nel);
 
         if (nel != str.numel ())
           replace = true;
         for (octave_idx_type i = 0; i < nel; i++)
           {
             strings[i] = chm.row_as_string (i);
-            if (!replace && strings[i] != str[i])
+            if (! replace && strings[i] != str[i])
               replace = true;
           }
 
         desired_type = string_t;
 
         if (replace)
           {
             str = strings;
diff --git a/libinterp/corefcn/ls-hdf5.cc b/libinterp/corefcn/ls-hdf5.cc
--- a/libinterp/corefcn/ls-hdf5.cc
+++ b/libinterp/corefcn/ls-hdf5.cc
@@ -587,17 +587,17 @@ hdf5_read_next_data (octave_hdf5_id grou
       d->global = hdf5_check_attr (data_id, "OCTAVE_GLOBAL");
 
       H5Tclose (type_id);
       H5Dclose (data_id);
 
       retval = (d->tc.load_hdf5 (group_id, name) ? 1 : -1);
     }
 
-  if (!ident_valid)
+  if (! ident_valid)
     {
       // should we attempt to handle invalid identifiers by converting
       // bad characters to '_', say?
       warning ("load: skipping invalid identifier '%s' in hdf5 file",
                name);
     }
 
 done:
@@ -798,17 +798,17 @@ save_hdf5_empty (octave_hdf5_id loc_id, 
   int retval;
   for (hsize_t i = 0; i < sz; i++)
     {
       dims[i] = d(i);
       if (dims[i] < 1)
         empty = true;
     }
 
-  if (!empty)
+  if (! empty)
     return 0;
 
   space_hid = H5Screate_simple (1, &sz, 0);
   if (space_hid < 0) return space_hid;
 #if HAVE_HDF5_18
   data_hid = H5Dcreate (loc_id, name, H5T_NATIVE_IDX, space_hid,
                         H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
 #else
diff --git a/libinterp/corefcn/ls-mat5.cc b/libinterp/corefcn/ls-mat5.cc
--- a/libinterp/corefcn/ls-mat5.cc
+++ b/libinterp/corefcn/ls-mat5.cc
@@ -1499,17 +1499,17 @@ read_mat5_binary_file_header (std::istre
       if (! quiet)
         error ("load: can't read binary file");
       return -1;
     }
 
   if (! swap)                   // version number is inverse swapped!
     version = ((version >> 8) & 0xff) + ((version & 0xff) << 8);
 
-  if (version != 1 && !quiet)
+  if (version != 1 && ! quiet)
     warning ("load: found version %d binary MAT file, "
              "but only prepared for version 1", version);
 
   if (swap)
     swap_bytes<8> (&subsys_offset, 1);
 
   if (subsys_offset != 0x2020202020202020ULL && subsys_offset != 0ULL)
     {
@@ -1902,17 +1902,17 @@ save_mat5_array_length (const double* va
               if (xfinite (tmp)
                   && fabs (tmp) > std::numeric_limits<float>::max ())
                 {
                   too_large_for_float = true;
                   break;
                 }
             }
 
-          if (!too_large_for_float)
+          if (! too_large_for_float)
             size = 4;
         }
 
       // The code below is disabled since get_save_type currently doesn't
       // deal with integer types.  This will need to be activated if
       // get_save_type is changed.
 
       // double max_val = val[0];
@@ -2290,17 +2290,17 @@ save_mat5_binary_element (std::ostream& 
     }
   else if (dv.numel () > max_dim_val)
     {
       gripe_dim_too_large (name);
       goto skip_to_next;
     }
 
 #ifdef HAVE_ZLIB
-  if (mat7_format && !compressing)
+  if (mat7_format && ! compressing)
     {
       bool ret = false;
 
       std::ostringstream buf;
 
       // The code seeks backwards in the stream to fix the header. Can't
       // do this with zlib, so use a stringstream.
       ret = save_mat5_binary_element (buf, tc, name, mark_as_global, true,
diff --git a/libinterp/corefcn/ls-oct-binary.cc b/libinterp/corefcn/ls-oct-binary.cc
--- a/libinterp/corefcn/ls-oct-binary.cc
+++ b/libinterp/corefcn/ls-oct-binary.cc
@@ -248,17 +248,17 @@ read_binary_data (std::istream& is, bool
         tc = octave_value_typeinfo::lookup_type (typ);
       }
       break;
     default:
       goto data_read_error;
       break;
     }
 
-  if (!tc.load_binary (is, swap, fmt))
+  if (! tc.load_binary (is, swap, fmt))
     {
     data_read_error:
       error ("load: trouble reading binary file '%s'", filename.c_str ());
     }
 
   return retval;
 }
 
diff --git a/libinterp/corefcn/lsode.cc b/libinterp/corefcn/lsode.cc
--- a/libinterp/corefcn/lsode.cc
+++ b/libinterp/corefcn/lsode.cc
@@ -310,30 +310,30 @@ parameters for @code{lsode}.\n\
                 {
                   jac_name = unique_symbol_name ("__lsode_jac__");
                   jname = "function jac = ";
                   jname.append (jac_name);
                   jname.append (" (x, t) jac = ");
                   lsode_jac = extract_function (c(1), "lsode", jac_name,
                                                 jname, "; endfunction");
 
-                  if (!lsode_jac)
+                  if (! lsode_jac)
                     {
                       if (fcn_name.length ())
                         clear_function (fcn_name);
                       lsode_fcn = 0;
                     }
                 }
             }
         }
       else
         error ("lsode: incorrect number of elements in cell array");
     }
 
-  if (!lsode_fcn && ! f_arg.is_cell ())
+  if (! lsode_fcn && ! f_arg.is_cell ())
     {
       if (f_arg.is_function_handle () || f_arg.is_inline_function ())
         lsode_fcn = f_arg.function_value ();
       else
         {
           switch (f_arg.rows ())
             {
             case 1:
@@ -365,17 +365,17 @@ parameters for @code{lsode}.\n\
                     jac_name = unique_symbol_name ("__lsode_jac__");
                     jname = "function jac = ";
                     jname.append (jac_name);
                     jname.append (" (x, t) jac = ");
                     lsode_jac = extract_function (tmp(1), "lsode",
                                                   jac_name, jname,
                                                   "; endfunction");
 
-                    if (!lsode_jac)
+                    if (! lsode_jac)
                       {
                         if (fcn_name.length ())
                           clear_function (fcn_name);
                         lsode_fcn = 0;
                       }
                   }
               }
               break;
diff --git a/libinterp/corefcn/mappers.cc b/libinterp/corefcn/mappers.cc
--- a/libinterp/corefcn/mappers.cc
+++ b/libinterp/corefcn/mappers.cc
@@ -916,22 +916,22 @@ isfinite ([13, Inf, NA, NaN])\n\
 {
   if (args.length () != 1)
     print_usage ();
 
   return ovl (args(0).finite ());
 }
 
 /*
-%!assert (!isfinite (Inf))
-%!assert (!isfinite (NaN))
+%!assert (! isfinite (Inf))
+%!assert (! isfinite (NaN))
 %!assert (isfinite (rand (1,10)))
 
-%!assert (!isfinite (single (Inf)))
-%!assert (!isfinite (single (NaN)))
+%!assert (! isfinite (single (Inf)))
+%!assert (! isfinite (single (NaN)))
 %!assert (isfinite (single (rand (1,10))))
 
 %!error isfinite ()
 %!error isfinite (1, 2)
 */
 
 DEFUN (fix, args, ,
        "-*- texinfo -*-\n\
@@ -1248,24 +1248,24 @@ isinf ([13, Inf, NA, NaN])\n\
   if (args.length () != 1)
     print_usage ();
 
   return ovl (args(0).isinf ());
 }
 
 /*
 %!assert (isinf (Inf))
-%!assert (!isinf (NaN))
-%!assert (!isinf (NA))
+%!assert (! isinf (NaN))
+%!assert (! isinf (NA))
 %!assert (isinf (rand (1,10)), false (1,10))
 %!assert (isinf ([NaN -Inf -1 0 1 Inf NA]), [false, true, false, false, false, true, false])
 
 %!assert (isinf (single (Inf)))
-%!assert (!isinf (single (NaN)))
-%!assert (!isinf (single (NA)))
+%!assert (! isinf (single (NaN)))
+%!assert (! isinf (single (NA)))
 %!assert (isinf (single (rand (1,10))), false (1,10))
 %!assert (isinf (single ([NaN -Inf -1 0 1 Inf NA])), [false, true, false, false, false, true, false])
 
 %!error isinf ()
 %!error isinf (1, 2)
 */
 
 DEFUNX ("isgraph", Fisgraph, args, ,
@@ -1338,24 +1338,24 @@ isna ([13, Inf, NA, NaN])\n\
 {
   if (args.length () != 1)
     print_usage ();
 
   return ovl (args(0).isna ());
 }
 
 /*
-%!assert (!isna (Inf))
-%!assert (!isna (NaN))
+%!assert (! isna (Inf))
+%!assert (! isna (NaN))
 %!assert (isna (NA))
 %!assert (isna (rand (1,10)), false (1,10))
 %!assert (isna ([NaN -Inf -1 0 1 Inf NA]), [false, false, false, false, false, false, true])
 
-%!assert (!isna (single (Inf)))
-%!assert (!isna (single (NaN)))
+%!assert (! isna (single (Inf)))
+%!assert (! isna (single (NaN)))
 %!assert (isna (single (NA)))
 %!assert (isna (single (rand (1,10))), false (1,10))
 %!assert (isna (single ([NaN -Inf -1 0 1 Inf NA])), [false, false, false, false, false, false, true])
 
 %!error isna ()
 %!error isna (1, 2)
 */
 
@@ -1378,23 +1378,23 @@ isnan ([13, Inf, NA, NaN])\n\
 {
   if (args.length () != 1)
     print_usage ();
 
   return ovl (args(0).isnan ());
 }
 
 /*
-%!assert (!isnan (Inf))
+%!assert (! isnan (Inf))
 %!assert (isnan (NaN))
 %!assert (isnan (NA))
 %!assert (isnan (rand (1,10)), false (1,10))
 %!assert (isnan ([NaN -Inf -1 0 1 Inf NA]), [true, false, false, false, false, false, true])
 
-%!assert (!isnan (single (Inf)))
+%!assert (! isnan (single (Inf)))
 %!assert (isnan (single (NaN)))
 %!assert (isnan (single (NA)))
 %!assert (isnan (single (rand (1,10))), false (1,10))
 %!assert (isnan (single ([NaN -Inf -1 0 1 Inf NA])), [true, false, false, false, false, false, true])
 
 %!error isnan ()
 %!error isnan (1, 2)
 */
@@ -2071,17 +2071,17 @@ tolower (\"MiXeD cAsE 123\")\n\
 
   return ovl (args(0).xtolower ());
 }
 
 DEFALIAS (lower, tolower);
 
 /*
 %!assert (tolower ("OCTAVE"), "octave")
-%!assert (tolower ("123OCTave!_&"), "123octave!_&")
+%!assert (tolower ("123OCTave! _&"), "123octave! _&")
 %!assert (tolower ({"ABC", "DEF", {"GHI", {"JKL"}}}), {"abc", "def", {"ghi", {"jkl"}}})
 %!assert (tolower (["ABC"; "DEF"]), ["abc"; "def"])
 %!assert (tolower ({["ABC"; "DEF"]}), {["abc";"def"]})
 %!assert (tolower (68), 68)
 %!assert (tolower ({[68, 68; 68, 68]}), {[68, 68; 68, 68]})
 %!test
 %! classes = {@char, @double, @single, ...
 %!            @int8, @int16, @int32, @int64, ...
@@ -2130,17 +2130,17 @@ toupper (\"MiXeD cAsE 123\")\n\
 
   return ovl (args(0).xtoupper ());
 }
 
 DEFALIAS (upper, toupper);
 
 /*
 %!assert (toupper ("octave"), "OCTAVE")
-%!assert (toupper ("123OCTave!_&"), "123OCTAVE!_&")
+%!assert (toupper ("123OCTave! _&"), "123OCTAVE! _&")
 %!assert (toupper ({"abc", "def", {"ghi", {"jkl"}}}), {"ABC", "DEF", {"GHI", {"JKL"}}})
 %!assert (toupper (["abc"; "def"]), ["ABC"; "DEF"])
 %!assert (toupper ({["abc"; "def"]}), {["ABC";"DEF"]})
 %!assert (toupper (100), 100)
 %!assert (toupper ({[100, 100; 100, 100]}), {[100, 100; 100, 100]})
 %!test
 %! classes = {@char, @double, @single, ...
 %!            @int8, @int16, @int32, @int64, ...
diff --git a/libinterp/corefcn/pt-jit.cc b/libinterp/corefcn/pt-jit.cc
--- a/libinterp/corefcn/pt-jit.cc
+++ b/libinterp/corefcn/pt-jit.cc
@@ -510,17 +510,17 @@ jit_convert::visit_function_def (tree_fu
   throw jit_fail_exception ("No visit_function_def implementation");
 }
 
 void
 jit_convert::visit_identifier (tree_identifier& ti)
 {
   if (ti.has_magic_end ())
     {
-      if (!end_context.size ())
+      if (! end_context.size ())
         throw jit_fail_exception ("Illegal end");
       result = block->append (factory.create<jit_magic_end> (end_context));
     }
   else
     {
       jit_variable *var = get_variable (ti.name ());
       jit_instruction *instr;
       instr = factory.create<jit_call> (&jit_typeinfo::grab, var);
diff --git a/libinterp/corefcn/regexp.cc b/libinterp/corefcn/regexp.cc
--- a/libinterp/corefcn/regexp.cc
+++ b/libinterp/corefcn/regexp.cc
@@ -963,17 +963,17 @@ are zero or more @qcode{'b'} characters 
 %! assert (e, 10);
 %! assert (size (te), [1, 1]);
 %! assert (te{1}, [1,5; 7,10]);
 %! assert (m{1}, 'short test');
 %! assert (size (t), [1, 1]);
 %! assert (t{1}{1}, 'short');
 %! assert (t{1}{2}, 'test');
 %! assert (size (nm), [1, 1]);
-%! assert (!isempty (fieldnames (nm)));
+%! assert (! isempty (fieldnames (nm)));
 %! assert (sort (fieldnames (nm)), {'word1';'word2'});
 %! assert (nm.word1, 'short');
 %! assert (nm.word2, 'test');
 
 %!test
 %! [t, nm] = regexp ("John Davis\nRogers, James", '(?<first>\w+)\s+(?<last>\w+)|(?<last>\w+),\s+(?<first>\w+)', 'tokens', 'names');
 %! assert (size (t), [1, 2]);
 %! assert (t{1}{1}, 'John');
@@ -1240,17 +1240,17 @@ for details on the syntax of the search 
 %! assert (e, 10);
 %! assert (size (te), [1, 1]);
 %! assert (te{1}, [1,5; 7,10]);
 %! assert (m{1}, 'ShoRt Test');
 %! assert (size (t), [1, 1]);
 %! assert (t{1}{1}, 'ShoRt');
 %! assert (t{1}{2}, 'Test');
 %! assert (size (nm), [1, 1]);
-%! assert (!isempty (fieldnames (nm)));
+%! assert (! isempty (fieldnames (nm)));
 %! assert (sort (fieldnames (nm)), {'word1';'word2'});
 %! assert (nm.word1, 'ShoRt');
 %! assert (nm.word2, 'Test');
 
 %!assert (regexpi ("abc\nabc", '.'), [1:7])
 %!assert (regexpi ("abc\nabc", '.', 'dotall'), [1:7])
 %!test
 %! assert (regexpi ("abc\nabc", '(?s).'), [1:7]);
diff --git a/libinterp/corefcn/spparms.cc b/libinterp/corefcn/spparms.cc
--- a/libinterp/corefcn/spparms.cc
+++ b/libinterp/corefcn/spparms.cc
@@ -164,17 +164,17 @@ longer running time.\n\
   else if (nargin == 2)
     {
       std::string str = args(0).xstring_value ("spparms: first argument must be a string");
 
       double val = args(1).xdouble_value ("spparms: second argument must be a real scalar");
 
       if (str == "umfpack")
         warning ("spparms: request to disable umfpack solvers ignored");
-      else if (!octave_sparse_params::set_key (str, val))
+      else if (! octave_sparse_params::set_key (str, val))
         error ("spparms: KEY not found");
     }
   else
     error ("spparms: too many input arguments");
 
   return retval;
 }
 
diff --git a/libinterp/corefcn/symtab.h b/libinterp/corefcn/symtab.h
--- a/libinterp/corefcn/symtab.h
+++ b/libinterp/corefcn/symtab.h
@@ -2468,17 +2468,17 @@ private:
       error ("unable to %s symbol_table object for scope %d!",
              create ? "create" : "find", scope);
 
     return retval;
   }
 
   void add_nest_child (symbol_table& st)
   {
-    assert (!st.nest_parent);
+    assert (! st.nest_parent);
     nest_children.push_back (&st);
     st.nest_parent = this;
   }
 
   void insert_symbol_record (const symbol_record& sr)
   {
     table[sr.name ()] = sr;
   }
diff --git a/libinterp/corefcn/utils.cc b/libinterp/corefcn/utils.cc
--- a/libinterp/corefcn/utils.cc
+++ b/libinterp/corefcn/utils.cc
@@ -337,21 +337,21 @@ If no files are found, return an empty c
 
 /*
 %!test
 %! f = file_in_loadpath ("plot.m");
 %! assert (ischar (f));
 %! assert (! isempty (f));
 
 %!test
-%! f = file_in_loadpath ("$$probably_!!_not_&&_a_!!_file$$");
+%! f = file_in_loadpath ("$$probably_!! _not_&&_a_!! _file$$");
 %! assert (f, "");
 
 %!test
-%! lst = file_in_loadpath ("$$probably_!!_not_&&_a_!!_file$$", "all");
+%! lst = file_in_loadpath ("$$probably_!! _not_&&_a_!! _file$$", "all");
 %! assert (lst, {});
 
 %!error file_in_loadpath ()
 %!error file_in_loadpath ("foo", "bar", 1)
 %!error file_in_loadpath ([])
 %!error file_in_loadpath ("plot.m", "bar")
 */
 
@@ -412,21 +412,21 @@ If no files are found, return an empty c
 
 /*
 %!test
 %! f = file_in_path (path (), "plot.m");
 %! assert (ischar (f));
 %! assert (! isempty (f));
 
 %!test
-%! f = file_in_path (path (), "$$probably_!!_not_&&_a_!!_file$$");
+%! f = file_in_path (path (), "$$probably_!! _not_&&_a_!! _file$$");
 %! assert (f, "");
 
 %!test
-%! lst = file_in_path (path (), "$$probably_!!_not_&&_a_!!_file$$", "all");
+%! lst = file_in_path (path (), "$$probably_!! _not_&&_a_!! _file$$", "all");
 %! assert (lst, {});
 
 %!error file_in_path ()
 %!error file_in_path ("foo")
 %!error file_in_path ("foo", "bar", "baz", 1)
 %!error file_in_path ([])
 %!error file_in_path (path (), [])
 %!error file_in_path (path (), "plot.m", "bar")
@@ -1007,21 +1007,21 @@ all name matches rather than just the fi
 
 /*
 %!test
 %! f = dir_in_loadpath ("plot");
 %! assert (ischar (f));
 %! assert (! isempty (f));
 
 %!test
-%! f = dir_in_loadpath ("$$probably_!!_not_&&_a_!!_dir$$");
+%! f = dir_in_loadpath ("$$probably_!! _not_&&_a_!! _dir$$");
 %! assert (f, "");
 
 %!test
-%! lst = dir_in_loadpath ("$$probably_!!_not_&&_a_!!_dir$$", "all");
+%! lst = dir_in_loadpath ("$$probably_!! _not_&&_a_!! _dir$$", "all");
 %! assert (lst, {});
 
 %!error dir_in_loadpath ()
 %!error dir_in_loadpath ("foo", "bar", 1)
 */
 
 DEFUNX ("errno", Ferrno, args, ,
         "-*- texinfo -*-\n\
diff --git a/libinterp/corefcn/zfstream.cc b/libinterp/corefcn/zfstream.cc
--- a/libinterp/corefcn/zfstream.cc
+++ b/libinterp/corefcn/zfstream.cc
@@ -168,28 +168,28 @@ gzfilebuf::open_mode (std::ios_base::ope
   bool testt = mode & std::ios_base::trunc;
   bool testa = mode & std::ios_base::app;
 
   // Check for valid flag combinations - see [27.8.1.3.2] (Table 92)
   // Original zfstream hardcoded the compression level to maximum here...
   // Double the time for less than 1% size improvement seems
   // excessive though - keeping it at the default level
   // To change back, just append "9" to the next three mode strings
-  if (!testi && testo && !testt && !testa)
+  if (! testi && testo && ! testt && ! testa)
     strcpy (c_mode, "w");
-  if (!testi && testo && !testt && testa)
+  if (! testi && testo && ! testt && testa)
     strcpy (c_mode, "a");
-  if (!testi && testo && testt && !testa)
+  if (! testi && testo && testt && ! testa)
     strcpy (c_mode, "w");
-  if (testi && !testo && !testt && !testa)
+  if (testi && ! testo && ! testt && ! testa)
     strcpy (c_mode, "r");
   // No read/write mode yet
-  //  if (testi && testo && !testt && !testa)
+  //  if (testi && testo && ! testt && ! testa)
   //    strcpy(c_mode, "r+");
-  //  if (testi && testo && testt && !testa)
+  //  if (testi && testo && testt && ! testa)
   //    strcpy(c_mode, "w+");
 
   // Mode string should be empty for invalid combination of flags
   if (strlen (c_mode) == 0)
     return false;
 
   strcat (c_mode, "b");
 
@@ -353,17 +353,17 @@ gzfilebuf::setbuf (char_type* p, std::st
   // First make sure stuff is sync'ed, for safety
   if (this->sync () == -1)
     return 0;
   // If buffering is turned off on purpose via setbuf(0,0), still allocate one.
   // "Unbuffered" only really refers to put [27.8.1.4.10], while get needs at
   // least a buffer of size 1 (very inefficient though, therefore make it
   // bigger?).  This follows from [27.5.2.4.3]/12 (gptr needs to point at
   // something, it seems).
-  if (!p || !n)
+  if (! p || ! n)
     {
       // Replace existing buffer (if any) with small internal buffer
       this->disable_buffer ();
       buffer = 0;
       buffer_size = 0;
       own_buffer = true;
       this->enable_buffer ();
     }
@@ -389,17 +389,17 @@ gzfilebuf::sync ()
 
 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
 
 // Allocate internal buffer
 void
 gzfilebuf::enable_buffer ()
 {
   // If internal buffer required, allocate one
-  if (own_buffer && !buffer)
+  if (own_buffer && ! buffer)
     {
       // Check for buffered vs. "unbuffered"
       if (buffer_size > 0)
         {
           // Allocate internal buffer
           buffer = new char_type [buffer_size];
           // Get area starts empty and will be expanded by underflow as needed
           this->setg (buffer, buffer, buffer);
diff --git a/libinterp/dldfcn/__eigs__.cc b/libinterp/dldfcn/__eigs__.cc
--- a/libinterp/dldfcn/__eigs__.cc
+++ b/libinterp/dldfcn/__eigs__.cc
@@ -210,17 +210,17 @@ Undocumented internal function.\n\
           fname.append (fcn_name);
           fname.append ("(x) y = ");
           eigs_fcn = extract_function (args(0), "eigs", fcn_name, fname,
                                        "; endfunction");
         }
       else
         eigs_fcn = args(0).function_value ();
 
-      if (!eigs_fcn)
+      if (! eigs_fcn)
         error ("eigs: unknown function");
 
       if (nargin < 2)
         error ("eigs: incorrect number of arguments");
 
       n = args(1).nint_value ();
       arg_offset = 1;
       have_a_fun = true;
@@ -305,17 +305,17 @@ Undocumented internal function.\n\
         error ("eigs: OPTS argument must be a structure");
 
       octave_scalar_map map = args(3+arg_offset).xscalar_map_value ("eigs: OPTS argument must be a scalar structure");
 
       octave_value tmp;
 
       // issym is ignored for complex matrix inputs
       tmp = map.getfield ("issym");
-      if (tmp.is_defined () && !sym_tested)
+      if (tmp.is_defined () && ! sym_tested)
         {
           symmetric = tmp.double_value () != 0.;
           sym_tested = true;
         }
 
       // isreal is ignored if A is not a function
       tmp = map.getfield ("isreal");
       if (tmp.is_defined () && have_a_fun)
@@ -354,17 +354,17 @@ Undocumented internal function.\n\
       if (tmp.is_defined ())
         permB = ColumnVector (tmp.vector_value ()) - 1.0;
     }
 
   if (nargin > (4+arg_offset))
     error ("eigs: incorrect number of arguments");
 
   // Test undeclared (no issym) matrix inputs for symmetry
-  if (!sym_tested && !have_a_fun)
+  if (! sym_tested && ! have_a_fun)
     {
       if (a_is_sparse)
         symmetric = asmm.is_symmetric ();
       else
         symmetric = amm.is_symmetric ();
     }
 
   if (have_b)
diff --git a/libinterp/dldfcn/__glpk__.cc b/libinterp/dldfcn/__glpk__.cc
--- a/libinterp/dldfcn/__glpk__.cc
+++ b/libinterp/dldfcn/__glpk__.cc
@@ -171,27 +171,27 @@ glpk (int sense, int n, int m, double *c
       if (glp_write_lp (lp, NULL, tmp) != 0)
         {
           error ("__glpk__: unable to write problem");
           longjmp (mark, -1);
         }
     }
 
   // scale the problem data
-  if (!par->presol || lpsolver != 1)
+  if (! par->presol || lpsolver != 1)
     glp_scale_prob (lp, scale);
 
   // build advanced initial basis (if required)
-  if (lpsolver == 1 && !par->presol)
+  if (lpsolver == 1 && ! par->presol)
     glp_adv_basis (lp, 0);
 
   // For MIP problems without a presolver, a first pass with glp_simplex
   // is required
-  if ((!isMIP && lpsolver == 1)
-      || (isMIP && !par->presol))
+  if ((! isMIP && lpsolver == 1)
+      || (isMIP && ! par->presol))
     {
       glp_smcp smcp;
       glp_init_smcp (&smcp);
       smcp.msg_lev = par->msglev;
       smcp.meth = par->dual;
       smcp.pricing = par->price;
       smcp.r_test = par->rtest;
       smcp.tol_bnd = par->tolbnd;
@@ -218,17 +218,17 @@ glpk (int sense, int n, int m, double *c
       iocp.tol_obj = par->tolobj;
       iocp.tm_lim = par->tmlim;
       iocp.out_frq = par->outfrq;
       iocp.out_dly = par->outdly;
       iocp.presolve = par->presol;
       errnum = glp_intopt (lp, &iocp);
     }
 
-  if (!isMIP && lpsolver == 2)
+  if (! isMIP && lpsolver == 2)
     {
       glp_iptcp iptcp;
       glp_init_iptcp (&iptcp);
       iptcp.msg_lev = par->msglev;
       errnum = glp_interior (lp, &iptcp);
     }
 
   if (errnum == 0)
diff --git a/libinterp/dldfcn/__init_fltk__.cc b/libinterp/dldfcn/__init_fltk__.cc
--- a/libinterp/dldfcn/__init_fltk__.cc
+++ b/libinterp/dldfcn/__init_fltk__.cc
@@ -288,17 +288,17 @@ public:
 
     std::string menupath;
     for (int t = 0; t < menubar->size (); t++)
       {
         Fl_Menu_Item *m = const_cast<Fl_Menu_Item*> (&(menubar->menu ()[t]));
         if (m->submenu ())
           {
             // item has submenu
-            if (!menupath.empty ())
+            if (! menupath.empty ())
               menupath += "/";
             menupath += m->label ();
 
             if (menupath.compare (findname) == 0)
               return (t);
           }
         else
           {
@@ -309,17 +309,17 @@ public:
                 if (idx != std::string::npos)
                   menupath.erase (idx);
                 else
                   menupath.clear ();
                 continue;
               }
             // Menu item?
             std::string itempath = menupath;
-            if (!itempath.empty ())
+            if (! itempath.empty ())
               itempath += "/";
             itempath += m->label ();
 
             if (itempath.compare (findname) == 0)
               return (t);
           }
       }
     return (-1);
@@ -378,17 +378,17 @@ public:
 
     if (idx >= 0)
       menubar->remove (idx);
   }
 
   void update_accelerator (uimenu::properties& uimenup)
   {
     std::string fltk_label = uimenup.get_fltk_label ();
-    if (!fltk_label.empty ())
+    if (! fltk_label.empty ())
       {
         Fl_Menu_Item* item = const_cast<Fl_Menu_Item*> (menubar->find_item (
                                fltk_label.c_str ()));
         if (item)
           {
             std::string acc = uimenup.get_accelerator ();
             if (acc.length () > 0)
               {
@@ -397,52 +397,52 @@ public:
               }
           }
       }
   }
 
   void update_callback (uimenu::properties& uimenup)
   {
     std::string fltk_label = uimenup.get_fltk_label ();
-    if (!fltk_label.empty ())
+    if (! fltk_label.empty ())
       {
         Fl_Menu_Item* item = const_cast<Fl_Menu_Item*> (menubar->find_item (
                                fltk_label.c_str ()));
         if (item)
           {
-            if (!uimenup.get_callback ().is_empty ())
+            if (! uimenup.get_callback ().is_empty ())
               item->callback (static_cast<Fl_Callback*> (script_cb),
                               static_cast<void*> (&uimenup));
             else
               item->callback (0, static_cast<void*> (0));
           }
       }
   }
 
   void update_enable (uimenu::properties& uimenup)
   {
     std::string fltk_label = uimenup.get_fltk_label ();
-    if (!fltk_label.empty ())
+    if (! fltk_label.empty ())
       {
         Fl_Menu_Item* item = const_cast<Fl_Menu_Item*> (menubar->find_item (
                                fltk_label.c_str ()));
         if (item)
           {
             if (uimenup.is_enable ())
               item->activate ();
             else
               item->deactivate ();
           }
       }
   }
 
   void update_foregroundcolor (uimenu::properties& uimenup)
   {
     std::string fltk_label = uimenup.get_fltk_label ();
-    if (!fltk_label.empty ())
+    if (! fltk_label.empty ())
       {
         Fl_Menu_Item* item = const_cast<Fl_Menu_Item*> (menubar->find_item (
                                fltk_label.c_str ()));
         if (item)
           {
             Matrix rgb = uimenup.get_foregroundcolor_rgb ();
 
             uchar r = static_cast<uchar> (gnulib::floor (rgb (0) * 255));
@@ -455,17 +455,17 @@ public:
   }
 
   void update_seperator (const uimenu::properties& uimenup)
   {
     // Matlab places the separator before the current
     // menu entry, while fltk places it after. So we need to find
     // the previous item in this menu/submenu. (Kai)
     std::string fltk_label = uimenup.get_fltk_label ();
-    if (!fltk_label.empty ())
+    if (! fltk_label.empty ())
       {
         int itemflags = 0, idx;
         int curr_idx = find_index_by_name (fltk_label.c_str ());
 
         for (idx = curr_idx - 1; idx >= 0; idx--)
           {
             Fl_Menu_Item* item
               = const_cast<Fl_Menu_Item*> (&menubar->menu () [idx]);
@@ -485,17 +485,17 @@ public:
               menubar->mode (idx, itemflags & (~FL_MENU_DIVIDER));
           }
       }
   }
 
   void update_visible (uimenu::properties& uimenup)
   {
     std::string fltk_label = uimenup.get_fltk_label ();
-    if (!fltk_label.empty ())
+    if (! fltk_label.empty ())
       {
         Fl_Menu_Item* item
           = const_cast<Fl_Menu_Item*> (menubar->find_item (fltk_label.c_str ()));
         if (item)
           {
             if (uimenup.is_visible ())
               item->show ();
             else
@@ -509,17 +509,17 @@ public:
     uimenup.get_property ("position").set (octave_value (static_cast<double> (pos)), true, false);
   }
 
   void add_entry (uimenu::properties& uimenup)
   {
 
     std::string fltk_label = uimenup.get_fltk_label ();
 
-    if (!fltk_label.empty ())
+    if (! fltk_label.empty ())
       {
         bool item_added = false;
         do
           {
             const Fl_Menu_Item* item
               = menubar->find_item (fltk_label.c_str ());
 
             if (item)
@@ -549,17 +549,17 @@ public:
                 if (len > 0)
                   flags = FL_SUBMENU;
                 if (len == 0 && uimenup.is_checked ())
                   flags += FL_MENU_TOGGLE + FL_MENU_VALUE;
                 menubar->add (fltk_label.c_str (), 0, 0, 0, flags);
                 item_added = true;
               }
           }
-        while (!item_added);
+        while (! item_added);
         uimenup.set_fltk_label (fltk_label);
       }
   }
 
   void add_to_menu (uimenu::properties& uimenup)
   {
     std::vector<int> delayed_menus;
     Matrix kids = find_uimenu_children (uimenup);
@@ -766,17 +766,17 @@ public:
     help = new Fl_Button (4 * status_h, toolbar_y, status_h, status_h, "?");
     help->callback (button_callback, static_cast<void*> (this));
     help->tooltip ("Help");
 
     end ();
 
     set_name ();
     uimenu->add_to_menu (fp);
-    if (fp.menubar_is ("none") || !uimenu->items_to_show ())
+    if (fp.menubar_is ("none") || ! uimenu->items_to_show ())
       hide_menubar ();
 
     update_boundingbox (internal);
 
     if (fp.is_visible ())
       {
         // FIXME: This code should be removed when Octave drops support
         // for FLTK 1.1.  Search for default_xclass in this file to find
@@ -1177,17 +1177,17 @@ private:
         cbuf << "[azimuth: " << v(0) << ", elevation: " << v(1) << "]";
 
         status->value (cbuf.str ().c_str ());
       }
   }
 
   void set_currentpoint (int px, int py)
   {
-    if (!fp.is_beingdeleted ())
+    if (! fp.is_beingdeleted ())
       {
         Matrix pos = fp.map_from_boundingbox (px, py);
         fp.set_currentpoint (pos);
         graphics_object robj = gh_manager::get_object (fp.get_parent ());
         root_figure::properties& rp =
           dynamic_cast<root_figure::properties&> (robj.get_properties ());
         rp.set_currentfigure (fp.get___myhandle__ ().value ());
       }
@@ -1388,17 +1388,17 @@ private:
 
   int handle (int event)
   {
     if (event == FL_FOCUS)
       return 1;
 
     graphics_handle gh;
 
-    if (!fp.is_beingdeleted ())
+    if (! fp.is_beingdeleted ())
       {
         //std::cout << "plot_window::handle event = " <<  fl_eventnames[event] << std::endl;
 
         // FLTK resends keyboard events with flipped case if all
         // widgets rejects the event.
         // See Event Propagation http://www.fltk.org/doc-1.3/events.html
         static bool key_resent_detected = false;
 
diff --git a/libinterp/dldfcn/ccolamd.cc b/libinterp/dldfcn/ccolamd.cc
--- a/libinterp/dldfcn/ccolamd.cc
+++ b/libinterp/dldfcn/ccolamd.cc
@@ -508,27 +508,27 @@ ccolamd, csymamd, amd, colamd, symamd, a
       octave_idx_type cslen = in_cmember.numel ();
       OCTAVE_LOCAL_BUFFER (octave_idx_type, cmember, cslen);
       for (octave_idx_type i = 0; i < cslen; i++)
         // convert cmember from 1-based to 0-based
         cmember[i] = static_cast<octave_idx_type>(in_cmember(i) - 1);
 
       if (cslen != n_col)
         error ("csymamd: CMEMBER must be of length equal to #cols of A");
-      else if (!CSYMAMD_NAME () (n_col, ridx, cidx, perm, knobs, stats,
+      else if (! CSYMAMD_NAME () (n_col, ridx, cidx, perm, knobs, stats,
                                  &calloc, &free, cmember, -1))
         {
           CSYMAMD_NAME (_report) (stats) ;
 
           error ("csymamd: internal error!") ;
         }
     }
   else
     {
-      if (!CSYMAMD_NAME () (n_col, ridx, cidx, perm, knobs, stats,
+      if (! CSYMAMD_NAME () (n_col, ridx, cidx, perm, knobs, stats,
                             &calloc, &free, 0, -1))
         {
           CSYMAMD_NAME (_report) (stats) ;
 
           error ("csymamd: internal error!") ;
         }
     }
 
diff --git a/libinterp/dldfcn/colamd.cc b/libinterp/dldfcn/colamd.cc
--- a/libinterp/dldfcn/colamd.cc
+++ b/libinterp/dldfcn/colamd.cc
@@ -581,17 +581,17 @@ Xerox PARC, and @nospell{Esmond Ng}, Oak
     }
 
   if (n_row != n_col)
     error ("symamd: matrix S must be square");
 
   // Allocate workspace for symamd
   OCTAVE_LOCAL_BUFFER (octave_idx_type, perm, n_col+1);
   OCTAVE_LOCAL_BUFFER (octave_idx_type, stats, COLAMD_STATS);
-  if (!SYMAMD_NAME () (n_col, ridx, cidx, perm,
+  if (! SYMAMD_NAME () (n_col, ridx, cidx, perm,
                        knobs, stats, &calloc, &free))
     {
       SYMAMD_NAME (_report) (stats) ;
 
       error ("symamd: internal error!") ;
     }
 
   // column elimination tree post-ordering
diff --git a/libinterp/octave-value/ov-base-diag.cc b/libinterp/octave-value/ov-base-diag.cc
--- a/libinterp/octave-value/ov-base-diag.cc
+++ b/libinterp/octave-value/ov-base-diag.cc
@@ -504,17 +504,17 @@ octave_base_diag<DMT, MT>::load_ascii (s
 
   if (extract_keyword (is, "rows", r, true)
       && extract_keyword (is, "columns", c, true))
     {
       octave_idx_type l = r < c ? r : c;
       MT tmp (l, 1);
       is >> tmp;
 
-      if (!is)
+      if (! is)
         error ("load: failed to load diagonal matrix constant");
       else
         {
           // This is a little tricky, as we have the Matrix type, but
           // not ColumnVector type. We need to help the compiler get
           // through the inheritance tree.
           typedef typename DMT::element_type el_type;
           matrix = DMT (MDiagArray2<el_type> (MArray<el_type> (tmp)));
diff --git a/libinterp/octave-value/ov-base-int.cc b/libinterp/octave-value/ov-base-int.cc
--- a/libinterp/octave-value/ov-base-int.cc
+++ b/libinterp/octave-value/ov-base-int.cc
@@ -216,17 +216,17 @@ octave_base_int_matrix<T>::load_ascii (s
 
           for (int i = 0; i < mdims; i++)
             is >> dv(i);
 
           T tmp(dv);
 
           is >> tmp;
 
-          if (!is)
+          if (! is)
             error ("load: failed to load matrix constant");
 
           this->matrix = tmp;
         }
       else
         error ("load: failed to extract number of rows and columns");
     }
   else
diff --git a/libinterp/octave-value/ov-base-sparse.cc b/libinterp/octave-value/ov-base-sparse.cc
--- a/libinterp/octave-value/ov-base-sparse.cc
+++ b/libinterp/octave-value/ov-base-sparse.cc
@@ -450,17 +450,17 @@ octave_base_sparse<T>::load_ascii (std::
   if (extract_keyword (is, "nnz", nz, true)
       && extract_keyword (is, "rows", nr, true)
       && extract_keyword (is, "columns", nc, true))
     {
       T tmp (nr, nc, nz);
 
       is >> tmp;
 
-      if (!is)
+      if (! is)
         error ("load: failed to load matrix constant");
 
       matrix = tmp;
     }
   else
     error ("load: failed to extract number of rows and columns");
 
   return success;
diff --git a/libinterp/octave-value/ov-bool-mat.cc b/libinterp/octave-value/ov-bool-mat.cc
--- a/libinterp/octave-value/ov-bool-mat.cc
+++ b/libinterp/octave-value/ov-bool-mat.cc
@@ -580,15 +580,15 @@ Compatibility Note: Octave accepts compl
     gripe_wrong_type_arg ("logical", arg);
 
   return retval;
 }
 
 /*
 %!test
 %! m = eye (2) != 0;
-%! s = !0;
+%! s = ! 0;
 %! c = {"double", "single", "int8", "int16", "int32", "int64", "uint8", "uint16", "uint32", "uint64", "logical"};
 %! for i = 1:numel (c)
 %!   assert (logical (eye (2, c{i})), m)
 %!   assert (logical (eye (1, c{i})), s)
 %! endfor
 */
diff --git a/libinterp/octave-value/ov-bool-sparse.cc b/libinterp/octave-value/ov-bool-sparse.cc
--- a/libinterp/octave-value/ov-bool-sparse.cc
+++ b/libinterp/octave-value/ov-bool-sparse.cc
@@ -383,17 +383,17 @@ octave_sparse_bool_matrix::save_hdf5 (oc
       H5Gclose (group_hid);
       return false;
     }
 
   tmp = m.rows ();
   retval = H5Dwrite (data_hid, H5T_NATIVE_IDX, H5S_ALL,
                      H5S_ALL, H5P_DEFAULT, &tmp) >= 0;
   H5Dclose (data_hid);
-  if (!retval)
+  if (! retval)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
 
 #if HAVE_HDF5_18
   data_hid = H5Dcreate (group_hid, "nc", H5T_NATIVE_IDX, space_hid,
@@ -408,17 +408,17 @@ octave_sparse_bool_matrix::save_hdf5 (oc
       H5Gclose (group_hid);
       return false;
     }
 
   tmp = m.cols ();
   retval = H5Dwrite (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL,
                      H5P_DEFAULT, &tmp) >= 0;
   H5Dclose (data_hid);
-  if (!retval)
+  if (! retval)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
 
 #if HAVE_HDF5_18
   data_hid = H5Dcreate (group_hid, "nz", H5T_NATIVE_IDX, space_hid,
@@ -433,17 +433,17 @@ octave_sparse_bool_matrix::save_hdf5 (oc
       H5Gclose (group_hid);
       return false;
     }
 
   tmp = m.nnz ();
   retval = H5Dwrite (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL,
                      H5P_DEFAULT, &tmp) >= 0;
   H5Dclose (data_hid);
-  if (!retval)
+  if (! retval)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   H5Sclose (space_hid);
 
@@ -471,17 +471,17 @@ octave_sparse_bool_matrix::save_hdf5 (oc
       H5Gclose (group_hid);
       return false;
     }
 
   octave_idx_type * itmp = m.xcidx ();
   retval = H5Dwrite (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL,
                      H5P_DEFAULT, itmp) >= 0;
   H5Dclose (data_hid);
-  if (!retval)
+  if (! retval)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   H5Sclose (space_hid);
 
@@ -509,17 +509,17 @@ octave_sparse_bool_matrix::save_hdf5 (oc
       H5Gclose (group_hid);
       return false;
     }
 
   itmp = m.xridx ();
   retval = H5Dwrite (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL,
                      H5P_DEFAULT, itmp) >= 0;
   H5Dclose (data_hid);
-  if (!retval)
+  if (! retval)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
 
 #if HAVE_HDF5_18
   data_hid = H5Dcreate (group_hid, "data", H5T_NATIVE_HBOOL, space_hid,
diff --git a/libinterp/octave-value/ov-bool.cc b/libinterp/octave-value/ov-bool.cc
--- a/libinterp/octave-value/ov-bool.cc
+++ b/libinterp/octave-value/ov-bool.cc
@@ -124,17 +124,17 @@ octave_bool::save_ascii (std::ostream& o
   return true;
 }
 
 bool
 octave_bool::load_ascii (std::istream& is)
 {
   scalar = (octave_read_value<double> (is) != 0.);
 
-  if (!is)
+  if (! is)
     error ("load: failed to load scalar constant");
 
   return true;
 }
 
 bool
 octave_bool::save_binary (std::ostream& os, bool& /* save_as_floats */)
 {
diff --git a/libinterp/octave-value/ov-class.cc b/libinterp/octave-value/ov-class.cc
--- a/libinterp/octave-value/ov-class.cc
+++ b/libinterp/octave-value/ov-class.cc
@@ -1167,17 +1167,17 @@ octave_class::reconstruct_parents (void)
           octave_class::exemplar_info exmplr = it->second;
           parent_list = exmplr.parents ();
           for (std::list<std::string>::iterator pit = parent_list.begin ();
                pit != parent_list.end ();
                pit++)
             {
               dbgstr = *pit;
               bool dbgbool = map.contains (*pit);
-              if (!dbgbool)
+              if (! dbgbool)
                 {
                   retval = false;
                   break;
                 }
             }
         }
     }
 
@@ -1610,17 +1610,17 @@ octave_class::load_hdf5 (octave_hdf5_id 
       m.assign (dsub.name, tcell);
 
     }
 
   if (retval2 >= 0)
     {
       map = m;
 
-      if (!reconstruct_parents ())
+      if (! reconstruct_parents ())
         warning ("load: unable to reconstruct object inheritance");
 
       if (load_path::find_method (c_name, "loadobj") != std::string ())
         {
           octave_value in = new octave_class (*this);
           octave_value_list tmp = feval ("loadobj", in, 1);
 
           map = tmp(0).map_value ();
diff --git a/libinterp/octave-value/ov-cx-sparse.cc b/libinterp/octave-value/ov-cx-sparse.cc
--- a/libinterp/octave-value/ov-cx-sparse.cc
+++ b/libinterp/octave-value/ov-cx-sparse.cc
@@ -416,17 +416,17 @@ octave_sparse_complex_matrix::save_hdf5 
       H5Gclose (group_hid);
       return false;
     }
 
   tmp = m.rows ();
   retval = H5Dwrite (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL,
                      H5P_DEFAULT, &tmp) >= 0;
   H5Dclose (data_hid);
-  if (!retval)
+  if (! retval)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
 
 #if HAVE_HDF5_18
   data_hid = H5Dcreate (group_hid, "nc", H5T_NATIVE_IDX, space_hid,
@@ -441,17 +441,17 @@ octave_sparse_complex_matrix::save_hdf5 
       H5Gclose (group_hid);
       return false;
     }
 
   tmp = m.cols ();
   retval = H5Dwrite (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL,
                      H5P_DEFAULT, &tmp) >= 0;
   H5Dclose (data_hid);
-  if (!retval)
+  if (! retval)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
 
 #if HAVE_HDF5_18
   data_hid = H5Dcreate (group_hid, "nz", H5T_NATIVE_IDX, space_hid,
@@ -466,17 +466,17 @@ octave_sparse_complex_matrix::save_hdf5 
       H5Gclose (group_hid);
       return false;
     }
 
   tmp = m.nnz ();
   retval = H5Dwrite (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL,
                      H5P_DEFAULT, &tmp) >= 0;
   H5Dclose (data_hid);
-  if (!retval)
+  if (! retval)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   H5Sclose (space_hid);
 
@@ -504,17 +504,17 @@ octave_sparse_complex_matrix::save_hdf5 
       H5Gclose (group_hid);
       return false;
     }
 
   octave_idx_type * itmp = m.xcidx ();
   retval = H5Dwrite (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL,
                      H5P_DEFAULT, itmp) >= 0;
   H5Dclose (data_hid);
-  if (!retval)
+  if (! retval)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   H5Sclose (space_hid);
 
@@ -542,17 +542,17 @@ octave_sparse_complex_matrix::save_hdf5 
       H5Gclose (group_hid);
       return false;
     }
 
   itmp = m.xridx ();
   retval = H5Dwrite (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL, H5P_DEFAULT,
                      itmp) >= 0;
   H5Dclose (data_hid);
-  if (!retval)
+  if (! retval)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   hid_t save_type_hid = H5T_NATIVE_DOUBLE;
 
diff --git a/libinterp/octave-value/ov-fcn-handle.cc b/libinterp/octave-value/ov-fcn-handle.cc
--- a/libinterp/octave-value/ov-fcn-handle.cc
+++ b/libinterp/octave-value/ov-fcn-handle.cc
@@ -447,17 +447,17 @@ octave_fcn_handle::load_ascii (std::istr
               for (octave_idx_type i = 0; i < len; i++)
                 {
                   octave_value t2;
                   bool dummy;
 
                   std::string name
                     = read_text_data (is, std::string (), dummy, t2, i);
 
-                  if (!is)
+                  if (! is)
                     {
                       error ("load: failed to load anonymous function handle");
                       break;
                     }
 
                   symbol_table::assign (name, t2, local_scope, 0);
                 }
             }
@@ -632,17 +632,17 @@ octave_fcn_handle::load_binary (std::ist
               octave_value t2;
               bool dummy;
               std::string doc;
 
               std::string name =
                 read_binary_data (is, swap, fmt, std::string (),
                                   dummy, t2, doc);
 
-              if (!is)
+              if (! is)
                 {
                   error ("load: failed to load anonymous function handle");
                   break;
                 }
 
               symbol_table::assign (name, t2, local_scope);
             }
         }
diff --git a/libinterp/octave-value/ov-fcn-inline.cc b/libinterp/octave-value/ov-fcn-inline.cc
--- a/libinterp/octave-value/ov-fcn-inline.cc
+++ b/libinterp/octave-value/ov-fcn-inline.cc
@@ -339,17 +339,17 @@ octave_fcn_inline::save_hdf5 (octave_hdf
     }
 
   retval = H5Dwrite (data_hid, H5T_NATIVE_CHAR, H5S_ALL, H5S_ALL,
                      H5P_DEFAULT, s) >= 0;
 
   H5Dclose (data_hid);
   H5Sclose (space_hid);
 
-  if (!retval)
+  if (! retval)
     {
       H5Gclose (group_hid);
       return false;
     }
 
   // attach the type of the variable
   type_hid = H5Tcopy (H5T_C_S1);
   H5Tset_size (type_hid, nm.length () + 1);
diff --git a/libinterp/octave-value/ov-java.cc b/libinterp/octave-value/ov-java.cc
--- a/libinterp/octave-value/ov-java.cc
+++ b/libinterp/octave-value/ov-java.cc
@@ -503,21 +503,21 @@ initialize_jvm (void)
 #else
   std::string jvm_lib_path = JAVA_LDPATH + std::string ("/libjvm.so");
 #endif
 
 #endif
 
   jsize nVMs = 0;
 
-# if !defined (__APPLE__) && !defined (__MACH__)
+# if ! defined (__APPLE__) && ! defined (__MACH__)
 
   octave_shlib lib (jvm_lib_path);
 
-  if (!lib)
+  if (! lib)
     throw std::string ("unable to load Java Runtime Environment from ")
           + jvm_lib_path;
 
 #if defined (__WIN32__)
 
   set_dll_directory ();
 
   if (! old_cwd.empty ())
@@ -525,20 +525,20 @@ initialize_jvm (void)
 
 #endif
 
   JNI_CreateJavaVM_t create_vm =
     reinterpret_cast<JNI_CreateJavaVM_t> (lib.search ("JNI_CreateJavaVM"));
   JNI_GetCreatedJavaVMs_t get_vm =
     reinterpret_cast<JNI_GetCreatedJavaVMs_t> (lib.search ("JNI_GetCreatedJavaVMs"));
 
-  if (!create_vm)
+  if (! create_vm)
     throw std::string ("unable to find JNI_CreateJavaVM in ") + jvm_lib_path;
 
-  if (!get_vm)
+  if (! get_vm)
     throw std::string ("unable to find JNI_GetCreatedJavaVMs in ")
           + jvm_lib_path;
 
   if (get_vm (&jvm, 1, &nVMs) == 0 && nVMs > 0)
 
 #else
 
   // FIXME: There exists a problem on the Mac platform that
@@ -585,17 +585,17 @@ initialize_jvm (void)
       JVMArgs vm_args;
 
       vm_args.add ("-Djava.class.path=" + initial_class_path ());
       vm_args.add ("-Xrs");
       vm_args.add ("-Djava.system.class.loader=org.octave.OctClassLoader");
       vm_args.read_java_opts (initial_java_dir () + file_ops::dir_sep_str () +
                               "java.opts");
 
-# if !defined (__APPLE__) && !defined (__MACH__)
+# if ! defined (__APPLE__) && ! defined (__MACH__)
 
       if (create_vm (&jvm, &current_env, vm_args.to_args ()) != JNI_OK)
         throw std::string ("unable to start Java VM in ")+jvm_lib_path;
       //printf ("JVM created\n");
     }
 
   jvm_lib = lib;
 
@@ -1351,17 +1351,17 @@ unbox (JNIEnv* jni_env, const octave_val
 #undef IF_UNBOX_PRIMITIVE_SCALAR
     }
   else if (val.is_empty ())
     {
       jobj = 0;
       jcls = 0;
       //jcls = jni_env->FindClass ("java/lang/Object");
     }
-  else if (!Vjava_matrix_autoconversion
+  else if (! Vjava_matrix_autoconversion
            && ((val.is_real_matrix ()
                 && (val.rows () == 1 || val.columns () == 1))
                || val.is_range ()))
     {
       Matrix m = val.matrix_value ();
       jdoubleArray dv = jni_env->NewDoubleArray (m.numel ());
       jni_env->SetDoubleArrayRegion (dv, 0, m.numel (), m.fortran_vec ());
       jobj = dv;
diff --git a/libinterp/octave-value/ov-perm.cc b/libinterp/octave-value/ov-perm.cc
--- a/libinterp/octave-value/ov-perm.cc
+++ b/libinterp/octave-value/ov-perm.cc
@@ -287,17 +287,17 @@ octave_perm_matrix::load_ascii (std::ist
   char orient;
 
   if (extract_keyword (is, "size", n, true)
       && extract_keyword (is, "orient", orient, true))
     {
       bool colp = orient == 'c';
       ColumnVector tmp (n);
       is >> tmp;
-      if (!is)
+      if (! is)
         error ("load: failed to load permutation matrix constant");
       else
         {
           Array<octave_idx_type> pvec (dim_vector (n, 1));
           for (octave_idx_type i = 0; i < n; i++) pvec(i) = tmp(i) - 1;
           matrix = PermMatrix (pvec, colp);
 
           // Invalidate cache. Probably not necessary, but safe.
diff --git a/libinterp/octave-value/ov-re-sparse.cc b/libinterp/octave-value/ov-re-sparse.cc
--- a/libinterp/octave-value/ov-re-sparse.cc
+++ b/libinterp/octave-value/ov-re-sparse.cc
@@ -445,17 +445,17 @@ octave_sparse_matrix::save_hdf5 (octave_
       H5Gclose (group_hid);
       return false;
     }
 
   tmp = m.rows ();
   retval = H5Dwrite (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL, H5P_DEFAULT,
                      &tmp) >= 0;
   H5Dclose (data_hid);
-  if (!retval)
+  if (! retval)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
 #if HAVE_HDF5_18
   data_hid = H5Dcreate (group_hid, "nc", H5T_NATIVE_IDX, space_hid,
                         H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
@@ -469,17 +469,17 @@ octave_sparse_matrix::save_hdf5 (octave_
       H5Gclose (group_hid);
       return false;
     }
 
   tmp = m.cols ();
   retval = H5Dwrite (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL, H5P_DEFAULT,
                      &tmp) >= 0;
   H5Dclose (data_hid);
-  if (!retval)
+  if (! retval)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
 
 #if HAVE_HDF5_18
   data_hid = H5Dcreate (group_hid, "nz", H5T_NATIVE_IDX, space_hid,
@@ -494,17 +494,17 @@ octave_sparse_matrix::save_hdf5 (octave_
       H5Gclose (group_hid);
       return false;
     }
 
   tmp = m.nnz ();
   retval = H5Dwrite (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL, H5P_DEFAULT,
                      &tmp) >= 0;
   H5Dclose (data_hid);
-  if (!retval)
+  if (! retval)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   H5Sclose (space_hid);
 
@@ -532,17 +532,17 @@ octave_sparse_matrix::save_hdf5 (octave_
       H5Gclose (group_hid);
       return false;
     }
 
   octave_idx_type * itmp = m.xcidx ();
   retval = H5Dwrite (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL, H5P_DEFAULT,
                      itmp) >= 0;
   H5Dclose (data_hid);
-  if (!retval)
+  if (! retval)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   H5Sclose (space_hid);
 
@@ -569,17 +569,17 @@ octave_sparse_matrix::save_hdf5 (octave_
       H5Gclose (group_hid);
       return false;
     }
 
   itmp = m.xridx ();
   retval = H5Dwrite (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL, H5P_DEFAULT,
                      itmp) >= 0;
   H5Dclose (data_hid);
-  if (!retval)
+  if (! retval)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   hid_t save_type_hid = H5T_NATIVE_DOUBLE;
 
diff --git a/libinterp/octave-value/ov-str-mat.cc b/libinterp/octave-value/ov-str-mat.cc
--- a/libinterp/octave-value/ov-str-mat.cc
+++ b/libinterp/octave-value/ov-str-mat.cc
@@ -365,17 +365,17 @@ octave_char_matrix_str::load_ascii (std:
                   if (tmp.is_empty ())
                     matrix = tmp;
                   else
                     {
                       char *ftmp = tmp.fortran_vec ();
 
                       skip_preceeding_newline (is);
 
-                      if (! is.read (ftmp, dv.numel ()) || !is)
+                      if (! is.read (ftmp, dv.numel ()) || ! is)
                         error ("load: failed to load string constant");
                       else
                         matrix = tmp;
                     }
                 }
               else
                 {
                   error ("load: failed to read dimensions");
diff --git a/libinterp/octave-value/ov-struct.cc b/libinterp/octave-value/ov-struct.cc
--- a/libinterp/octave-value/ov-struct.cc
+++ b/libinterp/octave-value/ov-struct.cc
@@ -739,17 +739,17 @@ octave_struct::load_ascii (std::istream&
             {
               octave_value t2;
               bool dummy;
 
               // recurse to read cell elements
               std::string nm
                 = read_text_data (is, std::string (), dummy, t2, j);
 
-              if (!is)
+              if (! is)
                 break;
 
               Cell tcell = t2.is_cell () ? t2.xcell_value ("load: internal error loading struct elements") : Cell (t2);
 
               m.setfield (nm, tcell);
             }
 
           if (is)
@@ -858,17 +858,17 @@ octave_struct::load_binary (std::istream
           octave_value t2;
           bool dummy;
           std::string doc;
 
           // recurse to read cell elements
           std::string nm = read_binary_data (is, swap, fmt, std::string (),
                                              dummy, t2, doc);
 
-          if (!is)
+          if (! is)
             break;
 
           Cell tcell = t2.is_cell () ? t2.xcell_value ("load: internal error loading struct elements") : Cell (t2);
 
           m.setfield (nm, tcell);
         }
 
       if (is)
@@ -1383,17 +1383,17 @@ octave_scalar_struct::load_ascii (std::i
             {
               octave_value t2;
               bool dummy;
 
               // recurse to read cell elements
               std::string nm
                 = read_text_data (is, std::string (), dummy, t2, j);
 
-              if (!is)
+              if (! is)
                 break;
 
               m.setfield (nm, t2);
             }
 
           if (is)
             map = m;
           else
@@ -1464,17 +1464,17 @@ octave_scalar_struct::load_binary (std::
           octave_value t2;
           bool dummy;
           std::string doc;
 
           // recurse to read cell elements
           std::string nm = read_binary_data (is, swap, fmt, std::string (),
                                              dummy, t2, doc);
 
-          if (!is)
+          if (! is)
             break;
 
           m.setfield (nm, t2);
         }
 
       if (is)
         map = m;
       else
diff --git a/libinterp/octave-value/ov.cc b/libinterp/octave-value/ov.cc
--- a/libinterp/octave-value/ov.cc
+++ b/libinterp/octave-value/ov.cc
@@ -1597,17 +1597,17 @@ make_vector_dims (const dim_vector& dv, 
                   const std::string& my_type, const std::string& wanted_type)
 {
   dim_vector retval (dv);
   retval.chop_trailing_singletons ();
   octave_idx_type nel = dv.numel ();
 
   if (retval.length () > 2 || (retval(0) != 1 && retval(1) != 1))
     {
-      if (!force_vector_conversion)
+      if (! force_vector_conversion)
         gripe_implicit_conversion ("Octave:array-to-vector",
                                    my_type.c_str (), wanted_type.c_str ());
       retval = dim_vector (nel, 1);
     }
 
   return retval;
 }
 
diff --git a/libinterp/parse-tree/pt-mat.cc b/libinterp/parse-tree/pt-mat.cc
--- a/libinterp/parse-tree/pt-mat.cc
+++ b/libinterp/parse-tree/pt-mat.cc
@@ -322,23 +322,23 @@ tm_row_const::tm_row_const_rep::do_init_
     some_str = true;
 
   if (all_real && ! val.is_real_type ())
     all_real = false;
 
   if (all_cmplx && ! (val.is_complex_type () || val.is_real_type ()))
     all_cmplx = false;
 
-  if (!any_cell && val.is_cell ())
+  if (! any_cell && val.is_cell ())
     any_cell = true;
 
-  if (!any_sparse && val.is_sparse_type ())
+  if (! any_sparse && val.is_sparse_type ())
     any_sparse = true;
 
-  if (!any_class && val.is_object ())
+  if (! any_class && val.is_object ())
     any_class = true;
 
   // Special treatment of sparse matrices to avoid out-of-memory error
   all_1x1 = all_1x1 && ! val.is_sparse_type () && val.numel () == 1;
 }
 
 void
 tm_row_const::tm_row_const_rep::init (const tree_argument_list& row)
@@ -578,23 +578,23 @@ tm_const::init (const tree_matrix& tm)
             all_real = false;
 
           if (all_cmplx && ! tmp.all_complex_p ())
             all_cmplx = false;
 
           if (all_mt && ! tmp.all_empty_p ())
             all_mt = false;
 
-          if (!any_cell && tmp.any_cell_p ())
+          if (! any_cell && tmp.any_cell_p ())
             any_cell = true;
 
-          if (!any_sparse && tmp.any_sparse_p ())
+          if (! any_sparse && tmp.any_sparse_p ())
             any_sparse = true;
 
-          if (!any_class && tmp.any_class_p ())
+          if (! any_class && tmp.any_class_p ())
             any_class = true;
 
           all_1x1 = all_1x1 && tmp.all_1x1_p ();
 
           append (tmp);
         }
       else
         break;
@@ -638,17 +638,17 @@ tm_const::init (const tree_matrix& tm)
                && this_elt_dv.length () == 2)
         {
           // FIXME: this is Octave's specialty. Character matrices allow
           // rows of unequal length.
           if (this_elt_nc > cols ())
             dv(1) = this_elt_nc;
           dv(0) += this_elt_nr;
         }
-      else if ((!any_class) && (!dv.hvcat (this_elt_dv, 0)))
+      else if ((! any_class) && (! dv.hvcat (this_elt_dv, 0)))
         eval_error ("vertical dimensions mismatch", dv, this_elt_dv);
     }
 
   ok = true;
 }
 
 octave_value_list
 tree_matrix::rvalue (int nargout)
diff --git a/liboctave/array/Array.cc b/liboctave/array/Array.cc
--- a/liboctave/array/Array.cc
+++ b/liboctave/array/Array.cc
@@ -1431,17 +1431,17 @@ Array<T>::delete_elements (const idx_vec
         {
           // Stack "pop" operation.
           resize1 (n-1);
         }
       else if (i.is_cont_range (n, l, u))
         {
           // Special case deleting a contiguous range.
           octave_idx_type m = n + l - u;
-          Array<T> tmp (dim_vector (col_vec ? m : 1, !col_vec ? m : 1));
+          Array<T> tmp (dim_vector (col_vec ? m : 1, ! col_vec ? m : 1));
           const T *src = data ();
           T *dest = tmp.fortran_vec ();
           std::copy (src, src + l, dest);
           std::copy (src + u, src + n, dest + l);
           *this = tmp;
         }
       else
         {
diff --git a/liboctave/array/Array.h b/liboctave/array/Array.h
--- a/liboctave/array/Array.h
+++ b/liboctave/array/Array.h
@@ -35,17 +35,17 @@ along with Octave; see the file COPYING.
 #include "dim-vector.h"
 #include "idx-vector.h"
 #include "lo-traits.h"
 #include "lo-utils.h"
 #include "oct-sort.h"
 #include "quit.h"
 #include "oct-refcount.h"
 
-//!Handles the reference counting for all the derived classes.
+//! Handles the reference counting for all the derived classes.
 template <class T>
 class
 Array
 {
 protected:
 
   //! The real representation of all arrays.
   class ArrayRep
diff --git a/liboctave/array/CMatrix.cc b/liboctave/array/CMatrix.cc
--- a/liboctave/array/CMatrix.cc
+++ b/liboctave/array/CMatrix.cc
@@ -1204,17 +1204,17 @@ ComplexMatrix::inverse (MatrixType &matt
               else
                 rcon = 1.0;
               ret = chol.inverse ();
             }
           else
             mattype.mark_as_unsymmetric ();
         }
 
-      if (!mattype.is_hermitian ())
+      if (! mattype.is_hermitian ())
         ret = finverse (mattype, info, rcon, force, calc_cond);
 
       if ((mattype.is_hermitian () || calc_cond) && rcon == 0.)
         ret = ComplexMatrix (rows (), columns (), Complex (octave_Inf, 0.));
     }
 
   return ret;
 }
diff --git a/liboctave/array/CSparse.cc b/liboctave/array/CSparse.cc
--- a/liboctave/array/CSparse.cc
+++ b/liboctave/array/CSparse.cc
@@ -1122,17 +1122,17 @@ SparseComplexMatrix::inverse (MatrixType
             }
           else
             {
               // Matrix is either singular or not positive definite
               mattype.mark_as_unsymmetric ();
             }
         }
 
-      if (!mattype.is_hermitian ())
+      if (! mattype.is_hermitian ())
         {
           octave_idx_type n = rows ();
           ColumnVector Qinit(n);
           for (octave_idx_type i = 0; i < n; i++)
             Qinit(i) = i;
 
           MatrixType tmp_typ (MatrixType::Upper);
           SparseComplexLU fact (*this, Qinit, Matrix (), false, false);
@@ -1185,29 +1185,29 @@ SparseComplexMatrix::determinant (octave
       err = 0;
 
       // Setup the control parameters
       Matrix Control (UMFPACK_CONTROL, 1);
       double *control = Control.fortran_vec ();
       UMFPACK_ZNAME (defaults) (control);
 
       double tmp = octave_sparse_params::get_key ("spumoni");
-      if (!xisnan (tmp))
+      if (! xisnan (tmp))
         Control (UMFPACK_PRL) = tmp;
 
       tmp = octave_sparse_params::get_key ("piv_tol");
-      if (!xisnan (tmp))
+      if (! xisnan (tmp))
         {
           Control (UMFPACK_SYM_PIVOT_TOLERANCE) = tmp;
           Control (UMFPACK_PIVOT_TOLERANCE) = tmp;
         }
 
       // Set whether we are allowed to modify Q or not
       tmp = octave_sparse_params::get_key ("autoamd");
-      if (!xisnan (tmp))
+      if (! xisnan (tmp))
         Control (UMFPACK_FIXQ) = tmp;
 
       // Turn-off UMFPACK scaling for LU
       Control (UMFPACK_SCALE) = UMFPACK_SCALE_NONE;
 
       UMFPACK_ZNAME (report_control) (control);
 
       const octave_idx_type *Ap = cidx ();
@@ -5459,28 +5459,28 @@ SparseComplexMatrix::factorize (octave_i
 
 #ifdef HAVE_UMFPACK
   // Setup the control parameters
   Control = Matrix (UMFPACK_CONTROL, 1);
   double *control = Control.fortran_vec ();
   UMFPACK_ZNAME (defaults) (control);
 
   double tmp = octave_sparse_params::get_key ("spumoni");
-  if (!xisnan (tmp))
+  if (! xisnan (tmp))
     Control (UMFPACK_PRL) = tmp;
   tmp = octave_sparse_params::get_key ("piv_tol");
-  if (!xisnan (tmp))
+  if (! xisnan (tmp))
     {
       Control (UMFPACK_SYM_PIVOT_TOLERANCE) = tmp;
       Control (UMFPACK_PIVOT_TOLERANCE) = tmp;
     }
 
   // Set whether we are allowed to modify Q or not
   tmp = octave_sparse_params::get_key ("autoamd");
-  if (!xisnan (tmp))
+  if (! xisnan (tmp))
     Control (UMFPACK_FIXQ) = tmp;
 
   UMFPACK_ZNAME (report_control) (control);
 
   const octave_idx_type *Ap = cidx ();
   const octave_idx_type *Ai = ridx ();
   const Complex *Ax = data ();
   octave_idx_type nr = rows ();
diff --git a/liboctave/array/MatrixType.cc b/liboctave/array/MatrixType.cc
--- a/liboctave/array/MatrixType.cc
+++ b/liboctave/array/MatrixType.cc
@@ -324,17 +324,17 @@ MatrixType::MatrixType (const SparseMatr
               if (j - ru > upper_band)
                 upper_band = j - ru;
 
               if (rl - j > lower_band)
                 lower_band = rl - j;
             }
         }
 
-      if (!singular)
+      if (! singular)
         {
           bandden = double (nnz) /
                     (double (ncols) * (double (lower_band) +
                                        double (upper_band)) -
                      0.5 * double (upper_band + 1) * double (upper_band) -
                      0.5 * double (lower_band + 1) * double (lower_band));
 
           if (nrows == ncols && sp_bandden != 1. && bandden > sp_bandden)
@@ -386,17 +386,17 @@ MatrixType::MatrixType (const SparseMatr
                       && (a.ridx (a.cidx (j+1)-1) == i))
                     {
                       perm[i] = j;
                       found = true;
                       break;
                     }
                 }
 
-              if (!found)
+              if (! found)
                 break;
             }
 
           if (found)
             {
               typ = MatrixType::Permuted_Upper;
               if (ncols > nrows)
                 {
@@ -642,17 +642,17 @@ MatrixType::MatrixType (const SparseComp
               if (j - ru > upper_band)
                 upper_band = j - ru;
 
               if (rl - j > lower_band)
                 lower_band = rl - j;
             }
         }
 
-      if (!singular)
+      if (! singular)
         {
           bandden = double (nnz) /
                     (double (ncols) * (double (lower_band) +
                                        double (upper_band)) -
                      0.5 * double (upper_band + 1) * double (upper_band) -
                      0.5 * double (lower_band + 1) * double (lower_band));
 
           if (nrows == ncols && sp_bandden != 1. && bandden > sp_bandden)
@@ -704,17 +704,17 @@ MatrixType::MatrixType (const SparseComp
                       && (a.ridx (a.cidx (j+1)-1) == i))
                     {
                       perm[i] = j;
                       found = true;
                       break;
                     }
                 }
 
-              if (!found)
+              if (! found)
                 break;
             }
 
           if (found)
             {
               typ = MatrixType::Permuted_Upper;
               if (ncols > nrows)
                 {
@@ -960,17 +960,17 @@ MatrixType::operator = (const MatrixType
 }
 
 int
 MatrixType::type (bool quiet)
 {
   if (typ != MatrixType::Unknown
       && (full || sp_bandden == octave_sparse_params::get_bandden ()))
     {
-      if (!quiet && octave_sparse_params::get_key ("spumoni") != 0.)
+      if (! quiet && octave_sparse_params::get_key ("spumoni") != 0.)
         warn_cached ();
 
       return typ;
     }
 
   if (typ != MatrixType::Unknown
       && octave_sparse_params::get_key ("spumoni") != 0.)
     (*current_liboctave_warning_with_id_handler)
diff --git a/liboctave/array/PermMatrix.cc b/liboctave/array/PermMatrix.cc
--- a/liboctave/array/PermMatrix.cc
+++ b/liboctave/array/PermMatrix.cc
@@ -43,17 +43,17 @@ PermMatrix::setup (const Array<octave_id
     {
       if (! idx_vector (p).is_permutation (p.numel ()))
         {
           gripe_invalid_permutation ();
           Array<octave_idx_type>::operator = (Array<octave_idx_type> ());
         }
     }
 
-  if (!colp)
+  if (! colp)
     *this = this->transpose ();
 }
 
 PermMatrix::PermMatrix (const Array<octave_idx_type>& p)
   : Array<octave_idx_type> (p)
 {
   setup (p, false, true);
 }
@@ -73,17 +73,17 @@ PermMatrix::setup (const idx_vector& idx
     gripe_invalid_permutation ();
   else
     {
       Array<octave_idx_type> idxa (dim_vector (len, 1));
       for (octave_idx_type i = 0; i < len; i++) idxa(i) = idx(i);
       Array<octave_idx_type>::operator = (idxa);
     }
 
-  if (!colp)
+  if (! colp)
     *this = this->transpose ();
 }
 
 PermMatrix::PermMatrix (const idx_vector& idx)
   : Array<octave_idx_type> ()
 {
   setup (idx, false, 0);
 }
diff --git a/liboctave/array/Sparse.h b/liboctave/array/Sparse.h
--- a/liboctave/array/Sparse.h
+++ b/liboctave/array/Sparse.h
@@ -241,17 +241,17 @@ public:
   Sparse<T>& operator = (const Sparse<T>& a);
 
   //! Amount of storage for nonzero elements.
   //! This may differ from the actual number of elements, see nnz().
   octave_idx_type nzmax (void) const { return rep->length (); }
   //! Amount of storage for nonzero elements.
   //! Synonymous with nzmax().
   GCC_ATTR_DEPRECATED octave_idx_type capacity (void) const { return nzmax (); }
-  //!Actual number of nonzero terms.
+  //! Actual number of nonzero terms.
   octave_idx_type nnz (void) const { return rep->nnz (); }
 
   // Querying the number of elements (incl. zeros) may overflow the index type,
   // so don't do it unless you really need it.
   octave_idx_type numel (void) const
   {
     return dimensions.safe_numel ();
   }
diff --git a/liboctave/array/dMatrix.cc b/liboctave/array/dMatrix.cc
--- a/liboctave/array/dMatrix.cc
+++ b/liboctave/array/dMatrix.cc
@@ -851,17 +851,17 @@ Matrix::inverse (MatrixType &mattype, oc
               else
                 rcon = 1.0;
               ret = chol.inverse ();
             }
           else
             mattype.mark_as_unsymmetric ();
         }
 
-      if (!mattype.is_hermitian ())
+      if (! mattype.is_hermitian ())
         ret = finverse (mattype, info, rcon, force, calc_cond);
 
       if ((mattype.is_hermitian () || calc_cond) && rcon == 0.)
         ret = Matrix (rows (), columns (), octave_Inf);
     }
 
   return ret;
 }
diff --git a/liboctave/array/dSparse.cc b/liboctave/array/dSparse.cc
--- a/liboctave/array/dSparse.cc
+++ b/liboctave/array/dSparse.cc
@@ -1215,17 +1215,17 @@ SparseMatrix::inverse (MatrixType &matty
             }
           else
             {
               // Matrix is either singular or not positive definite
               mattype.mark_as_unsymmetric ();
             }
         }
 
-      if (!mattype.is_hermitian ())
+      if (! mattype.is_hermitian ())
         {
           octave_idx_type n = rows ();
           ColumnVector Qinit(n);
           for (octave_idx_type i = 0; i < n; i++)
             Qinit(i) = i;
 
           MatrixType tmp_typ (MatrixType::Upper);
           SparseLU fact (*this, Qinit, Matrix (), false, false);
@@ -1275,29 +1275,29 @@ SparseMatrix::determinant (octave_idx_ty
       err = 0;
 
       // Setup the control parameters
       Matrix Control (UMFPACK_CONTROL, 1);
       double *control = Control.fortran_vec ();
       UMFPACK_DNAME (defaults) (control);
 
       double tmp = octave_sparse_params::get_key ("spumoni");
-      if (!xisnan (tmp))
+      if (! xisnan (tmp))
         Control (UMFPACK_PRL) = tmp;
 
       tmp = octave_sparse_params::get_key ("piv_tol");
-      if (!xisnan (tmp))
+      if (! xisnan (tmp))
         {
           Control (UMFPACK_SYM_PIVOT_TOLERANCE) = tmp;
           Control (UMFPACK_PIVOT_TOLERANCE) = tmp;
         }
 
       // Set whether we are allowed to modify Q or not
       tmp = octave_sparse_params::get_key ("autoamd");
-      if (!xisnan (tmp))
+      if (! xisnan (tmp))
         Control (UMFPACK_FIXQ) = tmp;
 
       // Turn-off UMFPACK scaling for LU
       Control (UMFPACK_SCALE) = UMFPACK_SCALE_NONE;
 
       UMFPACK_DNAME (report_control) (control);
 
       const octave_idx_type *Ap = cidx ();
@@ -5656,28 +5656,28 @@ SparseMatrix::factorize (octave_idx_type
 
 #ifdef HAVE_UMFPACK
   // Setup the control parameters
   Control = Matrix (UMFPACK_CONTROL, 1);
   double *control = Control.fortran_vec ();
   UMFPACK_DNAME (defaults) (control);
 
   double tmp = octave_sparse_params::get_key ("spumoni");
-  if (!xisnan (tmp))
+  if (! xisnan (tmp))
     Control (UMFPACK_PRL) = tmp;
   tmp = octave_sparse_params::get_key ("piv_tol");
-  if (!xisnan (tmp))
+  if (! xisnan (tmp))
     {
       Control (UMFPACK_SYM_PIVOT_TOLERANCE) = tmp;
       Control (UMFPACK_PIVOT_TOLERANCE) = tmp;
     }
 
   // Set whether we are allowed to modify Q or not
   tmp = octave_sparse_params::get_key ("autoamd");
-  if (!xisnan (tmp))
+  if (! xisnan (tmp))
     Control (UMFPACK_FIXQ) = tmp;
 
   UMFPACK_DNAME (report_control) (control);
 
   const octave_idx_type *Ap = cidx ();
   const octave_idx_type *Ai = ridx ();
   const double *Ax = data ();
   octave_idx_type nr = rows ();
diff --git a/liboctave/array/fCMatrix.cc b/liboctave/array/fCMatrix.cc
--- a/liboctave/array/fCMatrix.cc
+++ b/liboctave/array/fCMatrix.cc
@@ -1207,17 +1207,17 @@ FloatComplexMatrix::inverse (MatrixType 
               else
                 rcon = 1.0;
               ret = chol.inverse ();
             }
           else
             mattype.mark_as_unsymmetric ();
         }
 
-      if (!mattype.is_hermitian ())
+      if (! mattype.is_hermitian ())
         ret = finverse (mattype, info, rcon, force, calc_cond);
 
       if ((mattype.is_hermitian () || calc_cond) && rcon == 0.)
         ret = FloatComplexMatrix (rows (), columns (),
                                   FloatComplex (octave_Float_Inf, 0.));
     }
 
   return ret;
diff --git a/liboctave/array/fMatrix.cc b/liboctave/array/fMatrix.cc
--- a/liboctave/array/fMatrix.cc
+++ b/liboctave/array/fMatrix.cc
@@ -858,17 +858,17 @@ FloatMatrix::inverse (MatrixType &mattyp
               else
                 rcon = 1.0;
               ret = chol.inverse ();
             }
           else
             mattype.mark_as_unsymmetric ();
         }
 
-      if (!mattype.is_hermitian ())
+      if (! mattype.is_hermitian ())
         ret = finverse (mattype, info, rcon, force, calc_cond);
 
       if ((mattype.is_hermitian () || calc_cond) && rcon == 0.)
         ret = FloatMatrix (rows (), columns (), octave_Float_Inf);
     }
 
   return ret;
 }
diff --git a/liboctave/array/idx-vector.cc b/liboctave/array/idx-vector.cc
--- a/liboctave/array/idx-vector.cc
+++ b/liboctave/array/idx-vector.cc
@@ -230,17 +230,17 @@ idx_vector::idx_range_rep::as_array (voi
 }
 
 inline octave_idx_type
 convert_index (octave_idx_type i, bool& conv_error,
                octave_idx_type& ext)
 {
   if (i <= 0)
     {
-      if (!conv_error)          // only gripe once, for things like A(-10000:0)
+      if (! conv_error)          // only gripe once, for things like A(-10000:0)
         gripe_invalid_index (i-1);
       conv_error = true;
     }
 
   if (ext < i)
     ext = i;
 
   return i - 1;
@@ -357,17 +357,17 @@ idx_vector::idx_vector_rep::idx_vector_r
   if (len != 0)
     {
       octave_idx_type max = -1;
       for (octave_idx_type i = 0; i < len; i++)
         {
           octave_idx_type k = inda.xelem (i);
           if (k < 0)
             {
-              if (!err)         // only report first error, in case 1000s.
+              if (! err)         // only report first error, in case 1000s.
                 gripe_invalid_index (k);
               err = true;
             }
           else if (k > max)
             max = k;
         }
 
       ext = max + 1;
diff --git a/liboctave/numeric/CollocWt.h b/liboctave/numeric/CollocWt.h
--- a/liboctave/numeric/CollocWt.h
+++ b/liboctave/numeric/CollocWt.h
@@ -145,24 +145,24 @@ public:
   double left (void) const { return lb; }
   double right (void) const { return rb; }
 
   double width (void) const { return rb - lb; }
 
   double alpha (void) const { return Alpha; }
   double beta (void) const { return Beta; }
 
-  ColumnVector roots (void) { if (!initialized) init (); return r; }
-  ColumnVector quad (void) { if (!initialized) init (); return q; }
+  ColumnVector roots (void) { if (! initialized) init (); return r; }
+  ColumnVector quad (void) { if (! initialized) init (); return q; }
 
   ColumnVector quad_weights (void) { return quad (); }
 
-  Matrix first (void) { if (!initialized) init (); return A; }
+  Matrix first (void) { if (! initialized) init (); return A; }
 
-  Matrix second (void) { if (!initialized) init (); return B; }
+  Matrix second (void) { if (! initialized) init (); return B; }
 
   friend std::ostream& operator << (std::ostream&, const CollocWt&);
 
 protected:
 
   octave_idx_type n;
 
   octave_idx_type inc_left;
diff --git a/liboctave/numeric/SparseCmplxLU.cc b/liboctave/numeric/SparseCmplxLU.cc
--- a/liboctave/numeric/SparseCmplxLU.cc
+++ b/liboctave/numeric/SparseCmplxLU.cc
@@ -51,41 +51,41 @@ SparseComplexLU::SparseComplexLU (const 
   octave_idx_type nc = a.cols ();
 
   // Setup the control parameters
   Matrix Control (UMFPACK_CONTROL, 1);
   double *control = Control.fortran_vec ();
   UMFPACK_ZNAME (defaults) (control);
 
   double tmp = octave_sparse_params::get_key ("spumoni");
-  if (!xisnan (tmp))
+  if (! xisnan (tmp))
     Control (UMFPACK_PRL) = tmp;
   if (piv_thres.numel () == 2)
     {
       tmp = (piv_thres (0) > 1. ? 1. : piv_thres (0));
-      if (!xisnan (tmp))
+      if (! xisnan (tmp))
         Control (UMFPACK_PIVOT_TOLERANCE) = tmp;
       tmp = (piv_thres (1) > 1. ? 1. : piv_thres (1));
-      if (!xisnan (tmp))
+      if (! xisnan (tmp))
         Control (UMFPACK_SYM_PIVOT_TOLERANCE) = tmp;
     }
   else
     {
       tmp = octave_sparse_params::get_key ("piv_tol");
-      if (!xisnan (tmp))
+      if (! xisnan (tmp))
         Control (UMFPACK_PIVOT_TOLERANCE) = tmp;
 
       tmp = octave_sparse_params::get_key ("sym_tol");
-      if (!xisnan (tmp))
+      if (! xisnan (tmp))
         Control (UMFPACK_SYM_PIVOT_TOLERANCE) = tmp;
     }
 
   // Set whether we are allowed to modify Q or not
   tmp = octave_sparse_params::get_key ("autoamd");
-  if (!xisnan (tmp))
+  if (! xisnan (tmp))
     Control (UMFPACK_FIXQ) = tmp;
 
   // Turn-off UMFPACK scaling for LU
   if (scale)
     Control (UMFPACK_SCALE) = UMFPACK_SCALE_SUM;
   else
     Control (UMFPACK_SCALE) = UMFPACK_SCALE_NONE;
 
@@ -260,48 +260,48 @@ SparseComplexLU::SparseComplexLU (const 
       octave_idx_type nc = a.cols ();
 
       // Setup the control parameters
       Matrix Control (UMFPACK_CONTROL, 1);
       double *control = Control.fortran_vec ();
       UMFPACK_ZNAME (defaults) (control);
 
       double tmp = octave_sparse_params::get_key ("spumoni");
-      if (!xisnan (tmp))
+      if (! xisnan (tmp))
         Control (UMFPACK_PRL) = tmp;
       if (piv_thres.numel () == 2)
         {
           tmp = (piv_thres (0) > 1. ? 1. : piv_thres (0));
-          if (!xisnan (tmp))
+          if (! xisnan (tmp))
             Control (UMFPACK_PIVOT_TOLERANCE) = tmp;
           tmp = (piv_thres (1) > 1. ? 1. : piv_thres (1));
-          if (!xisnan (tmp))
+          if (! xisnan (tmp))
             Control (UMFPACK_SYM_PIVOT_TOLERANCE) = tmp;
         }
       else
         {
           tmp = octave_sparse_params::get_key ("piv_tol");
-          if (!xisnan (tmp))
+          if (! xisnan (tmp))
             Control (UMFPACK_PIVOT_TOLERANCE) = tmp;
 
           tmp = octave_sparse_params::get_key ("sym_tol");
-          if (!xisnan (tmp))
+          if (! xisnan (tmp))
             Control (UMFPACK_SYM_PIVOT_TOLERANCE) = tmp;
         }
 
       if (droptol >= 0.)
         Control (UMFPACK_DROPTOL) = droptol;
 
       // Set whether we are allowed to modify Q or not
       if (FixedQ)
         Control (UMFPACK_FIXQ) = 1.0;
       else
         {
           tmp = octave_sparse_params::get_key ("autoamd");
-          if (!xisnan (tmp))
+          if (! xisnan (tmp))
             Control (UMFPACK_FIXQ) = tmp;
         }
 
       // Turn-off UMFPACK scaling for LU
       if (scale)
         Control (UMFPACK_SCALE) = UMFPACK_SCALE_SUM;
       else
         Control (UMFPACK_SCALE) = UMFPACK_SCALE_NONE;
diff --git a/liboctave/numeric/SparseCmplxQR.cc b/liboctave/numeric/SparseCmplxQR.cc
--- a/liboctave/numeric/SparseCmplxQR.cc
+++ b/liboctave/numeric/SparseCmplxQR.cc
@@ -71,17 +71,17 @@ SparseComplexQR::SparseComplexQR_rep::Sp
   BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined (CS_VER) && (CS_VER >= 2)
   S = CXSPARSE_ZNAME (_sqr) (order, &A, 1);
 #else
   S = CXSPARSE_ZNAME (_sqr) (&A, order - 1, 1);
 #endif
   N = CXSPARSE_ZNAME (_qr) (&A, S);
   END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-  if (!N)
+  if (! N)
     (*current_liboctave_error_handler)
       ("SparseComplexQR: sparse matrix QR factorization filled");
   count = 1;
 #else
   (*current_liboctave_error_handler)
     ("SparseComplexQR: sparse matrix QR factorization not implemented");
 #endif
 }
diff --git a/liboctave/numeric/SparseQR.cc b/liboctave/numeric/SparseQR.cc
--- a/liboctave/numeric/SparseQR.cc
+++ b/liboctave/numeric/SparseQR.cc
@@ -51,17 +51,17 @@ SparseQR::SparseQR_rep::SparseQR_rep (co
 #if defined (CS_VER) && (CS_VER >= 2)
   S = CXSPARSE_DNAME (_sqr) (order, &A, 1);
 #else
   S = CXSPARSE_DNAME (_sqr) (&A, order - 1, 1);
 #endif
 
   N = CXSPARSE_DNAME (_qr) (&A, S);
   END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-  if (!N)
+  if (! N)
     (*current_liboctave_error_handler)
       ("SparseQR: sparse matrix QR factorization filled");
   count = 1;
 #else
   (*current_liboctave_error_handler)
     ("SparseQR: sparse matrix QR factorization not implemented");
 #endif
 }
diff --git a/liboctave/numeric/SparsedbleLU.cc b/liboctave/numeric/SparsedbleLU.cc
--- a/liboctave/numeric/SparsedbleLU.cc
+++ b/liboctave/numeric/SparsedbleLU.cc
@@ -49,42 +49,42 @@ SparseLU::SparseLU (const SparseMatrix& 
   octave_idx_type nc = a.cols ();
 
   // Setup the control parameters
   Matrix Control (UMFPACK_CONTROL, 1);
   double *control = Control.fortran_vec ();
   UMFPACK_DNAME (defaults) (control);
 
   double tmp = octave_sparse_params::get_key ("spumoni");
-  if (!xisnan (tmp))
+  if (! xisnan (tmp))
     Control (UMFPACK_PRL) = tmp;
 
   if (piv_thres.numel () == 2)
     {
       tmp = (piv_thres (0) > 1. ? 1. : piv_thres (0));
-      if (!xisnan (tmp))
+      if (! xisnan (tmp))
         Control (UMFPACK_PIVOT_TOLERANCE) = tmp;
       tmp = (piv_thres (1) > 1. ? 1. : piv_thres (1));
-      if (!xisnan (tmp))
+      if (! xisnan (tmp))
         Control (UMFPACK_SYM_PIVOT_TOLERANCE) = tmp;
     }
   else
     {
       tmp = octave_sparse_params::get_key ("piv_tol");
-      if (!xisnan (tmp))
+      if (! xisnan (tmp))
         Control (UMFPACK_PIVOT_TOLERANCE) = tmp;
 
       tmp = octave_sparse_params::get_key ("sym_tol");
-      if (!xisnan (tmp))
+      if (! xisnan (tmp))
         Control (UMFPACK_SYM_PIVOT_TOLERANCE) = tmp;
     }
 
   // Set whether we are allowed to modify Q or not
   tmp = octave_sparse_params::get_key ("autoamd");
-  if (!xisnan (tmp))
+  if (! xisnan (tmp))
     Control (UMFPACK_FIXQ) = tmp;
 
   if (scale)
     Control (UMFPACK_SCALE) = UMFPACK_SCALE_SUM;
   else
     Control (UMFPACK_SCALE) = UMFPACK_SCALE_NONE;
 
   UMFPACK_DNAME (report_control) (control);
@@ -245,50 +245,50 @@ SparseLU::SparseLU (const SparseMatrix& 
       octave_idx_type nc = a.cols ();
 
       // Setup the control parameters
       Matrix Control (UMFPACK_CONTROL, 1);
       double *control = Control.fortran_vec ();
       UMFPACK_DNAME (defaults) (control);
 
       double tmp = octave_sparse_params::get_key ("spumoni");
-      if (!xisnan (tmp))
+      if (! xisnan (tmp))
         Control (UMFPACK_PRL) = tmp;
 
       if (piv_thres.numel () == 2)
         {
           tmp = (piv_thres (0) > 1. ? 1. : piv_thres (0));
-          if (!xisnan (tmp))
+          if (! xisnan (tmp))
             Control (UMFPACK_PIVOT_TOLERANCE) = tmp;
           tmp = (piv_thres (1) > 1. ? 1. : piv_thres (1));
-          if (!xisnan (tmp))
+          if (! xisnan (tmp))
             Control (UMFPACK_SYM_PIVOT_TOLERANCE) = tmp;
         }
       else
         {
           tmp = octave_sparse_params::get_key ("piv_tol");
-          if (!xisnan (tmp))
+          if (! xisnan (tmp))
             Control (UMFPACK_PIVOT_TOLERANCE) = tmp;
 
           tmp = octave_sparse_params::get_key ("sym_tol");
-          if (!xisnan (tmp))
+          if (! xisnan (tmp))
             Control (UMFPACK_SYM_PIVOT_TOLERANCE) = tmp;
         }
 
       if (droptol >= 0.)
         Control (UMFPACK_DROPTOL) = droptol;
 
 
       // Set whether we are allowed to modify Q or not
       if (FixedQ)
         Control (UMFPACK_FIXQ) = 1.0;
       else
         {
           tmp = octave_sparse_params::get_key ("autoamd");
-          if (!xisnan (tmp))
+          if (! xisnan (tmp))
             Control (UMFPACK_FIXQ) = tmp;
         }
 
       if (scale)
         Control (UMFPACK_SCALE) = UMFPACK_SCALE_SUM;
       else
         Control (UMFPACK_SCALE) = UMFPACK_SCALE_NONE;
 
diff --git a/liboctave/numeric/base-qr.cc b/liboctave/numeric/base-qr.cc
--- a/liboctave/numeric/base-qr.cc
+++ b/liboctave/numeric/base-qr.cc
@@ -45,17 +45,17 @@ base_qr<qr_type>::base_qr (const qr_type
 }
 
 template <class qr_type>
 qr_type_t
 base_qr<qr_type>::get_type (void) const
 {
   qr_type_t retval;
 
-  if (!q.is_empty () && q.is_square ())
+  if (! q.is_empty () && q.is_square ())
     retval = qr_type_std;
   else if (q.rows () > q.columns () && r.is_square ())
     retval = qr_type_economy;
   else
     retval = qr_type_raw;
 
   return retval;
 }
diff --git a/liboctave/numeric/eigs-base.cc b/liboctave/numeric/eigs-base.cc
--- a/liboctave/numeric/eigs-base.cc
+++ b/liboctave/numeric/eigs-base.cc
@@ -242,17 +242,17 @@ ltsolve (const SM& L, const ColumnVector
   octave_idx_type b_nc = m.cols ();
   octave_idx_type err = 0;
   double rcond;
   MatrixType ltyp (MatrixType::Lower);
   M tmp = L.solve (ltyp, m, err, rcond, 0);
   M retval;
   const double* qv = Q.fortran_vec ();
 
-  if (!err)
+  if (! err)
     {
       retval.resize (n, b_nc);
       for (octave_idx_type j = 0; j < b_nc; j++)
         {
           for (octave_idx_type i = 0; i < n; i++)
             retval.elem (static_cast<octave_idx_type>(qv[i]), j) =
               tmp.elem (i,j);
         }
@@ -937,17 +937,17 @@ EigsRealSymmetricMatrix (const M& m, con
 
       if (f77_exception_encountered)
         {
           (*current_liboctave_error_handler)
             ("eigs: unrecoverable exception encountered in dsaupd");
           return -1;
         }
 
-      if (disp > 0 && !xisnan (workl[iptr (5)-1]))
+      if (disp > 0 && ! xisnan (workl[iptr (5)-1]))
         {
           if (iter++)
             {
               os << "Iteration " << iter - 1 <<
                  ": a few Ritz values of the " << p << "-by-" <<
                  p << " matrix\n";
               for (int i = 0 ; i < k; i++)
                 os << "    " << workl[iptr(5)+i-1] << "\n";
@@ -970,17 +970,17 @@ EigsRealSymmetricMatrix (const M& m, con
               for (octave_idx_type i = 0; i < n; i++)
                 mtmp(i,0) = workd[i + iptr(0) - 1];
 
               mtmp = utsolve (bt, permB, m * ltsolve (b, permB, mtmp));
 
               for (octave_idx_type i = 0; i < n; i++)
                 workd[i+iptr(1)-1] = mtmp(i,0);
             }
-          else if (!vector_product (m, workd + iptr(0) - 1,
+          else if (! vector_product (m, workd + iptr(0) - 1,
                                     workd + iptr(1) - 1))
             break;
         }
       else
         {
           if (info < 0)
             {
               (*current_liboctave_error_handler)
@@ -1230,17 +1230,17 @@ EigsRealSymmetricMatrixShift (const M& m
 
       if (f77_exception_encountered)
         {
           (*current_liboctave_error_handler)
             ("eigs: unrecoverable exception encountered in dsaupd");
           return -1;
         }
 
-      if (disp > 0 && !xisnan (workl[iptr (5)-1]))
+      if (disp > 0 && ! xisnan (workl[iptr (5)-1]))
         {
           if (iter++)
             {
               os << "Iteration " << iter - 1 <<
                  ": a few Ritz values of the " << p << "-by-" <<
                  p << " matrix\n";
               for (int i = 0 ; i < k; i++)
                 os << "    " << workl[iptr(5)+i-1] << "\n";
@@ -1531,17 +1531,17 @@ EigsRealSymmetricFunc (EigsFunc fun, oct
 
       if (f77_exception_encountered)
         {
           (*current_liboctave_error_handler)
             ("eigs: unrecoverable exception encountered in dsaupd");
           return -1;
         }
 
-      if (disp > 0 && !xisnan (workl[iptr (5)-1]))
+      if (disp > 0 && ! xisnan (workl[iptr (5)-1]))
         {
           if (iter++)
             {
               os << "Iteration " << iter - 1 <<
                  ": a few Ritz values of the " << p << "-by-" <<
                  p << " matrix\n";
               for (int i = 0 ; i < k; i++)
                 os << "    " << workl[iptr(5)+i-1] << "\n";
@@ -1851,17 +1851,17 @@ EigsRealNonSymmetricMatrix (const M& m, 
 
       if (f77_exception_encountered)
         {
           (*current_liboctave_error_handler)
             ("eigs: unrecoverable exception encountered in dnaupd");
           return -1;
         }
 
-      if (disp > 0 && !xisnan(workl[iptr(5)-1]))
+      if (disp > 0 && ! xisnan(workl[iptr(5)-1]))
         {
           if (iter++)
             {
               os << "Iteration " << iter - 1 <<
                  ": a few Ritz values of the " << p << "-by-" <<
                  p << " matrix\n";
               for (int i = 0 ; i < k; i++)
                 os << "    " << workl[iptr(5)+i-1] << "\n";
@@ -1884,17 +1884,17 @@ EigsRealNonSymmetricMatrix (const M& m, 
               for (octave_idx_type i = 0; i < n; i++)
                 mtmp(i,0) = workd[i + iptr(0) - 1];
 
               mtmp = utsolve (bt, permB, m * ltsolve (b, permB, mtmp));
 
               for (octave_idx_type i = 0; i < n; i++)
                 workd[i+iptr(1)-1] = mtmp(i,0);
             }
-          else if (!vector_product (m, workd + iptr(0) - 1,
+          else if (! vector_product (m, workd + iptr(0) - 1,
                                     workd + iptr(1) - 1))
             break;
         }
       else
         {
           if (info < 0)
             {
               (*current_liboctave_error_handler)
@@ -1957,17 +1957,17 @@ EigsRealNonSymmetricMatrix (const M& m, 
           octave_idx_type jj = 0;
           for (octave_idx_type i = 0; i < k+1; i++)
             {
               if (dr[i] == 0.0 && di[i] == 0.0 && jj == 0)
                 jj++;
               else
                 d[i-jj] = Complex (dr[i], di[i]);
             }
-          if (jj == 0 && !rvec)
+          if (jj == 0 && ! rvec)
             for (octave_idx_type i = 0; i < k; i++)
               d[i] = d[i+1];
 
           octave_idx_type k2 = k / 2;
           for (octave_idx_type i = 0; i < k2; i++)
             {
               Complex dtmp = d[i];
               d[i] = d[k - i - 1];
@@ -2193,17 +2193,17 @@ EigsRealNonSymmetricMatrixShift (const M
 
       if (f77_exception_encountered)
         {
           (*current_liboctave_error_handler)
             ("eigs: unrecoverable exception encountered in dsaupd");
           return -1;
         }
 
-      if (disp > 0 && !xisnan (workl[iptr (5)-1]))
+      if (disp > 0 && ! xisnan (workl[iptr (5)-1]))
         {
           if (iter++)
             {
               os << "Iteration " << iter - 1 <<
                  ": a few Ritz values of the " << p << "-by-" <<
                  p << " matrix\n";
               for (int i = 0 ; i < k; i++)
                 os << "    " << workl[iptr(5)+i-1] << "\n";
@@ -2343,17 +2343,17 @@ EigsRealNonSymmetricMatrixShift (const M
           octave_idx_type jj = 0;
           for (octave_idx_type i = 0; i < k+1; i++)
             {
               if (dr[i] == 0.0 && di[i] == 0.0 && jj == 0)
                 jj++;
               else
                 d[i-jj] = Complex (dr[i], di[i]);
             }
-          if (jj == 0 && !rvec)
+          if (jj == 0 && ! rvec)
             for (octave_idx_type i = 0; i < k; i++)
               d[i] = d[i+1];
 
           octave_idx_type k2 = k / 2;
           for (octave_idx_type i = 0; i < k2; i++)
             {
               Complex dtmp = d[i];
               d[i] = d[k - i - 1];
@@ -2549,17 +2549,17 @@ EigsRealNonSymmetricFunc (EigsFunc fun, 
 
       if (f77_exception_encountered)
         {
           (*current_liboctave_error_handler)
             ("eigs: unrecoverable exception encountered in dnaupd");
           return -1;
         }
 
-      if (disp > 0 && !xisnan(workl[iptr(5)-1]))
+      if (disp > 0 && ! xisnan(workl[iptr(5)-1]))
         {
           if (iter++)
             {
               os << "Iteration " << iter - 1 <<
                  ": a few Ritz values of the " << p << "-by-" <<
                  p << " matrix\n";
               for (int i = 0 ; i < k; i++)
                 os << "    " << workl[iptr(5)+i-1] << "\n";
@@ -2655,17 +2655,17 @@ EigsRealNonSymmetricFunc (EigsFunc fun, 
           octave_idx_type jj = 0;
           for (octave_idx_type i = 0; i < k+1; i++)
             {
               if (dr[i] == 0.0 && di[i] == 0.0 && jj == 0)
                 jj++;
               else
                 d[i-jj] = Complex (dr[i], di[i]);
             }
-          if (jj == 0 && !rvec)
+          if (jj == 0 && ! rvec)
             for (octave_idx_type i = 0; i < k; i++)
               d[i] = d[i+1];
 
           octave_idx_type k2 = k / 2;
           for (octave_idx_type i = 0; i < k2; i++)
             {
               Complex dtmp = d[i];
               d[i] = d[k - i - 1];
@@ -2920,17 +2920,17 @@ EigsComplexNonSymmetricMatrix (const M& 
 
       if (f77_exception_encountered)
         {
           (*current_liboctave_error_handler)
             ("eigs: unrecoverable exception encountered in znaupd");
           return -1;
         }
 
-      if (disp > 0 && !xisnan (workl[iptr (5)-1]))
+      if (disp > 0 && ! xisnan (workl[iptr (5)-1]))
         {
           if (iter++)
             {
               os << "Iteration " << iter - 1 <<
                  ": a few Ritz values of the " << p << "-by-" <<
                  p << " matrix\n";
               for (int i = 0 ; i < k; i++)
                 os << "    " << workl[iptr(5)+i-1] << "\n";
@@ -2952,17 +2952,17 @@ EigsComplexNonSymmetricMatrix (const M& 
               ComplexMatrix mtmp (n,1);
               for (octave_idx_type i = 0; i < n; i++)
                 mtmp(i,0) = workd[i + iptr(0) - 1];
               mtmp = utsolve (bt, permB, m * ltsolve (b, permB, mtmp));
               for (octave_idx_type i = 0; i < n; i++)
                 workd[i+iptr(1)-1] = mtmp(i,0);
 
             }
-          else if (!vector_product (m, workd + iptr(0) - 1,
+          else if (! vector_product (m, workd + iptr(0) - 1,
                                     workd + iptr(1) - 1))
             break;
         }
       else
         {
           if (info < 0)
             {
               (*current_liboctave_error_handler)
@@ -3214,17 +3214,17 @@ EigsComplexNonSymmetricMatrixShift (cons
 
       if (f77_exception_encountered)
         {
           (*current_liboctave_error_handler)
             ("eigs: unrecoverable exception encountered in znaupd");
           return -1;
         }
 
-      if (disp > 0 && !xisnan(workl[iptr(5)-1]))
+      if (disp > 0 && ! xisnan(workl[iptr(5)-1]))
         {
           if (iter++)
             {
               os << "Iteration " << iter - 1 <<
                  ": a few Ritz values of the " << p << "-by-" <<
                  p << " matrix\n";
               for (int i = 0 ; i < k; i++)
                 os << "    " << workl[iptr(5)+i-1] << "\n";
@@ -3523,17 +3523,17 @@ EigsComplexNonSymmetricFunc (EigsComplex
 
       if (f77_exception_encountered)
         {
           (*current_liboctave_error_handler)
             ("eigs: unrecoverable exception encountered in znaupd");
           return -1;
         }
 
-      if (disp > 0 && !xisnan(workl[iptr(5)-1]))
+      if (disp > 0 && ! xisnan(workl[iptr(5)-1]))
         {
           if (iter++)
             {
               os << "Iteration " << iter - 1 <<
                  ": a few Ritz values of the " << p << "-by-" <<
                  p << " matrix\n";
               for (int i = 0 ; i < k; i++)
                 os << "    " << workl[iptr(5)+i-1] << "\n";
diff --git a/liboctave/numeric/oct-fftw.cc b/liboctave/numeric/oct-fftw.cc
--- a/liboctave/numeric/oct-fftw.cc
+++ b/liboctave/numeric/oct-fftw.cc
@@ -66,17 +66,17 @@ octave_fftw_planner::octave_fftw_planner
   plan[0] = plan[1] = 0;
   d[0] = d[1] = s[0] = s[1] = r[0] = r[1] = h[0] = h[1] = 0;
   simd_align[0] = simd_align[1] = false;
   inplace[0] = inplace[1] = false;
   n[0] = n[1] = dim_vector ();
 
 #if defined (HAVE_FFTW3_THREADS)
   int init_ret = fftw_init_threads ();
-  if (!init_ret)
+  if (! init_ret)
     (*current_liboctave_error_handler) ("Error initializing FFTW threads");
   //Use number of processors available to the current process
   //This can be later changed with fftw ("threads", nthreads)
   nthreads = num_processors (NPROC_CURRENT);
   fftw_plan_with_nthreads (nthreads);
 #endif
 
   // If we have a system wide wisdom file, import it.
@@ -143,17 +143,17 @@ octave_fftw_planner::do_create_plan (int
 
   // Don't create a new plan if we have a non SIMD plan already but
   // can do SIMD.  This prevents endlessly recreating plans if we
   // change the alignment.
 
   if (plan[which] == 0 || d[which] != dist || s[which] != stride
       || r[which] != rank || h[which] != howmany
       || ioinplace != inplace[which]
-      || ((ioalign != simd_align[which]) ? !ioalign : false))
+      || ((ioalign != simd_align[which]) ? ! ioalign : false))
     create_new_plan = true;
   else
     {
       // We still might not have the same shape of array.
 
       for (int i = 0; i < rank; i++)
         if (dims(i) != n[which](i))
           {
@@ -263,17 +263,17 @@ octave_fftw_planner::do_create_plan (con
   bool create_new_plan = false;
   bool ioalign = CHECK_SIMD_ALIGNMENT (in) && CHECK_SIMD_ALIGNMENT (out);
 
   // Don't create a new plan if we have a non SIMD plan already but
   // can do SIMD.  This prevents endlessly recreating plans if we
   // change the alignment.
 
   if (rplan == 0 || rd != dist || rs != stride || rr != rank
-      || rh != howmany || ((ioalign != rsimd_align) ? !ioalign : false))
+      || rh != howmany || ((ioalign != rsimd_align) ? ! ioalign : false))
     create_new_plan = true;
   else
     {
       // We still might not have the same shape of array.
 
       for (int i = 0; i < rank; i++)
         if (dims(i) != rn(i))
           {
@@ -410,17 +410,17 @@ octave_float_fftw_planner::octave_float_
   plan[0] = plan[1] = 0;
   d[0] = d[1] = s[0] = s[1] = r[0] = r[1] = h[0] = h[1] = 0;
   simd_align[0] = simd_align[1] = false;
   inplace[0] = inplace[1] = false;
   n[0] = n[1] = dim_vector ();
 
 #if defined (HAVE_FFTW3F_THREADS)
   int init_ret = fftwf_init_threads ();
-  if (!init_ret)
+  if (! init_ret)
     (*current_liboctave_error_handler) ("Error initializing FFTW3F threads");
   //Use number of processors available to the current process
   //This can be later changed with fftw ("threads", nthreads)
   nthreads = num_processors (NPROC_CURRENT);
   fftwf_plan_with_nthreads (nthreads);
 #endif
 
   // If we have a system wide wisdom file, import it.
@@ -485,17 +485,17 @@ octave_float_fftw_planner::do_create_pla
 
   // Don't create a new plan if we have a non SIMD plan already but
   // can do SIMD.  This prevents endlessly recreating plans if we
   // change the alignment.
 
   if (plan[which] == 0 || d[which] != dist || s[which] != stride
       || r[which] != rank || h[which] != howmany
       || ioinplace != inplace[which]
-      || ((ioalign != simd_align[which]) ? !ioalign : false))
+      || ((ioalign != simd_align[which]) ? ! ioalign : false))
     create_new_plan = true;
   else
     {
       // We still might not have the same shape of array.
 
       for (int i = 0; i < rank; i++)
         if (dims(i) != n[which](i))
           {
@@ -606,17 +606,17 @@ octave_float_fftw_planner::do_create_pla
   bool create_new_plan = false;
   bool ioalign = CHECK_SIMD_ALIGNMENT (in) && CHECK_SIMD_ALIGNMENT (out);
 
   // Don't create a new plan if we have a non SIMD plan already but
   // can do SIMD.  This prevents endlessly recreating plans if we
   // change the alignment.
 
   if (rplan == 0 || rd != dist || rs != stride || rr != rank
-      || rh != howmany || ((ioalign != rsimd_align) ? !ioalign : false))
+      || rh != howmany || ((ioalign != rsimd_align) ? ! ioalign : false))
     create_new_plan = true;
   else
     {
       // We still might not have the same shape of array.
 
       for (int i = 0; i < rank; i++)
         if (dims(i) != rn(i))
           {
diff --git a/liboctave/numeric/randmtzig.c b/liboctave/numeric/randmtzig.c
--- a/liboctave/numeric/randmtzig.c
+++ b/liboctave/numeric/randmtzig.c
@@ -586,23 +586,23 @@ oct_randn (void)
       uint32_t *p = (uint32_t *)&rabs;
       lo = randi32 ();
       idx = lo&0xFF;
       hi = randi32 ();
       si = hi&UMASK;
       p[0] = lo;
       p[1] = hi&0x1FFFFF;
       x = ( si ? -rabs : rabs ) * wi[idx];
-# else /* !HAVE_X86_32 */
+# else /* ! HAVE_X86_32 */
       /* arbitrary mantissa (selected by NRANDI, with 1 bit for sign) */
       const uint64_t r = NRANDI;
       const int64_t rabs = r>>1;
       const int idx = (int)(rabs&0xFF);
       const double x = ( r&1 ? -rabs : rabs) * wi[idx];
-# endif /* !HAVE_X86_32 */
+# endif /* ! HAVE_X86_32 */
       if (rabs < (int64_t)ki[idx])
         return x;        /* 99.3% of the time we return here 1st try */
       else if (idx == 0)
         {
           /* As stated in Marsaglia and Tsang
            *
            * For the normal tail, the method of Marsaglia[5] provides:
            * generate x = -ln(U_1)/r, y = -ln(U_2), until y+y > x*x,
diff --git a/liboctave/numeric/sparse-dmsolve.cc b/liboctave/numeric/sparse-dmsolve.cc
--- a/liboctave/numeric/sparse-dmsolve.cc
+++ b/liboctave/numeric/sparse-dmsolve.cc
@@ -421,30 +421,30 @@ dmsolve (const ST &a, const T &b, octave
         {
           ST m = dmsolve_extract (a, pinv, q, dm->rr[2], nr, dm->cc[3], nc,
                                   nnz_remaining, true);
           nnz_remaining -= m.nnz ();
           RT mtmp =
             qrsolve (m, dmsolve_extract (btmp, 0, 0, dm->rr[2], b_nr, 0,
                                          b_nc), info);
           dmsolve_insert (retval, mtmp, q, dm->cc[3], 0);
-          if (dm->rr[2] > 0 && !info)
+          if (dm->rr[2] > 0 && ! info)
             {
               m = dmsolve_extract (a, pinv, q, 0, dm->rr[2],
                                    dm->cc[3], nc, nnz_remaining, true);
               nnz_remaining -= m.nnz ();
               RT ctmp = dmsolve_extract (btmp, 0, 0, 0,
                                          dm->rr[2], 0, b_nc);
               btmp.insert (ctmp - m * mtmp, 0, 0);
             }
         }
 
       // Structurally non-singular blocks
       // FIXME: Should use fine Dulmange-Mendelsohn decomposition here.
-      if (dm->rr[1] < dm->rr[2] && dm->cc[2] < dm->cc[3] && !info)
+      if (dm->rr[1] < dm->rr[2] && dm->cc[2] < dm->cc[3] && ! info)
         {
           ST m = dmsolve_extract (a, pinv, q, dm->rr[1], dm->rr[2],
                                   dm->cc[2], dm->cc[3], nnz_remaining, false);
           nnz_remaining -= m.nnz ();
           RT btmp2 = dmsolve_extract (btmp, 0, 0, dm->rr[1], dm->rr[2],
                                       0, b_nc);
           double rcond = 0.0;
           MatrixType mtyp (MatrixType::Full);
@@ -452,29 +452,29 @@ dmsolve (const ST &a, const T &b, octave
                              solve_singularity_warning, false);
           if (info != 0)
             {
               info = 0;
               mtmp = qrsolve (m, btmp2, info);
             }
 
           dmsolve_insert (retval, mtmp, q, dm->cc[2], 0);
-          if (dm->rr[1] > 0 && !info)
+          if (dm->rr[1] > 0 && ! info)
             {
               m = dmsolve_extract (a, pinv, q, 0, dm->rr[1], dm->cc[2],
                                    dm->cc[3], nnz_remaining, true);
               nnz_remaining -= m.nnz ();
               RT ctmp = dmsolve_extract (btmp, 0, 0, 0,
                                          dm->rr[1], 0, b_nc);
               btmp.insert (ctmp - m * mtmp, 0, 0);
             }
         }
 
       // Trailing under-determined block
-      if (dm->rr[1] > 0 && dm->cc[2] > 0 && !info)
+      if (dm->rr[1] > 0 && dm->cc[2] > 0 && ! info)
         {
           ST m = dmsolve_extract (a, pinv, q, 0, dm->rr[1], 0,
                                   dm->cc[2], nnz_remaining, true);
           RT mtmp =
             qrsolve (m, dmsolve_extract (btmp, 0, 0, 0, dm->rr[1] , 0,
                                          b_nc), info);
           dmsolve_insert (retval, mtmp, q, 0, 0);
         }
diff --git a/liboctave/util/kpse.cc b/liboctave/util/kpse.cc
--- a/liboctave/util/kpse.cc
+++ b/liboctave/util/kpse.cc
@@ -1004,17 +1004,17 @@ path_find_first_of (const std::string& p
 
       /* We have to search one directory at a time.  */
       dirs = kpse_element_dirs (elt);
       for (dirs_elt = *dirs; dirs_elt; dirs_elt = STR_LLIST_NEXT (*dirs_elt))
         {
           const std::string dir = STR_LLIST (*dirs_elt);
 
           int len = names.numel ();
-          for (int i = 0; i < len && !done; i++)
+          for (int i = 0; i < len && ! done; i++)
             {
               std::string name = names[i];
 
               /* Try ls-R, unless we're searching for texmf.cnf.  Our caller
                  (find_first_of), also tests first_search, and does the
                  resetting.  */
               found = first_search ? string_vector ()
                                    : kpse_db_search (name, dir.c_str (), all);
@@ -1646,17 +1646,17 @@ brace_gobbler (const std::string& text, 
         }
 
       if (c == '"' || c == '\'' || c == '`')
         {
           quoted = c;
           continue;
         }
 
-      if (c == satisfy && !level && !quoted)
+      if (c == satisfy && ! level && ! quoted)
         {
           /* We ignore an open brace surrounded by whitespace, and also
              an open brace followed immediately by a close brace, that
              was preceded with whitespace.  */
           if (c == '{'
               && ((i == 0 || brace_whitespace (text[i-1]))
                   && (i+1 < text_len
                       && (brace_whitespace (text[i+1]) || text[i+1] == '}'))))
@@ -1758,17 +1758,17 @@ match (const std::string& filename_arg, 
                  part of the other case, but it seems pointless to do
                  the extra work.  */
               matched = true;
               break;
             }
           else
             {
               /* Intermediate //, have to match rest of PATH_ELT.  */
-              for (; !matched && *filename; filename++)
+              for (; ! matched && *filename; filename++)
                 {
                   /* Try matching at each possible character.  */
                   if (IS_DIR_SEP (filename[-1]) && *filename == *path_elt)
                     matched = match (filename, path_elt);
                 }
 
               /* Prevent filename++ when *filename='\0'. */
               break;
@@ -1789,17 +1789,17 @@ match (const std::string& filename_arg, 
          with a / (as in 'vf/'), FILENAME being the same 'vf/ptmr.vf',
          we'll be at the 'p'.  Upshot: if we're at a dir separator in
          FILENAME, skip it.  But if not, that's ok, as long as there
          are no more dir separators.  */
 
       if (IS_DIR_SEP (*filename))
         filename++;
 
-      while (*filename && !IS_DIR_SEP (*filename))
+      while (*filename && ! IS_DIR_SEP (*filename))
         filename++;
 
       matched = *filename == 0;
     }
 
   return matched;
 }
 
@@ -1898,29 +1898,29 @@ kpse_db_search (const std::string& name_
   int len = aliases.numel ();
   aliases.resize (len+1);
   for (int i = len; i > 0; i--)
     aliases[i] = aliases[i - 1];
   aliases[0] = name;
 
   done = false;
   len = aliases.numel ();
-  for (int i = 0; i < len && !done; i++)
+  for (int i = 0; i < len && ! done; i++)
     {
       std::string atry = aliases[i];
 
       /* We have an ls-R db.  Look up 'atry'.  */
       string_vector db_dirs = hash_lookup (db, atry);
 
       /* For each filename found, see if it matches the path element.  For
          example, if we have .../cx/cmr10.300pk and .../ricoh/cmr10.300pk,
          and the path looks like .../cx, we don't want the ricoh file.  */
 
       int db_dirs_len = db_dirs.numel ();
-      for (int j = 0; j < db_dirs_len && !done; j++)
+      for (int j = 0; j < db_dirs_len && ! done; j++)
         {
           std::string db_file = db_dirs[j] + atry;
           bool matched = match (db_file, path_elt);
 
 #ifdef KPSE_DEBUG
           if (KPSE_DEBUG_P (KPSE_DEBUG_SEARCH))
             DEBUGF3 ("db:match (%s,%s) = %d\n",
                      db_file.c_str (), path_elt.c_str (), matched);
@@ -2613,17 +2613,17 @@ kpse_var_expand (const std::string& src)
               i = var_end;
 
             }
           else if (IS_VAR_BEGIN_DELIMITER (src[i]))
             {
               /* ${: scan ahead for matching delimiter, then expand.  */
               size_t var_end = ++i;
 
-              while (var_end < src_len && !IS_VAR_END_DELIMITER (src[var_end]))
+              while (var_end < src_len && ! IS_VAR_END_DELIMITER (src[var_end]))
                 var_end++;
 
               if (var_end == src_len)
                 {
                   (*current_liboctave_warning_with_id_handler)
                     ("Octave:pathsearch-syntax",
                      "%s: No matching } for ${", src.c_str ());
                   i = var_end - 1; /* will incr to eos at top of loop */
diff --git a/liboctave/util/lo-regexp.cc b/liboctave/util/lo-regexp.cc
--- a/liboctave/util/lo-regexp.cc
+++ b/liboctave/util/lo-regexp.cc
@@ -171,17 +171,17 @@ regexp::compile_internal (void)
               pos = new_pos + 2;
             }
           else
             {
               size_t tmp_pos3 = pattern.find_first_of ("*+", tmp_pos2);
 
               if (tmp_pos3 != std::string::npos && tmp_pos3 < tmp_pos1)
                 {
-                  if (!lookbehind_warned)
+                  if (! lookbehind_warned)
                     {
                       lookbehind_warned = true;
                       (*current_liboctave_warning_with_id_handler)
                         ("Octave:regexp-lookbehind-limit",
                          "%s: arbitrary length lookbehind patterns are only supported up to length %d",
                          who.c_str (), MAXLOOKBEHIND);
                     }
 
diff --git a/liboctave/util/oct-locbuf.h b/liboctave/util/oct-locbuf.h
--- a/liboctave/util/oct-locbuf.h
+++ b/liboctave/util/oct-locbuf.h
@@ -180,17 +180,17 @@ public:
 // them will be nonempty.
 
 #define OCTAVE_LOCAL_BUFFER(T, buf, size) \
   const size_t _bufsize_ ## buf = size; \
   const bool _lbufaut_ ## buf = _bufsize_ ## buf * sizeof (T) \
      <= OCTAVE_LOCAL_BUFFER_MAX_STACK_SIZE; \
   T _bufaut_ ## buf [_lbufaut_ ## buf ? _bufsize_ ## buf : 0]; \
   octave_local_buffer<T> _bufheap_ ## buf \
-    (!_lbufaut_ ## buf ? _bufsize_ ## buf : 0); \
+    (! _lbufaut_ ## buf ? _bufsize_ ## buf : 0); \
   T *buf = _lbufaut_ ## buf \
     ? _bufaut_ ## buf : static_cast<T *> (_bufheap_ ## buf)
 
 #else
 
 // If we don't have automatic arrays, we simply always use
 // octave_local_buffer.
 
diff --git a/liboctave/util/url-transfer.cc b/liboctave/util/url-transfer.cc
--- a/liboctave/util/url-transfer.cc
+++ b/liboctave/util/url-transfer.cc
@@ -53,17 +53,17 @@ base_url_transfer::delete_file (const st
 
 void
 base_url_transfer::mget_directory (const std::string& directory,
                                    const std::string& target)
 {
   std::string sep = file_ops::dir_sep_str ();
   file_stat fs (directory);
 
-  if (!fs || !fs.is_dir ())
+  if (! fs || ! fs.is_dir ())
     {
       std::string msg;
       int status = octave_mkdir (directory, 0777, msg);
 
       if (status < 0)
         {
           ok = false;
           errmsg = "__ftp_mget__: can not create directory '"
diff --git a/liboctave/util/url-transfer.h b/liboctave/util/url-transfer.h
--- a/liboctave/util/url-transfer.h
+++ b/liboctave/util/url-transfer.h
@@ -88,17 +88,17 @@ public:
   }
 
   virtual void ascii (void) { }
 
   virtual void binary (void) { }
 
   bool is_ascii (void) const { return ascii_mode; }
 
-  bool is_binary (void) const { return !ascii_mode; }
+  bool is_binary (void) const { return ! ascii_mode; }
 
   virtual void cwd (const std::string& /* path */) { }
 
   virtual void del (const std::string& /* file */) { }
 
   virtual void rmdir (const std::string& /* path */) { }
 
   virtual void mkdir (const std::string& /* path */) { }
diff --git a/scripts/general/bitset.m b/scripts/general/bitset.m
--- a/scripts/general/bitset.m
+++ b/scripts/general/bitset.m
@@ -65,17 +65,17 @@ function C = bitset (A, n, val)
 
   if (any ((n < 1)(:)) || any ((n > Amax)(:)))
     error ("bitset: N must be in the range [1,%d]", Amax);
   endif
 
   mask = bitshift (cast (1, cl), uint8 (n) - uint8 (1));
 
   on = logical (val);
-  off = !on;
+  off = ! on;
 
   if (isscalar (mask))
     onmask = mask;
     offmask = mask;
   else
     if (! size_equal (A, n))
       error ("bitset: N must be scalar or the same size as A");
     endif
diff --git a/scripts/general/interp2.m b/scripts/general/interp2.m
--- a/scripts/general/interp2.m
+++ b/scripts/general/interp2.m
@@ -340,17 +340,17 @@ function b = isgriddata (X)
   b = all (d1(:) == 0);
 endfunction
 
 ## Compute the bicubic interpolation coefficients
 function o = bc (x)
   x = abs (x);
   o = zeros (size (x));
   idx1 = (x < 1);
-  idx2 = !idx1 & (x < 2);
+  idx2 = ! idx1 & (x < 2);
   o(idx1) = 1 - 2.*x(idx1).^2 + x(idx1).^3;
   o(idx2) = 4 - 8.*x(idx2) + 5.*x(idx2).^2 - x(idx2).^3;
 endfunction
 
 ## This version of sub2ind behaves as if the data was symmetrically padded
 function ind = sym_sub2ind (sz, Y, X)
   Y(Y < 1) = 1 - Y(Y < 1);
   while (any (Y(:) > 2*sz(1)))
diff --git a/scripts/general/private/__isequal__.m b/scripts/general/private/__isequal__.m
--- a/scripts/general/private/__isequal__.m
+++ b/scripts/general/private/__isequal__.m
@@ -68,17 +68,17 @@ function t = __isequal__ (nans_compare_e
   endif
 
   if (t)
     ## Test that everything is the same size since the dimensionality matches.
     nd = ndims (x);
     k = 1;
     do
       t = all (builtin ("size", x, k) == cellfun ("size", varargin, k));
-    until (!t || k++ == nd);
+    until (! t || k++ == nd);
   endif
 
   ## From here on, compare objects as if they were structures.
   if (t && isobject (x))
     ## Locally suppress class-to-struct warning.  We know what we are doing.
     warning ("off", "Octave:classdef-to-struct", "local");
     x = builtin ("struct", x);
     for i = 1:numel (varargin)
@@ -150,29 +150,29 @@ function t = __isequal__ (nans_compare_e
       f_x = find (x);
       l_f_x = length (f_x);
       x = x(f_x);
       for argn = 1:l_v
         y = varargin{argn};
         f_y = find (y);
 
         t = (l_f_x == length (f_y)) && all (f_x == f_y);
-        if (!t)
+        if (! t)
           break;
         endif
 
         y = y(f_y);
         m = (x == y);
         t = all (m);
 
-        if (!t && nans_compare_equal)
-          t = isnan (x(!m)) && isnan (y(!m));
+        if (! t && nans_compare_equal)
+          t = isnan (x(! m)) && isnan (y(! m));
         endif
 
-        if (!t)
+        if (! t)
           break;
         endif
       endfor
 
     endif
   endif
 
 endfunction
diff --git a/scripts/geometry/inpolygon.m b/scripts/geometry/inpolygon.m
--- a/scripts/geometry/inpolygon.m
+++ b/scripts/geometry/inpolygon.m
@@ -70,17 +70,17 @@ function [in, on] = inpolygon (x, y, xv,
     ## is y between the y-values of edge i,j AND (x,y) on the left of the edge?
     idx1 = (((yv(i) <= y & y < yv(j)) | (yv(j) <= y & y < yv(i)))
             & 0 < distance.*delta_yv);
     in(idx1) = ! in(idx1);
 
     ## Check if (x,y) are actually on the boundary of the polygon.
     idx2 = (((yv(i) <= y & y <= yv(j)) | (yv(j) <= y & y <= yv(i)))
             & ((xv(i) <= x & x <= xv(j)) | (xv(j) <= x & x <= xv(i)))
-            & (0 == distance | !delta_xv));
+            & (0 == distance | ! delta_xv));
     on(idx2) = true;
 
     j = i;
   endfor
 
   ## Matlab definition include both in polygon and on polygon points.
   in |= on;
 
@@ -93,23 +93,23 @@ endfunction
 %!        0.05840 ];
 %! yv = [ 0.60628, 0.04728, 0.50000, 0.50000, 0.02015, ...
 %!        0.18161, 0.78850, 1.13589, 1.33781, 1.04650, ...
 %!        0.60628 ];
 %! xa = [0:0.1:2.3];
 %! ya = [0:0.1:1.4];
 %! [x,y] = meshgrid (xa, ya);
 %! [in,on] = inpolygon (x, y, xv, yv);
-%! inside = in & !on;
+%! inside = in & ! on;
 %!
 %! clf;
 %! plot (xv, yv);
 %! hold on;
 %! plot (x(inside), y(inside), "@g")
-%! plot (x(!in), y(!in), "@m");
+%! plot (x(! in), y(! in), "@m");
 %! plot (x(on), y(on), "@b");
 %! hold off;
 %! disp ("Green points are inside polygon, magenta are outside,");
 %! disp ("and blue are on boundary.");
 
 %!demo
 %!  xv = [ 0.05840, 0.48375, 0.69356, 1.47478, 1.32158, ...
 %!         1.94545, 2.16477, 1.87639, 1.18218, 0.27615, ...
@@ -118,23 +118,23 @@ endfunction
 %!  yv = [ 0.60628, 0.04728, 0.50000, 0.50000, 0.02015, ...
 %!         0.18161, 0.78850, 1.13589, 1.33781, 1.04650, ...
 %!         0.60628, 0.82096, 0.67155, 0.96114, 1.14833, ...
 %!         0.82096, 0.60628];
 %! xa = [0:0.1:2.3];
 %! ya = [0:0.1:1.4];
 %! [x, y] = meshgrid (xa, ya);
 %! [in, on] = inpolygon (x, y, xv, yv);
-%! inside = in & !on;
+%! inside = in & ! on;
 %!
 %! clf;
 %! plot (xv, yv);
 %! hold on;
 %! plot (x(inside), y(inside), "@g");
-%! plot (x(!in), y(!in), "@m");
+%! plot (x(! in), y(! in), "@m");
 %! plot (x(on), y(on), "@b");
 %! hold off;
 %! disp ("Green points are inside polygon, magenta are outside,");
 %! disp ("and blue are on boundary.");
 
 %!test
 %! [in, on] = inpolygon ([1, 0, 2], [1, 0, 0], [-1, -1, 1, 1], [-1, 1, 1, -1]);
 %! assert (in, [true, true, false]);
diff --git a/scripts/gui/questdlg.m b/scripts/gui/questdlg.m
--- a/scripts/gui/questdlg.m
+++ b/scripts/gui/questdlg.m
@@ -129,21 +129,21 @@ endfunction
 %! if (strcmp (a, 'No'))
 %!   msgbox ('Suit yourself.', 'Message Box');
 %! endif
 
 %!demo
 %! disp ('- test questdlg with message and title only.');
 %! a = 'No';
 %! c = 0;
-%! while (strcmp (a, 'No') || !c)
+%! while (strcmp (a, 'No') || ! c)
 %!   a = questdlg ('Close this Question Dialog?', 'Reductio Ad Absurdum');
 %!   if (strcmp (a, 'Yes'))
 %!     q = 'Are you sure?';
-%!     while (strcmp (a, 'Yes') && !c)
+%!     while (strcmp (a, 'Yes') && ! c)
 %!       a = questdlg (q, 'Reductio Ad Absurdum');
 %!       word = ' really';
 %!       i = strfind (q, word);
 %!       if (isempty (i))
 %!         i = strfind (q, ' sure');
 %!         q = [q '!'];
 %!       else
 %!         word = [word ','];
diff --git a/scripts/help/help.m b/scripts/help/help.m
--- a/scripts/help/help.m
+++ b/scripts/help/help.m
@@ -210,10 +210,10 @@ endfunction
 
 
 %!assert (! isempty (strfind (help ("ls"), "List directory contents")))
 %!assert (! isempty (strfind (help ("."), "||")))
 
 ## Test input validation
 %!error <invalid input> help (42)
 %!error <invalid input> help ("abc", "def")
-%!error <'_!UNLIKELY_FCN!_' not found> help ("_!UNLIKELY_FCN!_")
+%!error <'_! UNLIKELY_FCN! _' not found> help ("_! UNLIKELY_FCN! _")
 
diff --git a/scripts/miscellaneous/compare_versions.m b/scripts/miscellaneous/compare_versions.m
--- a/scripts/miscellaneous/compare_versions.m
+++ b/scripts/miscellaneous/compare_versions.m
@@ -170,17 +170,17 @@ function out = compare_versions (v1, v2,
     out = (vcmp(firstdiff) > 0);
   else
     ## They're not correctly less than or greater than, and they're not equal.
     out = false;
   endif
 
   ## Reverse the output if not is given.
   if (not_op)
-    out = !out;
+    out = ! out;
   endif
 
 endfunction
 
 
 ## tests
 ## test both equality symbols
 ## test arbitrarily long equality
diff --git a/scripts/miscellaneous/substruct.m b/scripts/miscellaneous/substruct.m
--- a/scripts/miscellaneous/substruct.m
+++ b/scripts/miscellaneous/substruct.m
@@ -56,19 +56,19 @@ function retval = substruct (varargin)
 
   typ = varargin(1:2:nargin);
   sub = varargin(2:2:nargin);
   braces = strcmp (typ, "()") | strcmp (typ, "{}");
   dots = strcmp (typ, ".");
   if (all (braces | dots))
     cells = cellfun ("isclass", sub, "cell");
     chars = cellfun ("isclass", sub, "char");
-    if (any (braces & !cells))
+    if (any (braces & ! cells))
       error ("substruct: for TYPE == () or {}, SUBS must be a cell array");
-    elseif (any (dots & !chars))
+    elseif (any (dots & ! chars))
       error ("substruct: for TYPE == ., SUBS must be a character string");
     endif
   else
     error ('substruct: TYPE must be one of "()", "{}", or "."');
   endif
 
   retval = struct ("type", typ, "subs", sub);
 
diff --git a/scripts/pkg/private/configure_make.m b/scripts/pkg/private/configure_make.m
--- a/scripts/pkg/private/configure_make.m
+++ b/scripts/pkg/private/configure_make.m
@@ -136,17 +136,17 @@ function configure_make (desc, packdir, 
 
     ## Split into architecture dependent and independent files.
     if (isempty (filenames))
       idx = [];
     else
       idx = cellfun ("is_architecture_dependent", filenames);
     endif
     archdependent = filenames(idx);
-    archindependent = filenames(!idx);
+    archindependent = filenames(! idx);
 
     ## Copy the files.
     if (! all (isspace ([filenames{:}])))
         if (! exist (instdir, "dir"))
           mkdir (instdir);
         endif
         if (! all (isspace ([archindependent{:}])))
           if (verbose)
diff --git a/scripts/plot/appearance/whitebg.m b/scripts/plot/appearance/whitebg.m
--- a/scripts/plot/appearance/whitebg.m
+++ b/scripts/plot/appearance/whitebg.m
@@ -70,17 +70,17 @@ function whitebg (varargin)
 
   axes = findall (fig, "type", "axes");
   if (isnan (color))
     ## Root figure. Set the default axes and figure properties so that
     ## subsequent plots have the new color scheme
     if (isroot)
       fac = get (0, "factory");
       fields = fieldnames (fac);
-      fieldindex = intersect (find (! cellfun ("isempty", regexp (fields, 'color'))), union (find (! cellfun ("isempty", regexp (fields, 'factoryaxes.*'))), find (!cellfun ("isempty", regexp (fields, 'factoryfigure.*')))));
+      fieldindex = intersect (find (! cellfun ("isempty", regexp (fields, 'color'))), union (find (! cellfun ("isempty", regexp (fields, 'factoryaxes.*'))), find (! cellfun ("isempty", regexp (fields, 'factoryfigure.*')))));
 
       ## Check whether the factory value has been replaced
       for nf = 1 : numel (fieldindex);
         defaultfield = strrep (fields{fieldindex(nf)}, "factory", "default");
         try
           defaultvalue = 1 - get (0, defaultfield{n});
         catch
           field = fields{fieldindex(nf)};
@@ -100,17 +100,17 @@ function whitebg (varargin)
       endfor
       handles = children;
       h = union (h, children);
     endwhile
 
     for nh = 1 : numel (h)
       p = get (h (nh));
       fields = fieldnames (p);
-      fieldindex = find (!cellfun ("isempty", regexp (fields, 'color')));
+      fieldindex = find (! cellfun ("isempty", regexp (fields, 'color')));
       if (numel (fieldindex))
         for nf = 1 : numel (fieldindex);
           field = fields{fieldindex(nf)};
           c = subsref (p, struct ("type", ".", "subs", field));
           if (! ischar (c) && columns (c) == 3)
             set (h (nh), field, 1 - c);
           endif
         endfor
diff --git a/scripts/plot/draw/private/__marching_cube__.m b/scripts/plot/draw/private/__marching_cube__.m
--- a/scripts/plot/draw/private/__marching_cube__.m
+++ b/scripts/plot/draw/private/__marching_cube__.m
@@ -219,17 +219,17 @@ function p = vertex_interp (isolevel,p1x
   mu = zeros (length (p1x), 1);
   id = abs (valp1-valp2) < (10*eps) .* (abs (valp1) .+ abs (valp2));
   if (any (id))
     p(id, 1:3) = [ p1x(id), p1y(id), p1z(id) ];
     if (nargin == 11)
       p(id, 4) = col1(id);
     endif
   endif
-  nid = !id;
+  nid = ! id;
   if (any (nid))
     mu(nid) = (isolevel - valp1(nid)) ./ (valp2(nid) - valp1(nid));
     p(nid, 1:3) = [p1x(nid) + mu(nid) .* (p2x(nid) - p1x(nid)), ...
       p1y(nid) + mu(nid) .* (p2y(nid) - p1y(nid)), ...
       p1z(nid) + mu(nid) .* (p2z(nid) - p1z(nid))];
     if (nargin == 11)
       p(nid, 4) = col1(nid) + mu(nid) .* (col2(nid) - col1(nid));
     endif
diff --git a/scripts/plot/util/struct2hdl.m b/scripts/plot/util/struct2hdl.m
--- a/scripts/plot/util/struct2hdl.m
+++ b/scripts/plot/util/struct2hdl.m
@@ -96,17 +96,17 @@ function [h, pout] = struct2hdl (s, p=[]
     p = p(1:2, 1:(tst(end)-1));
   endif
 
   ## Place the "*mode" properties at the end to avoid having the updaters
   ## change the mode to "manual" when the value is "auto".
   names = fieldnames (s.properties);
   n = strncmp (cellfun (@fliplr, names, "uniformoutput", false), "edom", 4);
   n = (n | strcmp (names, "activepositionproperty"));
-  names = [names(!n); names(n)];
+  names = [names(! n); names(n)];
   if (strcmp (s.type, "axes"))
     n_pos = find (strcmp (names, "position") | strcmp (names, "outerposition"));
     if (strcmp (s.properties.activepositionproperty, "position"))
       names{n_pos(1)} = "outerposition";
       names{n_pos(2)} = "position";
     else
       names{n_pos(1)} = "position";
       names{n_pos(2)} = "outerposition";
diff --git a/scripts/polynomial/polyfit.m b/scripts/polynomial/polyfit.m
--- a/scripts/polynomial/polyfit.m
+++ b/scripts/polynomial/polyfit.m
@@ -141,17 +141,17 @@ function [p, s, mu] = polyfit (x, y, n)
     try
       C = cholinv (r.'*r)(k, k);
     catch
       C = NaN (m+1, m+1);
     end_try_catch
 
     if (n != m)
       ## fill matrices if required
-      s.X(:, !polymask) = 0;
+      s.X(:, ! polymask) = 0;
       s.R = zeros (n+1, n+1); s.R(polymask, polymask) = r;
       s.C = zeros (n+1, n+1); s.C(polymask, polymask) = C;
     else
       s.R = r;
       s.C = C;
     endif
     s.df = l - m - 1;
     s.normr = norm (yf - y);
diff --git a/scripts/polynomial/spline.m b/scripts/polynomial/spline.m
--- a/scripts/polynomial/spline.m
+++ b/scripts/polynomial/spline.m
@@ -94,17 +94,17 @@ function ret = spline (x, y, xi)
       szy = szy([2 1]);
     endif
   else
     a = shiftdim (reshape (y, [prod(szy(1:end-1)), szy(end)]), 1);
   endif
 
   for k = (1:columns (a))(any (isnan (a)))
     ok = ! isnan (a(:,k));
-    a(!ok,k) = spline (x(ok), a(ok,k), x(!ok));
+    a(! ok,k) = spline (x(ok), a(ok,k), x(! ok));
   endfor
 
   complete = false;
   if (rows (a) == n + 2)
     complete = true;
     dfs = a(1,:);
     dfe = a(end,:);
     a = a(2:end-1,:);
@@ -262,17 +262,17 @@ endfunction
 %!assert (imag (spline (x.',y,x)), imag (y), abserr)
 %!test
 %! xnan = 5;
 %! y(x==xnan) = NaN;
 %! ok = ! isnan (y);
 %! assert (spline (x, y, x(ok)), y(ok), abserr);
 %!test
 %! ok = ! isnan (y);
-%! assert (! isnan (spline (x, y, x(!ok))));
+%! assert (! isnan (spline (x, y, x(! ok))));
 %!test
 %! x = [1,2];
 %! y = [1,4];
 %! assert (spline (x,y,x), [1,4], abserr);
 %!test
 %! x = [2,1];
 %! y = [1,4];
 %! assert (spline (x,y,x), [1,4], abserr);
diff --git a/scripts/set/unique.m b/scripts/set/unique.m
--- a/scripts/set/unique.m
+++ b/scripts/set/unique.m
@@ -141,19 +141,19 @@ function [y, i, j] = unique (x, varargin
       match = (y(1:n-1) == y(2:n));
     endif
     y(match) = [];
   endif
 
   if (isargout (3))
     j = i;
     if (dim == 1)
-      j(i) = cumsum ([1; !match]);
+      j(i) = cumsum ([1; ! match]);
     else
-      j(i) = cumsum ([1, !match]);
+      j(i) = cumsum ([1, ! match]);
     endif
   endif
 
   if (isargout (2))
     idx = find (match);
     if (optfirst)
       idx += 1;   # in-place is faster than other forms of increment
     endif
diff --git a/scripts/sparse/svds.m b/scripts/sparse/svds.m
--- a/scripts/sparse/svds.m
+++ b/scripts/sparse/svds.m
@@ -262,34 +262,34 @@ endfunction
 %! rand_state = rand ("state");
 %! rand ("state", 42);
 %! opts.v0 = rand (2*n,1); % Initialize eigs ARPACK starting vector
 %!                         % to guarantee reproducible results
 %!
 %!testif HAVE_ARPACK
 %! [u2,s2,v2,flag] = svds (A,k);
 %! s2 = diag (s2);
-%! assert (flag, !1);
+%! assert (flag, ! 1);
 %! tol = 10 * eps() * norm(s2, 1);
 %! assert (s2, s(end:-1:end-k+1), tol);
 %!
 %!testif HAVE_ARPACK, HAVE_UMFPACK
 %! [u2,s2,v2,flag] = svds (A,k,0,opts);
 %! s2 = diag (s2);
-%! assert (flag, !1);
+%! assert (flag, ! 1);
 %! tol = 10 * eps() * norm(s2, 1);
 %! assert (s2, s(k:-1:1), tol);
 %!
 %!testif HAVE_ARPACK, HAVE_UMFPACK
 %! idx = floor (n/2);
 %! % Don't put sigma right on a singular value or there are convergence issues
 %! sigma = 0.99*s(idx) + 0.01*s(idx+1);
 %! [u2,s2,v2,flag] = svds (A,k,sigma,opts);
 %! s2 = diag (s2);
-%! assert (flag, !1);
+%! assert (flag, ! 1);
 %! tol = 10 * eps() * norm(s2, 1);
 %! assert (s2, s((idx+floor(k/2)):-1:(idx-floor(k/2))), tol);
 %!
 %!testif HAVE_ARPACK
 %! [u2,s2,v2,flag] = svds (zeros (10), k);
 %! assert (u2, eye (10, k));
 %! assert (s2, zeros (k));
 %! assert (v2, eye (10, 7));
diff --git a/scripts/specfun/ellipke.m b/scripts/specfun/ellipke.m
--- a/scripts/specfun/ellipke.m
+++ b/scripts/specfun/ellipke.m
@@ -115,19 +115,19 @@ function [k, e] = ellipke (m, tol = [])
 
   idx_neginf = (m == -Inf);
   k(idx_neginf) = 0;
   e(idx_neginf) = Inf;
 
   ## Arithmetic-Geometric Mean (AGM) algorithm
   ## ( Abramowitz and Stegun, Section 17.6 )
   Nmax = 16;
-  idx = !idx_1 & !idx_neginf;
+  idx = ! idx_1 & ! idx_neginf;
   if (any (idx))
-    idx_neg = find (m < 0 & !idx_neginf);
+    idx_neg = find (m < 0 & ! idx_neginf);
     mult_k = 1./sqrt (1 - m(idx_neg));
     mult_e = sqrt (1 - m(idx_neg));
     m(idx_neg) = -m(idx_neg) ./ (1 - m(idx_neg));
     b = sqrt (1 - m(idx));
     a = ones (size (b));
     c = sqrt (m(idx));
     f = 0.5;
     sum = f*c.^2;
diff --git a/scripts/statistics/distributions/binoinv.m b/scripts/statistics/distributions/binoinv.m
--- a/scripts/statistics/distributions/binoinv.m
+++ b/scripts/statistics/distributions/binoinv.m
@@ -146,17 +146,17 @@ function m = bin_search_binoinv (x, n, p
   end
   upper = max (2*lower, 1);
   k = find (lower != limit/2);       # elements for which above loop finished
   for i = 1:ceil (log2 (max (lower)))
     mid = (upper + lower)/2;
     cdf = binocdf (floor(mid(:)), n, p);
     r = (x <= cdf);
     upper(r)  = mid(r);
-    lower(!r) = mid(!r);
+    lower(! r) = mid(! r);
   endfor
   m = ceil (lower);
   m(x > binocdf (m(:), n, p)) += 1;  # fix off-by-one errors from binary search
 endfunction
 
 
 %!shared x
 %! x = [-1 0 0.5 1 2];
diff --git a/scripts/statistics/distributions/hygepdf.m b/scripts/statistics/distributions/hygepdf.m
--- a/scripts/statistics/distributions/hygepdf.m
+++ b/scripts/statistics/distributions/hygepdf.m
@@ -60,17 +60,17 @@ function pdf = hygepdf (x, t, m, n)
   ## everything in nel gives NaN
   nel = (isnan (x) | (t < 0) | (m < 0) | (n <= 0) | (m > t) | (n > t) |
         (t != fix (t)) | (m != fix (m)) | (n != fix (n)));
   ## everything in zel gives 0 unless in nel
   zel = ((x != fix (x)) | (x < 0) | (x > m) | (n < x) | (n-x > t-m));
 
   pdf(nel) = NaN;
 
-  k = !nel & !zel;
+  k = ! nel & ! zel;
   if (any (k(:)))
     if (isscalar (t) && isscalar (m) && isscalar (n))
       pdf(k) = (bincoeff (m, x(k)) .* bincoeff (t-m, n-x(k))
                 / bincoeff (t, n));
     else
       pdf(k) = (bincoeff (m(k), x(k)) .* bincoeff (t(k)-m(k), n(k)-x(k))
                 ./ bincoeff (t(k), n(k)));
     endif
diff --git a/scripts/statistics/distributions/nbininv.m b/scripts/statistics/distributions/nbininv.m
--- a/scripts/statistics/distributions/nbininv.m
+++ b/scripts/statistics/distributions/nbininv.m
@@ -118,17 +118,17 @@ function m = bin_search_nbininv (x, n, p
   end
   upper = max (2*lower, 1);
   k = find (lower != limit/2);    # elements for which above loop finished
   for i = 1:ceil (log2 (max (lower)))
     mid = (upper + lower)/2;
     cdf = nbincdf (floor (mid), n, p);
     r = (x <= cdf);
     upper(r)  = mid(r);
-    lower(!r) = mid(!r);
+    lower(! r) = mid(! r);
   endfor
   m = ceil (lower);
   m(x > nbincdf (m, n, p)) += 1;  # fix off-by-one errors from binary search
 
 endfunction
 
 
 %!shared x
diff --git a/scripts/statistics/distributions/poissinv.m b/scripts/statistics/distributions/poissinv.m
--- a/scripts/statistics/distributions/poissinv.m
+++ b/scripts/statistics/distributions/poissinv.m
@@ -161,17 +161,17 @@ function inv = analytic_approx (x, lambd
     y  =    -0.0155377333 + y.*rm;
     y  =     0.0174065334 + y.*rm;
     y  =    -0.0198011178 + y.*rm;
     y ./= lam;
 
     inv(k) = floor (lam + (y+t)+lam.*rm);
   endif
 
-  k = !k & (s > -sqrt (2));
+  k = ! k & (s > -sqrt (2));
   if (any (k))
     ## Newton iteration
     r = 1 + s(k);
     r2 = r + 1;
     while (any (abs (r - r2) > 1e-5))
       t = log (r);
       r2 = r;
       s2 = sqrt (2 * ((1-r) + r.*t));
diff --git a/scripts/statistics/distributions/tcdf.m b/scripts/statistics/distributions/tcdf.m
--- a/scripts/statistics/distributions/tcdf.m
+++ b/scripts/statistics/distributions/tcdf.m
@@ -60,17 +60,17 @@ function cdf = tcdf (x, n)
   kk = k & x_big_abs;
   if (isscalar (n))
     cdf(kk) = betainc (n ./ (n + xx(kk)), n/2, 1/2) / 2;
   else
     cdf(kk) = betainc (n(kk) ./ (n(kk) + xx(kk)), n(kk)/2, 1/2) / 2;
   endif
 
   ## deal with the case "abs(x) small"
-  kk = k & !x_big_abs;
+  kk = k & ! x_big_abs;
   if (isscalar (n))
     cdf(kk) = 0.5 * (1 - betainc (xx(kk) ./ (n + xx(kk)), 1/2, n/2));
   else
     cdf(kk) = 0.5 * (1 - betainc (xx(kk) ./ (n(kk) + xx(kk)), 1/2, n(kk)/2));
   endif
 
   k &= (x > 0);
   if (any (k(:)))
diff --git a/scripts/statistics/distributions/unidcdf.m b/scripts/statistics/distributions/unidcdf.m
--- a/scripts/statistics/distributions/unidcdf.m
+++ b/scripts/statistics/distributions/unidcdf.m
@@ -47,20 +47,20 @@ function cdf = unidcdf (x, n)
     cdf = zeros (size (x));
   endif
 
   knan = isnan (x) | ! (n > 0 & n == fix (n));
   if (any (knan(:)))
     cdf(knan) = NaN;
   endif
 
-  k = (x >= n) & !knan;
+  k = (x >= n) & ! knan;
   cdf(k) = 1;
 
-  k = (x >= 1) & (x < n) & !knan;
+  k = (x >= 1) & (x < n) & ! knan;
   if (isscalar (n))
     cdf(k) = floor (x(k)) / n;
   else
     cdf(k) = floor (x(k)) ./ n(k);
   endif
 
 endfunction
 
diff --git a/scripts/statistics/distributions/unidpdf.m b/scripts/statistics/distributions/unidpdf.m
--- a/scripts/statistics/distributions/unidpdf.m
+++ b/scripts/statistics/distributions/unidpdf.m
@@ -49,17 +49,17 @@ function pdf = unidpdf (x, n)
     pdf = zeros (size (x), "single");
   else
     pdf = zeros (size (x));
   endif
 
   k = isnan (x) | ! (n > 0 & n == fix (n));
   pdf(k) = NaN;
 
-  k = !k & (x >= 1) & (x <= n) & (x == fix (x));
+  k = ! k & (x >= 1) & (x <= n) & (x == fix (x));
   if (isscalar (n))
     pdf(k) = 1 / n;
   else
     pdf(k) = 1 ./ n(k);
   endif
 
 endfunction
 
diff --git a/scripts/strings/dec2base.m b/scripts/strings/dec2base.m
--- a/scripts/strings/dec2base.m
+++ b/scripts/strings/dec2base.m
@@ -151,17 +151,17 @@ endfunction
 %!assert (dec2base (2^51-1, 2), ...
 %!        "111111111111111111111111111111111111111111111111111")
 %!assert (dec2base (uint64 (2)^63-1, 16), "7FFFFFFFFFFFFFFF")
 %!assert (dec2base ([1, 2; 3, 4], 2, 3), ["001"; "011"; "010"; "100"])
 %!assert (dec2base ({1, 2; 3, 4}, 2, 3), ["001"; "011"; "010"; "100"])
 
 %!test
 %! a = 0:3;
-%! assert (dec2base (!a, 2, 1), ["1"; "0"; "0"; "0"])
+%! assert (dec2base (! a, 2, 1), ["1"; "0"; "0"; "0"])
 
 ## Test input validation
 %!error dec2base ()
 %!error dec2base (1)
 %!error dec2base (1, 2, 3, 4)
 %!error dec2base ("A")
 %!error dec2base (2i)
 %!error dec2base (-1)
diff --git a/scripts/testfun/assert.m b/scripts/testfun/assert.m
--- a/scripts/testfun/assert.m
+++ b/scripts/testfun/assert.m
@@ -266,34 +266,34 @@ function assert (cond, varargin)
               strtrim (cellstr (num2str (B(erridx) (:))));
             err.reason(end+1:end+length (erridx)) = ...
               repmat ({"'NA' mismatch"}, length (erridx), 1);
           endif
           errseen = errvec;
 
           errvec = (  isnan (real (A)) != isnan (real (B))
                     | isnan (imag (A)) != isnan (imag (B)));
-          erridx = find (errvec & !errseen);
+          erridx = find (errvec & ! errseen);
           if (! isempty (erridx))
             err.index(end+1:end+length (erridx)) = ...
               ind2tuple (size (A), erridx);
             err.observed(end+1:end+length (erridx)) = ...
               strtrim (cellstr (num2str (A(erridx) (:))));
             err.expected(end+1:end+length (erridx)) = ...
               strtrim (cellstr (num2str (B(erridx) (:))));
             err.reason(end+1:end+length (erridx)) = ...
               repmat ({"'NaN' mismatch"}, length (erridx), 1);
           endif
           errseen |= errvec;
 
           errvec =   ((isinf (real (A)) | isinf (real (B))) ...
                       & (real (A) != real (B)))             ...
                    | ((isinf (imag (A)) | isinf (imag (B))) ...
                       & (imag (A) != imag (B)));
-          erridx = find (errvec & !errseen);
+          erridx = find (errvec & ! errseen);
           if (! isempty (erridx))
             err.index(end+1:end+length (erridx)) = ...
               ind2tuple (size (A), erridx);
             err.observed(end+1:end+length (erridx)) = ...
               strtrim (cellstr (num2str (A(erridx) (:))));
             err.expected(end+1:end+length (erridx)) = ...
               strtrim (cellstr (num2str (B(erridx) (:))));
             err.reason(end+1:end+length (erridx)) = ...
diff --git a/scripts/time/weekday.m b/scripts/time/weekday.m
--- a/scripts/time/weekday.m
+++ b/scripts/time/weekday.m
@@ -62,17 +62,17 @@ function [d, s] = weekday (d, format = "
   endif
   if (ischar (d) || iscellstr (d))
     ## Make sure the date is numeric
     d = datenum (d);
   endif
   ## Find the offset from a known Sunday (2008-Jan-6), mod 7.
   d = floor (reshape (mod (d - 733048, 7), endsize));
   ## Make Saturdays a 7 and not a 0.
-  d(!d) = 7;
+  d(! d) = 7;
 
   if (isargout (2))
     if (strcmpi (format, "long"))
       names = {"Sunday" "Monday" "Tuesday" "Wednesday" "Thursday" ...
                "Friday" "Saturday"};
     else
       names = {"Sun" "Mon" "Tue" "Wed" "Thu" "Fri" "Sat"};
     endif
diff --git a/src/mkoctfile.in.cc b/src/mkoctfile.in.cc
--- a/src/mkoctfile.in.cc
+++ b/src/mkoctfile.in.cc
@@ -400,19 +400,19 @@ main (int argc, char **argv)
   bool depend = false;
 
   if (argc == 1)
     {
       std::cout << usage_msg << std::endl;
       return 1;
     }
 
-  if (argc == 2 && (!strcmp (argv[1], "-v")
-                    || !strcmp (argv[1], "-version")
-                    || !strcmp (argv[1], "--version")))
+  if (argc == 2 && (! strcmp (argv[1], "-v")
+                    || ! strcmp (argv[1], "-version")
+                    || ! strcmp (argv[1], "--version")))
     {
       std::cout << version_msg << std::endl;
       return 0;
     }
 
   for (int i = 1; i < argc; i++)
     {
       std::string arg = argv[i];
@@ -556,28 +556,28 @@ main (int argc, char **argv)
           pass_on_options += (" " + arg);
         }
       else
         {
           std::cerr << "mkoctfile: unrecognized argument " << arg << std::endl;
           return 1;
         }
 
-      if (!file.empty () && octfile.empty ())
+      if (! file.empty () && octfile.empty ())
         octfile = file;
     }
 
   if (link_stand_alone)
     {
-      if (!outputfile.empty ())
+      if (! outputfile.empty ())
         output_option = "-o " + outputfile;
     }
   else
     {
-      if (!outputfile.empty ())
+      if (! outputfile.empty ())
         {
           octfile = outputfile;
           size_t len = octfile.length ();
           size_t len_ext = output_ext.length ();
           if (octfile.substr (len-len_ext) != output_ext)
             octfile += output_ext;
         }
       else
@@ -597,17 +597,17 @@ main (int argc, char **argv)
                             + vars["DEPEND_FLAGS"] + " "
                             + vars["CPPFLAGS"] + " "
                             + vars["ALL_CFLAGS"] + " "
                             + incflags  + " " + defs + " " + quote_path (f);
 
           FILE *fd = popen (cmd.c_str (), "r");
           std::ofstream fo (dfile.c_str ());
           size_t pos;
-          while (!feof (fd))
+          while (! feof (fd))
             {
               line = get_line (fd);
               if ((pos = line.rfind (".o:")) != std::string::npos)
                 {
                   size_t spos = line.rfind ('/', pos);
                   std::string ofile =
                     (spos == std::string::npos
                       ? line.substr (0, pos+2)
@@ -631,17 +631,17 @@ main (int argc, char **argv)
                             + vars["DEPEND_FLAGS"] + " "
                             + vars["CPPFLAGS"] + " "
                             + vars["ALL_CXXFLAGS"] + " "
                             + incflags  + " " + defs + " " + quote_path (f);
 
           FILE *fd = popen (cmd.c_str (), "r");
           std::ofstream fo (dfile.c_str ());
           size_t pos;
-          while (!feof (fd))
+          while (! feof (fd))
             {
               line = get_line (fd);
               if ((pos = line.rfind (".o:")) != std::string::npos)
                 {
                   size_t spos = line.rfind ('/', pos);
                   std::string ofile =
                     (spos == std::string::npos
                       ? line.substr (0, pos+2)
@@ -654,23 +654,23 @@ main (int argc, char **argv)
             }
           pclose (fd);
           fo.close ();
         }
 
       return 0;
     }
 
-  for (it = f77files.begin (); it != f77files.end () && !result; ++it)
+  for (it = f77files.begin (); it != f77files.end () && ! result; ++it)
     {
       std::string f = *it, b = basename (f, true);
-      if (!vars["F77"].empty ())
+      if (! vars["F77"].empty ())
         {
           std::string o;
-          if (!outputfile.empty ())
+          if (! outputfile.empty ())
             {
               if (link)
                 o = b + ".o";
               else
                 o = outputfile;
             }
           else
             o = b + ".o";
@@ -685,23 +685,23 @@ main (int argc, char **argv)
       else
         {
           std::cerr << "mkoctfile: no way to compile Fortran file " << f
                     << std::endl;
           return 1;
         }
     }
 
-  for (it = cfiles.begin (); it != cfiles.end () && !result; ++it)
+  for (it = cfiles.begin (); it != cfiles.end () && ! result; ++it)
     {
       std::string f = *it;
-      if (!vars["CC"].empty ())
+      if (! vars["CC"].empty ())
         {
           std::string b = basename (f, true), o;
-          if (!outputfile.empty ())
+          if (! outputfile.empty ())
             {
               if (link)
                 o = b + ".o";
               else
                 o = outputfile;
             }
           else
             o = b + ".o";
@@ -717,23 +717,23 @@ main (int argc, char **argv)
       else
         {
           std::cerr << "mkoctfile: no way to compile C file " << f
                     << std::endl;
           return 1;
         }
     }
 
-  for (it = ccfiles.begin (); it != ccfiles.end () && !result; ++it)
+  for (it = ccfiles.begin (); it != ccfiles.end () && ! result; ++it)
     {
       std::string f = *it;
-      if (!vars["CXX"].empty ())
+      if (! vars["CXX"].empty ())
         {
           std::string b = basename (f, true), o;
-          if (!outputfile.empty ())
+          if (! outputfile.empty ())
             {
               if (link)
                 o = b + ".o";
               else
                 o = outputfile;
             }
           else
             o = b + ".o";
@@ -750,21 +750,21 @@ main (int argc, char **argv)
       else
         {
           std::cerr << "mkoctfile: no way to compile C++ file " << f
                     << std::endl;
           return 1;
         }
     }
 
-  if (link && !objfiles.empty () && !result)
+  if (link && ! objfiles.empty () && ! result)
     {
       if (link_stand_alone)
         {
-          if (!vars["LD_CXX"].empty ())
+          if (! vars["LD_CXX"].empty ())
             {
               std::string cmd = vars["LD_CXX"] + " "
                                 + vars["CPPFLAGS"] + " "
                                 + vars["ALL_CXXFLAGS"] + " "
                                 + vars["RDYNAMIC_FLAG"] + " "
                                 + vars["ALL_LDFLAGS"] + " "
                                 + pass_on_options + " " + output_option + " "
                                 + objfiles + " " + libfiles + " "
